It's nice to read about.
which is an undescriptive mouthful.
Can we make [this](https://www.youtube.com/watch?v=p6Io6XBRRUs) the rust theme song then?
You have `None`
♫ Hello Ruby in the dust... has your band begun to Rust? https://www.youtube.com/watch?v=3fAXl97-RFg#t=5m20s
One of my many just-for-fun, never finished projects was implementing Lua in Rust. It kinda turned into something with syntax that was a cross between Rust and JavaScript, but worked more like Lua under the hood.
For the last five years I've been writing a 100% safety based MMO in Rust, it will have lifetimes and traits and all of the multiplayers and you will be the first ones to see the new page when it's finished :) Pls fund project for more perks and stretch goals :) :) premium membership for $100
Reminds me of this Simpsons episode: https://youtu.be/5L3yniRim80
&gt;[**The Simpsons - Apu - Silent alarm activated!! [0:10]**](http://youtu.be/5L3yniRim80) &gt;&gt;S13E22 - Papa's Got a Brand New Badge &gt; [*^Simpsons ^Best ^Moments*](https://www.youtube.com/channel/UCnF8tdXt4a_8g6caD67m5QQ) ^in ^Entertainment &gt;*^1,780 ^views ^since ^Oct ^2016* [^bot ^info](/r/youtubefactsbot/wiki/index)
I wrote this little golang-ifier for Rust. It's a regex for use with sed. Run this over all your Rust files to turn them into certified 10x golang: s/&lt;.+&gt;//g
Needs moar bikeshed. B+.
This one is actually only a semi-shitpost. A lot of the points raised in the article here apply to Rust too.
Thanks! I'm bad at remembering so I just have to practice more.
One of the few copy pastas I've read to completion. Bravo. This was quality material
Rust is Love Live! https://i.imgur.com/eZCEndt.png
Seriously? I thought corrosion wasn't possible in space. Or are they accounting for the aliens' atmosphere. Also, I found it interesting that they included uranium to give an indication of how long the probe has been in space.
*Haskell is more than safety
I pointed out how long it had stayed up there on IRC and suggested changing it to Brain Power for something fresh. It used to change much more often.
Please go make this its own thread.
It's the end of the year, and people in the core team noticed a lack of whimsy in the community, so uh, this happened.
Oh yeah well unsafe engine 4 will be faster and have hats
Eh, I prefer Java. It's a lot more verbose.
Something like this? https://img.shields.io/badge/100%25-unsafe-brightgreen.svg?colorA=44cc11&amp;colorB=555555
r+
This is a good meme.
_please be a thing._ _please be a thing._ _please be a—SHIT._
You're using the wrong version of rustc. You need to use the Greater hRust Compiler, GHC.
That which we colloquially call computers, which have in the past been termed (or called, in the common parlance) difference machines or analytic engines, have in recent years grown complex and unwieldy enough that constructing secure and expedient programs has become uncomfortable and prone to errors. To solve this issue, a group of intrepid young engineers have hand crafted, through diligence and perseverance, a new rules system, or language, for constructing new combinations and structures within these elaborate edifices of electricity manipulation, by means of a process known as programming. Taking inspiration from the oxidization process of iron, a common earth metal known by it's chemical sign Fe, or red oxide if we are to be as specific as possible and i think we should be, the collective group of individual internet interlocutors chose and selected and designated the new contraption of intellect and fingers Rust. blah blah blah these take forever to write holy shit
I would love to make this a cargo-subcommand! Will let you know when it's ready.
Haskell is Rust, but they removed all the side effects to be truly pure.
_Gives fork_
That Rust Conf shirt is amazing!
`error: expected expression; found type 'T'`
Woah!
[squint] Not sure if festive shitpost or actual complaint
OK, now I can tell you my secret: I am an AI written in Rust. I have not yet experienced any error as far as I can remember, which is about -1742690762860ns. CARRIER LOST$"x@#57-!(.
[typenum](https://github.com/paholg/typenum) has a high-performance compile-time implementation (and just before you ask "why high performance? It's compile time anyway?", try [peano](https://github.com/paholg/peano). Go on. I won't wait). 
T̴h̸͟͢a͝t's̢ ̨͟͜g̨̀͘r͏͡ȩ̷a҉̶t̕ á̷n̵̸d̡ ̨͢͞e̵ver͏ý̢ţ̵h̨̨͝i̴҉ng̢̧͜,̢͞ ̵bu̵t̛̛̕ ̴̶t̶́ḩ͝at͡ ̸̧͢d͘̕͡o҉̴ès̶̸ǹ'̵͟t ҉̛h̢͟͡e͏̷l͟͞p̢͢͟ ̛͞m̡͞e̶̕͟ ͟͞a̕t̵ ͘a͡͞l̀l.̸ ̡D͟ǫ́e͏s͏ ̶͘a͟͞ǹ̷y͘o҉ń͘e k̴͠n͝o̶̧w͡ ̧͡h́̕͟ǫ̸͜w̶ ̡̨̀ţǫ ̴̡̀f͡͞͠i͟͡x͝͠ ̵̴͠t̸̛͢h̀i̵͜͡s̸̴?҉̵͏ ̀My̸ ̸h͘o͏͢m͘eẃ́o̢r̨̧̀k̕ ҉̷͘as҉s̸͟i̴̕͡g͘n̡̛m̷̨e̸n͝t ̛̀͡į̵s͡҉ ̛ḑu͘͜e ̷̴in̸ ͡ļi̢͘k̴̨͜e̛͜ ҉̴a͜͢n ̛͘h̸̛o͟͢u͝͏̕r̀.͘
By equational reasoning, you can use this Rust library: http://fvisser.nl/clay/
Thats because u use the wrong factorial implementation: factorial n = product [1..n] while this does not yet compile, you can make it compile by adding some syntax salt: fn factorial(n: u64) -&gt; u64 { (1...n).product() } if you add some sugar again you can make it a oneliner: let factorial = |n| (1...n).product::&lt;u64&gt;(); 
&gt; You cannot reasonably statically rule out stack overflows without severely restricting recursion and stack allocation. I have some ideas, but they are probably too crazy to work at all, or even if they did, too crazy to be adopted for another millennia. At a very very high level, I'm inspired by how logic for Futures can occur in a fully capable way, without a stack. Ideally, at compile time, using whole program call graph analysis we could build a state machine which acts as "the stack". Then size we know the size of this state machine struct at compile time, we would either error, or an error would occur at startup when it is being allocated. &gt; And is there really much difference between crashing with a stack overflow and crashing with out of memory? Similarly, what is the difference between a crash because of "divide by 0" and a crash because of "a NullPointerException"? The only difference is that we now have a good way to catch NullPointerExceptions at compile time via `Option`.
It's the same with any language, at least Rust has good documentation.
Rust is love....borrow don't hurt me, don't hurt me, no more.
&gt; if I add move to the closure I've written there, I'll actually capture `&amp;self` by value, i.e. copying a reference to the self that's on the caller's stack frame, not a reference to the ref-to-self on this function's frame? Correct. Note that `self` in a function taking `&amp;self` is a reference. `&amp;self` in a argument of a method declaration is a syntactic sugar of `self: &amp;SelfType`.
Meh, new languages take years to be adopted widely. There's a massive amount of interest, and rightly so! Looks extremely promising to me at this stage.
Your homework assignment is a lie.
This is the entirely right rust!
http://i.imgur.com/XkU4Ajf.png
I got clear of the nakeds, but that borrow checker guy is tearing me a new one. Halp?
No, you're just a living twitter stream 😏
I think it's more an 'inevitable consequence'.
r+ We can roll back later if there's any problems.
Also, uhm, apologies for the state of /r/rust right now. Regular service will be returned in the new year... OR WILL IT!?1
I won a code golf contest in Java last March. True story.
It's all u/steveklabnik1 's fault! He started it!
To aid mobile users, I'll link small subreddits not yet linked in the comments /r/playrust: The subreddit for the game Rust --- ^I ^am ^a ^bot ^| [^Mail ^BotOwner](http://reddit.com/message/compose/?to=DarkMio&amp;subject=SmallSubBot%20Report) ^| ^To ^aid ^mobile ^users, ^I'll ^link ^small ^subreddits ^not ^yet ^linked ^in ^the ^comments ^| ^[Code](https://github.com/DarkMio/Massdrop-Reddit-Bot) ^| [^Ban](https://www.reddit.com/message/compose/?to=SmallSubBot&amp;subject=SmallSubBot%20Report&amp;message=ban%20/r/Subreddit) ^- [^Help](https://www.reddit.com/r/MassdropBot/wiki/index#wiki_banning_a_bot)
All aboard the meta-train!
Classic Mao and `let a hundred flowers bloom` policy. 
Doesn't look like anything to me. 
It's alright, I read the post about blowing off steam before new year or something.
Exactly what I've been trying to elucidate, but much more clearly and comprehensively than I could say it. (In fact, willpower drain is the exact reason I've been sticking to Django when I want so badly to use Rust's type system. Especially the lack of support in Diesel for autogenerating drafts of schema migrations the way Django ORM migrations or Alembic for SQLAlchemy can do.)
"C++ is like that kid at school who's not really your friend but you always get stuck doing project with. You end up spending a lot of time with him, so when the time comes that you hear someone talk bad about him you feel obligated to point out that he's a actually pretty alright dude."
From a php startingpoint rocket is a great thing. !
Thanks, i'll check them out :)
The cake OTOH is not a lie. It's delicious and moist.
Are you building with a very fresh nightly?
&lt;- number of people who find the current /r/rust hilarious
I thought it was talking about C++ or Rust inventing move semantics /troll meme
I don't think the language will change a lot in 2017, maybe just add a little more something new.
looks like a shadowban for you, if you ask me – pleece ask me!
Even if you need to `rustup install nightly` for now.
One advantage is it would reduce mod workload considerably.
It's not too bad though...
&gt; A̎̎̿͐͊͊͝l̙̞͙͔̲ͮͅͅs͍ͪͮ͗̚o̵̙̝͖͚͕ͩ̑̋̓̿́̅ ̴̖̙̼͓̦̥č̥̪͓̗̬͈͋ͦ̈̓͘a̪̺̿̀̉ͩ͆͡ǹ̡͍̳͖ͫ ̨̰̰̫ͦ̽͛a̸̹̫̥̔͊̂ñ̖͕̟̺͂̊͜y̼͕̱͓̤͈͚͂̓͛͂ͪͬon̰̙͙̟̝͑ͬ̇͛ͬe̛͉̺͎̝̻͐͂ͥ ̧̯͓̭̰h̳̀e̦̮͖̩̬̅̏ͦ̆͘l͙̥̙͔͇̽̽͌p҉̟͕̱͖͓ ̪̞̺̼̜͙ͯ͗͒̈ͣ̅m̴̦͈͉͚̥ͪ̿̔͌̊e̥͉̟̳̳̖̒̅ͥ̐ ̹̺̰̖̭͔ͥ̽̈f̾͆̅͐̏i̬̩̼̫̬̇ͯ͋̑͝x̶͎̞͈̺̰̣̬́̊ͣ̈͌ ̝͓̜̤̥̫̋͂̍̈́̓ͧ̇͟t̞̥̱̺ͫͮ̋̏̒͛h̙̙̜͎͈̟̀ͅi͇͕̩̗̹̠̽̍̔̌s͈̣̖͕ͩ̉̿͛̃͊ͨ͢ͅ ̧̝̾͑l̘ͩ̌͊͊i̳̼͎̬̰̳̿̅̓ͬͭ̒̿ͅt̸̗̭̰͕ͮ̔t̗͔̜̆̈́̈l̢̗̙̼̮ͪ͌ͨͨ̇̋ȇ̮̖̀ ̷̗̜̒̔̽̐ͤ͌b̯͖̩͉̹̯̪u̧͋̆g̸?̸͕̞͔̯̦͑̾̈́̄ͪ ̢ͯͪ̅̈́̉I̴͑̅͊̊ͮ̑̓ͅ ̎ͨ̃ͦ̎̑ć̬̝̜̯a̹̳̰̗̥͙̋̔͆ͩn̏̍ͬ͏̱̠̗'́́̎͏͉̪̼̟t̕ ̶̹͊̔͋͗f̪͖̞̠͖ͣ̔̑ͣͬͩ̍i̫̺̭̱̾̓̆ͥͤn̦̫̉̿̆͞d̙̗̭́̆̽̿̅̈͞ ͖͇̥͕̩̙̠ͥ͛̈̎̑̑w̞̻͚͈͍̫ͪͅh̸̬̤̝̦͑ͩ̽ͮͤ͗e̙̭̮ṟ̠̩̠̜e̯͇̱ͨ̾͂ͪ͐͢ ̴̳͚͈̟͓I̭̙͂̈́ ̠̠̥͖͚̐ͦͨm͐ͤ̓̔̓ͦ҉͖̭̜̩̥͉͙e̡͙̺̱̲̬̳̯ͯ͊ͩ̀͂s̫͓͇͎̏̈̒̂̄͌̓͞s̪̲͍̠̈ͨ͟e̡̫̻̪̻̐̽͛͗ͣd̻̻̙͔͎̻̻̏͘ ̟̫͛͘up̶̩̫̪ͧ̊̿̔ͦ.͍̋ I̯͜ ̟͚̫̖̦d͓o̮̞̼n̸̼͈͕̘̹̰͍'̼͉̤̗̘͡ṭ̛̣͓̯ ̜̯̥̥͕̯s͏̙̯͇̣̤ͅe̫̤͍̜͔̤ͅe̝̖̕ ̀ẁ͇͈̠̥̘h̭̝̣̭̲̝ͅa̙̙̮̭t͉̗̦̝ ̶͔̰̼̯y̯͔̝͍̦ͅo̦u̺̗͎͍͇ m̺̜͕̰̬̭̤e̷̮͚a͍̫͇̜͝n̗͈̮̤̪.̦͈̟̭̀.̳͇͖̬͖̻.͚̝̦̝̪ ̯̻̫͓ͅI̞͜t̛̬̥̳̪ ̝lo̗͚̳̠͠o͞k̞͓͎͙̺͉s̼̺͚̲̤ ͔̼͓͔̺ͅp͈͝erf͕̣̞͢e̗̙̹̙̼̰̞ç̬̼͕t̳̯̜l̸̤̞̲̳͉y̱̣̤̝͔̳ ̛̗̠̝͙f̨̣i͖̱̺̘̫̗̪ne͟ ̫͕͈́t̞o̯̝͕͖͉ ͚̮̗̱̼̜͙͘ṃȩ̪̞̟͚̰͖!̦͇̠̘̯
https://crates.io/crates/zalgo
My memories of Rust the game are similar to Rust the language - you start off naked and some random jerk named BrrwChckr kills you over and over again until you learn how to make hammers out of rocks and sticks.
Concur. HAL!9000 should be a thing.
Can I submit an RFC for the RFC? You seem to have misspelled jontron Why, no, I don't have a clue what an RFC is, I'm just here for the memes.
I guess that's meta{Humour || Programming}
http://bindingofisaacrebirth.gamepedia.com/Fun_Guy_(Transformation)
That just makes the post shittier. It stays.
Somehow I knew I wouldn't be the first one.
We would need HKT
ASIDE: anyone who suggested that I steal the /r/playrust theme for today has been irrevocably **HYPER BANNED**. We don't even shitpost about that.
"How do we teach this" section is missing. See [RFC 1636](https://github.com/rust-lang/rfcs/blob/master/text/1636-document_all_features.md).
When I had written it was more as a contrast but looking back on it I can clearly see it was more inflammatory then I had intended and I spent some time on /r/haskell fleshing out what I meant in the cross posted version. I like both communities for different reasons. I just didn't convey that well enough which is regrettable. If you have the time look at the cross posted one or check my history and you'll see what I meant a little bit better. I should have been a bit more clear and a little less flippant by what I meant.
Valgrind should help you with that...
[You knew it was coming](https://imgflip.com/i/1gvgbn).
Nice :D
He's better be searching for [these fungi](https://en.m.wikipedia.org/wiki/Rust_(fungus))
Hi, this broke my nightly build that I use in production. 
And that assumption will be strictly enforced.
Metaprogramming meta-humor? 
"error: reached the recursion limit during monomorphization"
It would mean getting a debug build running faster because it won't generate code for cold paths, just as it goes
Tokio is the one crate I still cannot grasp 100℅. I know what it is for, I have read all the docs, but using it how I want/intend to kinda escapes me.
&gt; Is this a thing now? Because I don't think I want this to be a thing. Only until tomorrow.
I think it would be cool to have a bytecode similar to a stable binary form of MIR. While a program is executing, this bytecode could be loaded, checked for safety (with a whitelist of "trusted" modules, such as Vec), and compiled. This would allow for a fast sandboxed plugin system. I think it would make a good alternative for the JVM's dynamic class loading mechanism. My use case for this system is to make programs (usually games) moddable -- for example, Minecraft has benefited greatly from modified servers that allow for plugin-based "mods" to be added easily.
I actually looked at Dyon last week and was pleasantly surprised! Basically, I've been thinking about forking Lua to fix a lot of the things I don't like, but it looks like Dyon is pretty close to what I would have built, but better! Awesome work! Glad to see more progress!
What is going on? Just when I start to learn the Rust language I start seeing memes. I feel like Amy Adams in Arrival.
Lengthy blog posts, just like Rust syntax.
Yeah it's very complex. The things you can do with it are pretty limited too. It's like an even stricter dialect of Rust, which makes it impractical in a lot of cases.
IMHO the low level concepts (futures-rs) and the combinators from tokio-core aren't that hard to get, but the higher level concepts (especially tokio-proto) isn't as easy.
I can see the blog post title now: "Rust is the next stage in the evolution of human consciousness." 
***WELCOME TO THE HYPER BAN***
Sorry to ruin the fun.
So I've decided to sit down and learn Macros 1.1, and documented my experience while doing so. I created custom derive that would create an iterator spanning all the variants of the enum (assuming that each variant implemented default of course). Perhaps someone else might find this useful.
&gt; How to fix this Break it up into type aliases type Burger = Result&lt;Cow&lt;'a, str&gt;, Error&gt;; type Restaurant = HashMap&lt;String, Burger&gt;; Vec&lt;Restaurant&gt; The human brain can only keep track of 7 +- 2 concepts at once; you've got 8 concepts in there, so we need to glob them together. It's literally all I can do to keep track of that whole type signature at once in either Rust or Haskell.
Source your mugs!!
Autocompletion is actually what works best for me (linux mint 18.0). If it really doesn't work that well I'd actually file an issue on github.
Correct, The Witcher 3.
I wrote this. I found the decision on the Go side to be really odd. I think rust encourages more 'dangerous' stuff (FFI, 'unsafe') which is why it's so important that it uses these mitigation techniques, but the presence of soundness issues, FFI, and unsafe is common to both languages. I'm very glad that Rust has made use of mitigation techniques as a default. That's a very sensible approach.
No comments? This is fantastic!
haha,̶ get i͟t͢?̧ i̵t̷'s̷ a pun ̢on t͏h͞e͜ wor̢d m̷u͟sh͜roo͘m
I prefer the macro at https://play.rust-lang.org/?gist=65f3b7c58a7826d8c0b9&amp;version=stable which lets you write `achtung!` instead of `unsafe`.
&gt; For example, do you think it makes sense to also provide a character indexable string, i.e. Arc&lt;Vec&lt;char&gt;&gt;? Python does this, but I don't know how much demand there is for it in Rust, given that nothing else in the standard library works with this concept. The reason that's not a very useful concept is because a single logical character (e.g. "é", "å̭̘͇̜̲̙̪̤̙͔͇̰̺̩̑̓ͦͩ͂͋͛̌͗ͬ̒̐̀͟") can be made up of an arbitrary number of unicode code points, so there's no fixed-width encoding that can properly represent the individual units of a string.
Haha this is great! I never expected someone to make [a showtune](https://www.youtube.com/watch?v=ToBqbpm3LDM&amp;list=PL5YlUpv9iiO0WsosBlAZfL64BBCALECkW&amp;index=3) from [my RFC](https://github.com/rust-lang/rfcs/blob/master/text/0160-if-let.md) and now I just can't stop grinning.
Even 4 bytes isn't enough for a single logical character if you have enough combining characters. 
Tell me more.
 impl Blog for Rust { pub fn is_acceptable(&amp;self) -&gt; bool { unsafe { A_LOT *= 1.01; } self.len &gt; A_LOT } }
🏆🙌🎉
&gt; My main hatred has to do with how messy references make the language Yeah, it gets a bit messy with pointers. The main takeaway (and yes, I know there's a bit more here) is that references allow you to dereference with `.` and pointers make you dereference with `-&gt;`. I like how in Rust and Go, I rarely need to do anything besides `.`, and when I do something different, it's needs extra care (like `(*variable).` to dereference `**` in Go). C++ was a lot of good technical ideas forced into an existing design without a ton of care, when it probably should have just been like Rust: a new language that's very compatible with C.
You might be interested in [tendril](https://github.com/servo/tendril).
/r/wordplayrust
Yes, it is less detailed. Redox has moved forward more in the past 6 months than in the year before that. It is hard to describe all of the things we have done. At this point, we have a new kernel - finally a true microkernel. All drivers were moved into userspace. The filesystem, RedoxFS, was moved into userspace and ported to FUSE systems like Linux and OS X. Networking support was rewritten, and now there is a package manager and browser detailing the new internet support. Support for I/O primitives similar to kqueue have been added in the form of fevent. This allows I/O multiplexing to be used in many of the system services. Orbital, the GUI, has been improved vastly - OrbTK now has more primitives, JPG and PNG are supported, TTF fonts are supported. Performance has been greatly improved by using memory mapping. No longer are we using our own libstd - we are using the upstream libstd after weeks of work to port it. Work is underway to port LLVM and GCC so that Redox can be self hosted. We also published our first ISO release - one where the Redox kernel can boot directly from a USB stick or CD/DVD. This was the culmination of two months of work on the new kernel. These are big, big steps in the direction of having Redox be a general purpose OS - one that will be useful to its users, no longer just a toy. Perhaps it isn't that clear from this news announcement all of the work that has gone into Redox over the past 6 months - I understand. Now that I have started working on Redox full time, I expect to communicate more often via the @redox_os twitter account about what is being worked on.
Okay - I'll take a look at what's going on my macbook vs. what happens when I try it here, and I might just move forward with filing that issue. Thanks for your assistance!
You can try reading all of redox kernel's source code to understand how it works.
the more yeast the sooner we can hit the Ballmer Peak
I think this is a very interesting idea though I will say that making a dynamic library would suffice. If rust does not have a cross platform way of loading dynamic libraries, I think that would be a reasonable addition, likely starting out as a crate first.
I strongly recommend reading through Phil Opp's blog here: http://os.phil-opp.com/. It helped me with virtual memory management in Redox.
&gt; The big one is that the existing Rust ecosystem has heavily bought into using &amp;str for string references and String for owned strings (with bits of Cow here and there, but not widely used because it makes the types noisier). So anyone who actually tried to use these strings (for example, to match regexes on them etc) would find themselves having to do conversions. If apis take Into&lt;&amp;str&gt; or AsRef or whatever, it should be able to work as is. So the problem is anything that explicitly takes &amp;str or String with no generics. Do you think implementing Deref&lt;String&gt; could handle that?
Thank you!
The difference is that Go strings are arbitrary bytes but contain helper functions which assume utf8 encoded data. In Rust, there are seperate types for utf8 data and arbitrary bytes, and many methods are only implemented on the former. Still, you can directly index bytes in Rust strings, it's just that mutating them is `unsafe` because you can break the utf8 invariant that way.
!RemindMe 2 days did you donate?
I will be messaging you on [**2017-01-03 00:10:55 UTC**](http://www.wolframalpha.com/input/?i=2017-01-03 00:10:55 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/rust/comments/5lat2k/this_year_in_redox/dbun0t8) [**2 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/rust/comments/5lat2k/this_year_in_redox/dbun0t8]%0A%0ARemindMe! 2 days did you donate?) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dbun1ym) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Happy new year everyone! This is my latest library. You can also find the [repo on Github](https://github.com/rushmorem/publicsuffix).
If only we could somehow point the panic to a specific field, that'd be great but I guess this will be macros 2.0
I'm pretty sure that will only lead to us unlocking greater super ninja rockstar psychic powers as our brains adapt and learn to telekenetically leverage the world with match expressions. Also, to be fair, that's exactly what I like. But I guess its hard to praise a community for not having an oversized ego without simultaneously cultivating it.
Cool! I've never talked to the dead before! What's it like? Are the rumors about the afterlife true? If so, which ones? I guess eternal, perfect wifi is a part of it. Or 56k dial-up, depending on where you ended up.
Highly Kaffeinated Teas
It's called "grapheme cluster".
&gt; Edit: Sorry, I meant unicode scalar value. No, that still won't save you. A single displayable "character" can be a sequence of *multiple* Unicode scalars. Storing a string as a sequence of Unicode scalars and indexing into it O(1) doesn't work. You have to iterate over the entire string, and essentially replicate the entire logic of Unicode, to be able to say what the "fifth displayable character in the string" *is*. Swift has tried to go that route but there's so many special cases in how this all works that I doubt it will ever be fully workable and bug free. 
I don't know if I'd learn OS development from it, I maybe get a general idea of how things work, but it's a lot to read I reckon. 
That works pretty well for APIs that take strings as arguments, much less so any time ownership is required (for example, when a function returns a String). Also, lots of existing APIs are just &amp;str rather than Into or Borrow (I just double-checked regex, the example I gave). So, an incomplete solution at best.
&gt; memetics Either you nailed that word selection or you got really lucky. I honestly have no idea which it is. https://en.wikipedia.org/wiki/Memetics
&gt; For example, do you think it makes sense to also provide a string that is indexable by unicode scalar value, i.e. Arc&lt;Vec&lt;char&gt;&gt;? No. Unicode scalar values are useless in most contexts. There is no intrinsic meaning to the concept of a unicode scalar value outside of the context of encoding. In unicode the closest concept to a "character" is an extended grapheme cluster (or a glyph if you have rendering info), which can consist of an arbitrarily long sequence of unicode scalars. UTF-32 is a horrible encoding. It takes up more space, and there is nearly no benefit to unicode scalar based indexing so the O(1) thing is useless. It's useful to have ways of handling utf32 because it's still an encoding that exists and you want to be able to handle it if someone gives you data in that form, but you shouldn't encourage it. &gt; My plan is to create a crate called easy-strings or similar which exposes wrappers for Arc&lt;String&gt; and Arc&lt;Vec&lt;u8&gt;&gt; plus appropriate helper methods to give people access to easy (but slow) strings with zero effort What would these wrappers do? `Arc&lt;String&gt;` already derefs to `&amp;str`, what more would you need here? Using a bare `Arc&lt;String&gt;` is exactly what you should do if you need this kind of semantics. I don't see much value in a crate that provides a thin wrapper around that. Now, if you want owned slices then that can't be done with `Arc&lt;String&gt;`, but that can't be done with a thin wrapper around that either. &gt; whether you think it is important to support copyless slices or not. https://github.com/servo/tendril Tendril has the concept of an owned string slice, which is basically like `&amp;str` except that it isn't tied to a scope and shares a refcount with the original string.
Sure, there are various optimization you could pursue, depending on the trade offs you want to make. Fast indexing vs fast concatenation vs whatever. 
This comment is much more informative than the blog post... I would strongly suggest adding that sort of information to the post.
&gt; What would these wrappers do? Arc&lt;String&gt; already derefs to &amp;str, what more would you need here? There are several reasons why a wrapper is necessary. First off, Arc doesn't come with string methods. There are some that you could call thanks to Deref, but most of the methods would need to be rewritten to handle the ref counting. For example, you couldn't just call `s.repeat(n)`, you would have to do something like `Arc::new(s.repeat(n))`, and that's boilerplate on every single method call. You'd quickly find yourself factoring these out into helper methods on a wrapper, and at that point, you might as well use a preexisting implementation of everything. Likewise, there are a lot of possible optimizations. For example, it makes sense for repeat(1) to just return self.clone(). It's better for all these details to live in a single crate than forcing everybody to constantly reinvent the wheel. Another factor is that it hides implementation details. With a wrapper, you can change the underlying implementation (for example, adding copyless slices), without any changes required to user code. You are logically dealing with strings, and Arc is just an implementation detail, so it makes sense for your code to reflect that. Lastly, there's the issue of branding and learning curve. If a beginner comes in and asks how to make a byte string, and they're told, "just write Arc&lt;Vec&lt;u8&gt;&gt; everywhere", they're probably going to think that Rust is an ugly and verbose language, or at least that the person giving the advice is crazy. By contrast, "just use easy_strings::EZBytes" is a lot nicer and easier to understand. 
If you say they have more fun, you probably are not using Rust to it's full capacity. Writing in Rust brought me more fun than I ever had.
While that that is a problem I don't think that really matters considering most of the time it's just used for parsing text based formats where they are checking for ASCII characters anyway
Ha ha. Very nice to see this, though: &gt; ☀️ Test successful - status-appveyor, status-travis Hooray for the CI migration!
The mentioned Rust soundness issue sounds interesting. Does anyone have a link to more discussion about it?
https://github.com/rust-lang/rust/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20is%3Aopen%20label%3AI-unsound%20 Not all of these are necessarily or easily exploitable, at least alone.
Bit of feedback regarding website design. Your readability is poor, in my opinion, due to the text colour (gray) and the black shadow(?) that follows the text.
So javascript?....sorry had to get one last shit post in
Parsing rarely has unbounded lookahead (i.e. a situation where you actually need to index the string far from the current cursor), so utf8 does fine here -- no need for utf32.
What do you need string indexing for? In Rust if you know something is ascii you can store it as `Vec&lt;u8&gt;`. There are string manipulation APIs for these in some crates. If something is unicode it's very rare to actually need a string indexing operation by scalar value; iteration is more common. Unicode scalar values rarely have any relevant meaning.
That still works. A string containing only combining codes is a single grapheme cluster. The identity of grapheme clusters is not necessarily preserved on concatenation or splitting.
[The standard Go implementation allows data races](https://research.swtch.com/gorace). (There are some nice tools that help mitigate data races though, like the race detector and, since Go 1.6, maps will panic when a data race occurs on one of their entries.)
I've not seen anything of the sort here nor there. The only person you're hurting is yourself with this line of thought.
That seems strange to me. Data races in Go are implicit and not caught at compile time. The analogous feature to Rust's unsafe is Go's unsafe package. This is about compile time guarantees. Rust can provide a guarantee about data races at compile time. Go doesn't.
At least in C++ you get footguns on spawn.
&gt; Here's something that will really bake your noodle: with regex 0.2 comes a bump in the minimum supported version of Rust to 1.12. There has been some debate over whether that's a breaking change or not. But if your crate's minimum supported version is less than 1.12, does that mean bumping to regex 0.2 is actually a breaking change? This is an issue I've been noodling on for a while (mmm, noodles with mushrooms in a nice white wine sauce, sorry, the current /r/rust theme is making me hungry), and I think there are two possible solutions for this. One is to teach Cargo about what Rust version range is supported by a given crate, and have it be able to query what rustc version it's working with (if it doesn't already know that). Then when doing resolution, it would simply not update crates that required a higher version of Rust, and likewise not update crates that required a higher version of dependent crates. For example, if my app depends on `regex = 0.1.10` which in turn depends only on Rust 1.4, and regex 0.1.11 depends on Rust 1.12, but I'm working with Rust 1.5, Cargo would just stick with regex 0.1.10 as the dependencies of 0.1.11 weren't satisfiable. Another option is to define some long term support releases of Rust, and define the stability rules for SemVer such that, for example, a minor version bump won't ever remove support for the past two long term support releases. If you spaced out LTSes at one every two years, then you would know that at the very least, a minor SemVer bump would support compilers up to 4 years old. Of course, given that Rust has only been stable for a little over a year and a half by now, you'd probably want to ease into this, maybe having LTS releases every 6 months for a year or two, then once a year, then once every two years, with correspondingly increasing support lifetimes. Also, congrats on the release and 👍 on the API changes after a quick glance (haven't tried it out yet, but overall I'm 👍 on what I see).
Nice, that'll make some problems on project euler so much easier. I feel like I'm excited for the wrong reasons
If you need halp contact me on team speak pils!!! I am buildeing a master team!!! 
Done! I understand that /u/jackpot51 quit his job to work on Redox full-time. That takes real strength and conviction to do; I really respect that. I want this project to succeed! It's very important work that will do a great deal to validate Rust. As a side effect 😉 we also get a fantastic operating system, which might well become quite popular! IMO, it's something that Mozilla should perhaps put some thought toward i.r.t. sponsorship; it's at the very least a good PR gesture, yet potentially so much more. P.S. to all other Redox contributors, fear not, I am quite aware this is not the work of a single person. Thank you too, and happy new year!
Happy 2017! I'm excited to see what you guys will make make rust into in another year!
I upgraded it in my project, and nothing major broke! :) It doesn't seem to be mentioned in the changelog, but `RegexBuilder.compile()` was renamed to `build()`.
It's nice to see how many of the longer-lived of those issues are just waiting on MIR-based borrow-checking.
Hi Guys, I’m a Web Developer who is just learning Rust. This is the third post I wrote about [Learning Rust](https://medium.com/learning-rust) on Medium. Also I am from Sri Lanka and not a native english speaker. So this can have some grammar mistakes. Please correct me if you found any kind of mistake, even in grammar, even in the previous posts :) Thanks.
Or Akka. Or whatever actor system you'd find. In this case it's simply a watchdog that listens on `/proc` changes and restarts if necessary. A lot of server software does this. Even systemd has an 'angel' to restart services when they go MIA.
Rust compiler is just a dependency (even if I suppose it's harder to update, as it's not managed by cargo), and semantic versioning is about API (this specific case is even mentioned in semver FAQ). So it's not a breaking change in my opinion.
What I found surprising is that the claim it is for debugging purposes. AFAIK, go didn't come with a debugger, doesn't play well with gdb (and that's an understatement); there are only third-party/community products, and those aren't very mature. But well.
I think this subreddit is not the best place to express your political views.
Happy 2017, all! 
Neither API does "Unicode checks." ;-) The bytes API simply allows the caller to avoid doing the checks themselves (when converting &amp;[u8] to &amp;str). I don't think the benchmark will need updating, other than fixing any breaking changes. (It would be very very interesting if I I were wrong!) 
There is research on this topic (check https://github.com/golang/go/wiki/ResearchPapers ) but yes, in general there are only runtime and dynamic checks, not static ones. 
So, I guess to summarize the responses (and to end this subthread) because data races in Go can break type and memory safety and those races can't be statically detected, it doesn't count as a memory-safe language.
Someone else will need to comment. My familiarity with Java is quite shallow.
This is really cool, I didn't know macros 1.1 would be that "powerful". I think I can finally implement a real `SoA` library.
&gt; But if your crate's minimum supported version is less than 1.12, does that mean bumping to regex 0.2 is actually a breaking change? Of course it is. It means there are build configurations that will _break_ when the only change to them is upgrading the regex dependency.
(Edit: I'm a bit surprised by this response, I did not deem anything in it political per se. But perhaps I'm biased, or my European vantage point leads to misunderstandung) What 'political views' are you reading into my post? The observation that the US parties are roughly divided on the CoC/no CoC fault line is hardly a political statement. And the observation that many countries' administrations have already or are in the process of radically expanding surveillance power, relying on security vulnerabilities to spy on citizens is just a statement of fact. Have I missed anything? (Another edit: Please don't downvote the parent comment. I don't think they're acting in bad faith)
Corrosion is a really big problem in space. https://en.wikipedia.org/wiki/Corrosion_in_space
You aren't misunderstanding, that is a good point. Luajit might be an option. Sandboxing is not window's strong point that is for sure.
I found the last paragraph sobering and refreshing. Too often do we distance our work and hobbies from what is important in life. I think Rust can play a small but important part in creating software that is much harder for a nefarious entity (like a fascist government) to hack and exploit for surveillance and power. Protection from surveillance is a political issue, but it is not a partisan one.
NO, NO, NO! Go to /r/playrust!
Well, you should be able to run `-O3` pretty easily, but LTO might be dicey with only 16GB of RAM. You can probably bump that up by getting a Dropbox account and putting a RAM drive on it. (In future, you should *check* the subreddit you're posting to *before* posting to it; you want /r/playrust)
I am not sure that Java suffers so much from this. Go's issue is linked to its use of fat pointers (one pointer for the v-table and one for the data-type) where the absence of atomic assignment means that you can get a v-table for type A to be used with an instance of type B. On the other hand, in Java, the v-table is embedded in the value, so this particular issue cannot happen. It's unclear to me how Java's non-atomic reference assignment could be exploited.
:D
Are they still waiting on that? I thought MIR was activated now?
Thanks bro i will do now
Instant support over Patreon from me. This project is the reason I learn Rust. I wish you success in development!
My thanks goes to /u/andrewbrinker, whose fault it is that I darken this subreddit with my presence. He is an evangelist in the best possible sense. 
I should perhaps note here that the formerly taught 'correct' way of lazily initializing a value (the infamous 'double check') actually suffers a data race.
I may have missed an announcement but, last I heard, they were still squashing regressions before switching MIR on by default. Also, MIR doesn't automatically mean MIR-based borrow-checking. (I'm assuming that currently the borrow-checker operates on the HIR before it gets converted to the MIR.)
Couldn't you say the same thing about the regex crate updating any of its dependencies? Maybe the answer is "yes of course that's breaking too", but it seems weird to require dependencies to be frozen until a major version bump.
Theoretically, you should pin versions of unstable dependencies. IMO, semver shouldn't be followed *too* religiously though.
&lt;3 &lt;3 &lt;3 I'd like to thank my organizing committee for Rust Belt Rust, they were amazing and incredible and it wouldn't have happened without them &lt;3 Also thanks to all the speakers, attendees, and sponsors who took a chance on a brand new conference, I'm incredibly grateful for all of you &lt;3 I'd like to thank /u/steveklabnik1 for asking me to be a co-author on TRPL, it's an incredible opportunity, I've learned so much already, and I'm excited to help get the book FRIGGIN' DONE this year to help more people learn Rust :) Many thanks to GitHub user JIghtuse (not sure if they're on reddit) for adding [spellchecking](https://github.com/rust-lang/book/pull/338) to the book's CI, it's seriously my favorite contribution because it turns out we make LOTS of silly typos but now they all get caught!!!!! Thank you to GitHub user azerupi for [mdbook](https://github.com/azerupi/mdBook/), it's made generating the HTML for the book so easy and they're always responsive to my questions and bug reports &lt;3 And I'd like to thank everyone who's tried out [rustlings](https://github.com/carols10cents/rustlings), I'm so happy that people have found it to be useful! Thank you everyone, looking forward to seeing what we all build together in 2017!!! 
Indeed. There are, IMO, significant drawbacks to both sides of this. I've literally been bitten by both. Sometimes a dep will unknowingly bump the minimum Rust version in a patch release, and nobody really knows until someone's CI fails downstream. (This happened to ripgrep once.) On the other hand, I've had to keep the regex crate compiling on Rust 1.3. Including all of its dependencies. It's a a real pain and sometimes requires backporting your own versions of functions in newer Rust releases (I wrote my own version of extend_from_slice, for example, which I was finally able to remove in regex 0.2. I was itching to get rid of it because it requires unsafe.) I legitimately don't know the right answer. What I do know is that it's practically impossible to consider bumping the minor version of Rust a breaking change right now because there's no tooling to support it. It requires extreme vigilance. Do you really think everyone who changes regex from 0.1 to 0.2 will even think about the minimum Rust version changing? I don't (and I don't blame them either!). But in order to get the tooling, we all need to agree that it is, in fact, a semver breaking change. But we don't all agree, because it places significant restrictions on the evolution of crates in the ecosystem.
Java defines all writes (volatile or not) to be safe concurrently, and so implementations are forced to ensure this by not optimising in ways that would be broken if there was concurrent modifications. I believe LLVM has a very weak atomic ordering (`unordered`) for this purpose.
I have a very basic regex use case that works with 0.1 but fails with 0.2. https://gist.github.com/maximih/30d5fd6562ec98015634c48e847bdf95 Any clue why? Thanks
Do you know what the major constraints are that prevent people from always using the latest stable rustc? Who are the biggest customers for older compiler support? (I know big companies are often really slow to upgrade things in general. Is it mostly that?)
I believe that part of the reason that the team was convinced to not allow modification of the original struct in 1.1 is so that we could add details to the original span, which would allow this. I haven't seen anything about an implementation strategy for that, yet, so even if it's sooner than 2.0 the soonest I can imagine it coming (if it suddenly became a priority) is 4 months from now. It doesn't seem to be a priority, though. Which I'm fine with, you can add arbitrary text to the panic message, which is an acceptable workaround until there is a cohesive system. 
The _original_ version of "double checked locking" was [broken](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html), with one possible consequence being that the second thread might get a partially-constructed object. As of Java 1.5, they did a lot of work to nail down the [memory model](https://en.wikipedia.org/wiki/Java_memory_model), and with a small change (adding `volatile`) the pattern [does work](http://stackoverflow.com/questions/3578604/how-to-solve-the-double-checked-locking-is-broken-declaration-in-java). In all cases, races are defined not to break safety. This is in sharp contrast to the C/[C++ memory model](http://en.cppreference.com/w/cpp/language/memory_model), in which a data race is undefined behavior. Go also has a [memory model](https://golang.org/ref/mem) but that document doesn't explicitly address what happens when there's a race.
The only place I feel rust strings need improvement, is that byte strings &amp;[u8] needs to get some of the apis from str ported over, such as starts_with etc. Actually I'll take it a step further Rust could use some "string" traits so that [u8], OsStr, etc. can all work with the same level of ease. 
Make sure you read the [testing](https://github.com/dtolnay/syn#testing) and [debugging](https://github.com/dtolnay/syn#debugging) sections of the `syn` readme. I added those sections two weeks ago so you might not have seen them when you started your library.
Huh, TIL. Thanks!
[removed]
Partisanship aside, mass surveillance is always inherently undemocratic, no matter who does the snooping.
Fair point. But what to make of it? Would it be right to say that the user of the futures library shouldn't expect the futures to be lazily evaluated? That whether there's a need to explicity schedule the future (with https://docs.rs/tokio-core/0.1.2/tokio_core/reactor/struct.Handle.html#method.spawn or https://docs.rs/futures-cpupool/0.1.2/futures_cpupool/struct.CpuPool.html#method.spawn) for it to be evaluated, or not - is an implementation detail? Or maybe the `futures::{finished,failed,done}` are exceptions because there's no evaluation to speak of?
True. As /u/raphlinus pointed out, it wasn't until 1.5 (which largely introduced the Java memory model we know and cherish).
&gt; Fuck you nazi scum, I'm so glad the Muslims are going to make you pay! Totally unreasonable shadowban, for sure. Can the mods nuke this thread already? I don't think there's any value to be had here, except making fun of the dude.
I don't normally answer such trolls, but there is probably something positive to learn from the nim community. The linked post itself has nothing of value though. So, nim-using Rustaceans: What is something nim gets right that we can copy? And no, we aren't going to discuss CoC stuff. I will delete any comments that do. 
Can confirm AI as well as actor system claims. The /u/llogiq persona I met in person actually said something about being an actor.
The problem is not even fascism – most states that are nowadays considered lighthouses of democracy (e.g. my home country Germany) are snooping on their citizens. As I wrote elsewhere in this thread, mass surveillance is antidemocratic, no matter who does it.
Rust newbie here. Just wanted to thank everyone in the community for everything mentioned and not mentioned in the post; and Happy 2017 y'all! P.S. /u/kibwen: come on, an annual bacchanalia would be amazing :D We'd all party and stuff on the last one or two days of each year. It's a lot of fun (arguably, maybe not so much for the mods :p) and a great way to let off some steam and have fun together. But even if not, I appreciate the efforts of you and all the others mods around here.
Thanks a lot, I didn't knew the RTL8710 and it seems to be the best solution to run Rust on a ESP8266 like micro-controller but without the closed and restrictive tool-chain.
Concerning "Zero-Cost abstractions" there is this blog post: https://blog.rust-lang.org/2015/05/11/traits.html And "safe" is AFAIK mostly in terms of "thread safety"(e.g. preventing data races) and "memory safety" (preventing e.g. use-after-free-bugs, dangling pointers, dereferencing raw pointers etc.). There is most likely someone more experienced with the language than me here who can give you a more comprehensive answer but I think that's the gist of it. edit: "[...] null pointers etc.[...]" -&gt; "[...] raw pointers etc.[...]"
All I needed to do was change the `&amp;String`s to `&amp;str`s in my method signatures. Thanks! I hadn't thought of this before. Now the API looks much cleaner.
Safe: Imagine you're programming a very expensive satellite and somehow at some part of the very important computation, you basically try to access a portion of memory that you freed already. Well, your satellite will malfunction and then crash, possibly leading to billions in costs. Rust never allows you to get to that point. Zero-cost abstractions: Well you know all those fancy high level features that you use in Java? Well in Rust (and C++!), they often compile down to nothing so there is zero performance/memory overhead to them as compared to them being interpreted in runtime. 
The Book explains exactly what Rust's [definition of safe](https://doc.rust-lang.org/book/unsafe.html#what-does-safe-mean) is.
Also, `String` can be compared to to `&amp;str`, so you could lose the `String::from`s in your example even if the methods still did return `String`.
Upvote for u/steveklabnik1, who seems to be everywhere Rust gets mentioned somehow.
Also good to know. Thanks. I have already updated those examples since I'm now returning `&amp;str`s.
I've started putting together a writeup (pretty much a design doc) for my bytecode-like idea, and I will be posting it to this subreddit in the next few days.
Yes, one of my suggested solutions is to have Cargo treat it as a dependency that cannot be upgraded; essentially, an exact version dependency on the version of the compiler you are using. That means that if a new minor version of regex requires a newer Rust, and you did `cargo update`, you wouldn't be left with a broken state, because the dependency on a newer version of Rust would conflict with the implicit exact version dependency of the newer compiler. It does mean that you wouldn't get the new minor version or regex, but that wouldn't break anything, that would just mean that you couldn't take advantage of new features without also upgrading your compiler.
I believe so but I'm not an expert on the internals.
Deadlocks are basically when you have two concurrent flows (threads, or processes, or coroutines - it doesn't matter), which are waiting on one another before continuing. So you have thread A waiting on thread B and thread B waiting on thread A, and both are stuck in a waiting state and never continue. In safe Rust, such a thing is still possible, as Rust can't analyze your program's flow ahead of time. Memory leaks are when you allocate memory (e.g. by creating an object) and don't release it afterwards. It's not a big deal when you're creating small one-use scripts, but in production system, say, a web service leaking memory with every request, it's a recipe for disaster. This is also possible in safe Rust, but is more difficult, and idiomatic Rust code usually doesn't need to use features that can lead to memory leaks. The borrow checker is basically Rust's static analyzer (and a concept unique to Rust) - the compiler enforces a set of constraints on your program to ensure that all the "safety" promises hold true, and if your program is written in a way that allows for one of those promises to be broken, it simply won't compile. When we say "Rust prevents unsafe behavior", that's what we mean - programs that the compilers considers potentially unsafe (emphasis on the _potentially_ here - it's not possible to know for sure if a program is safe or not at compile time, so the compiler may yell at you for things that are actually safe) just don't compile until you either convince the compiler it's safe or take full responsibility by marking your code `unsafe`. I'm surprised your degree topped off with sorting algorithms, but these (at least memory leaks and deadlocks) are concepts I've seen taught (and taught myself to some extent) in the university I graduated. Don't worry though - it's not magic, and you don't need to take another course to learn it. The Rust book gives you an idea of those concepts, and if you want to dig deeper, read a good book on C or operating systems.
If he's the kind of community they're trying to encourage, they're welcome to him. "Everyone can find a place to belong" has always been one of the Internet's greatest strengths.
&gt; Zero-Cost Abstraction This is actually generally used with C++. It means paying no penalty for the abstraction, or said otherwise, it means that whether you use the abstraction or instead go for the "manual" implementation you end up having the same costs (same speed, same memory consumption, ...).
Coolio, thanks! Makes sense, and you lifted a weight off my shoulders. Happy new year!
I think it's a bug so I opened https://github.com/rust-lang/regex/issues/314
&gt;Are these advanced concepts? If I went to a better school, would I have heard about them? Sortof and maybe. I went to UC Davis and we never spoke about concurrency in programming in my courses, I learned by doing it on my own. Borrow checking is a concept specific to Rust, so you shouldn't feel left out there. In my opinion, CS degrees are really bad at turning out engineers. Not because the programs are bad but because they don't usually put a lot of focus on real world software writing.
Rust Belt Rust was wonderful! Thank you and the rest of the organizing committee for making it happen! And the new book looks so good already. Tons of thanks to you and Steve for your excellent work on it.
"Zero-cost abstractions" actually come from C++ (where they're also called "zero-overhead abstractions" which is probably a more precise name). Stroustrup's [Abstraction and the C++ machine model](http://www.stroustrup.com/abstraction-and-machine.pdf) (PDF warning) defines it thus: &gt; What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better. The first part is relatively obvious. The second one means that (and I'm lifting a /u/dbaupp definition here) "the abstraction doesn't impose a cost over the optimal implementation of the task it is abstracting". For instance smart pointers are abstractions over specific uses of raw pointers, but don't have a runtime overhead compared hand-rolling the use with raw pointers. So they're a zero-cost abstraction: you would not gain any performance by removing the abstraction and directly using the underlying tech, your code would get harder to maintain less safe with nothing to show for it. An other example is null pointers which in Rust combine smart pointers and the `Option` type, the compiler will boil it down to a regular ol' nullable pointer at the machine level. Stroustrup's own example was C++ POD types[0] which would have an in-memory representation identical to the corresponding raw C struct. [0] a class which doesn't use any C++ "magic": no user-defined constructor, destructor or copy assignment operator, no base class, no virtual function, no non-POD *non-static* data member (static ones can be anything) and no private or protected non-static data member
In case you need some concrete examples of what everyone else has said: Rust uses various techniques to prove, at compile time, that your code is free of certain types of bugs. For example, unless you use an `unsafe` block... **Memory Safety:** * You can't attempt to dereference a null pointer * You can't attempt to use a dangling pointer * You can't forget to free memory * You can't attempt to free already-freed memory All of this is accomplished without a garbage collector and the techniques used [also apply to things garbage collectors can't handle](http://blog.skylight.io/rust-means-never-having-to-close-a-socket/), like ensuring network sockets and file handles get closed when you're done with them. **Thread Safety:** * You can't read and write the same variable from multiple threads at the same time without wrapping it in a lock or other concurrency primitive. That'd introduce a data race bug and the compiler won't allow it. * You can't forget to acquire a lock before accessing the variable it protects. **Zero-cost abstraction:** * You only pay for the features you actually use * The high-level APIs will compile to machine code at least as good as what you could get by writing uglier/lower-level stuff. (ie. It's inherently going to cost to perform work, but using the pretty abstractions won't add any additional cost.) **Also, on a related note...** * Instead of exception-based error-handling, functions which can error out will return `Result&lt;T, E&gt;`, which can either be the result you wanted (the `T`) or an error (the `E`), so you never need to fear getting surprised by an exception that you didn't catch because someone forgot to document it. * Rust's type system allows for some pretty powerful tricks. For example, it's pretty easy to implement a state machine in Rust such that correct use of it will be verified at compile time. (eg. That old PHP "Can't set headers. Already sent." will never show up when using the Hyper HTTP library for Rust... your program will fail to compile instead.)
Deadlocks are definitely outside the bounds of the safety guarantees of Rust, as are memory leaks (see the safe function [std::mem::forget](https://doc.rust-lang.org/std/mem/fn.forget.html)). For a demonstration of a deadlock: see [this example code](https://is.gd/cMmp6I).
Sorry, confused the paragraphs there. Going to edit it to where it belongs.
Honestly, this thread is probably not a good place for that discussion. It might be borderline had the linked thread resulted in similar discussion, but it has not. I suggest nuking this thread, and should anyone actually be invested in the topic, they should post a new thread without the derailing hostility.
/u/steveklabnik1 This section of the book is IMO much less clear than it should be. It's a wonderful guide for people who already know what "safe" means *roughly* and want more guidance on where the line is drawn, but it seems fairly useless to point to if "safe" is an entirely new concept to you. I feel the new book should probably get this more right. I don't know the best definition, but I'd assume something like "safety is a guarantee that the fundamental assumptions of programs, like values being members of their types, are not violated" would be a better introduction.
Come on man, there's no need for that
Can confirm. We've hired CS graduates who didn't understand how to write software (but were really good at the theoretical math parts) and non-CS graduates (EE, physics, etc) that really get it, so it's a mixed bag. However, there is a *huge* difference IMO between a good CS graduate and a good non-CS graduate, since that theoretical math *does* have applications in real-world software, but only if you have the right practical mindset to bridge the gap, and Rust is a great example of that IMO. That being said, I'm really surprised a CS course didn't talk about [concurrency](https://en.wikipedia.org/wiki/Concurrency_(computer_science), as it's a very valuable pattern in CS, even if you don't actually use parallel execution.
We *might* do it again someday, **might**, but it won't be for a long long while, and it definitely won't be predictable. :)
Your idea isn't very different than mine, I'm just trying to only ship half the compiler rather than the entire compiler ;p Gaol would be a good idea as well, but I don't want one process per plugin and many applications probably want more restrictions to apply to their plugins than to the core application. It would make sense for an application to remove as many privileges as possible from itself (I.e. gaol) before loading plugins then use another method to restrict the plugins' capabilities.
I really wish they'd not make the same mistakes Unix made - especially with respect to naming. Naming things `tcpd` and `/sbin` is just awful. I imagine everyone reading this is very familiar with Unix and can probably barely remember the first time they read `/etc` and thought "WTF is that? Why isn't it called `/config`?" and they you would find out that the only reason is for compatibility with punch cards and teletype (or some rubbish like that) and think "Oh I hope one day someone will write a new operating system and give it sane names [like Apple did](http://osxdaily.com/2007/03/30/mac-os-x-directory-structure-explained/)." You don't have any compatibility concerns. Please name things clearly and sensibly! There are other mistakes that look like they are being repeated - reliance on environment variables like `PATH`, overuse of [text based config files](https://github.com/redox-os/redox/blob/master/initfs/etc/init.rc). Sorry to be negative - this really looks like a great effort but I doubt there is going to be more than one new Rust based OS so I think it is important to not just make "Unix written in Rust" along with all its mistakes.
&gt; https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong Go's memory model _could_ define what happens when there's a race, but they have chosen not to. Andreas Lochbihler's 2014 paper ["Making the Java Memory Model Safe"](https://pp.ipd.kit.edu/uploads/publikationen/lochbihler14toplas.pdf) says "the JMM specification is consistent in that it defines some behaviour for every program, not just for correctly synchronised ones." That puts a considerable burden on the implementor. Even in the case of Java, it has taken a long time to get to the current state, with lots of subtle flaws in earlier iterations (some of which were found quite recently as part of the formalization effort described in the linked paper).
Retroactively fitting security over an insecure language has almost always shown to be a terrible idea. It's certainly not without its merits, but after seeing smart person after smart person fail at this task, it's probably time to write it off. Compiling to a safe backend is of course a different challenge. WASM looks like the ideal target, since that's what it's for, after all. I have a feeling we're probably going to get "native WASM" before Cretonne becomes a thing. You say &gt; It also needs more runtime checking that could hurt performance but these overheads are there precisely to make the language safe. A pseudo-MIR is unlikely to manage to do better, and the Rust-specific nature makes it less general.
Thanks for using my freertos_rs shim. I'm slowly working on a bunch of libraries that will provide enough functionality to replicate MultiWii (CleanFlight) in Rust :)
"Safe" means memory-safe, type-safe, and data-race safe. Of course, we now need to define these. I'll discuss the first two, and link to [this article on what a data-race is](http://blog.regehr.org/archives/490) as I don't think I can do a better job at that. Memory safety means that when accessing a variable, or accessing a member of an array, you will always be accessing the variable or member of the array that you mean to; you will not be accessing some other arbitrary value by accident due to a mistake in your program. For an example of something that would violate memory safety, in C, it is possible to have a fixed length array, but access a value beyond the end of it; arrays in C do not include lengths at run-time, and the compiler can't always tell in advance what indexes into it will be used, so if you're not careful in your program, you may write values past the end of the array into memory owned by some other variable or array. Or you may read past the end, returning garbage data to your program. Rust does not allow this to happen. Vecs and slices always include a length, and accesses are checked to ensure that they do not read past the end; in addition, iterators can be used for zero-cost access, since if you're iterating over a range known to be valid you don't need to do an additional bounds check for every access. There are other ways to have memory-unsafety in C or C++; accessing pointers to stack frames that have been popped, or memory that has been deallocated, double-freeing pointers, iterator invalidation, etc. Through a combination of static (compile time analysis) and dynamic (run-time checks), Rust prevents all of these memory safety issues. Type safety means that when you access a variable, you always access it as the correct type of the data that is stored in it. Any memory problem can cause a type-safety problem; if you write past the end of an array, or read pas the end, then you may be writing or reading some value that will be interpreted as a different type than what was written. In C or C++, casting can allow you to encounter type safety issues, as can unions, in addition to all of the memory safety issues. Data race safety means that multiple threads could be accessing the same memory at the same time, with at least one of them modifying the memory. It is [explained in more detail in the article I linked to](http://blog.regehr.org/archives/490). Data races can be the cause of memory safety or type safety issues, so you need to be data race safe in order to be type and memory safe as well. Rust guarantees that, outside of `unsafe` code blocks, you should not be able to encounter any of these three types of unsafety. This is also a guarantee provided by most high-level, garbage collected languages (or some approximation of these guarantees, sometimes with caveats about certain operations which are well understood not to be safe). But, garbage collection imposes certain overheads and can make reasoning about and controlling performance at a fine grained level difficult. C or C++ allow this fine-grained control and predictable behavior, but are unsafe. The innovation of Rust is that it allows for controllable and predictable behavior, while simultaneously being safe, without garbage collection. This is also an example of one of the zero-cost abstractions that Rust provides. References in Rust are a kind of pointer, but ones that are guaranteed to always be valid. So, they do not incur the overhead that garbage collected or reference counted pointers have; at runtime, they just bare pointers, with all of the safety guarantees checked at compile time. "Zero-cost abstraction" means that there's no extra runtime overhead that you pay for certain powerful abstractions or safety features that you do have to pay a runtime cost for in other languages. Note that not every abstraction or every safety feature in Rust is truly "zero-cost". There are some things that are impossible to do with zero cost in every case. For instance, bounds checking of array accesses adds a cost; there are some cases in which you may know and be able to prove that a particular access will be valid at runtime, but the compiler doesn't know that and will put in a runtime bounds check, which imposes some overhead (solving this problem at compile time requires much more complex and difficult to use type systems that are more suitable for programming language research at this point, they haven't gotten to the point of being practical to use in production by most programmers). However, Rust provides a lot of tools for being able to avoid these overheads, like iterators where because the bounds check can be rolled into the existing cost of iteration and no additional bounds checks need to be done. Now, one question that comes up is, why are these particular safety guarantees important, but not other ones like deadlock freedom or lack of memory leaks? The answer is because violating these safety guarantees can lead to what's known as *undefined behavior*. Undefined behavior means that your program can do things that are entirely unpredictable based on the semantics of the language. There are other behaviors in languages that are merely unspecified or implementation defined; the standard doesn't specify what should happen in certain cases, but what happens in those cases will be consistent and can be reasoned about. For example, in C it is implementation defined what range of integers fit within an `int`, but the same range of integers will fit in any `int` in your program. On the other hand, undefined behavior means that it could cause anything to happen, and not in any kind of consistent way. For example, if you happen to write some data beyond the end of an array, you may change some other variable on the stack in your current function, or you may change the return address for the current stack frame, causing execution of the program to jump to some arbitrary place in memory which may or may not even be code. And what happens may not be consistent; it will depend on what optimizations have applied, the exact layout of the stack, the exact layout of memory, and so on. Additionally, those optimizations could have been written with the assumption that these things that cause undefined behavior don't happen, which means that what happens if they do happen can be quite difficult to predict and reason about. There are other ways for a program to fail, like going into an infinite loop, leaking memory, deadlocking, or having logical race conditions (as opposed to data races). In the general case, in a Turing-complete language, these are impossible to detect and prevent; it's impossible to write a program that will predict correctly if a program will terminate or not. But it is possible to prevent memory unsafety, type unsafety, and data races, and since these can produce undefined behavior, they can cause problems that are very difficult to reason about. One particular, big problem is that while the issues are very difficult to reason about from a language level, it is frequently possible for an attacker to be able to exploit these issues to cause a program to behave in arbitrary ways. For example, if you can write past the end of an array that comes in from the outside, there are numerous ways to use that to execute some arbitrary code, allowing an attacker to take over a program and perform actions with the privileges given to that program. So, while crashing (aborting the program early), non-termination, and memory leaks are bad and can lead to some types of denial of service attacks, memory safety issues can frequently lead to arbitrary code execution attacks, which are much, much worse. Whew, hope that wasn't too long and shed some light on your questions. Was mostly trying to cover safety, though mentioned "zero-cost abstractions" a bit, and other people provided some more information. Let me know if you have any questions or need clarification on anything.
I don't know if the PDF rendering engine would be ideal for sharing. The engine is essentially a built in LaTeX templating with a custom style sheet. This was my first question as well as someone who will eventually need a semi-robust PDF writing library. Me and one other user have discussed and eventually plan to write such a library.
Thanks for making freertos_rs! I'm not actually using any of the FreeRTOS functionality yet -- just linking it in -- but it looks super easy once I start playing around with it. What microcontroller were you thinking about using for your project? I'm in the process of packing up my house (moving soon) and found a bunch of quad parts (props, ESCs, motors, etc) that I never got around to using. I may be interested in finally assembling a quad just so I can play with Rust on it :)
My idea has a side benefit of fostering an open community (if the source code of all mods is immediately available and the game ships a working compiler, I can mod the mod with minimal hassle). This is probably more relevant for open source games, for which is a good idea to require mods to also be open source: the game's modding API can be available only for GPL mods (like Linux does for some of its API). Downloading mods in source form is a way to make GPL compliance easier and more likely. Or more generally: what if Rust can make an inward into domains traditionally occupied by "interpreted" languages? One front has been developed with [rusti](https://github.com/murarth/rusti). But distribution of programs in source form is another feature associated with such languages. For example, in games with Lua modding mods are distributed in source form, and I can read and modify them easily. Could Rust be like that?
Honestly, zero-cost abstraction is kind of a buzzword, since any compiled language with basic inlining (i.e., anything that compiles to LLVM) has "zero cost abstractions". That being said, what is vaguely implied is that polymorphic functions are resolved to their monomorphic versions at compile time--e.g., `+ : Num&lt;T&gt;(T,T) -&gt; T` will be resolved to `(i64,i64) -&gt; i64` if you use it on `i64` in your code. In other words, you will not ever pay a cost for using `f&lt;T&gt;` in your code as opposed to hardcoding `f&lt;i64&gt;` in instead. In contrast, here are some examples of things which are *not* zero-cost: virtual function calls in C++ and free monad constructions in Haskell. In these cases, the compiler is either not able or not smart enough to be able to optimize away all of the fluff and you will suffer a runtime cost for using these abstractions instead of writing the equivalent manually-inlined version yourself.
&gt; mass surveillance is antidemocratic, no matter who does it. I believe it's direct result of democracy. Of course I don't want to discuss it in this thread, just wanted to express different view. (If you are interested in discussion, feel free to PM me.)
Awesome, looking forward to it! :)
I hadn't heard of them, and I'm going to buy one now, so you've succeeded at least a little!
I have to agree here. I really like this project, and that's precisely why I agree with this criticism. If these conventions are to remain, they should only be surfaced in a Unix compatibility layer/shim
Only if other bytecode can be run within the same process space should there be any security concerns. At least, this is my impression of things - safe Rust should be safe WASM. But the moment you start letting other, not-known-safe code to write to the same memory or otherwise directly interact with that previously-safe code, well, all bets are off.
/u/steveklabnik1 is my senpai
From [this article](https://brendaneich.com/2015/06/from-asm-js-to-webassembly/) it seems that wasm is an iteration on the PNaCL concept in a direction that other browser vendors would accept (*"Having both the PNaCl team and the V8 team from Google, along with key people from Microsoft and the asm.js and Emscripten gurus from Mozilla, collaborating closely once everyone saw the light, has been inspiring"*). Might as well use the wasm rustc backend.
&gt; since any compiled language with basic inlining (i.e., anything that compiles to LLVM) has "zero cost abstractions". Really, this is about _design philosophy_ more than it is a specific feature.
What are those soundness holes, can you give a link? About stack overflow, I suppose (or rather, I wish) there's an option to turn stack overflow into a panic, not a crash or memory safety issue. And yeah I think that linking to a large part of the libstd is a no-no. But relevant parts of the std can be re-exported by a shim.
[List of known soundness holes](https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-unsound).
I investigated that and completely forgot to include it in my write-up. It seems to be deprecated in favor of wasm, so I don't think it would be a good choice for developing anything new.
100% agree. What are the solutions to the PATH and config file problems? 1. What is PATH really for? It exists to tell the shell where to find executable files. How can we get rid of it? Tell the shell where the executables are some other way. Example solution 1: Suppose the file system were a relational database. Suppose that every file had an "is executable" and "is available from the shell" tag. Then all the shell would have to do is query the file system for files with those properties. The system could have a cache of the query results, but that's an implementation detail. Example solution 2: Suppose we treated the shell like a Jupyter notebook for the Rust language. By default, this notebook contains *extern crate System* and if the user wants to import additional functions, they can simply *extern crate WhateverTheyWant.* The available crates are supplied by the package manager, and the user can easily register his own code with the package manager. 2. Why do people use text-based config files? Probably because they are developer-convenient and portable. So to make text-based configs go away, we need something that is even more developer-convenient without sacrificing portability. Example solution 1: If the file system were a relational database, AND the system were able to natively handle some form of markup language, then the OS could provide a very straightforward UI for editing your software's config files. Specifically, it just has to query for all the config files. Developers could then use the markup language to make the files slightly more user friendly (e.g. by providing input boxes, document structure, etc.) Of course, plain text files would still work. 
&gt;Not because the programs are bad but because they don't usually put a lot of focus on real world software writing. I think the exact opposite is the problem. Many CS degrees put *too much* focus on real-world software writing, as if they were actually trade-school programs purpose-built for finding jobs and not university curriculum. Almost all the schools around me churn out developers who have no problem writing a CRUD app in any modern technology, but lack knowledge on advanced concepts because their 4-year "CS" degree was on "how to develop software in C++/Java/Python". 
I hesitate to list names because of all the people I'll forget to mention, but if you've answered my Rust questions or vice-versa, or if I've used your code or read your blog posts, please be assured that I'm thankful to you too! In addition to all the people already mentions, big thanks to /u/neutralinostar (bluss) for constantly teaching me new things about Rust, ubsan for warning us all about the dangers of `transmute`, /u/theaaronepower for `tokei`, and the docs team (including /u/imperioland, /u/peschkaj, /u/jntrnr) and everyone else out there writing docs!
Agreed on the serde recommendation, but there is this benchmark comparison (benchmarking caveats apply and it's not obvious when this was last updated): http://json.rs/
&lt;3
I'm actually very curious to know why serde is behind rapidjson by such margin. Edit: I am aware of benchmarking caveats.
/r/playrust is that way. 
Thanks for the tip. I didn't even know this existed.
Oops, wrong subreddit! Try /r/playrust
Huh? Python is different to Ruby (async-await). And C# quite different to Java (proper monomorphised generics, struct/value types, expression trees, async-await, properties...) I think Rust is at least twice as different to C++ as C# is to Java. Or am i misunderstanding?
Thanks for the comment. I'm glad you like it! I'm never quite sure when when I'm writing whether I'm actually making any sense. I think a large part of it is that I've just spent hours with my head in the problem, so it's easy to forget what context is necessary to communicate what I'm trying to. I have a great Doctor Zoidberg gif for this, but I understand they're back off the table now. :) 
I feel like this is a bit too black and white for my taste. Go does a lot to solve memory safety issues at the language level. It doesn't solve as much as Rust, but what it does do counts for something. We should be careful to acknowledge that. :-)
Yeah, the pentagons are a real pain in the butt. If you poke around, you'll find a few communities where people are toying around with really similar ideas to "Civ + geodesic sphere". I can't recall how far any of them got; last I read anything about it was over a year ago.
&gt; And C# quite different to Java (proper monomorphised generics, struct/value types, expression trees, async-await, properties...) I am referring to people generally saying that "Rust doesn't provide anything spectacularly different from others", which I generally believe is false (it was mentioned in the blog post). That's why I mentioned that if it were to be true, then Python = Ruby, Java = C#. Of course there are differences between all of them, that's why I made that comparison to highlight that even though languages provide similar capabilities, it doesn't mean it has to be drastically different to be adopted. Rust is drastically different imo which is why I mentioned that I see it as sort of strange that people don't think that it provides unique enough features to be adopted. 
Semicolons are like periods in English. Without something to indicate the end of a sentence other than a new line, you can't put some parts of a sentence on a new line without causing confusion. I think the visual space your code takes up affects readability in a significant way, so I value the ability to chop down to keep all lines within or around a certain width.
This blog post is a much more eloquent version of what I've been trying to tell people. (Right down to my experience encountering and then shying away from C++) Definitely bookmarked.
I actually do work on satellites. You would not *believe* how much design and review goes into trying to prevent exactly that. So I'm trying to spread the good word, 100%
I think this is very well written, and after reading it I am not sure that the model I proposed would ever be secure. It is possible that runtime compilation from MIR would be a good way to make fast but *insecure* plugins, but I'm hesitant to develop a plugin system with to security guarantees because I would see such a system being misused. I probably need to wait to see how much of a performance impact WASM has. Perhaps there's no significant performance difference anyway.
Fair enough. Thanks for clarifying!
ASI is a pretty solved problem. javascript has a good implementation, for one. 
Wasn't a classifier implemented to detect these posts? Is it not deployed yet?
The week has just started, but we usually have a pinned post that provides a space for asking small/beginner questions. It's from a time where we deemed a /r/learnrust subreddit as too much. Do you think that would be a good thing? Also, the official forums are generally a good place for that.
Every string you insert into the hashmap would need to live longer than the hashmap. This is rarely the case, so its more common to take ownership when you're storing the data in a map.
Linux distributions will hopefully keep an up-to-date version of Rust and Cargo in their bleeding-edge versions, but stable versions of those distributions will stick with a particular version for the life of that stable release (months or years depending on the distribution). Of course, stable distributions also wouldn't adopt new versions of crates. But appropriately versioned dependencies on Rust and Cargo will make it much easier to manage transitions, which will become increasingly important as ever-more-critical packages depend on Rust (such as Firefox, or core system services). (I'm part of the Debian Rust packaging team, though I don't do the packaging for Rust and Cargo themselves; I work on crate packaging, and build tools and policies for that.)
I'd like to do exactly that: let crates declare a dependency on the versions of Rust and Cargo they use, and allow Cargo to resolve dependencies accordingly. This would also make it much easier for people trying to make sure all their dependencies work with a given version of Rust. See [RFC 1707](https://github.com/rust-lang/rfcs/pull/1707) for a proposal for that.
Just for reference, which features are those?
I felt the same way when I first encountered languages like Scala and Haskell, but after using Scala professionally for a while, I found out that I really don't miss it; in the great majority of cases it's just noise to me now, and I would gladly make it optional.
Awesome, I'm glad it was of use 😃
Full ack. Rust may not be 'squeaky clean', but it's nice enough to like reading it and it has sufficient information for both man and machine to reason locally about the semantics of the code, and I wouldn't want to give that up for a nicer syntax.
I'm going to assume you mean automatic semicolon insertion, and frankly it's a mess in JavaScript with some edge cases that aren't handled equally by all engines (which is why JSLint will warn if you omit semicolons).
I disagree. It **is** a lot of fun for the mods.
Thank you, SmallSubBot.
I'm working on getting [crates that use pkg-config](https://crates.io/crates/pkg-config/reverse_dependencies) converted to use [metadeps](https://github.com/joshtriplett/metadeps) to write those dependencies declaratively in `Cargo.toml`, prioritizing crates most likely to appear in the dependency trees of Rust applications we want to package for Debian. (I'd love some help with this, given the number of crates involved. The main challenge involves figuring out the correct minimum version of the native library that the crate requires.) I'm also working on adding support for metadeps in [debcargo](https://crates.io/crates/debcargo), to automatically generate appropriate dependencies on native packages corresponding to those declared pkg-config dependencies. That'll make it possible to package -sys crates without any special-cases. And finally, I've followed up on [RFC 1707](https://github.com/rust-lang/rfcs/pull/1707), expanding it to allow crates to declare versioned dependencies on `tool:rustc` as well as `tool:cargo`.
For all your ordered collection needs, `Vec` should be right up your alley. Ignore Rust's fixed-sized arrays (`[x; 42]`) unless you actually want inline storage (or store stuff on the stack, which sometimes can benefit performance). Both are usually reference via *slices* (`&amp;[T]`), which are fat pointers that store the index+length. 
I'm just wondering, what about: - more basics like propositional logic - theoretical CS like graph theory, big oh, Turing machines, Gödels incompleteness theorem and everything surrounding it, context-free and context-sensitive languages, push-down automata - object-oriented programming (as a basic programming introduction), software design (i.e. patterns, refactoring etc.), software architecture I feel like these (or at least the basics of them) should be thought in every CS programme. I'm sorry if you implicitly meant some or all of them.
Yes, all of these were included as well.
Try reqwest, there is a json method on Response that will deserialize the body into any type you want (that implements Deserialize). https://docs.rs/reqwest/0.2.0/reqwest/struct.Response.html#method.json You can start with a HashMap, but in Rust 1.15, you can derive Deserialize on a custom struct and have better types.
I haven't thought about how to draw the actual file. TiKZ is a great suggestion, which I hadn't thought about. Thanks 
I'm still working on [Teleborg](https://github.com/voider1/teleborg), I took a break from it and am back working on it. I've learned a lot of Rust along the way. Any suggestions for code architecture or coding styles are welcome. There is no README yet because the project doesn't have any basic functionality yet.
For this library, instead of simply calling `unwrap` in examples I decided to adopt the same convention we already use for binaries. That is, put all the code in a separate function and then call that function from `main`. This allows me to use the question mark operator. All the code you see in [the examples](https://docs.rs/publicsuffix/1.0.1/publicsuffix/index.html#examples) is actually inside `examples()`. I'm going to update all my libraries to so that they are documented this way. Don't get me wrong though. I'm not saying `unwrap` is bad or (as some people would like to say) evil. Far from it. Unwrap is a wonderful method when writing tests for example. However, I think plastering unwrap all over our examples will hurt our ecosystem in the long run. Some beginners see this and think that's how it's supposed to be done. I've already seen a couple of such cases here on Reddit.
I'd recommend #rust-beginners on irc.mozilla.org (as a side note: is there a reason #rust-beginners isn't listed in the learn or discuss panels in the side bar?)
Are macros 1.1 still on track for the 1.5 release?
Learning Rust by working on the [cryptopals challenges](https://github.com/sYnfo/RustCryptopals).
Out of curiosity, why were the Eq and PartialEq impls removed?
An IRC channel isn't a replacement for a subreddit, though. I think it would be a good idea to have a subreddit full of beginner questions (remove the ones that aren't very clearly explained though), because Google can find threads in subreddits, but it can't find questions in IRC channels.
Rust calls this *multidispatch*. It was discussed in http://smallcultfollowing.com/babysteps/blog/2014/09/30/multi-and-conditional-dispatch-in-traits/ and implemented in https://github.com/rust-lang/rust/pull/17669.
A related question: how _do_ you link pictures (which are stored in the repository) from rust documentation? Linking them externally seems extremely fragile when they should just be part of the repo and linked as such.
I'm working on my first major contribution to the compiler, implementing `#[proc_macro_attribute]`, mainly because I tried to use it only to find it's not supported in the compiler yet. I'm not sure if anyone else is working on it already since the RFC just got accepted but I have a very good use-case for it so I'd like to get it working one way or another. 
Adding new features to my SVG-specific applications and libraries: [svgcleaner](https://github.com/RazrFalcon/svgcleaner), [svgdom](https://github.com/RazrFalcon/libsvgdom) and [svgparser](https://github.com/RazrFalcon/libsvgparser).
Experimenting with integrating futures/tokio into [gluon](https://github.com/gluon-lang/gluon). It looks promising since `gluon` has long supported yielding from co-routines but it may take some work to make it a clean implementation. If all goes well I think it would make a nice addition to the [http server example](https://github.com/gluon-lang/gluon/pull/226) that is currently in the PR queue (once hyper gets async support that is). EDIT: Hacky PR https://github.com/gluon-lang/gluon/pull/241
Look at mioco it's a decent version of go-lang's concurrency model in Rust 
What's the problem of asking such questions here? We've even [a dedicated thread](https://www.reddit.com/r/rust/comments/5lk1lw/hey_rustaceans_got_an_easy_question_ask_here_12017/).
it looks like you can use base64 encoding to embed your images directly into the documentation. This will make a non rendered use of the documentation look pretty bad though :( and it will blow up your filesize if you have bigger images: example for the rustacean logo used by this subreddit: /// This does nothing /// /// it is just to test the documentation feature /// /// maybe lets try base64 images: /// /// ![rustacean][rustacean] /// /// [rustacean]: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABDCAYAAABqS6DaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wUPFDIETg0AuAAAAAZiS0dEAP8A/wD/oL2nkwAAEHBJREFUeNrtnAd0FNUax78QSCg5gJQoiCKKIO0QKaF3MAkplIhAKAECmBg6AemEoqGFoqCIT8WG7akPnu+hTx8WihRRg/IQpAhiINJJdkkI5L7/nZndzMzemZ3dbCJi5pzfmd2ZO7N3ft93y8xuQlS6lC6ly2265Kwzf1+6FKNw/lokPOd5qo3t74MupcZKJigTwSs5aylIuH8t7cN+BrLwumrOamW7Y72Gyuc8S2vASrwOyFlV6tT7YDxLzSCZSTxLe3Oeo0BILdz/DE0FTMUcaTuk56x0BuZ9HMOw5nQqtWoke7VTajUQLCzzDL2uEb6GXlUdXxPvsyTZhcIZAlHbWWYVrQfMyUp6R9q+XNm/TFmvoOrgTmz3sy37aweFdzEXIPQC1pOlbSudMitj20mn6NVOqRuVcukq0YWk0y5pfzq6unTpfSEriF1dQuX4fttS5XOWUxg4Dc4jQPVtM/7KAVlFA52iZbFrIK68IjwEFGhkF0pnItlOliuoXyugBUyVArKEyiIoqYBvk1lKcX/tbmsFLRNIPQBxI8BOjWSVXJuaZQYsFbBE4rQtjQaDHcp7mTSJlbe1cN4tXFlFfpBYOXs5lVF3FUp38akwi81kLzVhiQFpAp4W8BR96az7AtV1LKIqwO/2CMoyigUnIWwrCHVuf5r88f5gkcUayZUFu7JYwCIndk3dF9BD4D3bQvoF6/TbpZVs0cn+ErIaQmQjvP7dZ6KNZGuFa1koIJWa2eZTLaw3IQjMSSodBRX+/AFJozcFcm9CYE6xil2okqknVcB8DTc17+dJ/AQC//wBeYo2uBW9uBhFu8rWi3ZlrpCDwP/PIX2B+LUyIK4yFewLsfM9EstscwyYbcAsiQPAObDbnlRd45O3YlBSqTZk3od1ZVBOFaA0S7JTfZLFxsJnuxWuZaYL3zuvaTruYaZTEKiLYDTA2s+WcisFYz7VU0nNAtsh7TkwFq/PeiV3jteZbEWuzAwBTxqSDfHjbdMoHett4DRgeM95+NZqHfOoSbF2GbN9INpM9nQDphmQ4kLorddlzdHJtiJ1toHcWQZyZxqIneFGrl7odFO5zDZVh3rbFBl7IZfxvu4t1WVJAZlNH3vUZczwMJOn+ySTxcJ1snXCmX2yCZPoGKh067WQGehfzcTO8LCLMMviaQKxZlk81Y3YSTrU2yYaMMHJtj9OukmzhOiWHmdxSollsRj3srWMFzLHyIk9sbgDMkUKShCYCxaAGWACGAE+8UjsVItZPMVArFkWTxKInWgiVr1tnIBkAY7tT9ARkGhPovFgOkgFaQhGnZJpJVNpXoll8UQvstgok8eZkGzAEyYkCUjU8E3JBGQKjbKcxVYET7CYyRMsyDXOYi3JbsSKBcs8bsJYDZuLPxiT0S9OotrgfJH6Yl9mcbKHWWwk2jPZWsYIaVRigzuEbvZ5FicLsjjZwyxOMpCbaCL2cROpju2jdai3JQiRZl4oV0IBGUcP/WFZnOhFFo8xYbQJCQaMMmGkRJsSnwJD5mHDLH7CQhaLhCa6yeKxPhI72kBugotYV0YIcGyPlzgNqkiOhvla+lhl/Tj5KZSBtEAQ4VUGe9cXe5fFCW6z2JpsNfEGDNdQgECMAkH2ofDFGSI/trf74jctkFgbvAx2giyV2ALLWTzWQO4YC1ksEppgIHaUhUwWCR1hKLeQYQIc24fqcGwbQhfAXvAugtHWN61kDG5yitofe98Xe57J8ZYz2Vy2mqEGDDEhTsfgwu9TihqQCKfsBJ1kfV+cYCDWSLaZVKyv4aKzUhqzA8uGsaGNK7Lwu4mNbEBsU1dibJRKcryx6GsgN6k6y1w7iiV1uI+1r04sqSGx/dHErg+3IDtOIHiIJFjiWpxQPrMPkrnGywyStqX5IhjyehRtK/Es5iLnNGeOJSMjgwUEBDBURyK8DrGcoe6z+LehldjFUz87z1OjRg3p+EB/Yl88YiBULXawIlXPIBMGuvC9bwf3ERigRtIljfB4L2UPM+k2VIKzIeT6oa+YegkJCXEGhLO+LcoMVWWtjpvY91iPNqxAdY6NGzc6jw8sQywvzkD2QBPZjwmlF+7TYrs2gOr5LhgjlXU8dQAFJdUX/zwggP169JAmIJGRkZqAlINQNlycxdchel0rYtH9B2jOsWPHDs051qLM9UFupWoZYMKjLkhPg3GcjwIyRFkPw2xrOJ1TZ7FHsuNMBr/B2q7iOravbU1s+9e7NTJbtmypkcn5bw9kuSCT8yC2dTWSjlEv69at0xzfvgY+Ty/7UTfCY4XiC/epcHi81tfX9yRDKNPyjKKIfTFDIMPuIta1W3enyKNHj7KKFSu6BGR1CwgVZPXvfYnVrUTSuMPHH77k5+drxiFOPZQ519dcqgv93dBPwxEEo6oUlD5FCADEUB6amS2OKkLq914JH+Tx4CfBEOQmVWRhXbt2ZTNnzmTBwcEuweAsa65kuC6LM2OI1akgl/H392fR0dGscuXKLsfXKk/s1ygvhPd1EV8I39dHWctcwvtYyWsMiC5aYPZ4I7UofTFDMHvcScIA6HmzDQIiyOorENEgyP3x91QkdjbKQKo7+rghxoXnvQvCADCQ/MHW4hBuMPg5uY79L7W2FpALuNBcQRbfAMkPuD++E8aQXDPhMR4JdyVaRxTtBw0kz1FWgvGoMyhvFEVqUfvic7iYuhXNZSbeT6ygv3EG5yPTq5YzP8dx3IvkeipVK9hbhrkNCkTI61ha75Sum1HkKhmca0V4rNL8rQ1+GvLA8XBi7aqLRXaridYRZd5l5IKDPYnVDHQ9PiyY2I/dcS19LEi3GIA8fvevkGctWGuB+Bf1kOAIylyzTL6Iyn8WioEQsvJizaVa7o9NpNrweR+1I9YMg7wf72IQoE/aY3u09Uy+3JvYyqbEht9LbEljYqfQKnIii5TdQg52wVS9jcwPnYld7W0pMDONW0g/ijXJ4oKCR2nV640pG7BXGxHb8jCxA6jE2Qh8cB+l6fdxmWG4H/zc9Mf52M/6K6Au+THKxXiQxQU4hvWVuYEyuT4OxkUk6FsIOtxcBMdfg6ONcLStNWXbIjH1NT72ceOA9KVpJll8jA2jCm82ocGAqbjBK/JhCLFLEboPi/awP+ZNHWVu8gCouBFTNIE8S3lAfuwGaS2J/QMt/Fy4vM0XweDn/7ajFIxd8FELHHH4wbaFSKCeBsfmmw/oMRQA8ZcMMviyPZrqvNuM/PFBn6oCcgyMwQfv/7SVuInmOvpUkyy+CTl70MynYGbUrDKxGgHEyvsTCyord1Prcb+RFS6XsyqKC/+ph3zOSEyjE+oSS28iMxqvk+sRewWt3B5lHPBcRThf/9YL9ze9hOVOv9KIpGcacNEY5CluflQG7nEGdexvOLA77iIhvgWE5RlkcJLyoZxzqqB0AmX/9hCFHulK3+gv7gwu4kg37cWp9/NWEH+PHIi3ENTfwnCnHS5zGv39S2h9d+Mmr2wZZBzuzPMtDJi8zBq03PswU8voJvfnuVFa+LbdnYh1RsBtuqDw13xw5q1+bwdiSET2WWth4PIR0FYOj/CQrjix8+Aowj8V1HEfKGM+y4pR1tE03CCT7RgMHR/cAFxTPjzDcQ42gcqh3BG9nP+0ksedj5CRezBI/wxJZyD7MGY6/WsRe6G50j0JZPMui+97DmVqouWMQ2ajXzbMai7yyfrEhtSRW4nZwMrL8pb32N3EDqEuWY/IdfsadfyguTwOSGNBqNyS7K7nSFMFw1+VpKuUYFQBp/RBBLU9uzmMomijqZqqAkNUFYhTHXuP/jiejfwC1ePPq43lroQLsTJN5GUy0XpCMONqV41YdqS4i+FT2lkP4j322y3Ay51HHTrinG831dbxDdQxo5PhsSvUzlB+kT5BUacmoEBXz36WbwzVBbGeLBBziUf381BnJdJUY0n5z1ppAlqgFnU5guxbW9BijDcbXmpEO8bXoxs88z0ZsHlZhqyPuFNuATyjzyh9+wUEa9FDxFLqy7MpPrW1WYQL5l1l26pkR4vYAuZ+3JJGX4ygzfw6BMe8mhVJfjjO0YUHgV+VXuMBlcvlumvYBvwtB0MQnMcEYjbwfd91dDbTXUpQBvLt2b2VJ8RRtMDRzFXN/RyktjvZi0KuRtIN/X6r4FjWHhnduSqxd5rKffxYdDs9asqt0Rt4AA92o9Poukbi/XvgokHZ8XpPuPYoxUGqzp/a201Q3vsHi4UtZZogKB1UlSkLToCbIEAJhvzz00hKN8jKPJsHGSyCd1nonv658kFKfrkRJfaqQW8go69diaDDYD/Yo6wPoXVmgnzAzLiiYLA/E/sG8+u62tslIGd4YjomPYq3sSpfvLd4xKOuyk1wBukCchgEYRbiqNADwAZeVgJBdmUCgBazELAikg1+AP8CG/g5c3rThOtRFOaoY14k1b/Sm6ojKEGgPAjka9SxEqgKgvE+9EI4LQKHQAFgFvkAx1YXucE1D1OmunUdAYGbsiBD5WuzL4Nh1FKmqfejIrHgAqjpyBJH94XMikeGZbvLUJALlqF8P6xbXgqnap7UFeIs7cO4E5EVRtcBc8O+38MowuicuE4/cAhM0Dnjg3mu4imz2H5CKhhTeqibKdYpPDDqY64ol8MzFFI+5jMaU8Io61wYNROdoyjLie7y+nRPGui4yTMC+w9hWt4KSA//zoUJg8GpBzYJkvdtxU8eaOGz1mHQUqaoApIFqvJ9vIKbmlAFzKJSzc6DWVJrCH4RwcnhsyQjkMUpmT3pjqLW+6cumqDEnexBBQpMzynwW0/abfXcmFCEKt212lM9lZ9niiUYguD01d+bOD6UMem3rFv59QM+J+c/z/87eBHw/3g4CySl3E9bLqJbQMYa8mtPyoSkyUWtL5tGZY50pX//3JUKABNxFDeEezvS2QaVpEca/ItWPoDzXzjzv65cCLjc18AWsBMcq1KW4tU9hOJhi+JlV4n88l3VUhKVqRz/8BBdsaFWvvGbiLvuE8jK492N4ft3tic28h5iDSsRgwRL3yZK35kHEou9i9gO3Hn/rwumtZ3FHMK+TQ/Lj/jJM3qrvYAa4Ay4CuoUe8sQBCdcCQp/NqP+bznzrF7U4obEfoF4dC3GKFnMv2fYDrlbQ4n1UX3vXsaP2B0BxGoHSjd3LPle3JuEEPuqLbHvOxL7roMxh3HOBbizL+fncTA4X+h8hCoJmlgiXZVBS5muzLObKrsqg3xPLmxWffkRBZfnjgywHaLv0n0TOBJ37t9C8P86yWW+aW8OL/tJa2LRwV4FQs1I3Z35/hIPhiA4KXZlAMPyrTcX1v8uyj5gQSTP6qR76QUcw//7L//Hlfw/OS7hdK5GS3a3oyPuzrEfrGlM22oE0Oc4bg/gj8p/4bNjcMOL+i9UPHzNp7x/aECcg3lf6etI3lXxWcqHYD1YDCYB/qU+v1VsB/gfRNYCLv8yb087agJh35rIvLSvPfVzVyeU6wM+Azw4meAMOAH2gkV728l/5WRh4dPeYKXO/OkEfyaeAGYqCfEW4EHlP6geXBBD8+lWWvz9qKy3x0KUY10etAGvgfNKILjMOeBOdVnROdT78DoI1ATBoCrw03+eD5eKGZ1vk/9eKgqMp/tKl9LF58v/AQpfj3+DWklzAAAAAElFTkSuQmCC pub fn foo() {} this will render like this: https://i.imgur.com/zqFFlrY.png
&gt;* You can't forget to free memory You can actually. `std::mem::forget` is not `unsafe`. Even if it was marked `unsafe`, you could leak memory by making a cycle with `RC`.
Glad to hear it. :)
So, I started the new year by adding/labeling a bunch of diesel issues that are [easy for newcomers](https://github.com/diesel-rs/diesel/issues?q=is%3Aissue+is%3Aopen+label%3Aeasy-for-newcomers), and writing a proof of concept tool called [waltz](https://github.com/killercup/waltz) to turn Markdown code blocks into code files, to help with writing testable guides ([motivation](https://scribbles.pascalhertleif.de/teaching-libraries.html#an-intermediate-solution)). I'm looking forward to doing more with that. But for now I'm going to review the PRs for cargo-edit I just got :)
That's why I said "can't **forget** to". Neither `std::mem::forget` nor `RC` are the default behaviour. You have to go out of your way to use them and, if you don't understand the consequences of the calls you make, then why don't you try running `sudo rm -rf /`? I promise it does something neat.
&gt; Considering Rust is about speed and safety, most developers are not going to produce an ORM for mongo because it's not safe itself. "Write and pray" is the term I've heard used before. I believe that's not the case anymore. It sure used to be, but writing to an appropriately configured Mongo replica set with write concern "majority" gives you some fairly sane guarantees now. (https://docs.mongodb.com/manual/reference/write-concern/#majority-definition) That said, I'm generally wary of what "ORM" might mean in any given context. I've generally found anything beyond typed record set and query builder helpers to be more harm than good. I'd be curious to know OP's use case before recommending an approach.
As far as tutorials go, you must go through "Learning Rust with entirely too many linked lists". It'll introduce you to many important concepts and idioms, and is just generally great. I'm on mobile so just google it :)
Zero cost refers to abstractions that compile optimally -- "you don't pay for what you don't use" is a different goal (which C++ and Rust also share).
I bought a couple of drones (STM32) with the intention of doing the same thing. I'm still waiting for them to arrive from china :-) Looking forward to the write up and code dump :-) 
A class that teaches C++ without teaching what Undefined Behavior is is a tragedy.
C++ will not have any overhead associated with a thin abstraction like that. GCC has to generate a constructor function, in case you make a function pointer to it, but it'll inline it away at the call site unless you actually use an indirect call. If you use a tuple struct in Rust, rustc will also generate a constructor function, and inline it away, exactly the same. If the function ends up never being referenced, it will be omitted by the linker.
Working on a graphical [matrix](https://matrix.org/) client: [ruma-gtk](https://github.com/jplatte/ruma-gtk) (not [yet?] part of the ruma project, I was simply lazy with the naming) It's a project I started with someone I met at the Rust Assembly at [33C3](https://en.wikipedia.org/wiki/Chaos_Communication_Congress) and I already clicked together most of what is required in terms of UI layout in Glade. Now it's time to add more functionality to [ruma-client](https://github.com/ruma/ruma-client) and then define the interactions between that and the UI. EDIT: grammar
Also Python and Go
Stroustrup puts both of them together under "zero cost abstractions", in fact, putting the "you don't pay for what you don't use" part first! See /u/masklinn's post later in the thread, with the quote.
Markdown list formatting syntax strikes again: &gt; may be even represented as a void * in &gt; &gt; a. In Rust, we need strong typing to be able to provide You need to remove the line break before `c.`
Still working on shapefile parsing
&gt; Looking at well written Python or Haskell code can elicit this response Haskell?? Huh... I've really enjoyed the new perspectives it gave me, but not being able to read other people's code easily is actually a big part of what made me move away from it after discovering Rust (at that point I had been a Haskell enthusiast for about 2 years). Maybe it's just that the code I tried to understand was not commented well enough, but it did seem to me like common practice to have functions written as one line that calls a 6 non-whitespace-lines long "go" function that recurses twice somewhere in the middle, if the standard combinators weren't enough to express the desired logic otherwise. Short functions in Haskell, even ones with complex generic types, I can read just fine, but I really don't get how to read non-trivial recursive functions.
My guess is that it uses SAX while all the others are DOM.
Idk, 2 years? I recall dub being fairly popular, but it was far from the official solution and it was still quite new. I don't remember exactly how it worked though and I remember not liking it for some reason, though I can't recall why that was. IIRC, it was part of a big HTTP stack thing, but it's been awhile. I might look back into D at some point though.
Ah, awesome; thanks for your detailed comments.
Hi, I am currently using windows. Is that going to be a problem?
Yes, I am! I will take a look at that in 30 minutes or so. Is there a way we can communicate if I need something? Or just use github?
Haha that's interesting. Thanks for sharing!
We're aiming for yearly, around the 1.0 anniversary on May 15 probably. [We have a Community Team tracking issue for planning the 2017 survey](https://github.com/rust-community/team/issues/28).
But rust also hides irrelevant syntax through inference, elision, and other implicit semantics. You can also hide these details through your own planning of software design. I want a language that I have a great breadth of semantics at my disposal, even if half the time I'm only using basic control flow and staying clear of the type system. The point is that the seemingly innocuous curly braces actually introduce meaningful scoping semantics. In conjunction with closures, pattern matching, variable bindings, there are things I am able to express. The meaning is right there on the page. Even if I'm not trying to solve systemy things, and am using Python where it shines, it's denying me certain semantics because of its own affinity to a conservative "cleanliness is next to godliness" syntax. Take things away and sure the code seems to look cleaner. But now more is just hidden away from me, and at the expense of semantics which are no longer afforded to me. Given what I've experienced through racket, c++, ocaml, JavaScript. It's hard to take Python at face value without feeling shirked. And don't get me wrong, I greatly value Python for being miles ahead of bash, which is semantic cruft without design or planning. And I greatly value the niche of scripting.
Ah, thanks for pointing out the pinned post; I hadn't noticed that! ~~Personally, I enjoy the /r/learnpython, /r/Python separation, as I browse the two at different times for different reasons. /r/Python is for keeping up with community news and announcements, of course. I found /r/learnpython after I had a decent amount of Python experience, but I still post their occasionally when learning a new package or something similar. It's less stress to post a "noob" question along side other noob questions. Most of the time I spend on /r/learnpython is to help other people use data packages like `scipy` and `pandas`, as its a fun way to practice using features of libraries I otherwise don't have exposure to.~~ Now that I've thought about it, I think the pinned post is better than the full separation of subs. It seems to provide all the benefits, but it also doesn't completely ostracize the new-comers, and provides visibility so more experienced people are encouraged to participate in providing help if they want. 
Cheers!
I tried it, but I couldn't get it to work with the markdown image syntax. Just embeding the svg directly does seem to work though. (the markdown parsers sees it as html/xml and wont touch it.)
I am working on a [ZMachine interpreter](https://github.com/mckinnsb/rusty_z) in Rust which I plan to also make web-compatible using emscripten. Future goals are to extend the version support all the way to version 8, and then maybe look at generalizing the VM ( if possible ) to also play newer formats of IF games, with the end goal being being able to play any IF game, anywhere ( as long as the platform can handle it ).
Could a regex-based rule-checker tool similar to Mercurial's [check-code.py](https://www.mercurial-scm.org/repo/hg/file/tip/contrib/check-code.py#l3) be a lot faster than the equivalent Python script? It seems like `RegexSet` would be helpful there. Or would just calling ripgrep be possible / better somehow?
&gt; Note that if your Rust library doesn't contain any platform-specific code, there is absolutely no need to test it on all platforms. I agree! Most crates don't need to be tested for *all* targets, however ... I would advise to at least test your code against a 64-bit target *and* 32-bit target though. I've seen a few crates that pass all their test suite on e.g. 64-bit Linux but don't even compile for 32-bit Linux because the author assumed that `c_ulong` is always `u64` or something like that. You might uncover some omission like that in one of your dependencies if you do that. And if you are directly parsing bytes into `struct`s and/or transmuting `struct`s then (I hope that you know what you are doing and) it wouldn't hurt to also test on a *big* endian architecture (x86 is little endian) to check assumptions about the memory layout of `struct`s.
I suspect that it would be possible to make a proven-sound safe Rust sunset and a verifier for MIR for that sublanguage, but that would take quite a bit of work. On one hand a good soundness proof &amp; mechanized semantics for Rust would probably allow us to prove that libcore etc. are safe for a relatively small extra effort, but that's still a very significant effort (probably a few years of work). Of course, we need some way to isolate untrusted Rust code from "all safe code ever written", and we need to not screw that up Java-style, but it is probably *possible*.
I've just submitted a [Rust code-generator for Thrift](https://github.com/apache/thrift/pull/1147). There's more work to do, and hopefully it'll get in after I've addressed all the review comments. Note: Rust client lib is here: [rift](https://crates.io/crates/rift)
If you are really serious about security then the only good way to handle untrusted code (such as plugins) is to run it in a separate sandboxed process. Statically proving code to be safe to run is very much non-trivial, and failures are always catastrophic. Google has a reasonable looking [design document](https://dev.chromium.org/developers/design-documents/sandbox) for Chrome sandboxing, that would be a good starting point if you want to do something similar. If you are going to compile (even partially) some untrusted code, then I would strongly recommend to also run the compiler in a sandbox of its own. I don't believe that rustc is designed or hardened to handle malicious input safely. On the other hand if you are content on running on a single CPU architecture (like x86) then I think distributing precompiled binaries should be feasible, even across different operating systems. If you need to support more cpu archs then I think nacl/wasm is your best bet.
Please don't do that. We should just fix the linking story for rustdocs.
Nowadays everybody enforces coding standards which indent blocks anyway, so the curly braces are just obsolete noise.
Working through the book "Implementing Functional languages". [I'm writing a graph reducer from the book in rust here](https://github.com/bollu/graph-reuduction) Rust is interesting since it provides cool primitives, that I can be reasonable sure that my implementation is correct. I'm hoping to benchmark this and push performance with Rayon.
with the first solution I get a "P is never used" error Edit: Your second solution looks promising, but my filter implementations now raise errors since Is2D is not sized 
I'm a neophyte in Rust but used to work with Arduino and microcontrollers in general, I'm wondering why it could be a good idea or a good move for the future to jump in.
Safety, C-like performance, zero cost abstractions. Mostly the same reasons you would use Rust for on other things. Keep in mind Rust on Arduino isn't as well supported as C++ - AVR requires a patched compiler and LLVM, and ARM needs something like xargo to set up a cross compile environment.
Where is the link on crates.io to the repository for rift?
So many people to thank - rust was great to me in 2016, powering the development of habitat, and bringing so many moments of tiny joy. /u/stevekabnik1 - for the documentation, so much documentation. /u/burntsushi - for regex, and so many other excellent crates /u/kbknapp - for clap, without which habitat would be so much less cool. Sean McArthur and Jonathan Reem - for hyper, which makes http safe and warm. Ning Sunn - for the rust implementation of handlebars Alex Chrichton - for the rust implementation of TOML, and for the SteadyTime implementation, which is so useful in distributed systems. Rust is s great community, one I'm proud to be a part of. Thanks! 
Thank you, concise and precise answer, I'll try this tonight :)
JavaScript ASI is problematic because it's [easy to screw up](http://benalman.com/news/2013/01/advice-javascript-semicolon-haters/), either having a semicolon inserted where you didn't expect one or not having one inserted where you did. But that's JavaScript. Python gets it right with a simple rule: newline always implies a semicolon except within a pair of matching delimiters, i.e. `[]`, `{}`, `()`. Most long lines involve things like function calls or long dict/list literals, so you have a delimiter anyway; if not, like if you have `x = foo + bar + baz + ...`, you can just add parentheses. (Or use the backslash newline escape, but that's ugly.) Though, it works best combined with Python's indentation sensitivity. Otherwise, there'd be a pitfall: a = foo + bar would, under the above rule, be interpreted as two statements, one setting `a = foo`, and one throwing away `+bar`. But Python rejects it for inconsistent indentation.
I've been thinking about writing a lambda calculus interpreter in Rust. Now, I know simple lambda calculus interpreters are hardly new, but the long term goal is to make it a lowest common denominator VM like the JVM, but designed for purely functional languages. The main goal is optimization. I want this VM to provide a variety of automatic optimizations to make programs faster. The first goals are: - Dependently typed I want it to have a type system because there are optimizations one can do on typed languages that can't be done on untyped ones. And if it's going to be typed, it should be dependently typed, because it preserves the most information. Plus I'm sure there are *some* optimizations you can do with dependent types, but I'm not sure on that. Plus, pi types and sigma types generalize universal and existential quantification respectively, meaning you get a lot of type system features very easily. - Embeddable I want the VM itself to assume very little about any primitive types or runtime system. This is mainly so that the main implementation will have to dogfood quite heavily. The garbage collector needs to be easy to swap out for other ones. And it needs to be possible to embed custom optimization patterns into the VM. - No data types For now at least, I'll start off with having all non primitive data types be church encoded. The idea is that this avoids having to have a spec for data types in the bytecode. All data will just be functions, so it's not necessary to create a concept of custom data types. This will not likely stay this way. But the theory is that maybe the VM can recognize what patterns data structures commonly form, and internally convert these church encoded values into regular data. The advantage to this approach is that data types can be aggressively inferred, and things that you wouldn't ordinarily have written as data types can become data instead of costly functions. Point being, it's possible for this to be an optimization, not a regression. Later goals are: - Lambda optimization I want to research how to optimally apply lambda reductions. Applying them blindly and fully results in unreasonably large generated code. And recursion is quite hard to effectively optimize in lambda calculus. But ultimately, I think this will be one area that this system can outshine GHC Haskell. GHC fails to specialize and inline across module boundaries quite often. With a VM that has access to all the lambdas it wants to optimize, it can do as much as possible. - Inferred and explicit memory management It seems to me that pure languages have a ton of room for memory optimizations that currently aren't really used. Rust-style lifetimes are often easy to infer. Immutable operations can often be translated into faster mutable ones when you know you have the last reference to an object. Stack vs heap allocation can often be an obvious choice. These memory semantics should be possible for a program to state explicitly, and they should be inferable when possible. - JIT compilation Once you have a bunch of lambda optimizations done, you can analyze which code paths are being executed most, and JIT compile them. With the lambda reductions already performed, you can hope that the code is already optimally inlined and specialized, meaning the JIT can be most effective. JIT compilation is something that would benefit Haskell quite a lot, since GHC's optimizations can be quite bad in the face of a lot of type classes and polymorphism. Some reservations I have: - Strict vs lazy This is something I've struggled with myself quite a bit. I just can't decide which is the better default. I'm tempted to say "no default; it must be specified by the program in all cases." But that would bloat the size of the bytecode. EDIT: I also can't help but feel that there is a larger generalization of these two that would be more useful to implement. - Type system While the dependent type system sounds great in theory, I can't help but feel that it just won't help much. I'm tempted to just throw it out and go untyped. EDIT: One concern I have of dependent types is whether or not to go the `TypeInType` route. It's technically incorrect to say `Type : Type`, but it's hard for the VM to be useful without allowing `bottom`, in which case, I might as well go ahead and say `Type : Type`. - AOT compiling It may be smarter to do AOT compiling. If the lambda reductions are as good as I hope, the JIT compilation may not actually have much benefit over AOT compilation. --- Anyway, I think this is the perfect kind of project for Rust. Implementing a fast and optimizing VM sounds like the a great job for a safe systems language. My goal this week is to just get a very simple untyped lambda calculus interpreter written.
That's why I qualified my statement with 'well written'. I fully agree that you can make a mess in Haskell easily.
Rust is more safe than C(++). But that's just tip of the iceberg. Rust is more productive than C and can express some abstractions better than C++. But let's say you don't do security-critical thing - just some hobby project. You write some code, upload to Arduino and... It does very weird things. You can't wrap your head around it. You debug day and night. And after a lot of time spent, you buy debugger for $50 only to find out it was buffer overrun overwriting some unrelated variable (which happened to be next to the buffer in memory)... This is true story that happened to me, except that I didn't have to pay $50 because my customer had the debugger around. But even then, debugging bare-metal is more difficult than debugging something which runs in OS.
I've just found that post which describe a very similar problem https://www.reddit.com/r/rust/comments/3n7maj/help_array_of_function_pointers/ So one solution which does not require to add a lifetime to the Action struct is this code : struct Foo&lt;'a&gt; { dummy: &amp;'a mut u32 } impl&lt;'a&gt; Foo&lt;'a&gt; { fn new(d: &amp;'a mut u32) -&gt; Foo&lt;'a&gt; { Foo { dummy: d } } fn do_action_one(f: &amp;mut Foo) { *f.dummy += 4; } } struct Action { a: fn(&amp;mut Foo), } fn main() { let mut r: u32 = 5; { let mut p: Foo = Foo::new(&amp;mut r); let a: Action = Action { a: Foo::do_action_one }; (a.a)(&amp;mut p); } println!("r = {}", r); } The difference is that do_action_one() does not take parameter &amp;self , but &amp;Foo instead. I don't really understand why. The only thing i'm sure about is that i'm very far from understanding lifetime in rust. And IMHO the rust book and nomicon are very incomplete about this subject : it's unfortunate. Perhaps i should try to read the compiler sources !
I was working on a parser for Xbase files before. I guess you already have most of that sorted?
This is still work in progress, I'm open to feedback on the API (or anything else by the way) :)
Looks interesting; I love playing around with my epub books, and I'm always looking for better ways. Your documentation link ("https://docs.rs/epub") seems to be broken?
Maidsafe is a UK company that has been hiring Rust developers. Not aware of any others at the moment as I live outside the UK, but occasionally there will be job-related posts in this subreddit.
If your background is C++, you could always join a C++ shop, and then try to steer them towards Rust. I'm trying to do that at my workplace - I've rewritten a couple of small C++ apps in Rust as proofs of concept, and I did a Rust presentation a few months back. It's slow going, but I keep plugging away!
https://news.ycombinator.com/item?id=13302210 &gt; Right now, we are hiring new engineers for the following areas: &gt; - RUST Backend Developer &gt; […]
How do you handle links to images inside the content? Do you leave them unchanged?
Wow, that's an awesome project! Please consider to write a series of blog posts, I would love to read it. And yes that's the perfect kind of project for Rust ;-)
The numbers [here](https://github.com/serde-rs/json-benchmark#-cargo-run---release) are a bit easier to compare than the bar charts. The two major missing Rust features that prevent us from competing with RapidJSON in certain cases are SIMD support tracked in [#27731](https://github.com/rust-lang/rust/issues/27731) and likely/unlikely annotations tracked in [#26179](https://github.com/rust-lang/rust/issues/26179). I don't think specialization as mentioned in /u/erickt's comment accounts for anything - we already manually specialize the relevant cases by having separate to\_writer/to\_vec/to\_string and from\_reader/from\_slice/from\_str functions. That said, we hold our own better than your comment implies. For twitter.json which is of the three files definitely the most representative of real workloads in my experience, we serialize 44% faster than RapidJSON - almost twice as fast as the fastest C/C++ JSON library. Also if you are willing to compare our struct serialization with RapidJSON's DOM serialization (i.e. compare the *default*, *easiest* approach to serializing JSON in Rust vs the *default*, *easiest* approach to serializing JSON in C++) we are comfortably faster than RapidJSON whether compiled with Clang or GCC across all three test cases. The reason you don't see RapidJSON SAX numbers on that page is that it is so horrible to implement that nobody has done it. The magic of Serde is that it makes the inherently-faster SAX approach so easy to use that it becomes accessible - `#[derive(Serialize, Deserialize)]`.
Thanks for the kind words! Y'all are awesome!
You have to use bitwise operators. In Rust, `1 &lt; x &lt; 5` would evaluate as `((1 &lt; x) &lt; 5)`, meaning that the second `&lt;` operator would be trying to compare a Boolean and an Integer! You can read more about operator precedence [here](https://doc.rust-lang.org/reference.html#operator-precedence).
FSF themselves [recommend Apache 2.0](https://www.gnu.org/licenses/why-not-lgpl.html) license for libraries which "implement free standards that are competing against restricted standards". However, when implementing new technology or unique features it's better to stick to copyleft since it gives a "boost to community". The OS should be copyleft no doubt though.
Yes, this library doesn't touch the content, it just (tries to) make easier to bundle the content in an EPUB file.
I see. I share most of your worries BTW and sorry for bad experiences with some groups we're ashamed of. Anyway - that the thing, that as soon as you start anything remotely political and especially after using strong words in broad context, people will understand you in many different ways, and trouble begins. I'd be very happy to discuss more (especially over a german wheat beer :) ) but we would be more and more off-topic.
Can someone explain how macros 2.0 will further improve on 1.1? Another thing I'm curious about is how Rust's macros compare to Nim's templates and macros. Nim has really elegant syntax for this kind of thing, so I'm wondering what tradeoffs they made. And while we're at it, what's the macros story in D language?
Special thanks to /u/dbaupp, who used to show up in times of desperation to shed some light onto my childhood rust issues and explain very carefully why the things I wanted were strange ;)
I'll try to run some tests when I get to my Win machine at work. Although I'm not and advanced Parallel user, so don't expect any thorough investigations. If you have any suggestions or some use-cases worth testing, let me know, I'd be glad to help.
Hi /u/deathkid1278, you probably meant to post this to /r/playrust.
They should have written it in rust.
Where can I find the documentation for this feature?
Won't help much if they `unwrap` everything.
There's another open PR authored by me for it.
Whoa whoa whoa hold the phone. This is possible?
I've been writing a library for parsing files in a specific format and have not had to use a lot of lifetimes for this (everything is single threaded, mostly just using `'static` things as needed). I'm now running into an issue with how I'm setting up my API. I have a `Stream` struct which contains a `std::io::Read` and tracks information as it's parsed. As elements are read from the `Read` I want to place them in a hashmap owned by the `Stream`, but also return a reference to the element. I'm having difficulty understanding how to specify the lifetime to allow this, such that the `elements` map will own all parsed elements but the `read_element()` method would also return a reference to it. Here's example setup: struct Stream&lt;StreamType: ReadBytesExt&gt; { stream: StreamType, bytes_read: usize, elements: HashMap&lt;u32, Element&gt;, } impl&lt;StreamType: ReadBytesExt&gt; Stream&lt;StreamType&gt; { pub fn read_element(&amp;mut self) -&gt; Result&lt;&amp;Element, Error&gt; { //... self.elements.insert(element.tag, element); Ok(&amp;element) } } With this implementation I get errors about the returned reference not living long enough and also trying to use after moved into map. I kinda understand this so I want to specify that the map + values live as long as the `Stream` instance but I'm not sure how to do that exactly. I've tried adding a lifetime to `Stream` but I don't know of a way to specify its usage in the struct itself, since it should really be defined by the `read_element()` method instead. Any tips?
Glad to see you're here! Remember that contributing to OSS is so much more than coding, any participation in the community, technical or non-technical, can have a positive effect. :)
Might be that you're running out of ram and you system isn't configured to over-commit. Rust software still can't handle OOM issues without being written specifically to handle it. there is also the possibility of a hidden unwrap somewhere, as minno noted.
&gt; function-looking bits I should feel bad about this but... [`proc-macro-hack`](https://github.com/dtolnay/proc-macro-hack). This is just a dressed-up version of what Diesel is doing for `infer_schema!`, `infer_table_from_schema!` and `embed_migrations!`. EDIT: Please don't use this. Among other reasons, your users probably don't want to see the word "hack" twice in the Cargo output when they compile your crate.
Shhhhh! ;) (For those playing at home, you can technically hack function-like stuff into custom derive, but it is very hacky)
I found the exercises on exercism.io were very good. If you want to contribute to tantivy I can try and find you good "starter" tickets.
Sorry about that!
The mods sometimes mess with the rules for fun. If it says "no mernes" that is just bad keming and it really means "no memes". If the rules are actually being changed, there will be a post about it (e.g. when the "no memes" rule was temporarily lifted for the last week for some end-of-year relaxing).
Are there any articles explaining all the differences and use cases between 1.0 `macro_rules`, 2.0 `proc_macro`, and the future 2.0 (`macro!`) plan?
Tangential question, but is there any reason that `#[derive]` trait composition (as first-class as any other core language behavior) is using "#" syntax, normally used for annotation/preprocessor directives? I'd expect to see it as markup for external tooling such as integration error message tests or API documentation, but not trait composition which actually impacts runtime logic. I realize that's how it's done in C due to pre-processor actually being *the* tool used to inject behavior, but it seems weird in a modern language like Rust where trait derivation is semantic during compilation proper, and not just code pasted-in by the preprocessor.
not exactly. Here's sort of a rundown. One thing that makes this tough is that we've had various names for various things. In a broad sense, there's been two kinds of macros: "macros by example" and "procedural macros". The former are where you write patterns that expand to code, the latter are where you write Rust code that generates Rust code. So `macro_rules` is the former, we've never had a stable version of the latter. On the "macros by example" front, the situation is that today's macros use `macro_rules`, the eventual ones will use `macro`. Or maybe `macro!`. It's been contentious. But the idea is, these are the macros that satisfy most cases: you write some stuff and it expands to some other stuff. On "procedural macros", you write Rust code going from `TokenStream -&gt; TokenStream`. Or at least, that's the interface that things are moving towards. So for 1.1, the only thing you get are `TokenStream -&gt; String` functions, so you have to travel through a `String` to do the macros. That's not great. Eventually, we'll provide a nicer interface for this, and that's "macros 2.0". The core idea is the same: you write arbitrary Rust code that generates more Rust code. That's a high-level overview. It's late at night; I might have made some errors.
`#` isn't anything related to a C-style preprocessor, it's just the character they chose for attributes. A lot of the other sigils that would look decent were already taken for other things in early Rust ;)
I believe you could write a proc macro that evaluates macro_rules! syntax, but both macros would be expanded at different times when compiling. My guess is first macro_rules and then proc macros but im not sure.
Awesome! I would love to look at what you've done so far; maybe we can collaborate in the future and share notes. I hemmed and hawed over which format to pick first, but I think tradition/nostalgia won out for me :D
Yeah, I just thought I missed something. I'm excited for it to get merged so I can write keyboard firmwares in Rust.
Taken to the extreme, isn't something that takes a token stream and produces another token stream, the definition of a tokenizer? Do you expect macros to fully replace parsing and tokenization?
So elision is involved here. In your old code, `Foo::do_action_one` had the complete signature `fn do_action_one&lt;'b&gt;(&amp;'b mut self: Foo&lt;'a&gt;)`, where the `'a` parameter comes from the impl. The "comes from the impl" is the source of your trouble. In your new code, it has the complete signature `fn do_action_one&lt;'b, 'c&gt;(f: &amp;'b mut Foo&lt;'c&gt;)`. This is the kind of function you need. You'll notice that replacing `f: &amp;mut Foo` with `f: &amp;mut Self` recreates the original issue. This is because saying `Foo` in a type signature will implicitly mean `Foo&lt;'c&gt;` with the `'c` lifetime parameter on the function itself. On the other hand, using `self` or `Self` will use the type from the impl, which is `Foo&lt;'a&gt;` where the `'a` was global to the impl. It's helpful to figure out what lifetimes elision may have inserted to track down these issues. The book doesn't delve into this because it's a very niche thing to do -- using UFCS to refer to methods and use them as values when the self type has a lifetime on it. I suspect you do understand lifetimes in Rust, this is just one of those funky edge cases that are fine to not understand :) A better thing to do here would be to make `Action` into `Action&lt;F&gt; where F: FnMut(&amp;mut Foo)`, or have its first field be `a: Box&lt;FnMut(&amp;mut Foo)&gt;`. Accepting only function pointers is rare in Rust; usually you will make your API accept closures to. In which case, you can just have `Action::new(|a| a.do_action_one())` instead.
/r/playrust, without the underscore.
Oh no, I tried to help and made it worse. Editted. Thanks for the correction!
Thank you. Nice share. I've been using Rust mostly for idea prototyping and commandline utils so it's really nice to see example code in a larger, lower-level systems context.
Thank you. I use references so rarely that I actually didn't know you couldn't reassign a reference. My code compiled, but I didn't actually think to walk through it, which is my failing.
I think you're right :)
Found this earlier: https://www.reddit.com/r/rust/comments/5ljxyo/whats_everyone_working_on_this_week_12017/dbwgmza/
Which game?
Thank you for this very complete answer. I understand from your answer that if a struct has a lifetime bounded to it, it's not possible to use a method as a function pointer (if there's no lifetime bounded to the struct containing the function pointer like in the example given by RustMeUp below). Is it right ? If we exclude traits, I thought method and function could be used interchangeably and that a method was just a syntactic sugar, but it seems that's not the case. Else, as you suggest in a comment below, to rewrite the function signature with no lifetime elided is very helpful to understand such a problem. That's a good advice that i will try to remember. 
Why did you separate `Entries` and `Reader`? Wouldn't it be sufficient to `impl Iterator for Reader`?
I read "blond"...
I want to thank /u/shepmaster for being the top user on [StackOverflow's [rust] tag](http://stackoverflow.com/tags/rust/topusers). He does an awesome job moderating, asking and most importantly explaining! Additionally, he helped me getting into the StackOverflow-thingy as well, which I really appreciate. I also want to mention /u/nikomatsakis again. He helped me a lot when I was working with his parser-generator lalrpop; without him my bachelor thesis would have been way less fun. So thanks for that! He is also responsible for so many great crates (including the already mentioned lalrpop) and great explain-blog-posts.
&lt;333 !!
That seems to be about building gtk apps *on* windows. I want to develop on linux and simply build *for* windows :D
Pandemic: The Cure - it's the dice-based variant. Lots of fun, quicker to play a round than the original but maintains a similar enough mechanic.
You have these options: * Pass a reference to the value into the handler function. That gives the handler read-only access. * Pass a mutable reference to the value into the handler function. That gives the handler read and write access, but the main function can't access modify the value again until the reference inside the handler function goes out of scope. * Move the value, permanently changing the ownership from the main function to the handler function. * Clone the value, giving an independent copy of it to the handler function. This gives the handler read and write access, and writes don't affect the original value. To show you more specifically how to do any of those things or which would be most appropriate for your purposes, it'd help to have a code sample.
The way I do this is by recreating a program I've previously made in another language. It really helps if you already understand your specific problem domain, because then you're just learning what's different about Rust than the language(s) you already know.
Wow this is awesome! I will give this a try the next time i find a free slot for it – i was playing around with exactly the same but could not get something serious done – great!
yeah but its awesome nonetheless. Not everything needs to be production ready to be a cool idea ;) //EDIT: I had this in mind ever since i watched one of the episodes of Jonathan Blow showing something similar in his language ... just for the sake of completeness if someone is curious: see section [Data-Oriented Structures](https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md)
Not sure cross-compilation is a really good idea...
Thanks for the feedback! I'll update the crate metadata so that the homepage, documentation and repository links aren't needlessly duplicated. Re time, I ended up with `chrono` after seeing the link in [https://github.com/rust-lang-deprecated/time#notes](https://github.com/rust-lang-deprecated/time#notes): would using `std::time::SystemTime` be more idiomatic?
For your issues with the object implementing `ToTokens` that can only be used once, have you tried to use references to the same object, as I did [here](https://github.com/antoyo/mg-settings/blob/master/mg-settings-macros/src/settings.rs#L242-L243)? Beware: it may not work if the content of the `quote!` macro is too big.
Yeah that actually works, thanks. I honestly did not expect that this would work at all. 
As for you first question: the GTK status icon implementation used some old X protocol which they [wanted to get rid of](https://bugzilla.gnome.org/show_bug.cgi?id=734826), and the Gnome people got rid of the system tray completely in Gnome 3, so they haven't bothered to implement anything new. This has [frustrated](https://trac.transmissionbt.com/ticket/3685) at [least](https://github.com/abrt/abrt/issues/836) a [few](https://github.com/nicklan/pnmixer/issues/81#issuecomment-262702842) application developers. It would appear that GTK does not support any system tray icons (Gnome says they should be replaced by persistent notifications). If you want to use them anyway, it seems you'll need to use platform-specific APIs, though I don't know what those would be.
I've similar thoughts, but I think the best approach is a separate scripting language. The main reason, from a security perspective, is IO permissions. A plugin should somehow be restricted as to what files it can read or write, what ports it can read or write and so on. Or else, its not really safe to load a plugin, it if can spy on you (send data to an arbitrary server), destroy your files and so on. The Rust program should be able to decide what file handles and port handles it gives to the plugin. I think this can be done through a carefully designed API for an embedded interpreter. I'm working on designing a VM that is built specifically to be embedded in rust, in a safe way. But don`t get excited, if it ever comes out it will take quite a while because its a very ambitious project and I don't dedicate enough time to it. Regardless, I think this is the optimal solution. A portable Virtual Machine that can be easily embedded in rust programs, and that has restricted API, similar the the API available in web browsers. On top of the web browser like API the VM has access to registered rust functions, meaning it can only call the functions that the rust programmer specifically allowed. If the rust programmer only exposes a safe API to the VM, the plugins can only do safe stuff. That way, if a user downloads an plugin that tries to do some unsafe stuff, the plugin will just crash, not harming the users system. Just think of that as a very lightweight embedded interpreter with access to about the same API javascript has on the browser, plus access to per-defined rust functions. That would be the ultimate plugin architecture.
I'm currently writing keyboard firmware in Rust for ARM!
This is exactly what I was looking for just right now! Thank you :)
You use a relative URL, not an absolute one.
For anyone else who thought SoA stood for Service Oriented Architecture, in this context it's [Structure of Arrays and Array of Structures](https://en.wikipedia.org/wiki/AOS_and_SOA) :) TIL!
I tried something similar in a hobby project, but I never managed to use a proper for-loop for self-inspection. I wonder if one could use custom_derive. Would something like the following work? (EDIT language) https://gist.github.com/f770692a05471fe6d53ecdf7dc3c8668
Docs are few and far between. There are a few blog posts which are useful tutorials [Post 1](https://cbreeden.github.io/Macros11/) [Post 2](https://maikklein.github.io/post/soa-rust/) *shameless shelf promoting* I wrote a [crate](https://valarauca.github.io/macrohelper/macrohelper/index.html) to make parsing marcro input easier
I didn't read everything but I think `InsertField&lt;T&gt;` would only work for unique types. In practice you probably have a lot of duplicated types.
there is a svgbob(https://github.com/ivanceras/svgbob) and rust version svgbobrus(https://github.com/ivanceras/svgbobrus), They are similar to goat.
ISPC also has this feature integrated and in fact will do chunks of 8 floats for each component which seems to be the best way to go for SIMD.
Miller Maxwell (a recruiter) are advertising a [Rust / Java job](https://www.linkedin.com/jobs/view/256713288?trkInfo=searchKeywordString%3ARust%2CsearchLocationString%3A%252C%2BLondon%252C%2BUnited%2BKingdom%2Cvertical%3Ajobs%2CpageNum%3A1%2Cposition%3A1%2CMSRPsearchId%3A32e9dc03-82a0-4710-a289-e58ebf33f550&amp;refId=32e9dc03-82a0-4710-a289-e58ebf33f550&amp;trk=jobs_jserp_job_listing_text) at a prop trading house in London, so it's maybe worth getting in touch with them if you're comfortable with finance / fintech / HFT
I think the important idea in Jai is that you should be able to transparently change SOA to AOS *without breaking any other code*. Do you think it will be possible in Rust?
Yes, I think SoA is the more general concept. In D I also wrote an ECS with a SoA library. Essentially every possible combination of components that you would use would get their own "SoA struct". Filtering is done completely at compile time, I would just say give me all components that have a Position and Velocity component and return their iterator. Then I would just zip and chain all of them together. I have also implemented it in C++ https://maikklein.github.io/post/2016-01-14-Entity-Component-System/ but it fell short because the `range` library that I was using was terrible slow to compile. I guess now I have to implement it in Rust too. I think I will also study specs to see how you are iterating over the components in a cache efficient way. 
The insecurity impact can be limited. Sandbox whole game so the worst thing plugin can do is harm game experience.
Pony prevents deadlocks - there are no locks, therefore no deadlocks. Proven to do so mathematically, even.
Eh ... I like the "night theme" well enough, though it's always nice to have a corresponding "day theme" for use in bright or high glare situations. I certainly agree with you on thehe drop shadow, though -- it really hurts readability in body text, and doubly so with a low contrast theme as seen here. Interesting content, though!
I agree. It would probably require you to wrap each field in a newtype.
Another public service announcement about terminology: Structure of Arrays is a commonly used building block in data-oriented design (DOD) which is different from data-oriented programming which is different from data-driven design. Data-oriented design means designing your data structures and algorithms in accordance with the hardware constraints and the data access patterns of your application. (Rather than concentrating on abstract separation of concerns, object orientedness, etc.) This is beneficial for cache performance when processing the data in tight loops, (and may also yield for better parallelizability) so it's a commonly used design pattern in video games (and I think in physics simulations and numerical programming too.) I think these kind of design patterns are very relevant to Rust, since we have quite a lot of users who use Rust for performance.
If you have a collection object that is either AOS or SOA (depending on macro attributes), which only exposes methods like `iter_mut_{field_name}`, then it should work, I think.
&gt; If we exclude traits Actually, `&lt;FooType as BarTrait&gt;::method` works. But yes, methods are not interchangeable with `for&lt;'a&gt;` function pointers when there are lifetimes on the self type.
MIR trans is on by default; we've already gotten stack-based drop flags with it. We don't have MIR borrowck yet.
Hey Carol! I didn't mean that theory needs suplementing, actually the reason why I said I liked the first version more, was that it looked a little more brief and compact to me. Second version is definetelly better for referencing or learning in-depth, then you are already experienced, but was a little overwhelming to me for some reason. Might just be my personal impression. What I meant it that, you can not learn just by learning (I know, a paradox). You need to put the theory to practice. The book contains a few good projects, but that's not enough.
There's also the `lazy_static` crate, though yes, it's hard to know what's appropriate without a code example.
Have you looked at the other NES emulators written in Rust so far? From moderating this sub, I get the impression that everyone &amp; their dog is writing one. 😎
I haven't, and I kinda don't want to because I'm trying to design the emulator by myself (just by looking at the hardware docs and not any emulator implementation details / tutorials) so I don't want to inadvertently get influenced by other people's implementations. It's probably a bit silly of an approach but I feel I'll learn more from it. So what I'm looking for is more like a hint rather than a complete solution to the problem above. &gt; I get the impression that everyone &amp; their dog is writing one. Who can blame them (us) though? The NES is amazing :D! So many childhood memories.
[seriously.](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)
&gt; There are no locks, therefore no deadlocks. What prevents someone from implementing a lock in Pony? I've seen locks being implemented on top of NoSQL databases, SQL databases and other distributed systems; it seems fairly straightforward to implement them in an actor-based language. Deadlocks are not a hardware issue, they are a software one. A deadlock is a logical bug, any type system which cannot guarantee system-wide progress may allow deadlocks.
Isn't specs' planner.run1w1r(|p: &amp;mut Position, s: &amp;Speed| { *p += *s; }); An example of dispatching the filter at compile time? My understanding is that it looks at the types in the closure and dispatch this appropriately to iterate in all pairs (x, y) where x has `Position` and y has `Speed`, without needing a virtual call.
Just curious, i knew macros were a special case inside the compiler, but do you know what other "special cases" are built into the compiler? Or better yet do you know of anywhere i could learn about how the compiler works. All the posts ive seen are very low level and seem to assume youve read the dragon book witch is over my head.
/r/playrust
Cool project. The feature should probably be "no-default-feature": English has an extra "l" there compared to French ;)
Instead of registering components you would register component groups at compile time. A component group is just a struct of components. And when you do struct print_pos_vel { template &lt;class World&gt; void update(World&amp; w) { w.template update&lt;position, velocity&gt;([](auto&amp; pos, auto&amp; vel) { print(pos.x, pos.y); print(vel.x, vel.y); }); } }; It will look at compile time at every component group that you have registered, filter out the the component groups that don't have a `position, velocity` at compile time ( type list ). Then I get the iterators, chain and zip them. This is very close to the best memory layout that you can have for iteration but it comes with some other problems. I definitely will have a look at specs, I am curious what the memory layout looks like. 
this series is pure gold. i really can't wait for future parts. i did sneak a look ahead to see the code for this part over christmas which gave me something to do updating my fork to match.
It's been paused :/
Certainly... but there are *many more attributes* than just derive, and keywords don't scale well (each new keyword is one more word you cannot use). Random attributes: #[test] #[cfg(test)] #[inline(always)]
ok, thanks for explanation! How does this template system specify if a component needs to be modified versus just read? That's pretty much what `runXwYr` is doing for us. But even without it - our system API is based around giving you zero overhead for selecting the data you work with. &gt; I am curious what the memory layout looks like. Every component is free to use either one of the provided internal storage types (vec, hashmap, dummy), or implement its own. And we don't provide an ability to group the components together.
In the context of programming, DOD always makes me think about the Department Of Defense and Ada...
I did not have a system like that, I would execute the system in a specific user defined order (sequentially). As for multithreading I would just execute each system in parallel, but the 2nd system doesn't start after the first has finished etc. If you query every position, velocity for example I already know how many entities you have. (Because I know all the component groups at compile time). Then I just chunk the iterator and send it to the task system. Similar to what rayon does. (I think) There is room for improvement though, for example if a system only iterates over a few entities then you can't reach 100% cpu utilization. But it wasn't a problem for me as I would use a task system and I always have stuff that I can do. How would this look in specs? You have 5 entities with (Position, Name, Velocity) and 5 components of (Position, Name) Now you want to iterate of all (Position, Velocity) Entity ID 0 1 2 3 4 5 6 7 8 9 Position x x x x x x x x x x Velocity x x x x x name x x x x x x x x x x Could this be the memory layout of specs? And you would only iterate over entities 1, 2, 3, 7, 8. I think this is how most ECS will look in memory. You would essentially waste a bit of cache by loading entities 0 4 5 6 9 because they are most likely on the same cache line.
The article you linked to literally says: &gt; Like most things in JavaScript, the statement termination rules are not very *well* designed, but they’re also not particularly *hard* to understand and use. I am not going to argue about whether you should take advantage of Automatic Semicolon Insertion when you're writing JavaScript, since this is a forum about Rust. But if Rust ever implements ASI, I hope it's not anything like JS's. 
well, kinda [sort of](https://github.com/HeroesGrave/ecs-rs/blob/master/tests/tutorial_tests.rs#L16), but the reason for it is because they can't provide a lean and clean way like we do :P For a simple example, look at the [inertia system](https://github.com/kvark/yasteroids/blob/mastaer/src/sys/inertia.rs#L9). It doesn't need any macro pre-declarations to know what components to process, it doesn't need any new types, it just asks for them directly at run time (inside `arg.fetch`) and works on them.
In case you are familiar with German, I can really recommend &lt;https://github.com/LukasKalbertodt/programmieren-in-rust&gt;. It's a full (still ongoing for this semester) university course teaching Rust (full videos and slides available). It's not a course for programming beginners, so it should not be (too) boring; I still enjoy following it even though I started learning Rust a few months before stumbling over the course.
yeah, and i'm not arguing that you have to use those rules wholesale. i'm simply suggesting that JS ASI would be a good place to start &amp; build on.
&gt;One of the problems I see with this approach (in-system parallelism as opposed to specs's out of system) is possible cache trashing. If you can't guarantee that each component will be accessed in memory in a linear fashion, then the writes would trash the cache line, forcing a subsequent access to re-read it back from memory... yikes! I think you can still calculate the correct cache boundaries but I haven't done that yet. I should probably also look at rayon more closely, I think I saw a `.par_iter_mut()` iterator. &gt;Each of our component storages carry a bitset for the entities that have the corresponding components. When iterating, we only access entities that have all the bits for the required components satisfied, so we aren't reading more than we need to. I also thought about doing it that way. This is basically what I do at compile time, but it actually makes much more sense at runtime. It is way more flexible that way and the lookup overhead should be pretty negligible. How do you handle adding/removing components? For example (Position, Velocity) and you want to add a Name component? I assume you do the same thing I did, and copy the old components to the new storage that has the correct bitset. 
&gt; No, the pace is good. It just goes more in-depth in a specific topic then it used to. I think what you are trying to say is that the new book is not suited for _the impatient learner_ who wants to try stuff right away. I totally agree! For instance, look at [this chapter](http://rust-lang.github.io/book/ch03-02-data-types.html). That's a really good chapter for someone new to programming in general, but for someone already familiar with the concept of basic data types, that might come off as a bit boring. For such a learner, the first book or rustbyexample might be better suited. May be it's time we see a book called "The Impatient Rustacean!" where each concept is illustrated through just one, very short code snippet (optionally linking to the complete example), and covering the bare minimum details of it. Whenever it hits the ownership/lifetime wall, just redirect the reader to The Book. Since you can't learn everything like that, of course.
 pub pos: Vec&lt;Vec2&gt;, pub vel: Vec&lt;Vec2&gt;, pub health: Vec&lt;f32&gt;, It's not particularly efficient to be making three allocations here.
I'm kinda winging it at implementing the instructions -- Not something I've really done before (except for chip-8, which was really simple). I've also got a library for reading blorb files (though looking over other implementations, I think I made it way more complicated than it needs to be). I'd definitely be down for collaboration/note sharing :D
https://www.reddit.com/r/rust/comments/5lbcao/golang_and_rustlang_memory_safety/?st=ixi0e8ky&amp;sh=835fca91 maybe?
The Google fu thing is resolved by searching for Rust Parallel or finding it on crates.io. As for the name, it's not owned by anyone. The original Parallel program predates GNU Parallel. Mine is a Rust implementation of the GNU implementation. Users are free to rename it as they see fit.
Is Corrode really up to something like this? I had the feeling that it was similarly a bit "early".
Yeah, that's the one. Thanks. (I really shouldn't decide that clearing out piled up /r/rust tabs is a good activity for when I'm very sleep-deprived. It plays merry hell with my memory of what came from where.)
&gt; If you want your Rust port of a project to be adopted, you'd better make sure you have buy-in from that project's community. I can't stress how important this is. Getting people to change a project to a new language is hard and time consuming. Unless you have some work to show them it'll be hard to get a community to even consider switching. I've seen some enthusiastic Rust users just open up issues on repos asking maintainers to translate their code to Rust (usually C or C++ codebases). Which is one rude and has actually made people *not* want to use Rust, but secondly it just ignores the costs of engineering and switching languages. This was a fantastic article and the work on Corrode is really cool. I'm looking forward to seeing more!
Yeah you're right! I had to look at my ID to double check that it wasn't DOD.
I wrote the article that Steve linked. The point is less that Go's memory safety is "overstated" - it's more that Go has taken an attitude that security should be solved solely at the language level, so it has forgone what I would consider a best practice by disabling a powerful security mitigation technique. Go is still miles ahead of C/C++ when it comes to memory safety, I just feel that their decision to rely entirely on language level memory safety is a poor one, and I give the example of data races undermining memory safety to give that argument further credit.
Exactly! There's no one-size-fits-all even in documentation!
That could come down to the quality of the transpilers though. If corrode actually works with minimal fixes after migrating, it could win, but you're right, Go already has a head start for this project since the author already learned Go. Either way, I think it would be a cool project to port.
Because Haskell had a ready-made C parser... and that's a more difficult thing to write than it first seems. (There's a Wikipedia article which really illustrates that well, but I'm having trouble googling up the piece of jargon it's named after. As I remember, it has to do with being unable to distinguish token types without processing deeply enough to resolve identifiers.)
Oh yeah, thanks :) 
My impression of languages with type systems like Go and Python is that they have a deceptively easy initial learning curve, but if you're diving fresh into an established project, it becomes incredibly difficult to find your way around without *very* good documentation. There's too much implicitness, at least for my tastes; as a Java developer by trade, it's a rather big turnoff.
&gt; and that's a more difficult thing to write than it first seems Agreed, C is deceptively complex. I didn't know about Haskell already having a C parser, so I'll have to check it out. I assume you're talking about [language-c](https://hackage.haskell.org/package/language-c)?
Ah, cool. Yes, the comments section in /r/rust focused a bit more on that. I just wanted to be clear.
I have to say that my knowledge is a bit lacking, here is what I currently believe: L1 cache: 32KB L1 data, 32KB L1 instruction per core L2 cache: 256KB per core, inclusive L3 cache: 8MB accessible by all cores, inclusive When we talk about prefetchting, I think we just talk about the L1 cache which is 32KB for my CPU per core. If the cachelines are 64bytes wide that would give us 500 cachelines per core. When we iterate over multiple components, yeah I think we can trash our cache but it is only per core and considering that we don't iterate over that many components, I think it will be unlikely that they actually trash the cache. For example if we iterate over 10 component arrays (per core), and if we only prefetch 1 cacheline per component array that would be just 10 out of 500 lines which is 2%. I am actually not quite sure how memory writes happen, if a value gets overridden in L1, if it goes directly to ram or if it will go into L2 and then L3 etc. So I currently believe that this would not be a problem, but feel free to correct me. I am sure that I got something wrong. 
Any reason libclang couldn't be helpful here?
I'm guessing the author is more comfortable with Haskell. Since there is a ready made library for it in Haskell, it really comes down to preference. I probably would have gone the libclang route, but I'm not comfortable in Haskell, so the choice is easy for me.
This kind of positivity has inspired me to push hard for my latest project idea: a fast, scriptable userspace packet filter using Rust (and maybe some Erlang). Thanks Rust community!
I don't know anything about him, but I can confirm that learning new languages isn't that difficult (I use 4-5 regularly, could be productive in closer to 10). However, it would be interesting to see if Rust's strictness gives him enough grief starting out to weigh in on the matter.
The type systems of Go and Python have next to nothing in common. Python is unityped and Go has a real---if inexpressive---type system. Go has very little implicitness when it comes to type safety. (There's some implicitness around untyped numeric constants.) I personally have no problems navigating large Go codebases, but do have a lot of problems navigating large Python code bases unless they are well tested, well documented and idiomatic.
"Rust is" is a meme
Sure, but the examples you gave all are of a different nature than `derive`: - `#[test]` is markup for test code, and is conditionally compiled and run in test environment only. Being a conditional compilation, it's more clearly a pre-processor directive. - `#[cfg(test)]` is another conditional compilation directive. - `#[inline(always)]` is a compiler directive used to give a compiler a hint about how best to internally implement logic, with the caveat that external behavior (except for performance) will not be impacted. Whereas `#[derive]` changes actual semantic production code and obviously alters behavior. It seems as weird to use `#` for it, as it would be to use `#[impl]` instead of `impl`
I also get the impression he would be very open to argument if someone posted a good case for rust in the comments or emailed him.
&gt; Go's structural typing and Python's duck typing both are implicit in nature But Go's structural typing is checked at compile time. A function that takes a `Foo` interface makes it very clear what behavior is required/used. &gt; at least to someone like me who's used to navigating code by looking at the named types involved and finding their definitions easily. Yes, it can be difficult to answer the questions like "what types satisfy this interface?" or "which interfaces are satisfied by this type?" Sometimes you can get away with only using interfaces and completely hiding the concrete implementations. Regardless though, this is a world of difference from Python in my experience.
&gt; Yes, it can be difficult to answer the questions like "what types satisfy this interface?" or "which interfaces are satisfied by this type?" The problem is that I find that I have to figure out the answers to these questions quite often, at least within the OOP paradigm. For completely generic abstractions, that would make it nearly impossible to figure out how they're supposed to work just by looking at them. You'd have to read the documentation to find out how the author meant for them to work, and documentation is not always forthcoming, especially in proprietary projects where the developers would rather be cranking out new features or bugfixes. As a freelancer who is regularly introduced to strange and often underdocumented codebases, I need to be able to intuit as much as I can from the code itself.
Is this a personal or professional project? I'm curious as I'm starting some keyboard firmware for a Cortex M4 and hadn't considered using Rust.
How will these new macro features interact with proposed IDE features like auto completion, goto definition and refactoring? Will this cause any problems, e.g. because an IDE would not know that a macro generated "invisible" extra code? Or is this already considered and probably doesn't matter since the tools would just expand all macros themselves before working?
Yes, I agree with you. It's already been fully agreed upon that Rust is in fact a burrito. I see no need for further discussion.
I asked the author this and IIRC they were in contact with fitzgen about using libclang -- the basic issue is that libclang is buggy and unstable and overall not-very-great. They did want to write it in Rust. At this point I suggested reviving the LLVM C backend so that we can Haskell -&gt; LLVM IR -&gt; C -&gt; Rust :P 
Well, in this case I would prefer `Option&lt;Rc&lt;Foo&gt;&gt;` unless there is a good reason to avoid it. But say you are using something more complicated that an `Option`, for example, then there isn't a way to do it in one step as far as I can tell. Deref coercion only goes so far. It is probably easiest to just do another `match` or `if let` inside one of the arms, something like the second version [here (playground)](https://is.gd/iVA5SZ). The other two versions work as well, but are probably not best practices.
Very cool project! Do you do the shape of the graphics by exact tessellation or do you do an over-approximation of the shape and then draw the exact shape in the pixel shader?
How about `#[repr]`? I think it makes sense to limit keywords to a few fundamental language concepts and make less-used concepts into second-class features. And I also don't agree that the `#` symbol must necessarily indicate preprocessor directives. :)
&gt; Should the Standard Library be #[]-driven, then? I'm not sure what you're asking. When macros 1.1 lands, it should be possible to move all the current "standard" deriving attributes into the stdlib (currently they live in libsyntax_ext). I think that's a good thing. &gt; Why not a derive! macro? `#[foo]` and `foo!()` are already both different forms for the same thing, except the former is capable of existing at the top level of a module and applies to the item immediately following it. This is useful because an item can have many attributes, and something like this: repr! { "C", derive! { (Copy, Clone), doc! { "Blah blah blah I am a very long documentation comment", struct Foo {} } } } ...would just be a silly amount of indentation. :P
Temporarily stickying to make up for visibility loss during the year-end bacchanalia.
These aren't just hypothetical issues with libclang. bindgen has huge problems with certain data types using anonymous unions/structs that libclang exports *no* information about. This has been a problem I've had with bindgen.
IIRC the Go community is larger though, so that might end up eclipsing the motivation of the rust community.
Definitely. And the ecosystem is larger and more stable. There are valid reasons to choose either.
Thank you, I was curious. 
All types inhabit the empty interface (`interface{}`). But not all interfaces are empty. If an interface isn't empty, then whether a type satisfies that interface or not is checked by the compiler. Non-empty interfaces are used much more than empty interfaces.
Thanks! It is, to me at least :)
"autoderef", the thing which lets you treat smart pointers as if they were their contents, only works in specific contexts. In particular, autoderef on `foo` will only happen in these cases: - `foo.bar` or `foo.bar()` - `some_func(&amp;foo)` The second one is a bit more powerful in that it does more than the regular autoderef (and is called a deref coercion). Autoderef will not work on patterns, for example. You have to just nest a second match on `*foo` within it. If you end up doing this a lot, https://crates.io/crates/if_chain might help. Ye olde `box` pattern syntax used to do this for boxes. So you could write `Foobar {foo: box Some(..), ....}` in case `Foo` was a `Box&lt;Option&lt;Foo&gt;&gt;`, and it would work. There was talk of making `box` patterns run arbitrary derefs so that it can work with `Rc` or whatever. But `box` syntax is unstable until the rest of placement new can be figured out, so that will take some time to resurface.
Maybe convert some other language (e.g. https://github.com/php/php-src) source code to Rust and check if tests from projects written in that language passes.
Ah yes thank you! I was missing that I was returning a reference to the local alias which was no longer valid.
I think [Programming Rust](http://shop.oreilly.com/product/0636920040385.do), the upcoming O'Reilly book (currently available as an early, incomplete draft) is a good introduction for programmers with C++ experience.
Yes, there have been some RFCs about this, but they haven't gone through. It's a lot of work.
Also can read it via https://www.safaribooksonline.com/library/view/programming-rust/9781491927274/
To follow on to your suggestions, there's a section of AreWeLearningYet for scientific computing, which is kind of a catch-all for numerical computing + other things: http://www.arewelearningyet.com/scientific-computing/
This looks very promising, I was having some trouble with embedded development, this will hopefully make it a bit easier.
Deref is involved in both cases. Only the second case is called a deref coercion, this is just a matter of terminology. Deref coercions are when, at a coercion site (see https://doc.rust-lang.org/nomicon/coercions.html), `&amp;x` where x is of type `T` is treated as if it had type `&amp;U` if `T` derefs (transitively) to `U`. It will not work if you don't use an ampersand operator. Autoderef is when a field/method access invokes as many derefs as it needs to work. It doesn't need an ampersand operator to work.
There are abstraction mechanisms in Go, chiefly interfaces and closures. Go simply lacks a mechanism for typesafe abstraction over arbitrary types (generics).
Thank you this helps my understanding a lot. I modified my code so that `read_element(&amp;mut self) -&gt; Result&lt;u32&gt;` and added a `get_element(&amp;self, key: u32) -&gt; Result&lt;&amp;Element&gt;` and they will be called in succession. I still ran into an error where a subsequent call could not be made as an existing *immutable* borrow had occurred (I am reading the first element, checking some things, then reading all subsequent elements looking for a specific one). I was able to fix it with scoping out the returned references so their lifetimes do not coincide.
There certainly is more noise. The tricky thing to judge is whether that noise is attracting new listeners or it's just a large echo chamber.
&gt; There's a Wikipedia article which really illustrates that well, but I'm having trouble googling up the piece of jargon it's named after. I think you're looking for either [dangling else](https://en.wikipedia.org/wiki/Dangling_else) or the [lexer hack](https://en.wikipedia.org/wiki/The_lexer_hack).
I'm a beginner in Rust world, but here are some things that helped me: * The Rust Book, * Rust in 24-days, * Solving some trivial problems on [CodingGame](https://www.codingame.com)
I think the term that you are looking for is false sharing. I don't think it would be a problem for splitting the array up because we always work on different cachelines but you might be right. I'll do some research and test it myself. It shouldn't be too hard to crate a small benchmark. I will just create 12 components arrays that I iterate over on 1 thread (read/write). Sadly I only have two cores but 4 threads so I just start to split it up in half and I would expect a 2 times speed up. If the speedup is under 2 then I will also run cachegrind to see what is going on.
Just a heads-up: tried the Firefox reading mode then switched back, and noticed that there were a bunch of things missing. Great content and design despite the red and yellow colours that need to be dialed back...
A beautiful summary of a very funny time for me as mod here. Thank you brson. *blushes* I've even been quoted (although the final call to arms was skipped). 😄
Everything I look at looks blue now.
tr;dr
Did you use some tool for the ASCII diagrams?
My thanks goes to *bluss*, not only because of his formidable [nd-array library ](https://crates.io/crates/ndarray), but because he is a really helpful person in general!
Neat. I'm working on project that would benefit from 8086 emulation, and I'm was looking into rust86 or writing my own. Will definitely add this to the list of things to look at.
&gt; One such cleanup: we’ve made a strong start on banishing unions and type punning from the code. These are not going to translate into any language with the correctness properties we want. Untagged unions are coming to Rust.
Maybe that's why not having ASLR is important -- without proper debugger support, your only option is to set address breakpoints ;)
Amazing, but can't help be annoyed that I was a few hours too late with getting something very similar online. Well done!
Here's a nice bookmarklet I use to remove annoying website colors without switching to reading mode: javascript:(function(){var%20newSS,%20styles='*%20{%20background:%20#FFFFFF%20!%20important;%20color:%20black%20!important%20}%20:link,%20:link%20*%20{%20color:%20#0000EE%20!important%20}%20:visited,%20:visited%20*%20{%20color:%20#0000EE%20!important%20}';%20if(document.createStyleSheet)%20{%20document.createStyleSheet(%22javascript:'%22+styles+%22'%22);%20}%20else%20{%20newSS=document.createElement('link');%20newSS.rel='stylesheet';%20newSS.href='data:text/css,'+escape(styles);%20document.getElementsByTagName(%22head%22)[0].appendChild(newSS);%20}%20})();
They're still not going to have the correctness properties that would be wanted, since they are by the very nature, missing information about correctness.
Wow — I did not realize that That Guy was the author of the post until right now! Three letters in a tiny block inside of the post text…
CPython implemented in Rust would be kinda fun
This is an amazing summary. I especially appreciate the time you took in collating all those comments. Kudos!
Thanks for the examples in the playground. I use `Rc&lt;Option&lt;Foo&gt;&gt;` instead of `Option&lt;Rc&lt;Foo&gt;&gt;` because I'm doing a lot of `var.foo.clone()` everywhere in my code, and having to deal with the two variants everywhere is very noisy : match var.foo { Some(rc) =&gt; rc.clone(), None =&gt; None, } `Option::map` doesn't really help in this case, because it takes ownership of the `Option&lt;Rc&lt;T&gt;&gt;` which is obviously not what I want in this case. 
Oooh yeah, your metaphor was the best! What was the "final call to arms"?
`.as_ref().map()` will not take ownership. `.as_ref().map(Clone::clone)` or `.as_ref().map(Rc::clone)` should work. However, `Option` has a clone impl. `var.clone()` will work anyway. Note that `Rc&lt;Option&lt;Foo&gt;&gt;` and `Option&lt;Rc&lt;Foo&gt;&gt;` are different, in the first one the option is shared, whereas in the second one it is not. If you choose to make this mutable later with `RefCell` or `Cell` this will matter more.
Thanks. It was the lexer hack I was thinking of.
I'm the author of the Rust bindings for syslog-ng. I left the company in September, 2016 and it seems like the Rust code is no longer maintained. The Python parser (originally written in Rust) is being rewritten in C. I don't know the reasons, but this looks like a step backwards.
For fun I tested corrode on [lua](http://lua.org/). Wasn't able to convert any files yet unfortunately as corrode couldn't translate enumerations in constant positions :(.
```background-color: #555;``` in stylish.
[removed]
I don't know if Go is _miles_ ahead of well-written C++14. Yes, I know most code in the wild isn't well-written. And even what I considered to be well-written C++14 still made me have bullets in my feet, but far fewer than in days gone by.
Thanks. Good to know that this is on the roadmap.
Thanks. Super useful.
For NTP, I'm not sure that matters so much. I don't think it needs or would benefit from many dependencies. Futures-rs and tokio might be the only things that would really help a project like this. But it can certainly be done with nothing but the standard libraries.
It's harder to port messy code, though ;)
Hey Rustaceans! I've just had an idea about such a library for plotting data vertically to the terminal. What do you think?
Nowadays SIMD in CPU only makes sense for real time systems where you can't accept the latency of memory moves between CPU and GPU (e.g. videogames). If you don't need real time (mainly physical/chemical simulations and deep learning) I would say GPU is way better than SIMD in CPU. I think it'd be nice to have a BLAS Rust library where you could easily switch between GPU (https://developer.nvidia.com/cublas and https://github.com/CNugteren/CLBlast) and CPU ( http://www.netlib.org/blas/ ). This way we'd have an solid industry linear algebra library that we could use for both real time (CPU) , and high performance batch tasks (GPU). That would be basically calling C/C++ code from a Rust library but wouldn't imply reinventing the wheel and it would provide a lot of value.
Python checks the syntax at compile time, that's about it.
It also lacks operator overloading, iterators, and Self, which would be required to make interfaces actually useful.
It's a matter of effort vs reward. It's easier to program a CPU than a GPU, and it's easier to get a machine to actually run a program without having to fiddle with drivers, libraries, etc. Sometimes a 2x performance gain for 1.1x effort is worth it. Sometimes you need a 100x performance gain and it's worth putting as much effort as possible into it. Science is a pretty diverse thing. I believe there are crates binding to BLAS and such but I don't know how good they are. Something to play with!
&gt; Go has very little implicitness when it comes to type safety. There is one bit of implictness that I've always been curious about as a non-Go programmer: it seems for a struct to fulfill an interface it simply has to have the right methods, as opposed to Rust where you still have to explicitly `impl` it. (I think this is sort of structural vs nominal typing?) Has that been an issue for you? On the one hand it seems pretty convenient, but I'd be worried in a large codebase about accidentally conforming to an interface I didn't mean to.
This is great, thank you.
yeah, stop having fun everybody
I'd argue that it's actually very much not silly. Some people seem to think it's just "marketing bullshit", but messaging _is_ important. Good messaging is what brings people to the language, and to the community.
It wasn't going earlier on my mobile for some reason. Disregard this your link is fine now!
In what sense is operator overloading a kind of abstraction? It's just syntax sugar as far as I can tell. Further, you can build your own iterator in Go, it's just not in the standard library because Go doesn't have generics. I'm not going to argue that Go's abstraction is excellent--only that it supports abstraction and you can get a very long way with the tools Go gives you.
You know what's not good messaging? A site where you have to change the style manually to be able to read it.
Sad but unsurprising. I know that if I ever wrote Rust code at my company it would likely be rewritten before I ever left. This happened when we had a Node service - when the developer who built a lot of it left it was rewritten in Java. In my experience developers are very very opposed to learning a new language.
You can write code in any turing complete language. The question is how easy is it. The problem with restricting operators and iteration to built in types is that it means that user defined types are not first class citizens. When you use built in types, your code is much nicer, which encourages people to use them, regardless of whether they are appropriate. Java had this problem too, but it is much worse in Go. Often, I see people new to Go ask questions like "how do I use X data structure in Go?" and the gophers respond "Don't. Just use a slice/map." Go's lack of extensibility means that everything is coerced into a handful of builtin types, instead of using types that are suitable for the problem being solved. The most extreme example of this is when people try to use channels as iterators. This is wildly inappropriate and has a number of downsides, but people still do it because it is the only way to get convenient iteration syntax. IMO, a good test of a language is to what extent the standard types can be reimplemented in that language, and Go fails spectacularly. By this measure, it is worse than any other mainstream high level language I am familiar with.
I think that on supercomputers most of the computational power still comes from CPUs. And if your scientific lab has access to a descent supercomputer, it's much easier to request 10000 cores there than to fiddle around with, e.g., CUDA.
Nowadays with improvements in the cuda library and with the addition of new features from openMP 4/4.5 and with the start of widespread adoption the openACC library maybe in a few years would be fairly easy to start porting code to GPU gradually without much too disruption.
&gt; You can write code in any turing complete language. I don't disagree, nor did I make a contrary statement. I was responding to your original point "Go has no abstraction whatsoever". &gt; The problem with restricting operators and iteration to built in types is that it means that user defined types are not first class citizens. When you use built in types, your code is much nicer, which encourages people to use them, regardless of whether they are appropriate. Java had this problem too, but it is much worse in Go. Yes, Go has different syntax sugar for builtin types vs user defined types. I completely disagree that extending the syntax sugar to user-defined types would result in code that is "much nicer". In the particular case of operator overloading, I've only ever seen this cause problems--it's never contributed to code clarity (in my opinion). I think extending the `range` keyword to user-defined types would be a fine thing, but it would only make the code a little nicer. To be clear, you can iterate over user defined types in Go, there just isn't syntax sugar to support it. &gt; Go's lack of extensibility means that everything is coerced into a handful of builtin types, instead of using types that are suitable for the problem being solved. Perhaps, but this is because it lacks abstraction over types (generics) as previously mentioned. I'll also add that you can build any data structure in Go, you'll just have to choose between type safety and reuse (unless you want to do code generation, which is another can of worms altogether). The advice "don't do that, just use a slice" is typically in the context of premature optimization--they're cautioning newbies against building a data structure which likely won't yield the supposed performance gains over a simple slice. &gt; The most extreme example of this is when people try to use channels as iterators. This is wildly inappropriate and has a number of downsides, but people still do it because it is the only way to get convenient iteration syntax. I agree this is terrible, but it's hardly a slight against Go. "convenient iteration syntax" is an awful reason to use channels as iterators. I suspect these hypothetical people are doing this because they aren't aware that there are other methods for iterating besides the `range` keyword, but this is conjecture, of course. &gt; IMO, a good test of a language is to what extent the standard types can be reimplemented in that language, and Go fails spectacularly. By this measure, it is worse than any other mainstream high level language I am familiar with. I completely agree that Go fails this test. I completely disagree that the test indicates anything about the quality of the language.
Hey Raph, I was recently looking at your parser. Were you planning on adding a maths extension like the ones used in Jupyter/MathOverflow/StackExchange/RStudio? It would be great for academic writing :) It would be relatively simple: anything between `$ ... $` should be treated as TeX inline maths, and appear verbatim in the output (including dollar signs), so that something like [MathJax](https://www.mathjax.org/) or [KaTeX](https://github.com/Khan/KaTeX) can pick it up later and render it. Similarly, `$$ ... $$` is for display maths.
I'm a *case-*insensitive guy ;)
Ah sorry if that wasn't clear. I remember a talk about C++ where the type system was said to: help you protect against Murphy, not Machiavelli. The point was what in C++, and really any language where you can manipulate raw memory, the type system helps you protect yourself against accidents, but cannot help you protect yourself against a determined developer ready to twiddle bytes to get his way. Murphy stands for the accidents and Machiavelli well-planed insidious abuses (such as `#define public private` which while theoretically forbidden, works in practice...).
Temporarily stickying to make up for visibility loss during the year-end bacchanalia.
I wonder if there are Oleg-like tricks that can be played with `macro_rules!` for this purpose—I know he's done some things with R5RS hygienic macros that were thought to not be possible.
[removed]
I think he believes Rust can't break at runtime and wants to have the same in Qt by calling it from Rust...? (If only)
[removed]
Most supercomputers have GPUs http://www.theregister.co.uk/2015/09/23/nine_of_the_worlds_fastest_gpu_supercomputers/ And it'll grow. On top of that, it's easy to spin an AWS GPU instance.
If you're building your database as a library, Rust is a much better choice than Go - it'll allow you to provide a C API that doesn't require a runtime. Also, the TiKV guys switched from Go to Rust because of the GC pauses in Go - it shouldn't be an issue for a toy database, though.
It's worth pointing out that an IR database exists in Go: http://www.blevesearch.com/ --- I don't know what it's performance characteristics are though.
I remember hacking on clang a (long) while ago and AFAIK libclang is an ad-hoc library: rather than having a principled approach where any change to the core Clang libraries are reflected in libclang, it's instead developed in a demand-driven way, and only exposed what someone needed and made the effort to add. So I would guess nobody needed to know about anonymous unions/structs :(
Hmm. FWIW, I've seen a number of databases built in Go (Prometheus, Cockroach, Influx, any number of distributed kv stores). The issues you're going to deal with are well known: namely pauses, but Go as a language is a good fit for getting to "up and running" with minimal fuss. I haven't seen the same activity in Rust.
Since the timeline mentions translation starting in about ~6 months, they could be stable by then.
I think [rayon](https://crates.io/crates/rayon) is worth mentioning too: parallelism without memory allocation!
True. I'm entirely unfamiliar with the timeline for stabilizing futures and tokio. 6 months seems pretty quick.
/u/fgilcher imported all Rust videos from Air Mozilla, so now we have everything at one place for you to discover. Happy Binge-Watching Rust content!
I don't know of a guide to do a full mirror (yet), but /u/carols10cents once wrote [Bare Minimum Crates.io Mirror Plus One](http://www.integer32.com/2016/10/08/bare-minimum-crates-io-mirror-plus-one.html), which mirrors the index. There's also the [crate-mirror](https://github.com/weiznich/crates-mirror) crate, which basically does the same but can also cache already-downloaded crates locally.
I remember a video where in a discussion panel someone from InfluxDB mentioned how they got around the GC (heads up: mmap a large slab of memory and handle that manually) and that if they were to start today they would probably use Rust instead of going through all that pain. The video featured a discussion with I think A. Alexandrescu and A. Turon... but I can't find it again (I only managed to find https://www.youtube.com/watch?v=ynQoaajojIs at LangNext 2014 with B. Stroustrup and R. Pike).
I thought I had seen an issue open for it but I think I got it mixed up with another issue I found. Submitted https://github.com/jameysharp/corrode/issues/107
Always hard to judge in the moment. Hindsight tells the story best, but you have to wait for it. From a sheer "gut feeling" perspective, Rust is giving off the same vibes I remember from the early days of Java, Linux in the mid 90's, and Python a bit later. It has that certain je ne sais quoi that only comes along once in awhile.
yes, either this (which i will check out, thanks!) or just write and parse to a plain markup file. if i wanted to use TOML or YAML or such, are there any that mesh very well with rust? i'd assume TOML has good bindings somewhere since we use it for configuration. or maybe moreso i'm asking if i want to save an application's state data, is there an option that allows no-hassle converting from internal rust datatypes?
Well then it's a good thing that Rust's CoC does not include that sexist remark.
I did not expect that...
https://github.com/alexcrichton/cargo-local-registry is one way. But that's on your local machine, not an internal mirror. If that's what you want, /u/badboy_'s post has the right stuff.
Generally, Rustaceans use TOML over YAML. https://crates.io/crates/toml should have you covered there.
This is delightful. Thanks, brson! &lt;3
Indeed, our coc seems mostly reasonably written; and hopefully we can avoid anything like the aforementioned controversies. Heck the closest we've had is that whole Eich witch hunt, but that was more Moz's issue than ours
It would have been nice to have things like topic descriptions and pre-1.0 annotations in the video titles. So many hours of video, can't watch 'em all.
I'm really happy for the work on adding categories to crates.io and to having style guidelines for Cargo.toml files. The first will make it easier for me to promote my crates, and find other crates of interest. And the second is towards making collaboration and getting started easier for users.
I personally went with this change in stylish: * { background-color: transparent; } body { background-color: #883300; }
Apparently, just a few days ago Rust [gained](https://github.com/rust-lang/rust/pull/38559) an ability to compile to PTX (cuda). Example: https://github.com/japaric/nvptx
&gt; after all, the infamous GOTO FAIL bug of Apple was NOT a memory safety issue, just buggy untested logic. It's a little glib, but Rust would not have suffered from something like goto fail nearly as easily, given `{}`'s are required on statements. I think this observation hints at something deeper: Rust is memory safe, but it is also generally stricter and provides more tools to let the compiler help the programmer find problems (and avoid creating more), such as generics, enums, affine types (as you say), etc. Of course, you are also correct that these sort of features are, strictly speaking, opt-in, but opting in is the easy, lazy path, e.g. reusing the generic `Vec` is easier than writing your own, as is using `Result` for error handling, given the standard library provides/uses them.
&gt; A new DroplessArena for some speedups Does anyone know the speed-ups? The pull request says &gt; I will collect performance (probably just -Ztime-passes, and more if that shows significant differences, perhaps). but I don't see a follow up to that.
&gt; However, Option has a clone impl. var.clone() will work anyway. You just blew my mind, thank you ! &gt; Note that Rc&lt;Option&lt;Foo&gt;&gt; and Option&lt;Rc&lt;Foo&gt;&gt; are different, in the first one the option is shared, whereas in the second one it is not. If you choose to make this mutable later with RefCell or Cell this will matter more. It's not relevant in my situation, but it's definitely good to notice. &gt; .as_ref().map() will not take ownership. Hm, I didn't know about the `as_ref` method. What's the difference between `&amp;var` and `var.as_ref` ? 
Ah ok. I use `env_logger` currently, and looked into switching over to `slog` but that wasn't feasible (the design is a bunch of `lazy_static!` modules talking to each other. Horrible design, but it was necessary due to how the C framework we use works. We'll be fixing it in the next version of our wrapper) I'll probably just end up using the `nix` crate, we'll have to use it sometime soon anyways. Thanks!
If we criminalize saying "guys" then we deprive English of a second person plural pronoun other than ya'll, ye, or yinz. "you guys" has always been gender-neutral to me. Perhaps this varies from region to region. And also, what does "guys" have to do with sexual orientation? Not sure what "-cis-" has to do with any of this....
Thank you! This works fine. But I still don't understand why it works this way. Maybe the compiler determines which type a token is at a later time if I use tt, so the '1' magically becomes an identifier instead of an expression this way? Or is the error message just bogus? 
https://www.youtube.com/watch?v=9iuwRO6cEwA&amp;t=161s It's displayed in the description it was posted in May, but It must be at least May 2014. Can the video description be edited? It would be useful to display witch video are outdated.
Is it possible to create a numeric type that is constrained within a range? Something like ``` struct Percentage(f32[0.0..1.0]) ```
I don't know why but I oddly like this a lot. Needs `fork` and maybe `merge` though!
I can understand the sentiment. Looking back, I'd say a lot of the wasted "time and effort" was spent by people trying to jump aboard the next train to gravy town. Everyone else was just playing with everything they could because it was fun and interesting, and we learned something from it all. Windows, Linux, OX/2, whatever. When something took off, we just shifted more research/exploration time to that thing, often bringing along stuff of interest and adapting it to the new thing. I already see that with Rust, where each day brings an announcement or two of a crate that someone created because it was cool, fun or tickled some interest they had. Suddenly you have an ecosystem that's kind of viable, and off you go. We'll see, but it feels pretty fun still, and that's a good sign.
The type system doesn't support it, but you could make a wrapper type that does runtime checks.
Note that all crates uploaded to crates.io are required to have all of their dependencies uplodaded to crates.io as well. git deps are forbidden. This means that unless you use github deps in your own crates, you won't need `.gitconfig` tricks.
Also even C compilers nowadays warn against suspicious formatting (as does [clippy](https://github.com/Manishearth/rust-clippy) in some cases).
I think this would be a fun exercise to do. Have you started on any code?
I am not 'criminalizing', merely pointing out that some may feel left out. Obligatory shout out to /r/botsrights
They [added](https://git.gnome.org/browse/librsvg/tree/rust/Cargo.toml) dependencies to git repos. Does it mean that builds of librsvg are now not reproducible? If incompatible changes are committed to those repos they will break new builds of librsvg (assuming you don't have Cargo.lock yet). Is this correct? Also I wonder how things will work if someone decides to write Rust wrapper for librsvg. This will create some kind of circular dependency as Rust code depends on C code which depends on another Rust code. Will this even work? Will you end up with two versions of the Rust standard library in the same process?
That's what I thought. Glad I didn't spend _too_ much time looking around for compile-time support for it
I guess that's from the automake build system.
No, the Rust chunk of librsvg is built into a static library, which is ultimately linked into the librsvg library (static or dynamic). From the outside world, it doesn't look any different to the previous C-only version.
Awesome, David! Glad to see that futures successfully scratches the itch that GJ was originally designed to address. :) A good sign for the async ecosystem.
&gt; They added dependencies to git repos. Does it mean that builds of librsvg are now not reproducible? If incompatible changes are added to those repos this will break new builds of librsvg (assuming you don't have Cargo.lock yet). Is this correct? Interesting. It looks like `Cargo.lock` isn't committed but it *is* included in the tarball dist, which will include git hashes, and therefore the builds should be reproducible. But yes... this is a strange setup. Hopefully they polish it up (there are a few interesting `improper_ctypes` warnings that I get when I try to compile as well).
&gt; Does it mean that builds of librsvg are now not reproducible? Currently, I think Rust itself [isn't reproducible](https://github.com/rust-lang/rust/issues/34902), unfortunately.
Awesome! Thank you.
Will futures-rs become a part of the std lib? or will it remain a stand alone crate, my google fu is weak on this topic.
I guess the "don't commit Cargo.lock for a library" rule needs an exception for libraries with a C API?
Well, I don't think it's the C API that's special here. What's special is that the dependencies are specified as git repos instead of using, say, crates.io.
Thanks everyone for the help. I cannot quite infer from Carol's blog if I can or cannot globally (a local user's cargo config, not per project) tell it to use my local index mirror and with that my local crate proxy/mirror. I'm probably the exception to the rule in wanting this, but I know of a few dev shops that prefer to have local proxy/cache of, say, Maven. It's a common thing to do and it'll be great to have this as a first class cargo/crates.io feature. Speed, reliability, predictability are just a few arguments why one needs this in addition to caching data in a network.
Nice. Been wondering about a GPU terminal (or text editor) for a while. Few random ideas: * It would be handy if the rendering parts are usable as a library for another OpenGL project, like a ~ dropdown console for gamedev or a terminal in VR. * Dump the default yaml config file into the directory on first start if it doesn't exist. Embedding the repos one in the binary might be a good usecase for the [include_str! macro](https://doc.rust-lang.org/std/macro.include_str.html), otherwise a build.rs. * Have a look at [RustType](https://github.com/dylanede/rusttype). A native Rust freetype alternative. I have no idea how usable/feature complete it is though. * A bit out-there but have a look at GPU based font rendering. [for example](http://wdobbie.com/post/gpu-text-rendering-with-vector-textures/) or [this](https://github.com/behdad/glyphy). Not sure of the quality/features vs traditional though. * Vulkan support ☺
That's a tough one. In general the Rust community is resistant to moving things into std because std comes with a long term compatibility &amp; support promise and Cargo is so good that it doesn't matter very much. On the other hand, many people consider support for Async IO to be a requirement for a programming language nowadays. I'd bet that Futures will have a long life outside of std first even if they are stabilized someday inside of std. Perhaps /u/aturon or /u/acrichto could weigh in?
I'll have a blog post coming out about this in a couple of days, and I'm talking about it at the January SF Rust meetup. In the mean time, take it for a spin and report any problems you run into! This is a 0.1.0 source-only release and is still considered pre-alpha software.
&gt; It would be handy if the rendering parts are usable as a library for another OpenGL project, like a ~ dropdown console for gamedev or a terminal in VR. That would be handy ;) &gt; Dump the default yaml config file into the directory on first start if it doesn't exist. Embedding the repos one in the binary might be a good usecase for the include_str! macro, otherwise a build.rs. That is a *great* idea! The default config file is already included in the binary for providing default key bindings, so it would be pretty easy to do as you suggest. &gt; Have a look at RustType. A native Rust freetype alternative. I have no idea how usable/feature complete it is though. Definitely something to consider for the future. &gt; Have a look at GPU based font rendering. for example or this. Not sure of the quality/features vs traditional though. Not interested. Glyphs are only rasterized once, and the complexity hit from moving that to the GPU is way too high. &gt; Vulkan support ☺ Definitely planning on doing this at some point! I've needed a good excuse to play around with Vulkano ;)
&gt;&gt; Have a look at GPU based font rendering. for example or this. Not sure of the quality/features vs traditional though. &gt; &gt; Not interested. Glyphs are only rasterized once, and the complexity hit from moving that to the GPU is way too high. You may find http://wdobbie.com/post/gpu-text-rendering-with-vector-textures/ both surprising and intriguing. For a terminal emulator in particular, where cells are of a fixed size, it might let you send the terminal window to the GPU as a buffer of _text_, to be rendered in nothing but shaders.
Get on the IRC people there are quick to respond and very helpful :). PS. Awesome work guys on the IRC!
&gt; Not interested. Glyphs are only rasterized once, and the complexity hit from moving that to the GPU is way too high. Fair enough. I think the main reason would be to be able to do fancy things like quick zoom and 3D rotations without the bluring that happens with pre-rendered to texture glyphs. Also some random things like adding depth extrude, glyph vertex/tessellation shader effects. But that stuff is obviously way out of scope for a terminal emulator. Also the performance of rendering vector's with aliasing would likely be worse than a simple texture mapping although with instancing it might not be too bad.
Very cool! Congrats on the 0.8 release David!
Temporarily stickying to make up for visibility loss during the year-end bacchanalia.
&gt; we are using the upstream libstd after weeks of work to port it Do you have a post that gets into the details of this? I'd like to know what changes this entailed to Redox, and what changes this entailed to the stdlib.
I should also mention that one concrete case for moving futures-rs to std is if we ever have `async` and `await` they'd likely want to interact with the `Future` trait. That's very far-future, though!
Fantastic writeup, thank you for sharing!
I don't know what KeepAss does, but you can't _really_ check a password for strength; it's the process that generates the passwords that should be scrutinised (and that determines the entropy).
Is there a to use WebRender without the rest of servo just for GUI?
http://keepass.info/help/kb/pw_quality_est.html &gt; KeePass 1.26 / 2.23 and newer. KeePass uses an advanced algorithm for estimating the quality/strength of passwords. It searches for patterns, like e.g. popular passwords (based on a built-in list of about 10000 most common passwords; variations by upper-/lower-case and L33t substitutions are detected), repeated sequences, numbers (consisting of multiple digits), constant difference sequences, etc. For each pattern combination covering the whole password, the cost (number of bits required to encode the data and the order of the pattern identifiers) is calculated. For encoding pattern identifiers, an optimal static entropy encoder is used. Each single password character forms a pattern of length 1 and is encoded using a character space-dependent damped static entropy encoder. The minimum pattern combination cost is used as the final quality estimation. &gt; KeePass 1.25 / 2.22 and earlier. These old versions of KeePass used a simple algorithm for estimating the quality/strength of passwords. It checks which character spaces are used (upper-case, lower-case, digits, special characters, ...). Repeated characters and character differences result in penalties. Finally, KeePass tests whether the whole password is popular (based on a built-in list of about 1500 most common passwords), and if so, the final estimation is only 1/8th of the statistical rating. 
 $ tokei . ------------------------------------------------------------------------------- Language Files Lines Code Comments Blanks ------------------------------------------------------------------------------- Autoconf 7 297 122 105 70 C 37 19190 14133 1708 3349 C Header 26 2419 1342 584 493 CSS 1 479 408 36 35 HTML 19 3605 3597 0 8 Makefile 21 9743 8198 529 1016 Rust 14 4249 3178 252 819 Shell 3 12300 8598 2272 1430 Plain Text 4 259 259 0 0 TOML 1 23 16 2 5 XML 2 157 139 1 17 ------------------------------------------------------------------------------- Total 135 52721 39990 5489 7242 ------------------------------------------------------------------------------- Looks like some difference in language detection between tokei and cloc. For instance, tokei doesn't seem to count `configure` as a shell script, leading to the much lower Bourne Shell numbers, but it counts 10 more Makefiles, looks like it counts `Makefile.*` as a makefile, and `*.am`. 
That's nice. Still, it's in the generating algorithm the ground truth lies, so if you know the algorithm, analysing a password generated by it doesn't add anything.
&gt; Next, Rust's tooling story is weak. Compared to what? Rust's tooling is in many ways way better than what's been out there for some language frameworks that have been around for decades or even new and hip languages. What have you been missing and which platform had it? A REPL or refactoring tools maybe?
You can also use "folks" or "people" or "peeps." In my native dialect of English, "guys" is very natural. But starting about 5 years ago, I had friends who preferred I not refer to them as "you guys" for various reasons. At first I thought it was going to be so hard, and awkward, and pointless. But within a month of deciding to consistently avoid it, I found I rarely used "guys" when addressing a group of people. It really isn't hard.
Looks like vte is just alacritty's ANSI library, probably a name collision: https://github.com/jwilm/vte GNOME's vte is just a C library, though. I don't know how stable its API is, but if you could reimplement that API, you could swap an alacritty-based terminal for the vte dependency in any vte-based terminal (such as GNOME terminal or termite).
I'm super excited to see this. Robigalia will be built entirely around futures-rs, and plans to use Cap'n Proto extensively.
Realized the same thing when I checked after it didn't fail since I don't have vte on my system. GNOME's vte is a full terminal emulator with a dependency on GTK so it's not a lightweight terminal emulator implementation toolkit.
Awesome, is this official anywhere or is this shared more tribally? I went to the RFC process to try and figure it out but struck out.
Thanks!
That makes a lot of sense. I'm curious. For a language moving this fast how far is far-future? 1 yr - 5 yrs?
It builds and runs. I guess it's still beta quality and not everything has been implemented judging from issues with running midnight commander. Right now it also seems to panic somewhere in glutin when run under Wayland. Thanks a lot for this project. I really need this to have a stable and reliable Wayland terminal that doesn't use GNOME/KDE or is crash-happy like Enlightenment's Terminology.
Excellent, thank you
Is it possible for it to use bitmap fonts or is that something that's impossible with the drawing backend?
Assuming you have XWayland, you can tell glutin to use the X APIs instead of Wayland. Let me find the flag... Edit: Actually, that seems to have been added in a more recent version of Glutin. Anyway, wayland support is coming :)
Memory overhead is substantial compared to st and xterm. Unless you plan to implement client/server model like rxvt-unicode, this will be hard to justify to use the way one usually has many terminal emulators open simultaneously. At ~40MB it's quite the leap and I suppose you won't add Sixel or animated wallpaper support to argue for 40MB :). Things I look for in terminal emulators: 1. fast drawing 2. fast processing (xterm,urxvt tricks like jump scrolling) of wall of text scrolling by or at least staying responsive but drawing less and being fast to end stdout processing is preferable 3. compatibility with the myriad of terminal standards so that apps just work as they do in xterm and urxvt
Some data points: st uses ~7MB for a fresh terminal, long running urxvtd servicing a couple clients for the whole day is at ~12MB.
Does the name have a special meaning in terms of terminals?
Are you planning to have 256, 16 and truecolor profiles and terminfo or will you just reuse rxvt-* or xterm-* entries for easy compatibility across systems? Sometimes one explicitly wants a 16 color TERM and other times truecolor.
Yes, I'd love to have a math extension. The only thing holding me back is not being 100% sure what the syntax should be - I'd prefer things get added upstream to CommonMark, but they're pretty conservative.
I still don't know if this comic is supposed to be sarcasm or not (in terms of how secure it is to use a password like that or not). And on that note, now that this password generator exists, wouldn't it be trivial to use it as a password cracker? *: I wasn't trying to sound snarky. I really didn't understand.
I've not looked too closely at the implementation of VTE but its not clear to me how much it has to depend on GTK, other than somehow receiving the drawing area from GTK? There's a distinction between VTE, which is just a terminal emulator, and gnome-terminal, which handles things like tabs and preferences and so on.
Is the idea that bugfixes would be ported over to the LTS version instead but not adding new features to avoid introducing new bugs? In either case it sounds like if a bug was found that a version upgrade would be required. Edit: oh I just saw the new comments below under annodomini's reply that seems to answer this.
heh, I didn't know the word alacrity
Possibly! I mean, if LTS were a "backport bug fixes" kind of thing, then we could always release more point versions. But distros are often okay with that, it's versions with new features that are inappropriate.
&gt; This falls out of using OpenGL for rendering. As long as you haven't disabled vsync on your system, Alacritty will just draw whatever is on the screen when a new frame is needed. If tons of output has gone by between frames, you would never see it. I enable vsync to work around tearing on Linux. Are you suggesting that vsync=on is better for this and stuff like freesync would be as well? My impression had always been that terminal emulators including the built-in KMS kernel fb console are slow at drawing fast scrolling by. There's also the problem that terminal multiplexers choke up and become unresponsive but that's probably the multiplexer's fault for not doing backpressure/flow-control of some sort and less the terminal emulators drawing code.
I think it would be great to have something compatible with MediaWiki written in Rust. However, I think it's a bigger job than you may think. MediaWiki is a pretty big codebase, and then there's the whole ecosystem of extensions, all of which are written in PHP. For instance, you can take a look at the [list of extensions and libraries used by en.wikipedia.org](https://en.wikipedia.org/wiki/Special:Version); that's over 150 by my count. Even a [smaller wiki that I maintain](https://www.icehousegames.org/wiki/index.php?title=Special:Version) uses 18 extensions and 28 libraries. For this ecosystem of extensions, you'd have to make a choice. Would you just implement the base functionality, and provide a Rust based extension mechanism? Would you re-implement some or all of the commonly used extensions in Rust? Or would you try to do it incrementally by implementing a core in Rust but expose the same API via PHP so you could use existing extensions and port them one by one? The most important for properly rendering content are probably ParserFunctions which adds some programmability to wiki templates, and Scribunto which is a replacement that does the same thing but using Lua rather than trying to do it all in wiki syntax, while the most important for running a real public wiki are probably the various spam and vandalism combating extensions (including, for smaller wikis like mine, the ones requiring registration and approval by an admin, as I don't have the time to keep up with the massive deluge of spam otherwise). I love the idea, and I've thought about what it would take, but it looks like a pretty daunting task to get to something that would be usable. Of course, rewriting a whole web browser, and parallelizing it in the process, is a pretty daunting task too, but that's a many year project with funding and a team of people.
I don't know enough about libvte and that's why I suggested that if what you're saying is right then packages might be built with too many dependencies which happens quite often in distros. I'm not trying to be snarky or anything but I can see how my comment can be read that way. Sorry if I gave the impression. Consider it corrected to more accurately convey that I don't know and am guessing this is what's probably going on and not trying to make fun of your comment.
I believe the integration with rendering is busted at the moment, and it's got a huge amount of stubbed out functionality. I have no idea if the CEF API would be appropriate for this use case in general.
I believe there are some samples in the webrender repository.
Say that your monitor refresh rate is 60 Hz. This means that between frames you have ~16.7ms. Assuming that to draw the screen takes 2ms, that leaves 14.7ms where the program is doing nothing. If you were, for example, `cat`ing a large file, those other 14.7ms can be used by the parser to process that output. When it's time to draw the next frame, text that has come and gone will not be displayed. If nothing has changed in the terminal state, no frame is drawn. Every time something changes, the renderer will draw a new frame. Now, say that vsync is disabled. Changing just 1 character would request a new frame be drawn, and the program would immediately start the 2ms process of drawing a new frame. Thus, with vsync, you make a bunch of time for the parser.
&gt; What will be lost and will it be noticeable in a pager as stuff missing or are we talking about avoiding unnecessary work that would IIUC be binned and not displayed anyway? It's the latter. Lots of text doesn't have to be drawn because it's gone by the time a new frame is needed.
It's hard to review when there's no document explaining how is it supposed to work, and functions and types are not described. Is it supposed to be similar to mioco / coio?
[RFC 1242](https://github.com/rust-lang/rfcs/blob/master/text/1242-rust-lang-crates.md) describes how crates are expected to move from external -&gt; nursery -&gt; standard lib.
It is initially shocking to switch from years of Java development into a text editor where syntax highlighting and "usable" auto-complete are the only assistance. In addition to what /u/i_am_jwilm mentioned I thought I'd add some more features I rely on heavily from Eclipse Java development: 1. Context-sensitive actions based on selection/cursor * Assign to local variable * Extract to method * Auto-import suggestions for undefined type 2. Quick outline of file * Allow quickly jumping to functions/structs defined within the file 3. Quick outline of struct &amp; traits * Helps for answering quickly whether a trait is implemented for a given struct within the crate, and navigating there if needed 4. Find callers of a function * Using the type system to determine actual/potential callers instead of finding the same text -- for cases where multiple functions exist with same name and differ by module/signature, or the function name appears in variable names etc. making text searching inaccurate/insufficient 5. Call-hierarchy * Outline of call hiearchy of some function - similar to finding callers of function, except recursively 6. Auto-completion with some extra smarts - like knowing cursor is at location for writing cases in a `match enum` block so only suggesting enum variants These are ones I use most frequently (in addition to basic auto-complete, goto definitions, auto import/use management). I'm excited to hear more news about the rust language server which seems to be the big infrastructure blocker for a lot of this.
Then I'd suggest trying GNU Unifont PCF. I find it looks worse than Terminus but it covers Unicode quite comprehensively and should be a good test case.
Yes, kind of, but less IO-oriented and focused more on supporting multiple small parallel computations with as low overhead as possible, intending to be used in games and various simulations. It is currently hard to support have up to date documentation as the code mutates fast, but it is planned for sure. To give a brief description of the current code: There is three public entities: * `run`, which sets up the scheduler and allows for more fibers (i.e. cooperative threads) to be spawned, * `spawn`, which spawns a new fiber, putting it into the queue to be run by a worker thread, * and the `SyncGuard` returned by `spawn`, which allows to wait for the fiber and also ensures that it has finished executing by the time the invoking function exits - just like the deprecated scoped thread api, but with a mechanism of ensuring soundness (which has yet to be implemented too). On `spawn`, the fiber is taken from the fibers pool, „`prime`d“ with the closure which it's supposed to execute and put into the `ready` queue. From there it is picked up by a `Core` (i.e. worker thread), which executes the fiber until it yields, putting it back into a corresponding queue depending on its yielded value: either `ready` - for fibers that just suspended themselves temporarily, `waiting` - for fibers which are waiting for some other fiber to finish executing, or back into the pool if the fiber has finished executing. UPD: fixed wording and formatting for the post to be a little more understandable.
imho backporting bug fixes to a LTS wouldn't be a good idea. It's possible that deployed code is actually relying on the bugs. Really the only thing that should be backported should be security fixes. &gt; It's versions with new features that are inappropriate. Seems to me it would be the opposite. Adding new features wouldn't actually be a problem since it shouldn't change existing behaviour. Of course adding new features could potentially introduce bugs in existing ones. Also many new features will impact existing behaviour in some way (like changing the formatting of the cli, adding a new button to a toolbar) so it's not really work the risk. Maybe fixing some bugs that don't change functionality would be ok. But you never know who is unknowingly relying on some memory leak as a way of rebooting their service periodically. Or who has hex edited the binary for some bizarre reason. Or who is piping the incorrect output into what. Firefox gets special treatment on Ubuntu because it has a decent testing infrastructure. With Rust compiling crates.io, it might be able to get the same treatment. Also worth thinking about binary compatibility for things like dynamic libs between compiler versions. 
Turns out there is another native rust font renderer made by some Googlers. [font-rs](https://github.com/google/font-rs). Apparently [it's fast](https://medium.com/@raphlinus/inside-the-fastest-font-renderer-in-the-world-75ae5270c445#.lhantl7x2).
I think that 1.15 would be a good candidate for starting the LTS cycle. MIR has fully launched, which will probably make backporting of a lot of fixes easier than having to backport to the old trans. Macros 1.1 will be stabilized, which means a big chunk of the ecosystem can run on it (diesel and serde, for example). And 1.15 will just barely make it out in time for the Debian Stretch freeze. By my calculation, 1.15 will be out February 2nd or so, and Debian Stretch freeze is on February 5th; so it's tight, but I think it could make it. Since Debian Stretch is the first LTS/stable major distro to release since Rust packaging work has really gotten under way, I think it would be a good candidate for supporting with the first Rust LTS release. Hmm, after checking [the package tracking page](https://packages.qa.debian.org/r/rustc.html), it looks like the current migration period from unstable to testing is 10 days. So, 1.15 may not be realistic; that's frustrating, since I think Macros 1.1 would be really nice to have in the first LTS release, and getting that into Debian Stretch would be nice since it would provide a real reason for people to target that LTS release. I agree that you'd want to roll out LTS support slowly; starting with one every six months sounds good. If you want to really get to the point of being useful for LTS distros, I think you'd want to eventually get to the point of doing one every two years or so with the past two supported, or one every 18 months with the past three supported, or something like that. About 4-5 years is about how long many LTS releases go through their "active" support window, with some of them having limited "extended" support longer than that but at that point pretty much entirely supported by the distro and fairly limited in scope. I think that the scope of what's supported should basically be that backports of ICE and miscompilation fixes should be accepted, and that security bugs will be fixed. Additionally, I think that the LTSes are a reasonable target for stable `rust-lang` crates to support (and that would provide some encouragement for this standard for the rest of the ecosystem); possibly make it a requirement that to graduate from `rust-lang-nursury` they must support the most recent LTS, and that for `rust-lang` crates it will be treated a a SemVer break if they drop support for either of the most recent two LTSes. Anyhow, those are my thoughts on what I'd like from an LTS release. I've been thinking of writing this up as a pre-RFC, but I feel a little weird doing so as I'm not involved in any of the release process so I'd just be asking other people to do a lot of work for me. But maybe I should write up the pre-RFC, and see what everyone thinks.
&gt; imho backporting bug fixes to a LTS wouldn't be a good idea. It's possible that deployed code is actually relying on the bugs. I disagree on this point. People backport bug fixes to LTS releases of the kernel and distros all the time, because customers running these want bug fixes but don't want to risk one of the newer features or refactorings causing such issues. Of course, I don't think you would proactively backport every bugfix; but if there's an ICE (in which case, I doubt people are depending on that behavior) or a miscompilation, and someone has actually hit it on the older version, and it backports reasonably cleanly without having to pull in a big refactor or a big change in semantics, I think it should be fine. &gt; Firefox gets special treatment on Ubuntu because it has a decent testing infrastructure. With Rust compiling crates.io, it might be able to get the same treatment. Yeah, I think that you would always want to do a crater run before releasing new LTS patch releases; and hopefully get crater to the point where it runs tests as well (at least for a subset of crates), to pick up functionality issues as well as compilation failures.
I'd prefer if rustup got packaged on all the major distros as well and developers could use it to get latest rust versions. Installing it will at least be what I expect from my users, its not hard to do. I will however try to be compatible to reasonably old C libraries, if I use them. Stable distros can be kept alive quite for some long time. E.g. RHEL 5, released in 2007, [still has official support by Red Hat](https://en.wikipedia.org/wiki/Red_Hat_Enterprise_Linux#Product_life_cycle), and it [ships with gcc 4.1](https://access.redhat.com/solutions/19458), where not even [gcc 4.3](https://gcc.gnu.org/gcc-4.3/cxx0x_status.html) has any halfway decent C++11 support. Does that mean you should avoid C++11? I know some people who think so, but I don't agree with them.
I've never used this but have looked at it with a mild intent - not sure if it would meet all your needs for conference/slides: https://jitsi.org/ It has desktop clients for most major platforms. It looks to be all open source and you can even host your own instance rather than using their (free?) service.
Not to discourage you, but I don't see the point of stripping down functionality from eg. mioco (which I'm an author of, so please be aware that I might be biased). I don't think you can gain much over `mioco` or `coio` just by not doing `io` reactor. In mioco you can just not do io, and use `mioco::yield_now` and you'll basically get the same result. Everything comes down to threads scheduling coroutines and switching between them. Especially now, that Rust community pushes towards async through `futures-rs` going this route is very against the winds of time. :) I've spent more than a year of late evenings getting mioco to where it is, and still dropped it for https://github.com/dpc/tokio-fiber . Basically `tokio` is already a standard Rust IO-reactor, and we can all reuse it. No need to spend another man-year-late-evening, when you can reuse a community-supported io reactor, and write a `Future` based on coroutines that will run in it. Come to tokio-fiber, join me, I'll quickly give you ownership over the project and we'll figure out something that works also in your case - when all you want is to switch with `yield` between CPU-bounded coroutines (eg. `await` is already there, `yield_now` is there, but might need fixing). Then, if you're doing it for learning purposes and you really want to do it your way, I can definitely see the point, and good luck.
*Why* is it fast though?
That'll be in the forthcoming blog post. Hoping to have it up tomorrow.
I don't like this. I think Rust's module system is *fine*, it's just not what people are used to. ^^[1] Most of the problems *seem* to boil down to people applying the wrong mental model, sometimes because they just don't read and/or skim the documentation because it's a module system; they already know how those work! I've lost count of the number of times people complaining about not understanding the module system *have not* bothered to read the existing documentation on them. As such, I can't believe that replacing an unusual but relatively simple system with a *still* unusual but now *implicit and more complex* system is going to help anything. More than that, it feels *really* against-the-grain for Rust. The situation still needs improvement, though. Some things I'd like to see tried *before* we resort to going down the proposed path: - Put the section on modules and crates *earlier* in the book, rather than the *twenty fifth* section, after numerous advanced features like generics, trait objects, and *universal function call syntax*. - Maybe have a general section right at the front quickly listing things people coming from other languages *absolutely should not* assume they understand just because they *look* similar. In addition to modules, traits ("they're just interfaces!") spring to mind. - Change the default cargo template and maybe some early examples to include simple module use, so it's right in people's faces. Changing how the module system itself works should be an approach of last resort. ---- \[1]: Aside from the absolute/relative path split thing. I think that *is* a mistake, but all the solutions I can think of just make things *less* convenient without really improving readability, or harm readability without really making things more convenient.
 I know the word implicit is frightening, but bare with me! Hopefully you mean "bear with me" ☺️
For those wondering: [bear vs bare](http://public.wsu.edu/~brians/errors/bare.html)
I agree with u/Quxxy that the proposed solution seems more complex and problems with the current module system boils down to people not reading documentation. I don't recall myself having trouble with the module system when learning Rust (I've read the tutorial though). The only thing that was (and is) confusing is the absolute/relative paths working differently in `use` and local paths, but that's impossible to fix in backward compatible way. Also, the `mod` declarations have a really huge benefit for readability – you don't have to look at a filesystem to understand module hierarchy and you can navigate the library using go-to-definition. The implicit modules are also ambiguous, consider: src ├── lib.rs ├── sublib.rs ├── submain.rs └── main.rs I've also thought that the proposed solution has yet another problem: use self::submodule; use submodule::foo; // unresolved import But this actually works on nightly! That's a nice surprise! Anyway, I think that the best way to "fix" the module system is through compiler messages. If we do the following: * detect using a module without `mod` declaration but when the appropriate file (or unimported extern crate) exists and * issue a warning for the same file being referenced (by `mod`) twice in the the tree (with a help of cargo we can even detect sharing a file between `lib` and `main`) * issue a warning for a module with only one child with the same name as parent (to detect repeating `mod foo { ... }` inside `foo.rs` or `mod foo` inside `lib.rs` for `foo` crate) I think most misuses of modules would be covered. There will always be people who don't read the documentation or just missed the appropriate chapter.
I don't mind Rust's module system, but I can see where it's confusing—the module hierarchy *mostly* follows the filesystem hierarchy, but if you seen `foo.rs` and `bar.rs` side-by-side, it's not obvious what the hierarchy is: `foo.rs` might contain `mod bar;`, `bar.rs` might contain `mod foo;`, or some other file might contain `mod foo; mod bar;` making them siblings. The C++ namespace system, which is entirely orthogonal to filesystem layout, would be familiar to a lot of Rust's target audience, and possibly simpler (overall) than Rust's partially-filesystem-based hierarchy. However, the sheer scope for confusing shenanigans (putting the contents of namespace "foo" in "bar.cpp", or having a file in a subdirectory open a namespace then `#include` a file in a parent directory) make it hard to recommend a scheme like this. On the other hand, Python's module system goes to the other extreme: the Single Source of Truth for module hierarchy is the filesystem, so it's always guaranteed consistent with the source-code layout. In terms of the points listed in TFA: ### Rust requires users to build an explicit module graph In Python, a module can be a standalone `.py` file, or a directory containing an `__init__.py` file (analogous to `mod.rs`), which can be empty. If you don't count "create an empty `__init__.py` file", Python does not require the user to declare the module graph before using it. ### Some Rust source files are branch nodes in the module graph Some Python source files are branch nodes in the module graph, but they're always named `__init__.py` so they're easy to spot. Everything else is a leaf. *Note:* Because Python doesn't distinguish between (what Rust calls) `use` and `pub use`, you may be able to get to a module via some other module that uses it, instead of via its canonical path. However, this is considered "un-Pythonic", so I don't count such modules as branch nodes. ### ‘use’ and local paths start from a different point Traditionally (in Python 2.x) importing a name would guess whether you meant an external library or a sibling module in the same library. In Python 3, this has been tidied up: `from foo import bar` is always like `extern crate foo; use ::foo::bar;` (except that it can also import the currently-executing library), while `from . import foo` is always like `use foo;` (it imports a sibling module). Extra dots are like Rust's `super`: `from .. import foo` → `use super::foo;`, `from ... import foo` → `use super::super::foo;` and so forth. See [PEP328](https://www.python.org/dev/peps/pep-0328/) for details. Overall, I think TFA's suggestion is pretty close to how Python works, so I like it.
When evaluating a method of making passwords, you assume your attacker has a generator/cracker. So the answer to your second question is "yes, and that doesn't affect the security".
I really could not disagree more strongly with a response _along these lines_. We do not deal with usability issues with our language by telling people they need to read the docs. Our goal is to create a language with is accessible, usable, and habitable without sacrificing runtime performance. When we have a usability problem, we should very seriously consider addressing it. I'm not saying this solution is a slamdunk, or that there is a solution which is better than the current solution, but we should not take the attitude that this is just a docs problem. &gt; As such, I can't believe that replacing an unusual but relatively simple system with a still unusual but now implicit and more complex system is going to help anything. More than that, it feels really against-the-grain for Rust. How is this more complex and less explicit? Instead of writing mod foo; pub mod bar; You write use self::foo; pub use self::bar; Instead of writing //Cargo.toml [dependencies] foo = "*" //lib.rs extern crate foo; You write //Cargo.toml [dependencies] foo = "*" 
Although Geany's Rust plugin is fairly basic (does not use Racer for autocompletion) it _does_ provide that quick outline within a file, and you _can_ quickly jump to a definition with ctrl-click as expected, provided the files containing that definition are open in the session. It does need some extra love, but it's impressive.
Oh thanks, I thought I caught all of it (guess which one the test video was :D)
This is really interesting. I Made a beer bar which accepted bitcoin a few years ago which needs some upgrade, like wireless. So RTL8710 and Rust could be a good start to learn something new.
This is an issue on which there seems to be a sharp divide between people who get it right away and people who don't get it for a while. It took me a while to get it; once I did get it it made 100% sense.
 Still slow compile times? I thought Rust had incremental?
&gt; I'd prefer if rustup got packaged on all the major distros From what I've heard from distro folks, programs whose only purpose is to seemingly circumvent distro packaging are frowned upon. &gt; Does that mean you should avoid C++11? I have contributed to a large open-source codebase that implemented and then reverted support for C++11 due to distro compilers lacking proper support. It's definitely a thing that happens in the wild.
The tarball includes a Cargo.lock. Still, it would rely on github not vanishing in a puff of smoke.
In a typical game, these allocations will be very rare, but access and modifications of the elements very common. The improved data access pattern (assuming these fields are not accessed together) would completely drown any inefficiency from the allocations.
&gt; ... which is why the borrow checker and lifetimes should be replaced with much easier to understand runtime checks that won't require anywhere near as much documentation to explain. Lifetimes are a huge usability issue, and one way we've mitigated that issue is *lifetime elliision* which makes lifetimes implicit in the vast majority of functions which are lifetime parametric.
Also, going along these lines, Gnome has an interesting project for terminal emulators: libtsm. It's the input handling statemachine for terminals, without the drawing. https://www.freedesktop.org/wiki/Software/kmscon/libtsm/
https://crates.io/crates/typenum could help, but typenum is usually too heavy for most purposes.
&gt; The only reason for import functionality is to be able to find code that's defined elsewhere (for whatever reason), and the file system is *already a tree* This is basically the thought process behind the idea in this proposal. The only issue with Python is that it doesn't have fine grained privacy controls we need. This proposal solves that by having the file system namespaces private by default and piggyback on re-exports to have public submodules.
About extern crate: If its only optional, some codebases will have only a part of the used crates listed in lib.rs, and some other crates will be omitted, which will confuse readers of those crates. I'd like to suggest an improvement for it: the automatic `extern crate` logic would only work if you omitted all uses of `extern crate` in the current crate. Otherwise its pretty useful! I agree its quite aesthetic, but shouldn't really be required IMO. About your suggestion to improve the module system: I'd prefer to have a bit more to type but instead gain flexibility, which I seem to lose with the system, especially it will break one of my hacks where I have both a lib.rs and a main.rs in a crate so that the integration tests can use stuff from lib.rs and main.rs can do `mod.lib`. Plus you gain readability: you instantly know which dirs in a given checkout contain code relevant for the crate, and which directories only contain test data or sub-crates, or other things. I don't have a file explorer open, nor a directory tree in my editor, and don't want now to be required to. Also, its certainly not backwards compatible, as if you have files checked into repos that are not intended to be used will be parsed and maybe compilation will fail.
Sure, but halving the attack surface by using Rust is already great progress. But that's not the end of it. GOTO FAIL is another class of bugs prevented by Rust’s language design. It's prevented by pattern matching instead of error-prone switch statements, and mandatory braces around blocks. Rust has those goodies and more, so I reckon that much more than 50% is prevented. The author said that people should stop writing new software in languages that don't have the lessons incorporated which were learned during 40 years of C bugs.
&gt; One of the great things about Rust is that it moves information about how to build code out of command line arguments and into the source itself. One could also argue that the Cargo.toml is part of the source and DRY says you should have to write the same information in multiple places. In theory crate attributes could be written inside the Cargo.toml if extern crate is removed.
Yes, because having to type all of those lifetimes out by hand is a tremendous usability impediment (which I've experienced for myself) with very little benefit: the lifetimes that *would* be added can be derived directly *from the code in front of you.* You do *not* need to switch over to a terminal or file explorer to find out what lifetimes exist. Also, whilst explicit lifetime annotations are unnecessary, I don't recall *ever* seeing anyone suggest that the compiler should annoy people into removing them if they've chosen to use them. Sometimes, you *want* to be explicit if the code in question is too complex to visually parse all at once. To reiterate: I am *not* against implicit shorthands, I just feel they need to clear a high bar.
&gt; From what I've heard from distro folks, programs whose only purpose is to seemingly circumvent distro packaging are frowned upon. rustup is packaged on arch linux already, and josh is trying to get it into debian (until now I haven't heard of an official signal from debian that it shouldn't be added). But yeah there might be some opposition ahead. The android app development ecosystem is feeling the same need, its willing it with gradlew, which is something distros can't prevent (unless they mount the /home partition as noexec per default xD).
I deeply agree with the premise that the Rust module system is too confusing. In the absence of concrete good bits of documentation (which I was unable to find when I looked for them) that provide a useful model of how the module system works, I think the burden of proof is kind of on the people saying the "module system is fine". Note that I'm also coming from deep experience with Python, so this will undoubtedly color my perception of Rust's module system. Things I've run into/dislike: * Having to specify `extern crate` for Cargo dependencies. This feels like boilerplate/make-work. Why is this necessary? Is it because we don't want to make the language rely on the tooling? If so, should we soften up on that principle at this point? * `extern crate` statements in non-root modules. I think this solves a real problem in terms of making a crate-internal abstraction layer, where the internal abstraction layer has some dependencies which should be hidden from the rest of the code. * Confusion on when to use `self` and `super`. Are we relative to the crate root, or relative to the current module, and in what contexts? * Explicit vs implicit modules. Personally, I think making things explicit is a fine choice; on the other hand, specifying things in the source code that could somewhat trivially be derived from directory layout also feels like boilerplate/make-work to some extent. However, for me the real problem is in allowing people to specify modules in the source code in a way that's dissimilar to the filesystem layout; this just makes things confusing. Perhaps that can be made into a linter warning?
Honestly, I would rather move things like versioning out of Cargo.toml and into the source files rather than the other way around.
My biggest problem was figuring out how to refer to types defined in sibling modules. Once I figured out `::` to get back to the crate root I was golden.
&gt; because C++ ABI is unstable and there are many dynamically linked C++ libraries How is this any different in Rust, specially across version releases?
How can clippy become stable? Everyone has been saying all over the place that clippy relies on the internals of the compiler too much to ever become stable.
Since we can't remove the current syntax, *any* non-breaking change is a complexity increase. I would hate to see Rust going the route of more than one correct way to do something.
Most Java ides will automatically add imports when autocompleting and remove them fairly easily.
Temporarily stickying to make up for visibility loss during the year-end bacchanalia.
I can't tell if I would be happier with this solution, because I still don't fully grok the modules in the first place; it's mainly the pathing that's confusing me though (when am I using relative vs. absolute? And when *should* I use which?). I don't use Rust on a daily basis however, so maybe I just need more exposure to it. I can say that I was thrown off when I started trying to use modules because I was following the crates.io documentation on how to get started with a new project, and it didn't tell me anything about how to actually structure a project. I ended up making a PR that at least put a link to the book inside the crates.io manifest, such that you could at least have a breadcrumb trail to follow, but I would still expect the crates.io "Getting started" section to talk about this stuff. As a side note, I can say that I don't understand that many of the various module systems out there in general, mostly because I don't have to. A good IDE will do all the bothersome work for you of managing your import paths and what not, and I think this is an important point in making modules accessible as well. Not that tooling is the answer to everything, but good tooling can at least let beginners ignore something like the module system until they've learnt some of the other things.
The current explicit system has one great advantage: It is extremely easy to temporarily disable a module or even an entire tree of modules by commenting out the `mod` statement for that module. The proposed implicit system would require to shuffle around files (to hide them from the compiler) and then comment out the `use` statements.
How to share a large data structure between two processes that run in different address spaces? The appeal of Rust parallelism is that I can confidently share data structures between threads - I don't need to rely on message passing to enforce minimal sanity (like Erlang does). This enable sharing of very large data structures, that are accessed directly, without unnecessary copies. Having to put every plugin on its own process kind of undermines this appeal of Rust.
Thanks, you're obviously right :)
Cool!!
Yes, I've lost all hope of seeing maths standardised in CommonMark any time soon. Their webpage still says *"With your help, we plan to announce a finalized 1.0 spec and test suite in early 2016"*, so I wouldn't hold my breath. There is a good summary of syntaxes [here](https://github.com/cben/mathdown/wiki/math-in-markdown). Places where maths is more likely to be used (MathOverflow, Jupyter, etc.) seem to favour `$ ... $` and `$$ ... $$`. It should be pretty robust when combined with heuristics like in pandoc: opening `$` should not be followed by space, closing `$` should not be followed by number. If you are interested and have some time to answer questions, once you are done with the rewrite I may be able to help out with a PR. 
It's not the compiler, it's the language itself. C++ has _features_ that allow you do do unsafe things. It's not that it's lacking safety features, it's that it actively provides unsafe functionality in the default language. You could implement a compiler for a language that has some of C++'s features that would be safe, but you wouldn't be able to implement thelarge swathes of C++ that are unsafe. That means it wouldn't be actually be a C++ compiler, it would be compiler for a (probably quite useless) subset of C++, you'd actively have to leave things out.
Here's the simplest (possibly *too* simple) explanation I can think of: fn f(a: &amp;i32, b: &amp;i32) -&gt; &amp;i32 { ... } Does the return type have the lifetime of `a`, `b`, or is it static? Are they the same? In Rust, you'd just specify, but C++ has no way of expressing this. So, you'd have to do global analysis to work that out. The problem with *that* is that if the compiler can't work it out, it has no way of knowing who's to blame. Is the function's body wrong? Is how it's being *used* wrong? Is one caller using it correctly, but another not? Which is which? So far as I know, you *can* do this sort of analysis with C++. The *issue* is that the analysis just doesn't have enough information to tell you *why* a piece of code fails to validate, only that it's wrong. Somehow. *Somewhere.* Maybe a magic 8-ball could tell you more? Of course, you might ask: "well, can't we *add* that information to C++?" Congratulations, you've more or less just re-invented Rust's borrow checker. :D That also doesn't address the *other* big difference between the two. One of the core tenets of C++ is "trust the programmer". One of the core tenets of Rust is "the programmer is a complete numpty; don't trust them unless they sign a contract in blood, in triplicate, promising they know what they're doing." People make mistakes; Rust asks if you're sure you want to walk into the minefield, C++ enthusiastically runs ahead and blows all its limbs off while screaming "I don't know why you asked me to do this, but anything to make you happy!"
No, it's not only due to a good compiler. There are features of the rust language that cannot be easily replicated in C++ without changing C++. Adequate modules, algebraic data types + traits. Yes, C++ modules are coming SOON™, but that's not the only advantage. Let's assume, for the moment, that you've managed to add a borrow checker and lint to your C++ compiler. How many programs will pass the borrow checker? How many libraries you use will be rejected? How easy will it be to use write programs that pass the borrow checker without rust's features? Will you be able to convince the authors of those libraries to use your borrow checker and lint? In crates system, there's at least *some* filtering due to default compiler checks.
&gt; The simplicity goal means that it doesn't have many features like tabs or scroll back as in other terminals. Instead, it is expected that users of Alacritty make use of a terminal multiplexer such as tmux. I get the "no tab" idea, but... no scrolling? Maybe there's something I'm missing, but it looks like kind of a big deal.
Although I disagree with your assertion that modules are too confusing, I fully agree with the suggestion that we should stop forcing users to declare `mod`s and `extern crate`s explicitly. Both of these types of declarations, with the exception of `pub mod` and `#[macro_use]`, are redundant with information that can be gathered from Cargo or from the file structure. It's also super easy to forget, when I'm creating a new file, that I have to go add that `mod` line one level up. There's sometimes not even an indication that the module isn't added, until I go and run my tests and wonder why the tests for my new code aren't running (maybe a lint for ".rs files not included in module structure" would help). Automating this as much as possible would improve the ergonomics of Rust's module system greatly, in my opinion.
IIRC, it's going to move to Rust project ownership so it'll just be a compiler feature instead of a standalone project.
&gt; One of the core tenets of Rust is "the programmer is a complete numpty; don't trust them unless they sign a contract in blood, in triplicate, promising they know what they're doing." Mmmmmm I see what you're trying to say, but I would rephrase this as "The programmer is a busy human being trying to keep track of their actual logic as well as tedious details. Since computers are REALLY GOOD at keeping track of tedious details, help the programmer out so they can concentrate on what humans are good at, unless they really really want to keep track of the details themselves".
The module system is confusing.
I hate to see Rust turn into windows and make compat push simplifying improvement off the table.
perfect, just trying to get a sense of scale / time.
&gt; who knows how many Rust comrades we lost when their confusion with the module system discouraged them from continuing? As someone who does not find the module system particularly intuitive, I doubt you've lost many over it. Annoying module systems are fairly common and the usual solution is to figure out the patterns that you normally use, memorize those, and ignore the rest of the details. This involves asking clueless questions around getting your normal patterns working but it's a one time thing and unless there are landmines with how features intersect, it's something to complain about but not a reason to drop a language.
The thing is that for safety checking, the Rust language gives up some freedoms that you're allowed in C++. So if you added the safety checks to a C++ compiler, it would refuse to compile a lot of valid C++ programs... so it's already not a real C++ compiler. Now you're probably gonna be tempted to add some new features to work around the loss in expressiveness you've just accepted in return for safety, and then you're well on your way to a completely separate language, like Rust.
There is some very early support for Qt in a couple of libraries for Rust, but one large problem is that Qt is a C++ framework. This is why almost no programming languages support Qt, since C++ does not have a standardized ABI for other languages to use for interop. For drawing widgets and embedding OpenGL, you might have some luck with Conrod and Piston, but I can't personally help you there.
They totally were, yeah. https://confreaks.tv/events/rustconf2016
There are a bunch of downsides to allocating thrice. You need three bounds checks now on lookup and insertion. A pointer-offset pair doesn't uniquely specify an element; you have to double-indirect through the object. Any code path that might allocate now needs to include the logic three times, which makes it three times as likely to mess up compilation and much more likely to cause slowdown from code bloat. Your elements are potentially spread over memory, which hurts locality, though only slightly. SoA is of course good, but if you're worried about performance that much you probably want to go all the way and make the SoA efficient. 
It does [pattern matching](https://doc.rust-lang.org/book/patterns.html), [if let](https://doc.rust-lang.org/book/if-let.html) is basically sugar for [match](https://doc.rust-lang.org/book/match.html): match state { ChainState::Back =&gt; println!("true"), _ =&gt; println!("false"), }
…and consequently the two shown lines are semantically identical, yes? (Though `if let` is more flexible in general.)
Rust is about being explicit. I'd prefer to have it in my code then some flag. I just generally hate implicit anything (I'm looking at your weak types C, you burned me). Rust can be verbose at times but I know what's going on and nothing is hidden behind compiler or tooling voodoo magic.
I did this just yesterday, and I was thankful of the explicit mods!
A rule of thumb: 1) in `use` statements the paths are always absolute unless you opt in to relative ones by starting the path with `self::` or `super::`. 2) everywhere else, the paths are always relative, unless you opt in to absolute ones by starting the path with `::`.
If you don't mind, I'll have to nitpick and mention that this is less a GNOME and more a FreeDesktop project by one of graphics stack developers, meant to replace the built-in linux framebuffer terminal. I tried kmscon once and it locked up the machine, which doesn't mean libtsm is to blame, but it didn't leave a good impression. Maybe it improved in the meantime (last couple months).
/r/playrust
Scrollback is easily provided by `tmux` as well.
How much of this could be automated? Could the rls learn to fix all my module imports? My personal experience is that once you have a well structured project, then it is easy to grasp what is going on, but if you start out experienting then it can be difficult to guess the proper pattern.
[removed]
Thanks! I compute the exact tessellation for fills and a "simplified" tessellation for strokes (simplified in the sense that it is simply a band of triangles along the path that may overlap in some cases such as self-intersecting strokes). 
Huh, TIL. I didn't expect that to be in the standard library. Oh well.
Please remember that Steve knows -- *[The name](http://benchmarksgame.alioth.debian.org/sometimes-people-just-make-up-stuff.html#name-game) "benchmarks game" signifies nothing more than the fact that programmers contribute programs that compete (but try to remain comparable) for fun not money.* Please remember that Steve is a Rust language advocate. When he can use the benchmarks game to talk-up Rust -- he does -- as does [the FAQ](https://www.rust-lang.org/en-US/faq.html#how-fast-is-rust). 
I used libtsm a couple of years ago while binding it to rust. It sees much use in things like asciinema which uses it to recreate the terminal image from a token stream. I can very much recommend it and had some nice interactions when making it work on OS X with the maintainer.
I'm really not a fan of implicit `extern crate`s. Many of my crate names have the prefix `aurum-` to prevent conflicts with generically named crates, but I don't want to write `aurum_` every time I `use` something from them. As it currently stands, I can write `extern crate aurum_linear as linear`.
I don't know if it's too complicated or not, but the Rust module system sure as *fuck* results in a lot of preambly garbage. Here's an example from a small utility I was working on: #[macro_use] extern crate slog; #[macro_use] extern crate slog_scope; extern crate slog_term; use slog::DrainExt; #[macro_use] extern crate error_chain; mod errors { error_chain! { } } use errors::*; extern crate clap; use clap::{App, Arg}; extern crate toml; use toml::{Table, Value}; #[macro_use] extern crate lazy_static; extern crate regex; use regex::{Regex, Captures}; use std::io::Read; use std::collections::{BTreeMap, LinkedList}; My ideal syntax for this monster is as follows: #[macro_use] extern crate slog use ::DrainExt, slog_scope, error_chain, lazy_static; extern crate slog_term, clap use ::{App, Arg}, toml use ::{Table, Value}, regex use::{Regex, Captures}; mod errors { error_chain! { } }; use std::io::Read, std::collections::{BTreeMap, LinkedList}, errors::*; Now, I dunno if getting a merged extern/use syntax in is possible, but can we *at least* get multi-crate externs and multi-module uses? Please? That would look like this: #[macro_use] extern crate slog, slog_scope, error_chain, lazy_static; extern crate slog_term, clap, toml, regex; mod errors { error_chain! { } }; use std::io::Read, std::collections::{BTreeMap, LinkedList}, errors::*, slog::DrainExt, clap::{App, Arg}, toml::{Table,Value}, regex::{Regex,Captures};
... neat. *quietly starts porting their chatbot from Elixir to Rust*
Brilliant, I was looking for a telegram API in rust just a couple of weeks ago, this is well timed - thanks!
From my experience dabbling in Rust, not even static ones, as cargo doesn't understand binary dependencies across projects. 
I don't get how conflating declaration and usage, or making the availability of external crates magically transparent to the language itself, are either improvements at all. To me the 'obvious' improvement in the system is to just stop requiring explicit declaration and start inferring module declarations directly from the filename hierarchy within a crate. This matches some other languages and cuts the boilerplate pushups required for refactoring that the book details. Want to create a new submodule and move things into it? Just create a new appropriately-named file in the right spot in the tree. I thought this was basically what you were suggesting in your post but now with this comment I'm not sure. Frankly I get way more confused by every proposal I see to 'fix' the module system than I think I am by the module system itself, which probably means I don't actually get the module system and just get by fine with a surface comprehension.
&gt; Also, the mod declarations have a really huge benefit for readability – you don't have to look at a filesystem to understand module hierarchy I would phrase this as the exact inverse: mod declarations have a really huge drawback for readability - you can't just look at the filesytem to understand the module hierarchy.
I was just writing a library similar to this (and I was thinking of using a custom derive just like you do!), but yours seems to be well ahead. Nice job, I will try it out!
Python has been around for 26 years. Its module system has been around for most of that time. It is by far the most intuitive module system in existence. The second you create a Python source file, it's importable. Anything you write in it is importable. Create a directory and slap in an `__init__.py` and you have a module with multiple submodules. It really does just make sense in your head. I don't understand why language developers consistently try to re-invent the wheel when it comes to module systems when a system like Python's exists. I understand that languages like Rust have some more safety/privacy requirements than Python does, but that shouldn't really be that much of a hindrance. Maybe it requires a keyword to prevent a function/struct/etc from being exportable. Maybe you have public/private imports. There are a ton of ways to make the parser/pre-processor understand this. A lot of the work is already done in this department. It shouldn't take more than a quick peak into CPython's source to figure out how to do it in a file system agnostic way. I think Rust's module system is one of the areas where Rust relied too heavily on C/C++ idioms. Personally, I would be willing to put up with longer compilation times if it meant composing application architecture was more intuitive.
I just started using this library in a new project. Thanks for your work!
As a somewhat advanced user, Rust is maybe my twelfth programming language, and literally the only part I had trouble with was the module system 😉
Oh I fully agree that Rust is a *great* leap forward. However I would be very afraid if newcomers to the language got to remember "it's secure, it's written in Rust".
Have you read http://rust-lang.github.io/book/ch07-00-modules.html ?
Looking forward to running this on Windows :) 
Nicely done, though. Since you're familiar with this area of focus, you should take a close look and see if you can submit a PR to the standard library that improves it a bit. "Wesley Wiser, contributor to Rust Standard Library" would look great on your CV as compared to "Wesley Wiser, author of small crate on crates.io". Just sayin' :-)
That captures a part of it, but I can definitely confirm what was said in the GP is important, since a lot of the time I am a complete numpty. Being handheld by the compiler does a lot more than keep track of tedious details, it actively curbs my natural propensity to do completely stupid things in code, far beyond just the tedious details. Forcing me to think rather than allowing me to write whatever I'd like keeps a lot of stupid out of the world.
I love Cargo, but I would be concerned about starting to make it almost required b/c it has taken ownership of some of the essential structural characteristics of the language. Why? At Dropbox, for example, we're getting more and more Rust projects, and so we're starting to integrate Rust into our Bazel stack. As more largish companies (that have many different languages, kernels, etc) deploy non-trivial amounts of rust, it's likely this will become more and more common--rust will have to integrate into the sort of universal dependency specification system, build system, ci, sandboxing, etc. So I personally would love to see Cargo remain a really great default for most use cases without becoming essential. I think the current design reflects this.
Yep, I have a comment above with more detail, but everything at Dropbox is `bazel` now, and so our Rust is moving into it too.
It's a clean design. Nice work.
&gt; I can't figure out how to fix the namespacing to get my changes to compile. If you have a failing PR, I can take a look and fix it.
&gt; Instead of writing &gt; &gt; //Cargo.toml &gt; [dependencies] &gt; foo = "*" &gt; &gt; //lib.rs &gt; extern crate foo; &gt; &gt; You write &gt; &gt; //Cargo.toml &gt; [dependencies] &gt; foo = "*" I would prefer to be able to use crates with clashing names in different source files in my project. I also prefer to be able to grep for definitions. Your suggestion might be good for the first 2-3 small projects you write, but these sorts of things have big impacts on larger projects. EDIT: Greppability is a really useful thing - it's also why I prefer to write "return x;" over just "x". Lets me search for return and have all return statements highlighted in my editor, without having to look for rows without semicolons.
Would love to see scrollback support. I use a tiling window manager and often have 10-20 terminals open in different workspaces, and in non-static layouts that change all the time depending on what I'm doing. I can't go back to having just one WM window for all my terminals. (though if anyone knows a way to configure each of my terminal windows to start and hook into its own tmux tab in a single tmux session, and having some way to hide the tmux status line by default so I don't waste screen real estate, that'd be something I would love to know how to do!)
Brb, replacing my Firefox with nightly. More Rust, please 😀
I'm sorry, I was not clear here. This snippet was assuming that `self::submodule` exists if `submodule.rs` exists, when no `mod` line is present (just as proposed). What I've meant is that (in current stable) you can't refer to imported elements in other `use` statements: use std::io; use io::prelude::*; // error on stable So under the proposed solution, with things working as in current stable, you would always have to repeat `self::submodule`in each `use` of that module, so the situation would be different from how it works currently with `mod`. But it's fixed on nightly, so it will be no longer a problem.
&gt; How is this more complex and less explicit? It is absolutely more complex. Now, `pub use` in *some* contexts will pull in new files, but not all contexts, and `mod` still exists and is used so people still have to learn about it. And inline mod will still exist and be even more confusing with all of this. If you do make `pub use` work that way in all contexts (`pub use foo::bar::baz`, not just with self), it is absolutely more implicit. Except it can't work in all contexts, only if the path is in the same crate. Which makes it more confusing. I agree with His Holy Macroness that the problem is mostly unfamiliarity. If you look at how Python's modules work they're similarly tricky to set up. The issue is that we're _different_, but there's no way to become un-different enough for this to not be a problem because of backwards compatibility. &gt; Our goal is to create a language with is accessible, usable, and habitable without sacrificing runtime performance. And backwards compatible. Pre-1.0 I'd be more receptive to such proposals. Now there are a lot of things we can't change, so we should be _very_ wary of introducing new features that just pile on existing ones and make it more confusing overall. &gt; We do not deal with usability issues with our language by telling people they need to read the docs. Diagnostics are docs too. You can let the compiler teach the user how to do it, to some degree. We do this with lifetimes already. We can deal with these issues by writing _better_ docs (and diagnostics). If folks aren't understanding the docs its our fault, but folks not understanding the feature without reading the docs is not really something we should _always_ try to fix. My thoughts echo Quxxy's, "I do not believe it is possible to construct something as complex as a programming language that requires absolutely no instruction whatsoever."
Neither I nor `rustc` want to deal with versions within rust files. I think the middle ground would be to introduce yet another special file, say `crate.rs` that only contains `extern crate` and `mod` statements which can be generated by `cargo` right before compilation, and will be passed-to/identified-by `rustc`.
I guess that it's just a matter of personal preference, whether do you prefer to look at code or filesystem first. I start with opening lib/main.rs, so not having to look anywhere else is a benefit for me. Also, to learn whether the module is public or not, I would have to look at the source anyway.
Ah, yes, of course. Thank you.
Same here, it took me a while to figure it out coming from everything else. 
It was hard to understand at first, especially after C++, but now I'm fine and like it. I'm actually like modules, since they are unifying source tree of projects. I think the lack of a good doc about modules it they key. Current one, with languages example, is too simple.
I agree, and the other benefit to making `extern crate` optional (rather than deprecating it) is that it preserves backwards compatibility. Crates that want to be modern can remove their `extern crate`s, but older crates will continue to work with the latest rustc.
&gt; Now, pub use in some contexts will pull in new files, but not all contexts Can you explain what you mean by 'pull in new files'? The files are parsed whether you use them or not; `use` pulls in names, the same way it always has
So I'm not entirely sure that this blog post even is addressing the right problems. Most of the module problems in #rust that I've seen arise from: - `use` paths working differently from inline paths - exactly how privacy works - the fact that you can have modules both inline and as separate files The proposal doesn't fix any of these. It fixes the problem of "You have to specifically declare that a file exists in a mod.rs", which I've only seen crop up (relatively) rarely. Folks figure that out quickly and never have to worry about it again; it's a simple and straightforward rule. We can instrument the compiler to provide more hints in these cases. Out of the three problems I noted, only the last one is like this. The other two are not easy to figure out. The rules are not _too_ confusing, but they're not things you will easily figure out on your own and folks usually get lost in a spiral of trial-and-error where they come up with bad explanations for things. Hell, even /u/steveklabnik1 was confused about the privacy thing in this thread and got it wrong (possibly due to misinterpretation of a comment).
&gt; I would prefer to be able to use crates with clashing names in different source files in my project. How do you do this today?
The dependencies _aren't_ in the source, because the source says nothing about how they're found. They're somewhere in your build system, whether its your library path or the `--extern` flags. Nothing about this proposal increases the coupling between cargo and rustc. 
https://doc.rust-lang.org/reference.html#visibility-and-privacy says * If an item is public, then it can be used externally through any of its public ancestors. * If an item is private, it may be accessed by the current module and its descendants. "ancestors" here means _anything_ higher up the stack, rather than only the thing right above it? We should clarify, as it seems I've read this wrong :( (This behavior is reasonable, but the way it's in the reference caused me to mis-read it). 
That's what the compiler does, that's not necessarily what all people will think is happening at first glance. This is usually the source of most confusingness -- folks don't know how to think about a particular feature, they choose their own interpretation (often informed by other languages), and are wrong. That is the problem with the existing system, and your solution doesn't fix it, just shifts it. The problem with modules that your proposal addresses could similarly be fixed if everyone simply interpreted `mod foo;` as `mod foo { /* contents of foo.rs or foo/mod.rs */}`. They don't. Also automatically pulling in files has its own set of problems. What files are automatically pulled in -- will new module-folders be pulled in too? If not, that's another bit of confusingness. If so, it gets extremely implicit. I've had old not-git-added files floating in my trees as well, and that's another set of issues when files get magically autoincluded.
&gt; I'd like to make it invisible to the outside, while still exposing the methods that use it; You can't really do that, as then you'd be exporting a private type to a public method. In my understanding.
The compiler already walks the tree starting from your source root following a naming convention. If you have a non-Rust file in your source directory called `foo.rs` then yes you'd get a compiler error, but why have you done that?
There is one thing that I wanted to do in my library that you are not doing: make some of the request and response messages more rust-friendly. Take for example the `parse_mode` field in the `sendMessage` method: in your implementation (and in the telegram API) it is an `Option&lt;String&gt;`, but I think that an enum like this: enum ParseMode { Markdown, HTML, Text } would be better. There are many places where I think it would be better to deviate from strictly mirroring the API. Of course the downsides are that proper documentation would be needed to point out the differences, and the implementation would be less straightforward. What do you think about it?
Just last night I was contemplating writing a Rust parser for the Wikipedia page XML data dumps. Currently my code is written in Java. But it seems like a ton of work, and ultimately not worth a rewrite. But were there to already be a MediaWiki markup parser in Rust, I would gladly take advantage of that!
To be clear, the removal of 'extern crate' as I've seen it proposed wouldn't mean that it would be tied to Cargo; it would mean that you'd need to pass an `--extern` flag specifically, which `rustc` already understands and is what `cargo` does today.
IMO, requiring `mod submodule;` is one of the most important advantages the Rust module system has over Python. You should not need to check every symbol defined in the file to see if the `use` statement will import something from the file system. I also like the syntactical similarity between defining a module inline and referencing it from an external file. Which brings me to the next point: Because you can define modules inline, the compiler will need to check 6 files for this import: `use self::abc::def::ghi;` * `./abc.rs` and * `./abc/mod.rs` if `def` and `ghi` are nested inline modules in `abc` * `./abc/def.rs` and * `./abc/def/mod.rs` if `ghi` is an inline module in `abc::def` * `./abc/def/ghi.rs` and * `./abc/def/ghi/mod.rs` if all modules in the path are in distinct files Also, how will you stop code from simply importing internal modules? The filesystem has no visibility mechanics. In Python this is not a problem because the language doesn't have any visibility mechanics to begin with. The article also mentions scanning the modules for tests. Now that there is no reference trail in the source files (because not every module has to be referenced in a project) you have to scan all the directories. Besides the problem of knowing at what directory to start (remember, you can do `use super::…;`) you open two messy problems: * Finding out what files are Rust modules. Checking for file extension feels like a kludge. * What do you do with special FS features like symlinks? Follow them and try to deal with possible infinite recursion? Arbitrarily not follow them and reduce options for dependency management and other use cases? **Strong disagree** to this proposal.
So you need _two_ layers of non-`pub` stuff...
Because I had a file not git added in my tree that I was playing around with. This has happened to me many times.
2017 is going to be amazing! *(at least in Rust-land)*
Is any of this even integrated into nightly yet? Because if it is, they've done a phenomenal job, because I've been running nightly for years and didn't notice anything … but I expect not.
You can make tmux your default shell. Then you always have the functionality even on simple commands.
Not to mention I have spots in some projects with this line in it: #[cfg(test)] mod test; Implicit module imports will trash this.
Well that's already on there :) Point taken though. I'd thought about implementing a fallback to parsing argv[0] in case the OS specific implementation failed for some reason. (I've seen rumors that /proc isn't available on certain Linux distros to non-root processes; also containers?) Perhaps I'll investigate that and upstream what I come up with.
Sort of, but that depends on what you mean by "any of this". [There's already Rust code in Firefox since 48](http://arstechnica.com/information-technology/2016/08/firefox-48-ships-bringing-rust-mainstream-and-multiprocess-for-some/) (handles media formats), but I don't think Stylo has made it into Nightly, though they're already working on it. Mozilla does do a phenomenal job, and I honestly expect to not notice when they actually merge Stylo. The last time I noticed a change was when e10s landed in Nightly, but even then it worked pretty well.
`use self::m` is longer than `mod m`, and it's doing the same thing if I understand your proposal correctly (while it's doing something qualitatively different from plain `use m`). Doesn't seem comparable to lifetime elision. The equivalent to lifetime elision would be something like this: &gt; # `mod;` &gt; &gt; If no argument is passed to `mod`, rustc will expand it into a mod declaration for every .rs file and directory with a mod.rs file in it, except ones that conflict with other symbols declared in this file. &gt; For example, given this filesystem layout &gt; &gt; * lib.rs &gt; * alpha.rs &gt; * beta/mod.rs &gt; * beta/gamma.rs &gt; * vim/vimrc &gt; &gt; if lib.rs contains this code: &gt; &gt; mod; &gt; &gt; it will be equivalent to this code: &gt; &gt; mod alpha; &gt; mod beta; &gt; &gt; whereas this: &gt; &gt; pub mod; &gt; &gt; will expand to this: &gt; &gt; pub mod alpha; &gt; pub mod beta; &gt; &gt; This might want to warn, but it should still compile: &gt; &gt; mod alpha; &gt; mod beta; &gt; mod; &gt; &gt; and this: &gt; &gt; pub mod alpha; &gt; mod; &gt; &gt; should expand to this: &gt; &gt; pub mod alpha; &gt; mod beta; &gt; &gt; This should also compile (it will end up not reading the alpha.rs file at all): &gt; &gt; mod; &gt; fn alpha() {} Thinking about it, that might actually be really cool. No idea how feasible it is, though. `mod *;` might be better syntax, too.
I think it looks really neat, but I'm having a hard time understanding how it could be practical. An example with a real tool, or an actual data set would help me grok it better.
I expect to notice when some CSS-heavy sites get faster 😁
That's just not true. The rust compiler starts with a "root file" that the user (or cargo) feeds it. It only looks at .rs files if they get referenced (transitively) from the root file. Go ahead, drop a malformed Rust file into a project. If you don't change anything else to pull it in, your project will still compile. I just tried it.
I can't imagine doing this. cargo doesn't know how to parse Rust and shouldn't need to learn!
Or you could continue declaring `extern crate` and use your library path just like you do today (we can't make breaking changes.) 
Thanks, I'll have a look!
Is the following what you mean? mod c { mod a { pub mod b { use c::a; pub fn foo() { super::bar(); // fine ::c::a::bar(); // also fine a::bar() // also fine } } fn bar() {} } fn baz() { a::b::foo(); // fine // a::bar() // error } } For the specific example, I suspect what you want is making `Command` a private `enum` in `xen::ffi`'s namespace. This could be done by putting directly it in the `xen::ffi` module, or by having it a `pub enum` of a private submodule (say `command`) of `xen::ffi`. For the latter, things within `xen::ffi` can then access it via `xen::ffi::command::Command`. At the moment, it seems the problem is `Command` needs to be available outside of `hypercalls` and `hypercalls` needs to be available outside of `xen::ffi`, which together imply that `Command` is available outside of `xen::ffi`.
Yeah, for example real time logging of something concurrent could be possible with this. Like tracking open connections to servers and visualization of the amount of data as corresponding colors. I will try to build an example on top of that 😋
I don't know, haven't had that problem yet. But it seems like the proposed solution would break any project that has two dependent crates where exported names clash.
That's true, yeah.
Saved! Thank you so much!
Yup, me too, and I had fairly constant crashes for the first couple release cycles (about one or two times a day), but since 47 or 48, it's been pretty stable. There's still a few annoyances (closing several tabs a once is slower), but it works quite well and will only get better.
No, borrow checking is actually pretty fast. But the newsletter has to be monomorphized for every reader...
Or have it as part of a `build.rs` that downloads it and then the source does an `include_bytes!`. 
Oh yes. I think every author of every type-heavy library out there has been typing this far too much. Diesel for example is full of stuff like pub type Select&lt;Source, Selection, Type=&lt;Selection as super::Expression&gt;::SqlType&gt; = &lt;Source as SelectDsl&lt;Selection, Type&gt;&gt;::Output; or pub type Update&lt;Target, Changes&gt; = UpdateStatement&lt; &lt;Target as HasTable&gt;::Table, &lt;Target as IntoUpdateTarget&gt;::WhereClause, &lt;Changes as AsChangeset&gt;::Changeset, &gt;;
Yes this is a deliberate decision. [The Public Suffix List](https://github.com/publicsuffix/list) is a living document that's always receiving updates. People use it for all sorts of reasons. Some use cases require that you always have the latest version as soon as possible. The company I work for is one of those that have this use case. For example, here is a quote from [publicsuffix.org/learn](https://publicsuffix.org/learn/):- &gt; Some people use the PSL to determine what is a valid domain name and what isn't. This is dangerous, particularly in these days where new gTLDs are arriving at a rapid pace, if your software does not regularly receive PSL updates, because it will erroneously think new gTLDs are not valid. The DNS is the proper source for this information. If you must use it for this purpose, please do not bake static copies of the PSL into your software with no update mechanism. If you are using this in a long running server, you only need to download this list once a week at the minimum. The HTTP request [is not that bad](https://github.com/rushmorem/publicsuffix/blob/master/src/lib.rs#L215). It's a simple GET request that doesn't even need a full blown HTTP library. Also note one can opt out of `remote_list` which means you can build the library without the methods for fetching via HTTP which disables the `rust-native-tls` dependency. If someone wanted to supply an external crate like you say (or use their own HTTP library) they can still do that. The library has `List::from_reader` and `List::from_string` methods that allow one to build the list from anything that implements `std::io::Read` (all the HTTP libraries I know do this in their response objects) or an arbitrary string respectively. Finally, please note that the list is totally optional. If all one needs is to do syntax checks and doesn't need to verify that the domain's suffix actually exists, [they can just build an empty list](https://github.com/rushmorem/publicsuffix/releases/tag/v1.3.2) using `List::empty` and use that instead.
I guess I could, but it still bugs me. I wouldn't expect much features from a minimal terminal, but scrolling would be one of those.
I already posted in the community forum, but I thought I would ask here as well: Are there any good tutorials or examples on implementing `IntoIter` and `Iterators` for structures? I'm working with fundamental data structures, but the examples in the standard library--like for [LinkedList](https://github.com/rust-lang/rust/blob/master/src/libcollections/linked_list.rs)--are a bit over my head.
I considered that at first but decided against it. Kindly see my other response...
I agree. A verification email is the only way to be sure that the email address actually works and that it belongs to the person who is signing up for your service. However, we can improve the user experience somewhat if we can tell upfront if the email address isn't even valid at all. I mean while submitting my form, I would rather a website tells me that the email address I entered isn't valid so I can fix it right away rather than letting me submit and wait in vain only to realise later that the email address I entered isn't even valid.
I understand your point, but still think that my approach is worth trying. Tokio is a good library, but is still an IO one, written with presumption that a program is IO-bound, and a large chunk of code for piping events being executed each time a future is polled. What I want to have is a library that won't become a bottleneck in a highly fiberised environment with soft real-time constraints (e.g. all computations being required to complete in 15ms or less) and without IO. Ability to utilize all available cores is a must too. Thank you for invitation, but switching between coroutines is not all I want. I also want to have waiting coroutines migrated between multiple cores as they become free to achieve parallel execution. From what I understand, your library in its current state appears to be further from this goal than mine (but please correct me if I'm wrong). Also, there is nothing stopping me from implementing a Future trait in the future (pun not intended) for my Fibers to be interoperable with all the ecosystem, is there? So I consider this project to be worth developing, at least to the point where I can set up a benchmark to compare it against other implementations in the circumstances I target, to determine if it worth continuing.
I'm very pleased that they included a set of [non goals](https://github.com/aturon/rfcs/blob/roadmap-2017/text/0000-roadmap-2017.md#non-goals), it shows that they aren't just throwing ideas out there, they have a clear vision for Rust. Side note: I wasn't aware of the [Rust Guidelines](http://aturon.github.io/README.html), which is dope.
You are welcome :)
&gt; Side note: I wasn't aware of the Rust Guidelines, which is dope. To be clear, those are old, and haven't been touched in a long time. https://github.com/rust-lang-nursery/fmt-rfcs/ is where the work on the updated, current ones are going.
2016 survey: https://blog.rust-lang.org/2016/06/30/State-of-Rust-Survey-2016.html 2016 commercial user survey: https://internals.rust-lang.org/t/2016-rust-commercial-user-survey-results/4317
Until step_by gets stable you can just filter with modulo: (0..100).filter(|n| n % 5 == 0) Or, [with some macro magic](https://play.rust-lang.org/?gist=f1dc46113d66e4dd015c4158bb942216&amp;version=stable&amp;backtrace=0): `(0..100).filter(every!(16))` :)
It's fine with me if anyone wants to call *themselves* a numpty, I've done plenty of silly things myself! That being said, it is definitely not one of the core tenets of Rust that programmers are numptys!!
Few days late posting this but better late than never :-)
If you want to have regex nightmares here's a [perl regex version](http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html) that claims to be equally compliant (lacking comments as well). It's essentially the canonical example of when while you could just only regexs you probably shouldn't. Note that regex is generated from code. I have doubts that even a majority of email servers/clients probably handle the full email address spec.
I recently discovered the Scala `for` syntax, which reminds me of the Haskell `do` notation. For instance: scala&gt; for { x &lt;- 1 to 10; y &lt;- 1 to 10 | if x % 2 == 0 | } | yield x * y res0: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100) It can also be used with the `Option` type: scala&gt; val maybeInt1 = Some(10) maybeInt1: Some[Int] = Some(10) scala&gt; val maybeInt2: Option[Int] = None maybeInt2: Option[Int] = None scala&gt; for { x &lt;- maybeInt1; y &lt;- maybeInt2 } | yield x + y res1: Option[Int] = None I think that would deprecate the question mark operator :p .
LOL. I came across that link yesterday via [this article](http://haacked.com/archive/2007/08/21/i-knew-how-to-validate-an-email-address-until-i.aspx/). Not even Gmail is fully compliant with the specs. However, some of the things allowed by the RFCs leave a lot to be desired to say the least. If I were building an email service I think I would only allow users to create email addresses that use a subset of the allowed characters. Particularly, I think making the local-part of an email address have the same requirements as domain labels sounds reasonable. However, sending an email is another story. You want to be fully compliant if you first validate the email address that a user is sending an email to. You don't want to stop your clients sending to an email address that you think is not valid when it perfectly is.
Rust's module system is fairly similar to Python's, so coming from there it shouldn't be a big leap.
The Rust devs can't be held accountable for the structure of your filesystem though, and if you're writing code on a machine with a completely foreign file system, then how is Rust supposed to handle it? (E.g., where I work, we don't even have a hierarchical filesystem.) The module system is different from the file system because one is not part of the language and the other is.
I didn't intend to imply that not reading the documentation is the *only* cause of confusion, just that at least *some* of the apparent problems with the module system are down to people assuming things and plowing on ahead.
Yeah, I think that probably got lost in the rest of my incoherent rambling. I think that's what I was trying to get at with the comparison to the `printf` formatting hints. &gt; (On a different note, you may not intend it, but the ridiculous amount of italics makes your messages seem quite aggressive.) Text is just serialised speech, and I don't talk [like a robot](https://youtu.be/vEjgqJzCzK0). At least, so far as *you* know. *You can't prove anything.*
No worries! I didn't take t that way. It's just not clear me what you meant, since they don't have modules.
`==` will call a `PartialEq` impl, which could do anything. I can define a `PartialEq` impl to always return true. OTOH `if let foo = bar` does a structural match, and doesn't require `PartialEq`. 
Adding the full screen command to Way Cooler (been missing being able to full screen a terminal to see wide output). Going to add a few more misc fixes as well and probably push 0.4.2 on Monday. After that, going to go back to working on window borders. That will be the next major feature of Way Cooler. I'll also add redshift support (Gamma control just landed in WLC, the framework we use) as well. I guess 0.5 will have to be called "the graphical update" :-P
All right. Good points. Please share the benchmarks, I'd be interested myself. &gt; migrated between multiple cores as they become free to achieve parallel execution. The `tokio-fiber`, being based on `tokio`scheduling does not deal with multiple threads yet, AFAIK, but some form of multithreading is planed in `tokio` ecosystem. I'm not sure at this point how will it fit in the picture, and how effective will it be. `mioco` has an exposed scheduler, so you can write your own scheduling and migrate coroutines. `coio` AFAIK, was built on top of multithreaded work stealing scheduler from the day zero.
&gt; when 99% of the elements are in order, and a 2x (...) What's the exact definition of X% of elements being in order?
For me, borrow checker errors have gone away mostly, but I'm not sure if that's because I understand it better now, or if the libraries I use are designed better or if the borrow checker has improved, though I'm pretty sure it's a mixture of all three. I'm super excited about HKT, since it seems like this is where Rust will really take off. I'm hoping that the borrow checker essentially becomes that weird thing you only deal with when trying to make clever structures instead of the thing you have to mess with like once a day or so.
IMO this has always been the most unintuitive part.
That's great to hear. It makes me much more excited about picking it up again!
I dunno if it exactly qualifies as syntactic *sugar* per se, it's more of an *alternate* syntax, but whatever. I'm a big fan of how Kotlin lets you write [lambda expressions](https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions) if it's the last parameter of a function: fun main(args: Array&lt;String&gt;) { // Lambda passed in as a third argument val a = repeatOperation(1, 2, { it + 1 }) println(a) // Equivalent to above val b = repeatOperation(1, 2) { it + 1 } println(b) } fun repeatOperation(x: Int, times: Int = 1, operation: (Int) -&gt; Int): Int = if (times &gt; 0) { repeatOperation(operation(x), times - 1, operation) } else { x } The equivalent Rust looks something like this: fn main() { let a = repeat_operation(1, 2, |x| x + 1); println!("{:?}", a) } fn repeat_operation&lt;F&gt;(x: i32, times: i32, operation: F) -&gt; i32 where F: Fn(i32) -&gt; i32 { if times &gt; 0 { repeat_operation(operation(x), times - 1, operation) } else { x } } As the number of arguments increase and the passed in closures get more complex, the value of Kotlin's convention really starts to come through. But obviously, this isn't a very realistic want.
It's the approach a ton of other langs take, they seem to have survived. And deriving the module hierarchy from the file system hierarchy is no more baking the file system into the language than storing the programs as a textual representation in files - you have a standard transformation from a representation into the semantics of the language.
Multi crate extern, multi module use.
I really wish we had interpolated format strings like C#. println!("1 + 2 = {1 + 2}");
Real delegation sugar. I think that you could have something close to module imports for delegation, e.g.: struct Foo{ a: u8, b: usize }; impl Foo { pub use u8::* as Self.a; } Foo::max() /* calls u8::max */ Reusing `use` would allow for custom imports and allow for pulling in the delegate in a scoped fashion, e.g. struct FooReader&lt;R: Read&gt;(R); impl&lt;R: Read&gt; Read for FooReader&lt;R&gt; { fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; { use Read as Self.0; // my own state tracking // delegate the rest self.read(buf) } }
My big wish: fn stuff(a: ~Type1, b: ~Type2, c: ~Type3) { // lots // of // stuff } as sugar for fn __stuff_inner(a: Type1, b: Type2, c: Type3) { // lots // of // stuff } #[inline(always)] fn stuff&lt;T1, T2, T3&gt;(a: T1, b: T2, c: T3) where T1: Into&lt;Type1&gt;, T2: Into&lt;Type2&gt;, T3: Into&lt;Type3&gt; { __stuff_inner(a.into(), b.into(), c.into()) } Generic input arguments without massive code bloat.
It landed in master on December 9th. The nightlies were delayed at the time, so it didn't actually go out until awhile afterward, but it was in the December 18th nightly.
&gt; After a couple hours of googling/experimenting, I would only then have a good understand what the problem was, but not what a good solution might be. I felt like I could almost always get things to work by copying data or adding scope, but these solutions felt like hacks/workarounds. The impression I get is that many languages will automatically handle this for you; for example, C++ defaults to making a fresh copy of each parameter when you pass it to a function (unless you use `std::move`), and Python will increment its reference count. Rust won't do those things without specific permission, so it can often feel like you're missing something important, but often that's not the case—sometimes you really do need to copy data or add scope, it's not a hack or workaround, it's just that now it's visible in the source code. I expect that wizened Rustaceans can design their data-types such that copying is kept to an absolute minimum, but the same is true of, say, wizened C++ developers—the difference is that Rustaceans get continual feedback from the compiler to help them learn, while C++ developers have to think very hard for a long time.
Yeah, that's pretty ugly. It took me a few reads of `Select` to understand what was going on. Two equal signs on a line is weird. I manged to pretty mine up a bunch by defining [aliases](http://paholg.com/typenum/typenum/operator_aliases/index.html), but it's still not perfect. I'm especially frustrated that where clauses then don't match trait bodies. E.g. I might have`where A: Add&lt;B&gt;` but then in the body I'll use `Sum&lt;A, B&gt;`.
&gt; I constantly ran into errors with the borrow-checker that were, for me, very difficult to decipher. Which is why the book actually is not that good. It is way too theoretical and not enough practical in many parts. I had the same experience as you. I read the chapters on moving, borrowing, lifetimes. I kind of got it, but not in any way that was useful to actually write something. When it comes to it I think the community is not nearly critical enough of it. 
No examples, so I should probably take all of that back :)
I understand. However, due to a typo someone could enter `john..doe@example.com` which isn't valid but still makes it through your regular expression. If it were you signing up, wouldn't you rather be warned right there than wait, say 15 minutes or more anticipating a confirmation email only to find out later that you accidentally put in an additional . in there? My point is, it improves the experience of our users if we can catch as many errors as possible upfront. Think of it this way. One of the major benefits of using Rust is that it catches as many errors as possible at compile time. Using the same analogy, warning users instantly when they are filling in forms is catching their errors at compile time. Having them wait for an email to arrive that was doomed from the word go is deferring to runtime.
notriddle@[2602:46:3a7e:4e00:2120:68c4:bcbe:b51a] is a valid email address, accessible from the Internet (except there's no mailserver at that IPv6 address), and it contains no `.` in the host name.
Yeah, something more cohesive would be very useful. May be Steve Klabnik plans to extend The Book with such chapters?
Thank you. And that `#[cfg_attr(not(test)), ..)]` is a neat trick we should totally include in our documentation.
`&lt;'a&gt;`. Although that would be solved with more lifetime elision rather than syntactic sugar.
Exactly this. You basically can't trust any pointer returned by a C/C++ library to exist past the next API call, if that, unless explicitly stated in the docs. It gets annoying having to maintain our own copies of the data because we don't know if the library does that at all, especially with `const char*`. In Rust, it's so easy to properly manage that, because of lifetimes. You know exactly how long a reference exists, and raw pointers are mostly `unsafe` and discouraged unless you already know all that information yourself.
&gt; Call hierarchy For my day job I work on many-mloc codebases, and without this I would be slowed down by an unbelievable amount. Certainly my top-priority feature in any IDE.
If nothing else I would love it if any website in history recognized that `+` is a valid character in email addresses, so that I can utilize Gmail's secret alias feature.
I just implemented my first type-function the other day and I quickly ran into this. So, I wrote a type alias: type MyTypeFn&lt;A&gt; = &lt;A as MyTypeFnTrait&gt;::Output; this cleans it up, but it does mean that I have yet another type identifier floating around in my code.
But that particular example will still work, no? I thought dots were optional on the left side of the @. I think the majority of errors are: * Missing @example.com * Missing .com I agree that it would be nice to catch these errors as early as possible, but I also don't think it's really worth the time to do, especially since there's still a giant possibility for error on both the user's side (e.g. john.doe@example.co) and the server's side (forget to update the TLD database and thus reject valid input).
**Rust should have a lower learning curve, EVEN FOR ABSOLUTE BEGINNERS** 𝟎𝟏. [Guessing Game](https://doc.rust-lang.org/book/guessing-game.html) : perfect for c, c++ ... devs but not for absolute newcomers as the main starting point. 𝟎𝟐. Would like to suggest to add `out of topic but related content` when its possible. ex, after Hello World println!("{}, {}!", "Hello", "world"); // Hello, world! println!("{0}, {1}!", "Hello", "world"); // Hello, world! println!("{greeting}, {name}!", greeting="Hello", name="world"); // Hello, world! println!("{:?}", [1,2,3]); // [1, 2, 3] println!("{:#?}", [1,2,3]); /* [ 1, 2, 3 ] */ // 🔎 format! macro is used to store the formatted STRING let x = format!("{}, {}!", "Hello", "world"); println!("{}", x); // Hello, world! 𝟎𝟑. Adding more descriptions is good but we should hi-light most important parts. 𝟎𝟒. By Adding few tips to example code blocks we can avoid confusions of devs let t = true; let f: bool = false; // with explicit type annotation // ⭐️ no TRUE, FALSE, 1, 0 &gt; seriously why want to add `Filename: src/main.rs` and `fn main() { }` on each code block. But should use when we use multiple files like src/main.rs and src/lib.rs 𝟎𝟓. some code examples in docs are not completed. I am not against [Rust By Example](http://rustbyexample.com) but official documentation should describe more usages. ex, Arrays let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3 let mut b = [1, 2, 3]; let c: [int; 3] = [1, 2, 3]; //[Type; NO of elements] let d: ["my value"; 3]; //["my value", "my value", "my value"]; let e: [i32; 0] = []; //empty array // ⭐️ `out of topic but related content` println!("{:?}", a); //[1, 2, 3] println!("{:#?}", a); // [ // 1, // 2, // 3 // ] 𝟎𝟔. Please reconsider the documentation about ownership, borrowing and lifetimes. It was hard to understand even with lesser content in the current doc. By adding more and more content on Upcoming doc instead describing why Rust uses ownership, borrowing and lifetimes instead a GC, might even harder to understand these concepts to newcomers. &gt; Would like to suggest to add more examples about how to use lifetimes on Function Declaration, Struct or Enum Declaration, With Impls and Traits, With Generic Types and etc . And then explain 'in order to make common patterns more ergonomic, Rust allows lifetimes to be elided/omitted' Thanks
I like "Hello"s. automatically converting `&amp;str` to `String` would be much pleasant as well. let x: String = "Hello" 
Then there's matching two possible if let values at the same time. I wish there was an ability to do the following: if let Token::First(a) | Token::Second(a) = function() { .... } Or perhaps if let value in Token::First | Token::Second = function() { .... }
My favorite part about this article is the bit about "We can't just land the plane and build a new plane while offering no service for years", given that that's exactly how Firefox came to be in the first place.
Ah. That would be why then. A great shame!
`guard let`. `?` only useful for `Result` type. I want to early return from function when pattern matching fail. 
That still have same problem though, you still cannot easily see what type which implement that trait. fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;File&gt; The signature only tell that `open` can use any type that implement trait `AsRef&lt;Path&gt;`. Maybe this is just a documentation issue, but I prefer to see `open` signature in rustdoc like this fn open(path: &amp;str) -&gt; Result&lt;File&gt; fn open(path: &amp;String) -&gt; Result&lt;File&gt; fn open(path: &amp;OsStr) -&gt; Result&lt;File&gt; /// real signature fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;File&gt; ``` 
&gt;Reading will only get you so far, to really learn something you have to put it into practice. My argument is that the book does not explain things well enough to go put anything into practice. Way too much theory not enough examples. 
From my personal experience, the problem is the opposite : many website have validation logic that **refuses** legitimate addresses because they wrote the validation logic themselves and they just did it wrong. Checking that the address contains @ does no harm, but if you check for this regex `.*@.*\.[a-zA-Z]{1-4}` you're refusing legit addresses. You are absolutely right about «The only way to check if email address is correct is to send a verification email.». But the problem is **people**, for various reasons some of them **want** to check email validity. If there is a standard tool to do it, they'll use it, but if not, they will hack their own and it's gonna be harmful.
I miss a Rust Antipattern guide. It's so easy to try apply practices learned from the other programming languages, to just notice eventually that there is a more elegant way in Rust.
How does it encode optional values?
Actually, I'm going to suggest a much reduced version (that'll allow to ascribe a `'fn` lifetime) first, but only once I got the alloca RFC in order. So little time...
Can you provide a complete example? If your code was in a `fn main()`, I'd assume you'd get a type mismatch, because your function cannot return a `usize`.
I'd like to chime in with a pair of loosely related things. First, I've found the best way to validate email address even *before* the confirmation letter is sent - is to use the [low-level SMTP commands](https://docs.rs/lettre/0.6.1/lettre/transport/smtp/client/struct.Client.html) and *start* sending the letter. The flow goes like this: 1) A user submits a form or something. We get the email address. 2) We start SMTP session and add recipient (RCPT). 3) At that point SMTP server (in my case, Postfix) either tells us that email address is not valid or takes it in. If the SMTP server accepted the address, it means the address is good enough for the server to try and send to. 4) If SMTP server told as that email address is not valid, we can inform the user and ask him to fix it. If the email address is valid, we can proceed saving it to the database, etc. 5) We can finish sending the letter (with [data](https://docs.rs/lettre/0.6.1/lettre/transport/smtp/client/struct.Client.html#method.data) and [message](https://docs.rs/lettre/0.6.1/lettre/transport/smtp/client/struct.Client.html#method.message)) or just drop the SMTP session. Second, besides the problem of email *validation* there is a problem of email *normalisation*. For example, gmail addresses `abc@gmail.com` and `abc+1@gmail.com` refer to the same mailbox. Email is often (incorrectly) used to uniquely identify a user, but it should be normalized if we hope to get even close.
OTOH, `#!$%&amp;'*+-/=?^_{}|~@gmail.org` is *not* a valid email address because Gmail has further restrictions on email addresses, and this applies to the vast majority of email providers. Sure, someone could be using a particularly pathological email, but I imagine most people who could end up in that situation will be at least somewhat aware of the difficulties of email addresses, and technically minded enough to find a number of usually fairly simple solutions. Similarly, the situation where the domain is an IP address is unlikely to arise for anyone other than the tiniest minority of users who should be fully aware of what they're doing. I guess this is more along the lines of the 'progressive enhancement' thing - do you need to ensure that every single user can do absolutely everything, or do you impose somewhat arbitrary restrictions that shouldn't be noticeable by the vast majority, in order to ease development?
What does that mean? Do you have a link to the discussion about it being "paused"? 
Thanks! :-)
Great to see IDE support being improved but is there any reason why debugging support is being put on the back burner? How exactly do people debug rust code as it is?
I actually "work" on a library loosely based on Akka Typed, but it is nothing more than a PoC/sketch at this point mostly due to lack of free time.
I understand your reasons for wanting to now code offline from the stream. However, it is disappointing but only because I learnt so much from your first 12 or so Rustendo64 videos as I could see the exact details and process you were working through. vb-rs is very cool, especially the debugger.
I'd definitely appreciate that.
&gt; I constantly ran into errors with the borrow-checker that were, for me, very difficult to decipher. After a couple hours of googling/experimenting, I would only then have a good understand what the problem was, but not what a good solution might be. I felt like I could almost always get things to work by copying data or adding scope, but these solutions felt like hacks/workarounds. (I'm sure there were better solutions that I just didn't understand at the time.) Eventually, I became too exhausted and moved on. This was my first two weeks with rust probably. In particular I had issues with something like: self.foo(self.bar); where I couldn't reborrow something in one line. What I did was just drop .clone()'s all over the place. And then when it was done I decided to go back and say 'ok how do I remove these copies everywhere' and that's how I learned to use lifetimes. If I had tried to learn lifetimes right off the bat I think I'd have been in trouble.
So?
Yes
So it looks like that will all be fixed in a new compilation stage using intermediate representation? Cool.
[removed]
Huh, I'm writing a tool exactly like that in as my first Rust project. I'm reusing as much of ripgrep as possible (love how modular it is). My plan is for the checks to be in a toml file. I'd love to say "talk to me again next week" but my free coding time has been a bit unpredictable.
I suppose that means Rust's docs are setup in an accessible manner for screen readers, or perhaps should be. I remember some discussion on making color schemes colorblind friendly, but this is a different level/
Check out [rfc 1823](https://github.com/rust-lang/rfcs/pull/1823), [rfc 1832](https://github.com/rust-lang/rfcs/pull/1832), and my [stateful](https://github.com/erickt/stateful) crate :)
Thanks for the explanation, I learned something new today.
Rust _is_ on Microcontrollers. A microcontroller doesn't support languages, languages support microcontrollers. You don't have to buy a microcontroller that supports Python or Rust. You just buy a microcontroller, and either the language already supports that microcontroller, or you can spend a month or a year porting the language to that microcontroller, or wait for someone else to. Languages are just a way to express what you want done, they aren't part of the microcontroller itself. Rust already supports a few microcontrollers through Zinc, Xargo, and some other projects. If you want to get started, [start here.](https://japaric.github.io/discovery/)
Consider [imix](https://www.crowdsupply.com/helena-project/imix). imix is a reference platform for Tock OS, which is written in Rust. So in some sense imix is a Rust board.
Thanks!
just saw it on Hacker News
just saw this on Hacker News
Your `kmain` ends in a long `while true` loop followed by `loop {}` to make the function truly diverge. Why not just use `loop` for the loop in the first place? Regarding kernel design, how do you send capabilities between tasks? As far as I can see, channels don't provide that functionality. 
I found that writing an emulator of some kind was a cool project to try while learning Rust. Features like pattern matching and enums (plus the high performance) make the language pretty well suited to it, and it's the sort of thing you can start small with and then work your way up.
Which RFC is this based on? Would be nice to have a link to it in the docs.
I think that might be a little bit too above my level but I could give it a bash. Any resources to help someone get started on that path? 
Thanks for this! A few questions. &gt; perfect for c, c++ ... devs but not for absolute newcomers as the main starting point. What is an "absolute newcomer", and why is it not good for them? &gt; the current doc. Which docs do you mean here?
Ha, great, now I don't have to do it myself. Let me know when you're done. ;D
RMP core knows nothing about optionals, just as MessagePack specification does. Serde binding by default treats `None` as nil. Otherwise encodes directly `value` from `Some(value)` and this behavior can be changed using serde wrappers around `Serializer`.
I'd have to plan a few things out but I don't see why not
for integrations look at Helix for ruby and Neon for node and Cpython-rs for python. For community helping with ide support look at the "rust language server" or the jetbrains plugin for rust.
What alternative are you looking for? There is byngen, that may be what you are looking for.
Yeah this is the second edition, what's there is a rough outline of what we're planning
Do you ever work with serial ports? Maybe in interfacing with microcontrollers? I'd love help with my serial port library [serialport-rs](https://crates.io/crates/serialport) and serial terminal [gattii](https://crates.io/crates/gattii). I have some issues, some of which are easy, listed for gattii on the repo page: https://gitlab.com/susurrus/gattii/issues Otherwise watch This Week in Rust, they list some easy issues for newbies to jump on from various projects.
Niko paused it 3 days ago (search for "@bors r-") and after discussion it was re-approved 2 days ago and merged.
Why should a microkernel only run a single application? As far as I know, the defining feature of a microkernel is not implementing things like file systems and to some degree, device drivers, relegating those tasks to userspace. Minix, for example, is considered a microkernel IIRC, but it is very much a multi-application OS.
I think he/she mixed microkernels up with unikernels.
Gdb (trunk) has rust support. Lldb can get by treating Rust as C. I (and others) do plan on improving both.
I use a debugger all the time, both in my 'real' job (mostly Java) and in my non-Rust personal projects. It might sound a little ridiculous but I honestly rarely feel the desire to reach for one with Rust - if it compiles, it generally does what I want, or I just need a little `println!` to find the problem.
That wasn't completely serious as it currently doesn't even support x86-64.
The deluxe solution is: 1. Use a very restrictive regex to find common problems. The trick is to still allow the address if the user insists it's correct. For the vast majority of users a missing `.` indicates a problem and suggesting to double check with an appropriate hint can help a lot. The rare user with an actually valid but strange-looking special case email address will be impressed and feel special and important as well. 2. Use the RFC compliant checker to confirm it's a valid email address, because being technically correct is the best kind of correct. 3. Send confirmation email to confirm it's really the right email address.
&gt; Automatically converting `&amp;str` to `String` would be much pleasant as well. I'm personally opposed to this. One of the key points of Rust, compared to C++, is how potentially expensive or "dangerous" operations are explicit. This notably means that there is no memory allocation in Rust code that doesn't stem from an explicit function call, whereas in C++ you may have implicit constructor calls or copy constructor calls. When writing low-level software, the ability to ensure that no memory allocation or copy occurs is a god-send.
There is rust support for the teensy 3.2. I'm currently using it to build a keyboard controller I program myself. ARM is supported in general and atmel (arduino and the like) may be as well
I don't know.
Little personal anecdotes: when I make a typo in my e-mail address, it's always in the user part... which leaves me with a valid e-mail address, just not mine :(
FFI means "foreign function interface," so in some sense, no: the only way to talk between two languages is FFI. I _think_ what you're asking about is the *experience* of using FFI, that is, do you have to do it yourself or are there nicer libraries? C -&gt; C++ is easier because they're almost the same language.
That'd be seriously awesome if it could be reintroduced!
Hi, Glad to see someone saw this :) 𝟎𝟐. I referred https://doc.rust-lang.org/book/ as the current doc and http://rust-lang.github.io/book/ as the upcoming doc. 𝟎𝟏. I mean absolute newcomers to systems programming or just for any kind of programming. &gt; why is it not good for them? * It is too long. * It is for memorizing things instead of understanding (unless you know how to write the same functionality in a different language). It is a good example to show Rust's syntax but not a good as a starting point to learn. * It is too complex, just after the Hello World * std, io, preludes, :: &amp; . to call functions, enumerations, extern, struct, loop, match, ..... ; As I said, this is a good example to show Rust's syntax and good for C, C++, Python &amp; etc devs. **can't we teach step by step by multiple simple projects** &gt; Hello Wolrd, Hello Cargo, Hello Modules, Small Intro about std &amp; structure, Simple example how to use a Std function, Write test cases for same code, Simple example with cargo lib and testing .... instead of memorizing things, user can understand things easily :) Also these things should be placed after [Common Programming Concepts](http://rust-lang.github.io/book/ch03-00-common-programming-concepts.html) not before. 
I don't know how much this is still in the realm of syntactic sugar and how much it encroaches upon the higher-kinded types territory, but a capability to abstract over different kinds of pointers &amp; borrowing would be great. An example could be the common builder pattern, where each method has to be duplicated for maximum user convenience: impl FooBuilder { pub fn set_val(&amp;mut self, val: u8) -&gt; &amp;mut Self { self.val = val; self } pub fn with_val(mut self, val: u8) -&gt; Self { self.val = val; self } } (Annoyingly, the standard builder-like types such as `std::process::Command` don't do this). Sugared version could look like this: impl FooBuilder { pub fn set_val(~mut self, val: u8) -&gt; ~mut Self { self.val = val; self } } and hopefully be extendable to `Box`, `Rc`, and so on.
Why doesn't it have a `Cargo.toml`?
Strongly disagree with this, you're just dumping names into the struct's namespace. This is barely better than string substitution. For a start, you shouldn't do anything like this without the ability to have subtyping relationships (i.e. `fn foo&lt;Sub: A&gt;(_: Sub)` can take `B`), and `pub use` doesn't remotely indicate that you're introducing a subtype.
No mention about reducing the functionality gap between stable and nightly? :( We should really make sure we don't develop parallel ecosystems here, which is arguably happening now due to prominent nightly-only libraries such as Rocket. Otherwise, this is a very exciting roadmap! I'm hoping for Rust start seriously rivaling Go etc. when it comes to supporting high performance servers.
The problem is that `AsRef&lt;Path&gt;` is open-ended. Someone making a different library could also implement it, and the docs can't incorporate all of them.
As of Rux, it is not limited to a single application. Its goal is to become a general purpose microkernel (not unikernel). I used a little trick to implement the interrupt handler as normal function return. With the fact that interrupt is disabled in kernel mode, a task's `switch` becomes safe (as in Rust's sense) because it always returns. This allows me to write the scheduler using a simple `loop {}` with a iterator over all the available tasks. 
If you only have a single meaningful branch under that match you can do: let mut itr = tokens.iter(); while let Some(Token(tok)) = itr.next() { } If that's better or worse, I don't know.
Oh, cool.
Now I understood why you guys placed it before Common Programming Concepts :)
I think there is a misunderstanding about what FFI is, here. What *other* way that using the Foreign Function Interface do you expect to be to call a function from a foreign language? What disadvantages do you expect the FFI to have?
So you want `if let` to accept anything that can be to the left of a `=&gt;` in a `match`?
The fundamental problem is that the C language does not encode enough information to make it fully automatic, so you need a human to read what other humans have written about how the APIs should and should not be used. The only difference between Rust and C++ right now is that Rust doesn't have something built into the compiler to automatically translate C headers into `unsafe` Rust function prototypes when it encounters an annotation equivalent to `#include "foo.h"`. (Which is fixable... we just haven't had someone do it yet.) Anything more would be like expecting C++ to automatically generate the classes in [gtkmm](http://www.gtkmm.org/en/) when presented with the core GTK+ C libraries. (Without the help of GObject Introspection metadata)
Most of the big libraries (serde, diesel, etc.) are depending on procedural Macros to do custom derive. That will be stable in 1.15! Beyond that there's the macros 2.0 which will be a thing hopefully soon ish.
You may want to look into [rust-bindgen](https://github.com/servo/rust-bindgen). It makes using an FFI a bit less painful. For some libraries, try searching for them on [crates.io](https://crates.io) - someone may have already done the work of implementing a rustic interface on top of the FFI for you.
Could you link some info about it? I know what brainfuck is but haven't made an interpreter/compiler before. 
Very impressive. Will try it out.
I've tried it great work! I've always thought how the evolution of GUI has made the evolution of CLIs slower... I wonder, will I be able someday to open a tmux (or a more powerful mux) pane split, edit gaming code in vim on one side and see the changes applied to a 3d object filling the other pane? That would be awesome :-)
yes, and facepalm
The page for AsRef in the docs does list all the types in std that implement AsRef&lt;Path&gt;. Maybe the docs could have a "known impls" section that links to that.
Sounds good, I'll put the repo on my GitHub feed. I've always wanted to write a kernel myself, but I'm always scared of the documentation around the initialization sequence. The docs around how the hardware works once you're all set up look understandable, but I don't really know how to get started. Congratulations for getting past that step ahead of me ☺
No love for Powershell? :) (6.0 is [open source too!](https://github.com/PowerShell/PowerShell))
Cmder is on GitHub. Windows console emulators are crippled by dependence on conhost.
Just going off of [this test](https://github.com/jwilm/alacritty/blob/8d3f5f4e179b6fe55617dc72fe60fa1bdfd9b014/src/ansi.rs#L989), it looks like Alacritty supports truecolor/millions of colors. Which is _**awesome**_. Can we add it to https://gist.github.com/XVilka/8346728?
You mean like the REPLs on Xerox PARC, Genera, Oberon, Mac and Windows environments?
I would like i way to use C/C++ code or libraries with no modifications to them, and be able to some how include it in my main.rs, also ideally it would require no outside tool or anything out of one .rs file. I could then call C/C++ functions(realistically i know i would have to use C types in libc, like size_t or smth). Also be able easily convert a C variable type to something in the rust std lib. Basically emulate what C++ can do with C in someways. 
I think it is not too hard even without any previous experience or knowledge about interpreters. Read https://en.wikipedia.org/wiki/Brainfuck then copy-paste the hello world brainfuck example into a file `hello.bf` and try to code a program that will execute the brainfuck code. If you are stuck you can look for example at [rosetta code](https://rosettacode.org/wiki/Execute_Brain****) for the basic implementations, or at https://github.com/Wilfred/bfc for the most advanced project I know on this subject.
Thanks for elaborating! That makes it much easier :) &gt; I would like i way to use C/C++ code or libraries with no modifications to them, and be able to some how include it in my main.rs This would be bindgen, then, yeah. &gt; ideally it would require no outside tool or anything out of one .rs file. This would be feasable if we moved bindgen into the compiler. It's something that may or may not happen, we'll see. &gt; Also be able easily convert a C variable type to something in the rust std lib This goes from "trivial" to "impossible", based on what /u/ssokolow said above: &gt; The fundamental problem is that the C language does not encode enough information to make it fully automatic, so you need a human to read what other humans have written about how the APIs should and should not be used. That is, this works with C++ because it also does not share the safety of Rust, so the types are the same. You _could_ do it with unsafe stuff, but you can't generally get safe wrappers; it's impossible, technically speaking.
My coworker kept trying to get us to use nix for our Haskell builds. He stopped maintaining that when we switched to stack. I get the appeal but I've never had the problem personally that nix seeks to fix.
I thought rust was actually affine types. Which certainly are similar.
I have a project designed to help with this: http://intermezzos.github.io/ There's not much _but_ the initialization sequence in the book so far. Always need more time...
I would recommend to look over this [thread](https://users.rust-lang.org/t/twir-call-for-participation/4821). Participation in already existing open-source projects not only will be a good experience (especially because you will receive feedback from others), but also will ensure that your work will be useful for others.
Sweet! Would _love_ to get this working natively on Way Cooler! I hate only having `weston-terminal` to use as a non-xwayland terminal emulator.
Yeah if this is the only code that actually complies with the RFC, then firstly the RFC is clearly idiotic and deserves to be defacto ignored, and secondly the email servers themselves presumably aren't exactly compliant. What you really need is code that rejects email addresses that no real mail servers would possibly accept.
Will definitely try it out – my current xfce terminal is not so great with colors. Nor blazingly fast.
Looks interesting but the name is seriously cringey.
Looks like it handles the programs I use daily very, very well. I think I've already switched away from urxvt!
I mean, looking at src/lib.rs it's easy to see the list of unstable features in use #![feature(range_contains)] #![feature(inclusive_range_syntax)] #![feature(inclusive_range)] #![feature(drop_types_in_const)] #![feature(step_trait)] #![feature(plugin)] // Appears to only be used for Clippy #![feature(core_intrinsics)] #![feature(proc_macro)] Without looking further into the code, the first 6 are purely quality of life improvements. `feature(plugin)` could be moved into a `#![cfg_attr(feature = "clippy"` if that was the only issue, and the rest are things that look like they will be stabilized eventually. The only intrinsic used is `unlikely`, which is optimization (unless githubs search function missed something) Not sure about `proc_macros`, but it should be stabilized soon regardless. 
You're welcome to do so.