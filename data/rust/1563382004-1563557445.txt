The internet... As there is no moderation tool on the larger internet things like that will happen... This is really bad though.
He might be going through something in his life, so I think it would be a good idea to approach this thing with a bit more patience and compassion (note, he did promise to review the PR in question again).
#CoderGate
&gt; The author didn't see much value in it personally as they understood it was not likely to be any actual issue due to being unsafe code used only internally, only a contributor could introduce the UB and the author was adamant that their code review would prevent that. Even if function is private all functions which can cause UB while being used in safe code **must** be marked as `unsafe` or fixed to uphold safety requirements on which Rust relies. I doubt you would want to work with a project which introduces such function and have it anywhere near your project dependency tree: /// Don't worry, it's an crate-private function, we will catch /// possible UBs during review. fn transmute_copy&lt;T: Sized, U: Sized&gt;(e: &amp;T) -&gt; U { unsafe { let mut t: U = std::mem::uninitialized(); let n = std::mem::size_of::&lt;T&gt;(); std::ptr::copy_nonoverlapping(e as *const T, (&amp;mut t) as *mut U as *mut T, n); t } } I believe the biggest worry which community has is that `actix-web` maintainer does not understand or values the safety model of Rust. We heavily rely on this model and breaking it so easily for questionable performance gains is really worrisome, especially for a library which aims to be one of the pillars of Rust web-ecosystem.
Here is a thread about the past issues in case you were curious: https://www.reddit.com/r/rust/comments/8s7gei/unsafe_rust_in_actixweb_other_libraries
That's awful. I hope he finds another project he's passionate about.
Just curious, does Rust have UBSAN, ASAN, etc. support? Those are "just runtime", but it's a lot better than no runtime detection of UB, etc.
This stuff is fake and fabricated by a troll I know, don't even ask me why I bother to blur out their username, but: [Screenshot](https://i.imgur.com/3jchiwq.png)
&gt;One hundred uses of &gt; &gt;unsafe &gt; &gt; is not just shaky code. It's a totally broken process. how many unsafe use do you think std lib use ? Your previous and current comment don't take in account the size of the library.
Thank you very much, I really appreciate it!
lol
It's a good idea but the whole actix related codebase needs a spring cleaning before a majority can actually understand it. There are other frameworks coming up set to surpass actix's achievements like tide.
The problem is UB. Unsafe is okay, UB is not. If a program contains UB it is not a valid rust program according to the compiler. That stance towards it is not okay.
Yes, you can enable LLVM sanitizers through a `rustc` argument.
I think the key is the word 'core'. Security is a part of the dev's job but it isn't what they should spend _all_ or a majority of their time focusing on. That's the point - without the proper tools, devs would need to obsess over security or introduce security issues. With better tools, the dev can focus more of their time on delivering value and not simply making sure the software is secure.
 fn init_bool(x: *mut bool) { unsafe { *x = true; } } This is UB. According to the [docs](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.as_mut_ptr), turning a MaybeUninit pointer into a reference is undefined behavior and [std::ptr::write](https://doc.rust-lang.org/std/ptr/fn.write.html) should be used instead.
 fn init_bool(x: *mut bool) { unsafe { *x = true; } } I'm not sure whether this dereference manifests the uninitialized `bool`, but in general it would drop the old uninitialized value, which is definitely bad. Use `ptr::write` instead. For the FFI-init example, I did something similar in `std::sys::unix`: https://github.com/rust-lang/rust/pull/62163
[Article discussing this at ZDNet](https://www.zdnet.com/article/microsoft-to-explore-using-rust/)
No sure why downvotes, it was a simple comparison with what happened in #GamerGate.
Thanks, I fixed it in the post. However I believe `*x =` equals to `::write` for raw pointers, because Miri did not catch any undefined behaviour.
I guess the first thing to try would be to use a HTML templating library such as [Maud](https://github.com/lfairy/maud) or [Horrorshow](https://github.com/Stebalien/horrorshow-rs) to render HTML with the data into a string. Then set up a simple web server that responds to HTTP requests with the HTML string, using a web server library such as [warp](https://github.com/seanmonstar/warp).
I've been looking into both Rust and Go lately and noticed a big difference in compile times. Can anyone shed some light on the discrepancies?
[http://seed-rs.org/](http://seed-rs.org/) is also a great option
Here's 5 different ways to do it: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3bd68075a90757326e7df4a33698f028
I agree with you that giving pros and cons on the project (or crates in general) is good for newcomers. In fact, before the article I was under the impression that such a well known crate in 1.0 would have been audited by the community and be safe from UB. As long as people know what they are signing up for, It shouldn't matter what the author's attitude to different design choices is. Tell people the advantages and dangers and let them make the call. But yeah, personally I find it's current stance on 'accept UB or go to an interpreter' to be poor at best. &gt;you're not really speaking to the issue directly Looking back, you're right. More than anything I didn't want to see these threads turn into character attacks against the maintainer. For me at least its sad and disheartening to see someone who volunteers their time for FOSS to be thrown into the mud when there are other alternatives.
Note: due to how privacy works in Rust, any module containing `unsafe` is entirely `unsafe`, as `unsafe` typically relies on certain invariants that other pieces of code with access to the data-members can violate.
Thanks for replying! &gt; To do this, the compiler has to show that such a value exists. It has to choose one value and stick to it, and one choice might make one half of the code easier while the other choice simplifies the other half. In contrast, by making uninitialized memory unstable, this is all trivial. Right, I get that there is a greater overhead on the compiler in that it has to determine that there is such a value (rather than defaulting to 0 or something like that) and then be consistent about it, and that "sticking with it" means that opting for one simplification obviates another one. But it *also* makes things like the `AtomicU32` case simpler, right? There are disadvantages for compiler writers, but it seems like there are *global* advantages for the languages as a whole, albeit in probably nearly impossible to quantify ways.
They aren't equivalent. Dereferencing and assigning with `=` will attempt to `drop` the LHS value before overwriting with the new one. This code happens to work* because `bool`s don't have destructors, but if you were assigning to some type with one then it would result in a `drop` call operating on uninitialized memory. *Even though it happens to work in this case, it's still not behavior that should be relied upon
Good to know. Thanks!
Is this a troll post ?
I'm using rustc 1.35.0 and rls 1.35.0 and am getting a type inference error from the compiler when using an example from the book. [https://doc.rust-lang.org/book/ch16-02-message-passing.html](https://doc.rust-lang.org/book/ch16-02-message-passing.html) That first example: use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); } The compiler throws an error error[E0282]: type annotations needed --&gt; src/main.rs:4:20 | 4 | let (tx, rx) = mpsc::channel(); | -------- ^^^^^^^^^^^^^ cannot infer type for `T` | | | consider giving the pattern a type error: aborting due to previous error It's weird I haven't had any issues all the way up until this chapter with things not matching up with the book.
Is there an easy way to turn a `Vec&lt;(T, U, V)&gt;` into its components of `Vec&lt;T&gt;`, `Vec&lt;U&gt;`, `Vec&lt;V&gt;` ? This seems inefficient: fn main() { let iter = vec![(1,2,3), (4,5,6)].into_iter(); let mut a = Vec::new(); let mut b = Vec::new(); let mut c = Vec::new(); iter.for_each(|(x,y,z)|{ a.push(x); b.push(y); c.push(z); }); assert![a == vec![1,4]]; assert![b == vec![2,5]]; assert![c == vec![3,6]]; } [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4d6754152ccbcdf06c2d5beb30e5b0a2)
Thanks for the detailed response! I see that you were trying to handle the two cases of getting a &amp;'static str or a String, but I'm having trouble getting it to compile. I tried replacing the closure with |s| s.as_str(), but then the call to or() starts complaining about expecting an str but finding a reference. I'll have to look into that.
/r/rustjerk please
Did you even read my edit, where I basically retracted the benchmarks criticism?
One thing I've run into with MaybeUninit is I have a initialization function that takes a pointer to a buffer. \`\`\` /// Buf points to 8 contiguous u32s fn init\_buffer(buf: \*mut u32) { ... } fn do\_work(...) { let mut buf = std::mem::MaybeUninit::&lt;\[u32; 8\]&gt;::uninit(); init\_buffer((\*buf.as\_mut\_ptr()).as\_mut\_ptr()); let buf = unsafe { buf.assume\_init() }; ... } \`\`\` The issue is that "\*buf.as\_mut\_ptr()" is de-referencing the unininited pointer which feels a bit wrong. I think this is OK since the second as\_mut\_ptr, is basically just changing the pointer type, and the uninited contents aren't used. I think casting the pointer type is probably the cleanest, but I'm curious if there's a better option. \`\`\` fn do\_work(...) { let mut buf = std::mem::MaybeUninit::&lt;\[u32; 8\]&gt;::uninit(); init\_buffer(buf.as\_mut\_ptr() as \*mut u32); let buf = unsafe { buf.assume\_init() }; ... } \`\`\`
There is. [https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.first\_ptr\_mut](https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.first_ptr_mut) But this is a nightly-only experimental API.
Any objection at all, it would be really great to do so, thank you :)
You seem to misunderstand some things: 1) The PR in question does not affect a performance critical part of the code - it does not appear to have any performance impact. 2) There is unsoundness in actix - as Sean pointed out in the original thread. You can ltrigger UB by using the service combinators (part of the public API) in a specific way. The PR in question fixes something which isn't unsound *currently* but makes it doable through safe code which is a big no-no on a number of levels. There is absolutely no reason not to accept that PR.
That's a little different because it works on a slice `[MaybeUninit&lt;T&gt;]`, not `MaybeUninit&lt;[T]&gt;` nor arrays. But it's literally just a pointer cast, so `buf.as_mut_ptr() as *mut u32` should also be fine. pub fn first_ptr_mut(this: &amp;mut [MaybeUninit&lt;T&gt;]) -&gt; *mut T { this as *mut [MaybeUninit&lt;T&gt;] as *mut T }
As the book says: &gt;Note that this won’t compile yet because Rust can’t tell what type of values we want to send over the channel. The error disappear in the next step. You'd have the same issue with: let vec = Vec::new();
Sorry I must have missed that. Everything that doesn't compile typically has a crabby telling you it doesn't compile.
&gt; I'm not talking about code, so stop wielding that stupid safety shits. The code is what's relevant. Not the people, not their feelings, not their group-identities. The code.
Sure, but also, we probably don't need 500 people repeating it. I think the message got across just fine without a massive topic.
I'm not finding an assume_init for turning [MaybeUnint&lt;T&gt;; 8] into [T; 8].
I was expecting it to compile to 6502 assembly and was disappointed to see it "just" uses C as an output. Which is then compiled by the already existing cc65 compiler.
Splitting a vector like that is going to require a lot of copying regardless of how it's implemented. If you're asking if you could just take the 2nd and 3rd elements of each tuple out and leave the first, there's not really a safe way to do that except with a specialized method. Anything else would be at risk of leaving the vector in an inconsistent state in the case of a panic; at best it would have to leak all the untransformed elements.
...plus, even if the strawman were correct, I have things I need to code now, not X amount of time in the future when I've become sufficiently proficient in C or C++ to do things safely. That's why, if Rust doesn't meet requirements, I return to Python for a project.
&gt; In this case, the author could simply state that performance is paramount and that unsafe is used liberally wherever he feels like it That is a very superficial understanding of the situation because: 1. the uses of unsafe I've pointed out don't seem to gain any performance 1. a PR that removes unnecessary potential for unsoundness was ignored despite there being nearly no downside to merging 1. this is not the first time that there's been a fiasco over unsafety and Nikolay's attitude doesn't seem to have changed which should be a very big red flag 1. the article raises problems with actix which go beyond just unsafety, including bus factor and barriers for new contributors
This looks like a very interesting approach. I just want to point out that for most system administration uses that are not fronted by a service (such as command line utilities or perhaps scheduled system tasks), the logic will need to actually wait until the answer from the system (list of processes, etc) is available before proceeding with the rest of the work. So, all I'm getting at is the consumer should be aware of (and have realistic expectations about) the applicability of async ps utilities when they consider your new crate. (vs a possibly simpler alternative).
I never disagreed with that. I just don't think "If you think you can do better job, fork it and fix the issues." properly acknowledges how difficult it can be to get familiar with someone else's codebase, even in the best circumstances.
&gt; The bus factor of the project is far higher than it should be. This could be confusing. According to Wikipedia, the definition of the bus factor as "the minimum number of team members that have to suddenly disappear from a project before the project stalls due to lack of knowledgeable or competent personnel." is far more common, which makes a high bus factor desirable. (I'm assuming you're operating from the "number of indispensible people" definition, which is less useful in an open-source project since you need a very large project to have a bus factor other than 0 or 1 under that definition.)
You should file a bug! We should make sure to have that crab...
You're right, I used it wrongly. I just meant to say that if Nikolay disappears from the project then it's probably unsalveageably dead. Will edit
You probably don't want a boxed String, though, as it is already a heap allocation.
To simplify a bit, Go - as a language - optimizes *for* compilation speed very intentionally, whereas Rust and C++ optimize more so for runtime speed or for certain language features. For example, Rust has generics (types with type parameters), which get compiled into individual, monomorphised types for each type/type-parameter pair. Go doesn't currently have generics. [This SO question](https://stackoverflow.com/questions/2976630/how-does-go-compile-so-quickly)'s answers have more examples and details. &amp;#x200B; At the end of the day, the two languages have slightly different goals and priorities in mind. Go makes a lot of trade-offs to keep compilation speed low. Rust makes a lot of trade-offs to make the language powerful.
Yeah, I forgot to actually test that snippet. This is the fixed version with the right amount of derefs: let err_msg = err.downcast_ref::&lt;String&gt;().map(|s| &amp;**s) .or(err.downcast_ref::&lt;&amp;'static str&gt;().map(|s| *s)) .unwrap_or("unknown panic message type");
async seems a bit weird in this context but why not? :)
This is awesome dude, but next time you might ask someone to proof read your writing for you. No offense intended, but there are a lot of major errors. Excited to try your crate out though, good work!
Seriously??
By proof reading you mean grammar or logic errors? And thank you!
Why would you need a dynamic data structure for that? You can safely use a type alias to describe packet payload and change the type whenever needed , like [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e1ab7e644df7f46ced7a79f018371f38). This way you can refer the type of the payload by the alias and change the payload type by editing one line. Of course, you would need to recompile the entire code using the packet type for the change to take effect, but I believe at early prototype stage it is the default, isn't it?
Amateur question: Why do moves need to do a `memcpy`? Why can't the code using the moved value just keep the value at its address and use just that?
Good point. I'm actually pretty impressed with how streamlined and minimal the async syntax overhead is overall, but there's probably quite a bit of dependency and compile time overhead.
It seems like this was still quite a challenge, though. The C code generator needed modifications to generate C code that could work with CC65.
It does not. You included it in there because you wanted to use it as extra material to discredit nikolay's efforts, which is the entire point of your comment. I focused on that, even with your edit, because it's so egregious. You should re-write your entire comment, or delete it. Preferably the latter.
Grammar errors were all I really noticed.
Yes, you are absolutely right. This "issue" is basically solved by public interface, because `Future`s and `Stream`s returned are by definition mean that the result will not be available immediately, but at some point later.
see discussion here https://www.reddit.com/r/rust/comments/ce306u/microsoft_security_response_center_endorses_the/
Well, at least there was no logic errors :) I'm not a native speaker and I do not use English each day routinely, so this is the best I can do right now, even with spell checker and other automatic helpers. Guess I need to focus more on a grammar rules rather than code.
I was not aware, thanks for the info!
I should make this line a project motto
That it doesn't drop the value is definitely something you can rely on - when the type is Copy.
Hey thanks. Didn't notice 🙂
I opened [a PR](https://github.com/rust-lang/book/pull/2033), there should be as much Ferris as needed =)
I understand man, learning another language is hard. I've studied Spanish for a couple years and I still can't write well in it. You're not doing too bad at all.
I wrote the comment initially as an attempt to easily summarize the article to entice people to read it. At the time, I was one of the first commenters, and there was probably less than 10 karma on the post. I have nothing against nikolay personally or anything. I'm not even writing web stuff in Rust right now. Nikolay's done some great stuff in creating actix-web, and I think it was the first real Rust web frameworks if I'm not mistaken. Without Actix, who knows how much weaker the web tooling in Rust would be. I do not want to discredit Nikolay's efforts and I'm surprised and sad that this was what you got from my comment. I want Actix web to be better, like I want every Rust crate to be better. I don't think deleting a line about benchmarking would help. Even just editing it to "the author of this article also wrote some stuff about some benchmarking that may or may not be screwy, but I don't really understand it, so read the article" wouldn't really help. I'm already doing that in the lower edit, and if someone's reading my small comment, they're at least going to see that edit. Don't assume I'm apart of some conspiracy to take down Actix or some shit. I don't care nearly enough, and doing so would be dumb anyway.
It shows at least its making waves and deemed important enough
It sounds sweet in F#, too, until you realize that you are still exposed to all the thousand holes and papercuts of C#.
Good to know, thanks. English grammar books, here I come!
What's so disappointing about this whole episode is the sense of entitlement that some people on this reddit group seem to have. Sure unsafe code is concerning, sure you probably want to avoid it, sure Rust is very appealing to many people because of it's safety guarantees. Actix-web is not getting rammed down anyone's throat, or hyped beyond reason at the cost of other projects. &amp;#x200B; A point that seems to have been lost on so many people criticizing actix-web, is that the maintainer, literally, doesn't owe any member of the rust community anything at all. Please search for articles and concerns around the "Open Source Free Work Problem" and "Maintainer Burnout" issues, which btw have also affected the rust community. The maintainer doesn't have to manage a community, doesn't have to live up to some arbitrary standand and he doesn't have to respond to anything, every maintainer that does, does so out of pure altruism, and people often reward and praise maintainers that do so, and do so well, but there is no obligation. You don't have to sign up to some sort of club with a code of conduct and rules to become an OSS contributor. &amp;#x200B; There is also no contract around the safety guarantees that rust as a language provides for any of the crates published on github, gitlab, crates.io or anywhere else, we didn't pay for the maintainer's time and we are not entitled to any of it either. Consumers of Open Source Software benefit from the great gifts that these maintainers and developers give to us, it lets us build projects and businesses. actix-web is a massive project and a great endorsement of rust as a technology. If fafhrd91 likes beating benchmarks and puts more time into making actix the fastest web framework around at the cost of some UB, that is entirely up to him. If he loses end-users because of that focus, that's fine and no judgement on the project, it simply is just not fit for purpose for some end users. &amp;#x200B; Consumers can patch or fork the upstream work like many Linux distros have done for years, also, when you include a crate in your project or product the burden of it's fitness for purpose shifts to the you, the end-user, go read the licenses carefully, there is no implied guarantee - of correctness, fitness for purpose, having a good community, etc. A crate being published doesn't give anyone an implied right to how it functions or interacts, the burden is still squarely on the consumer to make sure that they understand what they are including in their software, we can't all judge this accurately so we rely on reputation and recommendations, but that still does not put the maintainers or developers of the crates we choose to use on the hook. &amp;#x200B; My thanks truly goes to fafhrd91 for helping all of us put rust on the map for being crazy fast and making software that stretches and tests the technology. It'd be a real shame if the rust community scores an own goal here and loses someone as talented and productive as Nikolai.
Consider the case of creating a value on the stack inside a function, then returning that value to the caller. The stack memory in question needs to be copied somewhere else or else it could be overwritten by any other code that manipulates the stack after that point.
&gt; If fafhrd91 likes beating benchmarks and puts more time into making actix the fastest web framework around at the cost of some UB, that is entirely up to him. If he loses end-users because of that focus, that's fine and no judgement on the project, it simply is just not fit for purpose for some end users. ​ This assumes that Actix has a bigass "this library invokes UB" warning. It does not, which means that it is hard for users to properly evaluate whether they want to use it, because they will see benchmarks and assume that it is reasonably safe thanks to being written in Rust
Unless you're only ever limited to a *single* process or something, these tools will probably have huge impacts in terms of making much simpler and more performant system monitoring code.
I was reading a bit about differences between Rust and OCaml compilation. Did Rust kind of shoot itself in the foot by following a Haskell approach with Higher Kinded Types, instead of following a more OCaml approach with Higher Polymorphic Types? Is that why Rust will forever struggle with compilation speed or is it a different aspect of its design that makes it a problem?
Definitely need to check these out! Thanks
I'm not exactly sure about your tone, because it's the internet. But this sounds really patronizing "I think someone just needs to talk 1-on-1 with the guy. He seems kind of unfamiliar with the way people collaborate in FOSS". If your goal is to sieze his ego and force him to conform, then this is a great method. It has about 0% chance of working because no one likes to get bad rubs.
I found [coffee](https://github.com/hecrj/coffee) to be comparatively easy to get up and running with to everything else I tried.
Oh, don't get me wrong, if you look at my other comments you'll see that I _totally_ agree with you. The point I was adding here is that the author of Actix could defuse the whole situation himself by putting up a frontpage warning to the effect that _he doesn't really care_ about usage of `unsafe` and that we can all fuck off if we don't agree with him (or something to that effect). And that would be the end of it, because we live in a free world and he's entitled to handle his repo anyway he wishes. Actually, the "UB" comment he made is already not far from that, might as well go all the way and make that clear. If the users were informed of the compromises involved, we'd have nothing to say.
Yeah, agreed.
I suppose using new compiler features should be a major semvar bump but I doubt anyone does that.
Believing that a crate uses no unsafe is just an assumption, any crate that you use could have unsafe in it without ever mentioning it. Or could claim 100% UB free unsafe and be wrong. Or claim ‘no unsafe’ and lie. Unfortunately the burden falls on us in the end. You are correct that we can’t all evaluate the code deeply, including myself, but our lack of depth or manpower doesn’t shift a burden on to the maintainer. It merely means we choose to trust. The big favor that other community members have done for us in this case is they have raised a flag, which at least can give us pause to reconsider or make us search for alternatives. The responsibility is ultimately still ours.
I did that on my phone and wasn't paying much attention, I'm going to remove it. Thanks for the heads up
I did that on my phone and wasn't paying much attention, I'm going to remove it. Thanks for the heads up
&gt;In Rust, developers typically add some measure of stability in that there should not be major API breaks between 0.n.x and 0.n.y, while changing the second number indicates some API changes. This isn't really just something developers "typically do". Cargo assumes crates do this, and that updating the minor version is valid and won't break anything. So `cargo update` can use the newer version and not expect breakage. It's true that such compatibility behavior sub-1.0.0 isn't part of the semver standard; but it is part of the variant cargo implements.
Maybe (s)he is writing an interpreter for a (maybe DIY) scripting language, and thus needs to create variables that can hold data of any kind of type - at runtime.
I think he should just pull actix from the benchmarks. No one would care about the unsafe code if it wasn't scoring at the top.
As a german, I wouldn't say "heim" is Old German. I'd say it's current german.
\&gt; The whole point of Rust is to be able to have both. &amp;#x200B; And isnt the whole point of Rust's \`unsafe\` to be able to have both, in even more cases?
&gt; What features from rust nightly are you using that keeps you from using rust stable. Funny
Started this a couple of months back. Had planned on doing more refactoring before releasing it, but after much procrastination and false starts I decided I might as well let it out, seeing as I've found it so useful already. It uses web-view, with a custom upstream webview fork that fixes some leaks and uninitialized variables. It doesn't use it *well*, but it at least works. I'll be reworking basically all of it in due course, particularly the whole mess of the backend loop. Either way, it's saved me about 400GB across a few TB of games and apps - if it's not pretty, it is at least effective.
lol
Personally I'd say that number of uses is potentially suspicious, but not necessary a problem in itself. Assuming the uses are justified, careful, and properly commented. There certainly are reasons for a library to use a fair amount of unsafe code. Trivially, I'd expect that in a library that wraps C code. Looking at the [curl crate](https://github.com/alexcrichton/curl-rust), a dependency of cargo, `rg 'unsafe \{' | wc -l` (not an especially good measurement) outputs 87, though the library is only a few thousand lines of code. 100 uses of unsafe in a library like actix-web might be fine (and desirable for performance) if done well, but though I'm not too familiar, this blog post doesn't inspire confidence.
Really cool! How would this compare to using [rust-psutil](https://github.com/borntyping/rust-psutil) with either `std::thread` (for kernel threads) or [fibers-rs](https://github.com/dwango/fibers-rs) (for user level threads)? Cause then users can opt into the asynchronous part if they want to (or not). I assume having futures built into the library would make the asynchronous aspect more seemless for one.
My god.. Rust is in the big time.
&gt; 2) unsafe-at-any-speed absolutists who are apparently willing to disparage the best and most featureful Rust framework to date, out of some misguided notions of purity Rust sells itself on being memory-safe. If a maintainer is over-eager to use `unsafe` in internal APIs, such that all it takes is one human slip-up to invoke Undefined Behaviour, I'll stick with Python. At least the complexity of writing compiled Python extensions in C or C++ and the added complexity of deploying compiled extensions of any type has historically pushed people to stick to writing Python extension in Python (ie. the memory-safe side of the equation) more strongly than the `unsafe` keyword does. &gt; I kinda doubt either of the groups have written a single line of code in their life. Most of my Rust work isn't public for various reasons, but the boilerplate I put together for moving myself off Python for writing little utilties should give you an idea of how much care I put into things: https://github.com/ssokolow/rust-cli-boilerplate Aside from that, most of my code is old and ugly because of stuff that's been going on in my life for the last few years.
It isn't *just* an MS stance.... That's the stance of essentially every company that I've interacted that wasn't a security consultancy or in some sort of "mission critical" industry with external standards and such. Which is part of why baking it in at the language and compiler levels is important; Anything short of breaking compilation as a result these issues just isn't loud enough to be heard over the whining of accountants. Build the code as cheap and fast as possible and keep it running as long as possible with the minimum possible (financial) overhead. It makes perfect sense from a business perspective and none at all from an engineering perspective. That's one of the handful of reasons Open source ages better in most cases; its a lot harder to sweep the gross hacky shit you just did under the rug and wait for it to become someone else's problem. Which isn't to say that there isn't gross Jacky shit in OSS just that people have to own it ;)
I think you can use `MaybeUninit&lt;[T; 8]&gt;` and initialize its elements with `offset` and `ptr::write`.
That copy could be avoided, but there isn't a way to do it with `String`'s API. I wouldn't worry too much about it because as long as the capacity increase is exponential the number of times that it can happen is small.
Those users are at fault for having that expectation. If you want to impose some standard, form an organisation that audits crates and puts them on some approved list (or not). Or pay someone to do this for you. What you cannot do is demand that other developers do this work for you, for free.
OMG i can't believe i actually made it to QotW xD
Isn't you comment a fine straw man's argument? Meaning that [u/deep\_fried\_eyeballs](https://www.reddit.com/user/deep_fried_eyeballs/) now would had to defend his/her opinion, because you including the stdlib - which is a very different lib compared to actix-web
It's a tricky balance. Bryan Cantrill (from Joylent) repeatedly points out, the thing that resonates with him about Rust is the cultural values of the community: a focus on correctness and speed. And from that focus flows many influential ideas, practically demonstrated by working code. The fact is that the author of actix has slightly different values that the wider ecosystem finds hard to accept. We're not very good at both communicating this difference clearly to the wider community (many of whom are new and asking questions like "which web framework should I use?"), and without making the feedback seem like personal attacks.
Agreed. If anything, this could make people shun `unsafe` more aggressively if they feel (correctly or not) that it's unacceptable to have doubts about specific instances of it. (ie. Be wary that people who feel deprived of the ability to distrust specific instances of `unsafe` might resort to distrusting *all* instances of it.)
Thanks for the insight! A little more about: &gt; And it would be a huge shame if you couldn't. Imagine all the messy, buggy C++ code you and your coworkers might generate over the next few years, filled with memory and multithreading errors. Imagine how much effort you might have to go through just dealing with the mess of a language that's C++. Rust is like C++, but without all the bad parts. I'm just not sure if it matches your definition of mature, and neither of us know. So you gotta figure it out man. I don't even have to imagine it: I'm witnessing it first hand on a &gt; 10 years old code base. Trust me, if I can use Rust, I will :) And I'm not giving up easily. Now, like you say, I must look deep enough.
Cheating is the wrong word, but whether here, or on sites like the Benchmarks game, I think that the "race to the bottom" for every language to one-up another ends up with code that looks nothing like code you'd actually deliver to production. I want to see benchmarks comparing languages/frameworks based on the **idiomatic** way to write in that ecosystem, the kind of code that would pass complexity analysis tools, code review, and see the light of day in actual software that needs to productively deliver secure and maintainable code as much as fast one.
Thank you for your fantastic work on this project. Criticism is totally fine and needed for further improvement on any project, but the way some people communicate here is disgusting and will only lead to fewer people being willing to share their work.
Given that perspective, I do wonder how many people want to revisit the idea of badging crates which use `unsafe` on crates.io without also being maintained by the Rust team. I worry that, if people who used to use interpreted or VM-based languages see this, they'll interpret it as indication that they were wrong to start using Rust, because they're *still* expected to understand the arcane things that kept them off C and C++ in order to audit their own crate dependencies.
You could also create a `[MaybeUninit&lt;T&gt;; N]` by `MaybeUninit::uninit().assume_init()` which is the one rare case that *isn't* UB because `MaybeUninit&lt;T&gt;` doesn't need to be initialized. After initializing each of the array elements, you can `mem::transmute` to `[T; N]`.
Dayyyym Mr. Riggleman knows
I'm perfectly aware of the situations when one actually needs dynamic payload, thank you. The description in the post, however, sounds more like the type of payload should be statically known, but the exact type is not decided yet. In this case introducing anything dynamic is counterproductive.
Surprising to hear a congressperson know what github is. Found his [bio](https://riggleman.house.gov/about) here. I wonder where he got the idea "Rust is 37 people in San Francisco".
lol I thought that was a joke but he actually asked that, awesome.
Wat! Libra, the alleged new currency for the world is so solid - trust us! ... oh, but builds on nightly! I don't get these crypto people... Either way, what kind of dark (or some might say simply deceptive?) sorcery is happening here. Doing \`cargo build\` using my local stable toolchain \`1.34.1\` on the current master branch of libra: \`\`\` cargo build info: syncing channel updates for 'nightly-2019-07-08-x86\_64-unknown-linux-gnu' info: latest update on 2019-07-08, rust version 1.38.0-nightly (6e310f2ab 2019-07-07) info: downloading component 'rustc' ... \`\`\` Am I missing something here? Why would you automagically fiddling with the local toolchain instead of doing the canonical \`+nightly\`?
I was mostly pointing to the [word etymology](https://en.wiktionary.org/wiki/heim#Alemannic_German). Would it sound better with origin changed to Old Norse?
just transmute it
My reaction watching the video: Wow, is this man really a politician? (i couldn't believe first hand) Going further, found out he really is \^\^'' &amp;#x200B; Great technical points and questions. Is this pretty common in USA, because could say i never saw these type of questions coming from a politician in Brazil. Even the Facebook's represent was kinda *astonished* by those queries coming from this congressman. &amp;#x200B; Well done Mr. Riggleman my /applauses
Pinning to a nightly build that is known to work isn't utterly horrible. It's similar to pinning to specific library versions.
&gt;Thanks for the insight! You're welcome! I'm really happy I convinced you to look further. :) Good luck!
Cargo automatically downloads the toolchain specified by a rust-toolchain file. https://github.com/libra/libra/blob/3d2a68e95077b47bc238333c833db03223aaff7b/rust-toolchain
Relentless.
Not really in my book. It's the "Old" part that's putting me off. Why make it more mysterious than it is? But this might also be me being too nitpicky.
It is worth pointing that Denver Lee Riggleman III, the congressmen you linked has a Big Foot Erotica work. So he maybe just _extremely_ online.
Many of us aren't even in the US, let alone San Francisco. Also I believe there are more than. 37 of us.
color me surprised. didn't expect that level of technical competency from a US govt hearing. Nice stuff!
Today I learned, thanks.
I'd love some stickers! (or a t-shirt, fwiw) I think RESF is at best when presented as a joke up-front. Great way to spark a conversation on a positive note.
&gt; I worry that, if people who used to use interpreted or VM-based languages see this, they'll interpret it as indication that they were wrong to start using Rust, because they're still expected to understand the arcane things that kept them off C and C++ in order to audit their own crate dependencies. I'd rather they overestimate the difficulty and stay away than underestimate it and mob up on open source maintainers that fail to meet their expectations. If this whole drama leads to people being more careful about their dependencies then at least something good has come of it. Too bad the step of collectively denouncing a prolific author couldn't be skipped. I don't think the so-called "nice" Rust community is handling this correctly and were I in the shoes of the author of actix I would be adding extra unsafe blocks out of spite at this point. I'm glad he's a better person.
Honestly I get that impression when I hear about anything new in tech, but it looks like this guy actually did his research. Pretty surprising that he started asking about nightly vs. stable features and the authenticity of core Rust lang commits.
There are dozens of us... DOZENS!
Honestly, I don't know what to answer, just thought it would sound cool. Plain "German" it is :)
Rust compiler perf has very little at all to do with either of those things. The main difference from *both* Haskell and OCaml is its value representation- everything is unboxed by default, and generics are monomorphized. On top of that, LLVM does a lot more optimization (and has a lot more *opportunity* for optimization) than Haskell/OCaml. And then there's just the quality of implementation aspect- a lot of things addressed in this post are just universal performance optimizations that you hit in any project, and there's a lot more where they came from.
Nah this is extremely unusual here as well
&gt; gfx-rs Javelin project kick-off 🎉 This is super exciting for anyone doing 3D graphics in Rust.
[removed]
&gt; I'd rather they overestimate the difficulty and stay away than underestimate it and mob up on open source maintainers that fail to meet their expectations. My point is that the Rust ecosystem has a problem ensuring that people don't conflate the values espoused on the language homepage with the values used to develop a given project. People are reacting based on an emotional investment in that misconception and, unless the core problem of that misconception getting *established* is addressed that's going to continue to happen. (ie. Either develop a way to clearly warn people about these disconnects, force projects into compliance, clearly advertise that Rust may not be safer than C or C++ in practice because the ecosystem doesn't document which projects play fast-and-loose with `unsafe`, or watch this kind of sourness recur.) &gt; and were I in the shoes of the author of actix I would be adding extra unsafe blocks out of spite at this point. I'm glad he's a better person. Reminds me of how I stayed away from [Quod Libet](https://en.wikipedia.org/wiki/Quod_Libet_(software)) for over a decade based on claims that they'd gotten so fed up with Gentoo Linux users that they'd tried to slip in a logic bomb.
Yes, absolutely.
PR in question could only have UB if you are hacking on actix-web itself. It was internal API and only maintainers of actix-web could have triggered UB.
Article states it's not erotica. It's a bigfoot hunt or something, and that's it. Erotia was a political opponent's accusation.
Yeesh. I didn't realize constructors are so yucky. The more and more I read about Rust's design, the more and more brilliant it is. Wow.
&gt;San Francisco Is it where the Mozilla devs are working on the Rust code base that is used in Firefox?
I'm picking my jaw up off of the floor.
Well, seeing the bright side, he just gave a huge visibility to Rust, i hope we vote for more technical people with political engagement/skills like him.
When it comes to software that handles anything money - security isn't taken lightly. Think hostile states, like Russia, Iran, North Korea, wanting to destabilize the US, money system, and/or the currency.
You tried increasing the memory availability to the Docker daemon? By default I think it's limited to like 4GB or something like that
I, too, really appreciate /u/fafhrd91's work on Actix. At the end of the day, it's really hard to ship something usable and he's done it. And don't tell me that everyone in the rust community doesn't get a little tingle of happiness seeing rust at the top of the TechEmpower benchmarks! I get the differing philosophies on `unsafe`. I would really support tooling that highlights how much it's used in crates, for example, for people to make decisions like that themselves. It's funny. For how much rust styles itself as a welcoming, open community, parts of it can also sometimes be among the most vicious, close-minded people I know. The Elixir community, by contrast, I've never seen anyone get anything but the kindest, most understanding help even though it doesn't seem to particularly make a big deal about trying to be inclusive. Could just be the number of people involved. I think there's more people who use rust.
Kind of sad that "Users feel that large number of dependencies == bloat" is a factor when really it's the same amount of code. In the linked thread, I see burntsushi's comment that "It is a good metric, because each dependency comes with its own set of overhead. Maintenance status, documentation quality, MSRV policy and more.", but all these tokio crates seem to live in the same repository and can be expected to be similar in all those respects.
The only effect of this post is to fuel the drama, please don't. We already have two threads discussing this at length.
I don't know enough about async. If I just want the number of cores now, can I just get them? &amp;#x200B; I don't really understand the advantage of async.. say someone wants cpu::physical\_count(). That shouldn't take a measurable amount of time, and there is no need to keep calling it, it isn't going to change. Could you give me some kind of idea as to why someone would ever want that asyncly?
&gt; The only usual dependency is libc. With the caution that, unless you're using the musl-libc target, you need to build against the oldest glibc you want to support. (Eg. via a container)
The String type represents an owned &amp;str, just like a Vec&lt;T&gt; represents an owned &amp;[u8] (both achieve this by storing the data on the heap, rather than the data segment or stack). You can create a mutable reference to an owned string: let s: String = "Hello World".to_string(); let s_mut_bor: &amp;mut str = &amp;mut s; Rust will ensure that there are no immutable or other mutable borrows while s_mut_bor exists. Otherwise, it is not possible to create a &amp;mut str from a &amp;str because of Rusts reference rules.
What's a `ServiceCache`? I can't find anything about it on either Google or Github.
Whoa, really? So is that just used for binaries? I need to look this up! Here I've been manually pinning the nightly versions in Docker. Appreciate the info!
And what of the C, C++ and Go benchmarks? The systems these benchmarks run on is a giant pile of unsafe code. In the scheme of things actix-web using some unsafe isn't something I find all that concerning. Sure, it's not \_ideal\_, but consider it from a C/C++ developer coming to rust perspective - it's just not that big a deal.
Govts who code
It doesn't have to buffer the sequence. You can trade space for speed here by letting the sub-iterators sort out their elements separately. Not nearly as efficient (*O(mn)* instead of *O(n)* for *n* elements with *m* keys) but fine for most cases. Like [this](http://github.com/BartMassey/groupby).
Specifically three dozen and change, it seems.
He did his research, as expected from former avionics engineer. That is the problem with engineers, it may not be their field of work but it will take them very little time to get the basic knowledge of it. Doubt he has ever programmed in Rust but it is obvious he is very efficient at gathering intel by simply reading topics on the Web including this sub reddit of course. Or maybe someone else did it for which I highly doubt given his background.
"Isn't it true, you've used unsafe dozens of time in the last month alone, and remember, you're under oath!" "Objection, your honor!" "Are you now using, or have you ever used, actix? Did you, or did you not, star the actix github? Answer the question!"
Dumb question: why can't you just do `[MaybeUninit::uninit(); 8]`? It [seems](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8063ff7defebf34310b9062fdd98789d) to compile at least. And it looks a lot less scary!
Because in the specific case we are discussing, an alternative to undocumented, unsafe code was provided and was met with derision. You can't complain about how the OS community is mean when you were mean in the first place. And we're not talking about someone *merely* complaining about unsafe or something. We're talking about a pull request that was documented, had tests, and where an issue was demonstrated. Frankly, I don't care if his reasoning for being an snide was that it was a patch to a private API, even if you don't want to accept the patch, you act polite about it. So either suck it up or stop promoting your project. He's had a bad attitude about this shit for a long time so I think the latter is more appropriate. You can submit a PR to fix code, it takes someone *wanting* to be different to get better.
Yeah I'd get one
Python got this right with their stack traces. I'm unaware of any other languages that do this.
That only works for `T: Copy`.
You can probably do what you want with traits or enums but you may want unsized types https://doc.rust-lang.org/1.5.0/book/unsized-types.html Something like: ~~~ enum List&lt;T: ?Sized&gt; { Nil, Cons(Box&lt;List&lt;T&gt;&gt;, T[]) } ~~~
I laughed...until I saw the references to `actix`. Too soon, methinks. There's definitely other great punchlines you could use, though!
Yeah thats a mostly up to date list of the currently used nightly features, I'm sure theres a more elegant way to identify all of the nightly features than grep, but it works well enough :) &amp;#x200B; The intention of that particular script is to eventually help us move towards eliminating the use of nightly features and limit depending on new ones so that we can eventually be on stable. Some features (like async/await) we'll need to wait until they've graduated to stable while others we should be able to make sufficient changes to stop relying on them.
A republican could be the second coming of Turing and i wouldn't give them the time of day.
Completely untrue. Except iterators are superior because you can do plenty of things like decide to run the iterators in parallel at the call site without needing a degree in category theory or understanding call/cc.
I've seen very few people make literal demands like you're saying. It's perfectly reasonable to 1) not use actix because of its de facto policy with respect to `unsafe` and 2) warn others about this as a downside of actix since actix doesn't advertise this policy.
He just merged the PR.
shuuuuut the fuck up already
Ok 'jordanpeterson' user.
He referenced GitHub, pull requests, frontends, backends, commits, nightly builds vs stable builds, JavaScript and Rust in two questions...referenced from a Congressman. What fucking Twilight Zone world did I wake up in.
👋 I'm the maintainer of [Electron Packager](https://github.com/electron-userland/electron-packager), which uses that Node module for the ASAR capabilities. Amusingly enough, RIIR has been on my TODO list for a while (mostly to see if there's any performance benefit), I just haven't gotten around to it because it's a *very* low priority compared to other Electron-related things on my (free time) plate. Honestly, getting paid to work on it would probably raise it to the top of my list. Personally, I'd approach it in a few steps: 1. Direct port from JavaScript (enough of the API so that it would work with Electron Packager) 2. Neon module 3. Feature parity 4. Idiomatic Rust 5. Speedups Is there a particular use case you want this for?
Yep, love that guy. Shame he gets misrepresented so often. Flattering that you took the time from your apparently very busy and fulfilling life to stroll through my comment history :) enjoy all the memes (and hilarious one-liners) I’ve posted!
Since moves are an implementation detail and can't be detected from code shouldn't it be possible to implement return value optimization without breaking any existing code?
That's... idiomatic in places, but personally I prefer to match the way people tend to handle strings- just take a `&amp;Path` or `PathBuf` directly and let the caller do the conversion. It gives you simpler type signatures, it's faster to compile, it puts less bloat in your binaries, and it's arguably clearer at call sites too.
Just draw a line around the outside of the text part, following it's general shape roughly. Leaving some of the background between the text and the border should look fine.
Bummer.
3 dozen and the high-five bot.
How was your experience with rodio? I've tried using it and found it full of issues, especially with its built in mixer. It causes pretty heavy distortions in the audio during mixing or when doing things like changing sample rates of files.
Bad bot
That's pretty much right, yes. Although I tend to only use generics like that in public methods or if I really need it. Otherwise, I just define them as concrete types instead: `fn(filename: &amp;Path) { ... }`. The typical reasoning for this is it reduces code bloat, where as using generics results in a new copy of the function for each unique type actually used (which might wind up being `String`, `&amp;str`, `&amp;Path`, `PathBuf`, `&amp;OsStr` or `OsString`). If you look inside `std`, you'll see this pattern: pub fn some_public_func&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; ... { some_public_func_imp(path.as_ref()) } fn _some_public_func(path: &amp;Path) -&gt; ... { ... } Or something to that effect. That way, you'll get a few copies of the small public API function, but only one of the actual implementation. Orthogonally, the other variant you might see is: fn foo&lt;'a, P: ?Sized + AsRef&lt;Path&gt;&gt;(filename: &amp;'a P) -&gt; &amp;'a Path { ... } Or, with elision: fn foo&lt;P: ?Sized + AsRef&lt;Path&gt;&gt;(filename: &amp;P) -&gt; &amp;Path { ... } Which is useful when you need to carry the lifetime or do something with the base type (where `P` is a DST). Example: https://doc.rust-lang.org/src/std/path.rs.html#1798-1800
Just leaving this comment as another vote for a mac version.
Well, I wish people vote for technically adept *Democrats*. As smart as he might be, he’s a *Republican*, and unfortunately, that negates anything positive about him.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rustjerk] [U.S. House Committee on Financial Services hearing: "Why was the Rust language chosen? Do you believe it's mature enough to handle the security challenges?"](https://www.reddit.com/r/rustjerk/comments/ceknqx/us_house_committee_on_financial_services_hearing/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I don't know.. You got and still get a lot of positive feedback about the features and speed in actix, just look at your own post history. You really pulled of a really good crate. But obviously you will also get the negative feedback, even more when you ignore rusts core values twice: Safety. And that means also avoiding undefined behaviour in unsafe code, leading to soundness holes, and being able to break with every rustc release. I still like actix &amp; actix-web, I still think we can overcome these problems, but obviously for that you have to accept that people won't be ignoring nor shutting down when you clearly state that you favour speed over safety in rust. Even more when the unsafe code doesn't even improve speed nor ads usability.
The problem is that people see Actix at the top of the benchmarks and then see it's written in Rust, and they know that "Rust = safety", and so think that Actix will be safe. So Actix is riding on Rust's reputation, but not paying back by actually fulfilling the contract with the compiler that would make it safe. So that's bad faith, in a way, just like marking something that's unsafe as safe is bad faith. It's like they're coding in a variant of Rust that has none of Rust's guarantees, not even in safe code. If it said up front that it doesn't aim to be safe, then everyone would have fair warning. Otherwise how would they know? Not everyone follows these reddit discussions. The danger is that it's Rust's reputation on the line in people's perception if something goes wrong, rather than Actix's. I have no interest in using Actix, but it bothers me a lot if it means that we never know whether we're coding in the unsafe-but-looks-safe variant of Rust or Rust as designed. So it's undermining the integrity of Rust.
Actually, considering you're going by the moniker svartalf, I would say change it to Old Norse.
Another constructor-less language is Go. Which is interesting because it has a form of inheritance called embedding: when you simply add the type with no name as a member, any member/method called on it that isn't there, is deferred to the embedded field. This forces you to construct the parent struct together with the new members of the child.
Isn't it the case that anyone using `unsafe` should be doing tons of checking before and after any use of it to ensure that invariants are being held?
If you want it to be easy, just write a separate function that does that. If you want it to be efficient, you'll probably want to split a single mutable iterator into 3 mutable itarators, which means that the original vector will have to stay alive in the scope of those 3 iterators. That will likely require `unsafe` though. fn split3&lt;T, U, V&gt;(input: &amp;mut impl Iterator&lt;Item=(T, U, V)&gt;) -&gt; (impl Iterator&lt;Item=&amp;mut T&gt;, impl Iterator&lt;Item=&amp;mut U&gt;, impl Iterator&lt;Item=&amp;mut V&gt;) {}
After having a talk with crate author it seems that he is really burnt out, this explains those comments. He's working for 2 years (probably unpayed) for 8-16hours so he take it intimately. He's conserning about performance loss in this case, and I cannot blame for position "if you cannot construct UB via public API then everything is Ok". PR author could benchmark the changes and show that there is no loss in performance so change is a win-win for everybody. Just different goals for different peoples. Worth communicating and explain positions to each other.
This function fn init_bool(x: *mut bool) { unsafe { x.write(true); } } should be unsafe fn init_bool(x: *mut bool) { x.write(true); } because otherwise safe code can cause UB with `init_bool(123 as *mut bool)`.
&gt; Which is interesting because it has a form of inheritance called embedding: when you simply add the type with no name as a member, any member/method called on it that isn't there, is deferred to the embedded field. This forces you to construct the parent struct together with the new members of the child. There have been proposals to add something similar to Rust. We already have "deref coercion" where if you try to call a function that doesn't exist it will check if `(*value)` or `(**value)` or so on has that function. The proposal was to add something like a `#[delegate]` attribute to a field that would use that exact same lookup strategy but by accessing that field instead of by calling `deref`.
It appears to be one of the goals in [Do move forwarding on MIR #32966](https://github.com/rust-lang/rust/issues/32966).
I think I saw somewhere in The Book that it mentioned that Vec and String are smart pointers. That kind of makes sense to me now; they're basically two ways of referring to the same kind of data.
Delegating should happen at impl, something like impl Trait for Type as Pattern(Type); Where `Pattern(Type): Trait`. The problem with doing it at data is that it opens up a whole can of worms: * Why shouldn't enums be able to implement traits shared by all variants? * Will structs have diamond inheritance? How would the whole thing work? * What about member access or destructing? Will this require exposing that we are inheriting/wrapping something or would we be allowed to do this transparently?
If you can trigger UB in safe code that's a compiler bug. However, if you have UB in unsafe code, that will leak into your safe code in the same way that a data race or use-after-free in unsafe code may leak into safe code. It is the responsibility of unsafe code to make sure the world is non-anomalous at the end of the block.
So. instead of Microsoft using the name "R#", how about "IronRust"? ;)
And the whole main function should be replaced with: fn main() { let x = true; dbg!(x); } Because unsafe and mem::MaybeUninit are dangerous.
I want to watch the video, but it says that it's not available. Anybody else currently having that issue?
I conveyed that information in my message.
Why should he care which language is used in the first place?
Great post! As another example, factory functions work nicely in higher-order functions -- `.map(Vec::with_capacity)` is fine in rust, but `.Select(new List&lt;int&gt;)` doesn't work in C#, and needs to be `.Select(x =&gt; new List&lt;int&gt;(x))` instead because constructors aren't method groups.
`debug_assert!` is nice to use, and I try to use it where I can. `assert!` can also be used in some circumstances, but if you're using `unsafe`, it's _usually_ for performance reasons, and an `assert!` inside a hot loop would be counter productive. My usual thing is to add asserts where I can, and a provide an argument in comments justifying the use of `unsafe`.
Interesting! I've seen the various number of functions produced by examining binaries, a lot of Rust code seems to be with generics, but I was trying to make it look like what everyone else was writing. I hadn't thought about splitting with public/internal versions, that's neat.
I've shot myself in the foot before with partially initialized objects or sub-classing overrides sabotaging constructor. In Java particularly, it's really really tempting to sometimes use the many ways to do something 'weird' during de-serialization for performance and screw yourself.
Excellent post! I especially prefer Rust factory functions over conventional constructors for their ability to convey some meaning through the function names, e.g. `new()`, `from_str()`, `with_capacity()`. It makes the readability of the resulting code much nicer, IMO. Also, I believe I found a few spelling errors: `sturct`, `JMV`.
What prevents people from forking the project and changing the leadership?
My goal had been to make calling functions with paths consistent across the crate, since it seems like I'm using `PathBuf` in some places because I'm joining paths, and in others I'm ending up with `Path` or dealing with `Strings`. However, it doesn't sound like the additional variations of functions produced within the binary may not be worth it.
Remember these hearings are often used for posturing and getting your "gotchas". In this case, the question about what nightly features were needed wasn't answered. That may have been exactly the desired effect: It makes the congressmen look good, like he knows what's going on. It makes Facebook's Marcus look at least neutral if not bad, since he doesn't know the answer. &amp;#x200B; It doesn't really matter what the answer is in that case. It's just a way to manipulate appearances. Typical politics.
If you're curious, you can find the [list of nightly features they allow](https://github.com/libra/libra/blob/master/scripts/nightly_features.sh): "--and" "--not" "-e" "async_await" "--and" "--not" "-e" "box_patterns" "--and" "--not" "-e" "box_syntax" "--and" "--not" "-e" "checked_duration_since" "--and" "--not" "-e" "crate_visibility_modifier" "--and" "--not" "-e" "drain_filter" "--and" "--not" "-e" "duration_float" "--and" "--not" "-e" "exhaustive_patterns" "--and" "--not" "-e" "never_type" "--and" "--not" "-e" "panic_info_message" "--and" "--not" "-e" "repeat_generic_slice" "--and" "--not" "-e" "set_stdio" "--and" "--not" "-e" "slice_concat_ext" "--and" "--not" "-e" "specialization" "--and" "--not" "-e" "test" "--and" "--not" "-e" "trait_alias" Some, like `async_await`, seem reasonable due to active work on them and their expected stabilization timeline. Others like `test` are also reasonable due to only being used for test; and a few are just library features that could probably be implemented by an extension trait if they ever went away. But some of these seem like features that have been long stalled out due to thorny design problems, like `never_type`, `box_syntax`, and `specialization`, and so which could change in substantial ways. On the other hand, they explicitly pin a nightly compiler, they have tests, they fuzz their system, and they use Mirai which is an abstract interpretation system to statically analyze certain assertions in their code. So it doesn't seem like it should be that hard for them to adapt safely if they have to remove usage of some of the nightly features.
It seems like everything is a visitor pattern in rust.
&gt; Being disrespectful was not my intention at all but I can totally see how the post, and this section in particular, may have come across as such. &gt; &gt; Innocent third party here, but it seemed like that was your intention throughout the post. The general rule for criticism of code anywhere I see, is you can severely attack the code but making any utterance of the person's name/username should never happen. People can get defensive about attacks on their code, which is when you have to remind people "you are not your code", but you're making more directed call outs of him personally.
for the same reason we care about rust? Some languages are better at doing certain things. If you want to write poetry with an uncertain time sense, English is a poor choice. Time is baked into the language, Mandarin though would be a useful choice. The same applies to computer programming languages and their usage.
Disagree. There is no way to make the point that I am trying to make without calling into question the maintainer's behaviour. I think burntsushi said it better than I can: https://www.reddit.com/r/rust/comments/ce09id/why_we_need_alternatives_to_actix/ety4hkz/
I guess this is just differences in opinion then. The above is how I personally operate.
How do I save a reference to a dynamically loaded library? I'm using `x11-dl` crate to work with X11. I need a reference to the libraries loaded in many places in my code. So far I've came up with this. Is this ok? How can I do better? ``` extern crate x11_dl; use std::ffi::CString; use std::mem; use std::os::raw::*; use std::ptr; use x11_dl::xlib; use x11_dl::xrandr; use x11_dl::xrandr::XRRScreenResources; use x11_dl::xlib::Display; pub struct X11 { xlib: xlib::Xlib, randr: xrandr::Xrandr, display: *mut Display, } impl Drop for X11 { fn drop(&amp;mut self) { unsafe { (self.xlib.XCloseDisplay)(self.display); } } } pub fn connect(display: &amp;str) -&gt; X11 { unsafe { let xlib: xlib::Xlib = xlib::Xlib::open().unwrap(); let randr: xrandr::Xrandr = xrandr::Xrandr::open().unwrap(); let display = (xlib.XOpenDisplay)(ptr::null()); if display.is_null() { panic!("XOpenDisplay failed"); } X11{ xlib: xlib, randr: randr, display: display, } } } pub fn some_feature(x11: &amp;X11) ... ```
1) Forking is not trivial, especially in a project of this size and complexity. That said, I would welcome a fork and there's no problem with it. 2) Another purpose of the article is to notify end users about the library so that they can avoid it, if they want.
Compiling LLVM is actually the faster part of compiling the rust compiler. When you have enough cores, it takes less than 2 minutes... while the rust compiler build still takes half an hour. (disclaimer: these are numbers from a few months ago, with 72 cores ; things may or may not have changed)
&gt;Well because we tell the compiler that a bool is either 0 or 1, if the compiler can prove that a value of type bool is uninitialized memory it has successfully proven the program has Undefined Behaviour. No, it doesn't matter that we didn't read the uninitialized memory. Well.. is that a bug, then? It *should* matter that we didn't read from it?
&gt;It *should* matter that we didn't read from it? No it does not matter at all, because you initialize a boolean with neither false(0) nor true(1). See [https://doc.rust-lang.org/reference/behavior-considered-undefined.html](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)
Why not build an unbiased metric into crates.io? e.g. Number of unsafe blocks If the worry is about unsafe being needed in a lot of cases and being a poor metric, let’s all push for something else that works? Maybe a crowdsourced section on crates.io about “risks”/“reviews” (like products on Amazon) and the author/potential users can choose to engage with these risks through an ecosystem wide, specialized channel for criticism. (As an outside observer) Doing this through reddit, about a single crate at a time, just seems very biased and targeted. Not only do I now want to contribute less, but it makes me worry about the longterm stability of the ecosystem as a whole.
Rocket has been on nightly since forever
Safe-wrapping SSE2
&gt; I have no problems with self deprecation Just remember to include a proper deprecation message so when you are no longer supported everyone knows what to use instead.
Both go and rust are set to overtake c++ in the next couple of years. Python has already oveetaken java.
That completely misses the point. One can absolutely use `unsafe` correctly, but a function that gives safe code access to UB is not something you should put in a "how to replace mem::uninitialized()" post. Your own example is already doing this correctly in the other spot: let state = unsafe { ffi::crypto_sign_ed25519ph_init(s.as_mut_ptr()); s.assume_init() // s is definitely initialized }; because FFI is `unsafe fn`s anyway, so making `init_bool` an `unsafe fn` would even a better example _in addition_ to being correct.
I might be out of the loop here, but what's the problem with Actix?
&gt; Why not build an unbiased metric into crates.io? e.g. Number of unsafe blocks This (and your review idea) have been discussed since the dawn of crates.io. You are not the first, and you will not be the last, to bring it up. It only sounds good on the surface. There are upsides and serious downsides to it once you dig in. I do not want to get into it, you should search this subreddit and other Rust forums instead. Moreover, it's pretty much orthogonal to this entire mess: the issue is not the _use_ of `unsafe` itself, but how it's used and how it's justified. You can't capture that in a metric, other than perhaps "number of CVEs filed against the project," but that's super coarse and certainly not helpful in the case of `actix-web`. Also, "why not build..." is an answer to almost anything. Let's do the best with what we've got for now. If you're an outside observer, you should appreciate that this actix-web issue is pretty dang subtle, and is likely difficult to understand if you aren't familiar with how Rust's safety system operates and the kinds of guarantees it needs to uphold. Given `actix-web`'s mindshare both inside and outside the Rust community, there is a lot at stake here for the ecosystem and even the credibility of Rust itself. This makes emotions run even hotter. &gt; (As an outside observer) There were a lot of things the community could focus on. Criticizing and piling on through reddit, about a single crate at a time, just seems very biased, targeted and not scalable. Not only do I now want to contribute less, but it makes me worry about the longterm stability of the ecosystem as a whole. Yes, as I've mentioned in several other comments already, this is problematic. On the one hand, people who are considering using `actix-web` really should know about this stuff. On the other hand, this particular criticism is primarily lodged at someone's judgment, which is hard to express without hurting feelings. Lots of folks could have been gentler, that's definitely true. But it's hard. Since this is the Internet, and since this is a _serious_ shock to some core values that are generally shared throughout the Rust ecosystem, it becomes easy to pile on. The next time a thread like this comes up, if I catch it in time, I'll be sure to try to warn folks about piling on. (Probably the mods should do that too. cc /u/matthieum /u/llogiq.) But that's hard, because lots of folks get defensive because of miscommunication, and then everything spirals. Putting yourself and your code out in the open is always a tricky thing to do. It's hard for me to truly empathize with how that feels though, since I've been doing this for so long (over 15 years of open source) that I've forgotten what that fear is like. (Although, I am still fearful about _what_ I say online. But that's a different and off topic conversation. :-)) &gt; Criticizing and piling on through reddit, about a single crate at a time, just seems very biased, targeted and not scalable. I've been heavily involved in the Rust ecosystem for over five years. `actix-web` is the first crate I know to simultaneously be very popular and abuse Rust's `unsafe` directive. That it is so uncommon is part of the reason why folks have responded the way they did. I have literal zero dependencies in all of my projects (dozens of them) that are maintained by someone with this sort of attitude toward `unsafe`.
https://old.reddit.com/r/rust/comments/ce09id/why_we_need_alternatives_to_actix/
Even compiler does not complain like this.
Good article. I'd just add that there is another spectacular way to shoot yourself in the foot with 'constructors' in certain languages, namely, reflection and deserialization are alternate ways to initialize objects which may, and usually do, go through different code paths. My worst experience was probably mixing both. You see to create a normal object, i used reflection as a poor man's substitute of closures (before they existed in java) to 'help' create `Action` objects. What i didn't understand at the time is that reflection trick would complicate immensely my initialization because closures are lazy (they wait until the closure is called) while the way i was using reflection was eager. That + deserialization meat i was trying to access un-initialized objects in the 'action' classes all over the object graph as I de-serialized. Not very smart.
&gt;a function that gives safe code access to UB is not something you should put Fair enough =) Updated the post.
How was your experience with gfx? Did you have to invest in extending/fixing it to complete tasks? Or was it feature complete for your uses?
May also be useful to know (if you didn't already) that you can specify a build target (and/or build options) in `.cargo/config` (and cargo will look for this all the way up the directory tree). I have a small projects directory with binaries I need to run on (basically) any Windows machine, so I use this to make sure all binaries target 32-bit windows and statically link the C runtime by default. Makes it really easy for someone who doesn't know anything about Rust (or even programming in general) to compile and use the binaries without issues.
/r/playrust
I can't figure out how to get this to compile, however I do understand why it doesn't compile ```rust trait Foo { type Out; fn bar(&amp;mut self) -&gt; Self::Out; } struct MyOut&lt;'a&gt;(&amp;'a mut usize); struct MyFoo&lt;'a&gt;(&amp;'a mut usize); impl&lt;'a&gt; Foo for MyFoo&lt;'a&gt;{ type Out = MyOut&lt;'a&gt;; fn bar(&amp;mut self) -&gt; MyOut&lt;'a&gt; { MyOut(self.0 as &amp;'a mut usize) } } struct Starter(usize); impl Starter { fn make_my_foo&lt;'a&gt;(&amp;'a mut self) -&gt; impl Foo&lt;Out=MyOut&lt;'a&gt;&gt; + 'a { MyFoo(&amp;mut self.0) } } ``` [playground link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=71f242842b5e13cd740bcb5fe5bf36e3) I don't know how to do fix this without changing the signature of `fn bar(&amp;mut self) -&gt; MyOut&lt;'a&gt;` to `fn bar(&amp;'a mut self) -&gt; MyOut&lt;'a&gt;`, but the thing is that I cannot change the trait, it needs to be without any lifetimes. For this example I'm defining it, but in my code I just implement someone else's.
You use a cryptocurrency made in DoubleSpendScript?
The competence is overwhelming!
Update (I'm sure there's a comment about it here already) looks like the author apologized and thanked the community, ended up merging the PR?
Which is *undeniably* the best language ever.
You can replace it with the slightly shorter form, using `impl` instead of explicit generics: pub fn foo(filename: &amp;impl AsRef&lt;Path&gt;) { /* ... */ }
Excellent work, though I'm curious how far these sorts of micro-optimizations can go. Last I heard, which I admit was quite a long time ago by now (Rust 1.6 or something?), a major part of the problem was that rustc was rather sloppy about how it generated code and so ended up potentially making 100's of megabytes of LLVM IR, most of which then vanished again in optimization passes. I know that improving this situation has been a big goal of of the MIR intermediate representation, and I like the idea of just making the compiler smarter to reduce the amount of work it makes for itself. Anyone know anything about that, or am I imagining this conversation? I really should go find out the state of this myself someday, and see what can be done about it...
Don't forget bors!
Python will overtake everything. Rust is pretty neat tho, I like it.
Normally, congress people ask about if Facebook can see their data when texting on WhatsApp, and why Trump's face comes up when you googl3 "idiot".
this is really, really interesting. I perused through some of the gui stuff, and it felt very educational. Thanks for sharing.
&gt;Python has already oveetaken java Lol. Completely different usecases. Good luck writing a large scale distributed system in python.
This is the first thing i saw after waking up, like what ? Nice stuff.
Incorrect
I'd like this guy more if that accusation was true.
I believe it's not possible without changing the trait, since it implies `type Out: 'static`. You don't have to redefine the `bar()` method though, if you change the trait like this: trait Foo&lt;'a&gt; { type Out: 'a; fn bar(&amp;mut self) -&gt; Self::Out; } But you'll then be unable to implement `MyFoo::bar()` in a safe way.
Wow - I'm surprised I missed this. I'll have to start looking into alternatives for the microservices I've been working on. Thanks for the heads-up.
I'm looking for a string tokenizer à la [spaCy](https://spacy.io/usage/linguistic-features#tokenization). I've seen various references to vtext, tantivy, and nom. Each seems incredibly different and since I'm rather new to NLP, I'm not sure what fits my needs. Is there a 'standard' tokenizer crate? Do I need to [build my own](https://nitschinger.at/Text-Analysis-in-Rust-Tokenization/)?
I believe it's not possible without changing the trait, since it implies `type Out: 'static`, i.e. the return value of `bar()` can outlive any implementor of `Foo`. You don't have to redefine the `bar()` method though, if you change the trait like this: trait Foo&lt;'a&gt; { type Out: 'a; fn bar(&amp;mut self) -&gt; Self::Out; } But you'll then be unable to implement `MyFoo::bar()` in a safe way. I believe you want something like this: trait Foo&lt;'a&gt; { type Out: 'a; fn bar(&amp;'a mut self) -&gt; Self::Out; }
They are asking from user's perspective, not developer's.
It's still a widely-cited theory. I've never seen data that backs it up. It may be true!
The Congressman was not asking from a user's perspective, he was asking from a security and stability perspective.
Thanks. Unfortunately I cannot make any changes to the trait `Foo` as it is from another crate.
I actually drove past they're sf office a month ago so I believe that's what he referring to.
/r/playrust
1) Why are you using a very young language for this? 2) WTF are you using features found only in nightly -- doesn't that smell of bugs and security flaws? &amp;#x200B; Answer 1) Umm... because that what the developers wanted to use. Answer 2) Because, you know, it's what we needed. &amp;#x200B; Yes, I am surprised to see anyone these days tear into programmer hype culture like that. I feels kind of good. I like Rust, but you can't blame the congressman for his common sense questions. The questions weren't all that technical if you cut through the jargon but the were legit.
I don't think this difference is necessarily fundamental. In Rust you can do \`.map(Some)\`, so in principle Rust-with-destuctors could allow \`.map(Vec)\`.
How does that change the answer? I know generally which languages are used to write my software and I know how that changes their deployment and usages. It matters, even to users.
I don't like that you are downvoted to hell like that, but I utterly disagree with you on this point: \&gt; Nik doesn't care to justify his position nor teach others from the internet how to evaluate unsafe. Nobody want to get “taught” that UB is fine if it doesn't cause a known bug. A piece of code that can cause UB in safe Rust is a bug. That's the whole point of using Rust in the first place! One can use all the `unsafe` you want, but please comply with this simple rule. `unsafe` is here so you can write safe abstractions on top of unsafe code. There can be bugs in unsafe code that can lead unsafety to leak, and that's no big deal. But if someone shows you the bug, **and files a PR to fix it**, [keeping the bug because you don't care](https://github.com/actix/actix-web/pull/968#issuecomment-510814540) is not an attitude that inspires confidence.
You can use cargo-watch, there is also a section on the actix user guide about it
&gt;However, it doesn't sound like the additional variations of functions produced within the binary is worth it. I'm not entirely sure what you mean here, but using `AsRef` only makes the API slightly easier, I think: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=86a982cfc38f4aacfbb6fffc100d7293
I feel like you are setting up some pretty unrealistic demands here. What puts you in any position to ask other software developers to prove anything to you? I've worked professionally with C++ for over a decade, and let me tell you, there are so many pitfalls it is almost unbelievable. However, I would say the biggest challenge in C++ these days is not avoiding memory bugs, just because experienced C++ developers are already thinking along the lines of Rust's borrow checker, which is indeed invented by people who have a lot of experience designing software in C++, and C++ has evolved to the point where there is plenty of handy tools available in the standard library. No, the biggest UB-related challenge in C++ is avoiding the death of a thousand cuts lurking in unexpected places. Things like signed integer overflow, array slicing, oversized shifts, incomplete rule-of-5/rule-of-7, unhandled moved-from object state... These are not exactly memory-related, but they don't exist in Rust due to Rust having more sane semantics from the get-go. Most importantly, you must toil for many years to acquire enough working knowledge of these ugly corners, before you can confidently design around them. This is why I might share your skepticism about "beginner-style" C++ code. As I've already said, avoiding `unsafe` gives a valuable guarantee that a piece of software does not contain a certain class of bugs. It does _not_ give any guarantee that it does not contain bugs that will crash your program in unexpected ways and that are hard to debug. The presence of `unsafe` does not tell you that a piece of software contains UB, and it should not impact your trust in the library's author by itself. It seems unnecessarily purist and cantankerous to dismiss a piece of software containing `unsafe` on those grounds alone. If you want to avoid bugs introduced by dependencies, I'm afraid you are not significantly better off in Rust than in other languages - you have to review their code yourself. This could be as simple as checking the line coverage of the test suite, or you could go deeper for critical software, but it remains a reality of writing software.
I'm using this already (which I got from the user guide). I'm specifically asking about having the browser refresh automatically during development when JS files are changed - or items in my static folder. I've had it working with the npm package I listed, and it's amazing for working with react in nodejs. I'd just like to know if something exists for actix-web that is similar.
Maybe you can just expand your cargo-watch command so that it watches static/dist folders too?
I thought he was referring to the Libra currency development team with that, but maybe I misunderstood?
Perhaps I'm missing something here. How will this refresh my browser/react component? It'll just run a cargo command right? Not what I need. Maybe I'll have to go write this reload thing myself - figure out how the npm package is doing it.
I guess I'm reacting to the moral outrage here, rather than the particular merits of avoiding `unsafe`. There can be a thousand reasons why an open source developer chooses to disregard an otherwise potentially good PR, and I don't think that aggressively calling someone "untrustworthy" or accusing them of being a bad software developer is constructive in any way. I think we all would hope to find both grace and forbearance in our daily work.
You’re not missing anything I am just throwing out half assed ideas. I would ask on the actiz gitter but I don’t know of anything that autorefreshes exactly
What changes for your usage of git (for example) if it's implemented in perl, ruby, c, c++, prolog, or bash? Your answer is about language, not even a runtime, which could have some effect on startup and run times of the tool (mitigated by eager jvm startup tools, for example), but still zero effect on your usage. Languages matter for problem expression. From this perspective, the tool you use is it's own mini-language of the specific problem set. What other general language was used to bootstrap any specific mini-language has zero effect on the mini-language user.
Unless you require it all to be Rust from the bottom up, [GStreamer](https://gstreamer.freedesktop.org/) can do that and has rather complete [Rust bindings](https://crates.io/crates/gstreamer). The [workshop](https://github.com/sdroege/rustfest-rome18-gtk-gst-workshop) we did at last RustFest is basically doing what you write above apart from the streaming part. It instead writes to a file and comes with a GTK UI. For the streaming part you have many options that are supported out of the box by GStreamer, including simply sending the data as-is over a plain TCP connection.
You don't need to have full proficiency of C++ to write safe `unsafe` code in Rust. You only need to understand the limitations of Rust. For example, it is not uncommon to have higher-level invariants upheld by your data structure, which lower-level data structures know nothing about. You may have a handful of vectors that are guaranteed to have the same length in your program, but you want to access elements across at the same index very frequently. In that case, using `Vec::get_unchecked()` is perfectly justified to avoid repeated bounds-checks, but that requires an `unsafe` block (as it should). Less experienced programmers may assume that a bounds-check is free; it is not, compared to a memory access. Whether it matters may be up to the particular usage pattern, so a library may try to accommodate patterns as broadly as possible without incurring unnecessary overhead. All that said, if we are really talking about what character traits that engender trust in other software developers, I would be much more suspicious of deliberate ignorance than tendency to use `unsafe`...
Thanks, I'll look into that!
In terms of creating a secure product, I would be much less worried about porting code using nightly features to stable, and much more worried about the occasional codegen bug in nightly. These are precisely the things that can introduce some extremely mysterious security holes.
You can... If you have a lot of hardware and a lot of CO2 quotas... ;-)
Go is not a serious contender to C++. Nobody writing C++ today is excited about Go (or rather, if they are, they should not have been writing their product in C++ in the first place). But a lot of people writing C++ today are excited about Rust. The main obstacle is developer familiarity (and consequently, hiring availability), so it will be a good many years before Rust overtakes C++. Meanwhile, the integration story is limited by things like the lack of inlining between Rust and C++ parts of the program.
To be fair, these answers would never cut it in big enterprise let alone government, so his questions were pretty on point!
Rocket keeps amazing me the more I use it.
"Withing" in the sentence after "sturct".
Works for me
The Bulgarian tax agency [got hacked several days ago](https://www.reuters.com/article/us-bulgaria-cybersecurity/hackers-hit-bulgaria-leak-data-from-russian-email-government-idUSKCN1UB0MA) and many GBs worth of financial and personal data got leaked so first I built a [small tool](https://github.com/martinsotirov/napgate) to eatimate the quantity of leaked info (emails and personal IDs), and then I built [a small search engine](https://github.com/martinsotirov/napgate-search) on Rocket that checks if your data is among the leaked docs (haveibeenpwned style). At first I tried extracting the data with Node.js but it was crapping its pants, especially when it came to filtering out the duplicates among 10+ million personal IDs.
See also https://llogiq.github.io/2019/05/18/momo.html, a macro to apply the monomorphisation-bloat-avoidal splitting technique.
While going with gstreamer as the previous comment suggested is probably your best bet, you could look into using rav1e, the av1 encoder.
(Paraphrased) "It's not typical at the DoD to depend on unstable code, so why are you using nightly? You can answer me later via mail" "I donno, guess I'll have to ask my team and send you a mail." How is this posturing? It's a very legit question. Sounds like you're making excuses for rust, and that makes the language/community look bad.
If you think git wouldn't be different if written in python, you haven't been paying attention. Just because all Turing complete languages are Turing complete does not imply all Turing complete languages are equivalent \*in all ways\*. Brainfuck is not used for professional development of anything, and for a good reason. Languages don't \*require\* you to solve problems in certain ways, but they sure do move your thinking in one direction or another. Being written in rust means software has in general certain behaviors and constraints that other another language might not and so the software written with it will tend to behave one way or another. If you think not, then why would you bother learning any language but the first you ever learn?
I think the question is more whether it implicitly creates the `&amp;mut self` that *would've* been passed to `drop`, thereby allowing the compiler to assume the value is initialized and leading to UB. I don't think the formal semantics have been nailed down enough for anyone to confidently say that it doesn't (slash won't in the future).
Note that Firefox doesn't have such a large amount of Rust code: https://4e6.github.io/firefox-lang-stats/. And while the language surely doesn't help, there are large classes of vulnerabilities that aren't caused by the host language, but by the JavaScript JIT, or are higher-level in nature like e.g. web pages being able to read local files through the PDF viewer extension.
YouTube was historically almost entirely python. A significant percentage of it still is.
Implementing a QuadTree to learn Rust.
You got me wrong. I’m just saying people are mistreating that guy. His faults are faults, but nothing is so significant that it makes his project unrecoverably “unsustainable” and instantly harmful to the community. The project has been actively maintained, and the guy has listened to people, regardless of his attitude. Just some discussion and patience would have solved this problem without causing all this fuss.
Well, to continue your example, what happened here is that someone wrote a blog post demonstrating that the `get_unchecked` could be called with out-of-bounds indexes. That's *absolutely* something that needs to get fixed. Your posts here would be reasonable if the actual situation was "someone complained that they're using `get_unchecked` in a sound way", but *that's not what happened*.
And safety issues have been found in `std`. But you know what happens? The response is "thank you for finding that!" and they get fixed. The problem here is not the *usage* of unsafe code, it's the unwillingness to actually fix it. (It's like back in the day when companies wouldn't fix security bugs. Thankfully that's no longer acceptable.)
I think you just described my dream application programming language! After working in Rust for a couple of years, it's going to be really hard for me to go back to an imperative language that doesn't have those three core things you mentioned. If someone makes this, I'll totally use it, as long as it could interoperate well with all the Rust code I have already written... ;)
&gt; For example, something like before and after Firefox Quantum. This can be tricky. As some Mozilla people have pointed out, a parallel CSS engine was attempted twice in C++, and failed both times due to overwhelming amounts of threading issues. Stylo (Quantum CSS), written in Rust, succeeded. How do you compare "project was abandoned due to unresolvable issues" with "project completed, possibly with a few bugs"?
&gt; because C++ is not expression-oriented language (which by itself is OK!). Is it though :P? Honest question. What would be the reasons to design a new general purpose language without being expression oriented?
I'd like a variantion of it that: * is JITed * does not allow `unsafe`, or at least allows dynamically loading code rejecting any form of unsafety, * allows tight control over what given code can access (a piece of code can only access what was passed to it). My main goal is to build operating systems that are purely sandbox-based and compiler enforced, eliminating need for MMUs, kernel/userland distinction and so on. Objects/resources are capacties and if a piece of untrusted code did not receive a filesystem object as an argument - it just can't do filesystem operations. But it could be useful for building any general purpose VM/sandbox eg. for distributed applications.
The only thing I really disagree with is exceptions. What I originally liked in Go, and what also drew me to Rust, is exactly the lack of invisible error propagation. Yes, it adds more boilerplate, but crates like snafu and failure help a lot with reducing the awkwardness; and it makes error conditions and handling visible and a priority. Apart from that, this sounds like a weird offspring of Swift and Go, with Rust ownership semantics mixed in. And yes, I would love that language!
Hm, kind of disagree on mostly eliminating `Send`/`Sync`. I think it's a pretty fundamental to making concurrent programs actually reliable, i.e. avoiding runtime failures or deadlocks from concurrent modification. But maybe just using them as annotations *would* be enough...
That's the kind of attitude that leads to a toxic community. We should not be scaring people away by dog-piling on them.
I concur that in the proverbial RustScript, I'd want to keep the overall model of GC-free memory safety (albeit with a simplified/more restricted syntax), as well as emphasis on concurrency safety. I also agree that the single biggest impact on simplifying the language would be abandoning explicit control of stack vs heap, which would also remove the need of manual pointer/reference management (autobox everywhere, like Java), remove different ecosystems in static vs. dynamic dispatch (e.g. `dyn`), etc. Let the business of allocation be fully managed by the compiler - it can try to optimize what it can, but without surfacing that in the language syntax. The *other* thing I'd do with RustScript (the article doesn't mention it much) is very heavily slant toward implicit casting and inference. Rust is in the middle of an eternal debate between the two polar opposites (and it makes sense, being a lower-level system language), but in a scripting language, I really want to almost never have to read or write `as`, `::`, turbofish, and the other myriad ways of casting/converting data from one type to another, where it's possible to infer automatically in a lossless way. To a degree, of course, I wouldn't want it to be as loose as JavaScript.
&gt; You don't need to have full proficiency of C++ to write safe unsafe code in Rust. You only need to understand the limitations of Rust. There's a difference between writing `unsafe` code (which I do to some small degree) and feeling confident in my ability to audit dependencies written by other people, which use `unsafe` in ways I may not be entirely familiar with.
What do you suppose the tradeoffs are between Result and exceptions?
Definitely a fun thought experiement! I'd love to have a rust-like language that could catch my data races but targeted a different spot on the performance/ergonomics curve.
I *think* the proposal is to make *everything* Send/Sync?
This is language specific. For instance, in Java, you can write `IntStream.of(1, 2, 3).mapToObj(ArrayList::new)`. It is a special syntax, but it can be done.
&gt; Cargo automatically downloads the toolchain specified by a rust-toolchain file. Little nit: it's actually rustup, to be precise the cargo wrapper that rustup provides: https://github.com/rust-lang/rustup.rs/pull/1172
I reall like this. It allows you to check out an older version in git and it would compile just fine without having to figure out which nightly version it used to use back then.
It's interesting that TiKv seems to be treated as its own product now, rather than jus a thing powering TiDb. I also just discovered that it's a CNCF project now, nice! Having a quality distributed key/value store in Rust is great. Now we only need sled to mature so TiKv can replace RocksDb with it so we have a full Rust solution.
Gfx pre-ll worked very well for me, yes I contributed some fixes &amp; extensions. Most recently I added the bc1 &amp; bc3 compressed texture support there that Robo Instructus uses throughout.
I don't think this is turning this pointer into a reference, for a non-`Drop` type like `bool`.
Yes it is.
It's worked ok for my uses, which I suppose is fairly simple playback of music and occasional sounds effects.
Congressman Bigfoot erotica x rust is the crossover I never knew I needed
Is that something tooling like clippy can catch, or do you as a dev need to be aware of it upfront?
For myself, I have a CI job which runs the build in a lowest-common-denominator environment (oldest libc I care to support, etc) and then the constructed binary `target/release/$project` ends up put into a package which is added to an apt repo which my targets can then install via `apt install $project` -- complex, though I'll admit I'm a Debian developer so I kinda like this approach :D
Unless you're doing something very odd, `rustup` is generally always installed as the user running `rustup-init`.
Would be nice if MS invested in a Rust debugger
I don't think it should, because this function can be valid depending on the passed pointer, and passing a pointer to uninitialized memory can be valid depending on the function. AFAIK clippy doesn't have any rules that do this kind of cross-function analysis. Before using unsafe a dev really should read about the things he wants to use, because there can also be other weird invariants to uphold. It's unsafe after all.
I reall like this. It allows you to check out an older version in git and it would compile just fine without having to figure out which nightly version it used to use back then. Hopefully they'll put their Cargo.lock into git, as well, at one point in the future.
yeah, but i hear there is some gdb support and stuff
+1 I don’t think RAII changes ergonomics of exceptions much: try-with-resources/with, though are less powerful than RAII, work good enough for non-memory resources. I don’t think I’ve ever seen resource leakage caused by exceptions in GC languages. What I’ve seen a lot though, is difficulty with dealing with “borderline” error conditions which happen fairly often and must be handled. Using exceptions for them, even in a small codebase, significantly complicates reasoning about the code. I do agree that things like exceptional io errors are easier to deal with via unwinding. Perhaps an unwrap operator (!!) can be used to have both results and unwinding conveniently.
Yeah, you can debug it as is but it's far from a good experience
And that change is in the banana stand. There's always money in the banana stand.
Is there a reference or linter that can assist in picking up on potentially concerning code like that though? Or do I need to have a fairly good understanding of such upfront? If clippy was appropriate it wouldn't have to flag it as an error, and could be opt-in? I'm a forgetful developer that makes mistakes often, so I like to lean on tooling to assist me with warnings/suggestions or outright problems. It's one of the reasons I'm fond of Rust and leveraging automation where possible.
It's also current Norwegian (in many dialects).
I've done something very similar. A incredibly simple solution that works well enough and takes maybe 10 lines of code: * use cargo watch * On startup, store a startup timestamp and expose it via a endpoint like `api/dev/version` * in your client side code, check the endpoint every 1-5 seconds and refresh is the timestamp changed
I can’t seem to find it but a saw a comment from someone that as they’ve increased the pool of users with WebRender enabled they’ve actually seen error rates go down, not up as you might expect from such a fundamental change.
Rust on WASI? :-D
Thank you, very kind!
Meanwhile, in /r/golang: &gt; Rust is not a serious contender to C++. Nobody writing C++ today is excited about Rust (or rather, if they are, they should not have been writing their product in C++ in the first place). &gt; But a lot of people writing C++ today are excited about Go. The main obstacle is developer familiarity (and consequently, hiring availability), so it will be a good many years before Go overtakes C++. Meanwhile, the integration story is limited by things like the lack of inlining between Go and C++ parts of the program.
That only gives you the video encoding part of the whole story though. Note that there's a GStreamer encoder plugin around [rav1e](https://gitlab.freedesktop.org/gstreamer/gst-plugins-rs/tree/master/gst-plugin-rav1e) available (and it's written in Rust).
Well, unsafe means that the compiler can't prove the code correct, so it's not really feasible to write a program that does that reliably. There are some very complex C++ static analysis tools that try to catch similar things, but they work on a best-efforts basis and can have false positives and negatives when the code gets too complicated. Since a compiler or any other tool can't reliably prove unsafe use correct, it relies on a much more complicated tooling - a thinking human reading the docs - to prove it. Unsafe itself is the limit beyond which automation isn't possible, or it wouldn't need to be unsafe at all. So it's the programmer's responsibility to use unsafe only when strictly necessary(for FFI or performance), and otherwise lean on the compiler by using safe abstractions. So design your code to be safe, keep unsafe use minimal and local, spend a few (tens of) minutes reading the docs and thinking before commiting unsafe code, and get someone else to review it too. Since it's supposed to be used rarely and carefully, you need to afford the extra time, focus and effort when you decide to use it.
This is a subreddit for the Rust programming language, not the game. You might want to head over to r/playrust with your question instead.
Is `rav1e` fast enough for real-time streaming?
Let's go through the list: * [async_await](https://github.com/rust-lang/rust/issues/50547) will stabilize pretty soon, it's been explicitly announced in multiple places. * [box_syntax](https://github.com/rust-lang/rust/issues/49733) is going to be phased out, I'm not sure whether [box_patterns](https://github.com/rust-lang/rust/issues/29641) will be phased out as well but I definitely don't think they'll stabilize any time soon. * [checked_duration_since](https://github.com/rust-lang/rust/issues/58402): library feature, I don't see anything speaking against stabilization, but not much support *for* it either. * [crate_visibility_modifier](https://github.com/rust-lang/rust/issues/53120): It's a long thread with lots of back and forth and as there is no explicit agenda by any of the teams, I doubt they will stabilize it soon. It might even be removed in the future. * [drain_filter](https://github.com/rust-lang/rust/issues/43244): it seems the libs team didn't want to stabilize stuff, not sure whether they still hold that opinion: https://github.com/rust-lang/rust/issues/43244#issuecomment-376886108 * [duration_float](https://github.com/rust-lang/rust/issues/54361) is likely stable soon, there is a PR for it to stabilize it: https://github.com/rust-lang/rust/issues/54361 * [exhaustive_patterns](https://github.com/rust-lang/rust/issues/51085) likely to stabilize together with never_type (see nmatsakis comment). * [never_type](https://github.com/rust-lang/rust/issues/35121): this one was stabilized once and then they removed it again because of bugs. Not sure whether the bugs are all resolved, I guess they'll wait until stuff like `mem::uninitialized` has been removed from codebases so it'll take some time. * *panic_info_message* (tracking issue is closed): not sure why here one just can't use the Display impl. * [repeat_generic_slice](https://github.com/rust-lang/rust/issues/48784): I guess this is a good candidate for filing a stabilization PR for, there seems to be consensus for stabilizing it. * **set_stdio**: don't use this one if you ever want to run on Rust stable, it's an internal feature. * [slice_concat_ext](https://github.com/rust-lang/rust/issues/27747): I'm not sure about this library feature, there might be some issues lurking. * [specialization](https://github.com/rust-lang/rust/issues/31844): riddled with **SOUNDNESS HOLES** and likely to stay unstable for years to come, you should remove it. * **test**: never going to be stable, as it's an internal crate. You can use the rustc-test crate instead: https://crates.io/crates/rustc-test * [trait_alias](https://github.com/rust-lang/rust/issues/41517): there seem to be open questions still, I think it won't stabilize soon If you remove usage of any feature where I said it won't stabilize soon, you'll be able to compile on stable.
Interesting. Think I'll do something with a websocket and open/close the connection based on a file watcher in my static dir. Reload the page when the connection opens. It's got nothing to do with my app starting or stopping, just when reactjs is changed on filesystem during dev.
Awesome, thanks for clarifying that :) &gt; and get someone else to review it too Is r/rust a good place to reach out for another set of eyes if I publish the code on github/gitlab? Or is there a more appropriate place to ask for such?
Lol. 70% memory related Bug. 🤣
https://www.reddit.com/r/rust/comments/ce306u/microsoft_security_response_center_endorses_the/
https://www.reddit.com/r/rust/comments/ce306u/microsoft_security_response_center_endorses_the/
Author of Maud here! I'm happy to answer any questions you may have.
\&gt; Such a language would almost certainly also use green threads, and have a simple CSP/actor model like Go does. There’d be no reason to have “zero cost” futures and async/await like we do in Rust. &amp;#x200B; This language would run into the same problems with green threads that Rust did so I'm not sure this would be the way to go. You really need GC to make green threads work as a lightweight concurrency primitive.
Well, yes, it was mostly intended to show that `.await` syntax looks okay and you don't need an over-verbose code anymore to work with Futures. You are right to say that fetching physical CPUs amount is not very expensive operation, quick benchmark confirms this; there is a notable (but still in nanoseconds) difference in results, only because of implementation details: test heim_bench ... bench: 6,307 ns/iter (+/- 321) test num_cpus_bench ... bench: 1,280 ns/iter (+/- 12) test psutil_bench ... bench: 58,863 ns/iter (+/- 2,120) If you need to get this data only once (ex, you need to spawn `n` threads during the program start, where `n` should be equal to CPU cores amount), it does not matter should it be a synchronous function or asynchronous. It is async because fetching this data still takes time (and for some platforms it includes external I/O, which might be slow) and in some cases you might prefer to do smth else while it is loading. Let's say, you need to collect all information possible and send it to a monitoring system, or you have some kind of reactive UI, which will automatically update the interface when future resolves. Also, Docker, for example, [allows](https://docs.docker.com/engine/reference/commandline/update/) to change CPU amount provided to a running container on the fly, so there is small chance that it might not be constant during the program life :)
The error handling is one of the biggest successes of Rust, and I've found a lot of people that think so as well. I'm writing both C# and Rust on a daily basis, and my sentence is that I don't want to use exceptions anymore. The exceptions are a mechanism created to "patch" the billion dollar mistake and the lack of algebraic data types.
See this thread for the build time benefits of pipelined compilation: https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199
i thought it was a programming error or just a bug
Microsoft Windows for Linux, written in Rust.
&gt;Apart from that, this sounds like a weird offspring of Swift and Go, with Rust ownership semantics mixed in. Very true. But I've been looking at Rust stuff for long enough that my brain really doesn't want to go back to a language like this. It's either all the way crazy functional like Haskell, or all the way towards Zero-Cost but nice Abstractions like Rust. Anything in between would probably annoy me.
D'oh! Sorry for the noise!
Well, why I appreciate Rust as our lord and savior, I wouldn't use it for a critical task yet. It feels to eager, such a moving target. No standard yet, no alternative implementations, big changes like non-lexical lifetimes. I would rather stick to Ada/SPARK for anything critical, and Rust for regular applications like browsers, players etc.
The only question is can they re-train their software engineers to work effectively with Rust.
That PR got merged btw, and the maintainer acknowledged they need to better understand how to work with/avoid usage of unsafe in their codebase. So don't go boycotting just yet?
Why's Java and Python in Firefox?
When I first saw this I really thought it was fake. I mean com'on, doesn't Mr. Riggleman sound like a made up name? Does anyone have a transcript of the video?
Exceptions are faster when not thrown, so I use them heavily now in high performance code.
Thanks! I'm not familiar with `fibers-rs`, but from what I see, it is using `futures` under the hood for user level threads and provides the executor to run them, so technically nothing stops you to get the `Future` from the `heim` API, put it into a fibers' executor and get the result of operation. Any other executor can be used too, of course, most popular being [tokio](https://crates.io/crates/tokio). I personally decided to go with async-first approach with hope that async ecosystem will evolve eventually and it would be a seamless experience to use `heim` as is. So it is the other way around, users can opt into using it synchronously :)
I too am a fan of Rust's approach to constructors, for many of the reasons you articulate. It is a decided improvement against the languages whose approach you contrast it with. However, to my way of looking at it: constructors are not a missing feature in Rust. Quite the contrary, Rust's offers a two layered approach to constructors: a built-in constructor primitive, and then the ability to layer on top of that initialization methods, which are actually necessary when fields are marked private. Rust's approach maps neatly to all three of your criteria for a good constructor, with no hole whatsoever in the reasoning. &gt; **Life Without Constructors**: In Rust, there’s only one way to create a struct: providing values for all the fields Aye, and the Rust documentation calls this a constructor. Which it is. &gt; how do you define a dummy state for an arbitrary object? I agree that the correct solution is not to set fields to default values. However, there are actually languages that know how to define a dummy state for an arbitrary object in a safe way. For example, Pony. LLVM also has machinery for tracking a dummy state: "undefined". &gt; inheritance more or less forces the language to have constructors .. But this won’t work in a typical single-inheritance OO language object layout! I am not following your logic here, to be honest. I do not see any obstacle to applying Rust's approach to constructors to a language that supports inheritance. I see no difficulty at all in allocating the required amount of space once and stitching together all the pieces to fill in all the fields, base and derived, in essentially one atomic operation. No piece-wise allocation is required in any way! I also am not clear about your second point wrt a "placement-friendly ABI". It is no doubt true that we rely on LLVM to optimize our initialization code to minimize data copies. I am not clear why this is a problem?
So the real issue is not exceptions but not having them defined in the function definition. And maybe for this hypothetical language you just need to declare the fact that it can throw an exception and not necessarily what kind of exception to reduce friction caused by verbosity.
It is utterly horrible from cooperation point of view. Anyone else willing to contribute will need to have the exact same version of unstable Rust, and the whole ecosystem work on either stable or farly recent unstable. The pinned unstable will eventually get out of sync with recent one.
If this is a real application for a real ICU, remember that regulations like HIPAA and GDPR exist. This comment has nothing to do with the technical challenges of Rust, but there are a lot of considerations when dealing with patient data and breaches of personal integrity.
And yet for all that, I really love C#
&gt;I do not see any obstacle to applying Rust's approach to constructors to a language that supports inheritance. It seems something like this would be hard to implement with only record syntax: ``` struct B { a: u32 } struct D1: B { b: u32 } struct D2: B { c: u64 } fn make_random_b() -&gt; B { let base = if coin_flip() { B { a: 0 } } else { B { a: 1 } } if coin_flip { D1 { base.., b: 1} } else D1 { base.., c: 2 } } } ``` At the time where we allocate memory for base, we don't know how much memory will we need for the final object. &gt;I am not clear why this is a problem? Optimizer is not always able to optimize away the copies, especially if, in program order, allocation of the memory happens *after* you have constructed an object. Placement new allows to take optimizer our of the question, by making sure that you *first* allocate the space, and than construct the object in-place, without any copies.
&gt; The main obstacle is developer familiarity No Go programmer would ever write this. The ability to quickly pick up the language is pretty much the most important feature of Go.
I was downvoted as if I were Nikolay, had anything to do with the matter, or agree with his approach. I'm not and I don't.
Wait, wasn't `drain_filter` found to be exploitable (and fixed) recently? There was no CVE because it was a nightly-only feature. This will indeed impact their security negatively.
The author does mention adding a GC as a fourth ownership option. GC also lets the user manipulate graph-like data structures in a natural manner instead of using specific patterns to satisfy the borrow checker.
If everything is Send/Sync then they are meaningless and might as well be removed. There is also the issue that not all resources are Send/Sync. Most are, but the one's that aren't are the ones that need Send/Sync to exist.
Visual Studio is minimally usable, although the vizualizers are a bit buggy and also incomplete.
&gt; If everything is Send/Sync then they are meaningless and might as well be removed. Yes, that is the general plan. &gt; the ones that aren't are the ones that need Send/Sync to exist. The plan is for the compiler to work out a way to make each resource Send/Sync. If there are things that can't be made to be (why?) then the compiler will know this and refuse the UB.
Finished reading TRPL and wrote the simple multithreaded web server, feeling like I understand almost everything. Is there any good free or cheap Rust exam online that could show me what topics I should revisit?
I'd guess it's in the build pipeline, not in the actual Browser
I know this is meant to be funny but holy God they'll do it if it means less work for them.
You mention Python, so let's explore that. I assume you imply that git would be different because Python is "slow", am I wrong? When you use Numpy and friends, what language do you use? Is it Python, Fortran, C, Cuda, or a combination of these? In fact, parts of git core are written in Perl and even Bash. And yet, the world hasn't collapsed. I agree with you that languages and their ecosystems have their strengths and weaknesses. However, it's a common pitfall to put undue importance on tool's implementation language as a user -- it is only important if you are an active part of the tool's development ecosystem.
If they're actual Software engineers there really shouldnt be a problem with learning another language
You are describing Java checked exceptions. They have turned out to be awkward in Java and IMO they miss the point: explicit error handling forces you to handle the error \*where it happens\*. You other deal with it directly, or propagate it with \`?\`. But using \`?\` still is a decision you have to make, and it leaves the error condition visible in the code.
I have seen a third of the team quit when projects change from c to rust. A good c engineer often has no desire to become a noob rust engineer for a decade before they own it.
Lets hope they don't release a Microsoft Rust with a whole load of Microsoft Windows only extensions though.. I can just see Rust# on the horizon.
Have you looked at yew? https://github.com/DenisKolodin/yew/blob/master/README.md
Wtf
Java is used in Firefox on Android. Python is in theb build system.
A modern day requirement for any engineer is to be adaptable. They can have a million and one reasons to not adopt “x, y, or z,” but at the end of the day it may not be their call.
You could do the exact same with Result returning mechanisms though, but with "reduced boilerplate". For instance, imagine the following pseudo-rust like language: fn i_can_fail() -&gt; () throws AError, BError { if some_condition() { throw AError::new(); } if other_condition() { throw BError::new("info"); } () } which could get turned into something like this using basically just syntactic sugar fn i_can_fail() -&gt; Result&lt;(), AError | BError&gt; // imaginary anonymous enum syntax { if some_condition() { return Err(AError::new()); } if other_condition() { return Err(BError::new("info")); } Ok(()) } You could still have the same error propagating operator (`?`) too. etc. At the end of the day, this is *just* syntax. Personally I really like the fact that I don't have to write `Err` and `Ok`, but macros like `ensure!` typically remove most of that annoyance. I'm not particularly advocating for or against this, I'm just trying to point out that language supported exceptions doesn't have to work any differently from how the current result returning mechanisms work.
I'm still Rust begginer and I'm implementing pong game and I want to write client/server for it. What would be some prerequisities to know (rust specific) or crates worth using?
I like the idea of a language designed around just in time compilation and/or install time compilation. Unfortunately I don't think one can fully rely on language-enforced constraints for security because of the wide variety of attack vectors that aren't memory safety issues (the whole spectre family of timing attacks for example).
This is how Servo works. The build system (tells rustup to) automatically download the appropriate Rust Nightly, so contributors don't need to worry about it. We have daily CI to notify us when the latest Nightly becomes incompatible, and try to keep up closely.
`Iron Rust` is the best language name ever though :P. Also, probably entirely un-googlable.
Is this something that is also supported by some C compilers?
Your code example has naught to do with inheritance, and everything to do with how you decided to split the initialization logic up with conditionals. Semantically, the exact same logic is found in [this Rust program](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=701653cba5c892ed80b1d2c092288fd6). The Rust compiler has no trouble handling this without requiring a single piece of memory allocation logic (look at the generated assembler to see this). In a language supporting inheritance, the resulting assembler logic would be identical to this. No optimizer is perfect across all arrangements of code sequence of course, but in scenarios I like this, I suspect it is better than you fear, especially when mem2reg is brought to bear. You might be surprised by LLVM's ability to progressively fill in a pointed-at memory location's data fields from a Rust constructor literal without an excessive amount of copying taking place! Good news on both accounts for the extensibility of Rust's approach, don't you think?
For your compresstimator, is it actually faster to run the file through lz4 level-1 than to [estimate the entropy](https://kennethghartman.com/calculate-file-entropy/)? (Honestly could be since lz4 is insanely optimized).
Is this just a summary of the introductory post of a blog series from yesterday?
Yes and no. Eg overuse of the failure::Error type can let code drift in that direction, but I think that's one of the reasons why it's popularity is subsiding. Also, you can still see at one glance which expression can yield an error. Like I said, with Java you often have a @throws declaration where the exception is actually five layers down and the only hope of tracking it down it is with a stack trace. In Rust you still cann followthe question marks. Also Rust encourages you to have intermediate error enums, while in Java you often end up with a @throws with the base exception class because you would otherwise have like 10+ types in your @throw.
I think chrome devtools workspaces do this, not sure if it works for js
Except that Rust is slowly, step-by-step, getting exceptions. At first, like Go, Rust exception... err... sorry... error handling required highly visible, explicit code. If statements, matching, that type of thing. Then people got fed up with the boilerplate, so the ".?" operator was added. Now there isn't so much boilerplate any more! It's still "explicit", yet it's barely there! All sorts of From/Into magic and macros were sprinkled on top to convert between the Error types to hide even more boilerplate. So what we have now looks almost like a language with exceptions, except with question marks everywhere and slow performance due to tagged unions on the hot path. You know what's coming next... some smart ass will figure out a way to optimise the tagged unions out in the common case, because exceptions... I mean errors only occur exceptionally... rarely. Yes. That's the word. Errors. Not exceptions. Exceptions are bad! Then the next thing you know, you'll have reinvented exceptions but called it error handling. Congratulations! You can have your cake, and eat it too. Except it's actually quiche, and nobody likes quiche.
I don’t know if its just me but I honestly hate Go’s syntax. Its a cool language, but I couldnt get used to the syntax.
The difference between algebraic error handling and exceptions does not, as you imply, lie in their implementation. What matters is being sure that a function cannot throw an exception, or that the possible errors that it may produce are listed and can be explicitly (if subtly) handled. In this sense, exceptions are extremely different because their handling is "opt-in". It becomes far too easy to write quick code that does nothing to guard against potential errors, and instead just throws them back to the caller. With Rust, every function is forced to at least acknowledge the existence of the error, and the programmer is forced to make a choice about whether to handle it or to kick it back to the caller. That is the difference.
This function is not possible without storage for when one iterator runs faster than the others. It would be reasonable efficient when using a small-vec optimisation to avoid the allocations when the iterators are in lock-step.
That kind of makes sense for C developers. Rust is pretty different to C. I imagine C++ or even C#/Java/Python/JavaScript would have fewer issues.
This might be a total noob question, but: I just do not understand why Traits are so popular and why they even exist. How are Traits better than simple Impls/methods? Let's say I wanted to build an IMAP client. I'd have an "IMAPaccount" struct that has fields like username, IMAP server, etc. In addition to that it also has impls/methods like "receive_emails", "delete_email" and "mark_email_read". It seems like a pretty straight-forward situation. So how can Traits improve this situation? Is this a case where Traits are indeed not a better alternative or am I just not seeing the bigger picture? (Which is quite likely :-) ) Is it possible to explain this without any complicated code examples? Traits are the one thing about Rust I really don't understand. People always complain about the ownership system, which was pretty easy for me to understand. But Traits? I still don't get them. Thanks so much in advance!!
Can you provide some more details please? Was the decision to move to rust forced by the management? Was there a training in rust beforehand? Did the team get to play with rust with smaller projects? 1/3 of the team is a lot...
&gt; The difference between algebraic error handling and exceptions does not, as you imply, lie in their implementation. What matters is being sure that a function cannot throw an exception, or that the possible errors that it may produce are listed and can be explicitly (if subtly) handled. Also that the errors are reified and you can transparently manipulate the success, the error, or the entire result.
The compiler doesn't understand `Mutex`es, threads, concurrency, or indeed any lifetime-related semantics outside of those that are declared though function and type-level lifetime annotations (which may be explicit). What it does know is that the code in `Mutex`'s method calls makes used of external function calls and `unsafe` code, so it's designed not to optimise them away to avoid unwanted side-effects. Perhaps in the future, it will be capable of some limited understanding of the semantics of types like this, but for the time being it's a good idea to be careful about where and when you use `Mutex` - consider using an `mpsc` if the use-case is more suited to it.
I think this is nearly optimal (given the current simplicity). I would use `a/b/c = Vec::with_capacity(original_vec.len());` because you know the number of elements exactly. Linear with a low-constant loop is the best for your given problem. If you want more ergonomics, implement a wrapper trait `Split3&lt;T,U,V&gt;` that implements `FromIterator` to hide your code. The other option I see I wouldn't recommend: to avoid the allocations and the copying. For this you will want to wrap a borrowed vector as e.g. `View3_1&lt;'a,T,U,V&gt;(&amp;'a Vec&lt;(T,U,V)&gt;)`. You probably want to abstract your current code and accept `impl Index&lt;usize, Output=T&gt;` instead of `Vec&lt;T&gt;` I wouldn't do this unless you *know* there access pattern is sparse (know as in proven or measured, Vec is really efficient).
It might sound elitist, but that’s probably the third of the team you should have gotten rid of a long time ago anyways.
I don't agree with anything here. And I don't like the way exceptions are done in Java. I'm just trying to point out that you *could* do exceptions (in a new language) in a rust like way (like how I did in the dummy syntax for instance). I don't want the properties of java exceptions at all, but sometimes I would like to steal *some* of the syntax.
Since the latest Windows features depend on Silverlight 2024, creating a GUI project in Visual Rust requires that you log in to your Microsoft Account and download the latest SDK from the app store. Note that in this version we are beginning the phase-out of non-CLR compilation targets
Hmmm maybe, to be honest it would be too much effort for me right now to completely think over all the complications. I'm actually perfectly fine with the way Rust does it and I was mostly speculating about how to potentially remove the error handling verbosity for this hypothetical *easy* to use language.
The key point here is not how good the optimizer is but rather can the language guaranty specific semantics. In fact, it cannot. Such a semantic guaranty requires a language construct.
He bounces back and forth between the Libra team and Rust in a way thats difficult to keep straight. Makes me think he doesn't have them straight in his own head, but if your mental model is that the backend is just some mixture of libra + rust then that's still clearly paying dividends as seen by his questions re: nightly. Just needs to update the mental model to combine the dev teams in his head as well.
He has an interesting background. &gt;Denver has also been CEO of several defense contracting companies specializing in counterterrorism, analytic services, rapid technology development, critical infrastructure studies, C4ISR, cyber processes and support to “follow the money” organizations. [https://riggleman.house.gov/about](https://riggleman.house.gov/about)
Furthermore the Congressman gives him an explicit out "Or do you see this as simply part of the prototyping process?" (also paraphrasing)
There might be a design that combines the benefits of both approaches, but I haven't seen one and can't think of one personally. The concept of lifting exception information up to the function declaration with transparent propagation is seems incompatible with the explicit error handling approach that makes Rust great for me.
Username checks out.
About a year ago I tried to create a reasonably large (50ish REST endpoints) fullstack rust application that ended up collapsing under the weight of rapidly increasing compile times and arbitrary scope creep. It was initially done with Rocket + Yew, but later transitioned to use Warp + Yew. I honestly think its real value only lies in showing how to structure such a project and possibly some patterns someone could want to utilize. It likely won't run without some modification because the ecosystem it relies on moves pretty quickly; I think of this mostly as read-only code for the moment: [FullstackRustDemo](https://github.com/hgzimmerman/FullstackRustDemo) &amp;#x200B; With the understanding that it is a highly complex, one-man, open source project maintained in spare time, I had plenty of gripes with Yew at the time I abandoned my project. I still follow Yew's development, and while I haven't used it again recently, development progress has really picked up steam this Summer and I wouldn't be surprised if my primary gripes with the framework have been addressed.
If I have `pub fn foo&lt;P: AsRef&lt;Path&gt;&gt;(filename: &amp;P) { /* ... */ }`, and then I call `foo(a_string)`, `foo(a_path)`, `foo(a_path_buf)`, `foo(osstr)`, you end up with duplicate versions of `foo` in your binary, since one is generated for every type used.
You want r/playrust as this is for the rust programming language
Build a GUI framework
Good point. Fixing: fn split3&lt;'a, T: 'a, U: 'a, V: 'a&gt;(input: &amp;'a mut Vec&lt;(T, U, V)&gt;) -&gt; (impl Iterator&lt;Item=&amp;'a mut T&gt;, impl Iterator&lt;Item=&amp;'a mut U&gt;, impl Iterator&lt;Item=&amp;'a mut V&gt;) Since the vector has to be mutably borrowed during the iteration anyway.
Indeed, I would have mentioned Python if you had not: its "constructors" are relatively normal constructors. Likewise Ruby where a constructor is just a `new` message / method on the class object (though the underlying protocol is non-trivial and has the same issues of partial construction as other languages). The interface to construction can be an issue, but I don't think it's the core concern.
Despite being constructor-less and unlike Rust, Go specifically doesn't require initialising all fields and instead uses the java method of zero-filling everything.
Traits basically correspond to interfaces in languages like C# and Java, and so you would use them in similar places: * Dependency injection. For example I write some code that needs an http client, but I want to be able to test it without needing to do actual network requests. So I define `HttpClient` trait, implement it for `hyper::HttpClient` and `MockHttpClient`. Then in my code I use trait object `Box&lt;dyn HttpClient&gt;, and then I can use different implementations for test and production code. * Generic code. `HashMap` has `K` type parameter for its key type, but it needs to be able to hash and compare the keys. So `HashMap`'s implementations constrains `K` with `Eq` and `Hash` traits: `impl&lt;K: Eq + Hash, V&gt; HashMap&lt;K, V&gt; { ... }`.
But Rust does have a language construct called a type constructor. Does this not guarantee specific semantics? This is my understanding of what we were talking about, the extension of Rust's constructor approach to seemingly more complex scenarios with optimal performance, due to the optimizer minimizing copying. If you are talking about something different, feel free to enlighten me with more specifics about what you are trying to convey.
Traits are for shared behaviour (or better: contracts) between multiple implementations. So you could have an IMAPClient and an SMTPClient both implement a trait EMailClient, which would provide methods like `read_mail` or `send_to`. If you later were to write e.g. a SpamBot to automatically send emails, you could hav ethe SpamBot rely on any class that implements `EMailClient`, such that it does not care whether you pass it an SMTPClient or an IMAPClient.
Yeah if it's really just about the frontend code reload you could do watch the frontend build directory (there is a crate for this) and push a notification via websocket. But you can also just use eg webpack Dev server and treat the frontened stack independently.
I sometimes looks over the [crates.io source code](https://github.com/rust-lang/crates.io)
Do you know why they're stuck on an old version of hyper? It seems like this is one reason Rocket still doesn't support websockets. Note: I might be misunderstanding something. I'm new to the Rust ecosystem.
Maidsafe for instance had 2/6 engineers quit when they rewrote in rust. I don't think it is overreacting, if you start as a c engineer and then you are asked to learn rust it's not what you signed up for.
FWIW triple bacticks don't work in old or mobile reddits making your comment very hard to read.
For local development, I usually use the create-react-app development server and setup a proxy to my actual backend server. Then for production builds you can build the react app and serve the files via actix-web.
If every exception was a checked exception (which was true in the parent comment’s description), you still have that same reasoning pattern. You always have to know what exceptions might pop up, you always have to handle them, and you always have to make a conscious choice of whether to re-throw them or not. In the end, using ADTs for checked exceptions seems to make them tolerable in precisely the way that they didn’t used to be: checked exceptions in Java are verbose and so people often skip them.
I've built a medium-size full-stack production application with actix-web and my own frontend framework, it's an internal tool but it's still in use. I've had to write like 5 lines of to convert JS's Promises into rust's Futures and to interface with file input, other than that - no js, no html, no css. The frontend communicates with the backend's REST via serde-encoded binary, it's great.
I'd personally love to have something like this. First, because one of my personal projects needs a scripting language that is easy to learn, compiles to small wasm binaries (rust compiles to *large* wasm binaries), and not totally slow like a dynamic language would be. Second, it could prevent Rust from *becoming* that language, because it would leave open a gap that then C++ or Swift would have to fill, both of which are no good alternatives.
You're determining what type of object is being created inside the constructor for that object. Think long and hard about that.
Upvoted!! ;-)
Thanks. Yeah, I could do that. I'm playing with actix-web to learn rust. This is a good little learning experiment. I'm not fussed at the moment about seperation of concerns. Just want 1 code base, rust server, react GUI. I've written stuff in node, c#, java, go, python... And a few hundred thousand lines of fken JavaScript for 22 years. I'm a hobbyist now, but most of that 22 years was professional.
Thanks for your input. I am so sorry, but I still don't get that. &gt;If you later were to write e.g. a SpamBot to automatically send emails, you could hav ethe SpamBot rely on any class that implements EMailClient, such that it does not care whether you pass it an SMTPClient or an IMAPClient. Why is that a good thing? If I understood you correctly traits just enable me to write less code? I could just do all that with impls as well, right? But it would be more typing. Is that the only advantage of traits? I want to code Rust the Rust way, but so far it seems like traits make everything more complicated without any real benefit.
Why the need for `mut`? Is it for stealing the data? - but then you need either a `Clone`, `Default` or `MaybeUninit`. With `MaybeUninit` come a lot of footguns though. I would have suggested the original signature but with a shared `Rc&lt;(VecDeque&lt;T&gt;, VecDeque&lt;U&gt;, VecDeque&lt;V&gt;)&gt;`. However this becomes too complicated for the original question OP asked.
Excellent explanation of the problems with c\`tors! Some finer points I'd disagree with: * Named arguments for the multiple ctors issue - I strongly prefer the "there's only one way to do this" methodology which Rust follows for the most part. In any strongly &amp; statically typed language such as Rust, the **one** way to classify objects is via their types, not field names. I'd much rather follow idiomatic Rust and have: `Celsius::from_kelvin(degrees: Kelvin); // Strongly typed to prevent dangerous mix-ups in space` The downside of the above is the duplication of information in the method name. Rust could potentially improve upon the above by relaxing the restriction on no-overloading of free functions to designated "ctor-like" functions by e.g. marking ctors with some special syntax/attribute/etc. * Regarding the local enforcement of invariants via private struct fields - I'd rather have an explicit way to codify this instead of relaying on an implicit convention. While true that it is local and therefore easier to reason about, it doesn't cover all cases and does introduce a minor wart in some cases. In particular, when I want to enforce an invariant on construction but also allow read-only direct field access to all the struct's members. This forces me to add a dummy private member that I wouldn't have needed otherwise. It isn't a major issue but it still is a wart.
Hmm... I'll see how far I get with it all in rust. 🤣. I might give up and do this.
you could read the rust book. it's great to read.
&gt; its "constructors" are relatively normal constructors. Hm, Python's "constructors" are pretty unusual, as far as constructors go. `Foo()` is just a method call on the `Foo` class object. That is, python "constructor" is actually a magic `__call__` method defined on type's type, which is typically `type`. For the curious, the definition is [here](https://github.com/python/cpython/blob/1b3892243433da7eae7f5f3a4f98f13d309c8926/Objects/typeobject.c#L950-L1000)
&gt; lifting exception information up to the function declaration It's alredy at the function declaration though. In the return type. If that's not function declaration level, I don't know what is. That being said, I agree with you on transparent propagation, and wouldn't want that either. In my pseudo example I expect that when you call the failing function you'd either have to deal with it there (whether the syntax was match or catch is rather irrelevant), or propagate it using something like the `?` operator.
&gt;&gt; its "constructors" are relatively normal constructors. &gt; Hm, Python's "constructors" are pretty unusual That's a typo / mistype, I meant "callable" not "constructors", sorry about that.
Except you totally made this scenario up and Rust won’t actually add exceptions.
Don't worry about traits for now. As long as your code is contained to your own project(s), it can often make sense not to use traits. They really shine across project (crate) boundaries. Let's say someone else wrote such a SpamBot crate/library - would he have used an SMTPClient or an IMAPClient? The correct answer is that he should use neither, because he doesn't really care about the concrete implementation. All he needs is a way to send emails to chosen recipients. Accepting the EMailClient trait as a parameter allows any user of his crate to choose whether to pass him an SMTPClient or an IMAPClient. I've written multiple small and one medium sized (one-person) projects, and I have maybe created my own trait twice.
&gt; ~~less work~~ more money
Ahhh that is so good to hear. It seems like in the Rust world everyone LOVES traits (and uses them often). That gives me the feeling that I'm doing something wrong/not doing it the Rust way. But so far I really haven't had the need to use them. Thanks so much for your help. Much appreciated!
less work = more money
This is cool! I'm trying to minimize the number of crates I'm using though, so I'm looking to solve this without adding a dependency.
Is TiKV kind of the equivalent of MongoDB? I don't fully understand its use case.
Webpack actually has proxy support built in for this use case.
&gt; If every exception was a checked exception (which was true in the parent comment’s description), you still have that same reasoning pattern. If you have two methods mayReturnErrorA and another alsoMayReturnErrorA then you need to handle the possibility that the error is returned for each method (even by simply using unwrap or ?), making it quite easy to reason about which errors can be returned from where. On the other hand with methods mayThrowErrorA and another alsoMayThrowErrorA you can have a single try/catch statement that handles both of these (and you could in the try block have multiple other methods that throw even more errors), which means that when reading code you will constantly need to check whether a method can return errors.
No, that's C
WTF everybody like quiche. And your story is cool, but whatever happens to the error handling, as long as I'm not having errors popping in my back, I'm ok.
This is a great reference using yew and actix: [https://github.com/saschagrunert/webapp.rs](https://github.com/saschagrunert/webapp.rs)
Here's a potentially-slightly hot take for this subreddit: don't build your first pass in Rust unless you've got bedroom eyes for the language. In terms of the frontend, Yew seems to be the go-to recommendation that gets thrown around, but I wouldn't use it. As a demo it works nice, but once you start needing to do more complicated things it shows issues... and truth be told, doing any UI development in Rust can be a pain due to the compile-time cycle. Use React, (raw JS || jQuery) with HTML/CSS, or whatever you want - I just haven't seen a Rust frontend web framework that comes close to what they're offering. Rust (with something like Actix) works great for backends/APIs, but in my experience building the initial version becomes a pain because of the compile-time reloading cycle being hell (/u/HenryZimmerman seems to have the same experience). The appeal of something like Askama is fun until you're recompiling the entire thing for each small change. What I do nowadays is build my prototypes in Django, and then migrate them if the project seems like it has legs, because: - The template system is easily reproducible in a Rust project - The ORM works well enough for DB modeling, which is easy to transfer to `diesel`/etc - The admin interface is still way too killer of a feature to give up for early stage projects - You can migrate the auth system very easily if you feel so inclined down the road, thanks to [djangohashers](https://github.com/Racum/rust-djangohashers). My two cents.
Webpack/etc have built-in support for this kind of thing, but if you're masochistic enough to want to do it in Rust on your own, I know Zola (the blogging engine/static site generator) has a feature like this, and last I checked the code was pretty straightforward.
I don't know.
Rust away
Yeah I’ve got all of hoops and gdrp covered. Gdrp is basically verification of the data and logging who was collecting at what time. Hippa for this specific application as we won’t collect any sensitive information other than a child id the only requirement is that it be in house in a serve within the building. And that we withhold data atleast 15 years. Atleast that’s my understanding of the requirements.
I understand.
Awesome I’m definitely looking into your library for this application! I’ll keep everyone updated here if I need any assistance.
Hmm ok, ill have a look into it. Thank you.
It's not full-stack, but [here](https://www.reddit.com/r/rust/comments/cdg5b4/rust_in_the_on_of_the_biggest_music_festival/)'s a recent experience report for a Rust web app.
Beautiful. Thank you :)
&gt;no alternative implementations, big changes Isn't that true for SPARK too? SPARK2014 was a complete redesign of the language and now they are talking about adding Rust's lifetimes/borrowing which I'm going to assume will lead to major changes again. I think SPARK looks really interesting though and is probably a better language than Rust for critical tasks, just not for those reasons. SPARK has a formal specification and I believe the compiler has formal verification that it implements the specification correctly.
No, it's a distributed key/value store built on RocksDB. Most databases (conceptually) use a key/value store under the hood to store data on the file system. So you can use TiKV to build a SQL or NoSQL database on top of it. TiDB does exactly that.
There are other linear algebra libraries that use SIMD although I haven't used any of them. Sometimes the state of SIMD support is a bit unknown, for example cgmath appeared to have SIMD support but I didn't compile when I tried it. One thing glam does differently from other Rust libraries I've seen is use SIMD types for storage. A lot of libraries store there data in `f32` and load it into SIMD registers to perform and operation then store the result back in `f32`. This has some overhead which glam avoids. The downside SIMD types are 16 byte aligned so it does result in some wasted space for types like `Vec3`. This is a trade off that `glam` has made for better performance. For further benefits you would have to go lower level with faster, or packed_simd, or the x86/x86_64 intrinsics in stable Rust. For existing data you can convert f32 tuples and arrays to and from `glam` types or you can use the `mint` libraries to convert between math types.
The core parts of git were written in C pretty much from the beginning. The rest of git, the porcelain as it's called, was written in a variety of languages, mostly interpreted ones because they weren't performance critical. Mercurial on the other hand was 100% python and notoriously slow. Incidentally, they're rewriting core parts in Rust to increase performance. I'm not sure why you're even trying to argue this. Of course you can write slow software in any language, but you can't write really fast software in any language.
Which is exactly what happened the last time this came like 6 months ago. I hope it's "for real" this time.
No, it is correct. People, all people, even you and me, are eachwise nothing more than a means to an end. For FOSS, that end is software, its accompanying documentation, and superiority over their proprietary counterparts. (Of course even the software being an end unto itself, is only in the opinion of each project's dedicated enthusiasts. For the rest of us, FOSS is, in turn, like any other software, a means to whatever end for which we use it. Which in turn ... but that recursion is far too broad and deep for a Reddit comment, and you get the idea anyway.)
&gt; In the end, using ADTs for checked exceptions seems to make them tolerable in precisely the way that they didn’t used to be: checked exceptions in Java are verbose and cumbersome to work with and so people often skip using them. I've always wondered why Java's checked exceptions are considered (at least) controversial and we consider Rust's error handling to be more of a success story. As far as I can tell there are only a couple of differences (ignoring implementation details): 1. Rust's `?` is an explicit way of propagating errors while Java's checked exceptions propagate implicitly. 2. With the help of `From`/`Into` and procedural macros, errors can be easily made convertible to other errors which is leveraged in `?` whereas in Java you have class hierarchies of exceptions and you get to use less specific base classes at higher levels. 3. Explicit conversion is locally supported in Rust via `map_err` and in Java via `try`/`catch` + throwing new exception. Now, what makes Rust's error handling less "verbose and cumbersome to work with"? (Serious question) The only thing that comes to my mind is that "conversion power" of `From`/`Into` is probably higher than what class hierarchies (only allowing to convert `SomeSpecificException` to `SomeMoreAbstractExceptionBaseClass`). So, there's probably less need for Rust's `map_err` compared to Java's `try`/`catch`.
Most of what this article sounds like is “we could make Go a bit more Rusty, drop the garbage collector and end up with a more ergonomic language” I don’t disagree completely but I’m really new to Rust and have written a fair amount of Go. I’m always far more productive in Go despite the lack of generics and extremely verbose error handling.
smh at whoever missed your sarcasm.
Beyond the points you mentioned (which I think are valid), the fact that errors in Rust are idiomatically sum types is nice in terms of annotation burden on functions: you say something like Result&lt;T, Error&gt; instead of “throws ErrorOne, ErrorTwo, ErrorThree, ...” (or going to a superclass, I suppose). Another reply also noted that we put a ? or some handling on each call that can error, rather than just putting try around the whole thing. This is probably a win for code readability (less cumbersome then) at a (usually) pretty minimal cost.
Even harder to google given the existence of the Iron web framework
One of the main issues with Java’s checked exceptions that I run into constantly is the fact that you can’t abstract over them or make them generic. You can’t write an interface Function&lt;A,B,E&gt; that takes an A, returns B, might throw E, and then write a map/filter/etc using that interface that throws E. With Java 8’s streams I’m constantly trying to figure out how much to use them / work around this / how much to just say ‘throws Exception’ when I have to / throwing RuntimeExceptions... Result&lt;B,E&gt; just works. I don’t know if there’s a reason Java’s checked exceptions couldn’t be parameterized over, though, if the design were to be expanded.
Doc with the changes in compilation times - https://docs.google.com/spreadsheets/d/1CU7o3IocPtNAUevvrPsTI77z_AexsRloUgiusiXJWtg/htmlview Anywhere between 0-45%, but looks mostly positive.
Will this have measurable performance boosts for cargo check or RLS times or will this only provide benefits for actions where actual code generation occurs?
For anyone wondering, there is a language which mostly hits the feature's he's suggesting. It's a garbage collected, actor-based, capabilities language (for bits like data-race freedom; it actually is more powerful than rust's, it's also deadlock free for instance). It's called [Pony](https://www.ponylang.io/). Introduction: [https://tutorial.ponylang.io/](https://tutorial.ponylang.io/)
What if I only partially initialize the array, for example by using `File::read()` that doesn't fill the whole buffer, then I want to work with the part that was initialized?
Big Ironic Foot
Been trying to learn Rust because I want a bit of a challenge but I'm still stumped on what I'm supposed to use it for. I do genomic data analysis, everything I need I'm my daily work is already completely covered by Python, R, and shell script. I use plenty of other software &amp; frameworks too like Django, Nextflow (Groovy), Docker/Singularity, and all my computational intensive work is handled by pre-made published &amp; verified software packages, we don't build them ourselves. So what am I even supposed to use Rust for? One thing I like is the static binary compilation but I'm already pretty settled with Python/R library management &amp; containers so the lack of it is not even a problem for me either. Am I missing something?
Have you read the PR that's at the heart of the most recent actix-web controversy? There's no pragmatism here, just an infantile response from the maintainer. https://github.com/actix/actix-web/pull/968
&gt; It's still "explicit", yet it's barely there! That's _exactly_ what the designers were going for with the `?` feature. Of course some people dislike it, that's fair, but I wouldn't make fun of it for doing what it set out to do :) &gt; slow performance due to tagged unions on the hot path Has this ever been measured? I know it's true in theory, in some cases. But in practice, if you're dealing with `Result` in a loop, doesn't that usually mean you're doing IO and making system calls anyway? I do like `?` and `Result` handling in general, but I think the real win happens when you _don't_ have `Result` in the signature. Then you know you can treat a function as infallible. Panics can happen, but usually only `unsafe` code needs to be very careful about those, and the rest of your code can treat panics as a bug and rely on RAII for any cleanup. The same doesn't seem to be true in exception-based languages. My impression is that you usually have to worry about every function call throwing, and you have to be careful to wrap your resources in `using`/`with` to clean up properly.
Cool, going to implement [http://livereload.com/api/protocol/](http://livereload.com/api/protocol/) and just use a browser extension. :) Thank you everyone.
you wanna get scolded by curl maintainer?
&gt; I don’t think I’ve ever seen resource leakage caused by exceptions in GC languages. I think it's more likely to come up in services under heavy load. If each request leaves a file handle dangling for a few seconds, that starts to matter when you handle a thousand requests a second. That's an unfortunate sort of bug, the kind that hits you just when you need reliability the most. I also see it come up more during process exit. Because everything in the global namespace is getting finalized all at once, and not in any predictable order, you start to see crashes where some finalizer calls into a module that's already disappeared. Python finalizers sometimes stash a local reference to global modules to work around this problem.
In my case, Arch Linux just has a rustup package, so it's installed globally. Wasn't aware the default was user-level. In any case the OP needs to install it in the local directory (I think), which requires setting the environment variables.
The latter: it only affects builds that do code generation.
This is awesome.
Yes. A rust like language, with gc and still having cargo and compiling to static binary ticks all boxes for me.
&gt; Except it's actually quiche, and nobody likes quiche. Who (besides vegans) doesn't like quiche, it's just cheese&amp;egg pie.
Do you know what kind of output it generates like native binary or something else?
That's not mandatory to use Rust. If you're happy with your current tools and have nothing to gain from Rust, just stick with what you know, don't you?
Broader question: would folks here say Rust is recommended for web applications over something like .NET or Java? I'm not sure the language offers anything over traditional approaches.
I had been told - and have observed it too - that some people simply don't like changes, it gives them discomfort - so they try to avoid it as much as possible.
Yes, those are the people you don’t want to write your code.
As far as I know, Microsoft already uses Rust in various things, so the headline is kinda vague.
*quits job* I'm rich!
Partial agree. `Result` is awesome even though writing your `Error` is a slog. But I wouldn't be looking at Go for error handling. Yeah its explicit but I really really don't like it.
&gt; Isn't that true for SPARK too? To some extent. I was more talking about Ada in this case. SPARK is more or less a moving target, although a very slowly moving one. Yet it's a simple add-on for Ada, so your spark code is still a valid Ada code AFAIK, and Ada is very stable from release to release (which are rare).
Explore the standard library, it's full of traits. For example, check out `File`, `Read`, `Seek`, `BufRead`, `BufReader` etc... APIs, try to write your own I/O library for something - that's what helped me the most imho.
This list is good, but &gt;riddled with SOUNDNESS HOLES and likely to stay unstable for years to come Specialization is explicitly listed on the lang team's roadmap for this year. That doesn't mean that it will absolutely happen, but I think you may be being a bit harsh here.
Working on a relational database ([https://github.com/drgomesp/oxidb](https://github.com/drgomesp/oxidb)) for studying purposes.
There's a couple of open source projects that use TiKV as the storage layer for a redis protocol compatible db. I saw another project that was using it to do a stream/queue similar to kafka.
&gt; Why the need for mut? I kinda assumed that mutability was needed from the OP, but you're right, that's not obvious from the OP. Without `mut` the iterators would be immutable, and no `unsafe` would be needed for the implementation. &gt; I would have suggested the original signature but with a shared Rc&lt;(VecDeque&lt;T&gt;, VecDeque&lt;U&gt;, VecDeque&lt;V&gt;)&gt; I'm not for this if we're speaking of efficiency. Iterators let you not to alloc/copy stuff around.
Yes
This was measured in Midory, with the following results: ``` I described the results of our dual mode experiment in my last post. In summary, the exceptions approach was 7% smaller and 4% faster as a geomean across our key benchmarks, thanks to a few things: No calling convention impact. No peanut butter associated with wrapping return values and caller branching. All throwing functions were known in the type system, enabling more flexible code motion. All throwing functions were known in the type system, giving us novel EH optimizations, like turning try/finally blocks into straightline code when the try could not throw. ``` http://joeduffyblog.com/2016/02/07/the-error-model/
Looks to be native binaries through LLVM
It's definitely going to be faster (or at least, use less CPU), since it's just bucketing bytes - but it's not very good at estimating real-world compressbility because it has no pattern-matching abilities. e.g. Mankind Divided's main 25G file: shannon_estimate=0.89, compresstimate=0.65, actual=0.64x Or a few of the .resS files in The Long Dark: shannon_estimate=0.90, compresstimate=0.91, actual=0.91x shannon_estimate=0.92, compresstimate=0.68, actual=0.56x shannon_estimate=0.89, compresstimate=0.91, actual=0.91x shannon_estimate=0.89, compresstimate=0.51, actual=0.45x shannon_estimate=0.89, compresstimate=0.81, actual=0.81x shannon_estimate=0.79, compresstimate=0.04, actual=0.04x shannon_estimate=1.00, compresstimate=0.67, actual=0.72x Ultimately I'm reading so little data it doesn't really matter, the sample size barely goes above 30, so about quarter of a megabyte for the largest of files.
I can understand that. If you hit the wall of "something broke. I'm the expert. I don't know how to fix it... well, fuck. I guess my company loses $2m every 15 minutes the software is down and now it's my personal fault since I don't know Rust well enough," well, I want to be in that situation about never. I'm fine with high stakes fixes when I know the systems well enough, but if I'm not confident, I'm going to let someone else do it. That sucks for me personally because now I look less capable, which makes me a target for getting let go. Might as well keep the current position long enough to find a new job where I can use my expertise, then be able to perform.
I can clearly recommend Gstreamer. Sometimes it is a little bit complicated to understand how gstreamer works, but in general it solves a lot of your problems.
Hey! The steps you've outlined sound great to me. I actually don't have a use case other than wanting to be able to list (at least initially) the contents of an `asar` file. Were I implementing this myself I would change some things about the CLI but that isn't the most important thing at this stage (or perhaps ever). I would much prefer the new `asar` crate not be tied in any way to one particular consumer (such as Electron Packager). I'm sure you understand what I mean by this. Also, I have a heavy preference towards using the GPLv3 license. I do not know if this would put Electron Packager or any other current consumers in a bind, especially considering the `neon` module bit (does that "get around" the linking bit or what?). If GPLv3 absolutely won't work the next ideal license, again just for me, is MPLv2. On the topic of paying for this work, how much do you believe is fair for an absolute bare-bones implementation of the lib and cli? Starting with just being able to list the contents of an archive as an end-user would be good IMO. What would be the best way for you to get paid? I don't know if using a particular system would work best for you. Please feel free to PM me if you'd prefer to discuss that in private. Thanks a ton for taking the time to respond and consider this work. :)
Have you noticed that some members of the community commented that the PR doesn't address undefined behavior? Nikolay was right and justified to challenge the claim and then correct in his assessment. Does he need to accept any PR that addresses unsafe? He's the author. He determines what is acceptable. He rejected one that was ideological rather than one that addresses real UB. That seems reasonable to me. He's been under constant fire from the open source community. He should not have responded how he did, but I can empathize with him for losing his cool and venting frustrations. This isn't enough to turn on him and his work, though, and especially doesn't warrant *another* very public attack on his character and craft.
Traits are a huge part of why Rust can enable good and productive *libraries and APIs*, if you are writing a binary you arent using them as much (though behind the scenes most of the std library uses Traits in their APIs, so you are actually using them)
I'm still kinda a noob in the lower-level programming space but I feel like Rust is C-ish but with some training wheels and some higher-level language abstractions that C does but maybe doesn't do eloquently. &amp;#x200B; So I feel like transitioning from C to Rust "shouldn't" be too painful but I could be wrong. I'm going from Python to Rust (learned a bit of C as an initial programming language) so maybe my experience is different.
Considering the memory safety guarantee provided by Rust, and : [https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/) It could be interesting to know whether or not a company needs to replace those 1/3 engineers that had quit, with new employees who knows how to use Rust, or new employees that are ready to make an effort to learn Rust.
The newer hyper uses tokio and futures and was a lot of work to update to, Rocket has a PR being worked on that updates the hyper dependency iirc
It was a little over a year ago, but yes, this has happened before and it's why I'm sour about the whole situation. https://www.reddit.com/r/rust/comments/8s7gei/unsafe_rust_in_actixweb_other_libraries
There is a proposal to add a new kind of exceptions to C++ that are somewhere between traditional exceptions and result enums: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r3.pdf
&gt; Rust is also more popular with developers these days and might be easier to recruit for. &gt; Developers love it because of its simpler syntax Uh, great journalism homework as always. /s
There's one crucial difference between Rust's pseudo-exceptions and exceptions as implemented in other mainstream languages, which is that in Rust, you have some syntax *at the call site* to tell you that an exception may emerge. Compare Rust: ``` fn caloriesInCake() -&gt; Result&lt;u32, NutritionalInformationError&gt; { Result::Ok(caloriesIn("flour")? + caloriesIn("egg")? + caloriesIn("sugar")?) } fn caloriesIn(ingredient: &amp;str) -&gt; Result&lt;u32, NutritionalInformationError&gt; { ... } ``` With Java: ``` int caloriesInCake() throws NutritionalInformationException { return caloriesIn("flour") + caloriesIn("egg") + caloriesIn("sugar"); } int caloriesIn(String ingredient) throws NutritionalInformationException { ... } ``` Note that this is a design choice. A language using exceptions could require equivalent syntax to call an exceptional method with the intent of letting the exception propagate. Indeed, the Herbceptions proposal for C++ includes this.
[Here's an example with Actix and Seed](https://github.com/David-OConnor/seed/tree/master/examples/server_integration). The main perk is that you can use the same data structures, functions etc on both client and server, instead of having to write and maintain separate ones, and convert between the two.
You can parameterise over exceptions in Java. This is legal: ``` @FunctionalInterface interface Function&lt;A, B, E extends Exception&gt; { B apply(A a) throws E; } ``` The problem is that you can't write a catch statement for a parametric exception type. So you can't write this: ``` try { return new Result&lt;&gt;(function.apply(value)); } catch (E e) { return Result.err(e); } ``` And instead have to write this: ``` try { return new Result&lt;&gt;(function.apply(value)); } catch (Exception eRaw) { @SuppressWarnings("unchecked") E e = (E) eRaw; return Result.err(e); } ``` Most codebases i have worked on end up growing a family of `ThrowingFunction`/`ThrowingPredicate` functional interfaces, with machinery to use them. I'm not entirely sure why this is not in the JDK. It does make things more complicated, and i suspect the designers really wanted the new stream stuff to be as easy to use as possible. It's a bit of a shame, because it's very common to want to use streams with IO (eg streaming over filenames in a directory, mapping each filename to some data extracted from the file), and at the moment, that is both awkward, and involves pushing all IO errors into unchecked exceptions.
I feel like Rust requires a completely different attitude to programming to C. Idiomatic Rust is all about high-level abstractions, whereas C is about low-level details. Rust lets you go level, but you use abstractions to do it. The thing is, if C programmers like abstraction then they'd most likely be using C++ rather than C. So chances are (outside of a few domains where C++ simply isn't suitable) that C programmers *don't* like abstractions. Hence they baulk at Rust, and tend to prefer languages like Go which take a similar "let's write everything out" approach.
Microsoft has been using Rust for years.
Oh wow, TIL, thanks for explaining that.
Rust/CLR for the win, lol
Not really, we have a couple but they're all spread out. A lot of the Sync people are here though, and they use Rust. Mozilla's pretty distributed.
[pre existing cache](https://i.imgur.com/TUTcrQ4.jpg)
Sorry for sounding a bit harsh. I made the list with a non-optimist view in mind so that they don't rely on features that only stabilize years down the road. I personally used specialization in one of my crates in an optional feature in 2016 hoping it will soon get stable and later removed it in 2017 because I wanted my users to be able to use it. Not sure what you mean with lang team's roadmap but maybe you mean [this](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#language) quote: &gt; Rust has a number of in-progress features -- such as const generics, Generic Associated Types, and specialization -- that have been in development for some time. It's time to finish their designs and ship them. Mentioning it in a list including const generics and GATs doesn't really help with evoking hope that it will stabilize soon. Const generics had been "there will be an unstable version of it in the compiler by end of year" for a long time until it arrived. And the current version is creating quite a lot of ICEs. GATs I'm not sure about but according to the tracking issue there isn't even an implementation yet. Both are major features and even async/await took more than the first half of the year to mature. I don't say this is bad, I really like that there is lots of care put into features before they get out of the door. This is the way it should be done. As for specialization, it has an implementation and I think there has been more design work on what and how it can be stabilized than const generics has. So right now it looks like it could stabilize first amongst the three features but of course this depends on how the teams prioritize it. Now to engage in glass balling: I am very doubtful it will stabilize this year, as async/await stabilization already took more than the first half of it. In 2020 it might happen, idk, depends on how it's being prioritized. But right now my non-optimist view is that the most likely outcome is 2021 and beyond.
So, what version of rustc/cargo potentially will contain this feature?
&gt;in 2016 hoping it will soon get stable and later removed it in 2017 because I wanted my users to be able to use it. Oh yeah, it's taken a long time, for various reasons. &gt;Not sure what you mean with lang team's roadmap but maybe you mean [this](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#language) quote: Yes, what I mean is "historically, there hasn't been a lot of movement on specialization because the language team hasn't taken finishing it off as a priority. Part of the reason for this is the lack of chalk. However, they've said that this year will be working on finishing these features, and so I expect there to be significantly more movement on specialization than there has been in the past few years this year." You're 100% right that I'm not saying "oh yeah specialization will certainly be on stable this year", but I do think that these changes are significant, and so its past does not mean that its future will be the same.
&gt; I don’t think I’ve ever seen resource leakage caused by exceptions in GC languages. I've seen them in Python since they carry the fully introspectable stack trace with them. You have to actually do something like store the exception some where or start yanking things out of the stack trace to cause this but once you do it's precisely negative eighteen funs to debug.
You missed my point. I'm not arguing language equality.
Seeing the direction they are taking Windows lately, with all the built in advertising, really makes me want this to not happen.
Neat! I haven't seen that one before. It sounds like the "non-`throw` functions are forbidden from throwing" part was important to their results. Would that mean that mainstream exceptions-based languages that are more permissive (Java, C++, Python) wouldn't be expected to give the same result?
Parallel rustc should help with cargo check. Related issues: * [Query Parallelization Tracking Issue #48685](https://github.com/rust-lang/rust/issues/48685) * [Release nightly compilers with ability to internally parallelize #59667](https://github.com/rust-lang/rust/issues/59667) * [Test parallel compiler #59530](https://github.com/rust-lang/rust/pull/59530)
1.38, likely released on 2019-09-26.
I guess they still have the R# name unused.
It will be possible soon once constants in array repeat expressions are on nightly.
Thanks for the help! Unfortunately it seems like the one limitation is that if you downcast to String, you can't return that reference, of course because of the borrow checker. Maybe it'll be possible when non-lexical lifetimes are released. Until then, I'lll definitely save your comment; it'll be useful to remember. =D
A huge feature for me would be language-level integration with actual Rust, ideally to the point where mixed-source packages are possible, and both compilers can import types and functions from the other language's modules.
This is a Hallmark moment of programming.
It depends on your needs but currently I wouldn't recommend it for real-time streaming. It's not very fast yet so you'll have to use a low resolution and framerate, and a fast machine.
I'd recommend `ggez` as the most polished 2D game framework. For networking there's `laminar`, but for a simple game you can also just use the TCP or UDP built into the standard library. I'd start with an `enum Message { ... }` serialized with `serde` into bincode.
How would you say your understanding of Rust's limitations compare to Node's limitations? I started focusing on Rust after looking for an alternative to JavaScript... - Rust creates small binaries and has fewer depedencies, making microservice architecture simpler (simpler is better). - Rust has a great type system that is core to the language. Much better than using TypeScript, which was bolted on top of JS. - Rust can compile to WebAssembly, which seems to be more performant than JavaScript over the long-term. It seems like a beautiful blend of Go and TypeScript. I get that some of the common libraries are still in beta/alpha stage, but that's something that I would expect to be resolved in the long-term.
I found yew after posting this thread, I think. I was *extremely tired* and very much in the weeds.
R# is resharper, that's already copyrighted, no way they could get that one :P
\&gt; I think it's used to explicitly tell Rust that the array a is intended to be iterated over, but I'm not sure. That's correct, but not just iterated over; iterated over by immutable reference. There are other options too: * `iter_mut()` for iterating by mutable reference * `into_iter()` for iterating by ownership
Firefox I think did the stats about CSS vulnerabilities of the past and they got some data about which of those could have been avoided. Can't google it right now.
the struct represented by 'a' implements the trait Iter. It provides extended functionality to iterate over something and the for loop is capable to use the functions of the implemented iter trait. One often used fn of the iter trait is 'enumerate()' which not only returns the next item of a collection, but also it's index number: &amp;#x200B; for (i, e) in a.iter().enumerate() { println!("Number: {} is of value: {}", i, e) } &amp;#x200B; It can also return mutable references and can do other stuff a "normal" iteration over a collection would not be capable of. It simplifies things such as cloning, or more complicated for loops if the index is needed.
😮Can you share the codebase? Also, who was this for? I'm curious who commissioned work in Rust.
Current model barely works (hence the attacks). And there's much more potential mitigations that can be done in software if one had full control over what is being compiled from an otherwise memory-safe code. First of all if a piece of untrusted code did not get IO resource to communicate with the outside world with, it will not be able to leak any stolen data to the otusdie world. And then you can do whole variety of things (all softs of randomizations, but potentially even utilize hardware enforced separation) in that model that you simply can not do in a model where you just run natively pre-compiled binaries that can do whatever they want.
that's so cool. I think that should be implemented in the next version and shipped with cargo.
Ah right. I read it as a complaint against just taking `&amp;Path`, which of course didn't make sense. That's quite correct, and a notable concern depending on the size of the function.
Thanks!
Unix model is bit outdated. Brainstorming may help, concepts like per-proc namespaces, capabilities will be nice for modern app based world. unix comes with too much 1970s cruft most of which can be simplified away. Some Berkeley additions to the unix also cause too much of complexity, better to avoid them altogether &amp; focus on fleshy part? In modern world, priorities are sandboxing, fast ipc, suitability in building distributed systems, virtualization (docker is too ugly soln IMO) And you can implement a POSIX compat layer anyway.
I'd love to share, but can't. This was the company: https://donors.decentralization.gov.ua/en/project/u-lead I wasn't commissioned for Rust specifically, just was given a rough spec and some designs, the choice of technology was mine.
you are welcome.
They'd be kinda dumb to not start using rust with 70% of their CVE's being related to memory corruption vulnerabilities.
first: &gt;People almost always start in precisely the wrong place when they say how they would change Rust, because they almost always start by saying they would add garbage collection. This can only come from a place of naive confusion about what makes Rust work. then: &gt;Probably I would also add a fourth modifier which is shared ownership, probably implemented via garbage collection The author sounds confused
I don't know if there's particularly good data on this. For the projects that have made such a shift, if there appears to be fewer bugs, does that mean Rust fixed it, or that a full rewrite of an old codebase with a newer, better design helps reduce the number of bugs? Getting good statistics can be quite hard when it's difficult or impossible to conduct an actual controlled study. What you can look at, which should give some sense of this, is how many issues in C and C++ software are related to memory safety, and assume those sorts of issues won't happen in safe Rust (a largely reasonable assumption). An [article from Microsoft](https://msrc-blog.microsoft.com/2019/07/16/a-proactive-approach-to-more-secure-code/) recently shared here has a graphic related to this.
It sounds like the thing that makes this "security-oriented" is that you're aiming for minimal dependencies. With that said, how is using your crate more secure than using only the the dependencies that I need directly? I'm not sure that I understand the value proposition, security-wise.
It's what I'd like to see, but that article only state figures regarding current memory safety bugs (70%), without Rust present yet, so, no comparison of before/after.
You've posted this to the wrong subreddit. You're looking for/r/playrust
Today I wanted to read about `std::iter::map()` and, since I know very little about rust, I searched for "rust map". Turns out there's a pc game called rust.
You should take a look at percy. https://github.com/chinedufn/percy
&gt; Were I implementing this myself I would change some things about the CLI but that isn't the most important thing at this stage (or perhaps ever). Can you file an issue in the asar GitHub repository? We would be happy to consider proposals to the CLI. &gt; I would much prefer the new asar crate not be tied in any way to one particular consumer (such as Electron Packager). I'm sure you understand what I mean by this. Initially, as it would be a direct port of the JavaScript implementation, the API would also be similar. Packager only needs one API function implemented, which happens to be different from your use case. I just want to point out that the steps were for the Packager use case. For yours, we'd swap out "Electron Packager" in step 1 for "list contents of an archive". &gt; Also, I have a heavy preference towards using the GPLv3 license. I do not know if this would put Electron Packager or any other current consumers in a bind, especially considering the `neon` module bit (does that "get around" the linking bit or what?). If GPLv3 absolutely won't work the next ideal license, again just for me, is MPLv2. While I'd personally prefer a strong copyleft license, practically speaking, that would prevent Electron Packager (and really any non-copyleft Electron tool) from using it. In any event, the code I was going to write (prior to this Reddit post) would probably have been Apache-2.0, given the licensing tendencies of both the Rust and Node communities, but this point is negotiable.
That's why he was the CEO, not the tech expert.
Yeah, I guess I did if you agree with me.
My biggest beef in general is compile times. I'm finding that if I use a workspace and create micro libraries things improve though, so I've been moving towards that
doesn't travis allow a 'post pass' deployment?
UBs in features that aren't that explored also are a problem.
What's a workspace? And a micro library? I want to move towards microservices anyways, both for front end and back end code.
Yes, it does. I think it is all doable.
I'm definitely intrigued. I like that it has inline CSS too! That was a feature I've gotten too used to in JavaScript.
I wouldn't put C#/Java/Python/Javascript devs into a Rust codebase.
I agree with the points you listed, but I don't think that is the full story. The big benefits of Rust in the webdev space are (in no specific order): 1. Better performance 2. Lower memory utilization 3. A generally more explicit and powerful language. 1. As a consequence, I find I write less buggy code and collaboration is easier. But you trade the following: 1. Much longer compile times 2. Being a more systems-level language, I find development speed to be slightly slower 3. Smaller, less-vetted ecosystem, the WASM side of which is not ready to replace JS 4. A harder to learn language, making hiring and onboarding more difficult &amp;#x200B; Node performance is only a few times slower than Rust, and RAM is cheap. Unless your domain requires raw speed and memory efficiency, these are merely nice to have things. Compile times reduce productivity a lot. For small projects, it isn't noticeable, but once you are supporting 30+ endpoints, I usually expect compile times to exceed 10 seconds, which breaks the quick feedback loop I find I require to stay in "the zone". Since \`async/await\` haven't landed in stable yet, I've found myself wrangling with Futures directly in code (calls to other services) that would have been much easier to write in TS/JS. The ecosystem is smaller, but getting bigger and better over time. If you already know Rust, I think it is worth it to use it for web backends. I find the general explicitness of the language and its type system make it harder to write buggy/obtuse code and makes it much easier to communicate intent than other popular backend languages. I would still stay away from Rust on the frontend for the immediate future. WASM in its current state seems optimal for rewriting the core of React in, or writing number-crunching code that is best performed on the frontend in, or porting an existing application to the browser to run in a &lt;canvas&gt; element, but I don't think SPA development can't really be justified at this point. There isn't a mature equivalent to Vue/React/Angular, and while Yew comes close, its compile times and poor library support make it a far less productive framework than TS/JS equivalents. I had a blast writing my app using Yew, but what I wanted from it was a learning experience. If you want something that can built within a reasonable time, styled with minimal effort, and integrates easily with the rest of the JS ecosystem, you are better off with one of the established JS frameworks. If you are chasing the holy grail of defining all of your message types in one language, you are probably better off using something like OpenApi or gRPC/protobuf to define what you send over the wire and derive your types on either end from that spec (although I haven't yet explored the feasibility of this in Rust).
It goes the other way too. People post on this subreddit expecting it's for the game, but it's completely unrelated.
haven't done it, but I may try. Never published anything useful to cargo. :)
windbg works well-ish. &amp;#x200B; [https://www.microsoft.com/en-us/p/windbg-preview/9pgjgd53tn86?activetab=pivot:overviewtab](https://www.microsoft.com/en-us/p/windbg-preview/9pgjgd53tn86?activetab=pivot:overviewtab)
I know some of the mitigations rely on the kernel/user separation. I am sure we can do a lot of interesting mitigations by instrumenting code but timing attacks aren't in that bucket. Sandboxing IO is indeed very good but it also limits the services that the (potentially untrusted) app can provide. Any useful application will need to perform some form of IO to function so there is at least some code with the potential to exfiltrate one way or another. I don't necessarily disagree with you about increasing security by being able to prove some properties of the code, but I would be surpriaed if it would be enough to deprecate things like kernel/user separation.
Nothing beats [the 5th top post in C++ questions subreddit](https://old.reddit.com/r/cpp_questions/comments/4rqlto/where_does_the_spit_go_that_the_dentist_sucks_up/)
new on this sub is sometimes a mess because of that game. IIRC at one point they even had an automod to tell people they were probably posting in the wrong sub. It seems like it's been better lately though.
Let's focus the discussion folks: https://www.reddit.com/r/rust/comments/ceoyjm/microsoft_to_explore_using_rust/
Sure. The Microsoft Security Center officially endorsing Rust, promoting internally and promising us a serie of articles goes slightly above just "using it", though.
&gt; In the end, using ADTs for checked exceptions seems to make them tolerable in precisely the way that they didn’t used to be: checked exceptions in Java are verbose and cumbersome to work with and so people often skip using them. There's more to it: exceptions in Java are not first-class. If an interface in Java accepts a `Supplier&lt;T&gt;`, it does not accept a `Supplier&lt;T&gt; throws E` nor a `Supplier&lt;T&gt; throws E, H`. Thus functional programming and exceptions are at odds in Java :/ Compares this with Rust where a `Supplier&lt;T&gt;` just works; it's just that `T` can be `Result&lt;U, E&gt;`.
Note: C++ has `noexcept` specifically to denote functions guaranteed not to throw, and it does impact code generation results (for opaque calls).
Several things you're changing feel like Rust has them not because it needs to be a systems language, but because the existing features let it get away with it. RAII can effectively replace garbage collection in every instance except for cycles, which are already hard to make because of the mutability guarantees. On the flip side, garbage collection fails in *many* places where RAII shines, because RAII works for arbitrary objects that require cleanup; objects where you can run out of space for them and your program stops working because the garbage collector doesn't understand them. Even in *HASKELL and PYTHON*, file descriptors are basically handled like they are in C, just with higher order functions, and those languages' garbage collector doesn't understand that file descriptors can be exhausted just like memory. Same goes for Mutexes in Go. Rust's RAII handles both of these, memory, *and more.* While it would be nice to not need Send and Sync, even ignoring performance, the OS disagrees. There are many types handed out by the OS and system libraries, especially graphics, where the library will break if you try accessing it from multiple threads. There's nothing you can do without running a background thread waiting on a channel to make an OpenGL handle Send. Yes, Vulkan is better, but that doesn't mean every C library you try linking to is going to be thread safe.
Hi, Rich. I'm dad.
Hi Dad. Do you still forget to put your unsafe behaviour in a save wrapper?
As someone working with low-latency code, I have disappointing news for you. In C++/Rust, exceptions/panics are implemented on modern platforms with the Zero-Cost Exceptions model which promises zero-cost when not throwing, and a hefty penalty when throwing. There's a fine print, though. The zero-cost is zero *runtime* cost. Optimization, however, suffers. I've seen upward of 20%/30% performance improvements switching to non-throwing code; something as simple as replacing `option.value()` by `option.has_value() ? *option : DefaultValue` in performance-sensitive parts. There are at least two reasons, it seems: - Inlining suffers from the presence of exceptions: the exception handling "bloats" the size of the functions, therefore less functions get inlined. - Optimizations (such as code motion) are less aggressive in the presence of exceptions. It may be as simple as a number of passes just bailing out when seeing an exception, or possibly that throwing an exception is considered an observable effect and therefore stricter sequencing is applied. In any case, in my experience, the presence of exceptions significantly slows down the hot loops despite the promise of zero-cost.
"Security-oriented" describes the real world uses cases we have for the framework as the developers, and what tradeoffs we're willing to make in developing it. Going forward security is our primary concern, and will shape our decisions around the dependencies we use. We also mention it to note that we intend to build additional security-related features into the framework in the future (as described in e.g. the conclusion)
Yes, son. That's why you exist.
You can assume the number would be much more lower with Rust, as most^* memory management bugs are impossible in Rust (when not using `unsafe`, assuming no bugs in the language implementation). ^* This includes use-after-free, double free, reading uninitialised memory, data races and buffer overflows. The notable exception is memory leaks.
Various Azure teams have used Rust or explored Rust. This is Windows team talking about using it. There's been hints that Windows is considering introducing memory safe languages in the kernel lately and this looks like an affirmation that it's rust: https://twitter.com/WindowsDocs/status/1115993065603379202
This is usually done with tags. You specify a build job that only runs on tags and publish there. All CIs support this.
Java checked exceptions are only analyzed by javac when compiling source code. The JVM ignores them when loading and executing bytecode. I.e. methods can throw exceptions even if they didn't declare checked exceptions. Issues will obviously come up if you compile against source code that's different than runtime code (e.g. dynamic linking). It also comes up if you use reflection since reflected methods can throw any exception (stay in school, don't do reflection kids). But the most common case is where a method is declared in a class but defined/overridden in a subclass that wants to throw exceptions. You can't add exceptions to the `throws` clause (callers don't know about subclasses and couldn't check them), so you either have to arrange for the exception to be added to the `throws` clause in the parent class (often a pain, rarely done), wrap the exception in a `RuntimeException` in the subclass, or just add `throws Exception` to methods that you intend for subclasses to override. Rust could potentially avoid these problems since its type system doesn't have all the subtyping issues and could abstract over exception types. The type system and macros also cover a lot of what you would use reflection for. But rust does have exceptions: `panic!`. Obviously it's an unchecked exception since the type checker doesn't analyze it, but in a specific case where you have an exceptional circumstance and want non-local control flow, it would work and it's even "safe" rust.
Specifically, at 1:26: &gt; We're looking at leveraging safe languages for building parts of the kernel.
Then what you're trying to do probably has a memory unsafety bug that the compiler is correctly rejecting. If the trait requires `Out: 'static` and you have an `Out` which isn't, then anyone who uses the trait will potentially access freed memory, or other kinds of illegal aliasing issues.
Rust is a little complex, sure, but this proposed language is a crazy nightmare. XD
You can swap the string out with `.downcast_mut()` but it complicates the expression a bit because of the immutable borrow: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=59d87aa05835b6edf1feec69d0ee6b3d
so tried to auto deploy to [crates.io](https://crates.io). I have an existing account already. Never used it, but once, but without a deploy from travi. &amp;#x200B; I did the following things: &amp;#x200B; * added .travis.yml to my project [cyrconv](https://github.com/aspera-non-spernit/cyrconv/) * logged into crates with my github account * generated a deploy token for travis * installed ruby-travis from the aur as user * cd'd into the project folder * executed .gem/...../travis encrypt TOKEN --add deploy.token // adds the deploy part and encrypted token to the travis.yml * added deploy on master branch and on tag change only * tagged the repo with git tag deploy * pushed the repo and tag with git --tagso push origin master * deploying was triggered but failed: &gt;error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata So it seems. the deploying process is simple to realize. The error refers to missing fields for [crates.io](https://crates.io). Have to check how to do that. Was long time ago I did that. Will report.
Protip: If you Duckduckgo [!rust std::iter::map](https://duckduckgo.com/?q=!rust+std::iter::map) it takes you directly to the docs for it. It works for any name in std, proc\_macro, or test. You can also Duckduckgo a specific crate with [!crates boolinator](https://duckduckgo.com/?q=!crates+boolinator).
Wow...thanks for that :D
I have some stats, albeit indirect. http://lcamtuf.coredump.cx/afl/#bugs - this is a list of memory safety bugs that AFL fuzzer has discovered in C code. Every single major C project is in there. https://github.com/rust-fuzz/trophy-case - this is the Rust equivalent of that trophy case, with the same tool. Notice that out of that entire list just a handful are marked as security-critical; the vast majority are controlled panics. It seems that humans make all the same mistakes, but Rust prevents them from turning into exploits. I have elaborated on that further [here](https://www.reddit.com/r/rust/comments/8zpp5f/).
Great! I had no idea duckduckgo had bangs! for C++ and rust!
That should just be: impl TryFrom&lt;T: Read&gt; for MyType
I'm using GitHub actions to do this in my crates.
It looks like you commented on the wrong post: [https://www.reddit.com/r/rust/comments/ceimgw/blog\_post\_perils\_of\_constructors/](https://www.reddit.com/r/rust/comments/ceimgw/blog_post_perils_of_constructors/)
I'm pretty sure he's saying if you wrote one and how easy it would be to write it in a way that sense safe but breaks in certain hard to see conditions, not that one already exists.
&gt; If you are chasing the holy grail of defining all of your message types in one language, you are probably better off using something like OpenApi or gRPC/protobuf to define what you send over the wire and derive your types on either end from that spec (although I haven't yet explored the feasibility of this in Rust). Are you saying this in contrast to using `serde`? &gt;I had a blast writing my app using Yew, but what I wanted from it was a learning experience. This is where I'm at. I just want to become good with the language/tools. I know it's not as mature as JS, but I expect that it will be in the future, and that would lead to future payoffs for me if my skills are already there.
Many thanks! It's the kind of stuff I'm interested.
Fwiw this is mostly what Rust started out as. There's nothing wrong with the language so-described, it's just a little ways from the niche Rust's design adapted to over time.
You would normally manually tag builds you wanted to deploy. Otherwise, you might really noise up `crates.io`
How would you write the types for unsafe code that's *implementing* the mechanisms to make things thread-safe? How would you write the types for objects that can't be shared between threads (and in particular, objects for which the overhead of a mutex or similar would be excessive)?
To be clear, the notice is apparently not displayed on the mobile app :/
https://jaxenter.com/security-vulnerabilities-languages-157038.html The original report is linked at the bottom of the page. Notice that Rust isn’t included, but you can already see that most vulnerabilities are in C, while C++ is quite low on the spectrum.
makes sense. I deployed 0.3.0 and then figured that I had not a binary main.rs or src/bin/cyrconv.rs in the project. So I basically deployed a successful build but useless program. Is there any chance that this can be avoided, maybe a mandatory lib/bin tag in the Cargo.toml that checks that?
Oh yeah: except exceptions. Life is so much better without them 😊👍
Yo let’s rocket raid this guy
Oh, wow. I wasn't even aware of Github Actions. Have you though about writing a blog post about it and describing how exactly did you set it up? Is this potentially easily "shareable", so that other users can easily copy what you did?
Sorry to say but this isn't useful. The idea is to compare project vs project over amount of memory related issues for example, not compare how much one language produces such bugs in a global scale.
I worked around it by creating a new blanket impl with one of the trait bounds being read for the type being converted from, and the other trait bounds being that the type being converted to must be able to use the existing try from that I had already impld in the form of another trait bound
This seems to be the case. However it seems to work for `From&lt;T&gt; for U`. I thought there was a blanket implementation for `Into`. What am I missing here? https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e17e713693d798baffe92eadfcdc1761
Dang it, debug comments. I forgot to build with the release flag set again...
&gt;My main goal is to build operating systems that are purely sandbox-based and compiler enforced, eliminating need for MMUs, kernel/userland distinction and so on. Sounds roughly similar to the goal of [Nebulet](https://github.com/nebulet/nebulet), which does this using WebAssembly (and is written in Rust).
There's nothing contradictory in this. Instead of using pervasive garbage collection for everything, provide garbage collection only in the cases where shared ownership is needed.
That makes a lot more sense; my Google-fu has been a little shabby lately. :P So people are thinking that it might be possible to store data of unknown size on the stack? How is that possible?
It's all good! So, it turns out that my memory-fu has been bad lately, we did accept [https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md](https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md) though it has not been implemented [https://github.com/rust-lang/rust/issues/48055](https://github.com/rust-lang/rust/issues/48055)
I'm just a beginner at rust, and don't know anything about unsafe. It looks like the whole thing is in an unsafe block. Does this negate all of rust's safety?
Yes indeed.
Yeah! Last year or so we've been pushing hard to make it a common data substrate for the cloud. Where etcd is great for small amounts of metadata (one of our components actually uses it!) we're excellent for storing large scale data (in the terabytes!) &amp;#x200B; My friend /u/brson is actually looking at using sled to back tikv soon. :)
For example: &amp;#x200B; [https://github.com/distributedio/titan](https://github.com/distributedio/titan) [https://github.com/pingcap/tispark](https://github.com/pingcap/tispark) [https://github.com/yongman/tidis](https://github.com/yongman/tidis) [https://github.com/pingcap/tidb](https://github.com/pingcap/tidb)
I mean to say that you could move your message definitions into a schema external to your implementation language and generate your datatypes for your Rust server and your, for example - TypeScript client. My understanding is that you could still use Serde to \[de\]serialize to an arbitrary encoding format, provided that the codegen from the .proto derives `Serialize` and `Deserialize`. I believe something like [https://github.com/stepancheg/rust-protobuf/](https://github.com/stepancheg/rust-protobuf/) can be configured to do this. (Sorry for specifically referring to gRPC, I'm still unfamiliar with this design pattern and its various ecosystems) &amp;#x200B; I haven't tried using .proto files as a message schema, but I'm planning to give it a shot in whatever personal project I do next. &amp;#x200B; I don't think exclusively using Rust on the frontend is a good investment (although it certainly isn't a bad ideal). Its in your best interests (wrt your carreer) to become proficient in JS/TS &amp; one of the big 3 SPA frameworks. If you want to have fun and contribute towards the ideal of Rust on the frontend, build something with Yew, locate where it is deficient for your needs and see if you can contribute something back to it. &amp;#x200B; I'd imagine that Go is the more employable skill in today's job market. Rust is becoming more of a viable employer-friendly technology choice at a pretty amazing rate, but you will likely struggle to find work using it versus other more established languages &amp; tech stacks.
I'm trying to implement a `Future` "by hand", although it's mostly based off inner futures. I already have code that creates a similar object by chaining `.and_then()` calls, but I want to try writing a concrete type (another part of my code needs it). I have a [playground link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=bd6c4c00720da6259199a81e2e639034). The idea here is simple. I'm trying to write a client for an internal/proprietary pub/sub implementation we use at my job. In this very specific example, I'm (1) creating a SUBSCRIBE message, which might fail, and then (2) sending it to a socket. (I'm actually hard-coding the message creation to always create a message [1, 2, 3] for the sake of minimizing the example, and completely omitting the actual TCP send.) I'm using a state machine for the future. In this case, there are only two states. In the first state, we already have either (a) a constructed message (`Vec&lt;u8&gt;`), or (b) an error when constructing the message. In the second state, we take the constructed message and write it out to a socket. The main issue I have is trying to move out of the future state object. I want to be able to move the byte vector from one state to another. Intuitively, this should be perfectly fine - it's owned by the future, and I'm swapping one state for another. However, I can't get the borrow checker to agree. What I'm missing - and what may be impossible in Rust - is a function that takes a mutable reference and a mutator function which takes the referent by value and returns a new one by value. In other words, I want to replace the value in-place. `mem::replace` doesn't do this at all. Is the only possible way to do this with a dummy variable? It sounds like I'm going to have to clutter the already terrible Future implementation with a mess of Options so I can replace them with None, modify the value, and replace it again. Not only does this seem like a lot of boilerplate, but it sounds very, very slow (it will have to do this for every single message you try sending!). Are there any alternatives? Or can I at least be reasonably sure that the compiler will optimize the whole thing to what it would be in C++ or a similar language? (Presumably I'd use the same technique to move the Error out of the first state - by swapping the first state with a "Finished" state to take ownership of it.)
I've read about experimental version(s) of LLVM which have a 6502 backend. Haven't looked into them, but it should be possible to go straight from rust to 6502 with that. Still cool OP got this working.
I want to talk about the first question. Surely it's been changing, especially when you see how web technology has become the polished turd standard. And, on the Rust specific side, Rust itself is a massive risk management tool. There's a strong case to be made that the risks of a newish language should be measured against the inherent risks of using *literally any other language*, be it real time performance, developer confidence, or general security concerns. If there was some choice between COBOL, ASM, C, C++, Java, JavaScript, Lisp, and finally Rust, then it should be obvious that there are always tradeoffs. For example, if I needed to translate a large JavaEE app into Rust, I'd sooner write a JVM in Rust than translate it 1:1.
This post isn't about Rust, but the end... &gt; If there are legitimate reasons for needing the speed, control and predictability of a language like C++, see if you can move to a systems-level programming language that is memory safe. In our next post, we’ll explore why we think [the Rust programming language](https://rust-lang.org/) is currently the best choice for the industry to adopt whenever possible due to its ability to write systems-level programs in a memory-safe way.
I'm fairly new to the rust community and come from a heavy JVM based ecosystem. I've been porting one of our production apps from Scala/Akka to Actix for performance benefits and a smaller memory footprint. Also some of our software is moving into the embedded space and running Scala web frameworks on things like a Pi doesn't play very well. &amp;#x200B; I've recently had a very pleasant experience getting a PR accepted into actix-web. Setting the max size of payloads for WebSockets wasn't exposed by the public API. After discussing the issue with [/u/fafhrd91](https://www.reddit.com/u/fafhrd91/) on gitter, he was able to point me to where in the code things would need changed and also provide suggestions on the best way to expose the API publicly. After a couple of commits, [/u/fafhrd91](https://www.reddit.com/u/fafhrd91/) merged the PR and made a release shortly after. This wasn't just my first PR to a rust project, but my first PR to the OSS ecosystem in general. I must say, [/u/fafhrd91](https://www.reddit.com/u/fafhrd91/) was very helpful identifying where the issue was and getting my PR merged. Just my anecdotal 2c.
 &gt;If you can trigger UB in safe code that's a compiler bug. I think that's usually a *library* bug.
You're going to pay for IO one way or another. If the majority of your application's work is reading files from disk, then pre-loading the data won't really help. If, however, you spend more time processing the information than reading it, preloading will definitely help a lot. In this case, don't pre-load the data of all the files, just pre-load the next file (or the next few files, if the processing/loading disparity is that high).
It's harder to prevent leaks than by merely preventing direct IO access. It's possible to leak indirectly by influencing something which does have IO access.
This sure is getting posted a bunch
This article was created 20 minutes ago.
In many cases there are direct parallels; for example, I've fuzzed a png decoding library that's never been fuzzed before, and it has plenty of bugs but neither of them were exploitable thanks to Rust. This is a stark contrast to libpng, where AFL has found exploitable bugs.
There haven’t been much notable performance improvements in recent weeks, but it will definitely improve when pipelining lands. (**cough**)
You might also be interested in https://rustsec.org/advisories/ / https://github.com/RustSec/advisory-db - a list of cases where Rust code actually *was* vulnerable, because people decided to use `unsafe` and misused it.
Not sure I agree – I believe that there is a smaller, better language inside Rust that's struggling to emerge and that it can be reached without messing with the things that make Rust Rust. - Get rid of all special syntax involving `[]`: Drop special syntax for arrays and slices. Use functions. - Get rid of all special syntax for ranges. Use functions. - Get rid of mandatory semicola to end lines. It's almost 2020. - Fix the inconsistent casing of type names. - Get rid of casts that are not casts but conversions. E. g. int ⟷ float casts. - Make everything that takes arguments consistent: structs, enums, functions. Get rid of all the special cases. - Replace `&lt;&gt;` in generics with `[]`- - Clean up the naming in the standard library. - Deal with the library stutter, e. g. `foo::bar::Bar` - Fix the broken `Eq`/`PartialEq` and `Ord`/`PartialOrd` hierarchies. - Replace macro invocations that emulate varargs with first-class varargs. (Yes, I know, every language designer hates varargs. Been there, done that.)
Sure, thanks!
Does Microsoft contribute to Rust at all?
This post was co-authored by Ryan Levick, who has been around the Rust world for a while at this point, and been doing even more lately. Someone on HN said &gt; MS has also already been contributing to Rust and LLVM to get it working on Windows ARM32 and ARM64. But I'm not sure how true that is, exactly.
[`posix_fadvise()`](http://man7.org/linux/man-pages/man2/posix_fadvise.2.html) may be worth looking at, in particular with `POSIX_FADV_WILLNEED`. [reapfrog](https://crates.io/crates/reapfrog) may be of some interest.
The biggest issue with Rust mechanism is that you can't really return different errors from a single function. So what you end up with is every library and application needing to define its own custom Error type. But then you end up jamming all possible errors into that Error and it no longer makes any sense. For example, let's say a function can return error A or error B. So you make an Error type that encapsulates those inner errors - cool. But then there's another function that can return error B or error C. Typically library authors will just add C as another variant to Error, and now it looks like both functions can return all three errors, but they can't! I think what we need is a better Result type with multiple error types: enum Result&lt;T, E...&gt; { Ok(T), Err(E), ... } Of course Rust doesn't support this, and the syntax gets wonky (what would the other enum variants even be called?).
I sometimes see comments on /r/Haskell referring to a study that the raw number of bugs doesn't tend to decrease when a project gets rewritten in a safer language. The justification I've seen (not sure if it's supported by the study or not) is that modern software development is focused on getting the software to a usable state and then adding extra features, not about squashing all bugs. So it's not even clear that you'd see a difference in the raw number of bugs, but instead in relative severity and time-to-fix.
I'm into making CLIs but I am a serious beginner. Are there any examples with this microframework?
Is this about 1.36.0? What changed that leads to better performance.
I think it's meant for r/playrust
I'm already a React/Node developer! I think my short-term job prospects are good. The reason I fell into the weeds was exploring microservices with Typescript, then Go, then Rust. I can already write monolithic architecture, but I want to learn to write alternative architectures (my current job has a microservice codebase, but I didn't set it up... I merely inherited it).
AIUI, Microsoft is footing the CI bill for `rust-lang/rust` now.
&gt; the thousand holes, papercuts and billion-dollar mistakes of the flagship, C#. I don't understand this. Microsoft hate aside. C# is a much better Java.
The move to Azure Pipelines is almost but not quite done, as far as I know, but yes, I should have mentioned that was in the pipeline (PUN INTENDED) too.
Oh it looked live to me since Alex deleted the Travis config a few days ago lol.
Then I'm probably just a few days behind. Great!
[cargo-audit](https://github.com/RustSec/cargo-audit) is a real-world example of a CLI app which uses Abscissa. It's a little weird though because it's a [third-party cargo subcommand](https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands).
No my position is that if I'm going to rely upon a crate for serious work then a developer should: + Only use unsafe when necessary. + Should have a rigorous testing process for unsafe code. + Should take unsafe bugs VERY seriously. It seems that ACTIX doesn't do any of these things.
Did they upgrade their offer from the initial 60 concurrent jobs for free to completely free? Rust's CI needs seem intense.
they pay actix-web creator to work full-time on this framework (they use it in Azure IOT Hub)
Makes sense. An old friend of mine would say, "Start by implementing your program in whatever high level language you can develop the fastest and most maintainable code in. If for whatever reason that doesn't give you the level of control or performance you need, re-write it in something lower level like C." I can see Microsoft going to an approach like this: C# for their high level, easy to write language then releasing MS-Rust for Windows (or whatever they decide to call it, probably Rust# these days), that their low level utilities are developed in and has added support for doing things where more direct kernel interaction is necessary.
Couldn't TiKV also be used to replace etcd? Or is TiKV too heavyweight / optimized for a different use case? &amp;#x200B; &gt;My friend [/u/brson](https://www.reddit.com/u/brson/) is actually looking at using sled to back tikv soon. :) Isn't this blocked on sled getting transaction support?
Looks like there was a double-drop on panic. I don't know whether that would be exploitable, I suspect it would be only if you actually catch the panic, but that's a good point that using these unstable features means you don't get CVEs when they are found to be unsound.
Azure Pipelines is sponsoring the rust project so they receive more than the normal free offering OSS projects get.
If there's UB in the library's unsafe code, then yes, it's a library bug.
We actually stopped using Travis CI and AppVeyor completly on July 1st! The config Alex removed a few days ago was just a leftover `echo` we kept for a while to avoid breaking our bots. To be clear though the migration as a whole isn't finished yet, there are still a few things we need to fix before we reach full parity with the old CI: those things are tracked in issues with the [azure-evaluation](https://github.com/rust-lang/rust/labels/azure-evaluation) label if y'all are curious.
Yeah I suppose you could say there is some feedback. When a project gets really buggy, people focus on fixing the bugs. The "really buggy" threshold doesn't change. However the types of bugs in Rust should be different, i.e. no memory errors or data races.
I don't really have time to discuss this again. 😄
The normal free offering is 10 concurrent jobs. When the rust project posted they were looking for a new CI, Microsoft offered 50 more for free. If it's still the current offer, then Mozilla would pay for all the job passed 60. If Microsoft offered unlimited jobs, it would be very generous!
&gt; AppVeyor Wow, this is news to me. I remember a lot of comments during the investigation phase specifically saying Windows was out of scope for now.
Microsoft has been working with the infra team to supply all the agents the team needs for free.
It is very generous indeed. Mozilla said they wouldn't release numbers but that their CI was very expensive. Which it must be if 60 concurrent jobs are not enough! I wonder how many jobs they run.
The [orginal thread said](https://internals.rust-lang.org/t/which-ci-platform-should-rust-use/9322) &gt; The service must provide both Linux and macOS machines. Windows support could be nice, but switching away from AppVeyor is not a priority for us. Which is slightly different than "Windows is out of scope."
The let statements may not need be required to be within the unsafe block, however interacting with the C64 requires reading and writing to specific memory regions. It doesn't negate all of rust's safety at all, the borrow checker is still at play and all that unsafe guarantees is: * Dereference a raw pointer * Call an unsafe function or method * Access or modify a mutable static variable * Implement an unsafe trait The reason why these are unsafe is that, writing or reading arbitrary memory regions is undefined by the language, on modern systems we would get a segfault because there is memory protection while on the C64 we just read whatever is at that location.
Just how many concurrent jobs do you need?
A CI build ([for example the latest one](https://dev.azure.com/rust-lang/rust/_build/results?buildId=3711)) runs on 59 builders, then we have some spare capacity for try builds, PRs and other repositories in our orgs.
That's impressive. And I expect that it will go up over time if platforms move into tier 1.
I think my confusion came from this statement earlier in the post &gt; These are the requirements we have for a Travis CI replacement. We aren’t looking for an AppVeyor alternative at the moment.
&gt; C# is a much better Java. You are correct, Java is an even worse C#. Scala (and eveb Kotlin's attempts at non-nullity) is similarly chained-down by JVM-interop, as F# is by CLR-interop.
The problem Microsoft is going to have with Rust if they choose it is that it has a baked-in decision (at the compiler level) that strings are UTF8 byte arrays. Not UCS-16, with is what the Windows Kernel, C#, and Java use. While rust has an "OsString" type, it's actually WTF-8 (yes, really) on the inside, which is a variant of UTF-8 that allows invalid UCS-16 to be represented losslessly. Even if AVX intrinsincs were to be used to accelerate the conversion, many APIs would take a performance hit when using Rust on Windows, or are just annoying to use. I don't know if Microsoft would embrace a language that would have a permanent performance penalty relative to Linux. Might be career suicide for whomever approves that! One interesting thing to note is that Windows 10 v1903 added UTF-8 as an MBCS code page, which would allow a smoother integration of Rust-like languages, but this doesn't make the conversion go away, it just moves it out of the language and into the Win32 DLLs.
Is there some way to determine at compile time the number of variants in an enum? I found an answer at SO, but it seemed tune to a different use case. Basically I want to be capable of writing code like this: enum Cost{ Low, Medium, High } struct CostEvaluator{ costs: [Cost; Cost.number_of_elements()] //this }
&gt; Has this ever been measured? I know it's true in theory, in some cases. But in practice, if you're dealing with Result in a loop, doesn't that usually mean you're doing IO and making system calls anyway? No, and it drives me crazy when people think that Async, Streams, and Exceptions apply only to I/O because clearly programs never do anything else. Errors in Rust are used for extremely fine-grained things such as byte-by-byte parsing in libraries like Nom. Granted, a lot of that type of thing would be inlined by the compiler, and you would hope that the error handling is optimised out of tight loops, but often it simply can't, because it's part of the visible control flow logic and hence must be kept.
(nit: The sync team is very distributed, and definitely not mostly in SF. I think only one of the team members out of ~10 (counting non-engineers) is in SF)
Why would Rust# be necessary? Rust supports Windows well already. Microsoft has been contributing to the current Rust project as well (they’ve started footing the CI bill) so it seems to me like they’re committed to the language as it is. Why would they fork it, instead of simply improving it?
&gt;I don't know if Microsoft would embrace a language that would have a permanent performance penalty relative to Linux Or maybe the next version of Windows moves to UTF-8. Or more likely, some kind of spinoff next-gen OS. It's not as crazy as it sounds. That's how NT/XP supplanted 9x a generation ago.
The compiler can't know though. Foreign functions and structures can never be figured out. Send/Sync being inferred when obvious is fine, but it just isn't possible to do it in general. That's why we need send/sync.
Interestingly, it's not because of a feature that Rust has, but because of a feature Rust *doesn't* have.
They could add it to the API, but they will never make any changes that break legacy code.
https://stackoverflow.com/questions/41637978/how-to-get-the-number-of-elements-variants-in-an-enum-as-a-constant-value You can also just use a HashMap instead probably - it doesn't seem like you really need the efficiency of an array in this case.
They don't need to break legacy code, but they could well add a 'compatibility mode' which makes *old* apps perform at a penalty. They did it before many times, you can run XP compatibility on Windows 10 today. Same with 32-bit compatibility on 64-bit machines. It's not the same as having a *permanent* performance penalty for everything going forward, and is something that may be acceptable.
I have to agree on most points. \`\[\]\` is a great point I have not thought of. There are so many ways to access an array, why one in particular has its own character? About \`&lt;&gt;\` vs \`\[\]\`. I do not see how the language gets simplified. The one thing I do not like about rust is that almost any symbol in my keyboard has some meaning. Makes it for a lot of memorization
That's not quite how the Win32 API is set up. AFAIK the Win32 api very rarely deprecates features, they just keep adding to it. They added support for unicode by offering two types of functions: ASCII and WIDE. They could support for another type that uses w/e encoding they want, but they wouldn't remove the old functions from the api completely, a different function would just need to be used (or pre-processor statement)
I definitely need performance (this is used in the main loop of an interpreted VM). There’s no “official” way without using that complex macro setup though?
Just started writing a kernel in Rust. So far I have safety by compiler error :) Eventually got everything compiling (and down to 5000 bytes for a hello world 64 bit kernel with multiboot header) though it feels wrong to have then immediately wrote a bunch of naked pointer dereferencing code.
Hmm, that's unfortunate.
Does anyone here have experience with `yew`? It has a LOT of GitHub stars so it seems like it's being used a lot, but the examples in the repo I ran were all not really impressive to me. They were all basic things to any reactive framework. Is the impressive thing about Yew "we got the basic primitive stuff down and this is a first step toward a WASM competitor to Vue/React"? Or is it actually used for any really nice UIs / impressive stuff? If so, how can I find those examples?
Yep, thought about it more than once... I even started writing such a post, but didn't finish. Your comment is good motivation for me to finish it.
I've looked for something like Secret&lt;T&gt; a few times and was about to write my own. Thanks!
Is there are decent dynamic "array + len" type I can use which doesn't include anything from standard? I'm writing an ELF format library for a kernel and so cannot use Vec, slice or any of the other standard library functions. I ask because my interface for creating the common portion of the ELF header is below pub fn new(data: *const u8, len: usize) -&gt; Option&lt;ElfCommon&gt; { I really don't want a raw pointer in the interface. If there is a good data type I can use that doesn't pull in standard it'd be useful. If not I might write a fat pointer struct. This brings me to my second point. Is there a way to conditionally compile whether something is included based upon whether the standard library is there or not? Basically in "kernel mode" I'd like the library to be stripped of anything std. I'd like to create my fat pointer but also have conversions from Vecs and similar. So in my tests I can straight up convert a Vec to a fat pointer yet in my kernel that function is not there because std is not there.
Congrats on the release! I'm new to rust and the various popular crates, so forgive my ignorance. I'm looking for a string tokenizer à la [spaCy](https://spacy.io/usage/linguistic-features#tokenization) or NLTK for Python. Can I use tantivy in that capacity?
&gt; Replace macro invocations that emulate varargs with first-class varargs. (Yes, I know, every language designer hates varargs. Been there, done that.) Given rust, varargs would have to be typed, and they would probably be a slice on the caller's stack. Typed, safe, and zero-cost! Similar to Go's varargs, except we can prove we don't need allocation.
&gt; Why would they fork it, instead of simply improving it? Embrace, Extend, and Extinguish. While it is no longer _official_ company policy. It **was** company policy, [the DoJ found during the anti-trust (monopoly) law suit](https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish). Which as of 2008 employees have testified in court is still an _unofficial policy_ [cite](https://en.wikipedia.org/wiki/Microsoft_litigation#Comes_v_Microsoft). It is hard to see the company in a different light after the 90's and 00's where they were blatantly downright evil. They sued a Canadian High School student over the domain name "MikeRoweSoft.com" [cite](https://en.wikipedia.org/wiki/Microsoft_v._MikeRoweSoft) which was the kids name. It is hard to trust them, as they've very publically demonstrated they are not trustworthy. So sure, maybe they've changed.
I believe, there is not. You're probably aware of `std::mem::discriminant`. I don't see how a single 10-15 line macro is complex though. It looks pretty straightforward to me, even though I haven't have anything with proc_macros before.
I should let the author speak for themself. Here's my understanding: The FFI would have to change dramatically for this language. You wouldn't be able to directly call foreign functions or work with foreign structures: everything would have to be wrapped or converted on the way in and out. It would likely be much slower and more memory-intensive.
If you explain it like that, sure. The blog post author comes on very opinonated with "This can only come from a place of naive confusion" when a more humble message would be appropriate, if as it appears later on, suggesting a garbage collector isn't at all a naive confusion.
slice? https://doc.rust-lang.org/core/slice/fn.from_raw_parts_mut.html https://doc.rust-lang.org/core/slice/index.html
&gt; Is there a way to conditionally compile whether something is included based upon whether the standard library is there or not? It looks like there is not https://github.com/rust-lang/rust/issues/42190
Interopt between the rest of their ecosystem?
&gt; I'd like to create my fat pointer but also have conversions from Vecs and similar. So in my tests I can straight up convert a Vec to a fat pointer yet in my kernel that function is not there because std is not there. something like this might work universally, without the need to distinguish std/no_std: pub fn new(data: AsRef&lt;[T]&gt;) -&gt; ...
Wanted to do a `/s` but that felt too obvious so `(cough)` it was.
There's zero chance of the NT kernel being updated to use UTF-8 internally. It would break binary compatibility with literally millions of third-party drivers. This just won't happen. Ditto with Java, the deployed base of code in enterprises is just too vast to tinker with something so low-level. System programming in UTF-8 is a Linux thing. Windows and MacOS use UCS-2 internally, and many Unix operating systems use UCS-4 or other encodings. It would take decades to move off UCS strings in the wider world than just Linux. The Rust team made a mistake in not using an abstract string trait and insisting on a specific binary representation. No amount of wishful thinking will change the reality that it's a niche language that painted itself into a corner that is a different corner that the vast majority of world is in.
Josh! I should let the author speak for themself. That said, here's my understanding: &gt; How would you write the types for unsafe code that's implementing the mechanisms to make things thread-safe? You wouldn't. Such code would not be representable in the language: the compiler would be the only thing that could implement it. &gt; How would you write the types for objects that can't be shared between threads? You wouldn't. The language would only give you access to thread-safe objects. That would likely involve some potentially-expensive conversions and locking and whatnot under the hood. &gt; in particular, objects for which the overhead of a mutex or similar would be excessive Those things would likely get much slower. As I understand it, the proposal is to produce a language for programs that sometimes run as slowly as Go or optimized Haskell (tolerable, really) but always are safe and simple. This would not be a "systems programming language" anymore: think Python but with the advantages cited by OP and way better performance than Python.
The other answer already covers most of what I wanted to say, but I would also add that the point of unsafe blocks is that, provided that they're properly written to maintain invariants, they localize potential unsafety. Ideally, stuff like changing the border and background colours would be written as functions with unsafe code inside of them, but then those functions themselves would be perfectly safe to call, meaning that most of the code could still be safe.
I've written a fair amount of winapi code, and haven't *personally* run into this as a big problem. If it turns out to be necessary, I think it would be possible to write a pretty good UCS-2 string library and the ergonomics would be okay. There's not a whole lot privileged about `String` and `&amp;str` except for string literals, and those can be handled by macros.
I'm not the one who got this working, actually, which is why I tried to put credit in the title. Unfortunately, the author of this isn't interested in working on it any further, and replicating his results using only what he uploaded to GitHub has proven somewhat challenging.
Well I guess that's the problem, I'm bored with what i know and this seemed like an interesting challenge but I'm having trouble finding a practical use for it
I wasn't sure, at least when there is a video with a bunch of naked guys it's obvious.
Heads up, it's either UCS-2 (the old name before surrogates were added) or UTF-16, not UCS-16.
No. Floats are fine. Various languages thought partial order (§5.11) and total order (§5.10) should exist within the same hierarchy, even if those orderings were incompatible with each other. That was a mistake. Now total order is pretty much inaccessible, and even trivial operations like "is this float in that list" suffer by returning incorrect results. It's a sad state of affairs, because it would have been easily preventable by reading the IEE754 spec and spending some time to solve the issue.
Yeah, I think the MSRC article/ title made more sense.
The page takes a minute, since it has to load the data and generate the graphs. To avoid generating the graphs, you can [view a table](https://perf.rust-lang.org/compare.html?start=2019-01-01&amp;end=2019-07-17&amp;stat=wall-time), which is also sorted.
What's confusing about this is that Microsoft Research already has a pretty kick-ass secure language in F-star, being used to build a verified HTTPS stack: https://project-everest.github.io/. I wonder if F-star is just not user-friendly enough yet or doesn't have a big enough ecosystem for their purposes here? I would be sad to see it fall by the wayside.
Many languages use resource scoping mechanisms to get the same kind of behaviour as RAII. Python has *with* and Java has *try with resource* for instance.
I’m looking for better real-world examples of multi threading. Every example I see out there is about incrementing a counter or printing some text to the console. My use case involves a struct with a function which needs to access its vector property as read-only. Basically the idea is to break the vector into slices and have each thread compute some results, then join and copy into a mutable version of self. So I guess I’m looking for multithreading Rust tutorials when _self_ is involved.
I’m pretty much fighting with windows fans all day and Everyday haha. They don’t wanna admit it, you know. That’s funny 😂
yea. i'm referring to https://daniel.haxx.se/blog/2017/03/27/curl-is-c/ glad someone with bigger data set can say memory bug is dangerous
I'm guessing that Rust# would just be their branding for it. I doubt they would change it, but they might put their spin on the name when they add support in MSVS.
The reason this surprises me the most is the increased usage of procedural macros, which definitely aren’t what I would consider “highly optimized” code in **most** cases.
I just listened to a talk about this in the Curry On conference. My impression about this was that while it is super impressive technology, I don’t think it easily scales beyond building and verifying safety critical core components. There are obvious problems recruiting skilled enough people that are able to wield such tools for building bigger systems.
I just noticed your thread here. It's an interesting discussion. Do you have any advice for how I should refactor my code based on what you learned? Here is my windproc: https://github.com/dagit/mm2tracker/blob/master/native/src/main.rs#L240 I only call `GetWindowLongPtrW` in two places and I don't hold on to the result for very long, but I've always had it in the back of my mind that this is a terrible solution and it could fail as I refactor or add features. Thanks!
Agreed but the money now is in where your code runs not what code it is. If they think embracing rust gives them a cloud advantage, they will do it. Being good open source citizens is a byproduct of that goal.
LOL i see
The ergonomics will be terrible. Rust is already riddled with far too many string types, all of which have a hard-coded assumption that they're arrays of bytes. There is no String trait, and if there was, it would have to include [as_bytes()](https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes) and similar functions that are inherently UTF-8. So any UTF-16 or UCS-2 string type would have to carry around a separate UTF-8 buffer for compatibility. As a consequence, Rust's IO, parsing, etc...libraries have all had "all strings are byte arrays" assumptions baked into them. One way or another, you're forced to convert back-and-forth at the Win32, C#, or Java API boundary. That, or you'd have to rewrite basically all of Rust *and* its string-centric crates in an incompatible way.
You should fix that lol
Please note that rustc-perf only measures the time to compile the final crate in all of these benchmarks, rather than the entire benchmark. It's still solid proof of big improvements, no doubt! I'm just pointing out that the benchmarks might not be measuring exactly what you think they are measuring. In particular, it doesn't measure potential benefits of pipelined compilation at all.
The [`take_mut`](https://crates.io/crates/take_mut) crate has a convenient way to do this: fn update_some_field(&amp;mut self) { take_mut::take(&amp;mut self.some_field, |x| x.builder().pattern().update()); }
`Vec::new()` doesn't do any allocation, so it's cheap to replace it: self.state = Sending(std::mem::replace(msg_bytes, Vec::new()), 0);
I know at least two, but I may be using the wrong term for the team and meaning something broader :)
Yes, you should do the same as the latest [druid-shell code](https://github.com/xi-editor/druid/blob/muggle/druid-shell/src/windows/mod.rs#L931-L960): cast your `GetWindowLongPtrW` to a `*const` reference, then use `try_borrow_mut` to get a mutable reference when needed. I believe this approach completely follows the rules.
Yes, those are great when you can use them. Two downsides in my head: 1. It's possible to forget them. For example, files in Python will appear to work just fine even if you never put them in a with statement. 2. Adding a resource to a type that previously didn't contain one is an incompatible change. The type's existing callers need to start putting it in a with statement. Same for any other type that contains that one.
Thanks!
Does this include incremental compilation, or only apples-to-apples with a full fresh compile?
The problem is that `panic` during the construction of new value leaves `self.some_field` invalid.
Rust 1.29
Ah, the team split somewhat recently, if you count both the server-side and client side (both of which write a lot of rust) then yeah there are certainly more in SF than just 1. Probably at least 3?
Holy shit, that's impressive!
I followed that MikeRoweSoft saga, although at face value, it was/semmed evil, I also read some arguments that it was necessary, or they'd forfeit their rights to enforce their trademark/brand. Alas IANAL. It's the first time I heard this mentioned since the early 2000s.
Most strings in an app can stay utf-8. Only the ones crossing the winapi boundary need conversions, and in many (most?) cases the overhead of doing the conversion is fine. Only file names really need to handle the UCS-2 invalid Unicode cases. This just doesn't seem like a real problem to me.
If you want examples of Microsoft being evil, you don't even have to go that far back. The entirety of Windows 10 is pure evil.
It's not an example, but you probably just want [`crossbeam::thread::scoped`](https://docs.rs/crossbeam/0.7.1/crossbeam/fn.scope.html). Then you can just pass the slice directly into the closure.
It helps to read the sentences as they are written, I think. It is not GC in general that the controversial second paragraph is speaking of, but rather GC as the starting point for how to change Rust. What the author is telling us is that the order in which one prioritizes language design decisions is important.
Probably want to look into `rayon` examples.
We Need a Safer Web Programming Language As Well...
I know that trait bounds are a way to tell rustc that some type T has certain methods, but what about whether T has certain fields? The only workaround I've come up with is impl a function like `get_field` but that seems clunky / boilerplatey.
It is definitely annoying, but you're right: it is not a significant problem in practice. ripgrep operates entirely in utf-8 land internally, for both file contents and file paths, even when their original encoding is not utf-8. It works precisely as you say: by converting at the boundaries. To be fair, some effort needed to be expended on my part to get this right, but I split out most of that effort into reusable crates. It is not nearly the problem that the GP makes it out to be.
Could the compiler do this automatically? For traits like AsRef and Into and similar, I mean.
&gt; but what about whether T has certain fields? there is no way to do it (yet) https://github.com/rust-lang/rfcs/pull/1546
Nice! Thanks Hopefully this happens soon after they find the resources to implement.
I think they've only used the # suffix on CLR-based languages so far. I can't see that happening if they're looking at Rust as a better systems language.
Unfortunately not really no. &amp;#x200B; Tantivy does include a tokenizer that will make it possible to tokenize, lowercase, stem your text while keeping offset to the original str... &amp;#x200B; On the other hand... That's the only thing it will give you. spaCy and NLTK will give you PoS, named entity detection etc.
Well, it’s high time Rust have some proper NLP functionality! Tantivy at least is a starting point; tokenizing and stemming is the first stage for all of that. Maybe I’ll try and throw a (very amateur) crate together... Thanks for your response. Keep up the good work.
&gt; Oh and of course, I would implement this language and its runtime in Rust! When implementing a language with rust, would you compile to rust language source code, or some intermediate language?
It's a mix: - Clean: non-incremental. - Baseline incremental: first incremental compile, from scratch (slow). - Clean incremental: second incremental compile, with no changes (fastest possible). - Patched incremental: another incremental compile, with a small change (realistic incremental case). Some benchmarks are measured with multiple patches. You'll also see "nll" on the graphs, which was like "clean" but using the the new borrow checker ("nll" is short for "non-lexical lifetimes"). The new borrow checker is now the default so the "nll" job was turned off earlier this year.
Neat! I've been doing that manually in C# by using public static `New` functions :)
Creating a packet based bot for an old 2d MMO I used to play. Plan on having some kind of terminal interface for viewing stats, a log, and maybe a crude map view. This is my first "big" project in rust. I'd like to pull a lot of the functionality out into different crates so they could be used for more programs related to the game. https://git.sr.ht/~rleek/eobot
Well, they could just buy it if they really cared that much. This is Microsoft we're talking about after all.
From the std docs for the `Infallible` enum: &gt; Since this enum has no variant, a value of this type can never actually exist. This can be useful for generic APIs that use Result and parameterize the error type, to indicate that the result is always Ok. Why would you ever want a Result that is always Ok? Why not return the value itself?
Cool! Are you working on your kernel project publicly on GitHub by any chance?
Fascinating.
`ToOwned` says: &gt; Some types make it possible to go from borrowed to owned, usually by implementing the Clone trait. But Clone works only for going from &amp;T to T. The ToOwned trait generalizes Clone to construct owned data from any borrow of a given type. I'm confused about this wording. It first says Clone only work for &amp;T to T, but the very next sentence reads to me as the exact same thing. Is &amp;T not the same thing as "any borrow of a given type"?
If you need to implement a trait that returns a `Result` but you can't actually ever fail, for instance - the `FromStr` trait returns a `Result&lt;Self, Self::Error&gt;` (since many types can fail to be parsed from strings,) but there's no reason `String` could ever fail to be parsed, so it needs some value signifying that an `Err` for that `Result` is nonsensical.
`ToOwned`, unlike `Clone`, can go from `&amp;T1` to `T2`.
See also https://www.reddit.com/r/rust/comments/bpxg7w/momo_get_back_some_compile_time_from/. Eventually, yes, the compiler should do this sort of deduplication, and this is a stopgap measure until such a time. “Niko has plans there,” I read. I know nothing more on this matter.
Why is this trait `FromStr` and not `TryFromStr`?
Probably historical/legacy, like a lot of things from `std`.
Can you show me anything specific (not a decade old)? I don't use option. It doesn't save you anything. You are still checking a value and and throwing after you probably did that to set the option value. Also it seems to encourage a style with a lot of theirs m throw and catches littered around the code as opposed to in a few specific places. Also I don't see for it can affect inlining that much. I can understand that occasional case (even though I still don't see it), but modern exceptions on gcc and llvm don't need to keep records at run time of what to call. It is in the exception table based on the pc register. If anything I would expect inlining to be helped since the compiler has fewer branches to deal with and knows the straight line path. I've seen benchmarks that show less that a 1% error rate and exceptions basically always win out. I'll try to update the code I saw with option and see how that changes it, but I expect it to do worse. Keep your try catch blocks contained to fewer functions higher on the stack, test your inputs first, and throw rarely.
Is there any way for us to update them at this point? It will we be stuck with these names forever?
I doubt it. They could maybe alias it, but I'm not sure it's worth it for just a name change; I don't think `FromStr` is something most people implement, and it's almost never used by name (`parse()` is its common usage.) I'm not sure if they could actually fully get rid of the name even with a new edition.
To shill for a second and go off topic, if anyone is thinking of upgrading a machine and concerned about compile times, I recently began putting together a new home workstation with a Ryzen 3000 series processor and it's blazing fast for LLVM compile loads. I'm noticing significantly improved compile times for projects with a lot of dependencies, seems to scale well with core/thread count.
Take a look at the [C++/CX](https://en.wikipedia.org/wiki/C%2B%2B/CX) language projection and the features it adds. I can imagine such a variant of Rust existing at some point—I don’t expect it *will*, but I can imagine it. For reference, the C++/CX language has now been superseded by the [C++/WinRT](https://en.wikipedia.org/wiki/C%2B%2B/WinRT) library which is just C++.
I think it would need Rust 2.0 which will probably never happen.
This is awesome!
Can you speculatively run the program before it is requested, so that the 5 seconds execution "doesn't count"? Sometimes the easiest solutions are the best.
While in theory you could, this isn't where TiKV excels, and we think our friends over at etcd (also a CNCF project!) do a really great job on small scale metadata. &amp;#x200B; Regarding sled, I'm not sure!
It’s worth pointing out that the `take_mut` achieves not requiring a default value by turning a panic into an abort. This may be undesirable.
Sounds awesome. Do you have it up on GitHub or gitlab? I'm very new to rust and want to make terminal apps that display data fetched from APIs and this sounds very interesting.
Obviously the post is misplaced, but the title made me think I'd been missing a worthwhile series of posts on the state of optimization of the compiler, Firefox, Servo or something else. Or general tips on optimizing rust code.
Is there any API for me to iterate over a collections of N values rather than iterate over each value individually? I would like to, for example, have a String and instead of iterating over every char I can iterate over substrings (e.g. "helloo" -&gt; "he", "ll", "oo")
Yeah, I’ll send the link to you
Phew, do we need [https://perf.perf.rust-lang.org](https://perf.perf.rust-lang.org) now?
Can you use a Linux live USB drive?
Oh cool! That is exactly what I've been contemplating and the result I am expecting/hoping for.
Check out the Geekbench browser instead of my random Reddit shilling, they have an LLVM benchmark (iirc it's functions compiled per second). I'm measuring 550-580 in single threaded performance which seems consistent with other user uploads, I will say though if you do it, buy fast memory! I saw a 10-15% difference in benchmarks from 2400 to 3200Mhz RAM speed, but idk how significant that is with compilation in real workloads.
Haha, thanks, I will. It's just neat to see anecdotal evidence in support of an idea I've been contemplating. Thanks for the RAM tip, too.
I wrote about this a while back when the beta first started if you want a somewhat quick primer: http://mgattozzi.com/github-actions-an-introductory-look-and-first-impressions/
Sorry to reply so late. I have did some basic works on dev branch. Do you have any advice on it? :)
My code is on github. I have it private right now as frankly there is little there that doesn't come from Philipp Oppermann's blog. I used the first edition as I wanted to use multiboot. I'm doing a microkernel and I'm going to mimic the start up process of L4:Pistachio. It has a kickstart module that loads the kernel, memory manager (called sigma0 in L4 speak) and roottask. This basically allows you to write a kernel that doesn't care about how it is booted, doesn't need to understand the file system, doesn't need to understand grub module loading and doesn't even need to understand ELF. The fundamental theory behind L4 is "smaller kernel never leaves cache =&gt; faster IPC". Kickstart understands how to do all that and leaves the kernel in a running shape before vanishing. I additionally used James Munns guide on making the executable smaller as the original hello world binary was 1MB in size or something. Seems like it would be a mistake to remove all this functionality from the kernel only to lose the space savings to debug symbols. Between those three links is everything I have right now. Once I have my kickstart module loading a "Hello, world!" binary I'll probably open everything then. https://os.phil-opp.com/ https://github.com/l4ka/pistachio/tree/master/user/util/kickstart https://jamesmunns.com/blog/tinyrocket/
This probably isn't a direct answer, but here's a good series about porting a C library to Rust: https://people.gnome.org/~federico/blog/tag/librsvg.html. Admittedly, the process is going to be even harder for you because you're using C++ and Qt. I haven't looked at your code (though btw. your README screenshot link is browsing), but would it make sense for your application to split the UI and simulation logic to different process or library? That might be the easiest way to start a Rust port.
I'll give that a try, thanks. My loader code will still need to access it but honestly that will probably just be unsafe ptr conversion. I just don't want to be using unsafe once the system is loaded and don't want to write two ELF modules.
I doubt there's an issue having the kernel use UTF-8 and the user land UCS-16. Hell the JVM stores all strings as ~UTF-8 internally (there are some code points the standard insists must be represented weirdly) and then has a 16 bit char.
That's gonna be a hard one, and it's usually up to the programmers to "fix", because of how the Web works.
&gt; This decision bit the Rust team as well, they had the same issues when having to interact with the UTF-16 strings used internally in the Firefox codebase, which were "too hard to replace with UTF-8". TBH this is weird as Java already does this conversion every time you load a class. It stores all strings as UTF-8 in the constant pool and turns them into UTF-16 on initialisation.
I thought it was about this: https://blog.mozilla.org/nnethercote/2019/07/17/how-to-speed-up-the-rust-compiler-in-2019/
Some kind of Rust.NET would be interesting if the IDE supported transparent interop between Rust native assemblies and Rust.NET. Though I'm not entirely sure how the semantics in a GC environment would work.
To be fair, there's definitely still room for improvement, but it (clearly) has gotten quite a bit better.
`iter().chunks`
&gt; Besides being superior to C# in regards to better memory protections, Rust is also more popular with developers these days and might be easier to recruit for. I love Rust, but *wut*? No, Rust is definitely not easier to recruit for than C#. zdnet is confusing the "most loved" rating of SO (how do people who use it like it) with popularity (how many people are using it).
Interesting im waiting on the new zen2 threadripper release, and then decide what to do.
Very cool.
It's slow, but it's not *incredibly* slow. The first compile takes a few minutes, but from then on, it's okay. For what my anecdotes are worth, I've seen small Scala and moderate C++ applications take longer to build, for example, as well as admittedly fairly large C# applications.
Linux live doesn't allow installing, so unless it's a distro which comes with nmap and the like out of the box, it doesn't help :(
Oh dear, this site could do with some caching. Can I help with that somehow?
I'm not sure what you mean, what `nmap` the port scanner tool have to do with the Rust compiler? And you can certainly install packages on live distros, especially if you have an Internet connection. Also, on some of them you can have your home directory persisted, so you don't lose work on reboot.
Excellent. My Ryzen 9 3900X arrived today. I picked it exactly for this reason.
Somewhat of a wild card here is COM APIs. Idk how prevalent those are under the hood of windows. Conceptually, they match up very well with rust traits. Practically there's some discombobulation with respect to ABI compatibility. I've dealt with this in attempting to port a COM like API to Rust and dealing with how vtables are represented in the binary. Something that "just works" at the compiler level is certainly possible, but today it requires a hefty amount of macros and boilerplate.
I agree that the `[]` syntax is awful, but how would you write an array? * `vec[2]` can be `vec.at(2)` * `slice[1..]` can be `slice.sub(1..)` * But what would replace the plain array: `[1, 2, 3, 4]`?
I think the repo is https://github.com/rust-lang-nursery/rustc-perf
Exciting news!
Oh thanks! I just spotted the "fork me on github" link in the top right corner. Secretly kicking myself for being blind.
You'll get 30% of the solution with wasm, which allows everyone to use any language they want without insanity of transpiling (the remaining % being split between the language you'll choose and sanity of webbrowsers as a platform, there are tons of undefined behaviors there).
Yeah, that's one motivation for getting the r7 3700X. And the AM4 platform in general will let me get a 12- or 16-core chip down the line when their prices drop and second hand market availability improves. But I'm definitely against the idea of faster hardware being the best solution to software speed and I'm glad rustc and cargo are being optimized. I want to code Rust on laptops and Raspberry Pis and such too. My current laptop I don't see myself replacing soon is a dual core Ivy Bridge i5 machine with coreboot and Gentoo :)
Polymorphism. You can take a `&amp;Trait` or `Box&lt;Trait&gt;` or cetera, and use it to get dynamic dispatch or use `&lt;T: Trait&gt;` to get your code monomorphized – per actual type, one version is created. This gives you a lot of flexibility by decoupling behavior and data.
You should also check you're using buffered reads.
The best way to go from there is to find a project that suits your interest and has mentored issues and join it. https://this-week-in-rust.org has a weekly updated list of issues, and many high-profile projects (e.g. servo, Rust, Clippy) have their own lists or tags.
I haven’t found a crate yet that didn’t compile. However, for example the 0.3 version of the rand crate causes a runtime error, because it uses a stdlib function that’s not implemented. Newer versions have a feature flag to enable compatibility. Multithreading works differently in wasm (via WebWorkers) and thus doesn’t work out of the box. Dynamic allocation is not a problem. I haven’t tried wrappers for C-libs yet. In theory it’s possible, but probably doesn’t work automatically (because you need emscripten to compile C-code to wasm).
Are you sure that you want to use GTK on Windows? I tried to run an app, and that was buggy as hell. You should verify that, first.
Regarding asking others to prove something, I probably misunderstood your prior argument. My retort was more of the 'let him cast the first stone' variety. Sorry about that. &gt; If you want to avoid bugs introduced by dependencies, I'm afraid you are not significantly better off in Rust than in other languages - you have to review their code yourself. But you are better off! If you `rg unsafe` and come up empty, you can be quite sure (barring errors in std or the compiler) that you won't run into nasty hard-to-debug errors Rust guards against. You may still be left with logic errors, but those are usually comparatively easy to debug. And if you find some `unsafe`, you can look into that module and hopefully find the reasoning why a) this use of `unsafe` is sound and b) why it is here. Thus, it's enough to look at the module, you don't have to look through the whole codebase. What's more, those guarantees stay the same even if the code changes. The compiler would call us out if we (willingly or not) try to break them without `unsafe`.
This can be solved quite elegantly by creating WinString type. If someone needs optimal performance, they can use that, otherwise they can trivially convert to utf-8 strings. Not to mention most apps nowadays use utf-8 internally and convert to windows strings at api boundary. It is just simpler than compiling whole app for "windows strings".
Someone should maybe add a spinner there. I assumed it was broken.
Interesting talk which looks promising. I would love to see some example of systems UI with this. Like a gtk compatible UI or something.
I’m pushing [glsl-1.0](https://crates.io/crates/glsl/1.0.0) and [glsl-quasiquote-1.0](https://crates.io/crates/glsl-quasiquote/1.0.0) into production! :)
We already have it. Typescript is as safe as it needs to be.
This isn't a complete answer, but crates that compile code from another language tend not to.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programminggames] [Robo Instructus is out now - programming puzzle game written in rust](https://www.reddit.com/r/programminggames/comments/cf5jju/robo_instructus_is_out_now_programming_puzzle/) - [/r/rust_gamedev] [Robo Instructus is out now - programming puzzle game written in rust](https://www.reddit.com/r/rust_gamedev/comments/cdw2fs/robo_instructus_is_out_now_programming_puzzle/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Its kinda a privilege that development pays good, so you can buys those toys for home office xD
This is my solution (the best one I found): Use browsersync-cli to serve your frontend, and proxy API calls to your real backend. E.g. I have this in a batch script: start cargo watch -x "web deploy" browser-sync start --proxy "localhost:8080" --ws --serveStatic "../target/deploy" -f "../target/deploy" --no-ghost-mode --host "0.0.0.0" --port 8000 --no-open --no-notify --no-ui The first line starts a new `cmd.exe` that auto-rebuilds my wasm frontend when that changes, the second line auto-reloads the frontend when it has finished building. (I use `0.0.0.0` instead of the default localhost because I need to access my webapp from a tablet on the same wifi.) To auto-rebuild the backend, I use: cargo watch -i frontend/* -x r (ignoring changes in the `frontend` subfolder).
In my experience runtime dispatch to implementations targeting different CPU levels is quite common. For example you might have an AVX2, an SSE and a baseline implementation. Then you use CPUID to figure out which one is supported, falling back to the next slower one until you get to the baseline implementation which is supported everywhere.
The [`strum`](https://crates.io/crates/strum) crate provides an `EnumCount` derive that generates both a function and a constant giving the number of variants.
... and: Grayson Hoare.
How difficult would it be to use mrustc to compile Rust to C that can be run on the Texas Instruments Voyage 200 calculator (or more general, the TI-68k line of calculators: TI-89, TI-92+ and TI-V200, who all have the Motorola 68000 CPU)? There is a C compiler called TIGCC (and a fork called GCC4TI), which is what I used back in the day to write games for these calculators (good old times).. Would the C-output of mrustc be compatible with the m68k CPU? E.g. the `int` on that thing is 16 bit but pointers are 32-bit.
Awesome, thanks!
&gt; however this opened too many files and I'm not sure if that is best practice The cache is managed by operating system and I'd leave this kind of operations to system administrator. If that's you and you really have to do it, go through each file, open, read and close it.
&gt;For human-readable content, it may have been fine a generation ago (where the primary localization targets were other Western languages which fit into 2 bytes), but with universal localization this is no longer acceptable not only technologically, but also socially. The vast majority of human-language text in any live language fits into two bytes in UCS-2 - including Chinese characters. Specifically, everything on the everything on the [Basic Multilingual Plane](https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane). The only characters which need four bytes are those on the "astral" planes, which are either rare characters from scripts which are mostly on the BMP, or from minor historical or alternative scripts, or are from dead languages.
The default view only shows the last month and is noticeably quicker to load. That's how most people interact with the site, so it probably explains why there is no spinner. (A spinner would still be good, though.)
[Since Java 9](https://openjdk.java.net/jeps/254), the JVM has the choice of storing strings as UTF-16 or as Latin-1. There is scope for adding more encodings, but i think they have to be fixed-width (per UCS-2 code unit, that is!), to maintain constant-time indexing, so UTF-8 won't be one of them.
I'm by no means a C++ expert or a Rust expert (I'm just a lurker here :P). However, one thing that pops into my mind to consider is the build system. I've attempted to do a little scientific/numerical stuff with C++, but having to find the right libraries (e.g., Boost, BLAS, LAPACK) and integrating them with your project is a daunting task (like I said, I'm not a C++ expert, so this may be something you're comfortable doing). If you use Rust, you can probably just add most libraries you need to your \`Cargo.toml\` file and use them much more easily (there may be some C/C++ libraries that you still need to hook up manually, though, idk).
I don't have a whole lot to say, just that I'm \*super\* excited about this work! This is really cool stuff, and I'm looking forward to it maturing into something people (like me!) can start really using.
Rust2Wasm-binaries within the wasm-execution-engine: * AFAIK, no multithreading within the wasm-engine (maybe outdated info). * memory allocation yes, but permission must be granted by environment to grow memory. If you want to link against C-compilation, check both are compiling against the WebAssembly System Interface ([https://github.com/WebAssembly/WASI](https://github.com/WebAssembly/WASI)), and your runtime-environment must provide WASI-support. * 64bit integer ops yes (emscripten did not support native 64bit ints one year ago). * ffi via indirect call table, those functions must be provided via table of runtime environment * no zero-copy from environment into the wasm-engine, function parameters or return values must be copied between environment and the linear memory of wasm-instance. * Check the string encodings of your environment and wasm-binary match to each other * etc.
Yes async blocks are part of the normal async/await proposal.
I'm not sure about the book, but you can read console input with https://doc.rust-lang.org/std/io/index.html#standard-input-and-output and `from_str` to convert a string to a number: https://doc.rust-lang.org/std/str/trait.FromStr.html#tymethod.from_str.
Reading through the documentation and converting a python script to rust. Nice mixture of theory and practical. Progress is slow but steady.
That was an oily pun.
Is anyone measuring and tracking resource usage (CPU and peak memory) of, let's say, the linker when final binary executables/dynlibs are built? My workflow nowadays is pretty much: cargo check # 2-6 times cargo build --release Debug builds are too slow (at runtime) to the point where they are practically useless for my use-cases. One does need them from time to time of course. But they are not involved at all in my daily workflow. I wrote all that to mention the obvious, the Rust side of things (pre-codegen) is fast enough already (thanks). It's when you get to the LLVM/binutils side where the slowness becomes bothersome.
Hmm? You sure? I've never done OSS contributions and I have no idea how it works. Reading other people's code always feels like a labyrinth.
Maybe it helps to begin with type conversions first. Often you need to parse strings into numerals or vice versa. Then understand structs and implementation of structs. Then, if you aim to write a more flexible conversion tool you should take a look at how to implement traits and also learn how to use macros. I did a temperature conversion tool using macros and traits only. In combination I think that's very powerful. My approach was to create a general \`\`\`struct Temperature\`\`\`, that implements functionality from traits: 1. to parse from a string input (command line), 2. to be able to use \`\`\`Display\`\`\`\`(must be implemented for structs, otherwise only the debug output works). 3. finally implementing the \`\`\`From\`\`\` trait, using macros, where the two temperature units and the conversion formula is passed to the macro which implements the trait (instead of doing it manually for each temperature unit) It requires some knowledge of the language. Maybe put your conversion tool on github and amend the repo as you advance with rust. &amp;#x200B; This is my temperature project [https://github.com/aspera-non-spernit/temperature/tree/master/src](https://github.com/aspera-non-spernit/temperature/tree/master/src)
The part where he actually talks about his project starts at 14:37
Indeed, the 3900X, a 12 core 24 thread beast is only 500 dollars.
I was playing on a server called "7/17 Rusty Newcomers | Noob Friendly | Vanilla | Monthly Wipe" since it wiped. It's a community, vanilla server and I got banned from it by the supposed owner (Admin Man) because I was a nuisance to him &amp; his friends. &amp;#x200B; After killing two of his friends and looting them, I decided to run away, but the admin of the server used noclip and an L96 to kill me. Here's a picture of the admin floating in the air with an L9, that's how he killed me while I was completely obstructed from him, behind a rock as you can see at the very end of the video. [https://imgur.com/a/CEyx93C](https://imgur.com/a/CEyx93C)
If you're downvoting this, then you're enabling people like the admin of the server in the video.
Wrong subreddit. https://www.reddit.com/r/playrust/
I'm fucking retarded
It's okay, it happens a lot
I only recently realized that AMD is kicking ass these days, and haven't had the chance to look at their lineup closely. My workstations are generally used, dual Xeons, and tons of ram (128G or more). Is there an AMD equivalent (two sockets, server workload oriented)?
Simplest way to warm the cache is by reading the files. Some things to try for increasing read throughout of many files: - lz4 or zstd compression - changing the file size - crossbeam's work stealing deque for distributing read jobs to threads - file system tuning (which fs to use and its parameters)
RAM speed = CCX connection speed. If the core packages need to talk to each other = faster RAM == faster CPU
That should be the Epic line afaik.
Yeah. It looks like I need a broader understanding of Rust to do something of this magnitude. Thank you. It can really help to know how much one doesn't know. ;)
I'll chime in with another recommendation for GStreamer. I've used it and the Rust bindings to implement a similar video streaming application. You may be able to prototype the system without having to write any extra code: the [`gst-launch-1.0`](https://gstreamer.freedesktop.org/documentation/tools/gst-launch.html?gi-language=c) command lets you build a pipeline on the command line, and there are plugins for nearly everything (including a [TCP server](https://gstreamer.freedesktop.org/documentation/tcp/tcpserversink.html?gi-language=c#tcpserversink)).
Interestingly reapfrog doesn't use POSIX_FADV_WILLNEED, just POSIX_FADV_SEQUENTIAL. And beware that posix_fadvise may not be present everywhere. It looks to be present in FreeBSD and NetBSD, but not OpenBSD or OSX.
[Yes it does](https://github.com/the8472/reapfrog/blob/bf96ed2de9f636e3d6c6e3ffacb8b5db38ce255a/src/lib.rs#L151). It also has optional support for `POSIX_FADV_DONTNEED`.
learning never ends. You'll always find something you don't know. The language develops and adds new features or your focus of programming changes. When people write no_std libraries that looks like a complete new world to me. Although written in the same language. Even in "standard" rust, I never touched ```unsafe``` and don't know why cargo tells me I should add ```dyn``` because something is now deprecated. We all go through this. It speaks for you, that you know your limits (see Dunning-Kruger-Effect) :) Rust took a while to understand, especially, if you haven't used a language like C before and also because of it's unique borrowing approach. The borrow checker may drive you nuts at times. Maybe that's the first thing you need to understand before anything else. It's also true for me that rust is the only language I learned outside a school / uni / course / class environment, that I feel now comfortable with.
The idiomatic way to use `FromStr` is actually to use `parse` instead of directly using `from_str`: `let number: u32 = s.parse()?;`.
Fstar is in the vein of other ML-based software verification tools (not surprising that INRIA is a major contributor. I also believe MSR poached a good number of European PL researchers). It's an extremely powerful tool, but I don't think it's a reasonable one to use for large scale development. The same way that nobody, to my knowledge, writes large software in Coq or ACL-2.
If the disk is an SSD, the higher your queue depth, the better the overall throughput (in general). So you may benefit from parallelizing the work instead of making only one call at a time.
The reports of extreme compile times are either overblown or outdated. It’s really not that much slower than C++ in practice, I’ve found.
&gt; But what would replace the plain array: [1, 2, 3, 4]? I'd say a standard vararg function would be fine: array(1, 2, 3, 4) If it has to be more Rust-like (no varargs + random abbreviations) you could also do arr!(1, 2, 3, 4) That syntax has been shown to work perfectly well for `vec`s. &gt; The arrow would be consistent with the fn notation Actually I really dislike this. Many languages try to make lambdas and function definition look "similar", but I don't know of a single language that made them actually consistent: - In functions the **result type** appears after the `-&gt;` - In lambdas the **lambda** appears after the `-&gt;` I'd probably just get rid of `-&gt;` for functions altogether, it's a bit silly to have different syntax for `let`s and `fun`s. Let's make it consistent and use `:`, it's also way easier to read.
Just go for it! I recently started playing around with Rust on my cheap laptop (the CPU is a decent i5, but RAM and HDD are "average at best"). After the first compile, it is not so much different from building C++ code. Also, 95% of the times I don't need to actually compile and run, I just `cargo check`, which is quite fast, IMHO.
If you're used to C++, then C++ will be more productive for you. Rust is not a huge and complex language like C++, but some features like ownership, lifetimes, and traits do have a bit of a learning curve. Under the hood, your code is going to use the same linear algebra libraries anyway. There are crates with bindings for the important libraries, and you're not required to pre-install these libraries on your system. Rust's cargo build system is so so much better than anything you might know from C++. It's also a lot less flexible, but that's OK most of the time. Package management is easy, cross-compilation is easy. In most cases you're going to statically link everything into a single binary, which makes using your Rust software straightforward. Integrating native code with Java is always a bit icky, but you [wouldn't](https://github.com/seanjensengrey/rust-jna-example) [be](https://github.com/drrb/java-rust-example) the first to combine Java with Rust. Just like C++, Rust allows you to [write extern "C" functions](https://doc.rust-lang.org/nomicon/ffi.html#calling-rust-code-from-c). Similar to C++, Rust comes with a fairly minimal standard library. But since you can install additional crates very easily, Rust might still be more productive – even accounting for unfamiliarity with the language and for debugging obscure lifetime errors. I think using Rust is entirely feasible in your case, but not an automatic sell.
Mine just went up 300% :( sccache stopped working and my dependency crates are rebuilding endlessly.
Shout out to the cunts I worked with there that mocked me for being into it years ago. "You could never build a usable language with that safety. That's stupid. Everything has drawbacks." But then again, they/he also mocked me for being into Docker and Kube and we all know how that story played out. Fuck you Microsoft, fuck you til my dying breath.
&gt;But I want to explicitly care about logical types (integer vs string), and implicitly about physical types (i32 vs i64). It would be pretty interesting to bring the madness of string, number, bool and even object to RustScript. Like, just use dyn Num when you don't care and let the compiler choose it, specially because you can specify when needed. One thing that's very polemic and I hate but it may be cool for a RustScript is implicit Traits, implement the same methods and the trait is added (lazy addition to avoid conflicts).
You seem very certain of something that doesn't yet exist. &gt; Rust is already riddled with far too many string types, all of which have a hard-coded assumption that they're arrays of bytes. All strings **are** bytes. That's how strings work. What matters is what encoding those strings are that determines what bytes encode the string. The documentation for `as_bytes()` says that it returns the underlying bytes. It makes no mention of what encoding they are in other than &gt; The inverse of this method is from_utf8. It seems within the realm of possibility to me that this could be adjusted if UTF-16 strings were to be first class Rust strings. From your other comment: &gt; There's zero chance of the NT kernel being updated to use UTF-8 internally. It would break binary compatibility with literally millions of third-party drivers. Those drivers hook into the kernel at well documented points. There's no technical reason Microsoft couldn't decide to switch the internal NT kernel representation of strings and convert at API boundaries. Windows is little more than a huge nested pile of compatibility layers. Microsoft has already decided that compatibility is more important to them than getting every last bit of performance. After the security disaster that was Windows XP pre-SP2, they've also taken a much stronger stance with security. Given their own admission about how many of their issues are memory safety related, it seems extremely plausible to me that they're going to adopt Rust in the NT kernel in some way UTF-8/UTF-16 string conversions be damned.
The PRC mandates support for certain characters outside of the BMP for software. Consider also that tons of new emoji are outside of the BMP and have become wildly popular in recent years.
Try this: [https://www.reddit.com/r/rust/comments/bzkhmt/how\_to\_use\_gtkrs\_on\_windows\_using\_the\_msvc/](https://www.reddit.com/r/rust/comments/bzkhmt/how_to_use_gtkrs_on_windows_using_the_msvc/) &amp;#x200B; I compiled cairo-rs on MSVC toolchain once, I was successful after copying the .lib files to my project's root folder.
Compile times have always been comparable to most other AOT languages. People are just spoilt by bytecode languages and Go, which doesn't optimise anywhere near as aggressively. It strongly depends on what features you're using. Heavy use of generics and macros (especially the `include*!()` family with large files) can slow things way down.
I'm sorry I have to ask this, but what exactly about this code is undefined behaviour: let date = DateServiceInner::new() let my_ref = date.get_ref(); date.reset() `my_ref` is a reference to date. and `date` is being changed even though there's a reference pointing to it? But isn't that still valid Rust?
ITT terrible MS hot takes. Rust makes perfect sense as a replacement for C/C++. Expect this to become a trend as Rust becomes much more widely adopted. We use it for safety, utility and speed. If you want a systems programming language which offers the above you have few choices. One of them is amazing and proven to work in production and at scale: Rust. It would not surprise me to see Rust supplant C as the go-to systems programming language over the next 5 years.
Thanks for the kind words! It's early days but I am also very excited. We're making steady progress on the entire stack. Some people might find it rewarding to work on it with us; I think we're growing a nice community around it as well as writing good code.
The good news is that GCC already has an M68k backend, but the bad news is that the code generation is so terrible that no human actually trying could write worse code. Still, it should work.
This looks like a runtime feature. I'm referring to the class file format. https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.7
The standard library cannot change between editions.
Slices are built into the language, and aren't part of the standard library. You should be able to use them here.
You can do everything with GStreamer with "pngenc" followed by "multifilesink".
Feels like maybe you want us to give you permission to use Rust. Permission granted!
Yes, that's exactly it :) Please give me good reasons to build a case for Rust!
Quote of the week?
If full-stack Rust is not a hard requirement you could try `ffmpeg`. The library itself is well-known and quite robust, and the [`ffmpeg-sys`](https://github.com/meh/rust-ffmpeg-sys) crate also works but you'd want to evalute its safety yourself. You also might want to point at the one more recent git commit as it has not seen a release in a while. The current state on `master` branch works for what I have used it for, which is encoding a stream of images into an mp4. Be prepared that the conversion process (from mp4 frame format to raw image, and then to png) will be somewhat slow if done without GPU support and at full png compression. You'd need to research if ffmpeg can already help you with that, else compute shaders from the Vulkan graphics API could work but it's going to be a fair bit of code.
Swift, a language that primarily exists to be the new OS interface language for Apple’s UTF-16-based OSes, recently changed their string type to be exclusively utf8 — and it improved performance. Firefox, one of the largest and most pervasive users of rust, needs to work in utf16 because it’s part of the web platform, and we have coped with it fine. The presence of many string types with different usecases in a large system is not a new situation.
When people start grouping C and C++ under this mythical C/C++ language, I really start to doubt the validity of their arguments. C and C++ are very different languages, there is no such thing as C/C++.
No; if something is modified then nothing else can be holding a reference to it at the time. The reason it compiles is some unsafe stuff under the hood in Actix.
Coming from a Java/Kotlin background, one of my favorite features of Kotlin are the [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html). They let you invoke a closure on any particular value inline. These could be written more verbosely as a named function with that argument as a parameter. I know in rust it's typically idiomatic to just make stuff a local stack-owned variable with `let` but sometimes that just feels verbose. For example, consider FFI with a `Box&lt;T&gt;`. If I want to pass a mutable pointer to an FFI function, which might for instance set some variables in `T` I need several variables: One for the pointer, one for the resultant value of the FFI function, and another to hold the `Box::from_raw` so `T` is properly freed. With a scope function you could simply return a tuple containing the boxed pointer and the result of the FFI directly. I'm sure I'm nitpicking here, but it could be nice. Another nice to have would be some sort of sugar for "call this closure for with a raw pointer to `T` but retain ownership".
Isn't this because &amp;str is a slice whereas &amp;String is a borrowed String and are therefore explicitly different types? The thing that really boggles my mind is `AsRef`. The documentation provides no clarity to me on that trait.
`get_ref()` returns/returned a reference to an `Option`. `reset()` unsafely obtains a *mutable* reference to the same `Option`. Having more than one alive reference to the same object, with at least one being mutable, shall not happen in safe Rust, so the code is UB.
Ah OK. Then I was wrong. I though using get_ref() would be similar/the same as just doing &amp;date.
Dammit stop. I just built a way over my needs a year ago and I'm struggling so hard to resist the siren song of the Ryzen 3000 series.
This is the issue with it; the code seems completely fine. Nobody would think twice about it unless they know how it’s written under the hood. If things start going wrong, it’s going to be difficult to trace back here (unless you have a mental model of the entire code). If it were marked unsafe, it would be quite obvious this would be a place to look.
Ahhhh OK. Got it. Thanks so much for your explanation! This just confirms that/why I should not touch unsafe for my Rust projects! :-)
If someone wants to use unsafe in their code it is their code.
Do you use multi-threading/concurrency patterns in your "numerical engines" and have you ever had data races/race conditions in those? If so, Rust comes to the rescue. Also, the build system is really nice and painless.
Hmmm... makes sense I suppose. I was hunting for sort of a solution to if this was the idiomatic way to do this.
The 2000 series is getting really cheap too for ramen devs. AMD is a MVP!
And it's also an invariant that the user of the library must be able to rely on. For instance, consider this code: let date = DateServiceInner::new() let my_ref = date.get_ref()?; // Get the contained object or bail if None date.reset(); // In safe Rust this can't do anything to *my_ref because we hold a reference to it do_stuff(*my_ref); // Here we must be able to assume that *my_ref is still a valid object, but it isn't!
unfortunately. i don't understand the docs. to difficult to get started.
Probably just all unsafe because 1) the low level code has to be unsafe 2) it's a fairly small example. A more complicated project should try to wrap the low level details in safe functions (to whatever extent that is possible).
'I know enough lingo to sound smart and I know Rust is hip rn'
In this case people = c++ programmers. C programmers are also annoyed by this.
And even if the compiler did nothing, the *user* is allowed to assume that the `reset` call cannot modify `*my_ref` in any way, so if it was `Some(a)` before `reset`, it must still be `Some(a)`, but here it isn't! It has been sneakily been changed to `None` and `a` doesn't exist anymore.
He probably has a think thank or something like that giving him important points and advisement. Even if flawed it makes his life way easier to just have specialists make the quesitons.
I don't really have time to explain the why, I'll leave that up to somebody else. If you just need a solution do \`p.iter().find(|&amp;x| x.id == 2).is\_some()\`
Nice work! Thanks for the crates :) &gt; Also, I would love to have a native Rust GLSL -&gt; SPIR-V transpiler written in `glsl`. See the transpiler module for further information. The current SPIR-V transpiler uses `shaderc`, which is a Rust binding to the C library. Take a look at this issue, which currently discusses exactly this: https://github.com/rust-gamedev/wg/issues/23
Also, if you need to be doing membership tests and ID lookups, you probably want a hashmap.
Millions thanks! I will contribute to that issue as I can!
In this case you can read C/C++ as "C and C++". Both languages are affected by this issue in the same way, right?
No, writing to a raw pointer does not implicitly create a reference. The original code was well-defined. However, `write` is indeed better as writing to raw pointers with assignment is a footgun. Somewhere on my list is an item to propose an RFC to deprecate that operation for non-`Copy` types to remove the footgun... but I'd be very happy if someone else took over pushing for that. ;)
`find` gives you either `Some(x)` where `x` is the value that matches the predicate or `None` if there are no values that do. To convert that into a boolean, you can use `is_some` on that `Option` to check which it is.
Actually I think we should warn against writes into raw pointers for non-`Copy` types. It's a dangerous footgun. If you *really* want to drop first, you should make that explicit: ```rust ptr.drop_in_place(); ptr.write(new_val); ``` I think `*ptr = new_val` (where `ptr` is a raw pointer) should be treated as a code smell.
Yeah, I'd just prefer if we could avoid raw pointer casts. Thy are more dangerous than `transmute` because they do all the same things (re-interpreting data at a different type) with no clear syntactic signal and not even checks for getting the sizes right. With const generics, I think we can have reasonable APIs for uninitialized slices/arrays, but it'll take a bit.
Yeah, without const generics we cannot write such functions. Similar operations for `Box` are [going to land soon](https://github.com/rust-lang/rust/pull/62451); for arrays and slices we'll be there eventually.
Use `MaybeUninit::as_mut_ptr` and construct a slice with `from_raw_parts`.
Indeed I think having an array/slice of `MaybeUninit` works better than a `MaybeUninit` of an array/slice. You get safe (bounds-checked) indexing and things like that.
But there is some issue after implementing on my actual code which i forgot to mentioned in the playground code previously. [this is the real problem](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=91f03ce0731bd22c6bff66f76a03996c) i have Arc&lt;Mutex&lt;Vec&lt;Peer&gt;&gt;&gt; type and the iter() doesn't work
But there is some issue after implementing on my actual code which i forgot to mentioned in the playground code previously. [this is the real problem](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=91f03ce0731bd22c6bff66f76a03996c) i have Arc&lt;Mutex&lt;Vec&lt;Peer&gt;&gt;&gt; type and the iter() doesn't work
i've updated my playground code , and other problem is about the Arc Mutex that i've assigned. do you have any idea?
"read"/"use" is unfortunately a hard-to-pin-down concept. :/ For example, we tell LLVM for every `bool` that crosses a function boundary that it is "valid" (either true or false, nothing else). This is valuable information for LLVM because it means it can move an `if b` out of the loop -- without "validity", the `b` might be bad and if the loop didn't execute ever, moving it out would cause UB! So, to enable optimizations lake that, *obtaining* an invalid `bool` is already UB, even if you never use it.
Very good questions, sir. Now the first thing I want to say is that some people in C++ community are aware of the problems with UB. Therefore there is UB-sanitizer in clang and probably other similar projects exist. The thing about fields which we cannot mark as unsafe is in some way mentioned in this blog post: [https://smallcultfollowing.com/babysteps/blog/2016/05/23/unsafe-abstractions/](https://smallcultfollowing.com/babysteps/blog/2016/05/23/unsafe-abstractions/) (I think) I remember there was some blog post discussing possibilities to resolve this situation but I was unable to find it. It was not easy though. &amp;#x200B; Maybe it is impossible to proof correctness of unsafe code by static analyses but we can at least detect UB at run-time which is something that MIRI is trying to accomplish. In a way it is Rust's equivalent of UB-sanitizer. It has been in the works from 2017: [https://smallcultfollowing.com/babysteps/blog/2017/01/22/assigning-blame-to-unsafe-code/](https://smallcultfollowing.com/babysteps/blog/2017/01/22/assigning-blame-to-unsafe-code/)
Yes I am sure. That's where the mentor steps in, showing you around and helping you navigate the codebase. I have been both mentee and mentor and can attest that it works beautifully.
If we had the ability to prove that code inside of unsafe blocks was correct, the compiler wouldn't require it to be inside an unsafe block. The borrow checker has been improved greatly in what it understands over the years. The idea shouldn't be to check unsafe code, the idea should be to not need unsafe code anymore because the borrow checker is capable enough to understand all the complex edge cases that we currently need unsafe for.
You can't call methods of `T` on an `Arc&lt;Mutex&lt;T&gt;&gt;` - `Arc&lt;A&gt;` derefs to `A`, which in your case is `Mutex&lt;T&gt;`. You need to `.lock()` the mutex to get a `LockResult&lt;MutexGuard&lt;T&gt;&gt;`, handle the `LockResult` (since it may fail) to get a `MutexGuard&lt;T&gt;`, and then you can call methods of `T` on that, since it derefs to `T`.
With a `Mutex`, you can do [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=07dab3dc076e8e12fbb310e557a7425f). This is the same as u/K900_ suggested.
In that case you're looking at something like this: `p.lock().unwrap().iter().find(|&amp;x| x.id == 2).is_some()`
The objection to this phrase always mystifies me. No one believes that there is a language called "C/C++", but several people do use the phrase as a convenient shorthand when referring to characteristics shared by the two languages. Since they are closely related, there are several such characteristics.
Strictly speaking, it's because `str` implements `ToOwned&lt;String&gt;`, but `&amp;str` doesn't implement `Clone&lt;String&gt;` (due to `Clone` signature requiring &amp;T -&gt; T conversion, and `str` being not the same as `String`). The semantics of those types is not relevant here, if I understand you correctly, because type system just forbids this implementation.
Crates which depend on file IO cannot build for wasm, such as slog (which depends on dir for file logging, which depends on stdlib file IO)
What you've called "safe `unsafe`" and "unsafe `unsafe`" I think is somewhat commonly referred to as "sound" and "unsound" code. An _API_ is _sound_ if you cannot use it from safe code outside the "unsafe barrier" to cause Undefined Behavior (or otherwise break invariants), and _unsound_ if you can. It'd be correct to replace the `unsafe` keyword with `safe`; you're not supposed to say "unsafety lurks here" but "I've proven this correct".
And no hearts run any risk of getting bled with Rust, either!
Working on a CHIP-8 emulator to learn rust. Right now I need to make the display work and I'm trying to decide on which terminal crate to use. Work's keeping me busy though.
[How about tap?](https://docs.rs/tap/0.4.0/tap/)
time will tell. i'll believe this once sometimes gives this library some serious fuzzing, instead of looking at benchmarks. there was this one company who sacrificed security for performance, and now they are paying the price.
As for `AsRef`: &gt; Used to do a cheap reference-to-reference conversion. "Cheap" is a key here. Unlike `Clone` or `ToOwned`, `AsRef` should never do any allocation or bulk data copying, it just converts a reference &amp;T1 of an object to another reference &amp;T2 of the same object, conserving the borrowing rules.
Thanks. I was searching for splice rust and got the page below as the top link which implied it was standard. https://doc.rust-lang.org/std/slice/index.html
I like rust but this &gt;Birr-Pixton's Rustls-OpenSSL performance tests come to support a rising notion that Rust, overall, is now generally faster than C++. Being based off the benchmarks game is just dumb And this &gt;While the Rust project was ridiculed in the beginning, it is now being adopted at a rapid pace Was never true, people have treated rust with a massive air of scepticism that crops up with any new language, particularly one with lofty goals, but I don't think that it was ever ridiculed The reality is much more bland but much more important: rust was an unstable immature language with bad tooling (its a new language, this isn't a criticism!). It's been gradually being improved to the point where its feasible for some people to use it on various projects. Its not some grand turnaround in opinion, but an incredibly important consequence of how the language is being developed
&gt; I don't think that it was ever ridiculed Well there is r/rustjerk, though I don't know much time anyone's CTO spends reading that :)
&gt; It'd be correct to replace the unsafe keyword with safe; you're not supposed to say "unsafety lurks here" but "I've proven this correct". Not quite. Remember, there are both `unsafe` functions and `unsafe` blocks. Maybe require a `safe` or `audited` block to call an `unsafe` function.
...as long as it's made clear to potential users what standard they're adhering to, so that informed decisions can be made and, if their project becomes popular and then is discovered to be insecure, it doesn't harm the reputation of the Rust ecosystem as a whole.
If you're just going to call `.is_some()` then you should call `.any()` instead of `.find()`.
&gt; time will tell. i'll believe this once sometimes gives this library some serious fuzzing, instead of looking at performance benchmarks alone. Completely agree here. For a library as important as a TLS implementation, it absolutely should be vetted and tested thoroughly.
I'm no crypto person which is why I'm wondering if this is really a match between equals in terms of timing attacks etc and all the stuff a memory safe language doesn't protect against?
It's a mistake to assume that anything written in Rust is automatically secure. You're still gonna have bugs, and every now and then you're gonna have a bug with security implications.
Clarified, thanks!
Somewhat besides the point, there was a super interesting chart from Microsoft that 3/4s of cves were memory unsafety This library might suffer from all kinds of problems but just by virtue of the language it should be massively more secure right from the get go
&gt; bytecode languages and Go, which doesn't optimise anywhere near as aggressively. I think it's more accurate to say that bytecode languages' optimization, if they have it, is spread out over time. The JVM is very optimized, it just doesn't do it up front.
Are there any more big improvements coming to compile time? If my compile time cut in half again that'd be cool, but it would be great if it were like, idk, 1% of the current runtime.
This. Emoji are a great way to discover that tools like `git gui` break in surprising ways when you try to commit unit tests using non-BMP characters in string literals. (Unless you use unicode escape sequences instead of the literal characters.)
And I weep because of it.
Lots of good info here, thanks!
&gt; Can you show me anything specific (not a decade old)? Unfortunately no, the code is proprietary. I can however point you to Herb Sutter's [proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf), specifically page 31: &gt;&gt; **Enabling broad `noexcept` would improve efficiency and correctness(and try-expression, see §4.5.1).** Being able to mark many standard library and user functions as `noexcept` has two major benefits: (a) Better code generation, because the compiler does not have to generate any error handling data or logic, whether the heavier-weight overhead of today’s dynamic exceptions or the lightweight if-error-goto-handler of this proposal. [...] (In the future, it opens the door to entertaining default `noexcept`. Using `noexcept` more pervasively today also opens the door wider to entertaining a future C++ where `noexcept` is the default, which would enable broad improvements to optimization and code robustness.) Which notes that removing exceptions would enable better code generation. &gt; Also I don't see for it can affect inlining that much. I can understand that occasional case (even though I still don't see it), but modern exceptions on gcc and llvm don't need to keep records at run time of what to call. It is in the exception table based on the pc register. First of all, let's look at the assembly, [using godbolt](https://godbolt.org/z/yL3JZP): int foo() { throw 1; } int bar() { return 1; } Lead to the following assembly: foo(): push rbp mov rbp, rsp mov edi, 4 call __cxa_allocate_exception mov DWORD PTR [rax], 1 mov edx, 0 mov esi, OFFSET FLAT:_ZTIi mov rdi, rax call __cxa_throw bar(): push rbp mov rbp, rsp mov eax, 1 pop rbp ret As you can see, throwing an exception requires two function calls that are not inlined, even with -O3. I expect that the mere presence of the function calls has negative impacts on inlining heuristics. &gt; If anything I would expect inlining to be helped since the compiler has fewer branches to deal with and knows the straight line path. That would have been my expectation too; it didn't happen. &gt; Keep your try catch blocks contained to fewer functions higher on the stack, test your inputs first, and throw rarely. Agreed. I am for a single top-level catch handler which just logs and stops or moves on as appropriate. Unfortunately, I am very much talking about the happy path here, where no exception occurs and yet the performance is degraded by the mere possibility of them occurring.
well for your use-case i can recommend [rust-swig](https://github.com/Dushistov/rust_swig) for easy java integration, [nalgebra](https://github.com/rustsim/nalgebra) for linear algebra in our ecosystem that can come handy. Cargo is a really nice package manager and libraries like [rayon](https://github.com/rayon-rs/rayon) can help you a lot if u want to parallelize the computations for better performance. If that's not enough, i am pretty sure the code written will be much easier to maintain than C++, and did i mention how easy to refactor. P.S. If it compiles it runs usually, need i say more?
A compiler of developers? How does that work?
OpenSSL though implements intentional slow downs at several points to avoid timing attacks. &amp;#x200B; Does the rust lib do the same?
The great advantage that Rust brings is to be able to prove things very quickly using local information, by having a certain set of rules that the borrow checker follows. That doesn't mean that there aren't other things that could be proved, just that they can't be done quickly or conveniently. For example the formal verification of kernels and so on. So this is why I suggested that this could be done with separate tools and proofs cached in separate files to the source. Effectively when you're annotating your code with lifetimes, you're describing a proof to the compiler. But I think probably we wouldn't want all the source weighed down with more and more annotations.
*Epyc
Rust is certainly ridiculed in a bunch of places around the web. That's just how things go.
rustls uses ring, which is based off of boringssl, which is a fork of openssl so they not only are a match, they have common ancestor code