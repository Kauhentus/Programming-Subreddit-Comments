410 is more appropriate if you want to be explicit that it's not just a temporary thing. This should be orthogonal to making the error page useful for links that aren't updated.
What is the reason the panic handler is called (I don’t know TI-Nspire, but on ARM for example there are flags set on such an occurrence, that identify the error)? Could it have something to do with an unaligned memory access anywhere?
If they didn’t specify it had to be readable JS code that’s on them...
So does that make pub(crate) and pub(in crate) the same?
I have an associated constant that works in a `let` context but not in a `const` context. I'll live with let for now, why does `const` not work? https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e75b6476af8ac0579480db7f2b76809b trait Foo { const ID: i32; } impl Foo for i32 { const ID: i32 = 1; } fn f&lt;T: Foo&gt;(t: T) { const NUM: i32 = T::ID; // compile error E0401 dbg!(NUM); // dbg!(T::ID); // this works fine, but in my use case this is a long ugly path // let NUM: i32 = T::ID; // also works, but runtime overhead? // dbg!(NUM); } fn main() { let x:i32 = 123; f(x); } 
[removed]
I guess so
My panic handler isn’t even called at all - it just acts as if you were to hit the reset button on the back of the calculator, and displays a black screen and then boots up again. 
[Because items declared inside functions cannot refer to the type parameters of the enclosing function.](https://internals.rust-lang.org/t/cant-use-type-parameters-from-outer-function-why-not/3156)
But `let NUM: i32 = T::ID;` is also declared inside the function and that works. Why is `const` different?
`let` is a statement, `const` is an item.`fn`, `static`, `struct`, `enum`, `type`, `trait`, and `impl` are also items, and wouldn't be able to use `T` just like `const`.
I have worked with Neon and completely agree about it being superior. However i just thought that there is value in seeing how it is done the "hard" way. 
Within each submodule, you can write `use super::faa;`, and it will do what you want. If you want to go nuts with it, there's `use super::*;`.
A huge improvement would be just linking to the correct page in the 2.0 book.
I can see it without any missing images. I guess you've tried a full reload of the website otherwise I guess it may be something related to your internet connection 
Probably because of some dynamically linked libs. Once you build it. Do `ldd [program` and it'll show needed libraries. I think you can build fully static by using the musl toolchain.
I think the most important thing right now would be to have a good abstraction for integrating it into an application, such as a GTK UI.
Thanks for writing this up! (co-author of the lambda runtime) I've been noodling with a setup that lets you use [the CDK](https://github.com/awslabs/aws-cdk/) (kinda similar to [Pulumi](https://www.pulumi.com/about/) where you can do CI/CD deployments.
I agree that a redirect would be the best bet. I do feel OP's pain on this one, as I've often googled for answers and it's always edition 1 of the book that comes up, which brings you a page linking you to the first page of the newest edition book where you then have to search through the book to find what you're looking for
That was my plan after 0.6. In 0.6 I want to clean up error story (our localization model has a very strong fallback chain mechanism, which means a lot of things will return some value and optionally many errors) before I start looking for integration into UIs and work on convenience macros. But I think 0.5 is ready enough to start experimenting! :)
What if we make a template PR making one fix and _link to it_ from the "this is the 1.0 version" of the book page? I feel like more than half the battle is actually finding the right repo to make a PR to and where to change it.
&gt;I don’t really know anything on the area, but I’d guess having only pure functions requires immutability, which requires a lot of memory copying around, which is not suitable to a systems programming language. right that's my take, its useful to modify some things in-place..at least rust makes it crystal clear what \*is\* and \*isn't\* being modified (vs const not being transitive and so on in c++..)
Makes sense, thanks. :)
Maybe you could show the assembly line where this crashes ?
It should be ok, but this is what stuff like [tokio\_codec](https://tokio-rs.github.io/tokio/tokio_codec/index.html) is made for. pub fn filepath_to_stream&lt;P: AsRef&lt;Path&gt;+Send+'static&gt;( filepath: P ) -&gt; impl Stream&lt;Item=(f64, f64), Error=Error&gt; { File::open(filepath) .map(|file| { let codec = LinesCodec::new(); codec.framed(file) }) .flatten_stream() .map(|line| { (line.len() as f64, line.len() as f64) }) }
Thanks for your replies everyone. I have for now decided that this is not my first rust project. Hopefully I'll be able to implement something soon enough.
I don't have any problem with distributing the source code, but thank you for pointing it out!
Thank you for your experience, i will probably try another gui library if this is the situation. Conrod didn't need anything installed to function, but was much harder to use
What nightly are you running? Looking at the code and it's using some lang items that haven't been relevant in a while.
Thank you very much, i will try this out in the next few days. It's not what i had in mind, but it's a valid alternative
I’m using 1.34.0, build from yesterday IIRC
Do keep us updated please. 
I tried Azul, a gui library based on webrender, which would pretty much be the rust equivalent of electron, but the ram consumption was reeeaaaally high, 50mb for an empty application, and 100mb for a counter. I would prefer something more lightweight, but it's definitely an option i'm considering
Sure, I’d be open to that too.
Ah okay. The old lang items I found were in [this code](https://github.com/lights0123/example-nspire/blob/master/hello-world/runtime.rs) so I was surprised that things were compiling at all, but after digging around some more I saw [this code](https://github.com/lights0123/ndless-handler/blob/master/src/lib.rs) which looks better.
Damn, that matches my profile amazingly well. A shame it's not in Copenhagen, I don't like working from home.
/r/rustservers
This is the subreddit for the Rust programming language. You're looking for /r/playrust or /r/playrustservers
Looks pretty good so far! `::std::fmt::Display::fmt(inner, f)` in [this line](https://github.com/aspera-non-spernit/temperature/blob/40486ba0339c302cf341a8bc0c79f042fd1aa857/src/error.rs#L21) can be shortened to `inner.fmt(f)`. And with match-ergonomics, you neither need deref `self` in `match` nor use `ref` in the match arm (see my playground link). The macro `impl_from_temp` is pretty long and matches on the string representation of the types which is not optimal but okay since it might get optimized away. In my playground, I use a macro in combination with closures. It's a tad shorter. I assume the compiler inlines the closures (which don't capture anything). [My playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d04854a10a458c149f66e4b1a9d289c6).
/r/playrust
Yeah. It doesn’t compile without the first file, so I just left it there. 
That's weird. Not sure why a file that's not even referenced would affect compilation.
This is an attempt to implement the Redux approach in Rust. The documentation and examples should provide information on how it works. &amp;#x200B; As this is my first library crate, I would love to get some feedback.
You could use a redirect for non-search engine user-agents (google uses a distinctive user-agent, I assume other search engines do the same). Then for search engine user-agents put in a a robots.txt file that does not redirect and says "do not index this site". Another options would be for someone in the Mozilla organization to talk to google and have them fix it there, I am sure there are people at Mozilla that have suitable contacts.
Wow. that's cool, and for this purpose the closures are pretty awesome. I definitly have to look at the again. I avoided closures because often I see code that's unreadible to me. Maybe that's the reason why I never used them. I tried earler to pass the formula as str and combine them with value, but wasn't successful. Thank you very much. So cool. I updated the dev branch.
Is it based on tokio? You can sure get a lot of action with light weight futures!
So it's like a checksum for UIs?
No. It serializes entire objects. See the example snapshot in the docs. 
https://github.com/astrojhgu/adaptrapezoid_benchmark My benchmark by solving adaptive trapezoid integration problem. The result has not be concluded in the page yet. But in brief, Rust is as fast as C and C++ even faster by a little.
This is a nice crate! I read through the entire codebase in 5 mins because the code is so simple and intuitive. Further all the comments and tests makes this a great example of how a crate should be. I'm only speculating, but this system seems to be very easy to implement in Rust, and I think that shows that it is probably a good way of modeling changes. What I am trying to say is that Rust makes some patterns/paradigms harder or verbose to do because of the ownership rules, e.g like [Cathrine mentioned at RustConf 2018](https://youtu.be/aKLntZcp27M). Just like a ECS, I think this pattern is very easily represented in Rust because of its data oriented approach. One thing that I think makes this implementation great compared to the Javascript library is that using an `enum` to represent all possible actions makes it way easier to ensure that you exhaustively match on all actions. Further this prevent errors because of typos you might get while using the Javascript framework. Thank you for sharing! 
Yep. I saw [a guide](https://antoinealb.net/programming/2015/05/01/rust-on-arm-microcontroller.html) that mentions it, and it works, so I left it. 
Windows picks up DLLs from the app directory, so just ship GTK with your app
There are the [encoding](https://crates.io/crates/encoding) and [encoding-rs](https://crates.io/crates/encoding_rs) crates that let you convert to-from a range of arbitrary encodings.
Thanks, I'll look into those crates.
Or, you could put a redirect for all user-agents (that's what 301 is for) and not worry about all the other crap, because those will fix themselves.
I think a more interesting aspect to this Q/A is that, to my understanding, you could start to implement things like \`grim\`/\`slurp\`/\`wlstream\` in Rust now. Which is very cool.
Thank you for your responsiveness. I'm newbee in Rust, but I'll try to see where in project I could start.
[Here's a gist](https://gist.github.com/lights0123/ecc6c2d24adb9c5d1175835974101ce2) containing the assembly. [Here is the source](https://github.com/lights0123/example-nspire/blob/9638417a8a32b9099a3b134d2331bbde89622828/hello-world/src/main.rs) for this build. The function `format` is shown below: #[no_mangle] fn format(args: core::fmt::Arguments, str: &amp;mut String) { str.write_fmt(args); } The calculator crashes within that function.
That's severely over complicated. Rust's documentation is not the first website ever to have this problem. It's what 301s are for. 
In my experience they never do.
You should be able to remove it from the search index using robots.txt. That wouldn’t disrupt incoming links. 
&gt; This is a nice crate! I read through the entire codebase in 5 mins because the code is so simple and intuitive. Further all the comments and tests makes this a great example of how a crate should be. &gt; &gt;Just like a ECS, I think this pattern is very easily represented in Rust because of its data oriented approach. TBF Redux itself is at i's core is less than 50 lines of js. Any implementation of it without bloat is going to be incredibly small.. 
Maybe something with `transmute`? The nomicon [mentions](https://doc.rust-lang.org/nomicon/transmutes.html) that transmuting between non-`repr(C)` types is undefined behaviour, but I don't know whether `u32` and `[u8; 4]` are `repr(C)` or not. Can anyone comment on this?
wrong subreddit. 
A few observations from someone who used to deal with crawl configuration in a search engine: * There are *quite a few* flavors and release-specific snapshots of TRPL [still available](https://www.google.com/search?q=the+rust+programming+language+"introduction"+site%3Adoc.rust-lang.org) via a search, beyond just the second edition * There are [different](https://doc.rust-lang.org/book/second-edition/foreword.html) book [editions](https://doc.rust-lang.org/book/foreword.html) still being indexed, but also [different](https://doc.rust-lang.org/1.23.0/book/second-edition/ch03-01-variables-and-mutability.html) book [snapshots](https://doc.rust-lang.org/1.30.0/book/second-edition/ch03-01-variables-and-mutability.html) of the same edition corresponding to different numbered Rust releases * For the second case (duplicates across numbered Rust releases), the [current robots.txt](https://doc.rust-lang.org/robots.txt) blocks crawling the versions before 1.0 stable, but nothing since * Judging by the [placeholder messages](https://doc.rust-lang.org/book/second-edition/ch03-02-data-types.html) and the discussion here, it sounds like there's no desire for outdated book editions to continue appearing in searches (ones where the URL lists a specific edition or Rust release number) * Because the TRPL URLs that [don't specify an edition or release number](https://doc.rust-lang.org/book/index.html) have existed for a while and continue to be updated, it should be fine to de-index the various old versions via robots.txt, rather than set up some complicated set of HTTP redirects. As long as those out-of-date pages are still served, legacy links in StackOverflow posts etc. will continue to work for end users (unless those sites perform their own crawling to remove dead links in answers automatically, which would surprise me) * There may be value, for the sake of end users, in changing the pages served for old editions / snapshots so that they contain a link to the corresponding chapter+section in the current TRPL, as some comments suggest; but if the option in the previous bullet is used, this is orthogonal to the search engine issue, as engines will ignore these pages outright. * In practice, doing the previous bullet may be a pain, as the structure and precise chapter/section layout of the book has changed over time (what section in the current book should users be sent to?)
The thing is - that section with transmute is *the only part that actually works*. If you remove that for loop, it's the other parts that don't work.
Fair point. However the goal of the commit was to highlight that the paradigm fits well in Rust aswell. The implementation doesn't need to mess around with e.g `unsafe` or `RefCell`s, which many other patterns need when translated to Rust. As mentioned many times before, Rust makes implementing a linked list tricky because of ownership. Further there are very few usecases where a linked list would be a suitable structure because of it's sparse layout and expensive indexing. Hence my point was to highlight that the pattern redux employs fits well with the ownershipsystem in Rust because of it's inherent data-oriented nature. 
I'm pretty sure the only reason it "works" is because no code actually references that file. If anything actually tried using it, it would choke on the `stack_exhausted` and `panic_fmt` lang items, both of which no longer exist. You should be able to just remove it completely.
`xs.iter().map(|s| *s)` &amp;#x200B; This seems to work. `xs` is `&amp;[&amp;str]`, `xs.iter()` is an iterator of `&amp;&amp;str` items, and then you map it to an iterator of `&amp;str` items - compatible with `once("a")`.
Interesting - that didn't work before I separated things out into `ndless-handler`, but I just removed them and it still works. Still have this problem, though.
Hey so just to be clear, because `Subscription`s are only `fn`s without storage, you can't use a move closure, right? I'm curious as to the utility without move closures. The lifetimes are going to get really tangled up if you try to do pretty much anything, right? Or am I confused?
Mm
Yeah, I didn't imagine that would solve the problem. It was just a confusing thing I noticed. The actual problem you're running into is in the `format!` machinery somewhere right?
It fails at the `str.write_fmt` line. [Here's a gist](https://gist.github.com/lights0123/ecc6c2d24adb9c5d1175835974101ce2) containing the assembly. [Here is the source](https://github.com/lights0123/example-nspire/blob/9638417a8a32b9099a3b134d2331bbde89622828/hello-world/src/main.rs) for this build. A crash occurs in this function, when passed an argument with `format_args!` and a struct's member. #[no_mangle] fn format(args: core::fmt::Arguments, str: &amp;mut String) { str.write_fmt(args); } The calculator crashes within that function. I have noticed that the emulator itself segfaulted when I screwed up some graphics stuff, so I would assume otherwise. I don't think that memory is a problem, as it can easily format other numbers, such as variables or fields of the struct when they have been written to other than when initialized.
It turns out this may work perfectly for me! Do you have any plans to put it on github or gitlab? If not, would you take issue if I were to create a GitHub hosted fork?
I think you are right. Using function pointers for subscriptions is not ideal, as they won't be pretty useful. I will probably change subscriptions to a trait implementing Fn.
nah, going between u32 and an array of bytes should be fine as long as they're properly aligned.
If someone had the time to help with documentation of rust, who would they contact? My mother just retired from 30yrs of working at Intergraph where she did documentation for software. She has nothing to do now.
Yep. Specifically, somewhere in [this function](https://doc.rust-lang.org/core/fmt/fn.write.html).
Firefox on Android is based on Gecko, the same rendering engine as on desktop. It does contain Stylo (a.k.a. Quantum CSS) and a number of other components written in Rust. Firefox on iOS is based on WebKit, because that’s the only rendering engine allowed to apps in the App Store. There is no Rust code as far as I know.
I'm pretty sure it *is possible.* The only question is *is it worth it?* The icons and ui/glade files can be compiled into a GResource and included in the application binary, though doing this for all the standard icons is probably going to be tedious and miserable. Likewise, the libraries can be statically linked as long as you satisfy the legal requirements of the LGPL.
It really really is
Yeah, I tried to do something like this a while ago... let's just say I think I know why there aren't an abundance of event emitters written in Rust.
A "perfect hash function" might be an easy way to do this in a way that might be more efficient: https://github.com/sfackler/rust-phf Or you could take advantage on the clustering of the keys to do a bit prefix trie like in rust-encoding: * https://github.com/lifthrasiir/rust-encoding/blob/eb3d3c307df864f6a25e2ca16d49703e5d963ec5/src/index/singlebyte/windows_874.rs#L33-L71 * https://github.com/lifthrasiir/rust-encoding/blob/master/src/index/gen_index.py
Not sure if it works at all, gdk-pixbuf loads dll's as plugins for each image type
Have a project that runs all the formatters on the project is certainly a cool idea. I quite like it as well. The idea of splitting formatters as actions is intended to allow others to pick and choose. I haven't seem an example of a GitHub Action which trigger other actions internally, but if there was, I would certainly adapt the actions to be allowed to be reused like that as well. On that case, making a single commit would become much more feasible.
This was to optimize CPU time. To instead reduce code size, try a static `[u16; u8]` array with index indicating the byte value, and linear search.
Like any part of the project, emailing the team is a way to reach everyone. That’d be great!
Oof. Well that definitely complicates things.
I am 29 years old software developer with 10 years experience working with Java, C# and python. I recently (6 month ago) discovered rust and now I know it will be my future primary language. I just totally in love with its capabilities and guarantees. I already made some app (a command line tool + a remake of asteroid game with amethyst ) Do you have positions opened for people experienced in others languages but highly motivated to gain experience in rust? 
Hi, thanks for your suggestions :) To be honest, I've never dealt with perfect hash functions and will definitely look into them. In the mean time I think using the static \[u16; u8\] array would work fine for now. I will definitely try to upgrade it to a phf function once I get to grips with the concept. &amp;#x200B; Many Thanks, HOWZ1T 
Have a look at [rodio](https://github.com/tomaka/rodio)
You know, actually, I think what I would do if I were you is, rather than offer the `listen` API like you would in JS, offer a `futures::Stream&lt;State &amp;&gt;`. This allows users to use any futures executor they'd like and basically handles the problem for you. An easy `futures::Stream` implementation to use is `futures::mpsc::Receiver` (via the channel). Then I think you could just offer a `.listen` and pass the result straight into a `Receiver::for_each`. I'm curious to see what you end up doing.
Just thought about something similar. Wanted to monitor co2 level in my working room. Will try to get such sensor.
Your second version is basically the way to do it, but `map(|s| *s)` is actually spelled `cloned()`. It's a somewhat unfortunate name because what's being cloned is the reference, not the contents, but it makes sense if you really grok pointers. For that reason, &amp;&amp;T can always become &amp;T by virtue of the Clone and Copy impls on `&amp;T` for all `T`. If you check the signature of Clone and fill in `&amp;T2` for `T` you see it is `&amp;&amp;T2 -&gt; &amp;T2`. Copy can be thought of as having the same "signature" as Clone in the sense that Copy is just Clone elision.
Can you point where it's documented that WebKit is the only allowed rendering engine? I did know App Store was dictatorship, but... even forcing the rendering engine???
[https://developer.apple.com/app-store/review/guidelines/](https://developer.apple.com/app-store/review/guidelines/) Control-F "Webkit"
This looks really cool! As an aside, how does the Rust community handle immutable data structures in this context? For example, let's say my `State` object had a lot more than just `counter` in it. It seems to me that it would get very tedious to copy the struct and re-initialize all of the fields. In JS-land, I like using `immutability-helper` to make this easier (or just the spread operator for simpler cases). This is an honest question, as I still consider myself a Rust beginner
Thanks....
Thank you for an answer! It's not to be picky, but `map(|s| *s)` requires `Copy` while `cloned()` only requires `Clone`, so they are a bit different in the sense that the former will only compile if the type is "trivial" to clone, hence it might protect use if change some other requirements in the code. I see your point regarding "if you really grok pointers" it will be easy to see that clone on pointers are cheap operations. It is really handy that pointers implement clone instead of it being a different member function or trait, but I do wish that perhaps it could have been a better name for it. I think this is the reason a lot of people rather to `Arc::clone(&amp;ptr)` instead of just `ptr.clone()`, because the former shows that it's a cheap operation. I wish there was a `copy` member function of the `Copy` trait which would delegate to `clone`, because then one could be sure that `data.copy()` is a cheap operation while `data.clone()` is most likely an expensive operation. 
Ah, and this seems to mostly answer my question: https://stackoverflow.com/a/48389214/263986
It's far worse than that they force both the rendering engine and the JavaScript engine to be the WebKit implementations bundled into iOS. In other words you can only use WKWebView or UIWebView.
I've been reading through the docs, and it's mostly great but one think kinda stuck out to me: Why on earth is duration represented as a 32 bit nanoseconds and a 64 bit seconds value separately? In an otherwise very systems oriented language, why waste bits like that? Why not just store the number of nanoseconds in a 64, 96 or 128 bit integer? Even doing things like Abseil-cpp does and storing quarters of a nanosecond would be more efficient. This is language developed by a lot of really bright people obviously, and that decision is deeply confusing to me.
If you send a PR, you may want to look at [my top-level reply](https://www.reddit.com/r/rust/comments/am33qj/can_the_second_edition_book_please_return_a_301/efjv2w6), if you haven't continued following the thread. **TL;DR**: blocking the outdated versions (and [numerous versions](https://www.google.com/search?q=the+rust+programming+language+%22introduction%22+site%3Adoc.rust-lang.org) still appear in searches) via robots.txt would solve 99% of the problem (traffic from search engines), and for the \~1% who visit old editions because of StackOverflow links etc., one could add section-level links etc. to help them too. \+ mention of /u/steveklabnik1 . I've never worked on a PR, but I'd be happy to pitch in, and am also interested in possible contribution to docs more generally.
Using a stream sounds interesting because then you could e.g pair up state updates with sending network packets in a very clean way. However in this situation you have a single producer (the store) and many consumers (any place where `listen` was called). So you either have to make a new `mpsc` queue for each consumer (sounds expensive but might be efficient enough) or use something like [`bus`](https://github.com/jonhoo/bus) (but it doesn't use the `Stream` API). I haven't found a suitable channel, but perhaps there is? Or maybe one could implement the `Stream`-API for `bus`.
This representation matches \`struct timespec\` from POSIX/C. The primary use of the duration type is to interface with the operating system (timeouts, etc.) so it makes sense to essentially wrap the native type.
Np. Imo, the only viable way for a single file gui app is either giving up on crossplatformness, and dynamic linking to the system's gtk/qt/wpf/coaca, or a static-linked qt app in c++. You _can_ write your code in rust, and then your ui code in c++/qml with rust-qt-bindings-generator, and the qml option might be ok, but if your going to use c++ for the ui imo just write it in c++ to begin with. You could also try libui-rs, though idk if it supports static linking. Last I tried it conrod was pretty meh. Azul looks promising but not quite there yet
No. Rustup doesn’t build from source and the upstream msvc toolchain is built with the 2015 crt. 
Thank you! I wondered why so many languages were doing something that seemed so odd!
The other option is drawing the UI yourself. Isn’t that what Blender and Sublime Text do? Granted, it will take a lot of effort, but our ecosystem has very high quality graphics libraries like `gfx`.
Tastes may vary. I personally find that type FI = &lt;T as TableRouter&gt;::FetchIncoming; type Fu = &lt;FI as IntoFuture&gt;::Future; future::Join&lt;Fu, Fu&gt;; is easier to read and bracket match. I would personally prefer type Assemblage = (Vec&lt;A&gt;, HashMap&lt;B, C&gt;); Arc&lt;Mutex&lt;Option&lt;Assemblage&gt;&gt;&gt; both for readability and ease of bracket matching. But again, it's a matter of taste.
&gt; Because the TRPL URLs that don't specify an edition or release number have existed for a while and continue to be updated, it should be fine to de-index the various old versions via robots.txt, rather than set up some complicated set of HTTP redirects. As long as those out-of-date pages are still served, legacy links in StackOverflow posts etc. will continue to work for end users (unless those sites perform their own crawling to remove dead links in answers automatically, which would surprise me) Please don't. I often find myself specifically searching for bits of older editions because the newer editions don't have a direct equivalent. (eg. I searched up the first edition's syntax index quite a lot when I was "supposed" to be using the second edition.)
Sorry, I confused panic- and exception-handler. By panic handler you mean the Rust one, I guess? I meant the exception handler of the processor! Do you have such one? Your situation looks like there is something like an illegal instruction, an unaligned memory access … something that processor can’t handle. On ARM this calls an exception handler and if that exception handler is not there it calls the *double fault* exception handler, and if that again is not there, the processor is reset. To debug your code I would register all of these handlers (at least the double fault one) to see if that’s the right direction to investigate further.
&gt; You could use a redirect for non-search engine user-agents (google uses a distinctive user-agent, I assume other search engines do the same). Then for search engine user-agents put in a a robots.txt file that does not redirect and says "do not index this site". If you get caught treating GoogleBot differently than a regular user agent, Google reserves the right to penalize your site.
410 is semantically incorrect and, in the face of crawlers which implement the HTTP spec correctly, would hurt access to the most recent edition. (Crawlers are designed to deal with sloppy 404 responses, but 410 is an explicit "This is gone with no successor" message that can't be sent by accident, so it means "Delete this from the index and zero out any accumulated search ranking scores. There is no successor.")
But it *would* hurt people like me who are trying to track down stuff that is missing from newer editions. (eg. I searched up the syntax index quite a bit during the second edition era and, as far as I could tell, it only existed in the first edition.)
I don’t have an exception handler set (nor do I know how to set one). And actually, I just updated to the latest nightly, which fixes this problem. However, there’s a new problem: putting any struct in a `Some` or `Ok` causes the same error. [Here's a diff](https://www.diffchecker.com/Sl2Dp7RR) that shows the problem. The assembly on the left fails, and the right works without any problems. The types are: enum A&lt;T&gt; { B(T) } #[derive(PartialEq, Copy, Clone)] pub struct Rect { pub x: i16, pub y: i16, pub w: u16, pub h: u16, } fn some(r: Rect) -&gt; Option&lt;Rect&gt; { Some(r) } fn make_a(r: Rect) -&gt; A&lt;Rect&gt; { A::B(r) } &amp;#x200B;
So is this ARM? Wikipedia says ARM926EJ-S. Is this true for your model? In 10 minutes I’m on my desktop PC and I will look over the assembly code.
Correct. Thanks!
On the subject of using enums to ensure all actions are handled properly, you can definitely do that in typescript with a few tricks. That's what I do anyway, although it takes a bit of extra code.
I've heard security as part of the justification for this. iOS is extremely strict about handing out memory that is both writable and executable, but you pretty much need that functionality to do the JIT compilation that makes javascript perform decently. Only allowing the system web browser to do this is less than ideal but better than nothing. Of course there's other reasons why they wouldn't want other browsers on iOS and there are other less restrictive ways to try to mitigate the same kind of problems but it's not an entirely unreasonable tradeoff in my opinion...
There are some loose ends that would need to be tied up first; I noticed the other day that the link to the book in AsRef's documentation (https://doc.rust-lang.org/std/convert/trait.AsRef.html) still points to the first edition, so I'm sure there are more. Having broken links in standard library documentation would be really unfortunate.
Everything from the timing, through the design of the website and the handling of inbound links, to the upkeep and updating of the information hosted on the site reeks of inexperience and poor planning. Leaving aside the design of the new site (either semantic or visual), there are far too many issues that any experienced web developer simply wouldn't make. What makes these issues so damaging is that those who will be affected by them the most will be beginners and those evaluating the language for the first time. As it stands, the new website is at best a neutral factor in Rust's adoption and at worst a strong detriment. It's hard to believe that Rust is supported by Mozilla. Rust folks would do well to replace whoever caused this mess and appoint a competent professional in their place. 
Could you please clarify: does the implementation use mutable state? because original redux do not mut storage, which helps to have references to old iteratios, which is useful, for example, for gui rendering.
&gt; Are there plans to provide an example or expand the documentation? Almost all methods for these structs have descriptions in [DOCS.RS]. Welcome to [create issues] for questions! We will try our best to enhance the documentation. (Time or rather lack of time seems to be a major inhibitor of it.) &gt; Why little-endian for the numeric types instead of native-endian? Virtually all codes was written via `proc-macro`. It can improve performance. (Lots of computations are moving into compile time or computing manually.) But the code becomes quite complex, with terrible readability. (More code always brings more bugs, and maintenance will be more difficult.) A deterministic choice can reduce complexity. So we don't use native-endian. &gt; Would stdsimd make this even faster? Or are speedups achieved some other way? Yes! Now, we only use simd in [serialization] (via [faster-hex]). [DOCS.RS]: https://docs.rs/ [create issues]: https://github.com/cryptape/rust-numext/issues/new [serialization]: https://github.com/cryptape/rust-numext/blob/460bddb85b50687abb93dee71317c1dab1476b6b/constructor/src/fixed_hash/core/extension/serde.rs#L26-L39 [faster-hex]: https://crates.io/crates/faster-hex
Okay, so the assembly is basically just load and store instructions. I still have the strong assumption it’s because of an *unaligned memory access*. The ARM docs say: “On older processors, such as ARM9 family based processors, an unaligned load had to be synthesised in software. Typically by doing a series of small accesses, and combining the results.“ So you can only access addresses divisible by 4. In your diff on the right hand side in the load and store instructions I only see offsets of #4, #8 and #12 which are all divisible by 4. On the left hand side there is a #6 which might be the problem. I’m not sure how to proceed. I know GCC has a flag `-mno-unaligned-access`, but I don’t know for LLVM. I think the compiler shouldn’t generate unaligned accesses at all when the architecture doesn’t support them, so this might be a compiler bug. On the other hand it could also have something to do with the `transmute`, but from an `u32` to an `u8` this shouldn’t be a problem. Does this help you somehow?
Yes - thanks! I’ll try asking around on IRC. With the transmute, the exact same error occurs without it - in fact, the transmute is the only way that I’ve been able to actually read a number. 
I’d really like to investigate further. Unfortunately I have no TI-nspire at hand. Oh, I just saw that you have the repo on GitHub. I’ll look at it. On which IRC are you, maybe we can talk there?
Speaking of which, if you want to create an installer, I wrote a [blog post](http://blog.ssokolow.com/archives/2018/02/16/free-installer-creators-for-all-eras/) tallying up the free options (including stuff for targeting early Windows versions and DOS for retro-hobby authenticity). The TL;DR is that, if you want to build a `.msi` for free without a lot of hassle, the best option I've found is the [WiX#](https://github.com/oleg-shilo/wixsharp) transpiler and, if you want a legacy-style `.exe` installer, use [InnoSetup](http://www.jrsoftware.org/isinfo.php). (InnoSetup is what GOG.com uses and it has a `.ini`-style declarative project format extensible with PascalScript event hooks, unlike NSIS (the other big-name free `.exe` option that companies like Google, Dropbox, and Ubisoft use), which uses a mind-bogglingly low-level scripting language with no built-in support for logging what to uninstall.)
I may advice you to make signature of reducer to take State by value (consume), so then you can may do things like: ``` #[derive(Default)] struct State { counter: i8, ref: SomeNonCopyStruct, // ... a lot of fields } enum Action { Increment, } fn counter_reducer(state: State, action: &amp;Action) -&gt; State { match action { Action::Increment =&gt; State { counter: state.counter + 1 ..state } } } ```
As someone learning Rust, this solution seems like it would be a huge help to me and others trying to get into the language for the first time; making it much more welcome to newcomers.
I did not know what to expect so I suggested we went over parts of the book. We ended up not actually looking at it, at all! People were quite excited, those who tried it wanted to find a way to do more. I've heard comments in the like of "Rust is now my favorite language" and I was glad to not be alone :D We did find a couple of possible projects to try, but I think the learning curve was a bit underestimated and the suggestions were daunting. Also, there seems to be a general dissatisfaction with Python but I don't want people to blindly hope for something else that does not deliver. I've suggested we try to find smaller scope, isolated projects to build expertise before attacking larger ones. I might organize some learning material with hands on exercises. Time will tell if the planted seed becomes... a fireflower! :D
No, I'm saying that something in `Vec` (or anywhere in `std::vec`) might do safe operations that break the `unsafe` code, because it can access internal fields and break invariants (as others have said).
I’m not on IRC yet at all, I’ve just read that it’s a good idea to use for getting help. I’m in UTC-5, so it’s just night for me and I’ll take a look again tomorrow, at around midnight UTC. What IRC channels do you recommend?
Aren't they pretty expensive?
Interestingly enough I just started working on something to do exactly this. https://github.com/freemasen/jsyn It is still very early in the process but the goal is to convert `syn` ast to js to on theory be possible to use in a proc-macro context as well. 
&gt; Do you have an example of a piece of code where inferable type annotations inarguably improve readability? I would rarely add type annotations, but I think it's useful when the actual type of a variable is inferred, but not until noticeably later in the code. ```rust let v = Vec::new(); v.push(5); // Some more code here... f(v[0]); ``` Reading the first line, I know `v` is a `Vec`, but have no idea what it contains. In the next line, it becomes clear that the `Vec` contains some kind of integer, but I don't know what size. Even in otherwise good code, there may be a reasonable amount of code adding things to the `Vec` before it's passed to something that determines the exact size of the integer. So I'm often inclined to add type annotations to `Vec`, `HashMap`, etc. if it's not clear from the context. It may not be the only way to make the code clearer, but I think it can be a reasonable solution.
Better WASM support is always exciting, and cross-compilation is fairly cool. Looking forward to these features!
Nice. Bonus trivia: Why on earth would a CO2 monitor report as a Human Interface Device? Because Windows doesn't let you do third-party drivers for things, so you sneak your device in through the HID driver. Then everybody else is stuck with this nonsense — thanks Windows. (The right way is to provide both an HID interface and a sane-people interface: the HID spec allows this, but manufacturers can't be bothered for the tiny Mac/Linux market.) What [body part](https://www.usb.org/sites/default/files/documents/hid1_11.pdf) (pp. 45-46) did they use for the data?
Perhaps it would be more efficient to just let the `cross` project independently handle everything that's proposed for Cargo for 2019 and accelerate the timeline for the other improvements by 1 year. I'm surprised that `Xargo` was mentioned but `cross` wasn't. Would Cargo package a C compiler, standalone assembler, linker, sysroot, and runtime (QEMU, etc.) like `cross` already does? How would it do any of it better than `cross` already does? In 2019, I would like to see less ambitious and more practical issues addressed: (1) Don't have the features selected for a dev-dependency affect the features enabled for a runtime dependency (2) Fix the regression in how `cargo update` deals with yanked crates. (3) Allow features to be disabled/enabled automatically according to the target, (4) Allow `build.rs` and `#[cfg]` to detect whether the target has `libstd` available or not, so that it can decide whether to apply `#![no_std]` and avoid libstd, (5) Cargo.toml should be able to state the minimum version of the rust toolchain supported ("Rust 1.32 or later"), and (6) Add a stable "airplane" mode. Note that these are amongst the most +1'd issues in the Cargo issue tracker and these are issues that affect me all the time, regardless of platform.
They range from 20 to 250 Euro, or something like that. Mine was around 70.
I'm slightly concerned that there is no mention that the "cargo feature" support is currently completely broken around targets, dependency kinds and the new Rust 2018 package renaming. These problems have been known for a very long term and require substantial internal changes in cargo and they are long overdue. So while I agree with most of this blog post, I'd push everything back one year and make 2019 the year where the feature system is getting a massive overhaul.
Gotcha, yeah I completely agree.
Does [crates.io](https://crates.io) fall under the cargo branch? If so, that should be a top priority. The website is awful. It looks awful, it's sized awful on most screen sizes, and its hard to find the things you need. Rust's big sell of having a good package system with lots of small crates demands a better website, getting users to featured crates, the crates they need, and getting crates uploaded, all needs to be massively improved.
I think it's time for redux re-implementations to move away from the simple "counter" example, it's a bit too trivial to show off real world use. I'd be more interested in seeing an example which fires off http requests and efficiently updates a large struct with non-copy members. And perhaps show how it would be easily integrated into a GUI framework of some sort, because really you need the whole package to get value out of these libraries (data storage, event emitting, event handling, GUI rendering, asynchronous data fetching, etc.)
My pet peeve is custom profile (like.debug and release) support. The relevant issue seems to have turned to discussions about overriding profiles. Why are they important? Because the latest changes to the release profile (increasing the number of CGUs, enabling incremental builds) have made the generated code slower, and Rust gets some bad press in benchmarks because of it. And someone who wants to ship faster binaries can't without going through a lot of hoops like editing Cargo.toml. Finally, it tends to make reliably benchmarking code a lot harder.
A larger example is planned.
The state itself is not mutable. Dispatching actions changes the state within the store, just as with redux.js.
Good point, I will change that.
&gt; Writing plugins is also sub-optimal: although it is easy to make a plugin (just name your binary cargo-foo) *there is very little support in the form of libraries or APIs.* As someone who published a few (and experimented with much more) cargo plugins, this (and rest of that paragraph) rings very true. In a few of those projects I had to reimplement parts of the Cargo internals (see [margo](https://github.com/hobofan/margo), because the `cargo` crate either didn't expose those at all, or using it was far too heavy-handed for what I wanted to do in my plugins. One of the things I'd like to see as a plugin developer is more fine granular `cargo-*` crates instead of the current monolithic `cargo` crate, which is a huge(!) dependency.
I'm sure it won't come as a surprise to you, but none: Bus 001 Device 008: ID 04d9:a052 Holtek Semiconductor, Inc. USB-zyTemp Device Descriptor: bLength 18 bDescriptorType 1 bcdUSB 1.10 bDeviceClass 0 bDeviceSubClass 0 bDeviceProtocol 0 bMaxPacketSize0 8 idVendor 0x04d9 Holtek Semiconductor, Inc. idProduct 0xa052 USB-zyTemp bcdDevice 1.00 iManufacturer 1 Holtek iProduct 2 USB-zyTemp iSerial 3 1.40 bNumConfigurations 1 Configuration Descriptor: bLength 9 bDescriptorType 2 wTotalLength 0x0022 bNumInterfaces 1 bConfigurationValue 1 iConfiguration 0 bmAttributes 0x80 (Bus Powered) MaxPower 100mA Interface Descriptor: bLength 9 bDescriptorType 4 bInterfaceNumber 0 bAlternateSetting 0 bNumEndpoints 1 bInterfaceClass 3 Human Interface Device bInterfaceSubClass 0 bInterfaceProtocol 0 iInterface 0 HID Device Descriptor: bLength 9 bDescriptorType 33 bcdHID 1.10 bCountryCode 0 Not supported bNumDescriptors 1 bDescriptorType 34 Report wDescriptorLength 53 Report Descriptor: (length is 53) Item(Global): Usage Page, data= [ 0x00 0xff ] 65280 (null) Item(Local ): Usage, data= [ 0x01 ] 1 (null) Item(Main ): Collection, data= [ 0x01 ] 1 Application Item(Global): Logical Minimum, data= [ 0x00 ] 0 Item(Global): Logical Maximum, data= [ 0xff 0x00 ] 255 Item(Local ): Usage Minimum, data= [ 0x00 ] 0 (null) Item(Local ): Usage Maximum, data= [ 0xff ] 255 (null) Item(Global): Report Count, data= [ 0x08 ] 8 Item(Global): Report Size, data= [ 0x08 ] 8 Item(Main ): Feature, data= [ 0x02 ] 2 Data Variable Absolute No_Wrap Linear Preferred_State No_Null_Position Non_Volatile Bitfield Item(Global): Logical Minimum, data= [ 0x00 ] 0 Item(Global): Logical Maximum, data= [ 0xff 0x00 ] 255 Item(Local ): Usage Minimum, data= [ 0x00 ] 0 (null) Item(Local ): Usage Maximum, data= [ 0xff ] 255 (null) Item(Global): Report Count, data= [ 0x08 ] 8 Item(Global): Report Size, data= [ 0x08 ] 8 Item(Main ): Input, data= [ 0x02 ] 2 Data Variable Absolute No_Wrap Linear Preferred_State No_Null_Position Non_Volatile Bitfield Item(Global): Logical Minimum, data= [ 0x00 ] 0 Item(Global): Logical Maximum, data= [ 0xff 0x00 ] 255 Item(Local ): Usage Minimum, data= [ 0x00 ] 0 (null) Item(Local ): Usage Maximum, data= [ 0xff ] 255 (null) Item(Global): Report Count, data= [ 0x08 ] 8 Item(Global): Report Size, data= [ 0x08 ] 8 Item(Main ): Output, data= [ 0x02 ] 2 Data Variable Absolute No_Wrap Linear Preferred_State No_Null_Position Non_Volatile Bitfield Item(Main ): End Collection, data=none Endpoint Descriptor: bLength 7 bDescriptorType 5 bEndpointAddress 0x81 EP 1 IN bmAttributes 3 Transfer Type Interrupt Synch Type None Usage Type Data wMaxPacketSize 0x0008 1x 8 bytes bInterval 10 can't get debug descriptor: Resource temporarily unavailable Device Status: 0x0000 (Bus Powered) 
&gt; Allow a library's build.rs and #[cfg] to detect whether the target has libstd available or not, so that the library can decide whether to apply #![no_std] and avoid libstd. From all the experience I've gathered around `#![no_std]`, I think this is as much (if not even more) a `rustc` problem as it is a `cargo` problem: - There is no way to get information about `libstd` availability from `rustc` - There is no way to invoke similar functionality to the `#![no_std]` attribute via command line flags to `rustc`, meaning that outside tools can't force `no_std` (unless they inject code). Small plug: With [cargo-nono](https://github.com/hobofan/cargo-nono), I hope to help soothe the most common `no_std` woes for the time being.
One suggestion would be to replace you assembly instructions with NOP instructions until the crash goes away, and use this to narrow down where it crashses further,
I'm assuming you've seen https://youtu.be/0j74jcxSunY? He does state that localization tends to be very specialized to the application making a general purpose library incredibly difficult. I'm curious how Fluent addresses that.
Go ahead! I've been thinking about mirroring everything from that server on sh.rt for a while now, so I made a mirror for just that repository [here](https://git.sr.ht/~benjamin_l/imgui-gfx-hal) while I work out a better solution. Feel free to put your own copy on GitHub though.
Thanks! Yeah, I was just joking. I think the Table of Body Parts is one of the funnier things to find in a giant standards document like this. I can imagine the discussion among the committee about which body parts are in or out, the level of detail, etc.
Move the linker configuration that you have in Cargo.toml to .cargo/config instead.
From my experience with using Fluent, it provides a nice solution for mainly the translation part of the localization problem. Those are the problems outlined between (roughly) 1:25 and 5:15 in the video, and Fluent provides good primitives to deal with those.
No. The cargo team is a [subteam of the dev-tools team](https://www.rust-lang.org/governance/teams/dev-tools), while [crates.io](https://www.rust-lang.org/governance/teams/crates-io) is its own team. 
Redesign work for crates.io should start soon.
Uh? I don't recognize the careers.rust-lang.org URL at all, do you have any archived page/screenshot/info of what should be there?
You could try https://crates.rs/ to see if you like it more. That's what I use to to avoid the unpleasant client-side rendering on crates.io.
A version combo-box would be dope. I just don't want the Book to turn into CMake or Boost documentation where googling something pulls up a dozen different versions and none of them are current. 
This has already been possible for quite some time now, but the API was just improved. ;)
Some thoughts on the 2020 notes with IDE/build system integration. I have a non trivial build setup mixing cargo and cmake. It's possible with cmake's ExternalProject module, and some messing with .cargo/config, some rustc flags, and a messy command line build call to cargo using a bunch of cmake variables. However, here's what I'd like: 1. Pass environment variables to cargo. This is possible today but it depends on the shell, meaning my cargo invocation is not portable. These should be visible in build.rs, maybe in the binary, I don't know. 2. Specify target output directories with a flag to cargo. 3. Cargo as a library. I know this was discussed, but tools like conrod and ninja would very much benefit by integrating it as a library into their build processes. 4. Some means of specifying dependencies that cargo does not build, even if they're just files. There are other things, but those are the mildly low hanging fruit. 
:) Cool. Thank you for this!
If you have any suggestion try to post it on internals, thanks!
I'm guessing the rest mostly has to do with formatting and such, like where lines can break and RTL text, which is more for the front end where fluent is for the back end.
I am also quite frustrated by travis so I’m very curious to hear about the proposals. I don’t understand how it can be this mismanaged of a company. It took them more than a year to migrate org and com together which looks crazy from the outside. We paid for a long time for the open source offering because we have manu open source repos and it never felt right. Our mac workers were constantly backlogged :-/
Not really a suggestion because I have never used it myself, but Juniper [switched to Azure Pipelines](https://github.com/graphql-rust/juniper/issues/259), which supports all three platforms. Might be worth evaulating.
/r/playrust
Congrats, I love this crate and use it all the time. That said, a lot of these derives are to hack around the fact the Rust doesn't have proper newtypes (that inherit all the attributes of the underlying type). There has been [discussion](https://github.com/rust-lang/rfcs/pull/2242#issuecomment-350994748) about it and I understand why it hasn't been implemented but still.. makes me sad. Newtypes are one of the easiest ways to add type-safety to your code but they feel like third-class citizens in Rust.
My main issue is watching all those crates being continuously compiled, while on C++ I just use binary libraries.
Oops, I saw an old post referencing it, but I apparently misread it and they instead said they wished it existed... Deleting this post.
 Ok, running the function locally is super simple. Just get to your terminal and execute this:&lt;/p&gt;&lt;p name="1a7a" id="1a7a" class="graf graf--p graf-after--p"&gt;If you browse to It looks like something might be missing from the HTML. I can't see that part either.
Does rustup build the Rust compiler and whatnot? I thought it just needed access to CRT and such, and those should work on newer versions.
&gt; Our mac workers were constantly backlogged We're renting a few dedicated Mac Pros from them so we didn't see that (they don't sell them anymore btw), but I remember hearing a lot of complaints in the past. To their credit they *seems* to have addressed the macOS backlog though, looking at the status page the queue is always empty.
Don't worry, and have a nice day!
Now CodeLLDB supports shell globs.
I would love to see this! Could you please post a link or a small code snippet? 
It’s resolved now but it was 9 months of waiting and effectively paying for no improvement in service. They had to reduce concurrency on the builds to increase the likelyhood of builds finishing at all because also just queued tasks counted against the quota if I remember correctly. It’s definitely better now than a year ago for our use but the windows service seems stalled, the org to com migration still requires emailing support and I just have a bad feeling about the future of the platform. Especially now with the acquisition. 
I don't think that's a completely fair dichotomy to make. Python could be statically typed and still have very little punctuation. Some of the syntactic choices in Rust are purely lexical.
I'm very interested in Azure. The fact I can go and spin up 10 Mac instances at once from them is extremely neat but I've been using them for Windows stuff. \[I've only used them to prototype Windows Docker image builds for GNU and MSVC for the various Windows 10 releases (2 ABI \* 4 Windows Releases all in parallel)\]([https://github.com/nelsonjchen/docker-rust/tree/azure-pipelines](https://github.com/nelsonjchen/docker-rust/tree/azure-pipelines)). It's not ready yet as 1809 isn't available but when it does later, it definitely will be. It's crazy I can spin them up all up in parallel like that. If you ask the team, I think they might even just give more hosted VMs especially for a project like Rust with needs like that but the free limits for OSS are already extremely generous. 
&gt;Specify target output directories with a flag to cargo. That's https://doc.rust-lang.org/cargo/reference/unstable.html#out-dir I think
Please make it less dependant on JavaScript. While I understand the wish to appeal programmers from different backgrounds, the user experience should be more important than current front-end stacks make it to be. I can also imagine that on the other end you're losing potential contributors. Someone interested in learning Rust might not want to touch Ember. Neither would someone who strongly prefers React, Angular, vue, or any other stack.
[r/playrust](reddit.com/r/playrust) 
Try this alternative link: https://robertohuertas.com/2018/12/22/azure-function-rust/
What’s our budget? (Or how much is Travis costing us now?) Without that Info is pretty hard to suggest anything. For example, if the budget for this is 100k per year or more (150-200) one or two people could be hired full time to setup Buildbot or similar and manage our own hardware. Hardware is not really the issue. Many companies could donate hardware to the project to make their platforms tier-1 (intel, ibm, nvidia, hi5, etc.), and that’s a one time cost to them. But managing all that hardware and making sure buildbots run smoothly is a full-time job for at least two people. I doubt that any third party CI service will be able to manage these for us.
oh my god this is amazing. thank you and thank whoever built this. &amp;#x200B;
Unfortunately I can't share our current CI costs :(
Why does it have to cost that much? Isn't it enough to rent a couple dedicated servers and install ci workers on them? 
Yeah, that one's fine.
I'm currently using (and loving!) React hooks. They make redux redundant for react. I think they might be a bit too functional for rust (relying on GC), but worth checking out.
Rust ABI isn't stable yet. So you can't use a binary lib in different compiler version. Note: I know that C++ ABI is also not stable. But to me it is quite stable for each compiler vendor.
Also the Cargo dependency is really big and bloated for most kinds of things you want to in a library or plugin. For example, cargo-tarpaulin for coverage in CI makes my CI jobs take a really long time because of the large dependency graph that gets pulled in. 
Is there a tracking issue for improving the cargo API to better integrate with plugins? To me this sounds like a huge enabler of experimenting with potential future in-tree additions in cargo. On the same note, I really appreciate Rusts approach to a lean std offloading the experimentation to individual crates. Coincidentally, `cargo` is the tool to enable the community to function this way and I don't see why cargo itself should not follow the same approach. I wish something like this existed when I wrote [`cargo-with`](https://github.com/cbourjau/cargo-with) which needs to fish out the binaries build by cargo from the json metadata. I'd be very interested in contributing to solve this problem upstream.
Who installs them? Who maintains them when the OSes get upgraded and everything breaks? Or hardware breaks? Or new targets are added? Who debuts timeouts, network issues, etc? Rust has 100s of PRs continuously open, running 50 jobs each, testing the compiler in a lot of weird system hardware (x86, arm, aarch, PowerPC, phones, sparc, systemz, riscv, embedded, NVIDIA gpus, etc...) and OSes (Windows, Linux, macos, Android, bsds, iOS, redox, ...), deploying artifacts to rustup that get downloaded by a lot of users, etc, and that’s for the main repo only. Many other projects in the Rust Lang .org and nursery organizations do this as well. And /u/pietroalbani comment suggest that they need 1:1 support from CI hosting continuously to fix issues. Such a full-time CI gig pays well, 70-100k depending on where you are. And that’s for an 8 h/ day 5 days a week shift. We need at least two of them, and maybe 3, in different time zones, 7 days a week. That puts us in the 200k/year ballpark without electricity, network, and hardware costs. Paying 10k/year to Travis-ci is going to get you what you pay for. 1h of 1:1 support per month and 200 days from issue discover to issue resolved, no external hardware integration, etc. Rust is not Travis target customer. Travis target customer is the one that pays and doesn’t need any kind of support because their system “just works” for them. 
Good for you?
One the one hand I agree that this certainly doesn't help when building cargo plugins in CI. On the other hand, as soon as you start building multiple cargo plugins, you will find that that quickly becomes unworkable as the build times explode, even if each cargo plugin individually has a small number of dependencies. I would argue that if possible cargo plugin maintainers should aim to provide prebuilt binaries that can be easily installed in CI via the [trust install.sh](https://github.com/japaric/trust#use-the-binary-releases-on-travis-ci).
Oh neat, not as bad as I thought
No problem. I just happened to catch the [/r/rust/ announcement](https://www.reddit.com/r/rust/comments/8p9scz/cratesrs_an_alternative_to_cratesio/) 7 months ago. That was posted by /u/kremor but I'm not sure if kremor is the same person as @kornel who announced it over [on users.rust-lang.org](https://users.rust-lang.org/t/crates-rs-a-new-faster-crate-index-website/17876). 
Even for the same computer, the workspace concept as build cache has its own set of issues.
Bad UX on a SPA is solely due to a subpar implementation. It's entirely possible to make a SPA that behaves as well, if not better, than a traditional website. But yeah, if it's using Ember that's not a good sign. The industry has almost entirely moved to React and Vue (Angular is very rare amongst greenfield projects now, at least where I am).
A guy from MS replied in the forum and offered 60 parallel build jobs, for free. They are slowly but surely becoming my favorite tech company haha.
For a personal Rust project I’m also using Azure Pipelines. I’ve built a docker container which consists of everything I need to build, and test my project. Works pretty good! Wanted to achieve the same thing in Travis first but that didn’t end up that well. 
You say that, but the community has massively settled on React now, for example. There's a similar consensus building around TypeScript.
I wonder how well Rust would be suited to sr.ht?
I have a link to the model I'm using, you might find it on Amazon.
I'm sure it's possible, but I prefer sprinkling JS to enhance the user experience, not to make a SPA. Take a look at crates.rs, mentioned in another comment here. As for React, I find the whole concept of Virtual DOM dubious. I imagine the reasoning behind it is to stop caring about coordinating DOM updates, as a VDOM will be faster than doing 100 000 changes to the DOM. And the React apps I've used maybe most (Facebook Messenger in a browser and Signal) get terribly sluggish after a couple of hours. Compare that to docs.rs.
I'm not the author :b, only wanted to share.
I'm quite happy with GitLab CI, maybe that's a solution. It also allows you to add your own machines as builders. Although it doesn't integrate with GitHub too wel as far as I know.
I frequently end up compiling the same crate with the same features with the same other cargo flags on the same compiler version on the same computer a dependencies to the various pieces of rust I use. These artifacts could absolutely be shared between projects.
I had a good experience with [Drone CI](https://drone.io/). I'm just throwing it out there because it is often overlooked. It's [free for Open Source](https://cloud.drone.io/) as well.
Well, it depends on what you're actually making. SPAs are ideal for highly interactive websites, something which a documentation site is not. I can't speak to Facebook Messenger (I imagine terribly bloated with a ton of tracking) or Signal, but slowdown like that shouldn't happen.
BTW: stuck on an old version of Firefox at work (45.0?), and now crates.io doesn't render anything but a blank (well, green) page. Client-side rendering is really annoying, sometimes :(
GitLab CI would probably tick these boxes, although for GitLab.com we currently do not provide Mac OS and/or Windows runners. This has been discussed over the years in various shapes and forms, but due to a lack of Windows/Mac hosting experience we never really bothered. For [Inko](https://inko-lang.org) I'm using [Mac Stadium](https://www.macstadium.com/) through their FOSS sponsorship. It's a bit annoying to set up as you have to use virtualbox for the CI runners. Should the Rust team be interested in GitLab we'd be more than happy to help out, as we've done in the past with other FOSS organisations such as with the GNOME project.
@[athrowaway3z](https://www.reddit.com/user/athrowaway3z) adding \`move\` to the closure seems to make them almost identical in ASM, so I think that solves it: [https://godbolt.org/z/gHtOth](https://godbolt.org/z/gHtOth)
In POSIX the seconds part is `time_t` presumably so it’s compatible with APIs taking Unix timestamps. (This use is, of course, mixing durations and time points but that’s nothing new.) Note that `time_t` has commonly been 32, not 64 bits, hence the whole ”year 2037” problem.
There was talk about adding a `.copied()` method (for Copy types) to Iterator alongside the `.cloned()` method. This might help a little bit to make it clear what is a cheap operation.
I had some trouble doing a render loop using safe rust in wasm, I ended up with something like this. I'm not sure if this is what you were looking for, but works for me: `fn start_loop(self) {` `fn request_animation_frame(f: &amp;Closure&lt;FnMut()&gt;) {` `window().unwrap()` `.request_animation_frame(f.as_ref().unchecked_ref())` `.expect("should register \`requestAnimationFrame\` OK");` `}` `log(format!("Starting loop...").as_ref());` `let mut rc = Rc::new(self);` `let f = Rc::new(RefCell::new(None));` `let g = f.clone();` `let c = move || {` `if let Some(the_self) = Rc::get_mut(&amp;mut rc) {` `the_self.frame_callback();` `};` `request_animation_frame(f.borrow().as_ref().unwrap());` `};` `*g.borrow_mut() = Some(Closure::wrap(Box::new(c) as Box&lt;FnMut()&gt;));` `request_animation_frame(g.borrow().as_ref().unwrap());` `}`
&gt; I wonder how well Rust would be suited to sr.ht? They're new, and don't support OSX. I don't think that's a good fit (might of course change in the future).
Yeah, there's really no need for crates.io to be an SPA. And I'm someone who makes SPAs for a living.
This is definitely something I second. If your API is too deep to flatten, then it could be split into more crates. Some public modules are okay, but otherwise flatten everything you reasonably can for users.
Thanks for the constructive feedback. I've created/updated a few issues in the repo: [#219](https://github.com/ozkriff/zemeroth/issues/219), [#419](https://github.com/ozkriff/zemeroth/issues/419), [#420](https://github.com/ozkriff/zemeroth/issues/420). I'll try to address them in v0.6.
Yeah, the game is supposed to be playable only in the landscape mode. The map is small and should always fit the screen, so no scrolling is planned.
&gt; but due to a lack of Windows/Mac hosting experience we never really bothered. It would be great if you could expand at least to Mac. It's not terribly different from linux. I'm a freeloader (who loves the current feature set from Gitlab &amp; Gitlab CI). But there's probably a market for paying customers who want Mac and/or Windows support.
Thanks for the feedback! &gt; the kerning was really off for me in Firefox on Windows Created [an issue in good-web-game repo](https://github.com/not-fl3/good-web-game/issues/4). &gt; I found the summoners really challenging. The key is playing aggressively but paying attention to the rhythm of summoning - falling back a little bit when new demons arrive, crushing them, and dealing concentrated damage onto one of the summoners. And you are right about cooldowns - they must be synced with summon waves. &gt; Particularly if they got a lot of the grenade demons. They should be easy to kill if you play aggressively and just jump into them while securing your flanks from melee demons. The game's balancing isn't finished yet, there're some mechanics to be integrated into the game, as well as adding more units/abilities and tweaking the existing ones.
There is a plan to introduce new Rust mangling scheme, which may help Rust come close to a stable ABI. https://github.com/rust-lang/rust/pull/57967
The whole Amit's collection of tutorials and links is priceless. :)
I will definitely change to `.copied` if it gets stabilized. Thank you for the link! 
Read ‘funny compilation’ and was expecting some hilarious build.rs
The issue with Mac is that you have to maintain both the host, and the VM images. While some automation exists for this, it's probably a rather different approach compared to managing Linux. There is also the cost factor. From my experience, a Mac Mini can handle 3-4 virtual box builds before the whole thing slows down or runs out of memory. This means you likely have to use Mac Pros or equivalent, at which point things get expensive quickly. Windows is an entirely different beast, though at least you can run Windows in containers on a Windows host, which should make things a bit easier to deal with.
I think this is the issue that made me go back to regular FF from Pale Moon as well.
I'm having higher ranked lifetime bounds and type inference issues... Consider the following code: [playground](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=7187fabdae0a9d9ca7fd74f891096a52) // Some node type, must be a trait object trait INode {} // Visit a structures' nodes with a callback trait IVisit { fn visit(&amp;mut self, f: &amp;mut FnMut(&amp;mut INode)); } // Wrapper for creating ad-hoc visitors from closures struct Visit&lt;F&gt;(F); impl&lt;F: FnMut(&amp;mut FnMut(&amp;mut INode))&gt; IVisit for Visit&lt;F&gt; { fn visit(&amp;mut self, f: &amp;mut FnMut(&amp;mut INode)) { (self.0)(f); } } // Do some action on the nodes of a visitable object fn visit(_visitor: &amp;mut IVisit) {} fn main() { // This doesn't compile... visit(&amp;mut Visit(|f| {})); // But this DOES compile? All I did was add annotations // How to make this work without annotations visit(&amp;mut Visit(|f: &amp;mut FnMut(&amp;mut INode)| {})); } This is a trait object based attempt at a visitor pattern. I want to create 'ad hoc' visitors out of closures for convenience but rustc is inferring the wrong type for `f`: error[E0308]: mismatched types --&gt; src/main.rs:23:15 | 23 | visit(&amp;mut Visit(|f| {})); | ^^^^^^^^^^^^^^^^^^ one type is more general than the other | = note: expected type `for&lt;'r&gt; std::ops::FnMut&lt;(&amp;'r mut (dyn for&lt;'s&gt; std::ops::FnMut(&amp;'s mut (dyn INode + 's)) + 'r),)&gt;` found type `std::ops::FnMut&lt;(&amp;mut dyn for&lt;'r&gt; std::ops::FnMut(&amp;'r mut (dyn INode + 'r)),)&gt;` When I annotate the closure parameter f manually, it compiles. Of course I would like it to just infer the right thing.
I've also never gotten around to installing cargo-tree on my windows machine because it depends on the cargo crate, which in turn depends on some ssh crate, which requires cmake or some crap. Kind of a ridiculous dependency hierarchy for a tool that prints the tree of dependencies!
This sounds very interesting and I want to try it, could you share material you used to understand how to build your language? Started learning Rust recently, until now I mostly did PHP and Web Development.
Per the spec the BSS gets nulled out. That's typically done in some crt0.S type code. On embedded systems it's a good idea to check that it's actually being done, or to null uninitialized globals yourself to be on the safe side.
I've managed to write code in Rust for almost a year now, without having a solid grasp on lifetimes. I don't think I can make it any further without that understanding, though. To illustrate my concern, I have the following: struct Bob { a: String } struct Cat { a: String } impl From&lt;&amp;Bob&gt; for Cat { fn from(bob: &amp;Bob) -&gt; Cat { Cat { a: bob.a.clone() } } } fn convert_bobs_to_cat&lt;'a, T&gt;(bib: Vec&lt;Bob&gt;) -&gt; T where T: From&lt;&amp;'a Bob&gt; { let dog = bib.get(0).unwrap(); dog.into() } fn main() { let bob = Bob {a: "Hello, world!".into()}; let cat = convert_bobs_to_cat::&lt;Cat&gt;(vec![bob]); } The above is a contrived version of something else I'm running into. Adding `'a` to my `convert_bobs_to_cat` was done at the compiler's request, but now it's angry that `bib` doesn't live long enough. I've stared at The Book and some other bits on Google to try to understand what's really needed to make this work, but I keep falling flat. Any advice would be appreciated.
That's what, like , $2400 "value"? I would imagine the project would be happy to accept it, but maybe drop another $2400 to just go to 120. Daaaammnnn. 
I've personally had very good experiences with [CircleCI](https://circleci.com/) for Linux and macOS targets, both in the open source and enterprise world. I haven't personally tried it out, but Azure Pipelines might be another thing worth looking into, particularly since they can handle builds for Linux, macOS, and Windows on a single platform.
Here's most of it. I'm not sure I can share everything, and this is probably more than I should be sharing anyway, but this is the core of it. https://gist.github.com/bheklilr/4d1ea25f05faa7a4eeb5c897b92f6657
Thanks for such an awesome summary.
Does your convert_bobs_to_cat need to be generic over the return type? It's easy to fix if you can just return Cats: fn convert_bobs_to_cat(bib: Vec&lt;Bob&gt;) -&gt; Cat { let dog = bib.get(0).unwrap(); dog.into() } Further I would reorganize how the from conversions are done: #[derive(Clone)] struct Bob { a: String } #[derive(Clone)] struct Cat { a: String } impl From&lt;Bob&gt; for Cat { fn from(bob: Bob) -&gt; Cat { Cat { a: bob.a } } } Now clone the Bob before transforming it into a Cat. If you really insist on your example to work a 'small' tweak to the lifetime parameters makes it work: fn convert_bobs_to_cat&lt;T&gt;(bib: Vec&lt;Bob&gt;) -&gt; T where T: for&lt;'a&gt; From&lt;&amp;'a Bob&gt; { let dog = bib.get(0).unwrap(); dog.into() } As for why this works... I'm still learning about higher ranked lifetimes myself... I think the best way to go about this is to think of lifetimes as 'tagging' how inputs and outputs of a function related to each other. That is, the reason to put lifetime annotations on a function is because you take some borrowed input and return some borrowed result, the compiler wants you to annotate from where this resulting borrow was originally from so it can track the constraints of the returned borrow. In your example this is not the case, you are not relating a borrow on the input to some borrow on the result. In which case I would recommend to find some other way to do what you want to do (such as the suggestions I made at the top).
The only drawback is that they only offer 2 vCPU for the hosted VMs. Outside of self-hosting, there's no option to use larger machines. 
I've been looking for a place to dump one of my wishes for the future of Rust and this seems like a good thread. But i'm not even sure cargo is responsible for cargo doc..... --- Documentation layout &amp; features have much room for improvement. I know many of us come from other languages and we are very grateful for 'cargo doc'. But being better than most isn't reason to accept it as is. In my opinion docs are becoming too crowded with nightly features and traits that are not of interest in literally 99% of the cases yet combined take up 50% of the space. As an example , i'm pretty sure nobody has ever needed to see these lines on [the nightly cell page](https://doc.rust-lang.org/nightly/std/cell/struct.Cell.html): impl&lt;T&gt; Any for T where T: 'static + ?Sized, Finally, something like [Hoogle](https://www.haskell.org/hoogle/) 's ability to search by function signature would also be awesome. 
You need to tell the compiler that calling `bib.from` must produce a result that outlives `bib`. This is a bound on the type parameter `T`. Otherwise you could ask `convert_bobs_to_cat` for a `&amp;'c bob` and `From` will happily return a reference to `bib`. More specifically you need to say "for *any* lifetime 'a, T implements From&lt;'a Bob&gt;". Instead of "for the caller's choice of 'a" So take the 'a off the function and say `where for&lt;'a&gt; T: From&lt;&amp;'a Bob&gt;`. It's called a "higher-kinded lifetime bound."
Why is this posted on the rust subreddit?
Discord is a privacy nightmare, rust devs energy would be much better spent working on things like fractal, the gtk rust matrix client. 
&gt; a lot of these derives are to hack around the fact the Rust doesn't have proper newtypes I think you are being too generous to the concept of 'proper newtypes'. Inheriting all the attributes would open a giant can of worms, some of which don't have good answers. In the end you would want to tag at least some of your newtypes with what they should and shouldn't derive. And this is equally possible with just a library. Which this excellent library is proof off. 
This is very cool, but it is definitely not as trivial as the Rust solution. Thank you! 
(Note to people who get confused like I did: If there's a "We couldn't find the job you requested" message it's not because the job is canceled but because you need to enable third-party xhr requests.)
Is this a position in the Discord HQ in SF only or do they have other locations or remote arrangements too?
Higher *ranked*, not higher kinded.
Don’t know why people are downvoting you 
I wonder: Is the wasm32-unknown-unknown target of rust using Relooper or Stackifier?
A rather small project to learn proc-macro-hack. Coming from Python I always missed the imperative style to map over iterators using such a function. A lot of Rust code has way too long method/function chains for my taste, and I think postfix await/postfix try would've been less of a topic if not for that.
Please avoid posting bare links to articles not even mentioning the Rust programming languages. Instead, explain how you think the article is related to the Rust programming language: - preferably by using a text post, and linking to the article, - or by commenting on your link post.
I don't know if there is one place with "The Team's Current thoughts". As I recall our conversations there are 2 approaches we want to try. 1. Make more data available through the json. `cargo metadata` and [stabilizing](https://github.com/rust-lang/cargo/issues/5579) `cargo ... --build-plan`. 2. Finding parts of the cargo-lib that subcommands are using ( or copying ) and spitting them out to separate lib. At the intersection of the two approaches is helping the [cargo_metadata](https://github.com/oli-obk/cargo_metadata/issues/63#issuecomment-456981557) crate stay in sink with the types it copied from cargo. This makes it easier to make PR's to subcommands that can switch from cargo-lib to cargo_metadata. At the same time it starts figuring out making cargo-sub-libraries. Help on that would be lovely!
Well... given the massive community currently using Discord, an insider who improved the privacy of users would be valuable, no? Also, as much as I appreciate open source, it rarely pays the bills :(
Stackifier, but the emscripten equivalent uses relooper
I wouldn't judge anyone who decided to work for them, but I agree with you. Closed communication platforms are an unfortunate reality of the centralization of the Internet, and it'd be better to support the efforts of more open, interoperable systems. (Of course I'm biased towards [Matrix](https://www.matrix.org), but I also think we should be preferring centralized services like [Signal](https://www.signal.org) that prioritize user privacy with features like end-to-end encryption by default.
&gt; But i'm not even sure cargo is responsible for cargo doc..... Yeah I'm fairly sure `cargo doc` is just a fairly thin wrapper around `rustdoc`. 
Might make more sense to aim for a product manager kina position on the core product, rather than win32 programming for game integrations, idk.
You can always integrate it via repo mirrors + webhooks.
/r/playrust
Glium should support any OpenGL version. Not sure you'll find a crate for simple shapes because they're so simple to create. Also not sure why you'd want to target 2.1 unless it's OpenGL ES or you're on very ancient hardware.
... in San Francisco, CA.
Very good
Seriously!? That's... Well, ok, I'm just surprised. I hadn't seen that before. In this case, what I wound up doing (after I decided I didn't have a bug that was causing it) was I just ran `.replace("&amp;amp;", "&amp;")` on the results. I guess that explains why Chrome knows about this practice and does that before displaying the results. Thanks for the heads up!
The application POST call is returning a 500 for me. :(
Well, that's pretty cool. I wonder, does it encode crate versions in names in a reversible way?
How long has this been in the making?
Awesome
Because he's telling people to program rust for free instead of getting paid for it, essentially.
Cool, can someone answer these questions I have about mangling? (I might be completely misunderstanding how it works so all these Qs might not make sense) I thought mangling needed to be standardized in order to maintain a stable ABI. As in, if libFoo was compiled with names mangled, then I build libBar that depends on libFoo, they need to both have the same mangling scheme for the linker to work, right? Or am I misunderstanding? With that being the case, what was the mangling scheme that existed before this proposed one? I believe it was compatible with the C/C++ mangling scheme? And on MSVC targets, it was compatible with MSVC-built binaries? If that's all true, why introduce a new mangling scheme?
What about signed crates releases? :)
It's really a shame this is in San Francisco because I have basically no desire to go there. Even though this job description is _literally_ me down to the reverse engineering bit.
Agreed. https://spyware.neocities.org/articles/discord.html
Discord hiring process is a crapshoot. I applied there when they were looking for elixir engineers, and despite a github with 2ish years of steady open source contributions to elixir projects I was rejected without even a phone screen. Reading about other people's experience applying there seems to corroborate that. So yea, apply but don't expect much.
&gt; What’s our budget? As a separate question, it would also be interesting to hear what's recommended for a budget of zero.
The oldest commit in that repo is May 28th 2018, but it appears to be based on older code from 2017 here: https://github.com/windelbouwman/rspython/commits/master
&gt; rust devs energy would be much better spent working on things like fractal, the gtk rust matrix client. Is Fractal or Matrix offering to pay peoples' bills? If not, you're basically asking people to turn down a paying job to work for free.
Definitely not as simple, but it works really well. Most of it is just types that help the editor out, which also means that there's minimal overhead.
Another problem with using the `cargo` crate is if you want to do builds or other things, you are then forcing people to use the version of `cargo` you are built with rather than the current toolchain. I remember one plugin I was using was starting to give errors (or warnings) because of new cargo features I was using but the author wasn't releasing versions in lock step. This is one of the reasons I created [`escargot`](https://github.com/crate-ci/escargot/)
Yeah I wouldn't move to that shithole even from my semi 3rd world country
Give [`escargot`](https://github.com/crate-ci/escargot/) a try. I created it for these kinds of use cases (finding the binary while building using the current toolchain's cargo).
&gt; With that being the case, what was the mangling scheme that existed before this proposed one? I believe it was compatible with the C/C++ mangling scheme? And on MSVC targets, it was compatible with MSVC-built binaries? If that's all true, why introduce a new mangling scheme? The RFC text goes into this: https://github.com/rust-lang/rfcs/pull/2603
There are two useful crates I know that offer derives for enums, [num_enum](https://crates.io/crates/num_enum) and [strum](https://crates.io/crates/strum).
For anyone else curious, iirc this copies the final binary artifact to the `out-dir` rather than changing `OUT_DIR` for the top-level crate. It does not help with other final artifacts (completions, man pages) being generated by a `build.rs` (when properly respecting [`OUT_DIR`](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates)). At the moment, my recommendation is for the generators for these artifacts to be separate `[[bin]]`s. This also means its easier to access the parts of the crate you need rather than having to: #[allow(dead_code)] #[path = "src/args.rs"] mod args; Plus any dependencies `args.rs` has (like enums in other files).
&gt; Some means of specifying dependencies that cargo does not build, even if they're just files. I know this may be toeing the line of "cargo is not a build system." This is a problem I'll have integrating Rust into my company's build. I want a crate to access metadata files for code-generation (e.g. register maps). I don't want to manually check these files into their respective crates every time they change. Not sure what the best way to do this is.
Reach out and ask if they would let you work remotely. If they think you are a good fit they might make concessions.
Sounds like applying for a job almost anywhere.
range() with two arguments doesn't work for some reason
Don't worry! It's on our radar and will be one of the big items for 2019. It's not mentioned here because it is something that needs 'fixing' rather than a big new thing (i.e., it is included under 'technical debt' in the final paragraph). &amp;#x200B; To expand on the purpose of the post: this is about the big strategic goals for Cargo. There are a bunch of other things that should be tackled too, in some cases more urgently than these big things, some of those will be covered in a more detailed roadmap for 2019.
Note that this post is about long-term strategy, it doesn't cover everything we'll be working on over the next few years. In particular we're working on a post specifically about 2019 which includes a bunch of 'small' things as well as the big-ticket items of cross-compilation and plugins. &amp;#x200B; On cross-compilation, I am saying that this is a problem that should be solved, not that it has to be solved in any particular way. That may well be ways to make cross work better or even just doing a better job at pointing people to cross. However, I suspect we can do better by integrating some parts of cross and rustup into Cargo. &amp;#x200B; \&gt; Would Cargo package a C compiler, standalone assembler, linker, sysroot, and emulator/runtime (QEMU, whatever lets you run tests for wasm targets, etc.) like cross already does? &amp;#x200B; I doubt it, but we might be able to make it easier for the end user, for example, by letting them just run \`cargo build\` rather than having to explicitly install cross first.
The \`cargo-features = \["rename-dependency"\]\` line should go above the \`\[package\]\` line. That should do the trick.
&gt;One of the things I'd like to see as a plugin developer is more fine granular cargo-* crates instead of the current monolithic cargo crate, which is a huge(!) dependency. This absolutely one of the things we want to work on!
What exactly do you want from custom profiles? I think that at minimum you would have to edit Cargo.toml for any solution.
Not yet, but there will be! The timeline is that the Cargo team will work on a 2019 roadmap this week and I'll post that and some tracking issues for the work shortly after.
It does not, there is a dedicated crates.io team.
Thanks for these, they all sound like good things to have! Cargo as a library (or more likely many libraries) is definitely something I want to see this year. Post build steps as a plugin is also likely. The others will probably have to wait till next year, but I would like to see them done.
You want the rustdoc team :-)
Whilst not on our long-term strategy, we think that distributing binaries is a key thing to work on this year in the service of the Rust project's wider goals.
To be able to define a `publish` profile or whatever: [profile.publish] codegen-units = 1 incremental = false lto = true (assuming it's not built-in) Why? See the discussion around https://github.com/rust-lang/rust/issues/57968#issuecomment-459945320 and the threads linked below.
So I've actually used the multiple mpsc pattern and benchmarked it. (not publicly and not that thoroughly) It actually performs quite well with Tokio. At least I think it does. 
thank youu!!!!!
Nice! Glad to see it's not just bindings.
Thanks for the heads up, good luck on your efforts and thanks for everything you guys achieved.
Last time I checked Drone didn't support Mac or Windows, did that change?
/r/pcj
&gt; an insider who improved the privacy of users would be valuable, no? Discord makes it's money by [spying on and selling user data.](https://spyware.neocities.org/articles/discord.html) I imagine this interaction has occurred hundreds of times at various privatized software firms: Boss : "Put this spyware / user data logger in here." Worker: "No." Boss: "K then, you're fired. Here's 20 more people that'll do it instead."
I'm not going to blame people for doing what it takes to pay the bills, but /r/rust shouldn't be a job advertising board, especially since any work they'd be doing on discord would be private and contribute nothing back to the community. Work on fractal tho for instance would benefit humanity as a whole tho because it's an open contribution that we could all benefit from, and would have collective social value. Work on discord is wasted time, providing no value to anyone but discord's owners.
How about we not use /r/rust as a job advertising board, and direct people to open projects that benefit the community?
Ah, yes, thanks. 
Another thing you can do to erase the long type signatures is to return an `impl Iterator`.
My concern is that fixing these issues is not mentioned as part of the strategy. It seems like there's no plan to address these issues, to set a deadline for when they should be resolved (I suggest mid 2019), or even a plan to make a plan, or even an acknowledgement that they need to be addressed at all. These issues require major design decisions, which means they're not just bug fixes to wait for PRs for, in between the "main" work that's part of the roadmap. They need time blocked out for them as part of the roadmap.
You beat me to the punch, I was thinking about writing this recently.
I use Azure Pipelines at work (unfortunately not Rust, but .NET Core targeting both Windows and Linux). We have had a lot of really good experiences with their hosted build agents. Also, we have had good experiences when things don't go well if that makes sense. Even though we are not a big company, support was very responsive.
14 days leave aren't really a selling point 
Not at all
&gt; I know this may be toeing the line of "cargo is not a build system." If they're going to go around saying cargo isn't a build system, then the priority should be to get a build system for rust so we can build our code. Or admit that cargo is a build system.
There are good reasons not to impl Into. For one, argument mix up fn something( a : impl Into&lt;usize&gt; , b : impl Into&lt;EnumThing&gt; ) ... But the basic reason is that they are not always usize. https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=58063ef4ec979e6e570cff2d68a7abad
That function can fail even if you aren't using enums. I don't think one should write functions with signatures like that anyway; it defeats the purpose of strong typing if you have implicit conversions everywhere.
Thank you *so* much! After adding `+strict-align` to `features` in my target.json, it instantly started working perfectly.
I'm in San Jose and I wouldn't move there either. It's tough to commute that far as well.
That's pretty normal around here (bay area).
Really? Maybe from more established companies but the startup I work at offers unlimited vacation.
"Unlimited vacation" in my experience is "no vacation" or "whatever your manager is feeling like this week vacation".
I guess, it really depends on management. The last company I worked at (also a startup) also offered unlimited vacation and my manager made sure his employees all took at least three weeks. It's similar here, I was able to take three weeks over the holidays, and I'm not the only one who has done similar. 
How do they handle being sick/working from home in that situation?
They're very flexible about WFH. About half the engineering team is actually remote.
We hated circleci so much we went back to Jenkins. We thought it was *that bad*. 
I'm just starting to learn Rust, so excuse the silly question. Lets say I have to floats a and b, and want to calculate a\^b. I would do this: let result = f64::powf(a, b); And if I wanted to calculate a\^*e*, I would do: let result = f64::powf(a, std::f64::consts::E); But what's confusing is, neither of these next lines will compile! // cannot find function `powf` in module `std::f64` let result = std::f64::powf(a, std::f64::consts::E); // ambiguous associated type let result = f64::powf(a, f64::consts::E); What is going on here?
It's 14 *paid holidays* and 4 weeks of paid leave. Altogether, 6 weeks of vacation.
One reason no such impl exists is that I should be able to implement `Into&lt;usize&gt;` for my enums in a different way than the one your proposing. For example I might have an enum with variants `One`, `Two`, `Four` and `Eight`, which maps them to their respective number. You cannot have this magically work for any enum. Some trait will be required, and I recommend creating your own trait by the name `Cacheable` or similar. Then you could also implement it to allow caching `bool` and other non-enums as well as various structs.
I would love for this not to follow core Python too much but to become a better dialect of the language. There is too much weird stuff in Python that I don’t think should be copied into a clean implementation. 
I was thinking yesterday that if someone wrote a Rust Python interpreter, it could be called "rupee".
An interesting artefact of history I think. Rust has an `f64` module and an `f64` type. Before constants could be associated with a type they were defined in the module by the same name, however these methods are all defined on the type itself, not the module. If you go to the [`f64` docs](https://doc.rust-lang.org/std/primitive.f64.html) it links to the module docs and the other way around.
I like Ru-barb-py better. Barb, because it sticks both languages and holds them together. 
Question, can you import and run rust from python natively in the interpreter, rather than through some hackey imports?
I'd argue that ideally Cargo would do binary caching itself. Of course, that's easier said than done...
Hah, that's an interesting fact of the language. Thank you! But if types can now be associated with a type, why didn't the project deprecate `std::f64` and include `f64::consts` ?
I work at a marketing / analytics -- er, sorry *data science* -- firm in Cincinnati, and we start off with five weeks' vacation (in addition to suck days and holidays). Which is great for most people, but I didn't take any vacation last year and I swear to God everyone from my coworkers to my manager to my area's VP would not stop badgering me about it. At first I thought it was sweet, but I'm starting to suspect they just needed a break from me... 
Python 3.x ?
 fn outer(par: &amp;A) { inner(par); } fn inner(par: &amp;A) { println!("Hello, {}.", par.val); } https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b3ca3ec5079d7b60c211478671d2dc4e Is it bad etiquette to pass a reference into another function that takes a reference without the explicit `&amp;`? For example I could have written `inner(par);` as `inner(&amp;par);`. I'm almost certain it doesn't make a difference, but would it be bad *style* to not be explicit and say `inner(&amp;par);`? Thank you.
&gt; rupee That sounds more like a Ruby implementation.
Requiring that devs rewrite their code - or worse, their dependencies - to be compatible with RustPython is a great way to guarantee it won't gain traction.
(Internal thought process:) &gt; Meh, how good can it be? I'll just hide this post. &gt; &gt; You know what, I'll check it out just in case. &gt; &gt; Oh... oh. Oh, that IS good.
&gt; At first I thought it was sweet, but I'm starting to suspect they just needed a break from me... Many people need vacation, some of them don't realize it or feel pressured into not taking them. They may just want to make sure that's not your case and burn out.
fluent handles bidi data and interpolation by design. 
Is it faster?
That's normal. When you accumulate lots of vacation it hits their balance sheets. It shows up on their corporate reporting as basically a form of debt or liability that investors see. Like one year my company asked everyone to please take vacation and use it up. So you're harming them by not taking your vacation.
I'm working on adding support for the major traits to `libc` [here](https://github.com/rust-lang/libc/pull/1217) to implement RFC2235. Unfortunately I've gotten stuck with a struct that has an `f64` field, which you can't implement `Hash` on easily. If I want to hash an `f64`, what are the available options that the community has rallied around?
Copying from the orange site: &gt; At least 1/3 of Python's CVEs could have been prevented by using a memory safe language like Rust: https://www.cvedetails.com/product/18230/Python-Python.html?vendor_id=10210 &gt; &gt; \- https://news.ycombinator.com/item?id=19064069
Time to get to work?
Well, it's use it or lose it; you can carry over only one week year to year. So the only one really getting harmed is theoretically me. 
I personally would love a mode where my dependencies are built with optimizations but my crate is built without optimizations and with debug symbols. 
No problem! It’s an easy mistake to make.
Why not use the language yield? Its available at nightly Also I wrote this https://github.com/vova616/simple_generators
There is a talk about it at FOSDEM happening later today: https://fosdem.org/2019/schedule/event/rust_python/
Balance sheets are quarterly.
I knew Rust's docs were good, but \*daaaaaaamn\*.
I considered doing this project before but never got further than the name `respyte`. 
Credits will do fine.
I don’t think that’s the case necessarily. No existing Python implementation other than cpython got any traction because none offered something truely new. If ypu stay very compatible to cpython you drag in all the things that tale away the opportunities for optimizations and language design inprovements in my oppinion. For instance the wasm goal is fundamentally not going to be a thing if cpython compatibility should be achieved. 
I honestly just laugh when I see that these little special startups think they need people to move to SF. I am an expert at a specific piece of software that is popular right now and they could double my salary and I wouldn't move to SF. Absolutely absurd.
[builds.sr.ht](https://builds.sr.ht) But you know, it's Rust, so the team will make an opaque decision, behind closed doors, not justify it, ignore feedback, and ultimately pick another closed source option to build the OSS language Rust on. Or maybe a sane decision will be made?
If you need better performance in a piece of your app you could create a rust model that you call from Java
Keeping devs that are active in the community employed is valuable in three accounts, even when accepting that they might not be contributing as much raw code as they otherwise would. First, being able to pay the bills is always useful, and secondly, having first hand experience on what using Rust in production in closed software can be very illuminating on what shortcomings exist and need to be addressed if we want Rust to succeed, whatever that might mean, and lastly, open source code that would otherwise not be written could be written. How many people in the community care about some "older" technologies like XML? The libraries that are out there are generally of high quality, but there are several blind spots compared to other stablished tech-stacks (JVM, C++, .Net, etc.).
yeah, wix is what I use. Wouldn't call it anywhere near easy or intuitive though, still can't figure out how to install a shortcut directly into the start menu with cleanup support or instance
I can learn it for the right price.
I think r/rust should also have a quarterly pinned job posts like r/cpp. These posts are great but are scattered throughout the sub.
In principle, Rust can be used for anything the Android Native Development Kit would be suitable for, such as multimedia or game engines which need to get the most efficiency/performance out of the hardware. It's intended to be a good substitute for C and C++. Making garbage-collected JVM object-oriented-design libraries play nicely with Rust could be more challenging. [Jorge Aparicio's cross-compiliation guide](https://github.com/japaric/rust-cross) is probably a good place to start exploring. aarch64/armv6/arm are all "tier-2" platforms, which if I understand correctly means "yep, probably works but more automated testing of std library would be appreciated." I don't know how "production ready" it is, but the amazingly prolific Pierre "tomaka" Krieger has ["Android Rust glue"](https://github.com/tomaka/android-rs-glue), which I'm sure is worth trying and reading the source. Kotlin is a modern language in many of the same ways as Rust is, and Google is supporting it as a first-choice app development language. I think a lot of the experience and joy you'd get from Rust is likely to translate well to Kotlin.
 [0x08, 0x2B] This control is operated with difficulty using the left upper lift - 12 on a scale of 1-16 "💪"s.
I also had a pretty good experience with Gitlab CI at work. The ability to add you own runners is really useful for experimenting with different build infrastructures, and different hardware. The only thing is that I find their doc a bit messy and/or incomplete sometimes. Also, yeah, it integrates better with gitlab of course.
I've heard really good things about CircleCI from a co-worker. Why did you not like it?
Kiss3d is the only crate that I know that has functions for drawing simple shapes. It's *not* OpenGL 2.1. It is OpenGL ES 2.0. Which may or may not be close enough for you.
Ulysses by James Joyce, 1.48 MB, god bless
Oh I forgot. One thing that really bothers me about GitlabCI is that you have to wait for all the jobs of a given stage to finish for the next stage to start. But apparently, this [might be coming soon](https://gitlab.com/gitlab-org/gitlab-ce/issues/47063). This would be _really_ awesome.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/opensource] [Faster-hex implements](https://www.reddit.com/r/opensource/comments/amlf4m/fasterhex_implements/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
We have all the core pieces implemented, and can fully render monochrome flame graphs \o/ I've also filed a number of good beginner issues at https://github.com/jonhoo/inferno/issues, so if you want to try your hand at writing some Rust code, here's a place to start!
What could a better dialect of Python offer that *would* be truly new? Performance? PyPy is much more optimised than CPython and even though it remains highly compatible, very few people use it. Language design? I don't think minor improvements (enough to make a dialect of Python rather than a new language) would outweigh breaking compatibility with existing code. A dialect with breaking changes, however minor, would at best lead to a repeat of the Python 2 =&gt; 3 transition.
I would argue that you could use Rust for wasm libraries for use in reactjs on mobile platforms. Others are saying you could use it for native libraries too, but don't forget about the web side of things. I think the best use would be for web servers using Rocket and Actix.
/r/rust is for rust programmers. It's rare that companies offer jobs directly to rust programmers, ergo this post belongs here. 
Note that I said [WiX#](https://github.com/oleg-shilo/wixsharp) (WiXSharp), not [WiX](http://wixtoolset.org/). I gave up on WiX but WiXSharp is much easier to use and the README for it includes this: &gt; The package in the Releases section contains an extensive collection of Wix# samples covering the following development scenarios: &gt; &gt; * Visual Studio integration including NuGet packages and VS2013/2015 project templates extension &gt; * Installing file(s) into Program Files directory &gt; * Changing installation directory &gt; * **Installing shortcuts to installed files** &gt; [...]
Ah, that makes sense. I guess I'll indeed implement my own trait then. I was just worrying that I was missing some feature of the standard library. Thanks!
Rupee is India's currency 
/r/rust is for rust programmers. It's rare that companies offer jobs directly to rust programmers, ergo this post belongs here. 
most open source contributors of big projects come from company paid devs, e.g. chromium and linux
The rb still makes it look like ruby is involved.
I'd switch to a dialect of Python that had erasable static types in a second: not for performance, but for correctness. It's probably doable, but it would be a big project.
Why? py is pronounced pie.
https://internals.rust-lang.org/t/which-ci-platform-should-rust-use/9322/18 Just wanted to +1 Buildkite. I use it at work and while we don’t operate anywhere near the level that Rust does, it has been an absolute joy to use.
My impression, is that the team would love to see this happen. We will help anyone who spearheads it. But it is not where we are spending our time.
*Technically* the IEEE standard defines a family of "NaN" values and *technically* they're equal to nothing, not even to themselves. And Rust obeys those technicalities because in theory they could have a type-safety impact somewhere. In practice real implementations often only generate *one* NaN value from undefined operations. (As luck would have it, I was skimming the AMD manual for SSE instructions, and I can confirm that they only ever *generate* one NaN. In particular the NaN which is negative, quiet, and has all zero payload bits.) So it makes sense to flatten *all* NaN values to one canonical NaN which compares equal to itself. Also since +0 == -0, they should hash the same. Probably. Crates `decorum` and `ordered-float` do this with a newtype. 
Just looked at this and couple days ago... It's fantastic
&gt; What could a better dialect of Python offer that *would* be truly new? Eliminating the need for a GIL, for one.
This entry in the `LinkedList` section is great. &gt; * You are absolutely certain you really, truly, want a doubly linked list.
Around line 658 in https://github.com/RustPython/RustPython/blob/892493e464a51e75742ee367057f1e5e4e4c4b68/vm/src/builtins.rs seems to be the "range" implementation for one argument. Maybe submit a pr with the two argument impl? 
I was just thinking of making a python to rust compiler, this is even better lol
I’d call it Pyro
Modelling data using sql is so boring. Graph database allows recursive queries without a separate table, wishing there was a good database to use with rust?
I'm puzzled why the following code doesn't compile ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=790c199f317a23cd45d686ee2b80cb06)): fn f(s: &amp;str) { g(s, |x| h(x)); } fn g&lt;T, F&gt;(_: T, _: F) where F: Fn(&amp;mut (&amp;(T, T), T)) {} fn h&lt;T&gt;(_: &amp;mut (&amp;(T, T), T)) {} Some observations: * Replacing `g(s, |x| h(x))` by `g(s, h)` makes it compile, but aren't those supposed to be interchangeable? * Replacing `fn f(s: &amp;str)` by `fn f&lt;'a&gt;(s: &amp;'a str)` also makes it compile, which is super weird, though then the compiler says that "borrowed data escapes outside of function" and that it will be an error in the future. * `(&amp;(T, T), T)` seems totally arbitrary, but if I reduce that in any way the error goes away. I don't understand what's so special about this tuple in particular.
as a primarily-c# dev, i will advocate for this SO HARD at work... we currently have a linter rule set up that fails builds if someone forgets to write `ThrowIf.IsNull(myArg, nameOf(myarg))` for every argument that isn't allowed to be null. it's SO gross.
New Vector does, in fact, pay people to work on Matrix. But yeah, it is unfortunately very difficult to get paid money doing something useful.
Gradual typing a la typescript? Such a project could even compile to python. Would be great for ruby too, but it's a pretty large undertaking.
This is gonna sound stupid, but I don't really remember. We stopped using it two years ago. I vaguely remember the build times being _terrible_. And I think our builds would break for no reason, and if we reran them they would start working again. Also, you're really limited in what you can do because it isn't a platform you run. Like slack updates, docker container builds and pushes, ... But like I said.. I don't really remember. These are mostly me trying to remember stuff and I might be remembering wrong. It also might have gotten better by now. I'm not sure. In other words, take this comment with a grain of salt. Sorry...
lol, programmers are a dogmatic bunch
Well it seems like the problem is more that retrofitting it into C# doesn't work out nicely with default initialization and other things it seems.
I used pcap and then I think radiotap to parse the metadata (including Rssi) from the packets. 
Ah awesome. Shivered a bit when I first saw it was in perl.
Can you share the repo links please?
I wanted something that works on stable :)
I think "pycrust" is the best option.
It is not, but could be improved. I did a simple test to compare this to 3.6 by doing 100,000 list appends. The rust implementation took over 9 sec and Python3.6 took 0.076 sec. &amp;#x200B; &amp;#x200B; **Rust Implementation** $ time cargo run list_demo.py Finished dev [unoptimized + debuginfo] target(s) in 0.14s Running `target/debug/rustpython list_demo.py` 100000 real 0m9.269s user 0m9.172s sys 0m0.050s &amp;#x200B; **Python3.6** $ time python3.6 -m list_demo 100000 real 0m0.076s user 0m0.064s sys 0m0.011s &amp;#x200B; **Test Script** $ cat list_demo.py list_1 = [] for i in range(100000): list_1.append(i) print (len(list_1)) &amp;#x200B;
Okay that makes sense. I really like your function. How long did it take to learn all that? 
~~Because elsewise programming is not lucrative.~~ Because good practices are invented by greedy people who refuse to share them. See smalltalk and hypercard.
&gt; Finished dev [*unoptimized* + debuginfo] target(s) in 0.14s
Yeah, funding is one of the bigger issues facing FOSS and has been (and probably will be) plaguing it for a while. Unless you have a major project that can get corporate sponsors or something, it's really hard to make it more than a hobby/part time gig sadly.
I don’t have the repo links on me at the moment - but they’re both packages with those exact names on crates.io, and there should be repo links there. 
Rust is pretty awesome and I'm not looking back. One thing that can be annoying/tedious for me is refactoring code. For example, when a struct gains/loses a lifetime parameter it usually requires changes all over the code before it compiles again. It would be nice (but probably not possible) if the case of removing an item with a lifetime parameter would yield a warning about the now superfluous struct lifetime instead of an error, so that I can continue with what I'm doing and check that the changes actually work out - before fixing lifetime parameters in whole bunch of files. (Tip: Replace the removed item with PhantomData in that situation.)
The thing that annoys me the most is how many things use nightly as if it were a badge of honor. I get it, rust nightly is pretty stable, but you don't build production-grade software on an unstable platform if you know what's good for you. That being said, I think that problem will eventually go away on its own, so I'm not a special kind of worried about that.
There's MyPy, but yeah it's not quite the same. Duck typing is honestly my number one gripe with python. 
 $ time ./target/debug/rustpython list_demo.py 100000 real 0m8.375s user 0m8.326s sys 0m0.023s Calling the rustpython interpreter directly saved 1 sec. 
How first is it if you run the optimised version? I would expect the unoptimised version to be slow as bollocks. 
I guess I wasn't clear. You're not running an optimized build. You need to pass --release to cargo run to get a fair comparison. It may still be slower but at least the playing field will be even.
Ahh. Give me a moment while I optimize it to level 3. 
One sec...
Unsafe is really complicated to do right (will never be fixed) and it isn't really defined what you can and can't do in unsafe code (can hopefully be fixed).
I can understand where they're coming from wrt large code bases given how C# is often used. Non-nullable by default is a huge breaking change if you previously relied upon (rather than checking against) billable by default.
Yeah it's interesting and a bit paradoxical how much people who work in modern tech fields are reluctant to change.
I think you can also fix this by updating your Rust version -- you are using 1.30, the current one is 1.32. FYI, adding "[please help its urgent]" to the title but then not giving a reason why it really is urgent (sound like you're just reading a book?) is not very helpful.
Which debugger extension are you using? The LLDB one has a [manual](https://github.com/vadimcn/vscode-lldb/blob/ed956cefe3911bd96e7bbbd5b847a137822d548c/MANUAL.md) that describes some setup steps that might be necessary.
Yeah it is much faster now but python3.6 is still almost 4 times as fast. &amp;#x200B; $ time cargo run --release list_demo.py Finished release [optimized] target(s) in 0.15s Running `target/release/rustpython list_demo.py` 100000 real 0m0.477s user 0m0.421s sys 0m0.035s &amp;#x200B; **Calling rustpython directly** $ time ./target/release/rustpython list_demo.py 100000 real 0m0.303s user 0m0.281s sys 0m0.021s &amp;#x200B; 0.303 / 0.076 = 3.986842105 &amp;#x200B; &amp;#x200B;
Sounds like you want to have a tool that allows you to start the services, run `cargo test`, and then stop the services. That tool could be three lines of make or a shell script. If it's more than three lines and you'd like to write it in Rust, too, have a look at [this post](https://matklad.github.io/2018/01/03/make-your-own-make.html) on how you can use a sub-crate for that :)
see my reply to u/mansplanar
I am looking forward to using this SO much, though not perfect, this will be a game changer for C#, I'm sure. Of course enabling a null-strict mode implies making change to the existing code, screw those people who don't want an _opt-in_ option by fear of having to code more responsibly. 
What things do you run into? At this point, it’s basically rocket and not much else for me.
There are some warts in the language that are unlikely be addressed at all or in the near future. Things like `String`/`&amp;str` could have been better named. I am still unhappy with the error handling story in Rust. I really like the direction Rust has taken but its the details that make me sad. I think we don't have a good beginner friendly way to use and teach multiple error types. You can box things up, convert to String or use things like `error-chain`/`quick-error`/`failure`... all have their pros and cons but i can take quite some time to really explain this to a beginner and in what situation you should choose what. Also `The Book` – i think – is lacking behind in this regard. I havn't thought this through but i would like something like anonymous Enums to have things like fn read_data_from_encrypted_file(path: AsRef&lt;Path&gt;, password: &amp;str, data_name: &amp;str) –&gt; Result&lt;i32, (io::Error | cryp::Error)&gt; {...} I also would like to have something like anonymous `structs` because i often use structs to have something similar like named arguments for functions. I like the way the Vulkan API is constructed and i often do the same and would love to stop writing one time structs for this and have the callsite like render_pixel({x: 200, y: 400, ..Default::default()); I also would like to see a solution in cargo against the `left-pad` "like" problem – you as library/crate author can do nothing if dependencies of your library/crate make errors by correctly use semver. So either cargo gets a functionality to check semver compatible `publishing` or a way for the crate author or user to better specify crate versions (eg in Cargo.lock) ... [see](https://www.reddit.com/r/rust/comments/akpsw5/please_make_the_pain_stop/ef73p9i/)
...or use [just](https://github.com/casey/just) or [cargo-make](https://crates.io/crates/cargo-make).
I would not use the &amp;, personally.
On Windows you probably want Visual Studio Code's C/C++ extension which brings Visual Studio's debugger for native code to VS Code.
What is the benefit of such throws? Just better debugging or something else?
Not really. There's a *lot* to learn, and learning it takes time and effort. It's hardly surprising that people generally don't appreciate that effort being (even slightly) invalidated, *especially* if they don't believe the claims of improvement.
I'm not sure, there isn't really much concepts to learn. Just "Imagine result as data pipeline instead of mutation of locals" and you're fine. For example, How do you get all permutations of length n? You just get all possible permutations of length `n - 1` ant then just do cross join on your alphabet. Repeat until your length is 1 or 0. Permutations of length 0 is an empty set `{}` for every alphabet, permutations of length 1 is an alphabet itself. Permutations of length 2,3,... get inductively. 
I had trouble getting a debugger to work. Apparently gdb works, but I never got used to cli debuggers. Setting up eclipse as a gdb frontend wasn't successful either. In the end, I use `println` and unit tests. I know that it is possible to use a debugger, but I miss something like `cargo debug` or some other easy way to setup a intuitive debugger frontend
&gt; What could a better dialect of Python offer that would be truly new? It’s not necessarily about being new but removing the roadblocks we now know exist. The unicode approach of Python has many downsides, the stdlib cannot be trimmed down because of a few cross depenendciss between interpreter core and stdlib, the GIL cannot be removed due to a few interpreter internals leaking out, the gradual typing support is constrained by the wish to fit it into the existing language, the slot system makes it hard to optimize certain code paths etc. The interpreter is now in a corner where it can only be improved by changing the language. 
&gt; Non-nullable by default is a huge breaking change if you previously relied upon (rather than checking against) nullable by default. I'd assume it's an even bigger change if you were religiously checking against nullable by default: you were expecting and manipulating ubiquitous nullables instead of just assuming things would work out, so e.g. your checks don't work anymore when bare types become non-nullable and nullability has to be explicitly requested. Meanwhile if you were obliviously ignoring the vast majority of possible nulls, the only points you have to fix are when you really want a nullable, or were assuming an API would never return a null but turns out to now return a nullable.
This shit's useless. Nobody uses Python anymore. Just use Java, ffs.
I'd rather move all my code to stable sooner than later. Unfortunately, I rely on a few features that are still nightly only. Those features have become fewer during the last months, but e.g. specialization has been in limbo for a long time.
`packed_simd` for portable high performance code. 
&gt; screw those people who don't want an opt-in option by fear of having to code more responsibly. I mean, that's probably a motivation for *some* but for many I'd expect the issue is it's a literal breaking change. TBF it's only a warning, not a compilation error, but if your CI requires warnings-free code you still can't switch to the new release until the entire codebase has been migrated (or annotated to suppress the warning).
Congratulations, you over engineered it 
[PyO3](https://crates.io/crates/pyo3)
[line 658](https://github.com/RustPython/RustPython/blob/892493e464a51e75742ee367057f1e5e4e4c4b68/vm/src/builtins.rs#L658)
Some are reluctant to change \*period\*, but others are reluctant to changing and re-testing millions of lines of existing code. Real world sucks.
* No trait aliases yet. Especially painful with `Fn*` * Macros can't create new idents. Only proc macros can do that. * Breaking changes with traits and methods are a bit *tricky*. * Orphan rules. I understand why they are in place, but hopefully they can be relaxed in the future. * Avoiding allocations without allocators in `std` is very cumbersome. * Also I wish that the whole rust compiler would consist of separate semver crates to make tooling easier. `mir = "1.32.0"`
Hm, I currently started using CircleCI for a client and was really looking forward to it. In summary, I found it a huge let-down. Not the runners themselves, but the whole product around it. Bad interface, lack of control and weird ways of approaching things like builds across multiple repositories. It really makes us more work then worth.
My biggest pain point is IDE support. Rls is good and all, but every time I use IntelliJ Java one day I remember just how far we have to go. Even though it's all small things, like auto-import on auto complete, all of those small things can build up into a big difference. --- As for the rust language itself, there isn't really anything I currently dislike. There are tradeoffs, but I like to believe I understand the majority of them, and I agree with the may the team has decided things. There's a lot of thought put into every decision, and it really shows (in a good way).
Making GUI and Custom Graphs makes you fight the borrow checker 
* Failure, error chain, and the million ways there exist to handle errors so that code can interoperate. Error handling is hard, but this is not a solved yet. * lack of const generics - try deriving some trait for a struct containing an array with more than 32 elements. * lack of portable stable SIMD. * how long some libraries take to compile, no system wide crate cache, etc. * how much memory rustc uses when compiling some crates * how much HDD space rustc artifacts use (20gb target directories) * lack of custom DSTs, particularly a CStr type that actually works * unit testing wasm32 isn’t easy * testing for cross platform compatibility of libraries to all targets that Rust supports isn’t easy * poor support for using / generating GPUs native “binaries”: SPIRV, PTX, etc.
Might as well fail fast on something that's going to fail anyway at some point.
I really \*really\* REALLY wish I could split my code in multiple files without being forced into modules and module paths.
What’s the ram/resource efficiency though?
This is pretty good coverage of all the issues 👍.
Rust is following the lead set by every modern language I can remember. For example, Python works the same way (albeit, with `__init__.py` and `import` instead of `mod.rs` and `use`), as do JavaScript module-loading APIs.
You can use `mod x; pub use x::*;` to re-export everything from a submodule. You can also re-export from anywhere so you can make your public structure different from the private one entirely.
Is there a problem if you just pin your project to some version of nightly? For example nightly-2019-01-28 or so?
For now, the job ads don't disturb too much, so we generally allow them. On /r/java, we forbid them, because otherwise we'd get fifty job ads per news posts. But I'd guess it'll take /r/rust a whlle to get there.
Work is being done on that front. There are efforts to develop a model for how `unsafe` works so there can be a solid spec. I'd suggest taking at look at https://www.ralfj.de/blog/categories/rust.html
To be fair, PyO3's *raison d'etre* is to provide a nicer API than rust-cpython (which works on stable and which it was forked from) and it needs nightly features to do that.
I don't think many people would port their code to a new dialect of Python due to better Unicode (didn't we try that once?) or a trimmed down standard library. As above, optimisations wouldn't help either - they've not helped PyPy. As for improvements to optional typing support, I'm personally not convinced that this is a good direction for Python at all. IMO if people want static typing, they should use a real statically-typed language. OTOH, it's clear that removing the GIL and supporting true shared-memory parallelism would be a huge step forward for Python. Perhaps that would be enough to move people onto a new dialect?
Have you tried [gdbgui](https://gdbgui.com/) as an alternative to Eclipse? It's not as convenient as a `cargo debug` would be, but it has [explicit instructions](https://gdbgui.com/docs.html) for how to debug a Rust program.
Python consumes way too much memory due to it’s unicode model and working with hybrid text/byte protocols like http is very inefficient. Likewise the GIL cannot be removed without reshaping the language. WRT static typing: people want gradual typing in the Python community same as in the JS community. TypeScript got popular because it enables auto completion and catches many errors before running the code. 
How about ruspy 
So, it sounds as if you like the idea of gradual typing but not the current design/implementation? I'm curious to know what you would do differently?
I think that's why they provided is as an opt-in feature. By default, you're not even allowed to write \`string?\`, the compiler will tell you that you didn't enable the correct flag. It's non-breaking to upgrade to 8.0, even in terms of warnings.
Oh, that is cool! I’m still wondering why this is necessary, because LLVM should already know that it needs to do that on an ARMv5 architecture.
Nice and sad to hear at the same time. I know some companies that didn't want to switch to Rust because of it. Would be interesting if those companies would spend some time adding it. I'll talk with them and hope that it allows to get something concrete done.
Tbh I'd love that they somehow implemented the same “everything’s an expression“ behavior that exists in Rust, though I believe it wouldn't be easy to get it right, syntaxically speaking. This simplifies so many initialisation issues, I wonder why not all programming langages did it right away.
so when there are no mutable inputs, the only mutation would at least be marked by unsafe{} blocks (i.e. access of globals).. those would usually have wrappers hence places where they could be instrumented. I realise IO might be happening. I guess it would take a more ambitious effects system to track that..
Install rust-src with rustup.
Well... now the question also is, how did you compile Python :) Also, the way you run it, I'd imagine that about half the time the test code spends initializing the runtime, so, it's not a very useful comparison.
Data pipeline- a string of verbs? So by the time the permutations have a length of 2 they generate 2 digit strings? And it generates these and joins it for each of the ones above it to produce, say, 3 digit? (Like a zipper?!)
I don't think this should be a compiler feature. Seems like a job for something like `cargo fix`
No. This is way too early to talk about performance in any way. This is still missing huge chunks of the standard builtin Python APIs; you can't even do `range(5, 10)` yet. Correctness is also a huge stumbling block when writing and optimizing a basic Python interpreter. For now, it looks like RustPython went with a basic clean implementation. They lack the most fundamental optimizations that CPython has, like pre-compiling locals access (so you don't need to use a hashmap for every variable access in a function) and small integer cache (so you don't need to allocate on every numeric operation).
Nope, that's not an explicit goal (it uses an opaque hash made from information that Cargo generates and passes to rustc, which can depend on way more than just version numbers - Cargo package featuresets come to mind).
Lack of const generics, lack of alloca (can't allocate a DST on the stack), lack of inheritance/subtyping and lack of const fns. Const fns and const generics are probably going to be resolved this year, but I doubt the other issues will be.
Thank you, this was not only an effective fix for my problem, but also a lot to chew on and learn from.
Why would you want to split code without splitting it into modules?
[Null References: The Billion Dollar Mistake](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)
&gt; every modern language C# or Go do not really work like this. And IIRC, in practice most languages that do work like this support relative paths, i.e. if I have two files named A and B in the same folder, I can refer to A directly from B simply as A. I feel Rust made almost all the wrong decisions on this topic, the Rust book barely touches this as an afterthought (https://doc.rust-lang.org/book/ch07-02-modules-and-use-to-control-scope-and-privacy.html#separating-modules-into-different-files), and the improvements in 2018 barely help.
I know I can, I just feel that making *have to* was the wrong decision, and something I definitely do not like about Rust.
And yet thousands of programmers were doing just fine with it.. Perl is a fine tool for many tasks. If anything, programmers may shiver at a Rust implementation of something that was good enough in Perl because the end result is feature parity and performance improvements that don't make life much better.
&gt; Use a `LinkedList` when you want to efficiently split and append lists. I don't understand why they say this. `split_off` completes in O(n), which doesn't count as efficient in my book. How did a linked list implementation with the performance characteristics of an `ArrayList` end up in the standard library anyway?
Rust libraries (built by rustc) are ABI-unstable (compatibility not guaranteed) between Rust versions (even between nightlies or individual Rust builds), and this will remain the case for the forseeable future. rustc will error if you try to use libraries built by a different (older/newer) rustc than itself, and you can't do anything involving Rust library APIs by involving a linker without rustc knowing. Also, linkers tend to not care about mangling schemes, other than maybe having a demangler for error messages, and limiting the characters that can appear on symbol names. The previous "mangling" was a hacky thing built on top of a subset of the Itanium C++ mangling, but didn't do anything different for MSVC (neither does the new mangling). We don't care about being compatible with anything else because we don't have e.g. C++ interop or anything like that.
Compile times
&gt; Does your convert_bobs_to_cat need to be generic over the return type? At the moment, no, but in the long run yes. The contrived example was an oversimplification of another problem I'm having, and the higher ranked lifetime is indeed the solution I was looking for. &gt; I'm still learning about higher ranked lifetimes myself... It wasn't even on my radar until today. I think I'll be learning this one for a while too.
Dang, you're right. How bout PypyRus? 
Turning this on for an existing codebase results in SO MANY errors when you compile, but in reality they were all errors already, just waiting to happen at runtime. It's a great feature.
In Go I have the opposite complaint where I'd like to introduce more packages for the privacy boundary but I don't want to have a dozen single-file directories. :P
This. 
Lack of inheritance/subtyping is a feature, not a bug, and will hopefully never change. The others are definitely major pain points though.
Because I like having more flexibility to deciding separately about logical structure (modules) and physical (files).
Why would you expect it to be? Making an interpreter fast is going to depend far *far* more on optimisations specific to interpreters than it is on the underlying language.
That is probably a fair complaint to have about Go packages. I personally have not found much value in fine-grained, many-levels privacy inside a single high level unit (crate, module, library, what have you) even in very large projects, but YMMV.
I love C# I really need to get some formal education under my belt for modern C# as opposed to just the "what I've picked up over the years"-knowledge I have now, so that I can make sure I don't learn old pre-NET Standard 2 garbage. Modern C# is a fantastic language from all I ever hear about it. 
It's python &gt;= 3.5. f-strings also don't work, yet
I suppose I can see some theoretical merit in that, but practically, I can't think of an example where it would be a problem.
Good point. There are multiple error-reporting types because they all have some limitation — for example, `failure` claims: &gt; failure is **no_std** compatible, though some aspects of it (primarily the `Error` type) will not be available in no_std mode. ... which makes it mostly useless for `no_std`.
The module system. It seems unnecessarily complicated with lots of repetitive rituals that you have to do in order to make things work.
It works quite well in Visual Studio Code. You can even insert the use statement by clicking on a link in the error message popup.
["It's better fix errors than prevent them."](https://signalvnoise.com/posts/2440-we-all-know-the-saying-its-better-to-ask-f) If the function fails when it's called with null, why was it called with null? The error is in the caller, not the callee. Defensive coding as described above ignores performance. People wonder why their code is slow when every single function starts with a branch. 
One thing I’m currently thinking about is how to make a huge state machine. It'd be useful to make a large enum out of all of the states, so they can store their own sub-state information. However, then the whole state machine has to be contained in a single file, because you can’t expand an enum from a different module.
Can’t change output type of comparison operators. Can’t (easily) sort float. And no const generics. I work in a niche area so those issues probably aren’t a big deal to you. 
It isn't a feature. Rust had virtual structs pre-1.0 and there's an RFC for fields in traits. Currently rust has no way to express that a certain type extends another and thus a function that worked with the base type can work unmodified with a type that extends it. Composition over inheritance != Composition instead of inheritance.
I would suggest the GitHub issue tracker, but you already filed [an issue](https://github.com/intellij-rust/intellij-rust/issues/3331) there. 
The most annoying syntax issue for me is that you can’t combine multiple `if let` into a single statement or combine it with boolean expression. I get really deep `if`-chains pretty frequently. Also, the orphan rule is pure horror. It adds huge overhead to my code, because I have to convert between similar structs of different crates all of the time.
Things like [this](https://github.com/rust-lang/cargo/issues/5364), where the Cargo team are not producing the kind of that solution most users seem to want. But to be fair, there are currently a number of issues regarding feature flags which could do with fixing: - default features don't work very well, since many crates simply enable them whether or not they need them - `no_std` mode shouldn't be configured via feature flags; a build-wide `cfg` would be much better - discoverability of optional features is poor since rustdoc does not automatically document this, and attempting to use disabled features does not hint to enable them
Especially when the underlying language is either Rust or C. If the implementation is written in Ruby, not so much. 
To me, modules are about: - namespacing: having different elements in a program share the same name without conflict. - privacy: controlling visibility and access among different elements in a program Whereas files are nothing more (and nothing less) than a way to store, access, compare, explore and manipulate source code without language-specific logical level tools (class browsers, semantic merges, etc). The tension between the two is resolved very differently in different languages, with various levels of sophistication (or struggle, see *ahem* C++ modules), so it's normal to have different opinions and mileages about this based on your experience.
You can define each state as a `struct` in a sub-module, then have the enum be of the form: enum States { State1(State1), State2(State2), .. }
Haha alright. There will always be someone who will claim even the most esoteric tool "good enough" and that it's fine for doing something. But as you say though it's probably useful for something. Re: rust implementation, it would be nice to not have to install the entire PERL system to run one tool, especially when most system tools have are written in Python or something.
By "expand enum" do you mean "add new variants" or do you mean "split definition of enum and the implementation"? You can do the latter, and it's probably a good thing you can't do the former.
Yes, but then I have two places where I have to add new states. In my code, I ended up with four places, because I needed one enum like the one you wrote, one with references to the structs and one for deserialization via serde (which needed some special handling, because not everything is serializable). In the end, I'm probably just awkwardly working around the lack of inheritance by doing all of this.
I'm referring to the former. It might work if you restrict it to sub-modules of the enum's module, for example.
I don't like how hard - and sometimes impossible - it is to make what should be simple wrappers around boilerplate code. [For example](https://www.reddit.com/r/rust/comments/9hpt2z/implementing_generic_struct_for_any_lifetime/). This is usually due to lifetimes expressiveness limitations...
The stuff that's bothering me right now on my current project: - Build times. I'm up around 4+ minutes. - Debugging. Release builds, even with debug information, strip out nearly all variables, making the debugger almost totally useless. - RLS is painfully slow. It's so slow that when I want to find out if a change is correct, I can Alt+Tab to a terminal, type `cls &amp;&amp; cargo check`, wait, read the results, Alt+Tab back to my editor, and RLS still won't be finished. - UIs. I've given up and am learning WPF. I'd have settled for TUI, but even then nothing seemed to want to work on Windows, so C# it is. - The new pattern "ergonomics". It's like trying to jog with your shoelaces tied together. I don't think I've ever hated a change to a language as much as this.
Out of curiosity: Does it have a better/more flexible API than CPython? One that allows multiple instances and sandboxing?
Interrstingly, this is one area where PHP is pretty nice. They have pretty extensive support for (optional) type annotations that will throw runtime exceptions if the functions are called with the wrong types. They keep expading on which types can be used in annotstions, and I believe there are propisals to add static checking.
this is strangely fascinating could see it useful for embedding Python scripting in, for example, a game written in Rust, without having to depend on anything external—so easier cross-compiled, webassembly etc
Now I'm no expert but isnt that just how lists work? You have to go through N-1 elements to get to element N? If you want to walk through pointers to find the next element in the list, thats what lists are for. If you want better thats what every other data structure is for?
&gt;I really \*really\* REALLY wish I could split my code in multiple files without being forced into modules and module paths. &amp;#x200B; I didn't like this at first but these days you can \`\`\`use super::\*\`\`\` etc to flatten it where you want
Python ia one of the 3 most popular programming languages, and you think nobody uses it? A *lot* of people use it, and it is growing in popularity...
The things that stop me writing Rust right now are a lack of variadics, const generics and dependent types. I don't *need* any of these things, but they stop me being motivated enough to write a lot of Rust.
So you want distinct `debug`, `release` and `publish` build modes?
That's why I found it funny :)
My wishlist: \- values as type params, whatever you call it.. the ability to put buffer-sizes/dimensinos etc into type params \- streamline trait impl's by omitting the types.. get them inferred from the trait decl, as happens with haskel type classes. \- default+named args rather than builder patterns/making wrappers (cuts down on the number of functions to browse.. GUI, tensor APIs etc usually use this \-lack of auto-borrow for operators. &amp;#x200B; HKT would be nice but I dont grudge it's absence. &amp;#x200B;
AFAIK, Rustdoc is deprecated (development stopped) by a new tool in beta state.
It works even if you don't restrict it to submodules, I think. IIRC, the limitation is that you can't write an impl outside of a crate that defines the type.
At least. `publish` could be built-in or not. Somebody implemented it, but it wasn't merged because the Cargo team wanted to move away from build profiles.
That `mod.rs` are called that instead of `_mod.rs`, so they would stop messing with the file ordering, and also would be easier to spot (since they would likely be right below the folder name).
I used to have deep `if let` chains. Now I don't. Not sure if it's b/c I'm working on projects that don't require them or if it's because I'm handling errors differently (i.e. I use `?` frequently and define functions that return `Result`s now more often than I did in the past)
My line of thought was rusty python -&gt; RuPy -&gt; Rupee
This highly depends on the way you try to construct these. You can mostly avoid those problems with something like an ECS – but generally speaking you just use something like an index into e.g. a Vec for your storage. You really need to think more about the way to handle the ids, but generally you can solve many problems in this space like [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b64ddde921bbe5fdd115860ee766654d) ... we often see this in games code etc.
Note that I said "every modern language **I can remember**". (emphasis mine) I have never used C# because I don't develop Unity games or Windows-only applications and found Python to be better-suited for writing portable applications than C#. (Especially once it became clear that I'd be developing all my future-proof GUI applications in Qt to avoid the direction GTK+ 3.x has been going on the UI front.) As for Go, I looked into it but was driven off by the horrendous lack of proper dependency management and the lack of support for metaprogramming and generics. Because I loathe the drudge-work of writing needless boilerplate, I decided to stay with Python and Node.js for network programming while I wait for Rust's async story to mature.
What things aren't really defined? I agree it can be really complicated, but I haven't run into trouble with it not really being defined.
Rust has a special syntax for enums with no values attached to their variants which allows you to do what you want. It is documented in Rust Reference, see https://doc.rust-lang.org/reference/items/enumerations.html#custom-discriminant-values-for-field-less-enumerations
I tested it on my machine and I believe Python is probably making some sort of optimisation that rust version doesn't. Rust version takes more time and one core gets pinned at 99% for the entire duration of program. Python takes 1% cpu and finishes early. 
this name is [already occupied](https://crates.io/crates/pyro)
You need a separate enum for deserialization? It sounds like you could [manually implement Deserialize][1] in order to make this easier. As for the rest, you can probably create a macro which could remove most of the boilerplate and duplication for you. If you're new to macros, I'd be happy to show you how they could achieve this. [1]: https://serde.rs/impl-deserialize.html
There was a RFC to allow chaining of `if let... &amp;&amp; let... &amp;&amp; let... ` but I don't think it got merged.
That's pretty much what I ended up using as a workaround, but it's not really optimal to have to do this.
Yes, there's a workaround for it that looks like this: `if let (Some(a), Some(b)) = (fna(), fnb()) { … }` but it has the same problems as format strings, the lvalue and rvalue aren't next to each other, making this hard to read. This is an actual snippet from my code: `if let (Some(c1x), Some(c1y), Some(c2x), Some(c2y)) = (obj.get("c1x").and_then(|c1x| c1x.as_f64()), obj.get("c1y").and_then(|c1y| c1y.as_f64()), obj.get("c2x").and_then(|c2x| c2x.as_f64()), obj.get("c2y").and_then(|c2y| c2y.as_f64()))` All it does is to extract two two-dimensional points c1 and c2 from a parsed JSON file.
@jonhoo: Now for talks/blog posts about using the tool to profile, identify hot spots, and techniques to optimize? You did this ad-hoc while writing inferno, and that was valuable instruction, but these nuggets are buried within hours of video.
Basic const fn has already landed. More work to do, of course....
Papyrust
* Compile times * Compile times * Compile times Yea, that's it. I mean the language itself isn't perfect, but neither is any other language. Rust is a much better alternative to C, that's for sure.
I think that variadics with a nice syntax could already be implemented as a library. You know, something like this: `#[variadic]` `fn sum(num: f64, args...) -&gt; { num + sum(args...) }`
This is a library, so it's kind of hard to say for sure. Maybe somebody will need it? But I certainly can't think of a place where I'd need hex decoding to be 2.5-10x and be willing to add more `unsafe` code to my project to get it. It gives me flashbacks to the time the base64 crate had a security vulnerability because they decided to make the tricked-out optimized unsafe version the default.
&gt; The thing that annoys me the most is how many things use nightly as if it were a badge of honor. Really? Which nightly-only crates are wearing that status as a "badge of honor"? &gt; I get it, rust nightly is pretty stable, but you don't build production-grade software on an unstable platform if you know what's good for you. Actually, pretty much everyone else gets this too, as far as I know. The most prominent crates that are nightly-only are _trying_ to get to Rust stable. Each project has different constraints. The number of nightly-only crates has ***substantially*** decreased over the years.
I think `n` for `split_off` is the index, not the length of the list. Also, `split_off` on, say, `Vec`s isn't much nicer - for lists you traverse first `n` elements, for `Vec`s you copy the rest into new storage. May or may not be worse.
As far as I know, we don't have an authoritative document anywhere that exhaustively details what's UB and what isn't. AIUI, this is being worked on. See [this](https://doc.rust-lang.org/reference/behavior-considered-undefined.html) and [this](https://doc.rust-lang.org/reference/memory-model.html) for example.
You can do this with [`include!`](https://doc.rust-lang.org/std/macro.include.html). Of course, using `include!` to structure your modules would, I hope, not pass code review. In any case, I think Rust made all of the _right_ decisions here. Modules are a dream to work with.
Shouldn’t `range()` be a lazy generator according to the Python 3 standard? This seems to be exhibiting the old Python 2 approach of generating all values up front. 
&gt; Now I'm no expert but isnt that just how lists work? You have to go through N-1 elements to get to element N? You're right, but the scenario for a split is often that you "are" at the right pointer and basically want to call `split_here`, which `LinkedList` doesn't support. For some reason I forgot to mention that in my last comment 🤦‍♂️
Papyrus?
The changes that would make the language sane and JIT compilers able to compete with V8, like * compile-time defined classes (only; including metaclasses and operators) * removing threads or introducing strict rules * checking for usage of undefined variables at compile time in a viable way already make it an entirely different language, though.
As much as C++ syntax is kind of a mess, I very much like how variadic generics are handled in it. Parameter packs and so forth are very easy to use. Combined with a little recursion and `constexpr` functions and it's almost ideal. I think that aside from integrating it with traits and lifetimes, I'd be totally happy with just straight up copying from C++ in this regard.
Since this uses `unsafe` under the hood, you really should fuzz the code with `cargo-fuzz`. It's really easy to set up, see https://fuzz.rs/book/
Is there a reason why most intermediate compiler artifacts can't be run through `lz4` or some kind of bundling stage?
It's a troll, don't feed it.
Yeah, I've been using C++ for at least 6 years now, and the way parameter packs are handled is great, IMHO.
I prefer this variation of FnBox: https://github.com/rust-lang/cargo/blob/d4af22356a4836bac3b1c5de9115eec348d97628/src/cargo/core/compiler/job.rs#L17-L25
I'm guessing that was sarcasm.
When is using `Any` a reasonable choice? The docs say it's for emulating dynamic typing, but when does one really need it? I'm personally not a fan of this approach, but I don't like to be dogmatic about it, so I'd like to understand when it's actually a reasonable thing to do (as an aside, learning that Haskell's standard library uses dynamic typing for its exceptions was when I said 'screw this, I'm outta here').
Holding pointers or mutable references to linked list nodes would prevent any further interaction with the linked list in Rust because you can no longer guarantee data race freedom and non-aliasing rules. A generational index based linked list might be an appropriate way to deal with this problem, but I haven't ever used a linked list in Rust from any library or the standard library except indirectly through slotmap, slab, lru_cache, and some other data structure crates that wrap pointer/index based linked lists (not stdlib ones, but literally just indices or pointers, rather than using a library).
There’s the [Rust plugin](https://intellij-rust.github.io/) for IntelliJ. I haven’t tried it, so can’t speak to it. 
Have you used the intellij rust plugin? It's really quite good.
It's definitely a code smell of some kind that goes away with experience. I think it's usually caused by trying to do things at too high of level, or trying to do too much at once, and repeatedly having to dig deeper into structures in a single function, rather than splitting the code apart and assigning it where it's relevant. 
For a definition of spyware which equally invalidates every other popular service on the internet, including the one we're using to communicate right now...
The cult around it. Which means discussions can get very noisy and the hive mind is quick to silent anything someone managed to downvote first.
To be fair, that example would benefit more from a simple 'retrieve value and convert to f64' helper function than additional syntactic sugar.
GNU Parallel is also in Perl and it works just fine for most people. Of course, [the Rust rewrite](https://github.com/mmstick/parallel) has much lower overhead, which matters if you have tons of short-lived jobs like I did.
&gt; Rust doesn't have proper newtypes (that inherit all the attributes of the underlying type) In which language have you seen this behaviour? Haskell and Idris support new types. In both cases newtypes do not of automatically inherit the attributes of the underlying type. There is good reason for this: multiplication makes sense for an Double, but it does not make semantic sense to multiple a Height by a Height. (It would make sense to have an `area :: Height -&gt; Width -&gt; Area` function of course. ) The standard for newtypes is that the _compiler_ should strip away the type information such that, for example, in assembly Height “objects” just become doubles and the area function compiles to something identical to `area :: Double -&gt; Double -&gt; Double`. However in every language I’ve seen, at the _parser_ level they are treated as different, and do not inherit underlying behaviour except in those cases the programmer explicitly enables. This ability to opt-into only a subset of capabilities deemed semantically sensible is what makes newtypes useful.
That would be a specific solution to a generic problem. There are a lot of variations for the `y` part of `if let x = y`.
I can think of a few specific things 1. When using 'cargo install' there isn't an intuitive way to update the installed packages. You have to 'cargo install -f' to overwrite the old one with the new one. I'd previously had some frustrating issues that ended up being because cargo-xbuild wasn't up-to-date, and when everything else can be updated with either 'rustup update' or 'cargo update', it's easy to forget about it. 2. Better support for basic conditionals in const fns. Basically, I'd love to be able to enforce some basic invariance in types that can otherwise be const. 3. Language-level or std-level support for compile-time assertions. I know there are ways to do this, and crates out there that will do it, but it is ugly and it doesn't feel like something I should need an external dependency to do.
What would a good module system look like, in your opinion?
You don’t need these things to improve jitability. 
congrats. wait until the borrow checker welcomes you..
Strange to consider not having variadics as a lack... It's quite a mess in C/C++. It can be emulated through macro, which I find much better and a lot less error prone.
Looks better than wix yeah, but that's even more deps needed to build a package. Wix itself is annoying enough, you have to enable an older version of .net to run the installer, all of which amounts to a single "install" button. Why they don't build an msi, especially since thats the whole point of wix, escapes me
That sounds like a good candidate for s config variable in cargo. 
I think this is being fixed - you'll be able to have foo.rs with a folder named foo containing submodules.
You can fake this with `use super::*;`. Or just do what you're supposed to, and `use super::{A,...};`. There's also the `include!` macro if you want to ignore privacy boundaries. Most people writing rust don't seem to have an issue with the current system though.
&gt; UIs. I've given up and am learning WPF. I'd have settled for TUI, but even then nothing seemed to want to work on Windows, so C# it is. Sorry for dumb question, I'm very new at this GUI stuff.. Does GTK not work on Windows? I'm currently using gtk-rs on Linux and I'm around 2kloc right now, and it works nicely for me.
https://rust-lang-nursery.github.io/rust-toolstate/ might help. RLS is broken more often than not, perhaps you could try https://github.com/rust-analyzer/rust-analyzer/. It's not really great yet, but it's better than nothing.
&gt; The new pattern "ergonomics". It's like trying to jog with your shoelaces tied together. I don't think I've ever hated a change to a language as much as this. Can you elaborate on this? I'm not following the developments too closely and I have no idea what this is about.
No argument there. To be honest, I'm of half a mind to just say "Forget MSI. If an InnoSetup `.exe` is good enough for GOG.com, it's good enough for me," since it's trivial to install, matches or exceeds WiX# for common use cases, and even has a [3rd-party NPM package](https://github.com/felicienfrancois/node-innosetup-compiler) for incorporating it into build automation which supports running it inside Wine for cross-building installers.
You can create a tuple and `match` against it like this: match (val1, val2) { ('A', 'B') =&gt; { } ('B', 'C') =&gt; { } _ =&gt; { } }
gtk on windows is kinda painful in terms of distribution. This seems like a popular topic, I might write a post on it later
Naming collisions are handled inconsistently though. With use they are handled by not propagating down. With everything else it's handled by lexical scope. Couldn't we just have a use declaration in an inner module shadow the one from the outer module? This would be consistent with how variables work.
It seems more consistent, it would just mean that use uses lexical scope just like variables.
My ideal program would have a simple file listing an icon, source files/directories, and the target directory for each file/directory (defaulting to copying the source directory structure if not specified). It would then take care of shortcuts, uninstall cleanup, upgrading, and detecting x64 vs x86 binaries and choosing the right Program Files location. Extensions to bundle specific native libs (gtk, qt, etc) automatically would be even better. If it's simple to write msi files, this would be a great thing to have on crates.io so no 3rd party tools are needed
The compiler should do this automatically though you should file a bug.
LLVM or rustc?
Excited for the day when Discord merges with the Rust project and we all become gamers
There are already many good comments with things that are still missing. I'll make a list of things that exist but I wish were different instead: * Rust is moving a bit too fast. * I wish backwards compatibility weren't broken for aesthetic reasons, but only for soundness fixes. Other changes should only go in editions. * In a similar vein, editions aren't really backwards-compatibility. They are inter-language-version compatibility. Which is great, but different. * Editions should only be used as last resort to fix necessary things, not as marketing tool and not as call-for-proposals. * Non-public code and tooling outside of the Rust community should be considered more when making decisions. * I find 2018 modules/paths more complicated than their 2015 versions. * Invisible deref coercions mean: * It's hard to assert something results in a specific type. * Assignments, type constructions, returning a variable and so on can panic. * Default binding modes means patterns hide their reference semantics. * I liked `extern crate` * External dependencies simply show up in scope as symbols without a marker or any import. * Design discussions shouldn't assume every user uses a powerful IDE, or even syntax highlighting. * Design is sometimes way too opinionated for my taste. Rust should be a tool, and not every usecase will fit into a premade story. * Many panics should be more explicit. For example, many math overflow panics should probabl be some form of out-of-range errors instead. * Argument position `impl Trait` is the third way we have to write type parameter constraints. * Documentation is too web-centric. It would be great to query it from the command-line and other tooling. * Negative and policy RFCs should be a thing (to decide things like IDE reliance for features and such) * I wouldn't be surprised if this list gathers some downvotes. I guess these are my big ones. Disclaimer: Rust gets a lot closer to excellent than any other language for me. These are simply the things that would nudge it even further towards that.
Last I tried it, it wasn't compatible with the MSVC toolchain (which I'm using for debugging (at least for the bits that work)), and looked even worse than Gtk 2 did. AFAIK, it also can't be packed into a single executable.
The compiler was changed a little while ago to effectively automatically insert `ref` and `ref mut` into pattern matches where it thinks they're necessary. I loathe this because it's basically invisible code I didn't write with semantics I don't expect that breaks my mental model of what my own code is doing. It means I'm paranoid about every pattern match in my codebase now, because I'm never entirely sure if it means what I think it means.
Especially on Windows. RLS is so slow there that sometimes I can tab out to the docs of a crate, search whatever I was looking for, go back to the code, add the method/field reference, and do a cargo check before RLS even pops up with outdated errors and still no autocomplete. That's a net of zero productivity gain. On the other hand, my laptop with a weak dual-core CPU but running Linux gets nearly instantaneous autocomplete and it can point out errors on a line before I'm done typing the next one...
I would try rustc first but they make kick it up.
Rust borrows several of Haskell's niceties, but doesn't borrow enough of them.
&gt; lack of thin virtual pointers Not sure about this one. I have never seen a use case where thin pointer would be superior against Rust's fat pointer.
Json implements `Deref` and `DerefMut`, so you can get `&amp;EmailData` or `&amp;mut EmailData`. There's no method to get `EmailData` off it. I believe this is because the inner struct might be able to reference the response itself. It doesn't look like you have any reason to need the `EmailData` to be owned though, just a reference should work fine. 
ATCs? 
&gt; Language-level or std-level support for compile-time assertions. I know there are ways to do this, and crates out there that will do it, but it is ugly and it doesn't feel like something I should need an external dependency to do. This will probably arrive through the ability to raise compilation errors by panicking in compile-time `const` evaluations, so I assume this will get better in the not-too-distant future.
I think anonymous enums would be the best solution for error handling too. Enums with From impl's are basically at the moment, except for the amount of boilerplate required to implement them. Anonymous enums would solve that.
&gt; any issues with tooling, Compiler is kinda slow. I'm glad I'm not married to IDE "workflow" because while Rust is a joy to write in a minimalist editor I hear IDE support is not quite there yet. &gt; portability, Excellent when working with the standard library, seems to be a high priority for many other libraries. &gt; breaking changes, The language is careful to not make promises that are hard to keep. Very stable. Biggest gotcha is that if you are tempted to use experimental features those can and do change. &gt; or other gotchas? It will ruin you for other system level languages. I never fell in love with C++ and I think I'll now try to avoid writing C given the choice. &gt; In addition to things which are currently a problem, are there certain things that may likely *always* be challenging due to language design decisions? Yes. You will always be heavily encouraged to not only prevent use-after-free, data races, iterator Invalidation, etc. etc. but to design your code so that such correct behavior can be mechanically proven by the compiler. Rust doesn't remove the difficulty of doing those things right. It just helps you be confident that you don't have nearly as many mistakes waiting to become 0days. 
Gtk is relatively primitive in comparison with something like WPF/UWP, alongside Blend and Adobe XD.
&gt; Rust now somehow has even more mutually-incompatible error-handling strategies than Haskell does. It does not. All of the error handling strategies I'm aware of are centered around the `std::error::Error` trait. At least, I don't know of any prominent library that doesn't do things that way. The `failure` crate does introduce the `Fail` trait, but basically everything that implements `std::error::Error` also implements `Fail` by virtue of blanket impls, so everything is pretty much compatible. There are certainly more error handling crates out there, but most of them are in service of implementing `Error` or `Display` or `From`. But it's all the same underlying system.
FFI?
Associated Type Constructors (a Feature that solves some of the problems that HKTs solve)
I personally like how variadics parameter packs, pack expansion, fold expressions, etc. work in C++. I find them ergonomic and easy to use.
Do you have an example of such a pattern match? 
Mostly for saving memory. I tend to have lots of collections and types storing pointers to dyn trait and every pointer is two words. I wouldn’t mind trading a memory indirection for half the memory per pointer.
Lack of the following: * pure functions * Error handling, * named, optional, variadic parameters in functions * if let chains * global cargo cache (my hard drive fills pretty quickly) &amp;#x200B;
That would have one of two problems, depending on how you implement it: 1. If you apply it to `mod foo { ... }` (Declaring a child module within the same file) but not `mod foo;` (attaching `./foo.rs` or `./foo/mod.rs` as a child module), then it would be an inconsistency that could be confusing and would complicate refactoring and getting familiar with the interdependencies between bits of code. (I like it as-is on the "explicit interdependencies" front.) 2. If you apply it to both `mod foo;` and `mod foo { ... }`, then it would be the worst aspects of constructs like Python's `from foo import *` turned up to 11 because code in `foo.rs` could reference constructs in `parent.rs` without *any* declaration in `foo.rs` giving even a hint of where they're coming from.
I would stay away from it if possible. It is finally maintained again, but it's still a powderkeg of memory corruption and segfaults. Just stick to [rust-cpython](https://github.com/dgrunwald/rust-cpython) for now, which incidentally works on stable Rust.
You could certainly write something like that. To me, it sounds like it would run afoul of the "80% of the users use only 20% of the features, but nobody uses the same 20%" problem that makes it so hard for new "simple and easy" tools to replace "overcomplicated" incumbents.
I don't; if I notice one, it's because it's causing problems, at which point I fix it, thus removing it.
That is a brilliant crate name!
You do need point 1 &amp; 2. You need point 3 to make the language sane.
Hey, did you get anywhere with this? I might try to look into it if you're not planning to.
I don’t see why. There are plenty of jit compiled languages with highly dynamic type systems and open classes as well as threading. More importantly the reasons that Python is hard to jit compile have nothing to do with the points you raised. 
One thing that I don't like, is lack of inheritance.
The borrow checker breaks you down so that it can build you back up, stronger and more resilient than you once were. It also had me do all sorts of weird things like catch flies with chopsticks and scrub counters to a polish. 
Rustdoc is under very active development.
I admit I haven't looked at the situation recently, but about 6 months ago there were still a lot of crates whose instructions started with "this requires a recent version of nightly...". Maybe I'm just too used to looking at `master` branches and assuming people leave the README more or less unchanged for tags, though.
Try matching on an `&amp;Option&lt;T&gt;`. The `Some(x)` pattern should try to move out of the Option (which is a compile-time error, "cannot move out of borrowed content"), but due to match ergonomics the compiler changes the pattern to `Some(ref x)` and it Just Works™. Might sound useful, but after understanding how pattersn worked I don't like it either, I think explicit is much better.
A new RFC was accepted, but has not yet been implemented. https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md
&gt; &amp;_ on, left hand. Result off, right hand. &amp;_ on, Result off. Breathe in through nose, out the mouth. &amp; on, Result off." 
Inheritance is awful, and adds nothing of value we can’t get elsewhere. This should never be added. If that’s what you want, maybe give C++ a try.
So I would have to check a commit out before the one specified in the table? I was thinking about some comms d or somerhing were you could type in which components you want ad it'll spit you out the last date were they all worked. Is there an api to check against? The website probably has to use one of does it use generated / hard-coded values that are updated from a ci?
The only thing that really restricts me right now is the lack of generic associated types (a.k.a. associated type constructors). Everything else is a nuisance, but not having GATs is really limiting the expressiveness of what I can write. 
If it does that consistently against references, i don't see a problem with it.
Module system will be added in the next Go version.
You just do a cross join. E.g. cross join of sets `{"Green", "Red"}` and `{"Apple", "Berry"}` is `Green Apple, Green Berry, Red Apple, Red Berry`. If you think how you create permutations, it's the same way. For example we have alphabet `abc`. What permutations of length 1 we have. Well, `[a,b,c]`. Then, how do you create another permutations. Well, add one letter to beginning of everyting. So you get `a` + `[a,b,c]`, `b` + `[a,b,c]`, `c` + `[a,b,c]`. So, you get `[aa,ab,ac]`, `[ba,bb,bc]`, `[ca,cb,cc]`. And so on.
&gt;use things like error-chain/quick-error/failure... Having recently discovered \[derive\_more\]([https://crates.io/crates/derive\_more](https://crates.io/crates/derive_more)), I now just bypass all the error handling crates and just use pure Rust minus the boilerplate. My \`Error\` module is now literally just a list of variants with a few \`derive\_more\` attributes specified to create my \`Debug\`, \`Display\`, \`From\` impls, the works--basically what you always wished/expected it to be. Even auto-deriving \`From\` impls for non-\`std::error::Error\` types like \`NoneError\` (why, Rust why???) or argument processing scenarios like OsString returned in the \`E\` position of a \`Result\`) works without any boilerplate--it's finally practical to teach/explain best-practices idiomatic Error-handling in Rust.
The reasons that Python (and Ruby) are doing so bad in even in ridiculous complex JIT compilers (I'm looking at the average speed-up of [PyPy](http://speed.pypy.org/) and TruffleRuby with similar [numbers](https://pragtob.wordpress.com/2017/01/24/benchmarking-a-go-ai-in-ruby-cruby-vs-rubinius-vs-jruby-vs-truffle-a-year-later/)) whereas say JS, Lua and some Lisp dialects (although there is a lack of relevant benchmarks) do realitively good is AFAIK because recompilation and deoptimization are expensive, both in throughput and memory, which at some point also translates into throughput. That means, once you go off the hot path it's getting rather slow. And when coding in JS, Lua or Lisp by convention most people don't go off the hot path, which means the compiler can take an object initialization expression and optimize it to allocate the whole memory area in one pass. In Python and Ruby on the other hand when writing idiomatic code and using existing libraries and framework you have no choice but taking the slow path in non-trivial software. Threads add to that because AFAIR there is no restriction from which thread you change a whole class hierachy. There is also the fact that JavaScript lives in its own, fixed environment which can be JIT optimized as well, whereas Python and Ruby have to interface foreign code which can't be solved entirely. &gt;There are plenty of jit compiled languages with highly dynamic type systems and open classes as well as threading. Such as? &gt;More importantly the reasons that Python is hard to jit compile have nothing to do with the points you raised. And you think that is why?
You can try the 2019-01-26 or 25 nightly. That page also links to https://mexus.github.io/rustup-components-history/, but I don't see the historical data. The data comes from here.
Thank you :) And I'm not sure what that means, yet; but it sounds exciting! I'm sure it will be a rewarding experience either way. I really like how the manual is written
There are around 3 ways (that I know of) to accept/return an “interface”, i.e. a struct that implements some form of trait. Two seem redundant (Box&lt;T&gt; and Box&lt;dyn T&gt;), and the other (impl Trait) is not complete enough to be used widely yet as it’s not applicable in various places. One of my more recent annoyances is the lack of control on blanket traits. If I want to implement trait X for types that implement Y, and separately for types that implement Z, I can’t because at some point something might implement both Y and Z. There should be more control to handle such cases, rather than just compiler errors. I think this is being worked on, but I haven’t followed too closely yet. 
Cool! I will try it out. &amp;#x200B;
Python is hard to jit compile because you can’t make it three lines without hitting C where the JIT can’t make any assumptions. The entire interpreter ia available to extension modules together with the GIL and all refcounting and too much code depends on that. The interpreter frames are exposed and the dispatch system ia too complex. There are many more things but those are the root causes. 
I always think of borrowck as an angel sitting on your shoulder, advising you not to sin against the rules of ownership and borrowing, so your design will be obvious and your code simple and fast.
Yes to everything u/phaylon said.
[tarpaulin](https://github.com/xd009642/tarpaulin) is the main one for me. As of recently there's now a way to get it working on stable again, but it's still pretty kludgy. Proper support is still blocked on `[proc_macro::Span](https://github.com/rust-lang/rust/issues/54725)` being stabilized which, if memory serves, is also a major blocker for Rocket.
That's what I thought, too, but TruffleRuby JIT compiles C extensions and it didn't seem to have helped them that much. A 10x speedup for C function call benchmarks is impressive but the overall speedup compared to CRuby is still below that figure.
I had plenty of conversations with the pypy folks over the years with regards to jitability if Python. It will require to remove the roadblocks but the three points you highlighted never came up. 
Doesn't this work only thanks to the arbitrary self types, therefore on nightly only too?
I guess the hive mind is proving your point about the downvoting :-p
The angel bit sounds good, it's the whole fire and brimstone if you fail to heed the advice that is a bit scary...
I don't mind at all, I just hadn't gotten around to it. Thanks a lot!
When this happens to me, I typically get a type error somewhere later (e.g expected a value but got. Reference, etc)
I think `Box&lt;Self&gt;` specifically was accepted as a self-type since 1.0. I've check with Rust 1.10.0, and it happily compiles the code. That code is from Cargo, which builds on stable. 
Link to Fractal: https://www.matrix.org/docs/projects/client/fractal.html And very cool! I wasn't aware of this!
When I first learned rust, ref &amp; ref mut was one of the challenges that was part of the learning curve. Once I got it, I enjoyed the explicit nature. But I never learned it well enough, so now when that stuff is done for me, I feel much more unsure about the underlying semantics. It's uncomfortable and is probably the ergonomics feature I most consider a grave mistake.
Just curious, do you feel the same way about other things the compiler automagically infers for you (like lifetime elision, implied bounds, all the stuff that `?` does, etc)? Or is there something special/worse about match ergonomics in particular?
It's probably what you will struggle with the most when learning rust. Or not! Who knows. Just know that if you don't understand it immediately, keep trying at it and it'll click eventually. You might even just wake up after a day of confusion for it to just have clicked in your sleep even. :)
I've had to use it for equality on Boxed/Referenced traits. I'd image it's also useful for plugin schemes. trait Foo { fn as_any(&amp;self) -&gt; &amp;Any; } impl PartialEq&lt;Box&lt;Foo&gt;&gt; for Box&lt;Foo&gt; { fn eq(&amp;self, rhs: &amp;Foo) -&gt; bool { self == rhs.as_any() } } impl PartialEq&lt;Any&gt; for FooBar { fn eq(&amp;self, rhs: &amp;Any) -&gt; bool { rhs.downcast_ref::&lt;FooBar&gt;() .map(|rhs| self == rhs) .unwrap_or(false) } } impl PartialEq&lt;Any&gt; for FooQux { fn eq(&amp;self, rhs: &amp;Any) -&gt; bool { rhs.downcast_ref::&lt;FooQux&gt;() .map(|rhs| self == rhs) .unwrap_or(false) } }
Heh, that's interesting. I don't think I've ever seen it mentioned in any documentation or code and I've read through The Book and Nomicon several times. Definitely not a well known thing :-).
Heya, got your Twitter DM! I come from a PHP and web dev background as well. I have not stored bookmarks for all the resources I've used, but here are some pages/sites I managed to find again: - https://ruslanspivak.com/lsbasi-part1/ - https://hackernoon.com/lets-build-a-programming-language-2612349105c6 - https://doc.rust-lang.org/1.0.0/syntax/ (If you're comfortable digging into how rustc works a little when it comes to parsing and AST) - http://craftinginterpreters.com/contents.html - https://stackoverflow.com/questions/6376662/what-would-an-ast-abstract-syntax-tree-for-an-object-oriented-programming-lang The biggest hurdle for me was the understand how to build and walk an abstract syntax tree properly. The next challenge has been how to properly handle calls, state, and value storage around the interpreter. Parsing source code into tokens is relatively simple, but parsing that into AST is harder. I have paused development for my language prototype for now (busy with personal stuff) but I am planning on releasing the current prototype status openly on GitHub soon so others can learn from it and maybe suggest improvements as well.
That's genius. Wow. 
Thank you for the example, that's precisely the kind of answer I was hoping to get. Thinking of it, even when (if) multiple-trait objects are implemented, doing something like this would be incredibly messy. 
Maybe I've been spoiled by Java support in IntelliJ, but the Rust IntelliJ plugin is good, not great. It's amazing on small projects but on medium sized ones it appears to give up. Still, I see it's under active development so it will improve, no doubt. Also, I have high hopes for rust-analyzer.
I didn't have any expectations, it was a low-ball question that's easy to answer and gives a nice "where do we go from here?" conversation. The whole project is really cool.
If this implementation gains traction it would be really cool to see what optimizations could be made by correctly enforcing type annotations. If it could do Cython-like pre-processing to map python variables to native types that would be very interesting. 
In order of highest priority, to me: * IDE support could still go a long way - I would love more auto-refactoring tools. It's painful that I don't even have a basic "remove unused imports" function in intellij right now. * Unstable libraries. I'm on some older versions of libraries because upgrading would just be painful - I'll have to at some point, but when, right? I don't want to upgrade just to have to upgrade again in a few days. * Error handling \*should\* be good but it isn't. This needs to be handled in std, error handling is too fundamental, in my opinion, to leave to crates. I know progress is being made here. * Compile times are still quite long. I rebuild a lot of my code often, and I also have a slow deploy process to AWS infra. The good news is I have time to play some video games and watch TV. It's a blessing and a curse. * Futures are kind of annoying to encounter in libraries. I use \`.wait()\` everywhere and rely on threads. I know \`wait\` is bad, but it seems to work, and it's better than pulling in some other dependencies and working through docs to figure out the right way. async/await will help here. The language is the least of my issues, it's more about the support tools and ecosystem now.
Why would you ever write the code that way? You could move the gets/and\_thens above, into variables, at the very, very least. 
You were probably looking for r/playrust
The book uses it on multiple occasions, e.g. chapter 17. https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html#requesting-a-review-of-the-post-changes-its-state
Two points. The third is entirely for making the language more robust and comes with no cost. The other two points help with both. Still I'm not convinced, for those reasons: * It wasn't a game changer for TruffleRuby. Well, unless you are a server owner. We could now speculate that typical Ruby code employs way more runtime metaprogramming. That's plausible, given the difference in memory handling and culture. * As you said and consequential, typical code is riddled with C extensions. Which means that there isn't much non-trivial code with less extensions to test. C extensions might be next approachable roadblock, but that is only so, because PyPy isn't the defacto interpreter everyone uses. If we assume that the typical Python code contains less Python code per native code than in Ruby, at this moment this might rebound and idiomatic Python code will contain more Python e.g. with frameworks that mutate metaclasses; and then they will hit this roadblock. * PyPy devs seem like they aren't focussing solely on single threaded baseline performance, but on maximal throughput. So you, me or the PyPy devs might not even be talking about the same kind of performance. * PyPy devs need to keep the language compatible after all. 
&gt; lack of portable stable SIMD. I've actually been writing portable/stable [SIMD implementations of crypto algos](https://github.com/cryptocorrosion/cryptocorrosion#SIMD), building up a library for it as I go. The design is to provide an interface as close to the `packed_simd`/RFC2366 interface as possible, and allow choosing between SIMD "backends". - crypto-simd + ppv-lite86: builds on stable; supports SSE2 through SSE4 using coresimd intrinsics. With this backend, the [ChaCha20](https://github.com/cryptocorrosion/cryptocorrosion/tree/master/stream-ciphers/chacha) implementation I wrote yesterday comes within 15% of matching the throughput of an optimized ASM implementation on my SSE4 machine. - crypto-simd + packed_simd: use unstable dependency for SIMD on AVX and non-x86 platforms. The same ChaCha implementation is also pretty fast with AVX512. - crypto-simd + ppv-null: safe, portable, software emulation of SIMD. The library is still in an early stage, and not ready for use (unless you are up for writing the missing pieces of backend code as you go). I also still need to factor our my runtime CPU detection/algo selection pattern into a crate (might do that today).
Order of best to worse: async &gt; rayon &gt; channels (crossbeam or std) &gt; crossbeam + shared read only stack &gt; crossbeam + mutex &gt; custom long running threads + mutex + channels + other synchronization mechanisms Use async when you just have I/O stuff to avoid making threads. Use Rayon anytime you need to do a parallel operation and/or collect the result on several elements, as it's the easiest parallel code to maintain. Use channels otherwise if possible (with or without crossbeam) to make it easy for threads to become closed when the other side's channel closes and so that it is easy to reason about what thread is communicating to what to avoid deadlocks. Due try to avoid this, but the last place I would go to is using mutexes in any capacity. Save them as a last resort. Almost everything I encounter can be parallelized with rayon or channels.
This [rustdoc repo](https://github.com/steveklabnik/rustdoc) is archived. I'm not sure whether it's the official repo of `rustdoc`.
And that works just fine for errors whose only purpose is to halt the entire computation and be propagated to the user ASAP - or halt some part of it and retry again no matter what kind of error it was. But sometimes it is possible and desirable to figure out whether, for example, a failed HTTP request was due to one-of-a-million reasons (retry indefinitely), or due to incorrect credentials being provided by the user (do not retry, but instead attempt to reacquire credentials). And "structured" information about failures is one place where possibilities diverge: dyn Fail, dyn std::error::Error, dyn your::own::Trait, error-chain, an Enum of any other combination... All of those possibilities are then duplicated, due to the difference between std::Result and futures::Poll. Option itself forms one more possibility, but then Option can be used as the "happy-path" value for a Result or Poll, duplicating all those possibilities yet again. It's a mess!
What do you mean by a “stable ‘airplane’ mode?”
All of those things are part of the same system, and they aren't incompatible with one another. Errors are just values, like anything else. If you have a concrete value, then do case analysis over the error type. If you have a trait object, then use the source/cause methods along with downcasts.
&gt; Or is there something special/worse about match ergonomics in particular? One thing that match ergonomics broke is asserting type of variable. Before match ergonomics you could ascript type to a variable declaration and be sure that if code compiles then the variable has exactly that type. Since a single identifier is technically a pattern, after implementing match ergonomics it is not longer a case.
Glium does support compatibility contexts, but it wont use the fixed function pipeline at all, so it cant actually use OpenGL 2.1, just be compatible with it.
&gt; Also, the orphan rule is pure horror. It adds huge overhead to my code, because I have to convert between similar structs of different crates all of the time. I suppose that a global trait coherence is more important. However, I sometimes want private `impl`s. If i'm not mistaken, there is an RFC for this.
https://doc.rust-lang.org/reference/memory-model.html
&gt; By the way, I’ve been told this is used in javascript and actually has a name ‒ but I forgot the name. IIFE -- Immediately invoked function expression, pronounced if-ee. Used to be super common in js (since there were no modules, and functions were the only way to introduce a new scope), nowadays, it's not needed as much but is still used sometimes.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rustjerk] [Could we make some discussion about an empty set?](https://www.reddit.com/r/rustjerk/comments/amsq72/could_we_make_some_discussion_about_an_empty_set/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
You actually already can, this is stable.
there are plenty of times I'm writing some code in Rust where I think, "Ok, it's not letting me build this, and I understand why it won't, but my gut tells me something like this is possible if I invoke the dark arts of hacky type parameter usage, but there's no chance I'll ever figure out just what I need to do." part of the fun of getting better at Rust is when you hit problems like these and realize you're starting to understand the solutions (and why they are necessary). part of the pain of learning rust is when you can't :)
&gt; You can do this with include! Yeah this works and is also too horrible to contemplate even for my solo projects. `use super::*` as /u/dobkeratops suggests would be my natural workaround, but the underlying issue is that this style is just not what the language promotes, and thus working around it is A Bad Idea. So, I just do things the way the language wants, but (as my answer to the question the thread title asks) I don't like it.
wow. this impressed me more than I like to admit. elegant solution.
&gt; Discord makes it's money by spying on and selling user data. I have heard that claim before, and while I'm sure they're collecting data I have yet to see any evidence that they're selling it.
I second the web-focused docs. I frankly can't stand the Rust doc html output, although I do appreciate the work that went in to making the docs easy to create.
Can't blame you for your choice - I do work with Unity and we still build tools with Python unless they are integrated Unity tools. And PyQt is awesome. I find Go really nice and comfortable to work with, with simplicity and speed as a valid tradeoff for lack of generics. But all the github.com imports everywhere do make my teeth grind.
&gt; If you have a concrete value, then do case analysis over the error type. If you have a trait object, then use the source/cause methods along with downcasts. That's easy until the function that is making the library call isn't the function that should be doing the special handling - in order to reach the main control-loop, the special-handling-needy failure must unify its type with a dozen other failures that don't merit special handling. dyn std::error::Error is useful, yes, for unifying all the libraries' types into something that can give the user their error-message ... but other than string-comparisons with that message or with the message from the std::error::Error that is its "cause" (or whatever that method's new name is), there's not much more that can be done with its trait-objects. They're as opaque as any other trait-objects.
Relevant: https://codereview.stackexchange.com/a/127500/182435
Thank you for you reply and sharing the material! Can't wait to see your language on github.
I think you are looking for: https://mexus.github.io/rustup-components-history/
I see no reason that this couldn't be made to work, though...
I guess I've lost you. The source/cause method is exactly the solution to this. It lets you examine every error type in the causal chain.
If you have a bunch of repetitive code you can define a closure right before you use it. let getpt = |name| obj.get(name).and_then(|value| value.as_f64()); if let (Some(clx), Some(cly), Some(c2x), Some(c2y)) = (getpt("clx"), getpt("cly"), getpt("c2x"), getpt("c2y"))
The problem with this is that exactly 0 tier 1 targets have shipped with RLS during the (static amount of) time covered by this report. The only way to get historical info is to clone the repo, go back to prior commit, and then view the associated target's HTML page. ugh.
Is there any way to pass multiple args in a single string to `std::process::Command`? E.g. user passes `bash -c "echo \"foo bar\"" -i`. I know I should split it to `["-c", "echo \"foo bar\"", "-i"]`. Is there any standard method to do this which respects escaping?
You were downvoted, but I'd lose faith in Rust if the designers made it more OOP. Inheritance is one of the biggest mistakes of programming language design.
Wouldn't re-exporting values alleviate this pain?
I just cloned https://github.com/mexus/rustup-components-history and ran through the commits by day locally until I ran into updates including everything you were looking for. I wasn't looking especially closely, but 2018-12-26 appears to have most of everything included.
it's just.. I'm from Java. I don't know the power of the match, yet. thanks for that one, too. 
 macro_rules! defer { ($($x:tt)*) =&gt; { struct S; impl Drop for S { fn drop(&amp;mut self) { $($x)* } } let _guard = S; } } and macro_rules! go { ($x:expr) =&gt; { thread::spawn(move || { $x }); } } &amp;#x200B;
&gt; no system wide crate cache. Not by default, but this should work. https://doc.rust-lang.org/cargo/guide/build-cache.html#build-cache
Chapter 20 even has a FnBox...
We've reviewed the videos and they are in the processing queue, as soon as they are finished, they will appear on the website. Mind that the videos for both days of the devroom (Mozilla on Saturday and Rust on Sunday) end up on the same page.
One thing that shouldn't be overlooked is how much work would have to go into any other widely cross-platform formatted doc system. Web is standard.
Fire and brimstone happens only if you break the commandments of the borrowck with unsafe.
&gt;if I have two files named A and B in the same folder, I can refer to A directly from B simply as A Doesn't this make it really hard for you to tell where code is coming from? I know grep exists, but if I'm just browsing code in github it's nice to get an idea of how things are structured.
It sounds like you were using CircleCI 1.0, which kinda sucked. It tried to guess what you wanted and what it would do would sometime change, which was bad. Also lacked good docker support, had infra problems. CircleCI 2.0 however is incredible. I would say it should be the go to for any project nowadays. They took everything that was bad with Circle 1.0 and made it so much better. Everything is explicit now, you have workflows with multiple stages, stages run on docker so start in seconds, partial retries of only failed stages. It's so good right now.
Was it CircleCI 1.0 or 2.0?
This is great! Thank you :)
Amazing! Thanks for the heads-up both of you
3 of 139 comments in this thread are downvoted, and most of this thread is criticizing core parts of the language and the community. Is it possible that this one was downvoted for being a vapid, unsubstantiated comment rather than because of a "hive mind"? Seriously though, crying "hive mind" makes a kafkatrap. Deny it and that must be proof of the big bad hive mind, accept it and that must be proof of the big bad hive mind. The correct response is to give it a couple downvotes and move on.
So is the command line though. Why can I do all of my work in Rust from the command line, except access the documentation? Again, I'm not dissatisfied with the documentation overall. I just find the way the Rust docs feel clunky, and I wish there were other tools to choose from.
Broken links or replacing a linked content by just warnings is a very bad PR. I was also wondering that Google has top rated links to Rust documentation pages with no content. E.g. if I google for "rust ownership", the first result links to a ["second edition"](https://doc.rust-lang.org/book/second-edition/ch04-00-understanding-ownership.html), but the page has no content except a warning and links to other versions. I would not automatically redirect URLs to a newer version, because there is not always an 1:1 equivalent and you cannot assume that everybody is only using the latest version of the Rust tools. Instead, I would keep the old content and only add a link to the [root page](https://doc.rust-lang.org/) that contains links to the newest version of the Rust documentation. I have already commented a related issue on GitHub: [https://github.com/rust-lang/book/issues/760](https://github.com/rust-lang/book/issues/760)
Just wait until you discover (rust-style) enums!
You make a interesting point. I'm not going to re-read the book all the time to check the new features. I know we have a weekly, but there should be a simply compiled list of all new stable features/syntax that you can check, just go back to where you stopped reading and update your knowledge. Or just when you want to make a blog post/update a library, like OP could have. If there is one great, but it should probably be more accessible, since a lot of people don't seem to know it exists.
I need to target x86 aarch64 and wasm32 so I don’t think I can use “stable” SIMD libraries for that (the aarvh64 and wasm32 core::arch intrinsic are unstable). packed_simd does everything automatically everywhere which is nice.
Cool, i wish that was the default on macosx.
Ooh, that's a good point. It would be nice to have something like a `cargo man` subcommand. Still, I think it's a good choice to target web first and CLI second. I think the subset of people that program on CLI only is smaller than the subset that programs on GUI only. You're right that it would be nice to have more control over the final doc output in general.
Wait, really? I've only ever heard PyO3 is nicer to use, nothing about being dangerously unsafe?
With linked list you can keep a pointer to any node around and split in O(1). So if you insert a node, and keep a pointer to it around somewhere, split is O(1) - you don’t have to walk the list to find the node (because you have a pointer to it already). If you are using O(n) methods to split list you are probably just using lists wrong. E.g keep a counter and when you insert n elements save the pointer, and then do split in O(1). 
1) Very noisy code compared even to very noisy Java. A lot of .clone, Rc, RefCell etc, etc, unwrap from them. I understand their reasons, but the code of the main logic if your app sometimes significantly less than amout if code to satisfy compiler. 2) Bad functions composition.
 macro_rules! defer { ($($x:tt)*) =&gt; { struct S; impl Drop for S { fn drop(&amp;mut self) { $($x)* } } let _guard = S; } Dude what the fuck. You are both the biggest genius on earth and the stupidest person and it's great.
Rustdoc lives in the main rust repo in the "librustdoc" directory: https://github.com/rust-lang/rust/tree/master/src/librustdoc
Right, aarch64 and wasm32 are unstable-only no matter what. IMO stable on x86 and forward-compatible with stable on other archs isn't too bad.
On windows I've had good results with NTFS compression. If even that can save significant amounts of space... For example, my `.rustup` folder saves a gigabyte and a half of space, and my project target directories typically take about half as much space on disk. Consistently. Not much on it's own, but it adds up.
Can you do something like: ``` if let (Some(res1), MyEnumVariant { res2, ... }, true) = (my_option, my_enum, my == condition) { // whatever } ``` Or were you trying to accomplish something else?
&gt; UIs. I've given up and am learning WPF. I'd have settled for TUI, but even then nothing seemed to want to work on Windows, so C# it is. You can work around the bugs in Cursive by specifying a different backend IIRC.
What about a CLI browser like w3m or lynx?
It isn't typically used except when specifically you need to dynamically abstract over types, such as late-binding APIs. In Rust it is usually correct to preserve error typing, but sometimes people do use Box&lt;dyn Error&gt; or similar, which does erase the type, so do take note of that. Most good error handling practices usually involve wrapping the possible errors in algebraic datatypes (in Rust this is enum) and then, usually through annotation, creating proper error messages for each of the variants. This helps both when you need to handle error variants differently (match) and when you just need the debugging output (unwrap/expect/letting errors flow out of main via Result). In general dynamic typing is rare in Rust code and it is typically bad practice to use it unless it is required, easier to read write, etc compared to static polymorphism, so you should probably find things to be to your liking if you dislike dynamic typing but aren't dogmatic about it.
Wrong sub, try /r/playrust
I have had a very similar experience with this. One thing I've thought about a few times is trying to get an optional clippy lint that warns whenever this occurs, so that I can make sure that I write code I understand.
If you use inner(&amp;par), that will actually not work because then you will have a reference to a reference. In Rust there is no automatic referencing, so you don't need to worry about explicit reference.
We use it at work too, and I like a lot about it, but it does require building some infrastructure manually, e.g. we had to create our own build artifact caching process.
The borrow checker ensures that, when you loan a variable to something else and then take back the loan by using or freeing the variable, the borrowed reference can't be used after the loan is taken back. It gained a reputation for being a pain when it was less smart and it was hard for newbies to tell the difference between asking for something impossible and simply not expressing their intentions correctly. The new borrow checker is a *lot* smarter when checking a function body, so it's likely that you'll run into it a little later, when you're trying to pass references across function calls or to store references in data structures. Both of those things are common sources of frustrating bugs in C or C++ and common sources of frustrating compiler errors in Rust. 
I've found the rust's parametric polymorphism to be *much* nicer and more flexible to work with than languages I've used before with inheritance. There are languages that do both type parameters and inheritance, but I appreciate that rust takes one approach and focuses on making it really effective, instead of taking two overlapping approaches. Other languages with similar type systems don't tend to support inheritance either. That being said, what type of things are you running into that work better with inheritance?
Got any specific examples? It's definitely the case that discussions get noisy, but that's more the result of people *not* being silenced. See: high traffic RFC issues, which tend to end up repeating extremely similar discussions multiple times.
See my response [here](https://www.reddit.com/r/rust/comments/amnch0/question_what_are_things_you_dont_like_about_rust/efnl0bc/?context=3).
&gt; Even auto-deriving `From` impls for non-`std::error::Error` types like `NoneError` (why, Rust why???) Ouch, that looks bad. On the bright side at least it's nightly, hopefully it'll be fixed or theres some *really* good reason for not doing it by stable.
...listing requirements doesn't make requiring nightly "a badge of honor"
&gt; I wish backwards compatibility weren't broken for aesthetic reasons, but only for soundness fixes. Other changes should only go in editions. ???
A nice, Ty :)
Couldn't you do that pretty easily with a custom implementation of `rustls::ServerCertVerifier`?
This particular feature has always been there. The book doesn’t change that much, generally. The modules chapter is the only one that’s been revised significantly since the initial final draft.
Thank you, this is enlightening. I really like and appreciate the error handling in Rust. It's explicit and quite ergonomic, the compiler ensures that the errors are handled in some way, and thanks to having ADTs it's very simple to attach useful info to errors. Haskell kind of comes close to this - but only in pure code, because `IO` has exceptions, and the standard library uses them instead of `Either` for most functions. Having a `std::io::Result` in a function's signature feels _reliable_, I know at a glance what can go wrong.
Yes, that is what I was alluding to.
(Probably biased) summary: Breakage of code not visible to crater runs is considered theoretical. [Here](https://www.reddit.com/r/rust/comments/9hf2qy/the_future_of_rusts_backwards_compatibility/) is an older write-up of mine. [Here](https://github.com/rust-lang/rfcs/pull/2544#issuecomment-453653184) is a more recent summary from a language team member: &gt; This RFC technically amounts to a backwards incompatible change without using the edition mechanism. However, as the RFC notes, a crater run was made and the syntax was not encountered at all. The breakage is therefore strictly theoretical. In the eventuality that it isn't theoretical, the migration can be trivially handled by cargo fix. which to me makes the language not really backwards-compatible. I can see the case for excluding soundness fixes from that compatibility, but not for aesthetics like turbofish.
[The contain-rs linked list](https://github.com/contain-rs/linked-list) circumvents this problem with a `Cursor` type (basically a mutable iterator). I didn't read the source code to find out how, but it works, and pretty intuitively so.
You want to introduce extra syntax just to work around match 'ergonomics'? Perhaps it should just be removed in the next edition.
Is GUI development, I can't see a good way to implement a GUI toolkit without inheritance, I tried to create a small example in Rust and I failed hahaha. I really like Flutter and it has good API, a Rust version would be great. I see that composition rather than inheritance is a good thing, but I think one does not exclude another.
Just learn to pay close attention to the error messages that rust gives you. It has incredible error messages that show you, usually, right where the problem is. 
In a case like that I think it helps to remember the *goal* of backwards compatibility, rather than the *rule*. The goal being so users can trivially upgrade to newer rust versions, right? I havn't read through the RFC but if it can fix a longterm painpoint, actual breaks are strictly theoretical, and even if they exist they can be trivially fixed by an automatic tool provided with the compiler, then why shouldn't it be fixed? Being backwards compatible is nice and all but it's important to remember *why*, rather than doing it for the sake of it. Of course theres also a line, don't break BC just because "you can", even if it's trivial, but a hard rule just isnt flexible enough for the real world. In this case i'd say it's acceptable "breakage".
I wish that this had Windows support. It's definitely pretty firmly set in using the POSIX API from what I've seen, though...
I feel I could read this response equally validly as a legitimate suggestion or trollbait.
The problem you ask about does happen in C# (or, in practice, in C/C++) but not in languages that work as described in the quote. That said, I have found type inference to be a much harder barrier to tool-less code inspection, and grep-like facilities are also necessary to find references to a symbol, which I find a very important part of code analysis. Large projects will also have been written according to code guidelines that will usually include something to help here (e.g. "one class per file, both named the same"). (and if they aren't, you have bigger problems) So, all things considered, in my experience the problem you refer to is largely a non issue.
Reexporting in the super works, just like `use super::SisterModule;`. I just think that having to do it doesn't add any value, and I don't like it.
Sure it does: use the `std::convert` traits or Rust's delegation facility. One of the biggest problems with inheritance is that it does *not* ensure that "a function that worked with the base type can work unmodified with a type that extends it." - because of the fragile base class problem. which is the pathology inheritance introduces over composition.
It only isn’t to bad if you don’t need SIMD in other archs :/
I disagree. Backwards compatibility means that previous versions of the language are compatible with the current one (barring specification bugs like soundness issues, which this isn't). It's all explored in the post I wrote a couple months back I linked above, and in the turbofish discussion as well. This is about not discarding all in-house code, all tooling that needs to understand Rust code, like IDEs, syntax highlighters and so on. About having code in PDFs, in old mailing list archives, in IRC logs and such still be correct. It's so proprietary libraries, SDKs under NDA, and things we can never reach will remain correct. A successful ecosystem must always be a lot bigger than just `rustc`. Trivially upgrading your own crates is, to me, the smallest thing that backwards-compatibility gives you. And, like I said in the post, *we have editions*.
I think that one should be able to use move everywhere you can use ref.
https://github.com/contain-rs/linked-list/blob/master/src/lib.rs#L343 Notice that Cursor owns a mutable reference to the list. This means there can only be one Cursor per list and it also prevents access to the list. It isn't possible to have multiple Cursor.
I think there is a unstable intrinsic lib that does that, and there is a solution which you can implement on your own, but it's not so nice if you don't know the type. You'd create a Trait "TypeInfo" that has fn that returns a String or &amp;str that reflects the type. You implement that for String and Integer. I only know of primitive integer types u8 etc. So you have a struct MyInteger, that has the primitive integer as single field: &amp;#x200B; trait TypeInfo { fn type_of(&amp;self) -&gt; &amp;'static str; } impl TypeInfo for String { fn type_of(&amp;self) -&gt; &amp;'static str { "String".to_string() } } struct MyInteger { int: u8, } impl TypeInfo for MyInteger { fn type_of(&amp;self) -&gt; String { "Int",to_string() } } Í am also not sure, if you can implement TypeInfo for String, because it's in a different crate. If it's not possible, you would do the same for String as you do for the integer, wrap it into a MyString struct. &amp;#x200B; Now in you fn that needs to know what your arg is you can matc the return from x.type\_of() whether it's String or Int and act accordingly. &amp;#x200B;
I *think* I understand what you are asking? `args` is currently an `Iterator`, according to its type definition. You could parameterize `Command` on the item type and specify that as the iterator item type. ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=54fab4dbad1c74b1d8027f8748642489))
Wrong sub, you want [/r/playrust](http://reddit.com/r/playrust).
ty
Try rust-analyzer. It's much faster than rls.
There's two approaches for this sort of polymorphism: either use an `enum`, such as enum StrOrInt { String(String), Int(i32) } ... where T: ... + ExactSizeIterator&lt;Item = StrOrInt&gt; Or, create a trait for the operations that are needed on the element type and bound the item by that: trait MyTrait { ... } impl MyTrait for String { ... } impl MyTrait for i32 { ... } ... where T: ... T::Item: MyTrait
I often have to wait more than a minute for an incremental build change. Plus no specialization makes my code slower... Which is bad, since I'm writing very performance sensitive code.
I know about that syntax but I don't quite see how I can use that to adjust the type parameters for my implementation of the `Index` trait, sorry. Could you elaborate? As far as I can tell I would still need a trait that (semantically) says: "this is a field-less enumeration" for my `index()` function to be typesafe.
2.0
Maybe look in to the Any trait which van be downcasted to other types (basically checking what the underlying type is)
Someone once showed me how to cascade closures for if else a little known feature. I don't remember how that worked. :( This is simple: |x: char, y: char| x == 'A' &amp;&amp; y == 'B'; println!("both match") but somehow you can cascade the output of the closure as args for a second closure: // wrong |x: char, y: char| |x == 'A' &amp;&amp; y == 'B'|; println!("both match"); x == 'B &amp;&amp; y == 'C'; Can't get it right. 
Under what circumstance would you use it? These don't service any purpose by virtue of being hacks...
But…all those `printf!()` calls. I hate copy-paste. (Also, why is the range one more than required?) [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=961573656cee5b98a313e8433499cb61) The optimizer will hopefully take care of avoiding the extra `to_string()` calls. 
That's a winning attitude :) Look forward to lots of character building 👍
The optimizer is magic, but not all-knowing. It can't see too much behind allocations to always avoid stuff like that. Regarding FizzBuzz, allocations, matching and stuff, I always reference this amazing post: &lt;https://chrismorgan.info/blog/rust-fizzbuzz.html&gt;
It's a rust macro for defer as known from golang
But fn drop can't capture local variable.
This works, if you only have two combinations A and B or another one ie B and C. let x = 'B'; let y = 'C'; let check = |x: char, y: char|x == 'A' &amp;&amp; y == 'B'; true|| false; if check('A', 'B') {println!("Option 1")} else { println!("Option 2");} true if A nd B, false if B and C (or any other).
(Disclaimer: just woke up, may not be coherent.) &gt; do you feel the same way about other things the compiler automagically infers for you Not really. Take `?`: I may not know exactly what it's doing (as in, the precise types involved), but I can see that it's there, and I can modify the code to make the types involved explicit. Lifetime elision mostly isn't a problem because it *always* happens to *any* reference without a lifetime. Elided lifetimes hiding in a user type is slightly iffy, and has caused the odd problem in the past... but it's relatively rare and really comes down to "I didn't realise this type had a lifetime". Once I realise that, I don't tend to have an issue with that type any more, because now I know it contains a borrow. And if I'm dealing with complicated code, I can make all the interface lifetimes explicit and remove any confusion. The problem with match ergonomics is that there is zero visual cue it's doing anything. There's also no way to clarify the code to make the behaviour explicit. There's no way to turn it off to see if it's actually doing what I told it to do. It *globally* reduces my trust in my own code doing what I think it's doing.
Wow, that link was…oddly specific. Thanks much for pointing it out! After staring at [Godbolt](https://godbolt.org/z/_F-J4v) it looks like the optimizer does fail to avoid calling `fmt()` on every iteration. I thought it would be able to move the call into the basic block for the match arm; I'm guessing it doesn't know enough about `fmt()` to be sure it isn't stashing stuff somewhere. Anyway, easy enough to fix. ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=bed2e0f13acf856443eb22d4e03ead1a)) I was also worried about the extra modulus, but it turns out they are both turned into multiplies anyway, which is kind of neat.
Tuple struct with a dyn closure in it? Then you hold a shared reference at all times, but better.
I miss Java-style enums in rust and rust enum-variants in Java. Maybe we'll eventually see an `enum-variant` in Java once they have value types and records (structs) out there. Should be... ooh Java 17 or maybe Java 27. And the eco-system will catch up ~2 years after that - should be ready for production ~2025... ish 
Hm, it doesn't work for me $ tree . ├── baz └── foo └── bar 3 directories, 0 files whereas `br` leads to: /home/paho/test Hit &lt;enter&gt; to quit, '?' for help, or a few letters to search h:n gi:a
Last time I checked macOS got its own container runtime as well and Docker for Mac is using that. I remember it was in beta though, not sure how far it is now. 
There is no method for it in `std`, but there are some crates for it such as `shlex`. See [this stackoverflow post](https://stackoverflow.com/questions/53498414/how-do-i-pass-a-single-string-with-multiple-arguments-to-stdprocesscommand) for more details.
Ah thanks. I tried searching it in GitHub and all I could find is the rustdoc repo of Steve.
An angel sitting on your shoulder, hitting you in the nose with a plank until you get smart. 
I'm not sure whether this is the most disgusting or most beautiful macro I've come up with: macro_rules! anonymous { { $($field_name:ident : $field_expr:expr),+ } =&gt; { { #[allow(non_camel_case_types)] #[derive(Debug)] // Can add more derives here if wanted struct r#struct&lt;$($field_name),+&gt; { $($field_name: $field_name),+ } r#struct { $($field_name: $field_expr),+ } } }; { $($field_name:ident : $field_expr:expr),+, } =&gt; { anonymous! { $($field_name : $field_expr),+ } } } Example Usage: let mut foo = anonymous! { a: 1.0, b: anonymous! { c: 32, d: true, }, e: |x, y| x + y, }; foo.b.c = 4; foo.b.d = foo.a &gt; 5.0; println!("{:?}", (foo.e)(foo.b.c, 6)); println!("{:?}", foo.b); Prints: 10 struct { c: 4, d: false }
* What I see as widespread over-reliance on macros throughout the ecosystem. People are constantly doing things with macros that users of various other languages do quite trivially with not-macros. In many of these cases, macros might only be getting used at all in lieu of proper functionality to allow for [some thing], which is understandable, but I strongly disagree that macros are a particularly desirable thing to make heavy casual use of in general. * Things like `#[cfg()]` are simultaneously implemented in a way that is enormously more complex than equivalent functionality in other languages (as in with attributes, but not even specially handles attributes) and very objectively less powerful than what other languages (and this does **not** just mean C and C++) implement with nothing more than simple defines and compiler directives. * Compile times are pretty horrific. IMO the *real* root cause of this is dare I say the arguable *overuse* of generics in Rust. *Everything* is generic, even things that seem to me like they should be generic in the sense of compiler magic but not in the traditional sense of monomorphized `&lt;T&gt;`. It's just angle brackets everywhere, all the time.
"I have defined a struct in my crate" is what makes this work. If either the trait or the struct is defined in your crate, it's OK. It's only having both be external that's not allowed.
What features do Java-style enums have that Rust-style enums don't? I thought Rust enums were a superset of the functionality of Java enums.
I think the problem they're addressing here is moreso a side-effect of the fact that Rust compilation is very strictly based around the concept of a crate, which does kind of introduce a lot of weirdness. I do agree that it's all a bit more complex than it needs to be, and that there's something of an overly heavy focus on achieving a level of granularity via namespaces and such that probably isn't really necessary at all in many cases. What I think they want is just straightforward file-level modularity. That is to say, where one file is a standalone "module", so to speak, which can be "used" by any other file simply via its filename (which would probably also be a valid prefix for any types contained there, like `FileA::blah_blah` or whatever. Zig is a recent compiled language that works something like this, for example. I do think there's something to the whole concept, as it means re-use of specific blocks of code between projects is extremely straightforward if they are contained to a single file, and so on. Consider also that there's not *actually* any solid technical reason to always put everything into a big archive file (as in an `.a` or an `.rlib`) Linking against individual object files *is* "a thing", that would specifically seem to open doors WRT caching as a compile-time improvement in my mind.
Only somewhat related, but still nice if you do end up debugging without a debugger - there's the awesome [`dbg!()` macro](https://doc.rust-lang.org/std/macro.dbg.html) now.
&gt; Python consumes way too much memory due to it’s unicode model This is a statement that needs some unpacking, and background for readers (not you, Armin) unfamiliar with Python. The way Python 3.3+ internally stores Unicode is dynamic on a per-string basis; it uses an encoding that allows representing the widest code point of the string in a single unit. So any string containing solely code points &lt;= U+00FF will use one byte per code point. A string containing at least one code point &gt; U+00FF but all &lt;= U+FFFF will use two bytes per code point. Any string containing at least one code point &gt; U+FFFF will use four bytes per code point. The worst case for memory use in Python strings is a string that contains just one, or at most a handful, of code points over one of the above thresholds, because that pulls the whole string up into a wider encoding. On the other hand, in the best case Python can equal or even beat UTF-8 (since Python can do any code point &lt;= U+00FF in one byte, while UTF-8 has to do multi-byte for any individual code point &gt; U+007F). But it's a deliberate design tradeoff: Python isn't trying to achieve the smallest possible string storage at any cost. Python's trying to ensure that no matter what's in a string, it will be stored in fixed-width units in order to support the idea that strings are iterables of code points. Variable-width storage runs the risk of breaking that abstraction, and in the past actually *did* break that abstraction in ways programmers didn't often anticipate. Add I know you personally prefer another approach, but that's not the same as your preference being objectively better, and it's not the same as Python being objectively wrong or using "too much" memory; Python uses exactly as much memory as it needs in order to achieve its preference for string behavior.
As a Python person who isn't the one you replied to: I think Python's type annotations are a poor fit for the way the language is actually used. The `typing` library, mypy and other tooling are all fundamentally built on ideas of nominal typing, but what you almost always would want and care about in real-world Python is structural typing.
&gt; Doesn't this make it really hard for you to tell where code is coming from? The answer to this question, with regard to all languages, is no, if you're using a decent editor or IDE, which you should be. "I don't understand this code beyond what I can physically see because I am using an editor that has no ability whatsoever to analyze it at a broader level" is not really a valid complaint IMO.
Well, some crates don't build on nightly, so you end up limiting your dependencies. It's also just a little scary. Will all these features this library needs actually make it into stable or will I have to rewrite everything from scratch? Find out next year! Sure you can always stay on that specific version of nightly forever, but that seems foolish. Security vulnerabilities caused by old compilers are rare, but they can happen, and eventually it might become hard to track down an ancient nightly rustc, or it might not compile for all required platforms anymore.
Note where I said "just browsing it in GitHub". Explicit is better than implicit, and it's especially not beginner friendly if your language isn't ergonomic without a fully fledged IDE. 
You should add ``` impl&lt;T&gt; From&lt;T&gt; for MyError { fn from(_: T) -&gt; Self { MyError::Misc } } ``` Awfully hacky, but when you can't be bothered to write proper error handling, it's nice to just `?` everything and have it "work".
That's when you google it then abstract out the solution into some sort of module. or just paste the solution in a text file and remember its there when you need it.
The website is a little sparse with information. Is there another site which has descriptions of the talks?
FYI: If you're looking for more information about this, Googling "Rust orphan rules" will bring up relevant results.
&gt; I think the subset of people that program on CLI only is smaller than the subset that programs on GUI only. CLI docs wouldn't just be nice for people who "only" use CLI based tools. Lots of GUIs would work much better with simple text output. It's much faster to print a bit of text than it is to launch a web browser. I'd imagine it'd make for a far nicer UX for anyone who takes a little time to actually set up their environment, especially on slower machines. Also, the little help menu things you usually get when hovering over a symbol would be a lot easier to implement this way.
This isn’t being fixed, as the other reply suggests: it’s already fixed since Rust 2018.
It's not about CLI/GUI, it's about showing a little bit of simple text quickly. It takes a lot longer to fire up a web browser and render a page, and you can't really integrate that output into anything else without going through the whole web rendering process.
No, adding the reference does not make it fail to compile. I think Rust has automatic reference collapsing (i.e. &amp;&amp;par will be coerced to &amp;par if needed), which makes it work. In any case, I wouldn't add the extra reference - par is already of type &amp;A.
I don't even think it's un-ergonomic in any case unless you're just using libraries without ever having looked at their code at all or at the very least read their documentation. It doesn't particularly help though that people in the community at large seem to think it's a great idea and totally normal to shadow the names of things/types/e.t.c. that they **know** to already exist in the scope of their crates, which if you ask me is just objectively poor practice in every language ever, but what do I know.
&gt; I know grep exists, Is that actually a thing that people do? Like *grep* for symbols? It would never even remotely occur to me to do that.
Here are links to the list of talks in this room. There are links to a description for each talk. https://fosdem.org/2019/schedule/track/mozilla/ https://fosdem.org/2019/schedule/track/rust/
All the time. IDK, I may have a different perspective to most because I mostly program small improvements for big FOSS programs. So I spend a lot of time in unfamiliar codebases with unfamiliar build systems, and it's too much of a hassle to set up more permanent solutions.
A few options: If you return Result&lt;_, Box&lt;Error&gt;&gt;, any result with an error type that implements Into&lt;Error&gt; is usable with “?”. You can use map_err to map to a single type, such as formatting an error string in each case. Alternatively, a common pattern is to define your own error enum (implementing Error on it) that wraps the internal error types. Implement From&lt;E&gt; for every internal error type possible. Finally, several crates exist to make these patterns more ergonomic. failure and error_chain are two. 
Uh, that's not a package system problem, it's a problem caused entirely by the fact that Go has no concept whatsoever of specifiable field visibility levels, because it's Go.
I was gonna comment but this comment says all you need to know. I like using From, but only if it’s a simple mapping, for example turning io::Error into something else. Otherwise I would use map_err(...)?; for one-off cases. I actually posted about this myself https://www.reddit.com/r/rust/comments/9a8a2y/best_way_to_continue_if_ok_return_mapped_error_if/?st=JRPQK8E3&amp;sh=f88fce31 
Sorry for the noise.
I want to take an enum and a list of operators and find a way to represent a logical expression (as a syntax tree?). Like with a `derive` simiilar to `Debug` would be awesome to automagically generate tokens that represent the different values of the enum with the name itself. pub enum AnimalQuality { Biped, Canine, Leopard, Feathers, } enum Op { And(AnimalQuality, AnimalQuality), Or(AnimalQuality, AnimalQuality), Not(AnimalQuality), } Bonus if I can somehow nest `enum` types. I want to make an AST from strings like "`Feathers &amp;&amp; Biped`". They don't have to be infix operators if that makes it harder to implement, they just seem easier to read. I am kinda a newb and I don't quite know how to represent an AST but it would probably be lots of `Rc`'s of `Animal` and `Op`? Does `nom` or `pest` seem like a good library for this use case?
And then there's that demon on the other shoulder telling you "all C code is unsafe, so there's nothing wrong with it. How much could go wrong if you add a few lines with `unsafe {}` here for a slight optimization?" Of course, the demon is sometimes right (I'll let the programming theologians sort out the implications of that). But beware of the temptation.
I haven't needed to do threaded stuff in Rust yet (I'm still used to coming up with ideas I/O-bound enough to be suitable for Python), but you'll probably need to re-architect your code. [Using `Arc&lt;Self&gt;`](https://github.com/rust-lang/rust/issues/55786) is such a recently approved thing that it hasn't made it into stable Rust yet and, if that *can* make what you want possible (which I'm not certain of), I can't imagine it'd make for very comfortable code even then, given that you'd need to run *all* access to `self` through it.
`Box&lt;Trait&gt;` and `Box&lt;dyn Trait&gt;` are purposely redundant. Prefer Box&lt;dyn Trait&gt; in all cases. `dyn Trait` and `impl Trait` are different, and it is important not to confuse the two. `dyn Trait` is a trait object that is a pointer to the underlying data type that impls the trait and the vTable (list of function pointers for the functions in the trait). This means calling methods on it is indirect (derefercing the vtable and data pointers). When used in a collection e.g. `Vec&lt;dyn Trait&gt;`the data types do not all have to be the same. `impl Trait` is a source-erased type of a type that implements said trait. It helps ergonomically by allowing us to declare a function without having to make a generic parameter for the type. It also lets us returned unboxed types that contain unnameable types in generic parameters (e.g. closures in iterators). When used in a collection, all values share the same actual data type. There is also no indirection for calling methods on it. If you want a real redundancy, the following three function signatures are almost equivalent: * `fn&lt;T: Trait&gt; foo(t: T) -&gt; ()` * `fn&lt;T&gt; foo(t: T) where T: Trait -&gt; ()` * `fn foo(t: impl Trait) -&gt; ()` The only exception to their equivalency is that you cannot use turbofish on the final variant.
FWIW, there's ongoing work to bring structural typing in. See Protocols.
No, it works just fine either way. Function arguments are coercion sites and `&amp;&amp;T` is (recursively) converted to `&amp;T` at coercion sites. Note that it *will not* automatically `T` of some non-reference type. There's also a rule which will rewrite `m` (of type `&amp;mut T`) to `&amp;mut *m` at function argument site. This is useful because creating the new re-borrow introduces a new lifetime and that lifetime is likely shorter than the existing one. You can avoid the latter with `{m}`. No point avoiding the former because it will always give you a type error.
[warp](https://github.com/dgiagio/warp) might be helpful. I've seen [buckaroo](https://buckaroo.pm/) use it to [distribute their CLI](https://github.com/LoopPerfect/buckaroo/blob/master/warp-bundle-windows.ps1) which is written in F# and ships with a lot of DLLs.
As someone who's been programming for a while, I find the prose documentation kinda annoying. Ofc just my opinion.
When you absolutely need shared pointers to a mutable something, you can use a cell wrapper of some kind to do so safely. The standard ones are: - `Cell` - doesn't support borrowing the inner value and consequently only really works with plain-data types. No overhead. - `RefCell` - does run-time borrow counting. Small overhead, not thread-safe. - `Mutex` - allows borrowing the inner value, but only one borrow at a time. Thread-safe if the inner value can be sent between threads. - `RwLock` - run-time borrow counting which is also thread-safe and implements blocking. Requires thread-safe inner value. Highest overhead. - `Atomic*` - ultra-low-level thread-safe cell; only a few specific primitive types since hardware support is necessary. - `UnsafeCell` - wrapper type which warns the compiler that data at a location may change while shared, disables optimizations which would break cell types. Doesn't enforce safety rules against data races or illegal borrows; it does expect you to follow them. All cells contain `UnsafeCell`.
The first usecase of r# literals I have seen :) 
And it has up to three arguments.
Grep (or similar tools like `ripgrep`, which I'd recommend and is written in Rust) is a great tool for finding symbols and other things in a code-base. Perhaps some more sophisticated tools (like RLS) are better for many purposes, but I can use ripgrep with any project in any language without any special configuration and it can sift through even very large projects pretty quickly.
Ahh, got it, I didn't realize it did that. Neat.
If you're in an ocean you don't have to show water you retarded monkey
Use `derive_more` to derive `From` for enums, it's incredibly easy.
&gt;I think I'll now try to avoid writing C given the choice. C is kinky
&gt; Design discussions shouldn't assume every user uses a powerful IDE, or even syntax highlighting. They don't. At all. Not even slightly. It's mostly the opposite. They need to start catering *more* to that, I'd say. I've seen so many ridiculously long discussions about "readability" where the topic of discussion would not exist **at all** if not for the fact that **ALL** involved parties were seemingly using OldStalwartTextEditor3000 or whatever it may be.
Most languages with doc generators similar to Rusts tend to be able to output not just HTML but also often PDF as well as LaTex templates.
Having multiples version of futures and multiple versions of tokio. Some crate are still using the old tokio and are not usable with the new one (I think) or it's just really confusing.
I'll say ? Is your friend. You can write a couple of functions to do what you want with a signature if Result&lt;\_\_\_, Error&gt; and then just have one match that runs that function and displays the error if any. fn do_the_stuff() -&gt; Result&lt;_, Error&gt; { let req_body = serde_json::to_string(&amp;req_model)?; let res = client.post("[redacted]").body(req_body).header("Content-Type", "application/json").send()?; let res_body = res.text()? Ok(res_body) } fn main() { match do_the_stuff() { Ok(body) =&gt; { }, Err(error) =&gt; { println!("{}", error.display.to_string()); } Sorta pseudo code but that's kinda how it would look like.
I know there's work on it. I also know that it's coming awfully late, and at a point when all the fundamental tooling has already been architected around assumptions about nominal typing. Hence my answer to "what would you do differently" is I'd have built it around structural typing from day one.
Right, I wasn't disagreeing with you. It was just odd to write what you did and not mention Protocols.
Editions break your definition of Backwards compatibility too. So do new features. Doesn't that RFC only make turbofish *redundant*, rather than an error. Meaning old code will still work just fine. it just won't be idiomatic anymore. The breakage obviously wouldn't just be "theoretical" if it made turbofish an error, turbofish is obviously in use. The "problems" you list happen with editions too, and any of the other deprecated and replaced APIs. Not to mention the bigger problem of copying random bits of code from stackoverflow, blog posts, and irc. 
I think you read something into my original comment that wasn't there.
Hmm, no I don't think so. 
But editions are a rallying point at least. Otherwise, why even have them? New features, when backwards compatible, don't make old code not work anymore. I also noted in my top comment that I regard editions more as inter-compatibility than backwards-compatibility. The RFC turns things that are currently parsed as comparisons into type parameters, and thus breaks the language compatibility. It's not just about things being idiomatic. The quote further up says as much as well. And deprecated APIs are only deprecated and not removed for exactly this reason! So that things don't break. Deprecation instead of removal is a form of backwards-compatibility.
I said originally: &gt; The typing library, mypy and other tooling are all fundamentally built on ideas of nominal typing, but what you almost always would want and care about in real-world Python is structural typing. Nothing in this denies that people are working on structural typing. All it says is the truth: that the type-annotation and checking system for Python has been fundamentally built around nominal typing from the very start. That's a choice which has far-reaching effects, regardless of whether structural typing support is later added. I would have made different choices at the beginning, had I been in charge of it.
I didn't claiming you were saying people weren't working on structural typing.
Then why did you make a point of bringing it up and saying it was "odd" of me not to mention it? Again, the fact that it's being worked on *now* doesn't change the choices made back *then*, and doesn't change the *effect* on the Python ecosystem of having a nominal-only approach for so long.
&gt; Then why did you make a point of bringing it up Because someone reading your comment in isolation would read it as there not being structural typing at all. It was just adding information someone might want to know. &gt; saying it was "odd" of me not to mention it? It was just odd not to mention that structural typing exists. &gt; Again, the fact that it's being worked on now doesn't change the choices made back then, and doesn't change the effect on the Python ecosystem of having a nominal-only approach for so long. I'm not sure why you bring this up as I do not disagree with it and have made no comments about it.
This is idiomatic though, and proposed as one of the solutions to convert errors to the same type in their book, no sure it can be called a hack
&gt; It was just odd not to mention that structural typing exists. When PEP 544 is fully implemented with base protocol support in the Python standard library, I'll talk about it as part of Python. Until then, structural typing is, not part of Python. Right now you need a third-party library (`typing_extensions`) to get the base `Protocol` that triggers special-case behavior in `mypy`, and the whole spec is still a draft-status PEP. That doesn't mean it'll never happen; it does mean it's not yet a standardized part of Python.
Borrow checker is really scary only if you are coming from a language with GC and your ordinary coding patterns no longer work
&gt; a new student to programming &gt; green text in terminal Checks out.
also checkout https://crates.rs/crates/custom_error
Note that nothing fundamental actually stops GTK+ from working on the MSVC toolchain—​it’s just that the readily-available binaries have traditionally been MinGW-only. A few years ago I tried following the instructions at https://wiki.gnome.org/Projects/GTK/Win32/MSVCCompilationOfGTKStack, and porting that to Rust for use in a build script, but I got stuck somewhere along the way (can’t remember where). By the looks of it, progress has been made since then, with https://github.com/wingtk/gvsbuild probably being the state of the art, though it looks as though it still needs msys2 for part of the building, presumably because of autotools or some such thing. Not sure if they provide compiled binaries handily, though it looks like you could perhaps nab them for master from AppVeyor (though any such links will die after six months). But yeah, your reasons are pretty much exactly the reason why I gave up on it back then and haven’t seriously tried it this time round when looking into GUI stuff.
Interesting, I typically use `i32` or `u32` depending on whether negative values make sense or not. And when a variable is primarily an index, I go with `usize`. I don't need floating point numbers very often.
https://fosdem.org/2019/schedule/track/rust/
It does nothing of this sort. It just keeps your code from compiling until you come up with a workable design.
Would that be old testament C++ (90)?
That was my first FOSDEM and I enjoyed all of it. Thanks guys !
Thanks! I didn't know how the rule was called!
But my struct is only used in the type argument of the trait. The trait itself and the struct I implemented for are both external. 
Since my entire Rust life recently has been various parsing-adjacent experiments, I always end up trying to go [generic](https://docs.rs/num-traits/0.2.6/num_traits/int/trait.PrimInt.html), failing, then using `usize`. Other than that, my integer types are almost always short-lived and constrained by usage so I don't have to know their concrete type, just inference does.
I'm running a tokio runtime in `main()` on a `Box&lt;impl Future&lt;Item=(), Error=()&gt; + Send + 'static&gt;` I have constructed but inside the future I'm calling an async function that returns a `Future`. I've been trying to just make it synchronous with `.wait()` inside my function, but it hangs the thread. Then I tried to send a task executor to the worker thread, but that panics with an unintelligible stacktrace at startup. What are you supposed to do when you need async code inside a future?
if you're on nightly, there's the `try` block you can, uh, try: let result = try { let req_body = serde_json::to_string(&amp;req_model) .map_err(|_| "Failed to serialize request model".into_owned())?; let mut res = client.post("[redacted]") .body(req_body) .header("Content-Type", "application/json") .send() .map_err(|e| format!("Error during networking: {}", e))?; let res_body = res.text() .map_err(|e| format!("Error while receiving response body: {}", e))?; }; if let Err(text) = result { println!("{}", text); }
Oh. Oh wow. It took me a hot minute, but when I realized what you were doing with generics, my mind was blown. This is actually pretty genius.
Came back to this idea an posted another blog post, where I tried using a Binary Search. It didn't seem like there was any real performance improvements over the HashMap. Some runs would be better, but on average I didn't strong results with a Binary Search I think the next thing I might try is a static at compile time hash using rust-phf! Here is my most recent blog post if you are interested: https://coreyja.com/blog/2019/02/03/devicon-binary-search.html
I know this is a really nooby question, but I just can't figure out the install on windows10 and Ubuntu, could someone give me a YouTube video? Sorry... 
Speak for yourself, my nose is still swollen.
It's off topic, but from my experience compulsory avoiding duplication of even short code more often leads to poor code, then great code. Avoiding copy&amp;paste is one of those things that I call "circle of proficiency". Beginners suck at it, so get scolded by competent devs, but real senior guys are more nuanced about it, and know not to worry about it too much, and when even a long parts of seemingly redundant code are OK.
I use `u32` 80% of the time, `i32`/`u64`/`i64` 10% and `usize` the other 10%. --- Answer aside, I deal mostly with discrete data, and most of the numbers I store wouldn't make sense negative. `usize` is for dealing with indices into lists, but I'd never use it for anything else. Types smaller than 32 bits are... alright, kind of useful, but honestly it's easier to just grab a `u32` and not worry about the exact bounds of my data. `u32` is nice.
Nothing too big, but trying to strengthen my data structure and algorithm knowledge by slowly but surely going through all of the techie delight problems. I made a repo for it here: https://github.com/matrizx/techiedelight-problems-rs Trying to give as detailed explanations as possible.
Thank you very much 😊
For Ubuntu have you found [rustup](https://rustup.rs/)?
I'm going to need more information. What context are you talking about? A Windows exe is just an executable file. There's nothing particularly great or horrible about it compared to other platforms' executable file formats. Now when you have to handle more than a relatable single file executable then you could discuss packaging on different platforms for a year. But that's completely distinct from executable formats.
You do know Google exists, right? Your profile is full of lazy questions like this. If you need help, at least ask a proper question.
This seems like an XY problem: doing this kind of checking on generics is almost the exact opposite of how they're designed to be used. What is your situation such that you have this kind of structure, how are you creating it and what kind of different ways do you want it to behave for strings vs. integers?
Every argument to a trait can be thought of as another receiver.
I did Google it. The rust website said that the best way of install was through the CMD prompt, but exe is not preferable but ok. I do check before I ask, I just still don't understand as they gave a really vague answer, but thanks for the input. 
On their website they said that the CMD prompt setup was better than the exe file, but didn't explain why. 
I’d add IDE tooling to the list. It’s still far too flakey. As a minor annoyance I’m still not convinced by the module system. Still too much ceromany and not as simple as it could be.
I think normal variadics are less of an issue, but variadic generics are. I.e. needing to use a macro for something as basic as printing a string to stdout. Speaking of macros... I know it's controversial since a lot of people love macros so much, but I'm concerned about them being *too* quick to go to. IMO macros should be for things like avoiding repetitive code, DSLs, etc. but not as a crutch for a missing language feature. When your standard library relies on macros for something very basic, e.g. `println!`, I think it's a smell. Macros shouldn't be needed for this kind of stuff.
Are you trying to install `rustup`?
Correct me if I'm wrong here, but it seems to me that the fragile base class problem is something that occurs only when overriding of methods is allowed.
Yeah
I finished that, but at the end it says they will move it to the path directory, but I don't get what they mean by that. 
But what's the name of the executable? Is it `rustup-init.exe`? What page on the site are you getting your information from?
But WHERE. There's this page: https://forge.rust-lang.org/other-installation-methods.htm Probably has what you want. And it's not hard to find either, there's a big fat "Learn more" button on the installation page.
https://www.rust-lang.org/learn/get-started I'm not at my windows PC right now, but I remember when installing it said something about the exe file being worse. Maybe I'm just imagining it. Thanks for the link anyway though. 
I think so. I'm not on my windows PC now. I think it was https://www.rust-lang.org/learn/get-started , but I can't really remember. 
I'm not sure I'm a great coder, but I know I'm "senior", having coded continuously for about 40 years. I was kind of joking about the copy-paste, but I do find that copy-paste errors in code I review (by programmers of all proficiency levels) are responsible for an inordinate number of bugs and an inordinate amount of debugging time. They can be really easy to make and really hard to spot. So I'd rather err on the side of not making them when at all possible.
Not sure where you saw anything implying there is a problem with using the rustup-init.exe, as that seems to be the recommended default install method on Windows. Just follow the instructions [here](https://rustup.rs/).
Oh ok, I think I have got confused here. Thanks. 
Rust enums don't allow iteration over the possible values. They can't be used as array index types. They can't be gotten by casting a number. I forget which of these Java enums allow, but certainly at least the first.
Thank you! I'll look into it!
I hope the following answer is sufficient: The split between directly downloading `rustup-init.exe` and downloading and running a shell script is only relevant for Linux and Mac (unless you're using the Windows Subsystem for Linux (WSL)). Thus, downloading and running `rustup-init.exe` should be ok.
u64 / i64 / f64 for generic numbers. usize / isize for things in memory. u8 for ASCII numeric representation. Rarely use anything else unless I need to save memory or mildly reduce computation for some specific reason. Modern 32-bit processors even on small systems are usually fast enough and have enough RAM, so I'd rather not be bothered worrying about numeric wraparound. We're headed toward a 64-bit world and I want to be a bit ahead of it.
You can implement your own poll function for your future, which then forwards to poll calls to the "child" futures, and returns / acts on these result. Here is an example from some code I was playing with, where a future had an internal timeout. fn poll(&amp;mut self) -&gt; Result&lt;Async&lt;String&gt;, io::Error&gt; { println!("From deep withing the future!"); // Check for timeout match self.timeout.poll() { Ok( status ) =&gt; { match status { Async::Ready(_) =&gt; { if self.state != But2CmdState::StatusDelay { return Err( io::Error::new(io::ErrorKind::Other, "timeout!") ); } // Timout triggeres resend of status request self.state = But2CmdState::AwaitStatus; try_nb!( self.socket_tx.send_to(b"12345 s\n", &amp;self.dest) ); self.timeout.reset( std::time::Instant::now() + std::time::Duration::new(0 , 200000000) ); }, Async::NotReady =&gt; () } }, Err(_) =&gt; { return Err( io::Error::new(io::ErrorKind::Other, "timer error!!") ); } } 
&gt; But it's a deliberate design tradeoff: Python isn't trying to achieve the smallest possible string storage at any cost. Except by all reasonable benchmarks it always picks the wrong encoding. I did loads of benchmarks on this to analyze how it works and there are a few factors that make Python's internal encoding highly problematic: 1. It actually also carries a utf-8 buffer that is created by `PyUnicode_AsUTF8`. There are a lot of APIs that internally cause this buffer to be created. This means many (large) strings end up in memory twice. 2. Many real world strings contain one or two characters outside the basic plane. This causes Python to upgrade the string to UCS4 which is the most inefficient encoding for Unicode. The highest codepoint in Unicode is 21bit. UCS4 is 32bit. This is incredibly wasteful and never useful other than for direct indexing. 3. When streaming out unicode into buffers you often end up "reencoding" the buffer a few times. Start with an HTML document that is in the ASCII range: latin1. Hit the first unicode character in the basic plane, upgrade to UCS2. Hit the first emoji, upgrade to UCS4. Then later you need to send this all out, encode everything to utf-8. &gt; Add I know you personally prefer another approach, but that's not the same as your preference being objectively better It is objectively better to use utf-8 everywhere. In fact even if direct indexing was a desirable property the cache inefficiency of the current approach is likely to cause direct indexing into an utf-8 string with the access patterns python developers actually have to be superior. One could keep an index cache around and this is likely to yield similar results. It would completely break random accesses into large strings but that rarely happens anyways. &gt; Python uses exactly as much memory as it needs in order to achieve its preference for string behavior. Which shouldn't be a thing in the first place and should be deprecated asap.
`/internal` dir &amp;&amp; lowerCase should solve all issues. If you need more than that you're solving wrong problem IMO.
It would be impossible to do this the Java way with runtime reflection. However, a procedural macro should make this possible in Rust.
I had published first pre-alpha crate with an encoder for PostgreSQL `COPY WITH BINARY` format: https://crates.io/crates/pgcopy Going to learn how to write serde serializers now.
As a beginner to both Rust and programming in general I found the few examples up so far to be helpful, thanks! 
rustup installs rust in your home directory. When you type a program in terminal, the interpreter will search for that program in a list of folders like /bin, /usr/bin etc. That list of folders is stored in an environment variable called $PATH. After installing rust, the path to folder containing rustc, cargo etc needs to be added to $PATH. I don't remember whether rustup added its folders automatically or I had to add manually last time I installed. What exactly did the message say?
You and I are never going to agree on this. I will say, though, that I think you're too heavily focused on optimizing the use cases you deal with, and as a result discarding or pessimizing the ones you don't deal with. Language design is about tradeoffs; Python has made some that help you and some that don't, but there's no way to make a general-purpose language that doesn't have that property.
I've now tried compiling with rustc and it does compile, the thing is i want to test the program before building a .exe file, I'd rather compile with cargo, but if I'm unable to i will use rustc, thanks
The failure crate is your friend for this case: make your function return a `Result&lt;(), failure::Error&gt;` and modify your function as following: ``` let req_body = serde_json::to_string(&amp;req_model).context("Failed to serialize request model")?; let res = client .post("[redacted]") .body(req_body) .header("Content-Type", "application/json") .send() .context("Error during networking")?; ``` etc.
This kinda sounds like a poltergeist story, but right after compiling with rustc cargo started working just fine, for no reason, nor more errors, so i guess you were right, compiling with rustc somehow fixed it!
I'm sure you already know this but Rust has inheritance, just no data inheritance. Traits provide behaviour inheritance.
Other posts has said it too and I want to chime in, map\_err, is great! &amp;#x200B; Here's an example of map\_err from something I fiddled with recently: [https://github.com/anderejd/cargo-geiger/blob/7332ea9572e6e61c9358902b33141476c60bd7ce/src/lib.rs#L379](https://github.com/anderejd/cargo-geiger/blob/7332ea9572e6e61c9358902b33141476c60bd7ce/src/lib.rs#L379) &amp;#x200B;
You have my mighest respect for starting to program at all with Rust.
I'm planning to put out a release version of my [CO2 sensor crate](http://crates.io/crates/co2mon). Now with Windows support!
i think you're on to something... i've edited the main post with a playground MWE to show what i wanted to do, but which doesn't work. it feels like i need to adapt my design to fit the rust way better, but i'm a bit lost as to how exactly :/
[strum](https://docs.rs/strum/0.13.0/strum/) is a great set or derives for working with simple C-style enums. In particular, `EnumString` derives the standard string to enum-variant conversion, and EnumIter derives code for iterating over enum-variants, among other useful stuff.
Yeah, that's a good point. I realized after writing this that I have also sort of conflated inheritance with subtyping. Rust's trait objects presumably count as subtyping too, so it's wasn't even valid to say Rust doesn't have that.
I don't agree with the idea that everything needs a devil's advocate. Python's unicode model is objectively bad and there is a reason why nobody else does it this way. The *only* benefit you get is O(1) indexing into character points. The usefulness of this is questionable. However for the vast majority of cases where people do direct indexing it does not even perform better than an UTF-8 string. Many of the assumptions made for this design are grossly violated in the real world.
I'm implementing all relevant embedded-hal traits for [rppal](https://github.com/golemparts/rppal), which are a perfect fit thanks to the recently revamped `Gpio` interface. I'm also working on a software-based PWM implementation to allow PWM on any GPIO pin (in addition to the existing hardware PWM support).
I write a lot of graphics code. `u16` is rare and `i8`, `i16` and `i64` almost never occur. `u64` for gpu memory `u32` for lot of stuff, as Vulkan use it extencively and sometimes `i32`. `u8` usually in form of slice to represent raw bytes. `usize` and `isize` for sizes and offsets.
I write a lot of graphics code. `u16` is rare and `i8`, `i16` and `i64` almost never occur. `u64` for gpu memory `u32` for lot of stuff, as Vulkan use it extencively and sometimes `i32`. `u8` usually in form of slice to represent raw bytes. `usize` and `isize` for sizes and offsets.
I don't have experience with flutter, but I've also found rust's gui libraries to be pretty unergonomic to work with. The [gtk](https://crates.io/crates/gtk) crate leaks through a bunch of glib stuff, and has threading issues. [relm](https://crates.io/crates/relm) is nicer, but enforces a very specific structure. For less general purpose GUI stuff, [conrod](https://crates.io/crates/conrod) is pretty great, but it's specific to a much more limited use case and doesn't need to support a whole bunch of complex widgets. I'm not 100% sure that the problem with rust GUIs is just the lack of data inheritance though. It seems like, similar to interacting with the DOM in webassembly, managing lifetimes in a retained mode GUI is very hard and doesn't map well to rust's borrow checker. I remember seeing data inheritance related RFCs before, and I found [this](https://github.com/rust-lang/rfcs/issues/349) issue which has links to some as well as discussion. If you haven't seen these already, I'm curious if you think it would help with the type of API Flutter has.
I've been working on something this week, just using `syn`, and I've ended up writing a ludicrous amount of code, to achieve something relatively simple. 
&gt; typeobject method loopup struct What is that?
&gt; One of the biggest problems with inheritance is that it does not ensure that "a function that worked with the base type can work unmodified with a type that extends it." - because of the fragile base class problem, which is exactly the pathology inheritance introduces over composition. That's entirely wrong, inheritance has no part in this. The problem occurs because of dynamic dispatching - and as we all know, Rust *does* implement dynamic dispatching. Case in point: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2d73694150899e47141040869661a7e9 vs https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3b6fc353d15d0935fce72d61f43623d6
Graphics without any floating point numbers?
AFAIK you can merge the 2 match arms into 1 match arm which would look something like this match self.timeout.poll() { Ok(Async::Ready(_)) =&gt; { //code here }, Ok(Async::NotReady) =&gt; (), Err(_) =&gt; // more code here }
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/neovim] [Neovim plugins in rust: A step by step guide](https://www.reddit.com/r/neovim/comments/an0bjr/neovim_plugins_in_rust_a_step_by_step_guide/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thanks, looks like it will be useful!
GTK+ on Windows
Hi - author here! I'm by no means a Rust or VimScript expert and this started out as me trying to create a plugin for Neovim to learn me some Rust. There weren't a lot of resources on how understanding this process, so I made one to hopefully help anyone else and my future self as well. I imagine the code isn't the most idiomatic, I'm working on it! :)
The fundamental problem is that you're trying to use `self` to access the same object from different threads but, looking at your example, it looks like you also don't really understand Rust's lifetime system. (Trying to use `move` to and `&amp;mut self` together is a telling sign of that.) My general advice is to hand entire objects between threads, rather than trying to just hand pieces of them around. 
The feature is pretty easy to use in itself (if you're using the function, not writing it). Just like `scanf` and `printf` even if we all know that the first one is a security hole and the second one can become one pretty quickly too (but it's been improved a lot since now compiler check the `printf` string).
I want to use the newtype pattern to make a new type of vector which I'll call ItemList. I also want to use the newtype pattern to make something called ItemIndex which holds an integer. I want to make it so that ItemList and ItemIndex are coupled so that an ItemList can only be indexed using ItemIndexes (or used with range, or any other way that vectors are normally accessed). Is there an easier way to do this than manually implementing and wrapping the functions for index, range, etc?
on windows, the installer asked me to add the folders to my PATH vars, yet when I tried cargo and rustup on my console, they worked
I'm really interested about the anonymous associated types hack, however I fail to understand how to apply it in a trait as to emulate a function returning an `impl Trait` in a trait. In the example a free-standing function is used to return an `impl ProduceStuff`. Also, I'd need to return a generic type. Am I out of luck in this case and have to wait for existential types or GAT or is there some other work around?
Nice writeup, thanks. Here are some comments: 1. You can avoid most of the vimscript and use lua in neovim. I certainly lean that way :) 2. Logging is invaluable. Set it up in your crate, it's easy enough. You can't debug via `println!` because your stdout is connected to neovim (that should be uppercase, I've no idea how often I've made this mistake and had to dig to find the stray `println!` I forgot), and you need some [special setup](https://github.com/KillTheMule/nvimpam/blob/master/lua/nvimpam/job.lua#L99) for `errprintln!` to be useful, so just set up logging. 3. Logging is invaluable. Compile your neovim with `make CMAKE_EXTRA_FLAGS="-DMIN_LOG_LEVEL=0"` and use `NVIM_LOG_FILE=./logfile nvim` or something similar to get a detailed output of neovim's side of the communication. 4. If you need to go that deep, [a simple script](https://github.com/KillTheMule/nvimpam/blob/master/files/redir.sh) and a [msgpack decoder](https://github.com/KillTheMule/nvimpam/blob/master/files/decode.py) (you can also use nvim to do that) is invaluable in capturing all the communication and verifying things. 5. Neovim comes with a great test infrastructure that I can only recommend to use. I've written a [blog post](https://github.com/KillTheMule/KillTheMule.github.io/blob/master/test_plugins_from_neovim.md) about that. 6. That the `Handler` is moved into another thread brings a probability for race conditions, because this thread blocks on running the handlers. It might not hit you, see [here](https://github.com/daa84/neovim-lib/pull/23) for a first shot at fixing this. My guess is that a good fix needs `async/await`, but this is certainly an improvement :) 7. I've posted [this issue](https://github.com/daa84/neovim-lib/issues/24) to neovim-lib since I think this post is a good start. The docs on neovim-lib are a tad lacking. 8. If you want your plugin to be a good neovim citizen, you might want to consider setting [the client info](https://github.com/KillTheMule/nvimpam/blob/master/src/bin/nvimpam.rs#L121).
Great tips, thank you! I'm just a beginner getting started with such applications so any advice is certainly appreciated. I was aware of the Lua route, but did not want to add a 3rd language when trying to learn VimScript and Rust! Certainly seems interesting though.
Having to constantly use "as type" to cast variables when I'm just doing math. How hard can it be to add a u32 and a u64?
Sounds like https://kyren.github.io/2018/09/14/rustconf-talk.html ...
Do not forget that `println!` also produces compile-time errors if number of arguments is bigger than provided in the formatting string, or one of the arguments can not be formatted using given options.
Airplane mode presumably means something where you want to be able to run commands without any network connection.
I haven't had the chance to explore this space very far (resources management in the context of a rendering API) but I had the following ideas: Use indices to reference resources. Eg. `Texture` just wrap a `u32` and methods to interact with this texture live on your renderer (which owns the resources). As for your resource manager, you can ask the caller to pass you the renderer as an argument: `fn load(&amp;mut self, renderer: &amp;mut Renderer, ...) { .. }`. I imagine the resource manager doesn't need to hold on to the renderer, just temporarily being given a access to the renderer to do its thing. In this way I managed to keep out all `Rc` out of my implementation and make the whole thing more data oriented: Figure out resource ownership and don't spread it out over too many places. Reference resources by handles whose properties can be accessed by asking its manager. Figure out how you can pass resource manager by argument to where it is needed.
It's a matter of reducing the complexity of payroll, etc in multiple countries. We already have this setup for these three countries.
Almost only `i32`/`u32`/`f32` at work, and `i64`/`u64`/`f64` in private code. `usize` obviously for indexing-related things, and sometimes `u8` when some buffering is involved (but it is rather not num type in this context, at least not sematicly).
But what if you unload that texture and load a new one at that index? Of course, you shouldn’t unload textures when they’re still referenced. So, you can mark them as being in use. Since there might be multiple users of a single texture, use a counter to count the number of references. Now we just have reinvented `Rc`.
Sure thing, don't hesitate to send your application.
The issue is a simple `From` conversion is context-less. So `From` can't discriminate between different codepaths generating the same error type (unless these codepaths generate markedly different error *values* and then you're back to hand-rolling the conversion), which can be less than convenient.
FWIW you can just type `main` as returning a `Result&lt;(), Error&gt;`.
Currently my `Texture` class is exactly as you describe, although it also wraps a `width` and `height` for convenience. One reason I avoided the approach of passing the `Renderer` into the load method is that it means the `Renderer` needs to be accessible in contexts where it doesn't make sense for it to be generally accessible. e.g. within `update`. By passing it as a parameter to `draw` I can ensure that it's only being used directly in places where it makes sense to do so.
Yes, resource unloading is 'a problem' I haven't fully worked out yet. One pattern I was thinking about is to _never_ deallocate the _resource identifier_. Once created that resource identifier is forever associated with that resource. However! that doesn't mean you can't manage the underlying resource! Eg. you can unload it from GPU/RAM if it is unused and load it back in when it is needed. This can still be problematic in terms of dynamically created resources, but there are workarounds here (eg. keep a fixed number of 'dynamic' resource identifiers which are reused as needed, hopefully by this point you won't need generic resource management and you know exactly the lifetime of your dynamic resources).
It's definitely a hack when you're permitting the conversion of literally all other types into a generic error. Pretty sure the book doesn't recommend that ;-)
I once had to use it in an import. the redis crate has(or had?) a module called async, which is now a keyword. 
The one I definitely use the least - `isize`. The most - `usize` (because of indexing).
I think what you're looking for is implementing Deref and DerefMut like in [this example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f71676c9d9e4d36b3d40368b0b12c599). [Here](https://doc.rust-lang.org/book/ch15-02-deref.html) is more information about how these traits work.
One thing I'm curious about is the following: Does your ResourceManager manage GPU resources? If yes, I would recommend that your Renderer owns and manages all GPU resources. I imagine ResourceManager more like an abstraction over the filesystem letting you read/write to the underlying files. Then create_texture doesn't touch the filesystem, instead given a slice of bytes representing a texture file it creates an associated GPU resource. This keeps your filesystem and your renderer separate and disconnected, clearly separates concerns (resource manager manages file system resources, renderer manages GPU resources) and should work well within Rust's more data oriented way of working. This discussion will probably go a lot better with your actual code as a reference, is it available online?
I've just finished [implementing the Reingold-Tilford algorithm](https://crates.io/crates/reingold-tilford) for an upcoming project I'm working on, and I'm now trying to figure out which GUI framework would be best for said project (probably OrbTK, but we'll see). 
Yes. Set the `CARGO_TARGET_DIR` environment variable.
The thing is, once you implement all the details and fix every obscure issue, you arrive at the same solution as `Rc&lt;RefCell&lt;&gt;&gt;`. You can only skip on the details if you can make assumptions that the generic implementation can't do (like that you never want to unload anything).
Variadics are lot easier in D than in C++, especially since recursion isn't mandatory.
But they're not a mess in D...
&gt; Perhaps it would be more efficient to just let the &gt; cross &gt; project independently handle everything that's proposed for Cargo for 2019 and accelerate the timeline for the other improvements by 1 year. The cross project has almost zero manpower behind it. Keeping it barely working consumes most of their maintainers time.
Perl is hardly the most esoteric tool and is for many purposes "good enough". Yes, you can write very esoteric code with Perl, but it can (and often is) written in an normal form any programmer should be able to grasp. The only peculiarities are the function definitions (no argument lists, everything comes in as a list) and despite it being a dynamic language it distinguishes between (a limited set of) normal types and references. &amp;#x200B; \&gt; Re: rust implementation, it would be nice to not have to install the entire PERL system to run one tool, especially when most system tools have are written in Python or something. That's the thing. A lot of system tools were written in Perl because it precedes Python and other more modern languages. It was one of the first scripting languages that was generally available on a lot of platforms and it's capable of munching data in any shape or form (I've even done native syscalls for netlink sockets with in memory linked list from pure perl). And it's performance is very deterministic (though not necessarily fast perse). &amp;#x200B; I concede that it's not the most mainstream language at this point in time and that for most purposes there are better alternatives. But it's a language in which you can be very productive, write maintainable and reasonably performant code but that also carries a lot of historical baggage which makes it a lot less accessible for newcomers.
IIRC, Jython did that many years ago.
`create_texture` does currently take a `&amp;Vec&lt;u8&gt;` and returns the handle to the GPU resource. All the `ResourceLoader` does is load the bytes from disk and caches the texture handle. I think what I’m getting from all the comments so far is that I need to switch my mindset, currently I’m trying to emulate the patterns I use in C/C++ where you can get away with loose ownership and that is why I’m coming unstuck. I’ll share some actual code in a bit, I didn’t want to make the OP a giant code dump.
Err, a typo, meant "lookup". I meant: https://docs.python.org/3/c-api/typeobj.html It's not really an optimization, but a core part of Python object C API; but from reading the RustPython code, looks like it currently has nothing similar to this and thus does some basic things slower. Currently, for eg `a + b`, CPython can do some pointer dereferences to directly call the adding function (basically `a-&gt;type-&gt;numberfunctions-&gt;add(a, b)`) and only uses `__add__` as a fallback when a C function is not defined. RustPython only has a dict, so for each addition you need something like `a.type.dict_get("__add__").call_native(a, b)`.
&gt; to lots of character building Or characters jumping off buildings, something I can definitely see the borrow checker causing. Even after years with rust, it still remains the #1 most difficult computer-related skill I've learned. It got bad enough at one point that I started to seriously contemplate giving up on programming altogether. Those were dark times... But yeh, "character building" :o) 
That was a really good read. I don't want to go down the ECS route as it's a bit overkill for the simple game I'm making. There was still plenty of useful bits in there though around making things more "rusty".
That’s what generational indices are for.
It would have to convey the same type information somehow, without being very verbose. I doubt this is possible without using punctuation.
Same here, I'm a huge fan of custom attributes, but the part where one have to parse the attribute's fields is clearly very boilerplate-ish. I'm pretty sure that a tool like this could be easily implemented, tho: ``` #[foo(bar = "hello", baz = 42, /* optional: */qux = true)] fn test {} //... struct FooAttributeOpts { bar: &amp;'static str, baz: i32, qux: Option&lt;bool&gt;, } //... #[proc_macro_attribute] fn foo(_input: TokenStream, args: TokenStream) { let args = parse!(args as FooAttributeOpts); //... } ``` If nobody's doing that, I'll do this.
I've only done very simple stuff in both, but I had a way better experience with actix-web than I did with anything in haskell. It also performed way better from the start. However, I would say that both languages / ecosystems are not as well suited for the web as other languages at the moment. But this should be changing soon in rust.
You can write reasonably trivial derive-macros which will enable all of these (custom trait for iteration over values; From/Into generated impls for converting to/from ints). Maybe such derive macros already exist. You can also use [`as`](https://doc.rust-lang.org/rust-by-example/custom_types/enum/c_like.html) to cast to ints.
Does cargo then somehow name the different target directories differently if I set it system wide?
Working on a API library for the class royal api
I don't know.
`darling`, from what I see, is focused in custom derives. I was able to parse this: ``` #[foo(bar = "hello")] fn ... ``` but had no success with this: ``` #[foo(bar = "hello", baz = 42)] fn ... ``` In other words, everything with exactly one attribute worked, but it failed when I've added another attribute. 
In next week’s edition, we’ll ask wether gumboots or irony are better for making soup. 
Attributes on fields, or what? I've had good success with attributes on structs. I've built a couple of things for myself with Darling. I should probably polish them, then release some... like here's an example of one where I really should be using str instead of String. ```rust #[derive(Debug, JsonEndpoint)] #[jupiter( url = "https://sheets.googleapis.com/v4/spreadsheets/{spreadsheet_id}/values/{range}:append", method = "POST", ty = "self::append::AppendValuesResponse" )] pub struct AppendToRangeEndpoint { spreadsheet_id: String, range: String, #[jupiter(role("Body"))] body: ValueRange, #[jupiter(role("Query"))] query: self::append::AppendOptions, } ```
if you don't know which one to pick and have a background in the imperative language. go with rust.
Glad someone appreciates it. Was in a hurry to come up with a name while at RustFest Paris last year.
Ah I suspected SDL2 might be involved and it does exactly what I wouldn't do in Rust. The [Texture](https://docs.rs/sdl2/0.32.1/sdl2/render/struct.Texture.html) type appears to both be borrowed and also hold a pointer to the renderer internally. Which is odd because your code doesn't have a reference when using textures? A small nit but you there are very few reasons to take `&amp;Vec&lt;T&gt;` as an argument, `&amp;[T]` is probably what you want instead. Yes breaking free from C/C++ patterns is what made Rust far more productive for myself. In a way Rust claims to be compatible with C APIs but in reality C style code is very very hard to adapt to Rust in a direct fashion. Rethinking how the various pieces of data relate to each other, using indices instead of shared owernship where needed can make for a much better Rust development experience. I don't really have any specific advice to your code, but I can't help but feel your ResourceManager is... too generic? What kind of resources do you imagine it to manage that you can't deal with a little bit of duplication? It looks like all it does is make a cache, can't that cache just live inside your Renderer object? Embed the hashmaps you need for Textures (, ... and?) in the Renderer and add methods to fill it directly on the Renderer type. In my experience it is _far easier_ to refactor the code later into separate reusable blocks once you have an idea how you want your code structured than it is to later break up abstractions that don't work out. Let yourself be guided by the link posted by /u/steveklabnik1 (really really cool stuff in there!) and write your code in a dumb fashion first and refactor it later as needed.
Yes, trying to test a Commandline application. Sorry for the late reply.
&gt; Failure, error chain, and the million ways there exist to handle errors so that code can interoperate. To me it is. Just use enums. Not one giant enum that contains every possible reason for anything to go wrong in your entire library, but per function (or set of related functions) a specific enum with the ways that that specific operation can go wrong, and (if applicable). If some of the variants have extra information (possibly a backtrace), put that information in a `Box`. Then use `map_err(|err| match err { ... })?` to map between different enums. The issue with errors is that people try to make them do too much. To me it seems like backtraces should be the job of the debugger, not the program itself. The `?` operator is nice but people try to make it do too much, and they forego the mapping of errors, often at the expense of the user. It makes for a much better API if fine-grained errors of sub-operations are grouped into coarser categories (and this can be done without loss of information).
If you're not asking to override methods then I think you're asking for delegation (for which there's an RFC) rather than "inheritance".
At CurrySoftware we write our backends in Rust. I explored writting them in Haskell for a bit, but decided against it, mainly because we're already familiar with Rust. A little bit of our experience: Advantages of Rust: - Tooling and libraries are good (cargo, cargo-deb, rocket, actix, etc.) - do not worry about performance problems: your code will be fast Disadvantages of Rust: - sometimes cumbersome to write - in comparison to Haskell, Rust code is very noisy and IMHO ugly - lack of cool type-level stuff that would allow a [servant](https://haskell-servant.github.io/)-clone in Rust - as we write our frontends in Elm, switching languages is also a bit of a mental overhead
u32 master race
Adding attributed variables to my Prolog implementation, \[rusty-wam\]([http://github.com/mthom/rusty-wam](http://github.com/mthom/rusty-wam)). This is a major threshold-crossing moment.. it's the first step in enabling the creation of very powerful, sophisticated constraint solvers.
Indeed, but unlike Jython, this wouldn't be tied by the hip to the JVM.
You didn't really answer my question. Assuming you're talking about *interactive* command-line application, it's important to understand the application is not really real-time. You can pass all input and read all output at once. The result will be same as when you run the program manually. So, with `assert_cmd`, you could set input `.with_stdin().buffer("input1\ninput2` and check output `output1\noutput2`.
If you mean this: https://hackmd.io/ZUEHoEgwRF29hbcIyUXIiw# I don't think that quite addresses the problem. What you want to look at is this: https://internals.rust-lang.org/t/summary-of-efficient-inheritance-rfcs/494 The problem is described in the background section.