No problem! And wow I would have thought it would at least move the needle! I guess now I'm annoyed the internet is so good everywhere. :)
Been ages since I used a linux GUI _(been on OSX for ~7years)_, and yea for the last ~8 years I've been 100% terminal vim and kakoune. Big fan of keyboard only, modal navigation
https://github.com/vegard/prog-fuzz has been used to fuzz rustc. It has AFL instrumentation combined with grammar-aware mutators. Plenty of bugs found by it are listed at https://github.com/rust-fuzz/trophy-case
Appreciate the sanity check. Thanks :)
I've seen people implement Drop for a struct to do some custom thing when it is dropped from memory. Is there any inverse of that so I can do something whenever a new instance is created?
&gt; Uh, so you run a BFS for every deallocation of a potentially cyclic graph? It seems like that would be the only way of guaranteeing *deterministic* destruction of unreachable objects given the possibility of cycles - which is still *hella cool*, and a lot more than what typical GC gives you. There may however be ways of optimizing this further at reasonable cost - one would need to look at the general literature on "incremental" algorithms on graphs, to see what they have to say about reachability (which is what you need to 'trace' in order to do gc).
Cool! I remember seeing some of those bug reports and I was wondering about the process behind them.
AFL just kills programs that take too long and records them as timeouts for further analysis. It also avoids mutating these inputs further. AFL is remarkably robust.
1. This would require `From` and `Into` to be treated specially on a language level (or add a language feature to describe transitivity) 2. (more importantly) Conversion functions can lose information AND there could be multiple "routes" from A to C, which yield different results. I would also ask: how should the compiler choose when there is a choice of intermediary types, and is this algorithm easy for humans to reason about?
Looks really nice, although I've never used them. Scala is a very cool language, unfortunately my company uses Kotlin instead.
So macros?
They claim "memory safety" even though the borrow rules are only enforced at function boundaries (at best). This doesn't sound correct to me.
When it aborts, it releases the memory, but does it also free ports, file/database handles, etc.?
I loved playing with cockroachdb, have you tried yugabytedb?
Not yet, it was a little too immature for my tastes when I last looked at it.
Talking out of ignorance, how can a music festival have so much rps (7k)? Stackoverflow ats peak does 450rps.
I'm confused as to exactly how reference counting interaction with ownership and borrowing is supposed to work. I think what the document is saying is that you can't borrow references to the inside of reference-counted objects at all. (Presumably it means only mutable reference counted objects, since for immutable ones there is no problem with borrowing.) If so, that's surely extremely limiting. It would mean that reference counted code would have a hard time interacting with libraries that expect to be used in an ownership/borrowing style. Rust is not immune to this problem either—for example, it hurts Rust implementations of GTK+, where the whole GObject system expects all objects are aliasable and mutable, leading to a `Cell` and `RefCell` explosion. However, the advantage Rust has is that the entire crate and library ecosystem, as well as a lot of C APIs, are oriented around ownership and borrowing, so you don't run into this problem very often. This would not be the case in D (or in C++, if it added ownership and borrowing), which means that you'd be hitting interoperability problems a lot more frequently.
Yeah I remember that some features where missing that I commonly use and the pg wire protocol was a little unstable back than. Maybe I should revisit - just wanted to know if you had any experience because you mentioned cockroachdb. Not many people have experience with it.
Wrong forum, my friend. You want to post this on r/playrust. Good luck!
This is only designed to catch common problems, not be a holistic solution like in Rust. I'm skeptical that there's a way to add truly safe borrowing and ownership to C++ while retaining any semblance of backwards compatibility. The resulting language might well be called a new language, IMO.
I'd definitely recommend checking out TiDB as an alternative, though it seems like the pg protocol is a requirement for you and it implements the mysql protocol. It's pretty mature, very recently released v3.0.0, and its underlying KV was written in rust (rocksdb storage engine). It's a little more operationally complicated because you need to deploy three separate components, but I kind of like that since if you need to scale you can select which component.
Make the fields private, and provide a method to make instances of that struct. Then, the only way to make the struct is with that method, so you can put the desired code in that. pub Struct { foo: String } impl Struct { pub fn new(foo: String) -&gt; Self { // Do something here... Self { foo } } } This is also how you can make sure variants are kept about the struct, by validating the input and not providing any way to directly change the fields.
Thank you for your feedback. I’ve found an optimization to the BFS algorithm to only traverse forward links. This means that the runtime complexity is `O(links in cycle)` instead of `O(links in graph)`. The reachability trace does not propagate up to the GC root. I am loving this code review via Reddit. 🙃
Agreed. I suspect if they toned down the `&amp;T`/`&amp;mut T` rules into something closer to `&amp;Cell&lt;T&gt;` (and gave up on multithreading or solved it another way) they could stay pretty close to existing idioms. But I doubt they'll ever attempt any kind of sound implementation, given the rhetoric around it and the current design.
I have it on my Todo list. PG is not really a requirement I am just comfortable with. I was bitten by a quirky utf-8 shenanigan in MySQL back than and some error/data loss because of silently truncating data that would not fit. But that's mostly because of my lack of knowledge in the MySQL world. I just avoided it since then without any good reason. I think that's just how the brains work if you got bitten once because you where unprepared for the task/situation.
I've mostly moved to IntelliJ now, but before I discovered that, I used to use Kate religiously. It's a great editor.
Very nice! I'm also working (on and off) on a tool which has some overlap with this: [https://github.com/agersant/tiger](https://github.com/agersant/tiger)
Oh yea totally, don't blame you at all.
Tbh, I feel like more languages should have self-destruct mechanisms, so the best parts of them can be taken and reformatted into different languages, leaving behind the bits best forgotten. Computer science and engineering are still very young fields, and we’re clinging way too much to languages that are now dated and don’t represent the complexities of modern programming. I don’t think there are many C++ programmers who wouldn’t complain that the language now has too many bits stuck on - too much complexity just waiting to blow your feet off at the earliest opportunity. It’s time to retire it and move on to better languages, where possible
Nice case study, and glad to hear that handled the task so well! No offense intended to OP, but any time I hear somebody say they chose DB x over all other options, especially without substantiating evidence and an explanation of why their use case is special, I am very skeptical. I personally think it’s fine to choose something simply because you know it well, and I’m sure mongo does great for your use case, but that doesn’t mean other options could t have handled it just as well, or perhaps even better.
Is cargo-generate teaching people not to worry about adding dependencies? You could argue that it helps people start projects with a carefully chosen set of dependencies put together by an expert, instead of needing to understand the whole ecosystem from day one. But either way, I wish you had phrased things with less "labeling" of the people you're talking about. You called them "lazy coders" who "believe the world is a pony farm." If your goal is to educate people about coding better, isn't talking this way just going to alienate them and get in the way of what you're teaching?
One of my first was a CLI based tic tac toe game. Should show you string manipulation, memory management, and networking if you decide to implement a multiplayer feature.
What happens if you create a cycle but forget to "adopt" the Rc's? Does this cycle just get leaked? And what about if you break the cycle but forget to "unadopt"?
This is the subreddit for the Rust programming language. You're looking for /r/playrust
I appreciate your efforts none the less. Thanks for taking the time to make a post; it's so cool to see the community spreading.
If you create a cycle and do not track this with the adopt API, the structure leaks just like `std::Rc::Rc`. If you break the cycle but forget to unadopt, the object is kept alive until the cycle is deallocated. So a leak, but one that is cleaned up.
That will vary by platform and by things like socket options. The most typical case is that such things are immediately freed, and TCP connections terminated. Another case is that things like bound sockets will not be freed immediately, but only after some timeout (which I think tends to be one or five minutes). The worst cases are encountered when you have resources shared between processes; then zombies can rise and resources not get freed properly.
You are checking the actix-raw, which is not the one getting better results. That's just disonest...
Is it possible to recover a cause from catch\_unwind()? If so, I would appreciate some help understanding the error type it returns. For reference, here is the declaration of std::thread::Result&lt;T&gt;: `type Result&lt;T&gt; = Result&lt;T, Box&lt;dyn Any + Send + 'static&gt;&gt;;` I have no idea where to start with this, so I appreciate any insight you're able to offer.
Thank you, but I actually know what I was checking! I went through all of their benchmarks for about 15 minutes and just listed what I came across as I went. You'll see that the changes to the default allocation are in all of their benchmarks, but you are correct that the raw one contains the unsafe/header stuff. That's fine though, because I wasn't referencing any specific benchmark but rather "benchmarks" as a general thing. Sorry if that wasn't clear in the above discussion. Maybe I could have worded it in a better way, but given that I provided the links to the referenced code I'm not sure how that can be considered dishonest ¯\_(ツ)_/¯
Are you building this from knowledge of how to implement one or is it all from referencing existing projects in other languages and then optimizing it in Rust with additional features/improvements afterwards? I see a fair amount of rust projects that go with a ray/path tracer, but not any that can something similar like baking normals from a high poly mesh to a low poly, where the viewport is instead a 2D texture rendering information to the low poly mesh UVs. I guess it's not as fun visually for a project, but it's of practical interest to me :) I just don't see much material on it. I'm especially interested in baking vertex colours. I'm sure it's a roughly similar approach to ray/path tracing, just in a different context?
Congrats for the name!
What are some pros of Intellij over others like Kate? I haven't used IntelliJ for around 6 years, I think I might have moved off when they had changed to a subscription model, or because of some memory/performance issue that stemmed from Java, may have also been something to do with UI looking out of place on my Linux distro(that might have been a different Java program).
A ray tracer ? [raytracinginoneweekend](https://github.com/petershirley/raytracinginoneweekend). The book uses c++, but I think it's a good practice project for any PL learning and it's a lot of fun.
The default allocator I actually support and think everybody should do, it's jemalloc, which some months ago was the default allocator. Changing rust's default allocator decreased performance of a bunch of software. And I get the benchmark's problem but I have an actix server in production and it's very similar to the benchmark. So it kinda shows actix strenghts in the wild. I'm sorry if I was too agressive, but the example seemed very real to me. After some months of optimization the server was tweeked for peak performance, the benchmark replicates it.
https://crates.io/crates/libloading/reverse_dependencies
https://crates.io/crates/cargo Click `Dependant Crates`.
I almost never hear about it outside contexts where people are specifically talking about the KDE ecosystem. Even if someone uses Linux but only in the Gnome-sphere, there's no reason to be surprised they haven't heard of it.
[cargo tree](https://github.com/sfackler/cargo-tree) has output very similar to npm.
I guess it’s whatever you subscribe to; IMO your benchmarks should represent how most of your users will use your stuff. If most people won’t change things like the default allocator, then I don’t think that should be what you benchmark. Now, if Actix has documentation explaining to do that, then of course it’s a different story. Maybe they do and I’ve just never seen it? If so, naturally I retract my objection there. Don’t worry about it, just tired of people making more of this than it is :). It is a shame this topic is overshadowing the hard work people put in to Gotham v0.4, and I feel that’s unfair. People bring up benchmarks all the time and I basically want to avoid the situation where Gotham is pressured into nickel and diming percentages, much like how Hyper was in their benchmarks. I’d rather set the expectation that it’s unlikely you will see similar numbers from Gotham, and outline why, rather than people just assume that it’s “slow”. I feel I’ve been quite transparent in this and so it’s fairly disheartening to see how people react, that’s all.
Unless you're allocating in a loop, the overhead is essentially nil. You may have been burned by other languages' arrays which may have been entirely dissimilar in nature; e.g. python lists.
I did a CLI version of Conways game of life. It allowed for some fun design and ownership conundrums (does the board own the cells? How does updating work?) as well as debug formatting/ working with stdout. I also was then able to extend the project into file I/O to read in common file formats describing cool configurations.
That's my point, most users that need that kind of performance will change the default allocator. It doesn't make sense to compare benchmarks of extreme situations thinking about users that won't ever achieve those. To most users a node.js server will do. They won't care about that benchmark. &gt;Now, if Actix has documentation explaining to do that That's a great idea, but one can only ask much of the developers, create an issue or hit fafhrd91 on gitter (or the actix channel). That's a good way of helping the ecosystem. &gt;It is a shame this topic is overshadowing the hard work people put in to Gotham v0.4 I agree completely and I was fairly rude, I'm sorry, it's just that I've seen people complaing about those benchmarks without much proof and wanted to clear up. &gt;I basically want to avoid the situation where Gotham is pressured into nickel and diming percentages Hey, I just wanted to give my input, I know the maintainers changed, but I've used my fair share of gotham, I went with it because of the readme promise "Blazingly fast. Measure completed requests, including the 99th percentile, in µs." Which is simply not true, not even going into benchmakrs being a lie on its own, but in my experience it was much slower (and I wasn't able to get a full server running, but that's what I get for using something 0.3, I understand that the ecosystem is still moving). Keep up the good work on gothan, I really liked the engine, but the readme promise misguided me.
Ohhh... ok, so this is a UX issue then :) I somehow didn't see that next to documention/repo links, but on the sidebar, you have keywords and dependencies in large/bold font. I kind of expected depedents to be listed there too, as NPM does it. Thanks for pointing it out though!
What's with this sudden flurry of D content? I haven't heard much about D in like 10 years and suddenly in the past week or so, lots of D content is popping up.
I think this is how it works in any sort of art. We don't make art so that future generations can stare at what we made forever. We make art as part of a tradition that's moving and growing, so that the next generation can take what we've made and go farther.
Maybe [https://en.wikipedia.org/wiki/Baader%E2%80%93Meinhof\_effect](https://en.wikipedia.org/wiki/Baader%E2%80%93Meinhof_effect).
I haven't really dived too deep into macros in rust, but from what I can tell I think that rust macros are more powerful, but mixins are way easier to use/read.
I think it would require a blanket impl that would violate the coherence rules. If there's more than one "path" to get from type T to type U, the implementation would be ambiguous.
Always check (crates.io)[https://crates.io/search?q=Mapbox] for libraries. There are a few search results, but no idea how good they are.
&gt;crates.io Yes, was looking at these too. Seems like they are all for creating map-related file formats on the backend, which makes sense and is a good start. I was wondering if there are any crates that can be used for actually rendering the map itself in the UI. Seems like no such crate exists yet.
Oh, you were looking for rendering? Didn't catch that, sorry. If you want you can call JS functions from WASM as described [here](https://github.com/DenisKolodin/yew/blob/master/README.md#services). But I guess you wanted them in pure WASM for performance?
As of now, It's probably the best out-of-the-box Rust coding tool. I know some people are keen to setup their own custom environment with vi or emacs and then RLS and macros and whatnot but If you're aiming for straight IDE productivity, the IntelliJ Rust plugin is prrrretty good. Not entirely up to Java tooling, but getting close. Some Rust stuff (like macros) is just hard to see through, but a lot of common search &amp; refactor operations are supported. If you need in-IDE debugging support you need to get CLion (instead of IntelliJ) though, which has no community edition (you have to buy it) otherwise its the same plugin.
Yes, was wondering if map rendering in pure Rust is already a thing. Could be very helpful for developers working on data-heavy maps. I know there are already companies using Rust server side for generating vector tiles etcetera. Apparently it allows for huge gains in efficiency. Anyways, thanks for the links!
Congratulations on successful event and thanks for sharing this.
It can be any type passed to `panic!()` but typically will be `&amp;'static str` (for a constant panic message) or more often `String` (for a panic message with formatting arguments). You can access these types with the [`downcast_ref()` method of `Any`](https://doc.rust-lang.org/std/any/trait.Any.html): let err = ...; // your `Box&lt;dyn Any + Send + 'static&gt;` error let err_msg: &amp;str = err.downcast_ref::&lt;String&gt;().map(|s| s) // for &amp;str coercion .or(err.downcast_ref::&lt;&amp;'static str&gt;()) .unwrap_or("unexpected panic message type"); If you get "unexpected panic message type" you'll want to check the source of the panic to see the type of the value that's being passed to `panic!()` since there's no good way to get it from `Any`.
Please remember that Rust is a systems programming language and systems programming is about control. Asking the compiler to find some way from type A to B gives up that control, so we don't.
Hey, Avocado's author here. The driver works just fine with MongoDB 3.x up to v3.6, the reason being that it's primarily the wire protocol that decides whether the client is able to correctly talk to the server, and this protocol didn't change between 3.0 and 3.6 (which is nice given that they are of the same major version). The "3.2" restriction only means that this particular clause in the docs was last updated when 3.2 was the latest stable version. What features are supported "natively" by the client is another question; there *was* a case where I needed to synthesize a not-yet-supported command by hand, but it didn't cause any issues. Otherwise, the client seems to be [actively maintained](https://github.com/mongodb-labs/mongo-rust-driver-prototype/commits/master); in fact, while developing Avocado, I managed to get several PRs approved in the client library as well as the Rust-native `bson-rs` crate. But even if it weren't: just because a piece of software had its last commit months or years ago, doesn't mean it's "bit-rotting". Both Mongo and Rust have stability guarantees, so I don't see why the last change date in a client library repo would inherently cause one to "have problems with it". Looking at the [official documentation for the wire protocol](https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/), it seems like it's not going to change much in 4.0 either. In fact I was planning to test the client exhaustively on 4.0, but unfortunately I didn't yet have the time for that. It would be nice because features such as batch upserts are be possible to implement in client-space once we have transactions (and anyway, transactions are just a must have for implementing any reasonably complicated query in a sane manner). So do expect more work and more good stuff to come in this field.
Overzealous type conversion can lead to some rather confusing behavior: https://www.destroyallsoftware.com/talks/wat (Though, unlike `From`/`Into`, that involves implicit type coercion that can appear in any context.)
It's my main editor. I've written almost all my Rust code with it which is tens of thousands of lines, still using it. It has syntax highlighting and limited intellisense, meaning that if there is a word somewhere else in the same file, it auto-completes it. This is more useful than you think: most of the time you don't mention something for the first time, but for the second, third, etc. Kate is very fast, lightweight, and has few bugs. I use it together with a Konsole window that I use for compiling, git, etc. The only feature that I'm missing is being able to click on an error span in Konsole and it opens for me in Kate so that I can edit. Right now I need to copy the filename.rs:line:col string and do `kate filename.rs:line:col` in Konsole. If there is an instance of Kate already running, it will open the file in that instance pointing to the line/column specified. As for others using it, I know of a Rust compiler team member who used to use Kate as well (maybe still uses it). When I started out doing programming, I've been using IDEs, even paid for them with my student money, bought books that told me about cool key combos but then realized they are no magic: you still need to lots of thinking to write great software. IDEs lock you in, are often tough to be set up for external projects, need extra attention, etc. If you have tons of errors the copy-paste method outlined above can be a bit annoying, so I checked out vscode which can do this in a limited way but last time I tried to use it the code I was fixing needed `cargo build --feature something` so how do I tell vscode's rls plugin to enable that custom feature? No idea, I just switched back to using Kate because figuring out would take more time.
I know, you end up with tons of timeouts though that are all valid programs which just take a (very) long time to run.
If the only reason you have lifetimes is because you're using a \`&amp;str\` convert it to a \`String\` instead. I mean who owns the string?
I'm afraid of getting the details of why this isn't working wrong, so I'm just going to say that you *might* be the target audience for https://rust-unofficial.github.io/too-many-lists/index.html
Alright cheers for the reply :) Appreciate it
My understanding: because that's not the model LLVM (or the C or C++ standards) uses, although LLVM could have been designed to do it that way. C or C++ declares that reading uninitialized memory is "undefined behavior", meaning no assumptions about the result all possible. LLVM does the same thing. This allows some additional optimizations. And it should have no negative consequences to correct code, because there's really no legitimate reason reason to read uninitiated memory (an exceptionally bad "random" number generator?).
And you don't seem to understand :)
There's also mrustc and the experimental cranelift backend (whatever the status of that is). Though differences might more likely be from bugs in those (which could also be useful).
You're missing an `.unwrap()` to get the Ordering out of the Option. Of course, only do that if you are sure that an ordering exists, i.e. that all float values aren't NaN.
Let's all love lain.
I've used it a ton, worth checking out
Someone is build something for kubes.
Thanks
It seems that the images use Ubuntu, so with docker I can run Ubuntu on mac ?
Yes docker on Mac OS uses [virtual machines](https://en.wikipedia.org/wiki/Virtual_machine).
Cli based tic tac toe is usually my goto for new languages too? To learn about rust/wasm, I've made a [web tic-tac-toe](https://dystroy.org/wasm-tictactoe/) too...
How did you get that impression? the author wants to use function annotations but that doesn't mean they only affect the function boundaries. There also seem to be some language features like the scope variables that are somewhat going in the right direction.
&gt; Its more the question of did it arrive to the disk "eventually". The real question is whether this actually matters. If it doesn't, then why pay for it.
Mixins are harder to write and less powerful than Rust proc macros.
Came here for this. Can’t agree more
Is there a good guide on how to layout a folder hierarchy for a Rust project that's multiple distinct parts? Say I want to make an Actix server, Yew frontend, and a library/data structures that they'll both use in common. Do they all need their own .tomls? Should I just have them as modules? Or as crates? How do I accomplish any of that? So far this is one of the most confusing parts of Rust to me, so any guides or suggestions are appreciated.
Disclaimer: been a while since I touched D. This is slightly complicated. First of all, remember that macros in Rust have absolutely no access to anything other than the literal tokens you give them in an invocation. You can't look up names, types, values, *etc.* The simplest way to think about this: macros cannot know anything you don't explicitly tell them. In D, you can leverage templates to do things like look up names, reflect the members of structures, *etc.* This makes D mixins *significantly* more powerful. On the other hand, D mixins are restricted in terms of the actual code they can run. You can do computation and limited read-only IO, but that's about it. Also, I remember compile-time compute in D being *really* slow. For Rust, macros defined by `macro_rules!` are even more limited (you can do token substitution, and that's about it), and probably even slower. However, Rust also supports procedural macros which are just regular Rust libraries that can do absolutely anything, and run at native speed. TLDR: Rust macros are both more and less powerful than D mixins (depending on how you implement them). Rust macros have significantly less access to context than D mixins.
You may want to read [the workspace section of the manifest format chapter of the cargo guide](https://doc.rust-lang.org/cargo/reference/manifest.html#the-workspace--field-optional). To me, it sounds as if a workspace project with multiple sub-crates would be the ideal solution for you.
If you just want speed without the reliability that the data was definitely saved somewhere, then just pipe your data to /dev/null. https://www.theguardian.com/info/2018/nov/30/bye-bye-mongo-hello-postgres
You can use `Result&lt;T, Box&lt;dyn Error&gt;&gt;` if you want (and IIUC this may be required in the future). `dyn` doesn't really do anything, it's just there for the programmer.
I agree the stable index format isn't huge as long as I can rebuild it but for my use case there will probably be a few hundred indexes across multiple systems so its a pain to re index everything. Is there a road map of features you want to add I can see from the github issues you are considering geo-search, datetime fields and implement BM25F. The 1.0 release is more to do with you not changing the API soi can have confidence code i write today will work for a long while before I need to change it. Also thanks for this project it does look awesome and was so much easier to get up and running then Clucene.
present day
I don't like question where there is no fucking single link to explain what you are talking about, it's me who mush search what the behavior of `groupe_by()` of Scala ! Same I need to search the doc of Itertools myself. Have some respect for the time of other people and ask properly.
Yeah, it usually doesn't make sense for a raytracer to use low-poly meshes and 2d depth texture. Raytracing isn't realtime anyway (at least hobby projects), and keeping the number of triangles low is much less important, so its easier to use the highpoly meshes directly. Baking normals should be easy. You render your highpoly mesh and instead of rendering colors you render the normal vectors into your xyz channels. Not sure how or why you'd use raytracing for this. And I'm not even sure what you'd need vertex colors for, with textures and all the power pixel shaders give you.
My view is that the real advantages of ownership and borrowing are preventing things like iterator invalidation and race conditions. (After all, C++'s RAII does a fairly good job of avoiding memory leaks and double-frees.) But these things aren't even *mentioned* in the article.
Rust could've been the language to end C, but you guys standardized a large number of design decisions that were flat out show-stopper for a lot of us. I use `String::null_terminate()` as a canary. Trivial to add, perfectly safe, and a *huge* red flag if it's missing.
Some things can be enforced by the type system. Some things can be enforced in theory, but it's too cumbersome in practice. Some things are probably impossible to enforce in Rust as it currently is. Calling only signal-safe functions in signal handlers is impossible to enforce. In theory you could give each thread a "not in handler"-token that must be passed to all signal-unsafe functions, but that is a) trivial to bypass, b) way too cumbersome to use in practice, and c) `malloc` is unsafe and implicitly called by various things that don't have a way to pass such a token. To make such a thing possible, you'd probably have to generalize the `unsafe` mechanism into a "execution context" mechanism with different capabilities; then "signal handler" could be an execution context that is limited to doing signal-safe things: access atomic variables and call signal-safe functions. That would be a significant change of the Rust ecosystem.
/u/matthieum thank you for these suggestions. I haven't worked through all of them yet but the hashbrown crate that backs `std::collections::{HashMap, HashSet}` includes a hasher called `FxHasher` that it uses by default that only uses a single `usize` for storage and is much faster. It's also not cryptographically secure but cactusref is only hashing pointers. This change speeds things up quite a bit and also decreases the size of the `RcBox` from 144 bytes to 112 bytes. PR here: [https://github.com/lopopolo/ferrocarril/pull/206](https://github.com/lopopolo/ferrocarril/pull/206)
You can check out [Gab.com](https://Gab.com) and other platforms that have been shut down unfairly. When other federated places wouldn't ban [Gab.com](https://Gab.com) they got warnings from many services/publishers not just Apple. &amp;#x200B; People have even lost their domains over this. Just check twitter, fediverse, and even github comments you can see them fighthing. &amp;#x200B; There are several other instances but the gab one is ongoing right now so you can see it live.
Hey man, i saw this link on your twitter. and asked you but im sure you didn't realized. my question is why did you use unsafe? ``` unsafe { let mut u32_bytes = std::slice::from_raw_parts_mut( &amp;mut magic_number as *mut u32 as *mut u8, 4 ); fs_labels.read_exact(&amp;mut u32_bytes)?; u32_bytes.reverse(); assert!(magic_number == 0x801); let mut u32_bytes = std::slice::from_raw_parts_mut( &amp;mut num_items as *mut u32 as *mut u8, 4 ); fs_labels.read_exact(&amp;mut u32_bytes)?; u32_bytes.reverse(); } ```
/u/Shnatsel thank you for your skepticism. I gave my BFS implementation a once over and it turns out I was actually being quadratic. I've properly implemented BFS with a `Vec`\-backed queue now and performance has improved significantly. I added a benchmark and with these changes, drop performance is 90% improved. PR here: [https://github.com/lopopolo/ferrocarril/pull/206](https://github.com/lopopolo/ferrocarril/pull/206)
btw this is a very good blog to read. thanks for sharing
I think you could have used [byteorder](https://docs.rs/byteorder) to avoid the use of `unsafe`in your `read_labels` function, as well as make it more concise and readable. You might also want to use iterators instead of for loops in `process_inputs`
I'm not op, just cross posted from /r/programming (I'm not sure if that poster is the blogs owner either)
I had a response that the user has since deleted, they appeared to have misunderstand what I was talking about, so for additional context if anyone is able to provide some input/feedback on direction: ---
I don't know why `Vec::group_by()` is not in `std`. I suspect it is because the interface is a bit unusual/awkward: in particular, the `GroupBy` iterator needs to hold on to an unbounded amount of memory in the worst case. It could also just be that nobody ever RFC-ed it in there. The `itertools` `group_by()` has a fairly Rustic API. What were you hoping to get from it that you're not?
I recently saw a post about how there's no way that I need `static mut`. I've written 2 small crates, that use static mut and I would like to know, how I can substitute the `static mut`s and how the different approach works. https://github.com/greaka/arcdps_bindings https://github.com/blish-hud/arcdps-bhud
oh i see hahaah sorry
I'm going to answer one question you actually asked, and two you implied. &gt; why is `group_by` not implemented in the stdlib? Rust intentionally keeps a small stdlib, because it's easy for external crates such as itertools to implement powerful functionality. External crates can update much faster than the stdlib. &gt; why is `group_by` implemented on iterators instead of specific collections such as `Vec`? It's a more general solution: lots of collections can be easily converted to and from iterators, so implementing `group_by` on an iterator lets you apply it to any of those collections. This includes user-defined collectsions which implement the `IntoIterator` and `FromIterator` traits. Implementing it one collection at a time is less effective. &gt; why does group_by return an iterable of groups instead of a new `Vec` for each group? Idiomatic Rust avoids heap allocations when they are avoidable. If `group_by` were to return an `impl Iterator&lt;Item=Vec&lt;T&gt;&gt;`, it would need to allocate a new vector for each item. This has non-zero cost. Because it returns (effectively, this isn't the actual returned type) `impl Iterator&lt;Item=impl Iterator&lt;Item=T&gt;&gt;`, it doesn't necessarily need to allocate anything, which can be faster. In its [docs](https://docs.rs/itertools/0.8.0/itertools/trait.Itertools.html#method.group_by) you can find the specific assertion that "If the groups are consumed in order, or if each group's iterator is dropped without keeping it around, then GroupBy uses no allocations. It needs allocations only if several group iterators are alive at the same time."
&gt; To do the deallocation, drop the values in the Rcs instead of the Rcs. This breaks the cycle during the deallocation and allows Drop to crawl the object graph. What happens if the Drop implementation for the value type attempts to dereference Rc fields within that type that participate in the cycle?
Heh, I kind of feel the opposite surrounded by programmers who code mainly in java but all pretty much have experience with Haskell or Scala.
I don’t think there can be yet, since the current restrictions on `const` functions prevent branching, iirc.
&gt; Most of the time I don't need to write safe code. I think most people don't need to write safe code all the time. Most people don't write code with performance first in mind, the sole aspect where safety is a legit pain point, even more with «straight to trashcan once played with code», and definitely mostly deliver code that ends up hosted that safety first should be a #1 target.
I created a Rust + asm.js demo in 2017. It consumes Mapzen vector tiles and uses Rust to convert them to SVG paths. &amp;#x200B; [Demo](https://pyfisch.org/stuff/colorful-map/#map=12/50.1000/8.6001), [Blog Post](https://pyfisch.org/blog/rendering-vector-map-tiles/)
Even if your interlocutor was less than interested in having a conversation I found the thread pretty interesting. Thanks for the links / info.
I’ve been working on [Boa](https://github.com/jasonwilliams/boa), an experimental JavaScript engine, also a tool for me learning compilers too. It’s going ok. We switched on Clippy last week, so now have loads of linting and best practise errors to work through
You don't need `byteorder` for that, that functionality is in the standard library: [from_be_bytes](https://doc.rust-lang.org/std/primitive.u32.html#method.from_be_bytes)
Wow, you must be a very frustated little person. Actually you don't need any documentation to answer my question.
What irritates me is that it groups only consecutive elements &gt;Return an iterable that can group iterator elements. Consecutive elements that map to the same key (“runs”), are assigned to the same group. &gt; &gt;[https://docs.rs/itertools/0.8.0/itertools/trait.Itertools.html#method.group\_by](https://docs.rs/itertools/0.8.0/itertools/trait.Itertools.html#method.group_by)
https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=bd3da6e8a2ea820939e216b275ac2c4f Here's the discussion: https://github.com/rust-lang/rust/issues/53639. It was discussed that `SyncCell` (or some equivalent) would be provided by the standard library, so this approach would not be as boilerplatey as my example.
Thank you for the great answer!
What I want is to pick the best technical solution to an engineering problem. Your proposition that there are only two solutions to these problems, and that these are "zero-reliability" or "100% reliability", is incorrect. There are many solutions to this problem, and none of them is 100% reliable. I understand that you prefer an approach where you don't have to think for yourself about the trade-offs. This is, in itself, a trade-off. If that's the case, sure, don't pick NoSQL.
Emulation! To get started you can take a look at Chip8, which does not require any advance graphics.
Honestly it's because he's a C++ programmer that is comfortable with unsafe (since C++ is always 'unsafe') and knows how to do pointer math. A Rust programmer would know that unnecessarily using unsafe is always the wrong decision and to reach for the standard library method to accomplish the same ([from\_be\_bytes](https://doc.rust-lang.org/std/primitive.u32.html#method.from_be_bytes) as linked in another comment). This unsafe block may work but it is not idiomatic Rust and you should understand that most people would consider this 'bad'.
Ah nice :)
How would you lazily group non consecutive elements ? What are you exactly looking for ?
I have one project that has unit tests that I want to debug in IDEA CLion on Windows. That requires a target "nightly-i686-pc-windows-gnu" (32 bit, GNU) for the debugger to work correctly. However, I want to target "nightly-x86\_64-pc-windows-msvc" (64 bit, MSVC) for another project in my workspace (which depends on the first) when I link it as a DLL to be used with Godot. So, what is an ergonomic way to invoke these two different toolchains? I can't find any documentation on this "rust-toolchain" file which is mentioned briefly in the docs. I don't want to use rustup run if possible because it doesn't yet play nice with CLion. I'd rather use some cargo argument to change the toolchain for the test project build. Any ideas?
I don't think I deserve to be insulted, also I don't think every little person deserve to be also insulted. Also, I think I know what I'm talking about your question is lack of information. &amp;#x200B; What I said is include about "Criticism is encouraged, though ensure that your criticism is useful and actionable." I think my criticism is useful and actionable.
It's still unclear what you exactly want. Could you edit your question to explain what kind of behavior you expect from `group_by` ?
Ah. Right. There are a couple of ways one could implement the Scala-like behavior with iterators. There's the slow way, where each group iterator has to walk the whole set by key; there's the memory-intensive way, where things are split up eagerly to iterate over. I don't know of a standard tool that does either of these: perhaps someone else does?
Your code is prone to data races because synchronization is missing to deal with potentially multiple threads attempting to change global state based on your public API functions at the same time. Your API is not safe to use. With the help of `lazy_static` + `Mutex` you get to eliminate all your `unsafe` blocks for accessing global state like this: use std::sync::Mutex; lazy_static! { static ref FUNCTIONS: Mutex&lt;Option&lt;ArcdpsFunctions&gt;&gt; = { Some( ArcdpsFunctions { combat: None, imgui: None, options_end: None, combat_local: None, options_windows: None, } ) }; } ::: impl arcdps_exports { ::: pub fn options_end(mut self, func: SafeOptionsCallback) -&gt; Self { self.options_end = options_wrapper as LPVOID; let mut lck = FUNCTIONS.lock().unwrap(); if let Some(funcs) = lck.as_mut() { funcs.options_end = Some(func); }; self } ::: }
I'm totally backing this comment: [https://www.reddit.com/r/programming/comments/cdp77g/rust\_vs\_c\_implementing\_a\_neural\_network/etw8f40/](https://www.reddit.com/r/programming/comments/cdp77g/rust_vs_c_implementing_a_neural_network/etw8f40/) The writter should know more than a little before judging the language: there are trivial errors preventing the code to be fast enough.
Maybe that's my problem. I would have expected it to group eagerly over the entire Vec.
I am not sure what you are trying to say. Aren't Rust rules also only enforced at function boundaries? That is, you can check Rust rules for functions one by one without looking at other functions. It was one of Rust's design principles that this is possible.
Regardless, please avoid profanity. It's unnecessary and you're likely violating rules 1 (Respect our Code of Conduct) and 4 (Keep it chill) for this subreddit.
If you need to pre-sort by key, that's not hard. If not, this saves you the runtime cost of sorting.
In this specific scenario where its used, the builder pattern like functions are only called once and from one thread, as the calling library only lets you initialize once. Is it still unsafe to use? And should I apply the change that you proposed to the other library as well?
Direct link to the actual content: https://www.youtube.com/watch?v=doqno2H4HW8
I've wanted a similar function in the past, and was also a little surprised that it wasn't in the STD Iterator, nor Itertools. Fortunately, it's [simple to write](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fe89e19ac5587d4fd73ffadf4a8d71e5) an extension trait for iterators.
The thing is I think the first to be rude is the one who ask bad question and ask other to do their own work. I'm just too bad about not answer to this bad content.
Just go back a couple of years in the compiler and stdlib source code. E.g. my third [pull request](https://github.com/rust-lang/rust/pull/5678). So around 2013 there is good stuff.
`arcdps_exports` and its methods (including `options_end`) are public. They are exposed in the library's API as "safe" which they actually are not. The way I see it, you have two coices: * Mark functions of your public API that access (reading &amp; writing) global state which may be modified somewhere as `usafe`, too, and add documentation to warn users that these functions are not thread-safe * Ensure mutual exclusion so that "safe user code" (code written without `unsafe`) cannot invoke data races by using your API. I havn't looked into the other library.
Then be an example of how one *should* communicate. Trying to justify ignoring the subreddit's rules with an argument that boils down to "he started it" won't get you very far.
I read DoD as "Department of Defense" :-P
Thank you, this helped me a lot. You edited your code above, why does it use an Option now instead of `Mutex&lt;ArcdpsFunctions&gt;`?
I will not change what I am to please this subreddit, I'm not here for that. Also, I think you are being too paternalist with me. If I say something that a moderator will judge (without trial ofc) to need to be moderate and ban me then so be it. I don't care I said what I wanted to say, I'm just read this subreddit randomly. But don't be surprise if one day no one can make a critic anymore. That not the first time I try to make one, and other time I have been much more nice, didn't make a change, people get upset with any form of critic here. So why should I lost time to be nice when it doesn't make difference ? I say what was on my heart take it or leave it.
Because that's closer to what you've written. It seemed your use of `Option&lt;ArcdpsFunctions&gt;` was a deliberate choice. I don't really know what you're trying to achieve, here.
Oops sorry I forgot to type the compete word. I meant Data-Oriented Design haha
What's the purpose of implementing granular access control on this level if you can just restrict outbound network access via a security group or something? Also, doesn't `deno` do stuff like this? Just curious about what the purpose is since I haven't used something like this before.
Do as you will. I'm just saying that, if you're not obeying the "No Shirt, No Shoes, No Service" sign, don't be surprised if you get kicked out. The mods here are pretty good about *what* you say as long as you're polite, constructive, and on-topic.
I saw this at lunchtime today and tried replacing all the indexing with get_unchecked() to see if it was bounds checking that was causing the difference. That netted me a few percent. When I then ran it through a profiler (like I should have done in the first place) it showed nearly all the time being spent in the intrinsics, which surprised me, since that should theoretically be similar between the two languages.
There are a lot of statistics points: tickets, security, stock of rfid, entrance turnstile, 500 workers which work at the same time with the system, etc.
The biggest contiguous lump of Old Rust I know of is [this](https://github.com/eevee/amulet) library and [this](https://github.com/eevee/clio) binary that uses said library, but you'll have to strip back a few layers of "updated to use [a more recent but still outdated Rust build]".
&gt; [`group_by` from itertools] groups only consecutive elements Well, it's written on top of the `Iterator` trait which means it doesn't have random access. Also, it's written to be lazy and to consume as little memory as possible. If you want a more "global" grouping, you should rearrange your Vec's elements in-place (or clone it and then rearrange the elements in the clone). That's not really something a Rust iterators should do.
Turns out he was talking about a different talk in the same video and the timestamps shifted. That speaker did talk about social justice and inclusivity. Still, quite depressing that people are so bothered by the idea :/
Thank you It was something left over from earlier, when I still had undefined behaviour in my code.
Whoever the calling function is would own the String. But that's not the only reason. I've tried using Strings. Transition only has a reference to a state too. And it won't work even without &amp;str
Have you looked into [bacon_rajan_cc](https://crates.io/crates/bacon_rajan_cc) ? That library does the same thing i.e. provides deterministic cycle collection. I've not had the time to compare anything in depth however.
https://brson.github.io/archaea/ has lots of eaxmples of what rust used to look like
The author has answered these questions on the HN post: https://news.ycombinator.com/item?id=20444047
Hmmm. I'll check it out
&gt; Most of the time I don't need to write safe code. I think most people don't need to write safe code all the time. wow. this in 2k19.
I need help refactoring a method. seems easy enough but between generated source code (grpc), Futures, generics, and associated types I can't get the type signatures right on the return value of the function I want to introduce. What are some general strategies to approach this problem? For example, one trick I know to figure out the inferred types is to explicitly set the type to unit and then look at the compiler error. That works great for concrete types but how do I find the abstract type? I don't want to return a `MapErr&lt;AndThen&lt;AndThen&lt;Blah&lt;Blah&lt;Blah...` I want to return an `Future&lt;Item=SomeItem, Error=SomeError&gt;` (impl or Box'ed). So I kind of figured out my SomeItem and SomeError by substituting unit like before but `SomeItem` is a `Thing&lt;T&gt;` and I can't figure out `T` for the life of me. to make this concrete... github project: https://github.com/ian-p-cooke/tower-grpc the build-generated helloworld.rs: https://gist.github.com/ian-p-cooke/a7bd13d1fa25f7f4dab7628d8d83af31 my attempt to refactor hello-world example's client.rs: https://github.com/ian-p-cooke/tower-grpc/blob/968d8e6158c335ba01238865276a0bd6c8aeae77/tower-grpc-examples/src/helloworld/client.rs#L15 It makes me feel a little better that Clion couldn't extract the method with the right types either :)
To add to that: `return` used to be `ret`, `match` was `alt`, there were strange `++` symbols for arguments (don't know what they were for), lifetimes used to be indicated with a `\` instead of `'`. `mut` could be used as a field property (e.g. `struct Foo { n: mut i32, i: i32 }`), there were `pure` functions. And then the more well-known symbol-soup of `~` for owned boxes, `@` for refcounted things...
You want /r/playrust, mate.
Can't you use something like `CString` if you want a null terminated string? Calling it a huge red flag seems like an exaggeration
Yeah it's a tough one, but basically the error message is saying there is probably more than one lifetime in your code. I'd honestly start without any references, and then add them if it makes sense to do so. &amp;#x200B; Think about who owns what. Is the state owned by the state machine or the transition? Why does the state object need a reference to transitions? That would make a circular reference at first glance. &amp;#x200B; Orthogonally you might want to look at entity component systems and memory arenas, as they are both different ways of approaching this sort of problem (I think).
\&gt; Most of the time I don't need to write safe code. I think most people don't need to write safe code all the time. ouch. i feel the exact opposite. in fact, i'm sure it's the exact opposite given the popularity of java, go and python...
Great, thank you for sharing.
This is very timely for me! I've been writing a scripting language in Rust recently and I've been prototyping with `rust-gc`. I should probably look into ferrocarril (nice name!) more before asking this, but: Which existing garbage collection libraries did you evaluate and why did you take this route? I suppose I'm wondering why immediate memory reclamation is necessary/desirable for your project. Anyway great work! Really interesting stuff.
Sorry
Thanks for all your responses. They were quite insightful :D
A shame you seemed an honest man.
FYI gvargh is just another troll that posts nothing but anti-Rust comments like shevegen or shevy-ruby (or whatever he calls himself)
would you have a look again?
 Most of the time I don't need to write safe code. I think most people don't need to write safe code all the time. This is how you get SkyNet. You implement neural networks in unsafe Rust and you get SkyNet.
You can take a look at the [signal_hook crate](https://docs.rs/signal-hook/0.1.10/signal_hook/) and the usage patterns it provides.
I think you change safe to unsafe that makes sense!
Based on the way the OP wrote the code, you need to compile with the right CPU features enabled. The simplest way to do this is to just set `-C target-cpu=native`, which makes all features on your CPU available. e.g., RUSTFLAGS="-C target-cpu=native" cargo build --release Alternatively, you can use SIMD intrinsics with runtime feature detection, [as explained in the docs](https://doc.rust-lang.org/core/arch/index.html#dynamic-cpu-feature-detection). In general, if you see uninlined SIMD intrinsics in a profile, then there's a performance bug somewhere, likely in how the SIMD stuff is setup. The inlining is prevented because the compiler doesn't have the necessary CPU features to do it. Based on the timings in the OP, it sounds like they figured out how to enable CPU features, but I'm not sure. I unfortunately feel like I need to explain this every time I see someone use SIMD intrinsics in Rust, even though the exact same situation applies for C and C++ programs. I'm not sure how to fix that. :-/
&gt; it's now slow for me *not* or *now*? Just to make sure I understand correctly. I assume you mean not slow :)
"initialized" has a static meaning ("the compiler sees an assignment has happened") and a dynamic meaning ("the bits got initialized") and I did not know which one you were talking about. But it seems like you were talking about the dynamic meaning. So you are suggesting that `0xUU` (an uninitialized byte) should be "valid" for `bool`, but `0x10` not? I do not see the point of that, if we allow uninitialized we should also allow all initialized values. There is no benefit for optimizations or anything else from disallowing `0x10` if we allowed `0xUU`.
Is entry available for minors? I don't see it anywhere but I don't wanna risk it
The "basically" mostly hides the part about which we are not sure yet, like `u8`. An uninitialized inhabited zero-sized type like `()` is also okay, but then there is no reason not to use `zeroed` instead if the size is 0 anyway. Also, `let foo: MaybeUninit&lt;T&gt; = mem::uninitialized();` is certainly okay.
[removed]
`cargo test --target`?
I like "obtain", I will try to (also) use that in the future. Thanks for the suggestion! Finding the right words to describe this is hard, and important.
Congratulations on the game's release! 🎉
Interesting. Thanks!
Thanks! And thank you for all your support pre-release &amp; help with translations!
Congratulation for this release ! If you had to build another game like that now, would you use some engine (Amethyst for example) or will you continue as you did for Robo Instructus ? Thanks you for your devblog, it's an inspiration when I try coding my own game !
This looks pretty nice! Any chance of it becoming available on MacOs/Steam?
Is it open source? At least the engine?
Hi, glam author here, nice to see someone try it out! I had a very cursory look over your changes. There's a few things you can do faster, e.g. converting a vector to rgb in u32: let (red, green, blue) = (return_color.min(Vec3::one()).max(Vec3::zero()) * 255.0).into(); let final_color = ((red as u32) &lt;&lt; 16 | (green as u32) &lt;&lt; 8 | (blue as u32)).into() This uses SIMD for the min, max and multiply operations. Also this return Vec3::new(col.x() * scatter_hit.attenuation.x(), col.y() * scatter_hit.attenuation.y(), col.z() * scatter_hit.attenuation.z()); would be better as return col.x() * scatter_hit.attenuation; So again the multiply uses SIMD. I realise a lot of this is a straight port from another library :) In general if you need to access the x, y and z values of a glam Vec3 it's faster to convert it to a tuple or array rather than calling the individual accessors, e.g. let (x, y, z) = v.into(); But it's better to just use Vec3 methods if you can, avoiding accessing the individual x, y and z components.
The options available now are so different compared to a couple of years ago. I really like the way Amethyst are glueing a whole bunch of utilities together to make an engine. I'd definitely be taking a close look at these modular tools if I had started the game today. I do generally try to avoid full on frameworks as in the past I've found them as restrictive later as they are productive initially. But this also made sense as Robo Instructus isn't a typical game, in that it has few "entities", no dynamic collisions, no physics etc.
I use it daily probably for all simple text edits, writing notes, regexping. Newer tried for development.
The engine is not general purpose, so it's really just part of the game which is not open source currently. I used &amp; contributed to gfx (pre-ll/opengl), winit/glutin, rodio etc which are all open source. &amp;#x200B; When I developed something more general purpose I did open source it, most notably \[glyph-brush\]([https://github.com/alexheretic/glyph-brush](https://github.com/alexheretic/glyph-brush)) which is also used by a few rust engines now for text rendering. My other projects: [https://github.com/alexheretic](https://github.com/alexheretic/glyph-brush)
The barrier there is that I simply don't have a mac. If the release goes well I would like to revisit this, I'd obviously like the game to be available there.
What would happen if the value would exceed your expected limit? &amp;#x200B; As an option, why not use a struct with setters/getters which would allow the value be set via the setter and you'd check it and if not okay, raise an error of some kind? Then retrieve the value through the getter? &amp;#x200B; P.S: I don't use rust that much, so i might be off with the answer :P
I do not really understand your thinking here: &gt; where you are paying for reliability that you don't need The entire function of a database is to safely store your data. Now, even in relational databases, you can have less durability to improve performance - for example, batching writes instead of guaranteeing a write was saved to disk - but even here, the loss of durability can only happen if you have a severe hardware crash. &gt; That the reliability requirements of the ephemeral database of a brief music festival Well, I assume people's information and payment transactions are worth guaranteeing, but if you feel that your database is ephemeral, use Redis.
Well yeah but it would be cool if rust has type system level handling for stuff like this
Working on board support packages for TI Hercules micro-controller. no\_std unsafe code all day e'ry day.
I don't know why this isn't said yet, but monome devices do just that: look cool. They are incredibly overpriced for what they do. The "Arc" is just four knobs for $900. That's $225 per knob! For $150-250 you can pick up a used Behringer BCR2000 that has 32 rotary encoders plus 16 buttons while it can load and store presets for those buttons so you can save your patches and go back to them. If that's still out of budget you can pick up a Korg nanoKONTROL 2 NEW for $60 which has 8 knobs, 8 sliders and 24 buttons. I bought one a couple days ago and I can use MIDI just fine to control a software synth I'm writing in Rust with it. If you're interested in the Grid, instead of paying $700 get the $80 Novation Launchpad mini with 64 buttons, or even two of these. If you're interested in music production there are tons of generic MIDI controllers that don't look as cool or sleek but are just as functional for waaaay less money.
Well, yes you can. Take a look at [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d21c4d0371da1d9fa8adbba817dbee2b](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d21c4d0371da1d9fa8adbba817dbee2b) for one possibility. Basically, create a new struct and enforce your constraints through the struct's methods. Note that I took care to avoid over and underflows of the underlying `u8`, but the `add` and `sub` methods may over and underflow, which may or may not be a problem in a constrained type. There is a lot of boilerplate code here, and as far as I know there aren't any libraries for this, but you can do it. &amp;#x200B; If you are asking about language-level, then no. This is called a [dependent type](https://en.wikipedia.org/wiki/Dependent_type), and it's something you usually only see in functional or logic programming languages, with [Idris](https://www.idris-lang.org/) and [Coq](https://coq.inria.fr/) being the most popular if I'm not mistaken. As far as I know, the only non-esoteric, imperative language that supports dependent types is [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language)).
&gt; gfx (pre-ll/opengl), winit/glutin, rodio etc Are you using vanilla dependencies from crates.io or some of them are forks with custom tweaks?
Darn. Well it was nice to be reminded off the name for this kind of thing. Thank you
Yep all releases from crates.io
It’s also a separate type so you can be sure you have the correct style of string when passing to C; type safety is good. Adding null termination to String would make &amp;str not work the same way, which would introduce even more confusion around strings...
Intriguing! Feel free to come by the Amethyst chat or forum if you wanna exchange notes and use case explorations =)
Rust borrowing rules are enforced everywhere, not just at function boundaries. My understanding of the article was that D allows you to mess up with borrowing within a function.
Alex was kind enough to upstream all the changes they make.
&gt; As far as I know, the only non-esoteric, imperative language that supports dependent types is Ada. Nitpicking here: IIRC, Ada/SPARK supports specification of precondition and postcondition as logic constraints, and integer range as runtime checks, but Ada's type system is not dependently typed. Dependent type means you can encode logic propositions as types. As far as I could tell, this is not the case in Ada/SPARK or similar projects like Frama-C.
I appreciate the regular status updates and really hope this project takes off. If I want to contribute, is there a good place to start?
You can use VirtualBox to run MacOs. It won’t be the same (I understand there will issues with audio), but should still be workable.
In my 1st implementation of this (which I made for a game of mine), the state machine owns everything. The states and the transitions. They are stored in a dictionary/map. Then the transition would own the keys to the previous and the next state. But considering rust has references I thought about not implementating it that way, and use references instead. I'll read what was suggested in the other comment and get back here when I make a decision c:
I mean, I agree that safety should be a high priority for any code which is *shipped*, but probably for a scientist writing experimental code which will never leave his own workstation, safety is not the top priority.
This looks amazingly good fun and I intend to purchase it when I get home. Congratulations on your release. Any chance you might try and build it for SteamOS/Linux at some point?
&gt; like explicitly having to cast in cases where there is no harm in implicitly casting, I don't think this can work without serious usability issues -- inference will probably be compromised, small expressions might take a long time to type check (due to the compiler searching for long chains of conversions), weird precedence rules for resolving conversions along diamonds, not sufficiently general (available to users), poor interaction with saturating/trapping arithmetic operations -- and these are just the potential problems I can think of off the top of my head.
The primary platform is Linux as that's what I develop on. Windows it's also supported, I hope to add Mac support later.
[I'm working on making an AVL Tree with unsafe pointers.](https://github.com/camccar/rust-avl-tree/blob/master/src/lib.rs) To better understand how to work with raw pointers in rust. Still Need to add the 4 rotation methods.
Looks cool! What is the target programming skill level for players of this game? More for people first starting or experienced programmers?
I think this will help me build the Mac binaries, but I think I will need to get hold of some hardware for the initial development &amp; testing.
Considering how SkyNet got stupider with each iteration of the timetravel, that's probably right.
Could that deserve a warning/info during compilation? Ie. Intrinsics not targetting the current cpu ?
I'm not an expert but after reading some more I think you are right. Just updated my answer.
Just played through the demo and purchased the game. I can't wait to try more of it tonight! I really like the programming language used in the game. Most of the programming puzzle games I've played were more on the assembly side, so it's cool to see a higher level language in a game like this. Congratulations on the release!
I'm not sure I see how. Do you?
It's for both. Or rather, the early levels make an effort to introduce programming concepts fairly gradually. However, the difficulty ramps up quickly so experienced programmers will have an advantage once they get into the later levels. &amp;#x200B; So I think it's a game for all people that have a strong enough interest in programming their way past the puzzles.
What I did is go back to in the rustc tree to the 0.x tags: [https://github.com/rust-lang/rust/tree/release-0.3](https://github.com/rust-lang/rust/tree/release-0.3) &amp;#x200B; Then you can just look at the tests directory to find out how the code looked.
The author missed a great opportunity to refactor the Rust by asking on /r/rust "Why is my C++ Neural Network so much faster than my Rust one?"
Yep that's exactly the niche, it's a stripped down language in many ways (integer only) but still feels high-level compared to the assembly games. &amp;#x200B; Learning the language actually isn't really the challenge, it's creating and expressing the algorithms that's the fun I think. Particularly when they work!
Congrats! Looks great! Any chance for a Web/WASM release? :)
I haven’t heard about Inkwell, thanks for pointing it out.
It's not designed for web, and I don't imagine it'd be easy to redesign it to be, so don't hold your breath.
&gt; The entire function of a database is to safely store your data. Now, even in relational databases, you can have less durability to improve performance - for example, batching writes instead of guaranteeing a write was saved to disk - but even here, the loss of durability can only happen if you have a severe hardware crash. I often do not care about properly storing all data I get, and that's ok, because even if I would care, I often cannot guarantee that I will even receive all the data in the first place (e.g. data source disappears), and even if I could, I can only have so many backups and cannot guarantee that all of them won't fail at the same time, etc. I could make all of that better by throwing more money at the problem, but that has to be worth it. Often it isn't. &gt; Well, I assume people's information and payment transactions are worth guaranteeing I don't think they are updating people information at 7kqps, and I do hope that they aren't handling payments themselves, but just forwarding them to a third-party that does that.
Wow I just looked at their stats page https://stackexchange.com/performance Not related, but They’re massively over provisioned for 450rps peak... Also, someone’s running some bad queries. 11000 queries for those 450 reqs plus 60000 redis hits? Maybe they’re just bad stats. Or maybe that’s proof that I’m totally neurotic about query efficiency.
How was windows support?
Thanks for the explanations. I think I'm going to have to spend time with more concrete examples to get my mind to really accept these ideas.
I've been working on a little util to give me metadata on some large CSV files I've had floating around ( [here[(https://github.com/sullivant/csv_utils) ) - trying to determine an appropriate DDL for a flat file with no documentation is one of those things I end up having to do a bunch every now and again.
The docs for the std Hasher don't say what algorithm it uses. Is it MD5?
The upcoming value-generics feature should help with that. Then a library could offer a type like `ContrainedInteger&lt;u8, 10&gt;` which ensures the value is always smaller than 10. Of course integer overflow still needs to be checked at runtime.
Very nice, thank you.
Probably something not good. I can probably panic in this case.
That happens any time you use LaTeX with code in it, it does a ton of magic to get the output it wants. I have yet to find a solution for it (at least for `listings`).
Was MongoDB running on the same box or a different box? Was the lack of a redundant set up a concern?
SipHash-3-1 (AFAIK)
I needed some special code to avoid thread sleeping a minimum of 16ms (I made spin-sleep), I also found out that renaming files in Windows is *not* atomic, that hurt a bit. Other than that winit takes care of most of the differences. I use opengl 3.3 on both platforms which helps too.
Wow, very cool. Will look at this in detail. Thanks!
What is the recommended approach for building a (nonserious) 2D game right now? Amethyst looks cool, but its documentation does not seem comparable in scope to the size of its API, which makes me wonder if it's feasible to just jump in to it. I'm far from sure if I'd get half way in, decide I need a custom shader pass, and end up stuck in unfinished territories or undocumented functions. I think at least with wgpu the API looks small and derivative enough that I could run just by the examples and update as things change, but the niceties of Amethyst are quite tempting.
As someone who writes a ton of scientific computing code for very large HPC systems, I'd rather start with safe code first, and then only after tweaking it as much as possible to get the most performance out of it reach for unsafe code. It sometimes might require you to rethink your problem, but I'd say this approach can lead to fewer time wasted hunting down bugs months down the road.
Check out into_group_map in itertools. Not consistent, but it seems to offer the thing you are looking for, or close to it.
How can you read line without assigning it to a variable ? `io::stdin().read_line()` requires expects a parameter. I just need a user to pass a number and forget about it
A streaming JSON lexer built with nom so I can perform path/selector queries against JSON files asynchronously. If anyone knows of libraries I could use or that do the same thing, you’d be saving me a lot of time :)
It should be named [linear D](https://en.m.wikipedia.org/wiki/Linear_B).
Desktop link: https://en.wikipedia.org/wiki/Linear_B *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^268597. [^^Found ^^a ^^bug?](https://reddit.com/message/compose/?to=swim1929&amp;subject=Bug&amp;message=https://reddit.com/r/rust/comments/cdkwoe/ownership_and_borrowing_in_d/etx71id/)
Hey! Thanks for letting me know, I will have to go through and fix up, yeah I was doing a straight for the most part. Good to know I have a lot of little fixes I can do.
If it was that easy to restrict overflow checking to compile time, runtime overflows wouldn't exist. I could write without any understanding about the reasons, but that'd be kind of narcissistic, so i won't except to write that this is almost certainly unfeasible for language 'for humans' and even in a language 'for machines' that doesn't completely whitelists all of the program input.
Per the source code the algorithm is currently SipHash-2-4, typically with a random key. If you call `std::collections::hash_map::DefaultHasher::new()` the key is hard-coded to 0. [https://131002.net/siphash/](https://131002.net/siphash/) &amp;#x200B; This algorithm is not guaranteed to produce consistent hashes between versions. If the attacker can see the generated hashes, that could weaken the DoS protection. For both these reasons if you plan to let hashes escape the process that generates them via any kind of I/O, my understanding is that the standard library doesn't want to be involved in the design choice of which algorithm to use. Thus no guarantees about the implementation. If SipHash is in fact suitable for your application, the `siphasher` crate is the same implementation, but now you're opting in to using it. If you can trust the input, the `fxhash` crate is also popular because it's very fast. &amp;#x200B; The `md5` crate doesn't implement the `std::hash` traits, most likely as an additional step to discourage people from using it for their `HashMap`s. It's suitable for interopability with systems that use md5, and if you *really need* those traits, they're only few lines of boilerplate.
I'm not saying overflow detection should be compile time. That would be impossible as far as I can see. I just wanted to know if it was possible to have Ada style ints with constrained ranges (though I didn't word it that way and I'm sorry for that). I didn't know what to call what I wanted.
At the very least we'd have feature parity with C++ in terms of stuff like template programming.
I like the cut of your jib!
Well, that's a nice quick-win :)
&gt; Is it still unsafe to use? In that case it's defined behavior and your program shouldn't be doing "spooky heisenbug" things that result from the interaction of the compiler and hardware. &gt;the builder pattern like functions are only called once and from one thread, as Since your API must be handled carefully to prevent undefined behavior, good Rust style says that the API must declare \`unsafe fn\`. \`unsafe fn\` declarations just pass the responsibility to the caller. If you do this, it's wise to carefully document what special handing is required. It's even wiser to consider whether the API can detect multiple initialization and panic instead.
During the initial message, "Await instruction." should be a new sentence rather than simply separated by a line break. "Because when we aren't making big hauls, I'm looking bad `too` Nigel." The text could use some proofreading, if this far into the demo is anything to go by--assuming it's not a stylistic choice. Still, looks like a lot went into this and I assume it's solid from a programming / interactive standpoint! :-)
Oh sorry, I did understood it was per `RcBox`, so just sloppy wording on my part.
If you accept a String and then assign it to a self field, what exactly are you throwing away? The character buffer keeps pointing to the same address on the heap. Am I missing something?
Yeah, it's possible. And other variations of 'invalid domain' such as the `noisy-float` crate.
https://doc.rust-lang.org/std/clone/trait.Clone.html#method.clone_from But yeah, I've never seen it used in the wild.
Post it to /r/programming games! The sub is nearly dead :(
Post to /r/CodingGames! The sub is dying :(
&gt; Why use destructuring when you could just access them directly? It's convenient to create named variables for a thing. Destructuring lets you do things like `for (i, elem) in iter.enumerate()` or `fn foo((x, y): (f32, f32))` which can be convenient.
The first one is intentional and, I'd say, pretty minor. The line is *"Because when we aren't making big hauls, I'm looking bad to Nigel."* This is correct, to be clear the player character is not called Nigel ;)
You are throwing away the buffer that the old self field had (if it had one). Yes, if you accept a `String`, then that `String` already has its own buffer when it gets to you, so you can't go faster than just using that buffer. But the user might want to call `set_name` without actually having a `String`. They might want to set the name to a `&amp;'static str`, or they might only have a reference to some `String` that needs to become the new name. In that case, you're forcing them to create a new `String`, which will allocate a new buffer. And then you're that new buffer, whereas you could've just reused the buffer you already had (the one owned by `self.name`).
&gt; One big downside to this framework is that since the layout and data types of the Rust structs are not the same as you'd find in the C side of things Can you not use `#[repr(C)]` to align them?
Destructuring can be used to assign meaningful names to the members. For example: let (base, offset, mask) = register_tuple; device.write(base+offset, mask, 0x001f)?; tells you a lot more about what's going on than device.write(register_tuple.0+register_tuple.1, register_tuple.2, 0x001f)?;
It's not quite as flexible. It does allow for setting a \`String\` to a \`&amp;String\` and reusing the old \`String\`'s buffer. But you can't use it to set a \`String\` to a \`&amp;str\` and reuse the buffer.
There as crate that implements a lot of this: [https://crates.io/crates/ux](https://crates.io/crates/ux) &amp;#x200B; It implements from {i1, ..., i127}\\{i8, i16, i32, i64} and {u1, ..., u127}\\{u8, u16, u32, u64}
It's fairly recent, isn't it?
Just played through the demo and i have really enjoyed it, nice work. &amp;#x200B; I have one minor issue tho: Can you add numpad enter support?
Please do post this there, I'd say the game is very applicable.
There are 2 `String` at play: the left-hand side and the right-hand side. When performing `left = right;`, you throw away the buffer that `left` had and force `right` to allocate a buffer of its own. This can be wasteful.
There's nothing built in, but you can do &amp;#x200B; .read\_line(&amp;mut String::new())
Numpad seems to work fine with lock on &amp; off, at least on Linux. I'll check Windows when I get a chance.
The misunderstanding, of course, being that not-safe also means not-correct. What's the point of running code that spits a random result?
Totally with you on that. I guess to clarify my previous comments I understand that we can't always catch things like this atcompiletime but rust would be a prime candidate for applying this kind of optimisation
If you understand Specs sufficiently well, Amethyst doesn't add much complexity on top of it. It's more like a collection of small tools that compose well under specs (asset management, transforms, timers, etc.) The renderer is probably the most complex part, but that would be true of any custom rendering pipeline. In any case, to get started, you can just copy a simple renderer from one of the examples. That said, amethyst is changing fairly rapidly still, so it is a bit wild west. Documentation is lacking in places, but overall it is actually very good considering how rapidly things are changing. I don't think you'd get stuck though... it is a straightforward engine that is easy to extend, so if something is missing, you can usually add it yourself with minimal fuss.
That's a bit hyperbolic isn't it? I mean certainly you could have a program which produces a correct result, but has a memory leak for instance, or will result in an NPE only with certain inputs.
Finally a shiypost worthy of being pinned here
Yeah, the edit above was from realizing that possibility existed, despite the awkward phrasing. I've linked your game to someone who was asking for a good intro to programming recently!
this is for you /u/NoraCodes
Note that a memory leak is perfectly safe :) As for being hyperbolic, yes and no. It all boils down to trust and readability. With safe code, the executable binary has the exact semantics of the source code which you read. With unsafe code, unless you carefully tread around, chances are that the executable binary will have slightly different semantics, so that even careful inspection of the "wished for" semantics of the source code will not reveal why the result is bogus. This does not only mean that you cannot trust your source code any longer, unless you also trust the developer to have steered carefully, and therefore that you need to read the assembly rather than the source code to assess correctness. It's... painful. As the saying goes: "Make it work, then make it fast".
This is the wrong rust sub, this is a programming language. You're looking for /r/playrust
/r/rustjerk
Knuth2k19: Premature optimization is still the root of all evil.
If you destruct, you chan pass the ownership of the members around, can't you?
And apparently I can’t read. Thank you.
 fn set_name&lt;'a&gt;(&amp;mut self, new_name: impl Into&lt;Cow&lt;'a, str&gt;&gt;) { match new_name.into() { Cow::Borrowed(s) =&gt; { self.name.clear(); self.name.push_str(s); } Cow::Owned(s) =&gt; { self.name = s; } } } [`Cow&lt;str&gt;`](https://doc.rust-lang.org/std/borrow/enum.Cow.html) will hold either a `&amp;str` or a `String`. You can then re-use your own buffer if it's a `&amp;str`.
(not op but thought I might give some info. disclaimer, I'm a member of amethyst's org) I've been experimenting with Amethyst for a while now, and I can definitely recommend, given you are OK learning and experimenting a bit. Once you get a handle on the ECS, it's pretty easy to figure out. However there's a lot of common stuff that still takes a bit of knowledge and boilerplate, like setting up the render graph or adding a custom shader. Additionally, the assets system can be very difficult to understand, though a vastly improved system is on its way. I think it has one of the best communities for a Rust project, though. Definitely worth checking out if you have the time.
If you care about these particular semantics, you can do this: ``` fn set_name&lt;T: AsRef&lt;str&gt;&gt;(&amp;mut self, new_value: T) { self.name.replace_range((0..), new_value.as_ref()); } ``` Though this is likely so produce the same effect (in terms of number of allocations and buffer reuse): ``` fn set_name&lt;T: AsRef&lt;str&gt;&gt;(&amp;mut self, new_value: T) { self.name.clear(); self.name += new_value.as_ref(); } ```
`await` turns a `Future&lt;T&gt;` into `T` in an async context. You can then mutate `T` as if it were just any other variable. No mapping required but you can of course use combinators as well.
You can, and this would work for basic structs. If your structs fit any of the following criteria, then there are some problems: 1. Variable-size array data 2. Have unions 3. Have bitfields Variable-size array data is currently handled by using a `Vec&lt;T&gt;`. Unions are handled by instead [using an enum type](https://github.com/microsoft/lain/wiki/Translating-C-Unions) for a couple of reasons, including type safety, ease of debugging, and having no ambiguity which variant is worked with in mutation/serialization context. And finally, bitfields are not packed since I wasn't a fan of using getters/setters. Unions could probably be addressed fairly easily and leave the risk of using them up to the developer, and with bitfields there's nothing stopping you from replacing the sub-fields (or whatever you might call them) with a field representing all bits instead. There are also some types in the framework like `UnsafeEnum&lt;T, I&gt;` which can either be a `Valid(T)` variant of an enum `T` or `Invalid(I)` random value of type `I`. This could be used in a context like: enum MessageType { Foo = 1, Bar = 2, } struct Message { typ: UnsafeEnum&lt;MessageType, u8&gt;, // Will serialize to either a valid MessageType or random number .... } Long-term goals would be to get the layout closer to, if not the same as C structs, without sacrificing ease of development or features of the type system.
Yay! So happy to be able to support the rust gamedev community - just picked up a copy. Really inspiring work :)
Does Blender's Cycles work for you?
Thanks for all your advice everyone, that was very nice of you ! I finally had the time to work on error handling, hope someone can check it... Thanks !
That looks like what I want. I don't think there's any other community that has packages and ideas on improving the language the way rust does.
And yep it would make a circular reference. Shouldn't that work anyway?
You're working on the official BSP ?
That's not very elegant, but it does work. At least, if the compiler can undo the creation of the Cow enum and the branching on it, but it seems like it should be able to. I'm still quite fond of the idea in my edit of my original post to give \`From\` a method \`set\_from\` (and \`Into\` a method \`assign\_to\` or something similar), which would simplify the whole thing down to fn set\_name(&amp;mut self, new\_name: impl Into&lt;String&gt;) { new\_name.assign\_to(self.name); }
Thanks for the lesson
Working to create a support package specifically for the TI TMS570LC4357. I'm basing it on this project [https://github.com/paoloteti/ti-hercules-bsp](https://github.com/paoloteti/ti-hercules-bsp), combined with reverse-engineering HalCoGen C code provided by TI. &amp;#x200B; Unfortunately, OpenOCD doesn't support this device well, and LLVM doesn't support BE-32 architecture well, so it's been a technically challenging endeavour getting the tooling correct.
Thanks! Judith (player's boss)'s writing has a certain style to it, half informal half condescending. It's meant to rub you the wrong way a little, as it's not unknown for bosses to do this!
If Rust allows you to get a raw pointer directly from a `static mut` I don't really see the purpose of `SyncCell`. Safe code can't do much with it, and unsafe code is either putting a field with interior mutability inside a `static` or inside a `struct` or `enum`. In those other cases, unsafe code is more likely to be thinking about the `Sync`\-safety of the data structure *as a whole* rather than a single field. &amp;#x200B; In a nutshell `SyncCell` is, within `static`, only a more verbose way to say `mut` \- in both cases you're opting-in to global mutability. My gut says that arguments for why it's necessary may come from a misunderstanding of `UnsafeCell`, especially a belief that `UnsafeCell::get` is specially blessed by the language. It's not. (Probably.) The thing that the language actually treats specially are references to `UnsafeCell`. (Assuming the language becomes specified the way I'd expect.) `UnsafeCell::get` is nothing other than casting from `&amp;UnsafeCell&lt;T&gt;` to `*mut T` \- you could do the same thing with `transmute` and it would be sound. You *shouldn't*, because `transmute` is icky, but the compiler doesn't need to do anything special to compile `get`. 100% of the specialness comes from the compiler understanding elsewhere that `&amp;UnsafeCell&lt;T&gt;` is a may-alias reference (i.e. it may alias with other may-alias references). So the concern is whether `&amp;mut MUTABLE as *mut i32` invokes UB because of the transient existence of a `&amp;mut` reference. C's solution is to define aliasing based on the type of the pointer and whether it's dereferenced. That's a mess and hard to understand, but it's also why that particular pattern works in Rust code that exists in the wild. The reference is immediately converted. Why the heck *should* the compiler generate anything that breaks in the event of aliasing?? IMO the cleanest way to resolve this question, and the one which is least surprising to anyone familiar with the C/C++ `&amp;` operator, is to say that the borrow operators are specified to act as mere address-of operators when used at a coercion site that expects a raw pointer. If you create a reference and start passing it into functions all bets are off, but if you immediately convert it to a raw pointer (which is allowed to alias with anything) then there's no opportunity for mischief. "At a coercion site" isn't a perfect translation of this intuition into a formal specification, but it's a bright-line rule that's easy to understand. Situations where a reference is created and stored in a local variable but always converted to a raw pointer - things like that which are more fuzzy - *those* might make sense as UB. I'm not really equipped to contribute to that discussion. &amp;#x200B; And besides, this is the "easy" question thread. Oops. Still I think this tangent may be enlightening to folks who are trying to wrap their heads around unsafe and the memory model at a low level, but have already read the Rustonomicon and don't need to be told the basics again. The nature of `UnsafeCell` and the way it's currently implemented (it suppresses llvm's `noalias` attribute when it appears directly or indirectly in the type of a function parameter) was a pretty big epiphany for me and I hope it is for others.
/r/playrustcirclejerk enjoy our jerk aswell
Ah damage. I'm completely new to rust and was hoping to start a Greenfield project with actix. Is anybody here building web backends/APIs with solid libs like hyper as opposed to frameworks?
Congratulations 👍
If I had a need to write a web server in Rust today, I'd probably start by looking at `warp` or maybe Gotham. (I was surprised to see `warp` wasn't listed in this blog post.) The dependency count is still quite high **IMO**, but that seems unavoidable in the tokio ecosystem today. `warp` otherwise looks nice and simple, although it's built on some serious type system shenanigans.
I’ll add it, give me a moment
Yikes. For anybody who just didn't read the article (which you should, or at least skim), the actix developer didn't learn from the whole unsafe fiasco from a bit ago. The author of Actix closed and don't merge a PR one user sent in to remove some unsafe code, that was probably less efficient and harder to handle than safe code, and the author of Actix said, "I guess everybody could switch to interpreted language otherwise we will die in ub" He also broke semantic versioning, cheats on benchmarks, and has some god awful code (which he isn't very friendly with getting other users to help with). Oh, and there's 221 dependencies, which is an awful lot. If you're curious to know more, read the article, which is pretty good. Basically, Actix is still poorly written, and the author isn't trying to make it better. Go use something else that doesn't cheat on benchmarks and has undefined behavior.
&gt; HTTP requests being manually constructed in a way that no sane person would: ```let mut body = BytesMut::with_capacity(2048); let mut writer = Writer(&amp;mut body); let _ = write!(writer, "{}", FortunesTemplate { fortunes }); let mut res = Response::with_body(StatusCode::OK, Body::Bytes(body.freeze())); let hdrs = res.headers_mut(); hdrs.insert(SERVER, h_srv); hdrs.insert(CONTENT_TYPE, h_ct); res``` I suppose it might go a little against the "spirit" of the competition, but to be honest these are still fairly high level structured building blocks for an HTTP response, and I wouldn't be above using them if a specific endpoint really needed to perform fast.
Has anyone measured the benefits of having fewer crates? It seems to me that the number of crates should, if anything, speed up compile time due to the parallelization. The main issue is that small crates are needed to be able to maintain stability across such a large surface area. I know that some say to just issue breaking changes, but reality is users don't track changes...
You can look at the assembly [here](https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;code=use%20std%3A%3Aborrow%3A%3ACow%3B%0A%0Apub%20struct%20Employee%20%7B%0A%20%20%20%20name%3A%20String%0A%7D%0A%0Aimpl%20Employee%20%7B%0A%20%20%20%20fn%20set_name%3C'a%3E(%26mut%20self%2C%20new_name%3A%20impl%20Into%3CCow%3C'a%2C%20str%3E%3E\)%20%7B%0A%20%20%20%20%20%20%20%20match%20new_name.into(\)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Cow%3A%3ABorrowed(s\)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.name.clear(\)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.name.push_str(s\)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20Cow%3A%3AOwned(s\)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.name%20%3D%20s%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Apub%20fn%20set_name_str(e%3A%20%26mut%20Employee%2C%20name%3A%20%26str\)%20%7B%0A%20%20%20%20e.set_name(name\)%3B%0A%7D%0A%0Apub%20fn%20set_name_string(e%3A%20%26mut%20Employee%2C%20name%3A%20String\)%20%7B%0A%20%20%20%20e.set_name(name\)%3B%0A%7D) to see how well it optimizes. In release mode, `set_name_str` features calls to `memcpy` and (conditionally) `__rust_realloc`, since it's copying the data into the existing allocation. `set_name_string` has no allocations, just the deallocation of the existing string. In general rustc will always optimize out branches like that, because after monomorphization and inlining the result it sees is something like: match Enum::Variant1(parameter) { Enum::Variant1(x) =&gt; { use1(x); } Enum::Variant2(x) =&gt; { use2(x); } } which is trivial to convert into `use1(parameter);`.
Thanks for the alternatives!
Amethyst needs to fix its input lag issues before anyone should try it out for a real project. It’s hard for me to imagine how any significantly complex game can have offer a pleasant user experience when even its example Pong clone is rendered difficult to play because of its lag.
Reading uninitialized memory isn't even safe in any language, not even C or Assembly. You can read a byte from uninitialized memory, and it could read as zero, then spontaneously change to another value due to the way the OS's page allocation system works. See the [Facebook Strings talk](https://youtu.be/kPR8h4-qZdk?t=1150), (Talk about the OS messing with memory at 22:50)
Thanks for the article. I am not that used to Rust terms, what does UB mean?
Thanks! I’m only just starting out with SIMD and I hadn’t realized that. Turning on target-cpu=native makes the rust version 3.7x faster than the c++ one.
Undefined behavior
Yeah, I'll never use actix because of the unsafety/ attitude towards unsafety. Even if it had 0 unsafe, unless the author really demonstrated a different approach entirely, I would assume unsafe would make it back in. Cool that it's fast, but fast and unsafe has no place in a rust web framework. I'm personally hopeful for warp/ tower, as I trust the authors considerably more to build a web framework that matches my expectations as a rust developer.
Undefined behavior
Oh. Sounds logical. Thanks!
&gt; cheats on benchmarks, So, without making any assertions about the rest of the article, I found this piece, and this characterization of it, to be a bit off. The purpose of this particular benchmark is not to show what usual code looks like. It's to show the maximum possible numbers you can get. These techniques are also used by many of the other languages and frameworks in the benchmark, since they're explicitly allowed. In other words: this isn't cheating. It's not testing the thing you wish it tested, but that's a very different thing.
&gt; And finally, bitfields are not packed since I wasn't a fan of using getters/setters. There's no stable ABI for bit-fields anyway so...
I don't think the benchmark thing is even worth mentioning. Benchmarks are always like this, and it's no surprise, and I'll die of shock if Actix is the most egregious case of doing non-production techniques for perf.
[https://github.com/AhmedMostafa16/Silver](https://github.com/AhmedMostafa16/Silver) &amp;#x200B; I stopped developing it because I have lots of studies.
There’s an explicit category for ‘stripped’ implementations in the TechEmpower benchmarks: &gt; A Stripped test implementation is one that is specially crafted to excel at our benchmark. By comparison, a "Realistic" test implementation should be demonstrative of the general-purpose, best-practices compliant, and production-class approach for the given framework. Considering actix doesn’t even look at the HTTP method, I think it’s pretty fair to put it in this category
&gt; it's built on some serious type system shenanigans. 😅 Which of the various shenanigans seems troublesome?
Cheating is a bit of misleading term. He is with his framework what others do with theirs in the benchmark game.
If a crate uses `unsafe` it doesn't mean that it's bad. There are a lot of cases were `unsafe` is used to overcome some Rust "limitations". For example, take a look at `rgb` crate. It allows mapping `&amp;[u32]` to `[&amp;u8]`. It's completely safe, but can't be done without `unsafe`, at least efficiently. And there is still no point in removing all unsafe. std uses unsafe. Other libraries may use unsafe. And if we talking about web-servers, openssl is unsafe by default. This is a fruitless effort. PS: I'm using actix-web for my project.
That’s a new thing, as far as I know. Regardless, interpreting the rules are the job of the publishers of the benchmark; they review all code before it gets in. It’s on them, not on the implementors.
Here's a good article describing it: [A Guide to Undefined Behavior in C and C++](https://blog.regehr.org/archives/213). UB in Rust has the same effects, but the definitions of what language constructs are undefined behavior are [somewhat different](https://doc.rust-lang.org/reference/behavior-considered-undefined.html).
Does someone have a transcript?
&gt;Edit: also it takes a `&amp;self` so it doesn't help the case where you want to fill a `String` from a `&amp;str`. `fn clone_from(&amp;mut self, source: &amp;Self)` If the `String` in this case is `self` then I don't understand what you're talking about.
Indeed. There's a difference between: - optimizing "to the bone", which shows off the maximum performance that one can aspire to should they be willing to resort to the same tricks, - and cheating, which shows performance that is unattainable. Granted, few people will actually optimize to the bone, however it's still a useful number to know as it informs you on the room for growth that you have with your application. And yes, some application are optimized extensively.
With the same amount of code i think more crates is better (maybe not due to linking?). I see the bigger issue as you generally don't need everything that comes in a crate. So while smaller crates might lead to better compile times (I'd love to see benchmarks too), I think dependency count is generally correlated with the *percentage* of the dependency code that you conpile but dont use.
&gt; If a crate uses unsafe it doesn't mean that it's bad. That's correct. It's also not what the article is implying: &gt; You might be thinking 'somebody used unsafe a bit too much, what's the big deal here? Just fix it and move on.'. The problem I'm trying to highlight here is that there's a fundamental issue with the author's attitude which we don't seem to be able to change.
I don't like picking apart someone else's work, especially that they provide for free. Since the previous "unsafe" episode resulted in some unsavory personal attacks, I've been torn with how to handle my findings after reviewing actix-web again when it reached 1.0. Still, I think it's better for users to be aware, since they are deploying code to production. There's [this instance of `unsafe` here](https://github.com/actix/actix-net/blob/da302d4b7a3faaeb5d041f8480d4437113d2e0d5/actix-service/src/cell.rs#L33) that can cause UB if you use some of the service combinators and nest them, as you could take a reference and the nested call could invalidate it unbeknownst to you.
&gt; avoid thread sleeping a minimum of 16ms I'm curious, can Windows threads not sleep less than 16ms?
I read the article. But I kind of felt it pilloried the author of Actix a bit too much. If Actix is really so horrible, well, don't use it. It's free software, and you can be glad you have the code to judge the quality of your dependencies. This should be the first step for anyone choosing a framework or library his new project is going to depend on. &amp;#x200B; Yes, the closed PRs and responses of Nikolay are not helpful. But the maintainer has no obligation to do anything unless they allow you to pay him for his time. He is giving away his (life) time for free here.
It's not the unsafe to me that is the red flag, it's the actix authors attitude towards it and in the case of the article, attitude towards a PR *that removes unsafe and fixes a case of UB*. It's one thing to use unsafe, document it's invariants and uphold those in the name of performance. It's another to just let it fly because "unsafe is faster" or reply with "guess we should use interpreted languages or die in UB"
I'm curious what was your pain points while developing this game using Rust? What did you like the most?
Maybe this specific example was bad (although I'd still argue it's unrealistic). I'm going to cross it out and replace it
I highly doubt the maintainers actually review the code
Sorry if this is a stupid question, I'm not really a gamer. I'm on macOS. If I purchase it now, can I run it on a VMWare Fusion VM? If/when the macOS version is released, will I have to purchase it again to get the macOS version?
I don't think OP is saying unsafe is fundamentally bad. More that the author of Actix's attitude toward unsafe is... not good.
You can get around 1ms accuracy on Windows but you have to ask nicely beforehand (with winapi). See [https://docs.microsoft.com/en-us/windows/win32/api/timeapi/nf-timeapi-timebeginperiod](https://docs.microsoft.com/en-us/windows/win32/api/timeapi/nf-timeapi-timebeginperiod).
Not the original commenter, but I've tried to use warp before. I found the actual API fairly nice, but the host of type level stuff being done (HLists in particular) meant that error messages were often fairly hard to understand. I eventually ended up switching to actix as a consequence. Admittedly, this was a few months ago and I imagine that things have gotten better since then, so I might give it another shot.
They do, though they also admit that they're not experts at everything. Regardless, these kinds of issues are basic enough that you don't need to know the language to understand what's going on.
Fair point
I get that! Thanks for the feedback. Do you think docs could help her, or it's just daunting to see type errors from the compiler?
As I see it, the point is to warn people that about less-than-obvious things they need to know in order to make an informed decision about whether *they* should use Actix.
&gt;morioh Yo, Angelo
This functionality was made stable in Rust 1.35.
Do we need alternatives to actix? Maybe. But the main issue that actix suffers from is not the use of unsafe, the API, documentation or anything else but that it's effectively one person spending an enormous amount of time working on it but very few people are contributing to it.
I mean, would it be fair game for a python framework to call into a native C module to do some computation? Seems like you could put that in the former category. As steve has pointed out, it's down to the maintainers to make sure all the frameworks are following the rules, but I still don't think it'd be fair game to have something like that
Yes, exactly
Why does `char::is_ascii_alphabetic` take `&amp;self` as the receiver? Functions like `char::is_alphabetic` take `self`, which makes a lot more sense considering copying a 32 bit number is probably easier and faster than accessing it from a pointer. This seems inconsistent to me, is it a backwards-compatability issue?
I'm happy to add feature flags as needed to enable faster / smaller builds. People just have to request them vs. generally bemoan high dependency counts :)
Well, given this: let name: &amp;mut String = /* something */; name.clone_from(other); here `other` must be a `&amp;String`. But we want to be able to pass a `&amp;str` instead.
Good to know. That does not really answer my question though; are there features in cargo so that it does not pick too recent packages because they are incompatible with the "old" compiler that is to be used.
There are not.
Yep on both steam &amp; itch a purchase means you own it on all platforms.
This post and a few commenters here seem to be grinding an axe and aren't pointing out any major concerns. The OP admits to the post as a rant and it seems to be mostly hot air. Who cares how many dependencies the project has? Functionality is pushed out to lots of crates. Get used to it. Massive Rust projects are going to have lots of dependencies or programmers are going to end up writing all of it on their own. As for rejecting a seemingly innocuous PR -- going to need a lot more context before I believe anything OP says about the matter. People don't like to have their PR's rejected. It takes effort to draft the work and then it feels like a pie to the face when it is refused. I'm not going to respond to every item. I can't take emotional tirades seriously.
Huh, and here I thought this was going to be a discussion about actor systems. The actix project confuses me. As far as I'm aware, it started with [actix](https://github.com/actix/actix) the actor framework. But then actix-web came along and seemed to become the main focus of the project. [The actix site](https://actix.rs) only mentions the actor system in passing. It used to have some references in the docs to `actix` when `actix-web` was actually built on actix (pre-1.0), but I don't even see those now. In fact, `actix` and `actix-web` are almost entirely unrelated at this point. The only "actix" dependency that they have in common is `actix-rt`, which is just an abstraction over the `tokio` runtime/executor. There was a suggestion to change the name for 1.0 when it would no longer be based on `actix`, but the author declined. I get why they opted to keep the original name, I just find it unfortunate that now when people talk about "actix," they're more often referring to the offshoot `-web` framework that's not even built on the "core" `actix` framework now.
Ok thanks for the info! Do you think this would be something useful? (I mean, I would find it useful for me, but if it is only me...)
&gt;Who cares how many dependencies the project has? Functionality is pushed out to lots of crates. Get used to it. Massive Rust projects are going to have lots of dependencies or programmers are going to end up writing all of it on their own. This is not one of the main points of the post, it's just a minor gripe. Many other Rust web server projects have similar compile times &gt;As for rejecting a seemingly innocuous PR -- going to need a lot more context before I believe anything OP says about the matter. People don't like to have their PR's rejected. It takes effort to draft the work and then it feels like a pie to the face when it is refused. You act as if I sent the PR? I advise you to look at the actual diff and thread for yourself, it's not very long. The "major concern" is Nikolay's attitude, and since he is pretty much the only maintainer it's definitely something to be wary of
I am using Linux (X11 KDE).
What would have helped me at the time is having more examples in the documentation (which seems to be the case now), as well as possibly documenting common errors and their solutions. Just more to avoid the experience of "this task seems simple; surely I'm not the first person to have run into this problem," which is often frustrating.
It's undoubtedly useful, but there are tons of questions. People have looked into this before and there are a lot of questions.
... and when those other people try to contribute, the `actix` maintainer closes the PRs and says "I guess everybody should switch to interpreted language otherwise we will die in ub", rather than simply accept the PR that is fixing the UB. If the author were willing to accept PRs to improve the code quality, you would have a good argument.
Have you opened an issue? This is the first I've heard of that but I'm also not deep into the technical side of things.
Oh, right. In that case, OP's `set_from` proposal makes a lot more sense to me.
I'm not sure it's my favorite feature but it definitely provides some surreal debugging-in-prod experiences...
I don't think you read the article.
[Seems to just be historical.](https://www.reddit.com/r/rust/comments/bj0ki4/why_do_some_char_methods_take_self_by_reference/)
I'm in the process of learning it myself, I'm using simple problems from Project Euler to get up to speed, before I dive into something else. [https://projecteuler.net/](https://projecteuler.net/)
The biggest issue is long debug compile times. Or more precisely I want to fix a compiler error and see rls provide the next one asap, right now this is a slower process than other languages. &amp;#x200B; What brought me to rust was not having to worry about GC pause, thread safety &amp; null.
Thanks I'll look into it! [\#202](https://github.com/big-ab-games/robo-instructus/issues/202)
Adding to what others have already said. Unsafe isn't bad but *unnecessary* unsafe should be avoided, and the author seems to have no problem with these unnecessary unsafe blocks (like the `ptr::non_overlapping` usage I showed)
&gt; ... and when those other people try to contribute, the actix maintainer closes the PRs and says "I guess everybody should switch to interpreted language otherwise we will die in ub", rather than simply accept the PR that is fixing some of the UB. That's fair, but actix' problems are at least from where I stand not unsafe code but lack of documentation, examples, missing abstractions etc. Yet the only thing that seem to be of any interest to people happens to be the unsafe code. I don't feel like that is a good approach to software development. Every since that unsafe issue was brought up there have been lots of PRs and issues filed which are about the use of unsafe. One can argue that it should not do that but at the end of the day actix solves practical problems right now. The unsafe aspects of it don't show up as an issue in my experience.
I have finally made `linear/binary/exponential/linear_str/group_by_key` methods for the `slices` and `strs` available. That makes most of my closure easier to read know (~`|a, b| a.id == b.id`~ becomes `|x| x.id`). https://github.com/Kerollmops/slice-group-by/compare/group-by-key#diff-b4aea3e418ccdb71239b96952d9cddb6R431 PS: This has not been released yet, I need to provide documentation to these new methods before.
I'm glad to have seen the article. I have concerns about any application level framework with much / any unsafe code. In my opinion, unsafe is fine if you're doing something really low-level, like implementing a GC for an interpreted language. I don't see it as so appropriate for a web framework, especially since this is the main vector for server attacks.
&gt; The "major concern" is Nikolay's attitude, and since he is pretty much the only maintainer it's definitely something to be wary of Maybe, but it does feel like character assassination to me. I'm sure Nikolay has his issues and I'm not a fan of his lax attitude to unsafe either but I don't think that excuses these types of articles. At the end of the day actix is in much better shape than most of the other systems we have currently for practical use.
Not sure if I should feel complimented or insulted to be explicitly named in this post. I think (hope) the intention was the former...
Which bit? :p
What I'd love (not from you/`warp` specifically, btw - I think `warp` is great, these are more general ~~observations~~ hunches), is a way to benchmark how much code from a crate actually gets used, and then figuring out a cool way benchmark the impact of removing said code. Macros make this a bit hard obviously, but it seems like it'd be really useful. Generally, I was commenting on utilization ratio of code in dependency crates, but it's all guesswork. And with Rust I suppose you could say: 1) Make it work 2) Make it fast 3) Make it compile fast :p
I kind of think that code should speak for itself. If the quality is not up to \_your\_ guidelines: don't use it. You ultimately can't rely on others that much if you are deciding on a core framework for your next big application. Especially the "attitude" things of the maintainer are kinda out of place. Having a single maintainer might be a red flag for itself, because he might just die the next day in some horrible car accident. If it is about code reviews, maybe [crates.io](https://crates.io) needs a ranking and commenting system.
The tone of the post may be a bit harsh but tbh I think it’s fair enough since this there’s been issues regarding unsafe in actix and Nikolay doesn’t seem to have changed his attitude as much as we’d like. Again, I’m not trying to demean him or belittle his work, but on the other hand I think it’s important that people who choose the framework know what they’re getting into
I know you're doing great important work and I thank you for it, and that we should probably just let go about this, but [situations such as this one](https://github.com/sfackler/rust-postgres/issues/461) happen regularly and it's a bit annoying to double the compile time and dependency count just to keep a lib up to date. Do you think most of these 95 new dependencies could be avoided using feature flags ?
&gt; I think it’s fair enough since this there’s been issues regarding unsafe in actix and Nikolay doesn’t seem to have changed his attitude as much as we’d like. Which I think is very much an effect of the earlier posts about this. It has been brought up as this massive problem and for why one cannot use actix but in practice it has not caused any issues and continue to not do so. For people who actually are trying to get stuff done it turns out this is the least of our concern. &gt; I think it’s important that people who choose the framework know what they’re getting into Of all the issues I have with actix/actix-web/actix-net unsafety is not anywhere close to the top of my concerns. Trust me I tried plenty of alternatives over the last two years and right now there is very little else that works in practice. I really wish the discussion about actix would move away from this unsafe business to actual problems.
Nice, this is what I've needed for awhile. Finally getting the hang of rust itself, now I'm looking for the concepts I'm comfortable with (coming from Clojure here).
Unsafe is an "actual problem" and a massive reason why people are using rust in the first place. Sean has already pointed out how you can trigger UB in the actix API by using certain combinators. It's really not reassuring that the author of a large package is introducing these kind of commits with barely any review from others, if you don't find that a valid concern then I think we'll just have to agree to disagree
I'm the one that led the v1.0 documentation update for the user guide. I have a different username on github. I was mostly joking, but there might be a tinge of feeling insulted there too. I do agree with some of the things you've mentioned. The recent PR for removing some unsafe really rubbed me wrong too. I've started another user guide for building an application from scratch using actix-web, but have considered switching to something else. However, at this time I think I'll stick with actix-web in hopes that it gets the attitude adjustment it needs. I am attempting to start a movement of creating user guides that are based in reality so if nothing else this will be good practice. My hope is to write the 'Flask Mega Tutorial' but for actix-web. Who knows maybe I can use the same template for Gotham or Warp. The comments here are a little reactionary (not your fault at all). It's easy to say we can do better, but it's much more difficult to actually do. Hopefully we can all work together to make give a positive outcome.
Your best bet would be to just install rustup and grab the most recent rust distribution. It sucks that not everyone is allowed to do it though. The Rust ecosystem is still maturing rapidly, so freezes on compiler versions can really hurt in comparison to other languages.
I don't like project starter applications, and I don't think amethyst needs one. The amount of things in a step-0 amethyst project is not much. Also, I don't think copying what currently popular web frameworks do is a great motivation, or even a good idea. I love the work on sheep, one more step to having a complete 2D pipeline!
&gt; Unsafe is an "actual problem" Not in my experience. My experience might not be representative but overall the quality of codebases in Rust is pretty good despite frequent use of unsafe. Most of the crashers or memory corruptions in Rust have been bindings. I fixed at least two crashers that showed up in practice in rust-curl for instance. Never had a crash in actix. &gt; Sean has already pointed out how you can trigger UB in the actix API by using certain combinators. But all those APIs are pub crate so you cannot do this from outside. &gt; It's really not reassuring that the author of a large security-critical crate is introducing these kind of commits with barely any review from others, if you don't find that a valid concern then I think we'll just have to agree to disagree Our baseline experience is Python with uwsgi. A setup that has segfaulted many times on us and continues to do so.
My gut is that when people complain about X number of dependencies, they really care about something else. That "something else" tends to vary. For example, if what people care about is compile time, taking 95 dependencies and shoving them into a single crate would make the compile time **worse**. So, it would be most helpful to define the real goals and work from there.
That is something everyone can quickly see for himself by running a \`grep unsafe . -r\` on the code of the crate. And the article is not just about unsafe in actix. It's also about the attitude of the author, which is my main concern about the article. These kinds of articles quickly create a toxic attitude. What if I end up with a crate that is used by hundreds of thousands users and my wife is getting sick, so I have not that much time anymore and I am really stressed out. And I am concerned the PRs are piling up and I make bad calls about closing them. The last thing I would need are blog articles publicly pillorying my behavior/attitude. A private mail would be way more helpful in that situation. We are just humans and we have feelings.
Sounds like you'd like \`cargo-bloat\`
It's possible that some people chose not to contribute in other ways because the way the unsafe/UB issues are handled does not give confidence that it would be time well-spent in the long term.
Maybe, can't judge that. I think for at least a considerable time it has been quite hard to contribute because of all the refactoring that was going on.
So you're not actively doing any web development in Rust and if you were to, you wouldn't use actix-web? How could you make such a call without knowing what these projects exclude? Wouldn't it be prudent to evaluate all of the options at that time and then decide?
It's worth pointing out that a crash is the best case scenario. It's also possible to manipulate the wrong memory and it look perfectly fine to the OS, and you just have silent UB. &gt;But all those APIs are pub crate so you cannot do this from outside. That `Cell` type is used for the service combinators, like `AndThen`, and `CloneableService`. If some service grabbed a reference from it's cache, and then a later combinator invalidated the cache, you could have a use-after-free.
&gt; But all those APIs are pub crate so you cannot do this from outside. Sean seems to be implying that you can trigger it by using service combinators which are part of the public API
It's called Rocket.
You could look at Gotham, Tower-Web, or Warp. They're all built on hyper, and largely have very different styles to their API design.
If the author is unwilling to accept security fixes, why would I believe they are interested in accepting anything less important than that? From my point of view, security is fundamental. If a web framework is doing things in the name of performance that knowingly sacrifice security, why would I *ever* deploy that and put the company I work for at an unnecessary risk? A lot of people come to Rust because it enables them to write safer software than C++, while still having great performance. I've written lots of *unbelievably* fast code in Rust, without needing to reach for `unsafe`. But, `unsafe` is just a tool, and it can be used carefully and correctly, especially when you allow others to audit your `unsafe` code for both necessity and correctness. The cost of a security breach is *so much* higher than a 0.1% performance impact. Even if removing all `unsafe` blocks from `actix` were to *somehow* (and it's not clear *how*) impact performance by 10%, it would still be preferable. Renting 11 servers instead of renting 10 servers in the absolute worst case scenario is fine. In the real world, a web framework's performance is not strictly proportional to the performance of a web application anyways, since many endpoints are bottlenecked on databases, other external systems, available bandwidth, or available packets-per-second throughput. What's important is that the web framework does not introduce vulnerabilities into my web applications, while still being ergonomic to use and *reasonably* fast. I'm still highly doubtful that more than one or two of the `unsafe` blocks in `actix` materially affect performance, but the author's unwillingness to even consider merging PRs that remove `unsafe` blocks that are *shown* to be problematic is ridiculous.
actix-web remains your best option for async web development greenfield to your hearts desire
`SetTo` can have a nice blanket implementation for most uses: simply `mem::swap` self and the passed in value. Seems like a reasonable trait to have (and it might be possible to derive `From` implementations from `Default` + `SetTo`, limiting the amount of extra implementations required).
This does not seem to work any more. It worked months ago though.
I'm completely lost in this fight against the borrow checker. Here's a [playground link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9fc4399d3cccec2a72eed0c858e60e5e). I'm trying to use Tokio to perform async I/O. I want to be able to send data from any number of threads, but need synchronization to make sure that each send happens one after another (order actually doesn't matter too much for this use case, but atomicity does). To do that, I'm trying to use the Tokio mpsc module. The basic idea is to create an mpsc channel with the underlying socket. Then, I can send data to the mpsc channel, and have a single task that simply pulls from the channel/queue and sends the data, one message after another. The borrow checker is NOT happy about this. The error message seems descriptive, but I can't make heads or tails about what it's trying to tell me. error[E0495]: cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements --&gt; src/lib.rs:31:39 | 31 | tokio::io::write_all(&amp;cloned_ptr.socket, m.buf) | ^^^^^^^^^^^^^^^^^ | note: first, the lifetime cannot outlive the lifetime '_ as defined on the body at 30:23... --&gt; src/lib.rs:30:23 | 30 | .for_each(move |m| | _______________________^ 31 | | tokio::io::write_all(&amp;cloned_ptr.socket, m.buf) 32 | | .map(|_| ()) 33 | | .map_err(|e| eprintln!("write error: {}", e)))); | |_________________________________________________________________^ note: ...so that closure can access `cloned_ptr` --&gt; src/lib.rs:31:39 | 31 | tokio::io::write_all(&amp;cloned_ptr.socket, m.buf) | ^^^^^^^^^^ note: but, the lifetime must be valid for the call at 28:9... --&gt; src/lib.rs:28:9 | 28 | / tokio::spawn(tx_receiver 29 | | .map_err(|e| eprintln!("error in pubsub send queue: {}", e)) 30 | | .for_each(move |m| 31 | | tokio::io::write_all(&amp;cloned_ptr.socket, m.buf) 32 | | .map(|_| ()) 33 | | .map_err(|e| eprintln!("write error: {}", e)))); | |___________________________________________________________________^ note: ...so that argument is valid for the call --&gt; src/lib.rs:28:22 | 28 | tokio::spawn(tx_receiver | ______________________^ 29 | | .map_err(|e| eprintln!("error in pubsub send queue: {}", e)) 30 | | .for_each(move |m| 31 | | tokio::io::write_all(&amp;cloned_ptr.socket, m.buf) 32 | | .map(|_| ()) 33 | | .map_err(|e| eprintln!("write error: {}", e)))); | |__________________________________________________________________^ I haven't even gotten to the receiving side of the socket, either, which I think suffers from a similar issue (I need to create a connection object, and launch a task that uses the connection to receive data). I tried looking for examples, but every Tokio example I find is far, far too simplistic, so they avoid all this nasty business entirely. Or maybe I'm using the library incorrectly, but this seems like the kind of thing that is super duper easy with Asio (C++).
I understand that it's better to have the dependencies split in multiple crates. My issue is with having to bundle the whole tokio ecosystem when all I need is a synchronous postgres client.
Even simpler, `*self = to` just works, no need for `mem::swap`. What do you think of the idea in the edit at the bottom of my original post to have `From` and `SetTo` just be the same trait? A (potentially inefficient) `set_from` implementation can be derived automatically from `from`: just do `*self = Self::from(from);`
I don’t want to really get into this debate again; I was already pretty frustrated in your linked comments :) First I would like to point out that I am only one of the current Gotham maintainers (and an not an original author). I do not speak for the other maintainers, and I would hate for my opinions to impact them in any way should they disagree (although we haven’t really discussed this stuff). I’d appreciate if you could tweak the post a little just to make that clearer! On the topic at hand, I have been thinking about this a lot, because people were claiming I am biased. After consideration, my view hasn’t changed, but I honestly think it doesn’t matter much. If people allow themselves to be convinced by benchmarks that do not apply, that is their issue to solve. I know most benchmarks have changed to games; and so I’m going to basically try enforce a simple “Hello World” as our benchmark. If this makes us look a lot slower, so be it. Maybe some of the other frameworks will then remove their games too, such that we all seem slower. Then anyone considered “cheating” is an obvious outlier, and it’s very easy to communicate as to why. Given that these benchmarks are so public now, rather than overlooked, this seems like an easier task.
You're right - the real goal is compile times. But number of dependencies is reasoable proxy for how long something will take to compile
Does it give a specific error? `--target` is still listed as valid parameter to `cargo test`.
What's even more concerning, [the pull request fixing it](https://github.com/actix/actix-web/pull/968) was closed with a dismissive comment from the maintainer.
&gt; If the author is unwilling to accept security fixes, why would I believe they are interested in accepting anything less important than that? This is where I don't subscribe to the issue that any memory unsafety problem is a security issue. I'm using owning-ref's Owned Handle which I know is inherently unsafe despite having an unsafe API and I have ruled that to be within the bounds of what I'm okay with given the extra convenience this gives. This does not mean I'm okay with security issues. It just means that I have determined for my use that this is okay given the alternatives. &gt; From my point of view, security is fundamental. If a web framework is doing things in the name of performance that knowingly sacrifice security Until Rust came along most frameworks did things in the name of performance that had a chance to compromise security. Just look at how many frameworks embed C code in one way or another. Any C code (or FFI code) is inherently unsafe by the measure shown actix is measured against. &gt; I'm still highly doubtful that more than one or two of the unsafe blocks in actix materially affect performance, but the author's unwillingness to even consider merging PRs that remove unsafe blocks that are shown to be problematic is ridiculous. I'm sure if you can show that the performance is not impacted it would be a different conversation altogether. However I have yet to see a benchmark being attached to any of these issues.
Great article, thank you! BTW I think the web framework that many are waiting for is [`tide`](https://github.com/rust-net-web/tide).
&gt; That is something everyone can quickly see for himself by running a `grep unsafe . -r` on the code of the crate. There's actually a tool for that, which will recursively go through the dependencies for a crate, and report on unsafe usage. It's probably worth it for everyone (whatever your stance in this debate) to familiarize themselves with it. https://github.com/anderejd/cargo-geiger &gt; The last thing I would need are blog articles publicly pillorying my behavior/attitude. A private mail would be way more helpful in that situation. We are just humans and we have feelings. Any sort of personal attack towards anyone is not appropriate. At all. I don't think the article crossed the line, but instead validly raised some concerns about the project itself and the main author's handling of this subject. And I think this is an issue the Rust community should be discussing. I would like to think that most Rust authors would tend to avoid unsafe, but I'd like to see that point reinforced. It is a tool of (nearly) last resort, to be used when something just can't be accomplished via any means in safe Rust, or (less commonly) as a tool to squeeze out significant performance gains.
I'll tweak it - my mistake
If you are a contributor volunteering your time to a community driven project do you: * Support a project that doesn't hold similar ideals to yourself (as demonstrated by concern and patches around `unsafe` usage) * Support a project that does hold similar ideals to yourself * Wait for a project that holds similar ideals to you to gain features and market share before contributing I'd hazard a guess that the *vast* majority of people fall into the latter 2 categories, hence the lack of actix support/contributions from the community.
Interesting. Will look at that. Not sure if there is a good way to prevent this without using a RefCell though.
&gt; there were pure functions There were? They should come back.
&gt; I'm sure if you can show that the performance is not impacted it would be a different conversation altogether. However I have yet to see a benchmark being attached to any of these issues. As demonstrated by this entire discussion, many people in the Rust community believe this works the other way: there should be benchmarks demonstrating the necessity of *each* `unsafe` block, and at least a comment discussing possible UBs and how they're mitigated. The burden shouldn't be on people wanting to use the library to prove that each `unsafe` is unnecessary or harmful. The default position is that `unsafe` blocks are risky. &gt; Until Rust came along most frameworks did things in the name of performance that had a chance to compromise security The key word was "knowingly". If someone came along and pointed out an error in the C code, I would expect it to have been fixed. I wouldn't expect the author to do something that saves a nanosecond but might lead to writing into arbitrary regions of memory.
&gt; If you are a contributor volunteering your time to a community driven project do you: I take option 4: I contribute to projects I can use for the things I am doing. I think most people work like this. Overall the rust ecosystem does not get that many contributes on most crates. Actix is not an outliner here. Actix just has a much larger surface area. Actix if anything is a bit ahead of the curve when it comes to being useful for production applications at this point.
Author of Thruster here, and I'm stoked to have Thruster mentioned in the alternatives! &amp;#x200B; As an aside, especially around code quality, I think it can be really difficult to keep code quality when there are very few devs working on it, as I think someone else mentioned here. Since code review is not really possible when you're alone, it becomes very easy for the code to be a reflection of your mental model of the framework, which isn't always clear to readers coming in fresh to the code base. &amp;#x200B; The benchmark game is annoying. I like to try and keep Thruster (relatively) fast so that it maintains visibility, but it's a good point that what a lot of the top frameworks, not just Actix, are not something a developer would want for production. That being said, playing the game does enable us to draw lines about where the other frameworks are and where we can expect to be. There are multiple features in the Thruster framework that came out of trying to optimize, but are still super useful in every-day, like not traversing the route tree for static/known paths. In the end, I don't think Actix is bad, but I do think choices are good. Many of the web frameworks in rust have completely different paradigms, and, as such, help the ecosystem evolve as a whole. &amp;#x200B; Also, totally shameless plug, if anyone is interested in helping on Thruster, I'm always looking for contributors! Especially around the Hyper integration, as it got a little stale with the recent work in the async/await feature.
&gt; Actix if anything is a bit ahead of the curve when it comes to being useful for production applications at this point. Yup. It's why I use it too. I still hope something comes along and becomes a proper competitor if not unseats it though.
Thanks for that comment and the link. For me, this pull request and the maintainer comments are more than enough to avoid actix as much as I can. Which is disappointing cause I've heard a lot of good things about this crate, but those comments raise concerns about the crate future.
Well, if one of my criteria is language stability, then its relative lack and the consequences on the current ecosystem is certainly going to be a disadvantage for me. Maybe I should think about something like targeting past revisions (e.g. now the 2015 edition) but even then it is my understanding that it is still evolving? Also I'm actually eager for still unpublished big features (ex const generics) so I'm somehow looking for a middle ground, with compromises if needed. But for example for the applications I'm doing for work having to upgrade the compiler every 6 weeks or being at risk of e.g. not getting security fixes of some libraries (because the author might decide to depend on the last compiler all the time) is a clearly a no-go. Our release cycle is more in the order of a year, and we have to maintain or at least be able to maintain some previous versions. Of course we could try to backport ourselves, but at this point it might not make economical sense anymore... That's certainly not a problem we have in C++: there we can e.g. target C++14, compilers are very reasonably conforming even from early versions. And classic Linux distro actually take care of the security of library they ship, on top of that with a very simple upgrade story when libs are dynamic. Plus upstreams also more rarely change language version from day 1. Debian actually ships some Rust libs in Debian packages; I'll take a look at what is available, and their maintenance policy in this area. Hopefully in a few years Rust will be easier to adopt in cases similar as mine.
Tokio itself is split into many creates **specifically** to allow libs to pick and choose :) Any lib can depend on exactly the components they need and no more.
I wish I had more time to build my actor system. I think there's lots of potential for the concept in Rust. https://github.com/insanitybit/derive_aktor Example here: https://github.com/insanitybit/derive_aktor/blob/master/src/bin/ex.rs
Sounds like the definition of Cow.
This is a worrying trend. I think a lot of new Rust programmers don't really understand unsafe Rust. Writing unsafe code is completely fine, and sometimes you will have UB inside unsafe code, but at least it is inside an unsafe block and you know where to look. Marking an unsafe API as safe is just wrong on some many levels. I am not sure how the Rust community should handle this.
&gt; It has been brought up as this massive problem and for why one cannot use actix but in practice it has not caused any issues and continue to not do so. For people who actually are trying to get stuff done it turns out this is the least of our concern. This is a really bad attitude when it comes to security. It's like saying "We don't authenticate users, but no one has actually attacked us and it actually isn't a real concern". Safety should probably be at the top of your concerns, for the majority of projects, but especially for anything where user data is involved.
Second this. Tide has a great potential. I was never a big fan of actix. Only speed is not anough. Documentation was poor and the code style was awful (before 1.0).
Yeah makes sense. Then I guess the main issue that needs to be tackled is for library authors to take advantage of this provided flexibility instead of just bundling "tokio". Thanks for the information!
rustlang would be better, but I would say no anyway. Shame you can't add something like a terms and conditions "you hereby declare that you understand that this is not the game called Rust", before posting.
As always, performance analysis is complicated, and highly dependent on context. Yes, there are situations where reselling the buffer is a win. But there are also situations where using the buffer from the source of the assignment is better than reusing the target's buffer. Situation 1: The target buffer is always empty. Allocating a new buffer and doing the copy, then freeing the source buffer, is less efficient than the naive implementation. You could maybe be smarter about this and keep one or the other allocation. Situation 2: The source buffer is perfectly sized for its contents, while the target buffer is much larger. If you keep the target buffer, then you may waste a large amount of memory. Situation 3: The strings are large enough that the memcpy of the contents is more costly than the allocation operations. As always, when you examine performance issues, you have to ask "for what purpose?" And then you have to measure I agree that reusing buffers is often the best thing, but it is definitely not always the right thing. Measure, measure, measure.
&gt; Caml-like languages (like Haskell or Scala) You better don't tell the OCaml or Haskell people that you called Haskell Caml-like. ;) Often Haskell on one side and the ML family (including OCaml) on the other side are seen as two separate branches in FP.
Recent? Rust 1.0 baby!
To be clear, triggering _undefined_ behavior, even in unsafe code, is never okay. At that point it's game over, and whether your final program is correct is left entirely up to the whims of the compiler. The effects of undefined behavior are in no way contained to the code that's been marked as unsafe. To quote Gankro's excellent [blog post](https://gankro.github.io/blah/initialize-me-maybe/): &gt; Unfortunately, what compilers most love in the world is to prove that something is Undefined Behaviour. Undefined Behaviour means they can apply aggressive optimizations and make everything go fast! Usually by deleting all your code. I agree with you that `unsafe` code isn't quite as bad as what many seem to have the impression of (much like dynamic dispatch), but undefined behavior is whole different beast, and one you have to be _very_ careful with. And unsafe code is where UB will generally crop up.
I think you slightly misunderstood the issue. The issue is that there might not be a source buffer. Or more accurately, we might not be able to just take ownership of that source buffer. That might be the case for example if the user wants to call `employee.set_name()` and wants to set the name to `"Bob"`, which is a `&amp;'static str`. So there is no "source buffer" here. The user might allocate one by doing `"Bob".to_owned()`, but ideally we want to avoid that allocation, because we (the `Employee` struct) already have a buffer (as part of our `name` field). So we want to avoid that unnecessary allocation.
&gt; As demonstrated by this entire discussion, many people in the Rust community believe this works the other way: there should be benchmarks demonstrating the necessity of each unsafe block, and at least a comment discussing possible UBs and how they're mitigated. Many, but I'm not sure if it's the majority of the user base. It's definitely the majority of this subreddit and other vocal communities.
What do you need them for?
I don't know enough about specialization to really be able to tell which approach is better (I think need specialization here due to the blanket impl of From&lt;T&gt; for all T, but I guess that blanket implementation can just contain the `*self = value` code). Seems like it'd be worth writing up a small pre-RFC and posting it on the internals discourse.
Okay I thought it was more recent than that.
&gt; Seems like it'd be worth writing up a small pre-RFC and posting it on the internals discourse. I think I'll do that, yeah.
I’m looking at Van Patten’s card and then at mine and cannot believe that Price actually likes Van Patten’s better. Dizzy, I sip my drink then take a deep breath. ___ ^(*Bot. Ask me how I got on at the gym today.* |) [^(Opt out)](https://www.reddit.com/message/compose/?to=botrickbateman&amp;subject=Opt%20out)
Nice! I'll give it a try! I also love the fact that you are releasing on Linux but not on Mac 😉
UB inside inside an unsafe block is much easier to fix than an unsafe api that is marked as safe. You might have to redesign your whole API, unless you want to mark everything unsafe which is also not very helpful.
Might have been a wrong first impression. Does enabling borrow checks for all functions in a D program make it more strict than Rust?
&gt; This is a really bad attitude when it comes to security. It's like saying "We don't authenticate users, but no one has actually attacked us and it actually isn't a real concern". Security is not a binary game. For any attack vector you take the likelihood and impact of something happening. For most web application it's a lot more important to focus about application level security than about if some IO or scheduling code uses unsafe inside. &gt; Safety should probably be at the top of your concerns, for the majority of projects, but especially for anything where user data is involved. It is and it has always been. Which is why when writing web services my first and foremost concern is the safety and integrity of my user's data. To give you a very practical example: actix is currently the only system I managed to make work in rust that allowed us to make safe HTTP requests to untrusted sources which is crucial for the security of one of our services.
Yeah, trust me, I get all that. I'm pointing to the general issue, which is that there is rarely a single "best" when it comes to performance analysis.
Have you a preview of the final sticker ?
To write pure functions?
The important question: if you were to start a new game today, would you pick Rust again?
/r/progrust \- the pro-gamer-rust community?
As far as I'm concerned, it's a vocal minority who is trying hard to assert their ideology on others
What on Earth is `str`, and how is it different from `&amp;str`? I just had the compiler complain at me for using the latter instead of the former, and I'm having trouble understanding the difference. Is it true that it's technically not a valid type?
I don't feel like we need more web framework. I feel like we need to polish what we already have. There are a lot of rust webFW already that are not being taking care of. It feels like JS world being reproduced here where there is a shinny-new-definitive-everyone-should-use-FW every day. You start using it and 6 month later you feel that it was a bad decision.
I've had this conversion with folks many times, and the same stuff keeps getting rehashed. It's not just about compilation times. It's about maintenance. I just had a conversation with /u/dpc_pw about this: https://old.reddit.com/r/rust/comments/c9fzyp/analysis_of_rust_crate_sizes_on_cratesio/et046dz/ --- I don't really feel like going through all of that again. The bottom line that people _should_ understand is that the total number of transitive dependencies is going to put some folks off. The reasons for putting those folks off may not be shared by all, but there are plenty of valid reasons behind that opinion.
To paraphrase my comment from last year about Actix, which was downvoted to hell and for which I was accused of being overly melodramatic... &gt; One hundred uses of `unsafe` is not just shaky code. It's a totally broken process. I believe this new article adds weight to my point. Actix is not following the Rust way of doing things (be nice, be safe... then be fast) and when someone hurts themselves using it, they'll blame the whole Rust ecosystem, and we'll all be sad.
Ha-ha. I'm not joking here; why do you need pure functions?
It will be roughly 3" by 2.8", rounded corners with a white border. Unless there's some vocal preference for something else?
Actually I already [proposed to implement `group_by` on slice](https://github.com/rust-lang/rfcs/pull/2477) in the stdlib but there was backshadings on the name. So I made a library for my own usage named [`slice-group-by`](https://github.com/Kerollmops/slice-group-by) which even work on mutable and str. Be carreful, this library works like the Itertools one, it yield contiguous elements in a slice. There also is [an explanation of why using this library instead of the Itertools one](https://github.com/rust-lang/rfcs/pull/2477).
&gt; For most web application it's a lot more important to focus about application level security than about if some IO or scheduling code uses unsafe inside. The only reason this is true is because of the massive investment into: a) compiler mitigations for unsafe languages b) the migration to *safe languages* for web services, like rust for example The reason people target deserialization in Java isn't because it's inherently worse than memory corruption or something, it's because the other problems were solved. Moving back to a world where RCE via memory corruption is trivial would mean we see more of it, suddenly you'd have to care about it just as much or even more than application logic failures. &gt; actix is currently the only system I managed to make work in rust that allowed us to make safe HTTP requests to untrusted sources which is crucial for the security of one of our services. Sadly I think this says more about the rust ecosystem then actix, and I agree with the sentiment.
I'm not sure I follow what you mean here -- could you try phrasing it differently? Why is fixing UB easier inside an "unsafe API"? And what do you mean by "unsafe API" mean here? UB is bad no matter where it appears, and _must_ be fixed, and as soon as possible. What API you are exposing externally does not really matter. Even if you expose an `unsafe fn`, your code should _never_ trigger undefined behavior, and it should be made clear to callers what guarantees they must uphold to ensure that that is the case if there are invariants they must uphold. As to whether it's okay to mark APIs that internally use `unsafe` code as safe, I think that is very clearly the case. For example, `std::sync::Mutex` has unsafe internals, but presents a completely safe interface with no danger of undefined behavior or other memory safety issues. That seems okay to me?
&gt; You're right - the real goal is compile times. Not necessarily. See my comments here for more elaboration: https://old.reddit.com/r/rust/comments/c9fzyp/analysis_of_rust_crate_sizes_on_cratesio/et046dz/
The str to String case you mention has an experimental implementation in ToOwned's clone_into
&gt; b) the migration to safe languages for web services, like rust for example I don't think this is true at all. Most web services are written in Python which is an unsafe language and still most problems are sitting in application code and not memory corruption. &gt; The reason people target deserialization in Java isn't because it's inherently worse than memory corruption or something, it's because the other problems were solved. No, not because it's solved but because the payout is much higher. Untrusted serialization systems like Java's or pickle are easy to do and have huge payoffs. Memory corruption is relatively easy to achieve in Python applications but so hard to pull off in comparison that it's not worthwhile.
Totes down for a sticker. I don't mind paying if the costs don't work out for w/e reason
I think the other commentter pretty much guessed right, specifically, HLists. I haven't actually tried warp yet, although I did do a brief code review a while back to see how HLists were being used. It's definitely neat, but I'm overall not familiar enough with the design space to know how it weighs against something "simpler." Although, I don't envy the task of a web framework designer: it is difficult to compete with the race toward terseness.
How can you convert a `PathBuf` into a `Path`?
Just to know if it will be a simple rectangle or if it will follow the text shape?
I have never seen the compiler recommend a naked \`str\` before. Can you show me a small example that produces the error?
https://www.reddit.com/r/rust/comments/cdtsqz/reasons_for_not_implementing_group_by_on_vec/ety04pd/?utm_source=share
actix-web would be the last thing on my list to even look at, because the blog post submitted here wasn't news to me. I don't know what your deal is, but all I said was "I'd start with Gotham or warp." Actually trying something is a necessary stage in evaluation. Depending on your constraints, doing a rigorously thorough evaluation of all available options is impractical. But hey, if that's what you want to do random redditor, then knock yourself out. But I an't biting.
This is why I tend to prefer rolling release. Most Rust software tends to target the latest stable release, and often use features that were only recently stabilized because it's safer and easier than reimplementing for old compiler versions. With C++14, you're explicitly targeting 5 year old compilers. Rust wasn't even 1.0 at that point. It's fairly stable in terms of existing features, but is young enough that new features are constantly being added. Especially with things like `std::mem::uninitialized()` where developpers are being *heavily* encouraged to switch to using `std::mem::MaybeUninit`, which was only stabilized in 1.36, less than a month ago. On top of that features like `async_await` and `const_generics` are so eagerly awaited that a very large fraction of rust code will be converted to use then very quickly after their stabilization.
https://github.com/Kerollmops/slice-group-by
[This is the third method in the docs](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.as_path)
The most popular web backend is probably PHP, but it's not particularly pertinent. &gt; Most web services are written in Python which is an unsafe language and still most problems are sitting in application code and not memory corruption. First off, Python libraries that call out to C *are* exploited in the wild. It happens quite a lot. Python frameworks like django don't actually expose much C code directly, to my knowledge, anyways. In the framework itself there is no direct C code. Actix is different here - it exposes memory unsafety at a very early stage. The only stage earlier is likely your TLS. &gt; No, not because it's solved but because the payout is much higher. Untrusted serialization systems like Java's or pickle are easy to do and have huge payoffs. Memory corruption is relatively easy to achieve in Python applications but so hard to pull off in comparison that it's not worthwhile. The reason attackers don't go after memory safety is because it is in fact quite difficult, because of decades of work to make it so. In languages like Python the attack surface for these vulnerabilities will be quite smaller, same for Java. This feels like the wrong argument though. The issue isn't "memory safety is more important than application safety". Rust's value proposition here is "memory safety is effectively solved, focus on application safety". A web framework that allows memory safety issues puts as back to "memory safety is a problem, and maybe you prioritize application safety, and maybe that's the right call, but it's still a problem".
&gt; The unsafe aspects of it don't show up as an issue in my experience. Just wait for the day when a CVE gets filed against a Rust web server build on `actix-web` for a memory safety vulnerability. It's going to matter then, and it will surprise nobody whose familiar with `actix-web`. It's going to deeply surprise everyone else though. It won't be a good look.
Simple rectangle was my first stab at it. Do you have a preference? Clipping the background is possible but looks rough at first glance. There's enough background stuff that intersects the text and I think the background is part of the point of the image. I would tend not to unless there's vocal sentiment for it, but I want to make stickers people want.
Actually, Andrew's overview of Rust code is a very valuable thing. He has a super high quality of code, and the entire community appreciates when he shares his findings.
Currently, rust errors have a problem with not telling which lifetimes are which. If I were you, I would break up the code as much as you can into "if let/match/for" statements with no method chaining, and explicitly annotate every type. After you figure out what is going on, you can then put it back into iterator form
I'd be happy to have one!
It's not that it isn't stable. It's just things keep being added at a relatively fast rate, since there's been so much missing to get those true zero cost abstractions. Those unpublished big features you want right now? 3 years ago there were several more of them unimplemented. Besides that, the only "breaking" change has been some minor syntax stuff that's easily automated to switch from the 2015 edition to the 2018 edition. This is actually how the Rust compiler handles old editions internally. Unlike other programming languages, the Rust devs actually place a very high value on stability. Their only ask, really, is to keep the compiler updated. No old code will break. Even now, as they've found some soundness bugs with borrow checking, they will still compile it. There's just warnings for the next few versions, before they prevent it from compiling. The only code that they're fine with breaking is unsound code. --- I'm not really sure how Rust handles security issues in the compiler, and backporting those fixes. Really, that Debian included a single specific version kinda threw me for a loop. For me, at least, I don't really understand your use case of a frozen compiler version. For whatever you develop, there's actually zero effort in switching to a new compiler version, except in telling rustup to upgrade to the newer toolchain. Code won't break (except unsound code with lots of heads up, and only really rarely), and bugs will quickly get fixed in a .1 version. Basically, in Rust, they keep things stable enough so that you don't need backports, since the current version is basically the backport but with a few more features. This is explicitly why Rust has such small but rapid updates. Big updates always change a ton of stuff, so instead Rust has small updates and doesn't make true breaking changes (again, they're allowed to break code that shouldn't have been compiled, but accidentally is). --- Let me take a guess in how your development work is given what you've told me. You write apps where each version is maintained for at least a year, and where you gotta be able to backport security fixed and what not, whether it's in libraries or your own code. Across the next 10 years, you don't want to mess with breaking and updating old versions; you just want it to work. Well you're in luck! Target the 2018 edition and use any new features as they hit stable. Don't use the nightly or libraries that rely on nightly. Squint and inspect rapidly developing libraries and ones under 1.0, which are free to break API as much as they want (though some offer soft security guarantees). Those over 1.0 will typically backport fixes, but typically they don't make breaking changes and increment the major version number, so they don't really even need to think about it. With Rust, you won't be dynamically linking your own or other Rust libraries, since the ABI isn't stable. If you really want to be able to, you have to mess around with extern C stuff. That is to say, your entire app will be statically linked (with the exception of any crate that dynamically links to a c library, like openssl, for example). If there's some security fix in any library or your own app, load up the most recent compiler, update that crate, and just do a release build. (Again, crates on crates.io aren't guaranteed to remain stable and work when you update them, but most should be following semantic versioning and work as long as you only update the minor and path numbers.) Updating the Rust toolchain won't affect any of your old code, and its ability to compile. Rust, too, also follows semantic versioning. That's why it's only on 1.36.0, not 2 or 3 or whatever. It doesn't break old versions, except for the cases of soundness, like borrow checker bugs or mem::uninitialized, and even with those they give plenty of warning. --- I really hoped that I got across that you really should be fine (as far as I understand it). If you're still not sure and/or really want to use Rust anyway, I'd be happy to answer more of what I know regarding Rust's stability. I'd just need to get a better idea of your situation, if I didn't capture it accurately enough. In my original comment, I mostly was trying to get across something slightly different than what I guess I did. The Rust language is stable, and has been since 2015, when 1.0 was released. New editions are only for slight breaking changes, like adding keywords, which are easily fixed automatically, and can thus not actually break things. However, they're still adding new features really fast, which is fine, and still doesn't break things. By maturing rapidly, though, I meant that the community's libraries are breaking. So much net stuff is different from a year ago, and a year before that. So many libraries are finally able to be used on stable. So many libraries have stopped making breaking changes. But so much is still maturing rapidly. What I mean is that you can use Rust perfectly fine. It itself is great right now, and keeps getting better, without breaking jack shit. But the libraries you might rely upon? Depending on what you're making, those might break too often. Though, if you're considering C++, chances are you'd be fine writing whatever you needed from scratch, or even handling whatever community libraries you'd be using yourself. Again, let me know. I'd be happy to answer any questions, as I've been in the community since 1.0, following along, even if I haven't been doing tons of active dev work and can't help with complex issues. For something like this, though, I can help you get a sense of Rust's community and culture perfectly fine.
&gt; Python frameworks like django don't actually expose much C code directly, to my knowledge, anyways. In the framework itself there is no direct C code. Django has plenty of references to ctypes which is as unsafe as it gets. Flask depends on MarkupSafe and Jinja2, both of which have either large C things attached or use ungodly ctypes code to touch interpreter internals. &gt; In languages like Python the attack surface for these vulnerabilities will be quite smaller, same for Java. I disagree with this greatly. Buffers objects are a great concern to Python security and quite exploitable. They just generally are not because of how much work there is involved. C code also normally does not get exploited. Absolutely horrible C code can hang in mission critical code paths for a long time before exploited. Just think about how long it took heartbleed to be discovered despite how long that thing was an issue. &gt; Rust's value proposition here is "memory safety is effectively solved, focus on application safety". Except Rust's value proposition is: you do not have to sacrifice productivity and convenience in the process and that value proposition is in many parts not yet real. Just the entire design of the current futures has shown that unsafe code is not as avoidable as we all want due to shortcomings in our ability to express certain constraints in Rust code.
But that returns a reference to a `Path`, not a `Path` itself?
I'm sorry, but i hate the idea that an assignment can do nontrivial stuff. &amp;#x200B; And yes, i know that Deref/DerefMut and Index/IndexMut already break this semantic, but this seems to me as extra dangerous. i would like it better if you suggested marking it with a new syntax, like := or &lt;- or something.
With a `String` I can do something like `my_string.as_ptr()`. Why can't I do the same with an `OsString`?
Yeah, you are right, now with this explanation and the fact that I do not like big rectangle stickers I think I will not take one. However your explanation can be useful to someone else :)
I don't disagree with this at all and I'm very unhappy about some of the uses of unsafe in the codebase (particular the mentioned `Cell&lt;T&gt;` type). For me the issue is that the conversation is now so completely tainted that it's hard to have a reasonable conversion with Nikolay about this issue and that some of the aspects why actix is convenient to use and fast is bought with that unsafety in the first place.
In my proposal there is no new syntax. It has to be called explicitly as `name.set_from(x)`. I don't propose to change the meaning of `name = x` to `name.set_from(x)`.
We were here first. Why should we move? Also, I would hope that the language outlasts the game in terms of popularity.
I'm not really sure what your points are, so I'll take a step back. I don't really want to argue about Python's memory safety story, especially because I've already stated that exploitation of memory safety issues is more difficult today due to, again, decades of work to improve compiler mitigations. Actix is doing the wrong thing. Memory safety matters to web services. The rust community should continue to hold developers to a high standard, open source or not, free work or not.
The submission page says &gt; **The Rust programming language. For the Rust video game, see /r/playrust** Can't do much more than that.
Oh, right... Sorry, I'm tired and i got it mixed up with the C++ reference in the beginning.
I find it actually pretty amazing that **warp** represents the whole web application definition as a single type. Unfortunately, this also increases the compilation time a lot. warp added more than 40 sec to the compilation of my bare hyper app consisting of a custom router and 3 endpoints. However, it might be that I am doing something wrong (e.g. using sccache?). &amp;#x200B; What I personally was missing is a possibility to implement custom filters (`Filter` trait is sealed for now at least) and a more powerful error handling. At the moment, only some error types are exposed, errors lose previous context, custom errors need to be downcasted, standard error responses are non-customizable plain text, etc. It would be nice to have a single exhaustive `match` block in the error handler, which at compile time tells you that you forgot to handle a newly added error case. &amp;#x200B; However, let's not forget that warp just has version 0.1 and it did already so much right. It is a tiny but powerful abstraction on top of hyper. Apart from this, the author is very helpful and responsive (just check issues and PRs). So, I guess we just need to contibute more to the project and make it better in the spirit of the Rust community. :)
I develop on windows and hate this tidbit. In practice you can get reasonable small sleep times if you request a smaller duration than you need, and spin for the rest. I recommend trying a condvar wait/notify setup where it's applicable.
I thought I was pretty clear: unsafe is bad, but it's not the highest of my security concerns.
I read this document, and a bunch of the links that were intended to show why *instability* is desirable, but I feel like I still don't understand it. I can see why it's desirable to be able to distinguish between "this `u8` has a determinate bit pattern" (initialized to some value, possibly statically unknown) and "this `u8` has an arbitrary bit pattern" (uninitialized), but "this `u8` has an unstable bit pattern" seems like a third thing. In particular, for this example in the LLVM notes, void test2() { if (cond) V1 = ...; V2 = phi(V1, 0) ... // stuff that does not modify or look at V. if (cond) use(V2); } Since `V1` isn't initialized in the `!cond` branch, can't the compiler say "well, it's an arbitrary value, so just choose the value for the phi function that minimizes work"? Ralf does say that not having to pick a consistent value inhibits desirable optimizations, but which optimizations does *that* specifically, rather than just allowing the compiler to pick *some* value, inhibit? Considering that it seems to also inhibit some desirable programming idioms, such as taking a `(u16, u8)` pair to `AtomicU32`, which he linked somewhere, which (maybe?) would still be ok if uninitializedness meant "arbitrary" rather than "unstable".
I played with it more, and I think it's related to the move closure. I assumed it would capture the cloned pointer by value (as a move) and therefore the lifetime would be fine but it doesn't seem to do that.
Yeah, I get that, especially since the title "Copy assignment in Rust" seems like I want to bring copy assingment operator overloading to Rust.
There is no such thing as "a \`Path\` itself", \`Path\` is kinda like \`str\`, and \`PathBuf\` is like \`String\`. You don't use \`str\`, you use \`&amp;str\`, and likewise, you use \`&amp;Path\`, not \`Path\`.
Fair! I think the text shape would be a very appealing sticker, I think it just _also_ means revisiting the original graphic, which I don't have time/skill for right now.
Nice! You should tell OP :)
`str` is an "unsized type", which is a special kind of type that must be used in combination with some sort of pointer type. `&amp;str` is the most common of these, called a "string slice". But you can also have `Box&lt;str&gt;` or `Arc&lt;str&gt;`, at least conceptually.
I haven't tried it myself, but there's another actor framework called [riker](https://riker.rs/).
Yep i wrote the spin-sleep crate to handle this when I needed consistent small sleeps in the compute loop.
&gt; It's definitely neat, but I'm overall not familiar enough with the design space to know how it weighs against something "simpler." To add to that: very few of my problems on a daily basis have to do with request routing. The reason we ended up with actix is the actor (and now service system) and the many answers it has to questions that come up for composing larger systems. We only expose 4 endpoints and most of the code is not HTTP related. But even in the HTTP areas hyper/warp still lag a lot. For instance there is no working multipart support currently which is absolutely crucial for what we do.
Wrong sub. Try /r/playrust...
Really, i should just go to sleep, I'm really tired. Oh well, if you're in the night side of the planet right now, go see the moon. There's a peak lunar eclipse literally right now.
&gt; The question of course then is, does the effort spent writing safe code all the time outweigh the hypothetical reduction in bugs? Instead, with Moore's law slowly coming to an end, I think we need to design a system's programming language's that's fun to use, and more accessible to new programmers. I'm sorry to say that, but I think that nobody should listen to that guy. If he claims that he doesn't need to write safe code and then he mentions 'hypothetical reduction', then it means he writes hobbies projects at most. I maintain 20+ apps in rust (2 years), c# (on linux, 5 years) and ruby (5 years). In rust apps, I cannot remember when I've seen a bug other than logical ones last time. I don't have good enough memory to say it's never happened, but it might be possible. On the other hand, we still discover some null pointer exceptions in c# and in ruby... all kind of weird errors, all the time. Ruby is so fun to write but hell to maintain and to modify if you are not the author. In rust, this is a pleasure. C# is somewhere between, closer to rust, but not that close.
Yes, I agree the situation is unfortunate. It's no fun being at the bad end of a mob. I think most people are being pretty polite relative to how the rest of the Internet behaves, but this is a thorny issue. I've said in the past (outside the context of actix) that the people behind a project are fair game for evaluating whether to bring in a dependency or not. There's trust, reputation and good judgment that are hard to quantify, but are nevertheless important qualitative metrics. You hear the positive side of this a lot, e.g., "burntsushi's crates are always good." But the negative side is... ugly, because it's really hard to straddle that line between being rude/unfair and lodging legitimate concerns with one's qualitative confidence in a maintainer. And unfortunately, that's exactly what's happening here.
I think they're saying that marking an API that is unsound in particular scenarios as safe is particularly nasty.
That's a great example, thanks! Goes to show real machines are actually more crazy than I thought...
Yep, maybe not opengl though
Hmm, but I can definitely create `Path`s? For example: `Path::new("hello world")`? There are however, no obvious ways in which I can create a `str`?
I am, and I didn't know about it. Thanks. Shame it's not a full lunar eclipse.
`Path::new` returns a `&amp;Path`. https://doc.rust-lang.org/std/path/struct.Path.html#method.new
Yup, I hear that. The conclusion I'd probably unfortunately draw from that is that the Rust ecosystem isn't ready for building robust production grade web servers in the vast majority of cases. But I think that's okay; I wouldn't expect too much better at this point. I'm hoping the advent of `aync`/`await` will change this and result in an explosion of new work in this space. But I am optimistic by nature. :-)
Yep, it's pretty clear to me. People just don't read before posting.
&gt; I'm not sure I follow what you mean here -- could you try phrasing it differently? Why is fixing UB easier inside an "unsafe API"? And what do you mean by "unsafe API" mean here? As in replacing something like `mem::uninitialized` with `MaybeUninit` is fairly easy, or if you run into a segfault your will most likely be looking for unsafe code. Just finding the UB in the code from above is really tricky because of `clone` and `get_mut`. And fixing an unsound API will most likely be a breaking change. &gt; As to whether it's okay to mark APIs that internally use unsafe code as safe, I think that is very clearly the case. For example, std::sync::Mutex has unsafe internals, but presents a completely safe interface with no danger of undefined behavior or other memory safety issues. That seems okay to me? If you can guarantee that your public API is completely safe, you can use as much unsafe code as you want. That is whole the purpose of unsafe code. As far as I can see, the internal APIs for Mutex are properly marked as unsafe.
I’ve worked in a production project where we used warp. We really liked it for the most part, but the compiler errors does get a bit silly for a large number of routes. At one point I had to increase my scroll back buffer to see the start of an error message. :) We ended up splitting the routes up into related chunks and boxing those to alleviate the problem a bit.
I figured there'd be a 50% chance you'd find that interesting :) Yeah, last year's july eclipse was absolutely incredible though. This one tonight is the last "good" one for a few years :(
Oh yeah, glad you pointed that out. I'd definitely only buy this for the aesthetic. My more reasonable choice would be the Novation product line (Launchpad etc). They're just as capable and way more cost-effective than most other MIDI control surfaces on the market, from what I've seen.
It’s pretty much this; some tricks evolve into truly good internal changes. Others don’t, because they have caveats you wouldn’t want your users to deal with. They’re fine to boost your benchmarks a little though :p Not traversing the tree for static paths is something Gotham doesn’t do, but I’ve been working towards given the constraints of the current API. Do you have a separate mapping entirely for such paths that you check first?
Why do we need strong types? Because it's safer. It forces a more organized structure.
Totally agree! Yes, do when thruster starts it first makes a route tree, and then does a tree traversal to enumerate all of the possible paths. Then it adds any static path, i.e. non parameterized, into a hashmap that gets checked first on each request. I hope I explained that well!
This is pretty close to what I was considering, I’m happy to know it seems worthwhile. Thanks!
I only use the mobile app for Reddit.
The world makes sense! Thank you!
Any time :)
You must never have any UB, even in an unsafe block. One often-overlooked fact is that `unsafe` is meant specifically for writing code thah you *know* is safe, but that you have no way of proving to the compiler that it's safe. Kind of similar to how `unwrap` is sometimes okay to use even in a function that must never panic: if you *know* that you'll always have a `Some` or an `Ok`, then you already know that `unwrap` will never panic even if the *compiler* doesn't know that.
Sounds like someone is taking money from state actors to introduce vulnerabilities imo. Red flag to me.
&gt;Most of the time I don't need to write safe code. I think most people don't need to write safe code all the time. I don't think he ever had to fix a Heisenbug: [http://3.bp.blogspot.com/-f6o39qrUitQ/T8SBfb6CmFI/AAAAAAAAACc/ERb5rSCJaV8/s1600/heisenbug.png](http://3.bp.blogspot.com/-f6o39qrUitQ/T8SBfb6CmFI/AAAAAAAAACc/ERb5rSCJaV8/s1600/heisenbug.png)
I have never said anything about UB being okay. I just said if you have UB you at least want it to be inside an unsafe block because that is where you will be looking because safe code can *not* cause UB.
You have a fair bit of documentation on this point. Beyond that, I think you need better type-system support from the compiler so that it can in turn help users of `warp` more.
Gimme all your sulfur and maybe we wont raid you until next week \-REEEEEEEEEEEE
Thank you for pointing me to riker, looks really cool. That looks like a layer below what I want for my crate, perhaps I'll just write my macro to work on top of riker.
I'd love to have access to `#[on_unimplemented]` and similar things!
I've really enjoyed your progress, thank you so much for sharing the process! Congrats on the release.
Funny that the author says actix has too much dependencies while they like `tokio-postgres` which has 110 dependencies (with a clean debug build duration of 1 minute).
I'm gonna getch u with my ak if you come near my tower -Sweaty Roof camper
If you look at the docs, notice that there is no way to get at the representation without first using a lossy or result returning conversion function first. It is purposely conservative because of platform details such as null termination, or if \`u16\` is being used, etc. I could get what you are saying if you want the direct bytes without any lossy changes to them. There is a hidden \` OsStr::from\_bytes\` and \`as\_bytes\` though if you want that. I actually do not know what traits those methods are coming from. You can paste \`OsStr::as\_bytes\` in the search bar of the standard documentation, and it is there.
It definitely puts me off completely. Exactly: it's about maintenance, and also risk assessment. It's too much work to review, vendor, monitor for bugs and issues, and maintain many dependencies. Self-contained crates or ones with a few well-known dependencies are infinitely preferable.
added
Because you're the one bitching about the "problem" and the game is far more popular
No there's no need to do that plus you can't migrate a sub and have another take over because if someone from r/rust goes to r/rust after the change they'll just see rust game content and be like what the hell where is the rust language sub. It only works if a sub is moving to another and they put a link in the old one redirecting to the new one. &amp;#x200B; I don't think this is even an issue a member of this sub (not a mod) posted to r/playrust asking players to not post to r/rust so naturally it became a meme then someone crossposted it here as a joke. I doubt this sub gets that many people wrongly posting, rust was just on sale so influx of new players might have caused a few (not sure). It's really not that big of a deal.
I’m not complaining about the problem.
I'd love one!
It's open source. We could fork it? Give it a name that doesn't have connotations to actors. Accept community PRs. Anyone in?
You may want to use `#[cause]` instead of `reason`.
Probably still better than diesel in that regard
I just posted an RFC for an alternate strategy [here](https://github.com/tokio-rs/tokio/issues/1318) if you want to post your thoughts.
Does that still make sense if I use reason mainly for finer grained explanations? If so, do I basically declare an Error for every possibly error I create? Like an AttributeDoesNotExistError and then I put this into my AttributeLookupFailed error as cause?
Yes, it is my understanding that it does.
Thanks! I'll monitor that thread and see if I can chime in at some point.
That game will be dead long before Rust is. And then we’d regret not having r/rust.
What is the type of `m`? I am trying to separate the move closure from the `for_each.`, and that from `spawn`.
&gt; If you are asking about language-level, then no. This is called a dependent type Refinement types might be better match, and are afaik lesser hurdle than full dependent types. Although they are even more obscure than dependent types, so there is that.. LiquidHaskell maybe the most popular implementation?
I tire of this. Pure functions sound great, but what does 'pure' even mean? Can a pure function allocateon the heap? Because doing so changes global state. Can it mutate its arguments? Because that is mostly covered through the borrow checker: when something is passed by value it is impossible for the outside world to observe it, so you can do what you want with it. When you get something borrowed you can't mutate it (except for types that enable internal mutibility such as `Cell`). When someone passes a `mut` borrow they clearly *want* you to mutate stuff. LLVM internally discovers whether functions are pure when optimizing, so there isn't much of an argument there. So, for the final time: what do you hope that pure functions will give you in Rust? Do you have a code example where pure functions would make it better? What definition of 'pure' do you have in mind? "Because pure functions are obviously better" isn't an argument when you haven't even bothered stating what definition of 'pure' you're using. Here is a link to ye olde [INHTHWAMAHA](http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/) blog post that laid the groundwork for the removal of `pure`, if the background is interesting to you. Several of Niko's blog posts around that time may also be relevant. Also [thi(https://www.reddit.com/r/rust/comments/178t57/intimidation_factor_vs_target_audience/c83cavl/).
I've cross-posted it. [Link](https://www.reddit.com/r/CodingGames/comments/ce494n/robo_instructus_is_out_now_programming_puzzle/).
[You can in nightly](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=8100ca56b49673a1404b4ef9496d392a) :)
If you do not want to return a `MapErr&lt;AndThen&lt;AndThen&lt;Blah&lt;Blah&lt;Blah...` , then you want to do some kind of `collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;` or make the function return `impl ...`
On the other hand, sometimes security problems in Rust libraries require breaking changes to solve (e.g. there was some Rust stdlib method that took `&amp;self` when it should've taken `&amp;mut self`).
On [crates.io](https://crates.io) : Having - for each crate * A SLOC count * unsafe SLOC count * safe/unsafe SLOC ratio (%) * number of unsafe keywords ... would be very useful
Check Armin input on the matter: https://twitter.com/mitsuhiko/status/1151234488573128704?s=20
I’m in!
I miss the different landscapes, imo the game used to be a lot more interesting looking in the pics I'd see of the land, more mountains, ups and downs, interesting scenery.. Seems like nowdays its just mountains and valleys.
Wow, this is really neat! :D I had a similar idea right around the Leakpocalypse pre-1.0; was able to dig up this [writeup](http://ix.io/m6j) I had done on Nov 13, 2015 (as well as some discussion from [much later](https://web.archive.org/web/20181018155239/https://botbot.me/mozilla/rust-lang/2018-02-01/#96367306)) My design left cycle-breaking up to the types that would be GC'd, and would make the GC require that anything you put into it support cycle-breaking, but otherwise had a lot in common. At the time, my hope was that if we went with something like what you've implemented, we'd be able to guarantee destructors always ran, and rule out leakage. The final decision was to make leakage safe, though.
Wrong sub, go to r/playrust
I know how many times do you need to repeat and have mods removing threads about people asking for what server to play.. It's right on the rules, server advertisements are not allowed.. Like it even says too in the rules, there's a whole other sub for trying to find groups to play with.
Thanks for your interest! This gets asked often enough that I figured I'd better make a page on the website to answer it. Here you go! https://www.ruma.io/contributing/
I'm up for one.
I was thinking about ordering like 20-50. What are you planing to use?
It's a `Message` (right now just a `Vec&lt;u8&gt;` but in the "real" version it also has a `oneshot::Sender&lt;Result&lt;(), Error&gt;&gt;`, where `Error` is an enum defined in my library.
You certainly are (you meaning the subreddit )
Last time I posted something, it got covered up by the subreddit-picker's completion popup and it was easy to click the submit button without ever having that popup go away first.
I didn't think it was that big of a deal, in fact I am usually kind of amused whenever I see those posts. Eventually, Rust (the game) will lose popularity and the "problem" will solve itself. If the game outlives the programming language, then I will be truly distressed
why not rocket?
First, it's important to spell `Arc::clone(&amp;socket_ptr)`, although that wasn't an issue here. Anyways, if you put `let cloned_ptr = cloned_ptr;` inside the move closure (turning it into a block), you get a better error message: error[E0597]: `cloned_ptr` does not live long enough --&gt; src/lib.rs:32:39 | 32 | tokio::io::write_all(&amp;cloned_ptr.socket, m.buf) | ^^^^^^^^^^ borrowed value does not live long enough ... 35 | })); | - `cloned_ptr` dropped here while still borrowed
It doesn't compile on stable Rust.
I'm glad I was able to help you. I love Rust as well and Functional Programming
=)
There are places where you want to use `str` instead of `&amp;str` as a type parameter, e.g. `AsRef&lt;str&gt;`.
Thanks for your article, I enjoyed the read and share a lot of the sentiments. I think that perhaps something that wasn't directly addressed by your post was that we _desperately_ need to standardize around the `http` crate in a way where almost all frameworks can use its types with zero overhead and in an asynchronous fashion if desired. We need independent types outside of web framework crates that everybody can largely agree on. I know a lot of this has been blocked by stabilization of async, but regardless we need it. Honestly, I've also been super lost in the weeds in Actix's types and it's pretty much a wild west therein. I've written a little adapter system for a private Lambda function which converts between Lambda types and Actix request/response types to make routing requests much easier, and it's been really hard to actually get to the guts of Actix to convert between types. As you mentioned, the docs aren't on docs.rs and there are (really) important parts which are intentionally omitted from generated documentation that obscure underlying parts of the crates. I hope to see Actix move toward a more community-driven attitude; when an issue is filed, a bug reported, a feature suggested, there needs to be a discussion involving _maintainers_ not _the maintainer_. Actix is big enough now that it needs governance. I like Actix and I'll probably keep using it, the maintainer has put an ungodly amount of work into it, and I'm really appreciative of that. However, I honestly think that the next phase of Actix needs to be driven by a multi-maintainer approach.
Backing up a step, the core problem here is that `spawn` requires a `'static` `Future`, but `for_each` is creating a future with lifetime bounded by the future that `write_all` is creating, which is in turn bounded by the lifetime of the borrow of `cloned_ptr.socket`. One important thing to understand about `Rc`/`Arc` is that just because `Rc&lt;T&gt;: 'static` at a type level, it does not follow that borrowing the `T` out of the `Rc` gives you a `&amp;'static T`, not at all. Here you get a `&amp;'a PubSubSocket`/`&amp;'a TcpStream` where `'a` is the lifetime of the cloned `Arc` - not the lifetime of the type of the cloned `Arc` (i.e., `'static`)! I think that probably got confusing, so here's the thing: in order to make this work, you need to pass an *owned* `AsyncWrite` to `write_all`. There's probably a nicer way to do this but the only one which comes to mind, since I'm not immediately familiar with the trait, is to put a newtype wrapper around an `Arc&lt;PubSubSocket&gt;` which `impl AsyncWrite`.
Nope. It will still emit the corresponding CPU instruction. That is the very purpose of most CPU vendor intrinsics like this. Specifically, their purpose is to essentially permit very high level Assembly where each vendor intrinsic corresponds to a specific CPU instruction. The reason why the function doesn't get inlined (for AVX2 anyway) is because the enclosing function isn't marked as supporting AVX2, and therefore doesn't support the AVX function ABI (using `ymm` registers). The bottom line here is that calling intrinsics on CPUs without the necessary support for them is undefined behavior. Which is why the OP's code is technically wrong. The OP should either be `cfg`'ing use of those intrinsics using conditional compilation, or using dynamic CPU feature detection along with appropriate application of `#[target_feature]`.
Just download some scripts ez
That's interesting thoughts, but in some domains I guarantee that you can absolutely not update the compiler every 6 weeks, nor "gratuitously" recompile old software with a compiler newer than what was used at the time. Well, you probably "can" do it if you insist, but then you might have to retest way more things, and so over. Or maybe you will try to do it but your base OS will be too old, and you will actually not be able to update the compiler on this old OS. And no, you can't update the whole OS (oh well, same story :p ) That's the whole concept of maintaining old versions, and it is the worst when it actually applies to complete systems, even more so in regulated domains. You only update things in a very targeted way, unless you have shitload amount of money to be able to do it properly -- which nobody does because regulated is typically not high volume so you won't amortize enough of this effort. And *even* when you are high volume enough *and* unregulated, that's how current mainstream operating systems are maintained, for example. So I'm interested in the economical properties of things: if the ecosystem in practice relies on tons of libraries (kind of like node.js and npm), the risk of consuming that directly is too high for me in the current context. So *if* a distro does that for me yeah, I actually like that; that's why I will check at Debian policies for Rust matters and their list of packages -- maybe they are suitable for my use cases. Otherwise, I just have to wait for everything to mature enough :)
My own piece: https://rosettacode.org/mw/index.php?title=Y_combinator&amp;oldid=155643#Rust (https://gist.github.com/vi/5408426)
&gt; I think that probably got confusing, so here's the thing: in order to make this work, you need to pass an owned AsyncWrite to write_all. Interesting. I'm home for the day, but I'll try that out when I get back to work tomorrow. That kinda explains why the returned future contains the socket itself. Is the basic idea to using Tokio that you're expected to thread owned socket objects through futures? I guess that's one way to ensure that it's only used in one place at a time. Of course using an Arc might be easier anyways, for convenience. I think I'm going to try splitting the TcpStream into read and write halves to make this easier. I haven't even started implementing the receive code for this project but I suspect having separate ownership will make it easier to follow. Thanks for your help (and /u/dreamer-engineer for helping me as well)!
I am so wildly confused by this post..
As the kind-of-inventor of the memefication of RESF (in response to a negative meme building around [n-gate.com](https://n-gate.com), who invented the term) for April 1st 2017, I'm not happy with it spreading more. It's been a fun round and effectively took steam out of that negative drift, but I don't think it's in any way useful to further spread. No one likes a zaelot and I would not like an effective action of reclamation to turn into the thing that was criticised. That's also the reason why I for example shut down the Twitter @rustevangelism account and am not giving out the password. Still, I won't keep you, I also didn't create the picture.
Hot take: My guess is that his feelings got hurt last time people called out his coding practices and usage of unsafe and he's tired of hearing about it and takes it personally and closed the PR as a way of flexing his power over the community but he's only isolating himself further from the community in the process. Would make sense to me but I hope he's able to see the bigger picture and realize people are just here to create cool stuff and we should all get along for the sake of technical achievement.
I don't see anybody complaining here except you and OP who are both playrust subscribers.
The language doesn't support this, but if there were a way to erase the &lt;*a&gt; and turn it back into &lt;*&gt; (to be reassigned a closure at the new call site) whenever a type leaves scope I think this would work.
This is called type generativity. Rust already supports generative types: `for&lt;'a&gt;`. This is discussed elsewhere in this thread.
What
Seeing what you want to see to save yourself is pretty lame
Yeah, lifetimes sound like a natural way to do this since the types need to be scope aware (to fix the problem with loops). Thanks!
Wow, just wow. I have no words. Open source and community is not very pleasant place to be.
The game will outlast the language. New tech will come out but this game will be here in 10 years time easily. Also this is reddit, I don't trust people on stackoverflow, you trust people here?!
*Nice.*
Games been out like 5 years, and it just hit its concurrent user peak last month. This game will outlast the language easily.
From this response, I really don't know enough about enterprise and regulated use cases to say one way or another. I don't know the gotchas or the regulations, even if my gut tells me that it's probably possible. (Especially that, even with backporting or even bug fixes, you still need to recompile your program anyway, so I don't really understand the issue.) &gt;Well, you probably "can" do it if you insist, but then you might have to retest way more things, and so over. Not entirely sure how updating the compiler would cause this to be the case. I know in Python, the company where I work runs the test on all the versions they support, but Rust has pretty strong stability guarantees. &gt;Or maybe you will try to do it but your base OS will be too old, and you will actually not be able to update the compiler on this old OS. My only guess would be if libc relied on some system calls that got changed or something, and something somewhere breaks in this pipeline. But even here, I'm pretty sure it's not that crazy difficult to recompile rustc. Unlike other binaries, rustup binaries seem to be remarkably independent of whatever they were initially compiled on (this is probably the LLVM influence). Also, for Linux at least, rust supports musl instead of glibc, so your compiled binaries would only rely on whatever Linux version musl relies upon. Again, I'm unsure of your precise needs and the related gotchas, nor am I knowledgeable enough to guess. &gt;So I'm interested in the economical properties of things: if the ecosystem in practice relies on tons of libraries (kind of like node.js and npm), the risk of consuming that directly is too high for me in the current context. NPM can be pretty garbage, yeah. I'm not sure how Python, for example, works in whatever space you're working in, but I'd assume the standard library would be fine and nothing else. Or C++ and Boost, and so on. Rust explicitly has a small standard library so that the main Rust developers can work on the other libraries more flexibly, even once they're stable. In a way, some libraries are explicitly outside the standard library, yet are also apart of it. This also allows better alternatives to rise up. In fact, in the newest version of Rust, they've replaced the Hashmaps in the standard library with one that is downloaded from crates.io, but it just has the same interface as the old version, keeping everything stable. In a sense, you'd be using stuff from crates.io already, even if it's kinda bundled in already with the standard library. Bureaucracy might make this impossible, but you actually are going to want to grab at least some things from crates.io that are basically std library stuff, like regex or chrono. In other languages, it might be fine to grab one thing, but Rust really wanted to encapsulate everything and make it a community effort. **You just need to do the work to make sure you're not pulling in a bad library and can trust its author(s).** If it's a matter downloading things directly from the internet without supervision, there are tools for that too (even if there isn't support for Rust in tools like Artifactory, though Cargo offers some of that stuff). &gt;So *if* a distro does that for me yeah, I actually like that; that's why I will check at Debian policies for Rust matters and their list of packages -- maybe they are suitable for my use cases. Otherwise, I just have to wait for everything to mature enough :) Besides Debian, also check out the Rust policy for things, too. Check out a bunch of stuff of what's going on in this community, and if your definition of mature matches what's going on here today. Mature can mean many things, and I'm not entirely sure if we share that definition. That's why you really should go and figure this out properly. If you don't look deep enough, you might not realize you *can actually* use Rust. And it would be a huge shame if you couldn't. Imagine all the messy, buggy C++ code you and your coworkers might generate over the next few years, filled with memory and multithreading errors. Imagine how much effort you might have to go through just dealing with the mess of a language that's C++. Rust is like C++, but without all the bad parts. I'm just not sure if it matches your definition of mature, *and neither of us know*. So you gotta figure it out man. And if it's not ready for you, it might be ready 6 months from now. Or maybe how Rust's decentralized libraries doesn't fit with your organization's regulations, and you'd either have to do everything yourself in Rust or in C++. But everything's unsafe code in C++. So I beg of you, do a bunch of research. You might save yourself one heck of a headache, and Rust really might be more mature and suitable than what you think it is. (And if not, maybe try using it for something small, and do a trial run, or something.) Debian and Firefox, huge important projects, rely on Rust and believe it's stable enough to use it. Chances are, wherever you work, your place does too. tl;dr: Research Rust maturation and stability, and whether its policies and methodology works with your bureaucracy. It probably does, at least in enough ways for something, and it would really suck if you missed out on being able to use Rust. (Sorry if this got a little bit too passionate. I'm just worried for you. I might be a bit too much into Rust, because all other languages, on some level, are painful in some way or another in comparison to Rust. Rust just helps so much. ¯\\\_(ツ)\_/¯)
This should have been fixed several weeks ago, do you still experience this problem? Would you be able to share OS?
``` C:\gamedev\star_factory\rs\sg\sg_simulation&gt;rustup show Default host: x86_64-pc-windows-msvc installed toolchains -------------------- stable-i686-pc-windows-gnu stable-x86_64-pc-windows-gnu stable-x86_64-pc-windows-msvc nightly-i686-pc-windows-gnu (default) nightly-i686-pc-windows-msvc nightly-x86_64-pc-windows-gnu nightly-x86_64-pc-windows-msvc active toolchain ---------------- nightly-i686-pc-windows-gnu (default) rustc 1.38.0-nightly (4bb6b4a5e 2019-07-11) ``` ``` C:\gamedev\star_factory\rs\sg\sg_simulation&gt;cargo test --target nightly-x86_64-pc-windows-msvc error: failed to run `rustc` to learn about target-specific information Caused by: process didn't exit successfully: `rustc - --crate-name ___ --print=file-names --target nightly-x86_64-pc-windows-msvc --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro` (exit code: 1) --- stderr error: Error loading target specification: Could not find specification for target "nightly-x86_64-pc-windows-msvc" | = help: Use `--print target-list` for a list of built-in targets C:\gamedev\star_factory\rs\sg\sg_simulation&gt;cargo test --target x86_64-pc-windows-msvc Compiling nodrop v0.1.13 Compiling rand_core v0.4.0 Compiling cfg-if v0.1.9 Compiling lazy_static v1.3.0 Compiling stable_deref_trait v1.1.1 Compiling scopeguard v0.3.3 Compiling memoffset v0.2.1 Compiling smallvec v0.6.10 Compiling crossbeam-utils v0.5.0 Compiling either v1.5.2 Compiling atom v0.3.5 Compiling mopa v0.2.2 error[E0463]: can't find crate for `core` = note: the `x86_64-pc-windows-msvc` target may not be installed error[E0463]: can't find crate for `std` error[E0463]: can't find crate for `std` | | = note: the `x86_64-pc-windows-msvc` target may not be installed &lt; I cut out a lot of repeated error messages here &gt; To learn more, run the command again with --verbose. ```
The `?` operator: learn it; love it. if let Ok(_) = cookie_client .get("https://www.saltybet.com/authenticate?signin=1") .send() { log::debug!("Created Client"); Ok(Client { client: cookie_client, }) } else { log::debug!("Failed to get response"); Err(SaltyBetError::ApiAccessError { reason: "Failed to get response".into(), }) } can be simplified to: let cookie_client = cookie_client .get("https://www.saltybet.com/authenticate?signin=1") .send() .map_err(|_error| { log::debug!("Failed to get response"); SaltyBetError::ApiAccessError { reason: "Failed to get response".into(), } })?; log::debug!("Created Client"); Ok(Client { client: cookie_client, }) If `From` is properly for your error type, You would even be able to cut out the error constructor and leave it as: .map_err(|error| { log::debug!("Failed to get response"); error })?; because `?` Will automatically convert the error type its given into the error type your function returns. If this is an executable rather than a library, `failure`'s documentation recommends returning its error type, at which point you can use `ResultExt::with_context()` to add your custom `SaltyBetError` data without destroying any information that the higher up function returned.
This exists on nightly: https://github.com/rust-lang/rust/issues/41263
OP probably meant to post in r/playrust
Everybody can get frustrated at software and development, most developers are. I feel this thing, the agitated language of the original post, the upvotes, and many comments are too much to be good. * Looking at the techempower benchmarks (game?), I think many of the entries try to make its framework run as fast as possible within boundaries of test. Calling it out as "cheating" as a means to paint a character picture is not friendly, and not fair. This is how techempower benchmark is played. * Documentation. For a project in large part driven by one man (coding and documentation), I think the documentation is pretty good and have been glad to find a lot of code documented with examples and helpful explanations. There are enough areas to work on, enough to burn a man out, I'm thankful for the amount of documentation. * Number of crates I think is a product of a framework becoming mature, I think the most mature of all in Rust. I'm sure there is a reason for all of them, I wouldn't suspect the author to include them for fun, and the feature-set of actix is not extravagant.
Ah, okay, That makes sense. I thought I was having a stroke.
&gt;Funny part, I remember OP question about async state initialization and specifically for him spend my time and added App::data_factory. I guess that is usual. FWIW I *did* mention in the article that you added it afterwards. I really am not trying to be insulting, and I truly apologise for the way it's come across. However I firmly believe that many of the things I mentioned in the article are real and valid concerns which need to be addressed.
This issue isn't only about logic and risk. This is about people who don't contribute imposing great demands on someone, who is working as hard as he can, to go above and beyond to appease them, with minimal benefit to the system and at his personal cost. This is someone getting something incredibly valuable, for free, and demanding more. This is a modern day Ayn Rand novel.
Variables are only a piece of the puzzle when it comes to pure functions. What about IO? &gt;what do you hope that pure functions will give you in Rust? Purity. (For a more serious answer, look at my previous reply)
I've found [grr](https://docs.rs/grr/0.6.0/grr/) to be a lovely wrapper for using modern OpenGL
Looks like it's going to be a full series of multiple blogposts about Rust. &gt; We are a response organization, but we also have a proactive role, and in a new blog series we will highlight Microsoft’s exploration of safer system programming languages, starting with Rust. Please do join us on our journey.
&gt; This is about people who don't contribute imposing great demands on someone, who is working as hard as he can, to go above and beyond to appease them, with minimal benefit to the system and at his personal cost. This doesn't seem like a fair characterization when people are submitting pull requests.
&gt; If so, do I basically declare an Error for every possibly error I create? I would split `AttributeLookupFailed` into at least variants that are recoverable and those are not. `AttributeDoesNotExist` is very much a recoverable error, while `AttributeLookupFailed` because some API returned malformed data is not really. Somebody using your API might want to handle those recoverable errors and thus it helps if they can easily match them. Now, the fact that attribute lookup has failed *because* you could not parse u32 or that login failed *because* credentials were wrong is exactly how you should reason about using `#[cause]`. If there is a "because" in your explanation and especially if this "because" occurs due to some external factor, it is a `#[cause]`. My favourite short example of this is configuration loading: #[derive(Fail)] enum Error { #[fail(display="Could not find configuration location")] ConfigLost(#[cause] std::env::VarError), // *because* could not read an environment variable #[fail(display="Could not read configuration at {:?}", _1)] ConfigUnreadable(#[cause] std::io::Error, PathBuf), // *because* I/O failed #[fail(display="Configuration file {:?} is malformed", _1)] ConfigMalformed(#[cause] SomeParserError, PathBuf), // *because* we could not parse it // ... Other errors } fn load_configuration() -&gt; Result&lt;Configuration, Error&gt; { let config_location = std::env::var("CONFIG").map_err(ConfigLost)?; let file = open_file(config_location).map_err(|e| ConfigUnreadable(e, config_location))?; parse_config(file).map_err(|e| ConfigMalformed(e, config_location)) } Which allows then to show super helpful and contextual error messages like these: &gt; error: Could not read configuration at "/etc/foo/bar.cfg" &gt; caused by: Some I/O error or &gt; error: Configuration file "/etc/foo/bar.cfg" is malformed &gt; caused by: failed to parse some format &gt; caused by: expected semicolon at line 42 by using `failure`’s error trace mechanism.
They did put in effort. They open a PR, which he dismissed without cause.
Is there any reason to not have everything from 'core' repo installed?
Last I recall it could not handle importing my ply files. I think it was less than 1GB and needed more than my 32GB ram, so their importer or something has some issue. However, blender probably isn't the right tool for this. Similar tools like Maya also suffer to handle the density. Eg full file may be 140GB binary ply. With a great baking program like mightybake, even 10GB of this data requires 60-80GB of ram to bake. My last job at a vfx company(not exactly games but real-time experiences in VR), the workstation had 128GB of RAM for this and I wrote a program in rust to parse the file efficiently and export multiple chunks at a smaller size to work within the limit. There are still other improvements that could be done and I'd like to one day write my own baker app using rust. I guess I could look at blenders open-source code to see how they perform baking and try port/optimize it.
Try /r/RusttheGame
I agree. I deleted my comment but not quickly enough.
Correct. Retracted
[That](https://msrc-blog.microsoft.com/wp-content/uploads/2019/07/graph-1024x398.png) graph is probably the most compelling reason I've seen so far to try rust
Definitely!!!
This is easily one of the most pointless bots I've ever seen on this site.
It is a rustc-internal feature that exists solely for use in the compiler. I would not recommend relying on it.
I think you're looking for /r/rustjerk
Last I heard they are working on targeting stable
Interestingly, we were discussing this a couple of days ago for Gotham; whether to bake in certain (official) middleware behind flags, rather than ship them as separate crates. Definitely interested in the outcome of this RFC, as it will give us a good idea of what the larger community prefers!
So there's two layers here: what target the compiler was built with and what target you're compiling for. Every rustc is a cross compiler, so you can use a nightly-x86_64-pc-windows-msvc to compile to e.g. arm-linux-gnueabihf. To do so you need a few other files which can be installed with `rustup target add {target}`, which installs the target for the default toolchain. The `--target` argument is used for cross compiling. So `cargo test --target x86_64-pc-windows-msvc` will use your configured toolchain plus the target files to cross compile for that target. There's also a special argument `+{toolchain-desc}` which can be used to select the toolchain without having to use rustup override or rustup default. e.g. `cargo +nightly test` or `cargo +nightly-x86_64-pc-windows-msvc`. What's happening is that the `cargo` and `rustc` and other binaries in your PATH are actually shims which call rustup, which selects the toolchain based on the configuration, or by using the `+override` argument.
Would this increase compile times?
Sorry for the ambiguous phrasing; it was the reverse case. I was trying to pass a string literal, and it told me that it expected &amp;str but found str. Putting an ampersand seemed to solve the error. I'm a little baffled that adding a sign was necessary in the first place. I'm basically ignorant about the design of the language, so I'd give the designers the benefit of the doubt; I suppose there's some reasoning behind requiring a &amp;?
It's over ... stop posting playrust memes here.
Huh. I wasn't aware of all of these implications, I was just thinking "this is a fun sticker to have on a laptop that indicates I like Rust and want to cheerfully spread awareness of Rust wherever I show my laptop." Maybe in its original form RESF was meant to (if I'm understanding this correctly) gently nudge people who showed up to evangelize Rust in a forced fashion into maybe toning it down a little (is that correct?) but in the picture form it's a bit more self-deprecatory. There's a chance I don't want to bring bad blood like this in the real world. I still might think it's just a harmless sticker. I'll think about it, thanks for bringing this to my attention.
It sounds like the maintainer's response here is that the potential UB is only in private APIs. Is there a way to produce UB with the safe public API?
Thanks for the reply! Unsized types are those types that can't be stored on the stack, right—and that's why they have to be referred to by pointer?
&gt; This is "option #3" in Herb Sutter's talk. Actually, I don't believe this is correct, though the syntax looks like the syntax in his #3. This Rust code moves the `String`, so I think it's actually his "option #2".
I don't know about the ones in the PR. The unsafe I linked to originally *can* cause memory unsafety innocently by a user.
Thank you for your excellent work on Actix Web, fafhrd91!
Option #3 in Herb Sutter's talk calls \`std::move(name)\`
Yep! In order to store something on the stack, you need to know what size it is. ... at least, in current rust. There have been some RFCs for it. We’ll see.
Also coming from Scala – this wouldn't be a good idea, as retrieving only a specific key after the `groupBy` should not force the allocation to hold the other keys' values – a simple iterator would be sufficient in this case. This is one of the many issues with Scala's collection views: having random operations thrown in that force the computation of the view prematurely. `sorted` and friends is another pathological case in that regard.
You misspelled the user name "[https://github.com/aaron101](Aaron101)". It's actually [https://github.com/Aaron1011](Aaron1011).
Good catch, thanks! fixed now
Wow. This is exactly the sort of information I was hoping to get. Thank-you so much. Could you please tell me more about "rust-toolchain" - does this work, where does it go? I have a cargo workspace with projects. Can I set different default targets for different projects? :D
It is certainly the standard we hold for contributions to the standard library and I would say among the more seasoned rust users also. Fundamentally, when using unsafe blocks you are telling the compiler that you have manually verified the safety of your implementation. Since humans are forgetful and because someone else might need to work with the code you wrote, it is imperative that these manual proofs exist in comments and whatnot. It is also right that every use of unsafe blocks increase the trusted computing base and from a security point of view that should be kept minimal. So it makes sense that uses of unsafe for perf should be justified with some numbers. Finally, I would note that UB is a security concern in all cases because UB means that your whole program has no defined semantics and so it is not predictable especially over time.
Okay, watching that part again, I guess you could say it's like option #3, but I guess really the semantics don't match perfectly between C++ and Rust here. It's like option #3, except it won't implicitly perform a copy. To get it to copy, the caller would explicitly have to use a call like `employee.set_name(name.clone())` instead of `employ.set_name(name)`.
I was just skimming the GitHub thread, but it's possible that that wasn't clear to the author? Maybe someone could post a complete example triggering the UB?
The two are in different repos.
 Yeah it probably would.
&gt; To be clear, triggering undefined behavior, even in unsafe code, is never okay. Forgive my nitpicking, can you have undefined behaviour in safe code. I always thought UB only existed in unsafe code.
This is great thanks! I have wondered how to do some of these in past projects but couldn't figure out how or if it were possible :)
Why? You're going to compile the same amount of tokio code.
I can understand you feeling this way. You’ve put a *ton* of work into this project, and have achieved some great success with it. However, it seems that in open-source, success also comes with much higher expectations. Which is as it should be, but can be difficult if your personal sensibilities and the community’s general sensibilities differ. What I think might be useful is for you to take some time and document places where the values of the actix-web project might differ from the values of the Rust community in general. This might include differences in values around UB from safe code, project governance, etc. This will help people get clarity around expectations, and I think will help everyone involved.
With feature flags there might be a risk that you don't include the ones you need, because your dependencies happen to include them. Leading to possible breakage down the road when your dependencies update? Maybe that's not a big problem if it's easy enough to fix, though. (More of a problem for newer coders who might not understand why they're getting errors?)
Maybe they're the only ones that are found 🤔
Depending on the crate graph, it's possible it might actually reduce compile times, by opening up more parallelism. This gap might be reduced in the future through [pipelined compilation](https://github.com/rust-lang/rust/issues/60988) but today any inter-crate dependency chains artificially serialize the compilation process.
"not memory safety"
I’m on Windows. The frame rate is fine, it’s the input lag that is at issue. As of 6 days ago, I still experienced it. I already posted an issue on their repo, so it should get looked at eventually. Unless you know of a fix that was pushed in the last week?
Isn't that more of an issue of you taking the burden of those maintenance tasks that could be better handled as a community and verified by some tooling? [Renovate](https://renovatebot.com/) for example(available as open-source and you can self-host, or use their service for free on certain git platforms for open-source projects), automates a fair amount of this with configuration support. In that regard, smaller crates may be easier to review by the community, rather than crates that contain much larger / frequent updates. I'd rather common logic that can be shared across crates extracted to a common crate dependency vs the self-contained approach of crates doing their own implementation/maintenance to reduce dependencies..
You're not _supposed_ to be able to, and it's a bug if you can, but it has definitely happened in the past. I'm on my phone at the moment, but looking through the Rust issue tracker for things labeled unsound should give some examples.
Ha.. he’s lost.
`cargo` is able to compile crates in parallel. This would reduce compilation parallelism. That said, I believe that rustc is working on improving that story.
This is true... you probably want to jump in on the github issue though.
Whoa is this a rust-Elm.. binding? This could be amazing.
If there is no HTTP method usage, how can i use it? Am i missing something? And also i am a noob and i tried to use actix. It was hard but i can tell that Nikolay always gives answer to me, even my questions were silly. Yes, cold but its okey. No one have to be friendly or socialy. Maybe its his character. I am just looking his work. Is it works? Yes. Is it good? Yes. Is it open source? Yes. Thats it. If there is unsafe in rust, its okey to use it. If its so bad, rust developer should remove it.
&gt;If there is no HTTP method usage, how can i use it? Am i missing something? it ignores the method in the techempower benchmarks, that's why they're unrealistic &gt;If there is unsafe in rust, its okey to use it. If its so bad, rust developer should remove it. you should only use it where necessary, and many of these uses in actix are pointless (don't even have any performance gains).
I have had some heavy weekends getting my feet wet with Rust and I can see the potential.. but as someone who has been building APIs in Elixir full time for a few years, I am addicted to the genservers/actor model, and simple concurrency options available in Elixir/Erlang. Is this something that Rust would be a good fit for or would I have to learn an entirely new paradigm or approach to solving problems. Sry for the noob questions, but I think you offered :-)
Some of these improvements are pretty big (which is great!), but we should be excited for all the 1% and 2% improvements, too! They will all add up in the end to something important. Thanks for all the hard work on this!
Types are a kind of abstraction, so it's really easy for explanations of them to get away from the concrete reality. A value of type `str` is zero or more bytes, and those bytes must be well-formed UTF-8. Because it's possible for different values to have different sizes, we call `str` an "unsized type." Pointers to data must define both the address and size of the location which they point to. So pointers to unsized types have two internal fields: a starting address and a size\*. Pointers to sized types only need one field because, for example, \`&amp;mut u64\` must point to exactly 8 bytes, no more nor less. \*(This is a simplification. There are also dynamic-dispatch pointers, but I'll set that topic aside for now. 2018-edition code in good style will describe those pointers using the `dyn` keyword.) Unsized types are perfectly valid types. But it's currently not possible to store them in local variables. This also means that they can't be passed into or out of functions. And because operators are just a special case of functions, you can't even `+` them. `str` and `[u8]` get a little bit of help from the compiler. You can write literals of those types, or include data into the executable with \`include\_str!\` and \`include\_bytes!\`. But since the language doesn't allow naked `str` or `[u8]` values to be returned by any operation, the compiler links the bytes into the executable's read-only data segment and substitutes a `&amp;'static` reference to those bytes. String literals in C use the same trick. &amp;#x200B; So `&amp;str` is a kind of pointer to `str`. It means that the bytes starting at address *x* and continuing for *y* bytes may contain UTF-8 text - that because it's a pointer. Because it's a reference type, and not just a raw pointer, "may contain" is strengthened to "must contain." And this is a sharable reference type - there may be other references elsewhere in the program to the same memory at the same time. The default way that Rust handles shared references is to prohibit anyone from writing to memory during that time. There are ways to allow communication through shared memory, but the compiler needs to know if that's your intention because it changes what kind of optimizations are possible and can even change what machine language instructions are required, if communication between threads is possible. Since `str` is a plain data type, those special cases don't apply. It's not possible to modify the target memory location while the reference exists - and if you do it anyway, the machine code which reads that location might do something strange and unexpected (in fact, it's allowed to do literally anything). &amp;#x200B; Again the details are out of scope, but this mostly happens because the compiler is allowed to rearrange memory operations. For example, it can choose to read memory once before a loop and then re-use that value within the loop. That's faster, but it's only correct if the memory does not change while the loop is running. Sharable, read-only references allow the compiler to *assume* that memory will not change. And Rust's type system then enforces that rule on your safe code.
When they do then it will be advisable. Certain things they used won't be stable for very long time if ever.
The blog post that was recently linked here isn't just blind mob mentality, it shows examples of the concerning behaviour that the actix maintainers have towards unsafe. Personally, I would prefer a web framework in which PRs like that shown aren't dismissed as "we might as well switch to an interpreted language to avoid ub".
They are going to copy it as R#
The rustup exe searches paths up from the working directory and uses the first rust-toolchain file it finds. So yeah, you can do that. Your idea might always have the project root as the working directory, though.
&gt; profiling with OProfile. I admit I haven’t used it enough yet to gain any wins. It seg faults about half the time when I run it, which isn’t encouraging. I always thought that `oprofile` was mostly obsoleted by `perf` when it was introduced. EDIT: oh nm missed that - "... but I find its output a lot easier to read."
&gt; maybe `crates.io` needs a ranking and commenting system Umm, yes. Please? I've got close to 50 students right now getting started on their individual and small-group Rust projects. Some of them are web projects, some are games, some are definitely "other". All of these students are new to Rust and want to know which crates they should use. What's easy? What's trustworthy? As things stand right now, this is a research project. For web stuff, I've already had one student encounter Rocket nightly fail and need my help to dig out of it. I've suggested not Actix-web, but mainly because I think it's too hard for newly-minted Rust programmers to figure out how to use it. *I* don't know what crate a student should use for their first Rust web project. I've pointed the students at "are we web yet", mentioned some frameworks that look good to me (although I've only tried Rocket and Actix-web for the most part), and left them to figure it out. It's…not good. Same thing for game frameworks, same thing for database stuff ("you should probably use Diesel"). The problem with a ranking / commenting system is that it's going to take some curation to be successful. All the learned toxic behaviors of the Interwebs will be there to some degree. We should only do it if we're committed to doing it right. So far I haven't heard anyone willing to step up and lead that. Software is hard. Communities are hard. Ecosystems are hard. Software community ecosystems…
Can't wait until this shit game dies
Seriously, copy and paste it ten times and I guarantee people will see it more often.
I wish people would build out from the tower-* crates. They're obviously very fresh right now but they're nice and canonical and pretty inside. Can imagine some great and compostable web frameworks growing from them.
That might be true, but I think the thread derailed into something unproductive. Now the Actix maintainer has lost motivation of dealing with the community and open source, instead of feeling motivated to potentially correct some errors. Even if you believe that something he did was wrong, which might be demonstrably true (I don't know), you still have to consider if it was worth shaming him publicly for it like this. What was the goal with it, and did it achieve it? Is the Rust ecosystem and community better because of it? I personally think the problem could have been raised in better ways. I can understand him being very disheartened by it.
I am aware that it isn't close to being stabilized for general usage, but its API has been more stable than most nightly features and it is quite useful (which is why std uses it liberally). It has some clear limitations which is why we haven't pushed for stabilizing outside of the compiler. I would say that if you're working in a library that is nightly only (or that feature flags nightly features and checks for the current compiler in a `build.rs` to auto enable them), rustc_on_unimplemented is a tool to keep in your toolbox.
Would be cool if Microsoft would start to actively and openly start to support actix-web. If I remember this correct they are using it to some extent (azure iot?) and the main author is employed by Microsoft. So if they really want to explore this field (not only rust) they could start by making actix-web the Microsoft poster child of secure and safe systems programming. I think this couldn't hurt the project and I think it's sponsored (behind the doors) by Microsoft anyway. How else could the main author produce this amount of code with only free time? Would be cool from Microsoft to announce such a project as playground to explore this field and have a fast web framework without unsafe usage and no UB.
When you for example put `&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;` in your HTML file and serve it from `/`, your browser will create a request for `/mystyle.css` after loading the HTML. All you should have to do add a route for `/mystyle.css` which returns the CSS and you should be good to go.
while iterating over array-like structure I see sometimes people use \`.iter()\` and sometimes \`.iter().enumerate()\` what is the difference between both
How does glam compare to alternative crates like faster?
Maybe there was a better way to deal with it, but the dismissiveness that was shown to a perf-neutral PR whose only goal was to patch unsoundness holes caused by overuse of unsafe throughout the codebase concerns me. Especially since this is not the first time that actix has been discussed in the context of avoidable unsoundness caused by the author's use of unsafe where safe rust will work just as well.
Wow, amazing work! Can anyone tell me how compilation times have changed in the past 2,5 years? I haven’t been using Rust lately.
While this first post is very positive about memory-safe system programming languages in general and Rust in particular, I would not call this an endorsement. Still, great news!
He does. https://github.com/actix/actix-net/blob/master/actix-service/src/lib.rs is pretty similar to what `tower` [has](https://github.com/tower-rs/tower/blob/master/tower-service/src/lib.rs#L177).
i tested flamegraph output on perf results a short while ago - really easy to read [https://github.com/brendangregg/FlameGraph](https://github.com/brendangregg/FlameGraph) Small Linux/Perf Tutorial: [http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html](http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html) used this: &gt;\# git clone [https://github.com/brendangregg/FlameGraph](https://github.com/brendangregg/FlameGraph) &gt; &gt;\# or download it from github &gt; &gt;\# cd FlameGraph &gt; &gt;\# perf record -F 99 -a -g -- sleep 60 &gt; &gt;\# perf script | ./stackcollapse-perf.pl &gt; out.perf-folded &gt; &gt;\# ./flamegraph.pl out.perf-folded &gt; perf-kernel.svg
Then they'll slowly deprecate R# over the course of 15 years while they push the new and improved R# .NET CORE
There shouldn't be a reallocation after clearing.
The impression I got is that the proliferation of frameworks is because we're still iterating on what makes for the best API design in this space, given the limitations imposed by the borrow checker and the opportunities for compile-time correctness enforcement enabled by Rust's type system.
`.enumerate()` wraps an iterator so that `.next()` returns both the 0-based index and next item. It functions a lot like `(0..).zip(iter)` (although the actual machinery is slightly different).
Please also learn that: * Slapping a 1.0 version on the crate should mean some commitments in the Rust ecosystem, including that your dependencies are also stable and matured out of 0.x versioning; * Unsoundness is a serious thing. When your crate clients are chasing elusive bugs in production caused by a particular version of the compiler optimizing away UB in a surprising way, the quality of that code shows itself for real.
I was reading about an article [on github](https://github.com/JasonShin/functional-programming-jargon.rs#closure) the code says: \`\`\` let add\_to = |x: i32| move |y: i32| x + y; \`\`\` What is \`move\` operator here? where can I read more about it? when I search for it all I am getting links to ownership etc
understood, thanks :D
We have memory mapped IO, so any assignment to a non-stack variable can potentially perform IO. So pure functions cannot mutate their arguments in any way when `&amp;mut` or interior mutability behind a `&amp;` is involved. Seems overly restrictive to me. And then there are traits, will `pure` be part of trait definitions, so that only pure implementations may exist? Will emitting debug messages be allowed ("printf-debugging")? If so, then there must be a mechanism to bypass purity (through `unsafe`?), if not then purity will be a pain to work with. I love me some purity in Haskell, yet remain unconvinced that it would help Rust. So far you have done absolutely nothing to convince me otherwise, nor have you tried. I don't feel like this discussion is getting anywhere, so good day to you.
The problem with judging based on the majority is that it's partly what is responsible for C and C++ being considered "good enough" for so many security-critical components of consumer development for so long. I do aim to be civil, but I'd readily endorse a Rust framework with Python-like performance if it could guarantee that it was strictly equal to or better than Django in every way related to security. To me, it's not worth it to play security Russian Roulette with network-exposed code... especially when history tends to shrink the "un-exploitable examples of X" category (eg. the idea of a safe data race has more or less been disproven) and maintainership tends to struggle to keep up with the demand for it *without* sudden vulnerability discoveries.
That'd be amazing, .net ecosystem interop sounds sweet.
There is also kay. The actor framework for citybound. https://github.com/aeplay/kay It’s still experimental and uses a build script and code generation instead of procedural macros, but it might still be worth looking into.
It reallocates if the new data doesn't fit in the current string's allocated capacity.
I haven't benchmarked it or anything, but I didn't notice any improvements so far.
https://perf.rust-lang.org/
Have you looked at xsv... It sorta does that (maybe not to the extent that you need though)
I feel like you're being pedantic here. A pure function is not a difficult concept to understand. "A pure function is a function where the return value is only determined by its input values, without observable side effects." The benefits are, like I said, safer code, better integrity, and also referential transparency.
Thanks a lot, I was writing my own wrapper and this will save me a ton of time ! Still a Rust beginner and progress is really slow when you don't have time...
for UB to happen here, both .get() and .get\_mut() should be called in the same scope (i.e. nested because Cell is !Send). Cell itself is an internal component and - while I personally would rather have it declared \`unsafe\` with a big doc comment saying why it is unsafe and how to handle it safely - it doesn't seem to be the case in actix-service's code right now. Could you please elaborate on *how* that might happen?
Why do you think Amethyst doesn’t need one? Personally, when I’ve worked with pygame and Unity, I’ve sought out starter project tutorials and learned the basic game engine syntax from them, so I thought this could be somewhat useful.
I would love to have one. Thanks.
&gt;Maybe in its original form RESF was meant to (if I'm understanding this correctly) gently nudge people who showed up to evangelize Rust in a forced fashion into maybe toning it down a little (is that correct?) but in the picture form it's a bit more self-deprecatory. Nah, N-Gate just used it as a cheap shot against a project that has good and active marketing and evangelism building. We already actively work against zealotry. His framing of the RESF wasn't necessary malicious, but definitely not kind. It started to catch on, because 2017 also was a time where n-gate kinda became famous and we were covered in one of his FOSDEM posts quite elaborately.\[1\] So, we experimented with shifting the message by adopting it (which is also a marketing and message control move, to be clear). We're ambiguous about whether that was a good or bad move. Yes, it's a harmless sticker and printing 5 or 6 doesn't matter. Fuelling the meme again is a different kind of story and a line easy to miss. In any case, I don't want to keep you from anything, just make you aware of the context to allow you to... "jerk constructively"? ;) \[1\]: For those interested: I find n-gate an example of how programmer "rant" humor is often terrible, predictable and schematic. I have to say though that the author is generally fair with criticism and e.g. actively holds his crowds back from dog-piling on others.
Support and thanks from me, as a 6 months user of your work. Really appreciate it and I found it very inspiring to learn from actix/web, including unsafe parts. Something should be screwed about this open source community if the author of the huge work we can all use for free is taken as a robot and a function of some "must". I also didn't notice any "thank you for your work" in this PR, is not it a good style to thank the author in first place when pushing some more work at him?
The comments regarding the PR dismissiveness and closing should not be the focus. The man has a job, kids and is writing code for free. Everyone has a bad day. Hope to see this project and the rust community move forward together.
If you have multiple files that do not change when the website is running you can serve them statically . Here is a [example program](https://github.com/SergioBenitez/Rocket/tree/v0.4/examples/static_files). This will include the files in the executable.
Aren't c++ type traits just rust traits?
Note that the same issue exists in C++, where even if you try to use perfect forwarding with universal references / rvalue references, you will get an intermediate allocation of a new `std::string` if you try to pass a string literal or similar. Its memory buffer will replace whatever allocation you already had.
Hoo boy that is really fun to think about.
What he's saying is that a pure function in Rust would be so restricted in what it can do that it wouldn't be useful anymore. The only functions that could be marked as pure would be those that are so trivially obviously pure that the annotation loses its value.
Exactly. I think their view on Rust remains to be seen in the coming blog series. Still, it's potentially interesting. As a consultant, I frequently see a lot of non-IT companies taking the word of Microsoft very seriously, and being able to point to official Microsoft pages talking about Rust in a positive light can do a lot of good.
Still think back of a T-Shirt would work best. I have no problems with self deprecation - I think it's a healthy thing to be able to take the mickky out of oneself.
While it may be useful (see also [RFC #2495](https://github.com/rust-lang/rfcs/pull/2495), I don't see how it would solve your problem. Cargo has a Cargo.lock file. This fixes every library to exactly the version you previously compiled with. Until you call `cargo update` or change the minimum requirements in the Cargo.toml file, those will stay in place. (It is recommended that you check the Cargo.lock file for applications into source control.) Because you care about stability, you should not call `cargo update` unless you absolutely have to. So you can say, "I compiled version 3.2 of my application with rustc 1.35 and this Cargo.lock. This will keep on working forever." 8 months later, a bug is discovered and you have to fix it and release 3.2.1 of your application. (You main development is already at 3.4 now, but you need to backport the fix.) Some possibilities: 1) The bug is in your application. You fix it, you use the old compiler to recompile everything, you ship. Done. The only thing you need to do is remember which rustc version is used for which application version. (I'm pretty sure I've seen people stick special files in their project root for that. Can't find any repo with it though.) 2) The bug is in a library you depend on and there's a fix. So you upgrade the library (increase minimum version in Cargo.toml) and rerun the build. Cargo will automatically recalculate dependencies, and AFAIK it will try not to change any Cargo.lock versions unless it *has to* to meet the new requirements. Then one of two things will happen: 2.1) Everything works fine. You're done. Check in the updated files and release the new version. 2.2) It fails to compile, since the library in question (or one of its dependencies that was implicitly updated because the newer version depends on newer versions of its own dependencies) no longer works with the old rustc. (Note that the interaction of compiler compatibility and semver of libraries is still a point of contention.) In this case, you don't have much choice but to fork the library and either make it work with the old compiler again, or backport the fix to a version that still worked. 3) The bug is in a library and there's no fix. If you can't wait for a fix, you're back to forking and fixing yourself. ----- So, what would change if you could tell Cargo, "I need this to work with rustc 1.35."? Let's say that Cargo knows, for each library, what rustc it needs. The answer is, you'd fail early in step 2 if the library author upgraded his minimum rustc version. Instead of a compile failure complaining about unknown or unstable syntax, you'd get a Cargo error telling you that library X cannot work with this old compiler in the new version anymore. This will probably save you 10 minutes of work. If you've never had this kind of issue before (as before you encountered it this time) it might save you 2 hours of work. But the ultimate outcome is the same: you either backport the fixed library to an old copmiler, or you backport the fix to an old version of the library.
Grandpa, I thought asked you to stop watching Fox News. Next time I'm reducing the plan on the cable bill.
Working on a reddit terminal viewer, inspired by RTV, I started this week. I’m using `cursive` and `reqwest`. This is my first non-trivial Rust project, so I’m getting more practice with lifetimes and creating models, especially.
Bad bot
`move` means that all the variables captured[1] in the closure will get moved inside it (instead of being copied). You can find more about this keyword [in docs](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch13-01-closures.html) (near the end of the page). [1] `captured variables` are all the variables that closure 'captures' from its outer scope (in your example it's the `x` parameter in the second closure, for instance).
This. Unsafe is just there to tell the compiler 'trust me i know this looks bad but I know what Im doing'. It's not a 'go wild because mommy the compiler isnt around' card
Asynchronous programming and generators are still very much work-in-progress in Rust - they work, although a lot of polishing is still ahead of us. I'd say: try and decide for yourself. I've had quite fun writing actors in `actix` (not to be confused with `actix-web`) :-)
A lot of us see relying on nightly as a deal-breaker.
Good list. In Monad: &gt; flat_map is also known as bind in other languages. But the examples above don't use `flat_map` anywhere. They use `chain` and `and_then`.
I think OP tries to return `impl Trait`, but he's not sure _what that trait should be_, since rustc does not help in such cases (i.e. it does not try to infer the trait for the error message). If you see `MapErr&lt;AndThen&lt;...&gt;&gt;`, it's easy to say `oh yeah, it must be a Future!`, but there are other traits too, which are not always so obvious.
&gt;while I personally would rather have it declared \`unsafe\` with a big doc comment saying why it is unsafe and how to handle it safely That's just UnsafeCell in the stdlib. Which is why I think Cell is so problematic, it doesn't actually \*do\* anything except sweeping unsafety under the rug. Huge red flag.
Please ignore the vocal haters. I think Actix is amazing, and easily the best Rust web framework. I, for one, greatly appreciate your work, and I know that the silent majority does too.
the last comment of the the actix owner shows in my eyes that it isnt directly the pr rather he still feels personaly attacked from the last time and acted like that. hopefully in a few weeks when he gets his head clear from this all, he'll see whats going on. altough i dont like the use of unnesecery unsafe, i have the feeling some people just take every opertunity to blame him on personal level
I guess that https://www.reddit.com/r/rust/comments/ce09id/why_we_need_alternatives_to_actix/ is probably the reason.
(NBD, but the link you wanted was http://n-gate.com . Apparently n-gate doesn't do https.)
&gt; including that your dependencies are also stable and matured out of 0.x versioning Small nit: this should be *public* dependencies are at 1.0. It's totally fine to have a 1.0 crate with private dependencies that are at 0.x.
I read your post looking for substance, but all I found is FUD. As to your conclusion, "and I think it's time we looked elsewhere" let me just point out that no-one whatsoever gives any credence to where you think the Rust community should go. Writing a fast production-ready Rust framework is hard, hard, work and your kind of sourfaced critique is IMO has no place in the open source ecosystem. Parasite begone!
I saw a pie-chart from Mozilla in the same vein, but featuring more bug categories. I can't find it though, does anybody have a link?
Have an upvote. Though frankly, I think at the moment I would prefer first-class support for Rust in Azure, especially serverless functions. Rust could be *huge* there. (Functions in C# are a nightmare).
Nice to see more Zachtronics-style games. I love those. Will consider buying this one, but my free time is *very* limited these days.
Especially these days
Just found this comment linked from another thread and wanted to pipe in that I think you're definitely on the right track with that metric. I've written some thoughts about this before in the context of various npm-related scandals: https://old.reddit.com/r/rust/comments/a14i9x/how_can_we_defend_against_these_type_of_attacks/ean5q2s/
The community is rallying for a good reason. Rust's popularity is linked to its reputation as a safe language. Now, wake up tomorrow to a headline that company x has lost millions of sensitive user records due to Rust's popular web framework. Rust a supposedly safe language is apparently also vulnerable to security issues that plague other languages. Imagine the fallout from that crap. Imagine having to explain \`unsafe\` and how it's not Rust's fault and argue in the defensive. Years later either ignorantly or in bad faith, people will still be citing that news as to why you shouldn't use Rust. The community is taking a prophylactic measure right now to disavow the unsafe code.
Bad bot
Thank you, CornedBee, for voting on these_days_bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
I wonder if just killing off Globals in libsyntax would help... I want to do this for another reason: in IDE one does not really have a concept of parsing session, so the Globals would make evolving towards rust-analyzer like architecture hard. I am currently tinkering with the lexer and want to add string interner as a parameter to it, instead of doing a lazy TLS lookup on every non-trivial token.
I am very aware of this and it was partly the reason i wrote my initial comment. Having the Microsoft Security Response Center behind this with a story of how safe programming in the future could look like and Microsoft openly backing the project – could steer the project more in a direction people would want to see a big Rust project is heading as poster child of Microsoft's effort to promote fast systems programming languages. &amp;#x200B; If this is just down voting because "you mentioned actix-web" would be very disappointing for the Rust community! I think we can do better and be more constructive! I think we can agree that we don't want to see the world burn because we are an angry mob but improve things gradually where we can and give constructive criticism.
I think Actix is kind of controversial? It's taken a very focused "get this working and make it super fast" approach, sacrificing a lot of the core Rust values especially in its early days. It's gotten a lot better on this, but even now there's not a lot of patience for comments that maybe something isn't the right way to do it. It's a very impressive project and lots of people are using it with success, but I think a lot of people would rather see some competition that is maybe 95% as fast but takes a lot more principled approach. That's also something where the aid of a large company would be most valuable.
It’s unclear if your argument here is that Techempower is wrong or Actix is wrong. Techempower allowed all players to peel back layers of abstraction to speed up Text and JSON, provided they stayed in the same language/framework. Consequently everyone, from Java to Haskell, did exactly that. Haskell was an extreme case, dropping out of servant down to Warp for example. They later regretted this and removed the Text benchmark. The current fastest Python app on JSON, japronto, does indeed use a native C library for JSON serialisation. Actix was playing fair by the de facto rules of the game. The original article would have been stronger had it not included this easily disproven point, as its inclusion betrayed a certain tendentiousness.
Thanks, that is an interesting idea but frankly i would prefer to be independent of the platform my code should run on. I am a big fan of the idea to deploy my project on a systems that i see fit regarding the requirements of my client. I had many deployments where i was not allowed to use AWS etc. but had to use a root server in a data center in a specific country due to legislative ruling etc. I like to deploy where ever i like, pure servers AWS, google, Azure whatever fits best.
There's also some good conversation (and the usual negative comments) going on over at [https://news.ycombinator.com/item?id=20456273](https://news.ycombinator.com/item?id=20456273)
Thanks for your reply. I get this – and my post was addressing because i think such an effort from Microsoft could steer the project in exactly the direction you mention. Actix could become exactly the project you envisioned if the Microsoft Security Response Center would look after it and having Microsoft to promote this as a poster child of secure systems programming – that was the meaning of my last sentence \&gt;Would be cool from Microsoft to announce such a project as playground to explore this field and have a fast web framework without unsafe usage and no UB in the future.
This looks a lot like my Backgc. You might get something out of this writeup about it [https://gist.github.com/makoConstruct/9f5430c584bd5768d1b29739480692ea](https://gist.github.com/makoConstruct/9f5430c584bd5768d1b29739480692ea) I haven't tried to implement it yet. I think it'll have better complexities than most current collection schemes, but it has a lot of overhead, I'm pretty certain it wont be faster except in cases where the heap is much bigger than any normal program's heap ever gets. A paper I found proposed doing something like this for distributed systems, which is one such case. &amp;#x200B; You seem to be using HashMaps for something. There's a trick I do where forward links store their position in the backlink listing, which they can then use for constant-time removal by swapping the back element into their position and shortening the list by one (and updating the position of the one they just moved) (although I'm not completely sure I knew how to make that work, it's useful to bear that technique in mind in general)
Right, thanks!
Nah I don't think it needs to revisit the original graphic... If you do a follow-text countour sticker thing let me know! I'd like one and 2 business cards.
Thank you for your answer :) I will have to document a few things, even after refactoring to use `RwLock` instead
I know that the maintainer, Nikolay, has some history w/ unsafe code, but this post is rather a hasty bashing than a contribution to the community. The author could've chosen better words than this. Actix has delivered features and has worked so great, better and faster than its competitors, even with so many lines of unsafe code, no matter you like it or not. Nikolay deserves something better than this, if you're really concerned about the Rust community.
While I agree with you, I think we should be sympathetic and understand that despite it not being a dogpile, the author emotionally experienced it as a dogpile. It can feel very disempowering when suddenly a huge amount of critique of your public code is published and you have a large group of people saying "change this, this is bad" and suddenly everyone is talking about it like the change is a given and plans are already moving ahead without your blessing. Ignoring you completely. It's a bad rub. I saw this happening in the last unsafe debacle on his issue tracker a year ago. It just isn't respectful. He runs that project. He wrote the 30k lines of code behind it. The approach should be "we found this, we think it's bad, do you agree, if so what's the plan boss man?". I guess that interaction left him sort of jaded and it's why we are where we are right now.
Actix has been really great for busting through some of the chicken-and-egg problems in the Rust async ecosystem. It may not be my ideal web framework but it certainly set a benchmark for shipping software that is actually usable in production. I hope it encourages more people to stop navelgazing and stop building crates with incredibly abstract designs. When it comes to shipping software 99% is polish, optimizing for certain common use cases and finding the right amount of configurability.
What do you mean,do you have an example where using Cell can trigger memory safety bugs?
We can't use caching in our system. Everyone should get fresh results each request for all system.
 #[get("/index.html")] fn index_html() -&gt; &amp;'static str { inude_str!("index.html") } #[get("/index.css")] fn index_css() -&gt; &amp;'static str { inude_str!("index.css") } The content of `index.html` and `index.css` are now in the executable.
All things described are implementation details, and can be solved by either forking it or making PR. "codebase has some issues" and "maintainer has some issues" are not reasons to use another framework, especially if none of that really is visible to someone using Actix. If you think you can do better job, fork it and fix the issues.
&gt; Personally, I would prefer a web framework in which PRs like that shown aren't dismissed as "we might as well switch to an interpreted language to avoid ub". **The PR will be reviewed again in the near future to be considered for merging.** The author didn't see much value in it personally as they understood it was not likely to be any actual issue due to being unsafe code used only internally, only a contributor could introduce the UB and the author was adamant that their code review would prevent that. Granted, they didn't communicate that well, and it seemed perhaps they didn't review the actual PR for consideration as the given example of causing a UB resulted in the judgement I just mentioned(which wasn't apparent until discussion on the PR progressed). As there is no valid reason for dismissing it given, and the presumably unexpected community concern expressed(which has come across as negative towards the author's perspective), they're not as motivated to deal with it just yet. **This thread should be supportive to the author, to encourage/motivate and show appreciation, rather than becoming an additional thread doing the opposite.** It seems to largely be from a misunderstanding or poor communication. There was fair concerns raised about mental effort to keep the internal knowledge regarding introducing UBs due to use of unsafe during reviews, where the author might slip, or in future additional reviewers end up involved if the author is unable to continue maintaining the project by themselves over time. **Handing that mental effort off to the compiler via safer code makes sense, especially if there is no drawbacks to merging the PR.** **The author clearly cares about the community and why it's users choose Rust.** Otherwise they wouldn't bother participating in the discussions about it further or bother to review the PR for merging after clearing up the misunderstanding and importance/value to users(even when it's specifically internal only code for the project).
I have no idea how to read that site.
Rust doesn't need Haskell-style purity because it addresses the same problem though linear types.
The title alone is wrong. I cannot see how having an alternative is bad: IMO, it's always positive and needed.
I'm thankful that bytecode exists as a easy way to patch C# and java closed source applications. Native machine code editing is just too complex.
&gt; Now the Actix maintainer has lost motivation of dealing with the community and open source, instead of feeling motivated to potentially correct some errors. It's a shame. All that noise was over a misunderstanding that the author/maintainer refused a UB fix that could affect users of the project, when it was specifically only something that could be triggered internally and he'd pick up during review. They didn't communicate this correctly on their end, with their response being blown out of proportion(it seems it was more of a joke, like someone asking core devs to remove use of unsafe in the std lib like Vec users iirc). All that needed to be said was that, if the maintainer saw no drawbacks from merging the PR, would they value the benefit of the language preventing UB with a safe implementation for community PRs so he doesn't have to think about it during review, in addition to not having to pass on such information to any future maintainers/reviewers that may join the project. Instead, he got judged with rather negative attention by people that presumably didn't know any better(eg calling him out for cheating in benchmarks when it wasn't).
It is essentially where this sub-reddit is at, at the moment, and it's disappointing.
The title is an opinion preceded by “[rant]”, implying that it’s an obviously and admittedly hyperbolic opinion... it can’t really be wrong, it can just be ill-reasoned. As for your thesis, I give you the current notion of “alternative facts” as an example of negative and unnecessary.
&gt; dismissiveness that was shown to a perf-neutral PR whose only goal was to patch unsoundness holes caused by overuse of unsafe throughout the codebase concerns me. There wasn't any assessment on perf impact was there? It's just assumed? The PR was for internal code, only contributors to the project could introduce UB from it, which the maintainer is adamant they'd pickup during code review. So... kind of like many other crates which might use unsafe internally(even Vec does?), which would require code review to pickup on introducing UBs? The PR did have value to any potential contributors, or future reviewers/maintainers. I don't think that was considered by the maintainer, and thus they felt the value of the PR was questionable(as they only thought about their own perspective as the project maintainer?). It wouldn't impact any actual users of the project, the only way that it could is if the maintainer added/merged code that'd introduce the UB. Just so that you're aware, the PR is going to be reviewed at a later date and more than likely merged. The negative attention has delayed this though as it's affected the maintainer and could have been handled better considering the actual impact was overblown.
I'd love one, too. How do I send you 5$. Do you ship to Germany?
So the reason why there is unsafe in actix-web today is because it is principle-driven. One principle supporting it is one of applying critical reasoning to understanding when and how to use unsafe in such a way as to not expose the server to risk. Another principle is pragmatism. It is not practical to uphold a standard of zero unsafe when doing so is at a cost and risks are clearly understood.
[This issue](https://github.com/rust-lang/rust/issues/59718) is on the topic of reducing Globals use. Killing it entirely might be difficult. There are places where passing an argument is hard, most notable `encode()` and `decode()`; those functions really benefit from being able to access Globals directly.
Looks good, but I feel like it doesn't quite cover all cases. It does these: * take a `&amp;str` and copy its data into the existing buffer. * take a `&amp;String` and copy its data into the existing buffer. but it doesn't do this: * take a `String` and just replace `self` with it, dropping the existing buffer. No string data copy needed, unlike the previous cases.
Linking to "unsafe elitism" here could be misleading. The PR linked in OP is not part of such absurd movement at all. It fixes a "safe" function that was actually unsafe to call, and adds comments regarding "why this \`unsafe\` usage is actually safe" to some \`unsafe\`s.
Slightly off topic, but i remember reading that one good benchmark of a compiler is how long it takes to compile itself. Are there any rustc vs gcc vs ... benchmarks out there ?
I am deeply grateful for what Nikolay has contributed to the ecosystem. I don't agree with absolutist thinking and zero tolerance policies related to unsafe. It exists in Rust for a reason. Nikolay uses it responsibly. I trust that whatever the real issues are at play will be sorted out. If they aren't, these weren't real issues. Here in lies the challenge of defining what are real issues?
&gt;The PR was for internal code, only contributors to the project could introduce UB from it, which the maintainer is adamant they'd pickup during code review. So... kind of like many other crates which might use unsafe internally(even Vec does?), which would require code review to pickup on introducing UBs? &gt; &gt;The PR did have value to any potential contributors, or future reviewers/maintainers. I don't think that was considered by the maintainer, and thus they felt the value of the PR was questionable(as they only thought about their own perspective as the project maintainer?). It wouldn't impact any actual users of the project, the only way that it could is if the maintainer added/merged code that'd introduce the UB. Might as well switch to C++ if you're going to rely entirely on people's mental models to prevent UB. And we already know from experience that the maintainer can produce unsafe code that is UB in public APIs, because we've already been down this road with Actix! It's not the maintainer's fault -- Actix is mostly a great library -- but the point is no one is capable of reasoning about the safety of whole programs as well as the compiler. That should be the point of unsafe, to use judiciously where you can **locally** guarantee the safety of a construct which the compiler cannot, but Actix has repeatedly used it at arbitrary places seemingly to sidestep what could be design problems. And as for performance, **the burden should always be on unsafe code to demonstrate that it is faster, not on safe code to prove that it isn't a regression**, and in the absence of evidence safe code is taken. None of these unsafes are even commented with safety notes, much less performance justification or targeted benchmarks. Relying on review and "feels safe to me" when you're dealing with code that can cause UB in safe code at arbitrary points in your library is the whole reason we're in a mess that needs Rust to solve.
&gt; Nikolay uses it responsibly We'll have to disagree over that. I personally think he is too eager to turn to it for my definition of responsible use. The PR in question was to remove a means of triggering undefined behaviour using only safe code.
I'm not sure how to do thinks like static_if&lt;&gt; or is_type_of in Rust and have different code paths. I thought this was part of the const generics effort to allow for conditionals and loops (which make it on par or better than constexpr in c++)
A compilation of rustc by rustc doesn't compile LLVM, so to get a fair comparison you'd have to compare it to, e.g., clang compiling clang-without-LLVM.
&gt; Slapping a 1.0 version on the crate should mean some commitments in the Rust ecosystem, including that your dependencies are also stable and matured out of 0.x versioning; Is this specific to Rust? Link if possible for reference. I've seen advice regarding semver elsewhere, where the use of 0.x can cause issues and thus [it's advised to start with 1.0.0](https://blog.greenkeeper.io/introduction-to-semver-d272990c44f2)(appending `-alpha` or similar suffix to indicate quality). There are also other well known projects that go with even number stable releases, but odd number development releases(which then bump up to even number when read for release), although I think those are more software version related rather than packages. I don't expect 1.0.0 version to mean anything special, if it's still under heavy development with unstable APIs, communicate that. Not encouraging frequently bumping the major version number, but if using &lt;1 for development means semver rules don't apply, that's an issue I'd rather avoid? I do recall the actix-web crate introduced a minor version but it did bring a breaking change. That's more of a problem for me. I don't recall the project mentioning it was still not stable when it was bumped to 1.0.0. &gt; Unsoundness is a serious thing. When your crate clients are chasing elusive bugs in production caused by a particular version of the compiler optimizing away UB in a surprising way, the quality of that code shows itself for real. Yeah, but this isn't a UB that a user of actix can cause, it's only possible to trigger the UB example via using code meant only for internal use. Kind of like complaining that Vec has unsafe usage where you could introduce UB? For the UB to affect users of the crate, the maintainer has to introduce it themselves or through merging a PR they reviewed. They didn't personally see value in the PR creating all this fuss, but communicated it poorly as to why. The PR itself is of course valuable, in that it removes that burden of the maintainer having to be careful not to let the UB be introduced, the PR still included unsafe scoped code, it was just reduced scope with safer code improvements elsewhere. The maintainer will look at reviewing the PR again and merging it, but all the negative attention has affected them. Which to be fair, does seem overblown from those in the community assuming it to be much worse of an impact/risk, possibly not looking at the PR and just parroting things?
Thank you guys.. 😁
The closes Rust has to pure functions are const fn,which currently are pretty limited in that they: \- Can only be defined as free functions. \- Cannot contain control flow. \- Won't be usable in combination with traits for a while(either as bounds or implementations).
Also, the `unsafe` keyword doesn't make any huge changes to the compiler or anything, in fact there are only two extra things that are "unlocked" when you say `unsafe`: 1. Calling `unsafe` functions (including calling functions over C FFI, because those are always marked `unsafe`) 2. Dereferencing raw pointers That's it. It's just that these two things make it potentially possible to break the compiler's assumptions on memory safety or even cause UB without the compiler being able to prevent it, and that's why you have to specifically say "this piece of code is safe even though you can't prove it".
&gt; I don't agree with absolutist thinking and zero tolerance policies related to unsafe. There is no zero tolerance policy toward unsafe. The issues here are **bugs** (possible Undefined Behaviors when using safe Rust) due to mistakes in unsafe code!
maybe you don't but i do. I think too many people are too quick to de-emphasize unsafe and UB. I come from the opposite viewpoint, unsafe is my enemy unless there is a very good, and well documented, reason for it to be tolerated. bonus, if there is some documentation/followup on how to eventually remove that unsafe use. I am not an expert, I don't trust myself in dealing with unsafe, and I don't trust most people in doing so. People have repeatedly failed at that and that's probably one of the reasons why Rust was born in the first place. If it's to have my dependencies peppered with unsafe there is no point for me to use rust, there are plenty other languages out there with very good value propositions. The actix-web author is free to do whatever he wants, he is scratching his own itch and making code that helps fix his problems, his code is definitely very helpful to people who share similar viewpoints. However, I am not mandated in any way to use his library, and I sincerely hope that the unsafe-free ecosystem grows. The spaghetti/weird code, it's not great but I can live with. Caustic behaviour too, I am not a contributor so I don't care much. But the cavalier attitude around unsafe is a deal-breaker.
So if i delete the static folder after building the source or else move the executable somewhere else will it still work??
As promised I made some benchmarks. To do these, I forked the `rayon` and `crossbeam-deque` repositories and replaced the memory reclamation mechanism with my own `hazptr` implementation. I then ran the `rayon` benchmark suite with the previous memory reclamation mechanism (`crossbeam-epoch`) and the version using `hazptr`. The results of `cargo benchcmp` can be found [here](http://htmlpreview.github.io/?https://github.com/oliver-giersch/rayon/blob/master/benchmark_results.html) I am honestly somewhat surprised, that switching out the memory reclamation mechanism has such a significant effect on the results. I will have to look further into these results and especially why there are some improvements but also some quite significant regressions. I would also suggest to take these results with a grain of salt, as I've only used a somewhat older laptop with only 4 cores so far. Note that I have not done too much in terms specific targeted optimizations for the crate, so there may be some untapped potential for improvements.
Yep! You can try it out yourself
Microsoft is already heavily invested in another programming language called [R](https://www.r-project.org/) and their have [their own distribution](https://mran.microsoft.com/open) for it. So I guess the name R# is highly unlikely. But it is definitely possible that Microsoft takes inspiration from Rust for any future languages they design.
Do you keep a changelog anywhere? Could not find one within the repo.
&gt; but Actix has repeatedly used it at arbitrary places seemingly to sidestep what could be design problems. Ah ok, sorry, I'm not aware of any past issues about it. I'd have thought that if the maintainer had been running into actual UB problems that were causing real breakage/issues, that upon addressing that they'd have come to appreciate avoiding unsafe where possible and welcoming to any contributions to help achieve that. So I assumed it was just the developers attitude/ego from prior languages, that they leaned upon their own confidence, and if it was only internal code, not public APIs, then that might be ok. To experience issues, that while may have been more justified from being triggered via public API, the fact that their confidence in their code soundness had been proven to falter, you'd think they'd be more welcoming towards PRs to help address then, knowing that they could slip again. &gt; And as for performance, the burden should always be on unsafe code to demonstrate that it is faster, not on safe code to prove that it isn't a regression, and in the absence of evidence safe code is taken. None of these unsafes are even commented with safety notes, much less performance justification or targeted benchmarks. Fair enough. When looking over the PR, those safety notes was something I thought were pretty useful to have too (mostly because I don't trust myself, that's why I use rust and try to avoid unsafe), so the PR if anything becomes more accessible to contributors. &gt; Relying on review and "feels safe to me" when you're dealing with code that can cause UB in safe code at arbitrary points in your library is the whole reason we're in a mess that needs Rust to solve. Also a great point :) I'm happy that the PR will get reviewed again and we'll likely see it merged, but I do feel a little concerned with how the community approached it due to the side effect it had on the maintainer. Their work in general is still valuable towards the Rust community, and I hope this doesn't lead to hindered/halted development/contributions from the maintainer as a result. The Rust community is tough on safety, and I think that's great, but I also appreciate devs that invest so much time into contributing back. It could probably have been handled better?
.. and lack of mutual respect with the public as it tries to help address a perceived issue. I understand. Nik doesn't care to justify his position nor teach others from the internet how to evaluate unsafe. It takes effort to articulate that, and he hasn't. No one else has in his absence, either, though.
&gt; The language design really discourages grand designs, where Rust encourages it. Could you elaborate on that? I'm not familiar with Go much. I have some personal projects of my own that I want to tackle in Rust, generally I'd use an existing crate that is up to par, or contribute towards it when appropriate should I need something missing.
Long time lurker here. I've been watching your projects since DataFusion was first announced and I'm really excited about this! Is it too early to think about contributing?
I think someone just needs to talk 1-on-1 with the guy. He seems kind of unfamiliar with the way people collaborate in FOSS. Unable to take suggestions/criticisms, or respond with some reassurance or explanation of why the PR is rejected. Yes, it's fine to have unsafe blocks where justified... but they should be justified! As in, actually testing whether or not there's a benefit, and documenting the reason for it.
&gt; distinguish between "this u8 has a determinate bit pattern" (initialized to some value, possibly statically unknown) and "this u8 has an arbitrary bit pattern" (uninitialized) There is actually no distinction here in the abstract machine! In both cases, there is just a particular bit pattern in there. The abstract machine is a dynamic concept, and like an interpreter it "knows" all the run-time values. It is only when you consider static analysis done by the compiler that the difference between statically known and statically unknown comes up. But that analysis is not part of the language specification, it must be show correct *with respect to* the specification. &gt; Since V1 isn't initialized in the !cond branch, can't the compiler say "well, it's an arbitrary value, so just choose the value for the phi function that minimizes work"? To do this, the compiler has to show that *such a value exists*. It has to choose *one* value and stick to it, and one choice might make one half of the code easier while the other choice simplifies the other half. In contrast, by making uninitialized memory unstable, this is all trivial.
As far as I understand semver conversions, 0.x versions allow initial development with relaxed stability guarantees. In Rust, developers typically add some measure of stability in that there should not be major API breaks between 0.n.x and 0.n.y, while changing the second number indicates some API changes. Once you release 1.0.0, you commit to maintaining backward API compatibility for all subsequent 1.x.y releases.
"to save yourself" haha
Well the language first appeared 9 years ago so your point is moot.
Have you seen `cargo install flamegraph`? No Perl required :)
I know! We have many categories and even sub-categories of memory safety bugs. But for the purpose of the blog, we think that binary classification is better
I don't think OP is attacking you. I doubt you would even disagree with the title of the post-- of course there should be alternatives, right? Open source programming is a scientific process. We put code out on the internet and receive criticism &amp; suggestions for improvements. We determine whether or not the changes effect performance, security, and so on. And then make the changes as necessary, or reject with some understanding why. Consider that you are criticizing OP's criticisms, which is totally normal. But that OP feels the process hasn't been adequate-- not enough communication to explain your decisions. In any case, this is how it's going to be. People have actually been very civil for the internet. Make a decision about whether you accept subjecting your work to this process.
As always, the community is a better judge of their code, but the author did not see the UB leaking. I mean, the harshness when it's open for pounce, makes me anti-social.
\&gt;Now the Actix maintainer has lost motivation of dealing with the community and open source, instead of feeling motivated to potentially correct some errors. Well, that's up to him. If it's not his cup of tea, it's not the end of the world. Actix is still very valuable. Interested people could fork it if he gives up.
While I agree on raising concerns about security issues, I think this blog post comes off a way too aggressive and hostile. The whole "Flying Solo" section I also find to be in a very disrespectful tone: &gt;Oh wait, we can't look it on [docs.rs](https://docs.rs), because it's part of the actix-net crate, and [docs.rs](https://docs.rs) doesn't believe that it's a library. Not to worry, let's open up the copy of the documentation on [actix.rs](https://actix.rs) (which doesn't even seem to be linked from the main [actix.rs](https://actix.rs) site) &gt; &gt;... &gt; &gt;Hang on a second... so the ServiceFactory::create() method returns an item implementing NewService, and NewService supposedly acts as a 'service factory'? So NewService should really be ServiceFactory, and ServiceFactory should really be ServiceFactoryFactory. Got it. There's also IntoNewService, which presumably does a similar thing to ServiceFactory except it gets consumed. Then there's NewServiceExt (I have absolutely no idea why you'd need an Ext trait here). It gets even better - there's another internal trait called ServiceFactory, this time inside the actix-web crate itself, with a single mysterious method that doesn't on the face of it appear to 'create' anything (as a factory should): fn register(&amp;mut self, config: &amp;mut AppService);. We've also got two different HttpServiceFactory traits, one in the actix-web crate and one in the actix-framed crate, both internal and completely unrelated... &gt; &gt; &gt; &gt;I don't think I need to explore this rabbit hole much further to demonstrate what kind of mess we're dealing with here &amp;#x200B; I think the author should really stop up and think: "Would I talk like this to a peer at work"? I would definitely not like to have someone speak about my work like that and I don't believe the author would either. The naming was a bit confusing, so what? I'm sure if we dissect all code the you've written we'll find a few bad examples.This is the kind of tone that discourages people to contribute to open source and to open source their work, because any suboptimal code will get mocked. Rustaceans often highlights the open and welcome community around Rust as one of it's strengths. This thread and blog post is an example of the contrary. It's disappointing but I guess when a community becomes large enough they all trend towards the same equilibrium.
Please see this thread that I've linked elsewhere: https://old.reddit.com/r/rust/comments/c9fzyp/analysis_of_rust_crate_sizes_on_cratesio/et046dz/ --- I elaborate quite a bit more on this. There are serious problems with a micro-crate ecosystem. That a micro-crate ecosystem enables arbitrary code reuse is precisely its acknowledged benefit, and that benefit isn't what's in question. What's in question, in my mind, is whether it's worth it and how much granularity we should actually have.
Agreed. I came to Rust to get stronger compile-time guarantees than Python, I lack the skill to audit whether `unsafe` is being used properly in a dependency beyond the simplest, most primitive of FFI calls, and I know it. For that reason, my only recourse as a responsible coder is basically to shun `unsafe` entirely and, to ensure my codebase remains maintainable, to consider any author who might be too eager to add it later to be untrustworthy.
Please don't trivialize the effort involved in becoming familiar with someone else's code.
Of course the standard library uses it, that's the raison d'etre for the attribute... ;) If you are fine with relying on perma unstable stuff then knock yourself out.
Please look at the title of your post. Do you honestly think that alternatives aren't needed? Even if Actix was literally perfect at what it does, we would want alternatives.
We've been through this song and dance before with actix-web. Nik is generally unresponsive to reports of UB until it's all over Twitter and the front page of Reddit. It's clear to many that he hasn't learned from the previous round like many had hoped.
what about the Code of Conduct ? we have this only to be in there just for the eyes ?
Thanks for this! Btw, the anchor links on [this page](https://functional.works-hub.com/learn/functional-programming-jargon-in-rust-1b555) are not working.
This comment was added 10 hours after the article hit the front page. It's damage control to the situation. This is exactly the same thing that happened last time UB in actix-web hit the front page about 6 months ago.
Even with private API it's incorrect to have safe functions which can cause UB. At the very least you should mark them `unsafe`.
Your biggest dependency, `std`, is littered with `unsafe`. I think it's wrong to regard `unsafe` as synonymous with "unstable". Each use of `unsafe` should be justifiable (and ideally explained in a comment), but it would be misguided to assume that all uses of `unsafe` are inherently going to cause UB across your codebase. People write stable software in C and C++. It's harder, but you can't assume it to be buggy just because it's written without Rust's memory safety guarantees. Avoiding `unsafe` does not prevent bugs from being present in your code, and it does not prevent crashes from occurring. What it _does_ do is give you a strong indication of where in your code certain types of crashes are originating (specifically, crashes occurring as a result of memory access bugs). It is not possible to write any meaningful program that does not at any point enter an `unsafe` block. For example, if you want to do any I/O, you will be using constructs that are built on top of unsafe `libc` calls. It should be obvious to anyone that these are not problematic.
That's not quite true. If youwere to use this for a web-app, you could combine it with all kinds of permissively licensed crates likes Diesel or Rocket. You just couldn't publish the entire thing under a permissive license. Note that it's entirely fine by the GPL and other licenses to not publicly release your code at all. You can just deploy the app and call it a day.
You have another course of action: Learn to understand the lower-level constructs that become accessible through `unsafe` blocks, and why people might want to use them. You can do this by acquiring some experience with C or C++, or by implementing certain data structures in Rust that are not possible to implement without unsafe code (for example, doubly-linked lists). It is fairly shortsighted to stubbornly go ahead and declare anyone who uses `unsafe` for whatever reason untrustworthy.
Even unsafe rust is better than c++ to me. I have cargo.
Don't take it *too* seriously, the main point I was making was that Go's design, which de-emphasizes libraries, leads to a focus on shippable / runnable binaries. And those can be easily consumed by people with very low time investment, which gives a lot of visibility to your language as being a good fit for that problem domain to people who aren't necessarily looking to start a project right now, let alone try a new-ish language. Also personally I tend to get bogged down when creating a library, except when it's mostly splitting out existing code from a project. Except for very deep infrastructure work I think that's the way libraries should be grown/designed, but I recognize that may be more my personal experience than a universal one. To bring it back to Actix vs the competition, what I admire about Actix is that they had a strong focus on an actual use case, while a lot of the Rust async ecosystem was for a long time stuck in designs that I felt were trying to do too much at once and involving too many separate libraries / abstractions. You first need one thing you're really good at so people will use your code for real production things, and then you can branch out. If you never attract users who are pushing your code to the limit or actually using it to make money there is no drive to add the polish and optimization, so you will just keep adding more half-baked features and technical debt, which scares away the "serious" users even more.
I'd like to highlight that the headline to this post was written by a MS employee.
Is there a good reason why the standard library omits these? impl From&lt;char&gt; for i32 { ... } impl From&lt;char&gt; for i64 { ... } impl From&lt;char&gt; for u64 { ... } impl TryFrom&lt;u16&gt; for char { ... } impl TryFrom&lt;u32&gt; for char { ... } impl TryFrom&lt;i8&gt; for char { ... } impl TryFrom&lt;i16&gt; for char { ... } impl TryFrom&lt;i32&gt; for char { ... } impl TryFrom&lt;i64&gt; for char { ... } If not, I might throw together an RFC.
From the whole ecosystem point of view, having few people spending non-trivial amount of time on getting familiar with existing codebase is several orders of magnitude less than having everyone switching to completely different one. And in this case this time has already been spent.
I wholeheartedly agree with the spirit of this message.
It should just allocate anew without copying in this case.
No, that's not true. With perfect forwarding in C++, `employee.set_name("Bob")` will forward the `const char*` that points to `"Bob"` perfectly to the line `this-&gt;name = new_name` (where `new_name` is still just a `const char*`), and that calls `std::string`'s overloaded assignment operator with `const char*` as argument. This assignment operator knows about the buffer that it already has, and is therefore able to reuse that buffer.
Is there a way to match on a template type? like match a { A&lt;type1&gt; =&gt; ... A&lt;type2&gt; -&gt; ... }
Using a native C library is one thing - I was more talking about writing code from a different language directly in the benchmark. Regardless I think it’s a totally fair point to say that not looking at the HTTP method puts you in the ‘stripped’ category I mentioned
It also has the target type encoded as an associated type (`ToOwned::Owned`) rather than a type parameter, so each type can only be assigned to a single type. For example, `&amp;str` implements `ToOwned` and has the `Owned` associated type set to `String`. So if you have a `&amp;str` and want to copy its data into the existing buffer of a `OsString`, you can't use this (even though `OsString` does implement `From&lt;&amp;str&gt;`).
I was talking about stack overflow!!
lol
&gt; I think someone just needs to talk 1-on-1 with the guy. He owes us nothing. He doesn't need to change a thing. &gt; He seems kind of unfamiliar with the way people collaborate in FOSS. I think he's quite familiar with it at this point: at some point a mob will form, and they will shit on you for weeks. If this makes you cranky, the mob will claim your attitude is wrong, and someone needs to help you. &gt; Yes, it's fine to have unsafe blocks where justified... but they should be justified! You can uphold that standard in your projects, and the dependencies you choose to use.
Need more of em ML, Data Analytics projects. Rust with is parallelism and performance can really shine in this space. The compiler has some prolog based systems as well after all.
Being disrespectful was not my intention *at all* but I can totally see how the post, and this section in particular, may have come across as such. &gt;The naming was a bit confusing, so what? The point of the section was **not** to simply bash the naming, it was to demonstrate the barriers for new contributors. I think I need to take a step back and consider deleting this section in particular, although the damage may already be done. I absolutely maintain that I’m making a valid point here which needs to be addressed if actix wants to have any longevity. However in comparison to the other points in the article, it’s not as important and I feel like the harsh tone I adopted detracts from the overall discussion.
&gt;He owes us nothing. He doesn't need to change a thing. What does "owing" have to do with it?
As it is stated in the OP Article – yes it is clearly understood but we (Microsoft in that particular case) have still 70% of the vulnerabilities because we think it is understood but in reality it is not and we have problems with it left and right.
One implementation of that (MVT on the server side) is https://t-rex.tileserver.ch/. But if you work on a renderer, some people interested in it will turn up?
Check out https://docs.rs/noisy_float/*/noisy_float/.
This may be an unpopular opinion, but it shouldnt really matter to the rust ecosystem that this packages has potential for UB as long as people understand the risks they are taking. I appreciate the article for notifying more people about the problems, but going after this guy really doesnt fix anything. Actix is his project and he gets to make the final calls on it. If you dont like the choices he has made you have two options: 1. Dont use it 2. fork the project and put in the time and effort. If people prefer the soundness of your code they will use it. Sitting in these threads with a mob mentality of "this is rust he is _required_ to uphold these specific values" does nothing for anyone. He does not owe anyone _anything_.
Great read, love it. On a side note - for me your blog looks much better on 170% zoom.
I completely understand. In my spare time I love to do gamedev in Rust but with work and school it's hard also finding time to deal with low level OpenGL headaches. Good luck! :)
I'm really enjoying your blog posts and would like to read more about the questions you are facing and how you go about solving them. I'm thinking for example about your decision to move from enums to traits. Please more of that kind of thing!
The worst consequence that people are suggesting for `actix-web` is that people stop using it. Whether Nickolay is doing the work for free or not is immaterial, no-one's complaining about poor PR management or unsound code in toy projects. People are using `actix-web` for real, production systems, and so pointing out that this might not be the best idea is not elitism. Also, no-one's complaining about `unsafe`, they're complaining about _unsound_ uses of `unsafe`, and coding practices that could easily cause future unsoundness in unsafe code.
This is certainly my biggest regret of the whole situation
I've been working on [`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis) documentation but I expect not much will get done on that front this week as there are some big PRs that I'm working on reviewing. Most notably is a PR for the long requested Information quantity (bit, byte, ...) from /u/Lukazoid.
I don't think anything you're saying here is really contested, so you're not really speaking to the issue directly. In addition to the options of "don't use it" and "fork the project," other options include "explain the downsides of crates to others." I do this all the time myself. I just did it [the other day](https://old.reddit.com/r/rust/comments/cbyam4/println_in_color/etj6lzh/), and it's fine. Educating others on the downsides (or upsides) of certain crates is totally fair game. The problem here is that one of the downsides of actix-web is that lots of folks (including yours truly) don't like the philosophy the maintainer takes toward `unsafe`, which has been demonstrated a few times now. It's hard to communicate this without hurting feelings because it's about the behavior of a person rather than the code, but it's absolutely a fair critique of the project and it's perfectly acceptable to educate others about it.
&gt; What's in question, in my mind, is whether it's worth it and how much granularity we should actually have. Generally, if it's fairly generic/common type of functionality that could benefit others, make it a separate crate? If the logic is specific to a project but covers a particular region of functionality, make it a module, if you find yourself needing it in another project, rather than maintaining two copies, extract it out to a crate of it's own? I'm not sure what argument you have against dependency number is? Smaller crates increase the number, but they reduce the scope of what they're focused on, their easier to review. Eg, I need X functionality, it's not a huge amount of code to implement, but enough to avoid NIH and source it from an existing crate if there is one and relieve myself of the additional maintenance burden. In this case, I can probably have a quick review of the crates source and verify that it looks suitable for my needs or contribute whatever changes I need, still less work than writing from scratch. Or I could just copy/paste to skip the dependency just to reduce a number? --- I take it you'd prefer related functionality like data-structures to be grouped and maintained in a less distributed fashion by bundling them up into a single crate? Does that incur much drawbacks? If I use a single data-structure, and that doesn't receive any actual updates for months, but the main crate itself is frequently increasing versions, perhaps even major versions, what does that communicate to me? How do I know it received meaningful updates or breakages that would actually affect my usage? It adds some confusion/burden to the user to sift through a changelog and the like to figure out what has happened. What if a breakage is introduced for the crates functionality to support something unrelated to the portion that I'm using, but as a result I have to adopt to that or remember to stay on an older version, if the part of the crate I use does receive improvements, I then have to accommodate for that incompatibility the breaking change introduced. I'm not sure how that impacts other things like file sizes(not necessarily the binary output of my program) or compile times? What benefit is being gained from trading dependency count "bloat" for "bloated" crates? Reduced analysis paralysis during crate discovery since you might as well just go with what the bundle crate provides? Does that impact competitive drive from similar crates in development? (more devs on the same crate rather than spawning their own would be nice, but they're just as likely to do the opposite by contributing time/effort elsewhere which may stagnate that area of development rather than improve it, see the MP3 crate under Rust Audio, that got adopted into an organization group and development declined). If I have 50 crates, or 1 crate with them all provided, what difference does that actually equate to as a user? What is the benefit? I can imagine the docs get more broader/nested to navigate with more noise from parts that might not be of interest? --- Your linked thread points: &gt; *It is a good metric, because each dependency comes with its own set of overhead. Maintenance status, documentation quality, MSRV policy and more.* This is more to do with the developers themselves and their own time effort towards a project. If they had their projected merged into a larger crate, it doesn't mean this improves. Nothing stopping others from contributing improved documentation quality to existing crates is there? Maintenance can be eased by community PRs and the maintainer placing some trust in additional maintainers. If the original maintainer no longer has the time or interest to maintain the project, having some official community group that they could hand-off/donate their crate/project to would be good. That doesn't mean it'll end up in any better shape though unless there was already activity from the community and the maintainer was the bottleneck. Some of the issues you'll have can be better established by promoting automation/tooling. Just like we have rustfmt and clippy, there are great tools for keeping a project up to date like Renovate. Contributing tests and CI to projects that are worth the time assisting, helps here too. Getting devs to adopt conventional commits and using tools like semantic-release for automated changelogs in addition to improved dev practices, that may be more difficult to get small projects to adopt, granted. &gt; *Every time I add a new dependency, that's potentially another maintainer (or more, including transitive deps) that I have to interface with, along with their own maintenance status and roadmap.* And all those dependencies perhaps like lego blocks can be what builds very different crates beyond just that one you added. Where is the benefit in duplicating all that, which is obviously not fixing a problem by shifting maintenance burden onto many more. I understand how it's a concern, but I don't think it's all that productive to supposedly solve by consolidating dependencies either. Perhaps if that concern of yours was somewhat offset by placing on the maintainer of the crate, so that downstream dependencies it has don't need to be your concern? [ergo](https://github.com/rust-crates/ergo) project seems to try unify crates and do more than just re-export APIs as a meta crate. The alternative of a larger crate that consolidates it's dependencies away, I guess someone might adopt, but depending on the size/scope that involves, the burden of maintaining it alone may not allow it to live long or progress at much of a rate. You'd have a bit more luck finding well established crates and getting the devs to agree that merging projects is worthwhile(which does happen) where the momentum may remain and spill over into each other. Alternatively the real value is in achieving something like the ergo crate is doing, if you can just get those developers to collaborate/network with one another, and perhaps extend maintainership where appropriate to reduce the additional overhead/burden that may bring. &gt; *For example, let's say I want to maintain a MSRV policy. I have been successful in convincing some people that this is worthwhile, or to at minimum, document the MSRV in their CI configuration.* Had too google what MSRV policy was(Minimum Supported Rust version) :P That's a good concern to have. Something that tooling should be able to answer maybe? If compiling on versions of rust and back-tracking until it breaks is valid, then perhaps crates.io would be able to provide/maintain that information? Then when you update your dependencies, some way for you to be informed that the MSRV has increased because of x dependency throwing some build error? Is there a reason you need each crate maintainer in your dependency chain to adopt a policy for it? If you're just wanting to ensure you know what the minimum supported version that can be built with is, then that is something tooling should be responsible for, not expecting it from N maintainers. &gt; *This means dependents, such as regex, can't add their own minimal version check because rand automatically fails it* If it's something that can be handled by tooling/ecosystem rather than requiring maintainers to opt-in, this would be a non-issue? crates.io would be ideal for running such a service &gt; *Another example is licensing. A while back, smallvec was MPL licensed, and I refuse to include any copyleft dependencies in my transitive dependency chain. Adding more dependencies just keeps increasing this risk, because not everyone is as attentive as I am (or shares my philosophical beliefs).* I respect that :) I believe there is also tooling for this that can identify license(s) a project uses. Licenses can change during a projects life, so this is another reason to want to have tooling, otherwise, you're going to want to frequently check each downstream dependency just in case? Perfect for including in your build, probably sharing a similar automated way of handling the MSRV policy.
**Part 2** &gt; *I just had to convince someone to stop using a heavyweight dependency like ndarray because they falsely believed it was responsible for a performance benefit. In turned out that ndarray was just using row-major indexing in a contiguous region of memory where as they were previously using nested vecs. How often are situations like this playing themselves out over and over again that I am just not aware of?* If I understood that right, that someone used ndarray for a performance benefit over their own approach because for similar code it did better than what they originally had, or ndarray itself had an update that improved performance from previously using nested vecs approach? Either way, the developer chose to use popular library for functionality/performance because it allowed them to offload that effort/knowledge. If ndarray updates and gets performance improvements, it's a win for the dev who didn't need to do anything extra. If the performance gain is from adopting ndarray, it's a time saver because the developer doesn't know any better, nor wants to spend the time looking into how to do it better(it might not require much effort to do and be simple once you know better, but trying to educate yourself about such can be a rabbit hole / time sink often if you're not careful) so taking the easy / pragmatic path is usually preferred. If the gain the developer got from a dependency is just a small part of the crate, then sure, they could benefit from not bringing in a pile of dependencies if that's a concern to them. It wouldn't make a difference if ndarray had no dependencies and instead bundled it all into itself, that's arguably worse. If the code providing the benefit is of a reasonable size, it can be nice to abstract that off into a dependency that reduces the LoC that you have to manage/maintain. In addition, if the dependency does optimize that particular part of their codebase in future, you're in most cases getting a performance win yourself for free, whereas without it, you don't. &gt; *Every new dependency introduces a new opportunity to break something or introduce bugs or introduce subtly difference policies than the ones you want* So does any update of a single dependency? Every commit to it's code introduces those same opportunities, you're just hoping the maintainer(s) is more responsible for for a large consolidated crate than many smaller ones. With an approach like ergo takes, at least the meta-crate has maintainers that may try to further review their downstream dependencies to avoid such issues, relieving this burden on upstream. Whatever way is taken, there's always the possibility for those issues to occur, personally I prefer a smaller surface of where the cause may be, then a larger / monolithic surface. &gt; *There are other problems that come with a micro-crate ecosystem. Look at our Unicode crates, for example. Combined, they solve a decent chunk of tasks, but they are almost impossible to discover and their documentation, frankly, leaves a lot to be desired. There's really nobody steering that ship, and both the UNIC folks and myself came to the same conclusion: it's easier to just go off and build that stuff yourself than to get involved with the myriad of Unicode crates and improve them.* Discovery can be an issue I agree. It was not as bad a few years ago, but going on crates.io now, where I may get pages upon pages of crates to look through, discovering lesser known crates is more difficult, unless they've been announced on r/rust for some exposure(either I see them or I'm on crates.io with the default recent download count sort). I like to visit the github repos of crates(as they're not always consistent with their crates.io or doc.rs pages. Sometimes you find READMEs that link to similar projects(since those maintainers are more likely to know about related crates than a user in discovery mode is). Awesome lists help here a bit too. You don't need a special WG in these cases, just adopting something like `ergo` can unify the crates and bring on collaboration to improve the quality/consistency, even if some of the crates being unified aren't maintained as well. &gt; *There will always be examples where a "micro" crate makes sense. hex might be one of them. base64 is perhaps another, along similar lines. On the other hand, an alternative design might be a small-encoding crate that combines things like base64 and hex into one, perhaps among others, and therefore centralizes the effort. Cargo features could be used to control what actually gets compiled in, which lets people only pay for what they want to use.* That seems to echo what I've been saying so far about how it should be approached? The cargo features bit makes sense for one of the questions I had raised earlier too. &gt; *This is why this problem is so hard because reasonable people can disagree about the appropriate granularity of crate dependencies. I try really hard to keep crate dependencies to a minimum, and even I see myself as failing in this regard. But when I go and bring in a crate to do HTTP requests and I see my Cargo.lock file balloon to &gt;100 dependencies, then something, IMO, has gone wrong.* It's mostly just a number. Probably the best approach is to take that same approach as the prior quote mentioned with a meta crate that combines related crates where possible. Does the abstraction add much value in the case of HTTP and it's dependencies? Who maintains the abstraction crates? They add some lag towards updates from downstream becoming available to use. How many of those dependencies for HTTP are specific to HTTP only? What the size of maintainers and their activity like? How much can actually be consolidated to smaller crates to reduce dependencies in a meaningful way to you, without that consolidation biasing towards HTTP crate when other crates depend on these crate dependencies equally, else you end up with duplication? Would it be better for related crates to be grouped under an organization and monorepo instead? Is the actual issue because they're separate crates, or that they've got various maintainers and varying standards/quality? There's a key difference there. I don't think reducing dependencies/crates is the real issue, more to do with fostering a better development community.
you can't remove the Hurt for the People.
What would these do? `char` is a unicode scalar, so something like `'😅'`. Do you want to get the actual numerical value of it? You can write `'😅' as u32` and get `128517`.
Is there a detailed comparison of the different web frameworks available for rust today?
Hello! I've been working on some upgrades using new futures and async/await, and I've come into a problem which I've boiled down to this code snippet: [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2a3beba3bdaca3db84568ce070fd4650](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2a3beba3bdaca3db84568ce070fd4650) The question is: Given a struct that contains a function as a property, is there a way to let the function be \`Sync\` without having a generic parameter of the function be sync? In code: ``` struct A&lt;T&gt; { f: Box&lt;Fn(T) -&gt; ()&gt; } ``` Can we make the struct `Sync` even if `T` is not `Sync`. `T` is only involved as a parameter of the single function, it's not that the property itself isn't `Sync`, just the input when the function is _run_ isn't sync. Any thoughts/ideas would be appreciated!
Love reading these! Thanks for all your hard work and wonderful summaries! :D
I find this blog post really disrespectful, I doubt you'd like it very much if someone shit all over your work like that.
I appreciate the considerable time you likely spent in writing these two comments, but there are so many subtle points and assumptions in your comments to untangle, and I just do not have the energy to do it. Note that I'm not saying you're wrong, or even that I disagree with everything you're saying, it's just that there's a lot more nuance at play here. My comments in that thread are the result of spending _years_ in the Rust ecosystem doing daily maintenance. I was one of the first to publish crates on crates.io, and I haven't stopped since. I'm well aware of the different ways in which tooling could solve or at least mitigate some of my problems. In some cases, there has even been some attempt at making progress in the tooling areas, so I'm confident that some of those things will be partially addressed over time. But at a certain point, you can't avoid the additional overhead that more dependencies bring. In my opinion, while tooling will help with some stuff, the best solution to this problem would be a cultural shift in how we look at dependencies. Cultural shifts are uncomfortable, but I'll continue to stay vigilant and constructively express your values. Keep in mind that, as I've said a few times in my comments, *I'm part of the problem too.* I am not immune to adding too many dependencies to things. So this isn't a "my values against everyone else's" kind of thing. I see this more as a "ecosystem wide health" sort of thing. /u/dpc_pw made the good point that a better metric for my concerns would be "number of maintainers" or "number of umbrella projects." But we don't have any good tooling to discover that.
The problem is not that `T` is not `Sync`, but that the function trait object is not `Sync`. You need its type to be `Fn(T) -&gt; String + Sync` instead: struct Foo&lt;T&gt; { bar: Box&lt;Fn(T) -&gt; String + Sync&gt; }
Thx a lot..
yes but std is heavily reviewed by really smart people. I don't have any confidence that the same is happening with Actix. Particularly as in this case there was a problem with his use of unsafe, somebody provided a pull request that addressed it and his rejected that pull request. This would make very nervous about relying upon this particular code base.
Well my coffee break just disappeared 😡
&gt; the burden should always be on unsafe code to demonstrate that it is faster, not on safe code to prove that it isn't a regression That is a subjective opinion. It's one that many people agree with, and I also agree with its general sentiment, but it is nevertheless a subjective opinion. Look, safe code has the pros that it is more likely to catch bugs and UB. Unsafe code has the pro that it can be faster. You clearly value the pros of safe code a lot, but other people - clearly including the author of Actix-web - value the latter more. Neither of you are *objectively* right. The only objective burden of unsafe code is to be sound. Everything else is subjective. What's important here is that you should know the values of the project you're submitting a PR to. If I were to submit a PR that replaces a `RefCell` with an `UnsafeCell` to one of your projects for the sake of performance, I better have a benchmark showing a measurable performance increase. It's fine for you to reject that PR. But if you submit a PR to a project that clearly values speed over safety (in internal code), and your PR fixes no unsoundness or other bugs, but it does make the code slower, the burden is on you to provide benchmarks to demonstrate that it doesn't make the code *much* slower. It's fine for the author to reject the PR. The author in this case did unfortunately close the PRs with some rather blunt comments, but it's clear that English is not their first language. The fact that despite all these eyeballs that Actix-web has gotten over the past few days, nobody has discovered any actual bugs or unsoundness in it, is actually quite impressive. So please, all of us, let's stop this witch hunt against Actix-web and its author. It's completely unjustified.
If the community around a project like this doesn't agree with the head of the project, then the solution is simple: fork it.
I'm not the person to ask. :-) The only comparison I know about is the very vague (and probably wrong) mental model I have in my head.
I think I finally got it! The key was to replace `for_each` with `fold`, so the socket gets passed from each iteration to the next. The compiling code, for anyone wondering, is: pub fn new(socket: TcpStream) -&gt; Self { let (tx_sender, tx_receiver) = mpsc::unbounded_channel(); let (socket_read, socket_write) = socket.split(); let pubsub_socket = PubSubSocket { tx_sender, }; tokio::spawn(tx_receiver .map_err(|e| eprintln!("error in pubsub send queue: {}", e)) .fold(socket_write, |w, m| { tokio::io::write_all(w, m.buf) .map_err(|e| eprintln!("write error: {}", e)) .map(|(w, _)| w) }) .map(|_| ())); pubsub_socket } I still need to add proper error handling and a bunch more to it, but I think the basic structure actually works now. Thanks again!
Since reddit link previews are very informative: I'm working on a async library for system information fetching (same as Python `psutil`, except for Rust).
They're quite different libraries. glam is a linear algebra library (e.g. vectors, matrices) that happens to be implemented in SIMD under the hood. Faster is a high level wrapper for low level SIMD operations. My understanding of faster is you write code once and if you compile it for an architecture that has say 256bit vector widths then your code will use it without requiring any changes. If you were doing that by hand you would need to write separate code for 128 and 256 bit registers because they use different instructions. glam only ever uses 128 bit wide SIMD and can't take advantage of wider vectors.
This pretty much single handedly kill any will to even consider Actix for my work requirements.
It’s not ok for people to just expect that a maintainer write code for them, and complain when they don’t, but that’s not what happened. Having a bunch of people make plans to make a bunch of changes to your code so that it works better is great. If you disagree with the changes, then maybe there’s a better framework for everyone to use. Having a core piece of infrastructure that is not community driven, where potential security issues need to be approached with the attitude of “what’s the plan, boss man” is not healthy. Maybe everyone in this scenario would be more happy if the broader community coalesced around a different web framework for production use and actix kept a smaller, more deferential community of benchmark golf enthusiasts.
🤦‍♀️of course!!! Thank you so much!
you are correct, sir. Here's what I started with and where I've gotten: `fn make_client(uri: http::Uri) -&gt; Result&lt;Box&lt;dyn Future&lt;Item=(), Error=()&gt; + Send&gt;, ClerkError&gt;` Obviously Item and Error are not () but I don't know what they should be. Help me compiler, you're my only hope! ```Rust error[E0271]: type mismatch resolving `&lt;futures::future::and_then::AndThen&lt;futures::future::map_err::MapErr&lt;tower_hyper::client::connect::ConnectFuture&lt;hyper::client::connect::Destination, _, tower_hyper::util::Connector&lt;hyper::client::connect::http::HttpConnector&gt;, tokio_executor::global::DefaultExecutor&gt;, [closure@tower-grpc-examples\src/helloworld/client.rs:29:18: 29:54]&gt;, impl futures::future::Future, [closure@tower-grpc-examples\src/helloworld/client.rs:30:19: 40:10 uri:_]&gt; as futures::future::Future&gt;::Error == ()` --&gt; tower-grpc-examples\src/helloworld/client.rs:41:8 | 41 | Ok(Box::new(say_hello)) | ^^^^^^^^^^^^^^^^^^^ expected struct `tower_grpc::status::Status`, found () | = note: expected type `tower_grpc::status::Status` found type `()` = note: required for the cast to the object type `dyn futures::future::Future&lt;Error = (), Item = ()&gt; + std::marker::Send` error[E0271]: type mismatch resolving `&lt;futures::future::and_then::AndThen&lt;futures::future::map_err::MapErr&lt;tower_hyper::client::connect::ConnectFuture&lt;hyper::client::connect::Destination, _, tower_hyper::util::Connector&lt;hyper::client::connect::http::HttpConnector&gt;, tokio_executor::global::DefaultExecutor&gt;, [closure@tower-grpc-examples\src/helloworld/client.rs:29:18: 29:54]&gt;, impl futures::future::Future, [closure@tower-grpc-examples\src/helloworld/client.rs:30:19: 40:10 uri:_]&gt; as futures::future::Future&gt;::Item == ()` --&gt; tower-grpc-examples\src/helloworld/client.rs:41:8 | 41 | Ok(Box::new(say_hello)) | ^^^^^^^^^^^^^^^^^^^ expected struct `hello_world::client::Greeter`, found () | = note: expected type `hello_world::client::Greeter&lt;std::boxed::Box&lt;tower_request_modifier::RequestModifier&lt;tower_hyper::client::connection::Connection&lt;_&gt;, _&gt;&gt;&gt;` found type `()` = note: required for the cast to the object type `dyn futures::future::Future&lt;Error = (), Item = ()&gt; + std::marker::Send` ``` Ok, so Error is tower_grpc::status::Status (which is private and should be tower_grpc::Status). And I know Item is a hello_world::client::Greeter (that's the whole point) but I have to specify the T of hello_world::client::Greeter&lt;T&gt; and I don't know what that is. I also don't know why the compiler is using '_' instead of the concrete type in it's 'expected type'. If it told me the exact type I could at least copy/paste that, grumble, and move on my way. So after another couple of hours with the source code and documentation I did eventually figure out that the `_` were tower_grpc::BoxBody. So the signature using concrete types turned out to be: ```Rust type Client = hello_world::client::Greeter&lt;tower_request_modifier::RequestModifier&lt;tower_hyper::client::Connection&lt;tower_grpc::BoxBody&gt;, tower_grpc::BoxBody&gt;&gt;; fn make_client(uri: http::Uri) -&gt; Result&lt;Box&lt;dyn Future&lt;Item=Client, Error=tower_grpc::Status&gt; + Send&gt;, Box&lt;dyn Error&gt;&gt; ``` I'd still like to know how a more experience Rust developer would have tackled this refactoring. I feel like I'm missing some trick or perspective. Also I'd still like to know how to make Item just Greeter&lt;T&gt; where T is something the caller shouldn't have to care about. I opened an issue with the tower-grpc guys to see if they could help. https://github.com/tower-rs/tower-grpc/issues/192
&gt;He runs that project. He wrote the 30k lines of code behind it. The approach should be "we found this, we think it's bad, do you agree, if so what's the plan boss man?". Is that not what the pull request that fixed Undefined Behavior did? Then was promptly closed with little explanation?
I think the major issue is not but "unsafe" code but rather undefined behavior inside some of the unsafe blocks which \_does\_ potentially break the whole code base, makes it inherently unstable and insecure to attacks. And even bigger issue is maintainer's attitude towards undefined behavior in the code and their passive-aggressive reaction towards the contributors who try to fix that.
+1 on a Mac release, I would buy this game in a heartbeat.
Yes, exactly. I'm writing code which converts characters to and from their integer representations. These `impl`s would make it more convenient to do that, especially in generic code. Now that you mention it, I can't see any reason why we shouldn't support the coercions `'😅' as i32`, `'😅' as i64` and `'😅' as u64` as well. They're all lossless conversions.
We owe him nothing. If he doesn’t want to write a secure, community driven framework, then the community should move on.
I'm an idiot (I saw the steamos logo and thought it was the mac logo). Purchased :-D
The thing is that everyone works to different standards. Some hope-and-a-prayer "UB is fine" kind of stuff (it seems), others really to very high standards. If I have to work to high standards, obviously the burden is on me to check that everything I use fits in with that. I can't expect everyone else to do that for me because they all have their own priorities. Also, I'd rather not have long chains of dependencies where I could get stuck using an old version of something with no updates. In that case I'd potentially have to keep local patches on a whole chain of stuff until the maintainers get around to resolving it. Simple and minimal dependencies seem safer to me. Yes, having everyone use the same well-tested crates for very common requirements makes excellent sense. It's when it all starts fanning out to little-used crates or long chains that it seems more dubious to me, from a risk perspective. If I see a huge number of dependencies being hauled in, the value of the crate sure had better be greater than my effort to check through them all.
&gt; Basically, Actix is still poorly written, and the author isn't trying to make it better. Go use something else that doesn't cheat on benchmarks and has undefined behavior. This is pretty strongly worded. Actix is hardly the only implementation on techempower that's taking shortcuts for speed, my guess is MOST implementations are doing something similar.
You know, code contains bugs. It's a fact of life. Rust's safety systems are a great tool to avoid certain kinds of bugs. But it sounds like your position is that any developer choosing to use `unsafe` is on morally shaky ground and is an untrustworthy person. Don't you think that is a little over the top? There is plenty of low-quality and unreliable software around, including on crates.io, that contains zero `unsafe` blocks. It is not on its own a good measure by which you can judge the quality of software.
This is related to a post I made earlier in this thread ([here](https://www.reddit.com/r/rust/comments/cdtrxj/hey_rustaceans_got_an_easy_question_ask_here/etyisni/?context=3)) but I think this is a different enough question to warrant a new post. I'm threading a `WriteHalf&lt;TcpStream&gt;` through `tokio::io::write_all` calls, from one call to the next. This works great, except for one issue: the `Error` type of the `tokio::io::write_all` returned future doesn't contain the `WriteHalf&lt;TcpStream&gt;` I passed in. This means that ANY error when writing to the socket immediately closes it! Now obviously some errors warrant closing the socket, but not all of them. In this particular case, the entire thing is going to be wrapped up so it automatically reconnects on failure. But let's say I wanted to deal with those transient errors without closing the socket. How do you do that?
Could you give more detailed example? (not necessarily working, of course - just show how you'd like it to work)
Only if `set_name` is defined as `template &lt;T&gt; void set_name(T&amp;&amp;)`, and not if the (far more likely) version is used `void set_name(std::string&amp;&amp;)`. Nobody is actually doing the former in C++, because it naturally leads to an insane codebase that is incredibly difficult to work with (the compiler error you get when passing something to `set_name` that cannot be converted to an `std::string` will be massive).
So, are we going to talk about the fact that people tried to point these things out in the months following "the fix" in actix-web after it came up the first time, or nah? I get that it got gross, but I regularly saw people talking about still-existing UB and memory safety problems get downvoted because this community swung so far in the other direction of being uncritical to a fault. I'm getting really fucking wary of the community we're building here. We're NEVER going to get a website retrospective and I'm resentful of being gaslit about it. I'm getting resentful of stuff like this that has to occur... How many times, before we learn a lesson?
On that note - if anyone is so inclined to try and get Rust crab plushies I'd order two or three of those no questions asked. Huge fan of language plushies for my car and desk.. no idea why lol.
How about just addressing the concerns? Make the code safe by default and have a cargo feature to turn back on the unsafe code for speed? That would make the criticism go away. Or maybe someone else could do that -- make an `actix-web-safe` crate.
If you add Makefile support to acquire and install rustup, then you can use a `rust-toolchain` file to ensure that a specific toolchain (e.g. `1.36.0` or `nightly-2019-07-15`) is used. With that in place, `rustc` `cargo` etc, will all automatically (via `rustup` and your `rust-toolchain` file) be the right versions.
You and many others were downvoted, even when bringing specific concerns. I actually cannot believe I'm the one saying this, but I think the community overcorrected on trying to be nice.
Unsafe code in a Web framework is a **major** red flag. Unsafe code that doesn't **need** to be in a web framework is a gigantic flashing red sign saying stay away. Unsafe code in a Web framework that doesn't **need** to be there and which the author refuses to remove because he doesn't think it's a problem is just off the charts bad. Web frameworks absolutely, 100% need to be safe and secure because they are about the most exposed code you can have. This isn't a matter of "liking it or not" it's about code that is not fit for purpose and which misses the entire point of Rust as a language. If we wanted speed at any cost we'd write in C++.
I would like to second this message. Thanks /u/fafhrd91, you're awesome!
Meh. People have tried to ring the alarm several times since the initial hoopla and they were ignored or rebuked. Many of us are here because of the promise of safe Rust. I for one am incredibly happy this article was written. Just as the author is under no obligation to write code j like, I'm under no obligation to suppress an opinion about it's quality or place as a recommended library.
Doubtful. It didn't make a big enough pact last time and they're this hostile to helpful PRs this many months later? What makes you think anything will change? No one is blaming anyone, just pointing out that safe code is clearly not important to the actix author.... an important thing to know when actix is in all the headlines and is the defacto recommended web framework...
I think we have two harmful groups of Rust evangelists: 1) The rewrite-in-Rust mafia that historically has caused enormous antagonism by suggesting people should just RIIR! 2) unsafe-at-any-speed absolutists who are apparently willing to disparage the best and most featureful Rust framework to date, out of some misguided notions of purity I kinda doubt either of the groups have written a single line of code in their life.
``` trait InsteadOfMatch { fn action(...) { ...} } impl InsteadOfMatch for A&lt;type1&gt; {...} impl InsteadOfMatch for A&lt;type2&gt; {...} ... a.method(...) ```
If I have two struct, where one is basically a specialization of the other (in the OO sense) do I really need this much boilerplate? https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a052382edb644574c3bb88551a98d249 I have a similar use case where one struct has some set of functions. Another struct shares the same functionality as that other struct but has additional functions too. I would solve this trivially with inheritance in a language like Java but in Rust I'm not sure if this is the best and most idiomatic way. It sure seems like a lot of boilerplate.
I'm not talking about code, so stop wielding that stupid safety shits. What I'm saying is the maintainer is a human being who understands human language. Software can always be fixed whenever stars are aligned, yet you don't get many devoted people. FOSS is software AND people, and this guy has done a fair amount of work for the community. Just imagine a random guy walks in and completely denies your 100+ hours of work. That sounds truly fabulous.
It's been a while since I've look at this. That's a serious improvement over time. I guess I haven't noticed because my code base has been growing faster than rust has been improving :/
&gt; Everyone has a bad day. Which is why uses of `unsafe` should actually be kept to a minimum!
Isn't this basically the visitor pattern? Seems like this is the perfect use case for it.
Bought 3 for me +2 kids. Now I just have to wait for the macOS version so I can play mine.
Hey, you're Jason Williams! I loved your talk about [Boa at JSConf EU 2019](https://www.youtube.com/watch?v=_uD2pijcSi4) for a lot of reasons: 1. You presented a very technical subject in a way that just about anyone can understand. 2. You are unquestionable an accomplished engineer, and you had no hesitation, embarrassment, or apology in admitting you didn't know something or didn't yet understand something very well. It's really important that people like you model that behavior. 3. You clearly knew your audience. 4. It's just a great example of someone doing something complicated and difficult just because it's fun—the essence of the hacker spirit. 5. It's about damn time we get a little diversity in these tech talks. Looks like JSConf EU had that in spades this year based on their [speakers page](https://2019.jsconf.eu/speakers/). *Why is this still a novelty!?* 6. A systems programmer unapologetic about his love for JS. A JS programming unapologetic about his love for systems programming.
From my experience, it isn't even so much about learning syntax as just getting all the boiler plate code right. Based on that example it takes a couple hundred lines of code to get something to show up on the screen with Amethyst. That is really quite reasonable for this sort of library as it is necessary to expose all the knobs and configuration options available, but it is more than I'd want to try to type out by hand just from reading documentation. Personally I start a lot of graphics projects by taking some tutorial code that renders a triangle and then incrementally adding/swapping out pieces so that I always have something that compiles and runs without errors.
It really depends on exactly what you're trying to do. This \*might\* be the right call. Design questions are hard, because what you're asking is basically "I want to do this, is this how to do it?" when the actual answer may be "you don't need to do this, you can solve the problem by doing that."
I think that the cost of adding another tool just for creating a project is greater than the benefit of lightweight boilerplate being added for you. &amp;#x200B; Systems like Unity can get away with it because the editor consumes your entire workload, and is very heavyweight. For now, I think amethyst is too lightweight to convince me to download a separate project just to get started. I personally prefer just starting with \`cargo new\` and going from there. &amp;#x200B; Generally, I don't like projects that believe they need special treatment to be used, and if Amethyst continues with having so many different things to download just to get started, then I think it will bog it down. &amp;#x200B; Anyways, that's my opinion. As long as Amethyst is still easy to write the boilerplate by hand, I think I will be content without any of these helper tools.
Yeah, if the project's goal and methods differ from the community's expectation (as seems to be the case here), simply stating them plainly in the front page should be enough to close any further discussion. In this case, the author could simply state that performance is paramount and that `unsafe` is used liberally wherever he feels like it. You don't like it, use something else. Bam, case closed, next. What happened here is that someone else had to write an article to tell about the author's choices and preferences after discovering them the hard way. We could have saved a whole lot of drama had these things be stated upfront.
Never too soon! One of my main goals here is to just show what is possible and inspire others to get involved. This PoC is &lt; 2 weeks old and quite basic but over the next week I will put some serious thought into helping people get involved.
&gt; I just do not have the energy to do it. That's ok, I have a bad habit of writing too much, and need to practice being more mindful as I know the usual response(often lack of) is a result of not being terse. &gt; I was one of the first to publish crates on crates.io, and I haven't stopped since. Yeah, I know of you :) (who doesn't if they have used Rust enough ha) &gt; what does that suggest about the effectiveness of ideas like that Well the beta status of their sub-crates doesn't help with that I guess, but I don't think ergo is well known or easily discovered compared to the usual crates users are aware of and go to instead. It's the better approach if you want to reduce/consolidate dependencies, doesn't mean it'll be popular / well adopted. &gt; or "just collaborate" to me suggests you might not have spent enough time in the trenches. Not much in Rust, a fair bit in JS. Again, it's the ideal approach, not that it'd necessarily work out. In JS I've had to deal with bugs that were several dependencies down the chain and the maintainers refuse to address it due to LTS and the fix being another dependency that introduces a breaking change, so instead, it had to be worked around for the mean-time(not for my project but a popular framework I use where some tests turned out to silently fail in the CI). I also recall in 2016, a popular websockets library appeared to have only one maintainer whom had moved onto other projects, they were the kind of developer who was very active on Github with many projects they maintained and several organizations, pinging them was ineffective even out of github notifications. I think it took 6-12 months before the PR (very small and simple fix, a version bump of a dependency I think) was merged, with a really long thread of many devs wanting the PR merged and desperately trying to reach the maintainer so a feature wasn't broken anymore. Others had worked with a fork or adopted an alternative library. &gt; All of those things have been possible, but nobody steps up to do it, because collaboration is super hard work. I'm not terribly great at it myself, and tend to thrive more in environments where there's a clear sense of code ownership. I understand, it can also be less motivating due to how much friction it can introduce. Case in point, [this gatsby-image PR](https://github.com/gatsbyjs/gatsby/pull/13395) that I provided code review for over several months. Some of the core maintainers self-approve their own PRs before tests even complete in the CI letting bugs slip in. Other experiences are investigating causes of problems with a project for a user or myself because the maintainers are interested enough to justify the time to potentially identify the cause and resolve it. Even then some won't bother to resolve an identified cause unless you also have the code to resolve it, and maybe not then either. Does that count as in the trenches? :P &gt; In my opinion, while tooling will help with some stuff, the best solution to this problem would be a cultural shift in how we look at dependencies. I still think it's a maintainer issue rather than dependencies themselves tbh. &gt; Cultural shifts are uncomfortable Yes, but it helps when there is a more clear solution/alternative that's being encouraged as a result of that shift. Reducing dependencies(by consolidating them?) doesn't necessarily resolve the issue. &gt; /u/dpc_pw made the good point that a better metric for my concerns would be "number of maintainers" or "number of umbrella projects." But we don't have any good tooling to discover that. That does sound a bit difficult to do accurately in an automated fashion, especially since it's not platform specific. &gt; In general, I'm more of a "do the best with what we've got" kind of person, and don't really care about things like "well yeah, we could have tooling to solve x, y and z." At least, not in the context of this discussion. Fair enough. Don't get me wrong, you've made good points for why something needs to be done about the situation, it's just not clear how we *could* solve that effectively.
Try compiling with the nightly compiler (just run `rustup default nightly` before `cargo build`) - rustc release after release tends to be a little bit better on CPU and memory, so it might just work for you.
&gt;fafh I'm not sure I can pull this comment the way I want but here we go: &amp;#x200B; You have put your effort and your ideas in the wild wild internet. You made a very successful framework that for people like me felt like the FW to go if I wanted to use one with fairly good documentation, big community, and with a bunch of examples and blog posts to get started. I don't believe we need more FW as I said because it was really confusing on which one to pick at the beginning, nobody wants to feel like they are gambling when choosing for a FW and hopping that it doesn't go stale and then disappear. Happened to me many times and even if this time was for a small personal project, I wanted to feel that the FW I was picking will be relevant 1 year from now. &amp;#x200B; Now talking about the OP blog. These kind of thing happens all over the opensource community. Somebody makes a ton of effort putting something together in his free time and make it free for other to use and more important they can make a living using what you give back to the community (this is equally true even if a company makes an opensource project). And paying attention to the amount of effort to maintain a big successful project is, there will always be people trying to make their own project or their own ego bigger attacking your project as being shitty. You must overcome those "critics" and keep going. &amp;#x200B; Saying that so, I don't believe that blog had a malicious intention. I feel like he is only mentioning things that can be improved and change. That is the pursue we have as engineers, we want things to be better, cleaner, delightful; and we can only achieve that with honest feed back. Yes yes... maybe it wasn't put together in the best way... maybe it was and attack or at least it felt like it. BUT it is feedback nonetheless, points that you can embrace and improve in the future. &amp;#x200B; Coming from Ruby, where Rails is THE framework to go. Everybody talked about how shitty it was, but it become a standard. And for beginners that safety net knowing that other people use that FW is priceless. Rails heard all the criticism and they keep improving every version they pull out. They made it more modular, better performance, better routers, better everything. You can only achieve that hearing critics. &amp;#x200B; TL;DR Let the community around Actix-web grow, hear them, let them add things to your beloved work; pay close attention to critics "are they making a fair point even if they are attacking my work from a comfortable place?". Look at other project to get inspired. What is important for you and actix-web? &amp;#x200B; I hope you capitalize on your hard work and this success you have with the FW make you grow as a person too. This happens everywhere, even to Linus (with different topic but happens) &amp;#x200B; Hope my words help.
&gt; They're quite different libraries. glam is a linear algebra library (e.g. vectors, matrices) that happens to be implemented in SIMD under the hood. Oh, I didn't realize that(I've not used either yet). So, generally if I'm wanting to work with vectors or matrices and would like the benefit of SIMD, glam is the only project offering such presently? And then if I wanted to further benefit from SIMD, I'd have to go lower level with faster? I have some older projects which work with vertices with x,y,z positions or rgb vertex colours(both stored in a struct), and thought about looking into SIMD as a way to improve it further at some point. glam would be good for that right? Is it compatible with other crates that use vectors/matrices? Another project that also works with 3D data uses nalgrebra iirc(haven't touched it for about 2 years).
Ah I see, thank you for the clarification!
I think you might be under-valuing culture here. Culture has a ripple effect and molds ecosystems, especially for core libraries that everyone depends on. Right now, I just happen to think we lean a bit too far in the "it doesn't cost anything to add a new dependency" direction. If I had more time/energy, I could elaborate on the impact that culture has on the ecosystem today. Hell, this entire thread about actix is blowing up precisely because actix doesn't really fit into the assumed culture of the broader Rust ecosystem.
You can try to reduce the build parallelism with the `-j` `cargo` parameter, and with the [`codegen-units`](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units) `Cargo.toml` setting. How much RAM does your builder have?
Indeed, while we definitely want to be careful with our words, the MSRC is explicitly endorsing the usage of Rust *where appropriate*. Stay tuned for me posts in the series that will go into more depth on this point.
Yeah, that makes sense, too. As a relevant example, some of my friends became frustrated with all the boilerplate required to record, edit, and stream audio. They kept getting little things wrong that were hard to find and fix, and they ended up quitting that project and just going to python.
Ah, yeah fair point with the concern of long dependency chains. I've been bitten by that a few times with NPM packages, along with maintainers that stop maintaining a project(but are so busy/active on Github that the notifications feature is ineffective at reaching them for a PR that updates a dependency or some other small one line fix that fixes a breakage(eg I think one for websockets happened on newer versions of NodeJS or something). I've also had to maintain some personal forks with small changes for months in the hope they'd get merged upstream, worsened when it's a project that gets updated often, especially if the area you've patched is getting actively worked on and causes conflicts. Projects with many open PRs lingering based on scale/activity is one of my red flags rather than their number of dependencies. &gt; If I see a huge number of dependencies being hauled in, the value of the crate sure had better be greater than my effort to check through them all. What's your opinion of crates like rendy which split out a bunch of sub "rendy-*" crates vs that all being in the rendy crate itself?
How does the overload crate work? I was expecting calling the function to be a macro but it's not, only the definitions are inside a macro...
I think I'd be fine with sub-crates from the same maintainer or project if it all looked like good programming practice.
&gt; If I had more time/energy, I could elaborate on the impact that culture has on the ecosystem today. That time/energy would be better spent in it's own blogpost shared to the subreddit, rather than in response to me or a thread in r/rust that'd lost it's reach over time. &gt; I think you might be under-valuing culture here. Possibly. Although I've been programming for a few years and reasonably experienced, I haven't had much opportunity to work at companies with other developers, the only cultures I know are the "professional" ones that don't value/respect me as a developer by paying peanuts and treating poorly, or won't consider me over a university graduate for lack of degree. Communities, I'm fond of Rust and JS, I was at one point trying to get into C# but the culture of those communities seemed to attract a certain type of developer that I found unpleasant, not sure if that's changed over the years, it was especially the case for Microsoft oriented devs that bought into their stack/software.
This is _really_ nice! I just took over maintenance of itertools; unless you have any objections, I think the documentation to `Itertools::group_by` should probably mention your crate.
Cool, I had looked at this a while ago but I think it wasn't yet a standalone project.
I did that on my windows 10 as the os, but still its showing the error.
This is really nice on the eyes
That generally should not be a problem (it's a day event anyway).
Cargo bloat definitely looks interesting. From what I think I know, rust already strips out stuff it knows isn't needed, so this would do everything I'm looking for. But it's definitely a good start - thanks for sending that my way :)
I’m following your work on GitHub. After the battery crate it is a very nice project. Congrats!
That sounds great, thanks I will look into it. Is it expected that you are going to compile your project from source on every single system that you want it to run on, every time there is an update? With Python/R/shell etc., the version-controlled script in my repo is the program. What is the general method for getting your updated program to the places where its supposed to be running? `git pull` then `cargo build` every time?
No one owes Actix any adoption. No one owes Actix a zero competition ecosystem. But I’d argue that we owe each other respect and compassion in our communications. Something which I feel was lacking in the earlier blog post of logic-focused criticisms.
You can't return an arbitrarily long array like this. You need to either return a reference to it (which won't work because it gets dropped immediately after), or return an owning container like a `Vec`: fn listen(socket: UdpSocket) -&gt; (Vec&lt;u8&gt;, SocketAddr) { let mut buf = vec![0; 100]; let (amt, src) = socket.recv_from(&amp;mut buf).expect("no data received"); buf.truncate(amt); (buf, src) }
This is why unsafe is so dangerous: it's very to think we covered all use cases. As an example, make some `ServiceCache` that holds services in a `Vec`, and you turn it into a `CloneableService`, to share the cache. In `poll_ready`, you grab a reference to last item, and call `poll_ready` to see if you could reuse it. If you've given a clone of the cache else where, and that ends up being the last in the Vec, you'll be call the mutable `poll_ready` while already inside a mutable function of the clone. Say the clone then checks the current time, and decides the cache is expired, and clears the Vec. When it returns to the first call, you still have a `&amp;mut Service`, even though the memory it's pointing to was just freed. If you call any other method on it, you now *hope* it triggers a segfault, instead of wrongly modifying some unrelated object.
You are attacking a straw man. Parent distrusts devs who are 'too eager to use unsafe'. Using unsafe *without* good reason is indeed casting doubt over the quality of a crate. In the best case (and I believe this doesn't even apply to all of `std` as of now), unsafe code is well-documented with regards to it's invariants and preconditions for safety. When a crate maintainer closes a PR that replaces unsafe code with safe code without any ill effects (e.g. on performance) instead of merging it, a constructive discussion how to deal with that is certainly acceptable, nay, advisable. Perhaps the project needs some help? If so, let's organize it. By misrepresenting the argument, you try to stifle this discussion.
It creates a new struct and implements the Fn trait multiple times
There's always reader mode.
I doubt he has goals about unsecure framework, of course he wants his framework to be secure. It's not wise to make the project "community driven" when meaning, a pr is sent, even as the main developer, he must accept it because it therefore comes from community. Good or bad decision (in the moment), he weighed the pr. It also seems like you speak for some "community", but I'm not sure how you earned that.
You can return the `Vec`: fn listen(socket: UdpSocket) -&gt; (Vec&lt;u8&gt;, SocketAddr) { let mut buf = vec![0; 100]; let (amt, src) = socket.recv_from(&amp;mut buf).expect("no data received"); buf.shrink_to_fit();// &lt;- optional (buf, src) } Or you could return a boxed slice: fn listen(socket: UdpSocket) -&gt; (Box&lt;[u8]&gt;, SocketAddr) { let mut buf = vec![0; 100]; let (amt, src) = socket.recv_from(&amp;mut buf).expect("no data received"); let boxed = buf.into_boxed_slice(); (boxed, src) } The big difference is a `Vec` can grow, a boxed slice can't.
I started up r/RoboInstructus because there didn't seem to be one.
True, but – and herein lies the rub – even those low-quality hobbyist crates are as memory-safe as Rust's `std` allows them to be. While there were bugs in the past (and likely more will be found in the future), there are people dealing with them in a responsible way. So, compiling a crate of low quality without `unsafe`, you are very likely to not hit any memory bugs. Also if your argument is that people should understand unsafe code before commenting on it, you should perhaps prove that you understand it first. Even seasoned C developers get some parts of UB wrong with alarming regularity.
&gt; A developer’s core job is not to worry about security but to do feature work. But security is part of the feature. Is this just a MS stance, that security comes second, or third, or maybe not this sprint as it's not part of a MVP?
Worked. Thank you
Very helpful. Thank you.
That makes more sense. From you original comment I thought you were against having example applications showing basic usage of a library which seemed a bit extreme. On the other hand, having a dedicated tool just to download those examples seems a bit... well... redundant with git / copy paste.
&gt; Is it expected that you are going to compile your project from source on every single system that you want it to run on, every time there is an update? No, there's absolutely no need to do that. If all you want to do is run the project, you take the (statically-linked) binary and execute it. The poor-man's deploy is not `git pull`-then-`cargo build`, it's `scp executable target_host`. The only usual dependency is libc. &gt; Obviously you cannot put the compiled binary in your git repo, right? It's not a good practice because it bloats the repo, but it would work as a distribution channel. Anything that can copy bytes (and maybe check a checksum) would work too.
While these crates are very good, I still miss the options of [gengetopt](https://www.gnu.org/software/gengetopt/gengetopt.html)
I work in \*\*a lot\*\* of old(er) code, so I've been slugging through a tool which helps you understand existing C-family codebases. I'm trying to target use cases where an LSP-based tool won't help much. &amp;#x200B; It's along the line of the ideas in this book: [http://scg.unibe.ch/download/oorp/](http://scg.unibe.ch/download/oorp/)
What do you mean by RFC? I tried searching for it and found remote function pointer. I can't find an explanation for what that is, but I'm not sure what you mean by it in this context. I would appreciate a clue. ;)
Rust uses an “RFC process” to manage additions to the language. It’s short for “request for comments”. You can find them at https://github.com/rust-lang/rfcs
Rustup allows user-level installation: https://github.com/rust-lang/rustup.rs/#choosing-where-to-install Seems like you could let your management script take care of setting the required environment variables up, then calling rustup-init as part of install, if you wanted to keep using your management script.
Well in the post I replied to, you said &gt; even if you try to use perfect forwarding [...] you will get an intermediate allocation "Perfect forwarding" is `template &lt;T&gt; void set_name(T&amp;&amp;)`. The `void set_name(std::string&amp;&amp;)` thing is not perfect forwarding. And actually, with that variant, if you also provide an overload for `const &amp;`, which you should, then it avoids the unnecessary allocation. These possibilities are called "option 4" and "option 2" respectively in the Herb Sutter talk I linked to in my original post. The timestamp is 1:06:48 where he starts talking about this example. The whole talk is very good though, I highly recommend watching it.
Hey check out r/RoboInstructus
Bro stupid people are always gonna exist. You can't satisfy everyone. Welcome to the internet. But try to give your best and keep on going forward!
Okay, I agree on that his answer in PR was pretty... strange, I would say. But it must not be the reason to attack My personal opinion is - it's open source. Don't like something? Fork it and do it better, if you think you can't. Or try to push your idea and why your PR is valuable in more adequate way
This is amazing. Is there a documented list of guidelines to structure large projects in a way that is friendly to compilation time?
You would probably use a trait (see https://doc.rust-lang.org/1.8.0/book/traits.html), but depending on what you're doing, you might just want a `Box&lt;u8&gt;` to store a generic series of bytes
What could be worse is that LLVM gets updated, or `rustc` gets updated and that breaks `actix-web` in some hidden way (because `actix-web` depends on UB), and that causes some huge exploit or leak of data, and then the blame game starts. So we absolutely have to be clear the whole time that UB and other invalid uses of `unsafe` are completely unacceptable in Rust. No-one can help `actix-web` if its maintainers are unwilling to meet the requirements that `rustc` demands of it, i.e. if it doesn't keep the contract with the compiler. Really the Rust community needs to stay loud about Actix until it gets its house in order, or makes it clear to all its users that its `unsafe` use isn't safe, and they'll have to take their chances, because Rust could get pulled down with it. News headline: "#1 Rust web framework hack leaks 300M credit cards" ... then what?
That is very sad. I understand that some people may not like his approach to unsafe code, but that kind of attitude is simply unacceptable. I would guess most of the people who wrote those comments and emails didn't even know about the issues before a recent post brought it to life. This will eventually lead to people not being able to discuss issues of the rust ecosystem openly in the community, and that is worse for everyone.
&gt; Go use something else that doesn't cheat on benchmarks This completely unnecessary jab of yours invalidated your entire post, as far as I am concerned.
Most flexibly the [Any](https://doc.rust-lang.org/stable/std/any/trait.Any.html) trait allows emulating dynamic typing in Rust. But you may want to consider generics instead.
Traits might be the solution. However, sometimes I like to use enums. struct MainStruct { known_data1: uint32, known_data2: String, unknown_data: UnknownDataKind } enum UnknownDataKind { String(Box&lt;String&gt;), VecOfI32(Vec&lt;i32&gt;) // ... add more types here }
A bit related but not directed at the dev: why are people that are always suggesting the neutral approach to any open source issue of `Don't like it? Fork it.` the ones that cannot ever have a similar approach for this kind of stuff? `You are getting insulted over the internet? Ignore it.`
What is the best way to let him (and others) know that there are people like me that do appreciate what they have done and don’t think they’re shit?
This is a thing of beauty.
Thanks for the detailed explanation! I appreciate that you took the time to write that. Is it actually impossible to create an &amp;mut str? Or does the compiler allow it, provided there are no other references to that data at that point in time?
This is absolutely unacceptable behaviour not only from an ethical perspective but also from a Rust perspective. There needs to be an environment where people feel able to create and share software without fear of harassment. Please stop, this is not okay.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/c64] [Running Rust code on the Commodore 64, by xTibor](https://www.reddit.com/r/c64/comments/cef5qr/running_rust_code_on_the_commodore_64_by_xtibor/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; He just doesn't really care that much about Rust's safety guarantees and likes to use unsafe cause he's confident he knows what he's doing. So at this point he's just annoyed at what he perceives to be the Rust community's overly ardent stance against the use of unsafe and their critique of his coding style and he's telling people he's not interested in dealing with this issue anymore. We do seem to divide into two camps: those who are here for the safety, and those who are here for the performance.
If you know exactly how many kinds of data: Use a enum: &amp;#x200B; #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)] pub enum Scalar { None, //null Bool(bool), //Numeric I32(i32), ISize(isize), I64(i64), UTF8(String), //Complex Row(Vec&lt;Scalar), Vector(Vector), } If you don't, need to use traits + boxing with Rc or Box: pub trait Value { fn kind(&amp;self) -&gt; DataType { DataType::Any } fn as_any(&amp;self) -&gt; &amp;Any; fn as_scalar(&amp;self) -&gt; Scalar; } And you can combine both: pub enum Val { Value(Box&lt;Value&gt;), Scalar(Scalar), } This last one revelation was recent for me :).
The whole point of Rust is to be able to have both. The issue being raised is not unsafety; it's undefined behavior.
I find this post hilarious considering you're the spark that caused this to happen.
You're forgetting two others: [https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#unsafe-superpowers](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#unsafe-superpowers)
Well, /u/cuulcars, it seems like your idea has come to fruition! &amp;#x200B; [https://www.reddit.com/r/rust/comments/ceewrd/running\_rust\_code\_on\_the\_commodore\_64\_by\_xtibor/](https://www.reddit.com/r/rust/comments/ceewrd/running_rust_code_on_the_commodore_64_by_xtibor/)
This isn't a "rust community" issue, but "generic internet community" one.
UnsafeCell is a language item; the language itself changes its behavior when used. That's much more than simply marking a thing unsafe.
&gt; mIs anybody building a really solid static file server? Like, just, static files? Maybe with some cache control headers and range request support? And without trivial directory traversal exploits? Plug: my [http-serve](https://crates.io/crates/http-serve) crate will handle range requests and conditional GETs for you. This is just one aspect of a static file server, but it's the one I happened to need.
&gt;There are hooligans that show up at sports events, so stop all sports events?
I use actix in production and it makes me uncomfortable.
No reasonable person would look at the article and conclude that this behaviour is a good course of action. At no point did I incite or condone this sort of thing; I have explicitly criticised such behaviour and will be updating the post to reflect that.
Such messages are unacceptable in absolutely every situation! Nevertheless, I think it would be jumping to conclusions to say that this is reflective of the "Rust community" - whatever that may mean. It is examples like this which really makes me appreciate this subreddit and its moderators. The recent discussion around actix in these parts of the internet were civil and reasonably argued; at least in the vast majority of comments I saw. Might be due to the moderators though, but that would only show that the messages the OP showed here are unacceptable at least in these parts of the "Rust community".
Why make positive contributions to open source when you can just be an unforgivable dickhead to volunteers instead? Seriously, if you don't have something valid to contribute, then keep your trap shut. These people aren't your private software army.