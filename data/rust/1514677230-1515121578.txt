I'll try to give as much information as I can think of: Windows 10 Pro, AMD FX-8350 (8c/8t) 4.00GHZ, 16GB RAM First tried with 1.23.0-nightly (45caff88d 2017-11-11) initially, then updated to 1.24.0-nightly (2dad872a2 2017-12-29) nightly-x86_64-pc-windows-gnu toolchain cargo test ran fine, both without and with pure-rust. Both cargo test and the initial benching seems to be quite slower with pure-rust (roughly 60% speed or so). I get the same overflow issue with and without it, and always at the same bench point (this is very much not my expertise since I'm still very much a hobby programmer, is it simply a RAM issue?): encode : shards : 5 / 2 shard length : 1000000 bytes per encode : 1024 time taken : 0.394679593 byte count : 2500000000 MB/s : 6334.251996656944 encode : shards : 5 / 2 shard length : 1000000 bytes per encode : 2048 time taken : 0.406358621 byte count : 2500000000 MB/s : 6152.201210467244 encode : shards : 5 / 2 shard length : 1000000 bytes per encode : 4096 time taken : 0.368377622 byte count : 2500000000 MB/s : 6786.514301349173 encode : shards : 5 / 2 shard length : 1000000 bytes per encode : 8192 time taken : 0.371545058 byte count : 2500000000 MB/s : 6728.65900425999 encode : shards : 5 / 2 shard length : 1000000 bytes per encode : 16384 time taken : 0.339782974 byte count : 2500000000 MB/s : 7357.637643138646 encode : shards : 5 / 2 shard length : 1000000 bytes per encode : 32768 time taken : 0.357458667 byte count : 2500000000 MB/s : 6993.815595468553 encode : shards : 5 / 2 shard length : 1000000 bytes per encode : 65536 time taken : 0.3284658 byte count : 2500000000 MB/s : 7611.142469018084 encode : shards : 5 / 2 shard length : 1000000 bytes per encode : 10485760 time taken : 0.591360652 byte count : 2500000000 MB/s : 4227.538628998941 ===== thread 'main' has overflowed its stack error: process didn't exit successfully: `target\release\rs-bench.exe` (exit code: 3221225725) As I understand there's no way to backtrace when it overflows, and I blindly followed a SA answer and tried to use GDB, not sure if it helps much at all since I have no idea what I'm doing: [New Thread 15692.0x4910] [New Thread 15692.0x43f8] [New Thread 15692.0x5f8] [New Thread 15692.0x40a0] [New Thread 15692.0x40e0] [New Thread 15692.0x3fec] [New Thread 15692.0x3eb4] [New Thread 15692.0x433c] [New Thread 15692.0x3bf8] [New Thread 15692.0x3af8] [New Thread 15692.0x4a00] [New Thread 15692.0x3df0] &lt;... print output&gt; Thread 1 received signal SIGSEGV, Segmentation fault. 0x00000000004aa9f6 in ___chkstk_ms () at src\rustc\compiler_builtins_shim\../../libcompiler_builtins/src/x86_64.rs:15 15 src\rustc\compiler_builtins_shim\../../libcompiler_builtins/src/x86_64.rs: No such file or directory. 
same here on Linux + Firefox
I will leave the details to more experienced low level hackers. (My background is in Python. So I don't know much about SEGV and its friends.) But if I had to debug an inexplicable crash in a bench test... I'd try to convert the `#[bench]` test to a `#[test]`, apparently this benchmark exercises some corner case that you are not testing directly. Then I'd run that test in isolation. I'd go straight to adding print statements to try and isolate what is going wrong. If I am not seeing the print from my test I'd try adding the `--nocapture` argument. In General I'd try for a binary search of code, add a print in the middle of the test, if it runs add a print half way in what is after, if not then half way in what is befer. In this case I may jump straight to adding a print statement before every unsafe. As you know that is where this bug is occurring.
Ah, thanks!
I used the wrong term; rebinding in the same scope rather than a child scope
Ah right, yes the `benchmark_encode_inplace` uses stack allocation for the data before encoding, while `benchmark_encode` uses heap allocation. On Linux and Mac the stack allocation seems to be a lot more generous, so that's probably why it worked on my end. I've commented out the corresponding lines and pushed to the GitHub. Could you do a `git pull` and give it another shot? &amp;nbsp; Many thanks!
I'm not arguing that "integer overflow is harmless on x86", I'm well aware of UB and its consequences. I'm arguing that the statement "`printf` is not guaranteed to execute" is not correct – you seem to agree, the compiler might do it via a tail call or whatever, but the print will happen before the program can delete your hard drive.
Agreed I would like to know as well.
what does all this "unknown-unknown" jazz mean? it looks whacky.
References to the initial binding are retained so it doesn't look like it. https://play.rust-lang.org/?gist=60c7f8e1f8687385498c8f3dac8f038b&amp;version=stable Also some info here: https://stackoverflow.com/a/40628035/1930535
I understand the distinction perfectly well. But that text does appear in the RFC, so it's not correct to describe that restriction as "mythical." Things like underscore being disallowed in host names are what allowed later specifications like the SRV specification to use underscore prefixed labels without worrying about collision. Anyhow, underscore is not really the issue here. All of those same compatibility concerns with existing concepts of hostnames are why you can't just use arbitrary bytes in DNS hostnames, despite DNS itself not having any such restrictions. Protocols like SMTP, TLS, HTTP, etc, and all of the various implementations of the above, would have to be updated to support any hostnames that don't follow those old rules. Punycode is a reasonable hack for allowing backend systems (including many "middle layers" that are often present for many years without substantial updates) to still process hostnames following the old rules, while giving user-facing applications a way to process and display the full Unicode range (though initial versions were not great as they specified only a particular version of Unicode which was soon out of date). All of this is just a way of saying that treating DNS names as UTF-8 strings is not really useful. They should be treated as byte strings, with ASCII case folding only for matching, and if you want to allow arbitrary Unicode code points be used, Punycode is more likely to be of use than treating strings as UTF-8, but if you're doing anything other than allowing restricted identifiers and escaped octet values, it should probably be explicit and opt-in.
The ocean demo [doesn't seem to compile.](https://github.com/msiglreith/gfx_ocean/issues/3)
Do you think there is room for collaboration with vulkano.rs, or are the projects different enough that they ought to be separate? If they are different, can you explain what gfx-rs's goals are, and they compare with vulkano's? 
`--features` is what I was missing. Thank you!
[Absolutely](https://github.com/vulkano-rs/vulkano/issues/525)! gfx-render is going to be a higher level portable alternative to Vulkano, but nothing technically prevents Vulkano to use gfx-hal instead of raw Vk. A simple way to achieve that would be to link against gfx-rs portability layer, exactly like it's done for MoltenVK. It's unfortunate though... because why whould two native Rust libraries need to talk to each other across C linking boundary? It would be much nicer to integrate the two directly, but that would require more changes on Vulkano side, and Tomaka is reasonably not thrilled about this.
There's several flavors of web assembly compilation targets. Since web assembly is a browser tech, it doesn't really have a target platform (that's the first unknown) , and wasm32-unknown-unknown doesn't have any out of box supporting libraries, that's the second unknown.
Oh my bad. I must have misread the thread. You clearly do understand the distinction. My apologies.
No problem, I wasn't particularly clear in my original message, I had just been trying to point out that there was nothing "mythical" about the restriction, but didn't provide a lot of context for why I was saying that.
&gt; a ***well-designed*** general purpose language We aren't talking about golang /s
Drops happen at the end of the scope. This prints "rebound" followed by "dropped". struct D {} impl Drop for D { fn drop(&amp;mut self) { println!("dropped"); } } fn main() { let d = D {}; let d = (); println!("rebound"); } 
Why not port the vault that is receiving widespread adoption - hashicorp vault? 
Oops, we'll fix it ASAP ;)
&gt; We’ve just released a long-awaited gfx-0.17 featuring numerous fixes and improvements, including the WebGL2 support via wasm32-unknown-emscripten target. What This is real SWEET!
Isn't vulkano supposed to be a safe wrapper around Vulkan? Then, wouldn't gfx-rs actually make use of Vulkano as a safe wrapper around Vulkan, rather than implementing its own Vulkan wrapper? 
https://clang.llvm.org/docs/CrossCompilation.html#target-triple
Thanks for filing the issue! Updated to latest master, but dx12 crashes atm. Vulkan should be running fine.
With `portability` we expose a driver implementation (soon) for vulkan with gfx-hal. The chain would be `vulkano -&gt; vulkan (portability) -&gt; gfx-hal -&gt; vulkan/dx12/metal/..`
I started working on a port of python's pathlib to rust, but I have a lot going on. If you'd like I can make it public on github and give you commit access.
`rustc src/lib.rs -L /path/to/deps` for each one, place the generated rlibs in the same deps folder. `cargo build --verbose` will also give you all the flags you need, but a lot more of them too.
I think so. https://www.reddit.com/r/rust/comments/7ilq3d/pain_point_working_with_paths_and_arguments/?st=JBU5ZN3A&amp;sh=f2cc842b I've been working on a pathlib port to rust but I've got a lot going on. Let me know if you want to help out. Although it sounds like this may be more of a band-aid to the need to flesh out functions in Rust's Stdlib.
thanks!
So far, so good. I guess we’ll have to wait a little longer to find out.
&gt; If it's sometimes valid and sometimes not, you could use from_utf8 first and then if it returns an Err, use from_utf8_lossy. Why do the extra overhead? Both functions do the same checks, but the prior will return `Err` on non-UTF8, the latter will convert non-UTF8 sequences to `U+FFFD REPLACEMENT CHARACTER` and return a `Cow&lt;str&gt;`. It clones the input if it's non-UTF8, and reuses the reference to the original slice if it's valid UTF8. In other words, if you have data that's sometimes valid UTF8 and sometimes not, and you want Rust to gracefully handle the non-UTF8 characters, just use `from_utf8_lossy`.
I'm not hugely familiar with `gfx-rs`, but I would guess that `gfx-hal` operates at a lower level than the wrapper that `vulkano` would provide, meaning it would be easier for `vulkano` to wrap around `gfx-hal` than for `gfx-hal` to wrap around `vulkano`... but this whole discussion seems moot. I doubt either team is going to be convinced to become dependent on the other at this exact moment. They're trying out different approaches, and the winner is likely to be determined organically -- or they could both fill different roles in the community and both become established libraries for different purposes.
Maybe I’m wrong but I think because it’s one of the first introductory Rust books in print now. Plus O’Reilly tends to put out quality programming books. Rust programmers have fairly limited options right now. I’m still waiting on mine. :) 
We being?
I can’t speak as to why this is a good book for everyone since I’m barely more than a few chapters in and still fairly new to the Rust language, but I’m happy to share my impressions so far. My first reason for buying and waiting months for this book is simply because it’s the first book on Rust from O’Reilly Media. I’ve gotten a lot of value out of the “animal” books on other languages and trust that I’ll develop a stronger understanding of Rust as I work through this one. Aside from TRPL (which is excellent in its own right), resources offering a comprehensive deep-dive on the mechanics of Rust, how to write idiomatic Rust, and best practices are still sparse. Programming Rust is an all-in-one tour of the language that doesn’t have some of the conceptual gaps that are unfortunately left in TRPL. The writing is of course great, having been written by systems programmers with a comprehensive understanding of Rust. The chapters are academic without being too dry while also managing to be conversational without distracting from the goal of explaining the ideas thoroughly. The authors expect at least a basic grasp on some lower-level concepts but nothing someone coming from another language couldn’t easily pick up. The example code is well thought out and leaves plenty of room for play. I would probably be a bit further in the text if I didn’t experiment so much after something explained in the book clicks with me, and that’s not a bad thing. For someone who already has a strong foothold in the language, I’m not sure this book would be as valuable as it would be for someone still getting familiar with the ideas and mechanics behind Rust, outside of solidifying core concepts. I think most of the people who pre-ordered the book, myself included, are hopeful that this book will be the K&amp;R of Rust. TL;DR - Programming Rust offers a unique approach to learning the language from all angles in a way that I haven’t found in the official docs.
Every binding basically generates its own implicit scope, so there is no difference.
Wasn't K&amp;R special because it was written by the pair who implemented the language they were writing about?
Yep, Dennis Ritchie designed and implemented C. Maybe my analogy is a bad one - I just meant it as hoping this book becomes an authoritative reference the way C programmers think of K&amp;R. Although, given the authors’ history in the free software/open source realm, I’d be surprised if they haven’t contributed a bit to the language.
Kernighan wasn't a creator or implementer of C but given his other books I suspect the combination of Ritchie's expertise and Kernighan's writing ability are what make that book so enduring (and that C changes slowly keeping it from becoming obsolete).
It's just part of how the Rust iterator protocol is defined -- you don't have to have access to the next element until the user calls `next`. For example, the iterator could be loading data from disk on demand, or calculating the new value (e.g. `std::ops::Range`).
That was what I was looking for. Thank you 
`cargo bench` should generate an executable somewhere in target/release which you can run independently. Once you find that, run it under a debugger. If you have `gdb`, `gdb ./target/release/...` should get you into the debugger, then `run` to run the program, then `backtrace` to get a backtrace after it crashes.
Nice! Do NetworkManager plugins have a language agnostic api to code against or do you mimic C?
Here is a survey on syntax proposals for Rust. Please help by answering if you have the time. Please also do not spread the survey. For those of you who know what the survey is about, also do not post what it is about as that would bias the sample.
Unfornately all of your graphics options in Rust will have gotchas for some time. I don't think webassembly is a good idea for anything serious at this point. I'm working on a generative art toolkit and I started with gfx-rs but switched to glium recently because it has some features gfx-rs doesn't have yet. I would brace for maybe switching at some point, maybe more than once, if your project will live for some time. How SPIR-V ties into your project I'm not sure, but if you're suffering some kind of analysis paralysis right now it's always cheaper to choose wrong than to not choose; just do something and if it doesn't keep you interested and learning switch to one of the other things.
Meh, kotlin is just Java with sugar and IDE. The type system remains untouched. It's OK if you're doing android apps, i guess. If you're going to go JVM and skip Java, might as well go all the way to Scala, Clojure or Ceylon.
The other answers made good points already, but to understand *why* things are how they are you need to know that it's one of the core philosophies of Rust to catch as many errors at compile time as possible, and make code that results in things like your program crashing explicit and verbose. Having an inconspicuous symbol like the questionmark crash your program goes against that. I don't see anything inherently wrong with your proposal, but Rust is just not the language for that.
No, that would be /r/playrust.
I'm not a fan of the survey using Google's platform for several reasons: Because I missed the "this requires sign-in" banner at the top (too advert-shaped), I almost gave up because "these checkboxes are broken". (The checkboxes with grey border and white fill they used to mean "greyed out" is too similar to the "grey border and white fill" that native (ie. browser default) checkboxes use to mean "checkbox is interactable" and I mistook the greyed out images for simply a badly-designed (ie. low-contrast) syntax highlighting theme.) It also took me far too long to discard an incorrect intuitive leap because, on first read-through, I skimmed past the introduction text as "too small a font, relative to the rest of the content, to be significant". Also, if I weren't already active in giving feedback on RFCs, my response would have probably been "Oh, I have to sign into my Google account to do this? Never mind." (I try to avoid signing into Google through means other than IMAP or XMPP whenever possible. It's a hassle to ensure their cookies have been flushed once I'm done with whatever it is.)
I considered not requiring sign-in and discussed it with few other people, but I want to avoid the same person responding multiple times. The survey is perhaps not perfect, but it took at least an hour of work to put together including with the help of another person...
No. This is not true and needs to stop being repeated. The original LISP has little to nothing to do with the Lambda calculus, it merely borrowed the terminology "lambda" for anonymous functions.
Will there be a low cost edition for the Indian subcontinent? The current price for the pbook on amazon.in (INR 4670) is 5 to 10 times the typical price for such books.
It might be that they allow it specifically for these things but still won’t allow you to define your own labels with underscores. The topic came up in a discussion of using underscore labels for a new use case.
I think the vault is solving a different problem. Without getting into details, the hashicorp vault for example has 5 keys to unlock it. These keys must be stored outside of the hashicorp vault, which is where `s3/sheesy` comes in. Once this project has matured, one could certainly take it into new areas, even though I don't see that right now as I would want to solve a problem that isn't solved well enough yet. Hashicorp Vault seems to be liked by the people using it.
Honestly, the proposed weird syntaxes would be kind of a Rust showstopper for me. They are all terrible. Just make (let &lt;pat&gt; = &lt;value&gt;) be a first-class binding expression whose pattern scopes and lifetimes extend to the end of the enclosing block. Then you need no other special syntax, and you get a bunch of improvements besides the conditional special case. Our [Nickle](http://nickle.org) programming language has had a variant of this for decades (we don't do pattern matching, but we let (&lt;type&gt; &lt;var&gt; = &lt;value&gt;) be a first-class expression with lvalue &lt;var&gt;) and it's really convenient.
Right, there are faster ways of approaching this that people often use in practice (mtl/codensity/church free). Still, if runtime cost isn't an issue (e.g., when IO dwarfs computation costs), I always aim for Free. For example, when I make REST clients to access 3rd-party APIs, I usually use Free. Even when I don't end up using it in the final result, I almost always do the initial model with it. It's just so clean and simple compared to the alternatives, and I view its runtime cost as more of a symptom of a limitation of our infrastructure than a problem with Free itself.
Can you post the index pages?
That’s the fun part, if I turn that bench to a normal test, the test passes, it only crashes if I run it as a bench.
Are you using `rustfmt-nightly` ?
Yes I basically had 2 1 dimensional arrays (`a` and `b`) representing transformed into a matrix with column count `N` and I wanted to do a computation that maps the `i`-th rows of `a` and `b` into `a`: assert!(a.len() == b.len()); for i in 0..a.len() { a.row(i) = function(a.row(i), b.row(i)); } where `function` should just see the inputs as a 1 dimensional vector. To do this "idiomatically" IIRC I needed to zip `a` with `b` and 
Would be interesting to see if switching to a `char` iterator actually slows things down all that much if it operates atop a buffered UTF-8 file. Time for some benchmarking of my own, I guess.
you might be looking for /r/playrust 
Because this way, iterators don't have to calculate or fetch the first value until you ask for it. If you want to ask for it multiple times, `peek()` exists. This is really just part of how iterators are defined. If they allowed `curr()`, then they would necessarily have to calculate one item as soon as they were created. I don't see this as worth it: if you want the first item / current item, why not just make it peekable and call peek()?
But is it an expensive operation? Array access can be done in O(1) time, right? 
rust-url has this function. If your input is always a `Vec`, you could only keep the case where input is `Cow::Owned`. pub fn decode_utf8_lossy(input: Cow&lt;[u8]&gt;) -&gt; Cow&lt;str&gt; { match input { Cow::Borrowed(bytes) =&gt; String::from_utf8_lossy(bytes), Cow::Owned(bytes) =&gt; { let raw_utf8: *const [u8]; match String::from_utf8_lossy(&amp;bytes) { Cow::Borrowed(utf8) =&gt; raw_utf8 = utf8.as_bytes(), Cow::Owned(s) =&gt; return s.into(), } // from_utf8_lossy returned a borrow of `bytes` unchanged. debug_assert!(raw_utf8 == &amp;*bytes as *const [u8]); // Reuse the existing `Vec` allocation. unsafe { String::from_utf8_unchecked(bytes) }.into() } } }
Indeed it’s supposed to streamline the user experience when gpg is used for teams. To me this means that the common journey a user takes is easy to understand thanks to helpful error messages. As long as the gpg-agent program exists, s3/sheesy can be self-contained as it can eventually generate keys and/or deal with all the import/export/signing/trust business. From my experience with pass/gpg in big teams, this is sorely needed.
Wrong sub /r/playrust is what you are looking for
I generally sign into google in private tabs.
I'm comparing and contrasting existing solutions with this one as I try to understand what, other than the great choice in language, makes it unique. Hashicorp Vault was the first technology that came to mind because it is a secrets server and among the myriad vaults is the dominant one today (to me, at least). The other technology that comes to mind is the system keyring service. You're in /r/Rust where every discussion is as deep in the weeds as you could possibly get so please go into the details! You must be aware of the goals for using Shamir secret sharing. It aims to eliminate the chances that a single user can unlock a vault. 
From the looks of your screenshots you seem to be using nightly Rust. Nightly rust is known to be somewhat unstable at times. Try using stable Rust, instead of nightly. Good luck!
I didn't participate due to the requirement, fwiw. Not meant as criticism, I understand the need to prevent people from manipulating results, just as a data point.
I wouldn't implement it on `Vec&lt;u8&gt;`, as `Vec` has no business knowing about unicode encodings. I don't mind it being named `into` instead of `from`.
That is fair =) The decision certainly has its drawbacks!
sheesy (`sy`) is fine. I don't have a current need for this project but if I was searching for something to do s3 and spent time looking at this I'd be pretty annoyed. That said.... using `sy` to store Amazon credentials could be nice. :)
(/u/etareduce, am I allowed to refer to the original thread here or it's better avoided for purity of the experiment?) Reasons to not make `let PAT = EXPR`"as is" an expression found so far: - Breaking changes to common code due to operator priorities. - "To the end of the enclosing block" may be too long, spurious borrowing errors may appear. - It's ugly as hell in expression context.
Ok, some detail of the question wasn't clear to me. The input of the function is two 1D arrays? The output is 1 scalar, or a whole 1D row array?
&gt; Just make `(let &lt;pat&gt; = &lt;value&gt;)` be a first-class binding expression whose pattern scopes and lifetimes extend to the end of the enclosing block. Then you need no other special syntax, and you get a bunch of improvements besides the conditional special case. You know, I really like this idea. I think it is actually compatible with the survey (the `if &lt;expr&gt; &amp;&amp; let &lt;pat&gt; = &lt;expr&gt;` is similar, after all, although I wonder if there are possible parsing ambiguities). First of all, I am uncomfortable with special casing `if` without extending the same benefits to `while`. There is a reason that `if let` and `while let` were introduced at the same time, after all, and I'd rather have consistent usage. Therefore, I don't like `if let &lt;pat&gt; = &lt;expr&gt; &amp;&amp; if let &lt;pat&gt; = &lt;expr&gt;`, at least not without clarifying how it would like with `while`. Secondly, I am not too keen on the idea of using `is` for this. Apart from the `match` patterns, which are quite more elaborate, today pattern matching and binding is *always* using `let` with the binding *before* the expression. I'd rather stick to this usage for consistency. Especially seeing as `if let` and `while let` already exist and I feel the existing syntax should be an extension of the existing one, rather than a whole different beast. If `if let` and `while let` had *not* existed, I would probably have agreed to using `is` for conditional binding instead of overloading `let`, but since `if let` is not going to be deprecated anytime soon I'd rather stick with it for the time being. Thirdly, as I mention below, it's important to keep extensibility in mind. The use of `,` fails in this regard as it only allows conjunctions and bars the door to extending the pattern matching conditions to disjunctions. Fourthly, as much as I like `if let &lt;pat&gt; = &lt;expr&gt; &amp;&amp; let &lt;pat&gt; = &lt;expr&gt;` I am uncomfortable with the parsing here and would probably, like you mention, require parentheses. It seems that otherwise it could be parsed as `if let &lt;pat&gt; = [&lt;expr&gt; &amp;&amp; let &lt;pat&gt; = &lt;expr&gt;`. Brrr. --- I am not sure I'd go for *exactly* that syntax, but I like the idea of `let &lt;pat&gt; = &lt;expr&gt;` being convertible to `bool`. It makes it relatively easy to explain as well: - in a statement, `let &lt;pat&gt; = &lt;expr&gt;` only allows unrefutable patterns and evaluates to `()`, - in a boolean context, `let &lt;pat&gt; = &lt;expr&gt;` allows refutable patterns and evaluates to `true` iff the pattern matches; the scope of the binding will be a little weird, but that's how it is. The **one** wrinkle here is that I am not sure that the full power of boolean conditions can be made available. Sticking to conjunctions to start with is certainly the easiest, and it can be extended later: if (let Some(x) = foo()) || (let Ok(x) = bar()) { println!("{:?}", x); } while (let Some(x) = foo()) || (let Ok(x) = bar()) { println!("{:?}", x); } is a nifty potential extension, as `x` is guaranteed to be bound inside the block. It's a bit more complicated, as the compiler has to guarantee that all variables are bound no matter how the flow goes, but it seems doable in a backward compatible fashion. Pinging /u/etareduce about the above extension. Syntaxes which prevent adding such a feature should be a no-go to avoid painting ourselves into a corner.
Oh, I'm not arguing against you; in fact I agree. I just wanted to point out some additional information.
By no means I am suggesting to store all keys in a single gpg based vault instance, I just meant to show at the end of it, there is the need for a simple vault of some kind. Lowering the bar of entry for GPG based encryption for use in teams is the goal of ‘sheesy/s3’, and usability is what I am focussing on right now. At some point in the future it would certainly be nice to have comparison matrix (similar to the one found on the ‘gopass’ github site) to make clearer what the differences are, for example when compared to Hasicorp Vault, the system keyring, gpg + pass and gopass :).
These are all good thoughts. However, at this stage, I'd like to avoid inserting my bias on reddit on the proposal itself. I will reply at a later stage here =) Also, if you follow the link you are given at the end, you will find a long discussion about these things. But it is important to me that as many as possible answer the survey without being influenced by others.
I fully support avoiding special cases like "if let" and friends though and immediately going to "first-class binding expressions".
a decent imperative language still lets the compiler optimise, e.g. with const/restrict &amp; other aliasing restriction assumptions in c++, but of course rust could do it more easily with the borrow-checker's guarantees
Thank you very much! This tip was very helpful, I immediately found the bug and fixed it.
&gt; Arc&lt;String&gt; Could easily be replaced by `Arc&lt;str&gt;`. The `Arc` turns the `String` into permanently immutable, and the String is already a pointer. Also, most functions that work on immutable `String`s are actually implemented for `&amp;str` so you shouldn't lose any functionality.
Doesn't Rust have enough syntax already? You can already combine all the conditions in a single `if let (true, A(x), B(x), true) = (independent_condition, foo(), bar(), y.something()) { /* body */ }` and be done with it. Sure, that doesn't work if you need short circuiting, but squeezing multiple side-effect having functions into a single condition doesn't seem like something to encourage anyway.
The versions using multiple `if`s and comma feel very unnatural to me, especially the if case could have a impact on code readability in my opinion, considering an example like the one below: if some_pre_condition() // A // very // long // detailed // comment // explaining // why // the // below // check // is // required // in // this // condition // and // must // be // done // after // the // one // above if condition() { } Another question would be how exactly the `||` operator is "supported" by this version? There would be either the need to create a new keyword `or` - definitely not an easytask, although it might please some Pythonistats :) - or. to always use negation on the condition following the `if`. However, that would introduce additional overhead and require more rewriting when you suddenly find yourself in the need to introduce a bind into an existing conditional expression. All things considered, I'm strongly in favor of the two versions which still fit into the existing and established "rules" of using the logical operators for chaining of the conditions. Beyond that I don't have any real preference at the moment. Another thing to keep in mind is that the `if` and `,` versions may feel very alien to people that are new to rust. 
The input to the problem is two 1D arrays: `(Nrows*Ncols) x 1`. Then I want to view them as an `Nrows x Ncols` matrix for processing, where I have a function that takes two rows (with `Ncols` elements) and returns a row with `Ncols` elements. And I want to assign the returned row to the row of the matrix view of one of the input arrays.
Would be helpful if you could share an error message or such for gdb when you say it doesn't work, and for the commands you run in the console that work but that you say don't work in vscode
wasmstandalone might be written in Rust, but as it uses unsafe rust e.g. in order to jump to the JIT generated code, its output matters for its safety. If it generates code that can do something illegal for example. I also don't know whether it claims to be safe, or whether its authors assumed that the wasm that's loaded can be trusted. As I've said in OP, in order for me to consider wasmstandalone to be safe, it needs to have either had a security review, or underwent heavy fuzzing, or both.
Glium isn't dead. It's just not maintained by the original author. He still merges patches. Ex. I added support for [primitive index restarting](https://docs.rs/glium/0.19.0/glium/draw_parameters/struct.DrawParameters.html#structfield.primitive_restart_index) a few months ago and it took me a few hours to add it, got merged one day later, done. Glium works absolutely fine and it's easy to get a renderer up and running (instead of doing OpenGL manually). OpenGL is a lot easier to get going than Vulkan, which is also a drawback (for more complicated code). For example, textures are much easier to work with (in OpenGL). Which is good for me, since I write rendering applications (in Rust) that just have to render quads onto the screen (to combine many small tiles to a large one, for example). Understanding the math is much more important than understanding the API, ex. understand how you position a 3D camera in space to look at a point, understand the model-view-projection matrix, understand how you can use trigonometry to rotate something. You can do this in a renderer-agnostic way and change to Vulkan later. APIs change, Math does not. Also, Vulkan is only available on recent hardware, so if you want to give your app to a friend, he may not be able to run it. Just write a simple app where you look at a cube and can move around, FPS-style. If you're just starting out, please start with OpenGL (version 3 and up), you will simply get demotivated otherwise. A lot of tutorials are written for OpenGL and you still have to write OpenGL shaders for Vulkan (same syntax, same everything). April 20 is the next Ludum Dare game jam, if you want to join. I participated last time [and got something working](https://github.com/fschutt/LudumDare40) - even though [not perfectly](https://ldjam.com/events/ludum-dare/40/stackboxes/$67815). I've also noticed: Even though vulkano is an abstraction layer, you still have to understand Vulkan to use it - i.e. you have to know the difference between buffers and images. &gt; Rust -&gt; LLVM-IR -&gt; SPIR-V Take a look at [RLSL](https://github.com/MaikKlein/rlsl) and [rspirv](https://github.com/google/rspirv). RLSL is still active and is basically a Rust-to-SPIR-V compiler (Vulkan only). You'll probably don't want LLVM to do this, since you need domain-specific syntax anyway and LLVM wasn't really designed for GPUs. Start with making a [procedural macro](https://doc.rust-lang.org/book/first-edition/procedural-macros.html). That way you get access to the Rust token tree. Then you have to read the SPIR-V spec and compile the token tree to a SPIR-V binary. You can do this using rspirv (at compile time). &gt; Will I just be annoying if I am intellectually too slow to figure out their code base? No, please don't get that idea. Just don't be a dick and just post what errors you got and what you tried to do with some surrounding code. If you are trying to lean, people will help you. Also, you don't have to figure out the entire code base to fix a simple bug. That may be the case in C++, but not in Rust. I did a PR on the Rust compiler - I have no idea how all parts of the compiler works. I just asked other people "hey, do you have an idea where I could start", they gave me a file name. Then I started skimming the function names, found the function I was interested in. I used "skip to definition" and grep to find sub-functions, read their source code until I understood what's going on. Then I fixed the bug, did a PR and bam, done. Do I understand how the whole rust compiler works? No. Do I care? Not really. I fixed a bug that annoyed me and got the job done. I had the same experience with glium / cargo / etc. Rust makes it (IMO) very easy to maintain code (in relation to C++). You know exactly what values a function touches, no implicit state and "well you should know that X is bad practice because the compiler does Y instead". &gt; get a job Eh, game engine jobs are rare. I don't think companies hire you if you have never shipped an actual game. Most game programmers simply use engines - and you can already learn a lot of math that way. All game engines are pretty much C++ and I don't think they'll switch to Rust any time soon. See what [Blizzard has to say on Rust](https://www.youtube.com/watch?v=Az5F4lwSljI&amp;feature=youtu.be&amp;t=23m50s). I'd learn Rust to understand C++ better and then get a C++ job. The languages are conceptually in a similar space, if you understand Rust, you understand C++. If you really want to use Rust, go the indie route. People have shipped small indie games on Android + Steam using Rust and glium, for example. &gt; WASM / Web WASM is in it's infancy, but it's not unreasonable to use WebGL for game development. There is a cool series on [how to build a deferred renderer in WebGL](https://www.youtube.com/watch?v=LtFujAtKM5I&amp;list=PLMinhigDWz6emRKVkVIEAaePW7vtIkaIF), also check out /r/GraphicsProgramming. Sorry for the wall of text, just wanted to get this out there.
There are certainly ways around it, and I'd normally be using Firefox ESR with Self-Destructing Cookies, but, for every person you can talk to, there are likely to be many more who just silently disengage. My intent was to give some of the reasons I encountered that turnout might be low or data may be skewed, given the user experience the survey currently presents.
Does it help? http://shop.oreilly.com/product/0636920040385.do 
Oh cool; I forgot about that Wait, is this what non-lexical lifetimes will be affecting when that stabilizes?
That's true. Since they're intending for it to be used in firefox eventually, I think, I'm sure they'll safety audit it eventually.
Here's a part of the gdb log when I click the debug button in VSCode- ```=thread-group-added,id="i1" GNU gdb (Ubuntu 8.0.1-0ubuntu1) 8.0.1 Copyright (C) 2017 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word". Registered pretty printers for UE4 classes =cmd-param-changed,param="pagination",value="off" Stopped due to shared library event (no libraries added or removed) Loaded '/lib64/ld-linux-x86-64.so.2'. Symbols loaded. Program received signal SIGSEGV, Segmentation fault. elf_dynamic_do_Rela (skip_ifunc=&lt;optimized out&gt;, lazy=0, nrelative=&lt;optimized out&gt;, relsize=26856, reladdr=&lt;optimized out&gt;, map=0x7ffff7ffe150) at do-rel.h:112 Execute debugger commands using "-exec &lt;command&gt;", for example "-exec info registers" will list registers in use (when GDB is the debugger) ```
😳 yes it is. Wget was the way I could work around. But after that, cargo wasn’t pulling in dependencies. I had got the wire shark installed, and while tracing the request I saw that the server was sending ‘RST’ flag. Three way tcp handshake was successful! At that point I left my idea of installing rust on my home computer with lubuntu. I have a working copy on my Mac for my twiddling! Anyhow I’ll keep digging !
What are the features you found gfx-rs was lacking?
Random order of options is good, but kind of strange that the none option is sometimes buried in the middle. That's a Google Forms thing though, and at least the option is "None of them" rather than "None of the above". I don't know if I should be answering this survey, I'm kind of biased and know the exact RFC this is in reference to. (I am in favor of having this feature with some syntax and bias towards Swift's implementation since that's where I saw it first.) (Speaking of, where's the `, if let` option?)
i've been using a `BTreeMap` to store data for a program, which must be completely de/serialized at startup/shutdown. as my data store grows this operation has gotten slow enough to be noticeable. i'd like a B tree that only reads and writes nodes as needed from storage to increase performance. would this require completely rewriting `std`'s `BTreeMap` with the added functionality? would this be worthwhile to attempt or is there some obvious reason i'm missing that this is a silly idea?
I just made a mistake :)
Ok. I don't know the depths of Eigen, but there are clearly some things that are not available in ndarray. One of them is an "unboxed" passing of the resulting row as a value or as an expression template. So what ndarray would need with that is an elementwise operation or an operation that creates the whole row separately before it writes it back into A. I don't have an explicit answer, because a function that returns an expression template does not have a direct equivalent in ndarray. There is an experimental crate called algebloat, unfortunately they have no docs, so I have been unable to learn much about it or how it works. I know that it uses `Cell` pervasively, and that allows expression templates-alikes to both use the value in a location and writing back to that location without getting in trouble with the borrow checker.
&gt; I don't actually know what nom is or how it works. Maybe it's worth investigating If you talking about parsing bytes with rust the first thing that come to mind is `nom` https://github.com/Geal/nom It is worth investigating even without context of parsing nmea. And about `no_std` - of course `nom` works in `no_std` environment.
The first feature I came across was reading back from the frame buffer. I couldn’t find how to do it in the docs and I believe it was you who told me it wasn’t supported in the gitter. Since then I haven’t kept too close track of feature parity but I believe there was another thing or two I don’t immediately recall; will update this comment if I do.
It's a way for sure. I like the https://crates.io/crates/chan-signal crate too, maybe it might work?
Iterators are not just for array access. It can be arbitrarily expensive.
I'm either totally misunderstanding what the question is asking about, or these are very strange ways of expressing the pattern (except for maybe one).
Yes, I remember this discussion. Let me clarify the details: Technically, reading back an MSAA-enabled buffer is invalid operation in GL: https://www.khronos.org/opengl/wiki/GL_EXT_framebuffer_multisample You'd typically want to resolve first by making a blit into another target, and then read from that target. gfx-rs doesn't currently provide any built-in blitting, so that's indeed an obstacle, but a solvable one: you can always just read the sames in a shader and resolve manually.
Do they cover the subject of how Rust approaches OOP and related code design?
&gt; Understanding the math is much more important than understanding the API, ex. understand how you position a 3D camera in space to look at a point, understand the model-view-projection matrix, understand how you can use trigonometry to rotate something. You can do this in a renderer-agnostic way and change to Vulkan later. APIs change, Math does not. Also, Vulkan is only available on recent hardware, so if you want to give your app to a friend, he may not be able to run it. I have that under my belt (majored in math too). All of the programming I have done so far has revolved around scientific simulations, where the model output needs to be represented by a video at most. Currently, the way I produce videos is use cairo to create a bunch of PNGs, and then ffmpeg to string the PNGs together. The challenge with more complex graphics is that there is a LOT of infrastructure between you specifying the vertices of a triangle, and that triangle appearing on the screen. Learning how that infrastructure works, and learning how to talk its language, is way harder than the math, in my opinion. &gt; If you're just starting out, please start with OpenGL (version 3 and up), you will simply get demotivated otherwise. I appreciate the sentiment, but I am not sure I can buy into it. I am choosing Vulkan over OpenGL for the same reasons why I am choosing Rust over C++. 
Do O’Reilly still sell DRM-free digitial e-books?
Cool, thanks for the info.
All good points, I agree completely. 
This came up in the Rust users forum as well. I wasn’t aware that was released in 1.21. It is nice. Thanks for the explanation!
You need to drive execution on the `Core` somehow. One way to do that would be to add `core.run(futures::empty::&lt;(),()&gt;()).unwrap();` at the end of `main()`. You'll need a bit more machinery if you want `main()` to actually exit once things are done.
Great to hear! What did it turn out to be?
Agreed, I cannot participate either, Google surveys require js, and signing in...
Once you know your basics around rust I can only suggest checking out [Codingame](https://www.codingame.com). It kinda works like exercism, but is not specific to teaching the language, more of concepts in programming in general. It is a nice resource to implement some algorithms and to find good patterns in a language though. Like exercism you can look at other solutions to find new inspiration.
Tell me if I understand correcly. Vulkan Portability means you expose a standardized subset of Vulkan which can be mapped into other APIs. The mapping from one to other is written in Rust provided by gfx-hal. My question is: does it necessarily need to be compiled together with the source as static library or can I just use it as DLL on Windows with programs alredy existing? If the Vulkan subset is sufficently large then it could be possible to run Vulkan programs on machines which does not provide the API but have DX12 for example. There are lots of them unfortunately. If it works this could become huge.
Sounds like you solved it, but for the googlers in the future... I'd think there are 2 reasons switching from bench to test could matter: 1. Optimizations. Does the bug come back with `cargo test --release`. Test are normally run in debug and bench is normally in release. 2. Race condition. Perhaps it has to do with running the code in a loop, somehow. In either case tracking it down could be really tricky. 
As I mentioned I use some assembly files which I call inside Rust, and I was getting invalid memory reference error while I had a mistake in one part of the assembly. I had forgotten to preserve the nonvolatile registers in my assembly. 
I get this error on firefox as well -- but it's not related to the recursion error the above comment is referring to. That's about compile-time macro recursion, not runtime recursion.
A secret is knowledge that you share with only one person... at a time.
No, non-lexical lifetimes are about borrows – as long as we can prove that no two borrows are active at each point in time. Perhaps surprisingly that doesn't affect drops at all.
I'm not quite sure what you're trying to achieve, but if you're looking for `parsec`-like libraries, I would check out either [`nom`](https://github.com/Geal/nom/) or [`pom`](https://github.com/J-F-Liu/pom). I'm sorry I can't be of any more specific help.
I see - so the reactor is left with pending futures, and quits because it already resolved the future `core.run()` was called with. Is there a way to register futures that the reactor needs to wait for? A sink or something? Anyways, I ended up doing it with a `join_all` instead: core.run(join_all((1..9).map(|number| { println!("Sent {}", number); let uri = "http://localhost:3000".parse().unwrap(); client.get(uri).and_then(move |_| { println!("Received {}", number); Ok(()) }).then(|_| ok::&lt;(), ()&gt;(())) }))).unwrap(); 
But can I use pom on top of the XML library? Nom does not seem suitable 
&gt; Opening a Rust file should now look analogous to below. I sure hope it doesn't, would be pretty weird ;) &gt; BONUS I suggest putting `compiler cargo` somewhere suitable (in my case, that would be $VIMRUNTIME/after/ftplugin/rust.vim), so you can use `:cargo check` as well as `:cargo test` and the like.
It really is.
The Core needs to be running until the requests finish. The future you're passing to run finishes super quickly, just scheduling a bunch of requests, but they don't have time to finish. You'd need to make the core run more. We realize this easily trips people up, and it should be easier to do in an upcoming version.
`s/:cargo/:make`
We, the gfx-rs team!
Chapters 9, 10, and 11 cover Structs, Enums &amp; Patterns, and Traits &amp; Generics over the span of 43 pages. Those topics together should give you most of what you need for a solid OOP foundation in Rust.
&gt; Vulkan Portability means you expose a standardized subset of Vulkan which can be mapped into other APIs. Correct. &gt; does it necessarily need to be compiled together with the source as static library or can I just use it as DLL on Windows with programs alredy existing? Both approaches are being implemented. See [ICD groundwork PR](https://github.com/gfx-rs/portability/pull/8) by /u/msiglreith &gt; If the Vulkan subset is sufficently large then it could be possible to run Vulkan programs on machines which does not provide the API but have DX12 for example. There are lots of them unfortunately. If it works this could become huge. Absolutely! As it looks at the moment, the coverage is quite large. Only things like triangle fans are getting off board, plus a few nits. The investigation is being done on the way by us alone and as a part of the Khronos technical subgroup. &gt; If it works this could become huge. There is already MoltenVK on that space for OSX, and it appears to be quite successful at that. We strive to make gfx-rs portability a more robust (Rust safety, more performant, and more portable (we already have DX12 and GL, yo!) alternative.
Right, thanks, fixed it :) Can't tell how often I make that mistake when coding, too.
From the title, I thought this was going to be a post advocating a new project mixing both C and Rust, and I was about to be disappointed. Libcurl is a quality piece of software, though, and I find no problem with it being a requirement for a Rust library.
[removed]
I mean more from the perspective how to apply those tools to actual code design, since Rust differs from classic OOP languages like C++ and using that approach might not obvious for newcomers.
Great! I will definately check it out the next time I need a curl wrapper!
What's up with the font? "Source Code Pro Regular" starts looking rather ugly when the font-size &gt;= 18.5px. When I make my browser window narrower the font size shrinks and becomes readable again.
&gt; Learn Vulkan in depth... &gt; If I go the Vulkan route... &gt; Design and implement my own wrapper around Vulkan... &gt; Why not OpenGL?.. Basing your app/framework on gfx-hal will give you the knowledge of Vulkan concepts and the portability of GL. See a [neighbour thread](https://www.reddit.com/r/rust/comments/7n3lp1/2017_year_in_gfxrs/) about our 2017 recap for more info.
From a trustworthiness standpoint, I'd agree... but the simplified build requirements for a pure Rust project are hard to ignore, no matter how great a pedigree a C dependency has.
I mentioned that briefly in the post; if including a C library doesn't offer enough benefits, it may not be worth the extra compile dependencies. Though if it is a library like, say, Lua, there aren't really any special build requirements.
Ah, I understand. There's plenty of compare and contrast between Rust and C++, Java, JavaScript, and Python in the chapter on structs. I'm coming from a year of working almost exclusively in Node.js, so these comparisons have been helpful for me to wrap my head around the lack of prototypes, inheritance, and a directly visible "this" keyword inside of methods.
&gt; I don't think webassembly is a good idea for anything serious at this point. I have been _very_ impressed by WebAssembly, `stdweb`, `cargo web` and the `wasm32-unknown-unknown` target. For an ecosystem that's only a couple of months old, and which is undergoing rapid development as we speak, it's remarkably good. I'm planning to put some WebAssembly into real-world production as early as January, I think. That said, it's probably not the easiest choice for a game. And if you're using it, you will almost certainly be opening PRs against all sorts of Rust webasm projects to add missing features. I haven't had this much fun on the web since Rails 0.12, or maybe the mid-90s.
&gt; You're thinking, "What's the big deal with using Hyper?" I didn't actually see this question answered in the post. Why didn't you just use Hyper? It's a very nice library and is being built with large ecosystems in mind, like Tokio and Rustls. &gt; Advantages, which may include: less tooling required, easier package management, less runtime dependencies, or less unsafe blocks I'm going to add two things to this 1) Less cognitive overhead. Because it's all in one language, you don't have to understand the intricacies of more than one language in the codebase. 2) More potential to discover and fix bugs in underlying libraries. This is part of the better tooling, etc., but especially in the case of something like libcurl, pulling in the src, and recompiling to try and diagnose a bug becomes harder. I think both of these are big drivers to want libraries built natively in languages (not just Rust). You see this in Go and Java, lots of language native rewrites of common tools, and I think it's generally because of these two reasons.
`cnoreabbrev cargo make` and `command! -nargs=* Cargo make &lt;args&gt;` should help you ;)
You can't return a reference to something owned by the current stack frame. That's like saying 'here are the keys to my car, you can borrow it if you like' and then immediately setting it on fire and driving a tank over it. When that poor person you gave your keys to tries to use your car later, they'll be disappointed. The Rust compiler protects you from this type of disappointment, which is why it will stubbornly (and correctly) refuse to compile your program. You should read some more about ownership and borrowing, and I suspect about the stack and the heap as well.
I would be interested in doing this, but I have a major concern: `vulkano` or `gfx-hal`? If they are both roughly the same thing, why are they separate projects (this is my total inexperience/possible idealism speaking)? To answer this question, I would ask you these questions: In the neighbour thread you linked, you guys (the gfx-rs team) mentioned that the future might look something like this: `vulkano -&gt; vulkan (portability) -&gt; gfx-hal -&gt; vulkan/dx12/metal...` What is `vulkan (portability)`? What features of `vulkan` are being lost out on after passing through `gfx-hal`, since it aims to be an interface with more than just Vulkan? If there is feature loss, how do you justify it in terms of the grand design scheme? In your opinion, why would it be cool for `vulkano` to interface through`vulkan (portability)` rather than with Vulkan directly? Conceptual question: Vulkan is already a hardware abstraction layer. Why are we putting a hardware abstraction layer on top of a hardware abstraction layer?
Yes, its intended for these things. however it may require relinking if dynstr is positioned before executable sections. If that's not the case it's actually just a matter of moving around the pointers in the dynamic segment 
**You can't return a reference to something owned by the current stack frame.** What a revelation! Seems obvious now that I think of it, but somehow that didn't get registered properly. :) Thanks!
Might another benefit be that it would be easier for new contributors to get into contributing to `hyper`, than to `libcurl`, simplyl because Rust's compiler is just so much better at making sure you're not doing something you don't want to do?
I trust you've already seen https://github.com/alexcrichton/curl-rust and are going in a different direction?
Currently Static musl binaries still require musl at runtime (as ldso) if you want address space layout randomization, which is required on Android. Musl has rcrt1 to solve that which is enabled with stasis. You can do all of that without elfkit, that's really just a nice demo. The actual purpose of elfkit is to enable content addressable linking, which links libraries by content hash rather than name. 
This is pretty awesome. However, I find the lack of enums disturbing :P
I think that is definitely true and representative of statistics if your prior is Rust programmers, but it is important to remember that more programmers are C programmers by far still.
What if you're doing `[1,2,3,4].iter().map(|x| x * 2)`? It has to calculate a value then to get the first value. What if instead of `x * 2`, you're fetching data from a file based off of the index? What if it's a network operation?
(I'm a newbie too, so perhaps someone more confident can verify my answer) I think that when you pass `my_string` from a function, you are basically doing what "you intend to do": you aren't doing any data duplication, you are just passing the the address of the data from one owner, to another, while not doing anything to do the data (so its still around, in fact, you guarantee that it is still around). On the other hand, if you pass `slice`, then you must recall that Rust's scope rules ensure that the data `my_string` (and thus the data `slice` is referring to) *will be destroyed at the end of `f`'s scope*? I'd ask you: what's the point in giving a reference to a piece of data that has been destroyed? Another question for you to answer: if `slice`'s lifetime shouldn't be dependent on any of the inputs to `f`, then why is it being created inside `f`? Perhaps it should be created somewhere else, so that its lifetime is not dependent on `f`, and instead some more relevant scope? In other words: fn g() { let my_string = String::from("Hello World!"); let mut slice: &amp;str = &amp;my_string; slice = f("sweet", "cat", slice); } Assuming that `f`'s definition is now something like: `f&lt;'a, 'b, 'c&gt;(string1: &amp;'a str, string2: &amp;'b str, string3: &amp;'c str)`.
&gt; If they are both roughly the same thing, why are they separate projects gfx-hal is a Vulkan Portability implementation in Rust. vulkano is a higher level type-safe wrapper around Vulkan. Different goals, constraints, authors, etc. &gt; What is vulkan (portability) ? It's our [project](https://github.com/gfx-rs/portability) that is a C library wrapping of gfx-hal that can be linked to with the stock "vulkan.h" (or used as an ICD implementation). &gt; What features of vulkan are being lost out on after passing through gfx-hal, since it aims to be an interface with more than just Vulkan? If there is feature loss, how do you justify it in terms of the grand design scheme? This is still being investigated. See our [meta issue](https://github.com/gfx-rs/gfx/issues/1354) for some open-to-public details. TL;DR: if something can be emulated without too much trouble and noticeable performance loss, we do it. The idea is that the subset is defined as a standard by the Vulkan Portability technical subgroup, and we implement precisely that. &gt; In your opinion, why would it be cool for vulkano to interface throughvulkan (portability) rather than with Vulkan directly? Isn't this rather obvious? Because it would allow running on Apple, Microsoft devices as well as HW that's too old for Vulkan (thus, using the GL backend). &gt; Conceptual question: Vulkan is already a hardware abstraction layer. Why are we putting a hardware abstraction layer on top of a hardware abstraction layer? Because Apple and Microsoft don't recognize Vulkan as such. Hence, we fill the gap ;)
It's not possible to use an unsafe mutable static to hold a reference to the context of the program because of lifetime restrictions. Anything complex on the static context needs a static lifetime. Dynamic libraries, by definition, can't have a static lifetime and be dynamic at the same time. I've been fighting against this for about a week but I'm giving up now. It looks like it's simply not possible to interface with such a library in any useful manner from Rust...
&gt; I concur that having a Rust-only codebase can lend itself certain advantages, which may include: less tooling required, easier package management, less runtime dependencies, or less `unsafe` blocks. For me, the most important item on this list is: - Painless static linking and cross-compilation. Specifically, I deploy most of my Rust applications (including many production ones at work) using musl-libc. This keeps Docker container sizes down (speeding up production deploys), and it allows me to distribute cross-distro Linux binaries. But this comes at a price: every time I hit a pure C dependency, I need to add it to my [build container](https://github.com/emk/rust-musl-builder). This involves massive amounts of frustration, weeping, upstream PRs, and general misery. `libpq` and OpenSSL are the bane of my existence.
However if you just use it as linker instead of as post-linker, the object files are already linked by their hash
This is true for regular builds on tier-1 platforms, but a pure-rust project can cross compile to any platform Rust supports without having to download a C compilers for that platform. Just one advantage that I can think of.
Excellent points. Good reasoning. I think I have a better understanding now of where I went off track. Thanks for your answer.
I just made another edit, some code of mine was off in terms of where the `mut` should have been. Also, I added a link to the playground!
Just to check, have you been using [wasm-gc](https://github.com/alexcrichton/wasm-gc) on your result binaries? If you're developing on `wasm32-unknown-unknown`, the target does not yet have complete unused-code trimming, and your binary could be smaller than you realize if you haven't been using wasm-gc.
I knew about the Playground, and often use it to experiment with bits of code. What I didn't know was that you could *share* code with it. Pretty cool!
I've been reading it through Safari Online. I like it!
Yeah, please read [my other comment](https://www.reddit.com/r/rust/comments/7m0uir/hey_rustaceans_got_an_easy_question_ask_here/dry7gmg/) on this. I looked into the math library and it's just awful. Half of the operations could be moved to libcore, roughly 10 functions link into C, which is why rust has a dependency on libm, because 10 functions couldn't be ported. The situation for WASM + Rust isn't really great right now. If you can accept 60KB files, that's fine, but for most websites it's too much in terms of load time.
First off, thank you so much for your answer. It's improving my understanding a lot: I now know about the `Vulkan Portability Initiative`, and `gfx-rs`'s goals make a heck of a lot of sense through this lens! &gt; Isn't this rather obvious? Because it would allow running on Apple, Microsoft devices as well as HW that's too old for Vulkan (thus, using the GL backend). Now it's obvious! Two more questions for you: &gt; Because Apple and Microsoft don't recognize Vulkan as such. Hence, we fill the gap ;) Can you explain why this is so? The second question, unrelated to the first: do you think your team can provide mentorship notes for someone like me, who is keen on participating, but definitely needs mentorship notes of the kind found on issues for the rust compiler? I am becoming fairly convinced that `gfx-rs` is the way to go :)
That worked thanks. I've been able to remove the short links on a WIP branch.
I don't understand what the problem you're having is. You can absolutely have dynamic stuff in a global variable, but without seeing representative code, I can't tell where you're having problems. I see in another comment you're talking about wanting to put things with limited lifetimes in this global. That you *can't* do, but I don't understand why you need a limited lifetime in the first place. In this context, lifetimes *do not* control how long something is live for, they limit how long something *can* be live for. Anything in a global must be allowed to live for as long as the program needs it to, but it doesn't *have* to.
Exactly. I like to build musl-based fully-static Rust "scripts" without having a musl toolchain present beyond what rustup installs.
And here I am, not even thinking about making it work rather than trying to fix my stupid head :D Thanks a lot!
I found it made a noticeable difference but my implementation might be quite different to yours.
The obvious solution is to make a c compiler crate, either pure rust or embedded in Rust via the build. As the ecosystem grows dev will become exponentially easier.
[removed]
/u/hjkl_ornah, are you the author? I have a couple questions.
Is Rust known to follow the principle of "If it compiles, it works"?
I mean.. this is a pretty good reason: https://curl.haxx.se/docs/vulnerabilities.html Even with very mature and well-tested C libraries, they will very likely be more vulnerable to attack over the long run (especially as they evolve and introduce new, less tested, code). So an argument for using Rust instead of C libraries is simply that the as those Rust libraries gain use and stabilize they will likely be less vulnerable to security issues. Yes, there's potentially a risk that a brand new Rust library won't yet have the reached the maturity where this inherent advantage outweighs the bugs due to immaturity, but the only way to get there is to make the switch and start hammering on them. 
You're looking for /r/playrust
If you e.g. have logic errors, codepaths may not run – this has happened to me once or twice in two years of writing Rust code, and I always immediately knew where to look. So, I guess the answer is no, but very close. It of course heavily depends on your code, how much you use the type system, etc., so your mileage may vary.
Can you explain what is meant by "current stack frame"?
&gt; Can you explain why this is so? microsoft - dx12, apple - metal.
&gt; Can you explain why this is so? To expand on /u/ozkriff answer, these companies decided that Vulkan is not the best API to work with their kernel/hardware. This is not purely evil: I feel the beauty of Metal API, and it has some pretty amazingly elegant parts. I just want to see a single dominant API for developers, and Metal will never be that. &gt; do you think your team can provide mentorship notes for someone like me, who is keen on participating, but definitely needs mentorship notes of the kind found on issues for the rust compiler? I haven't payed attention to these notes. Thank you for the pointers! I'll check them out and add some notes to gfx-rs issues.
But doesn't Vulkan work on Windows? I am pretty sure I tried out some demos?
Thank you!
Take a look here: https://doc.rust-lang.org/book/first-edition/the-stack-and-the-heap.html
This. Exactly the same issue here and only for this reason I try to avoid most of things that have a -sys dependency in Rust. Sadly, it is still very hard (or almost impossible) to avoid as there is still too much foundational non pure-Rust libraries deep in the dependency chain. And maybe this will become an issue with wasm (unless CC crate will be able to compile C dependencies to wasm too).
Total newb here, but shouldn't you "just" move the `interval` into the closure? Say, fn start_heartbeats(&amp;mut self) { let interval = config["interval"].parse().unwrap(); self.heartbeats_active = true; thread::spawn(move || { while self.heartbeats_active { self.renew(); thread::sleep(Duration::from_millis(interval)); } }); } If you can't do that for whatever reason, you'd need to clone it (though I think it's a u64 anyways, so it should simply be copied... actually, shouldn't that happen anyways? Still worth as shot :)).
Thanks, unfortunately I don't think this will work in this case... To answer the question of the loop never terminating, there will be a `stop` method which will, among other things, set `heartbeat_active = false` and terminate the loop. But in order for the `stop` method to be useful, the `start_heartbeats` method must take `self` as a reference instead of moving it.
Well, threads can only take static references in general, so that will not work. You should look at the crossbeam crate with its scoped threads, that might help you. I don't have any experience there, though. Another thought: Maybe send `self` back through a channel when the thread exits?
OTOH, adding clang to the llvm that's already there because rustc needs it isn't that much of a dependency. Trying to install the VC compiler without downloading literal gigabytes is another topic, though.
Is it really possible to make `let` a proper expression that evaluates to bool? For example, how does `if !(let Some(x) = y) { ... }` work? What about `if foo(let Some(x) = y) { ... }`? I feel like this would turn to some weird scoping rules, where some specific expressions would be properly recognized by the compiler, and some wouldn't. I don't like this because then `let` would look like an expression, but wouldn't really be that.
I think you're handing out possibly invalid pointers. You allocate the memory using a vec, but then the vec will go out of scope. I think you should be using: Box::into_raw(vec.into_boxed_slice())
Not really going in a different direction, they're just different things. cHTTP is a higher-level abstraction of a HTTP client, whereas that project is a safe libcurl wrapper. In fact, cHTTP uses that crate to interface with libcurl.
Reading it back, yeah I wasn't very explicit about the answer, though I did answer the question indirectly. libcurl is stable and well-proven, which makes it a better choice (stability wise) than Hyper, which isn't even version 1.0 yet and a much younger project. Number 1 I definitely agree with, though writing Rustic wrappers are nice because it means usually just the developers of the wrapper need to understand C. Number 2 depends on the library; I like wrappers that bundle the source with them (like the curl-sys wrapper does), because then the C source for libcurl is right there, easy to edit and recompile already.
There is no simple fix to your program that I can see because you're trying to run code in parallel without doing any kind of synchronization. The compiler is preventing you from doing some very gnarly things. :) I don't have time to write out the answer for you, but basically: * The compiler message you're getting is basically telling you that you're trying to run a closure in another thread that isn't `'static`, which means it is borrowing something. In this case, you're borrowing `self`. * Conceptually, if the borrow checker weren't present, then there would be nothing stopping two threads from calling `renew` simultaneously, which would result in a data race since both threads would try to modify `self.config`. Similarly for `self.heartbeats_active`. * You need synchronization. You probably want a `Arc&lt;Mutex&lt;HashMap&lt;String, String&gt;&gt;` somewhere. It might help to read the concurrency section in the book: https://doc.rust-lang.org/book/second-edition/ch16-00-concurrency.html
Er, what? I'm pretty sure they don't use WTF-8; they are just byte sequences. Otherwise they'd have to be converted back and forth at every API boundary since WTF-8 is something entirely different.
Right; so your problem is that you're trying to use a particular interface in a way it's specifically designed to not support. So use something else. There's [`sharedlib`](https://crates.io/crates/sharedlib) which appears to have a `LibTracked` abstraction that does exactly what you want: it frees symbols from needing a lifetime by doing refcounting on the library the symbols are loaded from. In general, when you have lifetimes, they need to come from something "higher up". There's nothing "higher up" than global scope, so if you've got non-`'static` lifetimes at global scope, you need to change your design to not need non-`'static` lifetimes.
I would relish a doc that explained easy, reproducible ways to get pixels on the screen in Rust. 
Sounds good!
Errmm, they are WTF-8 on Windows. And yes, the standard library does a transcoding step on Windows. On Unix, you're right of course, they are just byte sequences and there is no transcoding step.
I think they're hoping that you'll try their safari subscription which would give you access to the ebooks. I believe safari has a free trial.
They used to. If you bought a preview of the book before they turned off that option you'd get a copy of the final ebook.
If that's true then [the documentation](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) needs to be updated &gt; Note that this does not return the number of bytes in this string as, for example, OS strings on Windows are encoded as a list of u16 rather than a list of bytes. WTF-8 is byte-based so if it's being used it contradicts the above.
Part of the problem is that a lot of -sys crates expect you to install C dependencies in the system-default location using a package manager. Crates that instead bundle the dependencies like the [lua](https://github.com/jcmoyer/rust-lua53) crate does are far easier to work with for consumers.
Yeah that's interesting. My suspicion is that it meant to say something like "it doesn't necessarily return the number of bytes." Note that WTF-8 is an implementation detail and isn't part of OS string's public API.
&gt; a better choice (stability wise) than Hyper, which isn't even version 1.0 yet and a much younger project. This is fair. But I would encourage people to checkout hyper. It’s very high quality software. I suppose it depends on your use case. &gt; easy to edit and recompile already. Yes, this is a nice way to bundle self-contained software. I like the sqlite libs for this same reason. But editing it creates an implicit fork, and then it might be more annoying to post back upstream. Anyway, great job on getting a release out! It’s great to have so much activity in this space. 
To me this seems like using "practicality" to justify using code that has worse security guarantees. Lots of popular libraries have had entirely predictable bugs (openssl) that would have been avoided by not listening to this advice. 
But not anymore. Really bad decision. I lost respect for them.
Exactly. Huge respect for all the work that the curl maintainers have done, they've done a lot more quality work than I have. However. I personally find it irresponsible to continue to have critical software that has memory vulnerabilities several times a year. That's **the** reason I work on hyper. Instead of just complaining, trying to actually plug the hole.
Yes
I guess that means you're talking to the Rust maintainers to use elfkit as a cross-platform musl-static alternative triple. Ignoring the obvious escape hatch of linking against host C libs, this would be a great way on the road to produce fully static pure Rust binaries. Good work, I'm excited!
Also, the `free` function doesn't deallocate any memory... The author should read into what the `Drop` trait.
I saw go-langserver in your vimrc. Did you go through any special steps to get that working with Languageclient-neovim? I don't get any lints or completions from it
Honestly, after more than 25 years of C (and C++), I've become very frustrated with the average C code I seen in the wild. OpenSSL is fairly typical, in a lot of ways. So much C code has buffer overflows, numeric overflows, memory leaks, double frees, undefined behavior, and an an endless number of bugs. There are exceptions—djb's code is quite good, dovecot seems reasonable, OpenBSD audits aggressively—but when I dive into most C code, I expect problems. And if I run a fuzzer, I expect a train wreck. And all of my devices and apps are constantly downloading and applying security patches. Microsoft regularly schedules "patch Tuesday". I need to apply security updates to my _light bulbs_, and I'm actually thankful that the vendor cares enough to support their products. I'm tired. I don't want to rely on programmers practicing constant, flawless vigilance. And I'm well aware it's going to take most of my natural lifespan to put a dent in the problem. But I'm not naive enough to think that we can just rewrite everything in better languages. Fixing this will take a generation, and we'll replace a few pieces at a time. So the ability to talk to C code is vital, because it allows us to tackle the problem in tiny steps. But given a choice, I'll take a Rust dependency when a decent one is available. I've run a fuzzer on Rust code, for over a billion iterations, and never found an exploitable bug. That's not to say that there aren't tons of good use cases for interfacing Rust with C! I've written a number of bindings, and I maintain a cross-compiling setup for several popular C dependencies. It's necessary and unavoidable.
Thanks, I can try throwing some `Arc`s and `Mutex`es in strategic places and see if I can come up with a solution. I probably should have been clearer in my original post--I realize why Rust is stopping me from doing this, and I appreciate it, however I was lost for figuring out how to get around the issue, since I didn't think I could just slap a `Mutex` around `self`. But I have some ideas to try now.
That's why I'm careful on how I choose my words. I do not *dislike* Hyper; I think it is important to the Rust ecosystem (though more on the server side). It is high quality. But especially for businesses, something that has been stable for a long time typically trumps new, even if quality, development.
Macros like `println!` and `write!` compile down to hardcoded procedures that look at the local variables you give them and make the appropriate calls to `write_str` (which often just calls `write`). Which is cool for performance and all, but the templates must be known at compile-time. --- The *really* annoying limitation of the standard formatter is that `Formatter` is a completely opaque struct. You can only create one by calling the `write` or `format` function; those only take `Arguments` values, which are only created by Special Compile-time Magic. Without `Formatter` you cannot invoke the `fmt` methods of the `Display` `Debug` etc. traits. Thus `[derive(Debug)]` is somewhat limited in utility. If `Formatter` were a *trait*, well, *Bob's your uncle.* But it's not. So generally speaking *serialization and formatting frameworks need to reimplement the basic glue*. They can't just recycle `Debug` and `Display` without accepting significant limitations. ... This would be a good project for me, now that I think of it.
So what we should be doing in the future is start making C interfaces for high-quality Rust libraries, yes? Then we can start writing our cross-language shared libraries in Rust.
&gt; That's like saying 'here are the keys to my car, you can borrow it if you like' and then immediately setting it on fire and driving a tank over it. When that poor person you gave your keys to tries to use your car later, they'll be disappointed. My God, my sides. Bravo.
My hint to you would be to find a way to break up your state somehow, and move some of it into the closure. But you should move it via an Arc. So if you have an `Arc&lt;Mutex&lt;...&gt;&gt;`, then you can cheaply clone that and move _that_ into your heartbeat thread. The possible downside here is that now you need to lock a mutex every time you want to read your config. That may or may not be acceptable, and there are strategies to avoid that, but at that point, you're optimizing so there's no blanket solution.
You wouldn't call renew, or you would split your state and call renew on that. 
Yes, it is traditional like Qt or Gtk.
I don't think it's a great concept for understanding Rust (more of a machine-language thing) but here goes. Imagine a really wide blackboard. (Actually this is a metaphor for memory, so it's one-dimensional.) Your program will start on the left with the blackboard blank. Each function has a *prologue* that blocks out how much space it will need to hold local variables. So `start` will use a little bit of leftmost space for setup (sets up the panic handling) then `main` will use the space next to it. When `main` calls a function, it'll get some space immediately to the right of `main`. These spaces are the stack frames, the blackboard is the stack. When a function finishes, imagine that it erases its stack frame, leaving a blank space for the next function. You can't borrow a local variable and return the ref, because when the function returns, it'll erase the local variable. Then the next function will reuse the same memory for something completely different. Add the fact that programs generally *don't* in fact erase stack memory (would just waste time), and this can be a hilarious source of bugs in C or assembly. Now, this is how machine language works. Rust has a more restrictive rule: variables disappear at the end of their block. `}` implies "cleanup everything that goes out of scope here." `Drop::drop` gets called, stack memory may be recycled even without the stack frame technically being freed. Variables can't outlive their blocks, so borrowed references can't either.
Yeah, I'm not ready to call this a working malloc. I thought the more interesting thing to write about is how to test it.
That's going to produce a fat pointer which won't match the return type. `mem::forget()` is the way to go.
Hello, i have followed tutorial. But i dont get ..hover,implementation,definition,rename, or codeAction in rust .. I also dont get warnings in rust. A lot more seems too work in python. Code completion and formatting does work in rust.
I can use the system gcc to bind pure Rust binaries to 64-bit glibc and either 64-bit or 32-bit musl using only what rustup can provide but, as soon as a C dependency creeps in, the lack of a proper musl toolchain causes the built to fail. (In fact, I discovered that when [project boilerplate](https://github.com/ssokolow/rust-cli-boilerplate) started failing to build after a dependency update until I set the appropriate feature configuration to opt out of the newly-added backtrace dependency in error-chain.)
Ahh, I see.. Thank you for helping me understand. 
You can cast a fat pointer to a thin one via `as`.
You shouldn't need to do anything special other than listing it in your `let g:LanguageClient_serverCommands = {}` dict. If you've done that then my guesses are: 1. You don't have a completion engine installed, a la `nvim-completion-manager` 2. You haven't initialized the LanguageClient: If you want it to start automatically `let g:LanguageClient_autoStart = 1` Otherwise, you'll have to manually trigger it (here's an example mapping) `let g:LanguageClient_autoStart = 0` `nnoremap &lt;leader&gt;lcs :LanguageClientStart&lt;CR&gt;`
Warnings should work, it will catch most things the compiler would bark at you for. However, not all of the features of the Language Server are implemented yet for the RLS. Different language servers are at different points. For a great talk on the RLS and it's development check out: Episodes 27-29 Episode 30 https://itunes.apple.com/us/podcast/new-rustacean/id1041815075
Hmm, ultimately don't you need to call the kernel memory allocater? What malloc and jemalloc and the like mostly do is function as abstraction layers over the calls to the kernel memory allocater since at the end of the day the kernel is the one handing memory out.
Cheers!
Yeah, in my roadmap are using brk/sbrk and mmap to actually implement a malloc. I just needed a stub for my testbench.
This example seems like exactly what I need: https://doc.rust-lang.org/std/mem/fn.forget.html#use-case-3
Every once in a while I remember how I haven't had a single null pointer exception in Rust and how fantastic that is.
I recently saw a pretty good talk about this: https://youtu.be/LLde-PJJZQA I never realized it was so difficult! 
God bless Rust 😁
Hi, great work, really! I hope Redox OS will continue to grow faster and faster! Another question: Is TFS discontinued?
Pretty sure they're coming from racer via Lang server
I wish rusti is updated to work on more current nightly though.
Thanks for the help but I don't really understand what you mean by &gt;Don't try to Rc&lt;RefCell&lt;Mutex&lt;Z̗̘͇̞͇̰̝͡a̵l̳͈̖̦̫͞go͖̭.͉̜͓͕̪̳̜&gt;&gt;&gt; yourself out of borrow checker errors. If this is a binary tree, then each node has exactly one parent, and it makes no sense to use reference counting. Each node has one parent yes, but they don't own the parent, so the pointer needs to be shared which is why I'm using Rc&lt;Ref&lt;...&gt;&gt;. What should I use instead of an RC to share the pointers?
I wouldn't dismiss `Rc&lt;RefCell&lt;T&gt;&gt;` so fast - you only pay the reference counter on `clone` and `drop`, and it's pretty fast in general. And it doesn't need to be so complicated: ``` fn modify&lt;F&gt;(&amp;self, func: F) where F: FnOnce(&amp;mut NodeData&lt;T&gt;), { func(&amp;mut self.ptr.borrow_mut()); } ```
Rust uses its own fork of llvm. So the clang you use does not use the same llvm. 
Totally fair :) I'm looking forward to this RFC, as I have a few cases of rightward drift that could greatly benefit from such syntactic sugar.
&gt; I feel like this would turn to some weird scoping rules You pin-pointed the weak point of this proposal on the head, I think. It's not clear to me what the scoping rules should be, or how they could be explained.
Parent pointers are non-owning, and that's why `Rc` does not fit in here: `Rc` allows for dynamic (number of owners is not known at compile time) shared ownership (all peers share the ownership). In this case, each node clearly has a unique owner: it's parent. And parent pointers themselves are non-owning. In C++, the node structure would look like this: ``` struct node { left: unique_ptr&lt;node&gt;, right: unique_ptr&lt;node&gt;, parent: *node, }; ``` In stable Rust currently there's no convenient equivalent for `*node`. Ideally, you should be able to use `NonNull&lt;Node&gt;` from the top-level comment, but at the moment, if I understand everything right, you need to use `*const Node` and then cast it to `*mut Node`. So this gives us the following picture ``` struct Node { left: Option&lt;Box&lt;Node&gt;&gt;, right: Option&lt;Box&lt;Node&gt;&gt;, parent: *const Node, } ```
If that helps, I have a red-black and a b-tree implementations lying around: https://github.com/matklad/tree_bench/tree/master/src. Red-Black tree is implemented using `unsafe` and raw pointers (and at least has wrong variance and probably quite a few other nomicon-grade bugs), B-Tree is implemented in a safe way, without parent pointers.
Data structures is this area in Rust that often requires unsafe code with a safe API area. It is possible to do them with Rc and weak references, but I feel like you won't be satisfied with it until you write it with some raw pointers inside. Coming from C++ background, it should not be _that_ scary. The one thing to stress though, is that the safe API in this case should be very similar to the one written with `Rc&lt;RefCell&lt;T&gt;&gt;`. For example, it should be possible to write tests for safe version, and then refactor it into unsafe implementation, and the tests should still pass. Similar to the approach taken in [linked lists book](http://cglab.ca/%7Eabeinges/blah/too-many-lists/book/) (highly recommended read!). By doing it this way, you can at least leverage the compiler to validate the API somewhat (and learn the upsides and downsides of different approach). Another highly recommended place to look for inspiration is the Rust standard library! All collections contain unsafe code, however, you will find that most of the code is safe, instead, there are sometimes special structures created for managing the unsafe part. This makes unsafe code much easier to reason about. And lastly, for some in-depth learning of unsafe, I recommend [Rust Nomicon](https://doc.rust-lang.org/nomicon/) for the best free in-depth book on unsafe, and [Programming Rust Chapter 21] for more academic and concise explanation (the information there is the same, except better structured).
But is it worth doing in practice? Like, is there any code in Servo which uses `Rc/Weak` combo purely to code around the borrow-checker, and not because there's some real dynamic ownership situation? At least in my experience, `Rc`s and `RefCell`s are a pain to work with: as soon as you add them, your stuff ceases to be thread safe, so you need to switch to `Arc` and `Mutex`, and that seems pretty horrible. And even then there's a high amount of boilerplate that remains to peel through layers of generics and to `.unwrap` stuff which is known to be non-null. And looks like it is almost always possible to use some sort of references or indexes to get a better solution. 
Don't think that's possible, references always need a lifetime specifier unless it can be inferred by the compiler. In a trait or struct however, the lifetime can't be inferred and thus you must specify one.
If implementers are allowed to borrow the data passed in as `raw`, then this is necessary, because the compile must make sure anything created by `foo(raw)` is disposed of before `raw`'s lifetime expires (even when in completely generic code. As an alternative you can require the return value of `foo(raw)` to have a static lifetime (that's effectively what not specifying it in the trait does), but then your implementation of `foo(raw)` for raw bytes will need to return an owned `Vec&lt;u8&gt;` or `Box&lt;[u8]&gt;`.
Servo uses Weak a couple of times, yeah. Perhaps not for this, but I can't recall any tree with parent pointers in the servo codebase, unsafe code or otherwise. This isn't "coding around" anything, this is exactly how those abstractions are meant to be used. RefCell is precisely for adding mutability to shared systems. Weak is precisely for dealing with cycles. You can create a wrapper around Weak that unwraps on deref in case you only care about delinking cycles on destruction.
Do you know how I can return a reference which was created from a pointer in a function? I have the reference but I can't return it because the compiler expects a lifetime parameter and when I add a lifetime parameter the compiler tells me it's not constrained
 &gt; is that the safe API in this case should be very similar to the one written with Rc&lt;RefCell&lt;T&gt;&gt; Thanks, Do you know how I can return a reference which was created from a pointer? I have the reference but I can't return it because the compiler expects a lifetime parameter and when I add a lifetime parameter the compiler tells me it's not constrained 
Yeah, I'd advise against writing data structures in Rust, even if it's just for learning. The inherent need for unsafe code doesn't really help a lot, since 99% of the time you're writing Rust you won't be needing unsafe. If I were you, I'd pick something else to help me understand rust, like implementing a web server, solving puzzles (sudoku, for example), solving programming challenges like Advent of Code, Project Euler, Tophacker, etc...
Thanks, that's a really good explanation
I ordered it on amazon.de last September and the shipment date got postponed multiple times. It should have gone out three days ago but was postponed again with an unknown delivery date... the only reason I'm not cancelling it is that my order still has the old price of 32 euros. If you really want the physical book and the costs are not a problem, you can get it from amazon.com for around ~50 euros, including delivery.
If I remember ticki changed his focus to other projects for a while. I'm believe TFS is still alive though.
"Functional" data structures that are acyclic and don't mutate without cloning aren't terribly difficult in safe Rust. (`Rc::make_mut` exists specifically for this purpose and is a good introduction to safe Rust's philosophy of isolated mutability. Read its source.) It also helps to think of recursive rather than iterative algorithms. Otherwise, yes, you're in `unsafe` territory, likely because cyclic references, shared mutability, and iterative algorithms are more difficult to prove correct. While safe Rust doesn't demand correctness, it does require you to implicitly prove safety, and that's harder to do in an environment with unpredictable interactions. Don't be too scared of `unsafe`. It still gives you a lot more structure than C++ 
While I certainly like the "if let Some(...)" syntax, matching a Result like if let Ok(x) = bar() { ... } is a cool way of ignoring errors, maybe you mean something like "if let Ok(...) = bar()?"? 
I think they want to say that a strict tree is compatible with plain ownership, and we don't need ownership: We have each parent own its children. However, with parent pointers, it is no longer a strict tree; it has a the structure of a graph with a cycle that connects the parent to each child and the child to its parent. So here some kind of more advanced (and tricky to implement in Rust) solution is needed.
Will ebook version being updated in the future?
Allow me to reiterate /u/nercury's suggestion to read [the Linked Lists book.](http://cglab.ca/%7Eabeinges/blah/too-many-lists/book/) It's worth your time. Reinventing the wheel on Linked Lists is **not** how I would recommend someone learn Rust. It's possible to implement Linked Lists entirely in safe Rust, but they concisely bundle up so much of the Rust learning curve into a single problem that it's bound to be a poor experience.
No, I didn't. I wanted to show pattern matching with another enum than Option :) As for ignoring errors, it makes sense occasionally. The designer of the API (who used `Result`) uses it to convey the details *if it matters to you*. In cases where you do not care (best effort processing), then you can certainly ignore the errors.
Does it only work on Linux, or will it work on macOS and other *nix-like OSes?
Something nobody has mentioned is to use indices into a vector to reference children and parent from each node instead of pointers. This way, the vector owns all nodes and dropping is easy and the ownership structure is super easy. One of the first things I created in rust was a Huffman tree using this method: https://github.com/cgm616/huffman-rs 
quick note: `wtf: PhantomData&lt;&amp;'a T&gt;` is the correct annotation. It takes up no space, as opposed to `&amp;'a PhantomData` which has to store an actual pointer.
NetworkManager has a [C api](https://developer.gnome.org/libnm/stable/NMVpnConnection.html) based on glib/gtk. It has lots of undocumented stuff - it's really a pain in the ass to work with it.
Can you write a review here when you finish it?
&gt; Understand what is possible with safe rust (cyclic data structures, like trees with parent pointers, are, in general, not possible). A lot of the boilerplate of cyclic structures can probably be abstracted away in a single unsafe library that exposes a safe interface though.
are you using rust in germany? if so ping me :)
One actionable thing I wish `ndarray` had is something like `Eigen3`'s Quick Reference page: https://eigen.tuxfamily.org/dox/group__QuickRefPage.html which provides many one liner examples of how to use the library.
The thing that scares me most on the [Vulnerabilities Table](https://curl.haxx.se/docs/vulnerabilities.html) isn’t even how long some of them went undiscovered, it’s the number of new vulnerabilities introduced in the past few releases. It really hammers home how hard it is to write safe C.
ebooks.com claim to be selling the title as DRM-free PDF/EPUB, if that's of interest. See [here](https://www.ebooks.com/95914803/programming-rust/blandy-jim-orendorff-jason/). I agree though, it is sad O'Reilly themselves are not.
ok, that's a good idea, I've filed an issue for that.
which line is it crashing after? are you literally seeing SIGSEGV or is it a panic? Do you have any more context to add? ssh2-rs is just a wrapper around the libssh2 library written in C, so it's easily possible for me to imagine a segfault to be occurring somewhere.
FWIW, I made a small Rc+RefCell-pointer a while ago. It has configurable memory overhead and poisoning support. You can find it in the [reffers crate](https://docs.rs/reffers/0.4.2/reffers/rc/index.html).
&gt; sess.handshake(&amp;tcp).unwrap(); at this point
Man, all these WASM projects are AWESOME. I'm so excited to see more mature toolchains come out for porting things to WASM, and then I'll be able to distribute certain tools however I like using mostly Rust! :) 
What message are you seeing in the crash?
nope Segmentation fault: 11
Thanks for the hint!
We can see [the code](http://alexcrichton.com/ssh2-rs/src/ssh2/session.rs.html#139) is literally just calling into the C library. We can see from [Session::new\(\)](http://alexcrichton.com/ssh2-rs/src/ssh2/session.rs.html#37) that it will return None if the C library returns a NULL pointer, and `Session::new().unwrap()` would have stopped the program there and spit out a nice error message if that had happened. Since we know we're getting back a non-NULL pointer, and then just directly passing that back to the C code, and then the C code is segfaulting... this is either a bug in the C code of `libssh2`, or there is something weird happening on your Mac. Have you followed the Mac-specific instructions [here](https://github.com/alexcrichton/ssh2-rs#building-on-osx-1010)? I feel like you had to, otherwise you wouldn't even able to run the code, but it's worth checking. This is all the help I can provide.
actually, someone reported a very similar issue here: https://github.com/alexcrichton/ssh2-rs/issues/54 Apparently, reinstalling libssh2 on their Mac solved the issue.
I've posted about this before in this subreddit, but I love how Rust makes my job so much easier for basically everything I care about as a systems programmer...even when I don't actually deploy it at work. Story time! **I've actually used Rust at work for quickly prototyping binary format parsers, and really enjoyed it.** I use those prototypes as reference implementations for the C++ versions that I later push to the company codebase. Why do it this way? Well...: * The binary format hasnt ever been written by somebody in the company, and I have to become the domain expert. **By using Rust, I avoid 90% of the initial safety and tooling headaches that are not essential to the parsing logic I'm trying to grok.** When I actually get to implementing the C++ version, my conceptual understanding hasn't suffered tons of "stretch marks" from dealing with unrelated safety and tooling concerns, and I feel much more confident I'm doing the right thing in production. * **Developing the prototypes usually take less than a day** for an MVP, and **because of `derive` trait magic I can get everything I could want when inspecting a parsed data set in minutes**: formatted `Debug` printing, a robust set of tools for determining parse failures using `failure`, and easy reuse of existing crates with `crates.io`, `cargo`, and the `docs.rs` website. * As an added bonus (because I LOVE this community!), it's not too hard to turn my binary format parsers into crates that can then turn around and give back to the community. I'm excited to share what I've been doing with the community soon -- I just need to make some time to publish the work I've done, now that Christmas craziness has come and gone. :)
We do what we must, because we can.
*go completions. Rust completions work perfectly for me, all set up.
I'm also hitting this. Unfortunately it's not giving me much else in the way of information to diagnose it. Too bad as it solved an annoying case I was avoiding refactoring into an ugly block. 
This is, as far as I know, how crates like [petgraph](https://github.com/bluss/petgraph) are implemented. It's pretty cool.
For those others who were confused, to press start you hit the enter key ;)
Very cool! Too bad firefox chokes a little on it
It doesn't work because your code is not valid semantically. What `fn foo(raw: &amp;[u8]) -&gt; Self;` is syntactic sugar for `fn foo&lt;'a&gt; (raw: &amp;[u8]) -&gt; Self;`; the `'a` lifetime is universally qualified with no further restriction. This means that the trait definition itself says that an implementation of this trait can take _any_ `[u8]` slice no matter its lifetime. Every single implementation of this trait must conform to this. In your particular case this isn't valid no matter how you put it. Even _if_ you do `imp&lt;'a&gt; Foo for &amp;'a [u8]` that is one specific quantification. Inside the function itself it will then use `'b` as universal lifetime quantification; while both are indeed universal they can still be _different_. What the code then says is that "for any single `[u8]` slice with whatever lifetime whatsoever we can take _any other_ `[u8]` slice with any other lifetime and convert one to each other. And if the timetime of the latter one is shorter than that of the former one then you have yourself undefined behaviour of course. So what you are trying to do is fundamentally unsafe. You just take _any_ slice with any lifetime and convert it to any other slice with any other lifetime in the case the former is shorter than the latter you're trying to perform the dangerously unsafe operation of lifetime extension which is for very good reasons not allowed in safe code. So you have to in some way limit the lifetime that the input value of `raw` can be in the trait; it has to be written down for a good reason.
I've written a few data-structures in C++, I inevitably make a few mistakes (read: crashes) along the way. Once I'm finally satisfied that my thing is not a complete, that is when the test suite I thought up passes (and is valgrind clean), I'm always left to wonder which case I forgot to consider which will crash in production. The same experience in (safe) Rust is very different because it forces you to solve *upfront* all those issues that you would discover (hopefully) little by little in C++. And yes, this means a rather frustrating experience to line up all the pieces when trying to migrate C++ code 1-to-1. There are multiple ways to solve this problem, `unsafe` is not one of them. `unsafe` code is **harder** to write than C++ code, because not only do you have to get the logic correct (as you would in C++), you also have to obey the myriad Rust invariants which are not quite yet formulated. `unsafe` code is therefore the **last** tool you should reach for, especially as a beginner. If you cannot understand how Ownership and Borrowing work when the compiler helps, what are the chances you will when turning it off? --- So, first solution, think modern C++. If you were forbidden to use `new` and `delete`, which types would you use? Most likely `std::shared_ptr` for the pointers to child and `std::weak_ptr` for the pointer to the parent. Well, you can do that in Rust (it's called `Rc` and `Weak`, respectively), sprinkling a `Cell` on top to get mutability back. That is: // MoveCell from https://github.com/SimonSapin/rust-movecell/blob/master/lib.rs // I prefer it to RefCell for education purposes because it makes ownership issues apparent at compile-time. struct ChildPtr&lt;T&gt;(Rc&lt;MoveCell&lt;NodeData&lt;T&gt;&gt;&gt;); struct ParentPtr&lt;T&gt;(Weak&lt;MoveCell&lt;NodeData&lt;T&gt;&gt;&gt;); struct NodeData&lt;T&gt; { value: T, left: Option&lt;ChildPtr&lt;T&gt;&gt;, right: Option&lt;ChildPtr&lt;T&gt;&gt;, parent: Option&lt;ParentPtr&lt;T&gt;&gt;, } --- Honestly, though, that's not the solution I would aim for to start with. On top of being daunting, it's also not that great performance-wise why with the memory scattered all over the place! If I were you, I would go back to the basics: struct Tree&lt;T&gt;(Vec&lt;Option&lt;T&gt;&gt;); Most trees and heaps can be encoded in an array. As a bonus, it's often possible to handle all those "child"/"parent" pointers *implicitly*. A simple index type illustrate the implicit encoding of child/parent relationship: pub struct TreeIndex(usize); impl TreeIndex { pub fn root() -&gt; Self { TreeIndex(0) } pub fn parent(&amp;self) -&gt; Self { TreeIndex(self.0 / 2) } pub fn left_child(&amp;self) -&gt; Self { TreeIndex(self.0 * 2 + 1) } pub fn right_child(&amp;self) -&gt; Self { TreeIndex(self.0 * 2 + 2) } } And here is a sketch of a minimal manipulation API. Note that it does NOT maintain any useful tree properties, such as guaranteeing that if `2 * N + 1` is set, then `N` is too (which is why the methods are private). It's useful, however, as a stepping stone to implement the full Tree API on top of. impl&lt;T&gt; Tree&lt;T&gt; { fn get&lt;'a&gt;(&amp;'a self, index: TreeIndex) -&gt; Option&lt;&amp;'a T&gt; { self.get(index.0).and_then(|o| o.as_ref()) } fn replace&lt;'a&gt;(&amp;'a mut self, index: TreeIndex, t: Option&lt;T&gt;) -&gt; Option&lt;T&gt; { std::mem::replace(self.get_mut(index.0), t) } } And it's also useful to demonstrate that it's perfectly feasible to get *both* safe and easy. *Note: the trick, of course, is that `Vec` itself is using `unsafe` under the hood; but hey, the whole point about "standing on the shoulders of giants" is to reuse code! Especially well-trodden code that is likely correct.* 
I thought llvm would be the trickiest part of rustc, but maybe not!
For fuck sake has science gone too far?
This is exactly the kind of things for which I find the recent posting we had about "being pragmatic" and wrapping C libraries instead of writing fresh Rust code not *that* pragmatic. Reusing C is a shortcut, sure, but what the hell is that error :( ? How come "re-installing" fixes the issue? *sigh*
This is a middle ground in safety, caution still needs to be applied writing the interior algorithms for a crate using these techniques. 
&gt; I wonder if you'd get performance increases by transpiling the nes opcodes to wasm and running using whatever browser API. Unfortunately it's not that simple. (: Statically transpiling 6502 code into anything else is an impossible task**, the best you can do is dynamic recompilation, which in this case probably wouldn't really work due to WebAssembly compilation being very heavy. ** - For example, NES games frequently use techniques like self modyfing code which are not possible to translate statically. Let's say you have a piece of code which you need to run a bunch times. So you make a loop. But NES' 6502 CPU has only two registers, so you *really* don't want to waste any of them for the loop counter. So what do you do? After each loop iteration you modify the instruction itself and decrement the loop counter hardcoded in it. That said, I'm pretty sure there are plenty of optimization opportunities out there, as I've made no effort whatsoever to optimize my emulator.
Exactly this. If you're using less than several 10s or possibly even several 100s (I've only benched up to 100ish for my use case) linear search is *much* faster due to being far more cache friendly.
Ah right, I forgot to write what is start and select! Thank you!
Cool thing! One more gameplay related remark: XZ for control is not really ideal on QWERTZ keyboard layouts, where X and Z are far apart. Something like AS, or XC should work well out of the box in more countries.
sigh!! I have to update my xcode ! and with current internet speed I think I'll be done with that in 2 days !
&gt; So what do you do? After each loop iteration you modify the instruction itself and decrement the loop counter hardcoded in it. Jeez, that's pretty hardcore.
Tricks like that were pretty common in old consoles and computers! Which is why just because a given system is old it doesn't mean it's easy to emulate, unfortunately. And the more accurate you are the slower the emulation is.
Doesn't work unless the refresh rate is 60 :(
Since I'm using [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) I guess that's true, sorry! What's your refresh rate? 144Hz?
They're right next to each other on my qwerty.
He's talking about qwertz, not qwerty.
Well, people did compile webkit to asm.js back in the day :) https://trevorlinton.github.io/
Very odd. You’d want to set the bench profile to have debuginfo, and should be able to debug it with VS, or Code.
Yeah, 144.
&gt; Too bad firefox chokes a little on it. No issues on my end.
That is the most ridiculous thing I've ever seen
There *is* an easy-to-use HTTP client in Rust, backed by Hyper. It's called [Reqwest](https://github.com/seanmonstar/reqwest).
gdb or asan, learn the tools
How about Netscape running on Windows 3.1 running on DosBox ported to wasm and running inside firefox? https://twitter.com/peerigon/status/923570919758540800
I wonder if you could compile qemu to wasm. Could be very cool.
&gt;Its design elements came from a wide range of sources. &gt;Channels and Concurrency : Newsqueak, Alef, Limbo &gt;Message passing and Thread failure : Erlang My understanding was that the Erlang influence was essentially dropped in the language design, but was an idea at the start. Also, does Rust have any built in channel or concurrency model? I thought that all of this was handled in other crates and not in the core language.
What you can do is allocate using `Vec::with_capacity(n)`. Insert all of your elements into the vector. Then call `into_boxed_slice`. Your can then turn that slice into `Box&lt;[T; n]&gt;` via `Box::from_raw(Box::into_raw(b) as *nut [T; n])`. Hope that helps!
out of curiosity, why do you then re-implement in c++? because that's what's expected in the company codebase? performance? something else? 
It's definitely because C++ is the de-facto codebase language; I don't have much influencing power yet, since my tenure at the company is still really short compared to some dozen-year vets here. Rust adoption hasn't happened...hopefully yet, if there's a good opportunity to make a strong pitch and I'm at this company longer. :) I came on recently, but I definitely think that there's room for what Rust has to offer somewhere down the road!
It's probably the best solution for converting HTML into a bitmap graphic. There's actually no way to do that properly using a browser's rendering engine directly (with the exception of embedding the HTML into SVG as a foreignObject and then rasterizing the SVG, which is also a big hack that doesn't work in all browsers).
I get wanting `if let` to be different, but a simple `if` of a large conjunction is better calculated outside of the statement. let in_range = minimum_x &lt;= lowest_x &amp;&amp; largest_x &lt;= maximum_x &amp;&amp; minimum_y &lt;= lowest_y &amp;&amp; largest_y &lt;= maximum_y &amp;&amp; minimum_z &lt;= lowest_z &amp;&amp; largest_z &lt;= maximum_z; if in_range { ... } 
Yes, thanks so much! I'm surprised I didn't think about converting a `Vec` like that; I've glanced over those methods so many times in the documentation but never realized how useful that is.
Threads are. If you have threads (or can fake them enough - you don't need multi-tasking AFAIK, just TLS), and a decent POSIX base, rustc should run just fine on anything with enough address space for all the allocations (e.g. for bootstrapping itself). Bonus: you shouldn't even need floating-point but we don't have a way of enforcing it. Quite the irony if you run it on asm.js.
I would still just use `Vec::into_boxed_slice()` to get a `Box&lt;[T]&gt;` though, unless you *really* need the fixed-size array. Fixed-size arrays tend to be a bit more finicky to use than slices, since at sizes &gt;32 they don't implement various nice traits... so I find myself converting them into slices quite often anyway.
What's great about this way of doing it is that the only "unsafe" part is the final box conversation to a static size.
If you include the debuginfo, yes.
Here's a splay tree with parent pointers implemented using an arena. It's actually pretty simple: [code](https://github.com/stjepang/vec-arena/blob/master/examples/splay_tree.rs) And here's a similar implementation in C++ using `new`/`delete` so you can compare them: [code](https://gist.github.com/stjepang/8ac006c7b90bd86631951f59b7969ec7)
In my experience, fixed size arrays almost always coerce into slices. I personally don't like to keep the runtime length if I know in dealing with a static size.
Looks nice! Also pretty cool that you were able to write so much web stuff in Rust. I feel ya on the WebAudio stuff too -- I ended up doing the same in my GB emulator [binjgb](https://github.com/binji/binjgb/blob/master/demo/demo.js#L166), but it makes me sad there isn't a better way until AudioWorklets are supported everywhere.
Define a trait with that function, then implement it for the type you want. [Example](https://play.rust-lang.org/?gist=cae6efe32679ee904b36a37cd6498d1c&amp;version=stable).
I've found this to be very true, but I don't think it's guaranteed. I mean, as llogiq said, there can be logic bugs. In most cases though, my development cycle is indeed to write some code, do a few cycles of "try to compile -&gt; fix compile error", then have it work. I mean occasionally I will literally forget to write some code, but everything I miss ends up being fairly obvious. I'd put it more like "if it compiles, the only bugs left are the obvious ones": rust does a very good job of removing any edge cases.
It is pretty bad on french AZERTY keyboard too. An option to select the keys would be great
The next step is a Firefox extension that replaces Travis. Just visit your project page on Github, and your browser compiles it and runs the test suite locally.
The only sense that concurrency is "built in" is that Send and Sync are lang items, IIRC.
wondering why is not accessible from /r/rust list? 
I dunno man. But, I bet it's possible.
Hmm. That might actually be possible.
If you look at the source code of LinkedList&lt;T&gt; (https://doc.rust-lang.org/src/alloc/linked_list.rs.html), **unsafe** has been used 29 times and also some of the features used in unsafe such as ptr::Shared are unstable and only available in nightly.
Maybe Rust should start shipping Clang along with its LLVM?
Try `let chunk: Box&lt;[[[u8; X]; Y]; Z]&gt; = Default::default()`. That should heap-allocate immediately without having to transfer from the stack, use u8's default of 0 for each value, and not need Vec's overhead during intialization. The difference is relatively minor but more concise. You can then fill the data however you want to. It's better to use multi-level arrays in Rust because it more clearly reflects your intention while still being represented exactly as you expect in memory (i.e., one 262,144 byte block). The performance is the same either way.
While the stack overflow only happens under some circumstances, you can get a guaranteed heap allocation without a move via `impl&lt;T&gt; Default for Box&lt;T&gt; where T: Default`. https://play.rust-lang.org/?gist=7bc9d33f9e3efa4110490fb7d3f6c8c4&amp;version=stable I believe this will only work for arrays up to size 32. But you can use multi-level arrays and still get the same in-memory representation as a single flat array. The element type itself just needs have a Default impl. But for programmatic generation, I'm not certain there is an easy way. You will probably want to encapsulate the data in a type and ensure the size invariant yourself, as you mentioned. That will also let you change your internal storage for voxels later without affecting the rest of your code.
I think qemu can run without privileged instructions, so it's really figuring out how to do something useful. You can't exactly do much with WASM yet since there are no threads, network stack, or graphics, so there will be quite a lot of fudgery to get an interesting demo going.
It works on macOS, other Unixen, and on Windows, provided you have SDL2 compiled.
/r/playrust
Good reasons, then!
`std::mem::zeroed()`
Cool, thanks. 
HTTP/1.1 defines and requires the `Host` header; but there are still a few HTTP/1.0 clients in use, some of which haven’t backported the `Host` header. Fortunately, most web servers require the `Host` header to disambiguate multiple virtual hosts, because without it you need one IP address per hostname. (HTTPS required one IP address per hostname for a long time also, but SNI is being depended upon by a progressively larger and larger fraction of the internet, so for most things it’s OK to depend on it.) So: if you want to support everyone imaginable, then you cannot necessarily know the URL the user used to perform the current request. But it’s fairly safe in general to assume the presence of the Host header if HTTP/1 is being used, and so, provided you’re willing to make that assumption you can know the full URL of a request.
Trying to write about Vulkan+Rust as "comprehensively" as I can. I am a beginner myself, so trying to keep track of all the bits that confuse me as I am working through them, and writing down how I got past the confusion. Aim is to have enough of a guide for Vulkan + Ash (a lightweight Rust wrapper around Vulkan), so that we basically have a Rust version of this tutorial: https://vulkan.lunarg.com/doc/view/1.0.57.0/windows/tutorial/html/index.html Just finished understanding [how Ash generates, using macros,](https://github.com/MaikKlein/ash/blob/bfd05ea8e9f0d2dab8e342cf1a8fdbcdb18e2d47/ash/src/vk.rs#L3936) wrappers around some of the most basic Vulkan API commands. 
Oh, so slab crate allows even deletion of items? Nifty!
Should I learn neovim, vim, or neither?
Ah yes, you're totally right! Sorry! I just had a brain fart there.
Where can we find more details on Hyper H2 support Sean?
Cool! I ended up buying it too, because I agree that having a comprehensive resource all in one place is nice. 
Yes it does! Although it only supports two, namely MMC1 (1) and UxROM (2). You can [check out this list](http://tuxnes.sourceforge.net/nesmapper.txt) to see which games use which mapper.
Laziness or ignorance are the usual reasons
&gt; Even some native games are this way, and for no good reason that I'm aware of. Yeah... some... Crysis is the only counter example I've ever personally seen.
I think you're on the right track with C APIs here. I'm not sure if the in-memory representation of `extern "C" fn(i32) -&gt; i32` is guaranteed in rust, but the in-memory representation of `usize` is. If a C api required a function pointer, that would be how to get one. It might also be useful for debugging, if you're wanting to quickly compare two function pointers to see if they're the same? With all that said, it could also just be a side effect of that `fn()` pointers are really just fancy `usize` wrappers. You're allowed to cast any `*const _` and `*mut _` to integers as well just because, well, it's what they are. It can be useful for debugging if nothing else.
For the mutability, this is something I had to get used too, and I'll let someone else explain it more fully. In short, the owner of the data fully controls mutability, and if you don't want something modified it's best to keep it private (non-pub field) and only allow access to it via a read-only method. For lifetime parameters, you're using one of the two "function" constructs in rust. `Fn` represents both functions and _closures_, which can copy/store data captured from their environment. This is why it isn't cloneable - you're allowing any Fn capturing any data to be used. If you wanted to only allow functions (and not closures), you can use `fn(i32) -&gt; i32` (note the lower case). `fn()` is guaranteed to be just a function pointer, so it can be freely copied and doesn't need to be stored behind a reference. For three: generic over what in particular? It would help if you could elaborate here, and possibly share some of the code which doesn't work. We can definitely help with compiler errors, but we can't if we don't know what the problem is or what's errorring.
how can i get it? `req.headers().get_raw("host").unwrap()` --- and what's the next, how to convert it into a string?
We design and implement a similar system like [scuttlebutt](https://github.com/dominictarr/scuttlebutt). I'm doing it in rust: [here](https://github.com/susu/kutyus-rs). My friend in Haskell: [here](https://github.com/PeterHajdu/kutyus-hs). It is still in a PoC-state, be careful :D
&gt; Also, does Rust have any built in channel Yes, the standard library has channels.
I agree. Just want to add that I suspect this follow the same safety semantics as raw pointers. I.e. It's safe to create (and manipulate) raw pointers. But it's not safe to dereference them since they might point to invalid memory.
For generics, there's a [good chapter in tho book about that](https://doc.rust-lang.org/book/second-edition/ch10-01-syntax.html). To make the `Cache` generic over all inputs `I` and all outputs `O` you write: struct Cacher&lt;'a, I, O&gt; { function: &amp;'a (Fn(I) -&gt; O), cache: HashMap&lt;I, O&gt;, } To make the `impl` generic you can do: impl&lt;'a, I, O&gt; Cacher&lt;'a, I, O&gt; { fn call(&amp;mut self, key: I) -&gt; O { ... 
I usually just switch to QWERTY when playing a game that doesn't support layouts correctly.
On a related note, wouldn't there be a faster and/or better way to initialize the array with identical elements?
That seems to be working approach :) In the meantime I came up with this: .for_each(move |(upgrade, addr)| { // ... }) .or_else(|_|{ // Ignore the errors in the last step by returning `()` match 1 { // this needed to let the compiler infer the error type 1 =&gt; Ok(()), _ =&gt; Err(()) } });
&gt; The KeyboardEvent.code property represents a physical key on the keyboard (as opposed to the character generated by pressing the key). &gt; This property is useful when you want to handle keys based on their physical positions on the input device rather than the characters associated with those keys; this is especially common when writing code to handle input for games which simulate a gamepad-like environment using keys on the keyboard. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
Okay, we can play the reference game. From that very page: &gt; Basic Support &gt; - Chrome: 48 - Firefox: 32 - Internet Explorer: No support - Microsoft Edge: No support - Opera: Yes - Safari: 10.1 In other words, not supported on IE, Edge, or until recent Safari. Now in my experience, even the most forward thinking developers don't completely drop the ball on Edge or latest IE support, typically at least IE 9 or 10 is a reasonable cutoff. And there's no trivial polyfill. So the chances of this being used are next do zero. Again, anecdotally, I've literally never seen a web game use these.
Not really. It can be optimized to use some simd operations, but I don't think it's that slow to begin with.
Missed that, just remembered this because I used it when I wrote my first small game with Rust + wasm... Still, Chrome represents a large majority of web users, and most people using Safari are using v11 (according to caniuse.com). Seems like it would be easy to start using this and then only IE/Edge wouldn’t have support for anything other than QWERTY... But still, if most webgames doesn’t use it then I guess it’s a problem. I personally use QWERTY so I haven’t noticed...
Right. https://github.com/metal-os/os
One way you can remove the lifetime fields and make the struct and implementation "generic" (in one dimension) is struct Cacher&lt;F: Fn(i32) -&gt; i32&gt; { function: F, cache: HashMap&lt;i32, i32&gt;, } This changes your `Cacher` to depend on the type of function you are caching, which (i) allows the implementation to inline that function as appropriate, and store any closed-over state in-line, but (ii) makes instances of this type used for different functions incompatible. Fortunately, I believe the type `&amp;Fn(x) -&gt; x` implements the trait `Fn(x) -&gt; x`, so you can recover your generic implementation by using that type, if you are so inclined.
&gt; So what you are trying to do is fundamentally unsafe. That's not what they're _trying_ to do; what they want is to have a single lifetime quantified at the impl level as normal, but to have some syntax sugar like the one that works at the function level. The short answer is: no, the language doesn't currently have any such sugar.
The problem is when it's a multiplayer game, you are no longer able to chat if you are used to another layout (either because you don't know QWERTY, or just because you are way slower in QWERTY than in your layout).
Eventmachine in Ruby. 
Here's my take on it: https://gist.github.com/m1el/4583d806cc58640b34565fe0218e7551
Call [`one()`](https://docs.rs/hyper/0.11.10/hyper/header/struct.Raw.html#method.one), it will return the first (usually the only) value of that header as `&amp;[u8]`. From there, as long as it is valid UTF-8, you can use [`str::from_utf8`](https://doc.rust-lang.org/std/str/fn.from_utf8.html).
From how you're asking the question I see you don't use either, so what you start with doesn't really matter, it will be some time until you see a difference between those. EXCEPT that neovim has a lot saner defaults and you can just start using it, while for vim you'd probably want to google a "minimal sane .vimrc" or something like that. I'm a huge (neo)vim fan, so I'd say you should, but there's basically no real way to tell unless you worked your way in somewhat. Give it a shot (`vimtutor` is your friend!), and if you have further questions, /r/neovim and /r/vim are there to help (I'll only vouch for the first one to be a friendly place though, the second is much more active, but a bit daunting at times).
It does have [`std::sync::mpsc`](https://doc.rust-lang.org/std/sync/mpsc/), which offers multi-producer single consumer channels which can be used for passing messages between threads. But they are somewhat limited, and expected to be deprecated at some point in the future.
RUST_BACKTRACE="1" should produce a backtrace as well.
True. I'm used to switch so I can manage, but it shouldn't still be an issue nowadays.
ah, lol, missed that :) whoops
The example in the [documentation](https://doc.rust-lang.org/std/net/struct.TcpListener.html) says `TcpListener::bind()`, but you wrote `TcpListener.bind()`. The `::` syntax is for static methods (those that don't have a `self` parameter), while the `.` syntax expects a value (struct instance) as the self parameter. Since you're calling it on the type itself, and not on an instance of the type, you get an error. The error tells you some of this: a value was expected before the `.`, but the type itself was found. The error message could be clearer, especially since "found struct `TcpListener`" can also be interpreted as an instance of the struct (and I think the same text is use for a value when trying to pass a value as a reference). The suggestion should definitely be to suggest to use `::` for the use of a static method. 
Sigh, of course, thanks!
"doesn't use garbage collection by default" implies it can be turned on, although the only way to get GC is using a library and deriving a trait for the types you want to have automatic memory management for.
I am currently starting to read The Rust Book, and i am wondering: what are the advantages/drawbacks of your tutorial compared to TRB ?
Amazing work! I'm a front end dev and want to use wasm, do you advice me to use rust? For what i've seen, is the most atractive and has a very good community. Can you give some useful links and docs? Thanks in advance!
O(1) vs O(n) lookups? 
Does the `vec![val, len]` thing not initialize a vector of length `len` with so many copies of `val` anymore? I found some posts on the internet that suggest that it works that way, but it seems to just construct a vector like `{1,2,3,4,5}` when you use `vec![1,2,3,4,5]`. I try to construct a vector with a certain initial size (like you would in C++ via `vector&lt;T&gt;(len, val)`.
You should check out the official rust irc channels. The guys and gals on there are super helpful and would a problem like this one in a matter of seconds.
&gt; Does the `vec![val, len]` thing not initialize a vector of length len with so many copies of val anymore? Put a semicolon instead of a comma before the length. (It uses the same syntax as arrays.) [Example code](https://play.rust-lang.org/?gist=49dbe7417013fb9a574bfd561ff0a05f&amp;version=stable) &gt; I try to construct a vector with a certain initial size Do you need to also set the elements to a specific value? You can get an _empty_ vector with a specific _capacity_ (size of its internal allocation/buffer) using `Vec::with_capacity(len)`.
Aw man, I'm stupid. I really missed the fact that it has to be a semicolon, thanks a lot! &gt;Do you need to also set the elements to a specific value? Not necessarily I suppose, since all values will be set anyway, but I'd like to access them via the [] operator. I think the macro will do the trick for now! 
Writing an [ogg-parser](https://github.com/fsasm/rogg) with nom and eventually playing Vorbis files. 
The book is much, much longer. If that's an advantage or a disadvantage depends on you :)
rc/arc is also technically gc
I can't agree with that. How I see it, the fundamental difference between reference-counted memory management and garbage collection is that in the former resources get released once they're no longer needed, while the latter reclaims memory only when needed. As a consequence, GC makes no guarantees about whether a resource gets released or not. This is especially annoying in game development where your resources are allocated on the GPU and you want to free them once you no longer reference them.
Sure. Most people are with you. According to the literature, though, both reference counting and tracing are different forms of garbage collection. In industry, "garbage collection" == "tracing garbage collection", but in academia, it does not.
I just finished a Taylor series for sin in rust. It's my first major(ish) rust project and I honestly feel really good about it.
FTFY: s/would/would resolve/ :)
What a humble response! Seriously, though, I hate those moments where I work myself into a mental corner where I know I'm missing something I know is going to be obvious in retrospect... #everyday
I couldn't leave this problem off my head; went ahead and installed wireshark and captured the packets. I had uploaded the pcap to my repo. the funny thing is that server is sending an RST flag terminating the TCP connection. Transmission Control Protocol, Src Port: 59606, Dst Port: 443, Seq: 0, Len: 0 would a high port of 59606 be a cause of issue? any pointers? https://gist.github.com/harrydevnull/690950b28617846b36d00092ec8490ee
Yes. See for instance [regex-capi](https://github.com/rust-lang/regex/tree/master/regex-capi) for C bindings to the Rust regex engine, or [cbindgen](https://github.com/eqrion/cbindgen) for automatically building C header files from an `extern "C"` interface.
Ah, that makes sense. I guess I was looking at it from only the practical side :) Independent of that, I just wanted to note that it sounds a bit confusing to me.
you can try [actix](https://github.com/actix/actix-web) api is stable, just waiting for h2 release
here is [user guide](https://actix.github.io/actix-web/guide/qs_2.html)
&gt; The problem is when it's a multiplayer game, you are no longer able to chat if you are used to another layout (Background: I use Dvorak myself) A fun hack I used to use - I wrote myself an LD_PRELOAD `.so` which intercepted my every keypress and made the game think I'm using QWERTY. (It basically switched the keyboard layout only for that one application.) If I pressed the button which opened the chat it reverted my keyboard to my usual Dvorak layout - I then comfortably could write whatever I want to write, and pressed Enter, which prompted my little hack to switch my keyboard layout back to QWERTY so that I can play the game.
I've started logging my time while working. I'm hoping it will improve my focus when I sit down to program. Instead of just writing each time stamp in a notebook, I figured I'd write a simple tool that will track the time for me with a button click to make logging simpler and so I can have it spit out a csv for some graph porn. Since I've just started learning Rust, I thought it would be a good first project that I can actually finish. Plus, I might get some real world use out of it. I'll be writing the very simple GUI with the help of glium. One of my goals is to avoid many libraries so that I'm forced to come up with my own solutions instead of spending my time learning libraries rather than problem solving. I'm still not sure what to call it. Its code name is 'tracks' for now. Any suggestions on a better name?
It's all good! This is more of a "maybe they wrote it this way because of this" than a "YOU"RE WRONG!!!"
Yay for more docs!
https://www.reddit.com/r/rust/comments/7nn3mc/sapper_web_framework_has_a_new_english_tutorial/
A small thing bugged me: Flask is a micro-framework not an mvc framework. Based on a brief glance at Falcon I think they see themselves the same way.
Yes.
async?
apparently not &gt; Sapper is based on Hyper 0.10.13, now using sync net mode, when async/await are ready, Sapper will follow it to walk to async framework.
I've been working on one of those! It's still in development, but I'm actively dog fooding with another side project of mine. It's heavily based off of the koa pattern from node is https://github.com/trezm/Fanta/blob/master/README.md
In general, the place to start on topics like this is [here](http://www.arewewebyet.org/). I haven't used it yet, but it seems like an answer to your specific ask might be [Gotham](https://gotham.rs/).
does it use hyper?
bingo. now re-read my question
No, it doesn’t. But it uses http crate. Do you have specific requirements for hyper?
&gt; I wonder if you'd get performance increases by transpiling the nes opcodes to wasm and running using whatever browser API. Funny, I was just looking into this (and other [similar ideas](https://github.com/cretz/software-ideas/issues/69)). The problem is one of timing. There are no WASM interrupts, sleeps, etc. So the game would go much too fast. After every WASM instruction you would have to have some `checkTiming` type call interlaced, and that would need to sleep as long as it needed to to maintain cycle accuracy (or just frame accuracy). Neither WASM nor JS offer a way to pause execution asynchronously, meaning you'd just be spinning which is not cool (I guess I could look into web workers).
This is awesome!
Well, you may want to have stuff like static file handling, file upload, powerful routing, etc. Having an API also makes it easier to create an ecosystem (look at Flask in Python, for instance). Not everything needs to be Rails.
That's awesome! Can I get a link? And btw, do you think it could be considered as hacking and thus getting banned for a Blizzard game? *A friendly* bépo *user (french dvorak)*
TWiR plus new [bytecount](https://github.com/llogiq/bytecount) and [flamer](https://github.com/llogiq/flamer) releases.
I personally would love an `if ! let`, if only so I can stop writing if let Common = expr { } else { handle_error(); } // continue without drift
One of those (I think Sync) isn't a lang item anymore.
Yeah I like that definition, but it doesn't really change much. React is "just a library", but you wouldn't say like "Yeah this is a vanilla JS app. Oh and btw we're using React."
Those are fair points. With that in mind, I agree with OP's question and am dismayed at the lack of good async frameworks. Good that Gotham exists, though.
If hyper will do, then use it. It is a library by design, and it's better that way. If you want to make a hyper Service run as a web server with a thread pool, it's 2 lines of code. If you want to integrate it into your existing app, it's also 2 lines of code. Rocket is great too. You might want to reconsider your stance against nightly Rust for production. Nightly doesn't mean you're always stuck with an unstable compiler and toolchain. You are free to stick to any day's Rust compiler version you choose. We typically update with Rustup every 2 weeks or so. Is it more work than using Stable? Yes. Is that extra work warranted by new, great features? I think so. The thing about nightly and unstable libraries in Rust, is your surprises are going to be at compile time. I have never, in 3+ years of having Rust in various states of production, had some functionality surprise me while the code was running. I have both hyper and Rocket servers running in beta, and being less than 1.0 or being on nightly Rust is the least of my worries. 
This was awesome, thanks! By the way, could someone tell me why memory is leaking at such pace? If I continue pressing "Run", memory requirements double almost every few runs. Is it somehow related to underlying allocator?
https://github.com/mehcode/shio-rs seems to be the closest
if Rocket fast, then Iron is faster anyway. 
[removed]
If I had to guess, it's due to a combination of a certain coding technique combined with wasm's constraints. To put it in a low-level sense, wasm includes `sbrk`, but with only positive arguments. That is, you can request more memory, but you can't give it back. So unless it re-uses the same previous memory for the compilation, it's going to grow and grow forever. I bet the allocator implementation isn't smart enough in a wasm context. That's all just a guess though.
I wonder, what is good about Gotham?
Do you use C or C++ professionally? I do. We've got a CI pipeline with both unit testing and high-level regression testing, we use valgrind, ASan and UBSan in the pipeline, ... and it's not enough. There are regularly crashes in production (say, monthly? bi-monthly?) and often times the source code where the crash occurs has not been touched for a long time. It just "happened to work" until then for some reason: assumption that no longer holds, timing issue, mystery, ... Anyway! What I find strange in this particular case is the "re-installing" bit. I hate when re-installing magically fix stuff because it means it was not stable in the first place. Something must have happened, it may happen again, and we have no clue about the cause.
Well, after authors of frameworks suggested to use diesel with Gotham, I would be very careful. Anyone who suggest to use sync database orm with async web framework is very questionable. There are other frameworks which work on stable.
Nightly exists for good reason. I'm glad we have nightly. I wouldn't personally use it for anything in production though. Stability guarantees are very nice.
I mean, you just use something like tokio-cpupool, no?
Sure, but what is the point of async web framework then? Sync framework would work better in this case
Can you explain what motivates you to only look for async frameworks? I don't really understand being so concerned about speed without even testing a realistic scenario (one that's close to your test case) on each framework. Sure, tokio-minihttp handles a gazillion "Hello world" requests like a champ... until you actually write your app and realize it's very CPU limited and handling I/O effectively is just a tiny detail in the big picture. Might happen, might not happen, but your requirements sound a lot like premature optimization.
Yes, and everytime one says that reference-counting is not a GC, an unhelpful pedantic pops us and argues that Yes, It Is! :(
Unfortunately, the reason why is that my type can _not_ implement `Copy`. There is no implementation for `HashMap` and `String`, and I have members of that type.
Phew! I was starting to question my aging nerd memory!
I think only postgres has async driver. But does it really matter? we are not in world on python or ruby where it is not possible to run code in parallel. async and sync code can coexists in same process.
It's safe if and only if you handle everything safe code can do with it. Dropping is a safe operation, so you do have to handle the possibility of a cloned struct being dropped if you implement both. Do note that this is totally possible! `Arc`, for instance, is both cloneable and implements `Drop`. You just have to make sure all safe code possibly still upholds invariants of any unsafe code you have.
Oh totally, I was just curious. I just use diesel and haven't worried about it.
&gt; And main needs to import file1 and file2. And file1 needs to import file2. When you say "import", what specifically do you mean? Generally, you don't want two whole copies of a module in the same project. What I would do is: 1. `mod file1; mod file2;` in `main.rs` 2. use `use` to bring whatever you need into scope where you need it.
I haven't gotten around to freeing blocks after running. It allocates fresh blocks for static storage and stack each run. Reboot kills the web worker, freeing it all.
`main.rs` is going to have to state the existence of `file1.rs` and `file2.rs` with `mod` declarations: mod file1; mod file2; then, in `file1.rs`, you need to pull `file2` into scope with `use`. use file2; or use file2::specific_function; The Rust module system is definitely a bit confusing at first.
I can't guarantee any will require new modules, but implementing missing features on existing rust crates is totally doable! I'd recommend starting at https://www.rustaceans.org/findwork/. This has links to a bunch of different rust projects with easy-to-work-on issues which you can contribute to. Not all all new features, but they might be good nonetheless to get started. If you're looking to make a new crate, the best advice I can give you is to think of something you might want a library for in rust, search for it in https://crates.io/, and find one with no crates doing it. #rust on the mozilla IRC might also be a good place to ask or check if something hasn't been done yet.
I need more info for that, as there's nothing about an `email` in what you've given me.
Rust's module system is hygenic, so unlike C/C++ it doesn't pollute your namespace with all the elements in a file. if `email` is inside `file2`, then you need to either: use file2::email; to bring the identifier `email` into scope. Or, you can just use the fully qualified path to call it directly: file2::email(arg1, arg2) (assuming it's a function. if it's not a function, then imagine I didn't put an argument list after it)
There is always another way. For example, why do you even need a `swap` method? Just have `Screen::update` take `&amp;mut self` and overwrite the content of `self`. Or what if the `Screen::update` took `Screen` by value and returned a new `Screen`? struct ScreenManager { screen: Option&lt;Screen&gt;, } fn ScreenManager::update(&amp;mut self) { let screen = self.screen.take(); self.screen = Some(screen.update()); } There are many solutions; possibly no clear "best" one; likely no "lasting" one.
I'm not 100% sure with Rust but maybe you should be careful when mixing non blocking with blocking calls even if async is "simulated" by using a dedicated threadpool. The web framework will accept far more connections than the threadpool will be able to handle if the operations on it are not "fast enough". This can cause some kind of "hanging futures" that will respond slower and slower. You might need a lot of threads on that thread pool which might end in the worst of both worlds. I learnt that the hard way with Scala.
I wouldn't say your typical webapp is CPU-bound. Most of them are IO- (or rather, database-)bound.
Working on my first real rust project, [`temper`](https://github.com/cmdd/temper), a linter for prose. At the moment the feature-set is pretty sparse, and the code is littered with todos, but it's decently fast.
glad you got it sorted!
Very interesting read, thank you. I have one question though, when you did the benchmarks against hashset and hashmap, did you use fnv hash or default hash? Sip hash is not very good at such small keys like 32bit integers.
I have the same problem on writing simple data structures like double linked list, graph as well. The thing is that industry standard on interview is basically asking you to implement graph, tree and linkedlist, I have not interview a company in which I don't have to do one of the above data structure, so knowing how to implement them would be nice. 
Ah, production, that's true. I usually find myself adding features to my projects within a couple days and on one I have something like 8 now, haha. 
By that definition though, hyper is a framework - at least the server side of it is.
Good catch! A workaround without nightly would instead be to use a tuple as the input, such as `Cacher&lt;(a, b, ...), c&gt;`
For what is worth, [there's an issue open](https://github.com/rust-lang/rust/issues/22692) to make this diagnostic more helpful.
yeah it's true that it's not super simple
&gt; I have both hyper and Rocket servers running in beta, and being less than 1.0 or being on nightly Rust is the least of my worries. here you go https://stackoverflow.com/questions/47941738/cannot-compile-the-ring-crate-file-not-found-for-module-montgomery and I can't compile my hello world either. 
Fair enough, but we do not know whether OP's case is a typical one. That's why I'd like some context from them instead of the weekly 'recommend me a framework with no criteria given' again.
you can not compile Rocket with latest nightly.
Thanks, I prefer that solution over a `RefCell`!
Wait, the files *have* to exist in memory at some point. Does the futures-fs crate use stuff like Linux' sendfile/splice/vmsplice syscalls (and related features on other targets) so that the data at least never ends up in a *user space* buffer?
Yeah this confused me too. It's not even like `sapper` is a particularly unoriginal name. Says a lot about the sheer number of web frameworks these days.
No, it's not zero-copy. But the other proposed solution reads the whole files in memory, while `futures-fs` uses buffers of a reasonable size. There's also https://crates.io/crates/tk-sendfile, but I haven't looked into it personally, as my system doesn't support `sendfile()`.
I would personally say neovim. There are no benefits to using vim (that I'm immediately aware of) but because neovim is backwards compatible. The only thing I can think of is that if you use vim first you'll have a better understanding of the differences so that if you end up in an environment without neovim you won't get frustrated trying things that don't work. However, that's still going to be a problem with your plugins and if you try to use vi.
idk, but when I hear actor I also want to hear supervisor, restart policy, user-land M:N scheduling, actors that have so little overhead that you can launch millions of them on a regular MacBook pro, complex actor graph/tree, and tools to visualize it.
You're right, I scanned the questions too quickly and misunderstood how the `is` syntax worked.
&gt; ...expected to be deprecated at some point in the future. I didn't realize this! Are they going to be replaced with [crossbeam-channel](https://github.com/crossbeam-rs/crossbeam-channel)? (Mostly curious to see how deprecation is being handled).
Does that mean that any API that I can hand a first class function to is a framework?
reposting from last week's since i posted it really late... i've been using a `BTreeMap` to store data for a program, which must be completely de/serialized at startup/shutdown. as my data store grows this operation has gotten slow enough to be noticeable. i'd like a B tree that only reads and writes nodes as needed from storage to increase performance. would this require completely rewriting `std`'s `BTreeMap` with the added functionality? would this be worthwhile to attempt or is there some obvious reason i'm missing that this is a silly idea? for additional context: i looked into various database solutions on crates.io and they all seemed a little too heavy/involved, so i went with the simpler route of a few B trees.
Seeing how there's [a bunch of crates](https://crates.io/keywords/coroutine) for this already, and [`libfringe`](https://github.com/edef1c/libfringe) (which requires nightly but achieves cheapest context-switches via inline assembly tricks), what's different about your solution? Does it have novel features, or better performance (than crates that work on stable)? I didn't see any talk about existing stackful coroutine solutions (only `libstd`) in your announcement post or your GitHub README, it would be really useful to have some comparisons for prospective users.
Maybe "expected" is a strong word. But [the discussion on #27800](https://github.com/rust-lang/rust/issues/27800) seems to indicate that no one is really interested in extending the existing `std::sync::mpsc`, and consider crossbeam-channel to be a better choice.
Next up: Make it a SPA using [yew](https://github.com/DenisKolodin/yew). ;) In all seriousness, this is really cool.
This is fixed: https://github.com/briansmith/ring/issues/598 You can use nightly again with rocket.
Hi! I'm the maintainer of a relatively new crate called [bnf](https://crates.io/crates/bnf) and would love some new contributors. If you're interested, I'd recommend playing with it a bit then checking out our open issues (I've tagged a few as "help wanted"). Some general tooling research to start a conversation, CI / build help for reporting test coverage, and implementing operator traits for our data structures. I'm also always interested in extending documentation, tests, and anything else that might jump out to a user. Feel free to raise questions on issues or create your own! 
Just incase if anybody needs web frameworks comparison developed in rust on basis of different libraries (Hyper, Tokio .. etc) here it is. https://github.com/flosse/rust-web-framework-comparison
I can tell you have this solved, but there's a cookbook recipe that you might want to gander. https://rust-lang-nursery.github.io/rust-cookbook/net.html#ex-random-port-tcp
Hi everyone! I've been spending some time on `env_logger` lately and have a sizeable pull request that needs some peer reviewing. Since this is a widely used crate I want to make sure the community has a chance to pile on any changes we make to it. I've tried to put some detail in the original post with context and design decisions but any input on things that seem strange, wrong or could be done differently would be much appreciated!
Wait, is that valid rust syntax? When was that added?
It depends on what you need to do with the strings. If all you need to do is iterate over an arbitrary number of strings, perhaps the most generic way is to take an iterator as an argument. fn work_with_strs&lt;'a, I: IntoIterator&lt;Item=&amp;'a str&gt;&gt;(strs: I) { for s in strs { print!("{} ", s); } } fn main() { work_with_strs(["a", "b", "c"].iter().cloned()); work_with_strs(vec!["d", "e", "f"]); work_with_strs(::std::iter::repeat("g").take(5)); let some_strings: Vec&lt;String&gt; = vec![ "h".into(), "i".into(), "j".into(), ]; work_with_strs(some_strings.iter().map(String::as_ref)); } [Playground](https://play.rust-lang.org/?gist=7c3a8730415ceac7e7442121e5e16b66&amp;version=stable)
No, it's not. I think that they've just been writing a bit too much C++ recently 😛
There is sapper, used for forustm, the rust.cc forum, and built on top of hyper: https://github.com/sappworks/sapper I have no experience with it but seemed relevant for your question UPDATE: it was already suggested in another comment, and looks like it is not async
Unfortunately, it runs rather slow on my machine, to the point where there are constant gaps in audio playback. Native emulators run just fine on the same machine.
yeah, that's pretty much exactly what i need, thank you :) just to know for future use, if i wanted to modify the strings, it would have to be: fn work_with_strs&lt;'a, I: IntoIterator&lt;Item=&amp;'a mut str&gt;&gt;(strs: I); right? (not sure about the 'mut' positioning)
There's lots of other great responses here, so I won't try to add on to them, but I did want to reply to something that I don't think anyone else has commented on: **What makes you think Shio is abandoned?** I think that that might not be a correct perception of the project's status. The last commit for Shio is 3 months ago -- I agree that it seems that the author hasn't given it much attention since that time, but the end of the year is generally packed with holiday activity, and it seems that [the author of Shio](https://github.com/mehcode) has been generally less active on Github during that time, period.
While I understand the desire for inline assembly, couldn't the same be done with cargo and separate .asm files? That is, if you are going to do assembly, why not go full hog and do assembly (you can even expose it with the C ABI). The main reason for assembly, IMO, is to get access to SIMD and maybe some new assembly instructions. But for that, I would much rather simply have language level SIMD support so you can cross compile. Something like let register = Register::new(4, 16); register.multiply(4); register.get(1); From there, the compiler can deal with turning that into the SIMD instructions that make sense or if SIMD is unsupported polyfill it. What I don't like about an ASM intrinsic (or really any sort of ASM integration) is having the potential of having x86 only crates in cargo. That would kind of stink.
Heh. I just ranted on a podcast about how disappointed I am that certain frameworks appear to be completely uninterested in figuring out a path to working on stable
I've got a working async PG adapter implemented (or at least mostly -- it panics in a few error cases at the moment that I still need to handle). I'm more or less in a holding pattern until tokio stabilizes a bit more. The implementation I've got right now was scary enough that I felt the need to have Alex look over it....... It sounds like the upcoming changes to tokio/futures will help with my pains (which everyone on that side are fully aware of AFAIK). Interestingly, the complaints about Diesel being sync have died down *a lot* lately.
\o/
Congratulations on the release and thanks so much to all of the Diesel team members for the hard work to get here! Next stop async? ;-)
https://www.reddit.com/r/rust/comments/7nn56a/production_ready_and_async_web_framework/ds3psk0/ It'll happen eventually. Waiting for tokio to stabilize a bit.
&gt; What makes you think Shio is abandoned? see "issues"
&gt; you have to use older nightly for rocket, not allowed to use anything other than the latest nightly. 
The most stale issues that haven't been filed by the author himself are also 3 months old. I'm not sure what you mean.
Rocket uses custom version of ring now, so should be fine now.
he hasn't been replying to the issues
"Call" not in the literal function call sense, more in "governs how the program is structured and behaves"
how long has it been around? 
I started to work on actix about half year ago.
Yeah so let's say you have a function "test" that replaces "." with ".." in a collection of strings, would this work? fn test&lt;'a, I: IntoIterator&lt;Item=&amp;'a mut String&gt;&gt;(strs: I);
We're naturally very keen on this for the [Gotham](https://gotham.rs) community and our [Diesel Middleware](https://github.com/gotham-rs/middleware-diesel) specifically. If there is any help we can offer or testing we could do once you're further along please let me know, keen to be involved. I'm even happy for that to extend to MySQL ;-).
No, no async web framework now. These async web frameworks in current rust community are all *TOYS*.
Congratulations!!!!
yeah, that's right!
recommand users.rust-lang.org to adopt it? :)
Maybe not so accurate, just mean it. :)
OMG.
Rewriting the internal node tree handling of Three-rs to be pretty, fast, convenient, and expose a cleaner API.
Thank you &lt;3
If you know the MySQL wire protocol I could certainly use help there when the time comes. It's very poorly documented.
Writing a blog post that attempts to answer the question "how much can you trust benchmark results from cloud-CI pipelines like Travis?" (eg. as suggested by [this post by BeachApe](https://beachape.com/blog/2016/11/02/rust-performance-testing-on-travis-ci/)). Intuitively, you might think "not much". Well, it turns out, the answer is... "not much" - but I have numbers to prove it. Benchmark results from Travis-CI are substantially noisier than equivalent benchmarks taken from a regular desktop PC. Disappointingly obvious, but it's nice to put some data behind the intuitive answer anyway. It does get me thinking about whether a sufficiently-smart benchmark harness (potentially some future version of [Criterion.rs](https://github.com/japaric/criterion.rs)) could mitigate the effects of this noise and give reliable-ish numbers even in a cloud-CI environment though.
The HTML templating macro doesn't appear to be compatible with actual HTML (those commas after attributes?), despite needlessly inheriting (some aspects of) HTML's XML syntax. XML's syntax was never good. Please consider something more rustic, like this, instead: html! { div{ nav class:"menu", { button onclick:|_| Msg::Increment, { "Increment" } // No more html comments! use Rust/JS style button onclick:|_| Msg::Decrement, { "Decrement" } } p { model.value } p { Local::now() } /* with side-effects! */ } } 
thanks for reading this. May already have M:N scheduling for actors. and panic would only affect one message, the actors should never die, so there is no supervisor and restart policy right now. you can create as many actors as possible. But may_actor stack size is a bit bigger than the normal actors from other library, it attaches to a coroutine under the cover. This is just a simple library that I'm trying to specify the connections between coroutine and actor, it's functionality is quite simple, support the core concept of actor.
I'm not a fan of `is` for binding because it tends to mean reference equality in other languages (Dart and Python come to mind). `as` might work, but it implies a type conversation so it might need to be `as let A(x)` or something to clarify that it's a variable declaration and not a type conversion. I agree with having `let &lt;pat&gt; = &lt;expr&gt;` be treated as a `bool` since that makes the most sense given `if let ...` and solves the problem of `while let` (and I like the `||` feature as well since it would help condense some `if let ... else let ...` chains in some specific circumstances, though it's certainly out of scope for this discussion IMO).
There are a lot of platforms where you need to make function calls that are only available in asm, but you're right that it's mostly a convenience.
why?
There are. you can come to rust.cc to post articles. And if Rust meetup holds, we will post notice on it. Attention it.
&gt; Now the async frameworks are not ergonomic at all, even say production ready. Now the async frameworks are not ergonomic at all, even say production ready. It is evil to program with future style on business.
what's future style on business.? why evil? are you the author of sapper?
Updating git repository `https://github.com/alexcrichton/cookie-rs` error: multiple packages link to native library `ring-asm`, but a native library can be linked only once that's it -- it doesn't compile
Awesome, thanks :)
[removed]
This is awesome :) I have yet to really get into Diesel but I'm very happy to see 1.0 has been released. I don't remember the exact names but I recall a fantastic interview that /u/chriskrycho had a while back with the creator (is that you, OP?)
Theoretically, you could have a `BTreeMap` that uses a file-backed memory map as an allocator (though allocator support isn't implemented yet), but it depends on what you're storing in the map. Strings and vectors have separate heap storage that would have to be included somehow. Have you looked at something like [rocksdb](https://crates.io/crates/rocksdb)? RocksDB sounds about what you need, and `rocksdb` even builds it for you so you don't have to do anything extra to use it.
Well, often it easier to let actor crash from my experience with OTP. I will take a closer look at May.
Yes that was me. We recorded another one today in fact. :)
I look forward to hearing it
The first one is going to drop garbage in case `f(&amp;val)` panics, so it's not safe &amp; sound. The second one is also not safe &amp; sound, because `f` could have another reference to the same cell, which it could use to cause that cell to change. 
Oh yeah that first one is kind of subtle. Any way to do it without having to result to the `Default` trait bound?
This is likely due to Cargo using a `HashMap` for configuration (which has a nondeterministic iteration order). Could you open a bug on Cargo? This is something we should definitely fix!
As long as you never implement scrollbars in JS!
&gt; While I understand the desire for inline assembly, couldn't the same be done with cargo and separate .asm files? That is, if you are going to do assembly, why not go full hog and do assembly (you can even expose it with the C ABI). You can't mix rust code and assembly in the same function that way.
If inline asm was possible, we could have a SIMD crate - it wouldn't need to be a language level feature. This doesn't have to be something the end developer used much.
This is awesome. Congratulations and Thank you!
This is a temporary issue coming from ring if I remember which was using a bug to get some module path working. but yeah that is the reason use stable for anything serious.
Does it support websockets?
I learnt C, and then C++ a bit more recently than you perhaps, but I only remember very basic details, but it's enough for me to understand get a high level understanding of what's going on when I read some C or C++ files. Currently, I am having to deal with some C/C++ because I am trying to understand a Rust library which wraps around an API written in C, so the ideas I am using in particular right now are * pointers: are like Rust references, except evil. C++ also has something called "references" which are very slightly less evil. You'll need to know how pointers are created, how they are assigned, etc., which is covered here: https://en.wikibooks.org/wiki/C_Programming/Pointers_and_arrays * in C, `char *` is a type for a string (it's complicated) and this comes up often enough that I think it's worth knowing about: https://stackoverflow.com/questions/1880573/c-difference-between-char-var-and-char-var (you don't need to read the answers unless you are interested, just read the question to know what I mean) * structs, enums, and arrays should be familiar from Rust, there is just some notation stuff that you should look up just to know how they are written * object oriented programming stuff: C++ has a fancy struct called a "class". It has "methods" (i.e. functions that are implemented for it), and "members" (variables that are a part of it); there is also this concept of inheritance which involves classes, which is where you're most likely to see the "ghost functions" you are referring to. There is some public/private stuff that you can deal with too. I'll let you read instead: https://en.wikibooks.org/wiki/C%2B%2B_Programming/Classes/Inheritance * C++ templates and macros: if you see stuff with `#`, those are [macros](https://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Compiler/Preprocessor), but sometimes you might also see [templates](https://en.wikibooks.org/wiki/C%2B%2B_Programming/Templates) which I do not understand at all, but I know its used for metaprogramming type stuff, and functions/structs/classes with stuff similar to Rust's generics, but...I don't understand much more beyond that Warning: inheritance is a very deep hole, it can get complicated fast, but I think good libraries try to generally keep sane. The rest is pretty similar to Rust, and shouldn't be a "surprise", except for funky notation. Header files, and class definitions are your friends. Header files contain "function prototypes", and class definitions (which basically contain "method prototypes", and then usual struct like stuff). They are great for getting an overview of "what's going on", without delving into the meat of the code/"how stuff happens". I am not saying Rust should have headers, I am just saying C/C++ headers are generally what you should aim to understand when trying to understand a C/C++ program/library/API.
If Rust could become the "default" wasm language, that would be huge for our community, the language, and the web as a whole. 
thank you for this! to answer your question, it's way, way easier to get up to speed with a crate that follows a predictable module structure and has awesome docs auto generated from the source. Other languages seem to have at least some structure to a project - but perhaps I am overstating this point.
ORMs are often regarded as bad practice since sometimes they'll obfuscate away the cause of performance issues. I've seen things like SELECT LIMIT 1 in for loops, rather than a SELECT * in vendor apps. This looks really nice though with the schema -&gt; struct generation and better error handling. I wonder if it could ever be integrated with GUI software so you can auto-create GUIs from your DB schema.
If the vector is guaranteed to be immutable, then yes. Otherwise, no, because if the vector is updated such that it has to reallocate, then the pointer inside `slice::Iter` is going to be wrong. Even if the vector doesn't reallocate, the length of the slice inside the iterator is going to be incorrect. Removing elements from the vector will have a similar problem, where the iterator can yield references to elements that have been dropped or moved.
C++ templates are exactly like rust's generics, except for the fact that templates can be infinitely recursive which rust doesn't support I don't think I just started learning rust tho, so there's a good chance I'm wrong.
SIMD is happening via exporting vendor intrinsics through the standard library. The typical injection to using inline asm for these things is that it inhibits optimizations that combine multiple intrinsics (because many of the vendor intrinsics are actually compiler intrinsics).
&gt; What I don't like about an ASM intrinsic (or really any sort of ASM integration) is having the potential of having x86 only crates in cargo. This isn't really asm specific. Once vendor intrinsics become a thing, we will have huge suites of functions that are very platform specific.
Wonderful! I hope it will be useful to you. 
&gt; C++ templates are exactly like rust's generics, except for the fact that templates can be infinitely recursive which rust doesn't support I don't think And that C++ templates support value parameters, *and* you can have static associated data, *and* that they're checked at expansion-time, not definition-time. :P
[Practical example](https://play.rust-lang.org/?gist=c14ef5d9777b7e2ab17181506a9f30c8&amp;version=stable). At least when I run it, the second vector allocates right on top of the first one, producing: i = 0; xs.next() = 1 i = 1; xs.next() = 2 i = 2; xs.next() = 3 i = 3; xs.next() = 1 i = 4; xs.next() = 2 i = 5; xs.next() = 3 i = 6; xs.next() = 1 i = 7; xs.next() = 2 i = 8; xs.next() = 3 i = 9; xs.next() = 1 i = 0; xs.next() = 5 i = 1; xs.next() = 6 i = 2; xs.next() = 4 i = 3; xs.next() = 5 i = 4; xs.next() = 6 i = 5; xs.next() = 4 i = 6; xs.next() = 5 i = 7; xs.next() = 6 i = 8; xs.next() = 4 i = 9; xs.next() = 5 i = 0; xs2.next() = 4 i = 1; xs2.next() = 5 i = 2; xs2.next() = 6 i = 3; xs2.next() = 4 i = 4; xs2.next() = 5 i = 5; xs2.next() = 6 i = 6; xs2.next() = 4 i = 7; xs2.next() = 5 i = 8; xs2.next() = 6 i = 9; xs2.next() = 4 
\o/ yey.
The general notion of what you're doing is a self-referential struct, which rust cannot currently express without unsafe code. If you'd like to offload the responsibility for the `unsafe` onto a third party crate, [`rental`](https://crates.io/crates/rental) is designed to express scenarios like this. Alternatively, you can opt instead to redesign your architecture to try to avoid the need for this kind of pattern, but depending on what you're doing that could either be easy or very difficult.
This is another example that powered by [may](https://github.com/Xudong-Huang/may). Hope you like it.
Wow, you put a lot of may related post there. Thanks!
I fixed readme example. Finally! it is stable now
Insofar as I'm aware, you can't.
Well, the async world is sort of in flux right now. When Diesel moves to async, you'll get the best of both worlds (depending on how ergonomic async ends up being in Rust).
If you already know Rust, give: - [Accelerated C++](https://www.amazon.com/Accelerated-C-Practical-Programming-Example/dp/020170353X) a try. For anything else, stack overflow's [the definitive C++ book guide and list](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list).
Cool, yew and stdweb really show some protentials of Rust in web development!
We can build upper houses on may platform, if it is rocked.
I'll rewrite my website https://kaizenjapanese.com from ruby to rust/ actix_web
Your question is no different from "How can I use environmental variables in a *.json (or *.xml or *.html) file?" It's your responsibility to resolve them after loading the data. (eg. Run a templating engine on each value you want to support variable interpolation for.)
It looks very promising!
And are turing complete
Aren't there some optimizations that can only be done through inline assembly? At least that was the case when I first learned C++ a decade ago.
The note about the PR landing for ?-in-main got me excited, but it looks like what's landed is only preliminary work to support alternative return types for main. Too early to get my hopes up. :)
I've recently been surprised by the amount of Rc&lt;RefCell&lt;T&gt;&gt; in my code (I'm just learning), and I've found my experience to be the opposite - I'm reluctant for message passing style, because it would mean passing around even more of Rc' RefCells. And why is that? I don't want to pass the indices to the collections around. It yields syntax overhead as well (not in your example maybe, but in other cases you would have to use indexing operator), and you can't assure that your index is valid (as it's just 'usize' in your example, but it could be key to some HashMap, etc). This means I'd indeed rather pass Rc&lt;RefCell&lt;T&gt;&gt; than any kind of index. I'm open to other suggestions to be honest though :)
How can I run `assert_eq!` with `std::io::Error`? I use my own error type #[derive(Debug)] enum MyError { Foo, Bar, Io(io::Error) } Now to test if a function returns the correct error type I could use `assert_eq!(my_fn().err().unwrap(), MyError::Foo);` if I were able to derive `PartialEq` but `std::io::Error` does not implement `PartialEq` :( So no I have to do s.th. like match my my_fn().err().unwrap() { MyError::Foo =&gt; { // ignore because it's ok :) }, _ =&gt; { panic!("wrong error type"); } } This is a bit cumbersome. Are there other ways to test it? Should I define a custom macro `assert_err!`?
Separate assembly files have a number of significant drawbacks: - You have to write function prologues and epilogues yourself instead of letting the compiler do it. - You have to write argument handling yourself. - You have to know the architecture's register clobber rules and follow them. (The compiler around inline assembly will make sure the code stays correct, even if it may be suboptimal due to saving and restoring callee-saved registers when you could have just used a caller-saved one.) - The functions cannot be inlined. - The functions are opaque to the optimizer (modern compilers actually understand inline assembly at least partially and can make smart register allocation choices). - Your build process needs a separate assembler invocation. (Including locating an assembler that understands the syntax you used.) - Your functions containing assembly don't have an enforced signature. - You have to use C interop rules for functions, including the inability to pass complex Rust types, extract some data from them and perform the assembly instructions on that data. For every assembler function you write, you'll probably have to write a Rust wrapper anyway. That's all I can think of off-the-cuff, though I'm sure there are more things.
Rusts generic system is too, at this point ;)
Thx. It's exactly what I wanted, a new before-going-to-bed book! RemindMe! "Ugly pile of hacks to make your computer lie!"
**Defaulted to one day.** I will be messaging you on [**2018-01-04 11:07:44 UTC**](http://www.wolframalpha.com/input/?i=2018-01-04 11:07:44 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/rust/comments/7ngcfg/ive_ported_my_nes_emulator_to_webassembly_using/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/rust/comments/7ngcfg/ive_ported_my_nes_emulator_to_webassembly_using/]%0A%0ARemindMe! ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
RemindMe! 1 day "Ugly pile of hacks to make your computer lie!"
&gt; Mm, well for your JSON example, you're just referencing a value deep within a structure, and for that, we have something much cooler than monad ;) I admit to never actually learning to use Lens properly. Instead, I'm guilty of writing "parsers" like `withObject "something" $ (.: "foo") &gt;=&gt; (.: "bar")` ;-) &gt; In practice, though, all the JSON I encounter comes in a known format, so I just use Aeson (in Rust, Serde). Sure, but in principle the `Maybe`s may not come from JSON :) Depending on the API you are interacting with, this could also be said for `Either` (though it seems `MonadExcept` or similar is more popular in Haskell than `Either`, esp. compared to how pervasive `Result` is in Rust).
When you're implementing bignums, you really want inline assembly for ADC/SBB (add with carry, subtract with borrow).
Been working on some a custom drawing and animation library that goes on top of cairo-rs. https://www.bit-101.com/blog/2018/01/introducing-bitlib-rs-for-rust-and-cairo/
This QotW … is it 2017 again ?
It isn't the complete set of features imagined in the RFC, but I think "only prelimenary work" is selling it short. Using nightly, with a feature flag, you can [actually use ? in main (playground link)!](https://play.rust-lang.org/?gist=795b7c22f48ccbed0366f0088e3ff2f8&amp;version=nightly)
I should note that I first quipped it in 2016. I was a bit surprised it got picked now. I also just noticed I've been doing Rust stuff for quite a while.
Unfortunately, the [`Box&lt;Error&gt;` example](https://rust-lang.github.io/rfcs/1937-ques-in-main.html#motivation) in the RFC [doesn't work](https://play.rust-lang.org/?gist=ca8c03bef07b953e72e7a54f84febf7b&amp;version=nightly), which is a more realistic use of `?` in main than just dealing with a single type of error.
Yeah that's exactly what I was thinking about.
Rust had green threads at some point, but it was a fairly different beast.
Well, you can merge them them into one string. Like: rustflags = [ "-Ctarget-cpu=x86-64 -Ctarget-feature=+crt-static" ] This should preserve the order.
heh, I didn't know rust lacked that. I'm still wrapping my head around `match` and combinators
Wrong subreddit, you probably meant /r/playrust/
This is nominally about C++, in comparison to Java, but it's an interesting discussion of how a language's symbol lookup rules influence the its style of module structuring, which may shed some new light on what we do in Rust. 
&gt; There are many solutions; possibly no clear "best" one; likely no "lasting" one. QOTW!
It seems you're trying to do something similar to what [the take_mut crate](http://docs.rs/take_mut) crate allows. You may want to have a look at its code, esp. the usage of `catch_unwind` to prevent the issues with your first solution that /u/diwic highlighted.
&gt; envsubst what's that?
A couple thoughts on top of what DroidLogician already mentioned: - You probably considered this already, but just in case: why not just hold an index into the vector? - mem::transmute might be "more unsafe" than you need. I don't know if there's an official best practice for this, but I think ptr::write might reduce the chance of accidentally converting the wrong type?
Matt Peterson, who's one of the new contributors this week, was the one who picked up the previous work for the lifetimes in macros and helped get it over the line for this week. He's also my best friend. **I'm so jealous that he actually became a contributor!** Now I want to find something! :)
...huh? Houses? What do you mean?
Why is the actual assembly listing a string? Even though it is a little more flexible than `__asm__` directives in C compilers, I don't think it makes sense in the long term. Already in the simplest examples beyond a `nop`, it gets awkward with the multi-line strings and the pseudo-`format!` arguments. Since this is a pre-RFC and we can freely bikeshed, why not take advantage of the fact that `asm!` is already macro-like, and go with something that resembles actual assembly listings more, i.e. a regular, token-based DSL?
Author of the game here! I have made this little game while experimenting with ggez in the last week or so. It is not a display of idiomatic Rust or idiomatic game development, but rather a small demo I thought would be fun to share. Working with ggez for the first time was wonderful and I really have to compliment the authors of the library in making such an intuitive and well-documented API. Ask me anything you want.
You can't do that with TOML -- but what it looks like you want is something like the [dotenv](https://github.com/purpliminal/rust-dotenv) crate.
Just updated the GitHub repository with gameplay gif :)
Surely HashMap should be deterministic, just not predictable?
you still have time to sort that out for me
&gt; which may shed some new light on what we do in Rust. Well the article says that none of it applies to Java, and you can basically replace Java with Rust in the article, so none of it applies to Rust. 
Well, this was my first contribution this week. Basically, if you forget to install a linker (missing link.exe or missing cc), previously you'd get an output of all the linker options and some weird error message. Which is useless, because if the linker is not installed, it doesn't help to have the linker options on screen. Now you only get this: $ ./rustc hello.rs error: linker `cc` not found | = note: No such file or directory (os error 2) error: aborting due to previous error The next step is to the same for missing libraries. If you currently forget that `curl-rs` links to `libcurl` for example, rustc just barfs all linker options all over your screen. My goal was to print only: what library is missing and where did the linker search for the library? Because that's pretty much the only relevant information. [Issue here](https://github.com/rust-lang/rust/issues/46998). I said that I'd do another PR, but I'm not sure because I have other things to do that are more important right now, it could take a few weeks. If you want to help and want something easy to start - help would be much appreciated. 
Is rust really the right tool for the job when it comes to web development? Surely that's the sweet spot of dynamic languages. I don't get why people are trying to shoehorn rust into *everything*
Can I have [Serde](https://serde.rs/) output comments before some fields while serializing? (for supported formats)
Yeah, that does not work :( I'm not 100% what happens there, but if time permits, I will look into it! `#[test]` and doctest support is still open, too.
Rust's hashmaps are randomly seeded to avoid DOS attacks, so the order is different every time.
I'm not sure what you mean by DSL, but the author (in his talk and in the pre-RFC) by DSL means an approach that `msvc` and `D` take, in that the compiler actually understands the pseudo-assembly natively rather than just working with strings and existing assembly (which is the approach taken by GCC and LLVM). He then argues that the template approach seems more practical, since you don't have to make `rustc` understand all different kinds of assembly for all different kind of platforms and all different kind of assemblers out there. Thus it's easier to implement and it's more portable (`mvcc` and `D` only support x86 inline assembly due to this restriction). I don't see it mentioned, but I see another benefit of not using a DSL: a DSL is compiler-specific and needs to be learned separately. With a template approach someone who is already well-versed with assembly can just use that instead of learning a new thing.
You can define a function to do it for your type ```rust impl MyError { fn ignore_foo(self) { match self { MyError::Foo =&gt; {}, _ =&gt; { panic!("wrong error type"); } } } } ``` and then at the call location you only need ```rust my_fn().err().unwrap().ignore_foo(); ```
&gt; Looks pretty cool! Want it added to the projects list? Thanks! That would be very nice! I'll make a PR later. &gt; Find any problems or rough spots or problems in the library? Just some strangeness with the filesystem, that requires a `/` a the start of every path string, which I did not understand at first. The rest was very smooth.
You missed the word "derive" in his question. Usually, if you implement drop, it means there are special operations that need to happen. And more often than not, you also need matching adjustments while implementing clone, so you wouldn't want to derive it.
If you mean Rocket, I think the author said he did want it to work on stable, but that he is waiting for a number of features to land there.
React is very much a "we'll call you" framework. It handles the lifecycle of components itself. The fact that its behaviour is fairly transparent does not change this fact.
&gt; I'm under no obligation to make Yes, you are
I thought I already did. &gt; It's your responsibility to resolve them after loading the data. (eg. Run a templating engine on each value you want to support variable interpolation for.) Load the TOML, then run a transformation of your choice (eg. HTML templating engine, regexp replacement, etc.) on each value which may contain variable substitutions waiting to be resolved. 
&gt; then run a transformation of your choice (eg. HTML templating engine, regexp replacement, etc.) regex -- this will make it too complex html engine -- how can it come in handy here?
Neat! Thanks for sharing your hobby project! I suspect that Rust might make this easier to maintain than the C that DOSBox uses. :)
I wouldn't recommend that. envsubst wouldn't know how to ensure that its output remains valid (and secure) TOML in the face of arbitrary environment variable values.
I gave you the benefit of the doubt the first time. This time, I'll just say "goodbye".
A random question. What do you do with shared only libraries? For example libsystemd? Also, what if said library cannot be compiled with musl? (How incompatible the musl and GCC ABI is in practice?)
Well, if you're working with shared-only libraries, you'll probably have to rebuild for each Linux distro, and maybe each distro version that you want to support. Or just have your users build everything. Most normal things work fine with musl-libc. It's not A*B*I compatible with GNU libc, but since you normally statically link it for Rust, that doesn't matter at all. It's reasonably A*P*I compatible with most things that you'll normally need. There are a couple tricks to watch out for, including a smaller stack size for the main thread.
Conceptually? Sure. By definition? Absolutely not. Facebook itself always refers to React as a library. You call React by using `ReactDOM.render` or similar. All objects are created by calling React functions, and all updates are triggered by asynchronously calling functions like `setState`. Does it feel like a framework? Definitely. That was actually my point. Is it a framework by the definition of "we'll call you"? Definitely not.
That makes sense, about the index. I think `ptr::write` has the benefit that if you accidentally change the destination type without changing the source type, the compiler is guaranteed to give you an error, rather than silently going ahead with a transmute if they happen to be the same size. The downside is that I think you'd need to manually `mem::forget` the source, if there's any chance it has a destructor.
I don't particularly care what Facebook calls it. Repeating "Rails is a library" doesn't make it one. The fact is, by its very nature, React is a "we'll call you" software: it is declarative. Sure, you write code to decide what to display when the state of the application contains a given piece of information, but React is going to run this code whenever it wants. Where I disagree is the "feels like a framework", in the sense that what people generally associate with a framework is "lots of complexity" and "a bunch of tightly-integrated various features", neither of which is found in React.
Won't spoil it before it's done :)
I will ask you to mind your language and remain courteous. Users here are provided you help *in their free time*, the only thing you can expect of them, and which is expected of you, is **respect**.
Nah, I was just too lazy to type out the whole `impl` block :p
Just curious: do the numbers change if you build with lto enabled? (`[profile.release] lto = true` in Cargo.toml)
Open space is where at the beginning the attendees suggest topics they want to talk about and then form groups to discuss the most popular topics. Memo to self: Tell people to write blog posts about what they want for Rust in 2018 and suggest roadmap things!
Yeah what was that piece of Rust philosophy? "Correct later is better than broken now" or something like that. Possibly the _opposite_ of what you want in the middle of a programming competition, as long as none of the broken inputs are in the test set :)
Ah, for a moment I thought this was a call for all kinds of blogposts!
I just ran into this as well.. has it been reported anywhere?
I'm always in favor of more blog posts!
Something like `libsystemd` is just going to hurt. The first thing you need to do, in general, is to rebuild the library (and any dependencies) 100% statically using the `musl-gcc` compiler (if that's what you're using with Rust), and very carefully set up the necessary linking flags in a `build.rs` script. Take a look at the `build.rs` in the `*-sys` crates for OpenSSL, libpq, etc., to get a good idea. Then look at [my musl cross-compiler container](https://github.com/emk/rust-musl-builder) to see how to build static C libraries, particularly the ones in the `Dockerfile`. But it may not work if `libsystemd` is always shared, or if all running programs need to use the exact same version of `libsystemd`. And even if you _do_ ultimately get it working, expect to spend several hours being very frustrated and/or submitting PRs. It can be a pretty complicated process, and you may be the very first person to try it ever, so the amount of help may be limited.
&gt; You may just be using a different definition of "library" and "framework". To me, when I think of "we'll call you", I think mostly of tools that look at your file structure and deduce how your application will work from a higher level, typically with a large global footprint. That's often the case, but Rails would still be a framework if you had a bit of boilerplate to register your handlers. &gt; However, if you contrast it with AngularJS, which is undoubtedly a framework, it clearly has a different modus operandi than React. AngularJS reads the page, allows components to be registered in the global cache or global scope, and then transforms the HTML accordingly. You never call (new Angular(data)).renderInto(div) or anything like that, while you do with React. You never call anything like setState; you just change variables on the scope, and it "magically" gets translated into DOM changes. Admittedly, I've never used Angular, but I don't see how a single line of code to wire it and using properties instead of a method call would really change anything. The library vs framework gap is about control. If there is inversion of control, then it's a framework. React does control the lifecycle of each component. Where in your code do you invoke `componentWillMount`? Nowhere. No more than you invoke the routing code in a web framework, or trigger the middlewares yourself. You don't trigger rendering. You can't change the diff algorithm. It's all handled for you, and there is no way to get this done in a different way.
I definitely see your point, and I think it largely agrees with my earlier point. Namely, the distinction between "framework" and "library" is essentially inconsequential. The small amount of boilerplate _is_ the difference between you calling it and it calling you, and, like you said, it's not really much of a difference in the end.
&gt; That's why you want to pair them with good debugging tools. This is where I hope Diesel's next focus will lie. I currently find debugging to be a pain point in Diesel. I'd like it to be easier to both `println` a query as a SQL statement (I don't feel that doing so is ergonomic at the moment), and have a way of configuring logging e.g. log every SQL query run and how long it took, or log every query that takes longer than X ms, etc.
This awesome! :D Ashley is really awesome and knows here stuff. We're definitely lucky to have her.
One of us! One of us!
I've never heard of ActionHero, can you say more about it?
Well I've actually got two half written blog post in my head, one retrospective on my experience getting Rust compiling on my Windows machine, and one examining the deferred fallible let RFC. I'll bump those up a step on my priorities then, I want to do it but haven't had the chance yet.
Is this a PC emulator? Can it run OSes other than DOS?
I don't see how it's different with or without deriving. If you're storing some internal structure in an Arc, and only doing actual dropping operations in that - it's totally fine to derive Clone for it. I mean, yes, a lot of things do need to do custom operations on clone - but if you don't, deriving it is fine?
This is really cool, I love seeing rust used for gamedev &lt;3 Was there anything specific to rust you felt was hard to deal with in the context of developing a game?
This is super cool!
If I were actually trying to define 'explicitness' I would say that when we write code, the things we type talk about something. When things happen because of a piece of a code we wrote, those things are explicit if the code is talking about them and implicit if it is not. Everything that happens during the running of a program happens because you expressed something in the code you wrote, but the things that happened because the code you wrote is talking about them are explicit and the things that happened in order to support those things or for whatever other reason than being topics addressed in the code are implicit. That doesn't necessarily mean 'noisy', since you can convey an awful lot of meaning about things in a single symbol, but it does mean that 'manual' things - i.e. things you talk about directly are explicit and things that are not manual are implicit. 
 [target.x86_64-apple-darwin] rustflags = [ "-Clink-arg=-lmylib" ] I think that should do the trick
`String::append()` is also replacing in practice. If `len` exceeds the capacity, new memory is allocated, the string is copied into it and then the old memory is deallocated.
How can you run other software on here?
Seems to me that the point is "Look, Rust got another thing better than C++!" :)
Congrats, Ashley, and welcome! I’m really excited about working together more closely this year.
I don't know your background, but it is expected from you to be able to do some basic research when looking to solve a problem with the community's help. At least take the time to Google your way around, and then come back to the forum for more explanations by formulating a sentence that's longer than two words, showing what you've learned by yourself so we can try to help you complete your understanding. Doing otherwise is considered rude and will pretty much guarantee you won't get anymore assistance.
I like this approach, I've always valued individuals expressing themselves in long form.
Works. Good catch on the missing "target." thanks!
I personally have solved this problem before by using a Cargo feature flag that switches a typedef between `Rc` and `Arc`: #![cfg(not(feature = "use_rc"))] pub type MyRc&lt;T&gt; = Arc&lt;T&gt;; #![cfgnot(feature = "use_rc")] pub type MyRc&lt;T&gt; = Rc&lt;T&gt;; Then the user can turn on the `use_rc` Cargo feature if they want. If you want more flexibility, you'll want to make the container type a generic parameter and use a trait to define the functionality you need: pub trait SomeRc&lt;T&gt;: AsRef&lt;T&gt; + Clone + From&lt;T&gt; { fn make_mut(&amp;mut self) -&gt; &amp;mut T; } impl&lt;T:? Sized&gt; SomeRc&lt;T&gt; for Rc&lt;T&gt; { // ... } impl&lt;T: ?Sized&gt; SomeRc&lt;T&gt; for Arc&lt;T&gt; { // ... } // don't typically need trait bounds here pub struct SillyTree&lt;T, C = Arc&lt;SillyBackend&lt;T&gt;&gt; { t: C } impl&lt;T&gt; SillyTree&lt;T&gt; { pub fn new(d: T) -&gt; Self { SillyTree { t: SillyBackend::new(d).into() } } } impl&lt;T&gt; SillyTree&lt;T, Rc&lt;SillyBackend&lt;T&gt;&gt;&gt; { pub fn new_singular(d: T) -&gt; Self { SillyTree { t: SillyBackend::new(d).into() } } } impl&lt;T, C: MyRc&lt;SillyBackend&lt;T&gt;&gt;&gt; SillyTree&lt;T, C&gt; { fn link(&amp;mut self, b: Vec&lt;SillyTree&lt;T&gt;&gt;) { self.t.make_mut().link(b); } } It gets more cumbersome if the user has to write out the full type (e.g. if they have a struct containing `SillyTree&lt;T, Rc&lt;SillyBackend&lt;T&gt;&gt;&gt;`) but the default for the type parameter makes the use with `Arc` as simple as the non-generic version. However, there's another issue you might have noticed. Because of how generics work, this approach requires leaking `SillyBackend` as an implementation detail. There's currently no way around it. With higher-kinded types (implemented as [associated type constructors/generic associated types](https://github.com/rust-lang/rfcs/blob/master/text/1598-generic_associated_types.md)) it could be made to work without exposing `SillyBackend`, though it'd be somewhat more complex: pub trait RcType { // using the same trait as above with the proposed GAT syntax type Rc&lt;T&gt;: SomeRc&lt;T&gt;; } pub struct Singular; impl RcType for Singular { type Rc&lt;T&gt; = Rc&lt;T&gt;; } pub struct Multi; impl RcType for Multi { type Rc&lt;T&gt; = Arc&lt;T&gt;; } pub struct SillyTree&lt;T, C: RcType = Multi&gt; { // `SillyBackend` remains encapsulated t: C::Rc&lt;SillyBackend&lt;T&gt;&gt;, } impl&lt;T&gt; SillyTree&lt;T&gt; { pub fn new(d: T) -&gt; Self { SillyTree { t: SillyBackend::new(d).into() } } } impl&lt;T&gt; SillyTree&lt;T, Singular&gt; { pub fn new_singular(d: T) -&gt; Self { SillyTree { t: SillyBackend::new(d).into() } } } impl&lt;T, C: RcType&gt; SillyTree&lt;T, C&gt; { fn link(&amp;mut self, b: Vec&lt;SillyTree&lt;T&gt;&gt;) { self.t.make_mut().link(b); } } If you don't expect a user to need both the `Rc` version and the `Arc` version at the same time, I'd probably go with the feature flag approach.
Ashley is great! So awesome to have another kind and very knowledgeable person on the core team!
HashSets do not give out mutable references as mutating a hashset element would possibly change the hash and you'd end up with an invalid state. If you mean a HashMap instead (figured since you call `insert()` with two parameters), use [`get_mut()`](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.get_mut) instead of the indexing operator. For some reason, `IndexMut` (which, like `Index`, is used for the square bracket operator, but in mutable contexts) is not implemented for HashMaps.
You can't really claim you want to work on stable, and then use nightly features which aren't on any sort of roadmap for stabilization. There's some amount of compromise involved which the maintainer seems unwilling to make
You want /r/playrust This is the subreddit for the Rust programming language by Mozilla.
Well, the main difference with vectors is the memory is allocated on the heap. So the arrays are (probably) further from each other and other variables, reducing cache locality.
Does anyone have a list of cheat codes? I could really use some. if there’s one to reduce the memory footprint of my HashMaps by 3x, sign me up!
At this stage, it is rather a "DOS" emulator. It has a incomplete CPU emulation, incomplete graphics emulation, and incomplete emulation of several DOS interrupts, meaning it should be able to directly execute MS-DOS .com files at this time. It would be possible to make it more of a complete vintage pc emulator. Currently, mame would be a better system if you want that functionality as a end-user.
I believe I hard-coded the binary to load. I'll implement some kind of load file dialog
Do these comments not also violate the Rust Code of Conduct? https://www.reddit.com/r/node/comments/6whs2e
Currently by changing https://github.com/martinlindhe/rs-x86emu/blob/master/src/debugger.rs#L35 I'll get around to adding a load binary command/dialog soon
Currently it is limited to running DOS programs, and I'm not sure a goal is a general full hardware emulator. I am doing some high level simulation of dos functions to avoid needing os files.
I've been planning to write up an analysis around a theme of concerns since RustBeltRust (CI) but been too busy trying to wrap up some major breaking chances in Cobalt. I guess this gives me the kick to get my writeup done.
What happens if you make a `vec![0.; 300]` and take slices of that? Something like let mut v = vec![0.; 300]; let (r, xy) = v.split_at_mut(100); let y = &amp;xy[0..100]; let x = &amp;xy[100..]; b.iter(|| { calculation(r, x, y); }); I'd expect it to perform roughly the same as the array version since the memory will be contiguous, like it is on the stack, instead of scattered with separate allocations.
You can write a trait that is implemented by both Arc&lt;T&gt; and Rc&lt;T&gt;.
This is dangerous, as features are additive, so activating the use_rc feature suddenly makes all the code break that requires the Send / Sync bounds of Arc
There's no current plans to change anything around either feature. Printing a query is pretty simple. It's just `println!("{}", debug_query::&lt;Backend, _&gt;(&amp;your_query));`. Logging is more or less on hold, since the current state of logging in Rust is pretty barren and doesn't suit our needs. [More context here.](https://github.com/diesel-rs/diesel/issues/150#issuecomment-318928436) It's possible (likely) we'll end up providing logging via our own ad-hoc framework with shims for slog and log at some point in the future, but it's not currently a priority.
OP wanted `Arc` to be the default; it could easily be the other way around, or a `use_arc` feature instead that is enabled by default. Presumably the user would know the risk and would only choose `Rc` when they don't need to send instances of the tree across threads.
Definitely would love to read the RFC one.
You can avoid that by creating a RcFamily / ArcFamily zero sized type instead.
&gt; which isn't fully necessary for this How so? What would it look like without GAT?
Having random hash iteration order also prevents people from accidentally relying on the order (even if it isn't specified as stable across versions). This makes changing the hash algorithm much more complicated, since people can have assumptions baked into test or production code. I ran into this issue at work when migrating from Java 7 to 8. Java 8 changed the hash iteration order (which it can do because the docs explicitly state that the iteration order may change), but there were a lot of tests which relied on a fixed iteration order. Something like Map&lt;String, String&gt; actualMap = getMap(); assertEquals(actualMap.toString(), "HashMap{key1=val1, key2=val2}"); Only works if the hash iteration order is consistent. If the hash order doesn't change often (I think it was a few years for Java), you can accumulate a ton of tests like this which make it harder to figure out which test failures are due to transient things like this and which are "real" problems. Randomly seeding hash maps is definitely the right way to go.
Hail to the King, baby!
ping
The problem is that the user doesn't always choose. As the post you're replying to states, features are additive. If you have some other dependency that relies on the same crate through some transitive chain, and enables the `use_rc` feature, you've now lost your `Send` bound regardless of whether you requested it or not.
You might try wrapping the field you want mutable with a Cell/RefCell
/u/steveklabnik1 - you wanted blogposts? come get some :)
:D Thank you!
they're also free not to give me any reply. 
goodbye!
Congratulations to Ashley :-)
not any. {{ get_env_variable("fdsfdsafdsfd" }} ----&gt; an expression like this can't be called directly from a jinja2 template engine - invalid syntax. 
Have you considered the name DustBox?
FWIW, I don't think the `fsize` name makes sense. The reason `usize` / `isize` have "size" in their name is because they can represent *any in-memory size in bytes*, because they're as wide as a pointer. Doing thing for floating-point isn't meaningful, as the width of a pointer doesn't correlate to floating-point support - see also https://github.com/rust-lang/book/pull/892.
I have not performance tested it much. However, it's not only because f32 is faster (I know that it's not) - I do this because I don't know what data format the user has. Conversions - from f32 to f64 and back - that a user might have to do in order to use my functions could be costly. Plus less size = more memory in cache = less cache misses. 
For graphics (UI / games), I've been told that `f32` suffices, but I'm not sure in what conditions that breaks down. My nit-picking is only about the name, though, I think just `float` would work great!
The name of the project is unfortunate then. If you can rename it, perhaps it should have dos in the name somewhere.
It can be done, but I ran out of imagination long ago :-)
That's a great name! I might borrow it!
Please do :D
So a `use_arc` default feature then?
MB, I accidentally the name, my current code is HashMap, not HashSet. That seems like exactly what I need though, thanks!
It's taken!
/u/nicnux came up with the name dustbox. It sort of has "dos" in it :)
Yup
yeah !!!
I meant it the other way around. It's not just "some", it's almost every one. Crysis does it right.
&gt; I don't get why this is an issue. It's not really an "issue" more of an annoyance around rusts minimal standard library. Having a similar library as C++ wouldn't hurt much. It's not a big deal, but I don't particularly like it when setting up new projects. &gt; What's wrong with f64::atan? The fact that you have to use `std::f64` - `core::f64` [does not have any methods](https://doc.rust-lang.org/core/f64/). If you disable the standard library, you'll know what I mean. From my point of view, these functions could be moved into core. They either use llvm intrinsics or they call into C's `libm`. Half of libm is ported, only 10 functions or so remaining. So if that could be ported, we could at least do mathematical operations without the standard library. 
Where are Garrus and Wrex??
I don't know anything about Ashley Williams, so I googled "Ashley Williams nodejs" and came up with [this](https://www.reddit.com/r/node/comments/6whs2e/multiple_coc_violations_by_nodejs_board_member/).
Do you have any good resources on how to get started lexing/parsing/etc with rust? Most of the info I found was either unfinished or not beginner friendly. [This](https://chr4.org/blog/2016/12/09/writing-an-interpreter-in-rust/) started out great but stopped before it got to evaluation :( I know that's a bit different than what your library does, but iirc it has similarities.
I just had a look and... wow that's terrible. Looks like a horrible decision overall.
Just as I expected - &gt; "never underestimate the wrath of a mildly inconvenienced white dude" Was one of the "problematic" quotes. So was "Kill all men". Usually, I don't care about that stuff. Comments about a group that faces no systemic oppression - especially by a minority in that group - is fine (and brogrammers get all up-in-arms about it which is pretty funny). I am a bit concerned about her leading a Community team with that record, though. I don't think someone in that authority should act that way towards potential community members. Stuff like that only creates a toxic environment, even if it isn't damaging. Being said, that's one thread, and she's seemingly run multiple projects. So I'm eager to see what she can do. Good luck to her.
https://github.com/DanielKeep/cargo-script
I think this issue is relevant: https://github.com/rust-lang/rust/issues/32631
I've been thinking about a solution for the BTreeMap cursor problem since your previous Reddit post and I came up with a [possible design](https://internals.rust-lang.org/t/looking-for-advice-on-extending-btreemaps-entry-api/6467). Feedback is much appreciated.
I'm on windows so using cargo-script breaks the colored error output which is really helpful :(
It's really not. It's so overblown by the "anti-SJW" crowd. What's *actually* a bad thing, imo, is that one of the top posts in the nodejs subreddit is a massive wall of text complaining about someone shitposting SRS memes. I write a lot of node code and wandered over there hoping to find a place like this and immediately ran away when I saw the top all time list.
Having read through that and related stuff, here's my (overly long) take on this weirdness: It seems like a lot of this is that there seems to be some sort of "net compliance" kept behind the scenes by those moderating—she may do a lot of good work, but she also goes off on people in hurtful ways, and this is fine by moderation's eyes because she's built up enough compliance capital to tank those. When people from the community at large (including those who may work with Node &amp; npm a lot, but not publicly or close to the core), who may not see the good she does, show up with valid concerns, the moderation side ends up feeling attacked as poor judges. They can't properly put themselves in the shoes of a bunch of new people who show up, and think it's mostly outraged trolls. This leads to further poor actions on their part. You end up with a lot of poor conduct that is understandable given the full context (possibly even excusable in cases), but it all reflects poorly on the moderation team and formal project as a whole. I trust the Core Team's judgement, and wish Ashley all the best in her endeavors here. I only hope that she, and everyone related to communities in open source, can strive to empathize more with people they wouldn't normally interact with and consider the full effects of their actions on a project. Rust has had a great community so far that's drawn many in, and I would hate for a ultimately minor issue to blow up and drive people away, like what's happened with Node. Enforcing a quality Code of Conduct is a mostly thankless job that drains people, with quiet effects, e.g. a user having a discussion with a moderator entering back into the community with a positive effect afterwards. It's natural to get worn out with this never-ending work, and human to falter. A moderator has to put in extra work to resolve their errors, though, to maintain their credibility for a community-focused position. It's a lot to ask, but I trust that Rust's leadership can maintain the integrity the programming community as a whole has come to appreciate.
I love rust and the community, I really do but after her actions with the whole node debacle my faith in her is rather low at the moment. I suppose in the end it doesn't really matter, I can still use rust regardless of who is part of the community. 
&gt;Usually, I don't care about that stuff. Comments about a group that faces no systemic oppression - especially by a minority in that group - is fine (and brogrammers get all up-in-arms about it which is pretty funny). Why are you not in favour of treating everybody equally in this regard? Why accept this kind of comments no matter what group they target? Like you I think that the victim complex some people have developed in recent years is ridiculous but if somebody makes those kind of comments they are obviously against equality. Of course it's less damaging to make comments like these about men in a male dominated industry but as a matter of principle this kind of behaviour should be totally unacceptable. 
I don’t understand how you can say “it’s really not”. The person you’re responding to read the thread, saw what she wrote, and came to his own conclusion. If you think it’s overblown, then ok, that’s you. But the person you’re responding to didn’t feel that way. For my own opinion, i just wish they could get less extreme and divisive people to run communities. The Ruby world also had a very divisive personality in Coraline and it was an embarrassing shit show.
/r/playrust
&gt; I don't think that behaviour should be allowed for a community director. This is the base for my concern. 
&gt; overblown by the "anti-SJW" crowd Personally I feel it's not an "anti-SJW" thing, it's more like a "telling users that you and your mods are laughing at users voicing concerns about rules not being applied equally" thing From the linked thread: &gt; p.p.s. this thread is transparent as fuck and we're literally all laughing at your sorry asses behind the scenes. Yes, Node folks are doing this. This just screams "we want to foster an open and professional environment" doesn't it? 
Regex is _the way to do this_. What you want is non-trivial: don't expect a trivial solution. If you reject all solutions posted, you won't find any. However, there are many ways of doing what you want that have already been posted.
The problem to me is that tolerating this kinds of behaviour blurs the clear boundaries set for communication by the CoC. I am a white male but I'm also a foreigner to the country I study, work and live in. English isn't my mother tongue and I speak with an accent. Because of this I had to face discrimination on the job and at university multiple times. Each time the behaviour violated work place statues or the anti-discrimination charter of the university I studied at. Each time the offender got a pass because I'm a male white foreigner. In most instances the comments were clearly racist and nationalist and still nothing was done. I can't vote in this country. When I finish my studies and start working here I will not be allowed to pay into and profit from the social security systems, furthermore I will be kicked out of the country should I ever lose my job, which puts me in a particularly vulnerable position. I accept and even understand all this, but people have also insulted me and treated me poorly intentionally because of my foreign background many times. This is the reason I am very sensitive of people arguing - or basically deciding - that hateful speech against certain groups is acceptable or does not warrant assertive action by those in power. Especially as a German I understand the need to protect minorities. I grew up in a country were Synagogues still look like fortresses. You will find a police car in front of almost every one 24/7. I am absolutely in favour of strict CoC and an assertive stance against any kind of hateful speech. Additionally I see no benefit in excluding any group from that protection. I agree that in Germany someone saying "Gas all Jews" is worse than someone saying "Gas all Germans" due to historic, recent and ongoing discrimination and oppression. But someone saying the later would - in my opinion - still warrant excluding them from the project completely. Likewise if someone writes "Kill all men!" in the context of a project like rust or publicly in general - rant or not - they should be barred from participating. If they made these kind of comments privately they are in my opinion still unfit for any position concerning community management. After all, whose place is it to decide which group can be targeted with such undignified slogans and which ones can't be? Sorry for the wall of text but this is something I feel very strongly about. As a foreigner I am a minority in the country I live in and because I'm white and male I have repeatedly found no support when I faced prejudice and discrimination. I understand that certain expressions and phrases are especially heinous when used against some groups compared to others but I do not understand why we should accept people using those expressions against those other groups. Stereotyping against anybody (even us white males) is bad enough to warrant a strong clear response. No group should get extra treatment in this regard the message should be "we stand united against discrimination from any side".
Concerns about a person can come pretty close to personal attacks and harassment. This is _precisely_ what the mod team exists for, if you have concerns about a person discuss it with us. There is little point discussing it in public, regardless of what that person has done, the only thing that serves is to provide a venue to publicly flog that person.
&gt; Concerns about a person can come pretty close to personal attacks and harassment. So because *some* concerns can seem like personal attacks, *all* concerns are banned? That's ridiculous. It's stuff like that that makes me feel unwelcome in this community, which is why I rarely participate =( Guess that's not a bug, it's a feature now.
&gt; but I'm not sure in what conditions that breaks down. it breaks down when people dont know how to manage centres. if you do things intelligently, f32 is sufficient
and thanks to AI workloads, hardware will also continue getting better at handling *16bit* data aswell (which is also a great tradeoff for some situations in graphics)
What? This subreddit gets disagreements _constantly_. We love disagreement. Disagreements about a _person_ come very close to personal attacks and harassment. It had already crossed the line here. If you have concerns about a person, this is what the mod team is for. Publicly shaming them is not civil. Also, for context, we've allowed discussions about the code of conduct and stuff in the past, and they all get really nasty. This subreddit has proven it cannot handle these discussions, and the subreddit mods decided to stop these the moment they get even a bit nasty.
Congrats to the diesel team! As a rust and diesel noob, I would love to see a guide on how to work with relationships (one-to-many, many-to-many etc.) with diesel. The existing guides all seem to use one table, and the API docs are a bit too hard to grok for me right now. 
Deleting statements of fact is, to me, not the same as moderating a community. &gt; If you have concerns about a person, this is what the mod team is for. I'm not sure censoring disagreement fosters an environment of communication and asking questions about leadership. I'm also not sure that painting legitimate concern as "public shaming" is really valid leadership, but that's whatever. I've made my point and you've made yours.
There's a phenomenon you see a lot when you moderate, where no matter what rules you enforce, no matter how small or obvious they are, _someone_ accuses you of being totalitarian and practicing censorship. Mods have to tune that sort of thing out completely. It might even be the opposite signal; if no one at all is upset, they're probably not doing their jobs :p A way of making the same point but not getting tuned out, might be something like "I think Rule X was designed to solve problem A, but it's also causing problem B. If we had Rule Y instead, I think it would avoid B but still solve A." But also probably in a separate thread, since people-getting-a-rule-enforced-on-them-arguing-that-the-rule-is-bogus is yet another ubiquitous thing that gets tuned out.
Hey, I love you guys, but this seems a little heavy handed usage of a green post.
Right, but, the posts were deleted because "they might soon become rule breaking." As in, several of the posts that were deleted were not harassment or even negative. Preemptive moderating non rule breaking posts actively hampers discussion and growth, no?
Congrats, Ashley!
I share your irritation (I like my little programs) so I did `runner`. Once `rand` is put into the static cache (which is a managed Cargo project) then running a little program is as easy as `runner -s -xrand myprog.rs` (and `-sc` if I want to just compile it. 
No? _discussing people_ is not allowed.
Right, but you're saying "your leadership is your leadership, you may not discuss them publicly." Hence the totalitarian statement.
If discussing people is not allowed, can you help me understand why this (top-level) post hasn't been deleted? Isn't this post nothing but discussing people?
That's not true. I notice you're allowing strictly *positive* discussion of the person. Ok.
It depends, I think. For the stupidest thought experiment I can think of: If a million people decided to post the trebuchet meme on one person's threads, that could turn into harassment worth stopping, even if trebuchet memes per se don't break any rules. If there was a history of trebuchet brigading on someone, it would probably make sense to moderate vague catapult references anywhere near their threads. My point is, it's complicated, it's always complicated. Usually people have good reasons for what they do, and it makes me sad when we don't give each other credit for that. I'm probably projecting a little bit here, sorry for singling out your comment.
&gt; I tried compiling a math-heavy library that I use for regular development to WASM. Turns out, you can only set the library once, globally, not dependent on the target architecture. Can you elaborate on what you mean by this? Do you mean that you can't just take a random Rust library and compile it into WebAssembly to be immediately usable in JavaScript? If so then this most likely won't improve anytime soon. You can use something like [my `stdweb` crate](https://github.com/koute/stdweb), but for that you still need to create a new `--bin` crate and manually export stuff you need.
No, I totally agree that moderation is hard and thankless and you never win. I recognize that it sucks. But I’m also saying, especially in regards to leadership, communities that do not allow public discussion of their leaders (good or bad) are kind of gross, no? We’re being told verbatim there is no public discussion of leadership, which I’m saying is unacceptable.
I'll answer this because it's such an area of competence for me that it'll nag at me otherwise. Here are three ways to do it with Django's syntax (which Jinja is a more powerful superset of): First, you can eagerly retrieve all environment variables: 1. Collect `std::env::vars` into a `Map` equivalent to Python's `os.environ`: use std::collections::HashMap; fn main() { let env:HashMap&lt;_, _&gt; = std::env::vars().collect(); println!("{:#?}", env); } 2. Feed that into your templating engine's context under a name like `env`. 3. `{{ env.fdsfdsafdsfd }}` Second, you can abuse a custom filter as a function. (I did this once to bridge the session API from the F3 mini-framework for PHP with Twig, which is a Django-style templating engine for PHP.) {{ fdsfdsafdsfd|from_env }} Third, you can add a custom tag. {% get_env_variable "fdsfdsafdsfd" %}
In order to compile a library to WASM, you need to set the lib-type to "cdylib". But setting that makes it unusable for building with rust libraries (you need the type "rlib" for that). So my problem is, I want a "cdylib" for the wasm32 target and a regular "rlib" for every other target. cargo only allows you to set the lib type once, it doesn't allow you to set the lib-type per target. [See this issue](https://github.com/rust-lang/cargo/issues/4881). I doubt stdweb will help. It's not about generating the bindings, it's about having crates that are usable **both** in WASM and in regular Rust. 
thx
I am impressed! You allow posts that just tell the world, how *great* someone is, but you disallow everything that could deal with critiques!? I think if someone takes leadership in any kind of organization, he *absolutely must deal with negative criticism*! This is simply an inherent part of the concept of being exposed to others. If you cannot deal with this (which is totally OK!) you simply cannot do the job 😉 To disallow critical comments (not talking about offensive posts of course!) is some kind of censorship, that is typical for political systems, no one really likes (like dictatorships, oligarchy and so on) - except the profiteers of course 😈 I don't think you as the Rust community should choose this road! I am just a reader who is interested in Rust, so I have no idea who this person is or what the tasks are he should do, nor what he might have done before. So I don't know whether there are concerns that are worth to be discussed here. But this introduction is something that makes me feel really bad about the spirit of your community. Hopefully this will change again in future times ☺️
I did a small reproduction of your code, and for me it seems like Rust is able to inline and heavily optimize the stack-based version to such a degree that it almost becomes a constant expression. In real world scenarios, this probably would not be possible and is something you need to be careful with for synthetic benchmarks. If you annotate `calculation` with `#![inline(never)]`, do you get similar results for your two tests? Some of the optimizations I see happening are only possible because the calculation has no effects. I'd suggest adding the following to your benchmark to make sure that your memory is actually used: b.iter(|| { calculation(&amp;mut r, &amp;x, &amp;y); r.iter().cloned().sum::&lt;f32&gt;() }); Code here: https://gist.github.com/udoprog/0437276b7ec3f0bb1b5ec07c3f83bf19
how is your solution application for a *.toml file?
You're a visitor to our community. We get to set rules like "No shirt, no shoes, no service". &gt; and I'll have to ask you to respect me and others. Despite your use of argumentative techniques that I normally only see from elementary school children, we have been polite and patient with you as we aim to teach you how to present yourself in a way which will make others in this subreddit want to help.
Thanks for clearing that up. Please make sure to also remove any comments that support her suitability, so as not to appear one sided.
That is the reason why `test::black_box()` exists, though it is unstable.
Why is the fault of people raising valid concerns that others might get out of hand? If it's anyone's fault it's OP's for making this post in the first place, but apparently that's allowed because (making an assumption here since my question about it was never answered) the mods agree with it.
Right, in the context of this discussion I assumed that it would be obvious that I was talking about negative comments, i.e the ones that actually become personal attacks.
The deleted comments were not personal attacks, as you've already admitted.
Questioning somebody's appropriateness for a role != "personal attack". But this is boring af - i'm going to sleep.
I don't like doing this either; I'd prefer to allow folks to discuss this, civilly, however: - This subreddit has proven time and time again that it can't handle sensitive discussions like this. The discussion was already pretty out of hand by the time I saw it - This specific discussion has been overlitigated in other venues for this person already, which has basically amounted to a mass public shaming of this person.
Right, that is in public, where it's little more than public shaming. State your concerns as strongly as you wish in private.
No, they had already become rule breaking.
&gt; Deleting statements of fact is, to me, not the same as moderating a community. There were statements of opinion as well. I shut down both indiscriminately, yes. &gt; I'm also not sure that painting legitimate concern as "public shaming" is really valid leadership You have a venue to voice that concern. In fact, you have two, you can email the mods, or email other core team members directly. Insisting on discussing it in public doesn't add more to this than moving it from a voicing of concerns to a public shaming.
They weren't personal attacks, however they were still discussing a person negatively, which isn't allowed. There are multiple mechanisms for getting concerns about a person addressed. Publicly flogging that person is not one of them.
No? I thought it would be pretty obvious. And my followup comments all basically explained this, I don't see what was unclear. Also, yes, it took a few hours, because _I wasn't at home for a while in between, and only could respond intermittently_.
Hmm. From the issue: &gt; There is a workaround in that I make a second crate (as `cdylib`), which just exposes the first one (the `rlib`), but I don't think this is the way to go It makes sense to me to use two crates - after all, they should expose two different styles of API. As you may know, a cdylib must expose a C API, with all the associated restrictions like no methods, no generic functions, etc. An rlib is for use for other Rust crates; while it *could* expose the exact same API as a cdylib, it would be more idiomatic to have a richer API that takes advantage of Rust's type system.
Good discussion is fine. Constructive discussion is fine. Constructive criticism is fine as well, however this criticism generally works better when directly discussed with the person, or in case of a behavior complaint, with the mod team. What was deleted was not a constructive discussion. And yes, I've made a decision to stop discussion on this topic _period_ instead of filtering the discussion because it becomes impossible to keep up with, and always becomes 90% concern trolling. Every single time this subreddit discusses certain topics it devolves into flamewars, and the subreddit mods decided to not allow those topics anymore.
Yeah, this is exactly the case; this particular person has already experienced an immense amount of harassment and public shaming and trolling over this same issue, and I'm nipping it in the bud before it becomes a problem here. In general publicly discussing why a community member is not suitable for leadership is problematic _anyway_, because it's basically a public shaming, but in this specific case I'm going to be more heavy handed because of the history of this issue, and past patterns on this subreddit.
&gt; I've made a decision to stop discussion on this topic period No you haven't; in fact, you apparently feel free to discuss the topic yourself in your mod post. You can't even keep your story straight!
&gt; Have them someplace else. IMO these are important conversations to have, and they're banned from Reddit, IRC, Github, and URLO. Where should we have them?
Only the Official Party Statement is allowed, is that it? Just be consistent for once and delete this entire post and I'll be happy. 
Meta rust: I created this theme for Gutenberg, a static site generator built with Rust. You can check out the theme here - https://github.com/piedoom/feather 
Does it break colored error output on windows? I tried to write my own program like this but never figured out how to fix the error output on windows
The key is to pass `--color always` to `rustc` - otherwise it tries to be sensible and not write out colour codes when stdout isn't a terminal. `runner` does work on Windows, and it does pass through colours on Linux/MacOS, let me check...
Great! Glad I could help! I was recently writing a [s-expression parser](https://github.com/Vurich/sexpress) and I needed to use `eq_ignore_ascii_case` for scheme’s `#\newline` and `#\space` escapes, so that’s why it came to mind
I did try passing that, the bug is `--color always` doesn't work on windows.
&gt; The public-in-private hack I think I remember seeing this in D. Basically the same thing, but it called them Voldemort Types. They were more useful since D has more powerful type inference in many more places, however they were still rarely used.
&gt; If you have concerns about a person, this is what the mod team is for. Publicly shaming them is not civil. The issue here is that the concerns were about the new head of community—someone rather close to the mod team. This discussion, which was not (yet) shaming, was removed under rules that'd I'd be fine with for almost anyone else. However, I'd expect leadership to be held to a higher standard, and expect them to be able to take a bit more criticism when they first join. This discussion is going to happen. If it doesn't happen on /r/rust, where the mods can shut down shameful content when it comes up, where does it happen? Probably not the forums, since those have the same rules. Twitter, which gives you barely any space for actual, nuanced discussion? I don't see that as a good option, but it's going to be chosen by many. The mods should have anticipated the scrupulous response from parts of the community (a valid response given what an uninformed member may find after searching for her) and prepared a response to be pinned here. I know you probably wanted to avoid bringing it up at all if possible, but showing a willingness to understand concerns and address them would be a good way IMHO to express the commitment to transparency and clarity the Rust team normally shows. In fact, preparing an actual response would have probably gone over a lot better here than making a bunch of smaller comments. This is a complex situation that deserves at least a couple of paragraphs.
&gt; But then the authors threw the functions out and replaced them by functions that return the change in pixels. What change, you ask? The change in pixels from the last position where winit queried the cursor. winit suddenly returned fractional values (i.e. “mouse cursor moved by 0.2 pixels”) — which is physically impossible. But winit will even send you events like “mouse cursor moved by 0.0 pixels”. Meaning, there is no blocking anymore — if you don’t use std::thread::sleep, your CPU will burn at 100% because of your window framework. Everything got worse. Now I have to check if the difference is 0.0 to check if the mouse hasn’t moved. Which is just ridiculous. On what platform is this happening? Because I'm pretty sure on Linux winit does not generate any event if the mouse did not actually move at all. Now things have changed a little since winit 0.5, and winit now generates two different (and redundant) events: - `WindowEvent::CursorMoved` notifies that the cursor moved and provides its new location relative to the top-right corner of the window, as a `(f64, f64)` (fractional values _are_ relevant for gaming use-cases, with mouses supporting sub-pixel precision) - `DeviceEvent::MouseMotion` notifies that the mouse was moved and provides the delta, irrespective of any window, raw as provided by the input device. This is useful for FPS games for example. But on every mouse motion, _both_ events are generated, so you can just use the one you need. If I'm understanding correctly your need, the first event should be what you're looking for, isn't it?
The problem with holding all these conversations in private is that they don't show up when someone is searching. They find what's public. If it takes someone 30 minutes of research to try and get a handle on what happened with someone, most who see this announcement and just search won't get that far. They'll see the negative post that exists, feel uneasy, and probably just move on. Others not in the Rust community already may not be so kind in their judgement. Having a public release about the issue as a whole gives those who search a quality resource that helps with avoiding discussions like this in the future. I see the discussion here not built off of disdain or a desire to shame, but off of confusion. Widespread confusion about the ethics of a community leader seems harmful to a community, as well as the leader. Being public with this is important *because* it's hard to handle. Not handling it publicly leads to others doing it for you.
Sigh, Windows is always such a special snowflake... Windows 10 console [supports ANSI colours](https://github.com/symfony/symfony/issues/17499) these days, tho `rustc` doesn't know that yet
Agreed. I _want_ to talk about this publicly, constructively. That's why I left that edit on the post up top giving a quick idea of what the mod team's opinion was on this. What I don't want is for folks to start arbitrarily litigating this on their own here, effectively leading to lots of flamewarring and trolling and harassment. Ashley's already been put through this before by a different community. &gt; I see the discussion here not built off of disdain or a desire to shame, but off of confusion There was already some shame-y comments when I got to the discussion. There was definitely some trolling there already. I was going to wait and see otherwise. Sure, there is confusion too. I'm trying to address some of that, and I've said like a million times that specific concerns can be brought up in private.
Nice post (and thank you for the shoutout to my guide from last year)! I wasn't aware that there was a more active fork of the `vst2` crate - will have to try that out at some point :)
But anyone with two brain cells to rub together reading this thread will only walk away with the impression that Ashley has done something very, very wrong precisely because you deleted all the comments with legitimate concerns. Deleting non-rule-breaking comments (as you've admitted) and saying, "everyone, don't worry because the community has decided for you that all concerns are illegitimate" is not a good look.
You're a visitor to our community. Tell us why you have no respect to many members here?
 man 1 envsubst It is part of gnu gettext.
Let's take the library Tera. How can it be use here, for parsing and processing **toml** config files?
Still no info about what databases are actually supported. This should be the single most important information for an orm.. Nowhere to be found on the website or the readme.
&gt; everyone, don't worry because the community has decided for you that all concerns are illegitimate That is definitely not what I said.
Sorry for omitting the code. I posted the question from another computer where I couldn't access it, so I did a quick outline. I'm doing matrix and vector operations, basically what you did but inside nested for loops. const X: usize = 200; const Y: usize = 100; fn calculation(r: &amp;mut [f32], x: &amp;[f32], y: &amp;[f32], m: usize, n: usize) { for i in 0..n { r[i] = 0.; } for i in 0..m { for j in 0..n { r[j] += x[i] + y[i * n + j]; } } } #[bench] fn bench_array(b: &amp;mut Bencher) { let mut r = [0.; Y]; let x = [0.; X]; let y = [0.; X * Y]; b.iter(|| { calculation(&amp;mut r, &amp;x, &amp;y, X, Y); }); assert_eq!(r.iter().sum::&lt;f32&gt;(), 0.); } #[bench] fn bench_vector(b: &amp;mut Bencher) { let mut r = vec![0.; Y]; let x = vec![0.; X]; let y = vec![0.; X * Y]; b.iter(|| { calculation(&amp;mut r, &amp;x, &amp;y, X, Y); }); assert_eq!(r.iter().sum::&lt;f32&gt;(), 0.); } &gt; If you annotate calculation with `#![inline(never)]`, do you get similar results for your two tests? Yes. So `#[inline(never)]` gives the array and vector versions the same run time (close to 0.1ns). On the other hand `#[inline]` and `#[inline(always)]` don't speed up the vector version. 
If the mouse sensibility is low, wouldn't some small mouse deltas result in the cursor not moving? In this case, an event is fired (as `MouseMotion` would have non-zero delta) but the corresponding `CursorMoved` indeed shows up as a 0-pixel move? Or is the `CursorMoved` omitted in these cases?
&gt; There are multiple mechanisms for getting concerns about a person addressed. Could you say what these are? Because right now it seems like you just want to bury these concerns. I'm usually a big fan of the way you handle moderation here, but this is pretty bizarre. Also, the comments I've seen were pretty calm and reasonable, characterising them as "flogging" is pretty disingenuous. 
Thanks for your answer. Sadly, it makes no difference. My reference C code was doing a `calloc()` for each array, so the three separate vectors should be on par with it. 
Thanks for your answer. All the memory in my reference C code was heap allocated as well, so I expected Rust's vectors to match it, but they don't.
&gt; You can't discuss people negatively here. Honest question, is this rule documented anywhere? I don't think I've ever seen a "Don't criticise people" rule here before, and I can think of cases where community members have been criticised here without the mod team intervening. strncat
Postgres, SQLite &amp; MySQL. You're right it could be more explicit
Well, winit fires mouse event when the OS notifies it about the mouse being moved. It does not process the events further than translating the values from mouse physical motion space to pixel space if necessary, depending on the platform. In this case, it's possible that a few mouse motion events are raised with an effective move of 0, but it should not fire them constantly to the point of generating 100% of CPU load.
Email the mod team. Email core team members. I said this in my first post (well, the mod team bit at least). &gt; Also, the comments I've seen were very civil and reasonable, characterising them as "flogging" is pretty disingenuous. Most were civil, some were in the realm of flogging, and more importantly I was trying to preempt things.
Is there a de facto standard for easy-ish terminal graphics (i.e., ncurses)? Even better, is there one that's cross-platform?
As I've said in different words elsewhere in this thread, you don't want to pre-process TOML because the templating engine won't know how to preserve quoting. Instead, post-process it. Walk through the *output* of the TOML parser and run the templating engine on each field that needs to support variable substitution. For Tera, you'd want to use the `Tera::one_off` function with the contents of the TOML field as the template.
Here's the deal: Rust is a project, not a foundation or anything. The teams are working groups. Like, literally, some people are hired on those posts. I can only speak in my role as a community team member. Ashley is leader of the community team. This is not a public-facing task. The people Ashley leads and have chosen her are listed here: https://www.rust-lang.org/en-US/team.html#Community-team. Same goes for core. These are strictly the only people that have a say in that decision. We weighted that. We fully support Ashley. In the community team, we criticise our leadership, put we are also sovereign in our decisions. Indeed, that has happened regularly. This is normal. Ashley has, first and foremost managed to make great changes for our team in the recent weeks. This position is because of good work. I know some people feel entitled to say anything about anyone at any place at any time. This is not the case. An announcement is not the proper venue for upfront criticism or grinding old axes. Rules of general courtesy apply. This has nothing to do with censorship. You are free too leave those at any other place on the internet. 
Ok, fair enough. I didn't realise the mod team's responsibility extended that far. Thanks you!
"kill all men" - Ashley Williams (Rust Community Team Leader) As a white man I feel unsafe and unwelcome in the Rust community.
I'll just add that since there is almost definitely unsafe code to make that `struct(u32)` useful, that unsafe code effects the entire module it is in, not just the unsafe block that is contained within it, and therefore you must ensure that everything in the module maintains safe rusts gaurentees.
&gt; Criticize technical decisions, criticize actions all you want. The comments I saw /were/ criticising actions without making personal attacks, so apparently that isn't enough. &gt; But I'm not actually banning or warning anyone about this; which is when it would have to be documented. I'm preempting something by deleting posts. It doesn't have to be documented. It's good that you're not banning anyone for this, but I think it would be good for people to know (ahead of time) which of their comments will be deleted by mods as well. I understand the desire to not be overly explicit about this sort of thing to avoid rule-lawyering, but on the other hand using "rules" that nobody knows about to pretty arbitrarily delete comments you don't like isn't ideal either. 
Bring it up with the mod team
([posted](https://www.reddit.com/r/ProgrammingLanguages/comments/7nsrn2/monthly_what_are_you_working_on_how_is_it_coming/ds68g4v/) on /r/ProgrammingLanguages as well) Currently working on trying to implement Areas Löh et al.'s [tutorial on implementing a dependently typed lambda calculus](https://www.andres-loeh.de/LambdaPi/). You can see my progress at [brendanzab/lambdapi](https://github.com/brendanzab/lambdapi). Currently running into an annoying bug with my debruijn indices, so the tests don't currently pass. :(
I have the same impression. I really don't know what is going on this thread but it frightens me a bit 😓 Anyway: Welcome Ashley! Might your leadership of the team be fruitful!
Hi! I was working on a tracker and telemetry system for high altitude balloons. The system works using a raspberry pi zero and a custom board with the lora radio, barometer, battery circuit, temperature sensors, etc, and cand send telemetry packets and images using SSDV packets. You can see a preview of the system working here: https://www.youtube.com/watch?v=lOtWIxiUApo The custom board is here: https://github.com/ladecadence/StratoZero And the original python code here: https://github.com/ladecadence/ns1/tree/nsx The tracker code uses my python library for the LoRa rf95 chips I was talking about: https://github.com/ladecadence/pyRF95 I'll be great if you wanna help, as I said I'm just starting with Rust so any help is welcome. I've ported most of the pyRF95 code to Rust but the receive interrupt related stuff I was asking about: https://github.com/ladecadence/ASHAB-RS/blob/master/src/rf95.rs 
Or replacing. It's the third one I've seen....
[rusqlite](https://github.com/jgallagher/rusqlite)? It would be helpful if you included more of your criteria. What is it about Diesel that makes it less of a great fit for you? I'm personally happily using SQLite with Diesel :)
Well I have a project where I do this too (I call this type `Float` though) because: - the `num::Float` trait isn't perfect (IIRC `std::ops::` traits missing, no equivalent to `_ as _` conversions, etc.) - parametrizing every single type/function by the `num::Float` trait is painful - using functions parametrized by the `num::Float` trait is painful (`a.into() + b` might fail to deduce the type of `a.into()` but `b + a.into()` works) - modules, crates, etc. cannot be parametrized
Yeah, exactly this.
Do you really think something has changed since [the last thread](https://www.reddit.com/r/rust/comments/7jjwtr/alternative_to_diesel/) 3 weeks ago?
My question was why *not* nightly.
So they can be ignored and never been known about
diesel is heavy
yes. and you?
I love this kind of post! Thank-you.
Great! Without looking at the generated assembler it's hard to tell, but: Try returning the sum in each iteration. This way the intermediate calculations definitely can't be inlined or removed. Consider filling both the vector and the array with random values. This way the calculations aren't constant and there's no way for the compiler to remove them.
Yeah. I believe returning a value from iter blackboxes it. But I can't seem to find the documentation to Bencher :P.
Most of these concerns can be trivially found online with a simple google search. We're not hiding anything.
This is nothing new. For a few years the Rust team not only developed the great languge, but also pushed SJW / PC agenda, promoted positive discrimination, affirmative action and CoC that basically says support our agenda or STFU. All taken together, they created a hostile environment I don't wanna be part of (nor validate by my taking a part in it). I'd like all communities to take a step back, realize that tolerance tolerates, that's its not a blunt object to be used to silence/opress others, to adopt [NCoC](https://github.com/domgetter/NCoC) and be done with it.
you know what's better for me?
As someone who's watching this community, but not participating in any big capacity, I find this whole announcement and follow-up behaviour a bit strange. I understand that you don't want people to write personal negative opinions about a new leader, but by deleting every criticism it sounds like you're *very* afraid of what might appear. I hadn't heard about Ashley before this announcement and now I'm really wondering what happened. I mean, did she kill someone or something??? It seems like she's done something *really*, **really** bad and you're afraid that it might come up. Can you just … not be so afraid? Acknowledge that some people have had an issue with her earlier? Say that you haven't experienced anything of that sort and are all happy with her work so far?
Unfortunately [kairos](https://crates.io/crates/kairos) does not support this (yet). If there is demand, I could add this functionality, though...
Black-boxing the return value only prevents the compiler from eliding the computation entirely; it can still be const-folded. To benchmark the computation as if over dynamic data, the inputs need to be black-boxed as well. The docs for the `test` crate are unfortunately not published even for nightly so all you can really do is read [the source](https://github.com/rust-lang/rust/tree/master/src/libtest).
Diesel core team member here: Feedback from the community is very valuable to use! If you have some more _specific_ feedback, we'd really appreciate it! :)
This is simply not true. As a (mostly) inactive community member, I'm interested in what all these people are angry about, and I tried to google her name, along with "rust", "critique" and "comment". And all I find is some sports player which I don't think is the same person discussed here.
Censoring opossition (usually through the ugly "we're being nice here, and what you say might hurt some-snowflakes feelings" pseudo-justification) is, sadly, the norm in the "progressive" communities. Get used to it, or get ready to silenced &amp; ejected, and that only if yu are lucky. If you are not so lucky, you'll be villified, doxxed and attempts will be made to make your employer fire you. (And since today comanies are either already busy virtue-signalling, or at least scared of the PC / SJW mobs, it's not that improbably you'll be fired for an innocuous statement that's been blow out of proportions and re-interpreted using their insane rules. Oh so Orwell it's not funny ...)
There are some legitimate uses: https://rust-lang-nursery.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed
You're right. Making the function return `r.iter().sum::&lt;f32&gt;()` and moving the assertion inside the benchmark slows the array version down to the vector version. I also noticed that by writing the function body in unsafe code and using pointers to access all items, the performance of the array and vector benchmarks matches their C counterpart. 
I come from a security background. So I'm wary of algorithmic complexity attacks (hash DoS is a well known example), where an attacker maliciously crafts data which hits the worst case performance of your software. In your case you might weaken the guarantee to 100 or so consecutive combining marks, which allows you to still break up the degenerate case of where you have to deal with millions of them.
If fractional mouse position is only useful for gaming, why not just report the window-relative position using integral numbers?
&gt; though it is unstable. So are benchmark tests generally, so that shouldn't be a huge barrier.
Diesel *is* conceptually heavier than alternatives like writing SQL strings directly; its type safety must essentially be appeased, and if you don’t *grok* the Rust type system, using Diesel *will* be painful, while you might be able to get away with speaking SQL directly and using `result.get("field")` all over the place without such a deep feel for Rust. But I do not think that this suggests anything should change in Diesel, beyond steadily improving the introductory documentation over time, to get people up to speed with the awesome. I *think* that’s what the OP is complaining about; if not, well, it’s all true anyway. ☺
&gt; No rand() in the standard library + unnecessary cryptography Is hash function performance significant for you? Since the hash function used (SipHash) is fast and the "make new hash key" function is basically (old key + 1), there's probably not much margin for performance improvement by dropping hash DoS protection anyway (aside from the first hash key creation, which does get a strong key from the OS). For non-crypto random numbers, `rand` does have `weak_rng` (Xorshift) and will soon have some other options.
After seeing the comments in this thread I found a report on Ms. Williams actions, if anyone is interested: https://www.reddit.com/r/node/comments/6whs2e/multiple_coc_violations_by_nodejs_board_member/ I personally think it is very strange that a person behaving like this can be appointed as a leader of the Community Team (even as a member of the Core Team, in fact).
Hello Looks like a great thing. Few random notes from reading the article: * Authoritative servers usually compete with qps, not latency. It is related, but you try to overload with huge amount of queries and see where they start dropping. With your measurement, the server gets a rest between each query (if I understand it correctly), which isn't exactly realistic. * It makes sense to measure negative answers too, they act differently. * Bind 9 isn't exactly the fastest out there. Would it make sense to compare to others? * Seems like you find the exact same places expensive as other DNS servers (name compression, name comparison and lower-casing, lookups). * There are two things the DNS servers try to employ to boost performance. One is whole-message cache (the queries that are used often are kept pre-rendered and only the transaction ID is inserted and reused) and the `recvmmsg`/`sendmmsg` calls to receive/send multiple UDP messages per one system call when they are available.
Awesome, I'll have to try this out.
&gt; State your concerns as strongly as you wish in private. &gt; Most of these concerns can be trivially found online with a simple google search. To me, these two statements contradict each other. If I have concerns I want to be known, how can I make sure that they given the attention they deserve and aren't deleted unilaterally by a single person? I actually read the deleted thread earlier today, but opted to wait for a response before forming my opinion on this matter. Rather than providing a well-reasoned response that discusses reasons why the nod incident will not be an issue for this community going forward, and what safe guards are implemented against high-ranking community members abusing their positions, the factual and extremely relevant thread gets deleted instead. What are we, members of this community, supposed to conclude from this? I don't care about Ashley's past. People make mistakes, and I'm more than willing to give her a second chance. What I do care about is a fair and transparent leadership for the projects I care about. What I care about is certain views and agendas getting preferential treatment at the expense others as has occurred in this thread.
I'm rewriting my Node.js server in Rust, here a note to track the process: https://www.facebook.com/notes/%C4%91%E1%BB%97-duy/goodbye-nodejs/389589361494135/
Is there any way to have cargo compile with target-cpu=native for everything by default? Most of the time I'm just compiling stuff to use on my local machine, I wouldn't mind having to manually turn it off if I'm packaging something for distribution.
A solution by r/user/Gankro : http://cglab.ca/~abeinges/blah/rust-reuse-and-recycle/#higher-kinded-types Warning: you may not like it...
&gt; If I have concerns I want to be known, how can I make sure that they given the attention they deserve and aren't deleted unilaterally by a single person? Bring. Them. Up. With. The. Mod. Team. Most concerns about Rust can be discussed in public here. Concerns about a person have no place here. And yes, this can coexist with "this is easily googleable", because the point is to disallow this kind of discussion on _our venues_. &gt; and what safe guards are implemented against high-ranking community members abusing their positions The mod team. Other core team members. Mob justice doesn't fix things. You're not going to accomplish anything constructive by discussing someone's behavior in the open as opposed to discussing it in private with other community members and leaders. 
Found this as well after trying to figure out what the hubbub in here was about. Making stupid or offensive tweets is something probably everyone has done at one point in their life and regret making now but a lot of these are from the last 12 months, some the last 6 months. With the amount of effort that goes into the Code of Conduct and inclusiveness and whatever else strange is the only way to describe this.
&gt; Bring. Them. Up. With. The. Mod. Team. &gt; The mod team The way this discussion was handled sufficiently demonstrates why I don't have confidence in the mod team. Instead of addressing concerns, they are deleted instead. Why should I believe my concerns will be treated differently if made in private? Until transparent polices and procedures are implemented, "Contact the mods" isn't going to cut it.
That's a circular bit of reasoning. The stuff was deleted because you _can_ bring it up in private. This has always been the policy; we have always avoided discussing concerns about people in public venues.
I agree with you. I didn't see the deleted comments, but I found that /r/nodejs thread myself. Since /u/Manishearth said the concerns were about remarks made years ago, I suspect he's not aware of the more recent ones, or chooses to ignore them. I considered sending an email about it, but in the end chose not to, for fear of reprisals -- even though my online presence is rather minimal.
Even assuming you'd solve the panic issue, the first one isn't safe &amp; sound: let cell = Cell::new(Foo::new()); let cell1 = &amp;cell; cell_borrow_with(cell, |x| cell1.replace(Foo::new())); `cell1.replace()` will return the garbage value which is inside the cell during closure execution leading to double free. You probably want `RefCell` or maybe `Cell&lt;Option&lt;T&gt;&gt;`.
Well, the problem is two-fold. First, the `EventLoop`-based API takes a closure, it doesn't return an iterator anymore. The closure runs on **every** event that comes in. Plus, it gives me events when their are none - or the events aren't even relevant to my window. That, together, makes for a questionable design. &gt; irrespective of any window Yes, and I don't understand this decision. Even if my mouse is outside of the window, I still get events, why? They are completely irrelevant to my application. I basically have to duplicate the work of the window manager to check if my cursor is in the rectangle on the screen. Pair that with the fact that I still got events when not moving the mouse at all and the above "closure design", and you get why I am pissed off. And yes, I submitted [an issue]() &gt; fractional values are relevant for gaming use-cases I suspected that, but it doesn't help me. All I want is a simple loop that blocks and provides me with the values that are relevant to only my window. And that doesn't fire with values every 10 microseconds. &gt; But on every mouse motion, both events are generated Yes, but due to the closure-based design I still have to check them first to see if they are relevant, leading to the 100% CPU usage. Every windowing framework ever (X11, Win32 or Coacoa) has a message loop that returns integer values and blocks until the cursor has at least moved 1px. winit had that, too and threw it out because of gaming use-cases. 
Why ... why would there be reprisals for doing something we explicitly asked folks to do? We've had two folks contact us already and have had perfectly good conversations there. If you want to contact me individually, &lt;username&gt; at gmail works.
My reply is purely to the allegations layed out in the parent post. I'm not afraid of anything and don't consider the announcement a big thing, I just feel like this person is trying to frame things in a way that they aren't, especially raising censorship. That is all :).
&gt; This has always been the policy; we have always avoided discussing concerns about people in public venues. This is not true, or at least the enforcement of this policy has been very inconsistent. I remember in-depth public discussions of (now former) community member's behaviour. You participated in some of these discussions.
I don't think people are going to believe their concerns are listened to when they have to send them privately by email and any public message that goes against your position is deleted.
Thanks, Once the load binary command is in, how hard do you think it will be to run [freedos](http://www.freedos.org/). It mentioned maybe turning this into something like dosbox. If that is or becomes the case you can leave the emulator to you guys and the os to them.
Right, it's not consistent, it's more case by case. But I think most of the time we've tried to move discussion off public venues aside from mod notes, and often deleted comments discussing this. We should be more consistent, but in some cases you need to address things. "avoided" is key.
If, as you suggest, enforcing the rules causes more upset than not enforcing them, the next logical step might be to scrutinize the utility of those rules. (Just not in public, eh!)
If, as you suggest, enforcing the rules causes more upset than not enforcing them, the next logical step might be to scrutinize the utility of those rules. (Just not in public, eh!)
If, as you suggest, enforcing the rules causes more upset than not enforcing them, the next logical step might be to scrutinize the utility of those rules. (Just not in public, eh!)
That does not compile, I tried that, too. I think rustc quits and says "cannot generate rlib for WASM target" or something like that. 
I'm not sure.. In order to emulate at a lower level (for a general OS support) I would need for example a low level emulation of a hard disk. With my current approach, I can just map file accesses to the current file system. (I might be wrong in this, I haven't looked into it much). 
The old version did exactly that. I think winit still has that with `DeviceEvent::MouseMotion`, but now you get events even if the mouse cursor is not in the window. Which is contradictory to what any windowing framework ever does. I understand the gaming use-case, but now winit doesn't expose the old behaviour (the native message loop) anymore.
Yes, there was a [pre-RFC discussion about removing that](https://internals.rust-lang.org/t/pre-rfc-warn-about-inaccessible-types-in-public-function-signatures/5156) after `pub(in module)` landed.
How is this related to Rust?
Actually, I am still searching appropriate community for my post, very sorry 
Requiring code of conduct violations to be discussed privately is often critiqued as being part of the playbook for people wanting victims to go away. I'm assuming you are familiar with this sentiment and believe this objection doesn't apply here, could you explain your reasoning please?
This is great news! Congrats ag_dubs!
&gt; ...I have no idea who this person is or what the tasks are *he* should do, nor what he might have done before I've noticed that when there's a bunch of "it's about ethics in forum moderation" posts around that often there's some gender politics not too far away. 
I'm not even sure that fractional mouse position is useful for gaming. The human arm and hand are not reliably capable of sub-pixel precision as far as I know (at least at typical resolutions today), and that is many times more impactful regarding precision of movement than the qualities of the mouse used. A high-DPI mouse is just more sensitive to small movements. That doesn't make the mouse+user system more capable of realising minute adjustments. If anything, it makes it *less* capable, because for actual precision you want to translate large mouse movements into small on-screen movements, which is hampered by excessive mouse sensitivity. I can understand the need for raw mouse input, if it allows said input to bypass OS meddling like acceleration/smoothing, but the argument about precision sounds absurd to me.
Ashley is not a "he."
Great introduction to VST plugins! I have a question about the last example: why does it require interior mutability? As far as I can tell, all methods modifying the notes field get passed a `&amp;mut self`, so should be able to modify the field directly. I rewrote it without Cell and it at least compiles: [Gist](https://gist.github.com/MathiasLengler/ac5d1076294915347cf0aa749e908e3e)
That makes sense, and is also why I recommended providing random values as inputs here: https://www.reddit.com/r/rust/comments/7nkfq8/hey_rustaceans_got_an_easy_question_ask_here_12018/ds69mmz/ Looking at the source, there doesn't appear to be any way to flag inputs. How would you do it?
Is print_string not idiomatic OCaml?
Cargo's `--name` parameter *does not* allow you to override naming restrictions. You will not be able to produce a cargo-based project ("package") with that exact name. Take directly from `cargo help new`: --name NAME Set the resulting package name, defaults to the value of &lt;path&gt; You are getting that error because you have not provided the required `path` argument. Intended usage of `--name`: You can use this parameter to give your crate a name that is different from the path it will be created in. cargo new --bin --name my-crate-name my-crate-path Given then above command cargo will create a directory `my-crate-path` and inside of it scaffold a crate named `my-crate-name`. Hopefully this helps.
I'll try to start working on a `SQLite` backend for my [`tql` ORM](https://github.com/antoyo/tql) next week.
&gt; I also noticed that by writing the function body in unsafe code and using pointers to access all items, the performance of the array and vector benchmarks matches their C counterpart. That points to bounds checks as a potential cause of the Rust slowdown. The optimizer can usually remove them though -- you'd really have to check the assembly to see if it's happening for your code or not. Sometimes accessing the end of the array first (or just asserting that `x.len() &gt; highest_index_that_will_be_touched`) can be enough of an optimizer hint.
Note that the `fsize` type being defined depending on a feature is not a good use of features, which are supposed to be purely additive.
Deleting posts that disagree with a decision you’ve made is the definition of censorship.
No, it isn't.
Why are you just stating the negative impact on *her* but not addressing her inflammatory comments themselves? What do you think about her comments, were they appropriate? Will you encourage or support her if she makes similar comments in the rust community? Have you told her you don't want her to act similarly again? You're just talking around the issue, giving her unconditional support but not actually addressing any of the concerns people are raising... 
Then please tell me, where can we as a community discuss this matter publicly together? Seems as though the Rust team response is “you can’t, message the core team directly.” Which is not helpful.
&gt; Yes, but due to the closure-based design I still have to check them first to see if they are relevant, leading to the 100% CPU usage. I don’t understand this (I don’t really know neither `winit`, nor other windowing frameworks, I only had very brief contact with SDL, SDL2 and GLUT a few years ago, so it’s not surprising I lack understanding ;-)). How is this related to closure-based design? How different design would prevent it? If the framework checked if the event is relevant (more than 1px movement), wouldn’t it still use the same CPU cycles for the check to decide whether more code (your callback) needs to be executed? Reading your post I got the impression that the framework runs in a loop, generating mouse move events regardless whether real events happened (if none happened, calling your callback with `0.0` mouse movement), and never waiting for real events, thus really eating 100 % CPU. But reading through comments here I understand that’s not really the case, and the framework waits for actual mouse events to report them (some of them very often with small movement irrelevant for your application, because that’s what’s actually being reported by the hardware) – and they still need to be somehow filtered by some CPU work (in the framework’s loop itself, or your callback’s body). What do I get wrong?
You're moving the goal posts. You said, "... [the mods] has decided for you that all concerns are illegitimate." But that's blatantly not true and is an extreme misrepresentation of what /u/Manishearth has said repeatedly. &gt; Seems as though the Rust team response is “you can’t, message the core team directly.” Which is not helpful. Really? How do you know? Have you tried? You know what isn't helpful? Publicly flogging a member of the Rust community in a Rust venue. We don't control the Internet. Pick some other venue to do it if you must. It's not our responsibility to provide that venue for you.
That's my take also. I've only used it a bit (not for anything in production yet), and it seems to work fine, though there are some holes, and some things don't seem to match the Stripe spec exactly (for example, I have an open PR to make one of the `Charge` fields optional as it is allowed to be: https://github.com/rapiditynetworks/stripe-rs/pull/10/files).
how does their v1 correspond to versions at Stripe https://stripe.com/docs/upgrades#api-changelog ? 
Awesome! Is there a way to make cargo check tests + benchmarks by default when calling `cargo check`?
Hey, molten author, randomly found this via a search; Molten still needs a few bugs ironed out and a completed API (we're using this release to inform what it should look like). There are no huge blockers except for how little time I have to work on it. Once it's done, you should see a switch to Molten for fully lossless parsing and editing!
I don't have much to say, but this is just so cool!! I have (and I'm sure others have thought of this, too) a pipe dream of a GitHub+Soundcloud like website, but for music mixes. Where anyone can upload their raw mixes--rather than final renders--and anybody else can mix, tune, add tracks, change plugin parameters, etc, perhaps in an digital audio workstation that can run natively but also in the web. (Of course, with Rust + VST + Webassembly this could be achievable.)
&gt; I'm really wondering what happened &gt; like you're very afraid of what might appear. Death and rape threats directed at women in tech, like always.
It does! Thanks.
Of course you are free to apply your rules, if this subreddit *belongs* to this project as you call it. But you simply can't change people's mind - and not to allow people to comment on this announcement as on any other topic here will certainly raise bad feelings in many redditors here. I totally agree that often posts are offensive (especially when dealing *directly* with persons), but those that aren't surely add something meaningful to this topic. And after all she is taking the leadership in a team that has the term *community* in its name - sounds even more ironic that you won't let people that form such a community express their opinions 😯
I don't know of a way, but you could add an alias to your cargo config that passes the options you want.
My own variant of this idea is just called `time-tracker`. Maybe I'm just old and grumpy but I'm so over cute abstract names that don't describe the project.
I think your report also shows some of the benefits of keeping things external though. If something changes in a way that doesn't fit with your program, you can stay on the older version, or potentially fork it. That'd be harder if it was in the standard library.
The way this discussion is being handled is something I really like about the mod team's way of working. Some (or many?) people are wary of code-of-conducts in general because of the looming fear that a mob will destroy some person's reputation or job or whatever. The mod team is avoiding that. Stopping public discussion of people on either side of any argument is something I find extremely reassuring.
Maybe I'm not understanding the use case, but why? I use `cargo check` to check quickly without compiling everything, so I want it to do as little work as possible. Isn't there `cargo test` to run your tests?
I think he meant check the tests and benchmarks, not run then.
*Maybe I'm not understanding* Indeed I wasn't. :)
&gt;The mod team does not consider hyperbolic comments she made years ago, in an informal venue, in frustration, to be a problem. Alright. I've never heard of her before now, but it pissed me off reading the shit she was saying as recently as Aug 6th: "Kill all men" (I also want to point out that's much more recent than "years ago"). I believe I'm on record defending rust's CoC, since I believed it was a sincere effort to promote an inclusive community...but am I wrong in saying that someone who had said these things about women would have been passed over for this position? And that the CoC would have been brought out to justify it? In light of this situation the CoC just looks like a political weapon. Enforce. it. consistently. To be clear: we're not re-hashing the node thing *or* harassing _anyone_, and I'm a little annoyed I have to say that (since that seems to be what you're beating everyone else over the head with). I think I (and many others) just find it a little odd you're giving such an inflammatory character a leadership position in a community that is supposedly inclusive. If you think that's harassment than I don't know what to tell you. Also: if she does that shit again how do you think that will reflect on the rust community? Why take the risk?
I think a generic `Cursor` API would be nice, beyond `Entry`. Cursors are different from iterators since you can move a single cursor forward and backward at wish, whereas iterators only ever yield a single element once.
&gt; I totally agree that often posts are offensive (especially when dealing directly with persons), but those that aren't surely add something meaningful to this topic. And after all she is taking the leadership in a team that has the term community in its name - sounds even more ironic that you won't let people that form such a community express their opinions 😯 This is a common misunderstanding: The community team is a group of volunteers doing community work, not the communities representation within the project. This also means that we do not speak for the community within the project. In fact, most of what we do is collecting data and retweeting at the appropriate places. Call it ironic as much as you want.
The release changes are getting smaller. What is the reason and is this good?
I don't think I fully understand the difference between `cargo test` and `cargo check`. Where is this explained?
I don't know anything about her, and I don't really care about what she says on Twitter. What I care about is Rust being a great language. However, I have some big concerns with the announcement. Namely, this: &gt; improving Cargo by incorporating best practices from npm. There is nothing in npm that could be considered best practice. I really don't understand why the Rust project/community/whatever, with its aim of creating a great systems programming language, wants to become more similar to Node in any way. 
There's been a ton of foundational work going on that hasn't hit stable yet. The number of contributors, for example, was noticeably one of the highest we've ever had for a single release.
[removed]
`cargo check` compiles your code, but doesn't do codegen, that is, it only checks that your code compiles. `cargo test` compiles your code and tests and then executes your tests. Previously, `cargo check` would only check your code, not your tests. Now it can check your tests too. They won't execute, as no binary code is actually generated. Does that help?
Oh oops! I knew there was something weird when I was doing this last night at 4am. I'll add a fix and credit you, thanks for spotting that!
Your usage of the term *community* will not enlighten me, as you use it in so many contradicting meanings... So quite natural that I have probably missed the *real* kind of concept that your *community team* is all about 😉
On the other hand, discussing concerns publicly can quickly devolve into lynching when well-meaning people jump on the bandwagon, all from a simple misunderstanding or out-of-context statement. Decisions and critics should be reasoned and thought through, which public discourse unfortunately rarely achieves. If you have an alternative to this private/public dichotomy, which mitigates either issue, please do let us know!
It's interesting that cargo alternative registries and rustfmt getting included in release tarballs (which seem like huge features) didn't make it into the release announcement, and are only in the detailed release notes. `rustup component add --toolchain stable rustfmt-preview` succeeds, but then `rustfmt` (and `cargo-fmt`, etc) are not on my path so I'm not sure what's actually going on there. Maybe there's more work for those to actually be usable? The release notes aren't super clear about what they mean.
They're removed from the release notes, as they were included erroneously. Hasn't been merged yet though https://github.com/rust-lang/rust/pull/47160
Ah, good stuff. Thanks!
AFAIK, the Stripe API is `v1`. However, I have no idea what kind of backwards compatibility Stripe guarantees with their various dated upgrades, nor which dated upgrade (if any) the authors of this Rust lib are targeting. I'm on the latest version of the Stripe API and everything I have tried so far is working mostly fine. If you have trouble doing something, you might ask the Rust lib what upgrade date they are targeting, and then pin that version in your Stripe configuration (assuming that is possible).
To elaborate slightly, alternative registries landed, but is a nightly-only feature, and so isn't included in the notes. `rustfmt` being included is coming next release. That's not the only big thing for 1.24 though, I'm excited about it!
I agree. The Community Team is responsible for "coordinating events, outreach, commercial users, teaching materials, and exposure". Her previous CoC violations in the Node community would harm those goals if they continued here. It is likely that these issues have already been raised internally by the Rust Team, but it is important to also have the trust of the community, which can only come through transparency. I would like a clear, public apology and statement from her that this will not happen in the Rust community before I could support this decision.
I've attempted to read through this report. It seems extremely partisan, and a good number of quotes seem taken out of context and interpreted through a very distorted point of view, as if the reporter was more interested in taking her down than objectively stating the facts. Some quotes did give me pause, I'll admit. Her language is colorful, and was sometimes violent. Definitely not safe for kids, and possibly not safe for work. However, that is far from "damning" evidence. I hope that she has realized this issue, and will endeavor to do better. And in the mean time, I will trust in the Community and Core teams' judgement, having never had the opportunity to interact with her myself.
[removed]
I decided to go ahead and implement punycode support. With the idna crate, this was actually quite simple. https://github.com/bluejekyll/trust-dns/pull/325 this also simplified a lot of those comparison cases.
Really I just want ASM to access a few minor instructions like pause.
Personally, I try to err on the side of kids-safe phrasing on Internet, so **no** I would certainly not have written a number of those statements. Of course, I also avoid twitter because I find its short-message nature too easily leads to "hot-headed" statements that are then regretted, so maybe I'm just an old curmudgeon...
I seem to have gotten the rustfmt thing entirely, at least on Windows. Either this was unintentional or only got included in some OS versions? &gt; rustup run stable rustfmt --version 0.2.16-nightly (2bfcadf8 2017-11-21) &gt; rustup which rustfmt C:\Users\__\.rustup\toolchains\stable-x86_64-pc-windows-msvc\bin\rustfmt.exe &gt; rustup component list --toolchain stable [...] rustfmt-preview-x86_64-pc-windows-msvc (installed) &gt; rustup show Default host: x86_64-pc-windows-msvc stable-x86_64-pc-windows-msvc (default) rustc 1.23.0 (766bd11c8 2018-01-01) e: I checked the downloads for x86-64 linux and aarch64, both have a rustfmt. Added a comment to that effect to the linked issue.
I'm not sure how big of a difference this would make, but it might be worth it to benchmark `.split(' ')` vs `split_whitespace`. `split_whitespace` is guaranteed to match all unicode definitions of wihtespace, and match multiple spaces as one, so if your data is guaranteed to be split by spaces maybe that could help? I can't think of anything besides that.
Hey, thanks for expressing my thoughts exactly! :) I’ve chatted with Ashley briefly during Rustfest: she is awesome and her talk was a blast! :)
&gt; getting Rust 1.23.0 _is as easy as_ _do re mi, a b c, 1.23 baby you and me_
There is an error there, apparently no `cargo-fmt`. There *is* a `rustfmt` however, and `rustfmt +stable &lt;srcfile&gt;` does work
Just published a new release of the [fern](github.com/daboross/fern) with support for the syslog crate. I've been working on documentation for it, and also thinking about how best to package logger recipes. For the rest of the week, I'll be laying out a roadmap of issues for my screeps-rs graphical game client (for Screeps). It's been interesting working with conrod, and I've been surprised at how much of a difference a different architecture can make for performance. I recently implemented writing my data to display to a set of textures, rather than directly to the screen each render, and it drastically sped up panning around the game map.
This sounds like a fun project, I'll help if I can :) I know some about rust but not much about dos!
If it's as a first programming language, you might want to pick up something else first so you have something to rewrite in Rust. 
Ahh right, looking at the files I'm parsing, it seems that they do get variable number of spaces as they're being output by this old fortran code. Oh well!
I have a few questions. What are the merges in "Updates from Rust Core" being merged into and when will those changes be in a stable update? I have a macro that converts a string conveniently into a struct or panics if there is a problem with the string (so that the compiler warns about the panic and gives usefull information), but I sometimes accidentally put the wrong thing into the macro. A .to_string() function inside the macro still works and not panic on many things leading to a confusing bug hunt. How would I check that the type of thing entered into the macro is a 'static str? Is there also a way to explicitly check a string and convert it into whatever at compile time?
Port it to web assembly! :P
&gt; Rust, ReasonML, or Scala? Yes.
I know nothing of the drama, but I have experienced in the past that this subreddit can have vocal members who don't seem to understand that a greater context is more important than blindly applying rules. Even if we say that Ashley violated the CoC and that it being a personal twitter was not important, it doesn't matter. It doesn't matter because her comments are an obvious frustration with the greater context of the tech industry. The odds of you being a white man who can spend his time reading about Rust, learning it, _contributing_ to it especially (there is a known class bias in those who are capable of spending their time in the open source sphere), means that you are likely privileged, if not _very_ privileged. We don't analyze a chess game and ignore thirty years of history, the history is required. Ashley's comments are frustrations with the implicit sexism that still exist in online communities and most certainly in tech. I like to believe the Rust community is better than most other online communities at realizing this. I personally, find it frustrating that the community doesn't seem to understand this, and will leverage their criticism seemingly in a vacuum.
Regardless of your views on it, I'm not sure creating another thread (when the moderators have locked one) is particularly helpful
So it's kinda like this in terms of the scope of what each command does? +-----------------+ | | | +-------------+ | | | | | | | +---------+ | | | | | | | | | | | +-----+ | | | | | | |check| | | | | | | +-----+ | | | | | | test | | | | | +---------+ | | | | build | | | +-------------+ | | run | +-----------------+ 
I don't think you can check the type, unless you do a trick like this: macro_rules! only_string { ($arg:expr) =&gt; { #[allow(unused_variables)] { let _: &amp;'static str = $arg; } println!("{}", $arg); } } This makes sure the macro argument is of type `&amp;'static str`,
I think you accidentally posted this twice. Delete this one?
&gt; In particular, nit-picking through individual tweets and complaints about them seems entirely unproductive, and likely to shed more heat than light on the issue. I was replying to a single npm-thread/report, not "individual tweets." The npm-thread *itself* nit-picked through individual tweets -- were you saying that the npm thread itself wasn't productive (I would agree with you there).
I would like to convert a vector to a tuple, where the tuple contains all the elements of the vector, is that possible?
Here is [one post of one person's concerns](https://www.reddit.com/r/rust/comments/7nx3cm/announcement_ashley_williams_joins_the_core_team/ds6vc7w/) on the issue: &gt; The Community Team is responsible for "coordinating events, outreach, commercial users, teaching materials, and exposure". Her previous CoC violations in the Node community would harm those goals if they continued here. I don't personally hold their concerns, but I thought they stated it the most succinctly.
I felt a lot of the frustration was over a lack of information and *any* discussion, even a "one sided" one. If the community team had done a (separate) short thread to give even a small response to these "accusations" then things would have gone much smoother IMO. All users were seeing was that "posts had been deleted" and it smelled like drama. Some seemed to feel that their free speech had been impinged and jumped in with outrage.
Disclaimer: I don't know anything meaningful about the previous drama. I'm speaking in generalities. I also don't think that this thread is likely to be productive, I'm just speaking so that there is one more voice for diversity in Rust, silence is poison. People who don't like codes of conduct are also often the people who think that feminists' complaints of the status quo are actively harmful. They also tend to frame the criticisms of the status quo as attacks on white men, rather than as criticisms of a system that has institutionalized the promotion of white men for essentially all of history. The "this is attacking me" framing is important because, thankfully, it's no longer straight-up okay to be openly sexist. You've got to go through contortions that make it look like the system is fine, and that feminists are attacking for invalid reasons. Hence, a woman instituting a CoC is going to be a target of attack. You have to be incredibly brave to be willing to openly be a woman in a position of power fighting for diversity in open source. I didn't know much about Ashley Williams before this, but learning about it makes me incredibly happy to have her leading the community team.
Well said! I would change "People who don't like codes of conduct" -&gt; "Generally people who don't like codes of conduct"... but your entire first sentence made it clear you were speaking in generalities. I think there is also an idea that just because there is a code of conduct means that nobody should be "uncomfortable". When a white male (like myself) inevitably gets uncomfortable about a woman talking about unfair power dynamics (I feel like she's accusing me! I feel uncomfortable!) it can feel like the CoC is playing sides, when really "feeling uncomfortable" is not what it is about -- it's about being _inclusive_.
I found those specific tweets of hers distasteful, but...[shrugs]...whatever. I choose to ignore them and move on with my life. EDIT: Also, to clarify: I have zero opinion on her joining the Rust team; simply hope that she’ll do a good job, because as a community we need that!
&gt; Scala has a nice type system, runs on the JVM so we get all of that sweet sweet Java interop, is functional with a mutable escape hatch, and is a "boring" language that is used extensively. Additionally, the story for writing GUI applications for Java isn't as slick as web technologies. You might enjoy checking out [Scala.js](https://www.scala-js.org/).
Checkout https://github.com/ctjhoa/rust-learning
Not too surprising, I'd say. IIRC it's things that constantly make lots of syscalls that are the most likely to get a performance hit, and I don't think compilers are in that category.
`cargo` doc font size is too small on a large screen. I think `1.25rem` would be nice instead of current `1rem`.
They do, just not the annoying and entitled ones that want to be spoon fed
&gt; what are you actually trying to do? I try to [improve a macro](https://github.com/thibran/ok_tup). One route I'm investigating is to convert a `Option&lt;Vec&lt;_&gt;&gt;` to an option holding a tuple of N elements.
In my case it was for parametrised grammar productions where certain tokens and/or nodes are allowed only in specific contexts (for example, `yield` operator is allowed only inside of generators and so on).
you can zoom in on browsers to automtically adjust it. `1em` is supposed to *define* the basic size of the font.
[removed]
Just voicing my opposition, I prefer the current font size.
[removed]
related: the mdo crate for do-notation in Rust: https://github.com/TeXitoi/rust-mdo
I would be interested to see what would change if I enabled codegen units. But, as you say, compilers (particularly rust) are bottlenecked more by the pure-CPU optimization step than by IO. In any case, it's good to have numerical proof.
Wohoo, my `AsciiExt` contribution was explicitly mentioned in the release notes :) Now I'm boosted quite a bit up in [the ❤️-list](https://thanks.rust-lang.org/rust/all-time). 🎉 
Yes, and I don't think it's all that helpful to continue that discussion. I think that your original point stands; that random sarcastic tweets are not relevant, so then going on to continue the discussion that was not made in good faith about those tweets is kind of defeating your earlier point. 
If you're doing it with a macro, it should be possible just to produce code like `v.get(0).and_then(|_0| v.get(1).map(|_1| (_0, _1))).and_then(|(_0, _1)| v.get(2).map(|_2| (_0, _1, _2)))`, etc. That should work, assuming you want the output to be None if the vector isn't of the right length. Alternatively, something like `if v.len() &gt; 4 { Some((v[0], v[1], v[2], v[3])) } else { None }` might be clearer? The length check will mean all bounds-checks for access are elided.
For "Updates from Rust Core": These are changes which are merged into the current "master" branch of rust. Every night, the changes are built into and included in the nightly rust release channel (hence the name nightly). Every 6 weeks, a snapshot of nightly is taken, and this becomes the "beta" build. The last beta build is additionally promoted to stable. https://github.com/nox/rust-rfcs/blob/master/text/0507-release-channels.md has more info on this. So, to answer your question: features will be available in stable 12 or more weeks after they "land" as shown in a TWIR post. There's one more thing to note: not all features landed will be "in" the beta. Betas are exact snapshots of nightly, but not all features are necessarily enabled: some stay nightly-only, and require `#![feature()]` markings when using nightly. TWIR will usually say if this is the case for a added feature, or if it doesn't the linked PR will.
Meanwhile, HN is filled with the CPU bugs... Did someone posted this on HN?
Minified and gzipped :troll_face:
Even in Cmder?
!redditsilver
True. Tho `print_string` and kin are benign side-effects: I don't know of a way to break referential transparency with those. Granted, using them makes your code impure, if you want to be a purist about your purity. I also grant that one can write referentially opaque functions without much fuss, and mutate states out the wazu in OCaml. However, that kind of thing is generally discouraged and, even though it's not difficult, you do have to be explicit when you mark something as mutable or make use of side-effectual code. E.g., even if you just want to `print_string` in the middle of your function, you either have to assign a variable to the resulting `unit` value or place a semicolon to explicitly designate a stateful sequence. To be clear, however, I definitely come down on your side of the fence in thinking that we shouldn't let purity-purists artificially narrow the extension of "functional programming language". Many of the most exciting upcoming languages, ime, aren't hewing to purity, but rather extending their type systems to express impurity and change elegantly and concisely. I think I was trying to read u/rainbow7564's comment charitably, and under that reading there is ample room for Schemes and MLs (tho maybe not Common Lisp :) ).
[**Here's your Reddit Silver, Furyhunter!**](http://i.imgur.com/x0jw93q.png "Reddit Silver") /u/Furyhunter has received silver 1 time. (given by /u/joshery420) __[info](http://reddit.com/r/RedditSilverRobot)__
Is there a basic guide to using a C dynamic library within a Cargo project that works across Windows/Mac/Linux? I've looked at https://github.com/rust-lang/cargo/issues/4421 which doesn't have a resolution yet.
It’s got a healthy number of comments on HN.
Right after updating rustup and updating stable, I'm treated with the following messages on Windows: warning: tool `rustfmt` is already installed, remove it from `C:\Users\&lt;USER&gt;\.cargo\bin`, then run `rustup update` to have rustup manage this tool. warning: tool `cargo-fmt` is already installed, remove it from `C:\Users\&lt;USER&gt;\.cargo\bin`, then run `rustup update` to have rustup manage this tool. If I remove rustfmt and run `rustup update`, I get newly created hard links for `rustfmt` and `cargo-fmt`, but running either results in (respectively): error: toolchain 'stable-x86_64-pc-windows-msvc' does not have the binary `rustfmt.exe` error: toolchain 'stable-x86_64-pc-windows-msvc' does not have the binary `cargo-fmt.exe` I do not have the `rustfmt-preview` component installed.
So in order to enable both, you'd have to specify one as a dependency of the other? 
You can probably work out what you want to express in [attributes](https://doc.rust-lang.org/reference/attributes.html#conditional-compilation). Here's the [features reference](http://doc.crates.io/manifest.html#the-features-section). Would you mind clarifying what you're trying to achieve?
&gt; for some reason `cargo run` only prints `default`. I have no idea why. Because you didn't tell it to enable any other features. cargo run --features custom-name,something-else,whatever Note that features are *strictly* additive: you can't have mutually exclusive features.
I'm trying to toggle between using C bindings created by bindgen at compile time vs premade bindings. I'm using the feature flag to control whether build.rs creates the bindings and what path is used to import them in main.rs
How can I specify other features in Cargo.toml, list them as dependencies of `default`?
As far as I know, the standard `foo`, `bar`, and `baz` are used in rust, except perhaps for generic types (capitals starting at `T`), and lifetimes (lowercase starting at `a`).
Well, I won't rehash what you can find at https://www.actionherojs.com/. But, to sum, I will say that the nice thing about that framework is that it is designed really well for building an API that send and receives data, adn doesn't pretend to be anything else. It provides a healthy but lean mix of what I typically need. So, while you have routing, localization and pipelining through modules/middleware, it doesn't worry about templating or other "maybe" concerns. Two nice differentiators I really like are built-in sockets and background tasking. I prefer it to many of the more common Node frameworks.
Just list them like any other list of things. default = ["custom-name", "some-other-thing"] 
Neat! What makes it secure? From what I can tell you're using `rand`'s `thread_local` Rng, which is pretty good but I believe will is warned against for "cryptographic aplications". Honestly this doesn't seem like a cryptographic application, but maybe you have more info? Also, this reminds me of [my lib, UuidB64](https://github.com/quodlibetor/uuid-b64) which is (apparently) almost the same as nanoid except that it assumes that the outside world might be particularly good at UUIDs, so has a bunch of conversion methods for that case.
you could ask the same about brendan catching heat when he briefly wore the ceo hat. given his religious views, as ceo he became an instant existential threat, but he was totally cool as cto. he just needed to join the postmodernist bandwagon first, then he'd be forgiven. :)
So you feel like the children of Bill Gates are born with the same advantages as the children of insurgents in Afghanistan? Both of them are equally likely to grow up and be able to contribute to rust, if they so desire? edit: oh you're point isn't that the have the same advantages, it's that the way that people fight for equal advantage is wrong. Okay.
I kind of hoped that the ascii thing was treating `[u8]` like a string with similar nice functionality as `String` for character processing I guess like splitting on whitespace and what-not. It's kind of annoying I guess how Rust really wants you to use utf8 while often the outside world can't guarantee that everything is utf8 like processing command like arguments which in theory can contain arbitrary characters to point to arbitrary filenames. Like parsing `--input=path/to/file` and what-not is a lot more convenient on a `str` than on a `[u8]`
"Kill all men lol" https://twitter.com/hashtag/KillAllMen supporters: "haha lol, naww they're just joking, it's a joke haha. SO FUNNY!" ----- Hitler: "Kill all jews" supporters: "haha lol, he's just joking, it's a joke haha, he doesn't really think that"
&gt; Some seemed to feel that their free speech had been impinged i don't know... i think people felt like they were being told to shut up and either sit down or go away. it's fine. 'the powers that be' do as they please, as such is the nature of power. there are other communities that are more open if people want that. :)
Ah, that is a fair point. The reason I provided a bit of opinion on a few of the tweets was to not leave the linked reddit post without any context or alternative points of view. It is probably up for debate whether that was actually helpful though.
To be clear, they were told to discuss things "elsewhere" -- which is why I created this thread.