It depends on what the identifier is used for. Functions and methods aren't capitalized, type names are CamelCase, and statics and constants are full caps. However, GET is all caps because [HTTP verbs/methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) are capitalized. Any kind of REST API is going to be defined in terms of these verbs, so it's helpful to be able to easily identify them.
**Hypertext Transfer Protocol: Request methods** HTTP defines methods (sometimes referred to as verbs) to indicate the desired action to be performed on the identified resource. What this resource represents, whether pre-existing data or data that is generated dynamically, depends on the implementation of the server. Often, the resource corresponds to a file or the output of an executable residing on the server. The HTTP/1. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
At least that's opt in pain :)
Yes, pretty much. They are called [intrusion detection system](https://en.wikipedia.org/wiki/Intrusion_detection_system).
I envisioned the tool mainly for testing purposes like services boundaries. The main advantage I see would be mock versioning.
Totally an attempt to solve the same problem. `cargo-script` does it by creating a hidden Cargo bin project, and reads the dependencies from a Cargo manifest embedded in comments. `runner` has a shared cargo cache which means that new 'scripts' don't have the overhead of building a new Cargo project with re-compiled dependencies. It then gives you tools to manage that shared cache.
Exactly. `nom` is a 'light-weight' dependency, compared to say `regex` which significantly increases binary size and is slower to build. 
Not yet, but geal told me about it. I need to give it a try!
Working on a small platformer game with Piston, although I'm not yet familiar enough with Rust to make anything nice.
It can do a bit more: you can download and enable rules not only for malware, but for potential „policy violations“ (eg. uploading data to public clouds, using google nameservers). Basically, you choose (by writing or downloading) what to detect. Furthermore, there's a mode (not enabled by default) where it can actually filter that traffic.
That depends who is doing the counting. From crates.io's viewpoint, it is in a crate, thus it must exist. From rustc's view, it's not on the path, so it doesn't exist. From the crate's programmer's point of view, it was written, thus it exists. For other Rustaceans, if they know of the crate, even if they don't use it, it exists. Otherwise it might as well not, so tell us about your crate already!
Not creator but here you go :) http://i.imgur.com/S581TWq.png
Thanks to the docs team and the contributors for keeping up the work.
Have you considered making it more integratable with `#[test]` for easy setup and teardown? As-is, it feels like it might be simpler to mock lower in the stack for integration testing and rely on the façade from the actual codebase.
Thanks for your response! That sounds pretty cool. If I ever have the time to rebuild my home network (I've been looking into pfsense) I'll use something like this. (This sort of software is probably intended for businesses but some extra security can never hurt) I really like /r/rust. It's so nice that you can post a question here and you get a friendly and helpful answer. 😊
I think you're being slightly confused by rand, it's a slightly contrieved example. Let me just say: `use rand::Rng;` and `rand::thread_rng()` are _completely unrelated_. Neither of these statements is required for the other, and they do not affect eachother. `use rand::Rng;` is using a trait which allows you to do `.gen_range()` on the result - but it _has nothing to do with calling `rand::thread_rng()`_. This may be helpful to you, or might not: https://manishearth.github.io/blog/2017/05/14/mentally-modelling-modules/. I'd suggest checking it out in any case.
Basically, there can be an arbitrary amount of mutable references to a thing at the same time, as long as only _one_ of them is actually usable at the same time. Re-borrowing is fine in that regard because it prevents any use of the borrowed value in the meantime. Eg, this is perfectly fine: fn main() { let mut x = 6; { let a = &amp;mut x; let b = &amp;mut *a; let c = &amp;mut *b; let d = &amp;mut *c; let e = &amp;mut *d; let f = &amp;mut *e; let g = &amp;mut *f; *g = 10; } println!("{}", x); } (https://play.rust-lang.org/?gist=385aaff85e926966e7ef0a69425f76b5&amp;version=stable)
This is a good idea! I meant testing in the case of heterogeneous systems in a service architecture, not Rust only code.
&gt; […] reviews say that it is a programming language that runs crazy fast, that prevents segfaults, and that guarantees thread safety. Yes, [reviews](https://www.rust-lang.org/en-US/)! Very professional article.
Well, they could have mentioned that a new release appears every six weeks like clockwork. Otherwise I found the article light in actual information, but quite positive.
I'll do my TWiR and a bit of clippy stuff. Otherwise I'm mentoring some people who asked on twitter.
I suspected that might be the case from looking at the README. That said, I don't really see the niche this is aiming for. If I'm testing for a heterogeneous environment anyway, I'll generally rely on the more mature Python-ecosystem equivalents to your creation to do my API mocking. (Partly because their integration story is more mature and, in situations where they fall short, Python's got excellent metaprogramming support I can use to hack something up.)
I have finally completed the last big missing piece of [easyfibers](https://github.com/SergejJurecko/easyfibers): running multiple independent services with their own parameters. Since I use generics, before you could only instantiate a single Poller and it fixed you to the param and result types. Now the polling mechanism is general and there is a new type Runner of which there can be multiple instances with different param and result types. 
I just want to remark what a wonderful advertisement it is for Rust that this game, developed on and for Windows, can be run on Mac by simply downloading the source and executing `cargo run`. I couldn't imagine doing this with (most) other programming languages.
 println!("Enter your name: "); let mut person = String::new(); std::io::stdin().read_line(&amp;mut person).unwrap(); let person = person.trim(); if person.chars().all(|x| x.is_alphabetic()) { println!("Hello {}", person); } else { break; } The conditional can also be written as `if person.is_ascii_alphabetic() {`, but it is only usable in nightly as of now.
&gt; if person.chars().all(|x| x.is_alphabetic()) This will actually break a bit because `\n` isn't alphabetic. You need to `trim()` it first to get rid of the extra whitespace.
Realtime mmo/simulation with rust as FFI glue and on critical components like voice and audio streaming, distributed physics and high performance asynchronous pub/sub. Using tokio/futures for most IO, for servers and clients. Client works on mobile and desktop, embedded in Unreal Engine as plugin with FFI.
So, short answer: [here's a gist of an equivalent function to Python's `input`](https://gist.github.com/25354a1d834534f8772fc8b72e3d25c1). I've copied it below so you can follow along with my explanation. use std::io::{self, BufRead, BufReader}; fn input(prompt: &amp;str) -&gt; io::Result&lt;String&gt; { print!("{}", prompt); BufReader::new(io::stdin()) .lines() .next() .ok_or(io::Error::new(io::ErrorKind::Other, "Cannot read stdin")) .and_then(|inner| inner) } fn main() { println!("You typed {}", input("Hello!").expect("Failed")); } Long answer: So in case it wasn't obvious from my Rust equivalent, that Python code isn't as simple as it may seem. * Python hides a lot of complexity from you by using, for example, exceptions to propagate errors. The Rust code returns an `io::Result`, Rust's way of handling errors which is more explicit than exceptions. * Since Rust's default stdin is unbuffered (the `print!` and `println!` macros implicitly buffer, I believe) there's no easy way to get a single line without first wrapping it in a `BufReader`. The `lines` method returns an iterator of `io::Result&lt;String&gt;`, because each line could fail for some reason independently of one another. For example, you could pass invalid unicode, a newline, followed by valid unicode. In this case you would want the first line to return `Err("Unicode error!")` and the second to return `Ok("This is a line of input")`. * We then call `.next()`, which returns an `Option`, either `Some` if there's something to read or `None` if we've reached the end of stdin. * We then do `ok_or` to convert the `None` into an `Err`. * Since now we have an `io::Result&lt;io::Result&lt;String&gt;&gt;`, instead of an `io::Result&lt;String&gt;` (what we want), we call `.and_then(|inner| inner)`, which just folds the errors together (so `Ok(Err(something_bad))` will become `Err(something_bad)` and `Ok(Ok(something_good))` will become `Ok(something_good)`). * In the main function we just call `expect`, which turns an error into a "panic", which ends the program with an error message (similarly to uncaught exceptions in Python). It's important to note that Python does all of this, but it hides it from you. Rust is more explicit, because explicitness is important for avoiding mistakes. Neither is the correct way to do things, they're just different tradeoffs made for different languages with different goals. I hope this helps with your question.
Thanks for the tip! Edited.
&gt;if person.trim().chars().all(|x| x.is_alphabetic()) This worked for me! Thanks! I was wondering what exactly does the .chars().all() do? I assuming .chars() splits the string into individual characters and .all() iterates through them with a filter?
Git's sparse checkout still obtains a copy of every single blob. Its a limitation that hopefully will go away one day.
`chars` is an iterator over unicode codepoints, not necessarily characters. Definitely not the same as Python 2.7's string type, which is ascii. Each character has to be decoded individually, which is why `chars` is an iterator. `all` is like Python's `all([x.is_alphabetic() for x in some_iterator])` but it takes a function to call on each instead of taking an iterator of booleans like the Python version (which is why I have to use a list comprehension for the Python equivalent).
As it stands, there are many outstanding PRs with [design questions](https://github.com/rust-lang-nursery/rand/pull/27) or even [quite minor modifications](https://github.com/rust-lang-nursery/rand/pull/115) which have gone unmerged for months/years. I'd say there effectively is no maintainer. This PR is not supposed to be merged as-is, but to provide inspiration for the redesign discussion (see internals thread). However, to respect people's time, each commit has only a small change with a short description.
Thanks for the reply, this is all very interesting. I've been having a play with this. I noticed the the program will ask for an input before the prompt is displayed, but if you println! beneath print!("{}", prompt), both the prompt and println are displayed before the program asks for an input. What's causing this? 
Although `nom` does have regex combinators, but those are optional.
Trying to add skip list in tantivy. This is especially important for phrase queries, but it might also be handy to intersect posting lists with very different cardinality.
[removed]
Trying out [pest v1 alpha](https://github.com/pest-parser/pest/pull/88) and might get started on [built-in cargo outdated](https://github.com/rust-lang/cargo/issues/4309) if I get some time but that's unlikely. Also the next version of Tera will be a big one so if you have feature requests: https://github.com/Keats/tera/issues/206
I'm working on my compact storage and data interchange format with back- and forth-compatible schemas and code generation. P.S. Generating idiomatic Rust code is hard :).
It's probably the same problem you can encounter when using `sys.stdout.write()` in Python... Output is buffered to improve performance and writing a newline implicitly triggers a flushing of the buffer. The Python solution is to call `sys.stdout.flush()` afterward and I suspect you need to do something similar in Rust. See if it helps to add`Write` to the list of things `use` pulls in and then add this line after the `print!`: let _ = std::io::stdout().flush();
This blog post explains the "not necessarily characters" quite well and why Rust didn't consider safe O(1) string indexing to be valuable enough to support: https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/ If you actually want to iterate what we intuitively think of as "characters", the [unicode-segmentation](https://github.com/unicode-rs/unicode-segmentation/) crate provides a `graphemes()`iterator.
I managed to successfully execute my Rust binary in a web worker (yay!) and I trained a Neural Network model (Iris Dataset) in my web browser (this is awesome, isn't it?) This is the Github repo: https://github.com/afshinm/juggernaut-iris and this is the screencast: https://www.youtube.com/watch?v=cIHAIshmI8U I managed to render the loss chart and what I want to do this week is rendering the boundaries on the dataset graph. What I'm planning to do is developing a demo page for Juggernaut (http://juggernaut.rs/), something like Tensorflow's demo page but with this different that you are actually writing Rust and executing it on a web browser!
To clarify what stumpychubbins said about `chars`, there's no clear and obvious way to iterate over a string. Did you want to go byte-by-byte, codepoint-by-codepoint, grapheme-by-grapheme? Rust strings don't implement `Iterator` or `IntoIterator` directly because of that ambiguity. Instead, you have to call a method to explicitly request the type of iterator you want. See also my reply to stumpychubbins's response.
[removed]
Standard C++?
It was published 2017-07-28 but claims "the newest version 1.10 was released in December 2016" — giving the "article" that label is already generous.
well done! I'm following the development process of your game; it is really interesting to be able to develop a game in Rust. Can't wait to try that game!
As much as I love C++, it's not nearly as easy. There are package managers but nothing standardized like `cargo`.
I hope to have something more or less playable by the middle of september. Though I have a long-standing tradition of failing all the milestones :-D
For me it compiles and runs fine on Ubuntu 14.04. I have the following logged into the terminal but it does not stop the game from working correctly: &gt; [wayland-client] Found library libwayland-client.so cannot be used: symbol wl_display_get_protocol_error is missing.thread
Ah! This was the "internal buffering" I was talking about - good catch. There's actually an [open issue](https://github.com/rust-lang/rust/issues/23818) about this. I was just testing on the playground (which doesn't accept input from stdin, so it crashes on that `expect` call and the buffer gets flushed). The right way to do this is to put `io::stdout().flush()?;` directly after the call to `print!`. The `?` at the end is for error propagation (returns instantly on `Err`, similar to how Python's exceptions work), so it can only be used if the function that it's being used in returns a `Result` with a compatible `Err` type (which this one does). To use `flush` you need to import `std::io::Write`, just add it between the `self` and `BufRead` imports like this: `use std::io::{self, Write, BufRead, BufReader};`. So, the full function would look like: use std::io::{self, Write, BufRead, BufReader}; fn input(prompt: &amp;str) -&gt; io::Result&lt;String&gt; { print!("{}", prompt); io::stdout().flush()?; BufReader::new(io::stdin()) .lines() .next() .ok_or(io::Error::new(io::ErrorKind::Other, "Cannot read stdin")) .and_then(|inner| inner) } fn main() { println!("You typed {}", input("Hello!").expect("Failed")); }
True, but it your download from git usually all your dependencies are there. No doubt that Rust rocks though.
What's the latest and **least verbose** way to * Read from stdin until '\n' (or line break) is detected and storing into a string? For example: string input = readln(); * Read until EOF is reached and storing it into a string? For example: string result; foreach(string line; lines(stdin)) result ~= line; 
&gt; and become too reliant on it. C, I think. I feel that most rustceans share the opinion that macro system helps improving language by allowing people to write macros which can later become another syntactic sugar. The popular case is `?` operator, which evolved from `try!` macro. Macro system can help language to take off. There are many things that aren't implemented in the language (yet) and macros help the language to be used. Without them, the language would seem lacking important features.
If we just thinking about Rust not having `macro_rules!`, I think two things would become immediately more annoying: 1. Writing out impls for many types where each impl is effectively boiler plate. 2. Writing unit tests. For (1), I'd say *some* chunk of that is for tuples/arrays, which presumably could be fixed with integer generics. But there's also some amount of it for, say, integer types. For (2), I tend to make liberal use of macros in writing tests because you often want to run the same type of test on multiple input values, and macros can help you do this declaratively. Other than `macro_rules!`, the `derive` functionality is also incredibly useful and can often save a lot of annoying boiler plate. Particularly for `Debug` and `Clone` where the automatic derivation *almost* always does what you want. I do wonder what the world would be like without Rust's macro system. I suspect there would be more code generation hacks in the ecosystem. (I generally very much dislike exporting macros as part of a crate's public API, but there are some notable crates that make good use of them such as `nom`, which also wouldn't be able to exist without macros. I wonder if the community would have instead coalesced more on a parser tool that tried to fit into Rust's type system as a result. I don't know what the trade offs there are!)
Tried to test it, but it crashes when I hit the Mod4 key, which I use to resize the window in Linux (It's unwrapping a None value @ `main.rs:240: [...] input_event.virtual_keycode.unwrap();`.)
Lots of criticisms of Firefox there. I just honestly don't get why people think Firefox is a bad browser. If raw page render speed is all you care about, I can see the argument for Chrome, but I really think Firefox is the better browser overall. And also the focus on the CoC is just weird. 99% percent of discussion in /r/rust is about coding, the language, or documentation, but reading those Slashdot comments, you'd think we do nothing but talk about the CoC. The CoC rarely comes up!
Well, `macro_rules!` is *definitely* under-baked. It's also been used more times than I've bothered to count as a justification for *not* implementing a language feature (*i.e.* "you can do it with a macro"), whilst at the same time not getting anywhere near the love it needs (no, we *still* can't produce identifiers, we *still* can't factor out macros, *etc.*, *etc.*). But, it's a two-way street. The macro system showed that we needed `try!` as part of the language, and how it should look. It showed that we *really* needed custom derivation. It lets us patch over the holes in the language that there just isn't manpower and consensus to fix yet. Is Rust too reliant on macros? Probably. Would it be a qualitatively worse language to use without them? Probably. Coulda, woulda, shoulda aside, and practicality taken into consideration, I think Rust is a better language for having macros. Doesn't mean Rust should continue to take it for granted or get in the habit of leaning on it, and doesn't mean it should be reviled. Besides, Swift allows emoji in identifiers, so clearly they're in no position to be dictating good design principles to *anyone*...
I agree, these things are incredibly useful. And I doubt I could have convinced my collegeaus to use Rust, if it would not provide the level of convinience it does now.However I think it is a fair assessment to say, that we will see features like Higher Kind Types, later or maybe never, because the macro system removes a lot of the pain of not having them. Yet overall I'd rather have a usable version of Rust now, then a perfect one in several years.
I use firefox developer edition is my primary browser, and it's pretty damn snappy and nice. Great for tab overload as well. It's really gonna look exciting once more of Servo's stuff starts to make it in.
Rust has O(1) indexing at the code-unit level via the `as_bytes` method, just like most other languages, including javascript, java or C# (python3.3 being an exception).
I think I finally have a proof of concept for thermodynamic temperature and temperature interface in [`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis), but mostly summer activities!
When people think of "string indexing" they generally expect indexing no lower-level than codepoints. (ie. "string indexing" has meaning beyond that granted by its component words) Also, I qualified it with "safe" while using `as_bytes` is the Unicode equivalent to an `unsafe` block. That said, I'll admit the phrasing mistake in my initial post. My point stands with that correction.
[removed]
 use std::io; use std::io::{Read}; // Read one line let input = String::new(); io::stdin().read_line(&amp;mut input)?; // Read to end let input = String::new(); io::stdin().read_to_end(&amp;mut input)?; The latter method is part of the `Read` trait and works on any reader, not just `stdin()`. 
[removed]
Fun project, thanks for sharing! Really great to see that the code for this is so simple that you were able to jam it into a single `main.rs` without it being too difficult to follow. Projects like these show how Rust allows us to write simple, conceptually-clean code using a nice ecosystem of libraries already. Pretty great for a low-level "systems" programming language!
&gt; (..) not getting anywhere near the love it needs For reals. Even [my very simple feature request](https://github.com/rust-lang/rfcs/pull/1517) (`#[macro_use(not(...))]` to help with macro name collisions) was denied based on the fact that the current macro system is going away "soon". Yet here we are, more than a year later, without a suitable replacement anywhere on the horizon.
Without macros, `format!` could only generate run-time errors on bad syntax, I think? That would be a huge step backwards.
It could, but the rust community doesn't consider it a priority. Many believe that the transport security provided by TLS is sufficient, ignoring both the many instances where github was insecure and the rust developers that are stuck behind badly implemented corporate and governmental TLS MITM proxies. As for Rust binaries, they used to keep the keys that generate the signatures for rust-lang.org downloads on build servers. I don't know if they changed this yet. The current suggested workaround for all this is to download what you need from different locations, or to use distro-provided rust binaries and download and audit all the code you use yourself. I hope our community will start to address both cargo's and crate.io's various security shortcomings soon. 
haha whoops! Yeah i wanted to put in an end screen to prevent further building. I might try to patch it so you can't crash it at elast.
Ah cheers. I'm not using any key bindings, so ill probably just remove that code. I ported it over from my other game, wasnt sure if id needed it or not going in.
I wrote it on my mac, so you should be able to compile &amp; run it locally with cargo. I just can't seem to ship an executable, something wrong with finding the resources (error doesnt tell me what path its looking for)
&gt; anywhere on the horizon. There has been some movement; [an RFC was accepted](https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md).
I did develop it on mac :), but I often code Rust on my gaming PC at home when i don't feel like opening my laptop. While working with some of the editor keybindings in windows feels weird, overall it's been a pretty smooth development environment.
No, since its essential, it would be a language or compiler feature.
Some days, I'm thankful that the core Rust devs are conservative with new features. I've seen what happens to languages that grow as fast as they can. It ain't pretty. I think it's a good thing to have a language focused on taking things slow and steady. And then, other days, I just want to scream and ask the heavens why we *still* can't generate identifiers, we could do it *right now*, but *noooo*, let's just keep rejecting improvements that would mean I could stop tearing my hair out *I'm going bald are you happy now?!* Deep breath, [take it easy](https://youtu.be/LfeNhwnO8hw#t=30).
`format!` is effectively a compiler intrinsic anyway, so the fact that it's surfaced via macros is... kinda irrelevant.
Agree, I'm looking forward to that too. Facebooker's can't wait, of course. Meanwhile, I tried to repeat some of the Google gcheckout.sh fu with https://paulhammant.com/2017/02/08/further-experiments-with-expanding-contracting-monorepos/ - a Git repo in a Monorepo style, that can be expanded contracted (working copy) and still have a cohesive (recursive) build from root, or not from root.
[removed]
&gt; ? What does that imply?
Please don't! If you're not used to lifetimes, it's tough to get down where you need them at first. :) Just keep going and asking questions like you're doing, and hopefully it'll become muscle memory!
Congrats on the game! Runs fine on my Debian 9 laptop. :-)
I continued to work on my [asciidoctor crate](https://github.com/antoyo/asciidoctor-rs): I added the support for a bunch of other tags. I'm in the process to publish the webkit2gtk crate to crates.io.
&gt; missing macros part? or is there a version in-progress? We haven't gotten to the macros appendix yet.
Sorry, but... what the heck is a monorepo? Edit: Oh, let me google that for myself: https://developer.atlassian.com/blog/2015/10/monorepos-in-git/
Nice job! I also wrote a game in rust call [Ash Dash](https://ldjam.com/events/ludum-dare/39/ash-dash)! It was a command line game using a terrible binding to the winapi that I wrote... Best of luck to your game!
[removed]
That's awesome about the MSP430. I happen to have one lying around from my class last semester. I'll have to see if it's easier to deal with rust on there than C/asm :)
[It propagates errors](https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-).
The only reason `Column::Alias` references a `Column` is because the type is recursive. Otherwise I would probably never take a reference to it.
This is really impressive for something done in such a short time!
[removed]
Nightly is great! Always faster than Chrom(e/ium) for me. 
In cargo what is the difference between a project and package? I haven't been able to find a clear definition of both in the documentation. Is a project just the "main" package plus all of its dependencies? 
&gt; better than a signature uhh. Signatures are usually used *on the hash* and they have a different purpose. Keeping hashes of all dependencies makes sure you get the *exact same* code when you download the project in another place. Signatures make sure *the same author* uploads updates of a crate to the registry, and this is important. [One of the passwords with access to publish koa was literally «`password`»](https://github.com/ChALkeR/notes/blob/master/Gathering-weak-npm-credentials.md) Without signatures, all you need to compromise many dev machines is to guess a crate author's password, which lets you upload a version of the crate and it will be downloaded by everyone who updates deps of a project that depends on that crate. With signatures, you'd also need to sign the new version with the author's key. Which not as trivial as guessing a password — the actual key will typically be stored on the author's machine locally. (Though of course some people *will* publish their private keys and some of these *will* be encrypted with the password "`password`"… but one could hope developers wouldn't be *that* careless with keys :D)
[removed]
[removed]
I'm inclined to agree. While I want to be using Rust "NOW AND EVERYWHERE" I'd much rather be using the "The Best possible version of Rust from some arbitrary start date until they invent hovering sliced bread." Not only do language features need to be carefully accepted, but implementation matters a lot. I wouldn't want the compiler to become an untenable mess while it's still the one and only reference implementation.
I think if you want to bait people to switch over from C/C++ you do need a macro system or some other replacement. I'm saying that as someone who came from C/C++ and who used C macros. Rust's macro system does have issues. Some of them maybe stem from the fact that there was a rush to 1.0 and the macro system didn't get as much love as it should have. So in that sense macros were stabilized maybe earlier than they should have. But I certainly prefer a stable language with a not completely perfect macro system to a language that doesn't reach stable for years because of microoptimizations. Rust's macros are definitely shippable, and they are certainly many orders of magnitude better than what C has to offer, or even than C++ templates. I'm using Rust macros very often, to prevent repetition and to make code easier to read on the eyes. Sometimes stuff can't be expressed with functions yet without upsetting the borrow checker. Then I choose macros. I quite like Rust macros, even though of course I'd love to see some of its issues (them not being able to be imported for example, or various hygiene issues) fixed.
There is nothing politically at stake in Rust, and as yet, very little prestige. It's not like Wikipedia, or some big artistic project, or an interest community. There I might be worried about the CoC, because I think it's wide open for abuse. But it's not a problem now, in practice.
It's also now officially supported by JetBrains.
I feel like that comment is the real news! Better type inference is good, sure, but official JetBrains support is another major industry player adding credibility to Rust.
Well, for the record, nobody said "soon" there. On the other hand, I agree more than a year is long enough time that rejecting the proposal seems questionable now.
I reach for macro_rules! a lot, Like I know there's probably a smarter solution but I am not always in position to do that.
The main difference is how the language presents it. Java, C# and javascript all use string indexing at the UTF-16 code-unit level, not at the code-point level. The main differences to Rust are that they don't enforce correctly paired surrogates and don't educate the user that a char is a code-unit not a code-point. Python 3.3 seems to be one of the few exceptions, that actually offer indexing at the code-point level.
&gt;For (1), I'd say some chunk of that is for tuples/arrays, which presumably could be fixed with integer generics. But there's also some amount of it for, say, integer types I suspect not having macros would probably have resulted in the number traits not being removed from the standard library. Otherwise, implementing stuff for integer types would have created a huge amount of boilerplate.
This looks really nice. Thanks. This project got me wondering how hard it would be to create something similar for Windows. From what I can tell, doing so would involve working with the [systray-rs](https://github.com/qdot/systray-rs) crate. Does that sound about right to you? (I see you've created a [fork](https://github.com/mrmekon/systray-rs) of the systray-rs crate, so I'm guessing you've got some good insights into using it.)
Point... though, in those cases, it was originally intended to be at the code-point level and they don't enforce paired surrogates because: 1. Java, JavaScript, and the Win32 API were written for UCS-2 and retrofitted when Unicode outgrew 16 bits. 2. Retrofitting a requirement that surrogates be correctly paired could break existing applications or data. 3. C# was designed to match the Win32 APIs it was intended to be used with. Either way, my point stands that indexing UTF-8 code units is too different from what people expect "string indexing" to do, even if that expectation is also flawed to a lesser extent in other languages. &gt; Python 3.3 seems to be one of the few exceptions, that actually offer indexing at the code-point level. Someone mentioned in a previous /r/rust/ comment that Perl 6 goes even further and does [grapheme indexing in the core `Str` type](https://perl6advent.wordpress.com/2015/12/07/day-7-unicode-perl-6-and-you/).
Sorry for the incoming stream of consciousness. First off: I'm known for hating macros. Like, throw them in the deepest parts of Mount Doom. In my opinion, they point directly to flaws within the language you are using. I would even prefer code generation. That's one of the reasons I love Ruby: The language environment itself is very programmable, to the point where you can imitate other languages by just using Ruby. People think Ruby is complex, but at its core, it's very simple language (ask me over a beverage, I'll explain). There have been a lot of calls to introduce macros into Ruby and I'm happy they were never answered (and people found ways to do things better). But Ruby has another ugly thing: DSLs over well structured libraries. In Rust, this place is taken by libraries that mostly exist as huge macros that generate _some_ code with no good way to interact or manipulate it. So, I hate most Rust macros specifically for that. But here's the thing: I also hate ceremonial coding. Rust would be a much more painful language without some of the macro magic behind `println!()` or `try!()`. `nom` wouldn't have been possible without them. There's a lot of missing things in Rust than can be circumvented by doing the right 3 steps, schematically. And Rust isn't Ruby, it's extremely static, so our only option is to spell that out, _each time_. `ok, err := ....` If we would bless every of the cases where we currently use macros with a language feature, we still weren't done. I don't think Rust has grown macro features too soon, it was already quite obvious that many cases where they are used wouldn't/couldn't be fixed soon. Without them, people would have left the language left and right :). Yes, they are mediocre, but also: they were necessary for the success of the language. 
I'd rather have a perfect one in several years. I picked up Java in 1996. I would but much happier today if it had come out in 2001 without the mistakes. I picked up Rust this year; i hope to be still using it in 2038, and i hope i'm not cursing the decisions we're making now. 
[removed]
Your example about boilerplate impls sounds like the sort of thing Chris Lattner is talking about. If we hadn't been able to use macros to work around the boilerplate, it would have remained a problem which demanded a solution, and eventually would have got one at the language, library, or technique level.
[removed]
The CoC conversations always boil down to the same few things. Someone wants to be an asshole and CoC's "infringe on their free speech", or they have some "weird, bad feeling it will be abused in the future" and it never gets any less vague than that.
Amazing news!
Thanks! It takes a lot of focus to power through and get something done :).
I pushed a new commit to master to wrap that virtual keycode. I can't seem to reproduce on my mac at least. Let me know if it still crashes or not.
I was using PyCharm with Rust for a while as I learned Rust. But I switched to VS Code with the RLS. Does JetBrains IDE support data from RLS? 
I'm _extremely_ disappointed with most of the responses here. Those "trolls" and "haters", as you call them, are people we have to eventually sway if Rust is ever to be successful in replacing unsafe languages like C for low-level applications. Yes, there is a huge cultural gap between them and the current Rust community, but this mostly speaks to how insular and defensive the latter tends to be. It's not pleasant to look outside of your bubble.
&gt; uhh. Signatures are usually used on the hash and they have a different purpose. Attention: rant against signatures ahead. May contain traces of unpopular personal opinion. :) My main issue with signatures is that they are and were treated as some kind of magic bullet. E.g. signed drivers. Why should you trust the driver any more if its signed? Microsoft just hands out signing keys and hopes nothing goes wrong. They don't even do an audit on the code or anything. If some security researcher detects some abuse, microsoft revokes the signing cert; but how long until abuse is detected? The other issue with signatures is that only you, or only a small minority, e.g. government dissidents, might get a specially crafted version of a package. Its still signed with the official signing key because the owner of the key got either hacked or compelled to turn over the key. But you have no idea whether it has been tampered with or not! And the public will never know of the compromise because only you get the tampered version. Often software downloads in the free software world are secured by an https page saying "trust this GPG key with this fingerprint, and then you know the software downloaded via http is authentic". This is totally vulnerable to such an attack! If you instead said "this is the sha256-hash of the binary, please verify" on the https page, its far more secure. Also, all relevant signature schemes in use today are not quantum proof, while even for hash algorithms like md5 there is still no performant second preimage attack; the only attacks that exist are collision attacks. Not saying that you should use them, but they are really robust even years after they have been deemed not okay for usage. I mean thanks to this signing silver bullet myth the https/TLS system is virtually broken because most CAs from the root zone can issue certificates without any verification, and give it to clients without anyone ever knowing CA issued such bogus certificates. Again, google has been the only company that actually did something (certificate transparency). Further advantages of hashes: * Computing hashes is significantly faster than verifying or generating signatures * There is no secret involved, nothing you need to keep secure or can lose either through human mistake, or through side channel attacks (think of cache bleed) TLDR: avoid using signatures wherever you can use hashes instead. AKA, hashes are better than signatures, what I've originally said. And yes, some applications of signatures can't be achieved by hashes. Surely, use signatures in such cases! But that doesn't mean that a model where your cargo.lock only contains version numbers and public keys and no hashes and your security builds on verifying signatures is okay. Because this is very similar to what npm is having (afaik): if you deploy a node app, you never know which version of your stuff ends up in production because it downloads the latest stuff. There is no Cargo.lock equivalent, at least not without third party tools. Signing npm packages without a Cargo.lock mechanism would stay similarly broken. &gt; Signatures make sure the same author uploads updates of a crate to the registry, and this is important. I don't think its *this* important. I mean most crate authors are random strangers on the internet, while you usually (need to) have great trust in the operation of the package repo. Especially: * Usually, TOFU is used, which means that on first use, you trust whatever key the repo gives you, no matter whether its controlled by the repo (while claiming to be from the author), a malicious third party, or by the actual author. * Even if the repo requires something like keybase, how do you know whether an author is trustworthy? And what use is it to you if you end up without users like sandstorm.io because publishing packages needs so much effort? You also often times don't actually need cryptographic proof that some crate was authored by key X. The actually important part is ensuring the user is actually authenticated towards the application store. For fixing this you don't automatically need signing keys, but can use whatever secure authentication method exists, like second factor auth (or signing keys). This makes the story much easier and nicer for crate authors, as they can enroll new authentication methods much faster, while getting a userbase to accept a new key is harder. IMO the best thing to do here is to *allow* signing of apps, but not require it, because if you require it: * some people will do things that have worse security than what they'd achieve if with 2fa * some people will lose signing keys and its not like in android where you can just use a different domain name, in Rust crate names are kept short and to the point. You don't want to be forced to use a less nice name, because its directly exposed to the user. This will happen, and its bad. Instead, give the option to sign packages to the authors, so people who know the dangers of keys can deal with them and if its integrated with cargo even better. &gt; Though of course some people will publish their private keys and some of these will be encrypted with the password "password"… but one could hope developers wouldn't be that careless with keys :D :)
itt: people who are somehow *still* surprised that people *outside* this community are bothered by the code of conduct and the focus on social justice within Rust--in spite of the fact that a small number of brave/stupid/stubborn souls *within* the community continually warn about how Rust is seen outside the bubble...
Nice!
Great news! Even since some previous version I get much better auto-completion from Idea than Code.
You are looking r/playrust.
What do you mean
This project is for the touch bar, the dynamic touchscreen that replaced the F-keys on new Macbook keyboards. Doing the same for Windows would be tricky, since it doesn't have a touch bar :) You probably mean the "menu bar", or systray in Windows terms. For that, systray-rs is the way to go. I forked it for a cross-platform Windows/OS X systray app (https://github.com/mrmekon/connectr). I needed some slight modifications to make it compatible with the OS X API, which I wrote first. I plan to split that out of Connectr into it's own library, but it's a shame that it's depending on a fork of systray-rs. 
**Reminder: Let's stay constructive here.** Yes many comments on slashdot are not kind to Mozilla, or Rust. This does not, however, mean that we should condone such attitude on r/rust. Please remain civil.
I personally think that analysis is too simplistic. Just because there's a demand for a solution doesn't mean it happens quickly, and if it doesn't happen quickly, then people might not want to use the language. I don't know how you "solve" the unit test boiler plate. `macro_rules!` is pretty good at it. I have few complaints.
This is /r/titlegore :D i was really happy to hear about a new version of it ... but this comment is my todays mindblow :P
As a sanity check: is there a list of languages officially supported by JetBrains (just to check if it's 1 of 10 or 1 of 1,000).
It would be so nice to have a quasi-quoting to simplify/replace macros... There are a few out there, but still hacky. I'd much rather have something with as little boilerplate as possible. **EDIT** Looks like the declarative macros RFC is pretty close to what I want. 
I don't think that's a reasonable interpretation; how do you convince people that actively look down upon Rust, as if its very existence is an affront to their great skills of C programming? Look at these comments that have been "upvoted" moderately to highly. Tell me that these are comments looking to engender conversation and discussion. https://developers.slashdot.org/comments.pl?sid=10924699&amp;cid=54904579 https://developers.slashdot.org/comments.pl?sid=10924699&amp;cid=54905033 https://developers.slashdot.org/comments.pl?sid=10924699&amp;cid=54905361 https://developers.slashdot.org/comments.pl?sid=10924699&amp;cid=54904329 https://developers.slashdot.org/comments.pl?sid=10924699&amp;cid=54904489 https://developers.slashdot.org/comments.pl?sid=10924699&amp;cid=54904551 https://developers.slashdot.org/comments.pl?sid=10924699&amp;cid=54904811
But the Code of conduct really has not caused any real contention within the community? I've seen maybe one thread discussing it on this subreddit in roughly a year. 99% of discussions are about the language, on implementing cool things in Rust, and how we can improve the language. 
~~most likely not~~ No. JetBrain IDE's have their own special way of handling things which helps to facilitate their special features. 
r/rust is for the Rust programming language. r/playrust is for the Rust game. It seems to me you are playing the game, not using the programming language, and therefore you are using the wrong channel to seek help. Do tell if by "play rust" you meant using the language though!
The one on Wikipedia seems to include both the official list from their site and the ones they have plugins for: https://en.wikipedia.org/wiki/IntelliJ_IDEA#Supported_languages
Agreed.
I've been using IntelliJ with the Rust plugin for a while now. Truly love it
You just *entirely* missed the point. Entirely. Completely. Totally. The community experiences MASSIVE selection/survivorship bias. The COC has caused HUGE contention--by eliminating a HUGE swath of potential community members who opt out because they perceive the political and social agenda of the community as being inherently bigoted, racist, and toxic.
No, they don't.
what does that mean? will debugging be supported in IntelliJ too, opposed to being only available in CLion only at the moment? 
&gt; How do you convince people that actively look down upon Rust, as if its very existence is an affront to their great skills of C programming? Indeed, how? I (and I think ksion) want to know answers to this. It seems to me that you don't want to know answers, or decided that there is no answer. Which is unfortunate, because I (and I think ksion) think convincing them is necessary for Rust to succeed. &gt; Tell me that these are comments looking to engender conversation and discussion. The fifth one seems fine to me, for example. It starts, "I was interested in learning Rust and perhaps using it for some personal projects". It ends with "I'm not interested in using a programming language as some kind of social engineering experiment." Since Rust is, in actuality, not a social engineering experiment, we should strive not to be misunderstood as such.
[removed]
Has anybody who has used both IntelliJ+Rust and RLS+(OtherEditor) a reasonable amount care to weigh in on how your experience has been between the two?
I already give them money for a full sub (all products). Trying to figure out ways to give them even more. This is freak'n amazing! I have been using VS Code for Rust dev, but switched back to IntelliJ about a month ago. Even then, the plugin was amazing, fast and stable. Jump to source has been excellent. ♥♥♥♥♥ Hugs for everyone!
No it doesn't use RLS. However it supports much of the functionality that RLS provides to VS Code (types on hover, go to definition). In addition because because it has a better sense of what types things are it can likely do a better job of completion that Racer (RLS is not yet used for completion in VS Code)
Will/does it support rustfmt?
I've switched back and forth between IntelliJ+Rust and VS Code with RLS. Previously VS Code had much better type information so hovering to see the type of variable was better. However, with this version the IntelliJ+Rust does a pretty good job at types. Having correct types also means it does a good job of completion and overall, the IntelliJ+Rust feels more polished than VS Code. 
I can't imagine why anyone would want to exit this community rather than stick around for this kind of abuse...
&gt; that doesn't mean that a model where your cargo.lock only contains version numbers and public keys and no hashes and your security builds on verifying signatures is okay I never said it is okay! Listing hashes *is* the solution to reproducible dependency downloads, it shouldn't go away! &gt; There is no Cargo.lock equivalent There is in npm version 5. &gt; You also often times don't actually need cryptographic proof that some crate was authored by key X. But if you do have that proof, you don't have to trust the registry itself! Isn't that cool? :) &gt; TOFU is used Yes. That's the best you can do with random strangers. And it protects you from that stranger being replaced with another stranger, which I believe is important. &gt; the best thing to do here is to allow signing of apps, but not require it I agree! I didn't say it should be required :) Though it should be very strongly encouraged for popular packages. &gt; some people will lose signing keys Of course! Of course the registry shouldn't enforce this! All checking should happen on the client. I think (but I could be very wrong??) that in the Java world, the registry only wants you to upload *a* signature, without any checking. The client (cargo) should, when *updating* (replacing the hashes in `Cargo.lock`), verify the signature, and display a big warning if it's from a different key than before.
[removed]
Which is funny, I would almost say rust isn't conservative at all with new features. The rate and amount of new features that make it into the language is really impressive. Compare it to, really, just about any other language. Go, Javascript, Java. Besides smaller unused languages, I think C# is about the only language that has roughly the same feature implementation velocity. I'd say rust devs have struck a nice balance.
Just FYI, this post appears to have been stuck in the spam filter... it just now became available, as you can see [when posts are sorted by new.](https://www.reddit.com/r/rust/new/) You might get more responses now. 
You may want to run clippy on that code base, I got a lot unused import/method warnings when I ran the game.
I think I can rest my case when you were only able to come up with an objection to one of the links I pointed out. If the Rust community is so "toxic" as ~~you~~ the Slashdot comments claim, then what can one say about whatever community those commenters belong to? EDIT: made a mistake in attribution.
Yeah definitely. I saw those when building release mode, just couldnt be bothered to fix. Was tired EOD yesterday :)
Are you running the program with the "--release" flag (i.e. "cargo run --release" or "cargo build --release")?
Honestly, the main thing I don't like about macros is that they make tooling practically impossible. I've seen a few rust libraries that really heavily rely on macros and it is practically impossible to really delve into the library because of them. Heck, even without talking about tooling. Just figuring out as an end user how to use the library can be very complex. You are basically bound by the documentation and that is often lacking. I like the idea of macros, but I don't like how they tend to be overused. If they are only saving you 2 lines of code, then just write the two lines of code!
I highly doubt that *everyone* who disagrees with the CoC was silenced. Also, if you think there was such contention, provide evidence? The evidence of burden rests on you, since you're the one making the strong claims.
I haven't looked in too much detail, but the thing that sticks out in a huge way is that puppies::rescore() takes a mutex lock at the top of the function and holds it for the entire duration of the function. ~~You execute rescore in a thread pool, but you're getting exactly 0 benefit from the thread pool since only 1 rescore function can ever be running at a time.~~ &lt;-- not the case.. see below. In the Scala example, if it is doing any locking, it is not apparent to me. 
I'm going to assume this comment is in good faith. As evidence, I present the *countless* discussions taking place outside the Rust community where social justice policies dominate the discussion, and not in a good way. I also present the way that I and others are treated every time we broach this subject. I present /u/Suppiluliuma_I -- who, instead of engaging me on the points I have raised here, has chosen to imply that I am a racist. That's enough to start with, right?
Where did I say the Rust community is toxic? I don't think it is. Do not attribute words I didn't say to me.
I have used both a fair bit and I would recommend IntelliJ+Rust over everything else. VS Code+RLS is not bad, esp if you are already using VS Code for other things. 
People complain, but do they provide any actual points where they have been burned by the policy?
Do you have any numbers? Numbers would help us figure out how to interpret the problem. When someone says Rust uses Autism Driven development, do you think we should be taking them seriously?
Wow. Just wow.
Oh, I think I mistook you for another user. I'm sorry about that, I'll amend the post.
You're moving the goalpost. I said these policies are divisive and have the effect of limiting the rust community to only those who are happy with the social justice agenda of the existing community. And, of course, idiots like me who hope the language can transcend that.
That's exactly what I think when I read slashdot, which has no CoC.
Tell you what: let's run a survey of users of proggit and just ask them, directly, how the political leanings of the rust community impact their involvement. I assume that existing rust community members will be overrepresented and skew the results, but maybe that would be a good jumping off point.
And what kind of divisive social justice agenda would you say is being pushed by the existing community, exactly?
People that would be scared off by Rust's CoC are people that would have scared off other people. You have to make a choice -- adopt and enforce a CoC and scare off jerks, or *don't* adopt a CoC and scare off people who don't like jerks. Rust is the only programming-related community I've been able to participate in for longer than a month, and a big part of that is the CoC. &gt;they perceive the political and social agenda of the community as being inherently bigoted, racist, and toxic. Just to be clear, we're talking about [this Code of Conduct](https://www.rust-lang.org/en-US/conduct.html). Can you help me understand what in that CoC could be considered "inherently bigoted, racist, and toxic"?
https://developers.slashdot.org/comments.pl?sid=10924699&amp;cid=54904501 is actually a very good observation. 
I don't think I am: I'm asking what justifies the belief that the CoC is divisive? Just because people believe things about it doesn't make their beliefs true, and so their reason for staying away is then unjustified. If people want to believe something false about this community, and stay away because of that, then that's on them. Believe me, I was one of those people who resisted things like the "master-slave" dispute, and other "SJW" intrusions into what I believed were technical discussions. I've changed my mind about those issues after seeing how lack of enforcement of basic human conversation ettiquette in other communities has effectively made civil conversation impossible.
Well, everyone seems to gravitate toward the code of conduct, yes, but that's not what I'm talking about. For instance, a call went out last month for participants for a program that actively discouraged the participation of white men. This goes well beyond the code of conduct. And I would point out that you are begging the question when you make presumptions regarding the motivations of anyone who might, on principle, or for whatever other reason, have a problem with this kind of social and political agenda: you're literally saying, "Those people are bad because they disagree with me, therefore I don't want them here."
You ask: &gt; what justifies the belief that the CoC is divisive? Then you say: &gt; If people [...] stay away because of that, then that's on them. The public face of this community is, by and large, the social and political agenda represented by that code of conduct, and people will believe whatever you *tell them* to believe. They aren't believing anything untrue, as far as they know, and this community makes almost no effort whatsoever to disabuse them of that mistaken notion. (See? Even *I* say that it's mistaken.) ...But, seriously, you can't have it both ways. You can't both say 1) it's not divisive, and 2) it's causing them to stay away, but so what?
Let's keep calm :) I know it can be difficult having a good discussion, yet I think that /u/ksion and /u/sanxiyn are asking a valid question. Beyond the commenters on Slashdot who may or may not be "redeemable"^1 there is the issue that their comments will be read, and will influence their readers. It would be a shame if a large swath of people, convinced by these comments, would forego experiencing Rust altogether. ^1 *Cue link to Rust Evangelism Strike Force :D?*
Something similar was observed [back in May 2015](https://internals.rust-lang.org/t/diversity-on-the-governance-teams/2048/7) about the Rust teams themselves. [They're still not very diverse](https://www.rust-lang.org/en-US/team.html) :)
[removed]
It supports formatting with rustfmt, but also has integrated formatting.
I am not sure. "Looking at the profile pictures of Rust's contributors" is not a good way to measure diversity. I (ranked #38) am a 30s Asian male. catamorphism (ranked #6) is a transsexual. (This is public, reachable from that page in 2 clicks.) lkuper (ranked #30) is female. tshepang (ranked #31) is African. Manishearth (ranked #36) is Indian. And so on. Many profile pictures there do not give any demographic information.
&gt;For instance, a call went out last month for participants for a program that actively discouraged the participation of white men. [For reference for those following along at home](https://blog.rust-lang.org/2017/06/27/Increasing-Rusts-Reach.html) Yes, because white dudes are already over-represented in the Rust community. Furthermore, that program is exclusively additive -- it doesn't hinder anyone's ability to participate in the Rust community at large. No one's rejecting PRs because they come from white men. It was just an incentive to get some participation from groups of people who don't seem to participate as much. If they don't make an effort to target non-white folks and women with something like that, it's not hard to guess who will be getting those free tickets. &gt;And I would point out that you are begging the question when you make presumptions regarding the motivations of anyone who might, on principle, or for whatever other reason, have a problem with this kind of social and political agenda I mean, yeah. If a person thinks active efforts to combat racism and sexism are racist, sexist, and/or toxic, I don't want to share a community with that person. &gt;you're literally saying, "Those people are bad because they disagree with me, therefore I don't want them here." I'm literally not.
running their code, it is definitely using multiple cores on my machine. Each thread appears to take its own separate mutex. /u/sscdotopen I used a profiler, and it looks like around 71% of the total program execution time is spent doing floating point logarithms. Are you sure you're not doing something algorithmically different with the basic math? Floating point logarithms are expensive. EDIT: here's [the callgraph.](http://i.imgur.com/6SLWYq9.png)
Link quote: &gt; What I don't get is why the Rust community lacks diversity, despite them putting so much emphasis on supposedly supporting diversity. &gt; Years ago, back when I was a Java developer, I would sometimes go to Java conferences. There would be men there. There would be women there. There were probably transsexuals there. There would be old adults and young adults. There would be people representing every possible skin color. There would be somebody from pretty much every major ethnicity. There would be practitioners of pretty much every major religion. There was true diversity, without anyone actually trying to impose it through Codes of Conducts and Moderation Teams and "initiatives" and "affirmative action". &gt; Yet here we have Rust, with its invasive Code of Conduct, and the Rust Moderation Team to force it on the community, and all of its focus on "diversity" and "social justice". But when we look at the profile pictures of Rust's contributors [github.com], they appear to mostly be mid-20s white males (I'm assuming "steveklabnik" is a male). &gt; Now don't get me wrong, there's nothing wrong with being a mid-20s white male programmer. This isn't about singling anyone out, or about claiming that some mythical "privilege" exists, or anything like that. &gt; The issue here is that it appears that the more that the Rust community intentionally pushes for "diversity", the less of that we actually see. Instead of seeing a naturally diverse community form on its own, like pretty much every other programming language has, we've seen Rust's community become extremely homogeneous. &gt; It's as if the Rust community's efforts to force diversity on their community has actually had the complete opposite effect! While trying to create the most diverse community, they've actually only managed to create the least diverse one I've ever seen! A good observation, but a poor rhetoric. Yes, the Rust team is mostly composed of white male (I'll elide "in their 20s", I'd bet half of them are over 30), however I do not see much surprise here. The few companies I've known in Western Europe also mostly employ white male as developers, for the simple and good reason that most Software Engineering/Computer Science graduates are white males to start with. I used to work for Amadeus SA, a company who claims having agencies in more countries than are officially recognized by the UN. To say that its workforce is diverse is an understatement, even in Nice (France) where the main development center is you find people from all continents, and many countries. The last team I was in was half-French/half-foreign, and there I had the pleasure to work and sit with colleagues from Columbia, Congo, Mexico, Russia and Bengladesh. However, even in this most diverse company, and despite an overall male/female ratio close to 50%/50% as far as I could see... software engineers were predominantly male, and predominantly white. Aligned with the ratio of my class in engineering school (in Paris). And I think this is why insisting on diversity **in education** is important. As long as the ratio of graduating CS/SE students is so skewed, I don't see how we'll obtain a diverse developers workforce. 
The assumption that anyone who has qualms about the CoC is a "jerk" is itself narrow-minded and toxic. It's a big reason Rust is seen as a cult and a reason I've decided to mostly leave the community. To many people, a CoC is more than the sum of its words. It's a declaration of allegiance to the online social justice movement which by and large treats people in an incredibly awful way, especially if they're deemed to be "privileged". It's very understandable to be scared off by even a whiff of that.
Fair enough, I just personally do not see a way to convince people who, in my opinion, have already made up their minds.
I previously used VS Code more often. But that has changed over the past few weeks. I use mostly IntelliJ+Rust now and VS Code only for debugging.
&gt; https://github.com/sscdotopen/puppies/blob/master/src/main.rs Ah I see. Each indicators BinaryHeap is wrapped in a mutex, presumably to keep two threads from working on the same Heap at the same time, but there are as many indicators as items, so there isn't a concurrency issue at all. 
what do you mean?
The problem here is that you steadfastly refuse to believe that any reasonable person could ever disagree with you. And, yes, that kind of bigotry--because that's literally what that is--is divisive. (For reference: bigotry means "intolerance toward those who hold opinions different from oneself.) You don't see the irony in saying, "I don't want to share a community with a person who disagrees with me," and then saying, "But I'm not saying those people are bad and I don't want them here," on the very next line. I'm here to tell you: other people do see the irony in that, and it bothers them.
I have no interest in convincing these people to use Rust, &amp; I wish people would not devote time to it. Not only are there many systems programmers who are do not make malignant and ignorant comments about Rust on the internet, there are also *far far* more people who are not yet systems programmers, but who could become systems programmers. We don't need to "replace" C, we need to grow the pie by enabling more people to write systems level code.
Or you can just use Rust yourself and not give a shit about converting the masses. The crusty oldtimers of Slashdot will die off eventually.
The rust version does [this multiplication](https://github.com/sscdotopen/puppies/blob/master/src/main.rs#L204), which isn't done in the scala version. For some reason the rust version stores the score as a i64 and not a float like the scala version, even though the result of the logLikelihoodRatio function is a f64. Another difference is that the scala version of logLikelihoodRatio operates on signed values (aka i64), while the rust one operates on unsigned ones. Not sure if that makes any difference though. Modifying the top value of the [heap here](https://github.com/sscdotopen/puppies/blob/master/src/main.rs#L210) using peak_mut rather than popping and pushing may also help a bit. EDIT: Subtracting k11 from k21 [here](https://github.com/sscdotopen/incremental-cooccurrences/blob/master/src/main/scala/io/ssc/incrementalcooccurrences/IncrementalCooccurrenceAnalysis.scala#L168) seems to also be missing in the rust version. It might be a good idea to check that both versions give the same result if you haven't already.
While I am more interested in marketing Rust to existing system programmers than new system programmers for various reasons, I do not say things like "I wish people would not devote time to it", and I wish you stop doing so too. If you don't want to help, fine, but do not obstruct people trying to help Rust.
&gt; The issue here is that it appears that the more that the Rust community intentionally pushes for "diversity", the less of that we actually see. Instead of seeing a naturally diverse community form on its own, like pretty much every other programming language has, we've seen Rust's community become extremely homogeneous. Is there any actual proof for this person's assertion? I mean, their conclusion is based on "sometimes [going] to Java conferences" "[y]ears ago" and "the profile pictures of Rust's contributors [...] appear to mostly be mid-20s white males" (notwithstanding a solid shot against Steve Klabnik). They then take those two pieces of solid data to come to the very strong conclusion quoted above. Of course, they don't quite prove causality between their "evidence" and how Rust's attempts at diversity have (laughably and inevitably) backfired. Backfired to such an extent, even, that rust has lost tech's [naturally diverse community](https://arstechnica.com/gaming/2016/03/cast-of-hbos-silicon-valley-discuss-the-real-tech-region-at-swsw/). If you starve that post down to its bones and grind them up, dissolve them in acid, and filter light through the resulting solution to come to something like "the Rust community needs to make sure that its diversity initiatives do what they intend to", then sure, the post has a point. But as written, that post seems like barely dressed "anti-sjw" complaining. 
I understand if you don't want to evangelise, but I don't understand being against evangelism itself. Like it or not, programming languages *do* have network effect.
Normal IntelliJ formatting works (Ctrl+Alt+L) but it uses a pretty annoying style IMO, without enough customisation options. It does support rustfmt. Not sure if it's in the menus somewhere but you can bind it, or invoke it through the action finder (Ctrl+Shift+A), "Reformat file with rustfmt".
[removed]
The best evangelism is to make cool stuff in Rust, that isn't just "`$existing_project`, but in Rust!". Let the work speak for itself.
I wish people would not spend time trying to convince the people in this link for these reasons: 1. I believe their time would be significantly better spent trying to convince people who aren't predisposed to hate Rust (which could be systems programmers). 2. I believe that if they do convince those people, they will bring their aggressive and unpleasant communication style into our community. I just would strongly encourage you to focus your attention on people who don't behave like this.
&gt; People that would be scared off by Rust's CoC are people that would have scared off other people. &gt; I don't agree with this statement. You're making the assumption that those who disagree with the CoC are also those that would break the CoC. This is the same line of reasoning "Those who dislike government surveillance are those who have something to hide from the government." You're combining disagreement with wish for abuse. I know many people who are strongly against overt attempts at control of what others say but at the same time are some of the nicest people I know to others and those they deal with. Trying to lump them together in one group is disingenuous at best.
&gt; Aligned with the ratio in engineering school. Let me harp on my pet topic. If Rust followed population ratio, Rust would have a *lot* of Chinese contributors. But in fact, I count exactly zero Chinese contributors in top 50 contributors to rust-lang/rust. This is a good evidence of systematic bias against Chinese programmers, and non-English programmers in general. (Compare: there are Indian programmers, because India is in Anglosphere.) As a concrete step, we could take [non-ASCII identifiers](https://github.com/rust-lang/rust/issues/28979) more seriously, for example. I know there are hard technical issues here, but we could have put more serious effort.
It's not just not likely, the don't use RLS or compiler internals at all.
We agree to disagree on what is the best way to evangelise. (There actually *is* the best way here, although we don't know what it is. It is *not* axiomatic "the work speaking for itself" is the best way.)
Currently it only means that JetBrains will be displayed as vendor in plugin manager, but it opens a way for further investments in the plugin in the future
yes of course
&gt; The assumption that anyone who has qualms about the CoC is a "jerk" is itself narrow-minded and toxic. Good thing not everyone is thinking the same way. &gt; I've decided to mostly leave the community. Because a few people misunderstand stuff and because of CoC meta-debates you are leaving the community? That's on you. &gt; It's a declaration of allegiance to the online social justice movement That's presumption of intent. I don't see it that way. Rust community isn't about calling employers in order to get people fired, it isn't about defaming people in media, it isn't about the usual conspiratorial misconstructions at all. CoC got associated by that strain of activism, possibly because it was pushed by those people, but my impression of why Rust got to have CoC is because someone liked it at face value, not because it's part of any agenda. 
This was more crafted to the possible future but yeah, this sounds very misleading. I fixed that :)
kmc_v3 is the primary author of html5ever (and many others), and when he says he left because of "CoC problem", you should listen, not say "That's on you". Actual people with serious Rust contributions did leave, so just stop with "it's not a problem" nonsense. As for intent, good intent can and do lead to bad outcome. I also think Rust's CoC is of good intent.
&gt; by and large [citation needed]
Congratulations to matklad (u/matklad?) who has done amazing work on the IntelliJ Rust pluginto get it official recognition. This is great news!
"Project" is not really a real term within Rust. "package" is. A quick overview: 1. A *package* is defined by a `Cargo.toml`. You can see that `[package]` is the first line of `Cargo.toml` to reflect this. 2. A package contains one or more *crates*, which is Rust's compilation unit. This basically means "library or binary", and map to some sort of output file, generally an `rlib` for libraries or `.exe` or some other executable format for binaries. 3. A package can be part of a *workspace*, which puts together multiple packages. Why do this? They share a single `Cargo.lock` file and output directory. This makes it easier to make sure that they all use the same versions of dependencies, and don't require rebuilding the world when you switch between packages to work on. Even though these names are well-defined, sometimes people still refer to packages as "crates", because often there's a 1-1 mapping between them. Hope that helps! (Small side note: packages _were_ called "projects" long ago, and Cargo will actually accept `[project]` as a synonym for `[package]`, but that nomenclature has technically been gone for a very long time.)
I have a love/hate thing with macros - I would love for a language not to have them - they add another huge thing to have to reason about and they cause unbelievable complexity to the first stages of the compiler (it is almost a truism that most languages that are big on macros have *very* simple syntax). However, I think a lot of people don't really understand how important macros are for Rust. If we didn't have them we'd be a completely different (and probably worse) language. Imagine how we would have to engineer `println` to get the same safety and performance without macros. I think macros have really helped Rust get around a lot of performance/safety/ergonomics trade-offs.
Umm some sort of CTFE and variadics based hack? fn format_args&lt;const fmtstr: &amp;str&gt;(variadic args: &lt;fmtstr as FmtStrArgs&gt;&gt;::Input) -&gt; fmt::Arguments { &lt;fmtstr as FmtStrArgs&gt;::parse(args) }
&gt; Does that mean I can take whatever STM32 I can find and start using CANBUS etc. ? You certainly can. Since [this blog post](http://blog.japaric.io/quickstart/) you can work with pretty much any ARM microcontroller at the register level provided you have a SVD file for the device. And how about tokio ? I don't think tokio is no-std compatible. You can certainly use futures (or async/await/generators when available) to build an event loop in the `idle` function.
&gt; he left because of "CoC problem" If only I was furnished with one example where a person was undeservedly put down by CoC in a manner that is attributed to SJWs. All we get here are meta debates on why CoC proves Rust is filled with horrible SJWs but never a manifestation of that horrible SJW agenda affecting anyone. Maybe these meta debates and utter bs on ./ is a reason enough to replace CoC with something simpler à la "behave vaguely academic" but still carry out current CoC in full just so people stop believing in this ridiculous notion that Rust is somehow connected to SJWs. 
Half of the Swift standard library is written in a custom python-based text preprocessor (gyb -- Generate Your Boilerplate) due to the lack of macros. So Swift has just as many problems, but at least Rust has a known-hack-should-be-replaced-one-day solution that our developers can benefit from. ¯\\\_(ツ)\_/¯
You are right, the locking is not necessary, as every heap will be touched at most once, however I could not figure out a way to make the code compile in rust without the mutex. Do you have an idea on how to do that?
It sounds like you know what you're doing and you already have a pretty good plan! If it's a learning exercise then Tokio / futures is good because it involves more learning, otherwise with your requirements a main loop that does everything synchronously and then sleeps for a while is probably less work. I'd say just start! One caveat about Serde for Json is that you need to expect whatever you're reading to not change schema. A lot of json endpoints don't consider e.g. adding fields to be breaking a contract. Ymmv. 
This is great! I played with the previous bindings and it was already a much better experience. Most of my work now depends on tokio, will definitely try the new bindings and Stream trait.
Thank you for spotting the missing subtraction, I will fix that. I had to convert the score to an i64 in rust, as it will not let me implement the Ord trait for my ScoredItem struct if the score is an f64, due to the missing total order for floating point numbers (if I understood that design decision in rust correctly).
You are right, the locking is not necessary, as every heap will be touched at most once, however I could not figure out a way to make the code compile in rust without the mutex. Do you have an idea on how to do that?
&gt; Maybe these meta debates and utter bs on ./ is a reason enough to replace CoC with something simpler à la "behave vaguely academic" but still carry out current CoC in full just so people stop believing in this ridiculous notion that Rust is somehow connected to SJWs. This is basically my position and I would be greatly satisfied if this is done.
This sounds cool. Any links or are you still in stealth?
&gt; In order to run the scala version, execute the following file: &gt; https://github.com/sscdotopen/incremental-cooccurrences/blob/master/src/main/scala/io/ssc/incrementalcooccurrences/experiments/Movielens1M.scala I can't figure out how to run that Scala file. I installed Scala (and Maven) on Ubuntu. I managed to get Maven to build everything by doing mvn package -Dscala.version=2.12.0 But, if I try to run that particular scala file with scala Movielens1M.scala I get Movielens1M.scala:1: error: illegal start of definition package io.ssc.incrementalcooccurrences.experiments ^ one error found and if I try scalac Movielens1M.scala I get Movielens1M.scala:3: error: object IncrementalCooccurrenceAnalysis is not a member of package io.ssc.incrementalcooccurrences import io.ssc.incrementalcooccurrences.{IncrementalCooccurrenceAnalysis, Interaction} ^ Movielens1M.scala:17: error: not found: value Interaction Interaction(tokens(0).toInt - 1, tokens(1).toInt - 1) ^ Movielens1M.scala:23: error: not found: type IncrementalCooccurrenceAnalysis val analysis = new IncrementalCooccurrenceAnalysis( ^ Movielens1M.scala:24: error: not found: value numUsers numUsers = 9746, ^ Movielens1M.scala:25: error: not found: value numItems numItems = 6040, ^ Movielens1M.scala:26: error: not found: value fMax fMax = 500, ^ Movielens1M.scala:27: error: not found: value kMax kMax = 500, ^ Movielens1M.scala:28: error: not found: value k k = 10, ^ Movielens1M.scala:29: error: not found: value seed seed = 0xcafeb ^ Movielens1M.scala:38: error: overloaded method value / with alternatives: (x: Double)Double &lt;and&gt; (x: Float)Double &lt;and&gt; (x: Long)Double &lt;and&gt; (x: Int)Double &lt;and&gt; (x: Char)Double &lt;and&gt; (x: Short)Double &lt;and&gt; (x: Byte)Double cannot be applied to (Any) s"throughput=${(batchSize.toDouble / durationForBatch * 1000.0).toInt}/s") ^ 10 errors found which is not helpful. :/ so, it's hard for me to compare and even know if the Rust code actually is slower, and if so, why.
[There are Rust bindings for Dear IMGUI.](https://github.com/Gekkio/imgui-rs) Not sure if this is what you were looking for though.
[link](https://github.com/artemshein/schematiks) Early development stage and no docs yet. But it generates/bootstraps itself source code ([link](https://github.com/artemshein/schematiks/blob/master/src/model.rs)) :)
The type inference still completely falls over when it sees `App::new()` [in this code.](https://github.com/coder543/cryptoticker/blob/master/src/main.rs#L99) It has no clue what type `matches` is, or where any of the functions come from on lines 100 to 121. As a result, it also has no clue what type line 124 is. It knows what type line 123 is because of the OR operator. For comparison, RLS knows all of the above information, no missing pieces.
This is a master's thesis on [Tock OS](https://www.tockos.org/).
I updated the project to also include scala-lang (so you have to pull once more from the repository), and you should be able to run the program from the command line now via mvn scala:run -DmainClass=io.ssc.incrementalcooccurrences.experiments.Movielens1M
Nice, I did this aswell but for 1- and 2-grams. Code is not the best since this was when I began to truly understand how to write idiomatic rust. https://github.com/Emilgardis/problems/tree/master/lang-interp/src
[Also, check here if you haven't.](https://github.com/rust-unofficial/awesome-rust#gui)
Talking from experience, and while this is anecdotal, those pushed away from CoC-type things or other such activism get strongly burnt from ever trying to argue with people about this kind of thing (except for a vocal few). As people in favor of this kind of thing tend to be extremely passionate about them so it's like discussing things with a brick wall. Also, for some more anecdotal evidence I was personally almost pushed away from learning Rust because of several people really pushing for this kind of thing as it really puts a sour taste in my mouth. I'd compare it to eating sweet candy (Rust is awesome) with an extremely bitter aftertaste (the CoC nonsense). And no I haven't ever been hit by the CoC but purely the existence makes me very worried I will be in the future. It's basically a Sword of Damocles hanging over me all the time when dealing with the Rust community. I have no interest in getting strongly involved in the community and definitely not using my real name for fear of lasting repercussions over something miss-said that would affect my career.
I, for one, believe the text exclusively in the Rust CoC to be perfectly neutral, with the only problem being its adoption of the definition of harassment by the [Citizen Code of Conduct](http://citizencodeofconduct.org/), which makes the slightest, well-intended joke on our human sexuality an offense on par with threats of violence. This may be okay for those who are lucky enough to be paid to work on Rust, since this kind of dryness is the norm in enterprise work, but it kills any possibility of me seeing the overall Rust community as something I'd consider myself as "belonging to" or a place where I'd want to make friends or stay for any more time than needed to ask a question and get an answer. This sub and the forum have the benefit of having defined topics in every case where getting in and dropping out quickly is the norm, but I'm honestly on high alert if I have to get into chat for any reason; and I consider myself thick skinned. Attending a Rust conference "for fun" right now is out of the question. The other things that tends to get people riled up is affirmative action-style discrimination such as [this one](https://blog.rust-lang.org/2017/06/27/Increasing-Rusts-Reach.html) mentioned earlier in the thread. I'm saying this as someone who qualifies on three grounds for that particular offer, and the fact that I feel I have to state this to have any chance to be heard makes me feel even more troubled. This kind of thing implicitly implies our work to be inferior. It isn't like Mozilla is just helping out programmers in a tight financial situation with expenses, no, it strictly ties the problem to our gender, sexuality and the color of our skin, among other things. That's a real case of discrimination from people who I assume are extremely well-meaning in their intent to be inclusive, and that's a problem. EDIT: I'd appreciate answers to the arguments made, since downvotes do not communicate more than just disapproval.
&gt; Generating idiomatic Rust code is hard :) It totally is, even in clippy, where we have the existing code *and* the compiler on our side.
Ported the Rust standard library `std::sync::mpsc` module to use `parking_lot` types &amp; work on Windows XP using the stable Rust toolchain. https://crates.io/crates/parking_lot_mpsc There are still some rough edges in that port though, there were some lines similar to `impl !Sync` in the standard library version that didn't compile, they're commented out until I can determine what, if anything, to replace them with. The `mpsc` issue was the primary issue blocking a larger project from working on Windows XP, so porting it was the easiest solution. The other issue was `mio` and/or `miow` using Win32 APIs that don't work on XP, and therefore `tokio` couldn't be used even as an implementation detail of other crates. For example the latest version of `reqwest` doesn't work on Windows XP even without using the async APIs because it uses `hyper` 0.11 internally, but the older versions of `reqwest` still work. 
A big part of my annoyance with macros is the tooling to view the generated source code is not great yet. So if I want to understand what a macro is doing I often have to read the macro source code, which is often very difficult since my familiarity with rust macros syntax is understandably much less than with regular rust syntax. Yes I can manually run the code through rustc with the macro expansion flag, but that is very annoying and needlessly cumbersome. I feel like most complains about macros can be solved by better tooling, and I'm glad there has been such a strong focus on these things by the language team this year!
Ah, you are correct about the Ord trait (I believe it's related to the fact that a floating point value can be NAN.) Not sure how to best get around that.
look what popped up today https://www.reddit.com/r/rust/comments/6qgzu4/mocker_an_http_response_mock_tool/
It looks like that's caused by App::new() returning Self. I've filed an issue on about it: https://github.com/intellij-rust/intellij-rust/issues/1549
This has been said to you in the past, and I'll say it again: If you're unclear about what the CoC does and does not deem acceptable, _ask the mods_ (preferably email mod-team). We're here to help, we don't bite. In general we don't ban except in blatant cases (e.g. spam or very clear harassment), mod enforcement mostly involves warning the user and starting a (private) dialogue. The code of conduct even explicitly mentions most of this.
I removed a bunch of threads about slashdot. I don't like the community either, but let's please stay civil. (Your comment being removed is not necessarily an indication of incivility; I just removed entire threads) Edit: Never mind, the entire topic was deleted. Works for me.
well this is only the list for IntelliJ IDEA. There is also Rider which at least supports C# and I guess F# is coming, too.
You're missing the point. Whether or not the CoC is part of an agenda (I do not believe that it is), *people will see it that way*. You should try to understand why, and not just write them all off. I'm not saying this is a reason to discard the CoC but it is something that deserves to be understood. (Isn't the social justice thing supposed to be about empathy? I find that the expectations of empathy are often very one-sided.) Also I have in fact seen nasty comments on Twitter about members of the Rust community who are allegedly violating the CoC. So there's that. (I have also made nasty comments on Reddit so I can't claim the high ground here.) &gt; Because a few people misunderstand stuff and because of CoC meta-debates you are leaving the community? That's on you. No, there are many reasons, and this is not the main one. You really need to listen though. If the reaction to anyone who's had a negative experience is "That's on you", then the Rust community will turn into the kind of bubble where everyone is congratulating themselves on being friendly and helpful, without examining whether that's actually true. I've seen it happen in other programming language communities and it's not pretty.
I haven't done any web programming with rust, so I might just be confused, but how is this different from `hyper`? 
This doesn't actually *do* any of the HTTP stuff; it's basically just types. This gives you all of the regular interop stuff that sharing types gives you. Hyper implements this for its request/response/etc types, I write a library that works on this response type, now my thing works not just with hyper, but anything else built off of the shared types.
Http is widely used in developement that having a great http client is really important for any language. I personaly don't find one, start using [curl](https://crates.io/crates/curl) but decide to build [my own client](https://crates.io/crates/cabot), not for being the most widely used client, but to not depends on OpenSSL, and also to learn more rust and the http protocol itself. As far as I see, the http crate is a parser of http envelope (query and response), but is not going to achieve the transport. Is it ? 
Oh ok, so people can make hyper competitors while still being able to use the common types and things? Is functionality like parsing in hyper or http?
Hey, we can only agree to disagree if I agree to agree to disagree! [Plus it's mathematically impossible.](https://en.wikipedia.org/wiki/Aumann%27s_agreement_theorem) (This is not a serious post; ignore me.)
There is no niche targeted yet, perhaps testing micro-services with a dependency spitting out HTTP locally. I used it at work to mock some InfluxDB stuff and so far so good so I figured it might interest someone else.
&gt; Oh ok, so people can make hyper competitors while still being able to use the common types and things? Yeah, or plugins, anything. &gt; Is functionality like parsing in hyper or http? http will parse URIs, but nothing else, as far as I know.
Have you checked out reqwest? And yes, this isn't an HTTP client, it's a bunch of types and traits you could use to build an HTTP client.
Slow is fast imo
you can use GTK or Conrod or Relm. It's all still under heavy development. I feel like we have this thread every three or four days now, and it's just depressing to me. :/ We need to have a solid story for GUI in Rust, but I don't have time to work on it right now. Maybe GUI should be the top priority goal of the Rust community in 2018...
You've got a good point there.
Continue to provide value, strive to avoid providing drama. Time fixes the rest.
Let me know how well it works for your use cases, and if anything is missing or could be nicer :)
and it looks like a fix has already been committed! that's awesome!
I think CoC-type things become more important as a community gets larger. When I'm just thinking, my only audience is myself. I might think the crudest of jokes and find them amusing, and that's fine, I know I'm not a bigot/whatever . If I'm in private in the company of a very close circle of friends who know me very very well, I could crack some crude jokes, and they know I'm not a bigot/whatever, so I think that's fine too. But if I'm in a larger community, or an online forum where my audience could be anyone, and I say something that might be seen as abusive to subgroup X, I might be saying it in jest all I want, there can still be someone from subgroup X who does not know me and cannot assume I'm just joking. And if they have been regularly on the receiving end of abusive behaviour, they would be completely justified in feeling threatened. In this case, CoCs are essential to stop my behaviour. Of course, this could be enforced properly or horribly. It's one thing to be warned properly by a moderator, and it's another thing to have your character executed in public by a mob. (I think the Rust moderators enforce the CoC extremely reasonably.) And I think this is why some people are wary of CoCs. There have been mobs which destroyed careers of good people who said something in the wrong place. Yes, they were wrong to say it, and they probably deserved some kind of punishment, but they should not have had their character executed for it, or career destroyed. But the solution isn't to have no CoC, it is in enforcing it properly.
Doesn't deleting this topic play right into the hands of the "the Rust CoC is oppressing us!" crowd?
First, did you build in release mode? :) cargo build --release
Thanks for the downvotes everyone, you're really proving my point.
Which languages do you support? Do you use the same algorithm as I? I did number of experiences before (first I've tried to do this with Crystal calculating ngram on my own from text corporas), but looks like the best and the most efficient method I found is to use trigrams. (300 sorted trigrams per language)
To be more precise I found it in FrancJS lib, not myself: https://github.com/wooorm/franc
&gt; Isn't the social justice thing supposed to be about empathy? There's social justice which is frankly great, but then there's the turd that grew a few years ago that's connected to gg and sjw drama. Some people associate CoC with the later rather than the former. Remember the incident following Rosetta landing where NASA employee was made to apologize in tears in for wearing a shirt with motifs found commonly in pop culture? The display we are currently admiring on /. is misplaced reaction to heaps of similar witch hunts. &gt; Also I have in fact seen nasty comments on Twitter about members of the Rust community who are allegedly violating the CoC. So they aren't affected by CoC? I want to know about instances where community member was forces to get with the alleged SJW program of Rust community, not when mod team was perhaps lenient with CoC or there was difference of opinion on whether CoC was breached. &gt; You really need to listen though. Honestly I'm trying. 
&gt; Besides, Swift allows emoji in identifiers, so clearly they're in no position to be dictating good design principles to anyone... 👏👏👏
The idea here is that `hyper` will be an implementation that creates and receives types from `http`. Then, frameworks can just say "hey, give me a `Request`, I'll give you a `Response`", and a user could hopefully plug in any actual implementation in place. While careful not to say the `http` crate is just like them, think WSGI/Rack/Servlet.
It sounds like you're actually agreeing with me now? What's at stake is not the intent behind the CoC but the perceptions. I think the Rust community should be sympathetic to people who have a dim view of the online social justice movement. I myself spent far too long tolerating the gaslighting and dehumanizing shit that is thrown at supposed allies. As long as people are not actively being sexist/racist/etc, there should not be an ideological litmus test or a notion that you have to love and defend the CoC. When you call people "jerks" for not doing that, it means you are the jerk.
Thanks for the kind words :) Most of the CoC blowups I've seen were not about social justice, just garden variety assholery or the accusation of same.
We're not stopping anyone from participating in Rust, just stopping this particular metadiscussion that's largely not even about Rust. Meh. 
&gt; this ridiculous notion that Rust is somehow connected to SJWs. There is also history here. Several of the people who were part of Rust in the early days are pretty outspoken and extreme about social justice. It's not accurate to say that there's no connection at all. &gt; replace CoC with something simpler à la "behave vaguely academic" If you do this it will provoke the Twitter feminism brigade and they will spread the meme that the Rust community is an unsafe space for women.
I've completed first stage of my waveform generator application : https://github.com/azizunsal/waveformrs
I tried both Visual Code + RLS and IntelliJ-rust. In my experience, IntelliJ is less buggy (for instance, I had time where running Visual Code was locking my repo) than Visual Code. Everything feels faster. Find usage is incredibly useful. 
yes
When you hint at "several people" being "extreme about social justice" should I think "people like Graydon" or "people like antifa-Steve"?
To /u/ksion's point, that RFC even says it is a placeholder and defines very little about the new macro system, and was merged 6 months ago. Not that it's a bad thing that the Rust language maintainers are taking their time to do macros right this time, but I do think that RFC furthers the idea that macros 2.0 isn't anywhere on the horizon.
Eh, fuck it. I'm talking about Graydon and tjc. I also worked with both of them and I think they're good people. Politics is always hard.
I think the issue is that "CoC" has gotten a bad reputation after bad incidents that happened with CoCs in other communities. Regardless of what the particular CoC says and how it get applied in practice, some people get triggered by just hearing the term. Not sure what we can do about that... Perhaps renaming CoC to something like "Rust Moderation Policy" would help somewhat?
To be honest, I'm not really sure how I got this specific algorithm, I think it's just a normal implementation. I use `Iter::peek` for lookup in the 2-gram and use a `BTreeMap` for storing counts/frequency. I'm sure it can be hugely improved f.e with `itertools` for arbitruary long peeks to enable +3-grams and using EGCs (extended grapheme clusters) when iterating for support of more "complex" languages/scripts. I store the statistics in a yaml file ([example](https://github.com/Emilgardis/problems/blob/master/lang-interp/assets/english.lang)), currently has support for english, french and swedish, but more can be added if you supply a long enough (500+ words) file and run `lang-interp learn &lt;language&gt; &lt;file&gt;` I found that 2-grams was enough for me to detect language with enough reliability.
yeah I think I am confused because I would assume the trait would be auto include in `rand::thread_rng()` since it is a dependency for `rand::thread_rng()`
This could turn out to be pretty awesome for compatibility among different crates in the Rust HTTP ecosystem.
Whoo! This actually is super cool, and I wonder if there's a task that I could take now...I might be willing to dedicate some time to this after a year of experiencing the awesome Rust community. :)
Sure; it is something though. The implementation is landing now, or at least chunks of it is.
Does anyone know if you can run the IntelliJ Rust language features as a plugin for other editors?
I guarantee there will be! We'll have tasks covering a wide range of areas, size, and expertise. Hope to see you when we get started.
Thanks for sharing. Back in 2013 when I first got involved with Rust I thought the whole CoC business was a bit over the top as well, but somewhere within a year I'd grown convinced it's for the best, and its intentions laudable, and I still feel that way. I rather admire Graydon and like his writing style. As I recall Tim was the first one ever to accept a pull request by me, so he has unwittingly earned a place in my heart :D 
Hey -- I'm one of the maintainers of Mononoke. Thanks for posting about this! &gt; Lacking a Cargo.toml, I'm guessing that it's being built internally via Buck's Rust support. This is correct -- we use Buck to build Mononoke internally. I have a plan sketched out for converting our Buck dependency graph to `Cargo.toml` files -- it's somewhat tricky but not insurmountable. &gt; Haven't seen anything to suggest it's running in production though. This is also correct -- as the README says, we're in the early stages of development. We wanted to get this out now for two reasons: 1. We'd like to start making references to Mononoke from other in-development projects like [Eden](https://github.com/facebookexperimental/eden). 2. We'd like to get this code out for the Mercurial community to start looking at, since we're considering upstreaming some of this into Mercurial.
I doubt the "SJW"-reputation will be lost as easily as that. I don't usually agree with kmc all that much, but I think he's right about letting good work speak for itself. If the Rust community continues being awesome and making awesome stuff for a couple of years, while at the same time not having bad incidents like some of the other communties, the people who fear CoCs will eventually have to come around. In the meantime, I don't think we should insult their intelligence by calling the CoC by another name.
Google is *finally* putting a lot of effort behind scaling git to meet the needs of the Android Open Source Project. See Dave Borowitz's talk at Git Merge 2015. https://www.youtube.com/watch?v=cY34mr71ky8 
I was meaning this in a more wide-reaching meaning than just this subreddit. Also I'm not trying to make this about "me" but about using me as an example case of people that go to /u/Ar-Curunir's point. I personally no longer have strong immediate concerns (only concerns about the future), but that's not the point.
&gt; Maybe GUI should be the top priority goal of the Rust community in 2018... I feel like this is more and more true. And i noticed the same – GUI gets requested really often in the past few months. Personally i am not to heavily interested in this but i can feel that the interest in this field is stacking up.
Wouldn't make more sense to call it httptypes instead then?
Huh to me there's many other things that goes before GUI... 
I like the points and I strongly agree with your overall statement (especially your last paragraph) but just going to nitpick on a single point for food for thought. &gt; But the solution isn't to have no CoC, it is in enforcing it properly. I agree, however the analogous statement is "But the solution in a country to people behaving badly isn't to have no laws, but in enforcing the laws properly." The devil is in the details, as always and people in general are fallible and self-serving (even if they try not to be). I don't have a solution to this however as if I did I'd be President.
Yes, rust-mods@rust-lang.org is about the wider community, not just the subreddit. We're considering making this invitation for questions more explicit on the code of conduct page (in the sense that I'm considering it, and haven't gotten around to proposing it to the wider team).
&gt; We're considering making this invitation for questions more explicit on the code of conduct page (in the sense that I'm considering it, and haven't gotten around to proposing it to the wider team). That would be helpful. It would be useful place to redirect people to if they have concerns (have met a couple people online that were hesitant about Rust because of CoC-related issues). I'd suggest something more significant than just an email link though and more something of a web-form email that allows people to submit questions semi-anonymously rather than revealing their email (or being forced to generate a temporary one).
I am so used to Ctrl+Alt+L , it would be nice if rustfmt works with it. 
&gt; It sounds like you're actually agreeing with me now? In large part it seems so. :) &gt; it means you are the jerk. I think many of them are well intentioned but make honest mistakes due to not having the full picture which is understandable as most people didn't have time to take anthropological excursions to drama subreddits of both camps to understand where both sides come from. Without this picture people will side with either camp when reality is that both camps have many faults. 
To add one more reply, something that would also be useful is a "FAQ about the CoC" in the form of a "What this is not" and a "What this is" type FAQ. Getting explicit public answers from core moderation would really be helpful to link to people.
_arent_ the same thing; you have a typo :)
That's the hope :)
The impl period is a promising idea, but what I'm even more interested in from this post is the projected timeline: incremental compilation and MIR borrowck beta expected in August! Though I see that Chalk integration is a stretch goal for this year... color me impatient. :P
Might this not be confusing to people that the `http` crate cannot speak http itself? Maybe something like `http-types` might be a more descriptive name?
Yeah - the relationship is tricky. Note that this is perfectly valid, for example: extern crate rand; fn main() { let _x: rand::ThreadRng = rand::thread_rng(); } Without the import of `rand::Rng`, `rand::thread_rng()` _still works_. The only problem is that then `rand::ThreadRng` is somewhat useless - it has no methods on itself, only methods defined in `rand::Rng`. Here's an example of where you could actually be useful with this (use `rand::thread_rng` without `rand::Rng`): extern crate rand; fn do_rand(mut generator: rand::ThreadRng) { use rand::Rng; println!("generated: {}", generator.next_u32()); } fn main() { let gen = rand::thread_rng(); do_rand(gen); } `rand::Rng` is only imported inside `do_rand`, not for the whole crate. This makes `next_u32()` available inside `do_rand`, because `Rng` is imported, but it doesn't need to be imported anywhere else.
&gt; since this kind of dryness is the norm in enterprise work Eh I think degrees of "dryness" can be appreciated outside of professional setting. 
Well that would be amazing.
Besides having decent platforms specific API bindings (libc, winapi, the various Mac APIs), I see GUI as one of the biggest things stopping Rust in the conventional desktop apps space. It's a pretty glaring whole for a systems language actually. I primarily work in that space and the embedded space, and the embedded stuff seems to have a lot more momentum and is probably actually ahead.
what else would you prioritize over GUI besides the async/await stuff which is already being heavily worked on?
Just FYI Spice is the name of a circuit simulator that's been around for ages.
You can use `.partial_cmp` if you write the `Ord` trait impl manually. Or you can use something like [float-ord](https://crates.io/crates/float-ord) (Disclaimer: haven't used it myself, but looks good).
Yeah, we realized that. The debugger was our CS capstone project, so the name overlap was the source of some disappointment from CE people who came to see it.
No, we use and have invested heavily in Mercurial for our monorepo. Our reasoning is explained in our blog post another kind soul linked in this thread (thanks).
FYI, this is the MIR borrowchk beta PR: https://github.com/rust-lang/rust/pull/43108
[Orbital Widget Toolkit](https://github.com/redox-os/orbtk). Windows, Linux, macOS, BSD, and Redox (anything with SDL2).
Web GUI. But having a native GUI library that can also compile to html would be even better.
I notice that headers appear to be strings, rather than types, as they are in hyper. Are they on docs on why that change?
Weird how this list lacks Orbtk.
Will it use RLS eventually?
But `println` isn't really a macro. It's compiler magic because Rust macros are nowhere near powerful enough to implement `println`. So... it kinda seems like an argument in the opposite direction?
The "Ship 1.0 synchronous http server and client libraries, built on http and hyper". Are there docs on what the relative focus on synchronous libraries vs async is? From playing around with tokio, I have really high expectations for that ecosystem zooming forward as soon as `#[async]`/`await!()` are on nightly.
I know the exact example I want to add to the tokio docs for tokio 0.2, if I can learn how to write it in the first place :P
If you're interested in language design, I'd love some help refactoring [Delegation of implementation (RFC 1406)](https://github.com/elahn/rfcs/issues/1) which is on the [2017 Roadmap](https://github.com/rust-lang/rust-roadmap/issues/17) in the Traits section.
I'd love to help with this somehow
I very much agree with the current roadmap : https://blog.rust-lang.org/2017/07/05/Rust-Roadmap-Update.html I think this roadmap has still a fairly long way to go. On top of that i would like the community to start thinking about standardizing tools, think more about retrocompatibility, large company issues like on-premise library management, etc... I think Rust has still a lot of work to do before I co sider it mature and feel comfortable to introduce it at work (I'm working for a large bank). GUI to me is not what rust is for. Maybe I am wrong, but I just feel like there's too many things to improve at the moment to focus on GUI.
Thank you. Do you ever rewrite public (monorepo))l history? How you handle it?
It would be nice to see the URI part of this broken out into a separate crate rather than included with the http crate since URIs are in no way HTTP-specific. Perhaps there's some overlap with Servo's url crate. If it makes sense to break HTTP types into a standard crate that everyone is encouraged to use, surely it makes sense to do the same for URIs. It would appear that the uri crate name has been abandoned at this point (github repository and docs are gone, last release well over a year ago), so maybe that can be reclaimed for some sort of canonical URI crate.
No, we don't rewrite published history. Mercurial has separate notions of [published and unpublished history](https://www.mercurial-scm.org/wiki/Phases), though, and we do treat that as an important distinction.
I just there up in my mouth a little. I could be missing understanding but you want a web GUI before a native one? What for? 
That's the 2017 roadmap, which seems to be fairly on track, given that's it's still (barely) July. I'm not proposing to abandon those efforts. C and C++ have clear answers to the questions about mature GUI frameworks. Python has clear answers. Rust tries to compete in high and low level programming, and both high and low offer good GUI frameworks. How is Rust not good for GUI? Rust was built for Servo, a browser engine. It will hopefully be great for banks too, and honestly a lot of this year's focus is on things that matter to banks running backend services.
A web GUI could provide "native" interfaces by using Electron with WebAssembly. Performance would be decent I think. A web GUI would allow Rust to replace JavaScript on the web.
Thank you that really helps clarify things. "Project" may not be in use but it is featured prominently in the cargo user guide which led to my confusion.
I certainly could see a `uri` crate doing much more than what `Uri` does in `http`. There are a whole host of rules around different schemes that `http` isn't really interested in, but clearly some people would be.
Nope. It is unlikely to. See https://www.reddit.com/r/rust/comments/6fs5q9/language_servers_and_ides/dinhtiz/ for some of the rationale.
Interesting. I still think that's not smart to just run electron with webassembly. Why not just compile for native? It doesn't really make sense imo. The web GUI JavaScript replacement seems much less likely. 
In a sense, it's not a change, because the `http` crate hasn't existed yet. This crate is built from lessons learned. While I still feel that typed headers are a fantastic thing that Rust can provide, they don't fit in `http`. Some people want them, some people hate them and just use `headers.set_raw` and `headers.get_raw`. And, the typed headers do have an overhead to them (it's very minimal, but it's not free). Typed headers will still exist, just not in the `http` crate.
That is an ambitious list to work through in 3 months.
I think gtk/conrod is good enough but creating gui in code kind of sucks. I think unless we have gui editor, we wont be getting nice gui apps. The main reason Unity3D has monopoly in games is that you can tinker a lot using a editor, dont need much code to keep it running.
I don't think that is true on either count (though I might be wrong, I don't know all the details of the println/format implementation). AIUI, println is just a procedural macro, it just happens that it is implemented inside the compiler rather than outside it. I think that once procedural macros are fully implemented you could write your own println.
Futures are inherently more complex than blocking IO. Even with async/await, there are lifetime capture issues that can be frustrating. While high performance servers are going to need async to be viable, there are many use cases that don't require this complexity (e.g. a program like the RLS that runs on localhost). The synchronous lib will be built on top of hyper and its async IO by running users' blocking code on a cpu pool, but keeping the http code on the event loop. So it should scale up to *moderate* loads, at least. Its also something we can ship as stable much faster than the entire tokio ecosystem and async/await syntax. We want to have the basic "getting started with Rust and trying to implement a little website" story down by the end of the year because its a really good onboarding path, and we want to support those users who don't actually need async *everything*.
Yeah I really need to work on Cargo's docs :(
I think I have a pretty good idea of how to do this synchronously in Rust by scanning a vec of tasks checking for whether it is time to fire and then setting the next wakeup. Where I could use some more specific help is in navigating the very large tokio API. It seems like you could use some combination of a stream + tokio-timer to signal when the event loop should generate the future to do the next task, but I'm having trouble seeing how to combine all of the pieces. I guess I'm spoiled coming from python where there is huge number of varied examples for a lot of libraries. 
You can use glade, a WYSIWYG GUI editor, to design gtk GUIs. I'm not sure if gtk-rs supports it (although I distinctly recall seeing a Builder type in gtk-rs, so it might). 
This is true, but it's also a good reason why Uri doesn't belong in http. It would be very annoying to be writing a program that used both http and non-http URIs and have them be separate types. Imagine writing a git client that needs to parse the repository URL. That could be http/https but it could also be file://, git:// or ssh://. Such a program would be forced to parse the URL into a different type first and then convert to the http Uri once it's determined that it needs to fetch the repository using http. Having a universal Uri crate capable of handling all Uri concerns that's a dependency of http would simplify that.
I know you might be a little biased, but I also know you're one of the well known embedded rust devs in the community. - Would you say RTFM is the go to solution for microcontroller/embedded dev with Rust? Any thoughts on other alternatives like [Bobbin](http://www.bobbin.io/)? - How would you compare it to non-Rust approaches like Arduino and ARM mbed? - Can Arduino boards, Teensy, SeeedStudio etc products be used as long as they have a Cortex-M processor, integrating fine with shields(GPIO)/groves(I2C) additions(sensors, bluetooth, servos) or are there some limitations here?
Is it native and plays nice with system UI conventions and appearance?
While I won't join in the downvoting of your post and I'll admit I'm an English-speaking white male in his early 30s, I have to say that I'm pretty attached to the idea of encouraging that identifiers be consistently in the same language used for keywords and standard library types such as `fn`, `struct`, `enum`, `String`, `i32` (integer), `u32` (unsigned integer), `f32` (floating-point), etc.. Governments and experts discourage [interlangs](https://en.wikipedia.org/wiki/Interlanguage) like "tamglish" (the practice of speaking an arbitrary blend of your knowledge of Tamil and English) because comprehension requires an understanding of both ancestor languages. Given that Rust's keywords are hard-coded to their English-derived forms, allowing non-ASCII identifiers risks encouraging the development of "interlang code" that's less maintainable and more difficult for new project members to read. While I'm certain it'd be less comfortable for me until I got up to speed, I'd choose a redesign of Rust that rebases its keywords on Latin or Esperanto over efforts to sabotage mutual comprehensibility in this way. (Especially given that maximizing code comprehensibility is one of the ways Rust achieves safety.) That said, given that English has replaced Latin as the language of science and is clearly on a trajectory to become the world's linuga franca, I think complaints about sticking with English can be filed under "Some people just happen to grow up speaking the common/trade language as their first language. We shouldn't punish everyone to spite that fact."
**Interlanguage** Interlanguage is the term for an ideolect that has been developed by a learner of a second language (or L2) which preserves some features of their first language (or L1), and can also overgeneralize some L2 writing and speaking rules. These two characteristics of an interlanguage result in the system's unique linguistic organization. An interlanguage is idiosyncratically based on the learners' experiences with the L2. It can "fossilize", or cease developing, in any of its developmental stages. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
It does make sense. A problem at the moment is that the `http::Uri` type is optimized to work well for HTTP2 as well, such that the 3 pieces (scheme, authority, and path) can be combined into a `Uri` without copying. That detail is irrelevant to a `uri` crate, and specific to how URIs are written in HTTP2...
See [japaric/cortex-m-rtfm#41](https://github.com/japaric/cortex-m-rtfm/issues/41) for details.
Any ongoing discussions about those lifetime issues?
For the interested: https://http2.github.io/http2-spec/#rfc.section.8.1.2.3
By the way popping, and then pushing is twice as slow as calling replace because you have to rebuild the heap twice.
I believe they were discussed on the RFC thread. You can't have a borrow that lasts across an `await!` point, e.g: let x = &amp;y; await!(something); f(x); is invalid. There are possibly solutions.
Gtk-rs supports glade, you are right. It is possible to make GUI in rust, then why people don't do it? I think it is important to brainstorm some ideas. - crates.io is nice for libraries but what about binaries? I think rust lacks binary packages distribution channel - theming in gtk? i don't like the default style, is it possible to change it? - we need few nice GUI projects to guide new projects when creating a GUI app - what about games? game GUI editor would bootstrap games projects
Something I've said in [a previous post](https://www.reddit.com/r/rust/comments/6ewjt5/question_about_rusts_odd_code_of_conduct/die78kv/): Rust's CoC basically boils down to: 1. Attack points, not people 2. Be constructive 3. AIM TO BE polite 4. Stay on topic as much as possible (See the linked post for elaboration) It's not fundamentally different than "Quiet in the library or we'll ask you to leave" or "No shirt, no shoes, no service" and I strongly suspect that the hullabaloo around online CoCs is due in large part to people being used to being more uninhibited online.
Big +1 There are a lot of RFCs that haven't been implemented yet: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AB-RFC-approved Those are a good place to start for anyone that wants to help. There's a lot of compiler stuff in there, which can be hard to get started with. Some of them don't look [too difficult](https://github.com/rust-lang/rust/issues/43038) though.
For checking the header, couldn't you use `flags_7: verify!(be_u8, is_not_nes2)`, with this definition? ``` fn is_not_nes2(flags_7: u8) -&gt; bool { flags_7 &amp; 0b0000_1100 == 0b0000_0010 } ```
I think the main problem with gtk-rs (any many other crates on crates.io) is that they depend on system resources that they can't declare as dependencies in Cargo.toml. It is then left on the developer of the library (and any consumer of such library) to install and keep track of those undeclared dependencies. Users must also have these dependencies installed. It's too much friction for all involved compared to libraries that only depend on baseline system features. That said, I still believe gtk-rs is the currently the best GUI library available to rust developers, at least on systems where gtk can be installed without a hassle. This situation might improve when/if Rust finally gains dlopen-like support, and libraries can opportunistically use the best library on a given system.
[native-windows-gui](https://github.com/gabdube/native-windows-gui) looks like a great project for windows. Now we need something for macos. 
&gt; Would you say RTFM is the go to solution for microcontroller/embedded dev with &gt; Rust? I would say no or at least not yet. Embedded is very vast; for some areas RTFM is not usable right now. For instance, if you need to do wireless networking like WiFi or BlueTooth then you'll have to use something else. The reason for that is that there are no (standalone) WiFi / BlueTooth drivers written in (pure) Rust which means you'll have to use a C driver / library / framework. Vendors usually ship frameworks (a framework dictates how the application is build, i.e. it includes its own build system) rather than isolated C libraries; RTFM needs full control over the vector table of the microcontroller but C frameworks usually use the vector table extensively and provides no access to it so they are not compatible with RTFM. There's also [Tock], an embedded OS written in Rust. There's a capsule (a Rust driver) for using BlueTooth but again that can't be used with RTFM. The reason is similar: the capsule has a hard dependency on the Tock kernel and both the kernel and the capsule make extensive use of the vector table so RTFM can't use it. (The concurrency models are different too: threads vs tasks so it makes little sense to use them together) [Tock]: https://www.tockos.org/ TL;DR a ecosystem of Rust drivers not tied to runtime / kernel / particular concurrency model needs to develop to make RTFM more usable in more places. &gt; How would you compare it to non-Rust approaches like Arduino and ARM mbed? They can't be directly compared. RTFM is just a concurrency framework; it dictates nothing about how you should do I/O or how you should organize your drivers. OTOH, Arduino and ARM mbed are complete frameworks that ship with libraries to do I/O and are rather opinionated about how to do concurrency. The usual concurrency model I have seen in these C frameworks is: you have no access to interrupts, all your code goes into a main / event loop, non-blocking-ness is obtained through hidden buffers that are implicitly flushed in interrupts or using the DMA and multitasking is obtained using threads. Concurrency wise I'd say RTFM is more flexible: you can implement the other model with it. Except perhaps for the threading aspect but when async/await is implemented in Rust you should be able to do cooperative multitasking in `idle` in a way that is as "straight line code"-ish as threads while likely being more efficient due to less and more efficient context switching. &gt; Can Arduino boards, Teensy, SeeedStudio etc products be used as long as they &gt; have a Cortex-M processor, integrating fine with shields(GPIO)/groves(I2C) &gt; additions(sensors, bluetooth, servos) or are there some limitations here? There are no limitations around hardware. Currently RTFM supports Cortex-M and MSP430 microcontrollers but I think it should be straightforward to port it to the AVR architecture. As I said RTFM only does concurrency so the be able to use the hardware to do I/O you'll have to get driver from crates.io (Rust) or from a vendor (likely C), or write your own.
There was a recent blogpost with a v2 of the RTFM(Real-Time For the Masses) framework, so just go to the blog link of this thread and check the latest post. It now supports Cortex-M0 :)
Will it be a dependency of `hyper`?
Thanks for the update! I'll be sure to try it out.
There was a nice article on HN that circulated recently about how to confuse webservers with interesting or slightly malformed requests (which I cannot for the life of me find a link to…) Having `Request` expose "`Uri`" the way it does seems like a risky thing to do, having just read that article; IIRC, some of the confusion was middleware not recognizing proxy requests from origin requests. Origin requests, at least to me, are so vastly different from proxied requests that you need to know which one you're handling; it seems ripe for someone just doing `a_request.uri().path()` and then making serving decisions off of that — and indeed, *the example on the main page does exactly this.* This also implies that the `Uri` type isn't really URIs; that is, it does not describe the same set of values as the `URI` production in [RFC 3986](https://tools.ietf.org/html/rfc3986), the RFC that specifies URIs. I think I'd feel more at home with something like, enum RequestTarget { OriginForm(Path), AbsoluteForm(Uri), AuthorityForm(Authority, maybe?), AsteriskForm, } This would more closely match the RFC, and allow the extraction of the `Uri` type to a common crate (since it could now actually contain only a URI, and not other things required by HTTP's `request-target` production.) There is a `.origin_form(&amp;self) -&gt; Option&lt;&amp;OriginForm&gt;`, but it returns `Some(…)` when the request is in `asterisk-form`! (My suggestion above does make correctly handling an origin request slightly harder, as my reading of the spec says that an origin server should handle both `origin-form` and `absolute-form` where the hostname is the origin server's hostname.) (Yes, there is the `.origin_form` method, but that appears to also work on `asterisk-form`…) For `Response`: how is trailer header data (not the closely related `Trailer` header) represented? (I readily admit that I've never seen uses of trailer headers, but I *have* seen use-cases for them.) My 2¢. (I do think the idea of having a common-home for stuff like this is an *excellent* idea. But if you don't want people to re-invent the types, they need to be rock solid.) (I also wonder about the wisdom of `Method` implementing `is_safe` and `is_idempotent`, even for methods it doesn't know about… (it returns the safe defaults of "not safe" and "not idempotent", which isn't that bad.)) (Lastly, `HeaderValue` permits the creation of headers containing 0x7f, which I believe isn't allowed by HTTP 1.1 (or any version); neither the `field-vchar` production (the "v" being for "visible", though really, "printable", since it includes space) or the `obs-text` production have 0x7f in their terminals.)
That may be part of it but I wouldn't narrowly limit to online things. Most of people's reasons they give for their dislike is related to events that have occurred in real life, not the words they like to use online.
It's based on SDL2, so no not really.
Cheers, thanks for the insight.
It's good to hear that the synchronous stack will be built on top of the async libs. A major challenge that consumes the Python ecosystem is the non-interoperability between existing synchronous libraries (both client and server ones) and the new `asyncio` ecosystem (or the `twisted`/`tornado`/etc. ones for that matter).
Web GUIs are not native.
&gt; I would say no or at least not yet. Embedded is very vast; for some areas RTFM is not usable right now. Thanks, I appreciate that. Is there a rough time frame you think that opinion would change? Is there anything currently for Rust that might have some advantages over RFTM? Tock looks interesting, it's GPOS not RTOS though from what I understand? I don't need an RTOS but my interests are usually with deterministic timing which RFTM seems suited for running bare metal? &gt; TL;DR a ecosystem of Rust drivers not tied to runtime / kernel / particular concurrency model needs to develop to make RTFM more usable in more places. **I guess the likelihood of that happening is a good while off in years?** I've not developed drivers, so no idea how much work would be involved for WiFi or Bluetooth say. Presumably an open-source driver might have some code that bindgen could help get someone started with a port. **What about connecting another board that focuses on wireless that doesn't run Rust?**, such as those ESP8266 / ESP32 boards? Network related code might be handled on that in Lua with Rust on the main MCU handling sensors and servos fine? I've seen some boards like [BeagleBone Blue](http://beagleboard.org/blue) that has a Cortex-A8 and a Cortex-M3, no idea if RTFM is as straight forward as boards on your post to get working with that and how wireless is handled(presumably via the A8), I'm guessing RTFM could work on such a board and communicate with the A8 somehow, similar to how I described with the ESP boards. [Photon boards](https://store.particle.io/) have had Rust support for a while, I noticed you've been involved with that too. While they do not run pure Rust, **I could still develop for those with Rust instead of C and have a good experience? They seem to have wireless support too.** &gt; They can't be directly compared. RTFM is just a concurrency framework; it dictates nothing about how you should do I/O or how you should organize your drivers. Reading about RTFM I was under the impression from the blog posts that I could get a board going and controlling LEDs, reading sensor data, controlling a servo etc. I only have limited experience with an Arduino project from over a year ago where Rust didn't seem to be in as good of a state for embedded(at least from research seemed like a lot more effort to get started). My project was fairly basic using a shield with serial RX/TX signals to read/write RS485 protocol to a larger product and control it. I wrote in C a packet parser/writer on the MCU that had to be deterministic to sync with the larger products timings and that MCU connected via uart-usb to my PC to a service that handled wireless networking to mobile devices(UI to control the larger product). My experience with C on the small project had me seek out Rust in the first place :) Your blogpost on logging is great btw, I remember uart strings taking too much time for debugging that they introduced bugs themselves(took a while to realize that). So uhh.. **what other common functionality is required that the quickstart doesn't touch on?** I know Arduino has a bunch of libraries(and I guess drivers), it's been a while, I remember configuring baudrate, toggling LEDs, accessing GPIO pins, using UART and flushing the buffers, I think you touch on all this. I2C iirc was also supported, so SeeedStudio products that use their Grove connectors(I2C) just need to be able to communicate over that to use their add-on products(sensors, servos, etc)? &gt; As I said RTFM only does concurrency so the be able to use the hardware to do I/O you'll have to get driver from crates.io (Rust) or from a vendor (likely C), or write your own. Perhaps I was mistaken about GPIO/I2C, as this seems to suggest RTFM has nothing to do with that? Are you referring to this difference?: gpioe.bsrr.write(|w| w.bs9().set()); vs LEDS[0].on(); If that is the equivalent of what you mean by implementing a driver, for LEDs, sensors and servos, perhaps that isn't so difficult to put together for my own use-cases, but Bluetooth/WiFi I'd imagine is more complicated.. I don't mind the former much, I remember specifying LED and a few other things by their pin and a 0 or 1. That API(before the more friendly one in 2nd example) came from `svd2rust` and became the `stm32f30x` crate from what the quickstart seems to imply? **As long as I can read/write with that to control a servo motor or read sensor data I'd be happy.**
It actually took me an embarrassingly long time feeling confused why Hyper was being left high and dry until I realised what the crate was actually about.
actually, you should try to make a web app. its really easy to make something not ugly and reliable/maintainable with rocket/handlebars/bootstrap.
i saw that relm has some easy tickets, maybe start there :)
The intention is for these types to be all over common APIs. Returning an "httptypes::Result" doesn't feel as good as returning an "http::Result", and they want using these types to feel good :)
Okay, but Rust doesn't yet have procedural macros in any real sense. Rust shipped with a macro system, which conferred a lot of benefits, but not enough to do `println`... but we implemented it anyway.
Wow, nice to see Specs in action!
True. There is a worrying trend toward simplistic, absolutist thinking on both ends of the political spectrum and that's not limited to online behaviour.
I am also sometimes using intellij just for refactoring, but I can't seem to make the switch from emacs. The most important feature for me is to quickly switch between different layouts http://i.imgur.com/ovV0Qv3.gif I often work with ~6 files at the same time, also note how every layout has a different window layout. I have sort of tried to emulate that with tasks in intellij but that did not work out as expected. It is really sluggish and buggy, I don't think it is intended to be used that way http://i.imgur.com/0Bhxdcx.gif Maybe there is a better way? 
You mean, with wasm/asm.js? Something like [domafic](https://github.com/cramertj/domafic-rs)? Perhaps there's a way to abstract between relm and domafic (they both have a Elm-inspired API)
Unfortunately it's not quite possible because functionality of built-in reformat action is used in almost every edit/refractor/snippet action in Intellij world Want to insert new line? Formatter is fired in special mode to determine potential alignment etc... 
Currently not, but it is possible to implement this, though we're not planning it in near future 
What you could generate xref html representation of the source which would have an option to show the macro expanded version with the parameters highlighted in the resulting source? Macros can't be bad because the tooling to view them is bad. That would be on the tooling, not the macros. Otherwise just don't use them.
&gt; Imagine how we would have to engineer println On a slightly related note I watched an incredible video yesterday of someone implementing `printf` using Idris' dependent types - [see here](https://www.youtube.com/watch?v=fVBck2Zngjo). Super readable, concise and integrates nicely with and benefits from existing language features like the total type system and the repl (and in turn `:doc`, `:t`, etc). I think Idris is a nice example of a language that is quite simple at its core but still has enough flexibility that it doesn't require macros or compiler magic for a feature like this. That said, I believe its reflection story is still unstable, and I don't think there's a nice way to do things like `derive` yet without unstable features. I think I agree that macros were probably the right choice for Rust at the time - at least it's a hack we can all standardise on :)
Thanks for letting me know :) I tried it out earlier today and was really impressed with the Rust functionality, the only issue which really affected me was `error_chain` didn't appear to work.
I watched the video, tl;dw for the curious: - optimizing git-packing/GCing on the server (by leveraging the Google infrastructure to do these things at scale, in parallel, in the background, not something everyone could do) - reducing object counting time by using bitmaps, which is an efficient data model to store reachable commits given a certain commit (Btw, two problems that mercurial doesn't have, by nature) - how they needed to write a python wrapper around subrepos, no clear way forward, git needs them to scale but it's a burden to maintain and everyone hates them (UI was even worse at that time) - streaming bundles for clones from a CDN (instead of having them served by the VCS) it's been there in mercurial [for some time](https://www.mercurial-scm.org/repo/hg/rev/5a95fe44121d), enabled for every hg repo on bitbucket for several months Nothing too fancy overall. I wouldn't be surprised if they transition android to a monorepo within a couple of years.
&gt; Besides, Swift allows emoji in identifiers, so clearly they're in no position to be dictating good design principles to anyone... On the other hand, let λ = 5 print(λ) is valid Swift, while let λ = 5; println!("{}", λ); is invalid Rust. So I'm not sure we're in a position to be dictating good ident rules to anyone either.
I implemented the improvements suggested, e.g., I made the Ord implementation for ScoredItem work with f64 and I switched to using peek_mut to update the heap. These suggestions improved performance quite a bit, however, the rust implementation is still way slower than the Scala one.
That's not a clear win. If I wanted to work on that code, *I can't type the name of that identifier.*
Am not saying macros are bad. Am saying that the lack of good tooling support for them makes them a non trivial amount of extra cognitive overhead when I have to check the source. 
Yeah, we don't support macros yet, but it's slowly being implemented piece by piece :) @alygin did some work on it but his PR seems stalled https://github.com/intellij-rust/intellij-rust/pull/1291
Linux: `ctrl shift u 0 3 b b space`. Windows: `alt 0 3 b b`. Mac: `Option 0 3 b b`. **People who are Greek: [just hit the key](https://en.wikipedia.org/wiki/Keyboard_layout#Greek)**
**Keyboard layout: Greek** The usual Greek layout follows the US layout for letters related to Latin letters (ABDEHIKLMNOPRSTXYZ, ΑΒΔΕΗΙΚΛΜΝΟΠΡΣΤΧΥΖ, respectively), substitutes visually or phonetically similar letters (Φ at F; Γ at G) and uses the remaining slots for the remaining Greek letters: Ξ at J; Ψ at C; Ω at V; Θ at U). Greek has two fewer letters than English, but has two accents which, because of their frequency, are placed on the home row at the U.K. ";" position; they are dead keys. Word-final sigma has its own position as well, replacing W, and semicolon (which is used as a question mark in Greek) and colon move to the position of Q. The Greek Polytonic layout has various dead keys to input the accented letters. There is also the Greek 220 layout and the Greek 319 layout. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
You're a good bot I don't know why you're getting swarmed.
Yeah, well that doesn't work for me. Besides which, you can't expect people to type like that. Besides which, if those're fixed at four digits, they won't work for scripts outside the BMP.
Good on you, mate. That is the kind of *positive* attitude we need.
Wow, that's really impressive. Slightly OT - do you think that juggernaut will face the same issues as leaf did? That is getting crushed under tremendous weight of tensorflow?
Working on finishing up [chapter 3 of my book](https://www.manning.com/books/rust-in-action) on productive Rust programming/intro to systems programming. Wow, it feels weird to be talking publicly about it!
That's a really impressive undertaking. Any particular reason why the Python or Ruby implementations didn't suit?
Isn't that the same as this de-sugared version: let x = &amp;y; something.map(move |_| { f(x); })
Sure, tooling could be improved.
People, calm down! The world is much more varied than we'd like to admit. Differing opinions need to be entertained and indeed studied carefully. Work through the rhetoric, and you might find something enlightening. EDIT: Apparently too much sensibility for this community. Heh.
Yes it is (or close enough), and if you try to return that future you'll get lifetime errors.
Yes I take a look but I did not try to use it. Correct me if I am wrong but since hyper and reqwest are now tokio based, it sounds ridiculous to use it if you are using blocking socket too. Tokio looks great and I try to use it but I need more doc on it, especially on how to write timeout.
I use emacs almost soley for magit.. I like other editors but I my speed with spacemacs is fast for me especially with rustfmt on save and invoking cargo it's all fairly ergonomic. I suspect I can do many of the things I'm used to but it'd require me to learn new shortcuts :/
I also heavily use magit, it is by far the best git tool I know and I probably will never switch away from it. You can also use the leader key in intellij idea. This is currently my .ideavimrc file let mapleader = " " map &lt;leader&gt;=G :action SaveAsNewFormat&lt;CR&gt; map &lt;leader&gt;ff :action GotoFile&lt;CR&gt; map &lt;leader&gt;sc :action GotoClass&lt;CR&gt; map &lt;leader&gt;o :action tasks.goto&lt;CR&gt; map &lt;leader&gt;c :action CommentByLineComment&lt;CR&gt; map &lt;leader&gt;i :action ShowIntentionActions&lt;CR&gt; map &lt;leader&gt;fer :source ~/.ideavimrc&lt;CR&gt; inoremap &lt;C-s&gt; &lt;esc&gt;:w&lt;cr&gt; nnoremap &lt;C-s&gt; :w&lt;cr&gt; set surround 
Yeah, working with all windows uniformly and conveniently is one feature I miss from Emacs as well. However, my workflow in IDEA is a bit different from Emacs, so I don't need that feature urgently. The workflow is rather idiosyncratic, so it most likely will not fit you, but it might contain some interesting ideas :) 1) I disable editor tabs in the settings, so that they don't stand in my way. If I want to see a *thing* in the editor, I use `Ctrl+N` or `Ctrl+Alt+Shift+N` or (comparatively rare) `Ctrl+Shift+N`. So, my workflow is based on having a single thing on the screen at a time and fast switching between different points of focus. If I want to find something in the same file, I usually use `Ctrl+F12`. If I were to give one advice about learning IDEA, it would be "disable tabs, so that you are forced to navigate with shortcuts" :) 2) Sometimes I need to view two pieces of code side by side. While IJ has "split-pane" view, I prefer to delegate arrangement of several windows to my window manager. So if I want to view `Foo` and `Bar` side by side, I `Ctrl+N &gt; Foo`, then `Win+Left` to tile the current window left, then `Ctrl+N &gt; Bar` and then `Shift+F4` directly from the popup to open a new editor window with `Bar`, and then tile it to the right with `Win+Right`. 3) Sometimes, I want to work with a set of related items, here, `Ctrl+B` and `Ctrl+U` helps me to navigate "forward", and `Ctrl+Alt+Left` and `Ctrl+E` helps me arrive at the point I was previously at. 4) I use "autoscroll from source" option to keep my project view (`Alt+1`) synced with the currently open file. And I move project view to the right, so that closing and opening it doesn't move my code visually on the screen. 5) I store a layout with all toolbars closed as a default, and use `Shift+F12` to quickly focus on the editor. Hope that's useful! :) 
I always though that the core team members spend too much time on RFCs. I have a full time job and I have a very hard time to follow all the discussions here on reddit and the official forums. I can only image the huge amount of time the people spend on reading the endless discussions on GitHub for each of the many RFCs out there. I think there should be periods of discussion and periods of implementation but in a more rigid way. Something like "We don't accept anything new until all the accepted RFCs are implemented." 
Thanks, that's actually quite helpful. I'll see if I get time to ease into it. I use Rider a bit for work when I'm not using VS2017 and I'm not negative to the idea of using IntelliJ IDEA but as you say, magit really is just too good. I sometimes use emacs for git.. :P
Fair enough. Better to have and not need than to need and not have.
Not to mention the [infamous Go example](https://www.reddit.com/r/rust/comments/5penft/parallelizing_enjarify_in_go_and_rust/dcsq64p/) with "template" code that can still be statically checked. &gt;It doesn't. That's just a "template" file, which I use search and replace in order to generate the three monomorphized go files. &gt; &gt;If you look closely, those aren't angle brackets, they're characters from the Canadian Aboriginal Syllabics block, which are allowed in Go identifiers. From Go's perspective, that's just one long identifier. 
I thought this too, but then I read another comment in this thread: &gt; The intention is for these types to be all over common APIs. Returning an "httptypes::Result" doesn't feel as good as returning an "http::Result", and they want using these types to feel good :) https://www.reddit.com/r/rust/comments/6qr9mf/announcing_the_http_crate/dl00rnt/ That has me convinced the crate should be called http. Could it be confusing? Maybe, but I think that's a relatively small hurdle, and probably should be the first thing addressed in the README with an example of how to use it with `hyper`. At the end of the day, as a user, I'm just going to google "making http requests in Rust" or something, and start with some stackoverflow or documentation snippet. I think there's focus on the name of the crate because it's being announced here, but I suspect it'll be no big deal in the long run.
Thanks! Well, that's a good question! I don't really know. What I'm actually trying to do is writing Rust, compiling to Emscripten and run that in a web browser. It's more of an experiment rather than a production ready thing but I hope to improve Juggernaut and the demo page.
There are quantum resistant signature schemes with Rust bindings, but it isn't thought that they will be needed for another decade. For the next ten years or so, the current signature schemes are thought to hold, by professional cryptographers. They can be combined with quantum resistant signatures to get a chance at extending the time indefinitely, and although these algorithms are immune to Shor's algorithm they are not well studied in general and other quantum or classical attacks could break them, as has happened at least twice against successive iteration of the ntrusign scheme, though I believe the current version isn't yet known as practically defeated via any known cryptanalysis. The signatures are up to a bit over a kilobyte though. Signatures provide reputability whereas hashes provide integrity for a single version for a single build of a project with trust put into its cargo.lock. The first time you get a signature key you have something called TOFU, trust on first use. The point is that if an attacker hadn't already compromised the channel, they will not be able to compromise crates purported to be by a given author through trivial web application level hacking, but rather will need to perform computationally impossible cryptanalysis or do more sophisticated and fine grained targeting of developers to get private keys that are decentralized over very many computers but also with various degrees of security competency, it's a much better situation than relying on hash snapshots for single versions and web application logic being sound, or software logic all the way below that, I mean it would simply be a more ideal situation to have a cryptographically secured package management system even with trust on first use, and also public keys can be distributed through many channels making it more difficult for an attacker to compromise all of them, and a person who makes a package using many other crates can sign the crate keys that had signed the packages that he used and create a sort of web of trust. I just see a lot that can be done in this area and it is a pretty important area, because even if you secure from the attacker pwning you with a buffer overflow or double free or what have you, the attacker will try to find the path of least resistance, so it necessitates having a highly secure package management system imo, and also substantial auditing being done on the standard Rust development environment rather than trusting individuals to do anything that isn't audited by at least one random other person before it is added to the main compiler. You always need to remember essentially that security has very very many different fronts, and that simply protecting the application level attack surface from classes of attack does not spell the end of security issues associated with a language. One thing I'm not certain of is if there is a GPG secured security bug reporting channel to the Rust security developers, because such channels should certainly encourage and offer the use of GPG for encrypting information on potential security flaws such that they can be fixed prior to an interceptor of the intelligence abusing them. You could even air gap the decryption of such messages, and using top tier operational security practices like this is something that I think the developers of security oriented languages should do, or at least should have awareness of. 
I do agree with other users in that Uri should probably be factored out, but apart from that I like what I'm seeing. I think it's a good step on the right direction. Any chances we can see the same done for http2? Seems like it would be quite different, but it might kickstart a good ecosystem of http and http2 libraries for rust. As an example of what it could look like, I kind of like Hyper-h2 for Python, as it is completely decoupled from IO and it just does the http2 parsing and processing, using an evented abstraction. A link to their docs in case anyone is interested: https://python-hyper.org/h2/en/stable/index.html
Did you try to fuzz your parsers? [cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz) can help :)
Perfoming synchronous calls on asynchronous APIs is relatively easy and performant, the other way around not so much. By having fundamental core APIs target the tricky async part and layering a sync API on top of it you can write and maintain a single implementation while catering for both worlds and allowing users to move between these idioms when the need arises. Most people often complain about the associated cost of doing synchronous logica using asynchronous APIs, but in practice it often turns into a win when one starts adding things like timeouts when interacting with external services (local or remote). The only part about using tokio that makes synchronous calls more of a hassle than you really want is the instantiation of 'tokio_core::reactor::Core' and passing a handle to it. I think allowing this part to be more implicit (`Into&lt;Option&lt;..&gt;&gt;` or so) would prevent a lot of boiler plating for synchronous users. The async as sync logic is mostly a case of calling '.wait()', which should make most APIs pretty easy to use without a dedicated synchronous API wrapper. __Edit:__ Sorry, I don't know how I misread your comment. Somehow my mind interpreted it as saying you don't wanted to use tokio when a blocking socket would suffice.
&gt; whilst at the same time not getting anywhere near the love it needs I mean, the plan always was that `macro_rules` is a stop gap, and the real macros 2.0 will happen eventually. Apparently it's coming soon, actually. Or at least the initial bits. The basic plan for macros 2.0 has been known for a while, though the details are still being worked on. It kinda makes sense in this context -- features are forever, so if macro_rules is "mostly good enough" for now and "great macros" will eventually replace macro_rules and be better for this, it shouldn't be a problem. ----- In case folks don't know the basic plan, it's like this (this is what I recall; this may have changed recently): - More general proc macro support (currently it's just derive, but this can be expanded to other things) - allow proc macros to be defined in the same crate - have an ecosystem of crates that help parse and reserialize the proc macro input/outputs. This includes better quasi quoting In this situation "regular" macros are basically a special case of proc macros, and could be implemented as a library (or special cased), but it kinda gives you a sliding scale as to how much macro magic you want. There will probably be a `macro` item that can be used for this.
How does this differ from the other rust gRPC library https://github.com/stepancheg/grpc-rust?
I don't think that refutes /u/Quuxy's point. Besides, Swift is worse than how /u/Quuxy says on this matter. In swift some groups of unicode characters are identifiers, _and some are operators_. See https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/operator-head
Not *really* related to the post but what's Kotlin like as a language?
imprecise statements should be ignored. That's all. If there is an issue, just name it that we can talk about solution. Else it's waste of time. This quote is negative PR imho.
I'm certainly highly interested in GUI. I'm going through the process of implementing a dedicated client server forum that is separate from a web browser, and which is more like a hybrid between a forum and IRC, and am taking advantage of the abilities offered by a client side program in terms of security which can be massively improved on from the web browser to website forum paradigm, which is where essentially everything is regarding forums such as phpbb and so forth, contrasted with IRC which has far more dedicated applications and a lesser focus on web interfaces. In any case, one of my goals is to use Rust for as much as possible, so that my application will be highly resistant from memory corruption vulnerabilities and so forth, but for the forum to also be attractive and modern it will need a GUI created for it and I would like to use pure Rust for this and the Conrod library looks like it will be perfect seeing as I want the forum interface to do live updates rather than needing to hit a refresh button, but the library looks extremely underdeveloped and as if it may be hard to make a featured and pleasant GUI of such complexity with. So far I've managed to use Rust for everything other than one cryptographic library and the database management system which will be postgres. 
"Not being able to combine if let with some other condition" is filed under "Annoying things that cannot be fixed", but I still hope we can fix this. [RFC issue #929](https://github.com/rust-lang/rfcs/issues/929) tracks this problem.
&gt; Linux: ctrl shift u 0 3 b b space. Only in GTK
&gt; tuple assignments. I’d like to be able to assign multiple variables from a tuple but it’s not possible now. And maybe it would be nice to be able to declare several variables with one let What? I'm pretty sure assignment is just a regular pattern match. `let (x , y) = (5 , 7);` works for me in the playground.
Yeah, I was about to comment asking about that.
Lots of good criticisms here. On the topic of the `type` keyword, I understand that `rustc` internally refers to type variables as `ty`. Perhaps this is a reasonable alternative?
At least it's got a great name. It's also really interesting to see Rust being used for numerically intensive workloads. I hope that you lean a lot from your experiments :)
&gt; Rust does not allow you to mutably borrow parts of the same array even when it should be completely safe like `let mut a = &amp;mut arr[0..pivot]; let mut b = &amp;mut arr[pivot..];` isn't that just `split_at_mut`?
Hey, check out `split_at_mut`! It's exactly what you want with regards to mutable arrays. You could also write a `swap_at` function that internally uses `unsafe`, since the only place that can be unsafe is if one of the two supplied indices are OOB. That's not in the stdlib but it's not anathema to Rust's safety guarantees.
https://doc.rust-lang.org/std/primitive.slice.html#method.swap
Does any language have this, though? I can't name one with native cross-platform UI on Windows, Linux, macOS, iOS and Android.
Completely agree.
This rant brings up a lot of already-known issues that have fixes in the works, while other issues have solutions which may not be intuitive or easy to discover, or are unstable. The author makes a quip at nightly, but in my experience API breakages aren't as often as you might expect, especially compared to pre-1.0; the contract with nightly is that breakages *can* happen, not necessarily that they always do. The rest is perception. &gt; If you care about systems programming and safety you’d have at least one or two functions to convert type into a smaller one (e.g. i16/u16 -&gt; u8) and/or check whether the result fits. This is the purpose of [TryFrom](https://doc.rust-lang.org/nightly/std/convert/trait.TryFrom.html) though it is unstable. &gt; Macros system is lacking. [...] The author might be interested in [procedural macros](https://doc.rust-lang.org/nightly/unstable-book/language-features/proc-macro.html) which are on the path to stabilization, though it wouldn't really help with the compile time issue. &gt; There are many cases where compiler could do the stuff automatically. For example, I can’t take a pointer to const but if I declare another const as a pointer to the first one it works fine. In my opinion compiler should be able to generate an intermediate second constant (if needed) by itself. This is a simple confusion on the semantics of statics vs constants. You can take a reference/pointer to a `static` because it is assigned space in the binary. `const` is purely a compile-time abstraction which is replaced with its value, like you would do with macros in C. &gt; Same for function calling—why does bitread.seek(bitread.tell() - 42); fail borrow check while let pos = bitread.tell() - 42; bitread.seek(pos); doesn’t? This is a known issue and is being fixed, first by a special-case in the borrow-checker (because it's a common pattern) and then in general with non-lexical lifetimes. &gt; `type` keyword. "kind" is used a lot. You can also do "type_", though that looks tacky IMO. &gt; Not being able to combine if let with some other condition (those nested conditions tend to accumulate rather fast); This is supported in `match` with [Pattern Guards](https://doc.rust-lang.org/1.6.0/book/patterns.html#guards). &gt; even when it should be completely safe like let mut a = &amp;mut arr[0..pivot]; let mut b = &amp;mut arr[pivot..];. Then you do `let (mut a, mut b) = arr.split_at_mut(pivot)`. The more general problem of taking disjoint slices/indices is something that could be addressed better, though. The author seems averse to external crates (not surprising coming from C/C++) but Rust/Cargo make it so easy that I don't think twice about it anymore. &gt; And only dream about being able to invoke mem::swap(&amp;mut arr[idx1], &amp;arr[idx2]);. Yeah, that's `arr.swap(idx1, idx2)` 
That is why the word is in quotes. You can make them look native.
Why do people desire these traits? Wouldn't a simple CSS theme do the job?
Just as you can make Java look native but there are many tradeoffs, like speed.
But that would make all the updates work server side which isn't ideal. I want to avoid javascript.
I think the author means something like let mut a; let mut b; (a, b) = (4, 5);
Compile times, yet again. I consider rustc's slowness to be a borderline existential threat to Rust. Firefox only has a small amount of Rust code in it but it's already ballooning out build times :(
JavaFX feels pretty quick and has a very nice api IMO.
GTK has the best theming support out of all toolkits that I know of. Lookup adapta gtk theme if you like material design.
Well you can do `let (mut a, mut b) = (4 , 5);`. To me it seems weird to declare a variable but not define it. I'm not sure what that even means.
QT looks native I think. I don't know if it works on iOS or Android though.
It does a halfway decent job of it, but it still has many inconsistencies.
That's different. You declare and initialize two variables. The other code is meant to do something like this: let mut a = 0; let mut b = 1; // Use a and b somehow let t = get_some_2_tuple_somehow(); a = t.0; b = t.1; // Use a and b again That is, you have two (or more) mutable variables which have already been defined (and likely initialized as well), and a tuple and you want to unpack that tuple into those existing variables. I had left out any usage of `a` and `b` to keep the example short.
https://github.com/pingcap/grpc-rs is a wrapper of gRPC official C ABI, from thread dispatch to http2 is not rust they have two blog about this project: - [gRPC-rs：从 C 到 Rust (gRPC-rs: from C to Rust)](https://mp.weixin.qq.com/s?__biz=MzI3NDIxNTQyOQ==&amp;mid=2247485070&amp;idx=1&amp;sn=848713a3cc212f76db7414ef39ea134b) - [深入了解 gRPC：协议(gRPC protocol insight)](https://mp.weixin.qq.com/s?__biz=MzI3NDIxNTQyOQ==&amp;mid=2247484946&amp;idx=2&amp;sn=f5d52103e363f9ca6a5facfa9ce55fb5) 
&gt; I can’t take a pointer to const but if I declare another const as a pointer to the first one it works fine. Wait, why _does_ this work? (Because it does. [Playground link](https://play.rust-lang.org/?gist=718932ef15b26b3bf78a60b4d3a75b05&amp;version=stable))
Sorry, haven't been on Reddit for a while so I just saw this. I'm of the mind that they're actually *not* totally orthogonal. They're also far from identical, of course, but there's some overlap: different experiences lead people to emphasize different things, and social diversity is part and parcel with that. And in any case, the goal here is to move *both* forward, and even if they were totally orthogonal, we have limited time and resources, so an initiative that can tackle both at once makes good sense.
For me the biggest problem is doing the equivalent of this C code which is very common: int ret = some_function(); if (ret &lt; 0) { // Handle error. return; } // Continue here at same indentation level. In rust `some_function` would return `Result` and your options are value = some_function()?; // Can't handle error :( OR result = some_function(); if let Err(error) = result { // Handle error; return; } // Must use unwrap :( let value = result.unwrap(); OR match some_function() { Err(error) =&gt; { // Handle error - one more level of indentation :( return; } Ok(value) =&gt; { // Too much indentation :( }
Also you can do now: if let (Some(foo), true) = (opt, x &gt; 42) { //... } The problem is that one can't write something like foo &gt; 52, but I think this is still useful.
You could do this: let mut a = 0; let mut b = 1; // Use a and b somehow let (mut a, mut b) = get_some_2_tuple_somehow(); // Use a and b again 
stepancheg grpc is a pure rust implementation but not ready for production. We tried to use it in TiKV but met some panics so we decided to wrap gRPC c core directly. 
stepancheg's gRPC is pure rust implementation while PingCAP's gRPC is a wrapper of official c gRPC implementation. And besides PingCAP's gRPC implementation is more complete and stable. Disclaimer: I work at PingCAP and we replaced his gRPC with our own wrapper two months ago.
&gt; Don’t tell me about `ChunksMut`, it does not allow you to work with them both simultaneously. [Like this?](https://play.rust-lang.org/?gist=5fa286f8a4caf2f442f95686d383cdda&amp;version=stable)
If "the job" is "look like a native UI", as per the OP's requirements, then no, absolutely not in the slightest.
I mean, the point at which you want the same UI in Windows and iOS is the point at which you're complaining that your dessert topping isn't also a floor wax. If you cut the mobile devices out, then any language with wxWidgets bindings qualifies.
Skimming the API I noticed that the request::Builder builds a Request after calling Builder::body&lt;T&gt;(&amp;mut self, body: T). The docs say this consumes the builder and that you must not call this method twice but I wonder why in this case body does not take self instead of &amp;mut self?
The link links to a PDF file for those who want to know.
That has completely different semantics though, consider this: let (mut a, mut b) = (0, 0); for thing in thang.iter() { (a, b) = thing.do(); } // use a and b here edit: removed passing `a` and `b` as parameters to `do`, because apparently that confuses some people.
Somewhat new to Rust here. His point about the macro system being unable to express something like that sequence of tuples was confusing. Would something like this not work? Or is he trying to do something different? macro_rules! quad { ( $a:expr, $b: expr ) =&gt; { (($a,$b), (-$a,-$b), ($b,$a), (-$b,-$a)) } } fn main() { let (a, b, c, d) = quad!(3, 4); println!( "({} {}) ({} {}) ({} {}) ({} {})", a.0, a.1, b.0, b.1, c.0, c.1, d.0, d.1 ); }
 let value = match some_function() { Ok(value) =&gt; value, Err(error) =&gt; { // process return; } }; That is in essence what the `?` operator and [`try!` macros do](https://doc.rust-lang.org/src/core/macros.rs.html#329-336). ~~You could probably code your own `try!` which takes a block of error-processing code instead of just calling `From::from(error)`.~~ [#30679 tells me that this may not be possible with basic macros](https://github.com/rust-lang/rust/issues/30679) not sure it'd work with procedural ones :/
Feels like array initialization should really have a macro in std. There are crates for this, but without them you're basically stuck writing unsafe. Personally, I don't care about using unsafe here, but it often leaves people with a feeling of "aren't I supposed to not have to use unsafe?" in my experience.
How about this? let ret = some_function().or_else(|err| { // Handle error Err(()) })?; // Use ret as you wish 
&gt; Besides, Swift allows emoji in identifiers, so clearly they're in no position to be dictating good design principles to anyone... [Now let me stop you right there...](http://i.imgur.com/0hyDOvo.png)
Thanks for that blog. Only one thing left: how do you create the STM32F30x.patch? I'm trying to do the blink example for a F405 and all the fine typesafe stuff for register accessing is done by above patch...
I did not! I will look into it :) EDIT: Now running on the URL parser! EDIT 2: Tried it on the URL parser for a few minutes. Didn't find anything :D
I created this crate to be integrated into [gutenberg](https://github.com/Keats/gutenberg). And a Rust version is going to be faster.
It is a little more involving that you'd think https://gist.github.com/lu-zero/677fd3a16cceafc736db32d73db7abbc So yes, you can do something but it requires a quite bit of thinking and it can get surprising or brittle way too easily. 
Why does it have to be unsafe?
No, it's not unsafe. It exposes a safe interface but uses unchecked code internally, just like every "safe" thing in every language. It's impossible to do anything in any language without unsafety somewhere.
Because you have to have two mutable references to the same array, which is forbidden in Rust. (You can either have one mutable reference or many immutable references.)
I'm confused. In that example, you *can* take a pointer to const - [further playground link](https://play.rust-lang.org/?gist=94d08e3b38360c28290c4b912c52013f&amp;version=stable).
I believe that your codebook example can be expressed by Rust macros like this: macro_rules! build_vec { ( $( ($a:expr, $b:expr) ),* ) =&gt; ( [$(($a, $b), (-$a, -$b), ($b, $a), (-$b, -$a)),*] ) } fn main() { println!("{:?}", build_vec!((1,2), (3,4))); } Output: [(1, 2), (-1, -2), (2, 1), (-2, -1), (3, 4), (-3, -4), (4, 3), (-4, -3)] Edit: I see, the issue is probably that when nesting macros, each level must form a syntactically valid expression. Though it might still be possible to use macros to build such a codebook, it would be nowhere as simple as equivalent C code.
But what I'm saying is that the author _is_ wrong here, there is a way to do it safely. It's just not in the core language.
Made my first little rust program just to get a really basic feel for the language, a terminal-based towers of hanoi simulator. If anyone wants to look over and rip apart my code, that would be greatly appreciated. https://github.com/termhn/rust-toh
Because otherwise the compiler needs to be smart enough to figure out at compile time that `&amp;mut arr[0..pivot];` and `&amp;mut arr[pivot..]` are disjoint parts of the same array. This is not that easy to implement as it requires the compiler to reason about the run-time behaviour of arbitrary code. The whole point of `unsafe {}` is essentially telling the compiler that the safety in the unsafe section is guaranteed by the logic of the code, instead of the borrow checker. This allows us to define a safe API with `split_at_mut`, which internally uses program logic to actually guarantee its safety.
Yesss I needed this so badly four months ago. I haven't actually read the whole thing yet, but by god is an in depth explanation needed. 
… Are you wilfully refusing to understand the issue? The problem is not the passing (they're already copy types anyway) it's updating their values in the parent scope as they're returned from a function. `thing.do` could take no parameters at all.
I'm pretty bummed at the recent regressions. Once or twice a year, someone improves compiler performance, the rest of the year performance goes down rapidly because PRs are merged without proper performance evaluation.
The problem is when updating the bindings, not when creating them. You can use pattern-matching to create bindings, but you can't when assigning to an existing binding (or an attribute).
This declares two new variables, whereas /u/doener's snippet (and the blog author's example) modifies two already existing variables.
&gt; We tried to use it in TiKV but met some panics Did you open an issue about this?
And, who knows, maybe a whole dedicated IDE for Rust at some point?
It seems to me that any worthwhile IDE is also very poor as an actual editor. A shame, really, since most of the time you'd want both. Maybe neovim (or something similar) integration into IDEs is the solution?
it *is*, but it's hard to **discover** this. The problem here is you can't even just '*do it the easy way inside an unsafe block*' - the syntax space is taken up; as I understand the safe-ness is built into the trait; *you can't have an unsafe version of []*. &amp;foo[i] ? no, it's ```std::mem::offset``` ? did I remember it right ?? Rust's philosophy seems to be actively hostile to unsafe code (beyond just marking it.. I *am* quite happy with the whole idea of an 'unsafe block'). You're having to discover and look up named functions, introducing more vocabulary to read through, *just to do basic things*. Thats what I'm finding surprising about rust. 
whilst I might mirror some of the sentiments, the fact it has good tuples in the core syntax *at all* is actually one the the things I like about Rust vs C/C++.
That shadows `a` and `b` instead of changing their value.
&gt; I'm still not precisely sure what you mean by with your code example. I mean exactly *what TFA complains about* namely that you can't use pattern matching (or any subset thereof) in [an assignment](https://doc.rust-lang.org/reference/expressions.html#assignment-expressions): let (mut a, mut b) = (0, 0); for thing in thang.iter() { (a, b) = &lt;nobody cares&gt; } // use a and b which may or may not have been updated does not work, and has to be written: let (mut a, mut b) = (0, 0); for thing in thang.iter() { let (_a, _b) = &lt;nobody cares&gt; a = _a; b = _b; } // use a and b which may or may not have been updated 
split_at_mut will work on vectors too because you can't push to the vector while maintaining the mutable slices.
Wouldn't it be great if Rust or a Rust macro package provided something like Erlang's bit syntax? That would be such a nice way to write byte stream parsers and generators.
&gt; It exposes a safe interface but uses unchecked code internally, just like every "safe" thing in every language. That's not really true. Any function defined purely on pattern matching and algebraic expressions (e.g., `not`, `and`, etc.) can be implemented without any (even transitive) dependencies on `unsafe` blocks. Purely algebraic definitions are dependent only on the internal consistency of the type system itself.
One of my biggest annoyances was mentioned here - the borrow checker doesn't like if you write something like "myVec.split_at_mut(myVec.len() - 5)" despite the fact that any human could clearly see that there are no borrowing issues here. So it just serves to slow down development and add useless lines of code for temp variables.
Because the compiler/type system is not smart enough to know that the subslices don't overlap if you just slice by hand. There's a variant when you try to mutably borrow different fields of a struct, it works if you do it directly (because the compiler statically knows the borrows are non-overlapping) but it does not if you go through an accessor.
There was that list comprehension macro recently too.
NLLs are on the way to fix that. :)
I think you have mistaken Rust for Haskell :P
Glad to hear - feedback welcome :-)
Besides the boilerplate and the error handling being two indents deep instead of one, this has the desired semantics, I think.
This is good. One problem is that you can't do an early `Ok` return from the error handler (pretty common).
That's great, I write my notes in asciidoc. It'd be nice to have a notes program in rust, I just compile them manually now.
The 0.9 update was pretty solid. I find it easier to reason about. Just need to figure out how to organize the font &amp; audio stuff with it :).
 let mut samples_of_a: Vec&lt;Vec&lt;u32&gt;&gt; = std::iter::repeat(Vec::with_capacity(10)) .take(NUM_USERS) .collect::&lt;Vec&lt;Vec&lt;u32&gt;&gt;&gt;(); let mut c: Vec&lt;FnvHashMap&lt;u32,u16&gt;&gt; = Vec::with_capacity(NUM_ITEMS); let mut indicators: Vec&lt;Mutex&lt;BinaryHeap&lt;ScoredItem&gt;&gt;&gt; = Vec::with_capacity(NUM_ITEMS); Uses of all of these types will be crazy slow. `Vec&lt;Vec&lt;u32&gt;&gt;` has `N + 1` allocations for `N` rows and 2 indirections for every access of an element, `BinaryHeap` requires indirection, `Mutex` requires locking/unlocking _and_ indirection. Accessing an element of `ScoredItem` requires one lock/unlock pair plus 3 indirections. `HashMap`s require indirection too. Creating `samples_of_a` requires _9746_ allocations of 40 bytes each. That will be slow no matter what.
As a diesel maintainer/fan, thank you so much for this. Hopefully it'll help people understand some concepts and get them started :)
I'm porting this [serial key verification system](http://www.brandonstaggs.com/2007/07/26/implementing-a-partial-serial-number-verification-system-in-delphi/) into Rust - [repo here](https://github.com/whostolemyhat/serial-key-generator). Seems pretty straightforward so far, although there's a lot of magical bit-twiddling.
Yeah, but if you do, please work on the branch `feature/futures-glib` since the master branch is not developped anymore. (I really should write a contribution guide.)
The life of open source is beautiful.
Even in Haskell, everything is ultimately compiled to mutating assembly code. I believe GGP's statement is true: &gt; It's impossible to do anything in any language without unsafety somewhere.
The best way I can think of is to just create, populate, and process the each heap within each thread. This results quite a bit different structure, and I'm not sure if it's worth it. The overhead of unlocking and unwrapping at the top of the rescore function shouldn't be, (and isn't, according to profiling) significant. 
&gt; the callgraph. This is all correct, but it's also done once at start-up. According to /u/coder543's analysis : http://i.imgur.com/6SLWYq9.png , the program spends 80% of its time in rescore, specifically in log() for the float. 
Well the hair I'm trying to split here is this idea that you must trust unsafe (in the sense that it breaks the rules of the type system) client code at some point. That is not technically true. If you include the behavior of the compiler/type checker itself, then sure.
Ah, ok. The wording of the repo confused me, "The rust language implementation of gRPC. HTTP/2 based RPC". From that I assumed it was also a rust implementation rather than a wrapper.
&gt; This is a known issue and is being fixed, first by a special-case in the borrow-checker (because it's a common pattern) and then in general with non-lexical lifetimes. Is there a tracking issue for this? I would *love* for this to get fixed, it makes me use iterators much less than I would like.
Nice! I've wanted to do this; I'm a huge fan of Bob's too :)
&gt; Please, for the love of programmers everywhere, don't write a language that depends on printf or any other variadic C function. C++ variadic templates.. might be hard to setup but these are a good solution IMO
&gt; This is a simple confusion on the semantics of statics vs constants. Mostly because C does a horrible job of using the keywords "static" and "const", really. Rust const is not C const. Rust static is not C static. (Rust const is more like C #define, Rust static is like any C global variable)
I notice that some of these things are incompatible with how Hyper does them (Request, in particular). Does anyone know what the Hyper devs' opinions are on this, or what their plans are with respect to this crate?
what I would suggest is a #[unsafe(...)] that flags everything in the file as 'unsafe', and quiets the borrow checker. i.e. other modules will need an unsafe block to call these. that wont pollute the ecosystem, and you can still grep for unsafe.
&gt;&gt; "As someone who obsesses over API design, I rather like exploring how to express invariants in a strong, rich and sound type system like Rust." I *do* absolutely like the fact that globals are unsafe{}, and that immutable is default; I totally understand and support the idea of the signatures communicating what can and can't happen. &gt;&gt; "Although that probably is not what you meant (you probably meant UI prototyping)." not just UI, but just trying ideas and algorithms generally.. how to store something , how to calculate something. the ad hoc nature of c++ means you can just code , then retrofit polymorphism by sticking 'template' infront - whereas in rust you need to state the 'shape' upfront; r.e. the borrow checker, I think there will be simpler forms of markup that can express the intent in a clearer way. There's a thread about a 'shortest lifetime' (opposite of 'static'). most of the time my use of references is simple.. passing non-escaping parameters around; returned references are short-lived accessors ; the default assumption is that a returned value owns everything; rust does the 'self/accessor case' by default which is nice; but there are times you'll need to deal with a fiddly lifetime label to express something else that is still a simple use case.
Its still in the RFC phase, so no tracking issue yet, but I'm certain it will go pretty fast from then on: https://github.com/rust-lang/rfcs/pull/2025
&gt; Mostly because C does a horrible job of using the keywords "static" and "const", really. And C++ added to that by using "static" for something entirely different... :P
&gt;&gt; "Rust can and should flourish in that space where people's use of C is just making things harder for themselves and everyone else," IMO with just a few simple changes Rust could be unambiguously superior in more use cases. I would like to have one language to concentrate on.. it can certainly focus on one driving use case but it shouldn't be 'actively hostile' to others.
Yes, and the scala version is using the same kind of data structures
FWIW Firefox's build times for Rust code are like 50% bindgen. There's work to speed bindgen up, but it's not there yet. I'm hopeful Cretonne will be a good alternative backend for speeding up rust compilation for local debugging.
&gt;&gt; I think it's easier to have a discussion on concrete things -- for example, you mentioned method overloading having tried haskell, I think I would be ok with rusts system if they actually let you elide the types in impls. At that point the 'trait' will become more synergistic. for those who want to see the types explicitely, i would argue Rust makes it super easy to grep for the trait; documentation/IDE can always re-insert it. there should be no need to cut/paste of course there's a learning curve to moving form overloads to traits, but if it offered that 'carrot' i'd welcome it more. [https://github.com/rust-lang/rfcs/pull/2063] the shocking thing for me is this suggestion has 2 up votes and 9 down votes. why not just suggest a compromise like 'it requires a #[..] to enable'. *surely* people using *libraries* are going to look at the trait more than the impls. I don't see why anyone would argue against this.
&gt; It would be unusual to prototype in C.. C++ is not much better my point is that you can consider a buggy program as a prototype; but it's in a form where it could be debugged (rather than rewritten entirely in an entirely different language), yielding a finished product. There's a higher probability you did something useful already, without having to deal with cross-language interfacing. So we have the ironic situation where I may consider going back to C++ from rust *because it's easier to try ideas out*.
Thank you so much! As a Diesel maintainer I'm so glad to see more guides popping up (FYI we recently added a [guide on updates](http://diesel.rs/guides/all-about-updates/))! In general I still think in-depth guides/tutorials are Diesel's greatest weakness -- it's even more prominent than the complex compiler errors :)
well sure the 'functional style' is very pleasing where it works (and I like the internal iterator style for parallelism potentail) but i does require digging through more vocabulary upfront to use. with c you learn the for loop and a fe operators and they can do anything and sure, once you learn the name of a helper it can do something with less typing.. but you still have to discover it. not everything has an obvious name; and not every permutation has been established
&gt; " and some safer, non-C derivation takes over?" i think there will always be a layering process remember the CPUs also grow, gaining new instructions; C *plus intrinsics* will always be showing something the machine does efficiently. back on the xbox360 we had a custom ISA for vector maths- there were intrinsic functions for handling dot-products and various D3D types. back on the PS2 there was a DSP that had specialised instructions for the AOS style of 3d programming ('multiply-add by the x component of ..') .. in these cases if you mapped to C (with intrinsics) you knew your code matched the hardware well. obsolete? I don't thinkso: today AI is all the rage and they are adding new instructions for that (handling the low precision types). The slowing of moore's law might mean *greater* reliance on custom instructions..
[removed]
If you want to peruse this change, I would suggest opening an issue on the repo with this info and a clear explanation of the current risks. 
I know why the compiler is slow and a little of what can and can't be done about it, but I do have to confess... I recently messed around with a C# program and it was *stunning* to not have to wait 45 seconds for it to compile.
I found this thread on stackoverflow: https://stackoverflow.com/questions/45037547/why-is-logarithm-slower-in-rust-than-in-java I tried adding RUSTFLAGS="-C target-cpu=native" as proposed there, but it also didn't improve the runtime 
Maybe he's mixing up "taking a pointer to X" vs. "turning a reference to X into a pointer to X"? Why wouldn't it work? When you take a reference to a const I would assume rustc does the same thing it does when you take a reference to a literal: let x = &amp;10; It just says "oh this needs to have a memory location behind it" and gives it one, and then presumably optimizes that out if it discovers it's possible.
Wow, a time-travelling changelog. Looks great, I'll try it when I'm home
/u/seanmonstar is one of main the hyper devs. He has contributed to the http crate and also commented multiple times in this thread. I am not sure if hyper will use the http crate as it is quite different from the current API but I am certain that the hyper devs will contribute heavily to the "standard" Rust HTTP implementation whether or not it is a new crate.
&gt; Firefox only has a small amount of Rust code in it but it's already ballooning out build times :( Happily, a lot of the Firefox problems were a silly thing that arielb has a fix for: https://github.com/rust-lang/rust/pull/43584
If you move `split_at_mut` (or whatever its equivalent in your language of choice) into a compiler builtin or part of the language, all you've done is moved that unsafety into the compiler - which has just as much chance of containing bugs as any `unsafe` block. So I don't know why you wouldn't consider the compiler here.
This is a great example... most of these problems are not Rust problems, but how-to-use-Rust problems. :-/ Not sure those posts will ever go away, 'cause Rust is *complicated* and it takes a lot of time to get a good grasp of the edge cases and the handy language features and bits and pieces of `std` that are there which mitigate them. I still remember the first time I actually went through the full reference docs for things like `slice` and `i32` and went "oooooh there's all this STUFF here I never realized existed". Contrast with say, C, where even if you don't know the stdlib very well it's obvious how something needs to be done, or Python where every problem has been solved *somewhere* on Stack Overflow, or even Common Lisp where every function can do exactly what you want if you dig deep enough and phrase your question in the right way. Rust has a lot more different kinds of moving parts interacting with each other than C or Lisp (well, Scheme at least), and a lot of built-in interlocks that make the program not compile if the moving parts would jam up into each other.
This looks like it can help, https://github.com/dtolnay/cargo-expand but still isn't optimal. Something about "with great power comes .... great" documentation.
If you want a synchronous client, you can just grab a `reqwest::Client`, and not worry at all about tokio or futures or anything. It works with just `io::Read` types. The [comment from iq-0](https://www.reddit.com/r/rust/comments/6qr9mf/announcing_the_http_crate/dl06iha/) does a great job explaining why `reqwest`s synchronous client over async hyper works well. In fact, reqwest is better for it. 
Oo, that book looks *excellent*. I think I might try following along in the original Java and C though. My Rust is actually better than my Java and C!
I feel like your response and the initial rant form an excellent epistemological pairing. We actually need *more* of these with fresh eyes in many different domains. Thank you.
The `Request` and `Response` were designed after hyper released v0.11, and tried to clean up some mistakes that were made in that. hyper will eventually replace its types with those in the `http` crate. Yes, that will mean a breaking change, unfortunately. However, it will try to be grouped with the breaking changes from futures and tokio, also.
Yes, see https://www.reddit.com/r/rust/comments/6qr9mf/announcing_the_http_crate/dkzhppi/
Which is why steveklabnik's response on hackernews is so productive: &gt; These kinds of experience reports are so valuable. (I've been following the whole series and they're very interesting.) Even if solutions to these issues do exist, if people can't find them, well that's a problem too. The Rust team understand that issues with being able to learn a language are just as important with issues with the language itself.
This sounds like a case for somebody adding some benchmarks for the compiler that can be run every so often.
This is where I like to draw the distinction between "safe" and "sound". `split_at_mut` uses _unsafe_ code, but in a _sound_ way, because it checks the necessary invariants to avoid undefined behavior.
&gt; it is, but it's hard to discover this. You're surprised and frustrated that you're expected to read through the docs for the type you're currently consuming? I wish my problems were this easy to solve :) But to be fair to you, from what I understand, rustdoc is getting work done to improve the UX, so maybe that will fix your issues.
REEEE this is why I knew I didn't want shadowing in Rust
My point is not about general population ratio, but about the influence of SE/CS engineering school population ratios in the population ratio of Software Developers. What I observe is: - predominantly white male population in SE/CS schools in "Western" countries, - leads to predominantly white male population in software industry in "Western" countries, - leads to predominantly white male population in free software communities.
&gt; You're surprised and frustrated that you're expected to read through the docs for the type you're currently consuming? **absolutely**, for something as trivial as that, which can be achieved through composition of basic operators elsewhere. The search space for 'everything I could do to an array' is *huge*. It is nowhere near clear how to get from a sequence of operations to a **name** ; searching all the **names** to find the **combination of operations you want** is a terrible process to have to go though. &gt;&gt; rustdoc is getting work done to improve the UX Rustdoc is pretty good already for what it can do; it's a **search issue beyond the scope of rustdoc IMO**. The best thing out there in this vein is '**Hoogle**' but even that can't execute a query along these lines. What is needed is the ability to write a piece of C, and ask , 'what is the rust equivalent'. (something like [shape analysis](https://en.wikipedia.org/wiki/Shape_analysis_(program_analysis)) ) you need a tool that can do this sort of thing (but for small blocks of code, not completely trivial expressions):- * 'given (a,b,c) what is (b-a)*c + a ? * *answer= "lerp(a,b,c)"'* * 'given a,b,c, what is min(b,max(a,c)) ? * *answer= 'clamp(a,b,c)'* etc. as the nature of the things that you need safe abstractions for grows, the naming will get harder and more obscure. I have an idea to eliminate bounds checks in array indexing with a version of a vector that keeps it's elements bounds ,and you do the checks once on pairing indices with vertices. **But what is that called?** ; anyone else wanting to use the same pattern will probably write it themselves faster than they could find what *I* chose to call it, and vica versa.
Oh, wasn't aware of that. Definitely bit nicer than calling rustc directly. You are right, it still doesn't take the place of well integrated tooling into an editor. Thanks for sharing.
We do. http://perf.rust-lang.org/graphs.html
Yeah, its fair, you'd like the "grammar checker" of MS Word for programming languages (i.e. write some code, the compiler lets you know there is a better way to phrase it), and an amazing polyglot search engine. Those are definitely things everyone would love. Meanwhile regarding the C to Rust stuff, you might be able to make little website which took some C and have you suggested Rust. Check out: [Corrode](https://github.com/jameysharp/corrode) and also the section about "what Corrode is not". Corrode would map C to unsafe Rust. XXX would map unsafe Rust to idiomatic safe Rust. This XXX would be part of what you're looking for, a best practice enforcer/generator.
&gt; you might be able to make little website which took some C and have you suggested Rust. yes, something that accumulated a lot of examples. data driven/community driven. This incidentally is part of why I think the old ~[T] stuff was so good: another way to do this sort of thing is to document by example, e.g. "what function takes (~[10,20,30,40],3) and returns (&amp;mut [10,20,30],&amp;mut[40]). The old ~ notation made compact literals for a lot of the common cases, with sync between what you read in debug prints and write in experiments. I've actually seen a tool for clojure which tries to find functions based on input/output pairs. Somewhere between that and Hoogle is what I imagine &gt; (i.e. write some code, the compiler lets you know there is a better way to phrase it) I'm sure it sounds very brute force, but bear in mind often you can write a simple implementation of something very compactly/quickly; final efficient implementations may be longer. I speculate that pairing 'efficient/optimized versions' alongside 'naive implementations' would allow people to search by writing the naive version first. Another good pairing is **"functions and inverses"** ("whats the inverse of x*x ? sqrt(x)" etc) of course many functions don't have strict inverses (lossy..), but again getting 'the best aproximation' could be another nice search tool. encoder/decoder pairs..
Seems like the best way to go - this is pretty 'typical' rust, using tuples to force patterns.
I changed the heap insert block to : if indicators_for_item.len() &lt; k { indicators_for_item.push(scored_item); } else { let mut top = indicators_for_item.peek_mut().unwrap(); if scored_item &gt; *top { *top = scored_item; } } Not that it matters much, since top() on a heap should be O(1) (also, is it &gt;? or &lt;?, I assumed &gt;, since your Ord impl does the reversal) I also changed the function annotations from #[inline(always)] to #[inline] because the compiler knows better than we do. Also, probably most importantly, I changed the variables k11, k12, k21 and k22 into u32's. This obviously is a departure from the scala code, but it makes it so the entire loop should fit into a single cache line. It shouldn't effect accuracy. After all of this, it averages around 650ms per batch for the last 500k. This is a bit better than the scala code which is around 680ms per batch for the last 500k. (on my 2015 macbook pro) This isn't terribly scientific. I can't really point to why the rescore function was slower on Rust, other than cache coherency. The only thing I can think of is the JVM is actually doing some pretty great hotspot optimizations since it is called so frequently in a rather tight loop. The other thing I notice is that the algorithms might not entirely be the same: When I added a counter for every time logLikelihoodRatio was called in each implementation, the Rust implementation was typicially about 350k more times, that's not a lot because both were being called about 750,000,000 times. But the fact that Rust was consistently higher means that something might be fundamentally different. 
 let value = some_function().map_err(|e| { // process })?;
Vocabulary libraries such as this are not only awesome for compatibility, they can also help switching one piece for another pretty easily, making it much easier to test various combinations or move to a more modern one.
No, not really.
(Not all core team members contribute to the compiler, FWIW. So the tradeoff here isn't as straightforward as it sounds)
I'm trying to achieve this with imgui-rs but for the moment the combo it way too big. As for the hour input, I tried input_int2 but again, the width is too big. How do we shrink widgets with imgui?
Because people don't understand the `let` keyword?
The linked article is unreachable. Did the author take it down?
Problem is a lot of RFCs end up dead on the issue tracker for months without any activity. Rust has a real soon™ problem when it comes to some concepts just never making it even into nightly because they sit in RFC hell after a really good discussion that lasted several weeks for months without updates. Its pretty disheartening to go sort by oldest open RFCs and see that ones from early 2016 are still open, don't see updates more than once a month at most, and haven't either been closed or accepted.
For people who want to look at actual code, Rust portion of Suricata is [here](https://github.com/inliniac/suricata/tree/master/rust), and Rusticata, which is not yet merged, is [here](https://github.com/rusticata).
To be honest, I find Rust `const` very confusing too. I expected it to mean "stored in ROM" (as in, a constant), not "literal expression to be copy/pasted".
The RFC seems not to be progressing much... and seems to be about something different. It only showcases multiple pattern matchings one after the other. I think it could be interesting to take a leaf out of C++, in C++17 an "initialization" statement was added to `if`: if (int x = func(); x &lt; 3) { } Which works with destructuring: if (auto [x, y] = func(); x &lt; y) { } I think Rust could adopt a similar form: if let Some((x, y)) = func(); x &lt; y { } // instead of if let Some((x, y)) = func() { if x &lt; y { } } Where the first statement is a pattern (possibly as simple as `let x = func()`) and then comes the condition.
Doesn't the "let" make it obvious?
it wasn't obvious to the ggp
Thank you for these pointers. The comparison must be scored_item &lt; *top as the new item must be larger than the smallest one currently in the heap (I know its confusing, as there is no min-heap). I tested your changes, but on my machine (Ubuntu 16.10, Intel(R) Core(TM) i7-4710MQ CPU @ 2.50GHz) Scala is still way faster. The difference in invocations is strange, I'll look into that. It could be due to the different rng's but that's just a wild guess.
yes, it's confusing to shadow in the same scope
Yeah, kinda. I somewhat blame that on C completely muddying up that space. Rust is const by default so basically everything is a constant the way you describe it. What C++ calls `constexpr` is what Rust calls `const`. (Except when talking about raw pointers, which is confusing). So Rust's const is basically "more const than a constant" (since everything is constant by default).
Ops.. Fixed :)
Yeah... can't wait for NLL to unclutter a lot of code.
Of course, this doesn't short-circuit; I'm not sure how often that matters in practice.
Thank you for expressing something which I felt but had no name for. The sheer number of methods for a type reminds me of php development. At least it's namespaced by trait/type but still massive.
Rust's `const` is not C++ `constexpr` because a `constexpr` still has a unique address, whereas Rust's `const` will produce a new value at each use. So Rust's `const` can be evaluated at compile-time, but is not a constant... and this has implications: in C++, I could potentially store a `std::string` in a `constexpr` (assuming it has a `constexpr` constructor), and then use a reference to it throughout the program; in Rust it would not be very sensible to use a `String` in a `const`. Your parallel with `#define` was spot on I think.
You can also try throwing [profile.release] opt-level = 3 debug = false rpath = false lto = true debug-assertions = false codegen-units = 1 panic = 'unwind' Into your Cargo.toml, but in this case I don't think it will help a lot, since the overhead is mostly in the log functions themselves. 
The hug of death is more probable.
Or, if you want more ML in your language: if let Some((x, y)) = func() in x &lt; y { }
[removed]
Looks like the server is down
It's somewhere in between. Because you can actually do compile time calculations with Rust const, and Rust const fns work, and can be used in e.g. array type sizes. It's more powerful than define (and typed!) but not exactly the same thing as constexpr, yeah.
&gt; I also don't get why independent dependencies of a crate can't be compiled in parallel They are compiled in parallel if possible. See also the cargo build -j flag
LLVM doesn't take advantage of the aliasing information, and rustc does very little optimisation (part of the slow compilation speeds is LLVM "fixing" the low-quality IR that rustc emits). If there was an LLVM-based Fortran compiler out there maybe it would take advantage of this.
There's been a lot of work, but nothing yet to show for it. An RFC is on its way.
By the way, I tried out the benchmarks in that link, and even without the RUSTFLAGS, I couldn't repro their bad performance: test bench_ln ... bench: 12 ns/iter (+/- 0) test bench_rnd ... bench: 4 ns/iter (+/- 0)
See https://github.com/rust-lang/rust/issues/38941 and https://github.com/rust-lang/rust/issues/16515 but most importantly https://github.com/rust-lang/rust/issues/31681
I'm deeply put off by this.
I contacted Kostya, the server hosting his blog got too many requests... For those that are curious &gt; Disclaimer: obviously it’s my opinion, feel free to prove me wrong or just ignore. &gt; &gt; Now I should qualify for zoidberg (slang name for lowly programmer in Rust who lives somewhere in a dumpster and who is also completely ignored—perfect definition for me) I want to express my thoughts about programming experience with Rust. After all, NihAV was restarted to find out how modern languages fare for my favourite task and there was about one language that was promising enough. So here’s a short rant about the aspects of this programming language that I found good and not so good. &gt; Good things &gt; &gt; - Modern language features: standard library containers, generics, units and their visibility etc etc. And at least looks like Rust won’t degrade into metaprogramming language any time soon (that’s left for upcoming Rust+=1 programming language); &gt; - Reasonable encapsulation: I mean both (sub)modules organisation and the fact that functions can be implemented just for some structure; &gt; - Powerful enums that can act both as plain C set of values and also as tagged objects, e.g. the standard Result enum has two values—Ok(result) and Err(error) where both result and error are two different user-defined types, so returned value can contain either while being the same type (Result); &gt; - More helpful error messages (e.g. it tries to suggest a correction for mistyped variable name or explains an error a bit more detailed). Sure, Real Programmers™ don’t need that but it’s still nice; &gt; - No need for dependency resolving: you can have stuff in one module referencing stuff in another module and vice versa at the same time, same for no need &gt; - Traits (standard interfaces for objects) and the fact that operations are implemented as specific traits (i.e. if you need to have a + b with your custom object you can implement std::ops::Add for it and it will work). Also it’s nice to extend functionality of some object by making an implementation for some trait: e.g. my bitstream reader is defined in one place but in another module I made another trait for it for reading codebooks so I can invoke let val = bitread.read_codebook(&amp;cb)?; later. &gt; &gt; Unfortunately, it’s not all rosy and peachy, Rust has some things that irritate me. Some of them are following from the advantages (i.e. you pay for many features with compilation time) and other are coming from language design or implementation complexity. &gt; Irritating things that can probably be fixed &gt; &gt; - Compilation time is too large IMO. While the similar code in Libav is recompiled in less than a second, NihAV (test configuration) is built in about ten seconds. And any time above five seconds is irritating to wait. I understand why it is so and I hope it will be improved in the future but for now it’s irritating; &gt; - And, on the similar note, benchmarks. While overall built-in testing capabilities in Rust are good (file it under good things too), the fact that benchmarking is available only for limbo nightly Rust is annoying; &gt; - No control over allocation. On one hoof I like that I can not worry about it, on the other hoof I’d like to have an ability to handle it. &gt; - Poor primitive types functionality. If you claim that Rust is systems programming language then you should care more about primitive types than just relying on as keyword. If you care about systems programming and safety you’d have at least one or two functions to convert type into a smaller one (e.g. i16/u16 -&gt; u8) and/or check whether the result fits. That’s one of the main annoyances when writing codecs: you often have to convert result into byte with range clipping; &gt; - Macros system is lacking. It’s great for code but if you want to use macros to have more compact data representation—tough luck. For example, in Indeo3 codebooks have sequences like (a,b), (-a,-b), (b,a), (-b,-a) which would be nice to shorten with a macro. But the best solution I saw in Rust was to declare whole array in a macro using token tree manipulation for proper submacro expansion. And I fear it might be the similar story with implementing motion compensation functions where macros are used generate required functions for specific block sizes and operations (simple put or average). I’ve managed to work it around a bit in one case with lambdas but it might not work so well for more complex motion compensation functions; &gt; - Also the tuple assignments. I’d like to be able to assign multiple variables from a tuple but it’s not possible now. And maybe it would be nice to be able to declare several variables with one let; &gt; - There are many cases where compiler could do the stuff automatically. For example, I can’t take a pointer to const but if I declare another const as a pointer to the first one it works fine. In my opinion compiler should be able to generate an intermediate second constant (if needed) by itself. Same for function calling—why does bitread.seek(bitread.tell() - 42); fail borrow check while let pos = bitread.tell() - 42; bitread.seek(pos); doesn’t? &gt; - Borrow checker and arrays. Oh, borrow checker and arrays. &gt; &gt; This is probably the main showstopper for implementing complex video codecs in Rust effectively. Rust is anti-FORTRAN in a sense that FORTRAN was all about arrays and could operate arrays safely while Rust safely prevents you from operating arrays. &gt; &gt; Video codecs usually operate on planes and there you’d like to operate with different chunks of the frame buffer (or plane) at the same time. Rust does not allow you to mutably borrow parts of the same array even when it should be completely safe like let mut a = &amp;mut arr[0..pivot]; let mut b = &amp;mut arr[pivot..];. Don’t tell me about ChunksMut, it does not allow you to work with them both simultaneously. And don’t tell me about Bytes crate—it should not be a separate crate, it should be a core language functionality. In result I have to resort to using indices inside frame buffer and Rc&lt;RefCell&lt;...&gt;&gt; for frames themselves. And only dream about being able to invoke mem::swap(&amp;mut arr[idx1], &amp;arr[idx2]);. &gt; &gt; Update: so there’s slice::split_at_mut() which does some of the things I want, thanks Tomas for pointing it out. &gt; &gt; And it gets even more annoying when I try to initialise an array of codebooks for further user. The codebook structure does not implement Clone because there’s no good reason for it to be cloned or copied around, but when I initialise an array of them I cannot simply declare it and fill the contents in a loop, I have to resort to unsafe { arr = mem::uninitialized(); for i in 0..arr.len() { ptr::write(&amp;arr[i], Codebook::new(...); } }. I know that if there’s an error creating new element compiler won’t be able to ensure that it drops only already initialised elements but it’s still a problem for compiler not being smart enough yet. Certain somebody had an idea of using generator to initialise arrays but I’m not sure even that will be implemented any time soon. &gt; &gt; And speaking about cloning, why does compiler refuse to generate Clone trait for a structure that has a pointer to function? &gt; &gt; And that’s why C is still the best language for systems programming—it still lets you to do what you mean (the problem is that most programmers don’t really know what they mean) without many magical incantations. Sure, it’s very good to have many common errors eliminated by design but when you can’t do basic things in a simple way then what it is good for? &gt; Annoying things that cannot be fixed &gt; &gt; - type keyword. Since it’s a keyword it can’t be used as a variable name and many objects have type, you know. And it’s not always reasonable to give a longer name or rewrite using enum. Similar story with ref but I hardly ever need it for a variable name and ref_&lt;something&gt; works even better. Still, it would be better if language designers picked typedef instead of type; &gt; - Not being able to combine if let with some other condition (those nested conditions tend to accumulate rather fast); &gt; - Sometimes I fear that compilation time belongs to this category too. &gt; &gt; Overall, Rust is not that bad and I’ll keep developing NihAV using it but keep in mind it’s still far from being perfect (maybe about as far as C but in a different direction). &gt; &gt; P.S. I also find the phrase “rewrite in Rust” quite stupid. Rust seems to be significantly different from other languages, especially C, so while “Real Programmers can write FORTRAN program in any language” it’s better to use new language features to redesign interfaces and make new overall design instead of translating the same mistakes from the old code. That’s why NihAV will lurch where somebody might have stepped before but not necessarily using the existing roads. 
I don't see how shadowing is more confusing than assignment. I rather dislike not being able to shadow in C#. Freezing/thawing is even a pattern in Rust that wouldn't make any sense without shadowing.
I'm not a fan of assignment
Interesting finding. You can see [here](https://godbolt.org/g/HSZWke) that clang optimizes c++ version with restrict keyword. And [here](https://godbolt.org/g/846CmZ) is the rust version.
Just started reading, I really like the writing style so far. Thanks for bringing this up.
I manually in-lined (edit: CSE'd) your floating point logarithms, which perhaps Rust was unwilling to do because it can't confirm that the `ln` library call is side-effect free? This approximately halves the running time for me (elapsed time from 90+ seconds down to 48 seconds). #[inline(always)] pub fn log_likelihood_ratio(k11: u64, k12: u64, k21: u64, k22: u64) -&gt; f64 { let xlx11 = x_log_x(k11); let xlx12 = x_log_x(k12); let xlx21 = x_log_x(k21); let xlx22 = x_log_x(k22); let xlx_sum = xlx11 + xlx12 + xlx21 + xlx22; let xlx_row = x_log_x(k11 + k12) + x_log_x(k21 + k22) - xlx_sum; let xlx_col = x_log_x(k11 + k21) + x_log_x(k12 + k22) - xlx_sum; let xlx_mat = x_log_x(k11 + k12 + k21 + k22) - xlx_sum; if xlx_row + xlx_col &lt; xlx_mat { // round off error 0.0 } else { 2.0 * (xlx_row + xlx_col - xlx_mat) } } ```
right.. because safety isn't "free" - you pay for it by guiding it.Wheras in other languages these methods are helpers which can do things more efficiently (if you know where to look), in rust they are *compulsory* to write 'safe code'. All that rust does ,really, is *eliminate the shortcuts*. If we could build the 'search database' I describe.. we could also use it to verify (by comparison to example) if a piece of C/C++ is using safe patterns
this is massively important to me: and actually this is a big part of my interest in Rust. Back in console gamedev we had to guide this in C++ with 'restrict' (and it was essential to get it right, e.g. enabling caching in registers for in-order scheduling, with unrolled loops.. we were regularly inspecting the output like this) my hope is that **propper immutability by default** would give the equivalent of 'restrict' based C++ code almost everywhere, but with without scaring people as much. Is this something that can be achieved with future hints to LLVM (it can't be just Rust that can use it.) ? in the PS3/xbox360 gen it was about loop unrolling; the same aliasing hints should also allow more use of SIMD with 'gather' instructions (over time they are gaining generalizations to the SIMD ISA that should allow more pervasive use).. it's all different forms of parallelism in the end
awesome, that runs pretty much on par with the scala implementation now!
In c++ you can say: tie ( a, b ) = someOpReturningATuple(); Could tie (or a similar thing) be implemented in rust standard library or compiler? Would that help?
Could that be changed or would it have pathological implications for the compiler?
[removed]
[removed]
Because a feature hasn't really arrived until it is in stable Rust, and that one hasn't "arrived" yet either. Stable Rust says: &gt; error: SIMD types are experimental and possibly buggy (see issue #27731) An experimental feature can change at will and may even be removed.
I believe there needs to be a corollary to Godwin'ing a PL thread by either talking about heat and effectful results. Mention Godel for bonus points. 
Kinda leaves open the mystery of why Rust/LLVM couldn't reach this implementation.
With https://github.com/rust-lang/rust/pull/31545 reverted I get: movl $0, (%rdi) movl $1, (%rsi) xorl %eax, %eax retq Reverting https://github.com/rust-lang/rust/pull/31545 is being tracked in https://github.com/rust-lang/rust/issues/31681
I like to describe it as "Swift on the JVM". The syntax of the 2 are veeery similiar and they market to the same kind of people. If you do any work in java I'd recommend kotlin. The interop is fantastic, so you can replace java files over time to see if you enjoy it
But CSS can achieve this... Both GTK and QT have themes that make them have UI that looks native. What am I missing here?
Rustdoc even has some Hoogle functionality (type `?` to see the options), but it seems to not work at the moment.
It's interesting to compare to other languages like Swift or Elm.
That might apply in the general case, but NLL specifically is being driven hard, e.g. https://internals.rust-lang.org/t/announcing-the-impl-period-sep-18-dec-17/5676 from yesterday gives some more concrete timelines.
It's not compiling at all... It's C#...
I'd be interested to confirm that the generated code for const X: usize = 15; let a = &amp;X; let b = &amp;X; has a and b referring to different locations.
Having issues chopping off the front of an unneeded Path. What am I doing wrong here: https://play.rust-lang.org/?gist=a0b42f8e1aef529324dbb4932fc85093&amp;version=stable Edit: You have to strip from the front. I was thinking it did more of a split and throw away the front. If there an easy way of getting path from a certain directory onward? ..\..\path1\path2\path3\file.jpg -&gt; \path2\path3\file.jpg 
It is fortunate that Rust is taking this leap sooner rather than later, but it is still... later that we could have hoped. The ecosystem built up from 2015-2016 was entirely synchronous, and once generators and keyword support lands you still have a bit of the Python "juggle async libs" problem, especially since std is all synchronous.
IPFS link from HN discussion: https://www.eternum.io/ipfs/QmYrdKpWbHCuNPUrBd6MPFrcTqPBW55w1AFHdw4toUt8MM/
Awesome. Love this book and have been planning a compiler project in Rust.
It's compiling to an intermediate language. This includes some compile-time optimisations, even. 
There's [an old RFC](https://github.com/rust-lang/rfcs/issues/372) but it makes the grammar quite a bit more complex as you need to look ahead much further before you know whether something is an assignment or a parenthesised expression.
The docs for strip_prefix say &gt; If base is not a prefix of self (i.e. starts_with returns false), returns Err. The path doesn't start with `about`, it starts with `../../folders/i/do/not/care/about`. note the second example, it would also need to be `/about` instead of `about`.
Excellent!
Yeah, I just figured that out. I thought I saw an example that made it split in the middle, but it was and is_err() test case and I didn't realize that.
It doesn't appear to work all that well, though. Look at http://perf.rust-lang.org/. It's not a good way to view the data, but it's clear there is a lot more red than green. Look at the week of 6/25/2017, something bad happened that was never addressed. Also, when I was working on compiler perf in Q4 last year there were multiple occasions where a significant regression occurred that I caught because I was re-running the numbers on that suite every Monday. Even with a one-week latency, it appeared that I noticed these regressions before anybody else, which suggested that they might otherwise not have been noticed at all.
The page isn't loading for me, here is a [wayback mirror](https://web.archive.org/web/20170801151217/https://codecs.multimedia.cx/?p=1246).
You think compile times might be a touch slow? Try compiling this: https://github.com/jcriddle4/rust_small 
I've never spend so much time debugging. Wow there was some very subtle bugs in this crate. All the known bugs are sorted out now though.
Thanks /u/stephanbuys! This is a great write-up.
Two reasons for short-circuit to matter: 1. complicated calculation 2. side effects I believe compiler could optimize #1 if it can prove no side effects. If you need #2, you should've written "normal" code anyway (else it's unclear).
/summary has the summaries field in the json response being null Results in just saying a big 'nulls' on the page
I am not sure what you mean by a macro. I don't want to pre-initialize my array's to zero as that really defeats the purpose of having the compiler tell me I am using uninitialized, or initialized to bogus values. I want the compiler to tell me that there is a problem. It seems like, for fairly straight forward initialization, the compiler should be able to infer that everything is initialized before any possibly reading of array values. mut myArray: [U32; 256]; for x in 0..256 { myArray[x] = (x*x) + (x * 19) + 3; } 
Look at smart casting in Kotlin. If you check that immutable value (not variable!) is not null it will be smart casted to actual value by compiler. However mutable ones won't do that since they can be changed anytime from any thread. It be nice if compiler was smart enough to do so without having you write extra code.
FWIW, this is the third time in a short period of time I've opened a thread to see a discussion of let mut ... &amp;mut ... mut ... mut Me thinks there's something about this area of the syntax that's confusing to people. 
any example code?
I should add it to the docs. Here: https://github.com/redox-os/tfs/tree/master/conc/src/sync
&gt; If there was an LLVM-based Fortran compiler out there maybe it would take advantage of this. https://github.com/flang-compiler/flang
You can do this with indexing in an `unsafe` block but it requires round-tripping through a raw pointer to break intermediate borrows: let (a, b) = unsafe { ( &amp;mut *(&amp;mut arr[..pivot] as *mut [_]), &amp;mut *(&amp;mut arr[pivot..] as *mut [_]), ) }; Discovery is part of learning a new language. When I was learning Rust I would just take a few minutes and sift through the API docs, usually on my phone when I was out and there was nothing else to do (the API docs render really well on mobile, kudos to the docs team). Even if I don't always remember everything, it's still time well spent because I can remember that there *is* a way to do it, and I can find my way back to it.
What book/tutorial/example would you recommend to someone familiar with low level programming and experience in C++? I've been reading the *Rust Book*, but I feel that 90% of it explains what low level programming is about, but not how Rust differs from other languages. Is there some more conscise version that just goes over the critically important and different parts, such as `Copy` vs `Drop` (not why they exist, but that they exist and how they work differently than C++, for example that it is a matter of the type), or a conscise explanation of how the borrow checker works.
Tooling can be helped by a good compiler, but I guess that'd be difficult in a compie-then-run-binary system. I guess you guys have no macro-expander either? It doesn't completely solve the issue, since you still need a valid example use of the macro.
Yeah, I know, not enough people pay attention to that, mostly pointing out that it _exists_.
Lets play devil's advocate here. Again and again we have seen languages that struggle because they didn't add a Macro/Generic system early enough. C++ templates are a monster, and that's because the language didn't think of them early enough. Adding them has been hard because of ways in which the language works. Even now there's proposals in C++ to add [new macro systems](https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/). They're good, but they add complexity under weird interactions which should be worrisome if anything for the cognitive load on users. Java's generic system is unsound because of workaround and limitations they have to do in order to hack around assumptions that the system did when there weren't generics. Go would benefit greatly of a macro or generic system, but it's hard to easily add one without breaking stuff. I don't know if having a macro system pushed early on makes sense. I do think that it has the advantage that the rest of the system works on the assumptions of macro systems. When people discuss features of Rust, we think about how they must be macro-friendly and it won't lead to an issue. The space is there, it just hasn't exposed the best way to do this. We'll have to wait I guess.
C# is not interpreted. It is compiled to MSIL.
Yeah seriously. It's getting to be an every few day kind of thread and the answer is, it's under development every single time. It's like futures and hyper all over again.
So this is probably a very stupid question, but I've been seeing SIMD come up a lot lately, all over the place. The Wikipedia article leaves me wondering about the difference between simd and something like `rayon`, and what advantages it would have. My guess is that it's at a much lower level and thus faster?
&gt;Discovery is part of learning a new language. .. and [principle of least surprise](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) is part of designing a language.. discovery is fine, for doing *new* things. Not for 'changing two things in an array'.
Think of it this way: with SIMD, you're making a whole batch of cookies. With rayon, you and several other people are each baking one single cookie at a time. SIMD operates upon many pieces of data in a single CPU operation, while rayon just splits tasks into multiple threads. SIMD and rayon could conceivably be combined to achieve better performance than either - the analogy being you and several other people are each baking whole batches of cookies. I hope this helps!
&gt; https://github.com/jcriddle4/rust_small Hopefully at some point a few of the most common ones (and `split_at_mut` is probably one of those) can be incorporated into the book or some kind of "learn these things first" guide.
What's surprising about it? It's a method on slices. Via `Deref`, it also appears in the docs for [Vec](https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.split_at_mut). &gt; discovery is fine, for doing new things.. A lot of Rust is new compared to other languages, so discovery is a bigger part of learning it.
SIMD work on a single thread, and parallelize the same operations on the elements of a vector (for example, doing many multiplications in parallel). It's normally performed with a different instruction set, like SSE and AVX instructions. Note that your regular code can sometimes be "autovectorized" by LLVM and use SIMD. Rayon has a threadpool (something like one thread per processor core IIRC) and dispatch jobs using work stealing: when a thread has nothing to do, it "steals" jobs queued to be performed on another thread. So Rayon can be used for heterogeneous workloads, because each thread can execute different code. SIMD in comparison is more limited in what it can do.
Don't know what rayon is but I'd assume so. SIMD uses special instructions dependent on the cpu.
That's one hell of a pitch. Would be incredibly useful.
For the width, maybe try messing with the style? https://github.com/Gekkio/imgui-rs/blob/master/src/style.rs [Here](https://github.com/bjadamson/softland/blob/master/src/ui.rs#L382-L394) is an example of me messing with the style on a UI I'm working on. If you can't figure that out, I would try (just to see if it works) putting it within a [child frame](https://github.com/Gekkio/imgui-rs/blob/master/src/child_frame.rs) just to see if that worked. edit: I forgot to mention [there is](https://github.com/Gekkio/imgui-rs/blob/master/src/lib.rs#L795-L799) also a version that doesn't require an array of style's.
Thank you for your work on this! I would be happy to see an officially supported Rust planet.
In response to the responses to this, I think all of us in the know can nod and understand the utility of this package and why it would be named `http`, but I wholeheartedly believe that it is _inevitable_ that newcomers will be annoyed and confused. Many will hurriedly grasp for the first thing that looks like what they need (perhaps they liken it to Go or Node's http package) and spend some time before realizing that it actually doesn't do what they assumed. Sure, this wouldn't happen if they gave the documentation even a cursory skim, but many newcomers don't have the patience for that and just want to see what can be done before delving into the details, and any even _potential_ friction that we introduce between those two points is unnecessary and detrimental. I think this effect is only magnified by the fact that it's named something as simple as http, which may connote a feeling of reassurance, "Hey you need to do something with HTTP? Don't worry, that's why we made it as easy as possible, look, we named the crate 'http' not Hyper or Rocket or something which you would probably only know were _for_ HTTP if you were _already steeped_ in the Rust ecosystem. We made it easy for you." Again, us in the know can justify it a million different ways for why we are in the right, but newcomers don't always fit perfect molds that we're expecting them to fit into. Little things like these might undermine the otherwise valiant efforts the team and community have been undertaking for outreach to newcomers.
&gt; i.e. write some code, the compiler lets you know there is a better way to phrase it Doesn't Clippy do that?
[removed]
The principle of least surprise is overrated. 
One example of what I mean https://crates.io/crates/array-init
... OK, this is a new low. Not only is this the wrong subreddit, this isn't even the *right* wrong subject. *Look* at a subreddit before posting to it. Or read the explicit warning on the submit page that this isn't the appropriate subreddit. I don't even...
/r/playrust Here is rustlang. Edit: wrong link...
SIMD uses instructions that operate on multiple pieces of data at the same time on the same core. There are instructions for multiplying one set of numbers by another set, adding one set to another, copying one number into an entire set, shuffling the order of numbers in a set, and so on. These instructions take about as much time to complete as the regular, single-operation instructions, so it makes the code run much faster if it can take proper advantage of these instructions. For a simple example, if you're writing code that just adds up every number in an array, you can take something like let mut acc = 0; for i in 0..nums.len() { acc += nums[i]; } and turn it into let mut accs = [0, 0, 0, 0]; for i in 0..nums.len()/4 { // These four operations complete in a single CPU instruction accs[0] += nums[4*i + 0]; accs[1] += nums[4*i + 1]; accs[2] += nums[4*i + 2]; accs[3] += nums[4*i + 3]; } let acc = accs[0] + accs[1] + accs[2] + accs[3]; This new code runs four times as fast. Rayon, on the other hand, separates code into multiple threads of execution. Modern CPUs can execute multiple lists of instructions at once, and each core can quickly switch between multiple lists. When you run multiple threads, your computer will execute some of them at the same time. Let's say you have a 2-core CPU. You can have one thread add up the first half of the list, and a second one add up the second half at the same time. Then, you add the results together, and you've finished in half the time. Since one lets you do multiple things per instruction and the other lets you run multiple sets of instructions, you can do both at the same time. If you split the code across two cores, and have each core use SIMD instructions to add four numbers at once, you'll get an (almost) 8x speedup overall.
I wound up using ugly string processing. Still not sure how you break up or search paths for directories. Tries some odd .components() iteration, but it didn't really work well.
I'm having trouble compiling my code on Windows. I'm getting *error: could not exec the linker 'link.exe': The system cannot find the file specified*. I have Visual Studio 2017 installed - from what I understand, that is supported as of 1.19? Do I need to add the linker to my path somehow?
Awesome work, Ticki. I can't wait to use this. 😀
Isn't there an automatic c-to-rust translator that makes liberal use of unsafe? I may be totally misremembering, but if so then you could just use that on example programs (or someone could throw together a website that does it for you compiler-explorer style).
If the future were boxed, it seems like you could preallocate the box with any such borrowed local variables already inside it so they persist after `await`. Not sure how feasible that is. [ETA] I suppose implementing it with source transformation probably makes it impossible/impractical to consult the borrow checker.
It is not ideal but helps you avoid js a little. With templates, everything is generated server side so no need to write js for simple pages. But yeah, rust with web assembly would be nice :).
&gt;First, @sdroege and @antoyo are now official members of gtk-rs, congratulations to them! &gt;@antoyo is the creator of the relm crate and also the one who wrote the bindings for webkit2gtk-rs. I admittedly don't know much about the Rust ecosystem, but does that mean the design of the relm crate will be incorporated into the gtk crate? Because some quasi-standard binding would probably be really nice!
cool. any news on 1.0?
Having just read /u/aturon's post now, I'm curious what it is exactly that's stopping crossbeam from getting its garbage reclaimed in your case /u/ticki_. Is it because the epoch counter isn't being incremented (meaning there's no garbage that's guaranteed safe to collect), or because the data is still being processed in some way, even though it's actually garbage, and hence crossbeam won't remove it? Or some other case I'm probably missing :)
This is my work-in-progress proposal for what would end up in `std` (well, probably `core`): https://github.com/BurntSushi/stdsimd --- You can see API docs here: http://burntsushi.net/stuff/stdsimd/doc/stdsimd/ A precursor to simd is `target_feature`, which has an open RFC: https://github.com/rust-lang/rfcs/pull/2045 I have a fork of the `simd` crate that uses `stdsimd` as well, as a proof-of-concept: https://github.com/BurntSushi/simd/tree/stdsimd
&gt;Unfortunately it's not quite possible because functionality of built-in reformat action is used in almost every edit/refractor/snippet action in Intellij world What would be nice is to be able to configure Intellij formatter format exactly as rustfmt or at least allow for the customization to do that. 
At the moment, that's *probably* a perma-unstable feature, and instead, we'll expose specific vector types tagged with `repr(simd)`.
Thanks
Ok thanks
Hi, I'm getting this kind of an error: warning: doc comment not used by rustdoc --&gt; src/errors.rs:8:1 | 8 | / error_chain! { 9 | | foreign_links { 10 | | Diesel(::diesel::result::Error); 11 | | DieselMigration(::diesel::migrations::RunMigrationsError); ... | 20 | | } 21 | | } | |_^ | = note: #[warn(unused_doc_comment)] on by default = note: this error originates in a macro outside of the current crate Strangely, Google returns 0 hits for "unused_doc_comment". I don't have any doc comments in the `error_chain!` macro. The error message looks like the output of the macro might contain some, that aren't used by Rustdoc? Or is it just a bug in Rustdoc and/or error_chain?
By the way, I would recommend godbolt.org for doing that kind of inspection.
Basically, move the vector types from the simd crate into std. The current solution has a number of problems, and answering your question is some good chunk of the RFC I'm writing. 
&gt; Just because there's a demand for a solution doesn't mean it happens quickly, and if it doesn't happen quickly, then people might not want to use the language. I think Go is a shining example of this.
Every non-trivial "safe" thing. Anything with dynamic allocation uses `unsafe`, which applies to every single container except tuples and arrays, which are very inflexible. Anything that may `panic` uses [`unsafe` code](https://github.com/rust-lang/rust/blob/master/src/libpanic_unwind/lib.rs), which applies to all arithmetic operations that may overflow. I/O is `unsafe` because it eventually hits either libc or syscalls.
As a rust beginner, the idea of my workflow being crippled by not knowing about something like `split_at_mut` fills me with the most unhappy feeling. Like even *arrays* are hard to master in this language. The complexity require to have a real borrow checker infects every other part of the language. Then people say that the borrow checker is only hard for the first week. Like ... are you serious?
I always enjoy reading posts about Tock. I live in Australia and unfortunately I can't attend Rustconf, is there any chance the training session could be recorded? Generally, I'd love it if all the workshops were recorded, but I understand if that's not possible. 
&gt;In all of these cases, users are can used shared references (&amp;) to mutate the value. I am reading this now. The above is not very clear to me. May be some typo? 
I don't think it'll be recorded, but the "syllabus" and other materials will be available online
Yep, a typo, thanks! Fixed.
By hand: by modifying the original SVD file. It's just that I checked in the patch rather than the whole original file. We want to have more sharing between different device crates because the layout of their registers look similar if not are exactly the same between devices from the same family, but it's tricky. We are discussing how to make progress on that area in [this issue](https://github.com/japaric/svd2rust/issues/96).
Hey, this was really accessible and a good read.
Is windows support planned?
Looking at the ASM on the playground, the const ends up in a rodata section as ref.0, and it loads that address into %rax, and then moves %rax to the two local variables. edit: Finding it in the ASM/IR is much easier if you set the value to something like 12345.
Yes, please.
Awesome post. One of the most useful explanations/motivations I've seen for types like `Cell`, which I very much have not managed to understand just yet.
&gt; The problem is that Rust can't compile files in parallel, while C can. Plus LLVM is a problem. The only solution that I see to this problem is to get a really, really beefy CPU. I believe that part of the problem is essentially that rustc generates really, really bad code, and then shoves it all into LLVM to clean it up. LLVM does a great job cleaning it up, but it has to do a lot of work to do so. Part of the goal of rustc's MIR intermediate stage is to generate better code from the get go so that LLVM doesn't have as much work to do. The not-able-to-compile-in-parallel also sucks (a lot), but I really don't see a good way around that unless one changes Rust's compilation semantics or figures out a way to multithread LLVM. In the end though... well, rustc does a lot of things that, say, C# doesn't need to worry very hard about (or can foist off to the JIT, maybe). It would honestly be very interesting to try to make an apples-to-apples compilation speed comparison between Rust and C++ code compiled with, say, clang.
It's hard not for the first week, but for the first week you actively try to understand it and not just try to route around it.
It looks like it's a false positive from the new lint and it's been [fixed recently](https://github.com/rust-lang-nursery/error-chain/pull/199).
This isn't just a problem with searching APIs, it holds for searching _anything_ when you don't know the name.
&gt; Is there a rough time frame you think that opinion would change? Hard to make a guess. It depends on how many people are on board with Rust and willing to write drivers *that are not tightly coupled to some kernel / runtime*. &gt; Is there anything currently for Rust that might have some advantages over &gt; RFTM? Depends on what you are doing and how much effort you want to put into *not writing your application*. Binding to some C library / framework can give you a head start but then you have to create a Rustic API on top of it to make the API safe; without that you are just writing C code in Rust syntax. &gt; Tock looks interesting, it's GPOS not RTOS though from what I understand? Yes, from what I've seen it's a traditional-ish OS with a kernel / userspace split (i.e. syscall interface) and a focus on process isolation and security. If you want to use Tock you are limited to the devices they currently support unless you are willing to port the kernel and write the capsules (drivers) you need. Which is not that different from using RTFM, I suppose, except that there's no kernel to port as the primitives work for all Cortex-M micros and a bare metal driver (in C or Rust) may already exist. &gt; I don't need an RTOS but my interests are usually with deterministic timing &gt; which RFTM seems suited for running bare metal? RTFM is a bare metal, zero cost actually, scheduler. &gt; I guess the likelihood of that happening is a good while off in years? For some things, yeah, probably years. At least for Bluetooth there are open source drivers that can be translated to Rust; OTOH WiFi tends to be more closed source. At the end there will be new chips coming every year so there will always be new code that needs to be written but a properly architected driver should let us reuse the protocol bits so that only low level device specific I/O details would need to be written. &gt; What about connecting another board that focuses on wireless that doesn't run &gt; Rust? Certainly doable. But it may be non starter if you are building a commercial product due to the increased cost and board size this approach entails. Or it may not, it depends on what you are building. &gt; I've seen some boards like BeagleBone Blue that has a Cortex-A8 and a &gt; Cortex-M3 From [this thread](https://news.ycombinator.com/item?id=13875597) it seems that the Cortex-M3 is used for power management of the Soc and that it's not programmable. The SoC does seem to have PRUs like some other Beaglebones but those use a custom ISA that rustc can't emit. &gt; Photon boards have had Rust support for a while, I noticed you've been &gt; involved with that too. While they do not run pure Rust, I could still develop &gt; for those with Rust instead of C and have a good experience? The photon related crates expose bind to the C API so the whole API is not exposed; also not all the C API has a corresponding safe idiomatic Rust API yet. The photon API surface has quite a bit of C++ API which bindgen can't currently deal with; that C++ API is much harder to bind to because C shims are required. &gt; Reading about RTFM I was under the impression from the blog posts that I could &gt; get a board going and controlling LEDs, reading sensor data, controlling a &gt; servo etc. You can but you can also do that *without* RTFM. RTFM is not concerned I/O; it only gives you memory safe multitasking / concurrency. For I/O [svd2rust] gives you a register level API for your device if you have a SVD file for the device. For some people this is enough; they are used to work with registers and to create custom higher level APIs tailored for their applications. Other people don't want to ever deal with registers; they want to work with a higher level API. This group will have to wait until someone writes a higher level API for them. [svd2rust]: https://github.com/japaric/svd2rust &gt; So uhh.. what other common functionality is required that the quickstart &gt; doesn't touch on? Quickstart includes svd2rust so you have access all the hardware to do I/O *at the register level*. As for what else is "required" see my previous paragraph. &gt; Are you referring to this difference?: The first line is the API automatically generated by feeding a SVD file to svd2rust. It operates at the register level. The second line is a higher level API I wrote. You can find it [here]. [here]: https://github.com/japaric/blue-pill &gt; If that is the equivalent of what you mean by implementing a driver, for LEDs, &gt; sensors and servos, Yes, that's what I mean by "driver": a higher level API that hides device specific details like the name of registers and magical hexadecimal values. &gt; perhaps that isn't so difficult to put together for my own use-cases, but &gt; Bluetooth/WiFi I'd imagine is more complicated.. I'd say the difference is around two orders of magnitude. Implementing a higher level API for stuff like digital I/O, serial, PWM is in the order of tens of lines (see the blue-pill crate linked above to get an idea) whereas WiFi is probably in the order of thousands of lines of code due to all the protocol logic. &gt; That API(before the more friendly one in 2nd example) came from svd2rust and &gt; became the stm32f30x crate from what the quickstart seems to imply? Yes, the stm32f30x crate was generated using svd2rust and it's where the register level API used in the first line comes from.
&gt;one lets you do multiple things per instruction and the other lets you run multiple sets of instructions Aha! Thank you!
Alright, officially-supported, production-ready fortran compiler of a similar calibre to gfortran. Clang competes with GCC so LLVM's C optimisations are great, but Fortran gets no love so the alias restrictions aren't fully used.
Clippy is a very shallow version of this. eg. In theory, you could analyze unsafe code and sometimes make it safe code.
With the recent 0.9 release of nix my attention has shifted back to my [fat-rs](https://gitlab.com/susurrus/fat-rs) crate. I implemented multiple file access over the weekend (up to 4 can be opened at at a time). I have two next steps: 1) Get it compiling properly in a `no_std` environment (there's a ton of debugging `println!`s in the code) and test it on real hardware. 2) Allow for creating empty files or directories. At that point I'll be at the point where I can really start testing out the API in a real project and see how well it works.
Continuing my Gameboy Emulator. I'm loading Tetris in and I'm able to execute instructions down to `0x27F2`. I've noticed its writing into tile and sprite memory so I should be able to start rendering things on screen soon. I've implemented timers and interrupts as well. I am generating the `V-Blank` interrupt but I am not currently servicing it. Once I am confident I have enough graphical data available I'll start servicing it and begin rendering things on screen. Hopefully this time next week I'll have a screenshot to share.
You said "simple". Also Windows and OSX, neither of which use CSS for their interfaces.
But it's not cross platform ;-)
Yes there is some degree of parallelism, but its not as parallel as in C. In C, can compile every compilation unit in parallel, even if there are dependencies between compilation units. The biggest sequential component is the compilation unit with the longest compile time. In Rust, a crate can only be compiled if compilation of all its dependencies is finished. The biggest sequential component here is the longest path through directed acyclic crate dependency graph (where vertices are weighted with the compile time). There are [proposals](https://internals.rust-lang.org/t/towards-a-second-edition-of-the-compiler/5582) to only require partial compilation of a dependency until the compilation can start, but nothing has been implemented or decided upon by anyone official yet.
I think it's pretty dismissive to suggest people just 'aren't trying hard enough' to understand the borrow checker. I've been using rust for over two years and the borrow checker is still hard. You can certainly gain a *basic familiarity* with the borrow checker in a few days, but it'll still trip you up. Remind me again why: let mut q = HasValues { values: vec!(1, 2, 3, 4, 5) }; let mut p = borrow_values_that_match(&amp;q, &amp;|f:isize| -&gt; bool { return f &gt; 2; }); fn borrow_values_that_match&lt;'a, 'b&gt;(x:&amp;'a HasValues, filter:&amp;'b Fn(isize) -&gt; bool) -&gt; Vec&lt;&amp;'a isize&gt; { ... } is ok, and: fn borrow_values_that_match(x:&amp;HasValues, filter:&amp;Fn(isize) -&gt; bool) -&gt; Vec&lt;&amp;isize&gt; { is: '^ expected lifetime parameter', and: fn borrow_values_that_match&lt;'a&gt;(x:&amp;'a HasValues, filter:&amp;'a Fn(isize) -&gt; bool) -&gt; Vec&lt;&amp;'a isize&gt; { ... } is: 'borrowed value does not live long enough'? The closure that never gets used again isn't alive for long enough? Why is that again? What is 'b again? Why does &lt;'a, 'b&gt;, but not &lt;'a, 'b: 'a&gt; make it ok? Not obscure at all right? come on. There's absolutely nothing wrong with people saying the borrow checker is hard to understand. It *is*. 
wxWidgets is also not bad from my experience.
At least they expand to good functions with a deterministic amount of stack space for arguments.
Yeah, this definitely should be changed. Actually there is longstanding issue for that: https://github.com/intellij-rust/intellij-rust/issues/431
&gt; efficient [...] extremely performant system for concurrently handling memory. It is more general and convenient — and often also faster — than epoch-based reclamation &gt; Epochs and classical hazard pointers are generally faster than this crate, &gt; That being said, there are cases where this library is faster than the alternatives These three claims of performance don't seem to line up (often faster but also generally slower with only "cases" that are faster?). Do you have some more concrete numbers to give us a better picture of what the tradeoff translates to? &gt; The issue with most other and faster solutions is that, if there is a non-trivial amount of threads (say 16) constantly reading/storing some pointer, it will never get to a state, where it can be reclaimed. My understanding is that GC can only be blocked if a thread gets stuck inside a single `epoch::pin()` critical section for an extended period of time. Specifically, - collection is only blocked [while there are threads running critical sections where the local epoch isn't the current global one](https://github.com/crossbeam-rs/crossbeam/blob/cb9dca913a5e2f083e765b8e344212743e1a42ac/src/epoch/participant.rs#L96), - every thread's local epoch is [updated to the global one each time it enters a critical section](https://github.com/crossbeam-rs/crossbeam/blob/cb9dca913a5e2f083e765b8e344212743e1a42ac/src/epoch/participant.rs#L69). - the global epoch [only moves forward when collection happens](https://github.com/crossbeam-rs/crossbeam/blob/cb9dca913a5e2f083e765b8e344212743e1a42ac/src/epoch/participant.rs#L103), so the current epoch of all threads entering and exiting critical sections *will* catch up to the global one, no matter how many of them there are (and the threads that aren't entering/exiting critical sections don't effect GC), In summary, threads that make progress won't be blocking collection. Of course, a single thread could definitely get stuck in a critical section (say, if there's a CAS loop that fails consistently), but a system that regularly hits that form of starvation might indicate another problem, or, at least, another region that needs optimisation. Maybe I'm missing something about the problem you hit?
I don't have access to a Windows machine so I can't do this myself but I'll gladly accept pull requests for Windows support :-)
Ok, I've almost ready for STM32F40x... Will create a crate for it and also writing a BSP crate for my board... Your blog post was sufficient for me Rust noob to do the ports, in the end everything goes well :-) It's my first time that I got my hands dirty with Rust but in the end: I'm soooo excited. Thanks for your work and sharing of it.
You write great code. I aspire to your levels of productivity and skill :)
Why wait for a Fortran frontend for LLVM when there already is a pretty darn alright Rust frontend just waiting to be used as argument in lobbying for those kind of optimizations at LLVM's org? ;) cc /u/steveklabnik1
I reckon Rust will be _the_ language for gamedev in 5 to 10 years, it has all the benefits of Fortran combined with all the benefits of C++ with none of the downsides, so basically the whole gamedev stack (the BLAS stuff and the rest of the engine, respectively) could be replaced (except for the gameplay programming I guess, but there's nothing preventing Rust from having bindings as high-quality as C/C++'s). I'm not in the games industry myself, so I don't know exactly what's missing in the ecosystem, but as far as language-level features go I think everything that would be necessary is on the roadmap. I think that the LLVM hint you're talking about is `noalias`, which according to /u/steveklabnik1's comment is unfortunately no longer emitted since LLVM doesn't handle the interaction of `noalias` and exceptions properly. If you really care about enforced loop unrolling, Rust's upcoming improved procedural macro support will probably allow seamless unrolling (something like an `#[unroll(step = 4)]` annotation that would unroll it 4 iterations at a time). I don't know how important explicit unrolling is nowadays though, were the PS3/360-targeting C compilers lower quality with regards to optimisation?
Oh absolutely, I'm just saying that if there was a Fortran frontend then we wouldn't have to lobby at all - they'd exist already. I don't know if Fortran supports exceptions though, so the current bug preventing us from emitting `noalias` might still exist (see steveklabnik1's top-level comment). If only GNU IR was targetable without tearing your hair out, it's got _the_ Fortran compiler built on top of it and as far as I know GCC consistently emits faster code than clang/LLVM.
Rust *does* evaluate arguments before a method call. The problem is that it evaluates the *receiver* before the arguments. Actually, I'd suspect that most languages do, it's just that Rust cares about mutable aliasing, which is what surfaces the issue. It's all well and good to say that given `a.b(c)`, Rust could obviously evaluate `c` first, then `a`, then call `b`... but what if instead you have `complex_function_with_side_effects().b(c)`. If you evaluate `c` first, and `c` *also* has side-effects, you now have the language evaluating expressions right-to-left which is going to be *even weirder* and more unexpected. This sort of thing needs to be hashed out in Rust because Rust cares *very deeply* about details which other languages just don't.
It's true about the upfront ('front-loading' is one of those Rust words like 'ergonomic'). But the point remains, first you need to learn C. And if you know Rust, you can still do C albeit in a less terse way. I'm not sure about the much-imitated C `for` statement, with its opportunities for finger trouble. I recall Stroustrup saying that writing explicit loops is 'tedious and error prone'. That being said, it isn't evil to use `for` in Rust, the functional style is a good tactic but not a requirement for club membership.
[You can tell](https://github.com/redox-os/tfs/commit/19a787f0ee1ea773a3da722c9cfa6b6c6aee749a) 😉
I don't think building Rust tooling around C is a good idea; most of Rust's value comes from having been willing to be a clean break with C. I really wouldn't want to have to know C to de able to write Rust.
But surely full rebuilds are not such a common thing? What's the small-change-debug-build time? Not saying it _isn't_ a problem, I'm sensitive to compile times and my C++ projects compile relatively quickly.
That doesn't make any sense in Rust, because this is not a cast.
We don't intend to for the moment. I'd prefer to only keep bindings in the gtk-rs organization.
1.0 is so far away that it hasn't even been mentioned once.
A clean break with C is impractical. this thread relates to writing **unsafe code**, and C is the defacto established standard for it: I haven't seen anything else that can express these sorts of things more efficiently. bear in mind other use cases like 'decoding blobs' etc. A lot of people that come to rust seem to have an anti-C reaction and they think writing something more verbose is somehow going to help in these cases . It isn't. these use cases can only be verified empirically , so verbosity just slows down writing the tests. I keep explaining the need for **unbounded array indexing** ; if you've got **bounds checks**, *that is an admission that your code has not gone through sufficient testing to be confident of it's logic*. What you have is a **debug build**. You can't use it for engine control software. (if it panics , your plane will still fall out of the sky). I have practical suggestions as compromises, but I keep running into to this philosophical 'anti-C reaction' . It's funny how even the C++ community has this. a refusal to accept where C is actually *good*.
here's what I ended up with, but it give's you back a vec of components instead of a pathbuf. Couldn't figure the last part out. Wouldn't say it's easy to use, but I guess you could wrap it in a function or trait. https://play.rust-lang.org/?gist=c8c531cc2c7fca7ea7c5cbf6c040b073&amp;version=stable edit: For someone that know's a little more, any reason why I can't collect to Components? It's defined in the docs as: impl&lt;'a&gt; Iterator for Components&lt;'a&gt; type Item = Component&lt;'a&gt; but I get the error: the trait `std::iter::FromIterator&lt;std::path::Component&lt;'_&gt;&gt;` is not implemented for `std::path::Components&lt;'_&gt;` I know it's a lifetime of '_ instead of 'a, but not sure why it's not working. https://play.rust-lang.org/?gist=ef7f6a92f84f685d9f0ab5b1dbb62bb3&amp;version=nightly
 Crate 'tarpaulin' does not exist the crate of the week is not linked correctly i guess ...
&gt; this thread relates to writing unsafe code, and C is the defacto established standard for it: I haven't seen anything else that can express these sorts of things more efficiently. There are any number of languages that can do direct memory manipulation; C is just popular because of Unix. &gt; I keep explaining the need for unbounded array indexing ; if you've got bounds checks, that is an admission that your code has not gone through sufficient testing to be confident of it's logic. What you have is a debug build. You can't use it for engine control software. (if it panics , your plane will still fall out of the sky). This is outright wrong. A core part of building reliable software systems is that when your code gets into an invalid state you panic immediately and handle it. Look at Erlang's "let it crash" motto, and then look at the systems that have been built in Erlang. Now of course it's better to not need bounds checks - but you do that by *proving* you don't need them as in the functional tradition, not by blindly assuming they're going to pass as in C.
&gt; There are any number of languages that can do direct memory manipulation; C is just popular because of Unix. Show me another that can do it as elegantly. so C and unix rose together; did that happen because of practical compromises that allowed them to accelerate past the competition? &gt; A core part of building reliable software systems is that when your code gets into an invalid state you panic immediately and handle it &gt; Look at Erlang's "let it crash" motto, and then look at the systems that have been built in Erlang. let your plane crash, let your car crash. let your VR game drop frames, and the user vomits. no. a *truly* reliable software system **DOES NOT GET INTO INVALID STATES**. It's been tested empirically until you're confident it wont. (a lot of science is ultimately empirical, 'we're 99.99% sure...' ) it would sort and count before it enters the critical loops, or know that immutable data has been verified on entry to the system. There's a concept of 'failing gracefully' where you've already prioritised such that if you run out of buffer space / time, you'll have sorted and approximated first. An example of this is an intelligent LOD system in rendering. The program doesn't **panic** if you try to draw too many primitives. Rather, it sorts the objects by priority, first, then drops the LOD levels , until it knows the load is within acceptable levels. *then* it enters the rending loop, confident that there will be no command-list buffer over-run. *I do accept the 'erlang way' has valid use cases*, maybe even 'covering most'. But if you are talking about 'a potential C replacement' there are other use cases where this philosophy is not sufficient.
maybe they don't :) it's still early days
Could be, maybe I'm a bit spoiled with gdb support in eclipse.
&gt;&gt; is the first thing that any unsafe code tutorial/talk teaches/covers. thats still way more effort than I'd expect. 'it's like C/C++, but you need an unsafe block to do anything dangerous'. the expectation is that you can open an unsafe block and get going using [] to do unsafe work. Anything less is sub-optimal ergonomics, .. stop trying to pretend it isn't. trying to distance it from C/C++ is unwise ; rust should build on these rather than try to replace them. Indeed, it relies on **[LLVM](https://en.wikipedia.org/wiki/LLVM)** which is *written in C++*, and relies on bindings to C libraries for many serious tasks (OpenGL.. vulkan..). I'd wager the world will get reliable pervasive static analysers before you could re-write a project like that. C *is* still better at low level work, so I'd argue we must teach C here incase anyone in this community is crazy enough to think it's *worth* replacing (with rust in it's *present* form ... I *do* believe you could improve on C, but it will take a philosophy shift here to do it)
Could cargo do a search-by-type-signature thing similar to [hoogle in haskell](http://hoogle.haskell.org/?hoogle=Int+-&gt;+MVector+a+-&gt;+%28Vector+a%2C+Vector+a%29&amp;scope=set%3Astackage)? Though that probably wouldn't help when someone just wants to use slices.
Matz, who popularised the principle of least surprise through Ruby, made it very clear that it was designed for his surprise, not some one elses. http://www.artima.com/intv/ruby4.html Money quote: "The principle of least surprise means principle of least my surprise. **And it means the principle of least surprise after you learn Ruby very well.** For example, I was a C++ programmer before I started designing Ruby. I programmed in C++ exclusively for two or three years. And after two years of C++ programming, it still surprised me." (which kinda points to the fact that "surprise" is highly subjective)
With a println!
Something similar to `elm package bump`, which diffs the previous and new API and updates the version number based on what it can infer? I'm not aware of any.
So, I have a [concurrent hash table](https://ticki.github.io/blog/an-atomic-hash-table/) of cached files. Since the whole system (often) accesses multiple files at a time, there is never time to garbage collect. Also, the API is super annoying (not because it's poorly written, but because of how epochs works) making it hard to create complex structures properly.
You can actually use the Webkit2 Web Extensions to make web apps in whatever language you want. The DOM APIs are available in the native bindings--you do *not* need to go through JS! EDIT: [I see you already have an example!](https://github.com/gtk-rs/webkit2gtk-webextension-rs/blob/master/example/src/lib.rs)
cargo-release can bump versions, but the user has to specify how the version is bumped (patch version is the default).
Thanks.
Ah cool, i had not thought of a().b(c()) But i suppose i would expect that function application/invocation has precedence over resolution ( or what ever the name for "." is in this context). So i would expect x = a() y = c() x.b(y) (My knowledge of the interaction between '*' , '&amp;' , '.' , '()' is not that advanced )
deleted ^^^^^^^^^^^^^^^^0.7666 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/89487)
For methods I used tests and Asserts basically, files can get a bit bloated though.
&gt; is: '^ expected lifetime parameter', = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `filter` I couldn't explain it in a better way if I tried. &gt; The closure that never gets used again isn't alive for long enough? Why is that again? What is 'b again? Why does &lt;'a, 'b&gt;, but not &lt;'a, 'b: 'a&gt; make it ok? Because `'b: 'a` (or having them be the same) means that you want the lifetime of the closure to be at least as long as the lifetime of the return value. With functions, type-checking looks at function signatures and not at anything else
&gt; a truly reliable software system DOES NOT GET INTO INVALID STATES. It's been tested empirically until you're confident it wont. (a lot of science is ultimately empirical, 'we're 99.99% sure...' ) There is plenty of software that runs on millions of machines for years (sometimes decades), and yet bugs are found in code that hasn't changed for an equally long period. Even [Java](https://bugs.openjdk.java.net/browse/JDK-8072909) shipped with a broken sorting method for years! So I'm not sure how much emperical testing you require to be confident, but unless you test for all possible inputs, your confidence will be misplaced. Luckily we can actually mathematically prove properties of programs, which is a lot nicer than empirical techniques.
But that more or less *is* what's happening, and the source of the problem: the desugaring would actually be: x = a(&amp;mut o); y = c(&amp;mut o); // uh-oh! x.b(y) Computing the receiver requires (in the cases where this is a problem at all) borrowing it, which then prevents the argument (which also wants to borrow it) from working. Which is all to say: Rust *is* doing what you seem to expect it to, it's just that what you expect is actually subtly wrong in a way almost no other language will prevent.
Oh yes, I think we're all waiting on that. Not only more opportunities for multi-threading, but caching intermediate artifacts. I noticed something curious the other day - 1000 line library crate, regular debug 2.6s. Building as .so, 1.2s. The build step is the heaviest part of the total compilation cycle.
Some typos: imperitive generater
That's a cool project too! Asciidoc for the web makes good sense
The correct name is [cargo-tarpaulin](https://crates.io/crates/cargo-tarpaulin).
&gt; No quote was selected for QotW. :(
&gt; Unfortunately debugging is not supported from within the IDE as only CLion has the ability to debug with GDB I am not user of intellij-rust, but what is wrong with `gdb`? I personaly used it to debug rust code, see https://sourceware.org/gdb/onlinedocs/gdb/Rust.html
&gt; Do you have some more concrete numbers to give us a better picture of what the tradeoff translates to? HP (hazard pointers) are not faster than EBR (epoch-based reclamation). This has been researched and documented extensively.^[[1]](http://concurrencykit.org/presentations/ebr.pdf)[[2]](https://news.ycombinator.com/item?id=10133441)[[3]](http://www.cs.utoronto.ca/~tabrown/debra/paper.pdf)[[4]](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.135.9418&amp;rep=rep1&amp;type=pdf)[[5]](http://csng.cs.toronto.edu/publication_files/0000/0165/ipdps06.pdf) There was a recent paper^[[6]](https://labs.oracle.com/pls/apex/f?p=labs:40150:0::::P40000_PUBLICATION_ID:4899) published by Oracle Labs that improves performance of HP quite a bit using special support from the kernel, but they're still not matching that of EBR. &gt; My understanding is that GC can only be blocked if a thread gets stuck inside a single `epoch::pin()` critical section for an extended period of time. Your understanding is correct. If a thread gets preempted while it is in a critical section, garbage collection is effectively paused until the thread gets rescheduled and exits the critical section. During this time newly produced garbage simply accumulates.^[[7]](https://github.com/crossbeam-rs/rfcs/blob/master/text/2017-05-23-epoch-gc.md#oversubscription) This phenomenon is reminiscent of lock contention. If you have multiple threads contending over a single lock, your performance will drop massively simply because a thread holding the lock might get preempted. HP don't suffer from the problem at all, and that's the major advantage over EBR. For Ticki's TFS this is apparently an important issue, and therefore choosing HP over EBR is completely reasonable. Microsoft Research has recently published a paper on Snowflake^[[8]](https://www.microsoft.com/en-us/research/publication/project-snowflake-non-blocking-safe-manual-memory-management-net/#), where they use a hybrid approach: both EBR and HP, which is due to their own specific set of constraints. Different problem domain - different solutions. The paper is an interesting read and even mentions Crossbeam! The problem of "stuck" garbage collection with EBR can be alleviated in some ways. One method is thread throttling in case a lot of garbage suddenly accumulates. Snowflake temporarily deregisters "stuck" threads so that they don't block garbage collection. Project Deuteronomy^[[9]](http://cidrdb.org/cidr2015/Papers/CIDR15_Paper15.pdf) (again, from Microsoft Research) simply uses a fixed-size garbage queue. Crossbeam is currently going through a major revamp. We're building improved EBR^[[10]](https://github.com/crossbeam-rs/rfcs/blob/master/text/2017-05-23-epoch-gc.md), and Jeehoon Kang is formalizing^[[11]](https://github.com/jeehoonkang/crossbeam-rfcs/blob/relaxed-memory/text/2017-07-23-relaxed-memory.md) (and hopefully formally verifying) its correctness. It should fix many problems with the existing EBR and bring better performance. The new EBR will also be incremental and therefore have much shorter pauses. After building a solid base, the plan is to build several new concurrent data structures on top of it.
&gt;&gt;Luckily we can actually mathematically prove properties of programs If that was true, **we would not have bounds checks** it might be that the proof you describe is more effort than practical empirical testing, or requires more computational power &gt;&gt;"for years (sometimes decades), and yet bugs are found " .. sure, notice i do say "99.99%", not 100% &gt;&gt;"So I'm not sure how much emperical testing you require to be confident" there will be an 's curve' of x=amount of testing, y=reliability . if you can get through a few extreme stress tests the chances of remaining defects are sufficiently reduced . a bounds check on an array can be ruled out in cases where those array indices have some meaning later verified by some other calculation. A piece of erroneous code setting up an index wrong will quickly break something else. (for example, glitchy polygons in a mesh). Add immutability, and the bounds checks quickly become extraneous (check once on loading/setup..)
&gt; C is still better at low level work, No it isn't. I write a lot of C++ code for low level work and it is full of asserts everywhere. everything low level I've tried to do looks better in C or C++. Asserts are ok, they are one weapon in the toolbox - just because other mechanisms are better in some cases, it doesn't make them obsolete; Bounds checks to me are for 'debug builds', and I'd actually bracket them under asserts (.. e.g. a C++ debug build may well add a bounds check assertion inside operator[]) 
You can include non-Sync types like `PhantomData&lt;Cell&lt;()&gt;&gt;` in the struct that needs to be !Sync for an equivalent effect: https://play.rust-lang.org/?gist=8841ed465bff39db7548b6ccc14429d0&amp;version=stable
&gt; I was a C++ programmer before I started designing Ruby. &gt; (which kinda points to the fact that "surprise" is highly subjective) as far as I know Ruby isn't for systems programming. ruby isn't used for tasks where C++ is ideal. Perhaps he designed ruby out of frustration having to use C++ for tasks it's not designed for. Rust is being surprising *for C++ use cases*, and has ambitions as a C++ replacement. (and the language engine *can do it*, it would just take some philosophical tweaks to make it better *in all use cases*).
I'm sure it would help in other ways, and would be very useful to have. Actually, I wonder if we could just make types *called* 'slice', 'box' etc *in haskell*, and write something that superficially looks a bit like the rust libraries *in haskell*, and use hoogle :) ```Mut (Vec t)-&gt;Usize-&gt;(Mut (Slice t), Mut (Slice t) )``` === ```splitAtMut``` .. i think a brute force database is the only way to handle the completely general case discovery.. 'this looks a bit like these examples..'
link to the [github repo](https://github.com/paritytech/parity-signer)
If you have any ideas please let me know :)
It seems that rust failed to infer that `x_log_x` is a pure function because of the branching `if x == 0 { ... } else { ... }`. If you remove the branching rust compiler would optimize that. But it quite surprised me that neither g++ or clang++ does this kind of optimization, so rust run much faster that c++ on [this](https://gist.github.com/anonymous/e1ca15f49d54de0e5c787a0a04660f1b) code. Maybe there is a good reason not to do this kind of optimization...
It hurts legibility as well. And maintainability. Having people question "why did they do this?" when just getting started on each line is a true barrier to entry.
His argument isn't about the relationship of the language to the task, his argument is about constant, indivdual use of the language. Matz didn't design Ruby out of frustration with C++. He's also certainly not "frustrated with C++", it's pretty hard to frustrate Matz with a language. He's got a very clear model why languages are like they are, it's basically his most extensive hobby, turned into a job.
/u/stjepang's comments sums the things up very well. For sure, those sections were certainly contradicting, I meant to say "sometimes" not "often". I've updated the docs to be less confusing.
We'll have to wait for build times to improve by an order of magnitude before rust can hope to be *the* language for gamedev (hopefully that is part of the 5 to 10 years plan).
Right, and I'm sure that you know that perfectly well after spending a week learning rust. no. You've also been using rust for &gt; 2 years. That's my point. &gt; I couldn't explain it in a better way if I tried. *sigh~* That's not the issue. *You* already know what's wrong, thats why it makes sense to you. It's not 'what's wrong'; it's how do I fix it? How does someone who doesn't know about lifetime annotations know what the error messages actually mean? How many times have you seen people 'blindly adding lifetime annotations' because the compiler suggested it might fix the problem? I sure have. *All the time*. ...and we're not even going into object or trait lifetime annotations here. You may have internalised (as I have, perhaps I guess to lesser degree than some other people) how the borrow checker works, how lifetime annotations and specialisation work... ...but I flat out reject the idea that anyone can do that, after just spending a week where you 'actively try to understand it and not just try to route around it'. Rust is complicated. Rust is hard to learn. The borrow checker is particularly difficult for people to grasp. I think there's ample evidence to support these points. My point is not 'explain how this contrived example works': it's; this stuff isn't trivial, and it's hard for new comers, and it's not trivial even for experienced programmers. It's just a flip off to suggest otherwise. 
Great Job! I'm super excited to see the rest of your posts. Right now my boss and I are trying to convince the higher ups that a specific portion of code should be written in a language other than JS to be used in a new react-native app. My boss is pushing for Go and I'm going for Rust. This will definitely help! Thanks!
I'm a total Rust noob ... but really, this looks like **a lot** of typing for me for a simple thing. 
German language coders have an advantage, because we simply use the german word `typ` ;-)
I've been developing in IntelliJ-Rust then debug in VSCode+Rust+LLDB. I couldn't figure out how to debug in IntelliJ
This week I'm getting started on a browser-based schematic and PCB layout tool. The rendering and routing engines will be written in Rust and run in the browser via asm.js or WebAssembly.
It's "corrode", and it generates basically entirely unsafe code, yeah.
rustdoc does a limited form of this today, but it's not very good.
Great first footnote. "The two are basically the same thing" had me stifling a laugh. The second footnote appears to have a typo: then the(y) typical microcontroller Tock targets.
That's my setup exactly.
(fixed typo, thanks)
This was an LLVM bug https://bugs.llvm.org/show_bug.cgi?id=34023
He didn't say there's something wrong with GDB, but intellij doesn't support GDB debugging, only CLion.
Did you try [Rust for C++ programmers](https://github.com/nrc/r4cppp)?
But Clion is the same intellij as others. I mean it is possible to install `rust` plugin for it.
Wouldn't that imply that it's closer now that it has been mentioned? &gt;:D
You are definitely correct. I created the upstream(rust) bug on it. Is LLVM the source of much of the slowness in Rust compiles or is it mostly on the Rust side?
No, in fact it's the opposite: every time someone mentions it; I delay it by a month! :p
This should work: par.iter().skip_while(|x| *x != "about").collect::&lt;PathBuf&gt;()
&gt; Is LLVM the source of much of the slowness in Rust compiles or is it mostly on the Rust side? The answer is sort of "both". In virtually all profiles I've seen, LLVM takes up 50% of the time. However, in my understanding, part of why it takes so long is that we make LLVM do a ton of work that, in theory, we could do ourselves. Generating extra LLVM IR to have LLVM compile it away is slower than not generating extra IR in the first place.
The error message is right, `Components` indeed doesn't implement `FromIterator&lt;Component&gt;`, which is necessary to call `collect()`. Note that having `impl Iterator&lt;Item=X&gt; for Xs` does not imply `impl FromIterator&lt;X&gt; for Xs`. In fact, these two traits often have very different implementors. While `Iterator` is implemented for structs carrying out lazy iteration (e.g. `Map`, `Filter`), `FromIterator` is implemented for collection types (e.g. `Vec`, `HashMap`).
Thanks, I was skipping over the "From" for some reason when I was reading it.
Can you be both "native" and "cross-platform"? My understanding is that Rust has good bindings for native UI libarries (winapi, GTK, cocoa), and also some cross-platform crates that provide pure-rust UIs (conrod comes to mind). But if a UI is native, then it cannot be cross-platform. I think your best bet in that case is QT, which looks reasonably native on all platforms, and has Rust bindings.
Though Rust is far from a concise language, I would suggest not taking that demo too far. The example was as it is at least in part for demonstration and lack of purpose.
&gt; It's funny how even the C++ community has this. a refusal to accept where C is actually good. I know of no good C++ programmers who would prefer to use C for _anything_. Especially since C++ can do everything C can do anyway. 
Ugh, really? So exploit the scanner is a possibility to gain SYSTEM level access on windows?
deleted ^^^^^^^^^^^^^^^^0.7861 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/48581)
Yep. And not only does MsMpEng have of parsers for zip, rar, jpg, gif, png, exe, etc. it also executes Javascript (and possibly other things?) in order to try and figure out if it's malicious. Any data written to disk that looks like JS will be executed: &gt; On workstations, attackers can access mpengine by sending emails to users (reading the email or opening attachments is not necessary), visiting links in a web browser, instant messaging and so on. This level of accessibility is possible because MsMpEng uses a filesystem minifilter to intercept and inspect all system filesystem activity, so writing controlled contents to anywhere on disk (e.g. caches, temporary internet files, downloads (even unconfirmed downloads), attachments, etc) is enough to access functionality in mpengine. MIME types and file extensions are not relevant to this vulnerability, as MsMpEng uses it's own content identification system. https://bugs.chromium.org/p/project-zero/issues/detail?id=1252 Mindbogglingly stupid. Granted, it's not any worse than every other antivirus software.
Yes, the rust plugin works fine. But it doesn't have GDB integration (GDB integration only works with CLion)
Deref is certainly a confusing thing in Rust, at first.
I've been looking for something like this. Not to sandbox MsMpEng, that's Microsoft's problem. I just want a general-purpose AppContainer launcher for windows applications. I run some questionable binaries from the internet and I want a way to audit what they are doing and deny access. Sandboxie et. al. have pretty poor UX and VMs don't work well for 3D apps. It seems Andy Ying has done 90% of the work. Perhaps I'll get around to finishing the other 90%.
I don't get it. You have CLion with installed rust plugin. CLion not allow you to use gdb integration if you open rust sources instead of c++ sources?
My rule of thumb is if `#[test]` or `println/printf` can't solve my issue I should refactor.
That was informative. Thanks.
I don't think `in` is a keyword at the moment though. Otherwise, as long as it's readable and not too verbose, I could care less.
C++ seems to be doing fine in that regards. Are Rust compile times that much worse? 
My preference in a situation like this would be to just hand a reference to the relevant data to the function, rather than an all-encompassing reference to the current object. Here's [an example.](https://play.rust-lang.org/?gist=aa0e28ea5790757c2313c791565ac797&amp;version=stable) But, what you have works! A user of that library seems unlikely to have any weird lifetime issues or other pains.
Rust compile times are much worse than c++ ones indeed (and I work on a code base with millions of lines c++). And more generally, game devs are asking for better productivity including better compile times more often than memory safety (agreed the latter is just one of the great things in rust).
Argh! Your link "10" points to Jeehoon Kang's relaxed memory paper (as 11 does). Any chance you could link to the article explaining how you plan to improve EBR?
Sorry! I've fixed the 10^th link.
Also with info! or trace!
Submit, submit!
To add on to what /u/burkadurka said, you can version = "0.11.0-rc.2" for error-chain, and the error will go away. It's a release candidate, so you should consider that before changing it, but that's what I did on one project.
Possibly dumb question: did you install the C/C++ Build Tools with VS 2017? That's the part where `link.exe` comes from. It should be able to find it if it existed... I'm still on 2015, but if I run `where link` in powershell, it can't seem to find it, but if I open up a "Visual C++ 2015 Native Build Tools Command Prompt" it shows up.
&gt; lobbying for those kind of optimizations at LLVM's org In my understanding, LLVM works like a lot of open source projects: opening a bug saying "please do this thing for Rust" means it'll sit there forever. Opening a pull request saying "I've implemented this thing for Rust" means it might make it in, but that means you have to have the time to actually write said patch.
Fair :)
It's not so much that they're that worse inherently, it's that we don't have incremental recompilation yet, so rust builds end up building a lot more than C++ builds do.
There is AppJailLauncher, it was created to run sandboxed executables during CTFs. It's not in rust but I think you might find it useful. https://github.com/trailofbits/AppJailLauncher
Which crate has those?
You probably have to do something similar to rust-sdl2: &gt; Copy all lib files &gt; to (for Rust 1.6 and above) &gt; &gt; `C:\Program Files\Rust\lib\rustlib\x86_64-pc-windows-msvc\lib` &gt; &gt; or to (for Rust versions 1.5 and below) &gt; &gt; `C:\Program Files\Rust\bin\rustlib\x86_64-pc-windows-msvc\lib` &gt; &gt; or to your library folder of choice, and ensure you have a system environment variable of &gt; &gt; `LIB = C:\your\rust\library\folder` &gt; &gt; For Rustup users, this folder will be in &gt; &gt; `C:\Users\{Your Username}.multirust\toolchains\{current toolchain}\lib\rustlib\{current toolchain}\lib` https://github.com/Rust-SDL2/rust-sdl2#windows-msvc The `LIB` env var one might not work, I think that uses pkg-config which bearlibterminal.rs doesn't use. You could also use `set RUSTFLAGS="-L C:\path\to\libs" &amp;&amp; cargo build`or add it to your build script: fn main() { println!(r"cargo:rustc-link-search=C:\path\to\libs"); } If you do figure it out, perhaps you can help improve the readme?
Good one 👏👏
Thanks for the props! AppJailLauncher-rs is open for Pull Requests. We're happy to further maintain all the software we release. :-D https://github.com/trailofbits/appjaillauncher-rs
(Even better, godbolt.org colors sections of the ASM the same as the Rust lines that caused them, handy.)
well, what I meant is compiler inserting `unwrap()` if you already checked it's safe. In Kotlin it's casting because java has null pointers, so anything you get from java is like Option&lt;T&gt; (but not really). something like if (something.is_err()) { return ... } // use something here like it was unwrapped and after. basically `if let` but without extra nesting. My real gripe with rust is inability of compiler to prove that trait implementation don't not overlap. no way to implement blanket for something that implements X, but doesn't implement trait in question. and no way to compare enum variants.
This blog post is written by the original author of AppJailLauncher about a rewrite of AppJailLauncher in rust.
[log](https://doc.rust-lang.org/log/log/index.html) ninja edit: you also need a logging *implementation*, like [simplelog](https://github.com/drakulix/simplelog.rs) or [env_logger](https://docs.rs/env_logger/*/env_logger/). the linked page has details though.
That's what I like about rust. A lot of things that you need to debug in Java just don't exist in rust. Don't like me start on ObjC where you can send message to null it's all cool. How many times I've send objects to uninitialized NSMutableArray...
&gt; well, what I meant is compiler inserting unwrap() if you already checked it's safe. In Kotlin it's casting because java has null pointers It is quite dissimilar, a cast does not change the representation of the object, just what the compiler thinks of it, in essence it's a type assertion. That's not the case when unwrapping an Option (NPO excepted) or a Result. &gt; no way to compare enum variants. Why would you not be able to compare enum variants? Just derive or implement Eq or Ord or whatever on the enum.
If anyone is looking for more information on operating systems written in Rust there is a project that is much further along. https://github.com/redox-os/redox
Oh, so I'm not the only one then ☺
Neat! Though i'm curious what are you looking to leverage rust for in React Native?
Woops, serves me right for reading the comment section before the article.
I've worked 10 years (on and off) in Java and never needed a debugger there either, simply because it's all so much more predictable than C, and if you code conservatively, deal with failures and log all unhandled exceptions or unexpected conditions that's often all the info you need. Failing that a few printlns or log lines generally reveal the problem. I wonder whether people need a debugger because they just code the "happy path" and then it all goes wrong and they have no idea what caused it. Or maybe there's a "debugger-based school of coding" or something, where people get in the habit of understanding code through a debugger?
If you make the container builder generic instead you probably don't have to trait ContainerBuilder&lt;F, M, L&gt; { type Con: Container&lt;F, M, L&gt;; } In general, this solution "works" to a point - you just keep pushing the generics up further and further until you reach a point where you don't need to. Or you reach a point where you need to but you can't, which is why generic associated types are important.
Fractally bad.
&gt; It is quite dissimilar, a cast does not change the representation of the object, just what the compiler thinks of it, in essence it's a type assertion. That's not the case when unwrapping an Option (NPO excepted) or a Result. I don't think you understand what casting i'm talking about. I'm talking `Int?` to `Int`, first one is either null or Int. Unwrap doesn't change representation neither, it just well, unwraps what is in that Option or Result wrapped. &gt; Why would you not be able to compare enum variants? Just derive or implement Eq or Ord or whatever on the enum. enum MyError { Something(std::io::Error) SomethingElse More(other::type::that::doesnt::impl::Eq) } In this situation only way to compare it is my doing patter matching, which leads to *very* verbose implementation of `Eq`. In my case I need to compare them only to make sure that is correct error is return in test, so manual implementation of Eq is not worth it, not it would be correct one implementation of `Eq`. They not equal, for that you need to compare what's inside too.
No need to be sorry, I'm glad you provided such an excellent collection of links to start with! --- After reading the proposal (looks good!), I have several questions/suggestions. **Thread-list/Thread-array** I think this may be a case where a jagged-array could be interesting. The type is essentially: `[*mut T; N]`, and each `*mut T` is a pointer to an array of size 1, 1, 2, 4, 8, ... (or a multiple of those, such as 4, 4, 8, 16, 32, ...). Due the exponential growth, the base array can be relatively small. Accessing a specific index is fast, and the number of sequential stretches grows logarithmically with the number of elements. (It is somewhat similar to an unrolled linked-list, with exponential growth and O(1) indexing) **Pinning/Epoch** Isn't there a way to have threads move from one epoch to the next in a more loosely coordinated fashion? I am thinking that it should be possible to have 2 epochs concurrently: - the deprecated epoch, - the target epoch (deprecated + 1). and have *4* vectors of garbage. Each thread should seek to move toward the *target epoch* as soon as possible, indicating to the other threads that they are no longer using any element of the deprecated epoch. Then, when no thread is pinned on the deprecated epoch, epochs can be moved forward. Of course, there might be a huge flaw I am failing to see here, however it seems to me it would solve the issue of having to reach a global pause time to be able to collect: threads pinned on the *target epoch* are not impending progress.
Sometimes happy path is the only path you know when you're dealing with poorly documented 3rd party nonsense...or anything related to music industry...
I'm building a pseudo-clone of Erlang/OTP in Rust called [Tino](https://github.com/tino-platform/tino). It's an stack-based, actor-based virtual machine so it has the potential to be extremely scalable and I'm trying to make it as rusty as possible. It's still in the really early stages but I have some of the core components put together so far.
Yeah the full name is cargo-tarpaulin for that cargo subcommand goodness. I called the github repo tarpaulin because as it's invoked like "cargo tarpaulin" tarpaulin seemed more logical name although I see how that could cause confusion.. Lessons learnt I guess
C++ allows one to hide the details of datastructures, e.g. treating code that uses arrays or link lists the same through iterators, using vtables easily, etc. but something happened... caches meant that pointer chasing etc didn't scale as well as straightforward 'flat' code (stepping through arrays linearly etc).. *the sort that's easy to write in C* C isn't obsolete, and bear in mind 'writing in C++' can mean using a C like subset at times my point is more aimed at the sort of C++ people who like to criticise C or pretend that C++ *isn't* built around it.
&gt;&gt;"because in C++ I do manually write all the asserts while in Rust the compiler does it for me." maybe you're manually writing bounds checks or something. Rust doesn't have inbuilt reasoning for the sorts of issues I ended up needing to write asserts for. My finding is the opposite: Rust is requiring more markup to let it prove trivialities which aren't really problems, which takes more time away from other tests I need to write anyway. If those other tests succeed ('is the geometry correct' .. 'does this encoder/decoder pair recover the original'), the probability of any 'low level issues' (simple errors like out of bounds arrays etc) is vastly reduced.
I'm using IntelliJ for development and Visual Studio for debugging (I'm on Windows).
I've seen that linker was given C:\Users\{Your Username}.multirust\toolchains\{current toolchain}\lib\rustlib\{current toolchain}\lib so I copied BearLibTerminal.lib inside this folder :) Thanks!
&gt; I don't think you understand what casting i'm talking about. I'm talking Int? to Int, first one is either null or Int. Both are a reference to an integer, that the reference may or may not be null is only a TS concern. In the same way, casting a Collection to an ArrayList does not change its representation, it's a reference (to an ArrayList) either way, the only thing that's changing is what the TS thinks of it. &gt; Unwrap doesn't change representation neither, it just well, unwraps what is in that Option or Result wrapped. NPO aside, `Option&lt;T&gt;` and `Result&lt;T, E&gt;` do not have the same representation as T (since they need a discriminant), the unwrap has to move the value out to a subset of the original somehow. 
&gt; The main reason why I decided to use Rust in this project was that I already had all modules written in it and ready to use (or at least I thought so)
deleted ^^^^^^^^^^^^^^^^0.9820 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/75627)
if you put bounds checks into those types, then compose them, how is that any different to the rust libraries? Are you just complaining that the standard libraries don't have a bounds check option. the standard libraries are open for replacement, get stuff from boost or roll your own, and community ideas can be absorbed back into the standard. Just as someone had to write *the rust standard library with bounds checks* , people can , and do, put bounds checks into C++ libraries **I don't need a whole new language for a bounds check** (I need it for other reasons, like getting rid of header files, getting 'immutable default',etc)
Can you make an example here? I am really having trouble mostly in the build function. I don't know how to create an instance of a container (that's the section in Java i use reflection). Should build get the generic parameter through turbofish `fn build&lt;X: Container&gt;(&amp;self) -&gt; X` and call it with `*.build&lt;IntContainer&gt;();` or do i need to have the generic parameter come from the Builder itself impl&lt;F, M, L, C: Container&gt; ContainerBuilder&lt;F, M, L, C&gt; for AContainerBuilder&lt;F, M, L&gt; { --skip-- fn build(&amp;self) -&gt; C { //how to construct a C? } } EDIT: the turbofish appraoch lead me to [this Playground-Example](https://play.rust-lang.org/?gist=9e48e9271a2de7f4acdf29a6adedf910&amp;version=undefined) i also added a `create` function to the `Container` unfortunately i get this error: error[E0308]: mismatched types --&gt; src/main.rs:52:29 | 52 | IntContainer{first: f, middle: m, last: l} | ^ expected i32, found associated type | = note: expected type `i32` found type `&lt;X as Container&gt;::F` EDIT2: the other way coming from the ContainerBuilder parameter list in [this Playground](https://play.rust-lang.org/?gist=75cca9eabbfe255866f6eb6e9570be5e&amp;version=stable) is leading to this error because i don't really know how to tell the Compiler the Type of `C` error[E0282]: type annotations needed --&gt; src/main.rs:108:8 | 108 | ib.first(1_i32).middle(2_i32).last(3_i32); | ^^^^^ cannot infer type for `C` 
try the manufacturing industry. I swear to god, the people they hire to write machine api's for cnc machines are the people who got fired while trying to write printer drivers who couldn't cut it. sheesh!
deleted ^^^^^^^^^^^^^^^^0.4346 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/65443)
I like that there are two 90%'s that need done.
As written, IntContainer::create is supposed to be able to create an IntContainer value that can contain many different kinds of values (based on the container type inferred from the caller), but it only returns a specific IntContainer that cannot contain other values. One way to resolve this would be to make IntContainer's members generic over three types: struct IntContainer&lt;F, M, L&gt; { f: F, m: M, l: L }
[removed]
looks cool; but dang thats a bunch of toolchains to make an app lol
&gt; Stratis aims to deliver equivalent features and ease of use of volume-managing file-systems like ZFS and Btrfs but via a hybrid model. Stratis is being developed by Red Hat developers but hasn't received too much widespread attention yet. Stratis is described in a white-paper from April by lead developer Andy Grover: &gt;&gt;Stratis is a new tool that meets the needs of Red Hat Enterprise Linux (RHEL) users calling for an easily configured, tightly integrated solution for storage that works within the existing Red Hat storage management stack. To achieve this, Stratis prioritizes a straightforward command-line experience, a rich API, and a fully automated, externally-opaque approach to storage management. It builds upon elements of the existing storage stack as much as possible, to enable delivery within 1-2 years. Specifically, Stratis initially plans to use device-mapper and the XFS filesystem. Extending or building on SSM 2.1.1 or LVM 2.1.2 was carefully considered. SSM did not meet the design requirements, but building upon LVM may be possible with some development effort. https://phoronix.com/scan.php?page=news_item&amp;px=Stratis-Red-Hat-Project Having such an important piece of RHEL written in Rust is a big deal!
Industrial controls API's are such a swap. I did SCADA based systems for years, it is horrible :\ 
Another solution is to template your code on the container type rather than the container's member types: https://play.rust-lang.org/?gist=6f738cb0f55d961df6d5ec4ebf45802d&amp;version=stable . This potentially makes more sense, because otherwise you're trying to write code that could theoretically build any type of container, but relies on very specific argument types in many places.
Another solution is to template the container builder according to the specific container that it will build, rather than the member types of that container: https://play.rust-lang.org/?gist=6f738cb0f55d961df6d5ec4ebf45802d&amp;version=stable .
This is just life.
I think this is simply the way things are. If somebody wants to use the name though, you can transfer ownership to them, but I don't what that entails in practice. I assume they just get to publish a new version of the crate, which is now their code instead of yours.
In the short term, Stratis is aiming to be shipped in Fedora 28: https://fedoraproject.org/wiki/Changes/StratisStorage
&gt; I think this may be a case where a jagged-array could be interesting. Thank you for the suggestion! :) We will definitely give jagged arrays a shot - they seem like the way to go. &gt; I am thinking that it should be possible to have 2 epochs concurrently. The method you've described sounds perfectly reasonable. The method in the RFC is very similar, except it distinguishes 2^64 epochs. But it still has a notion of the *latest* and *previous* epochs (just like the *target* and *deprecated* epochs). Then any garbage created in epoch `X` can be destroyed as soon as the global epoch becomes `&gt;= X + 2`. &gt; Of course, there might be a huge flaw I am failing to see here, however it seems to me it would solve the issue of having to reach a global pause time to be able to collect: threads pinned on the target epoch are not impending progress. Threads pinned on the *latest* epoch are not impeding progress, just like in your method. I'm not sure why you think the method in the RFC has to reach a *global pause time* (or what exactly that would mean). Perhaps the text is not as clear as it could be. :) Problems arise when a thread gets preempted or stuck for some reason. Even if the thread is pinned on the *latest*/*target* epoch, the global epoch will be able to advance just once, but not twice. So garbage collection still can't make much progress.
Put "Hey this is abandoned if you want it please email me" in the description, and then if anyone pings you, give it to them. &gt; the crate is apparently still getting downloads less than once a week. We download crates in order to check if the compiler still works on Rust code; you might be seeing that.
To clarify on your comment, Redox is very cool in that its a functional OS, kernal, userspace, UI, apps and all. If you are interested in learning about writing an OS from scratch, you're likely to find the OP's blog post series most useful. If you are interested in hacking on an already working OS in Rust, then check out Redox.
😎
Imagine having a pipeline that starts with a simple row in postgres that has a reference to xml file. Result either have to an entity or null. Thousands reason why entity couldn't be created. Plus multiple versions of xml standard that is created not just to describe music but everything and even Allah. They don't follow standard to the letter, and then on top of it there is complicated filters to enable/disable things in runtime. So you sit there an think why this row out of 40M other doesn't have mandatory field set and why is track got caught in filters. One time I had to use a debugger because somewhere on 9th circle of hell someone used `startsWith` instead of `equalIgnoreCase` and I was getting NPE in a place it's logically impossible to encounter. Anyway I think as system become more complex you will have to use a debugger and got through the code step by step. 
I think this explains why they're depricating Btrfs.
&gt; Slices are language level constructs, but with built in bounds check. You can make a slice in C++ easily, and add a bounds check. there's a standard one coming, i've heard ('span' i think). the standard library tended not to use them because it used pairs of iterators instead (more general). there's a 'range' construct for those in boost too. I do prefer slices.. but it's a pure library issue, not language. this is an example of exaggerating rusts capabilities, if you think it's something inherent that C++ can't do. There are plenty of other things that are hard to retrofit though. &gt; Safety by default just makes me way more productive (as in never debug a segfault) i find these issues to be trivialities; the effort always goes into algorithms/ behaviour, figuring out how to use libraries, whats going on with events etc. 
Thank you very much – i just need i few minutes to comprehend this :P EDIT: Ah, ok this is essentially "just" pushing the "wannabe ATC" into the generic parameter list ... but would work essentially the same? Mhhm i am wondering why i though i needed ATC in the first and i am asking myself why this does not work with the `type CON: Container;`. I think it is because associated types are really "backed" into the type but i need it to change in my case! I really need to reread nickos posts about ATC ... i have the feeling ATC wouldn't be much help here. 
Is this a duplicated answer? because the link to the playground is the same than your sibling answer.
I debug using CLion, it supports the intellij Rust plugin. It's still very early and has a hard time with any function that has a macro in it.
Gdb works fine with clion. But most people use the rust plugin with intellij (since it has a community edition). 
Okay, I can see the use of a debugger when it's an out-of-control codebase that has spiralled beyond the capacity of humans to comprehend, and you don't want to take on the 'git blame' of the massive refactor required to make it sane. Still, in your sane part of the code you can log everything that happens that is unexpected from the non-sane parts, to direct the "pointy finger of blame" in the right direction.
Here's something that compiles: https://play.rust-lang.org/?gist=02c1282762618020b95f8f492e9581a3&amp;version=stable You can make the container generic too.
I see, how would you feel about a crate having an "Abandoned" flag that could be turned on for the crate at which point anyone can come grab the name and upload a new version but only if that new version doesn't match any of the old versions. That's more or less what's suggested here but with the "Abandoned" flag we don't have to worry about being able to contact the original maintainer.
This has been talked about a number of times but never really got off the ground. A lot of stuff doesn't get abandoned on purpose; it's "I don't have any time for OSS this week." time passes... "oh it's been two years." In this (IMO, majority) case, such a flag does not help.
I think that's the longest Rust RFC I've ever seen.
I kind of wondered about such a thing being automated. For example if a crate receives no new versions and no genuine user downloads in something like 5 years auto mark it as abandoned. I'm not so sure about the 5 years number, but something like this might help with name decay. I'd hate to have a scenario in the future of "All the good crate names are taken by crates no one uses anymore."
&gt; I'd hate to have a scenario in the future of "All the good crate names are taken by crates no one uses anymore." There are much older and larger ecosystems than ours, and this hasn't been a significant problem. I hear your worry, for sure, but I don't think it's something we have to worry about.
I'm with /u/staticassert. People will just have to get over it. If you can't contact owners, just move on. Names aren't that important. Effort spent on engineering a technical or policy pseudo-solution to a trivial problem is effort wasted, IMO.
Thanks! But isn't `AContainerBuilder` only able to build `IntContainer`s? So it is essentially the same as `IntContainerBuilder`?
Yeah it's pretty big. Definitely for good reasons though. This isn't the easiest of subjects to get right.
Stratis lead dev, AMA.
How does it differ from [TFS](https://github.com/redox-os/tfs) that /u/ticki_ is writing? I don't know much about filesystems, so these two projects seem roughly similar in that they are both inspired by ZFS.
OPC UA or OPC DA. All I need to say. Spend thirty minutes looking into it, then consider I haven't yet killed my liver with alcohol. The guys who built it had no knowledge of programming design, they where purely machine shop people. COM! hey, let's piggyback our security on top of domain security licenses. Hey, bonjour for resource discovery sounds good.....nah follow the standard? of course not! lets implement our own! hey why not make a push *and* pull based protocol which requires an event loop and a poll loop! Hey, I built the standard (pronounced only) version of the framework for this...wait...I screwed up....lets just tack a '2' on the end of the class and continue...hmm...that's wrong also...ok a '3' then....um....'4'? yeah '4'. 3 broken unusable versions with one working version. awesome. ooh ooh let's make it so to implement standard behavior at the leaf of the hierarchy you have to reimplement a bunch of stuff at the root...but without mentioning how it's done! that's awesome! I sometimes look at my wrists and dream of sweet release.
I'd love to know this as well! Seems like an interesting project.
you can add tags to a crate, putting the "abandoned" tag on it wouldn't be a bad idea, in addition to the description.
^ there are two types of complexity. implicit and technical. Implicit complexity is the complexity just inherit to the problem. it's just the way it is. I want to do x when y and z when not y. This requires complexity, there is not option to avoid it. It's just the domain you are working in. Technical complexity is the complexity that is added to implicit complexity because of the details of the *tools or processes* being used to solve the problem. inheritance vs composition when solving the problem. a new 'thing' added to the domain inside the programming model since the model doesn't match the business domain well, etc etc. I've yet to see a problem so complex that the implicit complexity reduces a person to incomprehension. The inherit tools of deconstruction, hierarchial concerns, domain mapping, etc etc etc. has always allowed us to 'block box' parts so we can solve the problem without considering the entirety of the gestalt. It's worked in every case across every human endeavor...so far. Though this may be a case of "if we can't solve it with these tools we can't solve it so that's just the boundary of human conception", but I doubt it. That being said, *technical complexity* is easy to expand into incomprehension. Most of the artistry of programming tends to revolve around solving the problem without exploding technical complexity.
Why do you believe btrfs' difficulties may never be fixed?
This is gold! IMHO this solves Rust most annoying paper-cut.
The funny thing is that this paper cut required the equivalent of a full operating theatre to solve. Thanks to Niko and the other core devs for this!
&gt;&gt; A lot of Rust is new compared to other languages, actually it's taking tried and tested ideas. it's just blending them in one place. 
This is probably pretty close to what you're trying to achieve: https://play.rust-lang.org/?gist=1f1e14ac7265e5f00ed38a0d1c5fabbb&amp;version=stable
Yup. With `npm`, people just get more clever with names. It's to the point where if a package has a very on-point name, I assume it's no longer maintained (e.g. `http` or `math`). This works fine provided there's a good way to find the best crates/packages for a particular use case and IMO that is where the focus should be.
&gt; There are proposals to only require partial compilation of a dependency until the compilation can start, but nothing has been implemented or decided upon by anyone official yet. And unfortunately it sounds like implementing that would slow down the compilation of leaf crates.
Hi! I don't know enough about TFS or Redox's architecture, so please forgive (and correct) anything I say that's inaccurate. TFS is entirely new. It defines new on-disk data formats that enable new features listed, and of course being written for a new OS in a new lang (Rust) everything's been developed from scratch. Stratis takes a more incremental approach on how to provide new features like CoW, snapshots, integrity, etc. These capabilities already exist in a "bag of parts" sort of way on Linux via its device-mapper (DM) subsystem. Linux already has existing great (traditional-style) filesystems like XFS. Stratis configures these existing components in a layered fashion. This makes its development easier: we already have a filesystem layer, a CoW layer, an integrity layer, a RAID layer. Instead of creating this functionality, the work becomes *managing* these layers on behalf of the user, so that they function as a unified whole. The downside is that Stratis misses some opportunities made possible by an [integrated approach](https://blogs.oracle.com/bonwick/rampant-layering-violation). But, the advantages that we see for this approach are: We can write it in Rust since Stratis is primarily a userspace daemon (no Rust drivers yet in the Linux kernel :-)); it's easier to provide monitoring and API since it's already in userspace; and the aforementioned already-written, tested, and debugged capabilities for "free" so we can deliver an initial solution in short order, as well as sharing the work &amp; benefit of new storage features with the other users of device-mapper, such as LVM. This last part was really brought home for me earlier this week with the Permabit news. Once that technology is made available in-kernel upstream via device-mapper, Stratis and other projects can enable dedupe and compression much more easily than each project could separately.
It was already posted recently [here](https://www.reddit.com/r/rust/comments/6r4um6/rustbased_framework_to_contain_untrustworthy_apps/).
I am not a filesystem kernel hacker, so this opinion is based on the expertise of those who are, and have evaluated it.
Is this similar to the [IntermezzOS](https://intermezzos.github.io/) project?
Are NLLs to live along-side LLs or is this a replacement to what we currently have? Also at the very bottom I see reference to "Existential Lifetimes" is that supposed to be an even further advancement in theory?
"I have no idea, but it might, so _get that impl outta here!_" -- the coherence checker, cackling with glee.
Yes! But also have a look what [josh did](https://www.reddit.com/r/rust/comments/6r65k1/do_i_need_generic_associated_types_aka_atc_here/dl2r4tk/) its more elegant this way and i think it is exactly the difference between choosing the turbofish approach and the other way around through the generic parameter list. Your example can use the turbofish on build let ic = AContainerBuilder::default().first(1).middle(2).last(3).build::&lt;IntContainer&gt;(); whereas the solution from josh is going from "above" and use the tubofish at `AContainerBuilder` let ic = AContainerBuilder::&lt;IntContainer&gt;::default().first(1).middle(2).last(3).build();
Well I used the CLion trial and maybe it's only a minor annoyance but it always forces you to use cmake. The community edition lets you create a 'rust' project, CLion does not.
So right now I'm looking at 5mb xml file and trying to figure out why this said pipeline failed. It can't be sane if you have account for many possible branches that are "documented" by standard and ever more that are vendor specific and have zero spec. &gt; Still, in your sane part of the code you can log everything that happens that is unexpected from the non-sane parts, to direct the "pointy finger of blame" in the right direction. It's only possible on small portions of code. Locally I still rather use a debugger than logger in most cases, simply because logging there make no sense there. I just don't believe in sane private code. Doesn't matter how you refactor it. Code I'm debugging right now is well written and organized, but they're so many different execution paths it can go just because of nature of input data. 
That's what happened with me. The only crate I have where this really matters is ramp, but matters it does. Fortunately somebody reached out to me and offered to help out development. Generally, I recommend contacting owners of seemingly-abandoned projects. I don't have time to work on OSS stuff, but I do have time to reply to an email and fiddle with some Github settings. 
Never ceases to amaze me the great work that's going into Redox (though this looks like it has much wider applicability than just Redox).
In particular, the help is needed to [check the guidelines](https://public.etherpad-mozilla.org/p/rust-api-guidelines-threadpool) and provide examples that [can be included in the cookbook](https://github.com/rust-lang-nursery/rust-cookbook/issues/225).
&gt; Are NLLs to live along-side LLs or is this a replacement to what we currently have? I could be mistaken, but I think NLLs are meant to generalize LLs. So if your code works with LLs then it will work with NLLs too. Assuming I'm right about that, I would guess the plan is to replace.
Yes. phil-os is basically the classic in the "teaching OS programming with Rust" space.
phil-os is a teaching operating system. It's not meant to ever go somewhere. I've seen Phil speak lately and he said that he'd rather refactor/extend the current content and implementations.
I've been casually learning rust for a little over a week and the expected lifetime parameter problem is clearly outlined in the 2nd edition of the rust book. I would have been able to recognize the function needed lifetime parameters and *why* from the error message. As to: fn borrow_values_that_match&lt;'a&gt;(x:&amp;'a HasValues, filter:&amp;'a Fn(isize) -&gt; bool) -&gt; Vec&lt;&amp;'a isize&gt; { ... } I'm not sure why that gives you an error. So there's that. 
As I understand it, it's a backwards-compatible replacement. Everything that is currently valid will remain so, but whereas now the only way a borrow can be dropped is for it to go out of (lexical) scope, the new mechanism will be able to track the lifetime of borrows more accurately, such that something like: fn silly_example() -&gt; String { let x = "blahblah".into_owned(); let y = &amp;mut x; y.truncate(4); return x; } Becomes legal. Because the under NLL, the borrow made by `y` is seen to be dead after the `y.truncate(4)` line (because there are no further references to y in the source code of the function), and thus x can be used again. Whereas previously borrows were only counted as dead at the end of a block. It's basically just making the compiler a bit (quite a lot) smarter, but getting it to track when variable is actually no longer used, rather than using the simple, but overly conservative rule that a variable is no longer used when it goes out of scope.
&gt; implementing that would slow down the compilation of leaf crates. Not neccessarily. If you give everything to LLVM in chunks, and enable incr comp, it will only recompile changes, everything else will remain unaffected. At least in debug mode. Don't know about release mode, but maybe there we could have two separate phases: 1. compiling all crates to MIR, 2. compiling all MIR to actual compiled code, each crate in its own compilation unit.
WOW ! The most impressive RFC I've ever seen since beta. That is gold ! I can't wait for it to be implemented
Do we know if there are any cases where the new inferences breaks down but LL inference (if you let me call it that) would work?
I think the LL rule would still be present in the new system, it's just that there would also be other rules. So I don't think the new NLL inference can break down in cases where the old LL inference works. It is non-lexical lifetimes in addition to lexical lifetimes. (maaaayyyy have said the opposite above - oops!).
I think the LL rule would still be present in the new system, it's just that there would also be other rules. So I don't think the new NLL inference can break down in cases where the old LL inference works. It is non-lexical lifetimes in addition to lexical lifetimes. (maaaayyyy have said the opposite above - oops!).
I think the LL rule would still be present in the new system, it's just that there would also be other rules. So I don't think the new NLL inference can break down in cases where the old LL inference works. It is non-lexical lifetimes in addition to lexical lifetimes. (maaaayyyy have said the opposite above - oops!).
I think the LL rule would still be present in the new system, it's just that there would also be other rules. So I don't think the new NLL inference can break down in cases where the old LL inference works. It is non-lexical lifetimes in addition to lexical lifetimes. (maaaayyyy have said the opposite above - oops!).
I think the LL rule would still be present in the new system, it's just that there would also be other rules. So I don't think the new NLL inference can break down in cases where the old LL inference works. It is non-lexical lifetimes in addition to lexical lifetimes. (maaaayyyy have said the opposite above - oops!).
I think the LL rule would still be present in the new system, it's just that there would also be other rules. So I don't think the new NLL inference can break down in cases where the old LL inference works. It is non-lexical lifetimes in addition to lexical lifetimes. (maaaayyyy have said the opposite above - oops!).
"welcome to frontend, where all the tools are strong, all the devs are good-looking, and all the languages are above-average"
&gt; VMs don't work well for 3D apps unfortunately this is because given the present state of D3D/OpenGL drivers, 3D acceleration is basically impossible to secure. if you want secure execution, you either need a totally separate machine, or software rendering.
The [top comment](https://news.ycombinator.com/item?id=14909843) on hacker news does a pretty good job of explaining why. 
Ready for a dumb answer? I think so but I'm not 100% sure, is there an easy way to check? There is a link.exe in *C:\Program Files (x86)\Microsoft Visual Studio\2017\BuildTools\VC\Tools\MSVC\14.10.25017\bin\HostX64\x64* and 32 bit versions in similar folders. Not sure if that means anything.
what about people already using that abandoned crate? if you put new crate instead.
When you invoke the code: { let y = ... let x = borrow_values_that_match(&amp;y, &amp;|f:isize| -&gt; bool { return f &gt; 2; }) } &lt;--- This entire block is the scope of y, and the lifetime of the borrow &amp;y but: &amp;|f:isize| -&gt; bool { return f &gt; 2; } Only exists for the duration of the function call, so it's scope is only the scope of the *inside* of `borrow_values_that_match`. By putting 'a on both arguments on the function, I'm asserting that they must have the *same* lifetime, but the arguments I've passed don't, so it's an error. By adding 'b, I'm saying 'the lifetime of the closure is unrelated to the lifetime of &amp;y', so it's totally fine for it to be shorter. (This is also why 'b: 'a doesn't work; there I assert that 'b is &gt;= 'a, ie. the closure lives at least as long at &amp;y, and potentially longer; but once again, that isn't true in this case). It's really just a contrived example I invented to make the point that annotations are complicated; basically the reason it doesn't work is that you can't assert that the lifetimes of two arguments is the same, then pass in a pair of arguments that aren't. Since the closure is a temporary variable, it has a different (smaller) lifetime.
I asked about this a week or two ago and the answer was 'we're working on it', but you certainly haven't missed the results.
Hi there! 1. You don't actually need to put the url in the title, just put it in the url box when submitting (as you did) and then write the title without the link inside the title box. 2. This (/r/rust) is the subreddit for the system programming language called Rust. For the video game "Rust", please visit /r/playrust, and post your content there where it will be more appreciated. 
I can't immediately reconcile two statements. First &gt; we'd like to fix two shortcomings of the borrow checker: &gt; First, support nested method calls like `vec.push(vec.len())` Second &gt; There are some cases where the three points are not all visible in the user syntax where we may need some careful treatment. &gt; &gt; Method calls &gt; &gt; One example would be method calls: &gt; &gt; fn main() { &gt; let mut x = vec![1]; &gt; x.push(x.pop().unwrap()); &gt; } &gt; We propose the following error for this sort of scenario Why is the second proposed to be an error if nested method calls are intended to be supported? The two examples seem virtually identical to me. The only difference is the mutability, and I don't see how that should affect the result.
That makes more sense now that you've explained it. You're right though it seems simple in hind sight but it is confusing and not immediately obvious to figure out if you're coming in from another language.
Afaik NLLs are strictly more expressive than LLs, ie anything that is expressible with LLs is expressible with NLLs. I may be wrong, but that's the gist I've gotten from reading the various posts
Sure, but sometimes extra expressiveness makes inference harder. I have no idea if that's the case here. Hence my question. It could be that more things need lifetime annotations now.
Yes, good point. Any 3D app has DMA so it's a lost cause in that respect. I almost installed Qubes and attached my GPU to a Windows VM, but Nvidia cards dont work well for that (don't reset properly) and apparently that configuration triggers anti-cheat software. Realistically though, a run-of-the-mill Trojan won't use a GPU exploit or an AppContainer escape because they can just ask for admin access and get it. I think this approach may still be useful.
I am also very interested in the results of the survey this time around. There has been a substantial shift in my position on many aspects of rust now that I have been using it extensively for a while. Many of the input provided in the previous survey no longer holds. I want to see how aligned am I with the rest of the rust userbase as a whole on these matters (especially given that users here only form a small subset of all rust users). I eagerly await the results!
[removed]
1. How long do you estimate it will take until Stratis becomes suitable for use in production environments? 2. Can it handle pooling networked block devices together, or is running something like Ceph on top of Stratis required to achieve this? 
This is generally the case for all AV. They're C code written by design to parse attacker controlled information, and they all run as root.
Trailofbits does really awesome work, I'm often impressed by your projects. So cool to see a security company I respect using Rust. Thank you for the writeup and code.
GTK and Qt have themes that make their UIs look *almost* native. And feel *mostly* native. Some programs that use GTK or Qt have put in that extra effort so that they actually *do* look entirely native to most users, but it’s extra effort for them. Native controls are not simple. They tend to be rather intricate. Bear in mind things like accessibility as well—you’ve got to take into account many aspects of OS configuration (theme, OS version, any accessibility tech in place—and that’s not just screen readers). There is a reason why things like GTK and Qt are so complex.
I think "extra-expressiveness" makes conceptualization of the implementation details harder (just look at the RFC.) But the result will be Rust itself having an easier time determining lifetimes, and will give the user a more intuitive understanding of lifetimes.
We're still crunching away. We had a lot more responses, and going through the plain text takes time. Should be soon.
`vec.len()` takes `&amp;vec`, `vec.pop()` takes `&amp;mut vec`. That's the only difference I can see.
Some Thoughts. Gtk-rs is probably the best supported GUI available right now. It still has many missing APIs, rough edges, breaking changes, and lacking documentation. And that's with several people working on it pretty consistently for months. GUIs are hard, even when you're binding to something existing that you can generate code for. I'm sure in 1998 people were wondering why there wasn't a good GUI for python :P (Tkinter doesn't count as good). Gtk does support theming, you can apply a theme to the whole app to make it look like Windows or whatever, and also use CSS to customize stuff. You can't really distribute binary Rust libraries since the ABI isn't stable. You'd have to compile it for every released Rust version and then it still wouldn't work on nightly.
That is the difference, and it is important because it means you can get different results when you vary the order in which the method's arguments are evaluated.
From the [design doc](https://stratis-storage.github.io/StratisSoftwareDesign.pdf): &gt;Stratis doesn’t optimize performance within its data tier. Even the proposed performance solution (use SSDs) is *[very slow](https://gist.github.com/jboner/2841832)* compared to processor speed. If there's an opportunity to optimize away (prefetch it?) a read or a write why not do it ? Is this the wrong layer to look for such optimizations ?
What are your thoughts on bcachefs?
I'm developing a pavlovian response to seeing Niko's face pop up in my feed... [http://i.imgur.com/sR4iOFN.png](http://i.imgur.com/sR4iOFN.png) Always something good 😃
I'm not sure, but wouldn't making things require more annotations be a breaking change? That makes me think it won't change anything with lexical scoped lifetimes (modulo bugs of course).
This should literally just make more code compile.
That's all I could see too, and was what I was thinking of when I said "virtually" (though I have now made that explicit). But intuitively I'd expect the same behavior regardless. That is, I'd expect the mutable borrow for the argument to end before the mutable borrow for `push` starts, specifically because what `pop` returns is an owned value and not another reference.
&gt;doesn't work You're right; it's GTK only. I thought it was lower down but I was wrong. That's on me. &gt;can't expect can and do, especially for sigils which are on people's real physical keyboards. If someone wants to mangle their codebase by using symbols that never appear on keyboards, real or virtual, without extreme effort, that's on them, but there are a lot of people in the world I imagine wouldn't mind coding in their native script. "But I never plan on using this" is why we still have ASCII-only projects in this day. We're a Unicode-aware language; we should be Unicode-permissive in identifiers. &gt;fixed at four digits 􏿿 &amp;larr; U+10FFFF
I solemnly swear I'm not being snarky, but expressing actual confusion and/or a lack of understanding of character groups or lexing rules, *but* I don't understand why that's bad. Isn't ASCII broken up into "some are idents and some are operators" too?
New crate, new major version number. Old versions stay put, old users don't upgrade.
[removed]
Fittingly, I ran into my first NLL problem in a couple months just today. Toss in two curlies and it's a solved issue, but not having an otherwise needless new scope would be super.
New post in the series! As before *please* discuss in the internals thread, not here!
I have built a binary telemetry parser for work. It's a rather simple and unimpressive project, but it's replacing an ugly Python script, and will be the first of hopefully many Rust codebases powering our space missions. If anyone has reading material about searching in streams to throw at me, I'd love that. I plan on going through ripgrep soon to see what I can get from there.
But remember that according to the order of the evaluation `$THISFIRST.method_called_third($THISSECOND)`, so the borrow for `push` starts long before `push` itself is called! Remember that `$THISFIRST` might be a complex expression itself, that just returns a mutable borrow on which the method is applied to.
Isn't that exactly the same for `vec.push(vec.len())`, which is one thing NLL is supposed to help? `$THISFIRST` is only first now because it's _lexically_ first, to my understanding. So with NLL I'd expect `$THISSECOND.method_called_third($THISFIRST)`, more or less as if the argument were extracted to a local variable even it turned out to be a temporary.
The nested method calls proposal doesn't change the order of evaluation; that would be a breaking change, because it's already specified, and the expressions may have side-effects, whose order would change. The proposal is to allow a special case, where the mutable borrow returned by `$THISFIRST` is not seen as "actively mutable" during the execution of `$THISSECOND`. However, it's still seen as a (shared) borrow, which prevents `$THISSECOND` having a mutable reference to the same data.
Yes, it is, and everyone knows which ones they are. More or less. Here it's much more complicated because nobody understands the full set of unicode operators. IIRC it's not super consistent, there are characters which should probably be operators that are idents, and vice versa.
Ah, here's a succinct demonstration. I knew I'd seen a particularly absurd example somewhere. https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027112.html &gt; Let me tl;dr'er this even more: ☹️ is an operator, but 🙂 is an identifier. 
I still found it confusing... What if the author of "abandoned" crate decide to update it? I would add a timestamp for last update and mark crates which haven't been touched for a long time, but I am against replacing crates because we want that name. 
Ah I see what you're saying. That makes some sense, thanks. The only thing that complicates it in my mind now is that I thought order of evaluation was not formally specified and therefore technically free to change, though maybe that change is considered undesirable because there may be code relying on the unspecified order. Did I miss when it became specified?
Can this perform PTR requests? (like for reverse DNS)
I've been hacking away at a UI framework for a little bit, I've written a XAML like DSL using a procedural macro (inspired by relm, applying it to a trait impl). I've also written a CSS like macro for defining styles. [here's a screenshot of code for an example app] (http://imgur.com/a/XraDp) Right now it does: - Styling - Layout - Building a display list for WR. I am working on input at the moment and I guess invalidating styles (I'd love to get mouse hover working for example) ...then maybe down the road look into Futures-rs integration. 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/hKTrzwr.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dl3idtc) 
I have much respect for Kent Overstreet and think that people should subscribe to [his Patreon](https://www.patreon.com/bcachefs). I'd like to see it in the mainline kernel, and have it be developed in-tree, to maximize its development potential. We really don't have a lot of options when it comes to CoW file system solutions right now. I think we don't want to pin our hopes on just one effort like maybe people did with Btrfs. I'd like to see three or more projects with different approaches be successful, so users can always have options if one just isn't working for their needs.
I have plans to support that in the resolver, right now it only does fwd A and AAAA lookups. The trust-dns library can support a lower level API for doing direct queries: https://docs.rs/trust-dns/0.11.0/trust_dns/
My understanding is prefetch/readahead policy is in the filesystem. So since we're currently using XFS, whatever behavior it has is what Stratis would have.
Well, you already have the Kernel written, so that depends on what do you mean by writing an OS. If you mean writing the userspace, it shouldn't be more difficult than writing any other application. If you mean to extend the Kernel, it might prove a bit more difficult, but it has been proven to be possible.
I've been hacking away at a UI framework for a little bit, I've written a XAML like DSL using a procedural macro (inspired by relm, applying it to a trait impl). I've also written a CSS like macro for defining styles. [here's a screenshot of code for an example app] (http://imgur.com/a/XraDp) Right now it does: - Styling - Layout - Building a display list for WR. I am working on input at the moment and I guess invalidating styles (I'd love to get mouse hover working for example) ...then maybe down the road look into Futures-rs integration. 
1. It depends :-) How much of a dev, test, and user community can we build, that would accelerate progress? How many unanticipated issues come up? We're currently saying 2018 for the 1.0 release (we just tagged 0.1) which is the very earliest I would even consider production use, but there's a bunch of stuff that'll have, and a bunch of stuff it *won't* have. 2. Stratis is aiming to be a comprehensive *local* storage solution, so I think the answer is no, unless you're talking about a scenario where a machine has exclusive access to iSCSI or fibre channel luns. These just look like local block devices, and Stratis could use them.
&gt; Memory blowup, which happens when several threads constantly reads and writes, blocking garbage collection indefinitely and thus causing very high memory usage, if not out-of-memory. This issue isn't in hazards (like this design). I don't think this is not an accurate description of the problem with epochs, nor is it not an issue with `conc`. The detail of [the discussion yesterday](https://www.reddit.com/r/rust/comments/6qz9p2/conc_an_efficient_concurrent_reclamation_system/dl1sqmc/) was a little subtle: it's fine to have threads hammering on EBR-pointers, it's only possibly problematic when a thread is descheduled during a critical section (more likely to occur, e.g., if there's more threads than cores), blocking collection until it's can continue execution. Even then, it doesn't seem that problematic in practice: I instrumented crossbeam to log when a GC occurs, and collections still occur regularly even with a hundred threads just entering an EBR critical section allocating and `unlink`-ing some memory, and exiting the critical section, in a tight loop: the program still uses 12+GB of RAM and possibly growing, but it *isn't* caused by collections not running at all. It may well be that each GC doesn't do enough work, but that seems like something crossbeam can push on, e.g. each collection only clears the local and the global garbage lists, meaning each thread needs to win the GC race itself to clear its backlog; maybe some sort of wait-free-inspired "helping"/concurrent GC would help (if a GC is happening, other threads can probably join in and clear their own garbage, maybe?). There could also bugs in crossbeam, or it is hitting pathological behaviour in the allocator (I vaguely recall that some allocators optimise for the malloc/free pair being on the same thread?). In any case, I think the same descheduling problem happens with `conc`, due to [`Hazard::get` spinning on `BLOCKED`](https://github.com/redox-os/tfs/blob/0d54c1c7d0d3378b2aa99470d1bdb00804edb4a3/conc/src/hazard.rs#L99-L113): if a thread is descheduled between [requesting a hazard and protecting something with it](https://github.com/redox-os/tfs/blob/0d54c1c7d0d3378b2aa99470d1bdb00804edb4a3/conc/src/guard.rs#L61-L78), GC is similarly blocked, and blocked in a way that prevents progress completely on the thread trying to GC, rather than just accumulating garbage for a while (one could argue that this is good, as a form of back-pressure, but... I don't think a spin loop is the best manifestation of back-pressure, rather than something more structured/less wasteful). Of course, these critical sections are likely to be shorter than the EBR ones, but I'm not sure they'll be even an order of magnitude less, for many cases. Also, another problem that seems to currently be shared by both approaches is singled-threaded GC: the GC thread needs to be doing as more work than all the other threads, to be able to keep up, which means garbage needs to be cleaned up O(num_threads) times faster than it is created. For allocation-heavy work loads, this presumably depends a lot on the behaviour of the allocator.
Now if the control flow analysis can be exposed later to IDE debugging support…
Took me way too long to realize this wasn't a blitz to port libz to Rust.
&gt; most annoying paper-cut ELI5: Which one?