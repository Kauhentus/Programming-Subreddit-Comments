No promises, but I've spoken to people at Amazon who have hinted that Rust support is being worked on internally.
Did you try to pass \`--release\`? &amp;#x200B;
I think it would be best to make the syntax consistent (i.e. no `priv`, trait methods are private by default) and target edition 2021 for this change. The wait time would be a bit unfortunate, since I agree that there is a need for this, but I'd rather see it done correctly than end up denormalizing the syntax for the sake of a couple years' slight usability improvement.
Well knative you can use whatever you want for serverless.
How enviable! If only all of our problems had such little path dependence.
How much of the VM is the original chrome crosvm vs new code for firecracker? 
Hi, I'm the owner of the [ALSA](https://docs.rs/alsa) crate and I'm actually experimenting with [bypassing alsa-lib](https://docs.rs/alsa/0.2.1/alsa/direct/pcm/index.html) and using the kernel interfaces directly. This is to maximize performance and to have as few bugs (including latency bugs) as possible between the application and the hardware. If you're interested - sounds like it could be a good fit for your synth, if it wants to run on Linux?
So is this a sort of rump-/unikernel? They make it seem so but it doesn't mention those terms in particular.
crosvm is the Crostini Virtual Machine in ChromeOS.
My initial reaction is that the answer is no. The function accepts a `&amp;mut [u8]`, which is supposed to be a type-level guarantee that the referenced memory is initialized, readable, and writeable. There are still some open questions about how Rust should treat uninitialized memory (such as if it's okay to create references to uninitialized memory in unsafe contexts) but I wouldn't expect a safe function to behave properly in the presence of uninitialized memory.
You want /r/playrust
https://rustwasm.github.io/book/ There is even a WASM working group. I've used Yew, a wasm frontend, before in one of my projects and it works fairly well. Unless you mean something about the compiler itself can't be compiled. Then I have no idea.
So reimplementing it locally getting a *mut u8 is better?
This has a very "total annihilation" vibe to it imo :)
This is nice data to have for sure; but I personally find the granularity of the survey too coarse wrt. the difficulty of concerps, what challenges people face, and what Rust could do better, to base many language design decisions and priorities on it.
It's always a tradeoff, for sure. &amp;#x200B; There is free-form input, and one of the reasons processing the data takes so long is that it's actually read and taken into consideration, so there \*is\* room for more elaboration.
Ah; good to hear! :)
Why do you think that? It boot a linux kernel, so not at all.
&gt;What does it actually take for a crate to hit 1.0? This is an age-old question that is technically up to the developer. The SemVer spec recommends, but does not require, that 1.0 correspond to some measure of "production readiness", but doesn't define what that means.
Meltdown/Spectre involve cache timing side channels. You don’t even need to read the memory if you can infer it’s contents from timing.
You should definitely open an issue/pr on https://github.com/rust-lang-nursery/compiler-builtins for this improvement!
Why not pick both? `priv` doesn’t denormalize the syntax, I explain in my article that not using `pub` or `pub` would make it public. It’s non-breaking, so no need to wait for this feature! And yeah, we could change the trait’s default privacy for the next edition as you mentionned!
Possibly. It might be worth making an issue or PR on the rust-lang repo to see what other people think about the idea, but I don't know if the change would be accepted or not since, like you said, there's no real mechanism to state in the function's signature that uninitialized memory is permittable. I know there are some proposals for write-only references floating around, but I don't know if any of them have been accepted.
&gt;it derefs the buffer elements instead of just writing to it. This makes it not safe to use with uninitialized, right? So the difference between `&amp;mut` and `*mut` is that `&amp;mut` is managed but the compiler, and safety guarantees of rust. Where `*mut` is not. So `&amp;mut` is guaranteed to be initialized, and real. While `*mut` isn't. 
Hm, makes sense. And it's good that it's not being rushed to stabilize.
\&gt; Since then, however, @tirr-c recognized that there were substantial gains to be had by instead using an “around” design for the core trait: Historically, this approach has caused problems in Ruby (and I assume Python, but I know less about it), but I'm not sure that the downsides translate to Rust exactly. Here's the issue: Each middleware ends up becoming an object. Additionally, this increases the stack frame by a level of 1 for each request. This means that the GC has significantly more tracing work to do, and adds numerous jumps at each level of processing. That's why I \*think\* this shouldn't be a problem in Rust. The stacktrace thing for debugs is still there, but it's not like we don't already have fairly deep stacktraces in many scenarios. But something to consider...
Minor nit: the "how much work did it take to fix your code when you upgraded" graph could use some labels.
Language design is one thing, but right now there's a giant pedagogical hole between TRPL book and being comfortable enough to use rust for a non-trivial project, mainly due to concepts like the borrow checker, lifetimes, etc. Rust in Action might become the book that bridges the gap but it's still being worked on and there hasn't been an update since beginning of october. Essentially there needs to be a project/tutorial style resource that can guide the reader through common pitfalls due to rust-specific concepts and how to take the right approach to avoid them.
My primary concern with the whole rust 2018 thing was that things would be rushed. 
Yep! I had heard about this problem as well. Tide is likely to be far less "middleware-heavy" than Rails since a lot of the work will be done via "computed values" instead. But it's definitely something we should watch out for as things continue to evolve! (I also have some thoughts on "future proofing" here -- maybe worth opening an issue just to make sure we have somewhere to track this potential issue?)
&gt; I've always wondered why lambda doesn't offer rust as a language, then I got more confused when it added golang, which is uploaded as a compiled binary, and now this news makes it even more confusing. Each runtime is built by folks internally on an ad-hoc basis. Firecracker is a level _below_ Lambda/Fargate, providing isolation between each runtime (whether they be language-specific, in the case of Lambda, or a Docker container, in the case of Fargate). As cool as Firecracker is (and I think it's super cool!), it's more of a foundational technology that unblocks a lot of cool and complex features we'd like to support.
&gt;(I also have some thoughts on "future proofing" here -- maybe worth opening an issue just to make sure we have somewhere to track this potential issue?) Sure, feel free to file something and cc me :)
It's looking great for Rust. The answers for "underrepresented demographic" graphic don't add up. 92.06% (no) + 4.60% (yes, not specified) + 7.71% (LGBT*) = 104.37% While I understand that a person may be belong to multiple underrepresented groups these 3 should be mutually exclusive. &gt; The survey also highlights some challenges, as the number of women is still lower than the industry average of women in programming fields. Because how the question is worded I am wondering what the "peak underrepresented women" will be. If more women join the community a smaller fraction will feel underrepresented and choose the no answer. (This also applies to other groups.)
&gt;Most people take less than a month to get productive with Rust Man, really? I always struggle with the BC, especially when it comes to writing graphs and such.
As always, numbers are tricky! There's that 22% that still have yet to at all. &amp;#x200B; \&gt; especially when it comes to writing graphs and such. &amp;#x200B; Maybe the people who say they have just use petgraph :)
Not sure if you mean it as a good thing :)
"productive" is rather vague. I feel productive as in "I write programs which work", and it took me much less than a month, but I still don't feel at ease with many things in the language.
&gt;Blockchain shit meme
definitely yea.. whenever i try to re implement something from c++ to rust, i get stuck a lot due to especially borrow checker.... not that i can't accomplish it.. but more like it takes time to figure out how
It looks like currently no, but I'd expect it to go under the idioms lint eventually.
Back from RustFest Rome, and I'm still working on [mutagen](https://github.com/llogiq/mutagen), [TWiR](https://this-week-in-rust.org) and the [macro expansion in proc macros](https://github.com/rust-lang/RFCs/pull/2320) RFC.
Raster charts are painful to look at. Last time they were in SVG (afair).
&gt; The answers for "underrepresented demographic" graphic don't add up. 92.06% (no) + 4.60% (yes, not specified) + 7.71% (LGBT*) = 104.37% While I understand that a person may be belong to multiple underrepresented groups these 3 should be mutually exclusive. I'm not sure that's necessarily true. Somebody could identify as non-heterosexual *and* identify with another underrepresented group as well (e.g. maybe they're out as bisexual but not out about being transgender).
Can we get the languages breakdown? I'd like to know what % are the non-English responses.
What does the definition of scan_token look like? To help the compiler understand the lifetimes involved, I would expect something like this: fn scan_token&lt;'a, 'b, 'c&gt;(&amp;'a self, chars: &amp;'b [&amp;'c str], offset: usize) -&gt; Token&lt;'c&gt; { ... } If it doesn't include explicit lifetimes that relate the values stored in the `chars` slice to the Token return value, the compiler may be inferring the output lifetime from the self variable or some other argument that's passed in.
Thanks to all who put in the work to do the survey! Here is my strongest reaction from reading the results. Apologies if it comes across as a rant, I don’t mean to be overly critical. &gt; Over 40% of Rust users felt productive in Rust in less than a month of use, and over 70% felt productive in their first year. This seems to me like a very positive spin on a graph that is pretty scary to me. This means that for ~60% of users, it took them over a month to become productive. The post highlighted the significant portion which did not yet feel productive, but to me the even larger percentage which took more than 1 month, less than a year to become productive is just as concerning. Considering Rust as a tool with which to get work done, taking multiple months just to learn a tool before being able to use it meaningfully seems impractical. People generally don’t take 3 months to learn to drive before they can successfully drive to the grocery store. I don’t know of data to compare to other programming languages, but I would conjecture that a C++ user (for example), could become productive in Java or Python within say, 2 weeks. Rust is an order of magnitude off. Rust promises a lot of excellent benefits, but to me this data says that to reap these benefits you have to treat Rust as a violin rather than a car. Rust probably can’t fundamentally make itself as easy to learn in general as say, Java (though improvements with NLL help). Instead, to me this would suggest that to onboard users who want a car and not a violin, Rust should figure out how to make the most common specific use cases ergonomic and easier.
more trans than women? hard to believe.
`println!` is a macro similar to `format!`. Both use their first argument as the "format string", and replace every `{}` with text generated from the others arguments, in order. Inside the `{}` you can add formatting options, for example `:x` for hexadecimal formatting. By default, the text for each argument is generated with `std::fmt::Display::fmt`. `Display` is a trait, so you can only use `{}` with objects implementing it. ***It's not the case of*** `()`**.** If you use the formatting option `:?`, another function is used to generate the text : `std::fmt::Debug::fmt`. It is intended for more literal and less formatted printing and is implemented for more types.
&gt; Apologies if it comes across as a rant, I don’t mean to be overly critical. I think it's important to think about these things! However, I think this analogy is bad: &gt; People generally don’t take 3 months to learn to drive before they can successfully drive to the grocery store. Most states that I'm aware of require you to get a learner's permit before you're allowed to get a license. For example, in my state (New York), unless you're over 18, you must wait six months after obtaining a lerner's permit before you are allowed to apply for a license. &gt; I don’t know of data to compare to other programming languages, but I would conjecture that a C++ user (for example), could become productive in Java or Python within say, 2 weeks. Rust is an order of magnitude off. I think this is really the crux of it. I don't know the data either, but Java and Python are significantly easier to learn than Rust, because their design constraints allow them to be easier languages to learn. We'll never be as easy as Python without losing what makes Rust Rust. The question is, how close can we come?
Can you explain why a binary compiled from go is "supported" and one that is compiled rust, or blub, isn't "supported"?
Everything can be found in the official documentation : [std::fmt](https://doc.rust-lang.org/std/fmt/index.html).
I posted the other day about documenting 'sigils' in std. When learning Rust (and still once in a while today) I found myself sometimes looking at symbolic constructs and wondered "what was this again"? Unfortunately, googling these often didn't bring anything up. Although documenting these in std ended up not being the best idea, I still wanted to summarize them somewhere. Along the way this then became a cheat sheet. You can find it here: [**cheats.rs**](https://cheats.rs) ([src](https://github.com/ralfbiedert/cheats.rs/)) Because a single cheat sheet might not be the best for everyone, I tried to find a format that is (hopefully) useful for a particular audience: "Early Rust professionals" (experienced programmers, but intermediate Rust users), who prefer concise, example-driven content. I did not try to repeat things that are better explained elsewhere, but rather link from The Book up to the Nomicon, so users can pick an explanation level that suits their needs the most. Lastly, I wanted to have a URL that's easy to remember and to "tell your colleague". I would love to hear your feedback, especially if you consider yourself a "cheat sheet person". Please let me know what works for you, and what might be missing. I can totally see the format evolving from where it is today. 
Could someone edit the article to update the first appearance of NLL by: non-lexical lifetime (NLL), please?
I really like this approach! In nodejs land, koa took this approach and it really works well overall, makes it really easy to extend.
Hmm, I guess my country and field so have quite different statistics from US computer science. I'm in a computational biology lab and we're 50:50 women and men
I've been thinking about this a lot because my license is expired and I *really need* it to be renewed, so you just happened to comment on one that's *extremely* top of mind for me, hehe.
I'd love to see crossed data between "How long to get productive" and "Languages confortable with" (not only which language, but also how many).
https://blog.rust-lang.org/images/2018-11-RustSurvey/12-If_so_how_much_work_to_fix.png -- Most people put 1 whole work to deal with compiler breakages, but some put as much as 5 whole works? What are the labels?
Ah! Okay, thank you.
Since this has been posted, I can make a shameless plug. Both [cmtt](https://github.com/orgs/ratel-rust/people/cmtt) and I have been on-and-off on this for a while. With how Logos is coming around, and with the weather outside being what it is (winter in Berlin), I hope to at least split out the Lexer, AST/Parser and codegen out into separate crates, as those are useful on their own without the transformer, which is what currently is holding the project back. I'd be happy to get any amount of help on this. There is a lot of work to be done in the Rust code, but also Node.js bindings or the Wasm version for a [browser demo](https://maciej.codes/ratel-wasm/). There is also [a number of other JS parsers/compilers in Rust](https://github.com/ratel-rust/ratel-core/issues/99) in various states of completeness and different performance characteristics, that could also use help.
Thank you! :)
This is really nice, thanks!
I suppose it's true that traits are already the exception to the private-by-default rule, but I still dislike the idea of adding an ideally-temporary keyword (`priv`). For developers who already know Rust (i.e. are aware that you can't have private-visibility trait members), this feels like a new feature that's purely an enhancement, in the sense that we're just *adding* this new functionality. But for people learning the language, `priv` will probably feel like a lot more of a confusing exception than the current state of affairs (traits not being able to define private members), especially since, as-proposed, `priv` won't apply to top-level structs or functions. (For the record, I think it would be a bad idea for it to be legal in those cases, for exactly the reasons it was originally removed.) Then if you remove the keyword in a few years, just after people have gotten used to it, it will cause even more of a mess. I do really want the capacity to limit visibility on trait members, but I don't think `priv` is a good way to do it.
Avoiding initialization of large buffers can be significant, but for `encode_utf8` I’d just use `&amp;mut [0_u8; 4]` and only revisit if a profiler points that way.
Also note that `{:#?}` switches to pretty printing the Debug output.
The blockchain pattern is for establishing consensus without a central authority. In no universe would the problem blockchains solve be applicable to STAMPS. Take your golden hammer and market it somewhere else.
My country and field certainly have different statistics, but when seeing a woman working on a Mozilla-related project I basically assume trans until proven otherwise.
It's because you are trying to return a slice into the `chars` Vec. Since `chars` is an owned Vec on the `scan` stack, you can't return a reference to it without the `chars` Vec being dropped.
This is more or less the same as the [syntax index](https://doc.rust-lang.org/book/first-edition/syntax-index.html) from the first edition of the book. The fundamental problem with this sort of thing is that the people who need it most are *never* going to see it. The SI had the advantage of being in the table of contents of the primary documentation, and somehow people never noticed it. Given that this is a completely separate website, I don't much like the chances of newcomers finding this.
In general I'd like to have a link to the raw data dumps of the surveys. I like reading the stuff people put in custom fields.
I’m building a multiplayer server backend. Key points: - a single shard that can support up to ~1000 Websockets at once - small packet size is more important than low latency. I’m building a shared world exploration environment, as opposed to a reflexes-based FPS - Using ws-rs as my WebSocket library - client side front-end is HTML5/Canvas. Not using Node. - next week I’ll be incorporating a real-time database of some sort. Will explore Firebase first.
I was thinking about that, but I only use encode_utf8 for a iterator of chars, so I do that a bunch of times filling a large buffer.
Is there any other way to get Enum Box value besides `match` or `if let` Consider the following #[derive(Debug)] pub struct List { head: Link, } #[derive(Debug)] enum Link { Empty, More(Box&lt;Node&gt;), } #[derive(Debug)] struct Node { elem: i32, next: Link, } pub fn dostuff(&amp;mut self) { if let Link::More(v) = &amp;self.head { // Is there any other more direct way to get v ? // for example self.head.enumcontent.next ? } } 
What if T is a field of a struct, can I pass references to the struct around? Or is it undefined too? Like calling methods from the struct that fills the uninitialized memory.
I really love the new version of the Rust logo. Are we allowed to use it e.g. in presentations? I would love to do so.
If I recall correctly, Lambda grabs a symbol from the compiled binary to invoke it which is necessarily language-specific. However, I'd suggest watching "SRV409 - A Serverless Journey: AWS Lambda Under the Hood" (https://reinvent.awsevents.com/reinvent-guides/3-advanced-serverless/) when it's up. Additionally, Re:Invent isn't over, and while I have no idea what the Lambda team is up to, they tend to save the best and flashiest announcements for last.
I run it using `cargo watch` and it's nice; it might take a second or two but I can keep editing while it's doing it's stuff.
The key is really both distributed consensus *and* immutability. I understand why folks are frustrated. It’s been severely overhyped. Despite the overhype, it really does have some useful use-cases, and exonum is one of the better engineered consortium-type blockchains out there. I think the exonum team hasn’t been treated very well by the rust community. 
An example use case is that you want to execute potentially unsafe/malicious code &amp; prevent it from affecting your server, or other code running on that server. Like if you run a platform where you download and execute other peoples' code, but you want to make it so each customer cannot affect the other customer, or take over your server, this would let you do this. It spins up (cheap) virtual machine, and the process(es) that are running think theyre running in their own, full, server, but in reality, there could be thousands of these little virtual machines on the same physical server. If you're not familiar with AWS Lambda, its a platform that allows you to just submit some code in the form of a single function, and have it execute on certain events. Like you can upload the code of a single java function, and that code will be executed every time an event happens. AWS wants to run a billion of these functions using as few, highly-utilized machines as they can. If I asked you to naively implement this service, as quickly as possible, you would just allocate one server per function, or maybe one server per customer, so that each customer can't affect the other customers. But that's expensive. The problem is trying to run functions from different customers on the same physical machine. Its somewhat acceptable if a customer can ruin themselves if one of their functions hogs the resources of the physical machine melts the server running that same customer's other functions, but its not acceptable for one customer to be able to melt the server that has a different customer's code. And besides hogging the resources of the computer, security is the big one, truly. AWS's first principal is security, so the easiest way to make different customers from not being able to affect each other, is to put them on different physical machines, which could be costly if there are many many tiny customers. This would allow AWS to smush as many customers on as few servers as possible, which would save AWS lots of $. Firecracker would be used by someone trying to implement something like Lambda. Perhaps the most obvious &amp; great example would be the little sandbox-rust coding things you see amongst the documentation. Whoever runs that service could use Firecracker to run these little functions safely, preventing one function from affecting any other running function, and efficiently, so they could run more of these sandbox functions on fewer servers.
I love rust but I won't introduce it at work because rls is so bad. The idea of it being 1.0 rc is a joke. I would understand if it was having issues with macros but it seems to struggle with the STD Lib. 
You could of implement a `next` method on `Link` returning an `Option&lt;Node&gt;`? In general there isn't going to be much given "for free" working with enums. Everything will boil down to a function using `match` or `if let` at some point. There are some crates which help by automatically generating some functions, but I can't think of any that help in your particular case.
Perhaps if the compiler is too large, the client could send the code to the server to be compiled, and the server could send the compiled wasm back to the client to be ran in the browser? This would simplify the existing playground server setup I think, but potentially open up security holes if I visit someone else's playground link (I'd be running their code in my browser)? 
&gt; I would conjecture that a C++ user (for example), could become productive in Java or Python within say, 2 weeks. Rust is an order of magnitude off. I share your concerns about the 1 month to 1 uear category. But I don't think this is a fair comparisilon. It'd probably take a javascript or python dev a lot longer than that the become productive with C++...
Yes, stay tuned, Werner's keynote will include the Lambda announcements.
That number varies *wildly*, based on both [OS](https://stackoverflow.com/questions/47845/why-is-creating-a-new-process-more-expensive-on-windows-than-linux) and [CPU architecture](https://stackoverflow.com/questions/15168822/intel-x86-vs-x64-system-call).
How it compares with GCC (Closure Compiler)?
Thanks for all. I fix the problem using the [Box&lt;T&gt;](https://doc.rust-lang.org/std/boxed/struct.Box.html) on file\_doc and changed the lib for parse the xml. My current source: ... account: &amp;'a mut Account, pub file_doc: Box&lt;Element&gt;, } ... let xml = Element::parse(xml_str.as_bytes()); // Old: if xml.is_err() { return Err("Invalid XML content in OFX file"); } Ok(Ofx { storage: storage, account: account, file_doc: Box::new(xml.unwrap()) }) .. Full diff: [https://github.com/fernandobatels/blitz-money/commit/97a1259430184c963aab0032cf914a520386fc1a](https://github.com/fernandobatels/blitz-money/commit/97a1259430184c963aab0032cf914a520386fc1a) Besides what we discussed here, the article [https://bryce.fisher-fleig.org/blog/strategies-for-returning-references-in-rust/index.html](https://bryce.fisher-fleig.org/blog/strategies-for-returning-references-in-rust/index.html) and the rust doc [https://doc.rust-lang.org/book/second-edition/ch15-01-box.html](https://doc.rust-lang.org/book/second-edition/ch15-01-box.html) helpd's me to fix. About the [Box&lt;T&gt;](https://doc.rust-lang.org/std/boxed/struct.Box.html) . I am not sure if, for this case, is the only way, but works :) &amp;#x200B; If someon have others solutions or opnion about the Box, i would apreciate ;)
What's meant by "underrepresented group"? I have no idea whether members of my minority classifications are underrepresented in tech. There aren't many in tech but there aren't many overall anyway. Is it weird that I wouldn't know that?
Hey, this is great and well done!
This is your objection as I understand it: in this case perhaps Python is a genuinely “easy” language, whereas C++ isn’t actually easy, but still has been very successful. Rust is really more in the category of C++ in terms of power, but I’m rather unfairly expecting it to be as easy as Python. I think you are possibly right that a Python dev might take longer to become proficient in C++ than it would in Rust, but I think it all hinges on what “productive” is. That sounds like a cop-out answer, but bear with me. If productive means being able to write production quality code that you are confident in, then yes I agree with you (of course having real data would be good, but oh well). But if productive means being able to bang out an algorithm / prototype that essentially does the correct computation (and possibly has some hidden memory bugs), then I would expect that one could become productive more quickly in C++. The tricky thing about this is that both of the above definitions of “productive” are equally valid (to me at least), just different sets of people in different situations desire them. We don’t know which definition of “productive” people used to answer the survey, but maintaining some sort of balance between them seems like a pertinent thing to do.
I like the design. What are the planned middlewares? Some common ones I can think of are: &amp;#x200B; * Compression * Authentication * Caching (returning cached responses) * Caching Headers * Security Headers * Sessions * HTTP to HTTPS Redirects * Normalize URLs to end/not end in slashes * CORS Headers
I worry about people saying lifetimes are harder than unsafe, because unsafe is *definitely* harder.
I'm really happy that GUI development finally made the list as an area for library development. It's definitely an open question the best ergonomics for a GUI in Rust. Unfortunately GUI libraries are pretty complicated, but I'm hopeful that we'll get serious contenders in this space in the next year.
First, do you have benchmarks showing that your changes actually make the code faster? If not, don't do it. My personal thought is that your change is correct, because `u8` is `Copy`, which means that dropping it is a no-op.
Immutability is also not necessary, given a central authority. If the concern is that the government could surreptitiously give your rightfully-purchased stamps to someone else(?), all that's necessary are signed receipts.
It makes my code faster using uninitialized because it's a bigish array on the stack, so initializing only once makes the code faster (we are talking about nano-seconds, but it's generally half of the work the method does). In this case I could actually have a `[0u8; 4]` and use it as a initialized buffer to then pass to uninitialized, but it seems unecessary extra work. I don't get your point about `u8` being `Copy` does it make the function ok as is, since it won't drop the old values?
I'm not too sure it's inconsistent. I believe what's happening is that the negative is being applied after the power operation. If you do instead: ``` let n = (-3i32).pow(0); ``` You get the answer that you would expect.
nah, this is just order of operations. https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=a569e1345810787031d72188115cfa99 Anything to the power of 0 is 1. 3^0 -&gt; 1, and then you negate that, so you get -1. Then you assign `o = -5` and raise that to the power of 0, so you get positive 1. The unary negation operator is less binding than a method call, so calling the pow method takes precedence.
Got it, Thank you.
`-` is being applied to `3i32.pow(0)` (which is 1), not `3i32`. So it's evaluated to -1.
Got it, Thank you.
\+ Cookies?
Sorry it took me so long to get back to you. You were right `echo $BROWSER` produces a blank line, and `xdg-mime query default text/html` produces `wine-extension-htm.desktop`. So how do I set it so that it opens firefox instead?
I liked Niko Matsakis introduction to rust videos. He should make a little series, which can make the learning curve easy.
I think is unsafe is harrrdddeer. And lifetimes are hard.
You say "these are the same", the compiler says "well, they aren't, and I'm not allowed to *extend* a lifetime, so I have to shorten the longer one". So the tokens end up living only as long as `chars`. But then the return type says "will live as long as the source". The compiler can't extend the borrows in the tokens, and it can't shorten the return type (because it's the return type; it's already been fixed by you), so it has to give up. So it's not "chars lifetime must be longer", it's "the slices lifetime must be shorter", which then eventually conflicts with the return type's stated lifetime.
You know, I may be coming around on this. The key here seems to be that both: a secondary market is needed; and although there's a central authority it isn't trusted not to be corrupt, so pervasive transparency is needed. Those complexities don't necessitate a blockchain *per se*, but a blockchain bundles together the components (publishing, notarizing, etc) that the solution requires into a known pattern, so I could see a Greenspun's Tenth Rule argument being applicable. So, this application has changed my long-held view that permissioned blockchains don't solve any problem.
No, these are exclusive. If they identify as LGBT, then they can't be "no" or "yes (not specified)".
I think it's worth tracking the "how long to productive" metric, but one challenge, I think, is that it's going to be correlated with "using Rust for work". If I'm using Rust for my job, I bet I'd be productive in a month, both because I'm spending more time and because I'm probably working with experienced developers in an established codebase. If I'm dinking around on the weekends, it might take much longer. It might be interesting to ask people how many lines of Rust they've written, as a variable you can control for. I don't consider myself a Rust user, really, but I wrote a toy program of ~150 lines once and have played with some things on playground. I'd expect a person using Rust at work would write a lot more in a shorter amount of time.
I use VSCode and it lets you fold it in two parts? This seems like something that should be an editor feature rather than a style one that just happens to work on "dumb" editors(meaning they don't understand the language and only look at tabs?)
How does the performance of the generated JS compare with that from other compilers?
Surprisingly, while Rust not being considered by the company they work for is mentioned frequently, it doesn't appear that developments towards a better enterprise experience is wanted so far. I think of proxy/private crates etc ... 
Great idea, but... why not cheate.rs?
Stopped using Rust years ago. Why would I bother filling out a survey?
Sometimes, people like you enjoy telling us things, like why you stopped. It’s not nearly as many people who actively use Rust, of course, but it’s still a thing. And it’s useful!
With a normal struct, you are actually allowed to move out part of it and then move out the rest. If you want to do the same with a \`Box\` you must (as you observed) first "deref-move" out of the box and then move out the individual fields of the contained object to their final destinations. 
And sometimes you ignore my bug reports for years. Go fuck yourself.
It looks like Cookies and Secure Cookies could be a computed property since they need nothing but the request to get their values.
Yes, they absolutely can. They can be gay and also be something else they're not specifying. Also, the option in question is **not** "LGBT," it's "non-heterosexual." There are 3 other options that address transgender people.
Hehe, I considered `cheat.rs`, `cheatsheet.rs` and `cheats.rs`, but settled for the latter because it was closest to `docs.rs`.
if someone could please add the data types and whether they're stored on the stack or the heap
Shouldn't unary `-` have a precedence over period `.` ?
It seems surprisingly common in socially progressive, male-dominated internet spaces. This isn't the only community I'm a member of that sees this phenomenon.
You're a saint
We're neither your country not your field and a small community, which means that our drifts may differ from what you see in those fields. We're small enough that single persons talking to a few friends can notably make the needles drift. And this particular effect has been visible for years. 
I thought quite a bit about how to include common operators. My general problem with listing them is that I feel they don't really tell me anything new, while taking up visual space. When it comes to precedence, I would argue Rust prevents critical errors there through its type system (e.g., you can't accidentally add two int references). For everything else, I feel code should never be written in a way that others might have to rely on precedence tables. Willing to change my mind though about the latter part.
I would love to! Some questions: - What exactly should be documented? - Is this a table or a diagram? - How would it look like? - How would it differ from the "container cheat sheet"? There is a [tracking issue here](https://github.com/ralfbiedert/cheats.rs/issues/11).
Hurray! Videos galore 🎉
Yes - you can use it for whatever you like. The textures used are CC0 licensed, so there is absolutely no issue with it. If you want a custom version with some other improvements/suggestions - don't hesitate to reach out
Since I've been asked - the wallpaper is free to use for whatever purpose you're interested in, including reuse or editing. The textures used are CC0 licensed, so go crazy :-)
Ah, so it's related to the continuation construct itself, not the values it is operating on. This stuff is kind of confusing.
What's pub(in a::b) for
All unary ops have the same precedence, and for referencing and dereferencing having higher precedence than field access is pretty much required. It might have been better to give unary - and ! lower precedence but I can't think of any other situation where it could be harmful and there's value to the consistency. There should probably be a warning for this if there isn't already.
we very consciously don't do that, because there can be personally identifying information there
Love the colors on this one, but the inside of the wheel has this beautiful 3d bezel, and the outside of the wheel is utterly flat and perfectly meshes with the textures from the background. I mean [this](https://imgur.com/a/qPYkjaM) just looks like black paint on a textured wall. Needs some type of shadow, and a clearer break. Keep the background texture, but experiment with different cog textures. Also the left side of the R is a little strikingly different, the color gradient feels off without the texture to balance it out. Please keep going! I want to see how it looks in a couple more revisions!
I think the immutable borrow and immutable reference part (along with the mutable variant) is confusing. Now I'm wondering what's the magical difference between x and T.
This is great. I love it!!!
Ah, I love the "invisible sugar" part! So much of my confusion from Rust comes from the way it (helpfully) elides some operations for you. I'm happy it does. But in doing so, it makes it harder for me to reason about what the rules are when that elision is *not* possible. Implicit re-borrows have always confused me. I almost wish there was a way to disable all these sugars, just so I can write Rust in a way that **forces** me to understand all these requirements. Then, once I understand them, I could have the compiler auto-apply them for me like it already does.
Is the \`at()\` name set in stone? It's short and thus easy to type, but it bears not much information. What about \`path()\`? I think app.path("/").get(index\_endpoint) would be slightly nicer on the eye than app.at("/").get(index\_endpoint)
`Debug` tends to output more technical details about the value, like the structure names, members, and so on; the representation is usually close to the language syntax. It's not intended for user-facing output, but it's good for, well, debugging, error logs, and similar.
Well, it might also help those, who still have to read code from others who don't subscribe to that philosophy :-) Not trying to convince you, though; your work is fine as-is.
I see your point. Thanks for the feedback! I’ll try to see what I can come up with. 
Finalizing my data-driven test framework (each test case runs as a separate test and therefore looks nice in IntelliJ Rust :)!): ```rust #[files_test("tests/test-cases", { input in r"^(.*)\.input\.txt", // finds all files matching this pattern! output = r"$1.output.txt", // derives other input file names! })] fn sample_test(input: &amp;str, output: &amp;str) { // passes file contents as strings! assert_eq!(format!("Hello, {}!", input), output); } ``` Or (each test case is an array element of YAML file): ```rust #[derive(Deserialize)] struct GreeterTestCase { name: String, expected: String, } #[data_test("tests/tests.yaml")] // each array element of YAML becomes a test deserialized into given struct! fn sample_test(data: &amp;GreeterTestCase) { assert_eq!(data.expected, format!("Hi, {}!", data.name)); } ``` 
Awesome resource! Might be nice to also mention `&amp;*a`, which is also sometimes used. Might do a PR for it later today. 
&gt; This makes it not safe to use with uninitialized, right? Right. &gt; Should this be changed for ptr::write? No, that would be a breaking change: `core::encode_utf8` requires the input to be **valid**: the pointer to the slice has to be initialized, dereferenceable, its memory address be a multiple of the alignment of `T`, and it has to be the only active pointer to the slice, the metadata (the length of the slice in this case) has to be initialized (and **safety** requires it to be "in bounds" of the allocation), the data in the slice memory has to be **valid** (not only initialized, but with valid values for `T`, e.g. no `bool` with a value that is not `0` or `1`), etc.
Sure, This is what I have in mind: I'm still getting started with Rust so please excuse me if something is not accurate :) * What exactly should be documented? All of the data types for example (str, String, f32...) * Is this a table or a diagram? Tables * How would it look like? 2 Tables, Simple Types (Stack (like str)) and Complex Types (Heap (like String, Vec...etc)) * How would it differ from the "container cheat sheet"? Container diagram was a bit difficult to read (for me at least) I guess tables would be a bit more simple 
RLS isn't 100% yet, in my experience I would say it works around 70% of the time, it mostly fails at giving me completions of `unwrap`, and when the type is too complicated, but it's definitely an improvement over what we had at the start of the year. It doesn't crash often (I had to quit vscode and `cargo clean` twice in the past 3 months), and it's problem reporting works quite well, to the point where I almost never have to `cargo check` in a terminal. &gt; major disappoint for me I can see where you're coming from with this, but to me it's more a feeling of frustration rather than disappointment, I'm frustrated that it's so close to working fine, but there are still some places where it fails. The RLS team put out some impressive work this year. Are you using vscode? My experience with emacs + rls wasn't great, mostly the fault of emacs' language server plugins. 
Whilst I do agree compile times would be great, I still think rls should be top of the list. A lot of people, myself included, use the code completion to work out what they can do in the current context. It makes exploring and learning the language, and by extension other crates, a hell of a lot easier. 
It would be nice to see a concerted push here. The lack of a GUI library is a blocker for a whole class of programs that *could* be written in Rust but currently aren't being. I was thinking of writing a replacement for SourceTree, for example. I think my Rust is good enough to handle the back end work, but I quickly realized I would have no way of sending commands to my program because there is nothing I could build a UI in. It would also be great publicity for Rust if Rust-native programs started showing up and replacing Electron apps.. 
Given it was a goal for last year and we're still getting hangs, crashes etc it's not great 
There is, but it would come at a cost. Code reviews from independent persons before allowing a new version on crates would be one way.
It seems to be quite hard to protect against social engineering without having a lot of people cross check all the changes.
While these issues cannot be completely prevented, I think the risk can be reduced if we try to start seeing dependencies as introducing risk into our projects. This is especially important in the case of libraries. There are libraries in NPM, that expose only a *single* function, but introduce a dependency where this mess can happen ([example: pad](https://www.npmjs.com/package/pad), which is just an implementation of Python's `str.{l,r}just`). This is why I personally like the "batteries included" way of writing standard libraries. The standard library is checked and maintained by lots of people, which makes the risk much smaller. If the standard library is not complete enough, we could extend it (and example is C++'s boost-libraries) or make a curated list of libraries that are believed to not have a lot of risk. In the case of Rust, I would personally opt for the second one. But most of all: Do not \*just\* add a crate to your \`Cargo.toml\`. Check if it is really necessary to add a dependency, or if your problem can be fixed by writing 5 functions by yourself. It's not a shame to spend an hour or two putting library-style code into your project, if it saves you from adding another dependency.
This is an interesting idea: it would still allow the server-side to do less computations while avoiding transfering a large file over the network. And the security aspects are also interesting: * Regarding the client side, I guess if someone wants to run WASM in your browser, they still can, whether or not the playground code is executed on the server side * However, using WASM would allow the server to avoid running code from the user, which I guess is always good for security
If the statistic about women is accurate, that’s both interesting and worrying. &lt;3% women is so little! Trans people being overrepresented compared to the general population is of course very cool! I used those 3% as a comparison, I hope it didn’t sound wrong.
&gt; People generally don’t take 3 months to learn to drive before they can successfully drive to the grocery store Many do. Also the purpose of Rust is more like "becoming professional driver" than "driving to grocery store", and that's much closer to 3 months. &gt; Rust promises a lot of excellent benefits, but to me this data says that to reap these benefits you have to treat Rust as a violin rather than a car. I like this analogy and I think its right.
Wow, I didn’t know that! Very interesting. Good for the trans people to feel included, but wow that’s a sad number for women.
First, think before trying to replicate a SaaS - managed services often save you valuable time of implementation and maintenance. Second, there is already a project called [ImageFlow](https://github.com/imazen/imageflow) that implements what you propose. It seems to be faster than any other library that is available, but it's not battle tested, the web part isn't high quality IMO, and has a large part implemented in C so it's not like pure Rust. &amp;#x200B; While Rust is suitable for high performance computing, tuning for maximum performance requires knowledge mainly on SIMD. ImageFlow is built by people with such expertise. &amp;#x200B; Also see [libvips](https://github.com/libvips/libvips), a popular library used for all-round image processing. You could either embed it into your monolithic application, or use a proxy implementation mentioned in the README.
As a new learner of Rust (not yet worthy of the Rustacean label) I found myself digging into the async/await stuff last week, after reading about it in the Unstable Book, and found I could use a macro crate but it needed Nightly, which, frankly, scared me off it completely. (I think) I like Rust a lot, and I'm building a real thing with it, but there's an awful lot of this Nightly/Unstable/0.x stuff and I think that's going to be keeping the big enterprise shops and teams away. These are the people who won't adopt a Microsoft tech until it's on v3.1, after all.
Fact is, most people's code is not that important. Much is just for internal business use. Most code doesn't have access to private information, and most private information isn't useful to attackers. The risk of being compromised is 'small'. How small? Hard to tell, but as far as we know it happens only very occasionally on `npm`, a repository many times larger than `crates`. On top of that, the risk of being compromised falls on the business, whereas the convenience of `crates` benefits individual programmers, who probably don't really care if their employer gets owned (most business is boring). So I conclude it is perfectly rational to ignore the risk, pull in dependencies willy-nilly and forget about it. Yes, even a one-liner (though thankfully these are rare in the Rust world).
I must say I agree with your argument of moving code out of a crate into a smaller one. In your case you obviously know your dependencies. I mean, I have seen node projects that have over a thousand different versions of dependencies. With that many dependencies it is impossible to check every one of them. I do not think at all that this is common practice in Rust. But in node it is, and I kinda wonder how they got to this point.
It makes an item visible inside the module `a::b` (and any of its submodules). The module must be an ancestor of the current module, so you can always replace it it with a relative "upwards" path, like `super::super::super`, but naming it might be more convenient or maintainable.
Is that really true? Seems like part of the problem in this case is that code published in GitHub can differ from what is published to NPM.
Lots of young people still learning, discovering the fun of package/dependency management, wanting to have a small place somewhere in the real world. Plus the lack of standard library in JS.
It is possible to prevent this by limiting what (side-)effects certain dependencies can have either by blacklisting or whitelisting. For example, in a future where `const fn` is more powerful, you could ensure that the library you use cannot possibly have side-effects by requiring that all the functions in the dependencies be `const fn`. That way, the dependency cannot read files, send things over the network, etc.
When I skimmed through the issue on GitHub I got the impression that he had published and then force pushed.
I think I can never be thankful enough about the fact that whenever I feel "hmm, if only we could have this", then "bam" there is a RFC with every detail solving everything showing up in GitHub.
There's no way that could work practically!
Yeah, I understand. And putting extra effort in censoring all that data would've easily delayed this post until mid next year.
Nightly is generally ok, I have always been running nightly, features are mostly stable and usable. The futures are something else... The async/await features and implementation of a future are not documented, using e.g. streams with async/await is also not documented. I also tried to get into it last week but it was like hitting my head in the wall, so I just gave up until there's at least docs.
Cargo supports private crate repos, a feature added to help company adoption of Rust.
The SemVer spec does not mention the term "production readiness", and I continue to uphold that what the SemVer spec says about version 1.0 is very different from how most library developers feel about version 1.0. But few people read the spec anyway, so I don't care all that much anymore.
Keep us posted! :D Keep the good work, love it!
It doesn't feel like it would be too hard to introduce some form of dependency audit requirement into cargo's dependency retrieval to avoid single points of failure, such that [Crates.io](https://Crates.io) allowed people to publicly audit and attest/sign specific published versions of a crate and the build file allowed constraints on dependencies, such as: * Audited and signed off by at least N people, and/or * Audited and signed off by one of the following people { ... } * Audited and signed off by someone authorised to act on behalf of a specific firm or organisation Attempting to build with a dependency (direct or transitive) that didn't match the sign off criteria would be considered a build failure condition. That extra level of control might also make introducing rust an easier sell for large organisations, by allowing them to put a process in place to limit the cyber security risk by requiring someone from their firm audit and sign off on crates that can be used internally.
Could be nice if its done by cargo automatically. Honestly i want a easy way to sandbox in linux a long long while ago. Why doesn't linux come with a 'no networking' or 'no file access outside home and media' launcher utility yet? 
1. Don't upgrade your libraries unless you need to. 2. Add ability to use sha256 digests for package versions in Cargo.toml.
Nice! You should probably add "&amp;*T", I think it's called "reborrowing". It would also be awesome if you could somehow integrate the containers cheatsheet.
[The container cheatsheet](https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit) is a really valuable resource for this, which covers at least some of the types.
&gt; But for people learning the language, priv will probably feel like a lot more of a confusing exception than the current state of affairs For the record, previous discussions on this sort of thing tend to talk about how each new feature could be the one that exceeds a learner's cognitive/learning budget... so, if you want to search the RFCs repo for previous discussions of this nature, use "... budget" keywords.
In Haskell you have `unsafePerformIO`, doesn't Elm have something similar?
Beside due diligence on the consumer end, and capabilities incorporated into the type system, I can see a few measures that would make it harder for an `event-stream`-like debacle to happen again: 1) Make it obvious who the consumer is trusting by namespacing packages under their author's id. While it may be tempting to cede the `fooglarize` package, I would never give the keys to `pygy/fooglarize` to someone else. 2) Mandate a digital signature and 2FA (email) for publishing. 3) Reserve the `@@insecure` namespace for legacy packages published before the above is introduced. This isn't bullet-proof, but it would make an attack harder to pull out.
I have a couple of used compact desktop Athlon 64 machines that HP under-spec'd the coolers for and, since it didn't seem worth it to buy replacement coolers, my solution was to solve the problem more generally by installing `cpufreqd`(a daemon which manipulates the `userspace` CPU governor) and configuring it to provide system-wide thermal throttling. Here's the `cupfreqd.conf` I'm using for them: # cpufreqd.conf for systems which overheat if CPU-bound operations run for too # long. (eg. 7zipping multi-gigabyte backups or playing Minecraft) # # May require editing sensors3.conf to ensure "temp1" is unique if using # k8temp. [General] pidfile=/var/run/cpufreqd.pid poll_interval=2 verbosity=4 enable_remote=1 remote_group=root [/General] [sensors_plugin] sensors_conf=/etc/sensors3.conf [/sensors_plugin] [Profile] name=On Demand High minfreq=40% maxfreq=100% policy=ondemand [/Profile] [Profile] name=On Demand Medium minfreq=20% maxfreq=80% policy=ondemand [/Profile] [Profile] name=On Demand Low minfreq=20% maxfreq=60% policy=ondemand [/Profile] ## # Profile-selection rules ## [Rule] name=CPU Normal profile=On Demand High sensor=temp1:0-55 [/Rule] [Rule] name=CPU Running Hot profile=On Demand Medium sensor=temp1:60-70 [/Rule] [Rule] name=CPU Way Too Hot profile=On Demand Low sensor=temp1:75-100 [/Rule] 
One thing that affected them which can be made not to affect Rust is that while npm links to GitHub, the maintainer had uploaded \*different\* minified code. Since cargo always builds from source, we can make it so that cargo gets the code from published github tags or such, and so avoid that part of the situation.
Thanks! Will do!
Totally agree, the approach to dependencies is what keeps me from really learning Rust in the first place. I would totally switch to a language with a good (batteries included) standard library, but Rust choose to go the dependency hell way, which is fine for blog posts and simple projects but not nice for real projects.
For starter, if you own a crate that has a significant use on crates.io, please don't [give it to the first hacker who kindly asks you](https://github.com/dominictarr/event-stream/issues/116#issuecomment-440927400)…
In your first example the expression 'node.next' is aquivalent to '(*node).next', which moves the Node out of the Box&lt;Node&gt; into a temporary and then moves 'next' out of the temporary. After this you can't use 'node' (of type Box&lt;Node&gt;) anymore. So you have to store the temporary in a local variable, like you did in your second example.
`xdg-mime default firefox.desktop text/html` should do it for you.
Can't tell if you're being sarcastic or not \^\^
This feels like an important area to think about: the exploit in question used eval to load code from a test “data” file and loaded undeclared dependencies. It seems like there could be a meaningful combination of cargo-enforced restrictions and code scanning to make that kind of escalation harder, or at least more visible. Another angle might be working with OS tools - I’m most familiar with the macOS sandbox but I know Linux has some similar tools and a default configuration which restricts access outside of your project directory could both reduce the damage of an attack like this and prod developers to think more about using sandbox policies. 
While str would be on the stack, it's unsized and has to be wrapped in some sort of heap allocation - commonly &amp;str but other possibilities include Box&lt;str&gt;, Arc&lt;str&gt; and Cow&lt;str&gt;.
Firejail? Docker?
I don't think this is sustainable and really asks people to volunteer more of their time unless they did it on behalf of their company. I don't think there's a solution beyond, check what you can, and just trust people, which you're asking people to do with the audit check. It's just random people on the net. At some point somewhere you just have to trust that most people have good intentions or else you'd be writing code all by yourself for a computer you built from scratch and had sourced all the materials yourself by hand. I think we all want a good solution, but in the end I don't think there is one
It didn't sound wrong, just like strong disbelief :).
I personally think that crates.io shouldn't get special treatment for crates. You should be able to have multiple crate sources. Then somebody could create some form of "verified" crate source. 
I believe you can create an &amp;str that points to a stack allocated array.
Is it possible/feasible for cargo to monitor for network usage in build.rs scripts? Would it be worthwhile?
That actually wasn't the problem, if I read it correctly. I think they uploaded the malicious code to github, cut a new minor release, then reverted it and cut a new major release. Most people would be using the last minor release and not see anything suspicious on github if they checked.
`x` refers to a value. `T` refers to a type. A reference (`&amp;T`) is a type, for example: `&amp;str`. A borrow (`&amp;x`) is the act of creating such a reference, for example let x: &amp;str = "hello"; let borrow = &amp;x;
Where it makes sense, `Debug::fmt` should try to output a valid Rust expression. Hence, strings are quoted and usually you'll see a value constructor. It's not always the case, for long types or where the constructor needs a pointer or file handle etc.
I think we need a path to move/copy essential crates into a team maintained "blessed" version where no single person can commit without review (I think rust itself already works like that).
What would you say is missing from the standard library? 
Many companies will probably review all the crates they allow in their org anyway. So it would be very nice if that information could be crowdsourced. Not every company is probably happy to share their reviews, but maybe it is enough of some of them do.
Hmm, a bit sad that `extern crate` is going away. Maybe that could've been extended with syntax for toggling which things from that crate are importable. I'd prefer to have these things in the language, not just as part of Cargo (for example, in the Nix world Rust builds don't necessarily use Cargo). Lets assume there were some syntax like `extern [(item, const, macro)] crate ...` to say things like `extern const crate shady_crate;` and restrict possible imports from it to `const` stuff.
Yep, see the last example of [https://doc.rust-lang.org/stable/std/str/fn.from\_utf8.html](https://doc.rust-lang.org/stable/std/str/fn.from_utf8.html) &amp;#x200B; And this kind of thing goes for all types; for example, take a \`Vec&lt;T&gt;\`. The vector itself is on the stack, and the data is on the heap. Unless that \`Vec&lt;T&gt;\` is in a \`Box&lt;T&gt;\`, in which case, both would be on the heap!
&gt; For example, in a future where const fn is more powerful If you are going to worry about `const fn`, you should already be worried about build scripts, or proc macros. It would be nice to have the numbers of how many crates in crates.io could you use today if you were to not accept any crates with build.rs or proc macro dependencies. I'd suspect not many. 
So much. Want to do HTTP things easy? Crate. base64 encoding? Crate. Randomness? Crate. Comparing a project written in Go to one in Rust, you almost immediately have to start pulling in multiple dependencies for really common things. I’m a much bigger fan of Rust than Go, but go’s stdlib is way more useful than just and I wish rust would add more 
[Reposting my comment from another thread](https://www.reddit.com/r/programming/comments/a0kxmw/i_dont_know_what_to_say_backdoor_in_popular/eaj7y7k/) &amp;#x200B; &gt;The key metric is: &gt; &gt;***The total number of independent code owners in your transitive dependency tree.*** &gt; &gt;The JS/npm culture encourages the production and use of one-line "libraries," and as a result your dependency tree has a hundred times as many individual code owners as with other languages, each one responsible for one hundredth of the code. &gt; &gt;Here's how it works in sane ecosystems: When all of your dependencies, *including transitive dependencies*, are *owned* by a small number of well-known actors as part of large reputable projects, the difficulty of injecting malicious code into the average application's dependency tree becomes massively more difficult and time-consuming. It becomes so hard that its ROI goes to shit, and so people don't do it. &gt; &gt;Here, to get two million downloads of your malware per week, all you had to do was send an email to a single person to get ownership to overwrite a tiny piece of code with complete abandon. &gt; &gt;This would not happen if your project only had a total of ten transitive dependencies and every one of them had a team of maintainers who accept or reject code contributions. &gt; &gt;As an illustrative data point, we have a large game server infrastructure written in C++ and C#, and the total sum of transitive library dependencies for both C++ and C# servers is around 20. All of the dependencies are large established projects with no dependencies of their own, such as libcurl, protobuf or Newtonsoft.Json. &amp;#x200B; IMO this kind of dependency ownership proliferation is something that comes as part of the culture of the ecosystem, but is also something that tooling can help drive in a certain direction. [crates.io](https://crates.io) could for example have a simple number for how many teams are involved in developing the transitive dependency tree of the crate, and you could have a `cargo` command that shows you the same for your own dependency list, and also shows the same when adding a new dependency. The definition of a "team" becomes somewhat difficult here though. The intent here would be to nudge the community in a specific direction (fewer, more complete high-quality dependencies) by exposing and promoting this information in a prominent location and allowing people to easily make use of it.
Probably possible, but not feasible or worth it. You might as well just vendor your dependencies, and run cargo inside a VM without any network access.
Might want to check the sub you place this in next time. You’re looking for /r/playrust since this is all about a programming language also named Rust.
As I read it, it's certainly *an* issue. Per the linked article: &gt; the version published to npm snuck some additional code into the minified file \[...\] the code requires in ./test/data.js, which was also [snuck into the npm published version](https://unpkg.com/flatmap-stream@0.1.1/test/data.js) of flatmap-stream despite not being in the GitHub source &amp;#x200B; I could be reading it wrong, and it's certainly not the only issue, or the biggest one, but it is one that you possible could automate checks for and at least catch some malicious attempts (and/or honest mistakes). &amp;#x200B; &amp;#x200B; &amp;#x200B;
From an auditing perspective, that's quite easy to grep for.
The "cargo: allow `crate_type=bin` examples to run" link is börked.
\&gt; BTW it would be a nice touch that cargo and rustc could monitor for cpu temp and slow down accordingly. &amp;#x200B; This is the CPUs task...
Surely you could have a curated, peer-reviewed subset of crates. But having all crates managed this way is not practical. Maybe crates.io could have a "trusted" flag, and Cargo.toml could require that only trusted crates are used. I'm not sure if this is a good idea either, but at least it *could* be done.
Just having a package source field in Cargo.toml would be enough, for me at least. I don't mind crates.io being the default package source, but using a separate crate repository shouldn't be hard.
I have a thing, that i imagine is simple causing a hassle for album in random { println!("{}", album.artist.unwrap().as_str()); let songs = album.songs(&amp;client).unwrap(); for song in songs { println!("{}", song.title) } } This is causing an error error[E0382]: borrow of moved value: `album` --&gt; src/main.rs:76:21 | 75 | println!("{}", album.artist.unwrap().as_str()); | ------------ value moved here 76 | let songs = album.songs(&amp;client).unwrap(); | ^^^^^ value borrowed here after move | = note: move occurs because `album.artist` has type `std::option::Option&lt;std::string::String&gt;`, which does not implement the `Copy` trait But i dont really see why this should be causing a problem 
How many people code review dependency updates? If you care you do but I understand that actual security is rare. 
Yeah, rand is not in the standard library. To be honest, as long as crates works well it's fine by me to put functionality like that in a crate.
Ah, I was thinking of what I saw in the original pull request where the news first broke: &gt; @dominictarr Why was @right9ctrl given access to this repo? He added flatmap-stream which is entirely (1 commit to the repo but has 3 versions, the latest one removes the injection, unmaintained, created 3 months ago) an injection targeting ps-tree. After he adds it at almost the exact same time the injection is added to flatmap-stream, he bumps the version and publishes. Literally the second commit (3 days later) after that he removes the injection and bumps a major version so he can clear the repo of having flatmap-stream but still have everyone (millions of weekly installs) using 3.x affected.
Just want to remind folks in the thread about [Geiger](https://github.com/anderejd/cargo-geiger). No, it's not perfect for eliminating the risk of an `event-stream` like attack. The malicious code could have been designed without unsafe blocks. However this specific obfuscation tactic (IIRC decrypting some payload and executing it) would be unsafe rust AFAICT.
Although some of those crates are maintained by Mozilla people as well
Now if we could translate this into a standard that every package manager on every language can implement, that would be nice.
The first point, namespacing, is unhelpful. The instant you get more than one person maintaining a project you'll want group namespaces, and there you go, the vulnerability is back. I do like the idea of requiring a signature or such for publishing, and crates.io has been working on this sort of thing for a bit - there was a recent announcement about it. But it wouldn't help here cause the legitimate maintainer is the one who introduced the backdoor. One place a signature might be useful though is having each published version of a crate linked to a git/hg/whatever revision. If so, then you can verify that the contents of a crate actually match what's on GitHub.
&gt; Don't upgrade your libraries unless you need to. I don't think this is the right way to go personally. As it stands now I would say the majority of crates out there have dependencies listed that are outdated for what is objectively no reason. In 90% of cases if you do `cargo update --aggressive` on any arbitrary crate, you'll see it do a long list of updates, and then when you go to build it and test whatever examples are present... everything will compile and the examples will still work fine! Also I actively avoid crates that have like 20+ dependencies listed, all with *specific* versions, as I've found they generally tend to just get increasingly more outdated over time as opposed to being updated reasonably often.
That's currently being worked on. All I know of the details is "it's apparently harder than it looks". It's something many people want though.
Yeh, After this all blew up I realised that there's really not a lot you can do unless you have really fine grained control over effects. For example a haskell library with no IO in it's interface (and no unsafePerformIO lurking anywhere) should be incapable of interfering with other packages, meaning you only have to audit the packages with IO in their signatures... Seems like an interesting niche.
&gt; Firejail interesting, how did i miss this. But really i expect something in the kernel or default distro installs.
It's a culture thing. We need to learn that duplication is not always bad, extracting a module into a separate repo is not always good, and vendoring makes sense many times. I wish that rust libraries would be more hesitant to include dependencies, because right now, many popular libraries are packed with tons of them, and auditing so many dependencies is just not feasible. When it comes to a possible move by rust developers... Maybe cargo should support vendoring out of the box, and make it as easy as adding an external dependency is now.
My only real issue with crates personally is the completely unavoidable pulling in, building, and linking against multiple versions of *the same crate*, all the time, everywhere, when in many cases the difference between `0.2.3` and `0.2.4` is a small as a single-line change to a single file that you never even build because it's behind a feature listing that you're not using.
I don't think Cargo will use two semver compatible releases of the same crate. I've generally found the ecosystem to be pretty good at reducing duplicative dependencies. Which projects are you uaing that result in duplicates?
From what I can tell it's a problem that arises due specifically to people not using semver ranges but putting fully qualified version numbers in the TOMLs. As far as I can tell, if two different crates use a third crate, one depending on *exactly* `0.2.3` and one depending on *exactly* `0.2.4`, Cargo will indeed build both versions of the third crate.
I don't think I've ever seen folks use `=x.y.z` constraints, or at least, I know it isn't common. But your comments make it seem like this is a problem you run into frequently. Can yoy point to some examples?
We need more information. What are the signatures of album.artist, album.songs, client and the declaration of album and its type?
Seems like a custom derive is what you want. Emil's can have arbitrary discriminants.
Not to mention that the temperature limits are different for every CPU.
good, that’s what it was. by now I’m more inclined to believe it, though
Need to merge a docs PR from Anthony Deschamps on my personal copy of rpi-ws281x-rust to direct people to the correct repository (which FYI is https://github.com/rpi-ws281x/rpi-ws281x-rust). Also, not this week, but this January, I'm actually going to follow through on Spacebox, my idea for a free and open source Dropbox client in Rust. It would let us reclaim support for non-ext4 file systems, etc. So if you're interested comment here or drop me a DM and I can put you on the repo.
IIRC, the hacker contributed to the package for 1-2 weeks before the handover.
That page is not compliant with European Data Protection Law (GDPR) - notably if you are asking the user for their contact information, it is not sufficient to just say "By clicking 'send me now' you give consent to processing your data'". In particular, you need to explain how that data will be processed.
&lt;filesystem&gt; was added [in C++17](https://en.cppreference.com/w/cpp/filesystem) but I get your point. 
One would need a socially acceptable alternative, and whatever that looks like, it would need to be more appealing than the incentive of being relieved of a maintenance burden for a package you no longer need.
I really don't want to throw anyone under the bus, so to list one somewhat "ubiquitous" crate I've personally never used and just randomly chose from near the top of crates.io sorted by all-time downloads, `quote` currently depends specifically on version `0.4.21` of `proc-macro2`. I feel like it's just quite visibly incredibly common overall if you start scrolling through TOMLs.
Fixed now. 👍
Thanks!
Can we have an idea of the normal ticket price?
I was getting envious of many of the tools we have for data processing in Python and Spark land so wrote a library that loosely mimics the functionality of Beam. Plenty of features remain to be written and would appreciate candid feedback as well!
That whole page just screams "We will mine your data and sell it to the highest bidder".
F
Linux has good and improving support for kernel-level process sandboxing. Example: https://en.wikipedia.org/wiki/Linux_namespaces
I was just thinking about this, but for a different reason. Building a project with lots of dependencies, such as from `cargo install`, has a tendency to use 100% cpu which itself has a tendency to freeze up windows, which for some reason doesnt give itself priority cpu time or whatever. i wouldn't mind it keeping a core free and builds taking slightly longer so long as my computer didnt freeze everytime i wanted to install something..
I guess its impossible to put something on the internet without someone in this subreddit scooping it. ;) I'm currently on a transatlantic flight and I won't be free to answer questions for the next 24 hours, but I'll be blogging about this project tomorrow.
well, in haskell sum types are explicitly done by summing types (so each variant is already a type), whereas in rust they're done by summing named tuple "variants", which are weird and don't currently have their own type
I'm not worried about `const fn`; it is the *solution*. As for build scripts, I've written [a proposal](https://github.com/rust-lang/rfcs/pull/2523) that will obviate the need for a significant chunk of all `build.rs` files written. With respect to procedural macros, if we enforced that the procedural macro must be `const fn` then it too cannot perform side effects and only work with the `TokenStream` given to it. We'll need to make `const fn` more capable to make that viable tho.
There's always [`SafeHaskell`](https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/safe-haskell.html). Look at the [`mac`](https://hackage.haskell.org/package/mac-0.1.3.0) package for an example of doing information flow control with it. For more flexible mechanisms there's [Dependent Information Flow Types](http://ctp.di.fct.unl.pt/~luisal/resources/popl15-paper187.pdf).
It's actually in FCP close right now
You'll have to think about the precise semantics of `[(item, const, macro)]` here including how it deals with transitive dependencies; however, one could also have a more fine grained granularity for the `use` syntax.
It probably won't, the disposition is to close the RFC.
This is tons of fun! Great job :)
Might want to take another look, the RFC is listed as `disposition-close`..
Well one needs to check the code of every dep on every change to be really sure. All other methods demand some degree of trust in other people's work and good intentions. But this also applies to HW and OS's we use every day. So something like the exploit mentioned above can never completely be prevented. At least I don't see a way to accomplish this. 
[Bubblewrap](https://github.com/projectatomic/bubblewrap)?
Upon taking another look, what I think I'm actually referring to is basically just: A) any instance where there's only two-decimal-place versions like `0.15` vs `0.16` being specified, and there's no breaking changes between those two versions B) any instance where there's something like `0.2.9` vs `0.3.0` being specified, and there's no breaking changes between those two versions. I guess the real issue is a combination of different people just not operating at the same pace as far as updating their TOMLs, and also the fact that some people may literally never introduce any breaking changes throughout the whole lifetime of their Crate, whereas others might introduce them often.
Yeah, super sketch looking. I will not put my information anywhere near that shit.
sorry, boats :)
Thanks for that! It really looks interesting, as i was trying to move my pet project from sync TcpStream to tokio a while ago and gave up (mainly waiting for await/async). This just looks like exactly what i would have needed.
Perhaps you could write something like: `impl Instruction {` `pub fn from_byte(byte: u8) -&gt; Option&lt;Self&gt; {` `match byte {` `0x00 =&gt; Some(Self::Val),` `_ =&gt; None,` `}` `}` `}`
Would be nice if we had GPG-signed packages like Debian does. 
Totally agree. Rust has quickly become my favorite programming language, but coming from Go, I *really* miss the full-featured, readable, high-quality stdlib.
Lots of this nihilism in this thread. But the fact remains that NPM was the target, and not Debian. Because Debian does some things differently. 
How about a gameified review queue similar to stackoverflow where you can earn shiny karma / points / reputation / ... ? Many people seem to actually enjoy grinding on boring tasks like this. Even better: Deletionists could kill off all the nonsense packages.
A version of this could be in the Rust (unfinished) Reference document. But if not, I'm cool with just bookmarking this resource. Thanks, that will be very useful to me!
I have been thinking about how to crowd-source reviewing for a while now. I've called the latest iteration [Weighted Webs of Trust](https://github.com/matthieu-m/matthieu-m.github.io/blob/master/wwot.md); I invite you to have a look at what I think could manage crowd-sourced reviews at scale.
cargo will report an error in this scenario, it will not depend on both versions (you could have tested this yourself).
&gt; Well one needs to check the code of every dep on every change to be really sure. It's quite insufficient, though. I can relatively easily check that the code does no I/O, but I'll be unable to assess whether a particular cryptographic library is not willingly inserting backdoors when encrypting.
cargo treats `0.x` as incompatible with `0.y`, which is the convention for pre-`1.0` crates in Rust. If you don't introduce a breaking change, you should not increment that version number in pre-`1.0` crates.
this is available on nightly under the alternative registries feature
If you want a higher level of service than "WITHOUT WARRANTY OF ANY KIND" sign a contract and pay the maintainer.
The language and ecosystem can't. This was a social engineering attack. OSS implies you are the support, you are doing due diligence. If you neglect this responsibility it is on you. This why every OSS license had a section that screams &gt;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Literally what that is saying is, "_I don't guarantee this will work, if this breaks, you are on your own_" 
I was thinking of it as an opt in - for a small experimental project you might not bother requiring audited dependencies but for something you are going to rely on in a production setting you can and probably should already be auditing what goes into the final product. Allowing those audits to be tracked, made visible to others and enforced in your build if you want would allow others to benefit from your efforts. To echo nickez2001's reply, it's certainly been common practice in the firm's I've worked in in the past decade to create an internal repo which hosts a subset of publicly available jars/nugets/etc and block downloads from the equivalent public repos to allow them to review and control which versions of open source dependencies can be used. Having a frictionless opt in way of achieving this built into cargo/crates.io would eliminate the need to have an in house curated repository in a lot of cases.
The book uses the Yew framework for making a frontend. Yew is pretty opinionated, but looks pretty interesting. Any experiences with it?
Yeah I suppose I should've specified that this is exactly the kind of thing I want to avoid, as adding new instructions would mean updating the conversion function. I think it looks like a custom derive is my only bet...so I think I'll stick with the dependency. Ah well!
[removed]
You stop trusting the maintainer. It's how Debian/aptitude work, and it works quite well. By only allowing select maintainers in certain channels, one avoids situations like this. 
&gt; What does it actually take for a crate to hit 1.0? A miracle. We have a terrible tendency to treat `1.0` as "magic", "perfect", "production quality", "some mythical unreachable goal", instead of just "stable" as semver says. For Rust and its version of semver, `0.x` is just as stable as `1.x`, making `1.x` kinda redundant. This is also not helped by our even larger fear of `2.0`. For some reason we *really* hate the idea of bumping a major version.
&gt; The SemVer spec recommends, but does not require, that 1.0 correspond to some measure of "production readiness Where? Where does it recommended that? I'm not seeing anything like that. All it says is &gt; [Version 1.0.0 defines the public API. The way in which the version number is incremented after this release is dependent on this public API and how it changes.](https://semver.org/#spec-item-5) which says nothing about "production readiness", and &gt; [If your software is being used in production, it should probably already be 1.0.0. If you have a stable API on which users have come to depend, you should be 1.0.0. If you’re worrying a lot about backwards compatibility, you should probably already be 1.0.0.](https://semver.org/#how-do-i-know-when-to-release-100) Which says just being used in production, which is different than "you should be production ready". Incidentally, the "stable API" and "backwards compatibility" parts apply to most 0.x crates.
But experimental features like that are kind of in the minority, and there it makes sense to be 0.x. But most widely used, "stable", packages with public APIs and strong backwards compatibility guarantees are still pre-1.0, despite fitting the exact definition of what should be 1.0.
FYI the author added some compliment for Rust.
Even if unsafe was a good indicator: this sort of detection has been a cat-and-mouse game for a long time. There's generally always a way around it.
&gt; Have you tried IntelliJ? It's not perfect but it feels a bit more solid and it's getting better at a quick rate. But thats a third party tool and a completely different IDE. From the survey, the most widely used editors are VSCode, Vim, and then IntelliJ. 1 out of 3 editors working decently is not a good state of affairs. RLS is a blocker in my opinion. I use VSCode and RLS and i make do, but it isnt very nice. &gt; So, after the edition 2018 release I actually think that the next big thing to help adoption is to reduce compile times. Of course IDE work will help too. I disagree. Compile times are much easier to deal with than a lack of IDE support. Writing the code should be the easy part. You only compile after writing the code.
I would be interested in helping to implement this.
The second part is the bit I'm talking about.
&gt; Are you using vscode? Not the op but i'm using VSCode and it doesnt work well for me. I almost never get code completions, it has a tendency to get stuck if you add or remove dependencies(though it's improved a lot in this regard recently, i have to restart it a lot less lately, but i still have to sometimes)
I would suggest to those people that if they and people like them don't use the language, that they can hardly be represented in its community, because they aren't in it. 
Clarification: they all are very very evil. The two break/return cases are insane. 
Cool project. How is that name pronounced?
Planning on grabbing this tonight, felt weird not buying anything during the yearly prag prog turkey day sale so glad to see a book I want come out even in 'just' beta.
I'm working on it: https://github.com/dpc/crev . Come help me.
`nice cargo build` there ya go
Yeah, Debian does a thing differently: they don't let random people upload packages to their repos. That's not going to work for crates.io or npm. 
https://www.kernel.org/doc/html/v4.18/userspace-api/unshare.html
&gt; People generally don't take 3 months to learn to drive [..] This is a very US-centric thing to say. Here in Germany, you first have to pass a theoretical test, and absolve at least 20 lessons with a driving instructor before you are even allowed to the practical test. That process can very well take three months. That said, driving is a very risky activity that claims thousands of lives each year, so it makes sense to exercise caution. Similarly, I much rather have folks take three months until feeling productive than *feeling* productive earlier while actually *being* destructive.
Which is something I actually thoroughly enjoyed. It's always nice to learn about small nuances like these.
Very very nicely-done quiz. Thanks for making it and sharing it. Thanks also for entirely destroying my confidence that I have any idea how Rust works. I've been programming in this language for years and missed almost all of the questions.
I think the cargo community should learn some lessons from JS environment and create packages without any package dependencies. This could also eliminate other issues, like conflicting versions of the same package being requested from different dependencies. If you had a more complicated lib that required a dependency, say for example a png decoding lib that required a zlib dependency, it could be authored to explicitly remove this dependency in the lib, and instead provide an interface you filled out to glue the zlib dependency into png lib. This could also allow for other ideas, like maybe using a different zlib library that has specific features you want instead of the standard one. So there would be a bit more glue code when importing libraries with dependencies, but that is perhaps something another feature could be developed to solve.
Why not? It would definitely change the ecosystem a bunch, in both positive and negative ways. But it doesn't seem infeasible.
Because there's not nearly enough manpower to audit everything that exists on crates.io, never mind keep auditing things as they come in. So you either end up with a very limited set of packages on crates.io and everyone else moving elsewhere, or you need to spend insane amounts of resources to make it work at an acceptable rate.
&gt; Don't upgrade your libraries unless you need to. That leads to massively outdated libraries that are getting harder to upgrade, the longer you wait. By (carefully) upgrading often you can participate in migration when some feature is announced as deprecated in favour of a new one and then later the old one gets completely removed. But of course you should have as few dependencies as reasonably possible in the first place.
&gt; In this case I could actually have a [0u8; 4] and use it as a initialized buffer to then pass to uninitialized, but it seems unecessary extra work. You really should benchmark this. Also, since the buffer is so tiny, passing by value instead of by reference is very likely going to be faster than using uninitialized memory. Try passing `[0u8; 4]` to the function as-is without explicitly slicing it and see if that changes performance in any way.
https://crates.io/crates/differential-dataflow could be something to investigate for feature/implementation ideas
I think that the best thing to do to help mitigate this problem is to reduce dependencies. If I find a crate on crates.io that does what I need, then I realize that I'm depending on this person's code. What I directly depend on is usually a major crate by a trusted member of the rust community, or sometimes it's a small specialty crate that I end up inspecting to make sure it does what I need. The problem comes in when those crates depend on others that depend on others. I end up with hundreds of crates, that are usually just small utilities, to deal with buffers, bytes, or malloc, or something small. These are the ones that need special attention that I can't give them. It would be nice if they could be eliminated by moving functionality into the standard library, or "vendored" into the libraries that use them, or "blessed" by the rust community, or locked down so they can't be changed easily.
As long as you are learning Rust, you *are* worthy of the Rustacean label. Don't let anyone tell you otherwise.
Lol isn't github owned by ms now?
Thanks for the help all. &amp;#x200B; I moved to using the [string\_interner](https://crates.io/crates/string-interner) and [typed\_arena](https://crates.io/crates/typed-arena). One difficulty came up on this with respect to self references in structs. I would like a structure like (pseudo code, as writing on mobile) &amp;#x200B; `enum Value&lt;'a&gt; {` `VSTR(Vec&lt;&amp;'a Sym&gt;),` `VNUM(Vec&lt;f64&gt;),` `}` `struct Container&lt;'a&gt; {` `arena : Arena&lt;Value&gt;, // This doesn't work due to Rust not guaranteeing drop order` `interner : StringInterner&lt;Sym&gt;,` `kvPairs : HashMap&lt;Sym,&amp;Value&gt;.` `}` But that naturally doesn't work because of the self referential struct. I have the declare the arena outside the constructor so it's an extra parameter I have to pass around everywhere. Is there a design pattern around this?
Unsafe is easier if you avoid it completely.
Maybe have a blessed list of crates into a "batteries" edition. That allow to promote and demote crates when time passes on. This way, most people just get the "batteries" edition, alike python, is not as important if some libs are not used or replaced. Who wanna power then just take the "naked" edition and pull things.
FWIW #5 is a bug that I believe the plan-of-record is to fix as part of the universes work that Niko has been doing.
imagine a little visual streamlining in rust (intra module full inference, impl types implied by trait), but i guess you want the whole 'significant whitespace' thing
I wonder if cargo could learn from Android's security model here. Basically, we could allow: - crates can declare what permissions they need, i.e. network, file I/O, threading, heap allocation, etc. Then if any of their dependencies need more than that the compiler will error them. - crates can declare what permissions are allowed for \_each\_ dependency. I.e. if I depend on regex I should give it no permissions besides heap allocation (not even threading). Then the compiler would error if it requires extra. This could make auditing these kind of issues much more effective. One issue is that there has to be some kind escape+auditing mechanism for external (i.e. C) dependencies, since we can't restrict their access. For instance, I would like to be able to use \[ring](https://github.com/briansmith/ring) (and specify that it doesn't require permissions) even though it uses `unsafe` for C access to `boringssl`.
&gt; As for build scripts, I've written a proposal that will obviate the need for a significant chunk of all build.rs files written I wouldn't call this chunk significant. A lot of people use `build.rs` to generate files that get `include!`d, to compile C libraries that get linked, to link C libraries, etc. For the problem that that particular RFC solves, a lot of people just use cargo features to gate on whether some Rust feature should be used, not using `build.rs` at all. E.g. just because I'm using nightly does not mean that I want to enable nightly features.
Nice article... but who said this? &gt; The phrase the Rust team members like to use is that they’re trying to make the best 90’s era programming language they can.
To be honest, it's mostly purity and ML function calls. `add 2 3` rather than `add(2, 3)`.
Re. purity, there's `const fn` now. :) I personally would have preferred a Rust with a more Haskellian syntax (i.e. only having `data`, whitespace, etc...) but there's the complexity budget to think about; When you are trying to get more safety into the "systems" space, compromising on syntax to win folks over is a good trade-off even tho Haskell has nicer syntax.
That did the trick. Thank you!
- https://crates.io/crates/rustc_version/reverse_dependencies - https://crates.io/crates/version_check/reverse_dependencies This RFC isn't intended to solve all problems but every bit counts; if we can reduce the use of `build.rs` files, then that's less time folks have to worry during reviews.
&gt; Romio is a fork of another Rust project called Tokio "R" is two letter before "T", and "m" two letter after "k". Therefore, the balance is preserved, and the name of the fork can be objectively qualified as a "high quality". 
very interesting tech stack choice. i might be working in mapping next, but probably stuck using whatever is already in place.
The goal is to keep Ferris de facto, since “official status” itself in the Rust community is a complicated and not so clear concept. 
I don’t think anyone did directy. I usually say “2000s” or something like that.
Removing extern crate doesn’t really change the situation with Cargo, rustc already takes the crates as a parameter to the build.
For heap-allocated memory there is a way to request already zeroed memory from the OS, which it typically has on hand, so it's almost as efficient as requesting uninitialized memory, but still safe. When you write `vec![0; len]` it eventually gets invoked under the hood. Could you post the code you're trying to optimize? That way I could be more specific. On a related note, I have recently proposed [a safe abstraction](https://internals.rust-lang.org/t/pre-rfc-fixed-capacity-view-of-vec/8413) that solves essentially this problem - filling an uninitialized preallocated array efficiently, but there is no production-grade implementation if it yet.
Can anyone clarify whether this some kind of stable-only thing that nightly doesn't do, or something? Otherwise I don't think that functionality exists.
Can't wait to send this to the next applicant for our job. /s
I duffed around with it a few weeks ago to get a fly-over view of how far along it is. There's a little bit of a hurdle to figure out how everything is supposed to work together once you get stateful components on the screen, but I was pretty jazzed about how well it seemed to work together when I did get my head around it. I was impressed with how little you felt the seams between rust/javascript/html and how not painful it was to build things just using cargo with some flags.
`const fn` is not about purity.
With that kind of syntax it would be quite surprising if currying didn't work.
In an ecosystem with a larger granularity and smaller dependency trees it is much more difficult to find a project where * you can quickly become the sole committer with nobody else reviewing your commits and * the project is used as a dependency of a huge number of other projects I mean, I'm not worried about this kind of attack against any of the .NET libraries I use from Nuget, because I know they have active stewards who have been in good standing with the community for a long time (way longer than two weeks). There's a lot more attack surface for this kind of attack with something like webpack with its 700+ dependencies compared to Newtonsoft.Json with its... [0 dependencies](https://www.nuget.org/packages/Newtonsoft.Json). Right? Getting unreviewed commit access to Newtonsoft.Json releases would require a HELL OF A LOT more than two weeks of work, but can you say the same for all the dependencies of webpack?
We'll just have to agree to disagree here; For me it's both about compile time evaluation and determinism.
why is the original one named `tokio` anyway? is there something more to it than a city name? didn't find anything on the website either.
I currently use [num-derive](https://crates.io/crates/num-derive) for this sort of task via `#[derive(FromPrimitive)]`. You can then write: let b: Option&lt;Instruction&gt; = FromPrimitive::from_u8(0x00); 
differntial-dataflow is interesting; I remember reading Naiad many moons ago and liked what they were doing!
&gt; To be honest, it's mostly purity and ML function calls. add 2 3 rather than add(2, 3). That would imply curried functions, which would require boxed functions and the like. You could probably define an offside rule for Rust, but I don't know how good it would be given Rust is procedural and lacks constructs like let/where blocks.
Rust is the only language where I have full-blown type-aware autocomplete working in Atom, and that has worked for at least a year. Still, it's nice to see effort to improve the Rust experience.
I don't think it does. Currying can work by creating a closure, which works fine without implicit boxing. (Another option is to just not have currying: have the syntax but require every function is fully applied.)
The project states the goal is to allow experimenting with async/await with networking. Tokio has supported async/await (in an experimental capacity given the unstable nature of async/await) for a few months. See examples here: https://github.com/tokio-rs/tokio/tree/master/tokio-async-await
I wanted to disagree with you about the visibility defaults feeling weird, but while writing this comment, I realized WHY it feels weird. When you compare this with an OO language (instead of a functional one), it actually feels natural. A trait is similar to an interface - both define common behaviour of otherwise unrelated types. And common behaviour that you cannot observe makes no sense. From this angle, it is okay that all items of a trait must be public. However, there is a difference between OO languages and rust: In OO languages, visibility works on the type level. In Rust, it works on the module level. In an OO language, an interface with private methods is useless. A trait with private items in rust would be useful, since it can be used in the same module. However, that is IMO an edge case. Even after these arguments, the "pub by default" behaviour inside traits still feels natural. Of course, that makes it much harder to find an ergonomic solution for your use case.
I'll take a wild guess: `tok` means "token" and refers to [`mio::Token`](https://docs.rs/mio/0.6.16/mio/struct.Token.html), which tells the reactor which task should be woken up when an event arrives
These are all things we definitely intend on handling! It's an open question how many of these are best expressed as middleware vs computed values. *Please* feel free to open issues on any/all items like this that don't already have issues!
I'd be interested to see what the difference is between each library. At a cursory glance they look very similar: [https://github.com/withoutboats/romio/blob/master/examples/echo.rs](https://github.com/withoutboats/romio/blob/master/examples/echo.rs) [https://github.com/tokio-rs/tokio/blob/master/tokio-async-await/examples/src/echo\_server.rs](https://github.com/tokio-rs/tokio/blob/master/tokio-async-await/examples/src/echo_server.rs)
Agreed. If I was to design a haskell-style syntax for Rust, I'd still keep argument tuples, because it properly reflects the underlying semantics.
You may want to look at `tokio-async-await`, which provides async/await support while providing access to all the Tokio machinery: https://github.com/tokio-rs/tokio/tree/master/tokio-async-await
Wow, they weren't exaggerating about how nice the community is either!
More precisely, syntax highlighting and code folding 
Type aware completion is provided by RLS as far as I know so any editor that uses RLS should perform the same. 
Some thoughts that will probably sound like criticism but aren't intended to be hostile: 1. As I understand it, the "web of trust" is about certifying identity. It's a very simple question being asked of the web: "Is this person who they say they are?" Your system seems to overload this concept of "trust" to ask something more complex: "Is this code safe?" 2. As written, it seems like your system could still fall prone to the attack. You trust projects, not releases. Yes, this attack involved adding a new dependency, but it could have easily been inlined from the beginning. 3. The burden of trusting releases is so much higher. Every release will need to be checked by *someone*, preferably someone not involved in the development of the project. That's a lot to ask of unpaid volunteers! 4. What does "trust" entail? If I certify that a package is not malicious, but miss a legitimate bug that ends up doing the equivalent of `rm -rf /`, have I broken the trust? Am I obligated to get into long discussions when someone wraps more than they should in `unsafe`? 5. This web is inevitably going to have many passive consumers of trust and relatively few "producers" of trust (ie: people actually reviewing code). I don't know if that's actually a problem, but it feels like it might leave an opening for paid reviews (or trusts) that may or may not be entirely accurate. 
Nothing is set in stone! Please file an issue :-)
Are these changes that will bring us closer to a stable ABI?
I'm writing some simple Rust programs to learn the language. Not trying to do anything novel, just solve simple programming problems to get comfortable with the language. I was wondering if anybody could give me feedback on my code? This is one of the first things I've ever written in Rust, so any feedback on my coding style is super helpful! In particular, I'm totally stuck on error handling in from_binary. I have it returning an Option, though changing to a Result would be fine. The idea is, I want to return an error if there is any digit besides 0 and 1, but I don't know how to do that in a closer. Ideas? Here is the code with passing tests: pub fn to_binary(mut i: u32) -&gt; String { // 0 is basically an edgecase, because it's the only time we use a leading 0 // in the return value if i == 0 { return "0".to_string(); } let largest_power = 1 + (i as f32).log2() as u32; (0..largest_power).rev().map(|e| { let power = (2 as u32).pow(e); if i &gt;= power { i -= power; '1' } else { '0' } }).collect() } pub fn from_binary(s: &amp;str) -&gt; Option&lt;u32&gt; { let total: u32 = s.chars().rev().enumerate().map(|c| { let (i, c) = c; if c == '1' { (2 as u32).pow(i as u32) } else { 0 } }).sum(); return Some(total); } #[cfg(test)] mod tests { use super::*; #[test] fn test_to_binary() { //assert_eq!("", to_binary(123)); // fail on purpose assert_eq!("0", to_binary(0)); assert_eq!("1", to_binary(1)); assert_eq!("10", to_binary(2)); assert_eq!("11", to_binary(3)); assert_eq!("100", to_binary(4)); assert_eq!("101", to_binary(5)); assert_eq!("110", to_binary(6)); assert_eq!("111", to_binary(7)); assert_eq!("1000", to_binary(8)); assert_eq!("1001", to_binary(9)); assert_eq!("1010", to_binary(10)); assert_eq!("1011", to_binary(11)); assert_eq!("1100", to_binary(12)); assert_eq!("1101", to_binary(13)); assert_eq!("1110", to_binary(14)); assert_eq!("1111", to_binary(15)); assert_eq!("10000", to_binary(16)); } #[test] fn test_from_binary() { assert_eq!(from_binary("0").unwrap(), 0); assert_eq!(from_binary("1").unwrap(), 1); assert_eq!(from_binary("10").unwrap(), 2); assert_eq!(from_binary("11").unwrap(), 3); assert_eq!(from_binary("100").unwrap(), 4); assert_eq!(from_binary("101").unwrap(), 5); assert_eq!(from_binary("110").unwrap(), 6); assert_eq!(from_binary("111").unwrap(), 7); assert_eq!(from_binary("1000").unwrap(), 8); assert_eq!(from_binary("1001").unwrap(), 9); assert_eq!(from_binary("1010").unwrap(), 10); assert_eq!(from_binary("1011").unwrap(), 11); assert_eq!(from_binary("1100").unwrap(), 12); assert_eq!(from_binary("1101").unwrap(), 13); assert_eq!(from_binary("1110").unwrap(), 14); assert_eq!(from_binary("1111").unwrap(), 15); assert_eq!(from_binary("10000").unwrap(), 16); } } Thanks!
"incompatible" means "not semver compatible." "incompatible" doesn't mean "can't build both crates in the same binary" in this context. I kind of feel like you've dodged my ultimate question though. Specifically, you originally said this: &gt; My only real issue with crates personally is the completely unavoidable pulling in, building, and linking against multiple versions of the same crate, all the time, everywhere, But this doesn't really match my experience. I mean, I've certainly seen it happen, but I've _also_ seen the ecosystem be pretty good about trying to move forward and reduce duplicate crates. I wanted to see some examples to correct my blind spots. Typically what happens is a new semver incompatible version of a widely used crate is released, and then for some intermediate time, crates wind up building both the new version and the old as the ecosystem upgrades to the newer version. The duplicate crate is unfortunate, but it's not for nothing. In exchange, folks can move forward at their own pace without builds breaking due to version resolution errors. That's a valuable thing to have, and it really needs to be mentioned in discussions lamenting the existence of duplicates.
"semver incompatible" is a term of art which means that cargo will not unify these dependencies. Given a set of dependency requirements that cargo considers "semver compatible," cargo will either unify them or, if it cannot, it will error. But if two dependencies are on "semver incompatible" versions of the same package, cargo will build both of them. That's what I mean when I say it treats them as incompatible. I think there's some confusion in this conversation: I am on the cargo team and I am explaining how cargo works.
&gt; That would imply curried functions, which would require boxed functions and the like. No it wouldn't. fn curry&lt;A, B, C, F: Fn(A, B)-&gt; C&gt;(f: F) -&gt; impl Fn(A) -&gt; impl Fn(B)-&gt;C { ... } Both impls would be known if A, B, C, and F are all known. The only reason this doesn't work right now is because you can't nest `impl Trait`s.
&gt; try depending on two crates that depend on libc = "=0.1.0"and libc = "=0.1.1" respectively. literally nobody uses that syntax. If it is specifically supposed to be what prevents this kind of duplication by changing the way it actually handles the dependencies, it's not working. It doesn't matter anyways, because I'm talking about crates I have no control over. It's a chain reaction sort of thing that you can't reasonably prevent.
This is really cool stuff!
It's actually an interesting problem I've run into when thinking about this. Since heap memory would be a side effect in a heap-less language, it would mean that every function that allocates would have to be wrapped in a monad or pass around a heap parameter. Otherwise, Rust-like linearity or uniqueness types would allow for in-place mutation even if the semantics require purity.
&gt; Is there actually some specific error message you had in mind? I've definitely never seen anything along those lines, ever. That's entirely expected, because unlike what you said initially, people don't actually forcefully pin to specific crate versions in their `Cargo.toml`. When you do that, you'll get the error we're talking about. Here: $ tree . ├── Cargo.toml ├── crate1 │ ├── Cargo.lock │ ├── Cargo.toml │ └── src │ └── lib.rs ├── crate2 │ ├── Cargo.lock │ ├── Cargo.toml │ └── src │ └── lib.rs └── src └── main.rs 5 directories, 8 files $ cat Cargo.toml [package] name = "cargo-error" version = "0.1.0" authors = ["Andrew Gallant &lt;jamslam@gmail.com&gt;"] edition = "2018" [dependencies] crate1 = { version = "*", path = "crate1" } crate2 = { version = "*", path = "crate2" } $ cat crate1/Cargo.toml [package] name = "crate1" version = "0.1.0" authors = ["Andrew Gallant &lt;jamslam@gmail.com&gt;"] [dependencies] aho-corasick = "=0.6.8" $ cat crate2/Cargo.toml [package] name = "crate2" version = "0.1.0" authors = ["Andrew Gallant &lt;jamslam@gmail.com&gt;"] [dependencies] aho-corasick = "=0.6.9" $ cargo build Updating crates.io index error: failed to select a version for `aho-corasick`. ... required by package `crate2 v0.1.0 (/tmp/cargo-error/crate2)` ... which is depended on by `cargo-error v0.1.0 (/tmp/cargo-error)` versions that meet the requirements `= 0.6.9` are: 0.6.9 all possible versions conflict with previously selected packages. previously selected package `aho-corasick v0.6.8` ... which is depended on by `crate1 v0.1.0 (/tmp/cargo-error/crate1)` ... which is depended on by `cargo-error v0.1.0 (/tmp/cargo-error)` failed to select a version for `aho-corasick` which could resolve this conflict My take on the matter here is that your initial phrasing wasn't quite using the terms correctly, and caused us to talk past each other. Basically, you were talking about others pinning dependencies and that causing duplicate builds, but the thing is, people _aren't_ pinning dependencies in libraries and duplicate builds only come about where there are two (or more) semver incompatible releases in the same build tree. I can make this statement because of the following two facts: 1. Cargo's dependency resolver will pick the latest semver compatible release among two or more possibilities for the same crate that are semver compatible. 2. If no such selection is possible, then Cargo will report an error, as shown above. The easiest way to cause Cargo to fail is to use `=` style dependency constraints, but it's not the only way. 
It does: https://www.reddit.com/r/rust/comments/a14i9x/how_can_we_defend_against_these_type_of_attacks/eaocjsq/ 
For what TDD stands for? 
I am fine with any feedback, even criticisms. :) 1. WoT here means: "Do I trust that entity with their trust in code and/or people". Identity is secondary. Any imperfections in trust and people's judgment, are to be corrected by requiring more reviews. 2. It might not be clear, but every time you review a package, you review the exact content of it, so you review each release. Any time a single bit changes, new reviews will have to be made. 3. If you're serious about your software you're supposed to review your dependencies. At least business etc. should do it routinely. Using `crev`/`cargo trust` people and business now will have a way to collaborate, share etc. Some people could even make a living out of it: you want package reviewed: here is my paypal/Bitcoin address, tell me which one and I will review it in a day. Reviews also include things like `thoroughness`, `understanding`, `trust`, so one can eg. do a quick scan, spend 5 minutes reviewing the package and set the `thoroughness: low` so that people that don't want to trust a package that wasn't thoroughly reviewed, can ignore such review. Also, it's fine to trust reputable people reviewing their own software. It will make sharing github access and incrasing bug factor easier: even a rouge team member, can not fake reviews of other team members, etc. To sum up: `crev` is opt-in, and if you're serious about trusting your code, it will help you, it also allows starting with low-quality, low-effort reviews, and build upwards for packages that are commonly used. 4. No code and strict rules can replace human judgment. In your own reviews you can distrust packages that have `unsafe`, someone else can mark as untrusted packages that don't have 100% code coverage. You also need to judge which people, with what standards, to trust. 5. People that produce the reviews would probably do it anyway, so it doesn't cost them anything for rest of the community to leach on their work. In a sense whole Open Source is like this. And I already said: I anticipate paid reviews to be a thing, and I think it's awesome! People will have incentive to maintain a stellar reputation and great standard. I could even anticipate comercial, closed-groups reviews: even CVEs could be converted to "distrust code reviews" and charged money for. I am totally fine with that. It is supposed to be a free participation, open source tool, and as long as it is helpful and increases security, I think it's awesome.
Just saved this to 'watch later' on youtube (no time now). You might want to put something in the description about the talk titles/content. I just know I'll find this in a few months again and will have no idea what it is.
I like this, and have been thinking along similar lines. One thing I would ask you to consider is the potential for abuse; this sort of system provides an incentive for unethical parties to pad it by producing illegitimate reviews. `crev` has some consideration for this sort of thing already and deals with it via web of trust stuff, it just seems worth bringing up that, while good, all this really does is increase the cost of high-trust illegitimate reviews. Deterrent, not solution. Which may be enough, I confess.
I like this, and have been thinking along similar lines. One thing I would ask you to consider is the potential for abuse; this sort of system provides an incentive for unethical parties to pad it by producing illegitimate reviews. crev has some consideration for this sort of thing already and deals with it via web of trust stuff, it just seems worth bringing up that, while good, all this really does is increase the cost of high-trust illegitimate reviews. Deterrent, not solution. Which may be enough, I confess.
I have some questions: 1. If anybody can review a package, how are you supposed to trust the number of reviews? (I think you shortly mentioned it in the wiki) Will there be, sort of like a list over which users have reviewed and trusted a project? I'd want to go through a list and check if anybody I find trustworthy actually reviewed it. 2. If anybody can review a package, how will abuse of this system be handled? I already see before me, like the users name-squatting on crates.io, doing the same thing with review, either flag random crates trusted or untrusted. Will users that are able to review have to sign up somewhere? Or should users that are able to review packages, be invited or approved by existing members? I guess my main point is, having projects reviewed is nice. Though I don't see this succeeding unless the person that provides the review is also trusted. So some sort of approval system for users that want to start reviewing packages, and having trusted users in those approving positions to begin with. Then providing a list over which reviewers have trusted any given package.
The labels on that graph are completely unreadable without zooming in...
I would think you could make a language that compiles to rust and has true currying, I would just expect the compile times to be even worse...
&gt; The first point, namespacing, is unhelpful. The instant you get more than one person maintaining a project you'll want group namespaces, and there you go, the vulnerability is back. Not really. You could have org namespaces (That could be visually distinct from individual accounts), and list the past and current members in crates.io with other relevant metadata. Then it's up to the org to accept new members and manage its reputation. Technically, the owner of a one man org with dozens of packages could transfer all of them to an untrusted party in one fell swoop, but this isn't something to do lightly. Especially if there's an audit trail.
Does anyone with networking experience with rust have suggestions for approaching a program that captures data on one system(server) and sends it to another(client)? In my case that data is binary with 50-100 of them to serve to the client per second. The client should also be able to transfer some data to the server. The server would just send out data to any connected client when that data is available, the clients don't request it, and when a client does receive the data it'll consume/process it. Do I need to break my data into UDP/TCP packets and send them over a steam or something? How low level do you need to go in Rust to do this? I have something that works presently with shared memory mapped file, but would like to migrate to over a network. I assume asking on this thread is relevant to the topic?
Vim + racer + vim-racer + rust.vim + syntatics This stack is made in heaven. Atom,vs code are so slow and resource hungry compared to this stack as they use NON-NATIVE electrons. 
in `to_binary`: * you don't need to add one to the term which gets assigned to `largest_power` if you use an inclusive range: `0..=largest_power` in `from_binary`: * you can pattern match inside the parameter list: `.map(|(i, c)| { … })` * instead of `return Some(total);`, return implicitly with `Some(total)` (no semicolon!) * `2u32` is better than `2 as u32` * currently, `from_binary` will never return `None` because you treat any digits unequal to `1` as `0` * I'd write `assert_eq!(f(x), Some(y))` instead of `assert_eq!(f().unwrap(), y)` 
Test Driven Development. 
Is racer an rls alternative? Does the completion it provides context sensitive? I'm a vim user myself
These are _medium_ to hard questions? I have to recalibrate my Rust skill level to below medium then... I mean I knew a few (less than half of them) but these seem like corner cases in the Rust language that the compiler devs are intimately familiar with but not 'regular' users. 
Then maybe don't speak for a group you're not a part of? It's that kind of attitude that's pushing people away.
I don't think you understand what I said. Why bother trying to fit in something that will not try to challenge their status quo. Some communities are far more welcoming, so they don't see the need to push themselves to challenge systemic issues on their own.
Tech is just a privileged enough field that it's easier to be out than in many fields where you'd just get fired on the spot for coming out.
&gt; Why bother trying to fit in a community that will not try to challenge their status quo? How do you "challenge" the "status quo" of "some kinds of people aren't members of our community" without having those kinds of people become members?! Invent fake members? I'm not sure you understand what you're saying. &gt; Some communities are far more welcoming We were talking about under-representation, not welcoming. Two completely different things. If you look at [the survey](https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html#feeling-welcome) most people *do* feel welcome, followed by not being sure.
Okay, thanks for posting your setup. I'm going to try this out. 
Emacs + racer + rust-mode + company-rust yo
I'd rather just make a new language for that, hence [Pikelet](https://github.com/pikelet-lang/pikelet). Not sure if compilation to Rust is worth it - having good Rust FFI support would be nice though. Hoping that some of the type preserving compilation work on Rust, OCaml, and Coq will make that easier.
Glad to see this works now, remember trying to get something when it was still cretonne Will hopefully have a Befunge JIT soon. Looking over this, I'm not seeing how one drops functions. Important in the context of recompillation
&gt; Which may be enough, I confess. Considering how rarely things like package hijacking in NPM actually happen, even without any system like this, I believe the main day-to-day purpose of `cargo trust` would be notifying users of serious honest bugs, warnings about low quality code, and just increasing robustness and quality of the ecosystem by giving incentive to actually coordinating some eyeballs on popular crates and "scoring" them. "Catching crime" will be just a potential side-effect. I would also argue that this system can not be completely gamed. It's only possible to somehow avoiding detection by it's users too liberal with who they put trust in (in which case, why they even bother in using it in the first place) without enough redundancy. Some entities like companies will probably not have anyone outside of their org. in their WoT, so it would take multiple "bribes"/"hacks"/etc. And since everything is replicated and cryptographicaly signed, it will be easy to find who was at fault and in extreme case even take legal actions (if it in example was your own employee). This should give enough incentive to people not even attempt a hijack like this.
Agreed. This reminds me of code obfuscation competitions. 
As a way to learn MIDI and Rust, I'm trying to make a little MIDI message parsing library. So far I'm unsure if I should represent MIDI messages as nested enums, or have one huge enum that contains every possible message type. For instance, I've got: ``` rust enum MidiMessage { SystemMessage, ChannelMessage } enum ChannelMessage { ChannelModeMessage, ChannelVoiceMessage } enum SystemMessage { SysEx, RealTime, Common } enum ChannelVoiceMessage { NoteOff{ note: u8, channel: u8, velocity: u8 }, // etc.. } // etc.. ``` And then using it would look like: ``` Rust // ..deep within a lexing fn messages.push( MidiMessage ::ChannelMessage ::ChannelVoiceMessage ::NoteOff { note, velocity, channel } ); ``` It's very descriptive, but I don't think it would be very friendly if anyone wanted to consume those types. In less anyone has any suggestions, I'll probably cram all of the variants into a single `MidiMessage` enum and give them longer names like `ChannelVoiceNoteOff`
Super helpful, thanks!
It's entertaining trivia, much like http://cppquiz.org.
Maybe I didn't speak for a group I'm not a part of?
This would be incredibly hard/impossible to actually enforce.
You probably want to look at r2d2 -- not sure if it'll do everything you need, but it is a generic connection pool. The biggest issue is that it's not async, but I think it should work fine with async connections that you get from the pool synchronously (which you may be able to do async in a threadpool?). Even if you can't use it, looking at how it works may be helpful for designing your own async connection pooling. &amp;#x200B; [https://github.com/sfackler/r2d2](https://github.com/sfackler/r2d2)
I love hard programming quizzes, but "how does the rust parser tokenize line noise" aren't exactly the most interesting of questions.
&gt;You have answered 0 of 26 questions correctly. ... yep.
Sorry for reviving an old thread, but I saw sparkles doing this exact thing and was wondering if you had noticed anything weird when doing so, or had come across a better way to do it.
Nope, it basically replies on implementation specific (but not undefined) behavior.
I'd go with a stripped down model. The attack went something like this: 1. Compromise a package by inserting obfuscated code that didn't match the repository. Obfuscated code as a build input is a normal thing in the JS world, so really the only issue this corresponds to in rust is code uploaded to [crates.io](https://crates.io) not matching code on github/gitlab/etc. (flatmap-stream) 2. Compromise a package by relying on the compromised package (social engineering to take over the account). Furthermore they hid their reliance on said feature via series of commits adding the dependence, cutting a last minor release, removing it and then bumping the major version. End result is that it wasn't easy to notice the new package. (event-stream) 3. The compromised package executed specific obfuscated code depending on the environment to unpack even more code and run it. So what are the actual things used in this attack? 1. Code uploaded to NPM was different than the code in the repo (flatmap-stream) 2. A new dependency was stealthily added (to event-stream) 3. A dependency changed ownership stealthily (event-stream changed owners) 4. Code execution changed in a very, very obfuscated manner depending on the environment. I think we need some tooling changes to begin with: 1. Add code signing to assert crate ownership. Maybe the current login process is enough, I don't know quite enough to say. But we probably want some way to assert ownership of who actually cut a release. 2. Require (or maybe just optional?) a canonical url to where the source that built the [crates.io](https://crates.io) upload can be found, as well as the script required to assemble it. 3. Create a service that compares the contents of a crate on [crates.io](https://crates.io) and compares it to what's produced from the source repository. 4. Add a capabilities system for the [build.rs](https://build.rs), namely 1. The ability to declare that it won't use unsafe 2. The ability to declare what crates it will use 3. The ability to declare what parts of the std library/core are available to it I image that for part 4, it'd be very easy to write a wrapper around the fs utilities that can grant file system access (file reading/writing &amp; execution) in a restricted manner, available through a config. As well as wrapping what environment variables are available to it. Finally, with those in place, we just need a tool that lets us track what things will change when updating the Cargo.lock file: * New dependency? Ought to take a look * Owner changed? Also a flag to look closer * [build.rs](https://build.rs) permissions changed? Also a cue to take a closer look * Content from [crates.io](https://crates.io) doesn't match the source repository? That's a big red flag. Security is about layers, and I think these could be some good layers to add.
That's not the default behavior.
So it’s not the most elegant, but I wrote something that’s a pool of NameServers in trust-dns. To work around the problem of looping over all connections, it passes back a future result which is what the receiver is polling on. To make all this work, the NameServerPool basically runs in the background in Tokio, with message queues passing the request and responses around. Here’s a link to the code: https://github.com/bluejekyll/trust-dns/blob/master/crates/resolver/src/name_server_pool.rs
If the question let you answer both "yes" and "non-heterosexual" then yes the are not exclusive. I was assuming "yes (not specified)" meant that nothing else was specified. 
Thank you for responding so fast! I did a bit more research and came across this [issue](https://github.com/rust-lang/rust/issues/56058) , any idea for a fix for when/if this gets implemented?
It’s cool! You caught me at a good time. I don’t know, frankly.
I guess `S` isn't a variable in the `let` statement. It's a struct pattern, matching any instance of `S`. It's a very vacuous example of pattern matching.
Shameless plug for my crate [tmq](https://github.com/cetra3/tmq), which uses ZeroMQ. Check the publish/subscribe example for doing sort of what you're after. There are a plethora of other ways to accomplish what you want though if that doesn't float your boat. 
Exactly! Analogous to: struct S { x: i32 } let S { x } = f(); except with a unit struct rather than a struct with named fields.
&gt; if we enforced that the procedural macro must be const fn That would significantly reduce the power of procedural macros. As examples, Pest uses procedural macros to read in its PEG format and generate Rust code. A hypothetical AWS library could read in the JSON service definition files from boto3 to make it easier to stay up-to-date. A protobuf library could read in .proto files and generate the necessary Rust code. There's a ton of areas in which existing non-Rust formats can be translated into Rust code at compile time that should be allowed. A sandbox somewhat akin to FreeBSD's jails would be a much better solution, IMHO.
What specifically do you mean by opnionated?
I'm not sure but I definitely feel like I've heard it before, albeit a long time ago, as in pre 1.0 long time ago. 
I want to associate each Pokemon with data like stats, typing, and movepool, and I wanted to use enums because they ensure compile-time correctness: this system is clumsy, but it's impossible to name a Pokemon that doesn't exist. 
I would like to help. How can I be most useful?
Can you achieve the same thing by defining some species type with the species data in a module, exporting constants for each species initialized with the right data, and _not_ exporting a constructor for that type? Then if you require a species argument to construct a Pokémon type you know it’s at least coming from one of your constants.
oh frig. So let S = f() was pattern matching, the moved value wasn't bound to anything and drops, and when the second S in the print statement came, that was a new instance of S. so 212 :\ I feel robbed but I understand now, thanks.
This is awesome, love the idea/design. I might try hacking around with this over the weekend :)
You get this by default with cargo if you don’t pass --release. [Some context](https://github.com/rust-lang/cargo/issues/439).
I wasn't thinking of audits so much as a vetting process for contributors. Collect verifiable information about their actual identities, require them to complete some training the way Debian does, maybe even make them show some evidence of sustained prior participation in the community before they upload their first crate. I'd rather trust people than code. It's easier and more satisfying.
Awesome thanks :) I have heard of ZeroMQ but never tried it before. Can I send a struct or array/vec of u8 bytes as they're available with that? The examples you have are a bit light for me with my inexperience at a glance, looks like you're sending a string? My data is about 32MB in size and I need to send about 60 of those ideally per second, about 2GB/s, for some users it'd be more than that. The actual network transfer is an internal network on the same system between VMs and/or host system. The bandwidth is a non-issue for the memory mapped file in shared memory, and I think that is also zero copy(some unsafe operations). I'm not sure if I can avoid making a copy to send over network? In some approaches I had tried like websockets, iirc I had to make a copy.
I realise you've stated that you want to specify the Pokémon as code because of compile time correctness, but my advice to you would be to define the Pokémon as data - be it in json, toml, XML, whatever, because IMO listing something like 800 types in source is a little...cumbersome. The thing with rust is that even though you haven't defined your types at compile time, it's very easy to ingest data that safely resolves to an `Option&lt;Pokemon&gt;`, which you can destructure and process. That being said, if you insist on storing them in data, I would go with what others have said and write a procedural macro to reduce the code repetition.
If one re-interprets `largest_power` as _largest exponent_, one could also write: let max_exp = (i as f32).log2() as u32; (0..=max_exp).rev().map(|exp| { … }) removing the `1 +` and using an inclusive range instead :D
Does buying the beta ebook entitle me to a discount or something on the final release as well?
If it was a single downvote, it might have been [Reddit's vote obfuscation/fuzzing](https://www.reddit.com/r/TheoryOfReddit/comments/10xoka/what_does_vote_fuzzing_do_anyways_all_it_seems_to/) at work. 
You can send bytes instead of a string, basically anything that can be converted into ZeroMQ message. The examples are just there to get you up and running fast. I use tmq to send CBOR across the wire. If you have a `Box&lt;[u8]&gt;` it can be sent as a message with zero copy by using [zmd-msg-init-data](http://api.zeromq.org/2-1:zmq-msg-init-data) https://github.com/cetra3/tmq/blob/master/rust-zmq/src/message.rs#L89 I would definitely benchmark it though :)
&gt; That's a lot to ask of unpaid volunteers! It's not necessarily the case that they be unpaid. Businesses who write applications in rust have a direct incentive to pay their staff or to allocate funds for third party auditors to execute these reviews. &gt; Every release will need to be checked by someone, It's not necessarily the case that *every* release be checked. Perhaps every popular/major feature release. Crates with greater popularity should draw more motivated reviewers and could afford better release audit coverage.
Is there a reason the tile server uses `warp`, but everything else uses `actix-web`?
I feel like the context switch from one window / program to another is what most people mean when they say its feels heavy, i hate that switch. In just a few key strokes i have access to my whole system with vim. I can ssh in to a server, open something in etc, you get the idea. Plus theres just something about vim proper that I just didn't feel when i used atom with a vim emulator. 
Not that I have enough time to help unfortunately but do I just submit a pull request to your issues or is there some other first step to get started?
Cool, didn't know that syntax. Thanks!
So then to debug your binary: cargo build rust-gdb target/debug/your-crate-or-binary-name
[peer_addr](https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.peer_addr) or [local_addr](https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.local_addr)?
They should ask the question before and after the quiz. 
If you think you know what to do, go ahead and submit PRs. If you want to chat first, join gitter channel and let's talk: https://gitter.im/dpc/crev !
That would be awesome!
Join gitter channel : https://gitter.im/dpc/crev and we can talk. Take a look at the code, see if you can figure out anything from that WIP.
Thank you. I am planing to start with a simple "distance based graph traversal", where trust levels define edge distance, but potentially any algorithm could be used/implemented behind a trait/plugin/etc.
I'd love to see a proper effect system some day. For example, allowing library code to do logging using the standard log facade, but no other side-effects would be a really useful thing to do.
I'm talking about the domain name 
It's quite disingenuous to classify this as "line noise". The density of strange code is higher than usual, of course, but the core element in most questions is something you might sometime come across during daily work.
I set mine to run using standard keybinding using a macros. &amp;#x200B;
As someone who would be interested in writing network (mostly web app) servers, the major reason I've been holding off is that I don't *need* Rust right now and I feel I'd be committing to significant future maintenance from the expected changes in the underlying primitives. Having regular breaking changes on nightly Rust is annoying but fine where switching from sync hyper/rocket or futures to async / await seems like a "rewrite everything" sort of transition even if it probably is mostly mechanical once you get going. I skimmed through the async / await blogpost a couple days ago and things looked more or less ready. Are we there yet?
&gt;Nothing is set in stone! Well, except for the APIs written with [https://github.com/dropbox/stone](https://github.com/dropbox/stone) ;) &gt;Please file an issue :-) Done, thanks.
Being fired for that is illegal *even* in the US
&gt; I feel like the context switch from one window / program to another is what most people mean when they say its feels heavy If it's not app specific, how does that make Atom or VSCode "Heavy"? Isn't vim used in a terminal window normally? Are you saying that these windows/programs to change to are all ones handled by vim or the terminal? &gt; In just a few key strokes i have access to my whole system with vim. I can ssh in to a server, open something in etc, you get the idea. Within Atom, you can ctrl+tab to cycle open file tabs, and I think ctrl+t or similar to bring up an embedded terminal, pretty sure most things you can do on vim can be done in Atom, I can't comment on latency of such, I'd still expect vim to do better there, but personally I've found Atom to be fine, except for when I used it on Windows and it's project search functionality(do a keyword search on all files in a project directory) would often hang Atom(I think that's been fixed now but it was an issue for years), on Linux it never happened, I think I might have run into some inode limit one time though, something to do with filewatchers. &gt; Plus theres just something about vim proper that I just didn't feel when i used atom with a vim emulator. I've never used vim... well I think I did once but it wasn't intuitive/friendly to someone who didn't know how to use/navigate with it, vs something more basic like nano which often got the job done when I needed to edit something quickly via CLI. I can understand/respect that some people like to use vim/emacs, a mouse might be slow/cumbersome for them, but I prefer it despite that :P
That's what I use. Though VScode is also really good. Atom is just so heavy
Cool thanks for the tips! :) I've noted it down to try when I work on the project in future.
Wrong subreddit. This wouldn't have happened if reddit was written in Rust 
&gt; Some people could even make a living out of it: you want package reviewed: here is my paypal/Bitcoin address, tell me which one and I will review it in a day. AaaaaaAAAAaaaaaaaaargh So now there is a financial incentive for a reviewer to blindly trust anything. That seems very dangerous. In fairness, this is how a lot of credit agencies work, but (a) credit agencies also need to fundamentally generate trust for themselves, whereas your system doesn't seem to include any measure for trusting/mistrusting certain reviewers, and (b) 2008 famously demonstrated that the credit agency system wasn't quite as helpful as it was cracked up to be. Tbh, I can't really see the benefit of this system. It means that an action that previously required one bad actor now requires two, but the second bad actor doesn't need to be actively malicious, they just need to be forgetful, greedy, lazy, or just having a bit of an exhausting day. From what I can tell, there's also no bar for becoming a reviewer, and so a malicious actor can just ask their friend Me But-With-A-Different-Email-Address to give them a hand, and they can already get some very positive trust feedback on their tool. It also wouldn't solve the problem in this case - the project was already a fairly trusted project, written by a well-known and popular maintainer who people widely regarded as writing good code. The problem was when project ownership was transferred, and someone else was put in charge of the code. Now it could be that you need to review every single release individually, but that makes releasing new code harder, because people will stay on the older version until the new one has sufficient trust, which is okay for larger projects, but for smaller projects is going to be a much slower process. I think it's good that people are thinking of ways to solve this problem, but I think this is fundamentally not a code problem. It's a human problem and it needs to be solved by human people, not by additional tools that are directed towards the code itself. We need to avoid situations where there are millions of packages that do tiny little things that are very useful, but not necessarily worth installing an entire package for - a healthy standard library is good for this. As a community, we need to focus on a smaller number of key packages for key tools. We need to recognise that ownership transfers will happen, but that they cause a break in trust - perhaps by treating them as automatic major version bumps.
Ahh the title says IP address. IP to domain will require you to a DNS lookup for a [PTR record](http://help.dnsmadeeasy.com/managed-dns/dns-record-types/pointer-ptr-record/). Although not all domains will have such a record so it won’t always resolve to a domain. 
I am definitely very interested in this. Being in Berlin is a bit of an issue, but hopefully my current employer will be interested enough to send me.
I think he wants domain to IP. This is a normal DNS and this will always give a result. In windows you can use nslookup to do this (please remember to put the root '.' (Dot) behind the fwdn as nslookup will append your domain name if you don't. On Linux/osx you should be able to query DNS servers via dig or host. If you want to get resolve a domain to an ip from within your rust program you can use the dns_lookup crate. On nightly I think there is also the ToSocketAddrs trait. If you want something deprecated I think std::net still does has the lookup_host function. 
The website says that purchasing the beta entitles you to all updates for this edition. Click on the little help popups near the buy button. 
Away from computer, but would `pet.0.speak()` properly work? That might address (1), but I'm not sure.
Ahh right yeah that makes sense. 
If you're an experience programmer, you'll probably have a better time learning Rust than dealing with all the quirks of C++. However, Rust is not a strong asset when looking for game industry jobs (compared to C++). I think an easy way to frame the decision is whether it's to help your resume or to have fun making engines.
This seems like a good idea, but I've never written a macro in Rust so I'll try and learn now :)
Thanks for the help! I've never done macros in Rust before, but I'll take this as my cue to learn!
no :(, pet.0 doesn't have a concrete type.
Thanks! Purchased.
I really would like to do it by myself to understand the workings of the things since this is a learning project for me not a prod one can you advise any resource or something to help me learn how to do the query 
Just purchased it, looks like it should be a good read.
[Question 19](https://dtolnay.github.io/rust-quiz/19) has caught me off-guard and I haven’t been able to resolve it in my mind. It demonstrates that with `let s = S; let _ = s; f();`, the S is dropped at the end of the block, rather than on the `let _ = s;` line. This flies against my understanding of the subtle distinction between `let _ =` and `let _foo =`, that the former dropped immediately while the latter created a binding that would last until the end of the scope. Experimentation shows that in `let _ = S; f();`, the S is dropped immediately, as expected. Yet in that first example, simply by having first bound the S to a name, the dropping power of `let _ =` is negated. What’s happening? *Is* this a bug? It’s certainly surprising to me, and I thought I *knew* all this stuff. (I’ve done 15 of them so far, some straight-up and some after the hint; a couple I failed to get without running it. I feel I don’t know Rust as well as I did three years ago!)
Fixing this does let it compile, but then it overflows the stack during execution. OP: For a clue as to why, add a few println! in to show you the value of i, mid, and j in each iteration.
The problem is idealy it would be both, I guess that's why it has been so difficult.
I am trying to learn a different paradigm. I also felt it was worth noting that a lot of the quake 3 engine is made of objects.
Question 7 has a bug - it accepts the incorrect answer as well...
Also, it does not compile - should use \`Enum::First\` and \`Enum::Second\`...
What you want to implement is a DNS client. There are probably some tutorials around, but I'm not sure it's a particularly useful thing to implement from scratch.
One thing is using "objects" and another applying object-oriented programming. In game engines (and any project, really, even in C), you use objects all the time. Now, taking OOP as far as you would in other languages, that is not something you are going to do often in gamedev. Do not confuse both!
&gt; women don't consider themselves underrepresented if you read the chart closely
Depends on the state, and also it doesn’t have to be the official reason. Trans people are way more likely to be homeless for a reason.
It would reduce power sure, but there are a lot of proc macros that could get by such as serde. I think const fn has a place and I think sandboxing has a place. You don't have to limit yourself to one size fits all. Pick the least privilege that still gets the individual macro to compile. 
Reinventing the wheel is a great way to learn how wheels work. If you actually need to *use* the wheel, you'll usually get a better one if you use somebody else's. As far as game engines go, the good "wheels" are in C++, not Rust.
Good question: Seems unlikely from context, but there's also Type Driven Development
http://bluejekyll.github.io/blog/rust/dns/2016/08/21/a-year-of-rust-and-dns.html This blogpost explains DNS and rust and implements it from scratch. 
I'm sure you mean “if users were written in Rust”.
Sorry, what I should say is that _rustc_ can't compile to Wasm. Obviously Rust code compiles to Wasm.
TDD is great, but for a server it can be a little tricky. Actix does provide tools for testing, and the [documentation](https://actix.rs/docs/testing/)'s got you covered.
First off. Go learn macro's just because they are very useful. Secondly. Don't use macro's for this, and don't use Enum's for this. I'm not sure what your goal is but i'm 99% sure you're overvaluing the compile-time correctness. Sure if you write a function fn bulbasaur_attack() { Pokemon::Bulbasor .... } you would get a compile time notification. But it's much more likely you will want to use a 'thing that is a Pokemon', compared to ' Pokemon::Bulbasor '. And if you do, you will need to write functions for every specific Pokemon. 
&gt; I skimmed through the async / await blogpost a couple days ago and things looked more or less ready. Are we there yet? https://old.reddit.com/r/rust/comments/9riuyr/experiment_with_async_await_in_actix_web/ Btw, if you go with actix-web you won't have to rewrite much, and you can make your server fully async when diesel gets async support..
Yes, but I recommend using the 0.5 version from the git master. Another interesting frontend framework is [ruukh](https://www.reddit.com/r/rust/comments/9l0xho/introducing_ruukh_framework/) but Yew is more mature right now, if you need to build a frontend right now. But if you look at the Github history, the progress has slowed down over the past months and there are still issues that prevent me from recommending it for use in production..
For several reasons (especially location of silicon vendors), I would love to see an embedded conf in SE Asia or close, but Berlin is where I'm based at and that makes organisation significantly easier. But hey, we still need a RustConf in Australia/New Zealand. Any takers?
Yep. Just pick \*something\* and start reading the books and writing code. Learning the language is the easy part. Getting actually good at it is the hard part.
I was half thinking of going to Europe next year so this is a good excuse. I am quite happy to help set something (RustConf Aus) up as 'on the ground support'. Starting something from completely nothing is a bit out of my league though.
I could see it potentially alerting you of a change in ownership. If `worn_out@example.com` is trusted, but then transfers ownership and the crate is now signed by `new_account@malicious.ru`, `cargo` could prompt you to verify trust of the new signer. At least, I think that's what they're saying?
Assuming the name is derived from "Präzision" ("precision" in German), take the word "precision", cut off before the "s", then use a German-sounding R, stretch the "e" longer, and replace the "c" with a "ts".
I don't like this often repeated expression. Nothing we have ever coded in the past 60 or so years in all of programming is as universal or fundamental a concept as The Wheel. Everything we use now will one day be replaced, whereas the wheel will not go away. Those eventual replacements will not come from people who say, "Dont reinvent the wheel." Aside from that, there are many kinds of wheels. The wheels we need for our new cars are not the same as the ones "invented" for carriages. Imagine someone telling Henry Ford, "Dont reinvent the wheel. Just take some from that wooden carriage over there and slap it on a car." It's a terrible analogy in many ways.
Unless this is what they read when making the decision ... 
Now is the time to learn Rust. Those jobs will come pretty soon and there will not be that many experienced developers yet. Historically, game engines aggressively adopt anything that brings clear benefits (like embedding lua in game engines, implementing cutting edge stuff like Vulkan). C++ definitely is a big burden for game engine development currently and Rust addresses a lot of that pain. Especially now that vulkan is happening, new game engines should no longer be bottlenecked on a single thread like they mostly are today. Doing concurrency in C++ is notoriously hard and Rust fixes that. And there are already some Vulkan bindings for Rust. So, not a strange way to spend your time trying to do that at least.
The events team is there for help :). But yes, you shouldn't be alone, but maybe some other Rust people in Australia would like to help out? I also have good ties and some credit at RubyConf AU, so I can make sure that there's some experience to tap into.
Your type family example is wrong in Haskell. It should be: ``` class Hello a where type Return a helloWorld :: a -&gt; Return a ``` Or, preferred, `type Return a :: *`.
C++. superior handling of vector maths, smoother interaction with graphics libraries. the rust community doesn't really care about gamedev issues - it's a secondary concern. If you want to leap form C++, wait for JAI or the development of another language centred on the tradeoffs for the gamedev use-case.
&gt; Given that an iterator over a vector of results should be an iterator over results, [...] Except it *isn't*. When things don't work how you think they should, you need to check your assumptions. [`Vec::&lt;T&gt;::iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter) is (via [`Deref&lt;Target=[T]&gt;`](https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods)) actually [`&lt;[T]&gt;::iter`](https://doc.rust-lang.org/std/primitive.slice.html#method.iter), which returns [`Iter&lt;'a, T&gt;`](https://doc.rust-lang.org/std/slice/struct.Iter.html), which [implements `Iterator&lt;Item=&amp;'a T&gt;`](https://doc.rust-lang.org/std/slice/struct.Iter.html#impl-Iterator), **not** `Iterator&lt;Item=T&gt;`. It's an iterator of `&amp;Result&lt;f64, Box&lt;Error&gt;&gt;`.
It's a bit shame that `let foo = bar` is parsed differently depending on whether there's a type `foo` in scope or not. Of course, if you follow the proper naming convention this is never a problem, but still.
&gt; The community is sometime too proud to be close to the bare metal I read this as "it would hurt our pride to be close to the bare metal and therefore we aren't", which I think is the opposite of what you mean. "too proud of being close to the bare metal" is probably what you meant.
The Quake 3 engine was the first time id Software programmed in C++. It is not a good example of how to use the language. Don’t get me wrong, C++ *is* a pretty bad language, but if you’re learning from badly designed code, it will be even worse.
You should motivate this assertion.
&gt; "There is also users talking about the lack of a One True Framework a la Django in Python and Rails in ruby" This is anecdotal evidence provided by a handful of comments on social media by the kind of programmers who seek community confirmation of a web framework prior to adopting one. The survey shows that Rocket and Actix-Web are viable options for those who actually want a framework but lo and behold-- maybe don't even need them! This seems consistent with my understanding of those who use Rust: experienced programmers.
Great response - in fact "reinventing the wheel" in Rust might be extremely effective due to the nature of the bugs that it solves. And what a learning experience it'd be too! That is a truly exciting space to explore IMO.
All these really old routines give the operator immense power. Before the Internet there was no malicious software, and back in main-frame days the only users were the software engineers. Is there any point in using this power to re-define 'cd' to shut down the computer or 'ls' erase all files? (I hope I am not giving malicious software writers ideas, but I think they can think this sort of thing up for themselves.) The 'make' in Vim means 'make'. (I am not sure if it implements it itself or calls the shell, probably the latter.) Redefining it in Vim would be used to implement the odd tweak to adapt it to the situation, but if anybody makes it do anything significantly different, I would suggest they are starting to play the above stupid confusing game. Why not just invent a new appropriate command name for the new methodology? (pun above unintended.) On the corollary, to create a makefile to use cargo is no more difficult than making it use anything else. As I have indicated, I imagine a great number of modern IDE's use 'make' with a 'makefile' to implement Cargo this way. All the old Unix had to be ported into Linux and adapted for the x86 architecture. I almost resent not calling Linux 'Gnu-Linux' as it at one time was. It is the Gnu bit users are up against face to face, not the kernel, whatever the distribution. The fuss about gmake and accusation of it being a superset of 'make' I do not understand. I honestly think in practice, 'make' in main frame days was not as well defined as it could have been, because it was so implementation dependent. There was then several efforts to port 'make' from wherever into x86 architecture. It now seems to me 'make' is whatever you have in your computer, and if you wish to be more specific about esoteric features, you specify by preceding it with indicative letters, but sill call it as 'make'. If you are not into esoteric features, there is simply no difference between the lot of them. As far as I am concerned, make is still the same old make as existed in the 70's Unix. It's just not possible for an age old piece of software to survive this long without the implementation being tweaked - that's life. I honestly think most 'makes' around, in both Windows (if implemented) and Linux, are in fact gmake or gmake ported. Obviously I stand to be corrected on a lot of this paragraph. Where am I leading to? You have probably guessed what is in my brain. I know nothing about what you have there or how it came to be like that. Yet I ask you, if you did not write it yourself, are you 100% sure you have not picked up a cargo implementing makefile from somewhere and have it there lurking in the shadows? (Hiding in plain view?) This would suggest that, despite the target being modern, you are using your trusty but age old Unix derived Editor to tackle an age old problem the way one would expect: The conventional, age old, but highly trusted and widely used Unix way:- 'make' running through its 'makefile'. &amp;#x200B;
&gt; I want to default to object orientated methods What objected oriented idea specifically do you feel C++ does not accommodate? &gt;Also I really hate split implementation Don't do it then. You don't have to. High level advice: Don't worry so much about learning a language, learn programming. If C++ is presenting large difficulties in solving problems because you have some limited idea of how to solve problems in particular OOP ways, you have lots more you can learn about programming! People wrote Quake without any OOP at all, and many game dev studios avoid OOP-ish ideas for performance reasons, Rust doesn't have normal OOP. In the short term, learning C++ or C# will be the most useful for getting game development jobs in the industry. In the long term, who knows. For making your own games, pick any language you like where the performance ceiling is high enough to implement your ideas. 
how exactly is [] cleaner than &lt;&gt;
Yeah, I guess python has the advantage of not having to worry about memory management or static typing, so it's a bit easier to be productive in that sense. I can kind of see that. But I'm not sure I agree even with that new criteria. It only took me about a week to be able to bang out basic stuff in Rust. Maybe it had a bit more cloning in it than is ideal, but that's not too much of a problem for early code, and I hear that defensive cloning is quite common in C++ anyway.
Ready At Dawn and Chucklefish might disagree. Riot use it for some services and there is already a community engine that targets all the usual platforms - so we might see quite the uptick in indie circles. I agree - it won't happen tomorrow - but there are literally a couple of companies who are using it precicesly because it IS an improvement for them. So we'll have to wait and see...
Huh? It doesn't work like that. If a user that is considering using a library doesn't trust the malicious reviewer Me-But-With-A-Different-Email-Address, a positive review from that malicious actor is not going to cause the library to be falsely trusted. That's the point of web of trust: it isn't like some centeralized restaurant review website where every review counts towards a single score. It's _you_ who decide whom to trust and how much. Let's say that I decide to trust Alex Crichton, David Tolnay and Andrew Gallant because they are well known community members and known for their discretion and high-quality code. That doesn't mean that some random review by ShadyGuy69 would move my level of trust towards some piece of code an inch.
I just saw this presentation that probably is very interesting for you: [https://www.youtube.com/watch?v=UfMOOxOGCmA&amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;index=15&amp;t=0s](https://www.youtube.com/watch?v=UfMOOxOGCmA&amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;index=15&amp;t=0s) &amp;#x200B; I think the core of it is this trait: [https://github.com/fuchsia-mirror/garnet/blob/master/public/rust/zerocopy/src/lib.rs#L54](https://github.com/fuchsia-mirror/garnet/blob/master/public/rust/zerocopy/src/lib.rs#L54)
for those who don't use diesel and instead use parameterized sql, there is already a viable tokio-postgres solution
and when I point this situation out, the answer I keep getting is "it's a systems language", an answer I got from some of the amethyst people was 'we'll have scripting support' .. the point is for gamedev the opportunity is to make a language that's less ugly than C++ whilst retaining it's performance (e.g. no header files , syntactic tweaks around use of , []). The thing with gamedev is you start out 'all the way up' thinking about behaviour/presentation issues, but need to be able to drill all the way down to low level caching issues etc. It's got a unique blend of demands When I originally discovered rust , it was actually better , with it's sigils, which let you use the modern C++ style with less visual bloat.. it was much easier to read, and concentrate on what you are *doing*. Jonathan blow explains it right - the heavy angle bracket nesting messes with your head when you're reading things, it prioritises things backwards.. you spend more time logically parsing. the sigils blended in allowing intuiting 'muscle-memory' to function.
Rust, WASM, HTML5 canvas, profit! Perfect for hobbyist as there are no actual mature tools yet (as far as I'm aware). But if you want to have more employment chance, go for C++. 
At the cost of tricky parsing around array literals and subscripts.
you still had to decide whether to use URL Dispatch or Traversal! :)
They talked about Haskell without mentioning any of the common abstractions from its standard library? No wonder they make the two languages seem so comparable in expressiveness...
I don't think being verbose is an issue for any kind of developments. The time you lose on typing is sooo much less than the one you win because the compiler forces you to think properly of your data lifecycle. Of course less verbose is better but I consider nll, for example, a much higher priority.
Any reason why not using Spark or Flink for your MapReduce-style workflows? Efflux improves your productivity but this is still quite low level APIs.
&gt; No, not there. Q1 2019 seems possible. Is that the rough time frame for async/await on stable? We're probably close enough for me to start since I don't mind feature flagged nightly during active development.
I'd like to see an algorithm like this: I can decide to trust person A at trust level 0.6 and person B at trust level 0.8. Person A trusts person C at trust level 0.5 which means that I transitively trust that person at trust level 0.6 * 0.5 = 0.3. Then the code reviews by those people are weighted using the transitive trust level.
\[\] for array and slices, &lt;&gt; for type. Break one rule, tons of inconsistencies waiting ahead. End of discussion. As for snake\_case, I agree. It feels more natural to me.
You don't knew what you're talking about
Yes that is the rough time frame, but those in a position of authority appear unwilling to publicly acknowledge it so I suspect that there are some pretty substantial challenges that remain. Two weeks ago, I asked about the status of async/await: https://www.reddit.com/r/rust/comments/9wrtgs/asyncawait_status_and_tracking/ I don't know what kind of asyncio work you want to do so cannot tell you whether to postpone or dive in immediately. Using futures 1.0 design isn't necessarily throw-away work but anything that can be addressed by async/await ought to be, avoiding futures by all means necessary.
I believe there's some misunderstanding on how this all works. /u/GolDDranks [already replied to that](https://www.reddit.com/r/rust/comments/a1a0t9/if_you_want_to_prevent_package_hijacking_come/eapnvyp/) &gt; It means that an action that previously required one bad actor now requires two Or three, or four. Graph algorithm might require N independent paths of trust. Obviously the higher the N, the less chance there will be enough reviews, but if you're paranoid then why not. &gt; but that makes releasing new code harder, because people will stay on the older version until the new one has sufficient trust, And that's exactly the right thing to happen! There isn't any fundamental reason for everyone to jump blindly to new, unreviewed releases! &gt; (...) but I think this is fundamentally not a code problem. It's a human problem and it needs to be solved by human people, not by additional tools that are directed towards the code itself. Humans need tools to allow them to change their behavior, and organize in social settings. &gt; We need to avoid situations where there are millions of packages that do tiny little things that are very useful, I believe this is just wishful thinking. Even when limiting ourselves there will always be more packages that one user can potentially review. And software is getting more and more complex. To compete, we need to share and reuse. The trend is for people to move from languages like C++ to ecosystems like Node or Rust, that allow getting end product done 10x faster, by having read-made, tested solutions on all levels of granularity. It's a strength and great thing! We just need to give people an ability to gain some level of trust in what they are using, without loosing that benefit.
Neovim is your friend!
There is a huge amount to be said for familiarity with certain customs in language design when it comes to adoption by newcomers. When it comes down to things like bikeshedding over subjective cleanness of generic syntax, it makes complete sense to choose the familiar &lt;&gt; over something else - Rust is already a complicated language to learn, with unique features and syntax, so why introduce idiosyncratic syntax for something so widely recognised?
Looking at today's hardware, there are basically a lot of under utilized cpu cores when running games on high end hardware because threading is so hard in C++. With Intel and AMD now providing 24 or more cores on their high end chips, properly utilizing them is becoming an issue. Looking at Mozilla they seem to be getting really impressive results transforming essentially single threaded C++ into nicely concurrent and safe Rust. So, how would that not be not an improvement for game developers? It's not like utilizing multiple cores is particularly easy for them using C++. I'm all for new languages solving the same issues but Rust is here right now. 
I plan on `trust` to be one of `none`, `some`, `much` and `full`, IIRC. Too granular is making it too meaningless IMO. End user should be able to configure which level maps to what "values". Also, `cargo trust` just producing and circulates these signed artifacts. Anyone is able to do anything with them. In the future, there can be many different algorithms (or even standalone tools!), and it should be easy to implement any algorithm by yourself (it will be trait implementation or something).
Fair point!
It's not like Yelp or something though. I see where you're coming from but that does not appear to be how the whole thing works.
&gt; Unfortunately, Tide doesn't address these problems but instead adds to it: &gt; https://xkcd.com/927/ Sorry to be blunt, but XKCD 927 is the laziest comment one can make on these things.
Tttttt5tt////===/==/÷/////////////////////////=%+$-_= s jji£#//////
Yeah. Scala doesn’t have `[]` array literals and uses `()` for subscription (arrays and vectors implement the relevant`Function` trait which is pretty convenient).
I find that an odd decision, but well... In any case, it's a sailed boat, I'm not that interested in rehashing that discussion all the time :).
I'll agree with you on the syntax front. (That the need to unlearn is what makes Haskell syntax difficult compared to Rust.) However, as someone who is still primarily a Python programmer (but who has used QBasic, Visual Basic, Perl, Python, Bash, JavaScript, Lua, CoffeeScript, a sprinkling of C, C++, and Java, and a few DOS/BIOS ABI call stubs in inline x86 assembly... and probably some things I'm forgetting), I have to say that it's not the syntax or finding *a* way to implement the problem that turned me off Haskell... it's the inherent disconnect the functional paradigm represents between the theoretical model and the execution model. I've worked hard to avoid projects which would require me learning how to micro-optimize performance under a specific garbage collector and programming in a functional language feels like the entire language is like that. With Rust, the theoretical model is much closer to the execution model, so I can start to move beyond I/O-bound projects while generally treating the optimizers are pleasant surprises that may go away, rather than essential to trigger to achieve satisfactory performance. (ie. spending minimal time worrying about triggering a pathological case in the optimizers that "everybody just knows" and I don't have to fear about regressions because I was unknowingly depending on something the optimizer developers felt was a mere "implementation detail".) I'm reminded of Matt Pharr quoting Tim Foley in his series of blog posts on [the origins of ispc](https://pharr.org/matt/blog/2018/04/18/ispc-origins.html): "Auto-vectorization is not a programming model"
what about a language that transpiles to rust? that way, core rust doesn't get bloated by too many alternate ways to do things, and it can look like haskell with the performance of rust.
I think the reason is that &lt; and &gt; are also used for "less than" and "greater than" (where they don't need to be balanced) which can make parsing more difficult.
I thought it was something about research that had been completed by the 90’s
Sure. Rust is Rust. No intention to argue for changing the language in that respect. But I do find discussions of how different languages arrived at different solutions quite enlightening. Making collections functions (technically, `PartialFunction`s) does make sense mathematically and allows for more generic code, so with Scala being a fairly... academically-oriented language I presume it was a very natural decision. 
&gt; I've been here for 5 years. I've learned the hard way, this community/core team does not prioritise this use case. For the simple reason that we cannot focus on all use cases all the time. That doesn't mean that we ignore it or not encourage it. Quite differently, we try to keep open active communication with projects and things like Amethyst are doing great!
Why does Rust generate giant binaries?I have a simple program, a couple of source files, and the release binary is almost 6MB in size.
Thanks ma man
Thanks for the share! Can't wait to give it a read 
What I'm suggesting is that given a proc macro macro crate (A) and a crate (A) that uses it, then (A) should decide how much privilege to afford (B) both in terms of what code the macro itself is made up of (static analysis: e.g. restricting the macro to be a `const fn` and dynamic analysis : sandboxing &amp; panicing if the macro does iffy things) as well as what things the macro expands to. That way, (A) can check that `proptest_derive` does not need extra privileges and removes them. If `proptest_derive` suddenly wants more capabilities, it won't get them and we'll have compile time errors. Security is about layers after all; a single point of failure isn't good; it's better to have defense in depth.
&gt; Meaning, do you have tools or shortcuts for navigating code, or do you just expand types in your mind's eye? Go to the docs for the `iter` method. Click the "ⓘ" next to it. That, or click the return type and scroll down to the `Iterator` section.
[`Vec::iter`](https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#method.iter) is now shown in Rustdoc (Methods from `Deref&lt;Target = [T]&gt;`), though this wasn't the case a few releases ago, so that shortens the steps. In fact, as of a few releases ago, there's an (i) card on that method, which when clicked, shows you &gt; Important traits for Iter&lt;'a, T&gt; &gt; &gt; `impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; type Item = &amp;'a T;`
Also note that Yew uses stdweb, instead of the Rust-team-backed wasm-bindgen
You will likely find yourself to be a better C++ programmer after learning Rust. I'd recommend you start there. Full disclaimer: I'm on the board of directors for The Amethyst game engine foundation and I'm always looking for more people interested in using Rust for game development as it helps our engine grow.
It's statically linking all the libraries you're using (and, depending on platform and settings, a custom memory allocator). I've got a project with a few hundred thousand lines of code (plus many libraries), and that's only 6.7MB. It's not something to be worried about.
I'm learning game engine development in Rust. Probably a waste of time. But it's fun. I almost got tetris fully working. I think I'm more interested in indie development anyway. Not working for a game company. 
I use i3wm with vscode+rls. I have also tried vim+racer and vscode+racer back before rls existed. RLS is a superior experience IMO. Anyway, using something like i3 removes the context switch delay you're talking about.
Yes
&gt; I've worked hard to avoid projects which would require me learning how to micro-optimize performance under a specific garbage collector and programming in a functional language feels like the entire language is like that. I've *never* had to do this in Haskell... Maybe we were writing very different sorts of programs? ;) &gt; With Rust, the theoretical model is much closer to the execution model, Rust is still quite some ways from the actual assembly; even LLVM is comparatively a high level abstract machine. But I hear what you are saying; Haskell has two primary things which makes it more detached from the actual hardware executing things: Laziness and Garbage collection. Laziness affords you a greater degree of modularity since you can separate consumers and producers and thus we can write more maintainable programs. However, laziness is also makes for unpredictable timing and space usage, but many applications (most) don't care about that at all. Thus, I think the right default for a non-systems programming language like Haskell is laziness since there's otherwise an overuse of strictness. Here's a discussion on the benefits of laziness: https://www.reddit.com/r/haskell/comments/5xge0v/today_i_used_laziness_for/ Garbage collection affords you to have generic lambdas such as `a -&gt; b` as a term in your language, you don't need to separate things into Box, Rc, Arc, etc. the language takes care of that for you. Garbage collection also permits you to prototype your domain logic to code more quickly. Don't underestimate the value this has. GC also makes type systems much easier to design in the parts where they have to interact with the dynamic semantics. For example, you have an easier time to preserve parametricity which is a valuable reasoning property to have for modular programs. However, Haskell is currently in the process of adding linear types with which it can better interface with Rust and with which you can have more predictable performance (space-time) and make GC optional in parts of your program. In closing I think there's a place in the world for a strict language with manual memory management and a strong type system like Rust and I think there's also a place for a lazy GCed pure functional programming language like Haskell. They both have relatively clean design, rich type systems and are also closely related historically (and wrt. language design happening right now).
True
By that logic though we wouldn't need rust if C programmers just did due diligence. 
I think this is why some gamedev-focused people are interested in [nim](https://nim-lang.org/).
It's probably not an actual description of reality anymore since I haven't heard any fellow language team member say it and we have integrated research done in 2007 into the language. :) That said, we certainly aren't looking to integrate Homotopy Type Theory into Rust. ^.^
There is this crate which allows subtyping using delegation instead of inheritance: https://crates.io/crates/delegate
definitely C++. Rust is a very nice language, but it adds a different type of complexity that can be hard for new programmers. C++ game engines have been around for a long time and have been tried and tested. Most of the rust game engines aren't mature enough, and they use C bindings anyway from what I understand. also I don't see what issues you're having with objects in c++... c++ is very much a OOP language
See my last paragraph. I said that we need some kind of auditing+escape for unsafe and C
&gt;A lot cleaner and faster I'd disagree with cleaner. Likely longer, though. And faster? Possibly, but that just depends on the skill of the developers mostly. &gt;I'd consider lack of sub types/inheritance a feature, not a bug. Been arguing against that in Java for ages. Again, Java is not C++, and the way inheritance is used in Java is not the same as it's used (particularly for game dev) in C++. The idea that all inheritance is the sort of thing found in LargeBusinessCompany's Java EE codebase is not reality. &gt;And Rust does have traits, which is arguably more powerful than abusing inheritance hierarchies to reuse functionality. Surely you can't be arguing against code-reuse here? It's one of the more noticeably helpful use-cases for single inheritance: you can have *one* tangible base class, and any number of classes descended from it, all of which directly retain the concrete functionality of the base class while also doing something more specific on top of it.
Why are you making an object-oriented game engine instead of an ECS game engine? https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system
You will have to know C++ to do any game dev right now, every example you come across will be C/C++ and every API we use is in C/C++. Even if you only learn it to be able to write rust wrappers for them although it's quite likely that this has been done for most of the common things already. By the time you are good enough at Rust to do something impressive there will be Rust jobs in the game industry. Every company I know of is interested in Rust but is just dealing with a legacy C/C++ code base with the learning hurdles of Rust being the primary barrier.
Edward Kmett talks more about laziness, Haskell, and performance here: https://www.quora.com/When-did-you-realize-the-power-of-lazy-evaluation-in-terms-of-performance
Autocompletion works almost never for me in VSCode. Hovering over variables to see their type and squiggly lines work reliably though. I thought this was a problem with RLS, but if you say it works in Atom!?
Yes, those are all great ideas. I'm just focusing on number 4 because you could prevent this kind of thing at compile time. If you could assert that 90 percent of the crates (and their dependencies) didn't use file IO (except a few dependencies that you trust and whitelist, because of unsafe/ffi) then the job of auditing permission changes becomes a lot easier.
Could you elaborate on what exactly is so important about subtyping? You've written a whole comment condemning Rust as a productive game development language based on its lack of subtyping as if it were self-explanatory but it's far from it. “Not great, unfortunately.” Why? I'm not really sure why you're bringing up the diamond problem, either. When people discuss inheritance vs composition, they are referring to single inheritance as well. All inheritance is problematic.
RLS uses racer internally
Attributes could be assigned to stdlib functions stating that they need permissions. Then you could specify that crates can't do certain things. Besides unsafe/ffi, it's actually quite easy to enforce.
&gt; I've never had to do this in Haskell... Maybe we were writing very different sorts of programs? ;) I was just using it as an example of a real-world example of people relying on internal implementation details of specific VMs that's considered acceptable and normal in some circles. If I'm going to depend on internal implementation details, I want it to be things that I can just apply as rules-of-thumb, regardless of language or architecture, without having to put too much thought into them, then come back to with a source profiler if it becomes relevant. Stuff like: 1. Not doing things the branch predictor will obviously struggle with. 2. Keeping the nature of the CPU's cache hierarchy in mind 3. Not using power-of-2 strides, to avoid tripping over cache-line aliasing.
As a game dev, I don't think that lack of inheritance is more of a feature than an issue. Data Oriented Design is the new hotness as there are massive speed gains from this as well as a natural affinity for unit tests. Unreal is a representation of design of engines from it's time period, when OOP problems were not well known yet. So Rust's ability to be used in a DoD friendly manner is going to be more of a dictating factor. 
It doesn't exist in Java as a direct result of class inheritance, but in certainly does as a result of class inheritance mixed with the implementation of multiple interfaces.
i agree 100%
This just sounds like "*[buzzword feature]* for *[speculative future engine]* is better than what current still-most-widely-used-engine-in-existence does, for *[reasons I have not listed]*" to me.
&gt; Can you give an example of an application where running destructors is important even for abnormal termination with unknown cause? Wrapping `catch_unwind` around the unit-of-work code in a long-running daemon so that a single Error 500 (or equivalent) doesn't bring the whole thing down? Without destructors running on unwind, you'd geta memory leak from that.
So, no? You can't elaborate?
Who are you arguing with? At no point was the expression you hate implied. If we assume that OP is more interested in understanding game engines than making a game, then "reinventing the wheel is a great way to learn how wheels work". But in case we don't understand OP's real desires, more information was given. &gt; you'll **usually** get a better one if you use somebody else's. And this covers what you're saying about Rust. 99% of people who have a problem with C++ should not make their own programming language, but that doesn't mean that no one should. The people who made Rust *should* be asked why they think a new language is needed, and they should have a good answer. 
It depends on what your primary use case is. For many parts of an application I think making such costs explicit would lead to significant noise and an underuse of laziness. Haskell does have opt-in strictness so you can use that where needed. I also like the social consequence of laziness in that it sort of forces languages to also be pure which is arguably more important than what evaluation strategy you use.
I'm not quite sure what you're saying. There's no reason I can't do impl Species { fn attack(self, foo: bar) -&gt; baz { } } right? The advantage of having enums work this way, which I think is pretty important, is that it makes writing robust code significantly easier. (As a bonus, I think it might also reduce memory usage, because you don't necessarily need to pass anything besides the enum itself instead of associated stats, movepool, typing, etc.) If there's a struct `Species` that has 800-odd implementations, but could theoretically have many more, it means that it's really hard to even know whether the output of something like converting from a string is successful. If you expect `Species::from_str("Kyurem-White")`to work, that requires having `Species` be something that doesn't itself carry very much data: it's not like mutating Kyurem-White's stats is something you're going to do every day. I think with a struct you still have to enumerate each Pokemon one-by-one, which to be honest seems to remove the main benefit of that over an enum. If you already have to list every possible incarnation of something, why not make that guarantee explicit?
&gt;I wanted to jump of to a compiled language Java is a compiled language! That being said, I suppose I know what you mean - a native language without a VM, right? As many others have said, given your constraints, C++ is still the best bet. 
I'm curious in what way C++ handles vector types better
Then who does the auditing?
People like Mike Acton have long been against OOP and for DoD. Since joining Unity, he's been pushing for more DoD features and away from OOP. https://www.youtube.com/watch?v=p65Yt20pw0g https://www.youtube.com/watch?v=92KFSD3ObrY If you're interested in some of his talks.
Not a response to your question, but in addition to Scons, I'd also learn CMake. Not sure what build systems the gaming industry uses these days, but I see a lot of CMake in the open source world, and it gets the job done.
[See above. Specifically the last part.](https://www.reddit.com/r/rust/comments/a1ffb4/should_i_learn_c_or_rust_for_game_engine/eapw7u1/)
The reason for snake case, by the way, is simply that Python (PEP 8) uses it and everyone seems to like Python. At least that was the argument I put forth when I argued for it years ago.
Depending on what you define as "pure", that might be our point of disagreement. For some uses of the term "pure", I consider it to be a point against the language. (eg. As I see it, going from multi-paradigm with strong support for functional coding styles to pure functional is sub-optimal because that last step is the "20% of the work that takes 80% of the effort".)
&gt; The thing with gamedev is you start out 'all the way up' thinking about behaviour/presentation issues, but need to be able to drill all the way down to low level caching issues etc. It's got a unique blend of demands Sounds like any modern programming job I worked at, TBH. It's also the experience I have with most gamedevs I talk to (and I talk to a lot): gaming makes itself more special then it is.
Using `[]` would be cleaner for matching types in `macro_rules!` macro. `&gt;&gt;` is tokenised as a single token, so you have to write things like `Option&lt;Vec&lt;i32&gt; &gt;` so that a macro can correctly match on it.
I would really make this dependent on your goals. Want to switch to game development soon? Learn C++ and start coding in one of the current engines (Unity, UE, you name it). C++ isn't the most beautiful language and has aged, but it is the current standard. You will probably substantially work in C++ or even C# if you find a job next month. Don't get distracted by shiny things. If your goal is _learning language with teasing new concepts_ and your current interest is fiddling around with games, learn Rust. You'll learn a lot of the lingo of the gaming space and will learn how games are created. You can still map that to C++ later, should you be serious about it. On the chance that Rust in the space makes a notable dent, you will suddenly be one of the few that know Rust and game development.
Unity and CryEngine/Lumberjack use ECS I believe, at least the recent versions.
&gt; 2 out of... You mentioned JAI above. How many companies are using JAI?
&gt;Is that the rough time frame for async/await on stable? /u/aturon said in one of the tracking issues recently that he hopes to move to fcp within the next couple of releases. master is 1.32, and so that would make it be somewhere roughly in the, let's guess, 1.34-1.36 timeframe? that would be * 1.34: April 11 * 1.35: May 23 * 1.36: July 4 As always, this is just a guess, etc.
&gt; I suspect that there are some pretty substantial challenges that remain, which makes them cautious about communicating timelines. It's just always that even if you say something is a guess, people still think you're making a promise. The whole point of us doing time-based releases is so that we don't have to try and jam a feature into a particular release. That means, it's almost always best to not publicly speculate; there's little upside and a lot of downside.
&gt; Are programmers really not adopting Rust because it doesn't have a Django? I doubt that. For web dev, at least, yes, some are. People like having a default choice; it's safe. That is, if you don't know much, you rely on others' good judgement to help you decide. Having a "if you don't know what to use, use this" is really helpful when you don't know how to decide for yourself.
If you want to do it as a living, then learn C++. A lot of people in the industry are interested in Rust. There are studios switching to Rust. C++ is still universally king in the games industry. I would also imagine it would be easier for a C++ developer to get a job at a Rust shop, than the other way around. That aside; it all depends on what you want to do. There is a tonne of C++ resources out there which is a huge benefit from that regard. There is a growing body of Rust too, but we are still figuring things out. Rust is still treading new ground. If you want to write things from scratch then I'd definitely advise Rust over C++.
\&gt; rust is supposed to break from past baggage. &amp;#x200B; You can't do that in all cases, you only have a limited amount of these kinds of things: [https://words.steveklabnik.com/the-language-strangeness-budget](https://words.steveklabnik.com/the-language-strangeness-budget)
This is still quite subjective. I've used both, I still strongly prefer \`&lt;&gt;\`s over \`\[\]\`s.
Yes, rustc is written in rust. You can find the repo [here](https://github.com/rust-lang/rust/). The previous version of the compiler builds the next version of the compiler. The first version was written in ocaml AFAIK.
IIRC the original compiler was written in OCaml, very pre-1.0. Eventually it got to a point where rustc written in Rust, could be compiled by the original OCaml compiler, and boom: bootstrapped. Ever since then new versions of rustc have been compiled by the previous versions of rustc. New features have to be initially implemented in a way that can't actually use those features.
Yes, rustc is written rust. First versions of rustc (before 1.0) were written in OCaml, and then rewritten in rust itself. You can read about current way rustc is compiled [here](https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html#running-xpy-and-building-a-stage1-compiler).
This is actually fairly common for compilers -- GCC is written in C, clang is C++, GHC (the haskell compiler) is written in haskell, etc.
The problem in this case (which may or may not pertain to Rust/Cargo) is that the malicious code was added to the build-artifact, and was not in the source code (it was not in the Git repo).
My main point is that side-effects should be explicitly marked because they make programs hard to reason about otherwise; Making the effects explicit also gives you nice polymorphism abilities which can actually improve ergonomics with automation (see languages with effect polymorphism like Frank, Koka, ... as well as monads and transformers in Haskell). As for the definition of "pure" I'm not all that rigid; there are multiple definitions that make sense; for example, Haskell has [Debug.Trace](http://hackage.haskell.org/package/base-4.12.0.0/docs/Debug-Trace.html#v:trace) which isn't exactly pure in some definition but is benign and useful. In the context of Rust, I would be OK with `&amp;mut` types in `const fn` since that is also explicitly marked with types so there are no surprises lying in wait. I've never felt that enforcing control of effects in the type system like Haskell does takes 80% of the effort; in fact, Haskell has been called one of the [world's finest imperative languages](https://stackoverflow.com/questions/6622524/why-is-haskell-sometimes-referred-to-as-best-imperative-language); there's even a term ["imperative functional programming"](https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf). Purity has a lot of benefits; it makes reasoning about parallelism that much easier (and allows GHC to do amazing things wrt. parallelism); It bends code towards being testable (which is sorely needed).
Subtyping seems to be only used in C++ because there's no other way to get dynamic dispatch. Rust has dynamic dispatch, so I'm not sure what the real problem here is. FWIW I work on one of the largest franchises in the game industry and our engine only uses subtyping sparsely and always for getting around some C++ limitation.
So you're not chaining jobs, when you need multiple map phases? But ok, makes sense if you are productive with it and don't have performance issues :)
It seems to rhyme with Etsy. https://www.youtube.com/watch?v=OgxtLl6btIw
I've been thinking about replacing some game systems I got with Rust (from C++). What do you think are the largest benefits? 
I'm no game developer, but the number of libraries(aka rust crates) that are surfacing with respect to graphics 2d/3d for rust is growing quickly. That's a subtlety c++ -biased developers cannot deny. With respect to performance, there has been a lot of talk about how "rustified" your algorithms are implemented as opposed to something that is directly translated from say (java to rust), (c++ to rust), (golang to rust). If it's well-written in rust, it has been said it will perform just as well, if not better than c++. That said when golang came out, the reason developers would adopt it over c++ or java is because once you get used to using it, it's fun to use and does the job well. The only reason I considered using rust was hearing that rust was faster than golang and just as safe as golang if not safer. http://dtrace.org/blogs/bmc/2018/09/28/the-relative-performance-of-c-and-rust/ Doing parallelism/concurrency in golang was certainly easier than c++, but ultimately still complex when scenarios are not simple as the real-world usually is not straightforward. Does rust make it easier than golang/c++, I believe not. But I believe the compiler error messages help to protect you more against runtime errors than c++ or golang similar to the way ada/gnat does. I appreciate that. Does rust target all the hardware targets that gcc/g++. NO. But it does target the hardware that matters to most people. intel 32-bit/64-bit(desktop stuff), arm(32-bit/64-bit)(phones/tablets). That about covers the areas of application that are relevant to most people on the planet. Yeah we could go on about internet of things and robots and rust will be applied well there too. So what am i saying, you wouldn't be wasting time learning c++, golang and rust. Then embark in trying the c++/golang libs and rust crates that you care about(game engines). You have to look at the source carefully. Then ask yourself which sources are easier to read/follow/build. which sources are fastest to build with zealous optimization. Not speaking about game-engines, but after all that, I chose rust. What I chose doesn't matter. What matters is what you experienced. 
&gt; Subtyping seems to be only used in C++ because there's no other way to get dynamic dispatch. Rust has dynamic dispatch, so I'm not sure what the real problem here is. I can't imagine what you mean by this, exactly. As far as I'm concerned it's largely about the code reuse opportunities it affords.
It looks much better! The site looks more colorful now. Where can we give feedback?
This utilizes the brand new Lambda Custom Runtime feature that was announced at Re:Invent. https://aws.amazon.com/blogs/aws/new-for-aws-lambda-use-any-programming-language-and-share-common-components/
Yes it is. Thanks for your clarification. English is not my first language
&gt; Surely you can't be arguing against code reuse here? He is saying that traits are arguably better at this than inheritance. It seems like you are trying to claim that inheritance offers some unique benefit absent in Rust but you are not in any way explaining your reasoning. Everyone here understands the purpose and benefit of inheritance in a vacuum, but Rust presents alternative solutions to the same problem.
Yes, but that's neither here nor there as far as this question is concerned. There's an alternative backend in progress, CraneLift, which is written in Rust- and on the other hand LLVM is used as the backend for Clang, a C++ compiler also used to compile LLVM.
&gt; you can have one tangible base class, and any number of classes descended from it, all of which directly retain the concrete functionality of the base class while also doing something more specific on top of it. Traits can have default implementations, does that count?
This is just going into the slippery slope logic. Rust's solutions address **technical problems** with code execution. We have solid algorithms, and a good academic understanding of this. The solutions you want to solve are, **social** and **economic**. To apply the same problem solving logic to this without considering the human impact just blindly applying algorithms risks exacerbate existing systematic socio-economic problems while the only gain will be your ability to mindlessly write shovel-ware without doing do diligence on your imports. 
&gt; My main point is that side-effects should be explicitly marked because they make programs hard to reason about otherwise I have nothing against that. &gt; I've never felt that enforcing control of effects in the type system like Haskell does takes 80% of the effort I agree with this because I don't think that doing so inherently requires the design decisions Haskell made. My main issue with Haskell is that I have yet to see a convincing argument that going so far to the "purely functional" corner of the language design space is justified by the features it offers. &gt; Haskell has been called one of the world's finest imperative languages; there's even a term "imperative functional programming". The problem is that now I'm using metaprogramming to write imperative hackery on top of a functional language which then has to be transformed back into an imperative form for the processor to execute. Abstractions are unavoidably leaky, so I try to minimize the amount of potential trouble when those leaks surface.
How is it that it previously matches brackets/parentheses with regex? Don't you need a parser (a simple one, really) to do that?
I'll miss having the playground area as a "prove-it" zone.
 &gt;&gt; because threading is so hard in C++. you can do 'wide-model' parallel abstractions in c++ quite happily. I had that going 10 years ago, and c++ did eventually get the lambdas that let you use it more pervasively &gt; So, how would that not be not an improvement for game developers? you'd wipe out the convenience gains elsewhere. the thing that really makes threading easier is a set of rules which you can still implement in C++; avoiding globals and so on. you still need to rethink how things are written. the real reason threads are under-utilised is that there's a lot of legacy code. also for games machines you would be better off economising on the CPU and choosing a bigger GPU. the consoles have SOC's which have a big GPU with a manager CPU off to one side. the low level APIs cut down the CPU overhead 
it's not typing time, it's getting in the way when you're *reading* it.
Not really, because the point is that some number of the base methods will have more specific versions of them implemented by any given descendant class, that automatically first do everything the base implementation does *and then* something else.
It's just really tough to find a good code snippet; we had been thinking about this for quite a long time on the existing site.
FWIW, GCC has migrated itself to C++ too: https://gcc.gnu.org/codingconventions.html#Portability &gt; The directories gcc, libcpp and fixincludes may use C++03. Here's an article about that migration from a few years ago: https://lwn.net/Articles/542457/
I'm at AWS Re:Invent, as just saw this announcement.
&gt; gaming makes itself more special than it is. haha there might be other domains that are equally challenging. What i'm saying is it has it's own blend of priorities: the mixture of low level (embedded-like) *realtime* concerns with presentation/artistic issues, and indeed much of the time that I bring up concerns (with my gamedev hat on) , programmers form other domains usually retort *"that doesn't matter"* .. which may well be true (*for their domains*)
given rust is easier to parse, maybe you could make a syntactic fork (with transpiling both ways?) (much like the idea of SPECS for C++). but I have enough distractions already so I won't put time into it :)
I build on Archlinux and Win10 pretty much the same amount. 
Freebsd. Been working great for me thus far.
You can see the transition to new features in action by grepping for `stage0` configs. Stage 0 is when the prior version of rustc is used to build the current sources, and then stage 1 uses that product to build the current sources again.
The new slogan make it sounds like for systems programming and as mentioned in the post: &gt; We’re still not sure we love the term “systems programming,” as it seems like it means something different to everyone I don't consider web backends or even JS library through WASM as systems programming for example so if I was looking into a new language I would think it's not for me :/ [https://en.wikipedia.org/wiki/System_programming_language] shows OS, device drivers, compilers etc as example of System programming. I like the new design a lot however!
Yeah, we’d love to iterate more, but also didn’t want to block shipping on this one bikeshed. If you have ideas, please comment on the issue tracker!
Debugging mysteries crashes/bugs had fallen from 40% of the workloads to virtually nothing. Spending time designing good software architecture has gone up a little as a result (If you're designing things badly, Rust will let you know pretty quickly), but I'm more than happy with that tradeoff. I think perhaps the largest benefit is that *things just work*. Strange bugs are exceedingly rare. The standard library is immensely reliable and is clearly extremely well designed. There's no messing around configuring stuff, no fixing linker errors, no writing huge amounts of boilerplate code to make two libraries play nicely together. Documentation is amazing, and - provided you're willing to be a little less lazy and really learn how the language works - the compiler is totally reasonable about when and why it emits errors. I'm sure some people would argue that I'm some sort of fanatic, and perhaps I am. But I've waded through the heaps of s**t that using other languages, particularly C++, entail and I can honestly say that once you get the fundamental concepts that Rust is built around into your head, it's a thoroughly pleasant ecosystem to work with.
Looks like there is an issue open for images not being cached but it doesn't look like anything is cached currently (e.g. css or fonts). It causes every page to flash when I try to navigate around https://i.imgur.com/YjAHbul.gifv
/r/playrust
A few comments: 1. I like the original slogan better: "Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety." (Not a fan of the *blazingly fast* appellation, but I'll let it slide.) This told you exactly what the language was about: being fast, being safer, and making it easier to get concurrent programming right. The new slogan, " The programming language that empowers everyone to become a systems programmer." is not nearly as telling. 2. I like the code on the current home page that people can run. It's very nice when you're interested in a new language to immediately see what it looks like with a real code example. The new site has too much fluff and not enough stuff. 3. I like the colors and the typography. 4. Good thing to mention some users of Rust on the landing page. 5. The page takes a full 8 seconds to load for me on a 100 MBps internet connection. I don't know if the final page will be compressed/minified/etc., but it doesn't give a good impression that a language that is "blazingly fast" has a slow website.
I designed a more "full-fledged" alternative to dpc's solution, which I published nearly 3 months ago now: [Weighted Webs of Trust](https://github.com/matthieu-m/matthieu-m.github.io/blob/master/wwot.md). It is more complex, I think: more terms, more moving parts; and of course complexity and security are usually at odd. Still, as far as I can see, it is *complete*: - handles expiration/renewal of keys and e-mail addresses, because we are all forgetful. - handles recovery of identity after hacking. - ... I also find the principle of "diluting" trust interesting. That is, rather than trusting all descendant of a trustee up to N generations, the "Weighted" in WWOT is about having the trustee delegates 1/x part of its weight to each of its children, etc... As a result, there is no need to impose an arbitrary N since the total number of reviewers matters not, only the sum of their weights... and the sub-tree rooted in a given individual has a sum equal to the weight initially given to that individual and no more.
&gt;The programming language that empowers *everyone* to become a systems programmer. &gt;*everyone* to become a systems programmer. Umm, am I the only one who thinks this is overly dramatic? Look at [D's website](https://dlang.org/) It's modern, yet not full of overwhelming colors or styling, doesn't turn you into a systems programmer, conveys just enough information. IDK, maybe I'm getting old.
Really excited about this, but it also seems weird to me that they used an fn pointer instead of an Fn trait (or, even better, a custom Lambda trait)
It's what we hear from a \*lot\* of our users, especially those that come from non-C++ backgrounds. "I didn't think that I could do this kind of work, but with Rust, I can." And, it is one of the goals of the project overall.
Agreed. Don’t like that new slogan 
On your work computer, have you upgraded to the latest version of rustc? Have you had similar experiences with the issue [I posted here](https://www.reddit.com/r/rust/comments/9xseoa/rustc_hangs_on_windows_7_anyone_else)?
I am with you on this. I do like the massive boost to discoverability with the beta site, but it is a bit too "over the top". It reminds me of a young child who has found something shiny.
(╯°□°)╯︵ ┻━┻
Thanks! &gt;exactly what the language was about What do you think about the "fireflower" distinction? In some ways, saying what the language \*is\* is the issue; we do want what it's \*about\*. Which is not a list of features. &gt; I like the code on the current home page that people can run. We did too, but it's also got a lot of downsides. It's very hard to get a \*good\* example that's short enough to be understandable, real enough, etc. This discussion was going on with the old site too. &gt; The page takes a full 8 seconds to load for me on a 100 MBps internet connection. Nothing is currently optimized, \*and\* it's taking way more load than usual. This matters a lot.
MacOS (10.12 &amp; 10.13), Windows 8.1 and 10, and Fedora for myself
&gt; One issue is that there has to be some kind escape+auditing mechanism for external (i.e. C) dependencies, since we can't restrict their access. For instance, I would like to be able to use `ring` (and specify that it doesn't require permissions) even though it uses unsafe for C access to `boringssl`. FFI would be relatively, by having a granular FFI permission: `permissions.ring = ffi(boringssl)`. Unsafe, however, is much harder to constrain: if you can walk all over the memory of a process, you can essentially access any of its functionalities. I do wonder how widespread the use of `unsafe` is, though. If it could be isolated to a small number of libraries, it could be workable.
I love this idea, though it's pretty much what the old site did...
&gt; Really excited about this, but it also seems weird to me that they used an fn pointer instead of an Fn trait (or, even better, a custom Lambda trait) Hi! I'm an author of this. We did that initially due to static lifetime requirements. In a future version, I'd like to replace the `fn pointer` with Tower's service trait, so that folks can define their lambda handler as a Tower service (and use something like `service_fn` in Hyper, when that's no longer Hyper-specific).
&gt;that half-life logo
If you have the time you can make a PR at [https://github.com/awslabs/aws-lambda-rust-runtime](https://github.com/awslabs/aws-lambda-rust-runtime) :)
Only if you use `[]` for array literals and subscripts, of course ;) Scala solves the index issue by using `()`, remarking that an array is somewhat isomorphic to a function call: pass an index, get a value. There's no reason for special casing the syntax of indexing when it calls a function underneath, really. Array literals use `{}` in C, though it'd be a poor fit for Rust. Not sure what Scala uses.
Thirded. The orginal slogan is much more appealing to me.
I didn’t learn rust cuz it was easy, I learned it cuz it was powerful. 
&gt; What do you think about the "fireflower" distinction? In some ways, saying what the language *is* is the issue; we do want what it's *about*. Which is not a list of features. I think you're starting from the wrong assumption there. A programming language is a tool. People don't want to be told what they can build with your fancy new hammer, they want to know what differentiates it from other hammers.
Hi! I'm one of the authors of this crate. I'd be happy to answer any questions!
We've heard from many, many people that they, to use your metaphor, don't know what you'd do with a hammer.
Bleurgh. Probably an accidental mimicry of the Rust version. Should be fixed and hitting the CDN in a bit. Thank you!
I don't believe the rust home page is an appropriate place to start teaching people what programming languages are.
I'm been in the AWS sphere for years and have used Lambda quite a bit. I usually use NodeJS for my Lambda work but now I'm going to put some serious time in on my Rust learnings. WooT!!
&gt; As far as I'm concerned it's largely about the code reuse opportunities it affords. Can you give an example from UE4's public source or something? Just so I know what you're talking about. Offhand I don't see any inferiority in Rust's composition-based approach as a code-reuse technique. 
I feel like the current example is a bit too big (I hate that it doesn't even fit the box it's in), and there's only one. More, shorter examples, with a layout similar to the Kotlin one would fit the new site quite well IMO. I especially like that there's a coroutine example in Kotlin's site, and since safe concurrency is one of Rust's selling points, I thing a simple concurrency example would do wonders.
Like /u/steveklabnik1 said...I think that this actually states really well what one of the goals for Rust is. Even having a C/C++ background, I've felt this way myself using Rust and when I saw the beta site just now I literally shouted from my office chair, "YES! SO MUCH YES!"
The easiest way would be to store a vec of (string_id, start, end) index triples, rather than &amp;str's. If you have to have references, maybe you could look into something like https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-epoch?
Okay, I should go more into details around this and give it a more positive spin. I feel like there's a number of thing missing in Rust for gaming, just as we had for embedded. I _don't_ agree that they are exclusive to gaming, though. We see a lot of things where feature needs are surprisingly close to spaces perceived far away from each other - eg. embedded and WASM are sharing a lot of problems. To give another example, frictionless and speedy workflows matter _both_ for gaming and web development. If anyone wants to make Rust serious there, we need to find practice around these things.
That's not what I'm saying. Following your analogy is difficult. Let's try again: People are saying "sure this hammer maybe has a fancy grip, but I'm not in the market for a fancy grip: I'm in the market for a hammer to help me build a house." You focus on the house building first, and the details of how that helps later. Start with the what, then follow with the how.
Are there any plans to do event structs in a similar vein to rust-aws-lambda? I have an almost immediate use case with dybamodb streams.
This site is built with rocket, incidentally :)
Is this an official poll for something or just out of personal curiosity?
Regarding `data` specifically, I feel (and as hearsay, have confirmed with other people I know who have used rust) that the significantly more verbose type definitions in rust add a lot of friction and tend to keep people away from making a lot of simple constrained types instead of doing everything with primitives.
Well, I won't rate or give my opinion on any proposals, but the depriorization of gaming and other domains (such as scientific computing) is documented in the discussion around the roadmap. January will see a call for blog posts again and 2019 will see other priorities. https://github.com/rust-lang/rfcs/pull/2314 https://blog.rust-lang.org/2018/03/12/roadmap.html Also, I have to say, that there is a sizable group that wants to form a WG around gaming, but we currently have no bandwidth as a project to get new ones up. We _are_ working on that, so this is temporary.
As someone that uses rust but doesn’t do systems programming if I saw the new slogan I would of assumed the language isn’t for web stuff which is what I use it for.
That’s rust edition 2018 syntax for a trait object. 
&gt; People are saying "sure this hammer maybe has a fancy grip, but I'm not in the market for a fancy grip: I'm in the market for a hammer to help me build a house." Yeah, and you're saying "our hammer can help you build a house" while I'm saying "how is your hammer better for building houses than this other hammer?"
It's new syntax that does the same thing as `Box&lt;Error&gt;`. In particular, `Error` is a trait rather than a concrete type, so `Box&lt;Error&gt;` is a trait object that uses dynamic dispatch. But previously, the only way to know that was to know what `Error` was; if you didn't know it was a trait, you wouldn't know this was a trait object. The `dyn` keyword just makes that explicit. I believe that opting into the 2018 edition will make it mandatory? Not sure about that.
I didn't feel strongly about it, I just thought it was a neat sentiment about balancing proven-ness and actually moving the ball forward. [Meanwhile...](http://cowlark.com/2009-11-15-go/) :P
So... c++ is not java and code reuse? As noted by others, traits are a type of code reuse. Maybe instead of telling people they’re just wrong about inheritance, give a positive account of the benefits of inheritance over composition. 
You can do that with default implementations. You can have a wrapper that contains the struct you want and call the default implementation and then do more things to it.
Right. Both are important, but for the slogan, the simplest, most succinct description, it's "can help you build a house".
The fireflower metaphor is nice but I don't think it has actually been applied here. It hasn't evolved from "fireflower" to "Fire Mario" but rather from "fireflower" to "this makes you awesome". That is, the meaning what Rust actually entails has been lost and the new information only tells me "with Rust I will (allegedly) be a better person", which sounds more like an advertisement without substance than a convincing argument. Going from fireflower to Fire Mario is great but not while failing to convey how Rust is actually going to achieve making me Fire Mario.
&gt; What do you think about the "fireflower" distinction? In some ways, saying what the language *is* is the issue; we do want what it's *about*. Which is not a list of features. &gt; &gt; As a c++ developer the end result isn't that I can be a systems programmer, because presumably if I'm considering rust I'm already a systems programmer (whatever that means, because rust is being used everywhere) - the actual benefit is that the applications I write are fast, guaranteed crash free (for a certain class of crash), and correct (for a certain class of correct) If you really want to appeal to people, the best way is to simply show equivalent C++/whatever and Rust code, where the C++ code contains common and subtle errors (not just simply *nullptr, but dangling lambdas and implicit conversions), that the rust compiler either rejects or handles correctly The difficulty with rust I think is communicating the real advantages it brings to the table in terms of safety and reduced hair-tearingoutness for developers. If you can show a complex multithreaded race and say "this legitimately can't happen in rust" that's a major selling point So from that perspective the language itself is better than simply saying "it makes you able to be a developer", because frankly we're all developers anyway currently So in my opinion, the original slogan followed immediately by a mix of real world and contrived examples showing how in eg java you can dereference a null pointer like this common case, and in rust its impossible, and in C you need to write this common pattern which is dangerously unsafe (strings, ownership), and hey in rust its all 100% safe no leaks I can understand the problem of people saying they don't know what they'd do with rust, but it depends whether or not rust is actively trying to attract the existing developer base base (ie why is this better than my current tools), or new programmers (why should I learn rust over java/c++/javascript)
A language's homepage with literally no example or snippet is like jewelry store with no items on display. If we can't find *a* good snippet, how about a tabbed view that shows multiple snippets (possibly at random / switches periodically)?
Overall, this is a much needed improvement! Though, the h2 highlight in combination with the slab font does make it look a bit... cartoonish. Also the yellow from the buttons/links doesn't seem to fit the overall pastell-color scheme. What works for me is `.highlight { display: none; }` and a lighter yellow, e.g. #FFD859.
A self-hosting compiler is the ultimate dogfood project. It's an example of the capabilities of the language. Others in this thread have more decent explanations of the specifics.
That's now "find multiple good snippets"...
It relates to an [issue I posted](https://www.reddit.com/r/rust/comments/9xseoa/rustc_hangs_on_windows_7_anyone_else) earlier, the [Rust team determined Windows 7 isn't high priority since it's near EOL support](https://github.com/rust-lang/rust/issues/54874), and is likely not the most used OS for Rust. I was curious what the rough estimate would be and it appears to be as I expected.
Yes, we have done extremely little optimizing here so far. We'll get there!
I’m gonna be honest, take what you will. The new site does not have a unified color scheme, this makes it difficult to read. No code samples are on the new site which makes it difficult for anyone to have a first impression of the language. I cannot click on the release version in the new site which hinders my ability to see what changed in the new version of Rust. The contrast of the colors in the section headers (the ones with a block behind the text) decrease readability for me. What I like. The governance link in the new site is a welcome addition, I like knowing where Rust is going in the future. I also like the learn link and how inside the learn page all the resources are clear and standing out. The tools link is really useful and so are the upcoming events at the bottom of the landing page. This is just my first impression of the site. To be fair, I kinda like it after giving it a shot and navigating around for a bit. Good work. 
The code that the wrapper approach adds up to for non-trivial use cases is pretty undesirable, and methods specifically aren't even the whole story. Descendant classes also retain the actual fields/overall structure of the base class, for example.
Damn this calendar looks super ugly. Is it possible to style it?
Definitely not a fan. The information presented is okay, but it's too bloated visually. Also, the new slogan is pointless. I don't care if it empowers, I want it to be **powerful** -- blazingly fast, prevent segfaults, and guarantee thread safety.
The thing is, I don't think composition and inheritance are two competing ways of doing absolutely everything. I think they're two completely different concepts that don't amount to the same functionality and don't make sense for the same use cases. The things composition is useful for are things inheritance specifically isn't useful for or couldn't even be applied to, and vice versa.
Any general-purpose language. Niche languages intended for a specific use don't need to implement their own compiler if their purpose is not compiler implementation.
Hence "generally". :P
&gt; frictionless &gt; To give another example, frictionless and speedy workflows matter both for gaming and web development. right that's making sense I see overlap between games programming and (i) embedded, (ii) web (r.e. presentation), and almost(iii) the science/maths langauges (see the subtle ways in which Julia differs) . again you have a trilemna (within the gamedev case) but one difference I run into here is the prioritisation of *massive* (rather than just 'large') source bases. This seems to be where the justification is given for not having default args for example. I like quite a few of rusts pillars, but seem to run into friction with the details (eg. the prioritisation on some issues). When I came to it originally (pre 1.0) I imagined the foundation could be built on, I accepted it as a work in progress.
* I find the weird underline on the subheadings ugly and causes the subheading to be difficult to read * There's very little information at the top of the page. I'm not saying copy the wikipedia home page but I think the current site does a lot better * Rust in production is nice, including the videos of companies and stuff like that * Can only really echo what others have said about the slogan. It feels like you're selling me a lifestyle, not a tool that I'm going to use at work. In general I'm not even sure if Rust _is_ a systems programming language - a lot of the things I see built with it I wouldn't really describe as systemsy. * The code on [this page](https://beta.rust-lang.org/learn/get-started) strains my eyes to read, particularly the green background. On normal text it doesn't seem that bad 
Chaining manually is extremely trivial; there’s no reason to use more than we need. In our case we found that anything above raw MapReduce is basically just overhead - considering our input sizes we needed to be low level, I guess!
Isn't that what this redesign is all about? Expanding our market? We've exhausted the market of hammer users. Every programmer that's knows anyone has already heard about Rust. We don't need to advertise to them anymore. We need to expand our market to the non-hammer users. The project managers that see the word segfault and panic because they don't know what it means. 
I said this in my own comment, but I'll post it here for visibility. The new slogan is pointless. I don't care if it empowers, I want it to be **powerful** -- blazingly fast, prevent segfaults, and guarantee thread safety.
The new website seems to be aimed at a different class of people. i.e. Project managers rather than developers. Any thoughts on keeping both versions, putting the old version at, maybe, `dev.rust-lang.org`?
&gt;So much. Want to do HTTP things easy? Crate. base64 encoding? Crate. Randomness? Crate. It sounds like you wish Rust was a DSL for the web. It's a general purpose language, the vast majority of applications will never use base64 text or deal with HTTP. Those are perfect examples of what *doesn't* belong in STD. Randomness is a bit of a toss up, but it makes sense to me why it's not in STD. There are a million ways to go about doing it that all have tradeoffs, and it's better to leave it up to the community rather than have a simple implementation that only works for basic cases, like `rand()` in C. 
&gt; web developers Project managers
Reviewed on my phone: Like it! I agree that the first page your users see should be aimed at new users, not people like me! Some comments: A few styling problems on mobile that I'm sure you're aware of - small buttons at top - annoying double zoom for the events list - wierd font sizes at some places My only other criticism is that it looks like a website that's come from a template. I'd recommend trying to differentiate it a bit more - not just use colour blocks and colour wheels like everyone else. It's ok for a website about a programming language to look a bit geeky - it's reassuring!
Yeah, we've got an issue open about this here: https://github.com/awslabs/aws-lambda-rust-runtime/issues/12. In the short term, we'd like to export the definitions from [`aws_lambda_events`](https://github.com/srijs/rust-aws-lambda/tree/master/aws_lambda_events). Long term, we should take ownership of generating those event structs ourselves from our internal definitions.
Awesome. Thank you.
I like the slogan btw - but it would be good if you could click on "details" if you are an experienced programmer and see some more specific info like about the borrow checker, affine type system, etc.
You have access to all of those since you have the whole struct available I just don't really miss inheriting things, since I have multiple traits implemented for each struct. They don't need to inherit things other than in very particular cases. In my game programming I never thought "oh, let me use inheritance" because I never really missed it
Thanks! When you're not on your phone, would you mind checking out the tracker and reporting any if they don't exist? 
Will do
&lt;3
Already participating in [#408](https://github.com/rust-lang/beta.rust-lang.org/issues/408) :)
This looks great! I do agree the new slogan can be reworked a bit tho. The reason being is I think Fire Flower statements serve an important purpose distinct from Fire Mario statements and both being present present is most effective. The latter hooks you in and the former will back up claims with concrete facts and concrete facts are really important since there's unfortunately so much hyperbole on the internet. As an example, Elm's website has a pretty good setup where it hits you with a Fire Mario ("A delightful language for reliable webapps") and then right below backs that up with a Fire Flower ("Generate JavaScript with great performance and no runtime exceptions").
The layers of metaphor get pretty deep here, but what's one more between friends :) I think a big part of the audience is people who genuinely don't know that "any hammer can be used to build a house". Like, if you've used a few different hammers, you know that marketing something as a house-building-hammer is kind of a joke. But if you haven't really used a hammer, that's not necessarily clear. Also (peeling back the metaphor slightly), the programming language world has genuinely had a lot of house-specific or car-specific hammers for a long time, and some people building houses are very much still of the mindset that a house-building-hammer is what they need to be looking for, at least at first. Also, as with anything in the business world, we have to think about both the people who hold the hammer, and also the people who make managerial decisions about what hammers to order. Anyway, with that many metaphors I'm sure we could prove anything. But the high level view is that experienced programmers think about languages and tools in a totally different way from inexperienced programmers or other programming-adjacent people, and it's hard to be in one camp and put yourself in the shoes of someone in the other camp.
It's great to see that the Rust language now has sufficient mindshare and is so well established that the landing page can get away with presenting just about no information about the language itself at all. If I had seen this page all those years ago before I knew what the deal was with Rust, I'd probably have wandered off after finding no sample code nor any description of language features within a few minutes of browsing the site. But in 2018, where everybody knows what distinguishes Rust from other languages and how it achieves its claims of safety and performance, we don't need to expend any screen space on showing the language and can immediately proceed with telling people that it's really good. Ultimately, only a vanishingly small minority of visitors are going to be first-time Rustaceans, and those can easily get a feel for the language by clicking Learn &gt; Read the Book &gt; find the 2018 edition here &gt; Getting Started &gt; Next page &gt; Next page and scrolling down for one or two screens. With that out of the way, we can advertise yelp right on the landing page!
Thanks for that explanation 
:metal:
&gt;both being present present is most effective Yep, strong agree here. Let's see if we can't improve things!
Rust compiler written in Rust and uses bootstrapping: https://en.m.wikipedia.org/wiki/Bootstrapping_(compilers)
Reposting my comment from r\/programming, because it's the wrong subreddit. This seems to me like a downgrade. The new version of the site looks like generic clickbaity advertisement website. The focus is shifted from content to design, which I personally dislike when it comes to technical stuff. &gt; The programming language that empowers *everyone* to become a systems programmer. &gt; C: The programming language that empowers *everyone* to become a low-level programmer. &gt; JavaScript: The programming language that empower *everyone* to become a web programmer. These statements are neither false, nor useful. There isn't a programming language that *discriminates*.
Win 7, occasionally Ubuntu 18.04
I'm not sure if I have a clear picture of the issue you're running into, but one thing that comes to mind is that you can swap out dependencies for those in your private repo. It's a bit of a hidden feature, tbh, but there are docs in the reference on it: https://doc.rust-lang.org/cargo/reference/source-replacement.html
Also, is the site supposed to be released together with the 2018 edition release? The site is in quite raw state and being worked on in some wild rush in the last days. The feedback is also asked for only in the last few days, beside feedback from those suspicious people why buy the "fire Mario" nonsense rather that the old more serious/professional approach.
Obviously, thoughts about the slogan: Focus on "why you need Rust" as opposed to "what is Rust" is great. Explaining "why" as "everyone can be a systems programmer" is, kinda good I think? Obviously, empowering people is awesome, but - There are people who **are** systems programmers. They typically write their software in C, but would probably benefit from Rust as well? - This slogan can be read as "If you can't write memory safe C++ (modern, sanitizers, static checks, core guidelines), you can try Rust, but **real** programmers use C++" (obviously, I don't think that way, and most of C++ programmers don't think this way, but some say something vaguely along this lines). - Does everyone *need* to be a systems programmer? Obviously, systems programming is fun an engaging and will make you a better programmer, but in reality most of the programming is application programming. Focusing on systems programming is great, trying to say that Rust is a golden hammer that works for every domain would be wrong, but saying "everyone should learn Rust because everyone needs to be a systems programming" is not exactly perfect either. - To me, the core feature of Rust, it's unfair competitive advantage, is memory safety without garbage collection. The language and ecosystem around it obviously has a cornucopia of awesome things, but, imo, they are not what justifies Rust's existence: I can see Rust without Cargo &amp; rustfmt &amp; enums, but I can't see Rust without memory safety. So, I think it makes sense to make this more prominent on the website, with, perhaps, a thorough explanation on a dedicated page about what memory safety is, exactly, and why should you care, and why GC does not solve the problem in all domains, and why static checks and sanitizers aren't solving the problem either. Obviously, I don't have an idea of a better slogan: something along the lines of "Rust: a language which empowers you to build safe, secure and fast infrastructure"?
As a hobbyist code reader with light exposure to assembly and C over the years, Rust has helped me think about the "what" of software more clearly. In particular, the list of Features contains terms I was unfamiliar before looking into Rust. In a sense, I'm finally getting around to the arithmetic of it all. I hope that important technical and academic breadcrumbs can still identified easily.
I am so disappointed that AGAIN there was no attempt to keep a consistent header/footer between Rust properties, and sure enough, I immediately get dropped on the blog that has no apparent links to the main rust sites, or to cargo, or to docs, or to the discourse, or generally anywhere that would be helpful to link to.
We barely have the ability to maintain one site; two is far too much.
This design is worse than the old one. It uses far too many different colors, and makes information harder to read. The old design was coherent, this just looks like someone dropped several paint buckets.
&gt; there was no attempt to keep a consistent header/footer between Rust properties As I said in the post, this is working towards that foundation.
I don't like the new slogan, as others have noted, it doesn't seem to really tell a programmer what the language is about, or what it does differently, or what it'll provide them that other languages won't. I don't like the lack of a code sample. When I see a page for a new language, that's exactly what I look for first. The overall look of the new page is okay. I'm not a fan of the colors. Overall, it strikes me as more of a marketing page trying to sell non-technical people on a new technology. Maybe that's the goal, and maybe it's a good idea. But as a programmer, that's not what I want to see. I do like the highlighting of webassembly and embedded programming and network services. Those are good things to highlight.
I liked the no-nonsense simplicity and information density of the old site. The new site looks more like a marketing site where it's colorful and fluffy. If you're trying to convince management to use rust, yeah, the new site works better. But I think rust adoption is definitely a bottom up, engineer-led problem, not a top down management driven one. 
I've read the argument, that the term "systems programmer" is too narrow minded, as Rust has outgrown this initial goal and is nowadays pushing into web development, gaming, data science, etc. I share this concern. But I also like the new slogan. As a solution I propose the following: Change the slogan to: Rust. The programming language that empowers everyone to do **systems programming**. And then replace **systems programming** with additional stuff that can be done with Rust in an animated way. (i.e. cycle through the different activities) Some ideas: web development, data science, ...
Is javac written in Java? I think scalac is written in Scala so there's no reason they couldn't but I don't know if they actually did. Also I think it's only recently that the C# compiler was rewritten in C#. For a long time it wasn't and it was already a very popular viable language. That said, writing a compiler for your language in that language is a milestone that matters for a lot of languages. Of course if you do it too early, you can accidentally make your language designed mainly for writing compilers 😅
I think it's just the new decade coming. This is the 2020's style, and Rust is running on the bleeding edge.
&gt; People wrote Quake without any OOP at all Quake very much gets as close to OOP as you possibly can in C.
I like the fireflower metaphor. I haven't seen the talk by Kathy Sierra that inspired Dave Herman's blog post, but it reminds me of the Jobs To Be Done framework for analyzing the relationship between products and customers. It tries to get at the reasons that customers hire products in their lives. The notion is that if you understand those reasons, you can build a better product. Does it help you build a better marketing message? I'm not sure. The original slogan may actually communicate to *some customers* better that Rust is fit to hire for their job. One thing the fireflower metaphor does not capture that JTBD talks about explicitly is that there may not just be one job to be done. You may have several distinct customer personas that, if you look closely at them, are really solving different problems for the customer.
Wait till you see [this](https://www.ibm.com/plex/) I wish Rust website stayed as it is now.
I think there's a bit too much whitespace, it's a bit *too* spread out and feels poorly balanced. In particular the space under the heading blurb looks too big, like there's something missing. Not a fan of the typography. The coloured half-height backgrounds on the headings makes already fairly annoyingly wide-fonted text even more difficult to read by adding additional unwelcome noise for my eyes to work to ignore. There's an annoying mix of text that seems too small (the blurb in the Why/Build it in Rust sections) and text that seems too big (Rust in Production). Ironically the small bits have a better argument for being big than the big bits do (they have lower-contrast backgrounds to overcome). The garish background colours don't help (and most of it seems to turn into a dirty grey colour for colourblind users). Looking at the beta site in comparison to the old one it's noticeable how my eyes *relax* on the more conservative design. Blasting big chunks of green and red at me does *not* make me want to point my eyes at what you've written. The lack of code examples up-front is bit of a show-stopper too. A good example is worth a million breathless "Rust has great $x" sentences. And I don't mean the terrible example on the existing site - oh boy, this language makes it easy to match on magic numbers. The [D site](https://dlang.org/) is more like what I want to see. Some of the alt text looks superfluous. Like the WebAssembly icon having `"gear with puzzle piece elements"` - a good rule of thumb is to write what you'd put there if images weren't a thing. In this case it's just a bit of visual style to support a heading, so the alt text should almost certainly just be `""`. Please don't `target="_blank"` me. I'm more than capable of opening a tab all by myself. The `get-involved` section has an unclosed `div` in the `header` - some HTML validation probably wouldn't go amiss.
Yes. Couldn't agree more. If you want to get into game dev, learn an existing engine. Small correction: Unity is C# not C++. 
No, but if you want to appeal to Python/JavaScript developers then the fact that it is powerful is a key selling point. They're already using a language that's easy.
I'm in the majority here re: the slogan. It actually just feels disingenuous—anyone can already be a systems programmer without installing a new programming language's toolchain. Whatever OS you're using has a C compiler, and it's going to be *easier* for you to accomplish what you want in C than in Rust up to a certain complexity threshold. It's not about accessibility, it's about correctness, and this slogan doesn't represent that at all.
I think the "it does these things better" is what we're trying to convey, regardless of the focus. It's ok to drop very technical things like "thread safety" and "segfaults", however, the target markets listed in the post ("Embedded *systems*", "WebAssembly", "CLI apps", and "Network services") are much more informative than just "systems programming". When introducing a brand new language, and where technology is always changing, it's no longer clear what's considered systems programming anymore, and I don't even know what this specialized tool is intended to help me make.
The problem with the slogan is that this: &gt; Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety is the thing that cause this: &gt; " The programming language that empowers everyone to become a systems programmer." Is possible to not fully grasp what a "systems programmer" is, but is simple to understand that something "runs blazingly fast, prevents segfaults, and guarantees thread safety", even the more tech words here are common for most people with programming experience. So, what about a better slogan?:Lets try!: Rust is a programming language that guarantee* safe code and allow you to build fast applications at the system level.
I have a few thoughts. I like some parts of the beta, and don't like others. Pros: * Bold. I like bold designs, personally. The colors are bold, the layout is solid. Systems languages have often suffered from terrible visuals, and I think being appealing to newcomers is important. * Practical use cases. A language can be amazing, but still lack a compelling place to use it. I think Haskell and Clojure have this issue, where all I hear about them is their great type systems and flexibility and there's no concrete answer for "how will this make my software better." Cons: * Colors. These are bold colors, but not the right kind of colors. I'd much rather have a more limited palette of colors than have the current Dropbox-type clashing colors. Rust has a strong metallic, industrial theme already (Crates, Cargo, Piston, Servo, Nickel, this subreddit's colors), run with it! * Missing code snippets. We can't \*only\* appeal to newcomers; the obvious market is existing C++ developers, who don't care about these graphics and want to see what code and library support looks like. [python.org](https://python.org) gets away with putting code on the front page. We should show the strengths of Rust in the language developers understand best, code. * Slogan. Eh. I think it's good for newcomers, bad for everyone else, who will want to try to nitpick it. I think the no-compromises trifecta was really appealing to me: safety, performance, concurrency. I remember Graydon Hoare posting about all the mistakes Rust avoided repeating in its design - no null pointers, immutable by default. Might be worth giving this some visibility for all the people burnt by languages like C++ and JS. * [Crates.io](https://Crates.io) / [docs.rs](https://docs.rs) links. Project managers are concerned about the maturity of Rust's ecosystem, not merely the strengths of the languages. We should make the package index easy to find for this purpose.
&gt; No code samples are on the new site which makes it difficult for anyone to have a first impression of the language. This! Every programming language site should have a code sample above the fold on the homepage. 
Mostly on Windows 8.1. Occasionally on older PC with Windows 7.
I think this is a great example of how to iterate on this, thank you!
I'm not 100% sure, but please file something!
Either the company using rust or some kind of industry group I assume. This is in the hypothetical situation where rust is used in security critical enterprise contexts
This is a very interesting idea!
I think any use of unsafe would require auditing/whitelisting of certain crates which state their exact permissions.
I find it awfully condescending. It also undersells the language, as if Rust has no value of you are a capable programmer, or not interested in "systems" (whatever that means) programming.
Very few libraries need to even write to files, and doing so should be a red flag. Same thing with running she'll commands. It's not so much that crates request permissions. You the author of your app can specify what permissions you give to specific crates (and all their dependencies) and the compiler could check it.
Hey, me too! Multi-OS users unite! :)
Ow. Just…ow.
I find the white text on teal background quite hard to read, and the new site _feels_ a lot more like "this startup is selling to my manager" than "this language is speaking to me". The result is honestly quite alienating. That's beside visual components I simply find jarring, like the odd half-height backgrounds on the section titles or the incredibly wide color separation in the theme that honestly feels exhausting to me. The current website feels like the text is the message, and it's there to deliver it. The new one feels like it's a _billboard_ - meant to catch your eye at a distance, but not really convey anything more than "You should expend effort to learn things about me". If this was what Rust's website looked like when I first got into it, I likely would not have.
&gt; I like the code on the current home page that people can run. It's very nice when you're interested in a new language to immediately see what it looks like with a real code example. The new site has too much fluff and not enough stuff. Examples are nice indeed, but I don't think the current example does a good job of selling the language (no offense to the author). It just prints out a bunch of strings, and doesn't even do it in an elegant way. Calling `enumerate()` and then matching on the indexes, and invoking a separate `println!` for each index doesn't look very elegant, and makes the language seem convoluted. I would personally like to see multiple examples featured that each highlight a different strength of the language. See for example [python's homepage](https://www.python.org/).
"Good" doesn't really matter much here. When I'm looking at a language, I want to see a snippet that gives an example of some of the syntax and semantics of the language. I'm not going too study it deeply, I'm going to glance at it briefly and say "oh, that looks like a thing." Show me what your language looks like. I can tell you from repeated experience that if I don't find a snippet on the front page it will be the first thing I dig for, which will make me cranky and if I'm in a hurry make me just stop.
I do not like it one bit. Please try for much closer to plain text, not an explosion of colors and styles.
That's pretty much what "empower" means. And I like the focus on "everyone" too. It makes it clear it's not the "FootCannon 3000" kind of powerful.
TIL decision paralysis
&gt;"Good" doesn't really matter much here. ... Show me what your language looks like. That's what I mean by "good." It was (and still is) very difficult to show representative samples that are small enough, yet realistic enough.
&gt; The page takes a full 8 seconds to load About 3s to 4s for me on 50Mb/s. Most of that comes from Google Calendar, which does a septillion requests. At least it doesn't really block page loading. What I don't like is that this simple page weights 3.4MiB. 3MiB of that is just fonts, TTF instead of WOFF2, and each and every bold-italic-normal-extra-bold variant available. Sending just two WOFF fonts, the header one in bold and Fira regular, would perfectly do the trick and pull the whole site down from 3.4MiB per page to 1MiB or something like that.
Looks nice, although I'm really not a fan of the thick-line-behind-title-text effect. It looks like someone screwed up the CSS styles or browser incompatibility. Which isn't really a good look for a language that wants to emphasise its reliability.
All I have seen you say is that inheritance offers code reuse. Given that Rust also offers many of its own ways to reuse code, this is not convincing in the least. No one here needed it explained to them that you cannot share fields or make virtual methods in Rust. What we need explained is why you think this is an indispensable feature for game development. Can you come up with any concrete use cases where inheritance is required for game development or is at least a significant improvement over comparable Rust idioms?
Why is it always crypto jobs though?
[https://doc.rust-lang.org/book/2018-edition/appendix-02-operators.html](https://doc.rust-lang.org/book/2018-edition/appendix-02-operators.html) is where to go in cases like these; &gt; Raw string literal, escape characters not processed &amp;#x200B;
It looks like a startup trying to sell me a product using generic marketing buzzwords. 
&gt; You have access to all of those since you have the whole struct available You're missing the point that the whole thing is nothing more than a "sorta close enough" workaround for functionality that simply doesn't exist. &gt;In my game programming I never thought "oh, let me use inheritance" because I never really missed it Nobody ever thinks about it in that sense.
&gt; this document is just very poorly explaining the idea; it's very abstract and and full of newly introduced terms; it reads like a math paper, that requires someone to be already familiar with everything to understand it; Hum :x I've tried to define the terms before using them, but I may have missed some. I do define a number of terms just to ensure that everyone agrees on their meaning. The goal of the document is to be as precise as possible, after all. &gt; i am not convinced about the design in the first place, especially "weight calculations"; it is complex and high-level; IMO, complex systems don't work; they have to evolve from simpler, more mechanical ones; The main benefits of weight is their resilience: the system cannot be gamed by creating 1000s of accounts, because you cannot grant more "weight" to all those accounts than you had in the first place. Actually, weights are the central part here; all the rest is relatively boring account/review management. &gt; I didn't even know that word. If this is to be popular system then people have to use it from all parts of the world, without background in Anglo-saxon legal systems, and with English as their second or third language, it has to be trivial to understand. Well, that might actually stem from me NOT having English as my first language. It's never obvious whether a word is commonly used, or not, by the native speakers. What would be a more commonly used synonym? &gt; Who is going to deal with all that? I might misread it, but it sounds like a byzantine bureaucracy, that no one will be willing to do. I am laser focused in my design to make everything as simple and effortless as possible, because even a tiny barrier to entry can crush the the whole idea by just preventing it from gaining enough traction. I understand the sentiment, there is indeed a risk with regard to barrier to adoption. I find "byzantine bureaucracy" rather harsh, though. - The most essential command, "reviewing", is a single command. Exactly like your system. - Adding a user to the WWoT is 2 commands: an invitation (by a user) which is accepted (by a new user). There are more commands, to account for extra-ordinary situations, however the complexity of the "flow" of each command is inversely proportional to their frequency of use. &gt; it's unclear to me where will all this data live and how it will be circulated; Ledger of Trust seems like it will require a blockchain, or it will have to live on central server that hosts it; In my design, people just host their reviews on git and download updates from each other; The idea was indeed to have a server per ledger; similar to how crates.io is a server for cargo. And much likes crates.io, the idea was the files themselves would be available as a github repository: the server would only be involved for changes, not read-only access, for better scalability. It is slightly more complex to setup, however massively speeds up verification: a single request per ledger gives you *all* the reviewers and their reviews, rather than having to query a large number of end-points. This helps scaling. &gt; code is what matters; this document is not worth a lot unless someone will implement it Agreed. It is cheaper, however, to iterate a design at the specification stage, than at the implementation stage, which is why I'd rather solicit feedback early. After all, if someone demonstrate that the system is fundamentally flawed, there's no point in even attempting an implementation.
People seem to be perfectly happy with the old slogan.
&gt; If you give people the path of least resistance to trying the code, it can feel much more doable. D's sample code selector https://dlang.org/ is pretty cool as well. I thought the five links to different kinds of Rust use cases was pretty brilliant actually, and it's right there near the top of the site. Also I don't wanna dunk on dlang.org too much but it could *really* use some love from someone with design skills, the very poor use of spacing and typography makes the page look noisy and distracting even though the content is pretty good.
Assuming this is building Rust projects and not Rust itself. I cast a vote for Other, which in my case is FreeBSD. Arch Linux is my secondary platform. 
Fourthed. I have no desire of ever becoming or being a “systems programmer”. Yet I love Rust.
I'm aware of bytecode, don't want a garbage collector. I want to be able to manage my own memory.
Indeed
&gt;small and representative The reason for why you can't find such thing is because Rust is verbose, and only a verbose code snippet would be representative. It sounds to me like you want to make Rust look less verbose and more beginner-friendly than it actually is. 
CMake is pretty popular, I will learn it later but for now I would rather just learn C++.
I know it's unpopular to like changes but I really like the new redesign. Great job. 
If my goal was to create games I would use unity, however I prefer making game engines. Might seem dumb, but I love it.
I really like the five links to usecases, actually. Much more than toy examples. But a small sample of what Rust code even looks like on the home page is kind of obligatory. Also, about this page: https://beta.rust-lang.org/what/networking Really, I understand you probably didn't have the code ready yet when the designer delivered his work, but this is not okay. The code needs to fit. You can't just have scrollbars everywhere.
I mean, I don't know if many cases where it would help. I heard some Servo programmers wanted it, not sure if they still want it, or if they figured out a better solution to the same problem. I have never used this workaround either. There are many different ways to structure your program. I'm sure inheritance is the cleanest solution in some cases. But I can't think of anything from my experience
I am also a fun of the runnable code on the home page.
I've been programming in Rust for around a year or so and I love it. I'm not a professional though - I've started programming 2.5 years ago and TDD is quite a new concept for me. However, I think Rust and TDD both force the programmer to create good quality code - Rust's compiler handles possible problems with allocations, references etc and the TDD makes you think about what you want to achieve before you type. I've already seen how it changes my mindset. Off-topic question but it's kinda related: I've heard Haskell is an amazing language as well. What's your opinion about it and about the functional programming? What skills would I acquire by learning it?
Asking bunch of hardcore programmers about their opinion about a modern design. You get what you ask for. 
Thanks, I didn't notice it.
Some people are. Many are not.
Can you comment on the performance of this compared to other runtimes? Iirc python is/was actually the fastest lambda runtime and I'm curious if that's still true
Yes, that should be fixed! And that is the root cause, I believe. Can you file an issue please?
I'm all for updating the website, but honestly I don't think the new design is an improvement. 1. The colors are really distracting. The header legibility is rather poor, lots of white text or bright background, and also there is no single color theme, so to my eye, the whole thing looks like many different colors slapped together without much thought. 2. The contents are richer, but there's too much empty space around, this goes to another extreme. 3. The loading time for the old website is almost instant. On the new, the pages take time to fully render. This is rather upsetting to see considering that there isn't even anything interactive on the site. And I have a very fast PC and Internet, so it is probably a lot worse for many others. Looks like the fonts are the problem, so this is easily fixable, but needs to be fixed. 4. Overall, I don't know if the general look conveys the message of a serious language. I'm not against a more cheerful version of the website, but this just looks like some startup coming up with a landing page. 5. I think due to #2 there is a problem with finding stuff. For example, I go to the "Learn" page and all I see is only two links which lead me to the book and the rust by example. But this isn't the documentaiton. To read the docs, I have to scroll down, only then I see the documentation among the other links. Not completely buried somewhere, but not easily discoverable either. 
Test Driven Development. Sorry I didn't specify it.
I'm aware of how the main games deal with Pokemon, but I'm actually trying to do something slightly different: an AI for [Pokemon Showdown](play.pokemonshowdown.com). This means, for example, that I do really need to be able to parse Pokemon strings (because Showdown uses a specific format for printing Pokemon movesets that I want to be able to parse and output). I got string generation to work using strum and a few special cases, which is fine in my book (less than 50 lines, pretty readable). I'm pretty certain this approach will work fine. 
It probably would happen in C++ or Pascal
&gt; Given that Rust also offers many of its own ways to reuse code That's true, but they're not ways that apply to anything similar to the kind of code reuse I'm specifically talking about. &gt;Can you come up with any concrete use cases where inheritance is required for game development or is at least a significant improvement over comparable Rust idioms? It goes back to the same point as above. Note also that I don't agree that inheritance is somehow a competing alternative to anything Rust does currently, nor do I think there *are* any "comparable Rust idioms". I think it's just an individual concept that serves a particular purpose that Rust simply doesn't attempt to implement. As far as I'm concerned having composition *and* inheritance in any language is massively better than having only one or the other, because they're useful for completely different things.
You can use the RLS in neovim with [coc.nvim](https://github.com/neoclide/coc.nvim) for example. I use [YouCompleteMe](https://github.com/Valloric/YouCompleteMe) – I don’t know whether it uses the RLS – but it works pretty well with autocomplete in my experience (better than the RLS has ever worked for me in VS Code, but I haven’t used it for a while).
It's really useful to have async/await instead of callback hell. Here I can provide some selling slided from C# 5.0 presentation, that introduced async/await the first time in mainstream languages They are a bit blury so sorry about that. vs &amp;#x200B; See full presentation [here](https://www.slideshare.net/conceptdev/c-5-asyncawait-for-eastbaynet)
MacOS.
&gt; Hum :x I've tried to define the terms before using them, but I may have missed some. It's not about defining them. Humans are not robots. Just because you defined a term, doesn't mean the reader is going to understand it or remember it. I strive to explain my ideas in a way that it's possible to understand in relation to what most people probably already know, visual metaphors etc. Noone is going to sit and parse your document trying to make a precise sense of it, before they actually bought-in to your idea. The precision might be good for a spec, but not for a document which is trying to explain and gain some interested people trying to help. 
I don't think it achieves that. More 'this is how to build a thing that you live inside often made from brick, concrete, or wood'. I can't give a good definition of systems programming. What I can do is imagine a program crashing because of a segfault, a password being leaked because of a buffer overflow, a car crashing because of a data race, a build failing because of a configuration bug. There are a lot of languages that can achieve everything on the beta homepage - at least two of them are much more popular than Rust. So I think the argument should be why not to use those. I don't think it should be what the language can do (current homepage) or what the language can make (i.e. it's Turing complete), I think it should be what the language helps prevents from happening. That's what I see as the value proposition.
Can I request a vertical version as well, for the phone ;) 
&gt; That's true, but they're not ways that apply to anything similar to the kind of code reuse I'm specifically talking about. What ways? &gt; I think it's just a specific concept that serves a particular purpose that Rust simply doesn't actively attempt to implement in any way. What concept? &gt; because they're useful for completely different things. What things? Seriously, the number of comments you are writing without actually saying anything at all is impressive. Either you're just trolling or you need more experience with paradigms besides OOP, because it sounds like you're just stuck thinking of programming in OOP terms.
Javac is written in Java, but for obvious reasons the JVM is not, so iirc that's written in C. 
It reads as condescending to me.
How did you build this package so fast? 
&gt; not a top down management driven one It's a bit of both. People at my workplace are reluctant to try Rust; management aren't prepared to take risks.
I found it very impractical. It had nothing to unwrap and was an easy target for bickering. ("yeah, but my example says Rust is slower")
Thanks for the response. People like you make me love Rust's community and I'm grateful I can be part of it.
I really like the current site. The links to documentation and so on are visible and nice, the beta site just has "get started" and some tiny links that look greyed out so they look unimportant. The colors and spacing of the beta site seems like those websites that use 8 MB JS frameworks just to say "Hi." in the middle of the page. Please, just don't. &amp;#x200B; Please keep the old slogan. Programmers are interested in specifics traits of a programming language. Does it have a GC? Is it mainly interpreted or compiled, or both? What's the purpose of the language? What niche does it fill? What are its goals? 
The first feedback I got when I gave Rust promotion talks for Mozilla was that I should stop trying to have weighted discussion, not care about the others and sell them the cool stuff instead. That was from the audience. "People don't want" is always a bad way to start such a conversation. Many people want many things. 
I see people using sledgehammers to _destroy_ houses, but Your Metaphor Might Vary.
There is a dissonance between the programming language and this website design.
Also, comparative marketing always makes it seem like your thing doesn't stand for its own.
&gt; I would personally like to see multiple examples featured that each highlight a different strength of the language. See for example &gt; python's homepage The problem is that most of Rusts great features need examples that are a bit longer.
&gt; Agreed. Usability is important of course, but dumbing things down at the cost of capability and functionality has never been the Rust way and I'd be extremely upset to see that mentality become widespread. Rust has a strict backwards-compatibility rule. Removing capability is literally not allowed, to the point where they're eating the technical debt of Editions(tm), which are basically the same thing as HTML's "quirks mode".
This was developed internally at Amazon and open-sourced along with the launch of the feature. You can see that it lives in the "awslabs" GitHub organization. A C++ runtime was also released by Amazon.
The problem here is that "systems programming" is an arbitrarily defined phrase. Java is a "systems programming" language for some definitions, and it was extremely prominent in the web for a very long time.
&gt; Can you comment on the performance of this compared to other runtimes? Iirc python is/was actually the fastest lambda runtime and I'm curious if that's still true. Anecdotally, I've seen cold-start times between between 1ms and 15ms, but don't have (enough) hard numbers yet to give a _proper_ benchmark.
&gt; I liked the no-nonsense simplicity and information density of the old site. Sadly, when you dug through, a lot of the information was outdated, wrong, or people just didn't find it. I can only speak for the community team, but we architected our part so that we can make sure that everything on the page is always fresh.
Google Calendar is terrible. We're heavily investigating alternatives.
Sure. Will render one for you tomorrow. 
We have forge.rust-lang.org as a general information bag and maintainership of that is already very hard.
I'll start with **the good**: I really like the new focus on how Rust can be applied, and how it has been applied already. I think that gives a much better sense of Rust's actual capabilities than a feature list. And having links to specific applications (e.g. wasm) with further links on how to actually do those things is great. I also over-all like the new visual design. I have some nits (wish the logo were more front-and-center, the "learn more" buttons seem extraneous), but over-all I think it's really good! Now for **the not-so-good**, which is a little less concrete. A little fuzzier. But I still think important: My first gut reaction when visiting the new site was "I'm being marketed at". That may not be everyone's reaction, and it might not even be an especially bad thing. But I think it's worth keeping in mind that \_if\_ people have that reaction, it immediately puts a kind of social distance and distrust between you and the person viewing your site. The benefit of the old site is that in many respects it was humble and reserved, just telling me what Rust was. It's easier to feel like there's a real person/people behind that, rather than a marketing team. I'm also not sure if I agree with the fire flower approach in this case. Cosmetics companies also take the fire flower approach: you'll be a *more beautiful* you! Car manufacturers too: you'll be a *free, adventurous* you! I think there's a deeper discussion to be had here, but for me the gist of it is that the fire flower approach carries a higher risk of being manipulative. In particular, for it to be honest you have to be pretty sure that you *actually do turn people into the Fire Mario you're claiming*. Given the number of people who still seem to struggle with Rust, it's not at all clear to me that the new slogan is honest. A lot of people clearly aren't becoming the Fire Marios that the new slogan promises. Of course, we *want* to be able to promise this. I absolutely agree with the *goal* of making Rust as approachable as we reasonably can. But goals for the future are *not the same as current reality*. And I think any official Rust material should be very careful not to confuse the two. Unfortunately, I think the new slogan does.
 The state of C++ is better than ever, but the alternatives got even better. There's a good dependency manager for Windows now, vcpkg, which saves the day every single time I have to build something new. But even then, and after 20+ years of C++, I prefer to start new projects with Rust, F# or C#, no need to go through the usual hell.
Content-wise, I love the new content. Terminology-wise, I thought we were going to move away from using the term "systems programming", because it means different things to different people, yet it appears that the new website puts this term even more up front. Style-wise, I think prefer the old style. The old style had flaws, it was too serious, too boring, etc. but this made it the opinionated I guess. The new style is flashy, maybe in a way that either you love it or you hate it, and if you hate it, is off putting. 
&gt; Aha thank you. My bad. At the end of the article also mentioned rust. And then I realized. I just mistakenly assumed it's a personal package. For what it's worth, I _am_ an author of the package in question who is _also_ employed by Amazon.
I know it as "analysis paralysis".
Why? It looks like it's a pure static site...
That’s true, but it’s a good opportunity to dog food some of the rust web stack. It’s quite possible that it could be ported to a static site generator in the future.
I've programmed Haskell for a few years and I think that's a fair statement. I'm reminded of this: &gt; LISP is worth learning for a different reason — the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot. I wish we had a good FAQ for the sorts of things people learn that only get gestured at in posts like yours. I'm only starting to learn how to say what these things might be. Example: people coming from other languages often see `map :: (a -&gt; b) -&gt; [a] -&gt; [b]` as a two-arg function: "give me a function and a list, and I'll give you a list". This is not the only perspective. If `f` is a function, `map f` is a function over lists, and `map` is a one-arg function that lifts functions on elements to functions on lists. This is a surprisingly useful change in perspective, where you feel like you manipulate a function itself (sometimes several times) before actually applying it to your data. You can then start to think about `[]` (list) as an operation on types, that sends a type `a` to a type `[a]` ("list of `a`"). The huge amount of (parametric) polymorphism in some type signatures gives you "theorems for free", which let you say things like "from the type signature of `map` _alone_, I can conclude that any element in the result list comes from applying the function to something in the input list". Another example: function composition has this type: `(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c`. Roughly speaking, there is exactly one sensible function you can write with that type signature. Because the type system is so powerful (as far as mainstream languages are concerned), there's a capability for type-driven design that isn't so easily performed in other languages. This includes things like having the compiler generate code for you, because it can follow typeclass instances (which, AIUI, are similar to Rust's traits but allow more things, because Rust traded off zero-cost abstraction over expressive power). Laziness everywhere is interesting, too. If you don't have this, you sometimes get parallel libraries with "streaming" vs. "non-streaming" implementations of the same function.
&gt; I thought we were going to move away from using the term "systems programming", because it means different things to different people, Yep, this is still very much a desire of mine, personally. Still working on it.
I just found [`scraper`](https://github.com/programble/scraper) and [`select.rs`](https://github.com/utkarshkukreti/select.rs) just after making this post, such is life.
Yes, some sort of index-based approach to situations like this is very common and idiomatic in Rust. (And as some [recent talks](https://www.youtube.com/watch?v=aKLntZcp27M) have emphasized, it's common in C/C++ as well in high performance game development.) Structurally, the big benefit is that something holding an index doesn't claim any persistent ownership over the collection it's indexing into. Instead, index can only be used together with a real `&amp;` / `&amp;mut` reference to the underlying collection. That allows the reference to be very short lived (maybe only for one part of one iteration of your game loop, say) while the indexes live longer (maybe for the whole runtime of the game).
&gt; A self-hosting compiler is the ultimate dogfood project. Hm, not really. Many people say that it shows in languages if their only user was the compiler in the beginning. Rust had Servo as a dogfood project.
I say just steal the [example from Learn X in Y minutes](https://learnxinyminutes.com/docs/rust/)
I actually *really* like the new slogan. The old one was weirdly specific about some narrow kinds of bugs Rust prevents rather than focusing on the overall goal and design philosophy of the language. Rust does a lot more than just avoid segfaults.
Most people have heard of Rust. But most people haven't been convinced to give it a try yet. IMO the target audience is still primarily people who are already programmers in some capacity.
What does empower mean to you if not give people power?
Do you consider someone not a capable programmer because they want to be empowered by a new language with exciting new capabilities?
At https://beta.rust-lang.org/learn, the book title should be italicized. Currently &gt; Affectionately nicknamed “the book,” The Rust Programming Language will give you an overview of the language from first principles. You’ll build a few projects along the way, and by the end, you’ll have a solid grasp of the language. At first glance, it's hard to tell if "The Rust Programming Language" refers to the book or the language. Italics makes it unambiguous: &gt; Affectionately nicknamed “the book,” *The Rust Programming Language* will give you an overview of the language from first principles. You’ll build a few projects along the way, and by the end, you’ll have a solid grasp of the language.
I'm surprised you guys haven't heard of [Gluon](https://github.com/gluon-lang/gluon) !
Thanks! can you file a bug please?
Many people say "oh, Modern C++ is memory safe, so this doens't matter to me" or "yeah, maybe I get a null pointer dereference from time to time, but it's not a big deal and is easy to fix", stuff like that.
It's literally just the Greek letter lambda. It is not remotely exclusive to Half-Life, and was already in use in computing decades before the Half-Life games existed.
If you want to replace e.g. small Unix utilities, it is. Even without linking any libraries, the binaries are still quite big.
No, it doesn't seem dumb. Just a common thing where people want to get into games and end up building shitty engines instead. If you want to build engines then Rust could be a good choice, since there is a niche market. Heck, maybe get involved in one of the existing open source projects, that would be a good way to learn and service a niche that isn't dominated by UE and Unity. https://arewegameyet.com
And if you strip out the standard library, don't use any crates, and only depend on stuff that's already installed (like `libc`), you can shrink the binaries down to the same size as corresponding C programs.
I urge you to reconsider this. With the color scheme and styling, I just can't take it seriously. I'm scrolling through the pages and everything keeps changing - white text on dark, dark text on light, eyes constantly readjusting. Trying to browse through it looking for something is absolutely painful. Then there's all the buttons everywhere which are actually links, some of them open in a new tab, some of them don't, and it feels clickbaity. There's a whole section on "testimonials", like you're trying to sell me a pulp paperback at a book stand; trashy. If I had stumbled on this for the first time and this were my first impression of what rust has to offer, I'd seriously doubt it was worth spending the time to find out more. So I turned off the page styling, and aside from the huge amount of whitespace (not unexpected), it's actually looking all right. The content seems OK, I could find what I needed without too much trouble. A lot still felt like marketing fluff and not that informative, but ok, I can live with that. I like that there *is* a calendar on the front page. I agree with most of the other people here, I'd like to see some code snippet on the front page, just to be clear it's not like we're looking at R here or something, the syntax is sane and somewhat familiar (not bashing R, but it can be a little scary to look at). It doesn't even have to be that interesting, just a simple hello world would suffice. I like the accumulator calculator example of the past, it gets the point across. If I want to know more about what the language can do, I'll keep reading. 2/10, I appreciate the effort that's gone into this, but I think it's a step in the wrong direction.
The original: “a safe, concurrent, practical language” is nice and pithy. The existing: “Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.” Gets lots of key feature information in but is a bit of a mess. The new “The programming language that empowers everyone to become a systems programmer.” Is cleaner and I see the wording it in terms of empowering the user rather than the features of the language might be desirable. How about “The programming language that empowers everyone to write fast, safe code.” Or “...fast, safe, concurrent code” Honestly, I still quite like the original.
Interesting. Most of the folks I talk to (who have been writing C++ professionally for a while) have been burned enough that they see Rust's appeal, even if they're using a recent (11/14/17) flavor of C++.
Oh yeah, it's not universal!
I think the sentence in question is sending a message that most programmers are not capable enough for systems programming. It's not a message i agree with.
For some reason, when loading the page with Ctrl+F5 in Firefox, the page elements jump and flicker every time. It's really quite distracting. Initially I thought that some layout was being done with JavaScript, but there don't seem to be any scripts. Is it really just the webfonts? It would probably be worthwhile to try to fix that FOUT (flash of unstyled text).
I think you make a really good point, but I just feel like the slogan doesn’t sell rust well. To me, it has the vibe of “use rust if c/c++ are too hard for you”. Not that rust isn’t concerned with being ergonomic and approachable, but that’s not it’s primary concern, and more importantly, that not what makes rust special. I feel like maybe it would be better to go with something to the effect of “Rust is the modern systems language. Giving you the control of a low level language, without sacrificing safety or modern features ”. Again, to your point, rust as a language doesn’t just solve a couple of tough bugs, its also just a very well designed language and ecosystem for a variety of other reason. And while I don’t think that’s conveyed in the old slogan, I certainly don’t think it’s conveyed in the new one. 
I just took a quick look and while it seems interesting, it does depend on std and uses a garbage collector rather regions.
Oh, interesting! I got the opposite impression, that it's trying to encourage more programmers to enter the world of systems programming, and removing the stigma around systems programming being only for the "elite". I think this is something that is really great about Rust-- it manages to pull people from all different parts of the programming world together and give them access to powerful new tools. I thought the new slogan captured that well, but it's certainly not good if it's sending the opposite message! Hopefully we can iterate on it and clear things up.
I'll give them some benefit of the doubt because it is a beta and likely hasn't gone through many optimizations yet but when it goes live that just isn't going to fly. 
I have multiple openings for Rust developers jr through sr and a math degree doesn’t count against you. I think you’ll find that people who want rust really want rust and they will pay significantly more money than for dime a dozen C++ developers. The average C++ developer is dangerous, like a child pointing a loaded glock. 
Others have suggested using macros...but have you considered writing Pokemon out as data in a standard format that \`serde\` can parse and then generating code using a \[\`build.rs\` file\]([https://doc.rust-lang.org/cargo/reference/build-scripts.html](https://doc.rust-lang.org/cargo/reference/build-scripts.html))? It's a standardized way to generate code right before compiling the main project, so as long as you come up with a decent way of structuring your data it might be easier to just write code generation than maintaining everything by hand. :)
Why so cumbersome? &gt; Rust is a safe and fast system progamming language.
You might have a base class where all of the general boilerplate/utility/book-keeping functionality is implemented, and a number of child classes that are simply descended from it by one level and which do a variety of different things while indeed being further *composed* in their own ways of fields that consist of things likes structs primitives, or perhaps existing standard library classes like a `std::vector` that they use internally some way or what have you. Nothing about composition is in opposition to anything about inheritance, because there's just no crossover between them.
"Rust: A friendly systems language." 
It’s a funny story - when I was an avid D user, I suggested a forum redesign/restyle and sketched a prototype; years later I noticed they’ve actually merged that in, with some edits, and restyled the homepage the same way ;)
Not a fan. 1. It very visibly loads piecemeal, with things jumping around as resources load in and first screenful of the intermediate stages giving the impression that the page will contain nothing usefully readable until the page load finishes. Not a good first impression for a language that's supposed to have speed and reliability as two of its prime features. 2. The old site communicated relevant information efficiently. The new one reminds me far too strongly of the irritating single-page "puff pages", designed by graphic artists who used to work on magazines, that businesses put up to appeal to managers but which count *against* them when I'm assessing a bunch of competing options. If this becomes the Rust website, Rust will join the list of other sites where I consider the official landing page to be so bad at its job that I'll point people at the Wikipedia page instead. (Another example where I do that would be KDE's [Filelight](https://en.wikipedia.org/wiki/Filelight), which is the best disk usage analyzer I've ever found... but the [official site](https://utils.kde.org/projects/filelight/) doesn't have a single screenshot!)
Agreed, I'm not a fan of the solang either. To add something more useful to the discussion here: I really like the opening statement of the rust book: &gt; It wasn’t always so clear, but the Rust programming language is fundamentally about empowerment: no matter what kind of code you are writing now, Rust empowers you to reach farther, to program with confidence in a wider variety of domains than you did before. I think that could be made into a powerful slogan. I felt very empowered just reading it and I used that text in more than one talk already to introduce rust.
A historical perspective: some of the compilers back in the Real Programmer days were written in the target language with no actual implementation, then hand-compiled to assembly to create the first compiler. I'm looking at you, Oberon.
&gt; One big change to point out is the change of the community page and the switch from IRC to Discord. That also saddens me purely on principle, since I prefer to get and give open-source programming help on an open protocol like IRC.
Oooh I like that a lot. Maybe trim the first bit so it’s a better slogan. “Rust is about empowerment: no matter what kind of code you are writing now, Rust empowers you to reach farther, to program with confidence in a wider variety of domains than you did before.” 
Looks like it, thanks!
As the blog post says, we're interested in tweaking it further! We agree.
&gt; It very visibly loads piecemeal, As I've mentioned in the thread, we've done zero optimization work. This should be fixed.
Sorry, but I dont understand. Rust's solution the dynamic dispatch goodness you can get with C++-ish objects is trait objects. You can subtype traits to your heart's content, and IIRC can have multiple trait bounds on trait objects(?), giving you something like multiple inheritance. So what concrete subtyping does Rust lack?
Both of those engines still use inheritance heavily though.
The definition that includes Java actually [has the most claim to legitimacy](http://willcrichton.net/notes/systems-programming/), since the original definition of the term was about enabling the construction and long-term maintenance of large systems by multi-person teams. 
Building game engines is more fun than building games. ;-)
Would `#[repr(C, align(32))]` do the trick for your case?
I did read that since posting the comment, but it goes beyond load times of resources. No matter how much you optimize something, it's going to break at some point. (eg. if a user has a flaky DSL modem) The page should be readable (if not ideal) during the intermediate stages before the subresources load... not giving a false impression that some kind of JavaScript-based client-side templating engine has yet to run.
Sure. Making that happen is part of optimization.
You should just keep the old one
You're looking for /r/playrust
It's really cool to see notifications of local Rust meetups in China, India, and South Africa and such places. "I go have coffee and hang out with half a dozen rustaceans each week or two. And people on the other side of the world are doing the exact same thing."
There's a few reasons for this. One is that C programs will usually link to `libc` dynamically, given that it's universally present on most any system. Meanwhile Rust programs don't have that luxury, so they have to link to `std` statically and carry it around with them. And `std` carries around debug info by default even if your own code is compiled without it, hence the reason why `strip` helps cut things down to size. Though even with debug info stripped, your binary will still be larger than a similar dynamically linked C program since that standard code has to live *somewhere*. The current version of Rust also ships a custom allocator by default that also gets linked into the binary on some platforms, though that's due to change in a release or two.
Quite fair!
If it was as simple as just being able to call a particular method at a given time, then structs filled with function pointers would be good enough, which they aren't.
I like it but I was surprised by that there are no mentions of portability and how easy it is to write code that works on linux, osx, and windows.
That sounds like a great idea. Do you know if the exact behavior of repr C is documented anywhere?
I'll look into this: thanks for the advice.
https://doc.rust-lang.org/nightly/nomicon/other-reprs.html#reprc It pretty much boils down to "lay out the struct the way C does it"
I love the intention of the new slogan, but agree that it's not quite good enough. The term systems programming means very little to people who are not systems programmers 
I've actually been interviewed by a crypto company, and my understanding is that the barrier to entry for new technologies is pretty low. Most cryptographic solutions are relatively small in terms of breadth, so project turnover lets one try new things.
Agreed. Even though Discord is closed source, it does have a few advantages though, like voice chat and built-in history saving, not to mention images, custom Ferris emojis, etc. And the Discord team is actually really friendly with the Rustlang team, so at least we got that going!
Also paging /u/steveklabnik here, but what is the state of the Rust Community Discord server? Should it be linked in that page, since it deals more with the usage of the language? Also, this subreddit, while unnofficial, is a great place to discuss Rust. Would it be worth adding an unnofficial section in the community page to add these sort of places? 
Yea i guess there isn't a lot of old code that influences the choice of new languages to work with.
For me 'empower' falls into the category of meaningless marketing-speak. All those words have specific meanings, but those meanings have been tainted by overly-broad usages or attempts to be coercive. You also need to be careful not to get so high-level that you're no longer saying anything. We're talking about a programing language here, so if it's not empowering its user, that would make it completely useless. The goal here isn't to encapsulate 100% of what Rust is in a single sentence, because that sentence would be necessarily overly vague. The goal should be to speak to the essence and make people hearing it think, "Ooh, cool. I need to learn more about that." If I were writing it, I'd focus on what makes Rust different from other programing languages. The target demographic seems to be developers who know at least one other language. So the more it can speak to challenges encountered in other languages, the more it can capture the attention of the target demographic. To me, the most important part of Rust is its predictability/reliability/determinism, both from a performance and a behavior standpoint, so I might try to include one of those words. I also find it notable that you can basically program anything in Rust, be it an OS/embedded app, client-side web code and basically anything in between. It might seem like the term 'systems programing' encapsulates that, but I'd argue that the s#!tstorm that resulted from the Go team's usage of that terminology proved that it doesn't have a precise definition that everyone can agree on and imprecise language is a good way of writing words without imparting meaning. This kind of writing is really hard and it's going to take many iterations to get it right. But I think it's really important to focus on imparting meaning, and that means the feel and specificity of words really matters. And I think 'empower' really fails in those regards.
With some hardware running Java natively, it's also arguably a system language in the 'bare metal' sense.
Just gonna leave a comment here in the hope of hearing a response (งツ)ว
"fast systems programming language" is a redundancy - this can be simplified further: &gt; Rust is a safe systems programming language. ... or the previous complexity-budget can be reused to greater effect: &gt; Rust is a safe and expressive systems programming language. Excluding Rust, "safe" and "expressive" both generally do not belong in the same noun-phrase as "systems programming language".
I don't know if you're a good bot or a bad bot for doing this, but you sure are immune to the subtleties of human humour.
You're absolutely right, but maybe not everyone makes that connection. Furthermore, I would argue that D and C++ are also very expressive.
/u/steveklabnik1, I'm going to be the voice of support here. I really, *really* like this new website. The only things I dislike are the really unattractive Google Calendar widget, and the absence of any code whatsoever. People hate change, so I am not surprised by their knee-jerk reaction whatsoever.
Didn't the survey show that over 20% does not yet feel productive in Rust? I think [this](https://blog.rust-lang.org/images/2018-11-RustSurvey/5a-How_long_have_you_been_unproductive.png) image strongly contradicts the claim that *everyone* is 'empowered' by Rust. Why push the fairytale that anyone can be a programmer when Rusts own surveys show that Rust isn't for everyone?
Amazing! I stand corrected!
"building rust" sounds like compiling rust, not compiling your own code. You will get slightly incorrect data out of confusion. 
It doesn't have to be particularly realistic or representative. It does has to give them a taste of the language. Eg: - [Golang has hello world](https://golang.org) - [Dart has a big example](https://www.dartlang.org) Try it from the other side. Do you think you might like [Zig](https://ziglang.org) or [Pony](https://www.ponylang.io)? As someone browsing those sites, the *first thing* I look for is a code example to get a sense of what those languages look like. Do they look like C? Scheme? I don't understand how a code example is less useful information than body text telling me that I can use rust to write wasm, or body text telling me that rust is used at dropbox.
Yeah, my mistake.
&gt; Nothing about composition is in opposition to anything about inheritance, and nothing about inheritance is in opposition to anything about composition, because there's just no crossover between them. They're just two totally different things. I think you fundamentally misunderstand these concepts. Inheritance is a kind of composition. This should be obvious because the semantics of inheritance can be implemented in a language that does not explicitly have it. Inheritance is more restrictive, limiting you to only sharing functionality with child classes. If you absolutely need to express an inheritance relationship then it is more elegant if your language supports it, but why would you need to? &gt; You might have a base class where all of the general boilerplate/utility/book-keeping functionality is implemented For example, everything you mention here could be a separate class rather than a parent class. I think even where OOP is the accepted norm, putting utility functions in a base class is frowned upon. If you google “inheritance for code reuse” you get nothing but results explaining why you shouldn't do this _even in languages where you can_. In Rust for example, to share utility functions you would simply define functions and then import them where they are needed. I think you should look into getting a better understanding of ECS if you want to understand why inheritance isn't needed or even very useful in game development. You were technically correct in your other comment when you said that ECS does not preclude inheritance, but typically components are just plain structures rather than classes, let alone derived classes. ECS is just one way of designing a system without inheritance, but it's one that comes with benefits like easy parallelism and memory locality.
That's what I mean by "doesn't really matter." Throw the Guessing Game on there and call it a day. It's short enough and has some basic syntax and stuff.
FWIW as someone who does a lot of simulation and numerical work, the new slogan is very off-putting compared to the old one. 
Will this crate being actively maintains? &amp;#x200B; I assume that once the async/await of rust landed, there will be a huge change on tokio / hyper / etc. 
`TcpStream`s are `clone`-able.
I really like the.. font.
I don't care to become a systems programmer. The fact that it is a systems programming language is fine yet not relevant to me. I'm learning it because it's fast, concurrent, safe and several other neat things.
Pascal has real arrays at the language level and a built-in function to check their length AFAIK. kind of an odd example overall though IMO.
Quoting /u/steveklabnik1 who says Haskell tries to avoid bring popular, I fear that the new slogan works towards being popular. I hope rust tries to avoid popularity and focuses on being good
Sorry for hijacking the top comment but I wanted to address point 3 &gt;3. I like the colors and the typography I hate to be a spoil sport and to be that guy, but I have to disagree. The colors are a unique choice and they certainly stand out, but I'm not a huge fan of the moss green, diluted grape or strawberry bubblegum. I think a solid primary color and maybe an accent color would work much better. A dark orange -- rust colored, perhaps? -- I think would be very fitting Not a big fan of the slab serif font used for the headings and title. I don't know if it's the weight or the stroke size or the tight kerning, but something just seems off. I would try out a few more typefaces. Personally I don't use slab serifs enough to recommend something off the top of my head I really don't like this [off-center highlight](https://i.imgur.com/9gk1qjV.jpg) thing. It looks wrong and is unnecessary. A heading should be able to delineate a section on its own accord. Bolding is nice to make it stand out, but bolding and highlighting it feels egregious. I know a lot of this sounds pedantic, but I think it's important. I actually really like the current design because I think it embodies a lot of the values of Rust: simplicity, cleanliness, and organized. This design feels at odds with those tenets. It feels cluttered, messy, and unfocused. I understand this is a beta, and this is a lot of hot air over colors and fonts, but I think it's better that I make this statement now before this gets out of beta. In short: keep it clean, keep it simple. A dash of color here and there will look nice and won't hurt. Avoid overzealous use of color. Keep the clutter down.
Could you allow us to select multiple platforms? I try to make sure anything I write builds for linux (~centos 7 +), win 8+, current Mac, freebsd (at least as far as my router supports),arm 7 and 8... I cant say which would be "primary"
I believe the getting started page is missing a: ``` extern crate ferris_says; ``` In the example program.
People have said that they don’t know if “fast” means be compiler is fast, or programs are fast. “Safe” is also very subjective, even though we have an objective definition.
&gt; Will this crate being actively maintains? Yep! We plain to actively maintain this crate and get it to 1.0 and beyond. Lambda and Rust are a _fantastic_ fit. &gt; I assume that once the async/await of rust landed, there will be a huge change on tokio / hyper / etc. So will you have any plan about that? Yep, I'm in close contact with the Tokio and Hyper authors. We'll track those changes closely and update quickly. 
The intention is certainly not to market to non-programmers.
While you're here, care to learn more about the systems programming language RUST?
Happy to make a dent towards full support :)
&gt; People have said that they don’t know if “fast” means be compiler is fast, or programs are fast. I surprised. Absolute beginners won't know what a compiler is. Experienced programmers would expect that "fast" always refers to code execution, unless something like "compilation speed" or "fast compiler" is explicitly mentioned. &gt; “Safe” is also very subjective, even though we have an objective definition. A slogan can't be super precise, otherwise it will sound like something written by a language lawyer.
Well, I don't like the new slogan either. Especially with "empower", it looks like a "marketing" words...
If you're already a systems programmer, there's nothing in the new slogan that suggests that Rust provides any value to you whatsoever. It allows you to become a thing you already are.
I'm glad to see work being done on this! I see the recommendation to create issues in GitHub for feedback, but an issue seems a little strong for some kinds of feedback. Maybe consider some sort of survey? Anyway, here's some thoughts after I poked around the beta site for a short time. - I like the bold visual design, but I think the color scheme just has _one_ too many primary colors. Maybe try taking out either the green or the yellow? - The vertical rhythm seems a bit off. Most of the sections on the home page are very short, and so a lot of them fit on my laptop screen at once, which makes it feel a little "busy". - The content in the "Why Rust?" section is nearly perfect. I like how it highlights three important goals of Rust's design and then proceeds with some very short explanations of how it technically meets that goal. - Yay for references and quotes from people using it! - Not sure if the embedded Google calendar is just a temporary measure, but a custom calendar widget that blends in would be greatly preferable. Also I would put all of the upcoming event stuff on a separate page linked from the header. Typically people wanting to see the schedule already know that that is what they are looking for. - I really miss the code examples. First thing I _always_ look for on a language's homepage is an example of the syntax. Maybe it doesn't matter as much to newcomers, but I can usually tell quite a bit about a language by a 10-50 line snippet. - I don't like the header font at all. Not sure why. Maybe it is just to cramped. - Do we have enough success stories to have more than just the two on a dedicated page? Maye a "More success stories" link on the homepage. - The "Learn" page has so many useful links! I love it! Maybe also a link to docs.rs somewhere? - I really don't like headers without a width limit. It looks terrible on large monitors.
Likewise 
Tbh I could see Rusty Anvil being a library name
I had this problem too, I bought a new laptop, and through whatever order of installation I did, praying to gods, following directions better, it finally works as intended. It's still not perfect, but generally autocompletion and tabbing works well.
They’re also a production user!
I wonder if it'd make sense to have a "Rust for $X Programmers" section in the "Learn Rust" page, with the asked for contrasting code/features and an explanation of them. It needn't come across as confrontational if it's actually geared towards quickly explaining the similarities and differences to experienced people (as opposed to only focusing on things that Rust helps you with).
It's more than 2 - that's all I could come up with immediately. Riot games also use it in some services. I am a game developer and I use it for real time game servers. I think you'll find the use cases in games is growing and while it may be under the surface right now - it is happening. There is also the wonderful Amethyst Game Engine project, plus Piston. 
Not, in my experience, if you enjoy the satisfaction of people actually playing your games. ;-)
You can use immutable references as &amp;'a TcpStream implements Read and Write.
This was also a question on the 2018 state of rust survey that got finished/posted a few days ago fwiw. Linux was the most frequent response.
👍 from me
What is the meaning of runtime in this context? 
It’s supported natively, with an official API.
Technically he is right. Lambda is used to denote half life and is been in use as such decades before the notion of automatic computing existed 
But they also both use huge amounts of the kind of inheritance that doesn't exist in Rust. What's your point supposed to be here?
Then I stand corrected. Why do people use C++ instead of Pascal?
`MoveFromPin`? While we're resolving these matters, should we call this "bike-shedding" or "boat-shedding"? I think we need some community consensus on this. :)
I think the “this week in Rust” is a vastly superior intro &gt; Rust is a systems language pursuing the trifecta: safety, concurrency, and speed. That’s so much better than “the programming language that empowers everyone to be a systems programmer”.
&gt; Groan. This has the whiff of someone who stubbornly refuses to ever upgrade to Windows 10. What an oddly toxic response to a preference. I agree with the second part, it shouldn't be Tier 1 at this point.
It's my favorite too. 👌
I feel a little sad about this. I read over it a few times trying to get into it, and I just can't. The minimality, plain speech, informativeness, density and plain list of links off the original website were all quite intentional. You got enough information to know what the thing was -- pretty completely -- and links to everything you'd want to go to (clearly identified), on a single (small) laptop-screen worth of layout without scrolling or hunting around. Worked kinda hard to condense it to that size and keep it there. Each iteration in subsequent years seems to have expanded the amount of visual space, reduced the amount of informative content, buried ever more direct links, and placed increasing emphasis on slogans and ad-copy-like persuasive writing. This newest iteration is 5 pages of scrolling that hides all code and most technical information, replacing it with ad copy, testimonials, suggested types of programs and a bunch of scattered "learn more" links that don't give you much of an idea what you're going to get if you follow them. It feels much less informative, much more noisy, and much less clear how to navigate (or where any of the navigation goes).
Thank you, this worked out perfectly! I'm wondering if you could help me with this: As the loop iterates, I want to store the user input integers into vectors. I've tried going about this by.. let mut buy_list = Vec::new(); buy_list.push(buy); println!("{:?}", buy_list); which doesn't work, I get a single value for every iteration of the loop, which makes sense. But if I move this code to the outside of the loop, all my variables go out of scope. I need a way to push the input values into the vectors as the loop is progressing, and then being able to use those vectors further down the line. &amp;#x200B; Thoughts? &amp;#x200B; &amp;#x200B; &amp;#x200B;
I like the new look but I agree that have code on the home page was a good thing.
If you're trying to sell rust to developers then the new redesign is doing a very poor job. The first thing a programmer will look for when evaluating language N (usually against other languages) is concrete examples of what N is strong in. The last thing they'll be looking for is vague statements about developer empowerment, reliability, and project governance. The current design does a far superior job of selling rust because it puts the issues programmers might solve with rust up front and center. Also the bold design is more of a hindrance than a boon for a programming language website. A programmer will not pick up a language because its website is flashy. The simpler a techincal web page is to read and navigate, the easier it will be for programmers to get the information they need. Finally, the current design is better at selling rust because it includes code in the landing page. Introducing what a language looks like early on elevates one of the concerns a programmer has without them having to dig deep into the documentation. It also is an excellent opportunity to have control over a possible rust convert's initial impression of the language. A `match` statement is an excellent initial impression. The new redesign would not have sold me on rust if I was still a C programmer. the older design did. Technical remarks on the site implementations: 1. The old site is broken: the banner to direct users to the new site slides under the content when scrolling. 2. The new site is either too large or some assets are missing. I still haven't been able to fully load the site without something broken or missing. Otherwise, keep up the good work!
That's an option, but the (de|en)crypters save state, so it would get complicated.
The (de|en)crypters need mutable refs, though, or they can't call `read()` and `write()`.
I prefer the old design over the new one. It seems less cluttered to me, has a more consistent and "straight to the point design", and it just seems cleaner.
Please don't do this, it's horrible.
I think this discussion has turned positively [*Wadlerian*](https://wiki.haskell.org/Wadler%27s_Law).
That was a hypothesis and a possible explanation of data in the chart.
I agree with the sentiment of the new slogan, but don't like it, as much as rust is empowering. I think it has problems for the same reason **"Bumper bowling empowers *everyone* to play like a professional"** isn't going to make me feel great about choosing that option. Particularly the emphasis on *everyone* which puts the focus on compensating for the abilities of people, rather than on fixing common problems in earlier languages. The prideful part of me wants the think of rust as "systems programming sans deathtraps" more than "a language for programmers who aren't good enough for C".
Were I to choose the slogan, I'd nick SQLite's one: &gt; Performance, Safety, Concurrency: pick three
The new website seems to load slower (at least here on my phone). Website loading speed is very important: https://blog.hubspot.com/marketing/page-load-time-conversion-rates
[soup](https://github.com/pwoolcoc/soup) recently came out. Feedback would be really helpful at this stage. How does it look, /u/Crandom?
&gt;We did that initially due to static lifetime requirements Why not \`Fn(...) -&gt; ... + 'static\`?
The `Write` impl for `&amp;'a TcpStream` requires a mutable reference to the `&amp;'a TcpStream`, not the `TcpStream`.
You can delete your own posts.
&gt; why did I event study topology Because it is beautiful. Even though it is not that useful when you don't work with graphics. But knowing topology can be helpful for getting into machine learning, for example. 
It's a font website, they are always artsy.
I wasn't suggesting anything like that, just that ECS isn't a "buzzword feature" used by "speculative future engines". By most definitions, Unity is likely the most popular or the second most popular engine in current use, and it specifically states that with the introduction of ECS it is ["moving from the object-oriented to a data-oriented design"](https://unity3d.com/unity/features/job-system-ECS#tab-2). Of course they're not going to remove all use of inheritance, at least not any time soon. Of course inheritance *can* be used effectively, but in the case of Rust you have a powerful trait system with default method implementations, blanket impls, [custom] derives, macros, free functions and a flexible module system. In the presence of those, I don't really see the benefit of inheritance. For a very marginal decrease in verbosity, you add unnecessary coupling. A much more beneficial addition would some form of delegation syntax. I don't understand the argument for verbosity when C++ requires maintenance of header files. Yes, tooling can largely handle those. The same can be said for the majority of delegation (macros).
I wasn't planning on it, but if I know it may help someone it sounds like a fun opportunity! I have finals coming up soon but I'd like to have it I have time. What broadcasting time works well for you?
There is also [kuchiki](https://crates.io/crates/kuchiki).
I am a Java developer, but I've started secretly writing CPU-heavy code in Rust and calling Rust executables via ProcessBuilder. Nobody knows my dark secret yet. 
Anvil is the name of Smithay's reference implementation of a Wayland compositor using Rust 
That was it, thanks!
Lambda doesn't function with just implementing a single function in Rust – there is some other stuff you have to implement: it must have an event loop that reacts to the incoming requests and serializes and deserializes the events. The Lambda Runtime in this context means that.
I'm no expert, but I'll offer a few things I thought (that might be a little opinionated) One thing I'd recommend is for an HTTP server you use byte strings (`Vec&lt;u8&gt;` and `&amp;[u8]`) rather than regular strings (`String` and `&amp;str`),because as far as I know HTTP doesn't guarantee anything about UTF-8. Your code right now will fail if it tries to reply with a file that doesn't contain valid UTF-8, or if the request itself didn't contain valid UTF-8, and probably other places as well. You can get a static byte string slice using a string literal with a `b` prefix, e.g. `b"Hello World` will be of type `&amp;'static [u8]`. As for the string splitting error handling I don't really have much useful advice. You can use the `get` method to get and element an index in a slice without panicking. It'll return an `Option` you can match on and send a bad request response if something's not right. One more small thing, you might consider changing it to match on `verb` rather than using an if statement, especially if you plan on supporting more verbs in the future.
That's a pretty significant increase from the current size of ~430MiB
&gt;Consider: there's a vast, vast gulf between writing safe C for a compiler that could compile ASNI C if given it, and writing Rust for a compiler that literally won't allow memory safety errors and race-conditions. Outside of `unsafe`, that is.
Has someone \`PinUnnecessary\` proposed already? Where is this discussion going on? 
Op had actually submitted it there before submitting it here. 
It’s not that I don’t care enough to jump on the tracker but I am really surprised by this choice of words. The blog post even acknowledges that “systems programming” means different things to different people. A decade after the release of Go people still can’t agree on whether it enables systems programming or not, because no one agrees what it means. Worse, many people could read this, think “oh they mean Operating Systems” and never look at Rust again because they don’t work on operating systems. 
Nah because that's something loads of languages claim. Not unique to Rust.
And Go and D. It's not that hard.
I like it. Could even drop the "pick three" and just have "Rust: performance, safety, concurrency"
Definitely reads like a corporate page to me, exactly the kind of fancy presentation, buzzwords, and "oo everyone else is using it" they tend to love.
Just because they don't feel welcome doesn't mean they actually *are* unwelcome. How do you expect them to feel welcome, or anything else, if they just outright refuse any involvement in the community? it's a two way street. If they want to be involved and represented in a community a good first step is to *actually be a part of that community.* Or do you want non-x people "representing" x people? Or should we make up x people? How do you represent something that isnt there?
That would actually kind of work as a slogan Rust: C-like speed, memory safety, with an excellent compiler and modern language features. Maybe clean it up a bit Rust: performance, memory safety, and modern features.
The first version of Pascal was first written in itself, then manually translated to P-code (sort of like a VM for Pascal) which was then interpreted to produce the first self-hosted version.
What were the main selling points for you to use rust for numerical work actually?
Maybe the social footer should have a link to /r/rust too ?
NoPinNeededButThanksForAsking
Where is the Runtime API documented?
I have a similar experience. I started to code in C++ (my first jobs was in C++) but I moved to C# for my jobs and Rust for my personal projects. I will never type another line of C++ again for the sake of my mental health.
The implicit filter that is being applied to your poll probably need to be taken into account. &amp;#x200B; Usage of Win 7 among Windows versions seems to be around 36%: [http://gs.statcounter.com/windows-version-market-share/desktop/worldwide](http://gs.statcounter.com/windows-version-market-share/desktop/worldwide) 
I just wrote efficient diff algorithms. The existing crates computed diffs in O(NM), where N and M are the sizes of the versions. The API is probably a bit unexpected, any comments?
Agreed. I'd actually argue to replace systems programming language with full stack programming language. Rust is arguably the only truly full stack language out there right now (more so than javascript). AWS just announced lambda support for Rust. There are react like browser frameworks for Rust. Rust is a leader in the WASM adoption. People are doing operating system kernels and device drivers as well. You name it and you'll find people using Rust for it. So, how about: &gt;Rust is a truly full stack programming language that runs fast, guarantees safe memory usage, and is inherently thread safe. &gt; &gt;It allows you to develop anything ranging operating system kernels to microservices, games, and web applications. &amp;#x200B;
Made my day :)
Would it be possible to use iterators instead of arrays? A common use-case is to diff two data sources of arbitrary sizes (potentially terabytes) that get loaded one by one.
Thanks, that works great!
SmartOS (illumos) and Linux. 
"Rust: our website looks like a joke but the language is really solid." The new design and colors reek of unprofessionalism. There's a reason none of the other serious languages look this way. Take a look at all of these sites, https://crystal-lang.org/ https://dartlang.org/ https://dlang.org/ https://erlang.org/ https://golang.org/ https://julialang.org/ https://nim-lang.org/ https://python.org/ https://ruby-lang.org/en/ https://typescriptlang.org/ ....and tell us with a straight face the new rust-beta doesn't look like a huge sore thumb. 
No one is entitled to someone else’s emotional labour. And given how you ignore my example of outright hostility when a woman integrated the team, that’s just illustrating my point.
https://cheats.rs/ is a website intended as a lookup table for this kind of thing, where you don't know what to search for.
&gt; I think maybe this is some of the disconnect; we've seen far more non-systems programmers be interested in Rust than systems programmers. I personally think this is because there are just more of them, almost by definition. That's certainly true, and it's great that Ruby/Python programmers can now write more efficient and saver versions of their programs. But IMHO Rust is a lot more valuable if it's applied to the foundations of our software stacks, where the advantages of a safer language have a lot more widespread effects and therefore it would be nice if the marketing wouldn't scare off too much the guys working in this area. I might be such a guy and I love the beauty and clarity of the old side, but the new one just screams: modern web design, which might be quite hard to not have some kind of prejudice about. 
I think "portable" is another strength. I've seen projects written in Rust only because of this and not due to the need of the other Rust strength's like performance or thread-safety.
&gt; Rust is a programming language that allows fast and efficient use of all of a computer's hardware. something like that. Don't even mention 'systems programming' which not everyone can agree on the meaning of. Personally, I think the important point about systems programming is that you're concerned about how your software interacts with the machine. You might care about latency from the memory hierarchy, context switches, utilizing every core, zero-copy from some hardware buffer, etc. Things Python programmers don't want/need to think about as often. I think the 'allows' is important there because Rust isn't guaranteed to be much faster... if you just want to get things done and don't want to think about ownership much you can whip out a program written without much more effort than Python. For example, I have a Python script I've used every trick I can think of to get execution speed down to about seven seconds. I rewrote it Rust and it took me a little longer than it did to write the Python script. Execution speed? Six seconds. Where's all the much vaunted performance? Well, I looked and tweaked and tweaked and tweaked and now it runs in about six hundred milliseconds. That's beautiful. My Python script's finishing point for performance was just the starting point for my Rust program. When I write Python I'm usually going for 'fast enough' while when I write Rust I'm going for 'as fast as possible'. There's a concept that Martin Thompson brought to my attention years ago called 'Mechanical Sympathy'. I think that's what's great about Rust - it has a lot of mechanical sympathy wrapped in a very palatable ecosystem. https://mechanical-sympathy.blogspot.com/2011/07/why-mechanical-sympathy.html and https://groups.google.com/forum/#!forum/mechanical-sympathy for reference. 
Well in that case this doesn't need any crates.io support - it can be entirely community-driven, using something like [RustPräzi](https://users.rust-lang.org/t/announcing-rustprazi-a-tool-to-build-an-entire-call-graph-of-crates-io/22696).