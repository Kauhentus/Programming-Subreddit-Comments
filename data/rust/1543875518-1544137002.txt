I don't know anything about type-level programming, but maybe you could hard-code / pre-compute the values? They seem to be of a rather small range.
I saw this when I was using RLS. When I switched to idea, the disk usage became normal again.
I wrote indicatif because I could not get pbr to work like I wanted. First feedback I got is that someone could not figure out how to make indicatif work like he wanted. So not sure what that says about either library :D
I'm looking for more people to read the community info before posting.
Your want r/playrust
That’s just unreasonable! /s
Is there a tool like bingen/cbingen that can automatically translate Rust =&gt; C =&gt; C++. This would allow to map constructs that exist in both languages without having to manually implement them every time. Or is this maybe something that is in the scope of cbindgen?
Do you not `cargo clean` periodically?
Except if trait has blanket impl
I've deployed my [music reading game](http://www.music-reader.com/) which has an actix-web server and elm frontend. Its pretty much written but making a few tweaks here and there. Pretty simple server for now but I'll add a database at some point to track user stats.
Can RLS (nightly, as a part of Neovim + ALE + RLS combo) generate autocompletions for things in the standard library? It works fine for other crates - even pops up a preview window with doc comments for the thing in question (_squee_) - but for, say, `Vec` - nope. Do I need to add something to my setup for this to work?
sudo make me a sandwich 
rm -rf target
Just started learning rust, so going through the 2018 book. Enjoying it so far.
The Rust documentation is generated by rustdoc, and the tool lives in the compiler repository. Please file the issue on [rust-lang/rust](https://github.com/rust-lang/rust/issues), thanks!
I see! Perfect, thank you :)
Thanks! This will be very useful
Ostensibly the relevance is that if you use `unsafe { ... }` the wrong way in Rust you may get undefined behavior as you may in C and so this discusses what UB means. Of course, the things that are UB in C are not necessarily in Rust and vice versa.
&gt; Tuesday 6th I assume this is supposed to be Thursday 6th? :)
I feel personally that this article does not get to the heart of what UB is. The runtime behavior of a language is customarily defined in PLT by either its *operational semantics* (sometimes also *denotational semantics*). What you do is to define an interpreter which then in turn defines the abstract machine of your language. Undefined behavior occurs when this interpreter gets stuck and cannot handle some input / state. A language like the JVM/Java does not have UB because the interpreter/machine covers all cases. Optimizing compilers can use scenarios which are UB and assume that they never happen; with these assumptions, shortcuts can be taken and thus you have better performance.
For me, the metrics are almost the same, but some variants are kerned a little more to the roght than the others, leading a slightly strange left edge
Personally, I'd choose indicatif solely because it's created by mitsuhiko, his track record of amazing open source projects is insane.
This is probably a stupid question, but is the new module system coming in this release?
&gt; the memory safety is a thing but it isnt that difficult to be carefull about that. That's the kind of thinking that led to uncountably many security vulnerabilities in numerous pieces of software ranging from web browsers, to virtual machines, to the operating system itself. Rust does what it does to FORCE you to make those checks. Go prides itself on concurrency and channels, but there's absolutely nothing preventing you from causing a race condition accidentally. At best, you can run the race-detector in a separate check and hope that it catches the error, but it's not perfect and the most subtle errors tend to cause the most damage.
The impression I took away from it is that it's very relevant to understanding why using `unsafe` is a decision you don't want to make lightly. Nothing drives the importance of understanding your language's semantics home as well as examples of UB allowing the compiler to optimize away your checks or reorder your reads and writes.
The impression I took away from this is that it's very relevant to understanding why using `unsafe` is a decision you don't want to make lightly. Nothing drives the importance of understanding your language's semantics home as well as concrete examples of UB allowing the compiler to optimize away your checks or reorder your reads and writes. (Plus, combining that with an explanation of UB as "the compiler optimizers are allowed to assume this will never happen" really helps to make things clear.)
Wrong subreddit. You are looking for [https://www.reddit.com/r/playrust/](https://www.reddit.com/r/playrust/).
This is already a well-known issue and there’s a PR open that will fix it.
ty mb I'll fix lol
https://adventofcode.com/ is a popular challenge that's going on right now. A set of problems is posted each day until christmas, and you can use whatever language you feel like to try solving them.
Yes! This release is the Rust 2018 release!
It should be noted that this is Rust 2018 edition. 🎉🎉
Nah, it's coming out August 2019. Why did we call it Rust 2018 again? /s
Reeee! Got in a commit to [projects-rs](https://gitlab.com/anire/projects-rs). I've really let go of trying to do them category-by-category, so I'll just work on the projects which I find interesting. Would be nice if someone used my projects as a learning example or contributed :)
Have you looked into using the liner crate? It seems to be similar to linefeed, but has some other different features.
It is on Thursday, yes.
I've been using Rust for around a year but I used to be a script kiddie so I'm not too familiar with higher-level programming, so I don't understand the "no-std" thing? Why is that a feature? 
Correct
I'd guess that fontconfig (or the equivalent on other OSes) is mapping _full block_ and _left half block_ to one font, and the others are falling back to another font, and the browser is relying on the font metrics for the doing fixed-width instead of fixing the width first and then rendering the font. Just a guess though.
You probably also need to look for some side project which you can do with some other devs as it will give you more experience and interest to work on and learn new things in the language. In my opinion you probably going to get more out of working with some other people ( even if they are not very experienced ) 
Looks nice. Can I suggest to replace code snippet image with the actual text? Right now it's unreadable.
&gt;The current problem requires a 2D array and I'm wondering if I should try and use the native Rust data structures You could use a `struct` that wraps a `Vec` and implement `Index` and `IndexMut` to return a slice. There's a couple of good lessons about Rust to be had there. 
I was wondering the same thing and I found the hint in docs for DoubleEndedSearcher: &gt; All results of next() need to be identical to the results of next_back() in reverse order. next() and next_back() need to behave as the two ends of a range of values, that is they can not "walk past each other". If we split "baaab" on "aa" in the backward direction, we'll get a different sequence.
I think I've figured it out, broadly. Seems that WebAssembly doesn't like the C libraries which are presumably used in this crate. So no Oracle for me. Oh well. 
Thanks
Ooh interesting! Do you have a use case you’re targeting?
Looks like `cargo-sweep` is not automatic: has to be invoked manually. Would be great if Cargo could be configured to invoke it automatically.
Interestingly it renders better now for me (same device, same browser). Five eights looks identical to half, but otherwise, it's perfect! I do get your point though. Not all fonts provide all glyphs, and some might not fit together perfectly. Reminds me of one time that some software failed to display a space for me and displayed the unicode box that says "0 0 2 0" instead. Not everything is perfect
I have a library I’d like something done in and if the task sounds interesting to you I’d be happy to help you learn how to do it. Pasting below what I said about it before: — I have a small rust library for generating 3D meshes: https://github.com/turnage/immense. I’d love to hook it up to a 3D mesh viewer to get real time updates to the mesh users are working on. Right now they have to click refresh in a 3rd party viewer. I think adding a viewer is a relatively small but interesting project. Uses some 3D math, touches on IPC, some just-beyond-novice usages of traits and lifetimes, and some basic GPU usage. If you’re interested I’d happily be available for some calls to discuss it, answer your rust questions, etc.
Really excited about this project!
I do seem to recall looking at it last year or so. I was writing a shell for hashicorp vault, but I think it did not support windows and I wanted windows use, so I went with rustyline. Now I do not use windows at work so that was not a factor in deciding which library to use. Although now in hindsight I should have chosen something cross platform. I'm not sure if linefeed supports windows or not.
Examples on how to handle errors and timeouts on a remote MySQL server using mysl-symple? 
[removed]
There's Integer32, a Rust consultancy. Don't know how expensive they are, though.
Hi! I'm trying out some Web Scraping using [select.rs](https://github.com/utkarshkukreti/select.rs). It's been working great but I'm stuck on a simple task: get a text out of div. Here is the code: &lt;div class="container"&gt; &lt;div class="top"&gt; Nope &lt;/div&gt; Content that I want here &lt;div class="bottom"&gt; Nope &lt;/div&gt; &lt;/div&gt; Is there a way to query only the content of "container" div while ignoring the other divs? Follow up question: how can I contribute to the documentation of that crate? Thanks a lot!
Damn. That's very good
Continuing work on [Cratify](https://github.com/twilco/cratify), a web application I'm creating that allows you to subscribe to receive e-mail notifications when another crate starts depending on yours, or to receive a periodic summary e-mail listing crates that depend on yours. Sign up and log in functionality now complete front-to-back, minus session management, which is next on the chopping block! Also thinking about using Advent of Code as an excuse to finally learn Elixir.
That makes sense to me, thanks.
&gt; It is annoying though, just like how docker will slowly consume all of your disk space unless you manually prune your docker installation. ughhhhh :( 
Which PR?
https://github.com/rust-lang/rust/pull/56005
Can we make custom tool lints?
Thanks for the response! I agree that \`Point + Point\` is a weird case and probably not necessary. Even so, that still leaves three other cases so I'm interested in whether there's a way to do this cleanly :-)
Holy cow that's one of the dumbest things I've ever seen. They (or at least the reddit OP) wants there to be just one format that all data is sent through, that being HTML, and the element classes would provide data for the """"API"""" consumers to target with `querySelector`. Why though?
Thanks for the response! I should have mentioned that I did consider using a macro and would prefer not to because I find them hard to debug. That said, using a macro is looking like it's the "right" way to do this. &amp;#x200B; I like your approach of having all implementations forward to the one based on references!
Wait, so you want someone to teach you programming from A-Z, in their spare time, once a week? I’m going to be extremely blunt here. That’s not going to happen. You won’t learn programming at that level in a lifetime let alone occasionally throughout the week. Have you tried any online resources? I’m going to recommend one for you. https://www.freecodecamp.org/ As well as their YouTube channel. https://www.youtube.com/channel/UC8butISFwT-Wl7EV0hUK0BQ
Anyone has benchmark cool start time between Rust vs Go on AWS Lambda ?
You could always throw your hands up in the air and use a hashmap of 2-tuples of ints. Not gonna be performant though...
The whole point of Rust is that it doesn't trust you to manage all that (non-nil pointers, cross-thread communication) yourself: everything in the Rust standard library is safe to the point where if you follow the documentation and handle errors that arise elegantly, you will *never* have a runtime error barring some crazy circumstance. [Here's a section of the first edition of the Rust Book that you may not have seen](https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html#meta). It discusses pretty much what you're having troubles with: you know that what you're doing should be safe, but the compiler is telling you it's not. &gt;Many new users to Rust experience something we like to call ‘fighting with the borrow checker’, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer’s mental model of how ownership should work doesn’t match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less. It also seems like you're also coming from more lax, garbage-collected languages, where you didn't need to think about memory management very much at all. I also came from that kind of background, and I know that this is a large shift to make to dealing with low-level-ish memory management; you have to really think about where the data you have needs to be used, and how long you need to keep it for. You say that you understand ownership, and I don't mean this to be *ad hominem*, but I don't think you really do. I'd recommend re-reading the [ownership section](https://doc.rust-lang.org/book/2018-edition/ch04-01-what-is-ownership.html) of TRPL, and really familiarize yourself with all the concepts it discusses. [Here's an article](https://medium.com/@bugaevc/understanding-rust-ownership-borrowing-lifetimes-ff9ee9f79a9c) that explains this much more in depth than I am here, and compliments the Book. Rust can really be a very elegant programming language once you get the hang of it, and I wish you the best in your learning.
Looks like `slice::align_to{_mut}` were actually part of the 1.30 release? (But not in the relnotes?) 
`mean_median_mode` does too much. The functions should preferably be split up into separate `mean`, `median`, and `mode`. You do lose the optimization of doing everything in one pass, but in general functions should only do one thing. You should (generally) avoid using `clone`, as you're duplicating the amount of memory this function needs by two times. You use too many mutable variables. The code can be significantly reduced using higher-order functions. You should never pattern match `Option`. There are helper functions to extract a value or default value that you should use instead. I'm on mobile and I honestly only read up on Rust the other day, so I can't give you more specifics off the top of my head, but those are the immediate things I see that could be improved. 
You can't expect performance for free ...
&gt; mean_median_mode does too much. The functions should preferably be split up into separate mean, median, and mode. You do lose the optimization of doing everything in one pass, but in general functions should only do one thing. That is certainly a nice guideline, but not an absolute rule. For data processing like here, it can be absolutely essential only to loop through once. &gt; You should (generally) avoid using clone, as you're duplicating the amount of memory this function needs by two times. In particular, here the first loop can be changed to `for &amp;num in &amp;numbers` without any other functionality lost. &gt; You should never pattern match Option. Another absolute statement - let's rephrase that to "use the combinators (here, `unwrap_or` would be applicable) if possible". There are, however, plenty instances where a pattern match is the most readable solution.
Very cool. I don't know what I'm going to use it for, but I'm going to use it. 
You've specified `: i32` in 3 places where I'm pretty sure type inference would take care of you. `mode_key` doesn't need to be optional, you can set it to `0` initially and have the same effect. Note that you don't read from it until the very end when you determine if it needs to pick up a default value. You can just begin in the default state. `for num in numbers.clone() {` this is a bit odd; you don't need to clone a Vec to iterate over it. For this case it suffices to use `iter()` or `for num in &amp;numbers` and in both cases `num` will become a `&amp;i32`. In this way your iterator borrows and inspect the container instead of taking ownership and stealing its brains. l`et median: i32 = numbers[middle];` will panic if `numbers` is empty. Is that the correct decision for this function? It's fine to have an API that requires the Vec to be non-empty, but it's also reasonable to return an `Option&lt;NumberData&gt;` which is None for empty input.
What terminal/theme is he using? It's beautiful!
I applaud your initiative and approach. Cheers
Keep studying libraries in the ecosystem. Search them out and read them. Then you'll have more tools in your tool-belt. 
Rust certainly has the capability to increase your performance, but there is no guarantee. For instance, node.js is already very optimized for IO-bound workloads - if you don't need heavy computations or if those computations are not blocking you, rust might not increase performance much. That said, rust could be of great benefit. If you have some parts of your app that do heavy computation, I'd recommend _trying rust_ by just porting one of those parts and using it from JS. There are good libraries for turning rust code into a node.js module, so you won't have to rewrite your entire application. With that said there are other reasons for choosing rust too, besides performance. Rust has a very nice type system, and it's compile-time assurances are second only to Ada (and, well, a few other similar niche languages).
iterm with some custom colors
I've heard that NLL is supposed to be in 1.31. Is this still the case? If so, that seems like a rather glaring omission for what I think is a significant change!
It's those little conveniences I look forward to - conversion from `&amp;Option&lt;T&gt;` to `Option&lt;&amp;T&gt;` is a nice one.
Nothing to do with Rust, so maybe this is out of scope, but two algorithmic notes... You can find the median without sorting: https://rcoh.me/posts/linear-time-median-finding/ If you _do_ sort, then you can find the mode without hashing because repeated occurrences of a number will appear adjacent to each other.
But even with a one-dimensional array, what would you need the x position for? I'll really should have a look in the code, but I'm too busy for now. Maybe later.
Which one was eventually decided on?
I don't think the article actually *needs* to describe UB to that level of detail. As someone with only a very high level understanding of UB, the simplicity of the arguments and examples makes it much easier for me to understand *why* I should be worried about it; not just that I should be worried in general.
For me the widths are fine, but the line spaces differ a lot, most lines are overlapping, the half and full block are shorter than the rest.
It was possible for a very long time using option.as_ref() operation. In this version this conversion is available as impl From. 
Sure, but it was irritating. For some reason I fight with Option a lot - even defined a trait for .unwrap_ref() for cases I was sure about
https://codewars.com gives you small programming challenges and tasks you with writing solutions which are then submitted for public review.
Like `git gc` mhm ?
https://stackoverflow.com/a/42960702
That's how it is with C++ - maybe you were thinking of that.
[Doing](https://github.com/scott113341/advent_of_code_2018) the [Advent of Code](https://adventofcode.com/2018) puzzles in Rust!
Ha! I’ve been working on something similar: https://github.com/anderslanglands/color-space-rs/
How many integration test crates do you have? A common reason for larger then necessary target dir is a bunch of files in src/test. Each file is a separate crate which links in a separate copy of your library. To fix this, create a single multi-module integration test.
It's a workspace with multiple crates, each having integration tests, but not many. Anyway there are eventually many exe binaries produced with different hash suffixes for unit and integration tests, and they are not cleaned up from the debug directory. Same for dependent crates after updating them to recent versions.
I'm interested by the JS error though. Please file an issue for it.
 type Grid = [[u32; 1000]; 1000]; ... let mut grid: Grid = [[0; 1000]; 1000]; Replacing those lines with `type Grid = Vec&lt;[u32; 1000]&gt;;` and `let mut grid = vec![[0; 1000]; 1000];` should fix that with no other code changes needed.
Neither, but they have made the required breaking changes such that either can be fully implemented at a later date.
Colors are solarized though I'm guessing you knew that.
I also have problems with the Iterator page. Not only is it very slow to render initially, but due to the sheer amount of content on the page, it is also very sluggish to scroll through on my system. I'd very much prefer if trait implementors were just listed plainly like so: `Implementors: std::ascii::EscapeDefault, EscapeDebug, std::char::EscapeDefault, EscapeUnicode, ToLowercase, ToUppercase, ...`, with them being links so you can click on them to go to their doc page. This amount of duplication is a lot of wasted data. It makes the documentation bloated and slow.
&gt; only the content The content you describe are also nodes called _text nodes_. document .find(Class("container")) .children() .filter(|child| child.is(predicate::Text)) Disclaimer: I haven't run this code, I hope it runs.
Well... woops! :D
Thanks a lot! I'm going to try it
I made some edits. Also, this gives you an iterator of `String`s.
I would add: read the standard libraries. I remember that a lot of stuff made sense when I looked at the source for `Iterator` - the actual code is less scary than the function signatures.
Go and ask r/playrust, but I would suggest checking out 7 Days To Die, if you're into zombies and building.
In the Readme, the author proposes sending them an email if one has any suggestions on their crate. Or you directly open a pull request in which you add more doc-comments. However, I don't know how long it takes to be reviewed and finally merged.
The first bullets encompasses a lot of things, NLL is one of them.
thanks!! I'm not sure if I'll have the time now this trip, but I'll plan for it next time.
Hm. I don't think the link on that bullet point is a very accessible way to explain what it entails. I propose that the release notes are updated to include an explanation of what the 2018 edition includes.
There is a very good reason why `git gc` is manual only: it is the only operation that can actually cause you to permanently lose data that has been checked in at some point. All other operations in git can be undone, if you know what you are doing. The same reason does not exist for cargo-sweep: compile artifacts are by definition something that can be recovered by recompiling the sources.
API design wise, I don't think calculating mean, median and mode should use a `mut` argument.
&gt;You've specified `: i32` in 3 places where I'm pretty sure type inference would take care of you. Is that necessarily bad though? I sometimes write those for the sake of informing the reader rather than the compiler.
Hi, &amp;#x200B; I'm trying to make a .dll that Excel could call. &amp;#x200B; The working C equivalent .c file looks like this: &amp;#x200B; [https://pastebin.com/mRrtjdJb](https://pastebin.com/mRrtjdJb) &amp;#x200B; and .def file looks like this: &amp;#x200B; [https://pastebin.com/6Q2QjXK8](https://pastebin.com/6Q2QjXK8) &amp;#x200B; And C version I'm compiling with command: &amp;#x200B; `cl /LD /O2 excelfunctions.c /DEF excelfunctions.def` &amp;#x200B; Right now it feels like I'm facing a wall. There is this \_stdcall between the return type and function name in C version and I can't figure out the syntax and how I should reproduce that in Rust. &amp;#x200B; My latest tryout looks like this: &amp;#x200B; [https://pastebin.com/6DJnPc2M](https://pastebin.com/6DJnPc2M) &amp;#x200B; And I'm compiling with command: &amp;#x200B; `rustc --crate-type=dylib` [`excelfunctions.rs`](https://main.rs) &amp;#x200B; Any kind of help will be appreciated!
Have a look in [This Week in Rust](https://this-week-in-rust.org)'s help wanted issues. Most of them include mentoring, and should you find an issue you want to work on that isn't mentored, feel free to come back and ask for a mentor for that specific project. You'll learn Rust for free while helping the ecosystem.
I used ndarray's `Array2` instead. The `slice_mut()` method is so nice for manipulating the arrays.
Depends on whether you care about the particular type. It's pretty obvious that `sum` and `median` are integers; does the reader really care that they are specifically `i32`?
Isn't this what cargo clean is for??
Firstly, you have to specify the "stdcall" ABI and add `#[no_mangle]` so the exported function can be called. Secondly, you've got the argument and return types mixed up; it should *take* a pointer to a double and return one by-value: // unsafe because we're dereferencing a raw pointer unsafe extern "stdcall" fn square(x: *const f64) -&gt; f64 { *x * *x }
To be fair, the reason I'm doing "mean median mode" - a simple program - is because I'm trying to learn Rust. &amp;#x200B; I'm still not 100% sure where type annotations are required and where they are not. In this case, I figured that because a sum \*could be\* i32, or it \*could be\* u32, it's best to specify signed integer. 
Here's my [take](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=45b77f929492aaa965d53a4bbacbcfb4) for what it's worth. Note that none of the statistics are really defined on the empty vector: my code returns an `Option` for this reason. I preserved the imperative style of the original code. There's an argument to be made for a functional style here, but it would likely be multipass and computing the mode gets tricky. If you go this route, I'd suggest using the `Itertools::group_by()` method from the `itertools` crate as a convenience.
Keep in mind, I'm still learning, so I didn't know about unwrap\_or or here. (still don't actually... I'm only on chapter 8 of the 2018 rust book, doing the excercises as I go.) Pattern match was the only tool that was covered so far, so I used it. &amp;#x200B; If this were JS (my "native tongue"), of course I'd use higher order functions and break up mean, median, and mode, but this was just a quick exercise to see if I understood what had been covered so far - Vectors, hash maps, etc. 
Yep, it actually helped turn [this](https://github.com/Pzixel/boyan_detector_bot/blob/c550be648c7c919673cb0757bb27b76b09d262cf/src/main.rs#L131) into [this](https://github.com/Pzixel/boyan_detector_bot/blob/df49fee1a9ed754eb5d2c5c9b148e12b6177dfab/src/main.rs#L164). Feel the difference as they say... :)
&gt; you don't need to clone a Vec to iterate over it. Also on the subject of vecs: it's generally recommended that functions don't take a Vec unless they absolutely need to as it unnecessarily limits possible inputs. Here a `&amp;mut [i32]` would work just as well as input to `mean_median_mode`.
Thanks for your input! However it's still not working for some reason. In some point I had #\[no\_mangle\] there and I was also importing a pointer, but "my version" has been living quite a lot during the process (I've been trying a lot of stuff back and forth). However it didn't come to my mind to use unsafe in any point. One of the biggest problems is that Excel only states error code 48 and tells that the file cannot be found. It does find the C version however (and it works) if I use the same name, so there is something in the .dll that does not add up. Debugging this is a nightmare since I'm not getting any hints what's going on behind the curtains :) In C version's .def file the library is given a name and functions are being explicitly exported. I suppose "extern" is doing the export, but do you happen to know should the library have some kind of metadata inside it (such as a name) that's necessary for it to be recognized or something? At least C compiler is being nit picky if I try to use different name for the library then the filename and I was wondering if the key lies in the metadata.
The function is taking ownership of a vector. Whether the function decides to mutate it or not is its business. In other words, `mut` on the pattern side of function args isn't part of the signature. Of course, the question can be asked if `Vec&lt;i32&gt;` should be `&amp;[i32]` instead...
At first I would use a tool for looking at PE files (dependency walker from sysinternals comes to mind, but there are certainly better ones nowadays), to ensure that the exported functions look exactly the same.
Sounds like an adventure. I'll try that, thanks!
\`actix-web\`
Iron is pretty legacy, and Rocket only works on nightly rust. If you want something simple that works, and don't want to bother with the complexity of futures, then I've found `rouille` to be quite easy to use.
Thanks!
Any info on what it entails? 
Why do you like it?
Tried to open the file with dependency walker, but it crashes. I also noticed that the .dll is huge (some 3MB) while C version is only 72KB. I think I'll put this on ice for a moment. Already spent one whole day debugging this and if the .dll will be 3mb with only few lines of code (even with --release), I think I will reconsider if I should just go with C for now.
For 2018 code only, yes.
AFAIK Iron is abandoned with no plans of future work.
It's easy (I'm not using async) and works on stable.
Cool, I will check it out :)
I think the same reasoning applies, why supply \`Point + &amp;Point\`, when the caller can simply make a reference out of the first one anyways? You're copying out the data to construct a new Point in any case, so there's nothing to be gained by ownership here.
Iron is abandoned, Rocket is nightly-only and sync. I'd switched from Iron to actix-web easily.
You can try annotating the function with `#[export_name="squarec"]` instead of `#[no_mangle]`. There's some discussion on this kind of stuff in the following issue: https://github.com/rust-lang/rust/issues/17806
Cargo only has the \`clean\` command at the moment. There is some discussion: [https://github.com/rust-lang/cargo/issues/5026](https://github.com/rust-lang/cargo/issues/5026) &amp;#x200B; I use a couple of bash scripts run daily with systemd user timers. clean project ./target dirs: [https://gist.github.com/alexheretic/d6360c8cc848cc32daf8f26423f17689](https://gist.github.com/alexheretic/d6360c8cc848cc32daf8f26423f17689) clean .cargo caches: [https://gist.github.com/alexheretic/661cb78b49ca280c629c64be0fabf8d2](https://gist.github.com/alexheretic/661cb78b49ca280c629c64be0fabf8d2) &amp;#x200B; They're a bit crude, but basically allow me to forget about the issue until there is a better way to handle it.
Thanks. Tried that too, but still same error (48). I think the problem lies here: [https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/error-in-loading-dll-error-48](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/error-in-loading-dll-error-48) It seems it should be a "Microsoft Windows DLL" and not only that, even the early Microsoft Windows DLLs are not compatible. I bet the reason is not in Rust but in compiler. Maybe I'll try to build the C version with gcc in some point instead of cl to see if it's the language/user or the compiler. It could be that the DLL has to be built using Microsoft's own compiler which will put a secret "Genuine M$" tag there.
woohoo, nice!
Is he also using ZSH? I’m always trying to figure out how to tell when someone’s using zsh instead of bash. I want to switch but I don’t really see anything wrong with the way I use bash
Thank you! Your code helps me a lot.
This is great thank you
[Hello World Example](https://github.com/tomaka/rouille/blob/master/examples/hello-world.rs) It even has a [Websocket](https://github.com/tomaka/rouille/blob/master/examples/websocket.rs) example. 
I vaguely remember reading somewhere that you need the rust source installed for that to work. It might be as simple as \` rustup component add rust-src\`
Yeah this is being discussed in https://github.com/rust-lang/cargo/issues/5026 TLDR: cargo currently doesn't do any gc ops, it could in the future, but not everyone agrees we wat it to.
That's cool. I've not gotten into SPDs and using the actual color matching functions yet, but I plan on doing those once the rest is satisfactory. Is your spectral path tracer up anywhere?
Another example of a surprising , but according to the language standard allowed ,because undefined behavior is involved , optimisation is the following: https://gcc.godbolt.org/z/3oeng7 One thing that bothered me in the article a bit is the use of O9. GCC and Clang don't support anything higher the O3 and O9 will be interpreted as O3 
Rocket isn’t synchronous, it runs (by default) 2 * (# of cores) workers.
We’re using actix-web and are super happy. Would use again :)
`extern crate` is going away in the 2018 edition (coming in the next stable release of Rust). 
Here is a bit more on this: https://rust-lang-nursery.github.io/edition-guide/rust-2018/module-system/path-clarity.html
Looks good to me, except "A ls..." in `main.rs`. I'd use "An" since I (and everyone I know) pronounces it "el-ess".
My mistake. I thought 2018 only removed the external keyword need ie “extern crate foo” -&gt; “crate foo” . 
Looks great! Code is very legible. The only feedback I can even think to give is that it could use some tests, but idk how necessary that is. Good work.
I used Iron when learning Rust originally, since then I'm working in Rocket and Actix. I really like both, both are incredibly fast and easy to use. I would say though that Rockets documentation is much better than Actix. However, Rocket doesn't support generics in endpoints currently, which hampers tests. &amp;#x200B; If you're looking for something to put into production, I'd go with Actix. If you're looking for a toy to learn from, I'd go with Rocket, the documentation is better and it feels more "Rusty" 
I'm also using actix-web for a project. It's taking some getting used to (i mostly code using expressjs with node). But I do like it. Just figuring out how to structure things, write tests effectively, etc. :)
https://wiki.alopex.li/AnOpinionatedGuideToRustWebServers Rather outdated now, I need to make a refreshed version. Summary: `rouille` for simple stuff, `rocket` if you are okay with nightly, and give `actix-web` a good try too and see how you like it.
Reminds me of the other Rust ls replacement exa, though that one has seemingly stalled on development. 
It used to be worse. docker.qcow2, the virtual file system for docker, used to only ever increase in size. Pruning freed up space inside it but didn't resize the volume. Wonderfully they fixed that.
I'm using rust for advent of code again this year. I have the project structured like so: `1/ Cargo.toml src/ 2/ Cargo.toml src/ ``` And so on. In VSCode i have the folder open that contains the code for each day. However, it doesnt show me the RLS output when i save each one, i guess cause it's under a nested folder for a different binary? Is there a way to configure it to work with multiple cargo files? Or do i need to open the day solution folder directly?
I find this opinion very surprising. I'm wondering what languages you are coming from? In my experience Rust's basic tools are top-notch by comparison to many other languages. &gt; why am I installing and running a package manager (Cargo)? Am I setting myself up for trouble by just "compiling" my code instead of "packaging" it? Cargo is both a package manager and build tool. I'm not sure what you mean about compiling vs. packaging, but if you aren't using cargo to build your project I suggest you do so. When you start getting beyond a single file, Hello World type program, you will probably want its features. &gt; Why are there so many versions of Rust? (Nightly, stable, 2018, ??) Am I on the right language version? Will I ever learn the nuances of which language version I should choose? Yes, you will learn. It's much simpler than you might be thinking. For now, just use stable. You aren't missing anything spectacularly necessary by doing this and you will learn enough to understand why you might want nightly. &gt; There are so many tools it seems like I should be using. Clippy? Rustfmt? Surely these are good to use, but do I need them to get through the language tutorials? You don't need to use these tools. rustfmt formats your code for you into a nice standard style and clippy finds common mistakes or points out bad practice. You will probably have an easier time using these by using something like Visual Studio Code with RLS which will install them for you and integrate them with the editor.
Only for most things. If you're using something with proc macros, you'll still need extern crate, like with Rocket.
Ugh, I consider it to be unbalanced. I mean, build times are _way_ too short, and it breaks everything.
W00t! Everything works well for me so far.
Type inference will work _most_ of the time, and one of the nice things is, if you as the creator of the variable don't care too much about the type, you can leave it up to the calling function. Eg ```rust fn sq(i: isize) -&gt; isize { i * i } fn main() { let i = 2; let j = sq(i); // This line allows the compiler to infer i and j are both isize } ``` If the interface for `sq` changes, it won't matter to the calling code. This gets more complex with Generics however, if it was `fn sq&lt;T&gt;(i: T) -&gt; T`, the compiler can't guess what T should be. Then specifying the type is more important. This can be done one of two ways. Using the turbofish `sq::&lt;isize&gt;(i)` or by simply telling the compiler the type manually, `let i: isize = 2`
You should also post it on /r/unixporn 
&gt; I'm wondering what languages you are coming from? In my experience Rust's basic tools are top-notch by comparison to many other languages. The furthest I've ever gotten through a proper "learn a language" tutorial was with C. With C there is "a compiler" and you hit "build" and it builds. There is no special knowledge to gather besides two "booleans": "Do I have a compiler?" check. "When I hit compile on something trivial like 'Hello World', does this produce an executable that works?" check. And you're set. You can focus entirely on the language at this point. With Rust, there is a whole bootstrap script to get Rust installed, then you have to learn a package manager and manifest system... There's lots of options to tweak here and decisions to make. I'm sure this is great for complex projects, but as a first programming language and no formal training, every extra step kind of makes some people (myself included) want to give up. The reason is doubts can creep in and you start thinking "I've probably done something wrong." I'm also comfortable with bash, since you just write the file, make it executable and run it with ./[filename]. There is no tooling to speak of. You just learn the bash or sh funtionality and you're off to the races. Ruby is easy because it's interpreted so there is no compile step. I use Ruby in the context of Ruby on Rails, and if your web app runs without bugs you did a good job. Add in continuous integration tests (that other people wrote) and I can be confident I haven't broken anything. I would summarize my assumption about how to fix this as follows: The defaults need to "just work" (and as far as I can tell they do), and the tutorials should say (explicitly) that the defaults are fine, that most of the defaults are *the* correct or easy way to learn Rust, and that they are perhaps explained in a later chapter. Also: I think you can run "rustc" instead of building with cargo, and that is so much more familiar to a basic C programmer (than a full-on packaging system) that I think the tutorials should encourage folks to start that way if it helps them get the ball rolling. Perhaps the rule of thumb can be: If your code is lives in multiple files, it's time to start using Cargo. I don't think Cargo is needed for "Hello World" and other early coding exercises.
Firstly, welcome to the community! Editing scripts to fix bugs is where many of us started, it's good that you're somewhat familiar with the core concepts. Hopefully we can help out with any rough edges you're finding. There are a lot of tools around Rust and it's understandable that it'd overwhelming if you look at the whole ecosystem at once. Things like cargo exist to help you through it though, my advice is for the time being ignore the fact that things like rustc exist until you're feeling a bit more confident (honestly I literally only use it to check versions and I don't think I even need to do that). I think everyone learns differently, but I found Rust Book 2 a great place to start. I'm told that the newer 2018 edition book is better still. Both versions are free online here https://doc.rust-lang.org/book/ Second edition is also available in dead tree format. I've also found the community to be one of the friendliest around, if you get stuck, asking here, on StackOverflow or even on Twitter will usually get you help pretty fast. Good luck and have fun! 
Just finished my first project in Rust (an arithmetic calculator). It was good to complete the process from beginning to end. Now I am trying to decide what my next project should be.
&gt; I find this opinion very surprising. I'm wondering what languages you are coming from? In my experience Rust's basic tools are top-notch by comparison to many other languages. OP said they are comfortable with bash scripting, and capable of editing existing ruby scripts. 
Here ya go! https://rust-lang-nursery.github.io/edition-guide/rust-2018/index.html
I don’t think so. With rocket and 2018 edition I just “use” to import the macros.
It looks alright but 88 dependencies (transitive). Seriously?
Crashes when listing directory with a broken symlink :) Otherwise, interesting project.
how does it compare to exa? https://the.exa.website
&gt; Tried to open the file with dependency walker, but it crashes. That's a pity. It might be trying to demangle symbol names, and fail on some Rust idiosyncrasy... &gt; P.S. Found this. It seems that Excel is very picky on the dll's (: These requirements don't seem very strange though. The "early DLLs" it's referring to are likely relics from 16-bit Windows times and not relevant to modern OSs.
Thanks! Do you or anyone know if the "living edition" has all the improvements from 2nd edition/ "The Book 2"?
Looks cool. You should note there is no windows support in the README. And I would love a depth parameter for the \`--tree\` option.
&gt; Quality of code is strongly emphasized in the community. Would I live up to that standard if I started writing Rust? It's important to separate quality of code that you write as you're learning from code you publish and expect to be used publicly. And even in the latter case, you're never going to be perfect - it's far better to work within a community that'll help you grow and improve over the long term. The emphasis on code quality in all its various aspects is hands down one of the best parts of the Rust ecosystem. We can't compromise on that to make people feel more comfortable - and in fact, I think that would be largely counterproductive, despite your initial worries. &gt; The saturation of really knowledgeable programmers in the Rust programming language community is intimidating I feel similarly here. The community is incredibly knowledgeable, and _that's a good thing_. You've got to shift your attitude from seeing that as intimidating to seeing it as an incredible resource to be tapped. Maybe focus on people's attitudes rather than their knowledge? I've seen many communities where so-called beginner questions are meet with derision and scorn - something that rarely happens in the Rust community. Some of the big Rust projects (I'm thinking specifically of `rustc` itself) even have specific chunks of work carved out for beginners, with a person standing by ready to be a mentor. Compare that to a project like gcc or the Linux kernel... &gt; Any words of encouragement? Don't give up! There's no way around it, Rust is a difficult language to master. But at the end of the day, _you can do it_. Write a lot of code. Write bad code. Write good code. Make mistakes. Seek feedback, and develop your own intuition and opinions. There's no substitute for just doing!
Synchronous (in this context) means that each thread is only handling one request at a time. 
Ruby on Rails is a web application framework. Rust is a programming language. You can (try to) make a website without programming, but you definitely can't do programming without programming.
You can still do the same with Rust. Just `rustc main.rs`. You'll quickly find this to be lacking tho. Rust is not batteries included. Cargo makes installing dependencies super-easy.
Changed! Thanks for the review.
I think you can also this now: some_crate::some_macro!(/* */);
I've been using that as an ls replacement for many months. I like it. 
Yep, this is one of the next step. But I don't really know how to do it easily. If you have any ideas of example I take it.
It does - it's strictly newer as far as I know.
It should have. The second edition of the book is, I believe, just the "living edition" as it was when Rust 1.21 (I think) came out. But let me summon the lead of the Documentation team for you: /u/steveklabnik1
Arf... Indeed... Issue created -&gt; [https://github.com/Peltoche/lsd/issues/2](https://github.com/Peltoche/lsd/issues/2) &amp;#x200B; Thanks for the report!
Yep! And as of the next release, they’ll be reunified, and we’re only shipping one edition, the living one.
&gt; If I am just compiling "Hello World", why am I installing and running a package manager (Cargo)? Every program *bigger* than "Hello World" is probably going to need multiple files or external libraries, and then running `rustc` or whatever by hand becomes obsolete anyway. In C you would use a tool like `make` to build and link multiple things automatically, and dealing with external libraries is still awful. Cargo takes care of it all for you, so it's the default. You *can* run `rustc` by hand (just do `rustc src/hello_world.rs`), but it doesn't really get you anything useful over just using Cargo. &gt; There are so many tools it seems like I should be using. Clippy? Rustfmt? Surely these are good to use, but do I need them to get through the language tutorials? That's a good question. I'd consider them "there if you want them". If you don't want them, or just don't want to deal with them, that's fine too. I find that clippy tends to offer interesting suggestions for *better* ways of doing things, which can be a nice learning tool, but it's not necessary. &gt; Quality of code is strongly emphasized in the community. Would I live up to that standard if I started writing Rust? Of course! One of the interesting things about Rust is that almost everyone using it has learned it from scratch within the last 2-3 years. Figuring out what "high quality code" even looks like is still a bit of a work on progress. ;-) Though a lot less so than in 2017, fortunately. Part of the nice thing of Rust though, is that writing bad code is actually harder than good code. &gt; Much of the material written about Rust goes way over my head. Despite Rustaceans actively priding themselves on being welcoming and interested in how beginners will do when learning Rust, I wonder: Is the Rust community for me? Or is Rust just a language for other veteran programmers who want to build something better than what they had before. ...and that's the down side of everyone using Rust having learned it in the last 2-3 years. It tends to attract experienced programmers and neophiles who rapidly dive into the complicated, nitty-gritty stuff because the less complex parts are very close to things they know from other programming languages. There are a number of "learn Rust programming" tutorials out there, but many fewer "learn to program, starting in Rust" ones. Personally I don't even know how I would begin to write a "learn to program, starting in Rust" tutorial, because I barely remember what it's like to *not* know how to program anymore, and because I'm so used to teaching myself. **But this is not your fault.** People aren't going to think you're dumb or incompetent just because you haven't been programming for over a decade. We all take different paths in the road of learning, and go down them at different rates... but we all start in the same place. Lots of rustaceans love teaching and helping people as well. You being a part of the community will just make the community better at helping people like you, and who have the same concerns as you.
Can't be installed on my Arch. :(
exa is more mature and have some cool features like \`-G\`. It clearly does the job but it doesn't have the icons support and the pretty colors for example. It's more a taste question for me.
I've had a bit of a realization in this thread, while trying to explain why learning programming is so hard. Most programming lessons online COMPLETELY skip properly explaining the concept of code re-use and dependencies. (With the benefit of hindsight I see: That's why we have Cargo. That's why we #include things in C. That's why we jump so through so many hoops.) I think Rust should pull ahead of the pack of other programming languages and do an A+ job of explaining this to newcomers. Programming is advertised as a "rockstar's" discipline; You go in, write some killer code, and everyone sees you as the amazing coder hero. But when so much of a program is re-using good-quality libraries (not re-inventing the wheel)... You have to learn dependency management. No-one goes out and writes their whole program from scratch. But I as a beginner had assumed this to be the case. None of this was obvious to me before I got into open-source, (e.g. my Rails project has lots of "gem" dependencies in its "Gemfile"), but in hindsight, this seems to apply to the code individuals write too.
You can run rustc by hand, but it becomes impractical exceedingly quickly. There is also no point in time during the learning experience where rustc would be less of a hassle than cargo, even with just a single file and no dependencies you still want to pass in parameters. Cargo is probably number 2 on my list of reasons why I got interested in rust. With cargo, all you have to do to get started is "cargo new hello\_world" and "cargo run". As for your last paragraph, I'm not really sure what you mean because I think that's precisely what cargo does. Btw, there's also [https://play.rust-lang.org/](https://play.rust-lang.org/) if you just want to try some code online. Personally, I think what would benefit new users the most would be a short, concise step by step guide to get VSCode + RLS working directly on [rust-lang.org](https://rust-lang.org). Preferably ending in a link to a similar guide to get debugging working properly. 
I made a comment here: https://www.reddit.com/r/rust/comments/a31hk4/feedback_from_a_beginner_rust_tooling_is_sort_of/eb2rfx9 tl;dr I just suddenly realized code-reuse and dependency management is taken for granted and not really explained in most "intro to programming" resources. I think it would be GREAT if Rust's docs explained this for those of us new to the game entirely.
Thanks!
Good luck in your pursuit. As someone that is largely self-taught (I went to university and studied Computer Science, but I was quite familiar with the topic beforehand), I can't say this enough: Experience is the best way to learn. Think of something cool you want to make that gets you excited, and give it a go. Do some research, figure out how hard it might be, take a look at similar things others have done, and use your own initiative to get the thing made. You'll become far more familiar with things far more quickly than any one-to-one education process will permit.
Issue created -&gt; [https://github.com/Peltoche/lsd/issues/3](https://github.com/Peltoche/lsd/issues/3) &amp;#x200B; Thanks for the report!
Sorry to hear that... What's your problem ? Do you have any kind of error message or log?
Right now your main loop kind of mixes traversal and display. You might consider factoring the app into two big parts, the "traverse directories and emit a stream of metadata objects" part and the "fancy display" part. Most of your interesting, tricky, and platform-specific test cases can run against only the first part, things like symlinks, recursive mode, permissions errors, sorting, and filtering. Then you can use a smaller number of tests to exercise the display side to make sure that e.g. your tree view gets its indentation right. One big upside here is that when you change your colors or other formatting (probably more common than changing say your symlink behavior), none of your really tricky tests need to change, because they're only consuming the structured metadata and not the formatting.
&gt; Programming is advertised as a "rockstar's" discipline; You go in, write some killer code, and everyone sees you as the amazing coder hero. But when so much of a program is re-using good-quality libraries (not re-inventing the wheel)... You have to learn dependency management. This. The more time I spend working with mechanical or electrical engineers the more I realize: programming is one thing, but *software engineering* is something very different. Programming is knowing how tools work and solving small-scale problems, software engineering is designing/choosing tools and solving large-scale problems in a way that can be proven to work. Which is exactly what *every* other engineering discipline does already. The world is still learning how to do software engineering well. To me it looks a lot like mechanical engineering did in the 1850's, where you could have machines all built from the design by the same people, but if you wanted to actually use parts from one machine in another one you had to tweak and alter those parts by hand.
If the docs are slow, you can always generate rustdoc pages and view them locally in the browser.
I think the RLS supports cargo workspaces by now: https://doc.rust-lang.org/book/second-edition/ch14-03-cargo-workspaces.html
Just a heads up, I don't think you actually linked to [rsevents](https://github.com/neosmart/rsevents) in your post, just `rsevents-extra`.
Not yet, no. It’s still very early stages as I’m mostly working on the internal machinery,I.e. trying to find a satisfactory way to represent a scene graph in Rust. 
I see! so why didn’t you add icons in an exa fork? Just wondering ☺
There was a proposal to make “crate” a visibility modifier but it ended up not being fully accepted yet.
\&gt; There is also no point in time during the learning experience where rustc would be less of a hassle than cargo, even with just a single file and no dependencies you still want to pass in parameters. &amp;#x200B; Hmm. As a total beginner programmer I beg to differ. &amp;#x200B; rustc is a single self-contained executable (or presents itself as such...) that spits out... a single self-contained executable. The mental model here of what I've accomplished is SO MUCH more compact. When I learn something, it's hard for me to trust moving parts that I don't understand, and unfortunately Cargo is a lot of those moving parts. &amp;#x200B; I just want to know that my code works, and eliminating as many variables as possible is helpful for that. That's the benefit of rustc. &amp;#x200B; \&gt; As for your last paragraph, I'm not really sure what you mean because I think that's precisely what cargo does. &amp;#x200B; Hmm. I believe you're right! haha. But it's not really advertised that way, at least not clearly for a beginner. The docs I read (beginning of "The book" 1.0 or earlier) just sort of made it apparent that Cargo could do a lot of complex stuff, and I don't think it emphasized that you didn't necessarily need to make it do all that stuff just to learn programming. &amp;#x200B; I think there does need to be, as /u/icefoxen mentioned [here](https://www.reddit.com/r/rust/comments/a31hk4/feedback_from_a_beginner_rust_tooling_is_sort_of/eb2r023/?context=3), some more "learn beginner programming with rust" tutorials out there. &amp;#x200B; \&gt; Personally, I think what would benefit new users the most would be a short, concise step by step guide to get VSCode + RLS working directly on [rust-lang.org](https://rust-lang.org/). Preferably ending in a link to a similar guide to get debugging working properly. &amp;#x200B; Something along those lines sounds great!
There's a few things you can do, I generally mix and match but that may not be best practice. To start off with, anything that doesn't need stubbing can just have a normal unit test with normal data passed in with the output checked. For things that need stubbing, you'll want to make some thin Trait wrappers around them that can be mocked. For mocking here's a few things on offer, here's a good article that covers most of them https://asomers.github.io/mock_shootout/ I've been using Simulacrum with some success. Eventually it might be good to move what tests you can into documentation. In order to have rustdoc run the tests though you need to split the code into a library and a binary. You can do this easily by changing your fn main to fn start, changing main.rs to lib.rs, then making bin/lsd.rs extern your crate and call start. Again, can't speak to if this is best practice or if there are any negative impacts from doing this, I do it so people working on the same codebase can look up code easily, and examples provably work. Note, best not to compile in your mocking code so mark the extern with a #[cfg(test)]. This does mean rustdoc won't have access to it though so you can't use mocks in your doc tests. 
That’s modern civilization for you, not even related to programming. Nothing you do or consume isn’t based on something some other human has done. Even if you eat fruit, those fruits were bred by somebody at some point in the past. There is no such thing as starting from scratch. The closest you can come is to design your own CPU on an FPGA and run your apps on that, but even then, the synthesis tools you use were made by someone else and inject their own knowledge into your product.
C (and C++) are really the exception in the programming world. Pretty much every other language has a package manager/build tool. NPM for node. pip for python. gem and bundler for ruby. maven and gradle for Java. Etc. Etc.
Oh, that "git" column is awesome. 
Overloading doesn't exist, but it is possible to use type parameters and traits to pass different combinations of types to the same function.
That worked perfectly! Thanks a lot :)
Thanks for the detailed response! I would say that the C way of "including" is more suitable to small programs, like those a beginner would write, whereas Rust's seems to have more deliberately prepared for more complex dependency management for bigger programs, and seems more modern like NPM or RubyGems. That's all probably for the best, but I think the Rust docs should ideally explain what the deal is with package management and dependencies and such, (for us beginners to programming) since it's got more going on than the C way.
&gt; Rust 2018 is an unusual situation. You happen to be picking up Rust right before a major milestone. What milestone is that?
&gt; The furthest I've ever gotten through a proper "learn a language" tutorial was with C. With C there is just "a compiler" and you hit "build" and it builds. That sounds like you didn't have a "just a compiler", you had an IDE like Visual Studio. Text editor, project system, compiler, all integrated into one nice program. A standalone C compiler doesn't have a "build" to hit. For a single file, it's a pretty simple command, but if you ever get to the place where you need multiple files, or even external libraries, that's no longer the case. Rust doesn't yet have this single-install integrated experience. It's still a bit of collecting all the components together.
Really? I saw some similar-looking conversations, but no conclusions. It doesn't seem to work in [the playground](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=23e23fa873cbfca0ffd71b92b71e86d3).
Seems to panic if the terminal is not wide enough and it's printing in non `-l` mode. `-l` prints line-by-line, as expected. 
I was starting to think the same thing. I also found the current \`--tree\` implementation messy due to the current code structure and your proposition would probably make it cleaner to implement. I think I will try to refactor it this week-end. &amp;#x200B; Thanks for the idea
3 times `error[E0658]: access to extern crates through prelude is experimental (see issue #44660)`
It seems to be a problem with `time`
&gt; What milestone is that? The next version of Rust will support some opt in, and compatible, limited breaking changes. This is the first time we will have this functionality, so there is a lot of buzz around trying the Beta (pre release) version to make sure it works well.
&gt;why am I installing and running a package manager (Cargo)? Am I setting myself up for trouble by just "compiling" my code instead of "packaging" it? There seems to be confusion around Cargo and the compiler, rustc. * rustc compiles code into a binary executable, like gcc for C. * Cargo is a dependency manager. It allows you to use pieces of code others made, and that they published on the internet (on [crates.io](https://crates.io)). You're not setting yourself up for trouble by using rustc directly, but you will have to write your own code for everything your application does.
I found [this blog post](https://blog.rust-lang.org/2018/10/30/help-test-rust-2018.html): &gt;... &gt; &gt;Back in July, we talked about [“Rust 2018”](https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html). In short, we are launching a cycle of long-term milestones called “Editions”. Editions are a way to capture the progress delivered incrementally by our ordinary six-week release cycle – and focus Rust libraries, tooling, and documentation cohesively around it. Editions will be selected roughly every three years: Rust 1.0 was “Rust 2015” and Rust 1.31 will be “Rust 2018”. Each edition has a theme; Rust 2015’s was “stability”, and Rust 2018’s is “productivity.” &gt; &gt;... &amp;#x200B;
I mean, there's only so much you can do with an `ls` replacement. I use `exa` every day and am quite satisfied with it. What more would it need? 
It just not as fun. It started as a toy project in order to code some rust.
\&gt; If I am just compiling "Hello World", why am I installing and running a package manager (Cargo)? Am I setting myself up for trouble by just "compiling" my code instead of "packaging" it? Technically you don't need Cargo, however \`rustc\` is really only designed to compile individual files so most documentation starts you off with \`cargo\` as it provides a lot more features (by wrapping \`rustc\`) This avoids having to write out each file you need and much more importantly downloading packages. On thing you probably never ran into with C is dependencies, they are a huge pain. In contrast cargo makes them super simple. By using cargo you get access to those dependencies without any extra work on your part. \&gt; Why are there so many versions of Rust? (Nightly, stable, 2018, ??) Am I on the right language version? Compiling compilers is hard. Rustup provides easy access to various versions of the compiler. Why so many versions? The primary split is between Nightly and Stable. Nightly is built every "night" and is the latest and greatest of Rust possibly accessible. Stable is guaranteed to build your code basically forever if it works today. Additionally the compiler knows about this distinction and has special Nightly only features that don't have the stability guarantee. Just focus on Stable for now. Reasons to switch are: * 2018 has to do with Rust editions which are like C++11 basically, you can look into those once you have a firm grasp on the basics. * Beta is good for looking at the next Stable release to double check that "stable" is correct and to try out new features coming soon. * Nightly is for when you want the "new hotness" some libraries will be nightly only as it provides some helpful features (such as extra macro support) or something similar. \&gt; Clippy? Rustfmt? Surely these are good to use, but do I need them to get through the language tutorials? Worry about those later IMO. Purely a nice to have. \&gt; Would I live up to that standard if I started writing Rust? I wouldn't worry about that. Striving for perfect code does not mean never writing any code because it isn't good enough. \&gt; Much of the material written about Rust goes way over my head. Programming material like many things is about building on what you know, there are likely some bits that you are missing as a lot of the material is aimed at converting programmers for a variety of good reasons. However don't get discouraged, feel free to ask questions if you need help bridging the gap. \&gt; Is the Rust community for me? Or is Rust just a language for other veteran programmers who want to build something better than what they had before. (The saturation of really knowledgeable programmers in the Rust programming language community is intimidating). The Rust community seems to be pretty open from what I have seen. There are a lot of veterans but I take that as more people wanting the power of C++ without having to actually write C++. Take the vocal experienced programmers as a good thing, when the only vocal people aren't experienced it turns the community sour typically as consensus is harder to achieve. \&gt; What should I do as not only a newcomer to Rust, but a newcomer to programming, if I want to succeed? What should I keep in mind? Where should I start? Write code then write more code, repeat. Once you feel like you have a handle on the basics try writing something. Common choices are CLI tools (because GUIs are massive pains to get correct) or a library. You mention you have bash experience, try converting a complicated script and see how it turns out.
&gt; That sounds like you didn't have a "just a compiler", you had an IDE like Visual Studio. Text editor, project system, compiler, all integrated into one nice program. That's correct. I used Code::Blocks. At the time I couldn't have told you the difference between an IDE and a compiler, so I guess I'm learning it now. :shrug: &gt; Rust doesn't yet have this single-install integrated experience. It's still a bit of collecting all the components together. I wouldn't want it to harm the ability to hack on the individual bots and bobs that make up the tooling, but a more-unified experience would be less hair-raising for beginners to programming.
\&gt; I find this opinion very surprising. I'm wondering what languages you are coming from? To quote the OP \&gt; Comfortable with bash scripting, can edit existing Ruby files to fix bugs in a pinch but barely know what I'm doing aka someone without a lot of experience in more formal programming. Certainly coming from bash rust makes things more complicated.
I'm used to running `cargo clean` as part of my morning routine. That's frustrating.
It has "clicked" for me while writing in this thread that most programs have dependencies, and not just "include this particular part the standard library". &amp;#x200B; I never really got far enough in learning a language to realize this. &amp;#x200B; I've mentioned elsewhere in the thread, but I still think this is valuable info for beginners, and was never really explained properly in "learn to program" documentation that I've read so far. I learned dependency management from "apt install" ing on Ubuntu, and from my Rails app's Ruby Gemfile and NPM package.json. But I don't think I was taught it in a strictly programming context.
Your project has a much better/more clever name though!
&gt; I would say that the C way of "including" is more suitable to small programs, like those a beginner would write, whereas Rust's seems to have more deliberately prepared for more complex dependency management for bigger programs, and seems more modern like NPM or RubyGems. C's way of "including" as you call it is from a bygone era. So much, so that C++ is trying to move away from that model. Since you've, not actually written a large complex C project with external dependencies, you don't understand the headaches of with such projects. Nor trying to get other developers to a state they can even compile your program. C's way is simple, but it's not EASY. Cargo is really not that complicated. You have a centralized command, and a single file to handle dependencies. For most beginner Rust programmers, what it generates is enough to get you through the first few programs. What makes it great is that you can easily use external packages, with just a few key strokes. Now, try to figure out how to use an external non-OS supplied library like... libSSL, with your C application. It's not going to be so easy. It'll feel like you are driving around in a Model-T, while Cargo is a Tesla. 
&gt;public review. The top voted entries are often not idiomatic Rust. I wouldn't put too much confidence in the reviews on there. 
\`#\[macro\_export\]\` is a hacky \`macro\_rules!\`-specific thing that exports the macro directly at the top-level of your crate. If another crate were to bring in your library (\`bar\`), they'd be able to \`use bar::my\_macro;\` or even reexport it under \`mod baz { pub use bar::my\_macro; }\` which would allow them to write things like \`use crate::baz::my\_macro;\`. &amp;#x200B; Long term, the plan is to replace \`macro\_rules!\` entirely with a new system that has fewer of these edge cases.
Ah. I didn't read that properly. It's a crate at the root there.
Thanks for the detailed response! It sounds like having blinders on a bit as to the complexity is the appropriate choice for a beginner, even though most of what's cool about Rust is the complex stuff. (Coming here and getting the answers is more enjoyable than ignoring it all though!) Leaving all the defaults, and treating it like the simplest version of itself as possible makes it act a lot like C. Which I think is kind of the simplest compiled language out there still in use. I do think some guides that do a bit more hand-holding or simplifying would be great for those of us who want to "learn programming for the first time" with Rust.
Rust 2018 is the milestone. I meant release milestone, not a milestone of functionality, if that was confusing.
Fair enough! But now people have to decide between exactly features and yours 😢
&gt;Rust doesn't yet have this single-install integrated experience. It's still a bit of collecting all the components together. CLion + Rust plugin 
Thank you!
I initially had another paragraph in my comment that I think I understand where you're coming from. You need to understand the bits and pieces to actually learn/understand/memorize stuff. (That was of my major misgivings about the education system in my country - it was/is mostly about learning stuff by heart without actually understanding it.) Anyway, I removed that part after reading your last paragraph which seemed to contradict that. I was going to say that given my experience with various coworkers, understanding something does not seem to be a learning-requirement for most people. So maybe that's why you prefer something like rustc over cargo whereas most people would prefer the ease of use that cargo provides in the long run. Or maybe I'm interpreting too much into what I read :-)
Oh, poor people!!!
C's `#include` syntax is not a dependency management tool, it just copy and pastes source code from one place to another. It doesn't "just work," you need to manually install dependencies to your system (which is different on all platforms), add the installation to your PATH if the installation doesn't take care of it, build the dependency if necessary, then either add the package/dependency to your build file (CMake, Make, Autotools, etc) or manually add the linker/include flags to the command line. 
I like the windows event types and think they are sometimes more helpful than condition variables, therefore: Good stuff! What however might be missing to make the most out of events is the ability to wait on multiple of those (e.g. like `WaitForMultipleObjects`). This is immensely helpful for orchestrating multiple concurrent operations. However it's a thing that is pretty hard to implement. The next best alternative for that might currently be crossbeam-channel, where one can at least for multiple channels at once. Regarding the headline: I was a little bit confused about this: &gt;Not to be confused with async/await which does the same but only as part of what is basically an event loop Actually when reading "asynchronously awaitable objects" I'm thinking about exactly about async/await. And it makes sense, since also in async code sometimes one needs to wait until something is ready (e.g. an item is in a queue which is built on top of the event, etc.) For this use case I recently implemented an async/await compatible `ManualResetEvent` in futures-rs: [https://github.com/rust-lang-nursery/futures-rs/pull/1315](https://github.com/rust-lang-nursery/futures-rs/pull/1315) The nice thing about the futures compatible version is that it automatically enables the `WaitForMultipleObjects` equivalent via waiting for multiple futures and `select!`. 
Yeah, I like to know what the command I'm doing, uh, does. and how it all happens. I have noticed I'm a bit extreme about that compared to some other learning styles. &amp;#x200B; I find that if I learn the under-the-hood stuff up-front, I can search for answers more quickly. But if I blindly trust half-a-dozen components to work, and something breaks, I don't even know what question to ask. I can't Google "Help, my whole programming project isn't working!" &amp;#x200B; On the other hand, with Rails, running "rails new app" is \*THE\* way to start. As long as the way that hides complexity is well-supported and a well-worn path by other language users, you can trust it and ignore how it works at first. And any time the easy-mode installer doesn't work properly, you can still Google "Help, the specific easy-mode-installer didn't work as expected!"
You mention Ruby on Rails, but it has a similar system to cargo with bundler. The reason that most material assumes that you will understand what cargo is for is that there is an equivalent for essentially every modern language. As a beginner, and as a beginner who has only used C, Bash, and Ruby likely without any gems, you occupy a pretty rare niche for people interested in Rust. I agree that Rust could use some more material like, “Learn to program with Rust,” that doesn't assume as much about the audience. I think this would be great because I think Rust might be easier to learn if you aren't already accustomed to thinking about programming in a different way. Also some tutorial-level documentation on setting up a project with cargo and why you want to do this even for really basic programs might actually help some experienced C++ coders who will readily understand Rust the language but maybe not Rust the ecosystem.
It actually is all that is needed. Thank you!
Shame on me. Thanks for catching that - I've fixed it.
Hey, thanks for taking a look. You are spot-on on all counts, and indeed I know firsthand [how hard `WaitForMultipleObjects` is to implement](https://neosmart.net/blog/2011/waitformultipleobjects-and-win32-events-for-linux-and-read-write-locks-for-windows/). Fortunately, `rsevents` is implemented via the [`ParkingLot`](https://github.com/Amanieu/parking_lot) core crate, which should make that significantly easier as it allows giving each waiting thread a ticket to wait with/receive on awake, and allows for the evaluation of code prior to awakening the caller. I just haven't gotten around to it (as it was not a pressing need in the project that spawned this crate). Pull requests welcome!
Small tangent: I have yet to make the leap of installing one of these fonts on my mac, but projects like this make me want to try. I'm not sure how to choose from the various options (Font Awesome, Devicons, Octicons, Nerd Fonts,...) Does it matter much, or it it safe to go with any of them?
The similar C++ code is generated by rust_swig automatically https://github.com/dushistov/rust_swig
I have limited experience with it, so I have yet to see a top-voted entry that's not idiomatic rust. Mind providing a link?
You might want to look into [cargo-script](https://crates.io/crates/cargo-script), a cargo extension that compiles and runs a single .rs file without having to set up a new project every time. Example: $ echo 'fn main() { println!("Hello, World!"); }' &gt; hello.rs $ cargo script hello.rs Hello, World! 
&gt; First off: If I am just compiling "Hello World", why am I installing and running a package manager (Cargo)? Am I setting myself up for trouble by just "compiling" my code instead of "packaging" it? Cargo is the standard build automation. Like NPM for Node.js, it's responsible for automatically downloading and compiling any necessary dependencies when you type `cargo build` or `cargo run`. You're only setting yourself up for trouble if you try calling `rustc` directly. (That's only intended for special cases, like building new cargo subcommands... same basic principle as the git "plumbing" subcommands you never call in day-to-day use.) Many things you'd expect to be in the standard library (like random number generation and regular expressions) are crates in Rust, so that their evolution isn't tied to the standard library's. (eg. they can release a 2.x without forcing everyone to upgrade their code immediately.) &gt; Why are there so many versions of Rust? (Nightly, stable, 2018, ??) Am I on the right language version? Will I ever learn the nuances of which language version I should choose? Like browsers, Rust has three release channels. Stable is what you want to use by default. Beta is very much like stable, but lets you test your code against the version that will become stable soon. Nightly is for working with experimental APIs that they aren't yet committing to. As for "2018", that's like the different versions of the C and C++ standard that GCC lets you select using the `-std=...` option. It's not a compiler version, but a set of language features that may include backwards-incompatible changes, so you have to opt into them to avoid breaking older code. `cargo new` will handle generating a skeleton which opts into the recommended language version for the compiler you're currently using. &gt; There are so many tools it seems like I should be using. Clippy? Rustfmt? Surely these are good to use, but do I need them to get through the language tutorials? They're not necessary for the tutorials. I don't even run `rustfmt` all that often because I value my preferred coding style more than conformity with the rest of the Rust ecosystem and it has been a hassle to set up my desired configuration since the version I was using before became `rustfmt-legacy`. Clippy, on the other hand, is something you'll probably want to consider. It's not required, but each warning it produces includes a link to an explanation of *why* you want to change your code, so it's a good learning aid. &gt; Quality of code is strongly emphasized in the community. Would I live up to that standard if I started writing Rust? The whole idea behind Rust is that we can't all have a doctorate in language theory, so the skilled people write tools that help those less skilled to write better code. Think of it more as "The skilled members of the Rust community take pride in offering less skilled programmers the highest-quality tools and components possible." As long as you make an honest effort on the stuff you intend others to use, you're fine. I have only two pieces of advice there: 1. Only use `unsafe` after you've empirically proven that it's necessary and ruled out options that place less of a responsibility on you to get things right. Internalizing the rules for writing safe `unsafe` code is an advanced skill. 2. `panic!` and things based on it, like `assert`, `unwrap`, `expect`, and unchecked array indexing (`array[...]`) are not for error handling. They're for situations where you're making an assumption and want the program to die safely if it's violated. (Stuff like "We're parsing a hard-coded `const` string into an IP address object. This should never fail.") &gt; (The saturation of really knowledgeable programmers in the Rust programming language community is intimidating). Don't think of it as intimidating. There are always going to be novices in any field. Think of it as "In the Rust community, you have a much higher chance of having your question answered by something who *really* knows what they're talking about."
Hey all, I wanted to share my first real rust project. Small as it is I think it might be useful to others. Also if you have any feedback or comments I'd love to hear them :)
I know! 😄
Cough *"GCC has experimental support for the latest revision of the C++ standard, which was published in 2017"* cough 
I made a DFS N-Queens solver and then got caught up trying to optimize it to death, even though dfs is a bad way to solve that problem. Then, I got kinda caught up in making a chess engine. That's been a really great learning experience. Now I'm slowly working through AoC, trying out weird Rust things as I go along. I'm getting to a point where I find myself really leaning on the compiler instead of fighting it
Not particularly! The company I work for uses it for communication between several devices so that’s how I got interested in it. As a first step I would want to make a command line tool in which I can listen to all DDS communication happening in a network. (:
Ah cool, ill give that a shot.
Thanks for the precisions :) 
Issue created -&gt; [https://github.com/Peltoche/lsd/issues/5](https://github.com/Peltoche/lsd/issues/5) &amp;#x200B; Thanks for the report !
Thant `Symbol's function definition is void: -let` that sounds like a emacs-lisp error, and is probably unrelated to rust per-se. Are you sure that it is `-let`? that seems strange: i'd expect smth like `if-let` or `while-let`
Good catch! &amp;#x200B; Issue created -&gt; [https://github.com/Peltoche/lsd/issues/6](https://github.com/Peltoche/lsd/issues/6) &amp;#x200B; Thanks for the report!
I think there may be more optimization opportunities. * Only comparing hashes of files with the same size (so a single pass to hash based on the size, which I believe you already collect for buffering purposes?) * Taking file type into account in order to skip over headers and things when doing your short hash, like 'if its a png always skip the first n bytes for the header'. There are probably some parallelizable operations, like the initial directory traversal (there's a crate for this) as well.
Yeah, double checked. That's definitely the error: [error message!](http://www.aesgarth.co.uk/uploader/images/2018/12/04/leterror.png) 
If you want to implement it in lsd your welcome :) &amp;#x200B; Issue created -&gt; [https://github.com/Peltoche/lsd/issues/7](https://github.com/Peltoche/lsd/issues/7)
This is a really excellent response. Thank you for taking the time. (And thanks to everyone else in this thread also. This being reiterated a few ways makes it clearer.)
Interesting, thank you. &amp;#x200B; Seems like I could keep my bash workflow with this.
https://www.reddit.com/r/rust/comments/a2kn7y/sval_a_prototype_nostd_objectsafe/eazmjpx
Well, the fun thing is that when you write the thing in type level **every** function is hard coded into the binary. If for instance, at some point I call the function f(4/2) = 2, the function with these exact parameters **and** the result are hard coded in the binary.
yeah, the border type would be a great way to implement this faster. Don't read the code, it's a big mess :D, you would be faster implementing your own than reading mine.
Inspired by your comment, I searched around a bit and found this: [https://areweideyet.com/](https://areweideyet.com/) &amp;#x200B; Explains how to set up a fair amount of popular editors and IDEs for working with Rust. I'd probably use Atom or VSCode.
Actually, I'm already only comparing files of the same size and the comparisons are all quite parallel. I'm ignoring file type mostly because my initial assumptions included looking through files for which the name had been garbled.
One suggestion: if you pass the flag "-v" it will show you a lot about what it's doing. If you pass it "-vv" it will tell you pretty much everything it does.
Would love some "rust for beginners to programming" guides! &amp;#x200B; And I've definitely taken away from this thread that: 1) Cargo is awesome (and I should stop worrying and learn to love it :P) 2) The docs can probably evangelize Cargo better so that outsiders can "get" it better 3) Cargo is a lot like other package managers many of us have seen, such as NPM, Bundler, or I guess even APT, etc. 4) Dependency management is integral to modern programming (There are no "rockstars," certainly not ones in a vacuum!) (and most people already seem to know this one! I feel so out of the loop!)
Interesting tip! I will be sure to try that out next time. I think maybe something like that is what my (slightly paranoid and distrustful?) brain needs to begin trusting Cargo and treating it as "friend" not "foe. Plus I get to nerd out about the details even more. Always a plus.
Another improvement is to first compare size, then some bytes e.g. first 512 bytes, and only if those are equal do hashing. 
Is it just me, or does the link for const fn in the reference not actually tell anything about const fns?
Should be fixed. You probably need to update the package to the 0.6.1 version and it should be good. 
&gt; I'm still learning, so I didn't know about unwrap_or or here. We've all been there. :) As you write more Rust, you'll get more familiar with the standard library in general, and the various methods on `Option` and `Result` types. They're incredibly powerful and a key to writing great Rust, IMHO.
i'm afraid any explanation won't make much sense to newbies, because they'll be presented with a solution to a problem they won't really have for quite a while. going with the flow and blindly following tutorials might actually be the best way to get started.
When used with Rust, I noticed Tabnine launches RLS again. Doesn't this a bit harsh on CPU and SSD to have two instances of RLS at the same time?
I don't know how much C experience you have or even what operating system you are using, but I just wanted to illustrate a comparison. Starting out at the very beginning with C typically your compiling experience is going to look like this on a *nix environment: `cc hello.c -o hello`. This assumes that you are only using the standard library. If you need to use `math.h`, our experience changes to this: `cc myfile.c -lm -o myprogram`. Now if you want to do something like use a library to handle some XML like libxml2, you then have to compile with a command more like this: `cc myflie.c -I/usr/include/libxml2 -lxml2 -o myprogram`. And if we want to save compile time by not rebuilding files that haven't changed everytime, we have to write a makefile and use `make`. I should have mentioned to get the library and linker flags for libxml2, I had to use the `pkg-config` command. Now imagine trying to get this to work cross platform. Let's say you want to start a Rust hello world type program. To install your tools you run the Rustup script as documented [here.](https://doc.rust-lang.org/book/2018-edition/ch01-01-installation.html) I haven't run Windows in a while so I can't comment how the install experience is there, but on *nix based systems it's not too different from other tools. We start our hello world project with `cargo new hello_world` then `cd hello_world` and since Cargo initialized our src/main.rs file with a hello world program we then run `cargo run` and the words `Hello, world!` show up on the screen. If we want to use a third party library, we modify the `dependencies` section in `Cargo.toml`. While this involves a little more in the beginning, I don't think it puts too much on the beginner. Should Cargo be explained? Absolutely. Should it be explained before we get to writing hello world? Probably not. It's one of those things that should be covered later. Even C requires some skipping details initially as `#include &lt;stdio.h&gt;` normally gets put to the side until much later.
..but `git gc` isnt manual only? It can run automatically too, `gc.auto` and `git gc --auto`
When you're compiling hello world, cargo will actually write the file for you. Isn't it handy? It will create all the folders you need for you. Just do cargo new helloworld and then you can cargo run it. That's already fewer commands to run, not more. I also love rustup since I can update Rust without leaving the terminal. Forget about the versions. Just update the one you have already with one command. That's just awesome.
It just needs to be mentioned, it doesn't have to be in-depth. e.g.: "Lots of good code is already out there. Chances are that you'd like your program to do something that's already been figured out. This is where "libraries" come in. You can build on the work of others instead of reinventing the wheel. To manage libraries we will be adding them to Cargo.toml. Now Cargo knows what "libraries" we need, and can download them for us. Cargo is built to make it much easier tracking all the libraries (other people's code) you need to help make your app powerful." &amp;#x200B; Obviously someone who knows more could be more elegant (or accurate?) but that's a start. (Maybe this is already in the docs, but I don't remember it being said that clearly.)
I'm actually doing that as well. 4KB in my case.
&gt; First off: If I am just compiling "Hello World", why am I installing and running a package manager (Cargo)? Am I setting myself up for trouble by just "compiling" my code instead of "packaging" it? ​This is, in my opinion, a bug in Rust. You certainly can just compile "Hello World" and any binary or library…that uses no packages. Once you need to use a package, you are pretty much stuck with Cargo. In principle this could be fixed by changes to the compiler tooling to read the `extern crate` declarations and do something sensible by default…except those declarations are being removed in the 2018 edition, making `Cargo` mandatory. C'est la vie. &gt; Why are there so many versions of Rust? (Nightly, stable, 2018, ??) Am I on the right language version? Will I ever learn the nuances of which language version I should choose? ​Just use 2015 stable until you have some reason to move. Not worth thinking about early on. &gt; There are so many tools it seems like I should be using. Clippy? Rustfmt? Surely these are good to use, but do I need them to get through the language tutorials? ​Clippy is reasonably valuable, but you need to learn when to ignore it. Similarly with rustfmt. Both tools are there primarily to help you learn how to write good clean clear code without them. &gt; Quality of code is strongly emphasized in the community. Would I live up to that standard if I started writing Rust? ​Yes. Everyone is excited to help, so just be prepared to take and evaluate critique. &gt; Much of the material written about Rust goes way over my head. Despite Rustaceans actively priding themselves on being welcoming and interested in how beginners will do when learning Rust, I wonder: Is the Rust community for me? Or is Rust just a language for other veteran programmers who want to build something better than what they had before. (The saturation of really knowledgeable programmers in the Rust programming language community is intimidating). ​Rust is currently being Haskellized. It's an issue. Be problem-driven rather than technology driven: figure out the way to solve your programming problem that is easiest for you, and do that. Again, folks will be happy to make specific suggestions about easier ways.
Already tested, works fine.
I'm going to try to compile (badum-tsh) my take-away lessons into this one comment for easy reference. &amp;#x200B; \- In my opinion Cargo is relatively TOO POWERFUL for how CASUALLY EXPLAINED it is in the docs. Cargo is a huge thing. I think folks from other languages should be given some explanation of why it's worth the trouble (apparently it is well worth using Cargo!), and also newbies should get a gentle suggestion to ignore most of its complexity at first, since most of its features are useful with more complex projects only. \- The docs have too much jargon. Everything assumes a programmer who knows another language well and has been using it for a couple of years or more. I suggest using more general-purpose language that non-programmers and programmers alike would understand, where possible. This will also give rise to opportunities for clearer docs in general. Look at Ruby and Rails documentation for a great example of humanistic writing styles. Not everything is complicated, even things that seem that way at first. \- Rust has sensible defaults. It needs to be louder and prouder of this in the docs. Readers are casually exposed to complexity with sentences that pique one's curiosity. However, that curiosity is dangerous for newbies, since they will assume all these options are important, and will want to tweak them to see what they do. There needs to be a blessed "yellow-brick-road" path for newbies to follow and get up to speed. Briefly mentioning the complexity at hand is cool for veterans of other languages, but distracting to first-time programmers. \- Rust's docs seem fine as-is for veterans of other languages, but a separate, easier guide for newbies in general would be much appreciated. 
&gt; but not everyone agrees we want it to. For those ***wrong*** people with money, time, and space to waste, just let them disable it, while the rest of us mortals get on with target folders under 90GB and without years old artifacts.(Especially in the .rustup folder, no `cargo clean` for that, easier to forget.)
I don't know of any such crate and I believe it has little reason to exist. I already experienced a scenario when I got burnt by "reentrant" RW locks and I don't see a reasonable use for them now. Storytime. The issue with RW locks is that there might be a risk of writer starvation if there is lot of reads happening. Some systems resolve it by prioritizing writer - if there is a writer waiting, all subsequent read locks will block. This works well since all the read locks will get unlocked eventually, writer will do it's job and everything continues. Unless someone got "bright" idea to use reentrant locks. It might happen that a thread locks the read lock first time, then another threads starts waiting for write lock and the first thread attempts to lock the read lock again. You get deadlock and lose hours, maybe even days of your life debugging it. This actually happened to code I was working on few months ago. It took quite a lot of time to even find pretty reliable steps to reproduce it. Then few days of two people analyzing the problem. (I'm proud to be the one who identified the root cause.) Another "fun" fact: it was a macOS kernel extension, so for every iteration of testing we had to issue hard reset (deadlocked extensions can't be unloaded). Here I agree with someone who wrote "If you need recursive locks, your code is too complex." After experiencing several deadlocks stemming from ridiculously complex code, I can say that all operations within a critical section should only be memory operations - assignment, `memcpy` etc - no syscalls, no locks and no calls of complex functions.
Hello there! My latest question is: Is there a way to do head recursive macros? In other words, this won't compile: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=b79ea9eed18743dab470e566f742848c (inlined here) ``` macro_rules! tail_macro { [ $( $head:expr ;)+ $tail:expr ] =&gt; { $tail } } fn main() { println!("tail: {}", tail_macro![1;2;3]); } ``` that is, I want the _last_ element of a repeating list, not the first.
Answered my own question while fooling around in the playground: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=b798b76b3973a34e94897ada23effc88 Would still be interested to know if there's a non-iterative way to do the same!
I gave this advice not [that long ago](https://www.reddit.com/r/rust/comments/9y15bb/high_quality_rust_projects_to_learn_best_practices/e9zjtf5) too. You can start to read small crates that are interesting or useful to you.
FWIW React is mostly changing to be functional components instead of classes.
&gt; and if you don't trust the Rust developers not to inject malware into the script then you shouldn't be seeking to install the Rust binary provided by the Rust developers in the first place, as binaries are far easier to inject malware into. That is a fair point if you disregard state-level attackers (despotic regimes being able to coerce CAs into issuing a certificate intended for MITM).
I'm looking for some help on the proper data structure to choose (again!). I'm saving "things" of type "(u64, u64, K)" where `K` is an enum carrying no data. I say "things" because I need to save this data and do something with it, but I don't need it to be tuples/structs/w.e., I can choose whatever fits best. The two `u64` values actually form an inclusive range, and no two ranges intersect. Moreover, when computing those ranges, I can guarantee that I add them in ascending order. That is, if I were to make a `Vec&lt;(u64, u64, K)&gt;`, it would be strictly ordered just by `push`ing the things to it. Right now, I went with `BTreeMap([u64;2], K)`, because I figured I could make use of the ordering on `[u64;2]`. But now that I really need to do something with it, I'm stuck a bit on how to. Here's what I need to do: * Given an inclusive range `f..=l`, I need to find all entries from the `BTreeMap` where the key intersects this range, i.e. all entries `([a, b], k)` such that either `a` or `b` is in the range `f..=l`. Then, delete all those entries from the map. * Still given the inclusive range `f..=l`, I need to get all entries `([a,b], k)` in the map where `a` is strictly larger than `l`, and add/subtract a certain other value from `a` and `b` in the entry. * After the above operations, I'll need to put in new entries, where the smallest and/or largest of those new entries might need to be "fused" with the bounding other entries (that's gonna be a bit of ugly logic that's probably ugly in every data structure, just figured I'd mention it). The second problem seems to be solvable easily in a `BTreeMap`, since I can just use `BTreeMap::range_mut([l+1, 0]..)`, and then modify the keys in place. The first problem however doesn't lend itself to this very well. Getting the `([a, b], k)` where `a in f..=l` can be done with `range([f,0]..[l,0])`, and then I'd have to copy out the keys, and delete the entries afterwards. I don't see how I should do it for the `([a, b], k)` where `b in f..=l` though, other then simply iterating over the entries and looking directly. Overall, this feels like I should be using a `Vec&lt;(u64, u64, K)&gt;`, running through once to figure out the proper indices (plus modify those that need it), and then use `splice` for the new entries... This got a lot longer than I thought it would be. Anyways, thanks for any input on this ;)
Am I the only one who dislikes that purple-ish color? I like everything else, it's just the color that seems weird to me.
Avoiding UB possibilities in general in C is not a good idea for performance reasons. You should make UB impossible by checking your inputs, not changing your data types. UB allows the compiler optimizer to do much better optimizations.
&gt; Rust just tends to get you into it up front. What is rust doing here thats more "up front" than any other language? Every language(in this space) needs to be compiled somehow, and `cargo build` is a heckuva lot simpler than `gcc -afsankf file.c --sh file.o -wargsblarg -WargBlargX -y -Xw -x` or something. I'm curious to see an example of a compiled language that isnt "upfront" with.. needing to be compiled? Of course this doesnt even get into the fact that every language has versions
&gt; With C there is just "a compiler" and you hit "build" and it builds. What compiler are you using where you "just hit build" to compile C? And how are they so much simpler than `cargo build`? Are you using an IDE thats handling all the complexity for you?
Re-implementing an existing utility of mine in Rust (originally in Python). It doesn't need the rewrite; this is to test my knowledge of Rust after the smaller, isolated experiments I did to learn the core language. &amp;#x200B; The tool itself is for tracking my spending, similar to what you can do with services like Mint. Parsing the transaction history exported from my bank, categorizing expenses, comparing spending month-over-month, etc.
For context: because `rustc` came first, and you needed a way to link to dependencies, hence `extern crate`. Then `cargo` came along later, and specified where to find those crates. Now, even later, `rustc` is being changed to implicitly link crates it's told about.
I agree that cargo is simpler than trying to deal with gcc or rustc or whatever directly. The issue, it sounds like, is that if you run gcc by hand, it does exactly one thing and you know what that thing is, even if you don't know how or why it works. When you run cargo, it does A BUNCH OF STUFF, and you're more shielded from the details so you don't know the details of what that stuff is and how it fits together. It's certainly more convenient, but it's harder to dig down the stack to actually understand it. What I was saying with "Rust tends to get you into it up front" was that Rust tutorials generally start with cargo on the assumption that you're going to want to use cargo anyway, and don't bother trying to explain in detail what's going on underneath. Contrast most C tutorials, which start you off compiling and linking stuff by hand, and only later get into `make` or whatever.
I am not an experienced Rust programmer but from what I've read over the past two years on this subreddit, you should not get any biased comment. This community will just try to give you the best answer they can. If rust doesn't fit your needs, they will tell you.
No; group matchers are *always* greedy. Your options are iteration, or a procedural macro.
I'm a consultant right now that is converting a company's build tool stack for c++ from an old in house system to CMake + Ninja &amp; Conan (build system &amp; package manager). Getting that to work with cross compiling from scratch.. holy hell. I'd go as far as to say most c++ developers do not need to understand most of this, and I cry a bit inside when I know Cargo could replace it all. Read up on how code gets compiled to machine code, and you can apply it to anything. The differences is mostly details that gives no better insight unless you really want to work with it. A good example is how LLVM does it from the front end(Rust, C++ etc.) to its intermediate representation (LLVM-IR) and how it then can further compile that to machine code for many target platforms.
Given the context of this thread, any alternative to `curl | sh` would resemble shipping a binary installer, which is just as prone to interception and silent replacement as a shell script. If we start from the assumption that SSL can't be trusted, then there's little that the Rust project can feasibly do to mitigate the threat.
Looks like we had the same idea - my first rust program : https://github.com/mastfissh/deduper does exactly the same thing! Thanks for posting this, it's really interesting to see other ways of approaching the same problem.
Any chance you could make this a crate so a simple `cargo install ddh` would work?
No personal experience with JUCE, but this talk was quite nice: [Ian Hobson - An introduction to Rust for audio developers ](https://www.youtube.com/watch?v=Yom9E-67bdI)
Discord: Selfisherq#3882
unless it originally runs through javascript ...
Can you point me at some docs on how to do that?
Glad to help.
https://github.com/rust-lang/rust/issues/55618
Doing DSP is not too hard (but a lot of libraries are missing, including resampling), but for UI the situation is less fortunate. You can, of course, draw it manually using gfx-rs (pre-ll), but this is probably not the solution you wanted. 
For the issue with the vec, if you have ownership it is good. You can avoid that clone by getting the median first though.
You can publish binary crates (such as CLI tools) to Crates, no big deal. Installing it will place the binary in the Cargo directories (forget exactly where) and then you can call it by name.
I think it's primarily for libraries, but most Rust CLI applications I've used seem to be uploaded to crates.io, if only because otherwise someone else can take the name.
I used Iron for a moderately complex web server, and had no complaints, but it's not being actively developed anymore.
I'm going to say something controversial, and I hope that you are not offended as that is not my intention so apologies in advanced: If you are new to programming, Rust (which is a systems/driver/low level/) its perhaps not the best "first" language. I say this because I started out like I suspect many others also did on things like Basic on C64 some 30 odd years ago, if I was then suddenly dropped into writing say C++, it would be one insane jump, Rust is an even bigger jump IF you are just starting out in programming! I would suggest perhaps stick with Ruby, maybe Python etc, the once you are comfortable programming and solving real problems and not "learning the language", you can venture to Rust with a lot more confidence.
Jargon is tricky, and typically needs someone not used to it to point it out, so thanks!
Sorry, I looked at the code but didn't see that you were doing that.
Nice project, keep it up! A few tips / suggestions: - Provide binaries for the releases. I love cURLing musl rust binaries. - Consider using a 256bit hash function to minimize collisions. Shameless self-promotion for [highway hash](https://github.com/nickbabcock/highway-rs), which can give a 256bit hash and is 3x faster than Rust's default 64bit hash (at &gt; ~10Kb). - Read "[why it's hard to write a dupefinder](https://rmlint.readthedocs.io/en/latest/cautions.html)" - Corollary: invest time into a test suite! - Evaluate performance of mem-mapping large files
&gt;You should use signed values wherever possible because they are what the processor natively speaks much better than unsigned values. As far as I'm aware^(1), that isn't actually true, the Processor rarely cares about signedness outside of multiply/divide instructions and sign vs 0 extending instructions. This is because they were designed such that they are identical in common instructions like addition and subtraction `(-1): i8 + (-1):i8 = -2:i8` and `255: u8 + 255: u8 = 254: u8` both of which in binary are `0b1111_1111 + 0b1111_1111 = 0b1111_1110` also, normally the cases where signed and unsigned are different, the processor will either have two different instructions to handle both cases (ala: mul/div) or it will just support only one or the other (the Game Boy's `JR` instruction class for instance) &amp;#x200B; 1: This is me saying that I've written several (granted, 2 out of the 3 were of the same system) emulators, have read a moderate amount of assembly, read design specs for RISC-V and so on.
It doesn't because 1.31.0 stable is not released yet. See [beta version of the book](https://doc.rust-lang.org/beta/reference/items/functions.html#const-functions) for now.
I have a \` #\[cfg(feature = "rand")\]\` before \`extern crate rand;\` and many similar things. Am I still going to have to use \`extern crate\` everywhere in Rust 2018 or is there some other way I can do this?
I watched this which influenced my thinking: https://youtu.be/yG1OZ69H_-o?t=2354
 I have a \` #\[cfg(feature = "rand")\]\` before \`extern crate rand;\` and many similar things. Am I still going to have to use \`extern crate\` everywhere in Rust 2018 or is there some other way I can do this? 
Implementing \`Add\` only for references will prevent me from writing code that constructs points inside math expressions like \`&amp;some\_point + Point { x: 0.0, y: 1.0, z: 2.0 }\`. This isn't a deal breaker, but I would prefer that my point type behaves just like native numbers in rust which don't have these limitations.
Looks cool! I’d love to contribute!
-let probably comes from dash.el: https://github.com/magnars/dash.el/blob/6514359b8606a6a9a94068ccd601fcd6379d6584/dash.el#L1908 Try to install this library and see if the issue persists.
Have you tried `pub use crate::nix::*;`?
There is going to be ugly logic no matter what with that, so first make sure to make a struct named something like `ExclusiveInclusiveRanges` (You could make it `ExclusiveInclusiveRanges&lt;T&gt; where T: ...` to allow for more than u64.) that handles range checking and everything internally, and that hides the internal structure of whatever the (u64, u64, K) values are put into (in case you want to change that internal structure later and not have to change code using the outer struct). &gt; find "the largest entry that's smaller than all deleted ones" as well as "the smallest entry larger than all deleted ones". The public functions of your new struct would be stuff like `.greatest_lower_bound()` `.lowest_upper_bound()` . If it happens to be more useful for whatever your usecase is, there is another way to interpret the (u64, u64) part, and that is to have the first u64 be the lower bound, and the second u64 to be how many units there are until the upper bound of the range (e.g. instead of second = upper bound, first + second = upper bound).
The first block says that the crate `sdl2-sys` is to be found at the `path` `sdl2-sys/`, relative to that `Cargo.toml` file. This works because `sdl2-sys` is part of the same repository. If you wanted to use `sdl2-sys` yourself (you don't; it's just something `sdl2` is using itself), you could get it from crates.io instead, by putting this in your own `Cargo.toml` file: [dependencies] sdl2-sys = "0.31.0" You really just want to depend on `sdl2` directly, since this is what the examples use (`extern crate sdl2;`). You can do this from crates.io as well: [dependencies] sdl2 = "0.31.0" Once you get to the point of using `sdl2::ttf` like their example, you'll also need to enable the `ttf` feature of the `sdl2` crate, which means changing the above to this: [dependencies] sdl2 = { version = "0.31.0", features = ["ttf"] } That `[features]` syntax in the `sdl2` `Cargo.toml` file is them *exposing* that feature to their dependents (i.e. you), so that you can use the `features = ["ttf"]` syntax above.
No worries. The sorting by length is done on lines 76 to 82. Line 85 then spawns a compare function on each list of n byte files. That function then also has some parallelism in it.
I've had a look at your code to find how you deal with collisions. The `DefaultHasher` in rust's hashmap is siphash, who the creators of [do not indicate collision resistance](https://www.131002.net/siphash/siphash.pdf) as a property of siphash: &gt;We comment that SipHash is not meant to be, and (obviously) is not, collision-resistant. There is some more discussion [here](https://crypto.stackexchange.com/questions/35086/siphashs-non-collision-resistance) Have you thought about including a byte-by-byte comparison after a positive match on the hash to avoid collisions? It would be slower but more accurate.
In my experience: cargo being a defacto build system and package manager across all platforms makes Rust preferable over C/C++ even if you plan to have C/C++ dependencies (especially if the dependency has a safe abstraction crate). On mobile Rust has the same hurdles as C/C++ would have, but I'm tempted to say cargo-apk and the jni crate made things more pleasant to work with.
I've had a lot of issues with code completion where the list of things it gives me aren't "incomplete", but just straight up wrong. Here's an example: https://i.imgur.com/MCesYgA.png. I have typed 'nom::' and therefore would expect to see a list of things from inside of nom. Instead I'm presented with what looks like a list of literally everything in scope, including fun entries such as 'libunwind' and 'u128'.
I had no reason to try but the nomenclature section is funny so I will have to download this weekend and try.
I’d just like to chime in because yours is a completely unrelatable opinion to mine. I started out programming six years ago in middle school, with C++ (tooling: CMake) and Java (IDE-specific or Ant, etc.). Unlike most other people around me, I flat out despised doing web-dev related projects because of how much crud NPM and the like clutter repositories with. I tended to prefer C++ because it was the most minimal yet powerful of what I’d seen; I managed my dependencies with CMake or Git submodules. Then, two years ago, I found Rust. And I’ve got to say this: Rust has some of the best tooling I’ve ever seen. It’s just so streamlined. Cross platform is seamless. I’ve never been happier with any build system/dependency manager than Cargo. You’ll come to appreciate it.
Cargo is the best thing about rust and I can't understand how anything is simpler than cargo build... Now make...
Thank you for sharing your experience!
It is shorthand for try!. Basically it means you can write as if the result with a question mark after it is an expression of the type in its Ok variant, because it early returns the error otherwise. https://doc.rust-lang.org/1.9.0/std/macro.try!.html It can be used on a couple of types. See above for details.
&gt; If you are new to programming, Rust (which is a systems/driver/low level/) its perhaps not the best "first" language. I sympathize, but I'm not sure there's any real reason why Rust *can't* be one's first language.
 Ok(foo.bar()?) is equivalent to the following: Ok(match foo.bar() { Ok(result) =&gt; result, Err(err) =&gt; return Err(From::from(err)), })
Hey /r/rust, I'm using Advent of Code 2018 to force myself to think more like a Rust programmer instead of a C/C++ programmer. Namely, I'm trying to take full advantage of Traits, Iterators, and Pattern Matching. As for my issue, I'm trying to elegantly modify a value that may or may not be in a HashMap by calling get_mut on the HashMap and then running a match on the result. If I get a "Some()", I just modify the value, but if I get a "None" then set up the initial state of the value and insert it. However, the borrow checker doesn't like the "None" case where I'm trying to insert into the HashMap that I called get_mut on since that's where the first mutable borrow occurred. My work-around is to do it the "C++ way" where I query the HashMap to see if it has the key yet and then branch accordingly. The relevant code is below. Is there anything I can do to this to make it work with the match statement or is the if/else the correct way to do it? https://github.com/QMurphy/AdventOfCode2018/blob/master/rust/src/day4.rs#L50
I think you’re missing a free callback, and how you set that up will affect the design. You’ll definitely need one for zero copy decode or encode.
Pretty much every compiler or interpreter you've worked with so far has a lexer-parser, some kind of abstraction-lowering stages, intermediate languages (possibly several), and finally a codegen or JIT or interpreter loop that actually spits out machine instructions. That's a lot of complexity which you can - and should - safely ignore unless and until you want to experiment with compiler design. You probably don't ever need to know what "register coloring" is, even if you're going to write something quite advanced like a device driver. So most C programmers don't end up taking a C compiler apart, or if they do it's more likely from a desire to satisfy curiosity than a need for their project. Think of the Rust builder the same way. `cargo` is bigger than a compiler and `rustc` is just a piece within `cargo`, which you never have to think about separately. `go` works *exactly* like `cargo` too - it's a full build system. But because the compiler proper doesn't have its own separate name, it doesn't tempt newbies into confusion. Forget `rustc`. `cargo` builds and runs Rust programs. You *are* correct that a Rust-as-your-first-language tutorial should explain this in a sidebar.
Hi, I'm not quite sure what you mean. The function c_free calls the destructor of the Data and Opaque generic types. As far as deallocating the AvBufferRef goes, I think av_buffer_ref should do that right? If so, then that gets called in the drop impl
Apologies: * Missed the *Thanks* and *Links* slides at the end, pizza kinda stole the show * For the big overlay thumbnail, shall reduce that next time * For so many filler "um"s, it's my first talk in nearly a year of solitude
Thanks! What about that function.call()?
My b I glazed over that part. I’m not sure how that work to though. If you want to re-use your backing buffers how do you know when it’s free? I wouldn’t want to drop it.
Well an AVBufferRef is kind of like an Arc. It uses an atomic int to count references. You can create a new reference by calling av_buffer_ref, and free the reference using av_buffer_unref. If the refcount falls to 0 it will call the free function you provided.
This is my first project in Rust, a simple raytracer based off the content from my introduction to computer graphics course. &amp;#x200B; One of the biggest challenges for this project was trying to get the SceneNode hierarchical system working. I learned very early that rust seems to hate the possibility of cycles in data structures so I had to get creative. After trying a few things (and considering doing arena-based trees) I settled for just allowing each node to own its children. This removes the possibility of cycles but also means a lot of copied data while constructing the node tree. In the end, I'm pretty happy with the performance, and after the initial learning curve I'm finding myself starting to enjoy working with rust! Even though the compiler sometimes makes me want to rip my hair out, the readability of the error messages itself is enough reason for wanting to switch from C++ to Rust. &amp;#x200B; One paradigm I found myself using a lot for dynamic dispatch is creating an enum and then matching on it as seen \[here\]([https://github.com/shaunbennett/lucis/blob/master/src/geometry/primitive.rs#L33](https://github.com/shaunbennett/lucis/blob/master/src/geometry/primitive.rs#L33)). Is this fairly common in Rust, or are there better ways to handle dynamic dispatch like this?
If you're worried about the resource usage, you can type TabNine::no_sem in a Rust file to disable semantic completion.
Seems like a perfect candidate for the `entry` API - something like this: ``` let v = guard_sleep_sched.entry(&amp;guard_on_duty).or_insert_with(Vec::new); v.push(sleep_range); ```
Right, and what I mean is clients will probably want to manage buffer associations themselves as they do in C. For example if you have x decode buffers to use, you need that reference counting to know when the decoder is done with them, and when you can put them back in rotation. They shouldn’t drop.
Rust is fun to play with and there are a lot of great resources out there for learning, but the ide tooling leaves a lot to be desired. Thanks for working hard to solve this complicated issue. Anyone who has had the pleasure of writing c# in visual studio, with or without resharper, understands just how amazing tools like that can be. I hope rust can get there someday, and soon.
That fixed it thanks.
I’m at the same place with it. RLS overall works fine, and I especially find the red error squiggles and messages very helpful. But code completion is lost to me: I frequently get the straight up wrong case mentioned here as well. Now it’s in Siri territory: it could be great one day, but it’s lost my patience to give it a try. I would rather ignore the autocompleted rather than waste my effort at being disappointed again. I’m really hoping it can improve quickly and grab my attention again.
It's a mechanical transformation, so.... match config.doThis(someArg, &amp;location) { Ok(result) =&gt; result, // which is ultimately unused Err(err) =&gt; return Err(From::from(err)), };
Thanks for comment! This search engine main feature is filtering and searching. There are mostly operations on sets and simple calculations / counting. When I was making stress tests some time ago the CPU was mainly involved and it was a bottleneck. It was fun to make this library in JavaScript because it is relatively simple language and it can work on small datasets (1000 elements) quite well. Once there is more users (concurrency) or more items, Node.js is blocking and dying from computation.. Node.js cannot also natively use full potential of all CPU cores. There are libraries like [https://github.com/rvagg/node-worker-farm](https://github.com/rvagg/node-worker-farm) which allows to distribute computing tasks to different processes / cores. They are very easy to use but not as powerful and fast as in C, C++ or Rust... &amp;#x200B; Anyway when I look into benchmarks C++ seems to be 5-10x faster than Node.js in performing different algorithms [https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/gpp-node.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/gpp-node.html) Rust is quite comparable to C++ in the same tests. Sometimes 1.6x slowier but in some tests even faster [https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/gpp-rust.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/gpp-rust.html) &amp;#x200B; If I could make a search engine in Rust with similar interface as ItemsJS which works well for even for 100K-1M items and returns results in 10-80 ms and supports faceted and full text search that would be awesome but I know it can be very challenging... 
Nice CS488 project! Using enums the way you do is perfectly valid there, but there is another mechanism in Rust for dynamic dispatch called [Trait Objects](https://doc.rust-lang.org/book/2018-edition/ch17-02-trait-objects.html?highlight=trait,objects#object-safety-is-required-for-trait-objects) 
Thanks a lot
Cross-posted this to /r/raytracing
Seconding this. RLS just plain doesn't work most of the time in my experience.
Hey, r/rust I'm having trouble with a relatively simple function I'm wanting to write. The code I have is written below. pub struct JobGraph&lt;'a&gt; { jobs: Vec&lt;Job&gt;, dependencies: HashMap&lt;&amp;'a Job, Vec&lt;&amp;'a Job&gt;&gt; } impl&lt;'a&gt; JobGraph&lt;'a&gt; { pub fn add_dependency(&amp;'a mut self, master: &amp;'a Job, slave: &amp;'a Job) { let slaves_option = self.dependencies.get_mut(master); match slaves_option { Some(slaves) =&gt; slaves.push(slave), None =&gt; { let new_slaves = vec![slave]; self.dependencies.insert(master, new_slaves); } } } } The compiler output is the following: error[E0499]: cannot borrow `self.dependencies` as mutable more than once at a time --&gt; src\lib.rs:42:17 | 37 | let slaves_option = self.dependencies.get_mut(master); | ----------------- first mutable borrow occurs here ... 42 | self.dependencies.insert(master, new_slaves); | ^^^^^^^^^^^^^^^^^ second mutable borrow occurs here ... 45 | } | - first borrow ends here I've tried rewriting the function a couple of ways but I always get an error saying that I can't use a second mutable borrow. Is there a different mechanism that I should be using? &amp;#x200B; If I left any important information out please let me know. Thanks in advance for your help.
Gave your lsd a shot, looks like when you are redirecting output to a pipe, you are still writing the term colors to it.
You can `cargo install` stuff from git, using the `--git` commandline option. So `cargo install --git https://github.com/darakian/ddh` would install this.
Nice - look forward to watching this. I was meaning to try and get along for some of the night but was clashing with the Joe Satriani concert. 
If I had to make a guess on how long the debt/redesign will take, I'd guess about as long a MIR-based borrow check (NLL), which is on the scale of 2-3 years. I'd love to be wrong, but this will take a lot of work to get this changed without breaking anything meanwhile. In the spirit of every feature seemingly affecting every other feature, the [Trait System rewrite](https://github.com/rust-lang/rust-roadmap-2017/issues/8) and [Generic Associated Types](https://github.com/rust-lang/rust/issues/44265) are issues that the compiler redesign will have to take into account. It's hard to say at this point which one will get done first (or will they all get done as part of a Rust 2021 edition, perhaps). I'm not trying to be pessimistic, here--rather I'm trying to set expectations. If it were easy, it would be done already.
Another case for the `entry` API. ``` self.dependencies,entry(master).or_insert_with(Vec::new).push(slave); ```
I knew a such an elegant solution had to exist. Thank you very much.
I've seen a few rust projects tackle ray tracing. Do you know if doing something like the opposite(3D to 2D/UV) is more difficult? Seems there is a lot of information on building ray tracers, but not so much for texture baking, where you can have a source and destination meshes to transfer details like normals(normal map) or colour(diffuse/albedo/vertex). It's something I'd like to tackle at some point, if you're familiar with what I'm talking about, would looking at ray tracers like yours be helpful? Or are they likely completely different from what I'm talking about doing?
&gt; Edit `Cargo.toml`s of packages that depend on this package to use crates.io version rather than path. If I recall correctly, it is perfectly valid to have path _and_ version entries for the same dependency: When you build locally, Cargo will use the path dependency. When you publish / someone builds your package from crates.io, Cargo will user the version dependency.
Ahhh this is great to know if true, thanks!
&gt; My question to experienced Rustaceans is, would you recommend Rust to someone in my position? Nope. Stick with C++. Givin up JUCE would be a mistake, especially since there are no alternatives for Rust. &gt; My current plan, (whether I use Rust or JUCE) is to use it to create a static/dynamic library which I can then use from C++, Swift, C# or Java Well in that case, go ahead and use Rust. &gt; I've been trying out Conrod for creating the custom GUI elements. My idea is to use glutin to create an OpenGL context [...] Oh so your library want's to do graphics? To me it sounds like you're trying to write an audio plugin. Stick with C++. DSP in Rust is great, but you'll have to use C++ anyway for building say a VST compatible plugin. You could write the core DSP logic in Rust and link that into a C++ audio plugin, so you get the best of both worlds, more or less. It would be amazing if one could write a plugin / plugin host entirely in Rust, but the audio industry is sadly fixated on C++. They don't even seem to appreciate C.
And its r/playrust
Have you tried IntelliJ-Rust? It works pretty well for me. 
Mostly for absolute performance in code which has lots of eyes on it for verification. Stuff like the iterator for `&amp;[T]` uses it.
Rust is okay for haveving hierarchies in enum structures, this is how we usually implement trees, graphs, linked lists and so on.
The integration with Lua is very clever and looks very simple to do codewise. I might use that for one of my projects.
Ok thanks 
Your output (re: "part of println output") seems to make sense. The output indicates your function called mergesort twice (contrary to your previous claim that "it's not calling below 'mergesort' for the next half") before it called merge(). Both of the sub-mergesort() invocations didn't do anything since their lower\_limit and upper\_limit bounds equal each other. Passing 'mid+1' as the lower bound to the 2nd mergesort() invocation helps you avoid an infinite loop. Did I misunderstand anything?
Hmm, I haven't had any problems with completion in vim with RLS ...
You can go ahead and delete this post. 
Well, they're also not quite comparable since rustc uses the crate as the translation unit instead of the file. 
I found IntelliJ Rust to be good too. The same dude is the one working on Rust-analyzer so I’m cautiously optimistic that it’ll work out. 
I can relate to that feeling with the compiler. I fought once with the borrow checker which put me back to the learning book but then now I just write my code, expecting some errors to happen (mutability, reference arguments, ...), and fix them right after I compile the first time.
&gt;I have a habit of spending a lot of time learning things because I find them interesting and see a future in them, but that can be at the expense of "getting things done" with tools I already know. &amp;#x200B; This could be really helpful. I am not quite sure what you expect Rust to give you over C++. For the risks of Rust: would it make sense to write a minimal prototype in Rust and see how to goes? Like do something representative with audio and GUI. 
Oh..now i got. Two recursive call means two banches each time to the parent. Each node , its doing left and right half. 
I hear a lot of good things about IntelliJ-Rust, but I much prefer VSCode as an IDE these days. And really, you shouldn't have to switch to one specific IDE out of several major IDEs just to get a decent editing experience. Not to mention how poorly it speaks of Rust tooling like RLS, [IntelliJ-Rust uses their own from scratch solution.](https://intellij-rust.github.io/docs/faq.html)
This is what vulkano does btw.
But isn't `Ok(foo.bar()?)` the same as `foo.bar()`?
This is just so damn sexy, I _feel_ like this kinda tool would be excellent for distributing targeted backdoors. Needs a `build.rs`
Excellent post and excellent move with aligning RLS version with the toolchain version! Fun fact: we did the same for Cargo a while back. Today `cargo --version` prints the same `x.yy.0` number, the same as rustc. However, due to historical reasons, Cargo's version as a crate is actually `0.yy + 1.0`, so we have to do some fun version massaging to get the desired output for `--version` :-) I am really exited about future development of Rust IDEs! Hopefully we'll be able to focus more on this topic now that 2018 edition is almost shipped, both planing-wise and effort-wise. I am also intrigued by the hybrid approach, although I'd done it a little differently. Instead of leveraging rustc for providing some information (scopes &amp; defs) about all code, I'd use to to provide all information about crates.io dependencies (by using rlibs, rmeta or some other similar format), and handle local crates with the work-in-progress "IDE compiler". The good thing about this approach is that it is a subset of the perfect end state, because, when the "IDE compiler" is fully ready, it will just produce these rlibs itself, to make perf and memory usage optimal. The other approach of gluing rustc and racer along the scopes will certainly lead to a much better (but far from perfect still) immediate user experience, but I don't see this as a step towards the perfect end state.
Add me to the list. Code completion just throws up random things as soon as it sees ::
AH ok, thanks. A bit confusing, though.
You can actually do just that: [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=14b545645c76d11e1ba49d8ba9747e24](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=14b545645c76d11e1ba49d8ba9747e24)
Microsoft is demonstrating an extension they've made to the Language Server Protocol (LSP), the protocol that's also underlying the Rust Language Server (RLS). Their extension allows language servers to run in the cloud and serve requests on code that you don't have available locally. The raison d'être for this feature is that it provides full access to language information while you are e.g. reviewing a pull request from GitHub, but you don't have the branch checked out locally. The post also includes a call to action to help polish and finalize the extension: &gt;As part of building out this service, we've begun implementing LSIF support for various languages (JavaScript, TypeScript, C++, and C#), and we're extremely excited with the results so far. However, in order for this effort to be successful, it's critical that we partner with the community on both the standard, as well as additional language implementations. To learn more about LSIF, and contribute to this conversation moving forward, check out [the draft LSIF specification](https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md). This seems like a very nice way to boost productivity in Rust, if we can apply the same extension to the RLS. **tl;dr** - you can review a PR in VS Code, but still use 'go to definition', etc. without checking out the entire PR branch. This could be sweet for boosting productivity in Rust.
Some repeats from other comments, but my response: * `sort_unstable`, please. It's a bit of an historical accident that stable sort gets the `sort` moniker in `std::slice` and what you really wanted, unstable sort, gets this longer, harder-to-remember name. Such is life. The difference between the two is that the first line in `sort` is `puppy.kick()` but `sort_unstable` skips that. Or maybe it was that `sort_unstable` doesn't allocate and uses a faster algorithm. I can never remember which is the real reason. * The HashMap needs to go, sorry. In JS or other interpreted languages this may feel lightweight because it's basically just an object (I think it's spelled `{}` in JS?). In those languages, even after the JIT is warmed up to get rid of objects' dictionaries, a HashMap still isn't going to be the slowest part of your code. Not so with Rust: HashMap turned a small, quick function into a big, slow function. ("Premature optimization considered harmful" considered harmful, in my book.) To get the full benefits of idiomatic Rust (or other systems languages) you should get used to writing algorithms without HashMaps when possible. (And, if it weren't for historical context it might be surprising how rarely hashtables are used in lower-bound-complexity algorithms.) You've already sorted; just keep track of `mode_key`, `mode_ct`, `current_key`, `current_ct`. * Definitely already covered, but `numbers.clone()` should be avoided. It requires copying the whole vector. Saying `for num in &amp;numbers` was already mentioned but if you've tried that you may have gotten confused/frustrated/carpal tunnel from the result. Write `for &amp;num in &amp;numbers` instead — easy pattern to remember. In `for _ in &amp;numbers` `_` is a pattern which matches a `&amp;i32`; replacing `_` with `num` leaves you with `num: &amp;i32` and then you have to go around saying `*num` to get your `i32`. But if you replace `_` with `&amp;num` instead, which is possible because `i32` is `Copy`, then you have `num: i32` which is just what you get in your current code; no other lines have to change. (NB: if you change the function signature to `(numbers: &amp;mut [i32])` as mentioned below you would just write `for &amp;num in numbers`; the whole clone() problem goes away entirely.) * It's a minor thing, but maybe avoid an unnecessary local variable `l` and write let middle = (numbers.len() - 1) % 2; (and just repeat `numbers.len()` below). But, like, at least name your variable `len`; even years of Haskell have not prepared me for `l` -_-. * By taking a `Vec` as an argument, you may be forcing your caller to write `numbers.clone()` which is just as bad as if you write it yourself. Prefer `&amp;mut [i32]`. Of course, as another commenter said, maybe your caller finds it inconvenient that you're mutating their slice. A reasonable complaint, but by switching to this signature a caller who really doesn't want that can call `clone()` themselves (or create a `Vec` some other way) while a caller who doesn't mind you mutating their slice (maybe they're about to drop it anyways) can skip the expensive allocation. It's just more flexible. But context matters; if you know for a fact your caller will always have a `Vec` that they have no further use for, the current signature would be fine.
It returns the success value -- but your function returns a Result! Thus, you wrap it in the success variant of Result, which is `Ok(...)`.
Peace in ... &lt;impl&gt;
I now want to write "Rust Compiler Cloud as a Service" but also be 50% serious.
Almost. `?` also converts error if needed. 
This has some info although a bit outdated: [https://www.arewewebyet.org/](https://www.arewewebyet.org/) Others have mentioned [Actix-Web](https://github.com/actix/actix-web), there's also [Warp](https://github.com/seanmonstar/warp) and [Tower](https://github.com/carllerche/tower-web). I'm currently using [Rouille](https://github.com/tomaka/rouille) and it works quite nice so far.
[https://cheats.rs/](https://cheats.rs/) has an entry on \`?\` which points to 4 documents.
I was there, and know Ian, he's one of my inspirations for trying Rust on this project :)
That actually will fit perfectly into the current save analysis architecture of RLS.
Regarding your second issue: &amp;#x200B; There are some crates that may help you with numeric stuff, for example: &amp;#x200B; [https://github.com/JelteF/derive\_more](https://github.com/JelteF/derive_more) &amp;#x200B; [https://github.com/rust-num/num-derive](https://github.com/rust-num/num-derive) &amp;#x200B; [https://crates.io/categories/science](https://crates.io/categories/science) &amp;#x200B; [https://github.com/rust-unofficial/awesome-rust](https://github.com/rust-unofficial/awesome-rust)
If you can think of a punny name for it you might be able to nerd snipe /u/Manishearth into doing the remaining 50% that /u/killercup is not that serious about. (I'm willing to buy you peeps some Garlic NaN if that helps.) Yes, I'm substituting reality with one that makes me smile more.
ok perhaps Rust _could_ be used as a first language, but let me offer another perspective: if you had a teach a 10 year old _(who has never programmed before)_ and your options where Rust or Python which one would you pick? I know when I was teaching my nephews (11 and 8) I picked Python, they found the CLI more complicated then Python itself, and looking back no way would I even attempt Rust. But perhaps there are better teachers and I'm a bad teacher I don't know.
So it returns the error as a success code... Bad practice?
I saw there is a vscode plugin, did anyone tried that already? 
There is also a way to [embed a IE11 browser window](https://github.com/vanderlokken/rust-vst-gui) to make VST GUIs. IE11 doesn't support Wasm but we can compile Rust-wasm frontends to asm.js and use them in such embedded browser windows, when [this PR](https://github.com/WebAssembly/binaryen/pull/1786) gets merged. (Currently you can compile Rust to asm.js directly but only with Emscripten which includes its runtime.) Btw, [here](https://user-images.githubusercontent.com/535593/48801114-d0e6a600-ed0b-11e8-9f1d-4f68046fa731.png) you can see one of my MIDI VSTs with such a (non-wasm) web GUI. (It's not styled much, because it's only for my own needs.)
And for the project title pls.
I was about to do the same too as a first Rust project. Just had the time to create the repository :D https://github.com/lerenn/dedup/ I'll look at both of your projects if I'm stuck or if I want to see another way to do :) Thank you ! 
[`gcc -Wharrgarbl`](https://www.rover.com/blog/wp-content/uploads/2016/08/wharrgarbl-dogs-vs-sprinklers.jpg)
Can `git` be used instead of `version` (in addition to `path`) so that it behaves the same way?
Just keep in mind there are two kinds of `time`: bash function and utility. They differ a bit.
But then, the results will be less accurate, won't they?
No, it returns the success value wrapped in an Ok
Oh yes, because try makes it return before wrapping it.
Hello there, starting out with Rust! I really like the feel it gives me, so my long term project is to implement one of my research in Rust (from C++). Today I implement the very text-book dynamic programming algorithm for [computing the edit distance](https://gist.github.com/finalfire/8319b880ef8254b2d3f0d9259e133050) and I'd like some suggestions from you! Is that code ok, from a _rustacean_ point of view? The fact that strings are encoded as bytes for Unicode supports forced me to use the `.chars()` to collect a `&amp;str` in a `Vec&lt;char&gt;`.
It is true: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies (last paragraph).
This community genuinely giving the best answer it can will still give a biased answer. In fact, biases are mostly involuntary.
Only packages with dependencies on only crates.io crates can be published to crates.io, meaning no git dependencies.
done.
I think you issue is due to your toolchain version. What is you current toolchain version (\`rustup show\`)? &amp;#x200B; Can you try to update it by running \`rustup udpdate\` then try to compile again?
I'm quite new to rust and still finding my way around std lib. The code completion of rls constantly throws me off and at this point is a hindrance.
Why nobody reads a subreddit description? &gt; For everything related to the Rust programming language—an open-source systems language that emphasizes safety, performance, and concurrency.
This is what I'm doing (deriving [`EnumString`](https://docs.rs/strum/0.11.0/strum/#strum-macros)): #[derive(StructOpt)] struct Args { /// The file to read path: String, /// The language of the file #[structopt(long)] lang: Option&lt;Lang&gt;, #[structopt(flatten)] verbosity: Verbosity, } #[derive(EnumString)] // this impls FromStr enum Lang { #[strum(serialize="en", serialize="e")] En, #[strum(serialize="de", serialize="d")] De, } 
Thanks for the report, and issue have already been created ([https://github.com/Peltoche/lsd/issues/13](https://github.com/Peltoche/lsd/issues/13)). 
Comparing cargo and bare gcc is really unfair. 
&gt; 3. Cargo is a lot like other package managers many of us have seen, such as NPM, Bundler, or I guess even APT, etc. &gt; 4. Dependency management is integral to modern programming As someone who's between system administration, development, devops, and all sorts of other things: one thing I've been slowly learning to explain better is the context of these tools: * System package managers (e.g: pacman, apt, dnf, yum, portage, pacman) system-level management: network, storage, files, essential services, auditing. * Project/Dependency package managers (cargo, gems, npm, pip): the dependencies of the project can evolve indepedently of the system (but can still theoretically use system or user packages instead) * User package managers (snap, Flatpak, Homebrew): non-root users can install, run, and manage their own applications. 
Apart from TimNN's tip, make sure you don't use any prerelease versions (*-alpha.1 and so on), that doesn't work out very well for the intra workspace dependencies, then you'll start having to edit the versions often again.
Similarly, `cargo new app_name` is *the* way to start and no one runs rustc by hand (unless maybe you're working on modifying the compiler itself). That's why people are pushing back on the idea of introducing rustc to beginners, because they'll never use it again. Adding a disclaimer that you don't need to touch any cargo settings to get started and linking to the cargo docs sound like great ideas though.
I think there's two ways of learning programming: * Start at a high level (ex: how to fetch a URL) and break down how it works as the need arises * Start at the bottom (how memory allocation works, what different data structure characteristics are, assembly, compilers, etc) and work up to building something in a higher level language The first is faster to get started, but your skills are more limited. I think rust is probably a better fit for the latter method, due to the explicitness of memory management.
IIRC intellij started work on their plugin before RLS came into the picture
Hello, I am a big fan of Rust and choose it for almost every project over C++. However, Rust's GUI story is pretty weak at the moment. I would recommend you stick with C++.
How nice. Now I can thank you personally: Thanks!
Piston-Meta is a domain specific language for parsing human readable text formats. It is used in the Dyon programming language for meta parsing. Dyon's syntax is specified in Piston-Meta, so you can parse Dyon files with meta-parsing features in Dyon, or with a Rust application by using Piston-Meta. Also, Piston-Meta's is specified in Piston-Meta, so you can change the rules that you use to parse grammars. This was used to bootstrap Piston-Meta from an old version of the grammar to the new one, while preserving backward compatibility.
Why are we silently downvoting this?
¯\\\_(ツ)\_/¯ I just left a comment with my experience because I didn't want it to look like RLS code completion doesn't work for anybody ...
Question: Isn't `fn x() { Ok(foo.bar()?) }` the same as `fn x() { foo.bar() }`? If it is the same in this case, when would one want to use `Ok(foo.bar()?)` over `foo.bar()`?
Or the Annie operator.
None, cuz no async no life
Yeah, you can have my upvote cause that's really strange. Thanks for leaving hat feedback, as a fellow vim user that's encouraging.
I use [https://github.com/neoclide/coc.nvim](https://github.com/neoclide/coc.nvim), that has the best support for Language Servers so far.
Two quotes from the blog post (TLDR): &amp;#x200B; &gt;a modular, flexible cryptography library &amp;#x200B; &gt;Ursa will be written mostly in Rust &amp;#x200B; The github repo ist still empty though: &amp;#x200B; [https://github.com/hyperledger/ursa](https://github.com/hyperledger/ursa) &amp;#x200B;
&gt; minimize collisions To be pedantic even with 64 bits you'd need to be checking a few billion files to simply get a chance of a collision. The walkdir alone there is going to take weeks/months on enterprise systems, let alone hashing the files. If it's significantly faster then it should be the goto by default though, I'll definitely look into over 
Since I do most of my complication on a remote EC2 instance (32 cores! 244 GB of RAM! Release builds from scratch in under a minute!) this is a welcome development!
That's true yeah. More specifically, Racer existed before IntelliJ Rust, and RLS came into existence approximately a year after. We've never considered using Racer, because it's a heuristics based tool. After RLS appeared, the constant question was "should we switch to RLS?". It was a hard question to answer, but I repeatedly say "I don't know, but I lean towards "no" at the moment", for mainly the following reasons: * it's not clear if RLS can become a foundation for the perfect long-term IDE support, * it's good (for Rust) to have two independent competing implementations, * the specific language server protocol is a bad fit for doing things IntelliJ would want to do (note: the *idea* of a protocol is fine, Dart works via the protocol wonderfully. The specific details of the protocol are inconvenient) It was not a clear-cut decision though, because it was predicated on what RLS would like in the future, and that obviously was unknown.
The VS Code plugin is based on the RLS too
You could have a look at my dotfiles [here](https://github.com/foo-jin/dotfiles/blob/master/vim/init.vim), the rust setup I mostly copied from [jonhoo's dotfiles](https://github.com/jonhoo/configs/blob/master/.vimrc). However, I'm not sure this will fix the issues you listed, since I believe that is more of an issue of RLS itself than the LC plugin for vim.
You are missing `dash.el`, did you install company via `melpa`?
I'm not sure... It's been a while since I installed Company. Can i remove / reinstall via melpa? How would I do that?
I'm using YouCompleteMe for Rust autocompletion in vim. I think it uses Racer internally. It works most of the time, although sometimes the server crashes and needs to be restarted with :YcmRestartServer.
Loved the drawing of Ferris in her Yak shaving boutique :)
thanks. I don't think it's an issue with RLS as everything works using VSCode.
There's nothing in Rust that compares to JUCE unfortunately. Maybe that can change with time. And as various people have said the GUI story isn't great atm. &amp;#x200B; The language is great though, and I think for audio in particular has a lot to offer. A mini-DSL for rust for writing dataflow seems very doable, for example. Generics in Rust is way easier to work with than C++. And I'm hopeful that once SIMD support stabilizes then Rust will have nice solutions for it. It will just be up to people in the community to step up and make it happen, in the same way that the Amethyst/Piston communities did for games. 
Please, please video this. 
As u/mookid11 says, `dash.el` is a library, you can get it from any of the package archives, you could also remove `company-capf` from your backends since you weren't using it anyway.
Some more how-to-play instructions or simply better game feedback would be nice. I somehow managed to do the first batch of recipes, more by luck than anything, but I still can't say I understand what the various UI elements even do.
I tried &amp;nbsp; M-x package-reinstall [RET] racer [RET] Got this error Leaving directory ‘c:/Users/stuarts/AppData/Roaming/.emacs.d/elpa/racer-20181023.2304’ Compiling file c:/Users/stuarts/AppData/Roaming/.emacs.d/elpa/racer-20181023.2304/racer.el at Wed Dec 5 14:10:20 2018 Entering directory ‘c:/Users/stuarts/AppData/Roaming/.emacs.d/elpa/racer-20181023.2304/’ racer.el:189:1:Warning: Unused lexical argument ‘args’ racer.el:189:1:Warning: Unused lexical argument ‘command’ In racer--call: racer.el:207:15:Warning: reference to free variable ‘exit-code’ racer.el:214:9:Warning: reference to free variable ‘stdout’ racer.el:464:1:Warning: Unused lexical argument ‘it’ In racer--propertize-docstring: racer.el:472:28:Warning: reference to free variable ‘section-type’ racer.el:477:27:Warning: reference to free variable ‘section’ racer.el:588:4:Error: Wrong number of arguments: #&lt;subr symbol-name&gt;, 0 Compiling no file at Wed Dec 5 14:10:22 2018 This is so frustrating! I also tried dropping dash.el into my lisp folder for emacs. No bueno. Also reinstalled company. Still errors! Argh
I only found [https://github.com/ctaggart/octh](https://github.com/ctaggart/octh) which allows to extend Octave in Rust. If such a binding does not exist yet, someone would have to write it. 
Reinstalling racer I get the error M-x package-reinstall [RET] racer [RET] Leaving directory ‘c:/Users/stuarts/AppData/Roaming/.emacs.d/elpa/racer-20181023.2304’ &amp;nbps; Compiling file c:/Users/stuarts/AppData/Roaming/.emacs.d/elpa/racer-20181023.2304/racer.el at Wed Dec 5 14:10:20 2018 &amp;nbps; Entering directory ‘c:/Users/stuarts/AppData/Roaming/.emacs.d/elpa/racer-20181023.2304/’ &amp;nbps; racer.el:189:1:Warning: Unused lexical argument ‘args’ &amp;nbps; racer.el:189:1:Warning: Unused lexical argument ‘command’ &amp;nbps; &amp;nbps; In racer--call: &amp;nbps; racer.el:207:15:Warning: reference to free variable ‘exit-code’ &amp;nbps; racer.el:214:9:Warning: reference to free variable ‘stdout’ &amp;nbps; racer.el:464:1:Warning: Unused lexical argument ‘it’ In racer--propertize-docstring: &amp;nbps; racer.el:472:28:Warning: reference to free variable ‘section-type’ &amp;nbps; racer.el:477:27:Warning: reference to free variable ‘section’ &amp;nbps; racer.el:588:4:Error: Wrong number of arguments: #&lt;subr symbol-name&gt;, 0 &amp;nbps; Compiling no file at Wed Dec 5 14:10:22 2018 This is so frustrating! I also tried dropping dash.el into my lisp folder for emacs. No bueno. Also reinstalled company. Still errors! Argh 
thanks. Will try out that one as well. Currently running into issues: [https://github.com/neoclide/coc-rls/issues/2](https://github.com/neoclide/coc-rls/issues/2)
Still seems like an Emacs problem, you shoud search r/Emacs for more explicit answers
Very nice talk. At some point in the slides you check arguments to the C-visible functions with `assert!`. Doesn't `assert!` panic, which is a big no-no at language boundaries?
Is ferris female and/or is it a unisex name? Not that it matters either way, but the only time I've really heard that name outside rust is for ferris Bueller's day off.
The sibling comment here – that Google Podcasts won't play nicely with RSS and thus normal podcasts – is the reason I've never put it there. They also repost and recompress your audio, which I dislike, and reserve right (not acted on to date, as far as I know, but it's there) to play ads around your show in your playlists, etc. It's just kind of gross to me, and I'm pretty staunchly an advocate of the open web approach for podcasts. (This is the same reason the show isn't on Stitcher: their terms are onerous to me.) Podcast Addict was a good-enough tool a couple years ago, so I hope that works for you! And sorry for the hassle my personal hangups on this cause!
Unpopular opinion but semver is not the be all and end all. The correct versioning would be: 1.31-0.x.y and not 1.31 
Have *you* tried c# + resharper?
I also opened a github issue about this, but for a more casual conversation: Would it be difficult to fall back on standard unicode symbols for the file and directory symbols (and other symbols you may need).
Hi folks, &amp;#x200B; I'm wondering if there is a good way to run other programs from the system (e.g. anything on the PATH) in Rust? &amp;#x200B; For context, I'm taking this as a cool first project after my post on this subreddit yesterday... (trying to keep a lower profile so I won't link to the post, but if you recognize me, hi! That's me!) &amp;#x200B; Someone suggested I try taking one of my bash scripts and porting it to Rust. So one of the chief things I'd need to do is be able to run external programs. I'd love to know a code snippet or a brief bit of documentation that's a good way to do this. (Or an easy way and work myself up to the "proper way" if the proper way is harder.) &amp;#x200B; I'm coming from beginner/intermediate bash and knowing about 1% of Ruby enough to tweak an existing file. &amp;#x200B; I know enough to compile Hello World and am otherwise "aware" of programming stuff mostly from reading (rather than writing) code. &amp;#x200B; Thanks! Have a nice day!
Looks like more substantive work exists in one of the forks: https://github.com/mikelodder7/ursa
Not quite the same. The question mark version also includes the possibility of converting the Error type is there is an appropriate implementation of the From trait.
Fair enough, but I've learned more by "tiling at windmills" than I ever did with tasks appropriate to my skill level. At least I'll know more about what my needs are after I give it a good first go. I'm motivated to give Rust a try, and the other languages aren't exciting for me right now, so the choice for me is Rust or "not learn programming today." But in general you might be right. 
The module for working with subprocesses is std::process, documented at https://doc.rust-lang.org/std/process/index.html. It includes some examples of creating new processes and connecting to their input and output streams.
Haha yes, I'm hearing that the tools are good in this thread. And I think that's a big part of the point of Rust. The gap seems to be between not knowing programming really at all (like me) and being able to pick up Rust. There are so many newcomers to programming who want to learn C. So, naturally, there are introductions to programming written in C. I think the Rust community could have a few more options of good "learn to program" with Rust tutorials, and options for documentation friendlier to new programmers.
Hi, I'm pretty much an amateur at using ffmpeg, so I haven't quite used something like that myself, so I'm not sure what it looks like. Is there any examples of code that shows this? I'd be happy to make changes to my code!
is it just me, or are Bear references probably not a great idea in the name of a cryptocurrency-adjacent project?
It's working just fine. I've already listened to several episodes and so far I'm really enjoying it. I was just curious. It's nice to have everything in one place but I'm not apposed to using a separate app if I need to. Keep up the good work!
Because of [Thomas Pornin ](https://security.stackexchange.com/users/655/thomas-pornin) and [Tom Leek ](https://security.stackexchange.com/users/5411/tom-leek)? Or is there some other reason?
You generally can't call C++ code directly from rust. You'd need another bit C++ code that exposes a c-compatible API first.
Yes, that's why I think no one has done it so far.
\&gt; Similarly, \`cargo new app\_name\`is *the* way to start \[a new Rust project\] Yes! That dawned on me. The more I try to explain why I didn't like Cargo when I first ran into it (a few years ago), the more my experience with Ruby on Rails (since then) contradicts my point, and ends up illustrating why I \_should\_ like Cargo. I suppose I'll come around to liking it. I'll still probably run rustc a bit here and there when doing Hello World and similar, since I'm an oddball (and it hits the neurons in the reward loop of learning C!)... But I know a serious and public-facing project deserves (and basically needs?) Cargo. I think I can wean myself off of rustc.
Yes, it does. [From the official documentation](https://doc.rust-lang.org/std/macro.assert.html): &gt; Ensure that a boolean expression is true at runtime. &gt; &gt; This will invoke the panic! macro if the provided expression cannot be evaluated to true at runtime.
Point taken, but all of the hyperledger projects are private chains, so they have no cryptocurrency.
Just adding a small thought about the use of Cargo. If you compare it to how you compile code C/C++, once you get past programs with no external dependencies, Cargo wins hands-down. With C/C++, you have to figure out the right flags to pass to the compiler and the right order in which to tell it to build the code. If you're really unlucky, you'll have to learn two separate build systems (the Make build system and CMake, the build system for Make (i.e., you are using a build system for your build system, an excellent indicator of how horrible the tooling is)). With Cargo, you just add the dependency to the \`Cargo.toml\` and then you use it. Compilation headaches are all handled for you!
I saw a comment within the last couple days that said the panic language boundary thing is going to become safe by default soon, though I don't remember where it was.
Thanks!
Its the fastest in my experience. It's a little verbose and i found it hard to figure out sometimes. Knowing the Erlang/Elixir (Actor model) design patterns is a major boost.
If you happen to know: Where can I report a bug in the documentation? I think the first code snippet there doesn't run properly in Rust playground.
Symbol support is there. See [https://github.com/neoclide/coc.nvim/wiki/Language-servers#supported-features](https://github.com/neoclide/coc.nvim/wiki/Language-servers#supported-features)
It's here https://github.com/rust-lang/rust/pull/55982
This is the subreddit for the rust programming language.
Fuck my bad thanks 
Wrong reddit. This is for the programming language rust. Not the game rust.
Ah, got it, I missed that part
Just realized thanks 
This was a really great presentation! Thanks for posting.
I use deoplete and LanguageClient, but I don't know if they work with regular vim (I use neovim).
Awesome! You're very welcome! :-)
Thanks so much! I struggled with how exactly to set this up for such a long time! 
Small piece of feedback. You have this line: println!("Somehow a vector of negative length got made. Please report this as a bug"); In cases like that, where your basic assumptions about your program are violated, it's usually better to use `panic!` rather than `println!`. That way you're more likely to notice the problem as early as possible. In this particular case, I wonder if you added the line because Rust was forcing you to put a `_` clause at the end of your `match`. (`match` is good at noticing that you've handled all the variants when you're matching on an `enum`, but with other data types it usually requires that explicit default clause.) You might be able to refactor your if+match into a single if statement to avoid that issue, something like `if file_length==0 || files.len() &lt;= 1 { return files; } else { ... }`.
Small piece of feedback. You have this line: println!("Somehow a vector of negative length got made. Please report this as a bug"); In cases like that, where your basic assumptions about your program are violated, it's usually better to use `panic!` rather than `println!`. That way you're more likely to notice the problem as early as possible. In this particular case, I wonder if you added the line because Rust was forcing you to put a `_` clause at the end of your `match`. (`match` is good at noticing that you've handled all the variants when you're matching on an `enum`, but with other data types it usually requires that explicit default clause.) You might be able to refactor your if+match into a single if statement to avoid that issue, something like `if file_length==0 || files.len() &lt;= 1 { return files; } else { ... }`.
Are you sure? You may have to wrap those snippets in a `fn main()`. Most statements can't exist outside of a function or macro.
yeah, but as far as I see not supported by the rust extension..
I ran \`rustup\` and got \` rustc 1.30.1 (1433507eb 2018-11-07)\` with \` cargo 1.30.0 (a1a4ad372 2018-11-02)\` &amp;#x200B; \`cargo install lsd\` then reports \` error: could not find lsd in registry \`https://github.com/rust-lang/crates.io-index\` &amp;#x200B; So then I installed rust nightly, installed lsd, and got errors while running
I like what you are doing with lsd. I am having a problem though getting the icons to display properly. I am getting a box with a ? in it. The color of the box and the ? mark match the color of the file name. I would attach an image, but I can't figure out how to do it :( I am running on Mac OS 10.14.1. I installed the nerd fonts per the Nerd Font Readme Option 4 ( brew cask install font-hack-nerd-font ). My toolchain version is 1.30.1. Any ideas? Thx, lbe &amp;#x200B;
I don't really know, "Ferris in her Yak shaving boutique" was the title of the drawing in the presentation.
I use the setup described here: https://afnan.io/2018-04-12/my-neovim-development-setup/ And it’s worked fairly well for me. I think you c can specify options through the flags you call the LS binary with
It used to only apply to `Result` and application to `Option` was added later. Thus older articles only refer to `Result`.
I haven't used JUCE, but I certainly am doing audio programming in Rust. I think my stuff is promising, but very unfinished compared to the mature environment that JUCE provides. If the author wants to get audio plugins written, use JUCE. If the author wants to get involved in helping build the low level infrastructure, then my synth codebase could be appealing.
I ran to program locally as it runs in Rust Playground (they auto-wrap it in `fn main()` ). There is a pprently no output to the terminal? I used a simpler example from here to get some progress going: [https://stackoverflow.com/questions/21011330/how-do-i-invoke-a-system-command-in-rust-and-capture-its-output](https://stackoverflow.com/questions/21011330/how-do-i-invoke-a-system-command-in-rust-and-capture-its-output) &amp;#x200B; Apparently it is uncommon to want to just let an external program run? Meanwhile in bash that is almost all you do. So I don't need most of the features in these examples. My code looks like this: fn main() { use std::process::Command; Command::new("echo") .arg("Hello world") .status() .expect("echo failed to run"); } &amp;#x200B;
I've also built a ray tracer similar to yours a while back, but I notice the same problem here as when I built mine was that I spent far more code building a quasi-framework around the ray tracer. For instance your \`world.hits(ray...)\` is very highly coupled to \`Hittable\` (I used \`Collable\`) This in itself is a form of (I'd say unnecessary) complexity, and ought to be deleted. Nowadays I just use a simple function: \`raytrace(grid: &amp;Grid&lt;T&gt;, from: Vec2, to: Vec2, predicate: fn(&amp;T) -&gt; bool)\` just for finding collisions on a grid. That'd be my only suggestion. Just make it a function that depends on \_very simple\_ data types. No traits required.
&gt; Is ferris female and/or is it a unisex name? Ferris is canonically agender.
I might be misunderstanding your issue. Are you saying that TabNine launches an instance of RLS in addition to the instance that is already run by your editor?
(And I hope it doesn't come across as too critical!) 
Hi, I think it's indeed a font related issue. Are you sure that your terminal used the correct font? Which terminal emulator do you use?
Can someone please remove this?
you might find the :hook directive useful
This should be part of the rust layer in spacemacs.
awesome link. Thanks!
1. Using enums that way is absolutely normal, yes. You can also use traits to do dynamic dispatch, but there's nothing more correct about one way or the other--which one is best to use depends on the situation. 2. My guess is that the largest data structure you're implementing the operators on would be a 4x4 transform matrix, right? And probably most of your operations are on vectors, which are even smaller? In such a case, I would just implement the operator traits for \`self\` (no borrowing) so it works by value. That's what I did for the math types in my path tracer, in any case.
It really depends on the use case, but as someone working in the ops world, and writing a metric ton of custom tooling for ops - all in rust - I can tell you it works very very well.
Intellij does the same for scala. In the end all other code completion tools pretty much died due to Intellij, while not being perfect, atleast being reliable. It's a shame, cause Intellij has a LOT of limitations due to the fact they don't use native language tools. Advanced language features are hit and miss, and Intellijs code recognition tends to be behind on newer language features. If only Intellij would choose to work with the open source community and improve those language servers, instead of building their own. Maybe it's a business decision, maybe the native ones are simply too ambitious in scope.
Can I ask you to elaborate a little more, if you can? I’m working for a big international company that deals with huge data and will need som monitoring and data collection tools 
Agree 100%! I'm not a Rust expert - I just finished the core book, and I've put a bit of work into a project over the past couple weeks. I went back to doing some JavaScript code for work on Monday, and as I'm coding, I'm thinking things like, "I'd better handle null/None!" and build in the check that I would have used in Rust. Being constantly "bothered" by the compiler has very quickly built a habit of thinking about what I'm doing, even in other languages!
Monitoring of what? And collection of what kind of data - and where’s that data going? Aside from the technical considerations (which are simple, rust can probably do it, and do it well) you have to consider your team too, is this tooling going to be worked on by more than just you? Even if it isn’t now, it most likely will be in the future. You need to consider the size of these projects and who will be involved in it. Implementing a small tool to showcase rust to your team and get some experience of it would be good, creating an all consuming monitoring monolith and thrusting it upon an unsuspecting ops team will definitely not end well.
As of now I’m looking to introduce to team to it. We are talking bout 10k of machines spanning 20ish dcs in the globe. Not going to drop it on the team but maybe give them a start of how we can collect info on system properties and some metric to send to the Noc to proactively action on them. 
One person's frustration at the compiler is another person's opportunity for learning. Brilliant to hear you feel that Rust has changed you permanently - I feel the same way!
The new version of linkerd has its data plane in rust, and it’s control plane in go. Habitat is an ops tool written entirely in rust. The low memory and CPU usage is making it really nice for sidecars, it seems.
Fair point on the collisions. I have thought about this issue and I may move to another hash. On the question of a byte-by-byte comparison; given the relative performance cost of IO I'd rather just do two hashes while doing the "full" check.
Glad you liked it :)
Cool examples, ta! 
That's a good point. In this case I think the println predates my use of a match, but either way you're right it could be cleaned up.
rust has a very good cli tool development story, and its advantage over python is deployment - you can build binaries that have no or very few dependencies on the host machine.
Thanks for the feedback. I'll give highway hash and your article a look. I skimmed the rmlint article and one issue that I sidestep is in removing files. Any actions around the duplicate files are left to the user. ddh is purely a discovery tool.
That sounds really good. I think I tried once a rust app called ripgrep and it had no demos :)
Very similar thoughts and feelings. I went through almost all of the 2nd edition of the core material, sometimes referencing the first. I wrote a simple program to do some processing work on images. It was a good exercise. My day job is in C#, but Rust has made me much more aware of the things you’ve mentioned, even within a GC environment. In my free time I’m now learning modern C++ and I think first about my lessons from Rust. It helps me be proactive in how to defensively code against bad practices. Quick aside: A Tour of C++ is a good and helpful book, and Bjarne seems like a very thoughtful man.
I’ve wrote all custom tooling at my current employer in Rust. The main selling points to me were: * ease of making a binary that you can throw into any machine and run (rules out any language that is not producing statically linked, self contained executables); * ease of cross-compilation (no C/C++). It really helped to have things like `clap` available, and I never encountered a case where the the ecosystem fell short. That being said, all the tools I’ve written were trivial things like e.g. DHCP monitor for the network, so my experience may or may not be as applicable to the larger tools.
I actually like this approach, but am not sure why it's not performant? My initial idea was to create a vector of vectors of (1000 x 1000) zeroes and then increment sections of it as I process each square, and the two seem comparable. 
In my opinion, it’s much more technical than business: building compilers that work for IDE is hard (b/c you can’t just bolt IDE features on top of existing batch compiler, despite the fact that this seems like an obvious solution). So, usually there just isn’t an open-source thing that has the right architecture to be used inside of the IDE. I know very little about the Scala situation, but I think it exemplifies this problem. IIRC Scala presentation compiler, which was suggested as the open source solution for IDEs, didn’t work perfectly either. And now they are building dotty, which promises to be a new compiler, build with IDE use-cases in mind from the start. That probably means (pure speculation on my part) that the original presentation compiler wasn’t quite up to the task of providing good IDE experience.
Same here. The patterns that Rust enforced, transfer to other languages by habit, and lead to better code there as well.
Hi ! Here you can find my setup for neovim + Rust [https://github.com/dymayday/bearded-happiness/blob/master/neovim/init.vim](https://github.com/dymayday/bearded-happiness/blob/master/neovim/init.vim) I hope you will enjoy, feel free to ask anything :)
Curious why you chose `emacs-lsp` over `eglot`. I am currently using eglot and am pretty happy but have been thinking about switching.
YAY! good stuff /u/azrielh !
It's actually been available on stable for quite a long time at this point, you just have to use a (vastly superior) third-party crate to provide the harness: https://github.com/japaric/criterion.rs Once you write a criterion benchmark, and add the appropriate things to your Cargo.toml file, you can literally run `cargo bench` and it "Just Works", as they say.
Awesome project! I really like you've used Lua to describe scenes and integrated that with the rest of the ray tracer. &amp;#x200B; Nice job!
&gt; making Cargo mandatory. Nothing changes about the mandatory-ness of Cargo. You still needed to pass `--extern` to rustc for each `extern crate` you used. The interface between Cargo and `rustc` hasn't changed at all. 
I might help with the Todo app. I've been thinking about what features I would want in one, and have an idea for a format. Is there a repo for the Todo app?
This seems to be closer to the Haskell: input.chars().fold(Vec::&lt;char&gt;::new(), |mut stack, c| { match stack.last().cloned() { Some(v) if v != c &amp;&amp; c.to_ascii_uppercase() == v.to_ascii_uppercase() =&gt; { stack.pop(); } _ =&gt; stack.push(c) } stack }).len()
I don't mean to be one of those guys, but I also kinda do, haha. Have you thought of asking your workplace if they would consider moving parts of the program to Rust? Perhaps the most important parts, or parts that don't interface too much to outside C/C++ libs? I'm sure they'd understand why if you explain to them the benefits that would occur.
If this is indeed the intended path going forward I would hope the current rust leadership would say that out loud. If something is part of the toolchain it should be its best possible version or not exist. If they are conceding to Criterion I agree it should be removed since it never made it to stable. Alternatively they could come to an agreement with Criterion to adopt it as the implementation of the standard api. Thanks for the insight!
Yes it seems that's the case. I'm using VS Code, and when I'm looking in process explorer I see this: &amp;#x200B;
Are you on Windows and happen to have the source files in CRLF line endings? If true, try converting the files to LF. There seems to be a bug with rls-vscode or somewhere else.
That sounds awesome! Imag is developed in a monorepo, you can find everything you'll need on https://imag-pim.org There is an existing to do app, but feel free to completely reimplement it and change everything. If you have questions on the imag infrastructure or how to solve certain problems, feel free to contact me either privately by mail or over the mailing list. Feel free to ask questions on how imag stores structured and non-structured data if you have questions or you're not sure how to store to do data. I am not sure right now whether I have notes in the repo on what I'd like to see in the TODO app, so feel free to write up your thoughts and send them to the ML! Note that I'm on a sabbatical and might respond slowly. 
In contrast to what /u/Bourgond_Aries suggests, I think using Rust's trait system is very appropriate here; I'd just do it differently. In the (very vanilla) [path tracer I wrote](https://github.com/cdbfoster/rsrt/blob/master/src/main.rs#L680) as a similar exercise, the scene and all the objects in it all implement the `Shadeable` trait, whose `cast_ray` method casts a ray at the object (or scene) and, if there's a hit, returns all the data required to shade the intersection point. Rust's type system is very powerful and is intended to make situations like this simpler. It doesn't make sense not to use the tools you have.
Ah nice. I didn’t know that existed.
I have to balance multiple competing demands - risk of breaking something (old, fragile, under-tested code is prevalent), time to make the changes, benefit given to me as a developer, and benefit given to our users. Though the product is in it's sunset phase (has been for almost a decade... it just won't die!) we still have over a hundred-thousand users of it. Plus, because of the time it would take to upgrade as well as the perceived lack of benefit, I'm stuck on a literally decade+ old compiler and IDE. 
I feel like I understand what you mean. This may be useful for something like ffmpeg's [AVBufferPool](http://bbs.chinaffmpeg.com/html/group__lavu__bufferpool.html), I'll see what I can do
&gt; Now my question is, I guess, how good rust is for those kind of tasks. Also, how stable is the language in as versions pile up? Depends: * Streaming network services has been painful as `tokio` doesn't model 2+ network streams concurrently sharing state well. * API end point stuff service stuff has been _so successful_ I had to transition roles as the project was effectively _done_ and required so little maintenance that saying I spent significant time _working_ on those services made me feel guilt. Time was just spent on a feature by feature basis. * CLI stuff has been the biggest success story. There are 2+ year old projects that haven't required a single change to keep building, and functioning as expected. Cargo is extremely good at managing dependencies. * Static builds are awesome b/c once built you can just chuck the binary in `$PATH`, give it to a coworker, what ever. Not necessarily true if you link to `openssl`, but for non-network, or pure CLI stuff for CI/CD integration tasks I've found little equal. `go` works well, but its dependency management isn't _as easy_. * I want to just give `clap` a shout out. As it makes writing a rich CLI docs+options super trivial. I'm kind of at the stage I'd rather see my coworkers write a `rust` tool then give the give me a `python` script as it'll be more predictable in 1-2 years. I'm not sure how smooth the 2015-2018 epoch change will be, but I have faith it'll be handled smoothly. 
Yeah, given that the nightly bencher has been ported to stable as a crate (similar to criterion) I wonder why we even have the nightly only version. https://crates.io/crates/bencher Only thing missing is black_box and Criterion provides one so clearly it's possible.
I am on windows but the files have just LF line endings.
https://github.com/BurntSushi/ripgrep/blob/master/README.md https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md All of the information you could ever want about ripgrep is in the top level directory of the repository. Is there something I'm missing? 
I use http://nvim.fisadev.com/ which works really well for me.
In my personal projects i am currently fighting with rustc to make a structure thread safe. At work i was recently struggling with using an asynchronous native Python extension. I often wondered "should i protect this Python data structure with a lock?". I read about which operations should be protected by the GIL. I assumed what i did was correct, but i wasn't sure. I wished that rustc was there shouting at me if i'd made a mistake.
Publish: https://github.com/getsentry/symbolic/blob/master/scripts/cargo-publish-all Bump version: https://github.com/getsentry/symbolic/blob/master/scripts/bump-version
&gt; Only thing missing is black_box and Criterion provides one so clearly it's possible. Unfortunately, it isn't. Criterion.rs emulates `black_box` using a volatile read - a trick I copied from `bencher` - which is imperfect in poorly-understood ways (at least, poorly-understood by me). We still need a stable `black_box` which clear guarantees - see [here](https://github.com/rust-lang/rfcs/pull/2360) for the current stabilization issue.
I'm not sure what exactly qualifies as ops, but my first rust program (ever and for production use) was written in rust. It collects stats like database sizes, test some endpoints, check if things are running, etc etc. It has a json and a prometheus endpoint, so I can view things in time series (and prometheus is pretty cool tbh). It worked first time I deployed it, over hundreds of servers, and there has not been a single run time error, or unexpected behaviour in a year. Memory usage is small and constant, and it's fast (although this specific app doesn't need to be particularly fast). It's not a particularly impressive app, but I've coded it once, updated it once or twice, and it has never once failed. Other ops type things I've done was cli tools for things relating to our services. Cli tools in rust are absolutely fantastic to write. Incredibly fast robust and stable. (we even briefly used rust binaries on amazon elastic map reduce, which is essentially just cli binaries that read from stdin and produce some transformed output to stdout) The obvious downside with this is that coding in rust for ops stuff will take longer than python for example. That is, until you have a relatively good grasp of the language. Then development will be much faster. In my personal opinion, the fact that rust code pretty much doesn't break if you don't do silly things, has saved countless hours in my life. I'd definitely make a case that taking time to become proficient in rust and writing some good apps will save way more time than being able to churn out apps in a language that's quick to develop in like python. Not hating on python, I develop in it too, and all tools have their uses. But the stability of rust programs definitely is the greatest benefit to me. I don't have to worry if things will break or behave unexpectedly if I handle errors properly (sure this is true of other languages, but in rust you pretty much have no choice than to handle errors). I know all of the code paths are defined, because rust forces me to handle them. Or makes me explicitly type out .unwrap if I'm feeling naughty. The type system is incredible, and the lifetimes and ownership system is weird at first, but learning how it works will make you a better programmer in all languages. TL;DR: greater than normal learning curve. New language concepts, slow(er) development. Huge gain in long term stability and confidence in code. 
Impressive and scary. Thanks for sharing it. Be fearless: write the narrative! I personally couldn't match /u/aphyr_'s amazing writing, but I'd love to read whatever you could manage.
How does defining an empty enum to be able to take a pointer to it work? Shouldn't that be impossible (essentially the same as taking a pointer to `!`), or are the rules just different for raw pointers?
I should be fixed into the 0.6.3.
I should be fixed into the 0.6.3.
It's not recommended. You should use `#[repr(C)] pub struct Foo { _private: [u8; 0] }`. Sadly, the book recommended using `enum Foo {}` for a while, as it used to be general practice, but wrong. https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs (Last paragraph points to the problem)
I'm not quite sure what `flycheck-rust` actually does, as my regular-old-flycheck config seems to work fine (IIRC- I haven't work on a Rust project in some months). I also use `cargo` package and `toml-mode`: (use-package cargo :ensure t :diminish cargo-minor-mode :hook (rust-mode . cargo-minor-mode)) (use-package toml-mode :ensure t)
They should basically be the same thing, no? `eglot` is great if you work in many languages, but maybe OP only works with a handful of languages with LSP implementations.
Thanks!
And that's one thing I like. Yes, you can get bogged down trying to accomplish something Rust won't let you do, for whatever reason (such as moving a boxed trait object) and you have to re-architect to do things differently. Maybe you can post the structure and seek guidance on making it thread-safe? 
You're right, thanks for checking!
Does this have something to do with the way \`rest\` refers to a match that refers to the original input? Perhaps returning a map whose values are \`String\` types would be soothe the borrow checker. 
You seem to be reading the file in your parse function. That means the data you're parsing lives locally inside your function. It you want to return data borrowed from the input, your function should take the file contents which has been read in already. If you insist on this function reading the file, you will need the return value to contain String instead of &amp;str.
The problem is that you load content of file in String here let input = fs::read_to_string(input).unwrap(); And that String gets dropped at the end of the scope, but you are trying to pass (dangling) reference to this String out of function.
Got it, I understand now. Thank you !
Little rectification to make: &gt; No RFCs were approved this week And then 2 approved RFCs.
Not recommended seems like an understatement :) It's undefined behaviour. Reported here, thanks! https://gitlab.gnome.org/GNOME/librsvg/issues/391
I sometimes feel like Rust has made me lazy. Yes, I am aware of all those things I should be thinking about, but since the compiler has my back covered and will refuse to compile my code if I make mistakes, I have grown reliant on it. I often find myself writing Rust without thinking or paying attention to anything, and then just doing a little back-and-forth dance with the compiler until I fix all the errors. Since I've seen many of the error messages a quite lot at this point, this is also a pretty mindless process. I just glance at the message and I know what to go fix.
You should drop an issue on either racer.el or dash.el on github. github is more appropriate for this kind of discussion. Good luck! (:
Wait, what? TIL. I swear not too long ago it still had Enum? What issues does it have? Those should be linked? Why was it recomended for so long if it was undefined?
Oh, that's neat! I'll make that refactoring soon :)
Hmm, I may not need `flycheck-rust` then. I know LSP is what's providing info to `flycheck`.
No particular reason. `emacs-lsp` seems slightly more mainstream? I'm sure both are fine.
What does their layer currently use? A year or so ago I was just using `flycheck` + `racer`, but I actually found that the LSP integration in Emacs was good enough to just install the RLS and be done with it.
Good post. I think I already write very defensive code in C. Rust it is like my imaginary friend thinks the same way about races and memory issues like I do. /No I don't have schizophrenia :D 
https://doc.rust-lang.org/proc_macro/struct.Span.html Try calling Span::call_site().source_file(). Is that what you're looking for?
The link is 404 for me?
The issue it has is that dereferencing such a pointer is UB. I'm not sure where to link to, the Nomicon itself would be the source to write about that. The reason it was in the book is that people figured out that there was a problem, but the signal got lost somewhere when the FFI section of "The Rust Programming Language" moved to the Nomicon. We found that out when I was teaching that as a representation for opaque pointers at an advanced training at Mozilla with Simon Sapin in the room and he was like "where did you get this from?"... we fixed it shortly thereafter.
FYI `eq_ignore_ascii_case` is a thing. I'd argue most idiomatic Rust would be the manual loop with a pattern rather than `cloned`: for c in input.chars() { match stack.last() { Some(&amp;v) if v != c &amp;&amp; c.eq_ignore_ascii_case(v) =&gt; stack.pop(), _ =&gt; stack.push(c) } } len(stack)
Exciting!
They each have different frontends, eglot uses flymake and lsp uses flycheck etc.
lsp is a lot larger and more features but a lot harder to setup other language servers. Eglot is very minialistic etc.
I got lazy too and when doing C++/C this is the feeling. Everything is dangerous to look at, stupid yet extremely hard bugs to track and everything else... exactly what you said, emotionally draining. Like, 18 years of C/C++ hardened skin to be softened again after (sporadically) a few of Rust.
&gt; To be pedantic even with 64 bits you'd need to be checking a few billion files to simply get a chance of a collision If by "chance" you mean "reasonable expectation". 20 million files [is sufficient](https://www.wolframalpha.com/input/?i=probability+1+-+exp(-0.5+*+20+million+*+(20+million+-+1\)+%2F+2%5E64\)) for a collision rate of about 1 in 100,000.
To add to the positive sentiment, I might not have any opportunities at work to use Rust (yet), but as a self taught programmer working with mostly dynamic languages reading the book and messing around with Rust on the side has definitely made me a better and more confident programmer. Working with the Rust compiler has forced me to think about code in new ways that I believe has resulted in me writing better and more reliable code.
Yes it was marked as security issue, which by default makes the issue confidential. It's still there :)
Really looking forward to this stuff landing on stable :)
Having whole installation GPG signed would be a nice first step. Then signing key(s) could be signed by several Rust developers with Keybase + public video when they loudly read whole fingerprint. FWIW this is what Peter Todd did, so I was able to verify Bitcoin signatures more easily.
If you haven't given TypeScript a whirl yet, I suggest you do! It's not as sound as rust's type system, obviously as it's built on a dynamic language, but it's a much better experience than vanilla JS.
I have built tools in rust to help with our internal tooling and smoke screen testing. Every new little cli app I need to write, I write in rust. I wrote [lorikeet](https://github.com/cetra3/lorikeet) in rust and this little tool is used in production for our application level monitoring, among other things. The only issue I had was compiling with musl caused some unknown segfaults and infinite loops, so now I just distribute a binary for each platform (debian, centos, etc..).
Don't beat people up over it. :) This is Rust's problem, we caused this by recommending the wrong thing and then changing.
&gt; The issue it has is that dereferencing such a pointer is UB But isnt the point not to dereference it? Thats what an opaque type is? Why is that an issue?
&gt;ack covered and will refuse to compile my code if I make mistakes, I have grown reliant on it. I often find myself writing Rust without thinking or paying attention to anything, and then just doing a little back-and-forth dance with the compiler until I fix all the errors. Since I've seen many of the error messages a quite lot at this point, this is also a pretty mindless process. I just gla At least, it's a bit less dangerous to be lazy when you use Rust. Because if you are lazy in C++, you don't have the compiler kicking you in the face. In 2018 I think it's good to be "lazy" on that point, I prefer to work on something else instead of wondering if my code is safe.
Thanks
\&gt; I am maintaining a 20+ year old C++/etc legacy application, &amp;#x200B; And do you want to re-write this app in Rust ? :)
Worth reading just for the term "compiler driven development".
That said only files with the same length have their hashes compared against each other in my code. You'd need to have 20 million files of the same length to have a worry about duplicates (at a rate of 1 in 100,000).
Thanks for listening, and for being understanding!
Has TLS support directly rather than just punting with "use a reverse proxy". 
Having used Conrod in a big project, this is good to see. The backend stuff always caused grieve so hopefully this solves those issues.
https://internals.rust-lang.org/t/size-of-uninhabited-types/7651 The problem is that `enum Void {}` and `!` are considered uninhabited, while the type described above is inhabited, but also cannot be practically constructed.
The removal of `extern crate` declarations means that the source code is no longer as "standalone": you need to have access to the `Cargo.toml` file or whatever compiler invocation is being used to have any insight into what crates are being used by the source code. If somebody hands you a bare source file or even a whole source tree, it will no longer be easy to see what it depends on. The only reasonable place to store this information, as far as I can tell, is in `Cargo.toml`. This almost guarantees that Rust users will be using Cargo. The removal of `extern crate` precludes autogeneration of dependencies from source for Cargo. In a distant future in which at least some crates have stable names and APIs, the `extern crate` declaration might also have been used by command-line `rustc` to automatically load appropriate crates without having to specify them on the command line. The Rust 2015 situation in which `Cargo.toml` and the source code have to agree on the crates is definitely awkward, but I'm not convinced that removing crate information from the source code is a step forward. In any case, that ship has sailed — the ships leave Ferrisport at incredible speed, and you have to watch the docks carefully or you'll miss your chance to get on board.
I know this is lowly bikeshedding, but does anyone else have an outsizedly difficult time grokking the name `Unpin`? It trips up my brain every time I read it to a surprising/almost absurd degree.
The increase in the number of Rust dev vacancies is encouraging!
I'm also picking up rust for advent of code. You're probably well past it but it's a useful thing to know that you can represent any non jagged 2d array of fixed size pretty easily as a one dimensional array and some modulo.
I always like hearing alternative solutions because they're usually things I'd never thought of -- thanks!
You might find [this post and the corresponding talk](https://hsivonen.fi/modern-cpp-in-rust/) interesting. It's about exposing a rust library as a modern C++ library (sort of). Specifically, the Rust library is replacing a library which has been a part of firefox since 1999. I learnt a lot watching the talk, though I'm no C++ programmer. 
A question: why cant be go? I think go is super good in devops.
There is an endless amount of comments about this on the tracking issue.
Are you borrowing on function calls or just passing matrices through ownership/copy? I've struggled with deciding when to use the borrow versus copying. In my code I ended up using a borrow for all function parameters except for primitives (i.e. f32) and hoping that the compiler would optimize them out for the case that copying data is faster
I'm still not seeing why thats a problem, people shouldn't be trying to make values of either of them? Only as *opaque* pointers. Thats why it's opaque? Invalid transmutes like that are already UB?
&gt; I would either be super stressed and paranoid all the time, Thats how I was with C++ before i found Rust. Always worrying whether my code was safe or correct and whatnot. And the different compilers and all the "Well it's technically UB but all major compilers support this"(*eyes aliasing unions*) aspects sure didnt help..
I just tested this and it works perfect. I'm not sure I understand what this features array is doing. If I were to say make my own crate that had a feature to enable. 
Me too, although I think I'd actually prefer a significant chunk of the ecosystem to be working on nightly first. Hopefully this can facilitate that even if tokio doesn't plan to make the switch for some time.
You're not likely to match Haskell in terms of expressiveness (at least with Rust)
agree 100%
That's perfect, thank you so much. I'll need to look into those conditional methods more.
Thank you for your time. I am not sure I understand your raytrace function. What exactly is T and Grid&lt;T&gt; supposed to be? I wanted to avoid dynamic dispatch, and as such I used the Material and Texture enums with the corresponding variants. But as you can see that led to a lot of repetitive code such as 'Material::Lambertian(Lambertian::new(...))' and so on. However for Objects I tried to go with a trait based approach. Which one do you think is better?
Thank you for your time. I think /u/Bourgond_Aries is suggesting a generic-based approach instead of dynamic dispatch using traits. Unless there is a clear disadvantage I don't see why we should avoid a particular language feature.
There's a thread about this that might be helpful: https://www.reddit.com/r/rust/comments/5x41i4/rustcexe_on_a_memory_stick/
I thought about making bincode/serde real async. There is an `async-bincode` crate, but that requires prepending every packet with its length and it’d be nice if that could be omitted. I’d also be interested in helping with that.
Have you tried `actix`? It provides an actor-based system on top of tokio which seems like it could be a better fit.
Thank you. 
In my personal &amp; professional experience: yes.
Yeah but despite that it's one of the most unique ones out there. Definitely not generic.
Good story and same feeling about Rust. More language I know, Better code I can write..
Relevant: - https://www.reddit.com/r/rust/comments/78bowa/hey_this_is_kyren_from_chucklefish_we_make_and/ - https://youtu.be/aKLntZcp27M
Numpy, Pandas, linear algebra libraries, and any language that supports multidimensional arrays (tensors) will provide strong guarantees about what the memory layout of those data structures looks like. This makes allocating, deallocating, zeroing, multiplying, etc these structures very fast. You won't get quite the same benefits rolling your own from hashmaps or vectors. That said, there's much to be said in favor of throwing your hands up and using a slower solution because it's not worth the time to build one that is faster.
While I'm not much of an actual game developer myself, I do think Rust's strengths offer benefit in the areas that game development is concerned with. * **Performance**. With no GC, super-fast generated code, and control over memory, Rust hits a pretty nice spot to allow for the kind of optimizations you need to render a frame in the tight &lt;16.6 millisecond constraints of a game. * **Safety + Concurrency**. Modern games are very much concerned with taking advantage of the multi-core processors that are prevalent in today's and tomorrow's PCs and consoles. Rust doesn't do anything magical, but what it *does* do is allow you to reason with multi-threaded code in a much more confident way. Data races are prevented at compile time via the ownership and borrowing system, and the same system also highly discourages you from using certain bad practices. * **Standard build system + Cross-platform**. Cargo allows one to very easily pull in and manage dependencies, without spending much time other than adding a line or two to Cargo.toml. More time spent on coding the actual game. The same system allows one to reason with cross-platform nitpicks in a nice, convenient way. Not to say that other languages cannot already do cross-platform code, but Cargo + Rust makes it very smooth, from what I've seen. There are probably other things, but these are some big ones that I've gathered from reading about other people's experiences so far. So I think that Rust has a pretty solid case for gaining some traction (and it already has in a few cases).
thanks for the info probably choose rust
Is there a goto definition command.
Hi, In my setup it says ```File mode specification error: (void-function lsp-rust-enable)``` 
Dynamic dispatch is the most appropriate tool when dealing with heterogeneous collections of objects that must use a common interface. I understand the desire to use static dispatch where possible, but it's for situations in which there is only ever one implementation that you need to consider at a time.
Using an `enum` to wrap all possible implementors of an interface is not a very elegant solution. Not only do you have to define the struct and implementation for new types, but then you also have to update the `enum`. Dynamic dispatch through a common interface is much more appropriate (and exactly what it's designed for).
Rewrite it in Rust.
Yes. Exactly what my usecase was
It’s not an option because of the need for installing deps 
Yeah I very quickly found out it was a bad idea. Kept it in to get opinions :)
Lisp... I thought that language had died out due to the Great Bracket Shortage during the Jabbascript framework wars. A lot of poor webdevs died in those times. Always remember the Angular 🇺🇸😢
You could try the single thread executor if you're running into move issues: https://tokio-rs.github.io/tokio/tokio/runtime/current_thread/fn.spawn.html
I think the issue is more that it's "easy" to accidentally dereference a pointer, so having an accidental dereference of an opaque type be instant UB is kind of a nasty footgun. It would be better if the compiler could just error and say "hey this thing is opaque, don't do that". Right now the alternative is to use pointers to a zero-sized type instead of a pointer to an uninhabited type, but ZST pointers aren't a perfect fit for the problem either. There's eventually going to be a language feature called extern types to deal with the matter properly, but it's not here yet.
https://www.amethyst.rs Also: http://arewegameyet.com
Well, raw pointers to uninhabited types aren't necessarily UB since they have no requirement to point at a valid thing. But dereferencing such a pointer or, more subtly, turning the pointer into a normal reference is where UB happens. So it's a good idea to move to a ZST pointer for now either way.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/adventofcode] [cargo-aoc v0.2.0, support for \`Result\`s &amp; \`Option\`s](https://www.reddit.com/r/adventofcode/comments/a3lrzs/cargoaoc_v020_support_for_results_options/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
What is the point of the AsRef&lt;T&gt; trait? When is sticking an '&amp;' on the front of something not good enough?
Do you agree that C is a systems programming language? Do you agree that Rust is very similar to C in all regards related to systems programming? System software should be thread-safe and prevent seg faults and have a whole other array of behavior that Rust has but that can't be captured by explicitly stating each one in a tagline. Honestly, I think the slogan is the last thing getting anyone interested in Rust. If it can be a little more descriptive and a little less, uh, enumerative, then that's probably for the better. 
If you turn on warnings as errors, make use of static analyzers as default part of the build process, and enable all relevant warnings, while it still isn't as safe as Rust, it gets pretty close.
I’m colorblind and this just confuses me very much.
I think that it might eventually have one, but it needs to have someone caring enough to provide Unreal/CryEngine/Unity/Xenko/LibGDX/MonoGame level of tooling. While doing games in Rust with SDL/SFML like libraries is perfectly possible, during the last couple of years the games industry has finally started to adopt engine middleware as standard, so that is the level one needs to measure against.
`Grid&lt;T&gt;` is just a container of things (didn't include T: Copy + Clone) presented on a grid. I think you can avoid dynamic dispatch if you use generics without referenced types (ex. `Vec&lt;&amp;dyn T&gt;`) and instead just use `Vec&lt;T&gt;` in the function signature, but that makes all those `T` the same type, so you can still use traits but without dynamic dispatch and without heterogeneous elements in your container.
I'm disappointed that the slogan on the beta site hasn't been changed back yet.
rumqtt would be nice with future 0.3. Just saying.
If you tend to apply lessons learned in other languages to your "working language" I heavily suggest to learn Haskell next.
Then whats different with ZSTs? Is it not also instant UB to deference them, or a reference to them?
Unfortunately this is a battle where middleware is key. Also rust won't give as many advantages as might be expected over others because a great deal many devs are moving to a Entity-Component-Systems data model that doesn't care about the borrow checker and indeed is a source of 'data errors' in modern games. They do this because of performance, where it's simply 'better' to have game engine data that is 'related' (for instance all movement occurs on all objects at the same time) in a single data structure. This naturally pushes devs towards a 'non-class/non-struct' paradigm and to avoid the things that come with that (such as borrowing... or scaffolding disposal game logic to destructors etc. Games are moving away from representing game world data on language provided constructs and doing all the lifetime stuff by their own ad-hoc (but predictable) semantics. Thus games that load all game data that is not textures or meshes in statics at startup, or 'time independent' updates that update positions and then post a 'update damage' request for later (so the first thing to be damaged does not get destroyed before damaging others while still not requiring silly tricks like double dispatch) etc. 
Great! Now I can replace some `unwrap`s with `?`.
Even in case of ECS safe rust will protect you from using it in a way that would cause an UB.
cargo-aoc bills itself as "Cargo Advent of Code Helper".
Short answer: it's for when sticking `&amp;` on the front of something isn't good enough. Meaningful answer: its utility really shines in generic contexts. Note that `AsRef` isn't just implemented reflexively, i.e. `impl&lt;T&gt; AsRef&lt;T&gt; for T {}` but for any type with a reference-reference conversion, such as: * `Vec&lt;T&gt;` -&gt; `[u8]` * `String` -&gt; `str` * `String` -&gt; `Path` etc. This gives you the ability to create functions that are effectively overloaded for many functionally equivalent types. Just look at [`File::open()`](https://doc.rust-lang.org/nightly/std/fs/struct.File.html#method.open), for example. You could pass it a `&amp;str`, a `String`, a `PathBuf`, or anything else that implements `AsRef&lt;Path&gt;` (and references transitively implement `AsRef` as well so you additionally give the caller the option of passing either a borrow or owned value). Deref coercions can allow references to implicitly convert in a similar manner but a concrete type may only have one `Deref` impl.
OP's experience reminds me a lot of how learning Haskell impacted my thinking, regardless of language. I didn't work much with C/C++ so I am not feeling so much the impact of being forced to think about ownership and lifetimes. But I feel far more confident about jumping into C code now, than I would have before.
While this may be true in general, it's also completely irrelevant to the question asked, which is how to make the Rust code nicer.
With this, Rust could become a very viable alternative to JS for anything! Can't wait.
&gt; Since it's a speed competition It is?
ZST actually have one value and you can access that just fine, but as they have exactly one value it is probably safe to assume for the compiler that two references to the same ZST are actually pointing at the very same value (i.e. the references themselves, the underlying pointers are also equal). You probably don't want that in this case because the FFI type can actually have different values, not just one.
No. ZSTs have exactly one value and can be constructed, so they can be pointed to. For example, you can iterate over a `Vec&lt;()&gt;`. The compiler is not free to assume that they don't exist. The case for `!` and other uninhabited types is different: the compiler is free to assume that they cannot possibly be constructed and take any action based on that (including just ignoring the pointer). As an example `Result&lt;String, !&gt;` is different from `Result&lt;String, ()&gt;`. The first one can never error (and for that reason, doesn't need a discriminant), the second one just doesn't give you any info what the error was. 
Is this equivalent to using `#[repr(C)] pub struct Foo(c_void)`? Conceptually it should probably, as `c_void` is supposed to be exactly like `void` (as in `void *`, not as return type)... but the documentation also mentions that `c_void` should ideally be equivalent to `!` (it isn't right now, it's an enum with two variants), which would disallow its usage for cases like the above. Is usage of `c_void` like this also not well defined, or should `c_void` maybe be defined exactly like you mention above (empty array of bytes) and later as `extern type` / `#[repr(transparent)]`?
Something tells me that you're probably using \`Option\` incorrectly. Either you avoid combinators and try to extract the value before processing it, or option is totally redundant in that logic. \`as\_ref\` should be totally fine if it's used inside a chain of combinators. Otherwise, I could not see why it should feel irritating. &amp;#x200B; By definition, if you have an option then you essentially have two potential outcomes that both need to be handled. 
Whatever the answer, this seems worth a documentation fix. I'll send a PR for that later.
The situation is this: I cache a certain expensive value on the first call and thereafter can safely say .as_ref().unwrap(). So I defined a shortcut
Hm. If this happens often, then why not create a wrapper type that would always expose bare reference to the caller and cache the computed value under the hood? If it's not often, then writing as_ref().unwrap() once is not that painful IMO
That's cool. I'm afraid I got lost on this marketing sentence on the *Magic Leap* page, though: &gt; Both the real world and virtual light rays initiate neural signals that pass from the retina to the visual part of the brain. Yes. Yes they do.
Wrong subreddit, /r/playrust is what you want.
That is a good idea, using deref. Tho irritation is one of those personal semi-irrational things; people are different. Also, solutions do not always need to be optimal
Great stuff! Nevertheless, it is a bit unclear how far to the future will Romio be maintained? Say, if I'd port my project on Romio, will it be continued to be maintained after Tokio has catched up?
To add to this a bit of general (unwarranted) advice, if a function is called "parse input" but it also reads a file (as well as some other arbitrary number of non parse-y things), it's probably a good idea to separate that behaviour into its own function.
Nice example! What would it look like if it didn't use a thread pool? I would very much like to see that :) Specifically an echo server should be well served by a single asynchronous reactor core, so I am a bit confused by the thread pool there.
Wow, this looks amazing! I will definitely be giving this a try the next time I need terminal progress bars.
does it address the issued mentioned above?
is there support for \* LC does not support/detect traits \*LC workspace symbols are broken
Yes, I believe, newtype like Cached&lt;T&gt; that Deref's to T is the best choice here. You see, types are more than just a syntax. They represent some idea or some intention. Option type represents the idea of a value that may be missing. On the other hand, by writing as_ref().unwrap() you are clearly advertising your intention "just give me the reference, I know what I'm doing". Unfortunately, whilst this is true, it still does not explain to the reader _why_ you think the value will be there. So, by introducing a type with specific semantics you are solving many issues at once: you make code less noisy, easier to write and to understand. P.S.: of course, sometimes may be better to write unwrap once and just forget about it.
&gt; I also wondered why there is no fsize Why would anyone need `fsize` ? In platforms with hardware float support, smaller floats are almost always faster than wider floats.
I think no in indie. The language is too hard for this purposes. C# with unity allows to make prototyping very fast.
Smaller floats also mean smaller memory footprint, so that's a thing to consider too.
I think what he means is it's a coding speed competition, advent of code's leaderboard is based on how fast you reply to the problem
&gt; I agree that cargo is simpler than trying to deal with gcc or rustc or whatever directly. The issue, it sounds like, is that if you run gcc by hand, it does exactly one thing and you know what that thing is, even if you don't know how or why it works. When you run cargo, it does A BUNCH OF STUFF, and you're more shielded from the details so you don't know the details of what that stuff is and how it fits together. It's certainly more convenient, but it's harder to dig down the stack to actually understand it. Running GCC definitely involves more then one thing, to the point where it's hard to figure out whether some of the commands are actually commands to gcc directly or to underlying programs like the linker. I consider running `rustc` directly "advanced mode" and that usally serves well. 
I know that is what he means. It might even be true. It's also garbage. When I get home from work, the day's problem has already been released for 16 hours. Even if I wanted to, I couldn't reasonably compete.
Smaller memory footprint means more throughput, better cache utilization, etc. Even on x86, which doesn't support much operations on `f16`, there are instructions to convert `f32` to `f16` from/to memory.
Totally agree on that one, but I don't really care (or it's more like part of the deal...). Last year I use AoC to learn rust ecosystem, and made great progress in the language (being able to introduce some rusty part at work ;), for example), and this year I want to learn more about performance, that's why I build `cargo-aoc` in the first place !
Haskell completely changed the way I look at programming. It was so different to what I had done before that it basically broke my mental models and forced me to build new ones. There's a clear "before Haskell" and "after Haskell" in my programming career. 
`fsize` simply makes no sense. The point of usize is to provide a type that's big enough to index all memory on the machine, so an array of the smallest type which fully fills memory can be indexed by `usize` without overflowing. You simply can't index with a float because of precision problems: `5e7f32 + 1.0f32 == 5e7f32`. In any case, if you want to index based on a float, you clamp it to some value and then convert it to `usize` (or alternatively `isize`).
&gt; As a side question, I also wondered why there is no fsize although I found this crate implementing it, any insights? What role would it serve? usize/isize are specifically related to pointers/lengths: usize is guaranteed to be pointer-sized (hence its use for length) and isize is the signed version of *that*, aka rust's version of `uintptr_t` and `intptr_t` respectively. usize is *not* the "default integer" as e.g. `int` is in some language.
I don't agree with Rust being too hard compared to C#. It's way harder to **learn** obviously, but it's not any harder to use. The tooling is less good of course (because intelliSense is great, and the RLS not so right now) but millions of people are developing with Python or JavaScript with no auto-completion whatsoever so I guess it's not a show stopper for most people.
I don't agree with Rust being too hard compared to C#. It's way harder to **learn** obviously, but it's not any harder to use. The tooling is less good of course (because intelliSense is great, and the RLS not so right now) but millions of people are developing with Python or JavaScript with no auto-completion whatsoever so I guess it's not a show stopper for most people.
How do I pass a generic sequence of either a reference or an owned object into a function? I can do this: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=405aa86254c7a9a47af90ef8dc053297 which is basically `AsRef&lt;[Borrow&lt;Item&gt;]&gt;`, but then you cannot call the function like `accept_seq([])` with an empty sequence without specifying additional types. Is there a clean solution?
It’s an experiment to see how the new APIs can be used and what impact it has on a codebase and the APIs you create. Treat it as such.
It’s an experiment to see how the new APIs can be used and what impact it has on a codebase and the APIs you create. Treat it as such.
rust-bindgen binds to a subset of C++.
On some targets, you'll find hardware support for half precision (what would be `f16` in rust). Some are now adding 8-bit float support, too. Half precision has been around for a while but this recent drive to even smaller precisions is usually because machine learning applications that are so en vogue now can reap big performance wins (IIRC for inference at least, very little precision is required). Anyways, the performance increase that you describe matches my experience and is intuitive (IMO). A type called `fsize` would not intuitively describe "some optimal floating-point type" and as others in this thread indicate it's not analogous to `usize`. But a `float_least16`/`float_fast16` typedef (like C99's `int_least16_t`) might be reasonable.
In some languages there are aliases like `int_fast_least32` etc.
You are increasing your productivity by getting more comfortable off-loading more work to the compiler, and it changes how you work and how you think. When you go back to working in a dynamic language, you'll find your productivity dropping as you have to take on more of those responsibilities. This is a productivity change that is completely invisible to people who only work with lenient compilers or interpreters, because if they "try out" Rust for a week, it's not long enough for them to learn to change their habits and offload that work to the compiler.
Not sure if this is an easy question, but it's a good beginner one: If I want my day job to be coding in rust, what are my options?
Lisp is having a very small resurgence with Clojure and Racket.
I had this experience when I encountered Mozart-Oz, and bought the book *Concepts, Techniques, and Models of Computer Programming* and actually read a lot of it. I'd been a Java developer for about 10 years at that point and it was really eye-opening. And then I started programming in Scala for work, and that expanded things further. I just bought *Programming in Haskell* and am going to teach my kids programming in Haskell as their first language, and also as a new language for me. Should be interesting.
In addition to what others have mentioned, Ready At Dawn is now using Rust; they’ve even released a crate. And so is EA SPARK. Some members of that company have founded their own studio, Embark, which is going all-in on Rust. There’s a few other rumors...
/r/playrust 
Will you be able to easily merge this back into Tokio or is this more like a hard fork?
I think the author of that blog post you linked doesn't have a full picture of what simd is doing. Simd intrinsics introduced with `avx` allow you to operate on 256 bits of data in one cycle. You can fill these 256 bits with 32 bit f32s or 64 bit f64s. But that's 8 numbers vs 4 numbers. So when the author says... &gt; With that said I would not expect f32 to be any faster than f64 on modern 64-bit CPUs since you can do f64 calculations with a single CPU cycle anyway. ... he probably doesn't realize that in the case of `f32`, 8 of those are consumed in one cycle, while for `f64` it's only 4. So it's actually _not_ surprising that `f32` performs significantly faster.
Wrong sub buddy
&gt; On some targets, you'll find hardware support for half precision (what would be f16 in rust). Some are now adding 8-bit float support, too. Half precision has been around for a while but this recent drive to even smaller precisions is usually because machine learning applications that are so en vogue now can reap big performance wins (IIRC for inference at least, very little precision is required). One of the issues with half-precision floats is different applications have different wants, hence there being both an IEEE half-precision and a separate bfloat16: half-precision floats have a 5 bit exponent and a 10 bit fraction while bfloat16 has is 8 and 7, bfloat16 has less precision but more range and can be very cheaply converted to and from an f32 by just truncating or 0-filling the f32's fractional, which is apparently more valuable to e.g. machine learning applications.
Google and Facebook are hiring pretty aggressively, in my understanding. Amazon is using rust more and more, but I’m not sure if they’re hiring for rust-specific people. There’s a lot of blockchain jobs, it seems... and a bunch of smaller companies at various times. “This week in rust” has a jobs section, make sure to check that out too.
I don't agree with Rust being too hard compared to C#. It's way harder to **learn** obviously, but it's not any harder to use. The tooling is less good of course (because intelliSense is great, and the RLS not so right now) but millions of people are developing with Python or JavaScript with no auto-completion whatsoever so I guess it's not a show stopper for most people.
[Yep!](https://github.com/emacs-lsp/lsp-mode#goto-definition)
It’s an experiment to see how the new APIs can be used and what impact it has on a codebase and the APIs you create. Treat it as such.
Your name is definitely not Jeff!
Heeey, at least this guy uses Linux!
I think /u/maxfrai is spot on with his mention of indie. Rust is an amazing language in terms of what it fives you but as an indie, I'd highly recommend choosing the simplest route of c#+unity unless you're already very comfortable with rust. 
But doesn't Go produce statically linked exectuables? For example, "installing" [Nomad](https://www.nomadproject.io/) means putting the binary on that machine.
Tokio already supports the same functionality via feature flag. See: https://tokio.rs/blog/2018-08-async-await/ Once Async await stabilizes the feature flag will no longer be needed and Tokio will be continually adding more Async / await based functionality. I’m order to support the existing ecosystem, Tokio will not deprecate futures 0.1 support anytime soon. 
Tokio has already supported Async / await for a while, see here: https://tokio.rs/blog/2018-08-async-await/
Yes, if you want to "compete" on leaderboards, speed is the main factor. Personally I don't like this speed factor since it only favors 1) people who stay up late to get first hits (which I can't do) and 2) brute-force solutions without much thinking about the problem. Because of those issues, I look at the exercise as a way to practice Rust, explore the ecosystem, and to try to come up with the most efficient solution possible. For the later I want to easily be able to compare them so using criterion is great for that.
In my personal opinion, for indie level game development: No. I can see more indie devs sticking with pre-build engines, like Unity/Unreal. That being said though, I can very much see a future where Unity/Unreal start to use Rust a lot more. As for AAA development: I can very much see large studios using Rust for better safety and better performance. EA for example has already begun using Rust for a lot of new tools ([https://github.com/SEED-EA](https://github.com/SEED-EA))
Downvote for not reading where (s)he’s posting Upvote for Using Linux -&gt; Tie ;-)
Thanks for posting this, I didn't know there was a local group. I can't make the December meetup, but I'll look for future ones.
Now if only I could use lifetimes for return values...This is an issue I ran into yesterday, and I was thinking of filing an issue.
I know, however, I assumed that there was some trade-off to use the shim that you have made available. What I would like to know is: if I would port my current Tokio app to async/await, are there any drawbacks to using your approach? My current idea is basically to wait until Tokio is "futures 0.3 native" and then do the port.
Why not? All I've seen so far is that it hasn't *yet* taken over the AAA video game industry, which I don't think is remotely surprising. 
&gt; The language is too hard for this purposes. Huh? I've yet to see anyone substantiate the "Rust is too hard" argument with anything other than "I personally don't get it"
perhaps posting a link to the issue tracker here.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rustjerk] [How Rust Made Me A Genious](https://www.reddit.com/r/rustjerk/comments/a3okow/how_rust_made_me_a_genious/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I could tell my story too, but it's the same as yours. I am now a much better C++ dev than I was last year.
It’s in the post.
indie more so AAA tends to have established source bases (either off the shelf engines or in-house engines which can be re-used/extended between products) It's capable but I'm not convinced it's an unambiguous improvement over C++ (it has advantages and disadvantages, and there's a cost to switching and interfacing)
And Smash Bros comes out tomorrow, so a good week for software releases. :) Just a heads up that I might be somewhat, uh, neglectful of my moderating duties for a week or so...
Hi! I made that crate. You almost certainly do not need it. I've never needed it; I just made it on a whim after I saw someone suggest that approach for a particular problem in an /r/rust thread. ¯\\_(ツ)_/¯
The rationale is that if people were timed from the first time they view the exercise, it would be possible to copy solution code from others or to first make it on one account and then use that implementation to instantly submit on the second account. Even if you can't make the leaderboard because of circumstances, why would you care? Just make the puzzles for fun.
* Can it submit found duplicates to BTRFS on Linux for linking? * Can it find big duplicated blocks inside large files (i.e. VM images)?
Also Stellaris MegaCorp. Good day to play the space capitalist.
I am waiting for hours! I woke up early in the morning and checked if Nikolaus put Rust 2018 in my shoes :D (don't know if this tradition is celebrated anywhere else other than germany)
In the US, Santa or Saint Nick puts small presents in stockings on Christmas day, along with the larger presents under the tree. Related, but not quite the same; we don't have a separate Nikolaus day.
Wrong sub, bud. You're looking for /r/playrust 
r/playrust 
https://www.youtube.com/watch?v=3GwjfUFyY6M
happy happy joy joy
No to both.
You mean space communist, surely!
IIRC at least in the Netherlands, Germany, Belgium, Curaçao, Aruba, and some parts of Suriname.
If you multiply a bool by a full set of 1s, it will be all 1s when the bool is `true`, and all 0s when the bool is `false`. [example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=484b5384a076fc40e31fcf3b5fbaa32b)
So excited for this
In Wisconsin (a state in the U.S., and perhaps not statewide, but certainly school wide where I grew up), we celebrate Saint Nick's day in addition to Christmas. So stuff in the shoes on Saint Nick's, and then the typical American Christmas stuff at Christmas. Wisconsin has some very heavy German influences though - we have stuff like Oktoberfest: [https://www.funtober.com/oktoberfest/wisconsin/](https://www.funtober.com/oktoberfest/wisconsin/)
I think the subreddit should be renamed rust-lang. Too many people don't read the description every day.
I made this but the other answer is better. https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=1ae55b84e069383aa41be46e5b95171d
I have to admit that I was really taken aback when I first clicked on the link and saw the new page. I had a visceral reaction, and candidly, it wasn't good. I felt somehow a bit betrayed, like something useful and comforting had been taken away from me. At first, I didn't want to post anything. I know that receiving criticism can be disheartening, especially after spending a lot of time working on something. But, given the fact that I really enjoy the language, and want to see it continue to grow, I have decided to join the chorus Here were some of my immediate issues with the site: * The colors are discordant and distract from actually reading the text. The simply don't play well together * The font choices may (arguably) look fun when squinting at the page, but they distract when actually trying to read the page * The slogan makes the language seem much more narrowly focused than actually is - and it doesn't seem plausible to boot. It received a lot of negative focus at work * The important links for return users are de-emphasized for some odd reason. (Install Learn Tools Community Blog) * you have to scroll down on most pages to get to useful information / links which were previously accessible without scrolling. Shouldnt the most valuable information be the most accessible? I do think that there are very nice aspects to the site, and I really appreciate the work of everyone involved, but i wanted to share my initial reactions because they were pretty common, at least where I work. One question that I have not seen answered anywhere is what the goals of the redesign are. What was wrong with the old site that needed to be addressed? Who is the intended audience ?
People have asked whether this counts as on-topic; the answer is yes, because it mentions Rust projects by name (Service and WebRender).
Truly the biggest development since windows 3.0. What is the difference between rust 1.31.0 and rust 2018?
Can't tell if being hyperbolic or just also excited...🤔
1 day, 2 hours, 40 minutes, 12 seconds until Path of Exile: Betrayal. Arc Elementalist is going to be fun.
&gt;&gt;since you can do f64 calculations with a single CPU cycle anyway. This is also wrong. While modern processors have throughput of 1cycle per f64 arithmetic op (mul, add), they are not 1cycle latency ops. According to [Agner Fog's CPU tables](https://www.agner.org/optimize/instruction_tables.pdf) It's more like 3-4 cycle latency for modern processors (Ryzen, Skylake). It's correct though that there's little difference between f64 and f32 perf latencywise except for division/square root instructions.
You can do what [Sinistersnare](https://www.reddit.com/user/Sinistersnare) sugested or you simply write if condition { 0xFFFFFFFF } else { 0 } you don't have to worry about branches because even just opt-level 1 gets rid of any branching as you can see here: [https://rust.godbolt.org/z/3Rls0m](https://rust.godbolt.org/z/3Rls0m)
Ah! of course! Thanks, I knew there was a simple way. 
Cool! Questions are obviously welcome in this subreddit, but also, lately there has been more activity in /r/learnrust. You could always ask there for questions like this.
I think the greater opportunity lies in safe cooperative multitasking (ie: your tokyo and task related executors). I also think there is a opportunity for powerful scripting, if not in rust, in some simpler language that compiles down to it, if the generator story is sorted out. Namely i'm thinking of scripts that are bound as event listeners. Sometimes those scripts have to do things that aren't exactly friendly to a event queue, like 'wait 3 seconds' or 'open a messagebox and wait for user input'. And as it is a event listener, the classical way to do a continuation/generator in a script is pure nonsense, the generators have to suspend, but since they're on a event listener which is a singular event, they have to be enqueued into a '1 per frame (or a bigger number) special script queue. This combined with the ambiguity of sharing resources on scripts may give a opportunity to a game scripting framework that is both efficient (event based), usable (continuations/generators instead of callbacks) and safe (enforcing safe abstractions to share game engine resources, like messageboxes or new better approaches to timers and deadlines like what python libraries are experimenting with).
https://i.imgur.com/cig7xxA.jpg
Romania too
Its Shevegen in disguise
Rust 2018 is a full edition, with keyword changes and general improvements. 1.31.0 is the rustc version, which will allow Rust 2018 to be used on stable.
Will this be recorded? Because I'm very interested, but it will be kind of impossible to just teleport to the other side of the world. 
Neat! Quick question since I'm not familiar with how apps work on the Leap: Are all windows anchored in the physical space or can you "attach" some to you so they travel with you as you move around?
I'm using gtk-rs to write a GTK app for Linux. What's a HUGE pain in the ass, is that GTK isn't thread safe and I cannot design my GUI asynchronously. Meaning I push a button that triggers a function that does something that lasts 3 seconds. My button and GUI will remain unresponsive until those 3 seconds are over. This obviously sucks. There are some workarounds but they're all pretty hacky. So I've discovered the async/await work that's currently happening for Rust 2018 edition. So my questions are: 1. Once async/await works, won't this solve my GUI freeze-up problem? Or did I understand async/await wrong? 2. The fact that gtk-rs/GTK isn't thread safe shouldn't be a problem, because async/await is not the same as spawning a new thread. Is this correct or did I misunderstand how async/await works? 3. I looked into futures and tokio and it was way too complicated for me. Will async/await be easier than futures? Thanks so much in advance!
Same in Pennsylvania but again heavy German roots. 
You can use `(b as u32).wrapping_neg()`. For `false`, you get −0 which is 0, and for `true` you get −1 which is all ones. You have to use `wrapping_neg` as `u32` cannot be negative. Incidentally, if you use `(b as u32) * 0xffff_ffff`, or even `if b { 0xffff_ffff } else { 0 }` in release mode, they are all compiled to a single `neg` assembly instruction.
I came at the very thought!! 
What does the talk cover ? `core::arch` ? `std::arch` ? `packed_simd` ? Other libraries like `faster`, etc. ?
I disagree r.e too hard (although yes it's harder than C#, but a different use case) - people can take more risks in indy, I think the community/crate ecosystem could be made to work (fill in the gaps); if someone wants to use rust ,they can. I think it has a small but dedicated following.
it's all just a tradeoff . pay runtime for a GC, or pay with more coding time for Rust (noGC+Safety), pay more debugging time for C++
it objectively(measurably) requires more markup to achieve safety without a GC
Anyone else getting 404 error on version link of new version link of [https://www.rust-lang.org/](https://www.rust-lang.org/) homepage? Also, is there any other page where I can read about Rust 2018? Thanks.
The focus will be on using the intrinsics directly, so the stuff in core/std::arch. I will briefly touch on faster/packed_simd and other SIMD libraries. Much of the content will be agnostic to all of those things, such as how to lay data out to leverage SIMD well, how to deal with branches or instructions that have no SIMD equivalent, etc. 
I don't know if they will be recording it, but I will do a twitch/youtube version of it afterwards. So if you are unable to locate a teleporter, look out for youtube. 
Might be a dumb question, but I am still new to Rust. How do I go about using Rust 2018 or how do I know which one I am using? I mean I know which compiler I am using. Is there anything specific you need to use it or do you just start using 2018 features with the newest compiler and that is it?
Rustc wants to monomorphize `accept_seq`. Rephrased, it wants to generate specialized non-generic versions of `accept_seq` depending on the usage of `accept_seq`. If you in one line call — thus use — the function with `[A; 4]` and in another with `Vec&lt;B&gt;`, the compiler is going to produce to monomorphized functions. But with calls like `accept_seq([])` monomorphization cannot be performed as the type parameter `T` in `[T; 0]` can't be monomorphized (specialized) neither because it's not used anywhere else: `T` can't be infered. You could just annotate the call with a dummy type: `accept_seq::&lt;_, A&gt;([])` and be done with it. In other languages, i think Scala, the element type of an empty container is `Nothing` (the bottom or uninhabited type, "never type" in Rust) meaning there's no way to get an element of it (indexing panics, `get` returns `None`). I kind of wish this behavior will be arrive in Rust one day. If you want to be overly correct and use `!` (the never type) saying: "Dear `accept_seq`, I give you an empty something, thus you cannot possibly retrieve a value from it", then there's: #![feature(never_type)] impl AsRef&lt;A&gt; for ! { fn as_ref(&amp;self) -&gt; &amp;A { *self } } impl Borrow&lt;A&gt; for ! { fn borrow(&amp;self) -&gt; &amp;A { *self } } At the call-site: `accept_seq::&lt;_, !&gt;([])` etcetera.
I was looking for something like this. Thanks for sharing.
What is this I'm confused 
I might have missed it (didn't read every word of the article) but are all projects generated with cargo in 1.31 and beyond going to be flagged as 2018 or do we have to manually turn it on? If I was at home I'd just update and check but at work I don't have rust installed.
the table of contents links don't seem to work. (I'm using iOS Safari)
That it is, but its easy to lose sight of when wading through hundreds of comments
As far as I know, you need to have an **edition = "2018"** key in your Cargo.toml file to let the compiler know you want to use the 2018 edition features. 
Huge congratulations to the Rust team and community. I started learning Rust in January of this year just to pick up something new. Now I'm all in, I see the use for this language today, and with the release of the 2018 edition and just a few more features on the horizon I suspect we'll reach critical mass of Rust in production within the coming year or two. ^(const generics in 2019 pretty please)
🎉🎉🎉🎉🎉 Rust just keeps on getting better, btw the horizontal bars on the new homepage are really irritating and it would look nicer if they were removed.
someone beat you to it this time: https://reddit.com/r/rust/comments/a3pyrw/announcing_rust_131_and_rust_2018/
I dosen't work on the firefox nightly 65.0a1 either
If are looking for a way to just run echo and see its output on the screen, I would look at this: https://doc.rust-lang.org/std/process/struct.Stdio.html#method.inherit. It includes an example for inheriting stdout and stdin. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rust_gamedev] [Does rust have a future in the development of games?](https://www.reddit.com/r/rust_gamedev/comments/a3q3sg/does_rust_have_a_future_in_the_development_of/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
So excited! note: for me the links under "What's in 1.31.0 stable" on the page are not working. (https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#cargo-features)
I’m gonna fix it, thanks!
There are still a few issues with the new blog we need to fix. Should be fixed soon!
That's all that's needed. If you want to switch over an existing crate you can also run cargo fix --edition to help fix breaking changes.
And with that, the new [rust-land./org](https://rust-lang.org) which markets itself to managers and CTOs instead of the actual _users_ of Rust is live. ... 🎉
Rust 2018 will be specified by default in new projects created by `cargo new`.
Thanks, I appreciate the effort :) 
Why doesn't `use actix::prelude::*;` work anymore in new version? I guess something with new path and namespace rules.
Thanks that helps. Will it at some point not need specifying at all?
So exciting! So exciting!
Probably not, since it would stop older projects from compiling.
TL;DR for anyone else: you need to add `edition = "2018"` in Cargo.toml.
Sounds interesting. If you want to contribute some of the stuff you prepare for your talk to `stdsimd` or `packed_simd` (which has a perf guide and some more docs) feel free to open an issue or send a PR.
Installing rustfmt and clippy seems to not work, at least for me on OSX 10.11. Or is there something else one has to do to update? ~ $ rustup component remove clippy-preview error: toolchain 'stable-x86_64-apple-darwin' does not contain component 'clippy-preview' for target 'x86_64-apple-darwin' ~ $ rustup update info: syncing channel updates for 'stable-x86_64-apple-darwin' info: checking for self-updates stable-x86_64-apple-darwin unchanged - rustc 1.31.0 (abe02cefd 2018-12-04) ~ $ rustc --version rustc 1.31.0 (abe02cefd 2018-12-04) ~ $ rustup --version rustup 1.15.0 (f0a3d9a84 2018-11-27) ~ $ rustup component add clippy error: toolchain 'stable-x86_64-apple-darwin' does not contain component 'clippy' for target 'x86_64-apple-darwin' ~ $ rustup component add rustfmt error: toolchain 'stable-x86_64-apple-darwin' does not contain component 'rustfmt' for target 'x86_64-apple-darwin'
It's always good to see another stellaris player around!
What is the current state of that stuff? stdsimd became packed_simd? Or are they separate things now? 
Yes, great! Thank you very much rbaliki2!
Is JSON a hard requirement? Otherwise one option could be to use some schema-centric serialization, like protobuf and auto-generate the interfaces for both Rust and TypeScript. In Rust, IIRC, this can be completely automated through build.rs. I would essume the same to applies to TypeScript. Since you're not wed to HTTP/Rest, it could also be worth to check out grpc.io. (I have no experience, but have heard good things)
Windows build did not work on my Windows 10.
Sorry, just a nitpick: it's not "Entity-Component systems", but "Entity-Component-System pattern". The former wording makes many people think that Systems are not a part of the pattern, then they start implementing game logic inside components and call it "a ECS", which is simply wrong. Also, apart from other advantages of Rust, I think having hygienic AST macros helps. Coding in ECS is often a bit tiresome because of the verbosity and low-level details of component access. I have a feeling macros and zero-cost abstractions of Rust can make it more comfortable.
I must admit I've always had an issue with negatives in names, because I just can't seem to wrap my head around double negatives which they generally lead to :(
Are you interested in some Type Tetris?
And Iceland
You can't rename a subreddit, the best you can do is create a new one and make the old one private. It would be a very silly thing to do just to get rid of a few posts per day, in my opinion... 
&gt; Then the american tradition of santa claus... A tradition created by Coca Cola, IIRC :) 
Congratulations on this release and all the hard work! &lt;3 &amp;#x200B; Small nit: rustup &amp; clippy seem to only be available in \*-preview form for now.
I hadn't considered going through an intermediate protocol for some reason, despite the fact that we are using protobuf/grpc in other parts of our application. It's not actually that we're not wed to HTTP/Rest, it's actually that we're wed to WebRTC. For that and other reasons, we won't be using grpc-web for this. Thanks for the advice!
Same. Also tried adding clippy and rustfmt on my windows machine, but that toolchain also does not contain those components. 
The fix for this has been rolled out, thank you.
but 1.31 auto adds it to new projects.
FWIW, the website _shouldn't_ be aimed at users of Rust, as they're already using Rust. The website _needs_ to be aimed at those who _aren't_ using Rust. And one of the goals of the Rust 2018 marketing push _is_ to drive company adoption, which, for better or for worse, means marketing to the decision makers, not the developers. The people the old website was for are using the language already. (Let's try not to derail this thread too much though. Rust coming out of 2018 is something to be proud of! :tada:)
What error do you get?
apparently you need to `rustup update` *before* you install this version. Sorry about that! We could have made this more clear, but it was a mistake.
A new version of Rust released.
It's not very clear what the problem is. error[E0432]: unresolved import `actix::prelude` --&gt; src/main.rs:1:12 | 1 | use actix::prelude::*; | ^^^^^^^ could not find `prelude` in `actix` error[E0659]: `actix` is ambiguous (name vs any other name during import resolution) --&gt; src/main.rs:1:5 | 1 | use actix::prelude::*; | ^^^^^ ambiguous name | = note: `actix` could refer to an extern crate passed with `--extern` = help: use `::actix` to refer to this extern crate unambiguously note: `actix` could also refer to the module imported here --&gt; src/main.rs:1:5 | 1 | use actix::prelude::*; | ^^^^^^^^^^^^^^^^^ = help: use `crate::actix` to refer to this module unambiguously error: aborting due to 2 previous errors &amp;#x200B;
For me it still gives an error on both stable and nightly, even though the toolchains are up to date. I'm on rustup version 1.15.0, which I believe is the latest.
Interesting. What happens if you `use ::actix::prelude::*;`?
Yea but what is this github link tho. Isn't that like a python script thing
`actix::prelude::*` includes a module named `actix`, hence the conflict. change it to `use ::actix::prelude::*` fix the problem.. at least that's how I fix it. https://github.com/poga/actix-lua/commit/4107532256ad60220a7a5eecc74594543582d815
Hmmm, when *I* run `rustup self update` it says 1.14...
I had the same issue. it might be because I downloaded 1.31 before updating. Might not be ideal, but reinstalling rustup fixed it for me!
That works but the `::` is removed by rustfmt :( &amp;#x200B;
Are you replying to the wrong post? There's nothing about github here.
My rustup is installed directly from the git repository using AUR, so perhaps that causes the problems?
Oops I think i got a little confused because there was a link in that article somewhere. I still don't understand what this post or article is even saying though. It's talking about Language and idk what that has to do with rust
Is there some wait to make a 2d iterator? What I mean is an equivalent of: for y in 1..=10 { for x in 1..=10 { } } That would look something like this: for (x, y) in (1..=10).some_adaptor(1..=10) { } 
On windows, rustup self update will update to 1.14. On Mac, it updates to 1.15. 
Sounds like the `actix::prelude` contains `actix`? It should work if you write `use ::actix::prelude::*;`.
It's about the new ["edition" of Rust](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html): Rust 2018. Basically this is the way Rust does backwards-incompatible changes. You can still use the old stuff, or you can opt-in to the new stuff.
Does it work better with `cargo fmt`?
Is your rustfmt up to date? If yours is managed by `rustup`, a `rustup update` should have updated it.
So, so happy to have NLL on stable. And I hadn't realized how many other small ergonomic improvements were coming with 2018 - I always forget that `struct Foo&lt;'a, T: 'a&gt; ...` thing, so this new default is very sane for me.
As a user of Rust I literally never go to the website.
The [default global allocator has been switched from jemalloc](https://github.com/rust-lang/rust/issues/36963) recently. I didn't see it in the 1.31 release notes, is that landing in a later version?
You're right - I should have said "newcomers" instead of "users". I'm aware that my comment doesn't fit the attitude usually presented in this community, but I wouldn't say it's derailing the thread -- the announcement specifically calls out the new website. Also as to "derailing", this should have been discussed _more_, not less. This not-insignificant change didn't ever get seriously discussed in the open, and it feels like it just happened overnight, because in some sense it _did_.
If you installed rustup through your OS package manager, you need to update it with the PM.
That's in the current beta branch, so it should be released in 1.32.
&gt; If you're thinking it's about Rust the game, then you're in the wrong subreddit. Try /r/playrust. ohhh that explains why he's confused!
Congratulations! Rust has been an awesome journey – stable, fast, modern, a dream of programming language. What is the reason behind removing the command `cargo install -f` in a create? I find `cargo install --path . --force` more confusing beside of it being longer to write. The `--path .` part could mean that the create binary is installed into the current folder, which would be strange because the command is executed the current folder. But it is much stranger that the command targets another directory `~/.cargo/bin` when the user explicitly specifies a path. I guess there is a good reason for the change (as always with Rust), so I'm curious about the why.
I get the feeling you're on the wrong subreddit. This one is about a programming language. The subreddit for the video game called Rust is at /r/playrust
Yea I figured that out pretty fast
&gt; I always forget that struct Foo&lt;'a, T: 'a&gt; ... thing, so this new default is very sane for me. Is it though? I'm not even sure what &lt;'a, T&gt; means now. What if the 'a and T are unrelated? Does it leak that from the struct definition or is this some kind of elision that maybe doesn't always apply? If so, how do I tell it that 'a and T are unrelated?
That is not the issue, it updates/re-installs just fine (to version 1.16, now), but even then adding clippy or rustfmt doesnt work.
Hi Guys, This is the fifth post I wrote about [Learning Rust on Medium](https://medium.com/learning-rust). Now you can read the same content via [learning-rust.github.io](learning-rust.github.io) as well. However in this post, I tried to summarize about, - Smart Compiler - Why Compiler? - Explain Error Codes - Panicking - panic!() - unimplemented!() - unreachable!() - assert!(), assert_eq!(), assert_ne!() - debug_assert!(), debug_assert_eq!(), debug_assert_ne!() - Option and Result - Why Option and Result? - Basic usages of Option - Basic usages of Result - is_some(), is_none(), is_ok(), is_err() - ok(), err() for Result types - Unwrap and Expect - unwrap() - expect() - unwrap_err() and expect_err() for Result types - unwrap_or(), unwrap_or_default() and unwrap_or_else() - Error and None Propagation - ? Operator - try!() - Error propagation from main() - Combinators - What is a combinator? - or() and and() - or_else() - and_then() - filter() - map() and map_err() - map_or() and map_or_else() - ok_or() and ok_or_else() - as_ref() and as_mut() - Custom Error Types - Error trait - From trait &gt; 🐣 I am a Sri Lankan🇱🇰 Web Developer who works in Vietnam🇻🇳. I am not a native English speaker and I am just practicing Rust in my very little leisure time, while learning more about Golang, Devops and so much in the workplace. So, if you found any mistake or something I need to be changed, even a spelling or a grammar mistake, please let me know. 🚀 [Hire me!](https://github.com/dumindu/hire-me/blob/master/resume_dumindu_madunuwan.pdf) 🥤 [Buy me a coffee!](https://www.buymeacoffee.com/dumindu) ⭐ [Contribute!](learning-rust.github.io)
The compiler infers the constraint based on the types of the fields. So, if your T and 'a are unrelated, then it won't infer a constraint. 
I believe the reason is that this syntax is supposed to be less ambiguous, but I also prefer `cargo install` and `cargo install -f`
Ah, but isn't that problematic for documentation where all the fields may be private? Then I get tricked as the reader of the documentation. Unless rustdoc puts 'a there for you.
&gt; which markets itself to managers and CTOs instead of the actual *users* of Rust Of course it's not an purely an either-A-or-B problem, and plenty of work has gone into keeping it relevant for programmers. Nor are Rust programmers a uniform bunch who all benefit from the same kind of site.
IDE tools and async is my choice. I really like the progress Intellij Idea made but it's for me vscode is much better. Intelligent completion, easy refactoring, types inference... That's what we need.
I've had the same problem. Finally, fixed it by uninstalling toolchains \`rustup toolchain uninstall stable nightly\` and installing them again \`rustup toolchain install stable nightly\`
I'm sure you're capable of managing your calculations, but one word of caution on f32 I've learned from experience: the range of numbers it can represent is surprisingly small. It's pretty easy to break if you're calculating a sum. The lack of precision can also accumulate quickly, so to speak. For this reason I often store the results of aggregation operations on a collection of f32s in an f64, and, given the number of times that f32 suddenly exploded on me, I'm more likely to default to f64 than I used to be. ymmv. 
Thanks for this very verbose answer! Let me illustrate why I am doing this. In "real code", this method will always accept some *real* `Vec` or slice with values. But in certain (unit/integration) tests, I actually don't always care about that specific parameter in the function call. That's when I would like to call `accept_seq([])`, without having to bother with the type (which would indeed otherwise be inferred). I actually went with a form of the `accept_seq::&lt;_, A&gt;([])` approach: I made a macro with a short name that constructs a "typed" `[]`, namely it expands to `[] as [A; 0]`. Since it's only meant to be used in tests, I guess I don't care too much :-)
Yes, procedural macros are stable as of 1.30. You can define/create and use all 3 kinds of procedural macros: function-style, attribute-style, and custom derives.
What I'm arguing is that you don't pay “more coding time” when writing Rust. It took me a while, but I really feel like I'm as productive in Rust as I was in Java back then, and I'm definitely more productive overall in Rust than I was in JavaScript because of the static typing.
No. To keep old unmaintained code (which is unaware of editions and does not specify anything) working, the default will stay 2015. If no edition is specified in Cargo.toml / rustc arguments, the compiler will default to Rust2015. If you want to use any newer edition, you have to specify it explicitly. For newly-created projects, the Cargo.toml will specify the latest edition by default, as there is typically no reason to want to use an older Rust edition in new projects.
why down votes?
stdsimd ships as `std::arch` now and packed_simd is still a separate crate.
This worked! Thanks.
&gt;Work on IDE support is not finished, in particular code completion is not up to scratch in the RLS-based editors. However, if you mainly want support for types, documentation, and 'go to def', etc. then you should be happy. What does the part about RLS-based editors entail? What are the non RLS-based editors?
Oh, fantastic, thank you!
Congrats to the whole Rust team. This is an amazing achievement 🎉 &amp;#x200B; I've been learning Rust over the last couple of months and slowly starting to introduce it where I work. I see a very bright future ahead. Keep up the good work 💪🏼
Several other languages' analogous tools to cargo use `cargo install` to mean, essentially, `cargo build` (or at least, building all the dependencies). Specifically, both npm and bundler haver this functionality. Because of this, we've had new users accidentally typing `cargo install` and successfully installing their crate they're learning from into their PATH. This is a pretty bad experience, and we decided it was a good idea to prevent it - worth making you write `--path .` for the relatively uncommon case of installing the project you're in the source of.
I think they just created the colour scheme.
`(1..=10).flat_map(|x| (1..=10).map(|y| (x, y))`, perhaps?
Thanks for the reply. It makes sense to protect users from unwanted effects.
Cargo fmt calls out to rustfmt 
At least intellij
First of all thanks for working on that! Great to see a "native" futures 0.3 IO stack being around in order to be able to play with it! Regarding the mentioned points around `AsyncRead`, `AsyncWrite`, and `poll_vectored_read`: I think they should ultimately be defined to use real `Future`s instead of having different `poll` methods. Because building the current abstractions on top of `Future`s (e.g. implemented by async methods) is not always possible. Same goes for the `Stream` and `Sink` traits. The Tokio/Mio implementation isn't affected by this, because it doesn't use futures inside the implementation of the traits itself, but other things might. I will write a bit more about this in the futures-rs repository when I find some time. Ideally I think it should be something along ``` trait AsyncWrite { type WriteResult: Future&lt;Item=Result&lt;(), Error&gt;; fn write(&amp;mut self, data: &amp;[u8]) -&gt; Self::WriteResult; fn write_v(&amp;mut self, data: &amp;[&amp;[u8]]) -&gt; Self::WriteResult; } ```
https://compileroptimizations.com/ has a good list of common compiler optimizations.
I just tried Edition 2018 and I have a problem with derives. The blog post says this: &gt;You can import macros with use, rather than a #\[macro\_use\] attribute. I have two source files: main.rs and settings.rs. This is what I had before using Edition 2018 in my main.rs #[macro_use] extern crate serde_derive; mod settings.rs Now I removed the two top lines from my main.rs file and added this to my settings.rs file: use serde_derive; However now the compiler complains and I get loads of error messages for every derive. Just one example: error: cannot find derive macro `Deserialize` in this scope --&gt; src/settings.rs:16:21 | 16 | #[derive(Serialize, Deserialize, Debug)] | ^^^^^^^^^^^ So what did I misunderstand here?
Some possible theme ideas: 1. **Rust runs Everywhere** - Support for more architectures and operating systems, with am emphasis on embedded. - Even *better* `wasm` support and tooling. Let's see rust used from NPM packages, to blockchhain-smart-contracts, to wasm-powered application plugins. - Make things easier for packagers to build and package rust-powered applications and libraries. 2. **Batteries Included (some assembly required)** - Rust `std` is never going to be a batteries included standard library, but we can still give a batteries-included experience by focusing on ecosystem-excellence. - Make sure there's a recommended pure-rust crate for solving all common problems (I'm looking at you cryptography) - Make it transparently easy for someone to "just-reach" for the "correct" crate, with little cognitive overhead. Some idea include the idea of `extended-std` or a "recommended" list on crates.io 3. **Rock Solid** - Better tooling and support around tests, coverage, fuzzing and dynamic analysis. We're making *great* progress here, but we need to bring it home. - Formal analysis and verification of rustc, the standard library, and select ecosystem crates. This is a *big* task, but with real community focus, we could make great progress. 
It works but current IntelliJ-Rust doesn't understand the `::` prefix and loses all its type info. :(
How should one approach learning rust? I have some experience with C# and Java. I have written one app using Java which was super simple beer database but that was years ago. My ultimategoal would be to learn webassembly.
- read the entire official Rust book - optionally, read Rustonomicon and the book on macros - do some code challenge, e.g. advent of code, in its entirety, in Rust
In general, _actually trying to make the code fast_. Debug mode prioritizes making the executable quickly and making it debugable over all else, so it will make really inefficient code that is easily equivalent to much faster code.
Yes but Cargo knows the edition, while the rustfmt command does not. There's an issue somewhere (I think the rustfmt repo?) about this.
&gt;rustup toolchain install stable nightly Unfortunately reinstalling the toolchain didn't work for me. When I try to install `clippy`, `rustfmt` or `rls` I get this error: `error: toolchain 'stable-x86_64-pc-windows-msvc' does not contain component 'clippy' for target 'x86_64-pc-windows-msvc'` rustup -V says: `rustup 1.14.0 (1e51b07cc 2018-10-04)`
I'm arguing that you do pay more coding time; there's a straightforward tradeoff : to acheive safety, you need (i) more upfront markup (lifetimes, different pointer types), and (ii) more helper functions to wrap every potentially safe operations A garbage collector makes coding easier at the expense of runtime cost. I'm finding rust less productive than C++.
IntelliJ 
Close, just added a move in the last map and it worked (and x and y are swapped by that's trival). Still really ugly though sadly. 
As a Rust learner, I've found the IntelliJ plug-in in CLion has provided the most helpful experience. But that might be because I'm also a WebStorm and Rider user.
Ahh bummer.
Same here. Is it a Windows thing?
Are you running “cargo fmt” or “rustfmt”? And you updated to the new release, right? (I’m sitting next to nick and we’re trying to reproduce but can’t)
An excellent write-up, as usual!
Crate curation and development.
Chandler Carruth has a bunch of good talks about this, such as https://www.youtube.com/watch?v=FnGCDLhaxKU
The InteilliJ/CLion Rust plug-in is not based on RLS, it is a separate implementation in the JetBrains eco-system. 
Updated with rustup to 1.31, yes. "cargo fmt" works but rustfmt from IntelliJ and Sublime doesn't which is pretty annoying because I am used to format the code from within the IDE. &amp;#x200B;
Nit (/u/steveklabnik1): It looks like the rust book has been updated to the 2018 edition, but [the introduction](https://doc.rust-lang.org/book/ch00-00-introduction.html) still claims that the current version is available from No Starch Press. 
My top priorities are: * Stable async/await. * Stable `TryFrom`/`TryInto`. * Hyper 1.0. For a gold star, add in a web framework I can be confident won't be abandoned by maintainers or left for something else by the community within 3 months.
I haven't used it but I believe wasm-bindgen can do this.
This is still a bit experimental, but I‘ve been using https://crates.io/crates/serde-schema to implement serialization for protocols that require a schema description. It hooks into a typical use of the serde derive macro and attributes, and extracts a schema description from there. If your aim is to produce a json schema that would match how serde_json would serialize/deserialize the type, it may be a good starting point. Documentation is rather sparse at the moment since I’ve been writing it mostly for myself, but I’m happy to take questions, and there are also a few examples in the unit tests here: https://github.com/srijs/rust-serde-schema/blob/master/serde_schema_derive/tests/derive.rs
Also I wonder why rust still does not have crates for machine learning. It's fast, strongly typed and safe.
Thanks! This is a phrasing issue, I guess. Would you mind filing a bug against the book? I’m going to lose this in the hubbub of the release.
So apparently you have to use cargo fmt in order for it to understand the edition. I’m not sure about those two IDEs but it sounds like bugs should be filed...
Yes. A fix is on the way.
After much self-flagellation after reading your response, I changed my non-Aasci font for iTerm2 to 'Hack Nerd Font' and low and behold everything works :) Thanks for reminding me that turning things on matter :) lbe
*proceeds to post memes while /u/kibwen is playing SSBU*
Please, file away ! We're happy to help anyone having issues with \`cargo-aoc\` and are glad that people seem to like the project :) Please, provide an example of the given Lifetime problem so we can take a look 
There are a few projects out there using Rust for web backends, although some of them are probably learning projects more than anything. My personal feeling is that once the async/await and futures stuff is stabilized, Rust will be a great choice for microservices and infrastructure services. The [Linkerd 2.0 data plane](https://github.com/linkerd/linkerd2-proxy) (formerly Conduit) is written in Rust, for example. In modern container environments, Rust is a good choice because of the performance and low resource overhead. For actual web sites, though, I think it's always going to be easier to use something like ASP.NET or Node.js.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/python] [New Rust-based Jupyter client library](https://www.reddit.com/r/Python/comments/a3sapd/new_rustbased_jupyter_client_library/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hmm, is security WG so obscure that even the Rust developers are not aware of it?
Man I'm honestly really confused about the 2018 edition. Afaik with the newest compiler I can add edition = "2018" to my Cargo.toml to be able to use features available in the 2018 edition. And those had to be included in a new edition because they could break older programs, right? So if a new update with new feature comes are both edtions going to get the update and we are going to have 2 rolling editions from now on? Or is the 2015 edition just going to be completely frozen and only 2018 will receive new features? I wish they would just bump the version number to 2.0 instead of doing this. Rust promotes semver yet instead of actually using it they are doing this.
In a way, it's nothing new, variance tends to do similar things.
are you aware of the EvCxR jupyter kernel, out of google? https://github.com/google/evcxr/tree/master/evcxr_jupyter 
Hooray! Look at this handy function that was stabilised: &gt; `pub fn replace(&amp;mut self, value: T) -&gt; Option&lt;T&gt;` &gt; Replaces the actual value in the option by the value given in parameter, returning the old value if present, leaving a Some in its place without deinitializing either one.
We only talked about the “domain wg”s that were part of the yearly roadmap. That doesn’t mean other WGs aren’t important, but they’re often much newer, and haven’t shipped stuff yet.
Is there a legitimate technical reason that NLL is gated behind 2018 or is it just gatekeeping by the core team?
Hi I'm not familiar with this family of packages. I can see that it implements a \_kernel\_ but I can't see that it replaces the client abstraction. Does it?
I was going to write something with a very similar title to this. Every year there's a roadmap and every year it seems like most of the goals aren't delivered by the end of the year. [Even looking at the 2017 list](https://blog.rust-lang.org/2017/02/06/roadmap.html) I'd say we're still missing a _solid_ IDE experience, being equipped for high-scale servers and - although incremental compilation did help - a pleasant debug cycle. Not to say things haven't improved but I think it's really quite sad that a year later they are still boxes that are unticked. I think it's time to be a bit more realistic about what can be done in a year
My version is `rustup 1.16.0 (c4f0221d1 2018-12-06)`. I've build it from AUR and it's not released yet. But the [latest release on github](https://github.com/rust-lang/rustup.rs/releases) is `1.15.0`, so anyway your version seems to be outdated. Can you retry the same steps after updating your rustup (`rustup self update` it it works on Windows)?
2019 = maturity! I loved 'impl period' in 2017. I would love to see 'impl period' for the whole 2019. So many great things still not finished: specialization (my personal no. 1), more of const fn, async/await (community no. 1 I guess), type ascription, try from, macros 2.0, rls. Compiler plugins? (not sure if it is even possible) And optimizations, mainly of compile times. New things could be useful, but I would love to see these things finished first and I think it is nice goal for 2019.
According to the blog post, (at the very end of the [Non-lexical lifetimes section](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes)): &gt; We plan to backport it to Rust 2015 at a later date.
I think it causes a few breaking changes (code no longer compiles)
I couldn’t agree more. Rust is great for tooling, but I would pick languages more suited for building applications themselves (in my case it is anything on BEAM platform). I have written one service purely in Rust, and while it was robust, it would be hard to find anyone to maintain it after me (and that was just single, simple endpoint). For anything bigger I just not believe that it is worth it. 
These concepts are orthogonal. I think you are creating confusion to other readers by introducing latency in this context. The following definition is straight from Agner: &gt; The latency of an instruction is the delay that the instruction generates in a dependency chain. In other words, latency is the delay (measured in cycles) between the moment the calculation is performed and the moment the result becomes available to be consumed by another function that requires the result. Your latency is hence highly dependent on your particular program, and it is wrong to attach a particular value other than “one cycle” to it. Look for example at the implementation of matrix multiplications in the BLIS library: they try to design their multiplication kernels in such a way that the total latency of the addition+multiplication steps does not matter.
Cannot confirm, sorry
AIUI this was a conservative choice due to the *possibility* that some existing code might break. &gt; We plan to backport it to Rust 2015 at a later date.
Well, you could wrap it into a function and then at use site it would be simply `product(1..=10, 1..=10)`. Also, you can already find this function in `itertools` crate: [`cartesian_product`](https://docs.rs/itertools/0.7.11/itertools/trait.Itertools.html#method.cartesian_product).
wow... I had already run `rustup self update` (more than once, actually!) but I decided to try once again just in case... and now it updated to `1.16.0 (beab5ac2b 2018-12-06)`! Now it works: the problem has been fixed in less than one hour. Thanks!
You have a big constant expression in `react_polymer`, the regex constructor. This is not free. In release mode, the compiler probably inlined the function, then saw the constant expression inside the loop and pulled it out. (not certain rust/llvm can do this last part, but it seems likely) You might try running in debug mode with a profiler to see where the time is actually going. Then if that is indeed the problem, you can use `lazy_static` to avoid this altogether, as mentioned in the regex library docs: https://github.com/rust-lang/regex#usage-avoid-compiling-the-same-regex-in-a-loop
Wrong subreddit son. 
I like the idea of better ide tools. Debugging takes too long to get working, and when it does work, it doesn't work well. I've gone back to \*cringe\* writing println statements and logging.
There are two open problems with procedural macros (at least until the new edition, I have not yet had time to rustup): 1. procedural_macro_hygiene is still behind a feature gate. You'll need it to introduce bindings, for one thing. 2. Macros are likely to be unexpanded when you get them, so all you know is the macro path and the argument `TokenStream`. There is a RFC to rectify this, and it has seen very nice progress during the last weeks, so this is going to be rectified a few weeks hence. Depending on what you want to do with your macro, those may or may not be problems to you, but I encountered them when porting my proc macro crates to the new interface.
Curious what you mean by middleware 
Yes, the fix should be out!
Thank you!
Wasn't there also the issue that procedural macros couldn't be used in expression position? Is that still the case, or no?
It's still buggy on Windows. RLS, Clippy, rustfmt and co. don't exist
No it does not replace the frontend. Though I'm sure it will be of interest of the author.
Did you update rustup and then reinstall the toolchian?
Oh, I didn't know I had to reinstall the toolchain as well. Thanks, I'm assuming it works now.
Let me know if it doesn’t!
Anyone having luck with rustfix (`cargo fix`)? I've tried it on a few crates and it completely shits the bed on anything involving macros or custom derives. I might write up a report of my experience later, but at this point I'm just wondering if I'm an outlier in my experience or not.
I just want to say that I really appreciate how friendly and well articulated this post was. Oh, and this is the subreddit for the programming language called Rust. Not the game. Have a look at /r/playrust.
This is the sequence of commands that worked for me (half an hour ago, not before): 1. `rustup self update` 2. `rustup toolchain remove stable` 3. `rustup toolchain add stable` 4. `rustup component add clippy rustfmt rls`
async/await
Hey ! Jupyter Dev here. This is great ! We're happy to see things like that taking form. You (likely) have a number of complaints about documentation and things that make it hard to implement the protocol in a language like Rust. We would gladly hear these complaints and could try to address those in further version of the protocol. We already got feedback from the [QuantStack folks](https://github.com/QuantStack/xeus) who complain that some message fields did not had a know length and thus could not be stack-allocated. Fee free to send messages to our various channels, some people are likely interested in contributing there as well.
Probably not much drawback. I will to write a roadmap blog post soon to explain. Tldr in 0.1 async/await apis will have an _async suffix. For example, tokio::run_async will take an async fn while tokio::run takes an 0.1 Future. This will continue for a bit while things stabilize. At some breaking release the _async will be dropped. So, in theory it should be pretty painless to incrementally update.
Also, of course, async / await is still unstable and, as such, tokios Async await support is experimental as well. Things will most likely still break until it hits stable. Once it does, it won’t take long for Tokio to have stable support. 
It seems to have worked, but now RLS constantly crashes. I'm kinda thinking I may need to cargo clean, but I'll figure it out from here.
Thanks! I'm very glad you liked it! The slides are [here](https://killercup.github.io/presentation-declarative-programming-in-rust/index.html) (press `s` for speaker notes)
Great work!
Please file bugs!
All of that is straight-forward except the "distinct" - that's not an operation that's easy to do in general, so in a sense F# makes it seem less involved by providing one possible implementation. You can either first collect into a `Vec` then `.sort()` and `.dedup()` (which will, sadly, change the order of your elements) or have a `let mut seen = HashSet::new();` variable so then `.filter(|&amp;x| seen.insert(x))` is your "distinct" (I assume F# does the latter, not sure what kind of set it uses though).
There is always room for improvement. Major strides were made in those areas, e.g. debug cycle has improved a great deal thanks incremental compilation and parallel codegen landing.
Try to change the parameters ... https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5c8c70571a45ea0d240db9b2222332f8
Ty bro i didnt really understand but it works =)
If you are interested in learning Rust as a web developer, you can follow the development of Tide. There are big names working on it like Aaron Turon. &amp;#x200B; [https://rust-lang-nursery.github.io/wg-net/2018/09/11/tide.html](https://rust-lang-nursery.github.io/wg-net/2018/09/11/tide.html)
I guess a cross-platform native GUI library with also WebAssembly in mind, would be a good focus.