The first few versions of the rust compiler were written in OCaml. 
Thank you for responding! &gt; Typically how they differ in usage is that `Copy` is used for fixed-size, stack-located data that we know we can stack allocate -- `str`, number types, and so on -- where `Clone` is used for data structures that we don't always know the size of, or more importantly, may have to reallocate memory for at runtime. Does this mean anything `Copy`able will always be stored on the stack? And that only types with a fixed size are `Copy`able? &gt; In Rust each variable is assumed that allocated value has exactly one variable owning it, and when that variable goes out of scope, the memory can be cleaned up with no issues. I like this reason. If one of Rust's "beliefs" (idk what you would call it?) is that _allocated memory needs exactly one variable owning it_, then pointing another variable to the same memory would break that rule. So, we either need to invalidate the old variable (move semantics), or make an entire copy of the data for the new variable (copy semantics). Is that understanding of move/copy-semantics okay? 
I think if I still did a lot of mathematical modeling, I would take the time to learn Julia / I would advise any fresh PhD student planning on doing lots of computation to learn Julia instead of Python. It's definitely worth taking a few minutes to investigate - it makes the right set of trade-offs for numerical computing. With that said, I still feel exactly the same as you and want Rust-friendly numerics libraries. Maybe I'll try wrapping SUNDIALS CVODE and see how it looks... 
Isn't "cheap" subjective? Is that why you put quotes around it? A struct with a few fields could be considered cheap to copy, but what if the struct is really huge? Or is the cost for copying considered cheap because anything `Copy`able will always be stored in the stack? 
I have an ownership issue with my variable moved_fauna declared on line 129. is there any way to make my double loop starting at line 131 only borrow moved_fauna. I think one solution is to move the loop to a function which I am likely to do in the future once I have sorted out the next loop. https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f3849b24ee99cd757b117bc22f86207d 
&gt; This is in line with what a shallow copy is in other languages; it copies the top-level values but doesn't do any recursive copying. What did you mean by it doesn't do any recursive copying? I tried my same example but with `x` as another `Copy`able struct instead of a primitive and it performed a full copy. ``` #[derive(Copy, Clone)] struct A { x: Nested } #[derive(Copy, Clone)] struct Nested { y: u32 } let a = A { x: Nested { y: 2 } }; let mut b = a; b.x.y = 3; ```
From: [https://stackoverflow.com/questions/36672845/in-rust-is-a-vector-an-iterator](https://stackoverflow.com/questions/36672845/in-rust-is-a-vector-an-iterator) According to [https://doc.rust-lang.org/std/vec/struct.Vec.html](https://doc.rust-lang.org/std/vec/struct.Vec.html) : &amp;#x200B; "In the documentation for Vec you can see that IntoIterator is implemented in three ways: for Vec&lt;T&gt;, which is moved and the iterator returns items of type T, for a shared reference &amp;Vec&lt;T&gt;, where the iterator returns shared references &amp;T, and for &amp;mut Vec&lt;T&gt;, where mutable references are returned." &amp;#x200B; &amp;#x200B; Meaning, doing "for livly in moved\_fauna" actually moves the vector, however "for livly in &amp;moved\_fauna" works fine. Hope that's helpful. &amp;#x200B; &amp;#x200B; btw: Actually running that script in the playground completely killed my browser :)
This looks like something that might go into a rust repo issue to me
When you "move" a struct, say to a function or into another struct, does Rust actually physically move memory? Is it inefficient to use this over giving reference?
I like Rocket's ideas but it is still not on stable and I worry about the performance. Sure, it does not support async yet but that does not explain why it is slower than some of the synchronous Ruby setups. Hopefully it is just done minor stupid thing and not a fundamental architectural issue.
Thank you it is helpful. I thought the solution was in the other loop. first browser crash I have caused :o
So, I stand partially corrected! I was actually able to remove quite a bit of the unsafe code from the line break functions as well, though through slightly different means. There are still a few bits that appear to need some `unsafe` to maintain performance, but most of it is gone! Thanks for the push to clean this up!
Yes. However, just because the compiler is written in a language doesn't mean it is like that language. For example, I can easily write a C compiler in Haskell.
According to [https://doc.rust-lang.org/std/marker/trait.Copy.html](https://doc.rust-lang.org/std/marker/trait.Copy.html) : &amp;#x200B; &amp;#x200B; "It's important to note that in these two examples, the only difference is whether you are allowed to access x after the assignment. Under the hood, both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away."
I don't know about being stored on the stack, but they will \*always\* be a direct copy of the memory occupied by the struct (So if the struct contains a pointer to something else it will copy that pointer's value directly, it won't create a copy of what said pointer points to). Afaik, all structs have a fixed size, the concept of "varying size" afaik is usually implemented, for example, with a recursive option (Like "struct List {data:u8;next:Option&lt;List&gt;}") meaning that the struct itself is fixed size, so they can all be made copy-able (However this is not always desirable. From [https://doc.rust-lang.org/std/marker/trait.Copy.html](https://doc.rust-lang.org/std/marker/trait.Copy.html) : "A simple bitwise copy of String values would merely copy the pointer, leading to a double free down the line. For this reason, String is Clone but not Copy."). It might also be of interest that Clone is a supertrait of Copy, so everything Copy-able is Clone-able. &amp;#x200B; On the second question: Yes. &amp;#x200B; Happy hacking.
&gt; Does this mean anything `Copy`able will always be stored on the stack? My interpretation and knowledge is yes. The [`Copy` documentation](https://doc.rust-lang.org/std/marker/trait.Copy.html#when-cant-my-type-be-copy) says the following: &gt; ## When can my type be `Copy`? &gt; A type can implement `Copy` if all of its components implement `Copy`. &gt; ## When can't my type be `Copy`? &gt; Some types can't be copied safely. For example, copying `&amp;mut T` would create an aliased mutable reference. Copying `String` would duplicate responsibility for managing the `String`'s buffer, leading to a double free. &gt; Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's managing some resource besides its own `size_of::&lt;T&gt;` bytes. What these points can tell us: - You can only implement `Copy` on a type if its components are `Copy`; this limits you to a type composed of only standard library `Copy` types, enums (which can be trivially represented as `uX` numbers), or the unit struct (`struct A;`). Incidentally, these are all fixed-size and stack-allocated. - Types implementing `Drop` can't be `Copy`; only types that are heap-allocated need to implement `Drop`, because their resources aren't managed by the scope (i.e., they're not cleaned up when the stack is unwound, they have to be explicit). Counterpoint, you don't need to implement `Drop` if your resources are stack-allocated. &gt; So, we either need to invalidate the old variable (move semantics), or make an entire copy of the data for the new variable (copy semantics). Is that understanding of move/copy-semantics okay? That's a good way of putting it. When you create a new variable from an old one, data always has to come from somewhere. Rust chooses to move it by default, because it's always faster to move the data than to copy it. Rust goes the extra step and forcibly stops you using where the old data was, but I can't confirm if other (recent) manual memory languages do the same.
&gt; fixed-size, stack-located data that we know we can stack allocate -- `str` Wait, I thought `str` was unsized? That being the reason we use `&amp;str` 
&gt; Does this mean anything `Copy`able will always be stored on the stack? Anything that implements `Copy` always *can* be stored on the stack. I think walking through what `Box&lt;T&gt;` does will help your mental model. A `Box` is a smart pointer that stores things on the heap. Conceptually, the box "owns" its contents, like you say in your last paragraph. Creating a box allocates heap memory and writes its contents to it, and the `Drop` implementation of the box drops its contents if necessary and then frees that memory. A `Box&lt;T&gt;` itself is basically just a wrapper around a `*mut T`, where the pointer points to the heap. For example, you can have a `Box&lt;i32&gt;`. In this case, the box struct itself is something like `0x329a3d80` stored on the stack, and at that memory address on the heap, there are 4 bytes that represent an `i32`. So, even though the box struct itself is just a pointer stored on the stack, it isn't `Copy`. This is because copying it bit-for-bit would create two identical pointers to that `i32` on the heap. Now, when these boxes are dropped, they will each try to free this memory. Note that this is the case even though we know the size: `Box&lt;T&gt;` is 4/8 bytes (32/64bit systems) and `i32` is 4 bytes. Instead, we can clone a box if the contents are cloneable, which creates another box with a pointer to a new section of memory, and then clones the underlying contents into that new memory. In the case of a `Box&lt;i32&gt;`, the contents are simply byte-for-byte copied into the new heap location. But what if we had a `Box&lt;Box&lt;i32&gt;&gt;`? The same rules apply to the inner box as before: a box is expected to "own" its contents and be the only owner of them. Thus, if we cloned a `Box&lt;Box&lt;i32&gt;&gt;`, it would have to copy the `i32` into a new heap location, store an address to that in a new heap location, and then give that second address to the new outer box on the stack. This is where the sense of shallow versus deep comes in. 
My company, ferrous-systems.com does offer work like this, also continued maintenance. We're aiming for finding commercial sponsors, though. We give huge rebates for fully FOSS work. I do believe a proper LLVM backend is something we need (and soon). The cost of writing an LLVM backend commercially isn't cheap, though, and I would expect it at least in the range of high five-figures to low six-figures to make sure that we can guarantee proper continued maintenance. Without the prospect of continued maintenance, I would not expect the LLVM project to accept patches.
The problem is that, last I checked, mrustc doesn't borrow-check. It just assumes you've already done that using rustc... and I don't see any information in the esp-rs on whether they've hacked together some workaround to use `rustc` to borrow-check crates that are only meaningful under an architecture it doesn't support.
What's a PoC?
You're right, I'm wrong on `str`. A skim through the docs and book say `str`s are hard-coded literals or otherwise borrowed from owned strings; I don't think they're ever on the stack, and it's always borrowed because it's somewhere else. It also turns out the size is stored with the pointer, not the data, which makes `str` itself unsized.
Proof of concept, I would assume.
Proof of concept
Borrow-checking is not target-specific, though. Still, I don't see mrustc as a long-term solution, it's not meant as a production compiler. 
According to https://twitter.com/jcmvbkbc/status/976143248367394821, there's even a target available commercially, but not upstreamed. It's still unclear if the espressif backend will end up the same.
[mp4 link](https://external-preview.redd.it/mp4/H6dBIlg20X0txblX1GNzGzJufmLuyV3C9XvvVxtEPIk-source.mp4?s=10b6d95202a060adadcd66662072e76e78d5d1b8) --- This mp4 version is 13.73% smaller than the gif (2.14 MB vs 2.48 MB). --- *Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2
i'm sorry, i will upload mp4 next time! :)
Yeah, I use Rust to create Chrome/Firefox extensions (which are normally written in JavaScript). I also use it to create client-side single page applications (which also traditionally use JavaScript). It works really really well! &amp;#x200B; Rust is so nice and so powerful and so high level and so well designed and so general purpose that it can be used for pretty much anything. &amp;#x200B; My entire programming career I've used languages like JavaScript, TypeScript, Python, Ruby, and Haskell. Rust is my first "low level" language, but it certainly doesn't feel low level to me!
I was more worrying about it passing/failing code based on an interpretation of `cfg` attributes that will not apply when targeting the esp8266 via mrustc.
I might be a bit ignorant, but at which scales does async actually become important? I mean rocket+diesel seems quite performant to me and the main bottle neck is the DB anyway in most cases. Currently it feels to me like "async" was the paradigm of the month coming from JS land (where it was needed because of the lack of threading) and doesn't add much for most people. In my very limited experience with async code it becomes much harder to reason about program and data flow. Where/when should one use async code instead of blocking threaded code?
I think you meant r/playrust. This sub is for the programming language Rust
May be you should use RC&lt;RefCell&gt;
I see. Sadly, it's not documented. 
And don't forget: Only _ONE_ mutable borrow!
There is some syntactic similarity in that you're adding some metadata before a declaration, but AFAIK Python decorators are purely declarative, like C# attributes and Java annotations, ie they don't have a direct effect on the annotated declaration; at most they're recognized specially by the compiler. Whereas Rust macros can completely transform the annotated declaration in a user-defined way, and even allow the declaration to use a custom syntax, based on Rust's lexer but not its parser.
Yes. It is basically an RCU or RCU-like data structure, imo. 
If you mean attributes (which can be but aren't always pr
With clap/structopt, how do I get something like `foo -I bar baz quux` to parse to `Opts { includes: ["bar"], args: ["baz", "quux"] }` rather than `Opts { includes: ["bar", "baz"], args: ["quux"] }`? structopt generates `Arg::with_name("includes").takes_value(true).multiple(true)`, but that seems to give the latter semantics.
First, this talk was awesome for a lot of reasons. Second - I can't help wonder: could it all be implemented as a frontend to basically any conventional SQL db being a backend? Sort of like a smart memcache layer that knows sql and can update/manage cached data better? Maybe it wouldn't be as fast, but I think it would be easier to introduce into existing infrastructure and still use all the other features of backend db. 
Python is also a good candidate for data analysis (better than R, but that’s my personal opinion).
You forgot to link to your project: https://github.com/PsichiX/kaiju-compiler-core
Thanks :)
Reuse is actually not guaranteed even with move semantics: &amp;#x200B; According to [https://doc.rust-lang.org/std/marker/trait.Copy.html](https://doc.rust-lang.org/std/marker/trait.Copy.html) : &amp;#x200B; &amp;#x200B; "It's important to note that in these two examples, the only difference is whether you are allowed to access x after the assignment. Under the hood, both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away."
As far as i can tell, it pretty much does that already. However, you might wanna look at [https://github.com/mit-pdos/noria/issues/111](https://github.com/mit-pdos/noria/issues/111) before you try using it. Specifically: &amp;#x200B; " You're right that the current version of Noria is a research prototype. However, it's definitely ready to try out: we've manage to run some real web applications on Noria with minimal modification. " &amp;#x200B; " For production use, Noria might need: 1. Improvements to return more helpful errors when Noria doesn't support a query yet ([\#98](https://github.com/mit-pdos/noria/issues/98), [nom-sql, #36](https://github.com/ms705/nom-sql/issues/36)). 2. Better fault-tolerance and high-availability support: client failover ([\#105](https://github.com/mit-pdos/noria/issues/105)) and rebuilding only failed shards (rather than entire operators). 3. Better resharding/shuffles ([\#95](https://github.com/mit-pdos/noria/issues/95)), so that it can support upqueries across shuffles in the data-flow." &amp;#x200B; I personally find this project super exciting and hope it reaches production readyness at some point.
I think you got it wrong: In one case, the error refers to the right side of the equals, and on the other, to the left. Comment 2 ([http://i68.tinypic.com/33biyog.png](http://i68.tinypic.com/33biyog.png)) refers to the right side, and it's telling you it expected something of type Unit (Like the left side) but found &amp;str. Comment 1 ([http://i68.tinypic.com/2qnuyd1.png](http://i68.tinypic.com/2qnuyd1.png)) refers to the left side, where rust expected a str to which it can assign st. I'm not entirely sure why, since if you try that ("let x:str = st;") it will error, since you actually want a &amp;str. &amp;#x200B; The type of your st variable is &amp;str.
Yes, using up an extra 13.73% of the Internet is just…*horrible*. What kind of human being *are* you? &lt;/s&gt;
I think I should leave an active development part to you. Because trying to explain all the architecture changes and stuff to me will only slow you down. For now, I can try to add a Qt backend to `piet` and a `piet` backend to `resvg` as a separate branch.
Feel free to give the language a try, I think we all agree on this sub we prefer it over the game ;) 
Glad to see Rust hasn't changed.
I've never been raped with an AK or a spear while programming Rust before. I should be more careful. :) 
As a row is stored contiguously, it's possible to get a mutable slice with an `into_slice` method. pub fn make_board() -&gt; Array2&lt;usize&gt; { let mut board = Array2::zeros((9, 9)); for i in 0..9 { board[[0, i]] = i + 1; } board .row_mut(0) .into_slice() .expect("contiguous row") .shuffle(&amp;mut thread_rng()); board }
The book-length comments you made in this thread lead me to believe that you are more than capable of making a positive difference in the condition of reqwest's documentation and API.
how much of that is the fault of rust and not just poor foresight?
Not sure the borrow checker can protect you from a Mongolian horde gang bang. Is that what people are calling chained futures these days?
There is some good discussion [here](https://users.rust-lang.org/t/when-should-the-copy-trait-be-used/8634) on this topic, but there are no hard rules about when to impl Copy, otherwise the language could just make the decision for you. 
Rust's macros appear similar to Scheme
For a laugh you may want to watch [I can has grammar?](https://www.reddit.com/r/ProgrammingLanguages/comments/acx5gq/cppcon_2018_timur_doumler_can_i_has_grammar/), a CppCon talk from Timur Doumler about the state of the C++ grammar. It's presented on a very light tone, and I could not help but smile; yet at the same time it describes a very serious problem for C++ tooling... and the quality of error messages foisted on C++ developers.
In most cases I'd prefer using termion and println directly like this: ``` extern crate termion; use termion::{color, style}; use std::io; fn main() { println!("{}Red", color::Fg(color::Red)); println!("{}Blue", color::Fg(color::Blue)); println!("{}Blue'n'Bold{}", style::Bold, style::Reset); println!("{}Just plain italic", style::Italic); } ``` With this method you get compile time checks on the correctness of the println statement, rather than a runtime check as with your library. Also, since it uses the standard println macro, there isn't any extra syntax to learn/remember. Was there a reason this doesn't work for your use case? 
&gt;https://github.com/PsichiX/kaiju-vm-cli https://github.c jesus why so many different repos, dont even know where to start
I believe you might be looking for multiple(false)
nice one, thanks
mind telling a bit what the goal is of your project or was there an explanation / blog somewhere about this? It seems really interesting
I have an idea for a relatively small web app that I want to build mostly for learning purposes. I was looking at actix-web for this. However I keep hearing things about async/await support being "just around the corner". I'm basically unfamiliar with async programming so I was wondering if I should wait until that lands before starting? Does it even matter for this kind of project/using actix-web?
&gt; Without the prospect of continued maintenance, I would not expect the LLVM project to accept patches. This. LLVM has strict guidelines for adding support for new architectures, as it should since each new architecture means extra effort when modifying the backend code. Not only will they ask for long-term maintenance, but they will also seek to evaluate whether the commitment "Of course!" is indeed likely to be honored or not. The ideal case is a company with a vested interest in the target itself, the worst case is a lone individual doing it as a hobby.
Nah, I'm just a random guy with a profiler and 10 minutes to burn :-). &gt; I think cargo has a feature for examples so I don't need to declare another toml file for the examples but need to read more about it. Make a `main.rs` file instead of a directory. &gt; now you can run the example Yeah, seems fine now. &gt; I was thinking on using octree later on for the spacial query Yup, or a k-d tree. I think you've written this kind of code before (I don't even know what the `gox` format is)? I wanted to tell you before that `f32` doesn't implement `Hash`. That's because of the `NaN`, but you can use a crate like `noisy_float` or `decorum` to get a hashable float. I'm not sure which one's better. Gotta run, but here's a new profile: 24.05% main main [.] core::num::flt2dec::strategy::grisu::format_shortest_opt 6.28% main main [.] core::num::flt2dec::strategy::grisu::format_exact_opt 6.04% main main [.] &lt;alloc::vec::Vec&lt;T&gt; as alloc::vec::SpecExtend&lt;&amp;'a T, core::slice::Iter&lt;'a, T&gt;&gt;&gt;::spec_extend 5.06% main main [.] core::fmt::float::float_to_decimal_common_shortest 5.05% main main [.] core::fmt::write 3.92% main libc-2.28.so [.] realloc 3.81% main main [.] core::fmt::Formatter::write_formatted_parts 3.18% main libc-2.28.so [.] __memmove_avx_unaligned_erms 
FWIW, I have a similar experience with many rust docs. Rust seems to encourage a 'reference manual' approach to documentation; explain each trait, struct and method. What is often missing is the corresponding guide that maps from common goals to the how you achieve then. I've found that I'm often better off ignoring the docs to begin, and going straight to the examples. Once those give me an overview of how the crate is used, then the auto-generated docs can be used to make changes from there. This does seem to be a doc culture thing in parts of the rust community. It certainly isn't everywhere - the quality of the rust book for example is amazing. But it is a trap - people get lured in by the great docs on the basic language and then need a crate (because batteries aren't included) and find the docs aren't the same quality. Things are getting better. It used to be you had no good way of finding good crates. Now there is the rust cookbook, and the great work by the rust nursery team in getting some of these external, but commonly used, crates up to scratch. But I note that the rust cookbook recommends reqwest to make a simple http request, and if it's docs don't have a guide section then that's where people will get stuck.
If I understand you correctly, you're after a rust REPL (Read Evaluate Print Loop). They aren't in common use. You might want to also look at Jupyter. It is what you'd design if you weren't limited to a text terminal. There are Jupyter kernels for many languages. For rust specifically, take a look at https://reddit.app.link/v8amSp5XfT
Capable, sure. Once I figure out how to reproduce a 4-line Python script in Rust. 
Indeed. I think that [readthedocs](https://docs.readthedocs.io/en/latest/intro/getting-started-with-sphinx.html) set a good example for how to do things. Let's compare two examples: * [PySerial](https://pyserial.readthedocs.io/en/latest/index.html) * [RustSerial](https://docs.rs/serial/0.4.0/serial/) 
Well, about Gox, is a file format for building 3d voxel shapes, its kinda a 3d paint that supports voxels and marching cubes. I picked as my first format to integrate into my library because the tool has a lot of features and also supports kinda infinite terrain (not like MagicaVoxel that is almost the same tool). I was checking also num to parse the binary file (it may be more efficient) but my first implementation was to know what really does at low level the parsing stuff. I'm now concerned about `[core::num::flt2dec::strategy::grisu::format_shortest_opt](https://github.com/rust-lang/rust/blob/79d8a0fcefa5134db2a94739b1d18daa01fc6e9f/src/libcore/num/flt2dec/strategy/grisu.rs#L153)` I may do unnecessary convertions between uint/float and vice versa, need to check this out. Also I installed ubuntu in a VM and tried to run `perf` I get an output that is not so clean as yours, I mean has a lot more of method calls and also they are dirty (weird characters between them), did you use some special flag and/or create some kind of dsym for the example? What I tried was - `cd gaiku-3d` - `cargo --release --example main` - `perf record -g ../target/release/examples/main` - `perf report` Will check `noisy_float` and `decorum`, right now I implemented an ugly temporal solution that was just converting the vector into string and use that for the key (high level developer here, low level stuff are pretty new for me).
Great example. To be fair, much of what is in the PySerial docs isn't need for rust: just use cargo. The key is the 'Short Introduction' section. And some rust crates do have an equivalent guide, but enough of the 'standard' (albeit not std) crates don't that it becomes noticeable. Perhaps there needs to be a clippy lint: if the generated docs are less than X thousand words of overview docs (i.e. docs attached to the module rather than a struct within it) then you get a lint. 
Random question, how do you do the drop down terminal? 
I know that this thread should be about Noria and Jon-stuff, but .. :D This task seems like it would be pretty easy in differential dataflow, right? You would write folders .filter(|x| !x.actedOn) .map(|x| x.folderId) .count() and this would incrementally maintain the counts for each folder id. You could even skip the `count()` if you could deal with only seeing the changes to the counts (not always acceptable). The throughput should be in the millions of updates/sec per core, unless I am misunderstanding the query. The gist here is that deterministic computation and optimistic concurrency control means that you can retire really high throughputs of updates, because you don't need to sequentially lock and process each update (instead, you pre-serialize the updates by either transaction id or perhaps `publicationTimestamp` if that makes more sense semantically). You also aren't maintaining an indexed representation of `folders` so much as the post-filter/may `folders`.
Could you elaborate a bit on this? I don't have much experience with either language.
Possibly... I am not up to date on differential dataflow :) As you may imagine, however, this was just *one* of the tables stored in the database, and the application really relied on the atomicity of transactions for a variety of correctness properties, so it would be vastly easier to migrate it to another ACID database than completely rebuild it on top of a completely different data store. All that was really missing from the SQL database was this *one* optimization of `select count(*) from ... where ...;` :(
It's a research problem, but one we're working actively on. We do not believe it to be a fundamental design limitation, though stronger transactional semantics will obviously come at a cost. We believe we can do it without major interventions into the system core though! Keep in mind that Noria is specifically designed for web applications, which are _usually_ somewhat less transactional (though definitely not always). The prevalence of caches in web settings often means that you get eventual consistency anyway, and Noria is no worse than that.
Thank you! All I did was point to a function in stdlib :) Also, is it just me or `line_to_byte_idx_inner()` only takes the fast path with large chunks if the start of the buffer is aligned to the chunk alignment? I don't think that's always the case, so perhaps performance could be improved there. As for `node_children.rs`, I haven't looked at the code so I might be totally wrong here, but perhaps [generational-arena](https://github.com/fitzgen/generational-arena) crate will be of use.
Adding a method that does both an `insert` and a `refresh` should be pretty trivial, though I'm not sure it would add all that much in terms of ergonomics. You'd still then remember to call this other method and not just `insert` (which would likely be the first one you reach for). `discard` is a neat idea, though actually surprisingly tricky (if not difficult) to implement. Consider the case where one of the queued up operations is an "empty" of a key (remember that `evmap` is a multi-value store). How do you "undo" that operation? You'd probably have to do some reads from the current read map (which doesn't have the changes), but now you might end up doing a bunch of work to restore what was removed. Doable, but tricky!
When it comes to _Noria_ (which is our databases that _uses_ `evmap`), there isn't currently a mechanism for waiting for a set of writes to fully propagate. You can do it manually with marker writes, but that's about it. We are investigating adding more transactional support using timestamps though, which would give you the ability to say "wait until all these writes have percolated to all descendant views". But that's work in progress!
Thanks and keep up good work!
Yup, Noria was already posted [here](https://www.reddit.com/r/rust/comments/9mk404/noria_a_highperformance_web_application_backend/) a while back. This talk only discussed Noria relatively briefly though. The "neat data-structure", `evmap`, is only a tiny part of Noria, and arguably not really a novel contribution of the research. Empirically, we have found that such manual materializations do not in fact outperform Noria. I suggest you give the paper a read where we test this in more detail. The MySQL shim does add some overhead, but it is still much faster than what you get with all the SQL databases we tested with manual materializations. Keep in mind that for Noria, reads are really just hash map lookups, except in the rare cases where you miss in cache. Writes then update that cache in place. The materialized views of MS SQL are pretty weak in practice (I don't know much about the Oracle ones, but I suspect they're similar). They have some [pretty severe restrictions](https://docs.microsoft.com/en-us/sql/relational-databases/views/create-indexed-views?view=sql-server-2017#additional-requirements), and are _very_ slow once you have writes. Noria does not suffer from these problems.
Probably guake.
We've toyed with the idea of letting the developer directly specify the data-flow used to implement a query (and in fact, the initial design did this), but quickly ran into issues. For example, for sharding and cross-machine replication, we need to make "transparent" changes to the data-flow at runtime, which the developer would then need to know about and interact correctly will, which isn't trivial. It should be _possible_ though, and would also let you express queries that you cannot write using SQL. Noria already batches writes internally, precisely to avoid frequent synchronizing operations. That batching is currently pretty stupid and static, but it's totally reasonable for that to be smarter/more adaptive!
I'm not entirely sure what you mean by writes being blocking. Noria will respond to an `INSERT` the moment that write _enters_ the data-flow graph; it does not wait until it has been processed to completion to all derived views. We are looking into adding mechanisms for waiting for when a write has fully percolated throughout the data-flow, but that's not currently something you can do. As for your questions: 1. Are you saying that the users all have _unrelated_ queries, or just that they issue the _same_ queries with different values for parameters? The latter Noria handles very nicely using partial materialization (see the paper). The former is tricky, but then again, if the different users use entirely different data in different tables, there isn't really anything you can share. Noria has eviction, which might let you share somewhat fairly between different users, but doesn't have any mechanisms to specifically deal with multi-tenant systems. 2. That is exactly what Noria provides, as described above :) As I discussed [a bit further up](https://www.reddit.com/r/rust/comments/acucrs/rust_at_speed_building_a_fast_concurrent_database/eddq6cx/), support for stronger consistency and transactions is work-in-progress.
I think I say this pretty explicitly in the talk, but can see how, from the slides, it seems like I'm saying it's just all bad. I'm totally with you that the systems are mostly there, and that at this point the issues are more centered around ergonomics.
Not entirely sure what you mean? You can just run `cargo doc --open` and it'll do what you want?
DD isn't a different data store; you would attach it to the commit log of your existing source-of-truth store and it does high-throughput incremental view maintenance for you. It produces outputs at the same granularity as the inputs (eg distinct transactions).
First, thanks! Second, Noria relies pretty heavily on being able to use data-flow to propagate internal updates and let them update views incrementally. I'm not sure how you'd do that "in front of" another DB. Maaaybe you could do it by doing queries to the underlying database as you simulate how the write changes various states, but I think it'd be hard.
In my opinion it would be more useful to rescue the llvm c backend. This would allow to compile to all platforms that have a c compiler
Noria actually doesn't front any DB today. Well, it uses RocksDB for what is essentially an indexed log, but there's no SQL database. Noria does all the query planning and execution, persistence, networking, etc. itself!
Here's the status of Data Science in Rust, if you ever do take a peek back here: http://www.arewelearningyet.com/. 
&gt; There are at least four solution and all are terrible compared to both cargo for rust and stack for Haskell Not sure what you mean, this used to be a big problem indeed but it's been several years since everyone converged on a single package manager (opam) and a single build system (dune, previously called jbuilder). 
Good call!
First: `st` is a `&amp;str`, not a `str`. `let () = st;` is invalid syntax - valid syntax is `let var1: type1 = var2` or `let var1 = var2`, whereas you tried with `let type1 = var2`. Apparently the compiler could give you a better error message in this case.
You need to import [`SliceRandom`](https://docs.rs/rand/0.6.3/rand/seq/trait.SliceRandom.html). This can be either by the prelude `use rand::prelude::*` or importing it directly `use rand::seq::SliceRandom`.
This reminds me a lot of MySQL query cache. With regards to the manual materialisation, I would question if your research optimised the database and data structures as much as they could be, because unfortunately, these are uncommon skills that can have a big influence over performance. But I am happy to look over the configuration of the test setup in your research.
`let () = st;` is valid syntax, just like `let (x,) = y;` and `let (x, y) = z;` is. Here `()` is not a type, but a zero-element tuple pattern. You could also add a type annotation to that: `let (): () = st;`.
Noria is _very_ different to the MySQL query cache. While it does provide what the query cache provides, Noria's key feature is that that cache is efficiently maintained over time as new writes occur! Oh, you are probably completely right that the configuration could be further optimized! In some sense though, Noria's argument is that that optimization should be unnecessary. You will likely also need to configure Noria for optimal performance once it provides multiple index types and the like, but Noria provides a fundamentally different way of thinking about your queries. They are continuously executing programs, as opposed to programs that execute on read. You are _completely_ right that programmers/DBAs could, for any particular set of queries, manually construct a database schema, configuration, materialization strategy, and cache organization that would match, and possibly exceed that of Noria. But that is a _vast_ amount of work, and is often untenable if you have rapidly changing applications. Noria obviates the need for much of that. Sure, you'll still have to do more engineering to squeeze out the last drops of query performance (though remember, in Noria, query performance == write performance, not read performance), but at least most of the data pipeline is taken care of for you (things like cache invalidation).
FWIW: we have huge interest in the target outside of "we code for money", but lack the funds.
i had 2 goals: 1. prove to myself what i'm capable of doing after 1 year of work within Rust - i think i'va made some progress in language :D 2. i want to make 2 games: - one puzzle game about programming (text or graph-like, still don't know) NASA rover on Mars; - one big kerbal-like game about building and programming autonomous robots for battles on tournaments with other players; So i need to make it modular, capable to run on 3 main targets: pc, WASM and unity. My deep dream is also to be listed on arewegameyet.com :3
i's quake mode in ConEmu - very helpful shortcut! :D
I might be not remembering this from the talk, but it was said that you could tell cargo to error-out on building a crate if anything marked public did not have a document comment.
Others have mentioned what they have to say about Rust, and I agree. Rust gets in the way of making most data structures because it's difficult to prove they are safe. If Rust is your primary language, it might help to use it, but I would otherwise recommend using C or C++ to implement such code for practice. If you intend to create libraries, Rust is a good choice because you can ask the community to review your crate and you can investigate the correctness of your safe API over unsafe code. Some data structures may not even require unsafe, but many will. Others (in the other post) have mentioned that it's okay to use dynamic languages. It is okay, but it may be confusing and memory management concepts may not be learned (you might not think about the order things have to be cleaned up and such). I would specifically recommend only using a dynamic language if it is your primary language, but otherwise use C or C++ ideally because that will prepare you best for interviews, tests, and understanding the low level aspects of algorithms. Rust is okay too, just like dynamic languages, but it's going to throw a fit and distract you from writing your data structure code (except in the rare case unsafe isn't necessary).
thanks for finding and putting it here! :)
Do you mean #[deny(missing_docs)] 
kaiju-toolset is the main repo, then kaiju-core is the heart of all of the rest :)
Definitely not an unpopular opinion here. I think most Rustaceans understand the limitations of the language, even if it is fairly general.
Ok, I stand corrected :-)
Usual description-for-people-who-never-hesrd-of-it service: &gt; doh-client is a DNS over HTTPS client, which opens a local UDP (DNS) port and forwards all DNS queries to a remote HTTP/2.0 server.
Python decorators are actually full-blown (meta)functions; they take the decorated object (class/function/whatever) and return a new object that’s then bound to the original name. Indeed, the decorator syntax is just sugar for calling the function and rebinding the name yourself. Now, decorators can’t do AST transformations, but due to Python being so dynamic, all sorts of interesting things are nevertheless possible. Java has the concept of annotation processors, which transform the annotated entity at compile time. Writing them is hilariously verbose though.
Beginners probably don't need to mess with macros.
What I mean is that it doesn't follow references. So for example: ``` #[derive(Copy, Clone)] struct Foo&lt;'a&gt; { x: &amp;'a Vec&lt;u8&gt;, } fn main() { let vec = vec![1, 2, 3]; let a = Foo { x: &amp;vec }; let b = a; println!("{:?}", a.x); println!("{:?}", b.x); } ``` Here, the reference is copied bitwise, so both copies point to the same `Vec` - that `Vec` is not itself cloned.
Both those structs are copy so the rule applies that if a struct contains copy-able members, it can also be copy.
Imo, rust is great for the things that don't need system calls. If you're learning systems and just using libc without building rusty abstractions over it, you might as well use C. If you're doing other things or libraries exist then rust is great. Eg rust is great for trying out networking, but not for namespaces (containerization, etc ) as rust has great networking libs but wrappers for exec and other things are not that great. Good luck and have fun 
I think what Skytrias is asking is why split the project into 7-8 different Git repositories rather than keeping everything under the same umbrella?
&gt; `#[deny(missing_docs)]` Thank you! I was thinking it was a cargo feature and not rustc. https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html
I am (as an individual) in the same situation ;)
Oh, that! Yeah, you add `#![deny(missing_docs)]` to the top of your crate!
Yeah, I completely missread the question (I thought it was asking about using Noria as a drop-in replacement to conventional SQL). Apologies. &amp;#x200B; Thanks for your work!
Trust your instincts. Code *fearlessly*. Embrace that feeling because it is good 😈. Those C and C++ developers don't know what they are missing. If you use C just to facepalm yourself all day long until you are scared to write any code, you might just loose your *fearlessness* and start being careful and taking a day to write code that should only take an hour in Rust. It took me over a year to shake the feeling and just start coding. I am being a bit facetious, but I do want to contrast your statement because learning to be scared is a double edged sword, so don't assume it's going to help you, I am still scarred from C++ bugs that aren't of this world and the dark terrors of C++ forbidden knowledge of rvalues, template metaprogramming, the "" operator (why!), default move semantics, list initializer vs initializer list, and MSVC runtime interoperability 😳. Oh, and C doesn't get off easy. As much as I admire the people that made ffmpeg, how did this monstrosity get created? Gstreamer...please make documentation for, like, anything! At least comment your code! glibc &amp; apache-apr ☹️. Just save yourself. You will get burned by lots of problems that should never have existed. Then again, if you mess with just C with absolutely no libraries (or well documented, modular ones that don't use global state, which is common in C) just to learn a little systems programming knowledge, you might be fine.
Thanks for the clarification! Is it actually practical to retrieve the information of a specific snapshot of the database: ie, if I select the messages of snapshot XYZ, is it possible (and efficient) to retrieve the associated counters?
Its still about 5-8x faster than Django, Rails, or Flask all of which are popular web frameworks. And it shouldn't be a user breaking change to make its routes async so whenever that happens its just "free" performance. What generic sync Ruby framework is it slower then? They just redid all its decorators in proc-macro which evened out the performance versus the old compiler plugin impl. 
I wish you luck in your endeavor; such a feature would be a dream come true for me, and I doubt I'm the only one. Not having to deal with the complexity of caching is just such a huge simplification!
do crates published on crates.io need separated repos or i did something stupid? :D
I think you're right. This runs; but uncomment just one println! and the stack overflows: [https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2015&amp;gist=f0d596f849ccab5733a909f386190a2d](https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2015&amp;gist=f0d596f849ccab5733a909f386190a2d) const ASIZE: usize = 65536*2 - 1; struct Big{ s: u64, s2: [u64; ASIZE] } impl Drop for Big { fn drop(&amp;mut self) { println!("Drop: {}", self.s); } } fn main() { let y = Big{s: 0, s2: [0; ASIZE]}; println!("y: {:p} ", &amp;y as *const _); let y = y; println!("y: {:p} ", &amp;y as *const _); let z = y; println!("z: {:p} ", &amp;z as *const _); let z = add2(z); println!("z: {:p} ", &amp;z as *const _); let z = add2(z); println!("z: {:p} ", &amp;z as *const _); let z = add2(z); println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); let z = add2(z); //println!("z: {:p} ", &amp;z as *const _); println!("{}", z.s); } fn add2(mut x: Big) -&gt; Big { x.s += 2; x } &amp;#x200B;
Same on iPhone XS
Hey what is the name of the package, that adds those dots to your tabs? 
hmm, could you show me what dots?
aaah, got that! it's not a package - you have to select show paragraphs/whitespaces in main editor settings :D
Sounds reasonable. From a process point of view, what I think makes most sense is for me to get piet to the point where it does most of the things on your list (not all, but enough that a good fraction of SVG files could be run). If I keep my current velocity, that won't be all that long. I should also say, one of the particular reasons I find resvg interesting is its test suite. I think it would be great if the main requirement for a new piet back-end developer is "make it run the resvg test suite correctly and performantly." Lastly, this discussion of specific rendering quirks is very interesting. I'd be quite open to adding features to piet so you could request, say, PDF-style or SVG-style line cap conventions. I see a lot of the potential value of piet in isolating such quirks from users of the library.
thanks :)
If they are all inter dependent people usually put them in one workspace and one repo. Like \[Tokio\](https://github.com/tokio-rs/tokio) or \[Serde\](https://github.com/serde-rs/serde) for example.
Alright, let's get this show on the road: https://github.com/rust-lang/rust/pull/57378 Unfortunately, I am afraid that my setup is very suboptimal (Windows edition + Linux in VM compilation with a shared filesystem), which has made iterating over this PR extremely painful, performance wise. Even a simple `git commit` takes ages, which points to the filesystem being the probable bottleneck :/
That only works because the vec is immutable
Oh this one I know! String literals are hardcoded into the final executable. That's the first line of the memory and allocation section here https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#memory-and-allocation I was curious about that statement and tested it out with the following code: ``` fn main() { let a: &amp;str = "hardcoded1"; let b: String = String::from("hardcoded2"); let c: String = format!("hardcoded{}", 3); } ``` After a `cargo build`, we can use the `strings` utility to find the hardcoded strings in the binary: ``` $ strings ./target/debug/test | grep hardcoded hardcoded1hardcoded2hardcoded ``` Notice how both `a` and `b` are hardcoded into the binary even though `b` is a `String`. I'm guessing this is an optimization and Rust decided not to store it heap memory. However, for `c` which involved some concatenation, only the first part of the string could be hardcoded into the binary. Interestingly, the release binary after a `cargo build --release`, does not include one of the strings. ``` $ strings ./target/release/test | grep hardcoded hardcoded2hardcoded ``` I guess this is another optimization since `a` is unused. If we add a print statement to print `a`, and rebuild the release, we'll find it now contains the `hardcoded1` string!
oh, that's good idea! will do it :)
Thank you for the answer, so I guess the answer is sometimes it will move? Guess reference is better.
Given Python is easier to write, lots of data scientists that weren't programmers used it to analyse their data. Then libraries followed them there and today it became what is probably the most solid choice for data analysis. The heavy crunching is all done with libraries written in C so it's quite fast. And you have nice visualisations and everything. And if there's some heavy crunching missing, you can always write some library in Rust. ;)
Thanks for the elaboration! To me it looks like the RxJs approach is like an add on to fight the call-back-hell and Redux the foundation for ui frameworks. I am curious about how it will play along with stable asynch/await and upcoming Rust UI frameworks.
Just saw this now! I think an Etymology section in the docs/README is a _great_ idea and would be happy to merge a PR that adds it! :D
Oh, and for additional context, [this](https://www.reddit.com/r/rust/comments/5saw4z/evmap_another_efficient_concurrent_hashmap/) is the original Reddit post for evmap, and [this](https://www.reddit.com/r/rust/comments/9mk404/noria_a_highperformance_web_application_backend/) is the one for Noria.
Here's a compromise: Start with 100% unsafe Rust. Raw pointers everywhere etc. It's just as easy to shoot yourself in the foot with as C, but you get the benefit of not having to learn 2 completely separate languages with different tooling etc.
These 3 things are completely unrelated to each other: 1. Implementing `Drop` 2. Being stored on the stack or heap 3. Being `Sized` (having a statically known size) &gt; Rust won’t let us annotate a type with the Copy trait if the type, or any of its parts, has implemented the Drop trait. Implementing `Drop` is basically the same as providing a destructor in C++ - simply some code to run on the value just before it is being destroyed. Thus you cannot have a type both implement `Copy` and `Drop` - otherwise you would indeed have a problem with double drops. Technically it isn't unsafe being both `Copy` and `Drop` - its just not particularly useful. Usually you free some external resource in `drop` (or free heap-allocated memory), and having a type also able to be `Copy` is simply a potential footgun. &gt; If that's the case, does that mean Copyable types will never be stored on the heap? Where a value is stored does not depend on what traits it implements. If I do `let foo = SomeStruct::new();`, then I have `SomeStruct` that's stored on the stack (because all local variables are stored on the stack). But I can also do `let foo = Box::new(SomeStruct::new());` - now `SomeStruct` is stored on the heap. And it's `Box` that is managing the memory - `SomeStruct` does not care where I put it. I could then dereference the box to move `SomeStruct` out, and the box will give me the value and take care of deallocating memory once the value is moved out. `SomeStruct` could be `Copy`, and then dereferencing the box wouldn't even need to deallocate that memory - I got a copy of the value, and the original one that's on the heap is still there and can be used again. &gt; In other words, only types with a known size at compile-time can be Copyable? Well, yes, a type cannot be `Copy` if you don't know its size statically. But it's not really "in other words", its kind of a coincidence. Moving a value in rust basically means copying the bytes that make up the value (but in a sense it's a shallow copy - moving `Box&lt;SomeStruct&gt;` copies the 8 bytes that make up the pointer, and `SomeStruct` isn't touched), and also not allowing you to use the original value after that move: `let a = foo(); let b = a;` - after this using `a` will give "value used after move". So you cannot actually move values that don't have a statically known size, because the compiler does not know how many bytes it has to copy. Now the only difference with `Copy` is that you are *allowed* to use the original value after move - that's really the only difference. So it just happens that a value that is `Copy` must be `Sized`, because to be `Sized` it has to be movable in the first place.
That hasn't been updated since 1.0. Since we've gained other language features influenced by other languages, it'd be nice for somebody to do so the reading and figure out what else has been influencing.
Thank you for the walkthrough! I haven't gotten to the chapter on smart pointers and boxed types yet, but your explanation is awesome and everything you said makes sense to me! After some sleep and digesting everybody's answers, let me try to rephrase my two original questions. Your second paragraph proves to me these are false statements: &gt; Anything `Copy`able will always be on the stack &gt; Only types with a fixed size are `Copy`able The counterexamples for both being the `Box&lt;i32&gt;` in your example since: 1. The `i32` is `Copy`able but is stored on the stack 2. The `Box&lt;i32&gt;` is of fixed size, but not `Copy`able (since doing so would cause a double-free error) However, it seems like the converse to both statements are true: 1. If you are on the stack, you _have the potential_ to be `Copy`able. 2. If you are copyable, you are definitely of fixed size. The caveat to (1) being that sometimes making a copy of something on the stack is dangerous (specifically copies of pointers to owned memory -- like in your example). And the reasoning behind (2) is because a type can only be `Copy`able if its components also implement `Copy`. Would you agree with those statements?
[Like this?](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3551a277730de5828ba305499d902e7d)
 let mut vec_of_vecs_of_i32: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new(); vec_of_vecs_of_i32.push(vec![0i32, 1, 2]); vec_of_vecs_of_i32.push(vec![0i32, 1]);
Thanks!
Did you try to do it first? Just creating a vector with a vector inside will work fn main() { let foo = vec![ vec![1i32] ]; println!("{:?}", foo); }
I got the answer already , but thanks!
The difference between Python and R is that Python was designed by computer scientist as a general purpose programming language, while R was designed by statisticians as environment for doing their statistical analyses. As a result, Python can be used to program basically anything (webservers, GUIs, scripting) and incorperates many feature from common langauge (such as arrays start at 0), while R has a lot of stuff for statistics baked into the language itself. Since Python is easy to write and looks clean, many data scientists picked it up and there has been a huge growth in the number of libraries for data analysis. Combined with Jupyther makes it a solid solution. However, in the end, the choice is a lot like the discussions on Vim vs Emacs, Windows vs OSX, Android vs iOS. Both teams think their side is superior and the choice is personal.
Yes, the test suite took a lot of time. But it think that a custom one is the better idea in a long term, because for a rendering library, resvg test suite is too bloated (has a lot of useless tests). Also, I just remembered an another problem to consider (probably soon): gradients "validation". 1. cairo, chrome (skia?) and firefox (skia?) doesn't support focal points correction in radial gradients. And Qt does. See [resvg implementation](https://github.com/RazrFalcon/resvg/blob/ec7f4258e9b0a5a20364dd1fb30e7c8636d8fd07/usvg/src/preproc/resolve_attrs_via_xlink.rs#L356). 1. Stop point offsets are also handled differently. And they have [a tricky algorithm](https://github.com/RazrFalcon/resvg/blob/ec7f4258e9b0a5a20364dd1fb30e7c8636d8fd07/usvg/src/preproc/fix_gradient_stops.rs#L30). Cairo and Qt are mostly assume that the input offsets are valid and ignore invalid one silently. No sure if it should be done one a `piet` side, but at least it should be uniform for all backends. 1. Qt fails to render a gradient with transform on object bounding box. [QTBUG-67995](https://bugreports.qt.io/browse/QTBUG-67995). Not sure if the current `piet` backends are affected, but this is a thing to consider. Also, with Rust you can leverage type safety. Like in cairo and Qt, the radius of a radial gradient is f64/double. But it obviously can't be negative or even zero. So you can ignore an invalid values silently, print a warning, return an `Option` or make a custom number, like `NonNullPositive`. Same goes to stroke width, font size, etc. A lot of possibilities and architecture decisions. This is the part in which I'm very interested. Also, what about the Skia backend? I wanted to do it myself. But looks like there are no good binding for it.
All very interesting, I'll keep these in mind - I haven't really started on gradients yet. Skia is arguably the best 2D graphics rendering library, but the state of Rust bindings is problematic. It's also a very heavyweight dependency.
I'm happy with what Noria does, don't get me wrong. I am just asking that you consider when stating 'MySQL' in your stress test, to simply correct it to 'default MySQL'. &gt; But that is a vast amount of work Well, I would disagree there, because while it maybe vast amounts of work for developers, for me, it doesn't take very long. In fact, I offer a service called 'database performance audit' where I identify your top 3-5 bottlenecks with the current application usage and make recommendations on how to solve it. The problem is that companies do not hire DBAs any more and dont think about hiring external consultants. Micro service pattern and the vast array of different database technologies, makes it impossible for anyone to be an expert in all of them. But that is just my rant about how the industry is going..
I was under the impression that not only were they written in ocaml, but that rust originally started as a transpiled-to-ocaml language. Was I mistaken? (I do agree that rust has largely developed into it's own language and taken a large amount of inspiration from Haskell)
Async and await originally came from Simon Marlow's work in Haskell though, did it not?
It does matter a little bit. But it shouldn't be a large task to port it over. You'll be fine
Wow, nice!! The environment does sound painful. It looks like there is currently a build break--is some way I can help? I could spend an hour or so most evenings. Bad news: I don't expect to have any time available until Jan. 14th or 15th. Good news: I have two or three compiler commits and a bit of compiler documentation under my belt, so I'm a little bit familiar with the environment. Let me know...
Honestly, a while ago I thought the same thing. 
I'm experimenting with using `log` without any logging implementation and I don't see significant size bump even when I include `info!("Hello, world {}", 3);`. Empty `#![no_main]` executable for x86_64-unknown-linux-gnu: `147B .text section size`. After adding the `info!` line: `154B .text section size`. Obviously, that's with full LTO. So maybe just no doing `console_log::init_with_level` in release mode can keep formatting code away?
So, the way these things look like from the DD point of view is that your commit log pushes out things that get translated into (data, time, diff) where the `data` are payload, the `time` is some logical time (e.g. transaction id), and the `diff` is the nature of the change (for us, usually a signed integer indicating the addition or subtraction of the tuple). If we ignore performance for just a moment, you can recover any count for any folder as of any transaction id. However, the price you pay with DD if you want this is that each "key" (here: transaction id) maintains a history of its values (here: counts) which grows without bound, generally. If instead at the same time the database produces its update triples it also produces an increasing lower bound on the transaction ids that have not yet been reported (a low watermark, in stream-talk), and you agree that you'll only ask questions "as of" transaction ids in the future of this value, then differential compacts its state in place. So, you read out consistent results as of specific transactions, but it is probably only "efficient" if you don't require arbitrary historical access (which you can do, but you may want a temporal database at that point). One of the examples in the Noria paper is both Noria and DD doing something like your count example in a different setting (tracking page views, as counts, and reporting the counts for queried pages). Both systems there were handling 10M+ reads per second, with Noria ultimately scaling better due to its weaker consistency guarantees. 
webm! :)
Man I can't wait till I can reliably use `await!` - it simplifies life so, so much. I admit though, I'm a bit scared of how much magic must be involved. Specifically in function signatures. But it's still exciting, regardless
To the point I made, not much relevant wich one. The fact is rust have a harder learning curve, and is not for quick prototyping. &amp;#x200B; You could get much better with learning and practique, but I bet is easily to prove than a python or swift developer could write a solution and be done faster than a rust one. The gains with rust is that is more likely to be correct after finished. &amp;#x200B; This is the trade-off of Rust, and think is ok. Is just important to be clear what a tool is giving to you...
&gt; I was checking also num to parse the binary file (it may be more efficient) but my first implementation was to know what really does at low level the parsing stuff. Yeah, `nom` is somewhat confusing, and I could never remember how to use it (:. &gt; I'm now concerned about `core::num::flt2dec::strategy::grisu::format_shortest_opt` Don't worry, that's your hash table key. It should go away when you switch to a non-NaN float wrapper. &gt; Also I installed ubuntu in a VM and tried to run perf I get an output that is not so clean as yours Sounds like your `perf` doesn't know how to demangle your symbols? I'm on Arch, which tends to have the newest versions of the software. You'll also want to add this to your `Cargo.toml`: [profile.release] debug = true to get better symbols and stack traces.
&gt; Also, is it just me or line_to_byte_idx_inner() only takes the fast path with large chunks if the start of the buffer is aligned to the chunk alignment? That's not correct, I'm pretty sure. It's basically organized like this: 1. If the slice is already aligned, take the fast pass until you have fewer than `T::Size()` bytes left. 2. Deal with any bytes up to the next alignment. 3. Loop back to step 1. So if you start unaligned it skips step one, deals with the unaligned bytes, and then loops back to step 1 for the fast path again. Having said that, I think I can DRY the code more and avoid the outer loop, and make this all a bit more obvious. Next steps. :-) &gt; As for node_children.rs, I haven't looked at the code so I might be totally wrong here, but perhaps generational-arena crate will be of use. I don't believe that's relevant. Removing the unsafe in `node_children.rs` is just a matter of replacing my custom stack-allocated `Vec`-like structure with something like the `arrayvec` crate. Doing so will make Ropey a tiny bit less space-efficient, but it's probably worth the trade-off. To make it equivalently space-efficient, I'd need a struct-of-arrays version of something like `arrayvec`, which is quite literally what I've implemented (but special-cased to Ropey's data types).
Those sound about right. To be clear, you have to think of it not just in terms of what a type *is*, but what it manages. Something like a `Process` might be just a wrapper around an integer corresponding to a PID, but maybe the `Process` is responsible to terminate when it drops. So its about whether the type manages anything beyond its representation on the stack. Also, I'm not sure when in the book the trait `Sized` is taught, but I'd like to point out how it compares to the concept you have of size regarding `Copy`/`Clone`. As you said, if you are `Copy`, then you definitely have a fixed size, and you are also 'Sized`. However, structs like `Vec&lt;T&gt;` are also `Sized` because they have a fixed size *on the stack*. In fact, 99% of types are `Sized`. A reference to anything is sized, any normal struct is sized, etc. The only things I know of that aren't `Sized` are trait objects (`dyn MyTrait`) and slices (`[T]` and `str`). What this essentially means is that these types must always be used behind either a reference or a box, because a reference and box always has the same size itself no matter what it is pointing to. Well, that's actually slightly wrong, because there is special treatment for these. A reference to a slice (`&amp;[T]`) is actually a "fat pointer", which is a `(*T, usize)` with the `usize` corresponding to its length. The point is, that the fat pointer itself is always the same size regardless of the length of the slice. Thus `&amp;[T]` is sized and can be stored on the stack like normal, but `[T]` is not sized and cannot be used in most places, like having a variable on the stack of that type.
Hopefully Piet (and its backends) can become an alternative to Skia rather than just an interface to it. Skia is typically not packaged in distributions, and is not easy to compile or distribute outside of the Google ecosystem. (I’m really excited to see Piet develop!)
If you don't actually link a logging implementation, there is no size penalty. This is detailed in the README with some sample code describing how to conditionally enable and disable the code depending if feature `console_log` is enabled.
That can easily be arranged :) just put up an issue or even a PR here: https://github.com/doppioslash/arewegameyet/issues What category of game tech would you put it in?
Not exactly. There's a pretty open line between C# and the functional programming community, both through F# and through Microsoft Research (including Simon Payton-Jones). Much of that line involves putting developer friendly syntax around powerful programming concepts. LINQ is not a SQL DSL embedded in C#, it’s a developer friendly monad/applicative over sequence types (https://ericlippert.com/2013/04/02/monads-part-twelve/) - it's the same correspondence as between the list comprehension and do syntax. ?? is the Maybe monad in disguise. Here's a good take on the history of async/await: https://softwareengineering.stackexchange.com/questions/377464/who-did-async-await-first So the history here is that the machinery was inspired by Haskell by way of F#, but the developer friendly syntax was introduced first in C#. It’s *just* sugar, but good syntactic sugar that’s nicely handled by the language, compiler and runtime has been really important to developer productivity.
Perfect, thank you!
&gt; it might actually have been before 1.0. I might try it again soon just to see if I still have the same problems. Oh wow. That was before my time and the language was very different then. I agree that programming simple things in Rust requires (or at least strongly encourages) proficiency with a large fraction of the language's concepts. You *have* to deal with references and to understand aliasing and even a bit of lifetimes, just to get started. It really helps to grasp the basics of algebraic data types - you don't need the jargon but you do need to be able to use `Result` and `Option`. You don't have to define generic types and functions, but you will have to use them. C is like that too; you do have to fit the entire language in your head even for basic projects. Rust is a bit worse than C because of things like `for` loops and `print!` being backed up by generic code. Basic CSV parsing in Rust is almost certainly easier if you ignore the by-reference iterators and do everything with indices. There's also an interesting problem here: the parsed data representation needs to be defined and the obvious ways of defining it using the standard library are probably not optimal. For example you probably shouldn't parse millions of "y" and "n" fields to individual `String`s, but you can do that in Python because single-character strings have a special optimization. Generalized parsing of CSV to a very generic in-memory representation is likely to be both difficult to implement and kinda slow as it runs. I'd encourage you to give it another look, but with the caveat that Rust isn't going to be better than Python (or Go) for all purposes. Rust gives you a lot more control over run-time costs, fearless concurrency, good interfacing with assembly or raw hardware, etc etc, but if you don't need those attributes, it's difficult to justify. I'd say that Go is better at beating Python at Python's strengths, unless you're really good at using dynamic typing productively. 
Something that would be neat - more control over the cache. I'd be happy to see a cache that lives way longer + a cache that never dies, and is used for a fallback when DNS queries fail (I am virtually always OK with a stale result on my home laptop over a full DNS failure). Anyways, looks awesome. Glad to see an apparmor profile there as well.
I think the rust serial crate _does_ need more information. How do I configure RS485 mode on /dev/ttyO5 (rts/cts)? How do I adjust the character-timings (not the timeout, but the silence-period between characters on the wire). Those things you can perhaps figure out if you start poking and looking at all the Settings available, and admittedly, the rust serial documentation isn't the worst doc's I've read for a rust project. However, it reads like the in-editor keyword help for functions, the kind of things you used to get in TurboPascal (v4 and onwards had the inline help) back in the day. So yes, I think this is a cultural phenomenon, where the documentation rustaceans are writing reads like in-line help or function reference, rather than as documentation. And even then, as _bad_ such in many cases. &gt; `set_timeout: "Sets the timeout" 
Oh I see. Copying `Foo` won't cause a double-free error here because you're storing the `Vec` in `x` as a _reference address_. Now when we make a copy `let b = a;`, but since both `a` and `b` are on the stack and both of them don't own the `Vec`, there's no heap memory to free when they go out of scope. Had the definition for `Foo` been `struct Foo { x: Vec&lt;u8&gt; }`, and if we were to try copying it, then Rust would have to make a copy of `Vec&lt;u8&gt;`. But `Vec&lt;u8&gt;` is on the heap, so doing so would make a deep copy of `Foo`. We don't want Rust making implicit deep copies for us, so the other option is a shallow copy. A shallow copy would involve copying the pointer on the stack that points to the `Vec&lt;u8&gt;` on the heap. However, doing so creates two pointers to the same heap memory, which would cause a double-free error down the line when both `Foo`s go out of scope. So, both shallow and deep copies are off the table. That means `struct Foo { x: Vec&lt;u8&gt; }` cannot be copied in terms of Rust's copy-semantics. The alternative now is to offer an explicit opt-in deep copy mechanic (called `Clone`) for structs that cannot be copied. That's a lot, but I think I got it right. The only confusing part now is who owns the `Vec&lt;u8&gt;` in your example. I'd say it's the `vec` variable, but what if we declared the vector inline with the declaration of `a`: ``` let a = Foo { x: &amp;vec![1, 2, 3] }; ``` Here `a.x` only has a reference address, but it doesn't own it.
&gt; For example you probably shouldn't parse millions of "y" and "n" fields to individual Strings, but you can do that in Python because single-character strings have a special optimization. Generalized parsing of CSV to a very generic in-memory representation is likely to be both difficult to implement and kinda slow as it runs. Small FYI: the csv crate's `StringRecord` type uses one allocation to represent all of the data in a single record, but exposes an API that makes individual field access convenient. :-)
If you have any idea how to sidestep rebuilding `rustc` every time, I'd be most happy. I run `~/x.py test --stage 0 --incremental src/libcore`, and I'd appreciate if it only rebuild `libcore` and its tests, but unfortunately it rebuilds everything and that takes a good hour (when it succeeds in building, it sometimes fails after ~40 min for no reason I could discern). And hopefully someone will be able to help with the codegen failure, because the nightly compiler on the playground generates the expected code, but apparently stage2 didn't (hopefully my commit doesn't affect LLVM...).
I’m writing a music player, and I want the format string to be configured by the user, which means it has to be done at runtime. I agree that if everything is known at compile time you should probably just use termion directly. 
Scripting languages, i guess :D i'll send PR, thanks! 
Basically, async/await is syntax sugar to make writing a sync stuff easier. So it may make your eventual code more concise but you can still do what you need to do today, it’s just not as nice to write.
Semantically, move and Copy both copy the exact bits of the thing, the difference is if you’re allowed to use the old one after. Not being able to observe the old value makes eliding those extra copies easier in the move case.
`vec` is the owner in the example. 
Things don't need to be async for most people's use. For larger workloads asyncs benefits are real. If your workload is not CPU heavy, spawning threads for every connection will limit you to a much smaller number of connections than not doing that. It will also make it trivially easy to ddos you. Where sync becomes unviable will vary depending on your specific use case ( what work is server doing, how powerful is server, what r bottlenecks, ect ).
Good question, who owns `Test{ s: 0 }` in this code? It is only dropped at the very end, after "done" is printed: #[derive(Debug)] struct Test{ s: u64 } impl Drop for Test { fn drop(&amp;mut self) { println!("Drop: {}", self.s); } } #[derive(Copy, Clone)] struct Foo&lt;'a&gt; { x: &amp;'a Test, } fn main() { let a = Foo { x: &amp;Test{ s: 0 }}; let b = a; println!("{:?}", a.x); drop(a); println!("{:?}", b.x); drop(b); println!("done"); } See https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8ed71dc77ec497099226802a4829b9ac
Amazing explanation. Thank you.
Well, I don't.
Now your bleeeedin
I also think this fits to /r/playrust better. This subreddit is about the Rust programming language. I have removed your post.
This is kinda explained here: [https://doc.rust-lang.org/beta/error-index.html#E0716](https://doc.rust-lang.org/beta/error-index.html#E0716) A temporary variable is created and lives until the end of the block. However a small change to the code raises the hackles of the compiler: #[derive(Debug)] struct Test{ s: u64 } impl Drop for Test { fn drop(&amp;mut self) { println!("Drop: {}", self.s); } } #[derive(Copy, Clone)] struct Foo&lt;'a&gt; { x: &amp;'a Test, } fn main() { let a: Foo; a = Foo { x: &amp;Test{ s: 0 }}; let b = a; println!("{:?}", a.x); drop(a); println!("{:?}", b.x); drop(b); println!("done"); } By first declaring `a`, then assigning on the next line, it fails to compile.
/r/playrust /r/rust is for the Rust programming language. No audience here.
Why are people so lazy that they can’t even check it’s the correct sub before posting 🙄
With structopt if you make the type a `thing` instead of a `Vec&lt;thing&gt;` it will only be allowed to take a single value. There's no real way -- even conceptually -- to allow multiple things to a single opt and multiple things to the final args list. You could create a `struct CsvArg(Vec&lt;thing&gt;)` and implement FromStr for CsvArg to allow a single argument on the cli come out as a Vec in code.
Ah okay, that makes sense. Thanks.
You need, at minimum, a screenshot. Ideally, also a features list. I don't use ncdu and Flielight because they're the most performant on the initial scan. I use them because of how cleverly they combine interactive browsing, caching, partial re-scanning, and in-tool deletion support to allow me accomplish my high-level goals efficiently.
Cool, but I think C and C++ spots indicate that Github isn't an accurate measurement of real world popularity. Hell I doubt most C programmers even know what Github is from working with them in defense contracting. &amp;#x200B;
Wow! Passing swift too! Amazing.
I'm about 8 chapters deep in "The Rust Programming Language" and I like it. &amp;#x200B; \- Coming from a Pythonista.
This is amazing! Awesome job! Hope to contribute and use on my research some day :) 
Same, on both counts
Ok, so I'm looking into PS, it's nice and all, but I've run into the problem that it doesn't supports fonts very well. At least on my machine ghostscript will only load about half of the fonts on my machine through fontconfig and the rest is just ignored (no error). A bit of a bummer. I wonder if the ghostscript library could be used in a standalone manner and fed fonts from my program. 
Would that let me accept multiple copies of the `-I` flag though?
&gt; to allow multiple things to a single opt and multiple things to the final args list. I'm trying to allow multiple copies of the -I arg, each of which accepts a single value, as well as multiple final args; this should be possible?
I think it could be a feature called "match ergonomics" in action. Match ergonomics allows you to write: let option: &amp;Option&lt;String&gt; = ...; match option { Some(s) =&gt; {} None =&gt; {} } instead of match option { &amp;Some(ref s) =&gt; {} &amp;None =&gt; {} } or match *option { Some(ref s) =&gt; {} None =&gt; {} } Basically, it strips away layers of `&amp;` so you don't have to juggle with `*` and `&amp;` and automatically `ref`s the payload of enums. Match ergonomics occurs not only inside `match`, but everywhere Rust allows for pattern matching – `let` bindings, `for` loop variables, function arguments and the `match` itself. Assignment on the other hand does not allow pattern matching, it's a simple move of value from one place to another. So in example, when you're doing () = st; Rust errors about type mismatch in the assignment (without even bothering to check whether `()` expression makes sense to assign to). On the other hand, the `()` inside let () = st; is not an *expression*, but a *pattern*. So match ergonomics kicks in, and as a first step, tries to help you by stripping all the layers of `&amp;` and only then it realizes it was a bad idea in the first place. I think the error message here could be clearer on what happens, so feel free to file an issue about that! 
If you're willing the use a tiny bit of unsafe code the easiest way to do this is to simply pass the child process the file descriptor for your main processes stderr. You can do this my calling `command.stdout(Stdio::from_raw_fd(io::stderr::as_raw_fd()))` This way the child process will write directly into the parent stderr. Hope that helps. Also I think your copying stdout into stdout. 
My fault bro
&gt; `command.stdout(Stdio::from_raw_fd(io::stderr::as_raw_fd()))` This doesn't work, I've already tried. It closes (as far as I understand) stderr of this process, so all errors printed after the command finishes are disappearing.
Yoh could say you are "rust deep". 
&gt;You need, at minimum, a screenshot. Ideally, also a features list. ```$ ds 🔧 Analysing dir: "/Users/ehiggs/src/jdk11" 100.00% [4.01 GB] =&gt; "jdk11" ---56.23% [2.26 GB] =&gt; "build" ---28.47% [1.14 GB] =&gt; ".hg" ---8.45% [338.75 MB] =&gt; "src" ---6.09% [244.05 MB] =&gt; "test" ``` There don't appear to be more features.
According to docs ([https://docs.rs/clap/2.32.0/clap/struct.Arg.html#method.multiple](https://docs.rs/clap/2.32.0/clap/struct.Arg.html#method.multiple)): &amp;#x200B; "Pro Tip:It's possible to define an option which allows multiple occurrences, but only one value per occurrence. To do this use Arg::number\_of\_values(1) in coordination with Arg::multiple(true)."
I’m only on mobile, but I think `child.stderr.take.unwrap()` because that doesn’t borrow `child.stderr` but rather moves it out.
Oh, didn't see that (only been using it through structopt); thanks!
Your approach is close to working. Try `child.stderr.take().unwrap()`. That replaces the field on the child object with a None, which is what you want. Calling unwrap on the field directly will try to move it out without replacing it with anything, and the compiler will be upset about that. That said, if you want to get rid of the copy loop in your parent process and have the child write directly to parent's stderr, you can use the `os_pipe` crate. Get a copy of the parent's stderr pipe with `os_pipe::dup_stderr()` and pass that to `std::process::Command::stdout()`. Alternatively, the higher level `duct` crate has an `Expression::stdout_to_stderr` method that does a similar thing a little bit more conveniently.
`io::copy` doesn't work because it takes arguments by value, not by reference
Thanks! I'll try this tommorow
That's nice. I wish it was a bit easier to navigate or perhaps a bit interactive. Like Go has it's "Try go" or something like that, where you do little exercises which allow to understand how different features of the language works. I think it's much needed in Rust, given that it's not as straight forward language. And has a lot of complexity to it. I found easy to start with Go and even building things on the first day, but with Rust. Doc's and references just doesn't strike home all that well. (trying to get grips for Rust for WebAssembly). Perhaps we could so something like Go did? I found you're "slides" quite informative. If we could embed Rust editors on the other side and make it step by step tutorial it could really benefit any new comers. 
Maybe the right approach is to write an MIR to gnu C converter. This would let rust target LLVM or GCC supported architectures. https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md Item #6 of the above suggests that. I guess, I will stare at the source to see how hard this might be. I will learn something about the MIR. If nothing else.
This is a little confusing, but `io::copy` doesn't require its arguments by value. Passing &amp;mut references to them will work just fine. The reason this works is that both Read and Write have blanket impls on them that say for any T that's Read/Write, &amp;mut T is also Read/Write.
You could make this approach work if you mem::forget the Command object to prevent it from closing the pipe you gave it, but that's dirty and will probably leak other resources. The approaches I mentioned in another comment avoid this by properly dup'ing the stderr file handle.
`format!("{foo}", foo="foo_value);` is the more common convention for this (which slog also supports)
[PR #57366](https://github.com/rust-lang/rust/pull/57366) implements the output suggested in [the ticket](https://github.com/rust-lang/rust/issues/57279) and should be coming to nightly shortly :) [For the following](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=7353fd12938bb6b730a8ee0f4303a77a) ``` fn main() { let a: usize = 3; let b: usize = 3; let temp: usize = match a + b { Ok(num) =&gt; num, Err(_) =&gt; 0, }; } ``` the output will be ``` error[E0308]: mismatched types --&gt; src/main.rs:5:9 | 4 | let temp: usize = match a + b { | ----- this expression has type `usize` 5 | Ok(num) =&gt; num, | ^^^^^^^ expected usize, found enum `std::result::Result` | = note: expected type `usize` found type `std::result::Result&lt;_, _&gt;` error[E0308]: mismatched types --&gt; src/main.rs:6:9 | 4 | let temp: usize = match a + b { | ----- this expression has type `usize` 5 | Ok(num) =&gt; num, 6 | Err(_) =&gt; 0, | ^^^^^^ expected usize, found enum `std::result::Result` | = note: expected type `usize` found type `std::result::Result&lt;_, _&gt;` ```
It's all my rubbish crates.
Are you completely matching the interface of wc? Is the binary dramatically larger than normal wc? If the answers are yes and no, why not try to just replace wc for distributions that ship rust?
Not the tidiest thing I've ever written, and doesn't *quite* agree with BSD `wc` on what a "word" is, but it's, er, fast. That's what counts, right? The different code paths made for some irritating logic duplication, both in selecting which function to use and in those functions themselves. More work will be needed to make it support more than UTF-8. I dare say proper locale support won't help performance much, but for now it's a good 2-7x faster depending on the input and what you're counting.
... and if the rust devroom is full, I will present [tantivy](https://github.com/tantivy-search/tantivy) in the [search devroom](https://fosdem.org/2019/schedule/track/search/) on Sunday as well. (12:30 - 13:20)
yup not right now but I will definitely work on this. I was looking more for code review (even if there isn’t much of it) as I am kind of new to rust.
Probably - that's why I'm here anyways :)
No, and yes. 792200 cw 97288 gwc 23656 wc 913144 total All three stripped, cw build on nightly so lacking jemalloc. Most of it is structopt and friends, I expect. The interface isn't exact, some of the flags are mutually exclusive and toggle each other each time they're specified and I don't think structopt supports such things. There's also some minor disagreement as to what a "word" is. There's also the locale to consider - it's utterly insensitive to `LANG`.
Man, I really need an excuse to actually learn this language.
Which makes it the first non-C system language! 
I admit I've had to put things in /usr/local/lib/ghostscript/fonts/ and create a file in /etc/ghostscript/fontmap.d/ (this is on Debian). I don't remember all the details of why unfortunately. The end result after running `update-gsfontmap` is that the font I want is listed in /var/lib/ghostscript/fonts/Fontmap, which seems to do the job. You can always embed fonts into your PS document, although I don't remember the details of how that is done. There is also a standard set of fonts which every PS implementation must provide. A quick search suggests there are 14 of them. Really all of this is just ghostscript configuration problems. PS is certainly capable of what you need if you find the right way.
This is good isn't it? So far besides Python and C# I haven't found any language that I've enjoyed learning as much as Rust. Tried to learn Go, but I couldn't do it, that language was just too weird.
I forgot I was supporting you on Patreon (I don't have many occasion to use Rust tbh). I was not disappointed by the progress over time. Worth every penny.
FWIW I had a similar bug in SDL2 and C and it's fixed when I compiled the latest SDL2 from source. Hopefully they'll release 2.0.10 soon.
Good question. That map was originally based on the meetup.com listings. I don't know who maintains it.
Does it properly handle filesystems like BTRFS? IIRC that doesn't work well with some of the usual tools for some reason.
Why are there many PRs for C?
I bet if you learn it, an excuse will present itself. 
generics
big open source projects are usually written in C
Same here. But I am really looking forward to this becoming available. This could put Rust on a footing with SPARK
I find go to be a bit wierd coming from some backgrounds. Ideally Go is a good first language. I do find rust much nicer however 
I'll give you one. Find a IRL problem and solve it
Lots of open source stuff stick to C. OpenSSL et al. And don't forget python C extensions. And oh, Linux maybe 
I ended up taking the afternoon and getting a \`-sys\` crate wrapper around SUNDIALS built ([https://crates.io/crates/sundials-sys](https://crates.io/crates/sundials-sys)). Keep in mind that this is just a thin wrapper around the C API (which is hideous, plus the FFI makes things even more hideous -- see the test in \`src/lib.rs\` to see what I mean). However, this crate will make writing an ergonomic API much easier -- what do you think an ODE solver API in Rust should look like? Should it just be a copy of Scipy's with minimal Rust sugar on top, or should it exploit macros for a DSL-like approach (closer to Julia)?
I didn't have an excuse and I was actually discouraged from learning it. Couldn't be happier that I did - I've learned a ton about programming in general since picking up Rust. I am a better programmer, even in other languages, because of Rust.
Try running [`cargo-bloat`](https://github.com/RazrFalcon/cargo-bloat) to find out what's taking up the space
Compiler optimizations can be very aggressive with these things. If a function call gets inlined, for example, it could be that both moves and references disappear entirely. In general I wouldn't worry about it unless you start benchmarking something and you actually measure a difference.
Nah. I've been in a programming rut for a while. I have been learning it on the side. But I have nothing to do that motivates me to use it.
The way pattern matching applies in Rust made me really appreciate Haskell's pattern matching and type system.
This is why we need garbage collection /s
Depressing that this has more likes than anything serious I've wrote 😭🤣
 Hmmm. A programing rut in general might be hard to fix. I usually find doing something really visual gets me excited about programming again. The SDL2 crate is wonderful for that. But idk. 
Some of the other mentioned crates are probably better choices (and hopefully more portable), but this works: command.stdout(unsafe { Stdio::from_raw_fd(libc::dup(2)) }); You could also use `std::os::unix::process::CommandExt` and dup2 stderr to stdout in the forked child: command.before_exec { unsafe { libc::dupd2(2, 1); } }
On the bright side, it was a very good joke
If you think about it, it's the most popular language in the world with an ownership system ;)
You mean Canadian Aboriginal characters?
try r/playrust as this is the rust programmer's sub.. 
No, it was never "transpiled" (or lowered to anything other than machine code). The written-in-OCaml bootstrap compiler [is available to browse](https://github.com/graydon/rust-prehistory/tree/master/src/boot/) and it directly emitted stripped-down i386-only (32bit) binary object files for 3 platforms. That said: back then Rust was much more OCaml-y. We did not start with traits / typeclasses; we started with modules (for a while: first-class, though quite badly broken due to my lack of knowhow). I was and am unapologetically more of an OCaml fan than a Haskell fan. This opinion is not made from a lack of information about either, and I am not especially interested in having a Haskell-vs-OCaml argument here. I don't even think of them as being especially different languages from a family-lineage perspective. But insofar as I think eager is a better default evaluation strategy than lazy, and modules are a better abstraction mechanism than typeclasses, I am more in the OCaml camp. Other folks later in Rust's development argued for (and eventually won) the typeclasses / traits thing, against my earlier preferences.
Yes. They were designed and implemented by Scheme macro-system hackers: Paul Stansifer, John Clements and Dave Herman. Rust's macro system also takes some influences from [Dylan's macro system](https://opendylan.org/books/dpg/macros.html) which I believe all of the aforementioned Scheme hackers were somewhat familiar with; it's essentially the canonical Lisp-like, well-designed macro system built for Algol-family syntaxes.
It didn't help Java
You can delete this post.
Nice! Thanks for the information; that makes a lot of sense. I can definitely see the upsides for typeclasses, first class modules, eager vs lazy, etc. There's lots of interesting design choices for sure. For what Rust wants to accomplish, however, I think it's made some fairly solid choices so far. I definitely love first class modules though :)
It's just checking file `len()`, which won't take actual used space into account (which even on boring filesystems can differ, e.g. sparse files): -% du -sh /usr/src 2.7G /usr/src -% du -Ash /usr/src 4.7G /usr/src -% ds /usr/src ... 100.00% [5 GB] =&gt; "src" If you're looking for the actual on-disk usage you want to check [how many blocks](https://doc.rust-lang.org/std/os/unix/fs/trait.MetadataExt.html#tymethod.blocks) are in use.
I don't think you can do it (after all you have to compile monomorphized function variants beforehand), but your closure can [accept](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=aa35295c1cbc5b1437377c244b2a9a9d) trait objects, which I think should do what you want.
MIR is unstable and will stay so for a long time.
You can start installing spacevim with the rust layer. https://youtu.be/TNnZKR5xJpA Spacevim works better with neovim ;)
C++ has an ownership system, sorta.
I was looking for a modern language, and when I looked at Go I was vastly disappointed by pretty much every decision they made.
I should have been clearer about what I wanted... I have a varible of type `M&lt;T, U&gt;` which I need to somehow pass to a closure via its arguments instead of letting it be captured from the current scope.
Side note: Rust doesn’t have *templates*; it has *generics*. This is more than just a difference in terminology; templates are expanded before type checking and are type checked at the use site, while generics are expanded after type checking and are type checked at the declaration site.
Can you show us some code examples which will demonstrate what you want to do? Otherwise it's hard to understand your problem.
Many big C projects aren't on GitHub, so I am still a little surprised at this number. 
I always look at languages that I don't know, try them out. I also always loved low level programming. When I met Rust, I was looking for newer languages to try out, I choose Rust, Go and Julia. With Go I got disappointed how few abstractions it had in their stdlib, I felt like programming in C with Garbage Colector. With Julia, I love it, very easy to use and beautiful syntax, and I'll certainly use it instead of Python for some fast scripting when it gets a little bit more mature. Ahhh, but Rust... It was love at first non-hello-world program. Sure, I did fight the borrow checker at first, but ignoring that, a easy to use language, beautiful writing, no garbage collection, good hints and suggestions from de compiler, zero-cost abstraction, system programming... all of that made me change C/C++/Java(ewww!!I hate java, I used caused I was forced to!!) for Rust. Everything new that I want to do, I do it in Rust.
I started programming with C and asm for MS DOS and FreeBSD over 30 years ago. I remember hacking at CircleMUD source code and learning how to handle multiple concurrent users with just one thread. I didn't even know the word thread back then. So when I started doing commercial work with Java, being grateful for how simple it is, I was still constantly feeling that it's slow and memory-inefficient. I just wrote my first web-app in Rust a couple days ago and it's almost as simple as in Java. It's mind-blowing what the Rust devs created. If nobody comes up with something significantly better, I'm convinced Rust will take over the world in every area, except minor stuff like admin scripts and prototyping.
Rust used to be comparatively batteries-included in various areas, but that strategy was deliberately dismantled because it *didn’t work*. Green threading is a good example of that. Expressed succinctly: Go can go batteries-included, because it’s a deliberately simple language and there is very commonly one and only one obvious way to do something. Rust can’t go batteries-included, because it’s a much more complex language and there are quite a few different ways that you *could* do something, and it takes some time and experimentation to determine what will work best. Go as a language and ecosystem can mature quickly, Rust will take a lot longer. Part of the effect of that is that certain units of work were neglected because they were perceived as less valuable in a rapidly-changing world. As time goes by, things settle down and the best options bubble to the top, and things like decent documentation become more expected. (OK, that ended up not quite so succinct.) Rust is at version 1.31.1, but it is not mature yet. Important pieces like async are still being worked out.
Ive edited mypost
Does it work if you just leave off the type declaration on the parameter? [This](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;code=use%20std%3A%3Afmt%3A%3ADisplay%3B%0A%0Afn%20do_a_thing%3CT%3A%20Display%3E(things%3A%20%26%5BT%5D\)%20%7B%0A%20%20%20%20let%20closure%20%3D%20%7Cx%7C%20for%20val%20in%20x%20%7B%20println!(%22%7B%7D%22%2C%20val\)%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20closure(things\)%3B%0A%7D%0A%0Afn%20main(\)%20%7B%0A%20%20%20%20do_a_thing(%26%5B1%2C%202%2C%203%5D\)%3B%0A%20%20%20%20do_a_thing(%26%5B%22hello%22%2C%20%22cruel%22%2C%20%22world%22%5D\)%3B%0A%7D) creates a closure that takes a parameter based on the enclosing function's generic type.
When I was starting to get into programming sometime around 2017, someone mentioned that I should learn Rust instead of C++ in a chat where I asked for resources to learn C++ (I was in the language hopping phase). 
My C code kept crashing.
If I understood you correctly, then you'll have to create a wrapper closure: `repetitive_op(a, b, || closure_body(captured_var))`, and `closure_body` can be generic as usual.
Install the Rust Language Server (rls) and the Languageserver plugin for neovim
You can do low level programming (like in bare metal low level) in a modern language. Now if that isn't a good enough excuse I don't know what is!
It's hard to focus on the benefits of Rust if you mostly use c bindings though 
To call myself a Rust novice would be generous, but I have done a few small programs in Rust, always with SO and the book close at hand. I like Rust because there is not GC, so no pauses in your program. Unfortunately compared to Go, the language spec is not yet stable enough for me to come back to Rust code from six months ago without having to rewrite it. It is also missing key libraries available in Python and C++, namely OpenCV. And while the bottom line performance great, it still takes me much longer to prototype a quick server or algorithm in Rust than Go or Python while I wrap my head around the ergonomics. I'm really hoping that I can use Rust to replace C for my embedded tinkering, but until I can use the stable version, I will keep waiting.
I believe the Julia folks have done this with, https://github.com/JuliaComputing/llvm-cbe 
C.
Student group projects would likely be part of this (and Java)
There is repl.it. https://repl.it/languages/rust It doesn't have packages like rust playground. But you can feed it stdin through the button in the top right of the terminal window. Directly left of the &lt;[x] clear button.
At work rewriting to rust a python application to rust which contains memory leaks. At home writing Skribe — an engine for applications with Taskwarrior and Evernote functionality. 
Sorry for the late answer. I will look at your crate later today. I've been thinking about separating the shared elements between different formats, so I can add Word de-/serialization as well. I will inform you if it's complete.
I can't work out how I can access the elements contained in a Vector within a struct. Read only access is fine, I only want the value so I can render it. Here is what I have: pub struct Colour { pub red: f64, pub green: f64, pub blue: f64, } pub struct Canvas { pub width: i32, pub height: i32, pub pixels: Vec&lt;Colour&gt; } impl Canvas { fn new(width: i32, height: i32) -&gt; Canvas { Canvas { width, height, pixels: vec![Colour { red: 0.0, green: 0.0, blue: 0.0 }; (width * height) as usize] } } fn pixel_at(self, x: i32, y: i32) -&gt; &amp;'static Colour { &amp;self.pixels[(x + self.width * y) as usize] } } #[cfg(test)] mod tests { use super::*; #[test] fn creating_a_canvas() { let c = Canvas::new(1, 2); assert_eq!(c.width, 1); assert_eq!(c.height, 2); } #[test] fn get_a_pixel() { let c = Canvas::new(1, 2); assert_eq!(c.pixel_at(0, 0), Colour { red: 0.0, green: 0.0, blue: 0.0 }) } } I'm stuck on how `pixel_at` should work if I just want get the Colour at a given (x, y) location in my Canvas, for the purposes of reading the r, g, b values to render a pixel to an image (eventually). I'm coming from years of GC languages (mainly Ruby), so I'm struggling a bit with borrowing and references. Thanks for any guidance.
Was looking for something to replace C++, which was my main language at the time. I might have tried D if it didn't look like just "C++-improved". I don't know how similar they are in reality, but the strong association to C++ makes it unappealing to me. Go was evaluated and dismissed in the blink of a second. Following the development of Rust, I found myself agreeing to just about every decision made; and whenever I saw something I disliked, I quickly learned that it was about to change for the better (Usually just stdlib API nits.)
Reading through Chapter 9 of "The Rust Programming Language". Pretty happy with my progress. Got the book on the 4th and I'm farther in than many programming books I've ever tried to read.
A combination of: 1. I enjoy playing with new languages. 2. I like lower-level coding, but don't like debugging memory safety issues (which I've done my fair share of in C and C++). The first couple of toy projects I did in Rust made it abundantly clear that I could still have the power and control of C/C++ without having to deal with memory safety issues nearly as often. As a side note: since I'm not especially interested in the web (or network facing things in general) from a software development standpoint, for me the really nice thing about Rust's memory safety guarantees isn't security so much as easy debug-ability. In my experience Rust is simply more pleasant to dev with, and I pull my hair out a lot less often. Fighting the borrow checker is nothing compared to tracking down heisenbugs.
http://intorust.com/
Tutorial style documentation, as always
Amazing work! I'm astonished by the rapid progress month-to-month.
There's also a talk entitled ["A microkernel written in Rust: Porting the UNIX-like Redox OS to Armv8"](https://fosdem.org/2019/schedule/event/microkernel_written_in_rust/) on Sunday from 11:10 - 11:55 in the [Microkernel devroom](https://fosdem.org/2019/schedule/track/microkernels_and_component_based_os/).
&gt; You can always embed fonts into your PS document Ah, allright, that would probably be enough. Thanks. &gt; Really all of this is just ghostscript configuration problems. Yes, but since ghostscript is sort of _the_ postscript implementation these days, it matters :) In any case, I've been reading its documentation and it seems what I want should be doable. 
Actually, this isn't what attracted me at all :D
I read the code and thought "where's all the code!?". It's very compact without being overly terse or using too many unnamed functions/blocks/etc. In that sense, it's very good. &gt; if num &gt; 0.0 &amp;&amp; num &lt; 100.0 { Surely &gt;= and &lt;=. 0 and 100 are valid percentages. This would be caught in tests. &gt;---56.23% [2.26 GB] =&gt; "build" This is a cute report format but it's not parsable by other programs. Why not use whitespace here?
but RLS works only for nightly, amirite?
&gt; Try `child.stderr.take().unwrap()` Yeah, this works exactly as I wanted! &gt; you can use the `os_pipe` crate This also works, and I've decided to stick with the `os_pipe` crate because it uses native syscalls which are probably faster than my ugly hack. &gt; Alternatively, the higher level `duct` crate This crate is too complicated for my problem, I'll use much simpler `os_pipe` instead. Thank you so much!
I would like to try and speed up a function using the SIMD iterators provided by the faster crate. The function I am looking at is the following: fn prepare_schedule(m: [u64;16]) -&gt; [u64;80] { let mut arr = [0u64;80]; arr[..16].clone_from_slice(&amp;m[..16]); for i in 16..80 { arr[i] = sigma1(arr[i-2]) .wrapping_add(arr[i-7]) .wrapping_add(sigma0(arr[i-15])) .wrapping_add(arr[i-16]) } arr } I can't wrap my head around rewriting this using iterators, as the next values of the computation are also a function of previous results, i.e. it's not a simple map operation. The borrow checker will obviously not allow me to do this, as it requires a mutable and immutable references to `arr` at the same time: fn prepare_schedule(m: [u64;16]) -&gt; [u64;80] { let mut arr = [0u64;80]; arr[..16].clone_from_slice(&amp;m[..16]); let v1 = arr[14..78].iter(); let v2 = arr[10..73].iter(); let v3 = arr[1..65].iter(); let v4 = arr[0..64].iter(); for (x, &amp;a, &amp;b, &amp;c, &amp;d) in izip!(arr.iter_mut(), v1, v2, v3, v4) { *x = sigma1(a).wrapping_add(b).wrapping_add(sigma0(c)).wrapping_add(d); } arr } &amp;#x200B; Is there any way to rewrite this using iterators so it can be possible sped up using SIMD? &amp;#x200B;
This. I think GO appeals to developers who has struggled with C or C++ and hated manual memory management and generics. It could also appeal to Script Kiddies who has a hard time dealing with more complex language constructs. For everyone else GO pretty much sucks. I would't want to hire a developer who thinks Generics is complicated or unnecessary.
can tell you, that i said fk it to my early learning phase for my semester to learn about rust. i really liked it, although I just learned the syntax intensively, because. well. college. but sooooon I'll programm some stuff! and I'm waiting for this day! (last exams passed for this semester) and I'm telling all my friends about rust. so it hopefully spreads furthermore!
&gt; Using mrustc, you can target ESP8266! Isn't that on a fairly outdated version of Rust though? 1.17 I think? If you want to use those embedded crates that might cause some problems?
Now this looks like I where be spending fair bit amount of time :)
I wish they would make the syntax a bit nicer though. Its such a great language but it looks ugly to write. 
I think what hurts swift a lot is that they didn’t supported windows in the time, I know that with swift 5 they will support it officially. Also think that most swift developers works on iOS mostly so they don’t open source so much, meanwhile rust has a lot of open source projects.
I’m pretty sure I’ve been running RLS with stable Rust for some time. Maybe since 1.26??
I tried advent of code on it. I was able to pick up the basics of the language thanks to writing simple programs - borrowing, modules, the collections, traits, testing etc. I would need a different challenge to go deeper though. 
I personally find Go appalling, but it's really a huge stretch to say that people who code in it are incompetent. There's a ton of great and reliable software written in Go. Lots of really smart people like that language.
Hey, I did a fix with comments here: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3b69f9957435f53019b3090952ff56ad If you have any questions let me know.
GO has low usage friction and a low barrier to entry. Those are important benefits.
A torrent client using futures, but cant find a good spmc channel that works with futures
See https://crates.io/policies and maybe try send an e-mail to help@crates.io. In my opinion this violates many points of Code of Conduct (https://www.rust-lang.org/policies/code-of-conduct), e.g. the last one: "Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome."
Dudes who manage [crates.io](https://crates.io) don't give a shit. Don't try to play their game, ignore [crates.io](https://crates.io). Do you know you can use [plain github](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories) instead? Imagine you invent a "creative" unoccupied name for your crate, publish it, and then you want to add a proc\_macro subcrate (it has to be a separate crate), but someone may have stole all \*-derive / \*-codegen / \*-whatever names for all published crates.
Isn't go rather a competitor to python than to rust ?
How ridiculous :-(
No and that's fine. But it is a good reason to learn rust instead of some other new language. Very few languages and no other modern ones is capable of targetting that domain. 
There's also some people "reserving" crate names for later use, which is even more perverse because they're otherwise active members of the community. In most cases it's legitimate like reserving compound names containing your own crate (e.g. tokio-$stuff) but some go way over the line, like registering [https://crates.io/crates/solar](https://crates.io/crates/solar) or [https://crates.io/crates/godzilla](https://crates.io/crates/godzilla) or even [https://crates.io/crates/response](https://crates.io/crates/response)... like, excuse me, you think it's okay to somehow just claim these arbitrary and otherwise perfectly usable names indefinitely if you're not going to use them within the next few weeks or months? Why not just run a script and claim every single dictionary word just to be on the safe side? Cmon, don't be a dick..
Wrong subreddit. You want /r/playrust. 
Need to write a web server in rust but i am not sure now its the best choice. I am waiting for libraries around orm, graphql, autofac like, automapper like to mature. I want to write the core funationality in rust but tooling are bit painful
sounds like crate squatting to me.
Linux won't accept PRs through GitHub
I wrote code for work in a high level language and did some databasing stuff, I decided that I need to learn a systems language to better understand computer science and also be able to have more granular control of the hardware. When I went to find one, the fact that Rust restricts users from writing bad code in many ways at compile time stood out to me, so I picked it.
Could his github account be hijacked or is he just stupid enough to use an old (albeit rather unused) github account?
Hello, I'm new to Rust. I need help understanding the following example. **I know I don't need mutability here, but I need to understand the move.** I know a for loop is syntactic sugar for an \*iter\*/loop/match block. I also know that if I take the container as reference, it is not moved inside the scope of the for loop. But in this example, when the reference is a parameter for the function, I don't understand why there is a move: fn main() { let mut v = vec![1, 3, 5, 7, 9]; println!("average: {}", get_average(&amp;mut v)); } fn get_average(v: &amp;mut Vec&lt;i32&gt;) -&gt; f32 { let mut sum = 0; for i in v { // why is v moved here? sum += *i; } sum as f32 / v.len() as f32 // error: can't borrow here } I get this error: error[E0382]: borrow of moved value: `v` --&gt; src\main.rs:11:18 | 8 | for i in v { | - value moved here ... 11 | sum as f32 / v.len() as f32 | ^ value borrowed here after move For other examples, without the mut, it works as expected: fn main() { let v = vec![1, 3, 5, 7, 9]; println!("average: {}", get_average(&amp;v)); } fn get_average(v: &amp;Vec&lt;i32&gt;) -&gt; f32 { let mut sum = 0; for i in v { // v is taken as reference, no move? sum += *i; } sum as f32 / v.len() as f32 // no error now } What is the difference? Why would the mutability change the move semantics? I know I'm missing something obvious.
How are you reasoning that it violates the code of conduct when crates.io policies explicitly allow squatting? They are clearly not violating the code of conduct..
I loved C++ and heard about Rust over and over again. When I finally looked into it, I realized it has so much fewer language design problems than C++. Most of the things that annoyed me in C++ aren't annoying in Rust, for example installing a library. 
What were you writing before Rust, BTW?
My Programming Journey led me from VBA for my first program over Java in school (for a long time my go-to language) to Scala, while some of my work required C on STM32 and PHP on the web. Then I found Python and that's about where I am now, except JS work has increased a lot recently. Where does Rust come in? - I really liked Scala for its abstractions and strict and expressive typing, but the compiler is/was just too slow; Rust is still better there. - I dislike C for its shoot-yourself-in-the-foot-ness, but if you're on a Microcontroller, there's not much choice. The other choice, though, is Rust. - Python is great, sometimes duck typing and its dynamicness is just what I want. At other times, I'd love for Python to be more statically typed (and I'd love better and easier control over what a module exports). Also, I miss pattern matching and lambdas that consist of more than a single expression - a limitation of indentation-based blocks. - JS has become usable since ES6, but I still dislike the monopoly it got on the web by accident. Rust is slowly becoming viable there, too.
By MC do you mean broadcast or pick-one?
For me it's almost the opposite. do you have specific dislikes?
How is it not "spamming, trolling, flaming, baiting or other attention-stealing behavior"?
This is outrageous. He want to sell those names. Look at the description "contact me if u want to use this name". Crate.io should change there policies and ban that bastard. 
There's the letter and the spirit of the CoC. Saying that there is a first-come-first-serve policy is not the same as "Go ahead and register as many names as you want without ever using them, we don't mind." I would be fine with a requirement that after six months of no meaningful activity or something, a user has to prove they're still intending to use the name.
Build URL shortener service with targeting, analytics, and more features unavailable in Bitly. I feel the love to Rust. On the daily job, we use Python/Golang but I try to promote Rust in our ecosystem. I hope we will use it soon for speech recognition and video conference service.
You can find the first DESIGN.md draft [in this issue](https://github.com/fizyk20/generic-array/issues/68)
This is awesome. Thanks so much for your help, especially the instructive comments!
Would you think other languages would be better for the web? For example, do you think Rust could do front comfortably? If so how? As I see it, I don't think most of the issues people have with javascript on frontend is javascript based at all. Sure some of it is. Like occassional wtf here and where. But the problem is actually dynamic, interactive, non blocking UI's. Don't want to kill the spirit, but whatever language you pick to do your frontend, it will be some sort of flavor of React in different syntax. I mean, we already have C# front end framework Blazor, and there is nothing new there. Although it has no spread operator, so good luck with props copy pasta. How do you think your common backend languages would be affected / changed to better suit front end environments. Would it be for the better to the language in question?
You can find the first DESIGN.md draft [in this issue](https://github.com/fizyk20/generic-array/issues/68) Also, what One Weird Trick are you referring to? That it serializes/deserializes to/from tuples, rather than sequences?
yes
That one time they removed a squatter (and impersonator) seems to be an exception rather than the rule. No idea if anything has changed since then. https://blog.rust-lang.org/2018/10/19/Update-on-crates.io-incident.html
In my opinion, this sort of behavior is violating the spirit of the CoC as in pbeling's comment and thus the crates should be removed and the account banned.
Yes, that's perfectly valid, and doesn't actually _detract_ from what I wrote above. They _chose_ to do that, but they _also_ chose to not set up a clear foundation of _this is what we expect you to build_ - How should documentation be formed, - how should Structs be named in public API - How do you expose top level functionality towards the bottom if you don't include it - etc. etc. I feel that today, for example the Python language documentation (main) Could easily be done and represented for Rust, even when the crates and features in there _aren't_ part of the core language but in the external release cadence. Hey, many features that are "core" are external just for that, to break down the dependency walls and simplify release cadence. That's cool. Even for some batteries included languages ( hi Python) the favourite way of doing something (http requests) doesn't come from the core language (http.client is painful...) but as an extra dependency. That's fine. The language still delivers in discoverability and documentation. Rust doesn't. 
[This is a well trodden issue](https://internals.rust-lang.org/t/crates-io-package-policies/1041). More links: https://users.rust-lang.org/t/should-people-be-allowed-to-reserve-crate-names/8360 https://users.rust-lang.org/t/just-found-somebody-uploading-meaningless-packages-to-occupy-some-crate-name/23951 [One user who has been squatting names](https://users.rust-lang.org/t/should-people-be-allowed-to-reserve-crate-names/8360/23) claims that it's a service to prevent typo squatting. Solutions have been proposed. For example: [federation](https://internals.rust-lang.org/t/wip-pre-rfc-federation/8730). This would help non free users of Rust who want their own private crates.io for their organization (i.e. business). Another proposal was to [use domains as namespaces](https://internals.rust-lang.org/t/pre-rfc-domains-as-namespaces/8688) akin to how Java packaging works (which works very well). [Another dicussion](https://internals.rust-lang.org/t/crates-io-squatting/8031). AFAICS, the Rust/Cargo team has a lot of history/influence from the Ruby and Javascript/NPM world and are keen to avoid problems that they've seen in those schemes. IIUC there was a problem in the Ruby community where Github published all repos as gems under people's names so `github.com/ehiggs/somegem` would be detected as a gem and then they would push it to a gem repository. Then the search on the repository made no sense because it wasn't possible to see who was the originator of a largely forked project. In contrast, Java has not had this issue whatsoever on Maven Central and related artifactory/nexus systems. The people with Java experience seems to be crying out to just use a Java influenced approach but it doesn't appear to convince a lot of influential people. Either because they don't understand the solution or it's not being expressed well or I just don't understand the objections. [The most recent discussion I saw on the topic his here](https://internals.rust-lang.org/t/crates-io-incident-2018-10-15/8568).
I'm an ultra noob to rust so my opinion may not matter but I'll leave it here anyway. This is scary and undermines confidence in crates to some degree. Granted that 3rd party crates should anyway be used with caution but nobody can thoroughly review the entire code of all third party modules/libs they use. As such, there needs to be reasonable confidence in the packages ecosystem otherwise things could get as bad as in npm. Don't get me wrong - npm is wonderful and is better than nothing. It's also scary because whenever I get a new dependency, I really don't know what vulnerability and malicious code it's coming with (intentionally or otherwise, via more deps). I have to depend on Github telling me which packages have security issues and that's only based on actual CVEs, not on heuristics (which means, I could be unintentionally introducing security holes in anything I build (browser, desktop, server based) using packages from npm imo, having the package manager be more dictatorial and less democratic in nature (in the context of package names) won't be such a bad thing. The key is to identify the big impact areas (like package name squatting, spamming, etc.) and lock those down based on some rules.
I _think_ this is right: in the non-mutable reference case ask yourself this: why -wasn't- `v` moved? `into_iter` takes `self` so a move has to have happened... it just happened on an implicit copy of the reference! mut references are _not_ Copy so the same code doesn't work. if you call `iter` on `v` yourself the mutable reference is deref'd into a slice and the slice is copied to into_iter so that works. I worked through this my looking at the MIR generated for different scenarios in [the playground](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=653ec549d5a97752f49e9d6ae5337f26) Can someone confirm my thoughts here?
We must however be carefull with pulling back crates. This is a leftshift-drama waiting to happen.
What exactly is ugly about rust's syntax?
After learning Java, SQL and Python and having some quite basic knowledge of C, JS, and PHP. I somewhat wanted to learn Haskell and the functional paradigm. At that time I hadn't enough time and I dropped Haskell. Months later I discovered some software written in Rust: 1. Bat : A cli tool 2. Redox: OS 3. Amethyst: Game Engine Then I remembered that I had an O'reilly book about Rust (thanks to a bundle of humble bundle) and just for curiosity started to learning it. Again I just read a few chapters and dropped it for the lack of time. But two weeks ago I had the time and go to the rust-lang web and read the book. &amp;#x200B; **Things that I like about Rust**: \-Performance, not garbage collector, zero cost abstractions, memory-safety guarantees. \-Type system stronger than the languages that I've mentioned: 1. Options in Rust &gt; null and options in Java 2. Result &gt; Exceptions in Java &gt; -1 in C 3. Inmutability by default vs mutability by default. \-The potency of pattern matching and destructuring. (Enums and Switch statements in others languages are a joke vs. enums and match expressions in Rust). \-Cargo is just easy and fantastic (dependency manegement in Python and C are horrible) . \-A compiler that points you where the error is, with descriptive information. \- In the future I will prefer Rust+WebAssembly instead of JS. \-The community. &amp;#x200B; **Things that I dislike**: \-I don't think that you can do 100% fearless concurrency. I still want to learn Haskell for this. \-The complexity. This is an trade-off that I assume, but it's still there (lifetimes in some contexts, and build my own macros are the harder parts for me). &amp;#x200B; &amp;#x200B; &amp;#x200B;
I remember getting excited about D in 2002 exactly because it was supposed to be 'C++-improved' and then learning that D had GC which made it less 'C++-improved' and more 'Java-improved'. I switched to Rust exactly because I find it 'C++-improved'.
Sorry if it’s obvious but what do you mean by struct composition?
Couldn’t a name be released back into the pool if no code as been uploaded after X time after registration? Easy to work around though I suppose...
Well [crates.io](https://crates.io) is not Godaddy. This is a bad use, that should be reported and evidences the necessity of a small moderation system.
I like Go and enjoy using it daily at work. Please don't post zealot comments like this here.
You're right of course, WASM does not change the architectural needs of UIs, and Rust is not the only option. Maybe not the best. But I do believe that WASM will bring competition to the field, and that Rust will be a part of that field.
The answer is no: at least not yet. It would certainly be a nice feature to have, and I would have had use for it on a couple of occasions. It would be equivalent to a generic implementation of the `Fn` traits for the anonymous closure type, eg: impl&lt;T&gt; Fn(T) for Anon { ... } (C++ *does* have this feature)
Then they would just submit some trash.
Probably. But it's _something_ at least.
I played the game Rust and when i google'd Rust I saw this as the second option. Can't say it's as easy as Python though. 
Maybe the squatter is moderating and doing the community a favor? I see people here jumping to conclusions about malicious or economic intent but this ought to be confirmed first. Don't assume the worst.
In your comment, you say you were surprised about it being faster. After looking at the code, my guess is that it's because you're using parallelism. One would think this would make it faster in the case where your entire directory's metadata is cached. In the case where it's not cache, one might be surprised that it would be faster because one might think that it's just going to be blocked on I/O waiting to read metadata from disk. One possible reason why parallelism helps here---from what I understand---is because the flood of simultaneous I/O requests allows the operating system to more efficiently schedule reads. There have been a few posts on this subreddit in the past that did some experiments to show this, but I don't have links handy. The primary downside, at least how you've written it, is that you're going to use more memory than competing programs. Additionally, your tool will likely explode with a stack overflow on deeply nested directories because of your use of recursion. However, in practice, I don't know how deep you need to go to blow the stack. I don't know the internals of other disk usage utilities, but they probably don't make the same trade offs as your tools. Those should be considered in a performance evaluation so that users can make educated decisions about which tool to use.
Maybe it would be smart to implement a similar naming scheme as docker hub, everybody can publish under username/crate and popular crates can apply for a toplevel crate without the name prefix 
I was writing C++ code, a few years after C++11 came out. I thought move semantics and things like \`unique\_ptr\` were the best thing ever: no more unnecessary copies, and no need to remember to write \`delete\` anywhere again! Except after a while I noticed that every time I used \`std::move()\` to move a value, I had to remember not to use or move it again. The problem of accidental double-deletes and use-after-free got replaced by accidental use-after-move. And use-after-move bit me in the ass way more often than use-after-free and others, especially when using RAII and similar patterns. So I looked for solutions \*within\* C++. How can I prevent this use-after-move issue? The answer unfortunately was: you can't. The C++ type system doesn't understand what a "moved" value is. But fortunately, somebody suggested that this other programming language - Rust - does understand it. So I checked it out. And I'm still using Rust today. My own wish for #rust2019 follows from this. Don't focus so much on the minor ergonomics. Macros can help if necessary. Instead, make the type system more powerful: generic associated types, const generics, etc etc. Because if something is unergonomic, that's annoying, but if something is \*impossible\*, that can be a deal-breaker.
I'd never seen anything like the borrow checker before, and I wanted to see what it was like to program with it.
Explanation to the curious: Big open source projects are usually quite old. And back when they were started, C was THE go to language for a new software project. I wonder what the "C to Rust" ratio of big open source projects will be in 10-20 years.
Semicolon is evil. I get nothing but trouble with it. Modules are hard to understand. Then there's a problem with type aliases I think. But it could be just IDEA. I press Go To on Handlebars and it brings me to Registry. I'm like huh? It must be an alias. I try to find where that alias is defined and fail. It's just confusing. Otherwise all looks good, at least with my little Rust experience.
You mean “plain git”.
It sounds like you want FRP -- there's a few frp crates out there (as a matter of fact, I've recently published a [crate](https://github.com/aldanor/reactive-rs/#usage-example) that does just that - streams, broadcasts, filtering, mapping, other basic rx stuff).
I don't understand not using the Java method. It basically just turns the identifying type from (name, version) to (group, name, version). That's all it takes. You can take whatever name you want, as long as it is in your group.
I just noticed some files, like "Docker.raw" take up a different amount of space depending if you check through the "size" column or using "get info", on macOS. This is apparently caused by it being compressed space. Would using blocks fix this? Otherwise it seems to report size more accurately than other tools when comparing with my mac's info tool.
I'm really happy that this sentiment is seemingly widely held troughout the rust community, at least in most of the rust 2019 blog posts i've read. [Steve Klabnik's rust 2019 blog post](https://words.steveklabnik.com/thoughts-on-rust-in-2019) is another example. It is important for a language that's looking to compete with C and C++, to keep in mind that it will be used for at least as long as C has, and will be used. The sentiment that we should be very careful with adding new features is essential when trying to avoid becoming another C++. &gt; many requested changes are almost purely syntactic in nature, while some others are seeking to reduce boilerplate. Can someone provide some examples here, so I can get a better sense of what kind of syntactic changes or boilerplate reductions decrease the explainability of the language?
Is there a simpler way to skip invalid items when deserializing (json) to a HashMap? #[macro_use] extern crate serde_derive; use std::collections::HashMap; use serde::Deserialize; #[derive(Deserialize, Debug)] struct Item { id : String, name : String, } fn main() { let json_str = r#"{"valid_1" : {"id":"b", "name":"c"}, "invalid" : {"id":3.14}, "valid_2" : {"id":"d", "name":"e"}}"#; let json_value : serde_json::Value = serde_json::from_str(json_str).unwrap(); let items : HashMap&lt;String, Item&gt; = json_value.as_object().unwrap().iter().filter_map(|(key, value)| { match Item::deserialize(value) { Ok(a) =&gt; Some((key.clone(), a)), _ =&gt; { None } } }).collect(); println!("{:?}", items); }
Maybe one solution for crates.io without changing policy too much is to check a user's current crates and limit them to only 5 empty crates unless they're of a format of `existingcrate-subcrate` That way people can go nuts reserving crates that belong under an umbrella crate but can't abuse the system like this
I'm just a student, so position might ~~nullify this excuse i had~~ `fn reply(message: Excuse) -&gt; Option&lt;Motivation { None }` so YMMV. I love C. It's what I started with. It's the thinking that I like, and my experience with highter levels was that of "respect, but abstracting away the things that make it fun and interesting". Part of what I liked, and in some ways still do like, about C, is the responsibility for thinking about internal workings is hardcore. synchro, mem management, etc. It's fun because it treats you like an adult. When that programs runs without any signs of mem-leaks or other concurracy/mem issues, you have accomplished something seriously cool. What I Love about rust, is that it doesn't take away that responsibility, but rather provide you with a negative feedback loop that does 2 directly related things things: 1. Stops you in your tracks when you are making a mistake, which leads to... 2. Teaches you habits and techniques to approach memory management extremely well. This has taught me a lot about how to think about memory and performance in all languages. It has my thinking defaulting to things like "is this the only place in the code this variable is mutable? Does anyone still own this pointer?" etc. Runtime languages like Java and C# hold my hand too much for comfort. Recently saw a project group bemoan how slow their game was, because they didn't realize until it was too late that their code was doing expensive stuff like re-construct almost everything from just about scratch every render loop. Sure, optimizations happen behind the scene, but that tech has its limits. I'm also starting to get my mind around its approach to solving the problems that more OO languages solve with OO design patterns. ("Favor composition over inheritance" is wasted breath when composition is not only the only option, but more intuitive). I really like the prospect of doing away with classes ([ctrl-f Gosling, read the paragraph](https://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html)) as a way to help me expand my thinking. So here's my excuse: It makes you a better programmer. It exposes you to better ways to engineer a software system. These benefits apply to all code you write, not just rust.
If its empty its not an issue
[I brought this exact user up before](https://www.reddit.com/r/rust/comments/9aaanw). Crates team didn't do piss all about it, it's an awful policy and really should be changed.
I came because of the hype in /r/programming. I stayed because of sum types. I can't write code anymore without sum types. That and Cargo.
Thank you for your feedback. I will implement a command line argument `--max-cache-size`, which will determine the cache size. Your idea sounds great, to use the cache as a fallback if the server does not respond. Maybe in the next version :).
Please provide a complete program that reproduces your compiler error. Otherwise, it can be challenging to help. For example, `customer_accounts` does not seem to be defined anywhere in your code snippet, so it's pretty much impossible to see what you're doing wrong.
There isn't one yet. Customer_accounts is only a struct it doesn't do anything special. 
Part of the reason that I really like rust is its community. That includes the amazing crates ecosystem. If shit like this is allowed to happen,will we start getting crates to [check if a number is odd?](https://www.reddit.com/r/programming/comments/886zji/why_has_there_been_nearly_3_million_installs_of/), a crate to get a char from the [alphabets syntax?](https://github.com/jonschlinkert/alphabet) or will there be a (cargo drinking game)[https://npmdr.ink/]? We can't let shit like this happen.
OK, but that's beside the point. Please consider supplying some code that others can pass through the compiler that reproduces your problem.
\&gt; leftshift-drama I think you mean left-pad.
thanks! maybe I was doing something wrong. It's just I've downloaded Eclipse for Rust, and I've got only stable compiler on my system, so Eclipse failed to compile RLS. maybe that's Eclipse's fault, not compiler's one.
&gt; Semicolon is evil. I get nothing but trouble with it. I've never had problems with semicolons in Rust. It's crucial to know that statements are terminated with a semicolon, whilst expressions are not. Is that the grief they give you? &gt; Then there's a problem with type aliases I think. But it could be just IDEA. I press Go To on Handlebars and it brings me to Registry. I'm like huh? It must be an alias. I try to find where that alias is defined and fail. It's just confusing. Handlebars is a crate I assume? Goto definition on a crate brings you to the registry because IntelliJ tries to show you where the crate is coming from (I guess). You probably expected to be taken to the lib.rs of Handlebars' source code, which would indeed be more useful. This is on IntelliJ's side, so a tooling problem.
&gt;it just happened on an implicit copy of the reference! mut references are *not* `Copy` so the same code doesn't work. Which implementation of `Copy` are you referring to here? I'm no really sure what you mean by "implicit copy of the reference".
The way I see it, you need to pass \`self\` as a mutable if you want customer\_accounts to insert. Modify your function definition like so and tell us if it works : fn create(&amp;mut self, account: NewCustomerAccount) -&gt; Result&lt;CustomerAccount, String&gt; {
There’s precedent in Python for doing the reverse https://docs.python.org/3/library/subprocess.html#subprocess.STDOUT , but curiously not for doing this. I think we should add both to the standard library. Do you want to file a feature request issue?
Yup, that's basically [how du works](https://github.com/freebsd/freebsd/blob/2a52bc55467e95f92e1024cd558df3930df99594/usr.bin/du/du.c#L321-L323); use st_size by default, if `-A` is specified use st_blocks.
But there is obviously more to the code than what you’ve posted. We don’t know how you have defined your struct (or any other code that isn’t posted) so we can’t really help. 
And [GNU Radio with a Rusty FPGA](https://fosdem.org/2019/schedule/event/sdr_rusty/) about building a GNU Radio decoding block in FPGA with bindings written in Rust; in the Free Software Radio devroom. Unfortunately, 9:30 AM on Sunday sounds more like sleeping than listening to a hardware/Rust talk to me…
&gt; I'm not sure what that means. Exactly what it says: your method takes `self` by immutable reference (`&amp;self`), `.insert` modifies its subject and thus requires a mutable reference. You can't get a mutable reference to a member if you only have an immutable reference to the parent, so your method must take an `&amp;mut self` if it wants to alter `self` or one of its members. &gt; Additionally, is there some way of using a closure within a result? I would prefer not having to define before the Ok and instead just stick it in there. Well the closure seems completely unnecessary so yes? Why not just write self.customer_accounts.insert(new_account.id, new_account); Ok(new_account) ?
To be fair, while my first reaction was laughing about how absurd the is-odd module is, JS is full of evil gotchas. For example this one: ```javascript &gt; 9007199254740993 % 2 === 0 true ``` Using a module like is-odd [checks for this issue](https://github.com/jonschlinkert/is-odd/blob/a80ee0d831a8ee69f1fad5b4673491847975eb26/index.js#L20).
Some one did run a script and registered all short dictionary words. There was a lot of drama when it happened
As a D user, the irony is that D is still trying to cater mostly to the C++ folks. The loudest folks in the community came from C++ and they are trying to reinvent C++ in D, with template magic and everything. I still like D, but I wish it went more in the direction of "Java-improved" rather than "true-C++-hasn't-been-tried-yet" it's doing right now.
I guess that's because of the backward compatibility.
Maybe this recurring problem can be solved like this: normally no action is taken by the team, but 1) if you can't contact the squatter, or 2) if it asks for money to release the name, then you contact the relevant team and they force the release (or even ban the user) after checking that 1) it's really a case of squatting and 2) whether it's malicious (ransom squatting) or not.
Arguably Rust is a competitor to python in some domains...
I like this.
I think they just mean having one struct that has another struct as a property (and perhaps accepts it as an argument in it's constructor).
Here's my suggestion for a policy: https://docs.readthedocs.io/en/latest/abandoned-projects.html (see discussion at https://github.com/rtfd/readthedocs.org/pull/3343).
Did you actually send a message to help@crates.io or was it just this reddit post? While it may seem like this sub-Reddit is an official communication stream for the Rust community it is not actually one. 
My primary background is programming Java which I was also using for a hobby gamedev project. I was feeling overly confined by the everything-is-an-object paradigm. I was also concerned about how abstraction always seemed to carry a performance penalty (although in truth, I don't think I ever ran into any *actual* performance issues). C/C++ seemed too intimidating and I noticed Rust being talked about on Reddit and HackerNews. I liked the "zero cost abstractions" mantra, and thought the whole borrow checker thing was something interesting to learn.
I was actually thinking of detecting if the output was to a terminal or as the input to another program, and in the latter case, return json instead. And yeah for some reason I thought I couldn't test for equality with floats.. thanks for that!
lovely thanks! There doesn't seem to be the equivalent in windows so I figure len() will return the correct size there?
Which still is the wrong package :D `left-pad` was about yanking a package popular package. `event-stream` was about a introduced backdoor into a popular package after maintainership was handed over to a malicious actor.
Here's a suggested Ok-coercion syntax mentioned by newpavlov on internals: try fn foo() -&gt; Result&lt;(), MyError&gt; { if flag() { throw MyError } // no need for Ok(()) } try fn bar() -&gt; Result&lt;u32, MyError&gt; { foo()?; 1 } Now this feels rather attractive (although the `try` feels like a redundant syntactical tic; the `Result` is the key part of this signature). Coding in Rust means typing a lot of `Ok(())` every day. But, it is a coercion, and there are very few of these in Rust. The most popular one is Deref-coercion and is both convenient and confusing, since it creates the expectation that it happens in other concepts; it fudges the important idea that `&amp;str` and `&amp;String` are very distinct types. I was attracted to the _explicitness_ of Rust (coming from the implicit minefield of C++) and I can see that the cumulative effect of adding more coercions will be to add more cognitive load for people learning the language. So it's not really about "that's a cute convenience"; it's about the effect of having too many conveniences. And if this sucks energy away from the important task of stablization then that's a problem.
This would be useful. Something like Stdio::stdout() and Stdio::stderr(). Though we'd need to decide what would happen if you passed one of those to Command::stdin. (It's possible in rare circumstances that stdout might be a readable descriptor, and we might want to allow it? But in most cases it's probably a mistake, and it would be nice to have a clear and consistent error if someone makes that mistake.)
I like this idea because it would be a way to do this backwards compatibly
Thanks for the reply! 1) I guess I was surprised because I assumed the common tools would have a parallel implementation. 2) Regarding memory, I am wondering why I would use more memory? I use more stacks because of the threadpool, but stacks are generally just a few MBs right? And most of my memory comes from the tree that I build on the heap, which would be identical whether i use parallelism, recursion, etc... Is there something i'm missing here? 3) As for the risk of blowing the call stack, what would you intuitively recommend? - Falling back to iteration above a certain depth - Using my own "stack" using a a Vec with push() and pop() above a certain depth. - Dropping it because this design is doomed from the start. 
In order for it to be compared correctly, it needs to perform the very same tasks, with the very same output format as the tool it's being compared to such as "du -cab /home/userblah/". Ideally if it were a drop-in replacement for du, with the very same cli switches and documentation but faster that would be very useful. 
Looks like you want [GetCompressedFileSizeW](https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-getcompressedfilesizew), which you can [access via the kernel32 crate](https://retep998.github.io/doc/kernel32/fn.GetCompressedFileSizeW.html).
I don't know, I guess I thought you had to have the whole statement within the Ok. I'm not sure I understand how results work yet, I understand they're similar to exceptions. 
Probably, no. I'll have to go through the whole RFC process and this functionality can be currently achieved using crates like `os_pipe`.
The latter does indeed seem like an IDEA problem rather than the language ;) I agree that having an optional semicolon would be nice, though.
About what I expected: File .text Size Name 10.0% 56.5% 308.7KiB clap 5.9% 33.1% 180.6KiB std 1.2% 6.6% 36.1KiB [Unknown] 0.4% 2.1% 11.6KiB cw 0.1% 0.6% 3.4KiB ansi_term 0.1% 0.4% 2.2KiB strsim 0.1% 0.3% 1.8KiB textwrap 0.0% 0.2% 1.0KiB bytecount 0.0% 0.1% 655B heck 0.0% 0.0% 31B atty 17.7% 100.0% 546.2KiB .text section size, the file size is 3.0MiB
This doesn't go well when projects move from one group to another. Ownership changes, and when you embed the owner in what is intended to be a fixed, immutable identifier, it makes it hard for the ecosystem to accommodate that change.
Backwards compatibility is easy. The “legacy” crates can have an empty group name. Java basically did the same thing. Java wasn’t always the reverse of the domain, there are lots of packages grandfathered into maven central that have a simple single name. 
The crates.io team specifically wants to allow crate squatting.
`Result` is just an enum: enum Result&lt;T, E&gt; { Ok(T), Err(E) } that's quite literally all there is to it. So you call `Ok` with a value to create a "success result", and you call `Err` with a value to create a "failure result". Then there's a bunch of convenience methods &amp; syntactic sugar added (as well as the `#[must_use]` attribute), but at its core that's it, it's just a very small sum type which can store *either* a success or a failure. &gt; I understand they're similar to exceptions. The bit inside the `Err` is probably more similar to exceptions, `Result` is the reification of… a result really. That can be a success (returning a value in an exceptions-based language) or a failure (a raised exception).
&gt; Regarding memory, I am wondering why I would use more memory? I use more stacks because of the threadpool, but stacks are generally just a few MBs right? And most of my memory comes from the tree that I build on the heap, which would be identical whether i use parallelism, recursion, etc... Is there something i'm missing here? Most "production" grade directory traversal implementations will indeed use less memory in the common case by simply delaying read from a a directory iterator until it's ready to descend or yield the next entry. In this way, one avoids ever needing to store the entire list of directory entries on the heap. Of course, the problem with this approach is that it requires the use of a number of file descriptors proportional to the maximum depth of your directory tree. This is why said implementations will expose an option for explicitly balancing this trade off, which is what [walkdir does](https://docs.rs/walkdir/2.2.7/walkdir/struct.WalkDir.html#method.max_open). &gt; As for the risk of blowing the call stack, what would you intuitively recommend? I guess I'd recommend not using recursion. But this could potentially make the implementation significantly more complex. Caveat emptor: I've given a lot of thought to the generic problem of directory traversal, but have not spent a lot of time thinking about reporting on disk usage. So if I'm missing a key constraint here that's imposed by that use case, then I apologize and might be misleading you. :-)
Cool! I have a similar project called [uwc](https://github.com/dead10ck/uwc), but it makes a different trade-off: correctness with unicode. It's quite a bit slower than `wc`, so I was curious to see if something in Rust could beat it with a byte-oriented approach. It's a personal project that I don't have much time for any more, but over the holidays, I did some work on a branch that uses rayon to parallelize it, and I've gotten to to a point where it is within an order of magnitude of `wc`'s performance, which honestly kinda surprised me.
Match ergonomics really is nothing but a pain. I have never had it improve anything, and always end up having to manually dereference or manually reference things myself. To this day it is the only “feature” in Rust I truly dislike. 
I see. Now I get what it does. Thanks. 
A crates team member responded saying they wouldn't do anything. Got downvoted to hell so you might not have seen it
I was confused by what *block syntax* and *typestate* meant, but then I saw in the link those have been removed from the language.
Thank you for your help. I think I understand what you're saying, but I'm still not sure, because in other cases I don't see the mutable reference 'consumed'. In [this example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=981a6ba6a4757e7d7b6a4e94e9d793d0), what is the difference comparing to the for loop? I can use the mutable reference after the into\_iter() call. I'm starting to think I don't understand the for loop at all, and may need to read some more.
You can't reliably test most floats for reliability but 0 is a special case. And there's no point in being wrong as it's a &lt;=. :)
Reserving names is required in a flat namespace. Every crate name I reserved is from a project idea I thought of and is either in progress or abandoned without releasing or it is a name reserved for an extension of an existing project. It only takes so many times to try to release crates and hit reserved names before you start reserving names yourself. This behavior is a natural extension of having a flat namespace. 
I want to develop games, but C++ is crap and everything else doesn't perform as well. Rust having very good WebAssembly support is icing on the cake, as I'm working as a web developer right now.
I know about this fork and plan to contribute to it, but sadly it still has many bugs or missing features
The idea of the borrow checker and the aliasing/mutability guarantees were new and elegant to me, so I decided to learn Rust. It took two tries.
I wanted to write a remote desktop app for my phone. Obviously, I needed a server and Python wasn't fast enough. Rust had just reached 1.0, so I decided to learn a new language.
Yes i don't doubt that there are smart people using Go. It is however created for entry level programmers at google. (as said by the creator(s)). Its probably going to attract entry level programmers more so than experienced ones. 
Thank you Steve!
I think the book and the information you provide in the forums/reddit were very helpful for me when I was learning Rust, much appreciated. Good luck!
I am attempting to write a low level Vulkan renderer in Rust and am running into the API design problems caused by not being able to store borrower and borrowed in the same struct, described here by tomaka back in 2015: https://gist.github.com/tomaka/da8c374ce407e27d5dac Have there been any developments in Rust since then that might help this? Is the [rental](https://github.com/jpernst/rental) crate still the best option? 
I'm not sure how this is any more of a threat than just using third-party software in general. Nobody is currently depending on empty name-squat crates. They might, in the future, depend on packages at these names, and those packages might have vulnerabilities, but that isn't affected by the squatting at all. When you do a name transfer, the person you're adding as an owner can actually remove you (preventing you from having further access to the crate). I did this early on with \`irc\` when it was being squatted in a similar fashion to the one brought up by OP. As for confidence in the package ecosystem, I don't think anyone is ever going to be able to give you an assurance that none of the code you are importing, which was probably written by hundreds or thousands of people, contains any security vulnerabilities. I mean, nobody could give you that assurance even if you wrote it entirely yourself. But in practice, the open source world largely seems to run largely on reputation, and well-trodden packages are probably your best bet for mitigating some of these challenges.
Thanks for all of your hard work, Steve. The Rust community wouldn't be as good as it is without you. 
That's why we need to make a step into separating rust and it's commercial side from mozilla :)
So the train of thought is, "Uhg, I hate when people do this. _I'm_ going to do this."?
This issue has subtleties, but I speculate that deleting unused crates by users who've done things as the OP describes would free up most of the squatted names, without having a formal solutions to the grey areas. Leave the edge-cases alone for now, and address the obvious bad actors.
As I also said in my other comment, `vref.into_iter()` here actually calls `(&amp;mut *vref).into_iter()`, which is possible because a method call can borrow/dereference a variable implicitly ([docs](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)). To better see what's going on, you can add the function fn iter_of&lt;I: IntoIterator&gt;(i: I) -&gt; I::IntoIter { i.into_iter() } You'll see that changing `vref.into_iter()` to `iter_of(vref)` will break it because that actually consumes `vref`, as you might expect, and changing it to `iter_of(&amp;mut *vref)` works (which I think is exactly why `vref.into_iter()` works here).
I contribute 2 rubbish repo proudly.
It is slower than Roda and slightly faster than Sinatra. Roda is a generic framework written by the creator of Sequel and about 10-12x faster than Rails in most benchmarks. Sinatra on the other hand is a micro framework, but is not focused on speed or heavily optimized and about 5-8x faster than Rails just because of its micro framework nature.
You've been a gift to the Rust community, and you'll be a smart investment for whatever venture signs you on next!
I was a student during my first attempt, so kind of nothing/ anything. C++ was my favorite language by far though. I learned Rust alongside my first Job, which was Python.
Neat - thanks.
Thanks Steve! I still remember Rust for Rubyists (even though I wasn't a Rubyist) being one of the things that brought me back into Rust after lurking around some years earlier. Best of luck to you in your future endeavors. :-)
So one person could register bazillion accounts and reserve bazzilion * 5 crate names.
&gt; I've never had problems with semicolons in Rust. It's crucial to know that statements are terminated with a semicolon, whilst expressions are not. Is that the grief they give you? It's the fact that I need to think of them at all. Both Kotlin and Scala are modern languages and they don't require semicolons, so the code looks cleaner and easier to type. And with Rust I have to put them all over and then after moving some lines I need to remove some semicolons and add some. Looking at other languages I know it can be designed without, so it just doesn't make sense to me that Rust, being modern and starting from scratch would keep that C's annoyance.
I'm sorry to see this and I hope it's a wake up call to Mozilla. I hope to continue to see you around at meetups and conferences. Thankfully it's clear that Rust is much bigger than Mozilla at this point. With Fuschia, Firecracker, Magic Pocket, Oracle's VM, Chef's Habitat, and numerous other company backed projects making significant investments, regardless of how Mozilla is run I think Rust will succeed (though Mozilla still has a huge impact, naturally). Best of luck with moving to a new position.
Thanks for all your work Steve. Good luck with whatever comes next.
Sure but it's a much harder task to just automate. You need a valid email afaik now to register an account and you can't request an API key without doing it manually. So it's still possible but not something I can do in 10 minutes.
Rather than MIR, I'd target WASM (Rust-&gt;[WASM-&gt;C](https://github.com/WebAssembly/wabt/tree/master/wasm2c)) or create a new backend to [cranelift](https://github.com/CraneStation/cranelift). Thoughts? /u/fgilcher 
I made this page to collect info about systems on our computers which are being updated with rust versions! feel free to edit it or leave comments here about your favorite software which is being oxidized and I'll add to it.
This sounds like a very common story for those coming from object-oriented programming to Rust, which enforces a data-oriented paradigm and is not particularly friendly to "OO ALL THE THINGS".
Steve, thank you so much for your contributions and for your amazing book on Rust. I truly cannot express how fun and easy the language was to learn because of your work. Thank you and best of luck to whatever is next!
Made an [early pre-release of ggez 0.5](https://www.reddit.com/r/rust_gamedev/comments/acqdtb/ggez_050rc0_released/), at long last. As that post says, it is certainly not *done*, but most functionality is there and the API shouldn't change (much), so it's ready for other people to play with.
No, thank *u*. You've done great work.
That depends on the details of what sensor you're using and what your code is running on (microcontroller, raspberry pi, windows computer, etc). It won't help much to read about "creating firmware", because that's so broad.
This looks like it should be exactly what you're looking for: https://startupsventurecapital.com/rust-ide-repl-in-vim-11daa921a2c4 (Note: it's about ~1 year old and I haven't tested it out personally)
The [Pin API](https://doc.rust-lang.org/nightly/std/pin/index.html) is the only development in this space I'm aware of. It's what's underlying async/await and allows borrowing across yield points, which turns out to be related to self-referential structs. You can read withoutboats' blog series on it, [starting here](https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/). I believe the series ends when you get [here](https://boats.gitlab.io/blog/post/rethinking-pin/) where a redesign of the API is discussed. I also believe it's that redesign that's slated for stabilization but I haven't followed it that closely in the last few months. Maybe it can help your use case.
I see both sides on this issue: obviously no one wants rust to become as complex as C++, but on the other hand rust really is a hard language for a lot of people to learn, and some features (even those that just make it more familiar) can help people learn rust. Personally, I'm less worried about syntactic complexity (as long as it doesn't introduce things like ambiguity) than semantic complexity. The author of this post seems to be opposed any form of complexity, which is fine, but I'd have liked the post more if the author described what they think separates good proposals from bad ones. For example, they seem to like the `?` operator, which was quite controversial at the time, and is really just syntactic sugar itself. Why does that make the cut and not Ok-wrapping? 
Thank you for everything! ❤️
Why not? It's not as if refraining from doing so will accomplish anything. If other people can reserve hundreds of crates with common words, what argument is there to not be proactive? This is clearly a problem with crates.io/the ecosystem. 
The advantage is that changing the group is something noticeable when it happens, giving you some time to re-evaluate if you trust the new owners. (Also how often would it happen anyway?)
Go originally positioned itself as a successor to C and/or C++, but they found itself more popular among people coming from Ruby and Python. I'm pretty sure Rob Pike wrote something about this in one of those annual state-of-the-language things, but my Google-fu is weak right now.
Can you elaborate on this a bit? I know rust isnt super OOey, but what do you mean by a data-oriented paradigm?
Thank you everyone! I don't want to spam the forum with replies to everyone individually, so consider this one big &lt;3 to all of you. As I said, I still plan on working on Rust, so I'll still see you all around!
Thanks for everything you've put into Rust, Steve! I look forward to what you'll be able to do next, your work is greatly appreciated. Best of luck!
To start, I like the catch blocks that are being added. It makes it possible to use `?` in subsections of functions. Sometimes I've split up functions to imitate this. The only thing I've liked about `try fn` is saving me from `return Err(stuff.into())` otherwise I agree that it makes things too implicit. It feels like being embarrased about what make Rust different rather than embrassing it.
&gt; I'm not sure how this is any more of a threat than just using third-party software in general. Nobody is currently depending on empty name-squat crates. They might, in the future, depend on packages at these names, and those packages might have vulnerabilities, but that isn't affected by the squatting at all. A package with a more appropriate name is likely to be used over a package named less appropriately even if the latter is of higher quality. A lot of factors cause this (search engine results being the most prominent). If a good name is blocked and not used, changes are higher that it has been blocked only for selling it later. In this case, chances are that the buyer is either a company with money to waste or someone with an ulterior motive. A majority of the developers will just choose another, less appropriate name instead of shelling out money (they're already sharing their work, why would they pay money from their pocket as well?) &gt; As for confidence in the package ecosystem, I don't think anyone is ever going to be able to give you an assurance that none of the code you are importing, which was probably written by hundreds or thousands of people, contains any security vulnerabilities. I mean, nobody could give you that assurance even if you wrote it entirely yourself. But in practice, the open source world largely seems to run largely on reputation, and well-trodden packages are probably your best bet for mitigating some of these challenges. Did you even read my post? This isn't a binary 'is secure/is unsecure' question. Nobody is expecting any guarantees of security here. There's a wide spectrum here and preventing squatting helps eliminate one category of malware sources. If you're really interested to know more, take a look at the popular github/reddit/npm package names available for sale in various places. It's a real problem and trivializing it would be the equivalent of burying our head in the sand. Of course, it's a free world and you're free to do that if you want to
The train of thought is: "I'm trying to be productive and ship shit, I will follow the process".
Wow, that comes as a shocker to me, good luck mate.
Thanks! May I ask what your researches are about? 
I had missed your second edit. Thank you for your help, I got it now :)
Thank you for continuing supporting me even though you don't use Rust that much!
 Thanks for your great work. I don’t think the rust community would have been as strong as it is now if it weren’t for all hard work you have done. Good luck with your future endeavors.
Thanks! Having a job that is only part-time definitely helps a lot making progress in those projects!
The battle with borrow-checker lasted 4 weeks. History says the borrow checker will eventually surrender.
There's a name for this: https://en.wikipedia.org/wiki/Tragedy_of_the_commons Once a few bad actors start squatting, preempting them becomes a defensive posture. It's extremely rational for an individual but every squatter incentivizes more people to squat.
Vim's not a good IDE in general, because it's not meant to be. If you want to go that route I'd recommend Emacs with Vim emulation, you'll get a more robust experience.
I share your ambivalence; language design is really hard. Part of me would like Ok-wrapping, it would save some typing and 'noise'. But the details of how the coercion should happen are tricky, and then we would have to teach that. Add enough conveniences and we get something like Python: _superficially_ simple but actually not that easy to master. It's the cumulative effect that worries me.
For or against? Just clarifying because your post is ambiguous. 
That sounds like a really frustrating situation, good for you that you gave notice! I'm grateful for all the work you did on rust, excited to see what you'll do next!
Hope things go well, thank you for your work. You've done things when we've needed it. We wouldn't be here without you. 
Rust chooses to go with semicolons in order to be a free-form language, meaning it doesn't matter where you put newlines or tabs or spaces in your code, it's still the same code and it compiles. This is different from Python for example, which is a whitespace-significant language. Tabs/spaces and newlines change the meaning of the code. Kotlin mixes both. You can omit semicolons and let newlines be the statement terminators, or you can explicitely use a semicolon. Which of these three is the best is subjective, since it really is just mostly cosmetic. It's a polarizing topic for some though, just look at the people dismissing Python just for it's whitespace significance.
No problem happy to help
Doesn't feel like an issue worth designing around.
Not the OP, however, I believe they are saying that when proposing features one must address the complexity and feature totality of Rust *holistically at that particular point in time* and not in a vacuum of the feature's problem space, or at any previous point in Rust's history where the holistic complexity had a different (lower) value. As of today (Jan 7th, 2019) Rust has a certain level of complexity (which includes the `?` operator) and thus the `Ok` wrapping must account for added complexity on top of what's already landed. Every change adds some form complexity to an extent.
I'm trying to hash the contents of files inside a hash-map. Unfortunately Rust won't let me insert a value into the hash-map (borrow mutable) when I've already tried to retrieve a value (borrow immutable). It says: *"cannot borrow `self.files` as mutable because it is also borrowed as immutable"*. I tried putting curly braces around the code where the value is retrieved, but apparently the immutable borrow still lasts beyond that scope. struct Parser { files: HashMap&lt;String, String&gt;, } impl Parser { fn get_file(&amp;mut self, path: String) -&gt; Option&lt;&amp;String&gt; { { let val = self.files.get(&amp;path); if val != None { return val; } } match File::open(&amp;path) { Ok(mut file) =&gt; { let mut contents = String::new(); file.read_to_string(&amp;mut contents); self.files.insert(path.clone(), contents); Some(self.files.get(&amp;path).unwrap()) } Err(_) =&gt; None, } } }
Whenever I see `unwrap`, I always try to think of a way to remove it. For small examples it does not really matter, but it's nice to learn how to deal with it in a safe way. E.g: ```rust if self.tail.is_some() { unsafe { (*self.tail.unwrap()).next = Some(new_tail) }; } ``` could rather be changed to ```rust if let Some(mut ttail) = self.tail { unsafe { (*ttail).next = Some(new_tail) }; } ``` PS! I have not tested the provided code, but I think it should work :)
I’m in the libs team. We generally accept "small" PRs without an RFC for adding unstable APIs. (It’s before stabilization that we do a Final Comment Period to get team consensus.)
&gt; I switched to Rust exactly because I find it 'C++-improved'. I agree, in the sense that Rust replaces C++ for me. C++ has many things I like, but the language has so much bad design. Rust, on the other hand, is the first language I've ever used that feels like it's designed by *professionals*.
There’s already `impl From&lt;ChildStdin&gt; for Stdio` (and similarly `ChildStdout` and `ChildStderr`), so the error handling should be the same. (I haven’t checked what that is, maybe `Command::spawn` returning `Err(…)`).
&gt; Add enough conveniences and we get something like Python: superficially simple but actually not that easy to master. Of the dozen or so languages that I've "mastered", Python was probably the easiest. Maybe I don't know Python as well as I think I do, but I've certainly written a lot of code in it…
It was easier to cross compile Rust and C dependencies to Android with Cargo than C and C dependencies with CMake.
See also the previous /r/rust thread on this same guy: https://www.reddit.com/r/rust/comments/9aaanw/cargo_crate_name_reservation_spam/
nope, but It take a long time for me to make it working. If it does not work, fix is simple: delete all files under ~/.rustup and reinstall.
I hate these linked list examples. I never needed to implement a linked list myself except in school.
That's true somewhat, but if you're considering holistically adding features can reduce complexity by eliminating special cases or unifying disparate things. Though I don't think that's happening in this particular case of Ok-wrapping. I do think you've got what he was trying to say, though obviously different people will have different opinions on whether a particular feature is worth it.
I wanted to build a web server just to learn more about how server work. first I started in c. it had memory leaks and it never ran in the first try. after looking at few examples I rolled up a small server in rust. that was my first successful learning project with rust. (this reminds me I still have to handle threading and its been 3 years)
It raises the cost from 10 minutes to like... a weekend?
A single counter-example that explains a band-aid solution to a shitty problem doesn't address the notion that non-existant quality control results in a shitty ecosystem. And to be fair, having to go into fine detail to to, in terms of information, checks which of the two disjoint sets a value belongs to, such as in the example you give, is slapstick-level absurdity of violating dependency inversion.
Thank you for the work you've put into building up the Rust community! Excited to see what you become involved with next.
Really impressed. You are not far away from getting a technical paper published imo. &gt; Honestly, GenericArray is better than standard arrays at this point. With all the work on optimizing integrators, it sure seems like it.
&gt; I'd also like to help. Is coordination happening in the wasm working group or elsewhere? Heads up: we're restarting rust+wasm wg meetings this Thursday: https://github.com/rustwasm/team/issues/244
Heads up: we're restarting rust+wasm wg meetings this Thursday: https://github.com/rustwasm/team/issues/244
Maybe we make it a requirement that you upload a README with some information about how you plan to use a name you have reserved. Alternatively, put a time limit on how long names can be squatted before they are returned back to the pool if no crate has been published with that name. The system can still be games but it gets harder to do so. 
I agree, but bashing everyone who likes or uses that language isn't the way to go (lol).
Man this is rough. I've been at-arms length following Rust for over a year now, and you've (Steve) been a shining beacon in positivity and information. I've not seen another community with such a centralized, active involvement. I cannot commend you enough for the work you've done here Steve. I'm truly saddened for this turn. Thank you your significant contributions to Rust. I hope wherever you land makes you happy, and I greedily hope that continues to involve Rust. Thank you. &lt;3
&gt; It only takes so many times to try to release crates and hit reserved names before you start reserving names yourself. This behavior is a natural extension of having a flat namespace. Or, you ban the bad behavior and mandate that you can only take a name once you have a non-trivial package to upload.
It'll work correctly if you go with just one return path: https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d7e16129f03d6f86bacf06ce241fc97c. I'm curious why you're version is invalid though (I can't see any reason why it should be rejected).
Yeah, I 100% agree that they're not good examples of the sort of problem you'd need to solve in a given language. That said, I still like them—at least enough to write this one, anyway!—because they're small, self-contained, and dive deep enough into the language internals that you can (start to) see the differences in the "world view" of the language. (Compare them to something like Advent of Code challenges—those are also small, self-contained, and unrealistic to real programming, which makes them pretty similar. But many of the early ones don't get deep enough into the language to really get a feel for how the language pushes you to think/approach problems) 
Don't blame the player; blame the game. This is one of the things why people asked for namespaces. The first-come-first-serve system of a single unified namespace seems like a bad idea to me. It's super easy to give each create a GUID instead which you can just copy and paste into your Cargo.toml but they choose for this system which has numerous other problems and relies on too much centralization if you ask me.
Thank you for everything, Steve!
Yeah, that's how the world works: eat or be eaten, Don't get mad at the animal who eats the other animal to survive; get mad at God for designing the world like that.
You're a great example of positivity that the developer community needs. Never have I seen you interact in a negative manner with someone. Good luck at your next gig!
Please correct me if I'm wrong, but I don't believe there's any danger in calling `unwrap()` inside an `if_some()` block. The only way `unwrap()` can panic is if the item being unwrapped is `None`, and the if block guarantees that it isn't! (Of course, there might still be a reason to avoid `unwrap()` just as a code smell, but that's a bit different than doing it because there's a way to do it in a safe way :) ) 
In which case you have to do the original non-trivialness in secrecy and can't use an open-development model for it.
Thank you so much for your heroic efforts and accomplishments Steve! I wish you much more success in the future. Any project will be lucky to have you on their team.
It's the one thing I tell everyone who is interested in learning Rust: while implementing a binary tree or a linked list is an exercise for beginners in most programming languages, this is not true in Rust. 
You are completely right! You just made sure that it is `Some`, so `unwrap` is safe (won't panic). However the `if let` binding is constructed to do this, so there is no reason to make a `if_some()` - block in the first place. I would say that `if_some()` blocks are a code smell. 
How do you define non-trivial?
&gt; At work rewriting to rust a python application to rust which contains memory leaks. Your phrasing is a bit weird, does the Rust port have leaks?
Seems worth doing. I don't see any great reason not to. Just requires a bit of hard work.
I'm in the process of learning embedded development with Rust by writing my own keyboard firmware for stmf32f103xx processors. The [embedded book](https://rust-embedded.github.io/book/) is a great place to start. as /u/e-matteson said, we're going to need more details on what you're working with before giving any more concrete advice.
One of the reasons that the United States works as well as it does (and we can withhold judgement on how well that actually is) is because the government was designed to take people's desire to grab power and use it against other people against themselves. Each branch of the government is filled with people who want to steal power from the others. An equilibrium is hopefully reached where each branch is too busy stealing power from the other branches to find any time to steal power from the populous. &amp;#x200B; You can't build a system and then say, "And it will work because no one will go power hungry." Or even, "If anyone goes power hungry \*we\* will step in to stop them." Inevitably either people go power hungry, get greedy, or misinterpret the actions of others as malicious and react in a greedy fashion in perceived defense. &amp;#x200B; Hanlon's razor tells us that we shouldn't attribute maliciousness what can be explained by ignorance. So maybe the people eating up more than their fair share of crate names are only doing it because they truly believe they will be using them AND they fail to see the detrimental effect on others. However, the other side of the razor coin is that sufficiently advanced ignorance is indistinguishable from maliciousness. &amp;#x200B; The good news, though, is that marketing is an art form like any other and it works best when given overly burdensome constraints. I suspect that finding a good name for your crate wont be a significant problem if you have a crate worth using. But I do agree that this type of system doesn't work as well as we might hope it does.
Also, check out [coc.nvim](https://github.com/neoclide/coc.nvim/); I find it faster and generally a better experience than any other language server I've tried for neovim so far.
You probably don't even need the `ref mut` nowadays! :)
Well, it's not explicitly for sale, so I want to point out that that's an assumption. There's nothing precluding it, though.
Continuing on multilingual sites support for [Zola](https://github.com/getzola/zola), a static site generator. I will also remove `error-chain` from it (unless someone wants to do it! https://github.com/getzola/zola/issues/576) and update it to use v1 alpha of Tera. If I find the time, I might also try to reduce some of the [temporary allocations in Tera](https://github.com/Keats/tera/issues/364). Welcoming any help there as well!
Good point! I wasn't certain so I put it for good measure, but you are probably correct because `self` is a `&amp;mut Self` :)
That happens in Maven, including some relatively foundational stuff like JavaEE APIs. I've never really seen anyone have an issue with it. It almost always happens over version numbers, which means that you're updating the identifying tuple anyway. Also, having to visibly change the owner can be argued to be a feature.
It requires a lot more effort which is usually enough to deter a large amount of people acting in bad faith
I have to admit, you did seem frustrated to me in some of your comments on this subreddit recently. Reading this blog post puts that into perspective, but I apologize if the assumption the two are related is wrong. Regardless, it's a shame it has had to come to this, the quality of the available documentation is wonderful and I believe you've been a major driving force behind those efforts for a long time. I wish you the best of luck in all your future endeavors, and hope we haven't seen the last of you in this community. 
That perspective makes sense if you only think about immediate dependencies, but doesn't work as well with transitive dependencies. Imagine my_app uses several packages, which in turn have their own dependencies, and so on. Graphs with hundreds of packages are very common. Now, let's say a few of those transitive dependencies (most of which you may be totally unaware of) all use some package "awesome_co/thing". But "awesome_co" has decided to stop maintaining "thing" and pass it to a new group. Some of those transitive dependencies migrate to "new_maintainer/thing", but some don't. Now you have two copies of "thing" in your app. Hopefully, values don't migrate from one to the other at runtime. If this causes a problem for you in my_app, there's little you can do because, remember, all of this is way down deep in your transitive dependencies. What should be a simple administrative change "these people used to maintain thing, now these people do" is now a friction on the ecosystem because it's enshrined in the identifier of the package itself. So the question then is, does putting the owner name in every single package identifier add enough value to compensate for that friction? In practice, it's not clear to me that it does. There's value on either side — basically everything in package management is trade-offs — and I don't see that namespacing packages by owner is anywhere near a clear win.
The real reason for the addition of `..=` is that it's required to iterate from 0 to 255 in a u8 variable using `0..=255`; if you try `0..256` it will not work because 256 overflows and becomes 0.
Yeah, years of C/C++-sadness brought me to Rust
I don't agree that it's a deterrent. It's just that no one cares right now ie: there aren't really bad actors who care much about crates.io. Give it a few years and that will change and a weekend will mean nothing.
&gt; Modules are hard to understand. How come? Of all the complaints of Rust I heard over the years, the module system has never been any of them. I thought modules were pretty straightforword, the only thing might be the difference between `foo.rs` and `foo/mod.rs`.
Mozilla is making a grave mistake not doing everything they can to keep you. Thanks for all you've done for Rust! It really would not be where it is today without you.
It's not subjecive when, in one case, you have to type more and in another never bother with the thing in the first place. Cleaner code, less to type -&gt; better. Who cares about this free form stuff anyway, when doing crazy oneliners with lots of semicolons isn't part of everyday life.
I'm not proposing it as a end solution. Just as a stop gap that would fit within current crates.io policy . I do agree that they need to rethink their policy as a whole at some point because clearly people are abusing it, but that involves a lot of discussion. Effectively rate limiting people could fit in with their current policy without much work and would make it much harder for bad faith actors.
lib.rs, directory name, not lib.rs in those directories, blocks of `mod {}` inside those files besides that. It all seems arbitrary and counter intuitive at first.
One of the things I really like about Rust is how little of the standard library is privileged. You can write customer operators for your own types. If you want to create a type that works nicely with `for`, you just need to implement the `IntoIterator` trait. Working with `collect` just calls for `FromIterator`. Eventually, `?` will work with anything that implements the `Try` trait. `Ok`-wrapping suddenly privileges `Result`, making it exceptional. You can't write your own `MyResult` type and have it as capable as the built-in `Result`, because it wouldn't automatically `MyOk`-wrap. (This goes double for `fn foo(i: i32) -&gt; i32 throws SomeError`, since you could make a `Try`-like trait for autowrapping.)
Wrong subreddit you want r/PlayRust.
Wrong subreddit you want r/PlayRust.
Interesting idea; thanks for sharing. Hope this gets traction. Might be worth also linking to tools that facilitate oxidation. Corrode and C2Rust being the major ones now that Citrus is deprecated in favor of C2Rust. https://github.com/jameysharp/corrode https://github.com/immunant/c2rust https://gitlab.com/citrus-rs/citrus Disclaimer: I'm part of the C2Rust team.
Just released my (data_reader crate)[https://crates.io/crates/data_reader] yesterday. So my plans are now to start working on a faster backend for it, and also work on writing some more robust line and comment line counter functions then the current quick functions I have in there now.
I had the same issue. I "solved" it by throwing hardware at it, but it's still too slow. I think your solution is better for iterating.
I'm not super familiar with the ok-wrapping proposals, but I believe all of the serious ones base it off of a trait, so it would work for result, option, etc.
The conclusion about needing unsafe for everyday code is a bit surprising. How often do you write custom data structures? I've only used unsafe for ffi and that is also pretty seldom.
Agree, its a shame that Rob Pike does that by saying that they are not capable of understanding a brilliant language. 
The only way I can really think to make it more concise would be to replace that mapping with `.cloned()`. Functional programming can get verbose at times. Try to avoid unnecessary closures, but don’t obsess over aesthetics.
See also: - [FreeBSD kernel module in Rust](https://github.com/johalun/echo) - [minimp3](https://wiki.alopex.li/PortingCToRust) - [Oxidizing Python: speeding up URL quoting by 10x](https://tech.blue-yonder.com/oxidizing-python-speeding-up-urlquoting-by-using-rust/) 
I wonder what made you rewrite after 6 months? Did you use nighthly toolchain?
Thanks, fixed :-)
Actually, rust port consumes 10x less memory.
oh no. but thanks for your great work.
Fighting _for_ the borrow checker? Yes, I have indeed given talks with the aim of convincing people to use Rust because the borrow checker is awesome!
Exactly. I had used the nightly toochain for the VScode plugin, back when it only worked with the nightly toochain.
Perhaps a "paradigm" is too broad of a word, but object orientation is more about organizing source code than organizing the shape of your data. Traditionally, OO languages like Java and C# have made that possible by: 1. Making the basic building block of OO -- memory indirection using virtual dispatch and interfaces -- one of the most straightforward things to write. 2. Covering lifetime concerns by using the GC. However, Rust is different in that it brings nontrivial friction with both of these things by default: 1. Rust, because of its status as a system languages, forces you to opt into the abstractions you use. C++ is like this too: data is on the stack and directly accessed by default but provides a toolkit for choosing common memory indirections and management schemes (i.e., C++'s `unique_ptr&lt;T&gt;,`shared\_ptr&lt;T&gt;`are analogous to Rust's`Box&lt;T&gt;`and`Arc&lt;T&gt;\`, respectively). 2. Rust goes further than C++ adding friction to OO patterns in that it values correctness and making the usage of abstractions explicit. Accessing the data inside a `shared_ptr&lt;T&gt;` in C++ is as easy as writing `*data_ptr`, though C++ puts the burden on you to use it correctly. It's easy to shoot yourself in the foot in the course of normal code maintenance. Rust's values are, in general, to prioritize correctness over ease when they conflict, and so you may (read: usually) will have to write a bit more boilerplate to do the same things in order to force you to confront error cases. 3. Rust goes yet further in that your data lifetimes need to make sense lest you run into compiler errors -- you can't "simply throw a reference to the data somewhere" (sound familiar?) because the compiler will stop you unless you've been using indirections by default, which per above is normally an unnecessary hassle. This, in turn, puts pressure on correctly determining the shape of your data up front and more deeply understand the relationship(s) between it. OO does no such thing until and unless you run into performance problems. In essence, Rust pressures you to do the "right" thing for performance and correctness from step one, and the pressure ramps up the longer you ignore it. I've tried to give facts based on my experience, and I've found it eerily similar to [Catherine West's experience using Rust for game development at Chucklefish](https://kyren.github.io/2018/09/14/rustconf-talk.html): &gt;I’ve gotten a lot of questions over the past year or so that more or less ask: &gt; &gt;\&gt; How do you make a game from scratch in Rust? No, seriously… HOW. I mean, I can see how you can do it in theory, but for some reason when I try to apply patterns that I’m used to from other languages I just hit lots of problems? I’ve heard that this is called “fighting the borrow checker”, but… that doesn’t really seem to help me much. What am I doing wrong? &gt; &gt;Or, maybe it’s something like: &gt; &gt;\&gt; I can see how rust is great if you like very strict control, I can see it being used for small utilities or things where security is paramount, but it seems very restrictive! I don’t really see how you could make something large like a game without running into these limitations. How do you structure something like a game without needing Rc&lt;RefCell&gt; and Arc&lt;Mutex&gt; everywhere? &gt; &gt;These (straw man) questions are of course about games, but they also mirror sentiments I’ve seen about Rust in general. &gt; &gt;... &gt; &gt;\[I\]f you forget OO design and instead just concentrate on the data representation of your game state (or whatever you’re making), and you try hard not to make anything more complicated than it really has to be, things can actually be pretty simple! Another link that might be of interest is the WP article for [data-oriented design](https://en.wikipedia.org/wiki/Data-oriented_design), which Catherine talks about in her blog/RustConf talk.
And what if you have `Result&lt;Result&lt;(), E1&gt;, E2&gt;`, how far would it go? `Ok(Ok(()))` or `Ok(())` or `()`?
I'm just going to reiterate what everyone else is saying, but I just want to say - thank you Steve for all of your hard work up until this point! Rust just wouldn't be the same without your involvement.
I find it interesting that you connect these two posts. I pretty strongly disagree with the OP here, especially around things like ergonomics initiatives.
&gt; But the details of how the coercion should happen are tricky, and then we would have to teach that. We already have to teach the manual aspect of ok wrapping, and many newcomers find it very weird.
I don't think I've ever called it "data-oriented" but I like to write Rust code starting with the types, i.e., which data to transform into some other data, and derive the required behavior and which encapsulations are convenient from that. In OOP languages I used previously¹ I started by modelling a system around the possible encapsulations of behavior (coming up with a class hierarchy, basically). Ehh, okay, not the best description. Someone can probably put it in a more comprehensible way. 😅 ¹ Rust has changed me…
Content-Type: github/plain
No, you don't. You can put it up on github. If someone ninjas you into being able to ship first, you can rename your repo on github when it's ready.
Wouldn't have happened to the other side. If someone revoked `right-pad`, everyone would just migrate to `alt-right-pad` and their software would continue to work.
I think you made a good decision. Best of luck in your future escapades—the world is a big place, don’t be afraid to explore a bit!
How do you create memory leaks in python?
Or copy and paste the same hello world code on all crates.
Someone was commenting a week or so back that Rust's development should be seen as a marathon not a sprint. Someone needs to tell that to the higher-ups, because this looks a lot like burn-out to me. Underpaid, under-resourced, sprinting towards a deadline means burn-out and losing good people. I guess Steve only put up with a bad situation because he really wanted to achieve a personal goal within Mozilla and Rust, to his own high standards. I hope other Rust team members aren't also pushing themselves too hard (or letting themselves be pushed too hard). Got to find some balance and apply effort selectively. Good luck, Steve! I hope you find a good role somewhere for the future. Having high standards and being able to inspire a team to maintain those standards makes you valuable.
Yeah, those 70s languages made me use Rust.
"Simple", "Linked List", and "Rust" are not allowed to be in the same sentence together. However, like the Borromean Rings, removing any one leaves a perfectly valid statement.
So, alternatives to Rust? :) kidding. Good luck Steve!
It's take on null isn't bad either.
I'd also like to know it :-D The app is long-running and leaks show up after significant time. I didn't manage to identify exact reason of it. Moreover, the app is multithreaded.
Keep up the good work. WebAssembly is clearly the future and its awesome that Rust will be part of pioneering that work.
How would you define a type alias for a pointer to a trait method, then assign it? This is what I've come up with, but I feel like I'm hacking a workaround: trait Foo { fn foo(&amp;self); } struct Bar {} struct Baz { f : FooMethod } type FooMethod = fn (&amp;dyn Foo); impl Foo for Bar { fn foo(&amp;self) { println!("dynamic dispatch, woo!"); } } fn get_foo_method&lt;S : impl Foo&gt; () -&gt; FooMethod { |s| s.foo() } impl Default for Baz { fn default() -&gt; Baz { Self { f : get_foo_method::&lt;Bar&gt;() } } } More explicitly, I want to create a container of pointers to trait methods, and I don't know how to get a pointer to those methods without using a helper function that wraps the call in a closure. It's not the worst thing in the world since that closure is optimized away, but still I'd like something cleaner. 
Have you looked at the "Entry" API of HashMap? It is intended to help with just these kind of scenarios, and also to make them more efficient. For example: use std::collections::HashMap; struct Parser { files: HashMap&lt;String, std::io::Result&lt;String&gt;&gt;, } impl Parser { fn get_file(&amp;mut self, path: &amp;str) -&gt; Result&lt;&amp;str, &amp;std::io::Error&gt; { self.files.entry(path.to_string()) .or_insert_with(|| std::fs::read_to_string(path)) .as_ref() .map(|content| content.as_str()) } } This has the added advantage that it caches I/O errors and returns a Result for them. There is a lot of stuff going on in here, some of which may be non-obvious to someone new to Rust. First, we ask the `HashMap` for an "entry" with a given key. That gets us an `Entry`, which holds a mutable reference to the `HashMap` and can be used to read / write / insert / delete that entry, *without* re-hashing the key and doing another table lookup. It's kind of awesome. Next we call `.or_insert_with()`. This function takes a closure, which is only run when the entry is not found in the table; its job is to compute a value. Our closure uses `std::fs::read_to_string`, which reads the entire contents of a file into a single `String`. However, because that operation can fail, `std::fs::read_to_string` returns `Result&lt;String, std::io::Error&gt;`. Lucky for us, that's exactly what we're going to store in the `HashMap`. The `.or_insert_with()` call returns a mutable reference to the value of the item stored in the "entry". In our case, that means the return type is `&amp;mut Result&lt;String, std::io::Error&gt;`. But we don't want to return that to our caller, we want to return `Result&lt;&amp;str, &amp;std::io::Error&gt;`. So we use `.as_ref()`, which converts its input into `Result&lt;&amp;String, &amp;std::io::Error&gt;`. We're almost there! We still need to convert the `&amp;String` to `&amp;str`, because `&amp;str` is the right type to use in this situation. So we use `.map(|s| s.as_str())` for that. We're done, so that's the last thing we do before returning to the caller. Because the method now accurately reflects an error path, your callers will need to decide how they handle I/O errors. You could also write this code differently, if you don't want to cache I/O failures. This is just intended to be an example. 
By the way, are you familiar with the `sum()` method on `Iterator`? You can do this: let v = vec![1, 3, 5, 7, 9]; let sum = v.sum(); 
Hi, check out my neovim configuration file: [https://github.com/realcr/my\_init\_vim/blob/master/init.vim](https://github.com/realcr/my_init_vim/blob/master/init.vim) I use autozimu's LanguageClient's neovim plugin together with rust language server. You can see what it looks like in some of my twitch videos, here: [https://www.twitch.tv/realcr/videos](https://www.twitch.tv/realcr/videos) &amp;#x200B;
Working on my fun project to learn Rust: [terminal todo manager](https://crates.io/crates/ttdl)
This is how I do catch blocks without catch blocks: let val = || { let foo = bar()?; Ok(do_something_with_foo(foo)) }();
This is really cool. Some random thoughts: - The encrypt and decrypt interfaces return a `Vec`, which requires memory allocation, so it's not `no_std` compatible and potentially not suitable for extra-high-performance applications. [`sodiumoxide` solves that problem](https://docs.rs/sodiumoxide/0.2.0/sodiumoxide/crypto/secretbox/xsalsa20poly1305/index.html) with its "detached" APIs, which separate the authenticator from the ciphertext so that the ciphertext and plaintext fit in the same `&amp;mut [u8]`. On the other hand, [*ring* keeps the authenticators attached](https://briansmith.org/rustdoc/ring/aead/fn.open_in_place.html) but provides some parameters to control how the plaintext and ciphertext overlap. In general, Rust makes it tricky to support overlapping buffers in the way that C likes to, and I don't think a specific best practice has turned up yet. - You might want to document that `Context::finalize` clears the state it's operating on. Assuming I read that correctly in monocypher's docs. - Generating random keys and nonces properly is tricky enough that I'm surprised monocypher doesn't include code for it. (Their docs even note how tricky it is.) It might be worth directly integrating with the `rand` crate to spare the user from the responsibility of calling the right crypto-appropriate random APIs? Other crypto library authors might want to weigh in on this one, but I think it ranks highly on the list of "things users tend to get wrong."
I have no idea if it will play nicely with SIMD, but there is a `windows` method / iterator defined on slices, which itself iterates slices of values. You could use that for your look-back indices. Gahh, I just looked at it, and `windows` only gives you an immutable window. This *almost* works: fn prepare_schedule(m: [u64;16]) -&gt; [u64;80] { let mut arr = [0u64; 80]; arr[..16].clone_from_slice(&amp;m[..16]); for w in arr.windows(16) { w[15] = sigma1(w[14]) .wrapping_add(w[9]) .wrapping_add(sigma0(w[1])) .wrapping_add(w[0]) } arr } I wonder if you could lobby the Rust folks to add a `windows_mut` variant? 
I'm working hard on [piet](https://github.com/linebender/piet), a 2D graphics abstraction. My goal is to get it supporting the lion's share of needs from resvg. I've had nice community contribution so far and am open to that continuing.
&gt; Cabal isn't perfect but it has a better solution, namely: don't depend on two different versions of the same library. How does Cabal resolve the issue of stale, unmaintained packages? Eg, something depends on A-1.0, but it will work with A-1.1, yet because the maintainer is gone it cannot be updated. "Just update it" doesn't seem like a solution, since the maintainer is hypothetically gone, and "just don't depend on it" is a nonstarter, since the purpose of dependency management is to make it easy to depend on things. As I recall, Maven has a way to replace a dependency's dependency with another version (although it's very hard to do and discouraged, for obvious reasons - if you can update your dependencies, you should).
I agree. Steve has had a tremendously positive impact on Rust’s growth, from both technical and social perspectives. This is a loss. That said, I’m happy that he’s moving on to things that will hopefully bring him more happiness and less frustration.
I can't imagine you'll be able to convince many folks that this is a good idea, [me included](https://crates.io/crates/bstr).
You were the first person I "met" from the Rust community with when I discovered Rust a few years ago now. You were always both patient and adept at explaining new concepts without making the asker (often, me) feel stupid. Each time I saw you live by the code of conduct when challenged by others who didn't feel so constrained I came away impressed and with that much more respect. Thank you for your contributions Steve, and I wish you all the best going forward.
Single producer multiple consumers
Exactly one layer, because it's an unconditional wrapper, not a coercion.
&gt; But, it is a coercion newpavlov's example does not use coercion- that would imply you could optionally write `Ok(())` or `Ok(1)` instead and both would work. Instead it's simply an unconditional wrapper, which is why the `try` keyword is required. It's an extension of `try { .. }` blocks, which also unconditionally wrap their result in `Ok`. This is analogous to `async fn`s and `async { .. }` blocks. The `async` keyword introduces a new context with a new capability (`await!` in this case; `?` for `try`), and wraps up the result when it leaves that context. That is, you don't write `Poll::Ready(result)` at the end of your `async fn`s, just like you don't write `Ok(result)` at the end of your `try fn`s. If you want something extra-rigorous here, you can generalize these features to an "effect system" in which `try` and `async` are individual "effects" that the language tracks for each function. You can do some neat stuff with this, like "effect polymorphism" (imagine a combinator like `unwrap_or_else` able to take a closure that can be *either* `async` or sync, with the combinator itself becoming `async` when necessary). But even if you don't go any further, making `try` and `async` consistent means we get access to the rest of that research.
No worries, I just didn't want to sound repetitive in case you had read it, haha. This was very helpful for me as well!
Ah- it definitely will need a nightly compiler _to compile_, but you should be able to use it with a stable compiler once it's been compiled. From what I understand, most people just install it precompiled using `rustup`.
Afaik the idea behind the policy is basically "we don't want to waste time on policing or lawyering, so please don't be the kind of person that forces us to spend time on policing or lawyering kthx".
Your example is really hard to understand. The natural language description is difficult to read. Any chance you could choose a more descriptive name for one of the traits?
That's an awesome solution for what I'm trying to do, thanks! The Entry API looks great, and I expect to use it a lot when dealing with HashMaps. I wish I understood why my code doesn't compile, though. I thought I'd gotten the hang of lexical lifetimes and borrows, but now I'm not so sure.
In your blog post you talked about wanting no new features until 2020, I took that as you agreeing with the sentiment that we should be careful of adding too much features that bloat the language. Upon reading it again, I think you meant that we should hold of on adding features to focus on maturity. I'm sorry for putting words in your mouth. That being said, I'm curious to know where you stand on the issue of "feature bloat". Do you think the rust community is pushing for too much change too fast (regarding feature bloat, not maturity)? How important is avoiding "feature bloat" to you compared with better ergonomics when considering new features?
Wow. Very sad to see you leave. You were always one of those people that embodied the ideas of the Rust community: Professional, polite, always looking to improve Rust itself instead of getting defensive. Be it on here or on Hackernews, the two platforms I follow for the most part, as soon as the topic of Rust came up, you showed up immediately (seriously, how? :D). For example, when a beginner is just kind of pissed at Rust for making this one specific thing hard, to not just answer "well that's just the way it is, live with it", but instead ask "how could we improve the docs so this is more obvious?" is hard, and you managed to do it every single time. I think this is one of the hallmarks of Rust, the self-reflection, that makes the language and community so great, you embodied these ideals for me and imho were absolutely crucial in getting Rust to where it is today. So thank you, and good luck wherever you'll work next :) 
My rules: * Make your lifetimes explicit. Find every place where a lifetime has been elided, and replace it with an explicit lifetime. Sometimes it becomes clear where the problem is. * Break your code up! Break it up into smaller functions, then still smaller ones. Put explicit lifetimes on all of the functions. Again, this helps to make clear where the problem is. * Create a small example that demonstrates the problem, and ask for help here! 
Zero worries! I meant "interesting" literally, it made me wonder if there's any common ground around those spots that I'm not seeing. I think it's tricky, the subject has a lot of nuance. I find most conversations of "bloat" to be a bit simplistic. Sometimes, adding things can remove overall complexity because they make something simpler. That also goes for mental models. Something can maybe make a language feel more complex because it adds some sort of special case, but can make the overall mental model significantly easier. It really just depends. My advocacy for slowing down is more about quality and capacity than it is about some blanket "rust is done" sentiment. That said, I do think that after some of the features I've mentioned, we may be meeting diminishing returns. We'll see!
I saw you at RustConf and wanted to personally thank you for all of the time and dedication you've given to the Rust community, but I never made it through all the other people who must have had a similar idea. Anytime I had a dumb question on IRC you were always the first and nicest person to answer. &amp;#x200B; It's not in person but I hope it will suffice: Thanks Steve. Onto the next.
Will Xcode work on Windows though? It'll take a long time for third parties to create a development environment comparable to Xcode.
I really don't understand why people have such strong opinions on this, just pick another name! I haven't seen a single argument on solving this "problem" that was clearly better than what we have right now.
You are the reason I'm in Rust today. Your evangelism matters.
Being an outsider on this issue but seeing it come up constantly, why doesn't rust namespace crates like the npm registry does nowadays? ie `@jhenson/random` instead of `random`? For the slight inconvenience of extra typing it seems like it clears up a lot of issues not only around name squatting but also adds some extra transparency on who the crate is coming from.
Something something, [law of triviality](https://en.wikipedia.org/wiki/Law_of_triviality). Namely: &gt; Problems arise after a suggestion of building something new for the community, like a bike shed, causes everyone involved to argue about the details. This is a metaphor indicating that it is not necessary to argue about every little feature based simply on the knowledge to do so. Some people have commented that the amount of noise generated by a change is inversely proportional to the complexity of the change. I don't think it's possible to combat this. Moderating or censoring threads like this have their own (significant) problems. The other approach is for folks to just start ignoring it. I do my best to be cognizant of this phenomenon and try not to comment on things unless I feel like I feel like I have something compelling to share. I don't always succeed though!
I understand that you are frustrated. I am not saying that your feelings are not valid but instead that a more constructive route in the future is not relying on reddit posts to communicate with a team of volunteers. Especially when that team has a policy explicitly asking you to email them if you would like to discuss an exception to an item in the policy.
Thank you for everything you’ve done for this project and this community. I don’t know about others, but I wouldn’t be here without you. 
I am not saying they do not, I am simply trying to point out there there may be a better avenue for communicating with them. to quote from the crates.io policies page: &gt; In general, these policies are guidelines. Problems are often contextual, and exceptional circumstances sometimes require exceptional measures. We plan to continue to clarify and expand these rules over time as new circumstances arise. If your problem is not described below, consider sending us an email. 
I've seen two approaches, in Rust crypto-related libs, to generating random keys. Both approaches use the `rand` crate. The first approach is to use the`CryptoRng` marker trait from `rand`. This way you can specify a generation function to take in a `Rng` that needs to be a CSPRNG (hence the marker trait). This will both support uses of `OsRng` when `std` is available or a seeded `Rng` such as `ChaChaRng`, making it available for use in `no_std` as well. This still leaves the user responsible for correctly providing a suitable `Rng` however. Marker traits used in the `ed25519-dalek` crate [here](https://github.com/dalek-cryptography/ed25519-dalek/blob/2c22ff648a734cef14f3c673ea24c171d85be4c0/src/ed25519.rs#L311). The second approach is to directly make use of `OsRng` or `thread_rng()`, having the library generate a random key and not let the user handle generation themselves. This however depends on `std` to be available (does not support `no_std`). I think it depends on the libraries goal. If your main goal is to support `no_std` and think that users should be able to handles RNGs themselves, then the marker trait is obviously the go-to. As /u/oconnor663 mentioned, it does seem like users tend to get this wrong, which is why I've chosen to use the second approach in my own library. I have however separated it such that any generation function relying on `OsRng` is behind a feature-flag, meaning that the library still supports `no_std`, just without the generation functions being available. You can check it out [here](https://docs.rs/orion/0.12.0/src/orion/typedefs.rs.html#151-157) if you're interested.
So you can do [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7ae4d4a889c6677594865b8ab1001f9b), but the closure is still there. One thing to note: you'll be able to call the function on any `dyn Foo` (even with the way you did it, since you don't use `S`).
[removed]
Shift in ownership should be considered a breaking change. The case only matters when we change version, but changing the policy and beliefs behind it are big enough that people should check and verify that the new ownership, their beliefs, ideals, and direction, still match with the code using them. Version is so much more about politics than it is about technicalities. Technically code either works or it doesn't, you just use what works, and avoid what doesn't. The idea that you have to take a bunch of things together, and that they all need to work (and you can't just drop what doesn't) is entirely consequences of how we, the coders not the code, interact. Versions are just a consequence of this. So lets talk about your example. People use "awesome\_co/thing", which is great, but then "new\_maintainer/thing" comes in, and their plan is to inject ads or spyware into the binaries using the library to make money. And maybe it's not that bad, maybe they don't have as much problem bloating the code. Maybe they add a bunch of non-free extra features you don't want. Maybe the quality/reliability of the code from the new maintainers decreases and leads to an increase in bugs. Changes that aren't breaking, but if you had to choose all over again under these maintainers, you'd would have chosen something else. You just explained why this is so dangerous: suddenly you have to go through your whole dependency tree, not just pruning the bad "new\_maintainer/thing", but also all libraries that use it by default. If it were a breaking change then only libraries that explicitly choose to agree with the new management will shift. If it weren't, and it'd just happen by default, the old projects that don't have as much support will shift and spread the toxicity around until fixed. Now it's true, there's the problem of this breaking things. But why even have semantic versioning at all? After all v2.0 may not be backwards compatible, but it may work just fine for our specific uses of v1.0, why not just change it and move forward? What when one of my most important dependencies changes to v2.0 but the other libraries still use v1.0? So we already have this problem, and breaking changes will happen a lot more than ownership changes will, so why even care that much? Hell add the ability to have "curations", basically I release my own versions of "curated/packages", which are basically just symlinks to the real package, with just some extra checks that need to be passed before I consider a version (and owner) "curated" or not. The whole point of my packages is merely being a filter. And then as long as I'm reliable people can trust on me trying to keep the packages running.
It's been a while since I had a major "fight" with it, and I don't know that I can recall any specific instances enough to be useful, but I can definitely share some general trends I used to have. When I was newer to Rust, I used to describe my interactions with the compiler like this: "When the compiler complains, just try adding some `&amp;` and `*` to see if that fixes it. If it doesn't, you're probably doing something dangerous and should actually think about it." The next big phase for me came when I mostly understood how lifetimes worked, but hadn't internalized them enough to understand when I would run into lifetime issues or how to tell if there was a "fix" or whether I was in a situation that requires bigger re-architecting. This was the period where I mostly understood that the only time you really need to reason about lifetimes is at the type level, and since I was in the weeds writing Diesel 0.1 at the time, this mostly meant associated types on traits. So this was the period where I knew that I could do things like `impl&lt;'a&gt; SomeTrait&lt;'a&gt; { type Whatever = &amp;'a Foo; }` and follow compiler errors to lift the lifetime through other traits needing a bound on `SomeTrait`, but I couldn't yet tell ahead of time whether that would lead to a solution that worked. These days I've internalized the borrow checker enough that when I encounter a borrow checker error, I can quickly tell what the compiler is actually telling me (is it a minor mistake, do I need to reason about who owns this data at another level, is what I'm trying to say fundamentally nonsensical). In most cases, I still can't tell you what `impl&lt;'a, 'b: 'a&gt;` means without looking it up (which side outlives the other again? Why do I even care?) but the only time I write that bound is if the compiler tells me to. When writing in languages other than Rust, I tend to get annoyed that I *don't* have the borrow checker, since knowing if someone else can see/mutate this value right now is a useful thing to know for reasons other than memory safety. Probably the most recent specific instance of "fighting"the borrow checker that I can remember is writing most of https://github.com/diesel-rs/diesel/blob/5744e837182ccb440a0473dda746623a42ad5850/diesel/src/connection/statement_cache.rs. https://github.com/diesel-rs/diesel/blob/5744e837182ccb440a0473dda746623a42ad5850/diesel/src/connection/statement_cache.rs#L149-L159 used to be *really* ugly (but some new methods on the entry API cleaned it up) and https://github.com/diesel-rs/diesel/blob/5744e837182ccb440a0473dda746623a42ad5850/diesel/src/connection/statement_cache.rs#L239-L240 has also always been a bit messy, and getting it to avoid UB required some deep reasoning about lifetimes. All of my instances of fighting the borrow checker have been in library code which has to reason more about lifetimes than normal code. Since getting past that first "add more `&amp;`" phase, I haven't felt like I was fighting the borrow checker in application code.
\&gt;all use some package "awesome\_co/thing". But "awesome\_co" has decided to stop maintaining "thing" and pass it to a new group. Some of those transitive dependencies migrate to "new\_maintainer/thing", but some don't. Now you have two copies of "thing" in your app. Hopefully, values don't migrate from one to the other at runtime. If this causes a problem for you in my\_app, there's little you can do because, remember, all of this is way down deep in your transitive dependencies. You have the same thing with versions. Some one might depend on \`thing\` version 1.1 and another package depends on \`thing\` version 1.2. So this needs to be handled anyway. Java has handled this using \[shading\]([https://maven.apache.org/plugins/maven-shade-plugin/](https://maven.apache.org/plugins/maven-shade-plugin/)). Java 9 saw the introduction of \[modules\]([https://openjdk.java.net/projects/jigsaw/](https://openjdk.java.net/projects/jigsaw/)) with finer grained control of what is exposed by packages. So if you have \`dependencyA\` depending on \`thing\` version 1.1 then it's hidden and no one else knows anything about \`thing\`. Can Rust use this? I'm not sure. Maybe the Rust community needs to agree to agree on a binary format for crates (faster builds too!) and part of that agreement can be to support private symbols from transitive dependencies.
Can you give some examples of such RFCs? I'm not really sure what you're thinking of, even though I think I understand your example. Keep in mind that macros have their own downsides (IDE integration, syntax). I'm especially thinking about procedural macros. As a straw-man, you can implement `async` or other "mechanical" transformations as a function-like procedural macro, but do you really want to?
&gt; You have the same thing with versions. Yes, and that is a challenge. But that's a fundamental problem with the code itself — when you change the code in some incompatible way, the code using it must handle that fact. A package manager must deal with this in order to get the user to a runnable program. Group ownership changes doesn't cause any immediate problems in the code itself. You could add a separate "ownership solver" system to the package manager, but that isn't solving any technical problem in the code itself.
Doing a bunch of housekeeping on my OSS Projects, straightening out their CI story and setting them up with bors. It feels like busywork but if Travis CI stops emailing me about rustfmt changes, it'll be worth it (:
&gt; Here's a suggested Ok-coercion syntax mentioned by newpavlov on internals: &gt; &gt; [...] &gt; &gt; Now this feels rather attractive (although the try feels like a redundant syntactical tic; the Result is the key part of this signature). Coding in Rust means typing a lot of Ok(()) every day. I'm not a fan of the `throw` syntax. The only argument for it is that it's familiar from languages with exceptions. Rust doesn't have exceptions; it should not have throw. That said, I am a fan of the language construct. The way I envision it is using two keywords: `fail` for error-wrapping, `pass` for ok-wrapping. fn foo() -&gt; Result&lt;(), MyError&gt; { if flag() { fail MyError; } pass (); } The keywords are statements. They require a semicolon, like `return` or `break`. They work by exiting the nearest lexical `try` block, or the function if no try block exists. If try blocks are nested, a block identifier can be given to `pass` or `fail`, similar to `break`: fn foo() -&gt; Result&lt;(), MyError&gt; { 'outer: try { try { fail 'outer MyError; } pass (); }; } Now add a rule for pass-elision that is similar to return-elision: `pass`may be elided when it is the last statement in the block: fn foo() -&gt; Result&lt;(), MyError&gt; { 'outer: try { try { fail 'outer MyError; } () }; } Finally, add a lint that warns when `fail` is used with `pass` elision. This gives us the convenient "ok-wrapping" syntax, but ensures that, within a given block, any use of `fail` should be accompanied by `pass`. Why is that important? Because as keywords, `fail` and `pass` can be unconditionally highlighted, making the exit points of error handling code clear during a code review. There's two additional nice qualities of using `fail` instead of `throw`. * First, `throw` comes with baggage: in every language with the construct, it's clear that it shouldn't be used for control flow. In Rust, it simply is control flow. Why invite confusion? * Second, the word `fail` can be used for error handling, but it supports non-error conditions as well. For example, `fail` could be used for a failing lint (which could be a warning), failing tests (e.g. a performance regression), failing input validation (which isn't fatal), cache misses (in which case the cache-hit failed), a failed proof (which could even be a success case in a proof by contradiction), and so on.
&gt;Did you even read my post? I did read your post, and it was not obvious to me what you thought the security issue with name squatting is. I know believe I understand your concern (but please correct me if I am missing something): Succinct names like "algorithms", i.e. the kind that people like to squat, lend credibility to packages that might be unearned. The connection to squatting seemingly that you believe that if names are squatted and sold, the buyers have a higher chance of being malicious. &gt;There's a wide spectrum here and preventing squatting helps eliminate one category of malware sources. Whether or not moderators would remove squatted packages, anyone could choose to upload malicious code into a package with a succinct, trustworthy-sounding name, and then work to get it included in other code bases. To me, the latter part, the work to get it included in other code bases, is the security threat, not the squatting. &gt;A package with a more appropriate name is likely to be used over a package named less appropriately even if the latter is of higher quality. I agree if all other things are held equal, but I don't think it's right to suggest that the name is such a dominating factor, and that's why I alluded to package reputation. As a concrete example, there's a Rust `web` crate that is being squatted and a wide assortment of web frameworks written in Rust. Say someone uploaded malware to `web`. When trying to choose a Rust framework, I agree that I'd probably stumble upon `web` (at least if someone was trying to do something malicious with it), but I'm also going to look at documentation, blog posts, etc. I'm going to see a bunch of websites for a bunch of frameworks with people discussing them, and `web`, an astroturf package, is not going to appear in them. It's possible to make `web` convincing, of course, by getting it into these posts, but the kind of coordinated effort that be involved to get it into the hands of well-known Rust programmers and then into these posts seems large and ultimately distinct from the fact that `web` started as a package squat. Others have proposed solutions to name squatting that, orthogonally, provide mechanisms for the curation of "approved" packages or something. For example, the proposal to mirror Docker and namespace all packages with a mechanism for lifting curated packages into the "global" (i.e. unprefixed) namespace. I agree that package curation efforts can prove helpful in increasing confidence in the package ecosystem and reducing the likelihood that people adopt malicious packages (at least when well-known non-malicious ones exist).
You're thinking only of the malicious case. That's important, but even ownership doesn't solve that. You can have bad actors arrive in an existing organization. Either way, most cases of ownership changes are not malicious. A good example is a package I worked on. I wrote the original markdown package for the Dart language. It wasn't a priority for me to maintain it at work, so someone in the ecosystem volunteered to take it on. They kept it going, mainly doing minor tweaks for a while. Eventually, we had enough internal need for it that it made sense for us to own it again and the owner handed it back to us. At no point did we ship breaking changes to users. At no point did any difference in vision of philosophy occur. Most users of the markdown package probably never knew anything had changed, which is great. All they care about is that they can reliably get a package that parses markdown.
A pretty cool article about error handling in rust, with Option and Result types (that I can't find now, sadly). A few days later I rewrote a shell customization of mine in rust, with a lot of help from the kind peeps on irc. Been using it ever since.
Thank you so much! `deoplete` has been acting up for ages for me. Let's hope this performs better!
Thank you for everything, I think that you've made the rust community a much nicer place! You've been very helpful to me, and I look forward to hearing about your future endeavours.
Thank you!!! I hope you'll find a great next job, you definitely deserve it.
I don't quite get your point I'm afraid. If it's solved for versions then it's solved for groups. It must be solved for versions. Therefore there is no unsolved problem here given groups.
I've been trying to write a simple REST API with actix-web and I can't seem to be able to extract JSON from the HttpRequest as shown in the [docs](https://actix.rs/docs/extractors/). I want to write a handler for creating a user with the signature fn create(req: &amp;HttpRequest&lt;S&gt;) -&gt; HttpResponse; According to the docs I should be able to use `Json::&lt;MyStruct&gt;::extract(req)` to get the JSON and then use `.into_inner()` to get the data. When I do I keep getting errors because extract is returning a `Box&lt;Future&lt;Item=Json&lt;MyStruct&gt;, Error=Error&gt;&gt;` response and I don't know what to do with that. Is there just a gap in the documentation and implementation (I'm using 0.7.17), or am I missing something?
Thank you for this great example! Coming from c/c++ , I feel a bit dirty when using macros though. I know its a bit different in rust, so it's something i will have to get used to. Macros seems really powerful.
Why was not ..= just an iterator? We didn't need a special syntax, just ::core::InclusiveRange(0,255) 
So much this but C++. Debugging memory corruption bugs is a hell I haven’t got time for since I just code as a hobby. After dabbling in rust a little over the last few years I found myself essentially trying to write Rust in C++. Then I realised all the features that make Modern C++ interesting (ADTs, move semantics, concepts, modules maybe one day) Rust already has and in a much more ergonomic, sane implementation. At that point I switched to Rust entirely and haven’t looked back. Having got used to cargo now going back to trying to build a library with complex dependencies using CMake makes me want to throw my laptop out the window. 
In C/C++, they're purely text replacement. In Rust, every stage of macro expansion must be valid Rust syntax (for declarative macros), and this means that you have access to a lot more information during the macro expansion process. You have type information, you have lifetimes, you have expressions, you can implement a token muncher in them. Think of them as a tool in your toolbelt. 
thanks for all your great work, docs, book, communication etc. One thing your book taught me is that I don't want to ever use a language without a GC :D thats work for other people! 
On the topic of Result based macros like `?`, how will `?` handle more complex Results like that of futures? Eg, I _believe_ the current await API has a function sig looking like `fn foo() Result&lt;T,E&gt;`, but when `await` is used, is that not actually `fn foo() Box&lt;Future&lt;Item=T, Error=E&gt;&gt;`? So if await wants boxed futures, will `?` work with await?
That is really good to know! I tried dune and jbuilder, I had no idea they were connected. Mostly the problem was that I found more than one "new and improved" build system for ocaml. Maybe I could have compared the dates of various articles I found...
&gt; number crunching isn't fun in rust I think that const generics should make this a lot better, maybe not instantly, but the ecosystem has been held back by this. &gt; some data structures do not really fit for rust Agreed, but I this can be solved by using unsafe for the datastructure implementation. One could even use garbage collection in Rust, this would be especially useful for graph type datastructures, there are some ideas and basic libraries floating around for this. 
I imagine because .. was already a thing and people expected a way to create an inclusive iterator to be consistent with the non-inclusive one.
Back in 2015, I think you were the first person who answered my Rust related question on irc.mozilla #rust. &amp;#x200B; Helped me out tremendously. Thanks for the help and your work on Rust. I hope your future endeavours will be as awesome as your past.
Well I need to be able to write for any sensor that I need but I’m gonna choose one of the single board computers. For example RPI for now. It maybe boring topic to study but I have to
Welp, R.I.P. Rust. 
Highly unlikely, the only reason that Swift runs under Linux and sooner or later Windows is the backend development (maybe games and apps too, but without Apple Frameworks, AppKit, UIKit, etc). About cool alternatives to Xcode you have Intellij alternatives on Mac, they can easily port it to Windows and Linux, and Visual Studio Code already has a plugin using Swift LSP preview, that could easily get into Visual Studio when Swift 5 get released.
What a great chance to hear that you did the firmware for a keyboard. At the first I wanted to create a firmware for a keyboard in order to build my own pocket PC. Do you mind to share your firmware on github ? If it’s open source of course. Thanks for the recommendation I will start to learn Rust and it’s embedded system book. 
You probably saw this one already, but just in case: https://rust-lang-nursery.github.io/edition-guide/rust-2018/index.html I think right now it doesn't give a whole lot, bit it introduces a bit of futureproofing for the language itself. So the langdevs don't have to stress too much about breaking changes in the 2018 version, while allowing libdevs to use them if they ellect to.
A flat namespace, for better or worse, relies on users to act in good faith. Claiming and then irresponsibly neglecting a name is not that. If your project ends up running out of time, let the name go. Especially if you have multiple abandoned projects, and numerous unreleased/soon-to-be-abandoned projects- just free some of the names up instead of letting them fester for all time. Also you (and others acting similarly) might get a little more goodwill with crate squatting if you copy/paste in a brief essay expressing your annoyance at having to reserve a crate so early, instead of silently contributing to the problem.
A flat namespace, for better or worse, relies on users to act in good faith. Claiming and then irresponsibly neglecting a name is not that. If your project ends up running out of time, let the name go. Especially if you have multiple abandoned projects, and numerous unreleased/soon-to-be-abandoned projects- just free some of the names up instead of letting them fester for all time. Also you (and others acting similarly) might get a little more goodwill with crate squatting if you copy/paste in a brief essay expressing your annoyance at having to reserve a crate so early, instead of silently contributing to the problem.
https://crates.io/users/IvanUkhov similiar one. Check out that `assert` crate that is at 0.7, but contains like one function. :D
Mozilla? The same Mozilla that dumped RSS and integrated Facebook? Yeah, that Mozilla.
"No policy/enforcement" isn't quite the same as explicitly allowed. I mean it is the same for all practical purposes. But this way, it reads more like almost everyone agrees squatting is not desirable, just that solving that problem is too low of a priority.
are you meriadec?
In other languages you would inherent data or use more broad generics to structure code Composition is the only way to reuse data structures in Rust as there is no inheritance https://en.m.wikipedia.org/wiki/Object_composition
Desktop link: https://en.wikipedia.org/wiki/Object_composition *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^230384
Thanks a lot for your work and good luck in your new path, no doubt you will find very good job offers. (We met in buenos aires :) )
The sad truth is, we live in a society which values engineering much more than teaching. It sometimes worries me how much of an emphasis is put on diversity in tech as opposed to a broader diversity of values in general. Don’t get me wrong, I completely agree that systematic barriers which make it harder for people of many backgrounds to get into tech should be chipped away at (“removed” is perhaps too optimistic, some realities can’t be done away with — e.g. the fact that tech speaks English). However, diversifying tech is only one side of the equation, it still operates on the assumption that tech is the top of the food chain pyramid (which everybody should have equal access to). But what about challenging that assumption, re-examining the system of values our society espouses, perhaps somewhat redistributing some of the density in that highly skewed distribution and making the pyramid a little flatter? There’s plenty of jobs crucial for society, teaching included, which could use some value density spilling over from tech. I guess what I’m trying to say is this: ultimately, our goal shouldn’t be a society where “anyone can be a software engineer” (what about people who don’t *want* to be software engineers?), but a society where a decent living can be made by anyone making meaningful contributions to society, be it through coding, teaching, making pizza, or taking care of elderly people. Plus even within tech itself, things could use some value unskewing (looking at you, “exciting” disruption vs. “boring” maintenance). But I digress into idle daydreams :) What I primarily wanted to say is that when your job sort of straddles both engineering and teaching, but you get paid proportionally to the latter, it’s clear you need some additional non-monetary incentives to stick to it. In my case, I’m in academia, doing research in linguistics and teaching, both of which involves a fair amount of coding (I teach linguistics students to code because I firmly believe it’ll empower them to do better and more interesting work with language, whatever career path they end up choosing). Some of my close colleagues are engineers working on software projects curated by our department and they get paid more than I do, because of course they do — if they didn’t, we wouldn’t be able to hire any, that’s just the way the job market is. Conversely, the administrators can’t really justify spending that much money on us linguists because, well, we “come cheaper”, so to say, again as per the job market. Now, as long as the workplace environment is friendly and allows me to thrive, and my contributions are valued and appreciated, I’m more or less fine with this arrangement. I get to do what I love, teacher/researcher in linguistics is a much better fit for me than software engineer, I feel like I’m working on something where my modest talents can make a meaningful difference. There’s my non-monetary incentive. But I can totally see how these pros could be outweighed if some aspects of the workplace experience made me feel miserable or frustrated or both. Especially if I didn’t get recognition for a job well done or if I felt like I was on the sidelines of things. (Not to imply this is what happened here, just listing what would sour the deal for me.) The money angle would then undoubtedly start looming much larger in my mind. Anyway, all this to say thank you for all your hard work on Rust and good luck finding a position which allows you to make a decent living and makes you happy, whether it brings the big bucks or not :)
&gt;I think that const generics should make this a lot better, maybe not instantly, but the ecosystem has been held back by this. yeah. but all those explicit casts will still be there.(there are some use cases where this is a plus, and some where it is annoying) &gt;Agreed, but I this can be solved by using unsafe for the datastructure implementation. One could even use garbage collection in Rust, this would be especially useful for graph type datastructures, there are some ideas and basic libraries floating around for this. &amp;#x200B; actually, i got this running in rust. but the problem i saw was in refactoring. if you want it in safe rust you end up with all those RefCells and deep type structures - try to refactor it - if you make a mistake. if you do it unsafe - well - it feels more natural in c/c++. &amp;#x200B; &gt;Isn't this mostly diesel api changes? I'd be suprised if it actually was the rust compiler breaking backwards compatibility. it was about nightly updates, and little things like uuid crate incompatiblities. don't get me wrong. i like rust.
I'd be happy with just "the crates.io team has full discretion to decide what counts as squatting" together with some examples and nonexamples as guidelines.
Yeah, I saw that and read through most of it, but most of what is mentioned seems to be not tied to an edition but rather to the Rust version.
What city do you live in that you meet Rust developers like that? 
Devs mentioned somewhere that not all new features are going to be 2018-only, some might show up on 2015 if it makes sense and doesn't break stuff.
&gt; yeah. but all those explicit casts will still be there. What cast's are you talking about? I'm not very familliar with the num crate. &gt; actually, i got this running in rust. but the problem i saw was in refactoring. if you want it in safe rust you end up with all those RefCells and deep type structures - try to refactor it - if you make a mistake. if you do it unsafe - well - it feels more natural in c/c++. I actually meant tracing gc so no messing with refcell, there are some experimental libraries out there, but if that will ever be realized, it's still a very long way out.
Two jobs and many more years ago, I taught a Ruby class to kids with you through CodeNOW program. This was many years ago, and pre-rust, but I've followed you at a distance since and been impressed with what you've done for the language and the community. Best of luck in your next venture. Wish I had something for you here, but maybe next time. 
I think this was the post: https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html
Yes, here is the GitHub issue: https://github.com/rust-lang/rust/issues/45222
&gt;Mozilla? The same Mozilla that dumped RSS and integrated Facebook? Yeah, that Mozilla. There are much, much better RSS readers than live bookmarks, including some Firefox extensions. And I have no clue what you're talking about re: Facebook. 
Steve, you helped me learn rust and solve quirks through your talks, docs, and chat in irc. Everytime I had a question you were one of the first to respond. Every time. In many ways you are the face of Rust at the moment. To hear you were undervalued as a team member at Mozilla is very disheartening. I have no doubt you will find something soon that will pay well and do right by you.
I think that "diminishing returns" is a good way of putting it. It isn't that a given hypothetical syntax addition would have no value, clearly it is useful to whoever proposed it. At the same the effort to design, implement, maintain, and learn the new feature could easily exceed that value. In that model it is also easy to see where tension over new features comes from: the people paying the costs and deriving the benefits aren't necessarily the same. 
I don't have an excuse not to attend, do I?
Haha, huge emphasis on "in the process." I've got gpio and the serial peripheral figured out, but still need to get i2c and usb working. I also want to do all of the task management via Futures. Aaand then I need to put it all together. I've got a long way to go 😛 my repos are all at https://gitlab.com/polymer-kb. I'll be blogging about it at https://josh.robsonchase.com as I go (hopefully). My most recent post about setting up embedded debugging might be of interest to you! I'm not the first to attempt a keyboard firmware in Rust - a more complete project is here: https://github.com/ah-/anne-key
How is it? That CoC rule is for person-to-person interaction. If I start posting about [this](https://i.imgflip.com/2qlrg2.jpg) every day saying that it's been years since 1.0 and rust still doesn't have solid async i/o — that would check all the inboxes.
I became interested in it after seeing it place so high in the yearly Stack Overflow survey. Then I read some people elsewhere talking about how useful the compiler error messages were. I’m still getting the very basics down, but I don’t think I’ll need to do anything in Rust for a while so I think I’ll just slowly absorb the fundamentals over time.
Slowly migrating my hand-rolled message-passing code to Actix, hopefully, while simultaneously doing some wasm and server stuff.
Simply saying it is pain at the start however as soon as u understand concept and get some experience u would notice problems even before compiling your code :)
My suggestion: There are a number of sites which will provide you with programming challenges (e.g. Advent of Code). You can work though example problems and learn at the same time, without the drudgery of syntax and rules. Once you are more familiar with the language you can jump into graphics and game development and go from there.
It’s really not though. Take my opinion with a grain of salt, but I’ve found the rust version of SDL2 to be waaay more ergonomic, and comes with the full benefit of all of rusts idioms, data structures, and safety guarantees. you would never know jts c bindings if noone told you. One of the strengths of rust is how well it interpolates with C. Regardless, I wasn’t trying to put emphasis on SDL2 itself. Feel free to go play with some other library, or write something from scratch. The point is it’s a literal canvas for sketching out ideas, and trying to impliment them in a rusty way. Feel free to go play with the new ropes library or something if that’s more your jam. I just personally get excited by programing visual stuff. But setting up rust is not hard, and cargo makes pulling in libraries very easy. 
It's usually both. So let's say the rust compiler is what implements all the features. Some of these features may not be compatible or there may be newer versions of a compiler feature. Editions are a way to tell the compiler as a whole which feature set to turn on. So the features are tied to the compiler version in that it needs to support them but they're enabled by the edition.
Thank you Steve for everything you did to develop Rust community and everything you did to maintain the positive attitudes on community members and newcomers. I got really inspired from you, especially to share knowledge. Best of luck on future endeavors and keep up your good work. We need you.
People are most definitely use tarballs to install their rust build chains. At work, rust tarballs are the primary way for installing rust on local machines. If the tarball is going to be restructured, please consider doing it in a way that doesn't cause install.sh to break backwards-compatibility for the sake of deployment systems and scripts that were built on top of it.
Wanted to learn a more "traditional" language like C, think I accidentally learned C++ and got angry at `cout` and found it by accident.
This sentiment is a bit insulting to everyone who isn't Steve who has worked or does work on Rust. Please don't.
&gt; Especially when that team has a policy explicitly asking you to email them if you would like to discuss an exception to an item in the policy. So that their grievance can be shot down in private? Sometimes, especially when the perceived problem is caused those in power, the only way to enact change is in public.
Thank you sir for all the contributions to the community. Wish you the best for all your future endeavours. 
I think in C/C++, the thought process is "Only use them if you **absolutely must** and if you **really, really know what you're doing**", whereas in Rust, the thought process is "Only use them if you must" for a slightly looser definition of "must". You should still prefer to use normal Rust, but macros are much less of a no-no.
I'd like to read about this if you have a reference? I was aware there are `move` semantics of a sort, but I had figured it was similar in name only.
Thank you Steve, and best of luck on your next adventure. :) 
Hey thank you so much for your answers! &gt; To be clear, you have to think of it not just in terms of what a type is, but what it manages. I really like your example of a type that has a known size at compile-time, but we're choosing not to make it `Copy`able to be able to use `Drop` and for our own safety! And I don't mind the rambling at all! I tend to do it too. :-) Thanks again.
Yeah I looked at your original code and something very similar, and I can't understand why the borrow lifetime lasts as long as it does. I'm going to look at that some more...
That's an interesting error message. I don't think I've encountered it naturally yet. ...But now that I've said that, I bet I'll soon make a similar error! :-) Thank you for the examples!
Hey man thank you for your answers!
Hey sorry for not thanking you! I thought I had responded to you. Thank you for taking the time to continue the discussion. Your explanations definitely helped me understand Rust's ownership system a lot better and I'm way more confident about it now than I was a few days ago! Thank you!
I feel really really stupid. I'm trying to create a Vec list of traits that can be used as an inplementation of functions, but I'm getting some really bizarre errors: "trait object size is not known". What I am trying to do is create a list of callbacks that can be used when an event is to be processed, say "for each object in X, perform x.handle_event(y)", but I cannot - for the life of me - figure this out. And I know this is a common problem. Here's an example trait: trait EventListener { fn new() -&gt; Self; fn handle_event(&amp;self, event: Event); } Then, to implement, naturally, it's: impl EventListener for FooEventListener { fn new() -&gt; FooEventListener { } ... fn handle_event(&amp;self, event: Event) { println!("Just got event!"); } } And the implementation to add the callback is: obj.add_event_listener(FooEventListener::new()); But the error I get is: error[E0038]: the trait `event::event::EventListener` cannot be made into an object I've tried Box&lt;EventListener&gt; and that doesn't work. I've tried setting trait with Sized. THAT doesn't work. I'm completely and horribly lost.
The 2018 edition is &gt;1.30 (until the next edition ships in 2021 iirc). 
Nice, was just about to write such a thing myself (for use on Windows, where there's no cygwin). No need now. thanks!
Ok, I took your example and commented out the `return val;`statement in the "cache hit" path. As /u/Patryk27 points out, that eliminates having two different return paths, and now the borrow checker passes. That seems really counter-intuitive to me. I think that's actually worth following up with the language design folks. It seems like a totally intuitive and safe pattern, and like something that a lot of people are going to encounter. I'm actually really surprised that I haven't encountered it in my own work. 
lol, wonder how many people this applies to. We could end up being really grateful for the name clash, even though the Rust players annoy us by posting here all the time!
Although now that I've read so many different sources and the docs so much, I think I disagree with the reasoning here &gt; Rust chooses to move it by default, because it's always faster to move the data than to copy it. The docs for the `Copy` trait says &gt; Under the hood, both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away. Maybe moves can be optimized by the LLVM better? In which case yeah it would be faster, but I think the reason why Rust moves by default is because it's a safer choice.
Love Haskell, but the unpredictable performance makes it impractical. Love C++, but got sick of shooting myself in the foot with it. "If only," I thought to myself about 3 years ago, "there was a language with the strengths of both Haskell and C++!"
Who became the Rust project leader after Brian left? It seems like there's a consensus that Rust in 2019 should focus on technical debt, organisational structure and refactoring/tooling for the compiler. Who says "that's our official goal for the year"?
This is made slightly more clear if we use the 2018-edition-style syntax `dyn Trait` to refer to a trait object, and `Trait` otherwise. The problem is that rust cannot construct `dyn EventListener`, because then the `new` method would be unable to exist. If you had an instance of `dyn EventListener`, for instance inside a box like `Box&lt;dyn EventListener&gt;`, what would `new` return? It can't be `fn new() -&gt; dyn EventListener` because `dyn EventListener` is _unsized_ and cannot exist on the stack. But rust guarantees that `dyn EventListener: EventListener` (`dyn EventListener` implements the trait `EventListener`), and since this new method cannot exist, `dyn EventListener` can't implement `EventListener` and thus cannot exist. Functions like this are called "non-object safe" and prevent traits like `EventListener` from being made into "trait objects". The main way I would recommend solving this is to tell rust "new can only be called if I'm sized". This prevents calling `&lt;dyn EventListener&gt;::new()`, but still requires it for all `T: EventListener + Sized`. The syntax is trait EventListener { fn new() -&gt; Self where Self: Sized; fn handle_event(&amp;self, event: Event); } There's a little bit more information on this at https://doc.rust-lang.org/1.30.0/book/first-edition/trait-objects.html.
Here are two examples of the standard library using this technique, one where it's sufficient and one where it isn't. [Implementing basic traits on numbers](https://github.com/rust-lang/rust/blob/8e2063d02062ee9f088274690a97826333847e17/src/libcore/ops/arith.rs#L92) - the macro contains all of the `impl Add for...` stuff, with a slot that is filled in with the exact type when the macro is called. [Implementing basic traits on arrays](https://github.com/rust-lang/rust/blob/8e2063d02062ee9f088274690a97826333847e17/src/libcore/array.rs#L108) - same technique, but filling in the size of the array. This has two problems that it's not possible to fix with macros: it bloats the documentation (just look at the 5 1/2 screen heights of `PartialEq` implementations [here](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-PartialEq%3C%26%27b%20%5BB%3B%203%5D%3E)), and it only applies to the sizes listed. If you want to hash a 32-element array? Great, it works perfectly. Want to hash a 33-element array? Too bad. To properly solve this problem, the language needs to be changed to allow generics to take an arbitrary N for `[T; N]` at instantiation, like [C++ can](https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter) and uses in [its array type](https://en.cppreference.com/w/cpp/container/array).
So long and thanks for all the fish On a light-lighter note. Totally excites to see where you land next Steve
The efforts of these projects, put together, are basically the oxidization of OpenSSL-style crypto libraries: https://github.com/briansmith/ring + https://github.com/briansmith/webpki + https://github.com/ctz/webpki-roots + https://github.com/ctz/sct.rs + https://github.com/ctz/rustls/ *ring* is the only component that has any C code or use of `unsafe`. If you discount license text and huge data tables, there is more Rust than C in it already. All the other components listed here are pure Rust without any `unsafe`.
I made a complete list here: https://github.com/rust-lang-nursery/edition-guide/blob/5521dada71a232403bcce6870eed92897590561e/src/rust-2018/edition-changes.md This does not include anything unstable, or in-the-works.
Well at work we needed a language to write some relatively high performance backend systems in and didn't want to do it in C++ (we have some C++ codebases and they aren't exactly shining beacons of reliability). We initially tried out Go but were mortified after a couple weeks of using it so we looked at Rust, and have been hooked ever since. We're also looking at expanding into Rust webassembly on the frontend eventually, but we need to train some more people in the language before we can commit to this. It's a fresh, efficient language with lots of nifty "I wish C++ had this" features that's still actively being developed, what more can you possibly ask for? Takes a while to learn and requires you to sometimes turn off autopilot when coding but the payoff is huge.
Can someone elaborate on horror stories of “foundations gone wrong” Niko mentions in the post? I actually thought that Rust Foundation would be a good idea, since a lot of people agree that it's hard for companies to contribute financially to Rust development directly.
Zola is excellent software that is a pleasure to use. Thanks for working on it!!
&gt; It's still not clear to me whether Rust's ergonomics can rival those of GC'ed languages. I can only speak from my own experience, but: For over 10 years I had only used "high level" languages like JavaScript, TypeScript, Python, Ruby, Haskell, etc. Rust was my first "low level" language. It only took me a few months to become competent with it, I was really astonished at how easy it was. Nowadays I try to do as much of my programming in Rust as possible. I write Chrome/Firefox extensions in Rust (even though the extension system is JavaScript only). I also write browser web apps in Rust (even though browsers are JavaScript only). I think Rust's ergonomics are far ***better*** than languages like JavaScript/Python/Ruby. The static typing is wonderful. All the various features (traits, enums, pattern matching, etc.) are wonderful. Rust is overall ***extremely*** well designed. Third party libraries in Rust are also multiple orders of magnitude better than the libraries in JS/Python/Ruby. The tooling around Rust is also fantastic. The big question is: what about the garbage collector? Well, I haven't missed it. Rust's ownership model is plenty good enough, and I actually find it *better* than a garbage collector. When working on a large TypeScript project, we had to implement our own Disposer system, which requires us to manually dispose of things when we're no longer using it. We needed the Disposer system because a garbage collector only works with *memory*, it doesn't work with other things like filesystem handles, event listeners, etc. So even in a garbage collected language, you still have to do manual resource management! But in Rust, I don't. I can use Rust's ownership model to automatically clean up event listeners, filesystem handles, etc. So in actuality Rust is *more* ergonomic, since its ownership model extends beyond memory, whereas garbage collectors only work with memory. And whenever I encounter a situation where Rust's memory model is too restrictive, I just use `Rc` or `Arc` (which are reference-counted pointers). And bam, problem solved. It's like having a mini garbage collector, but only when you need it. In practice my apps usually have 1 or 2 `Arc`, and that's it. So you really don't need it very often.
Struct composition is a great to enforce ownership and clean up borrows and keep the borrorchecker happy. 
&gt; I think the inverse is true: Javascript programmers should not have to know what Rust is. whynotboth.jpg Just to clarify something: wasm-bindgen started with the goal that you should be able to compile a Rust library, and then use that Rust library in JS without even knowing that it's using Rust. So I think that use case is already pretty well handled. So the only use case which isn't handled well right now is being able to create a 100% Rust app. Hence the OP's post.
&gt; be the absolute cutting edge when it comes to Web Assembly, we should be thinking about being the 1st to satisfy web atomics and the 1st to satisfy WebIDL in the most official way possible Good news! That's already happened: https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html As for WebIDL, that has also already happened: https://crates.io/crates/web-sys Yeah, that's right: wasm-bindgen supports almost all of WebIDL. The bindings are automatically generated from official WebIDL. &gt; Web Assembly front end should be built ENTIRELY with a Rust toolchain. NPM should have no place in the future development of Web Assembly based front end. Rust programmers should not even have to know what Javascript is. stdweb, wasm-bindgen, and wasm-pack all support a "no NPM and no bundlers" mode. I disagree that NPM has no place: there are situations where you *do* want to use NPM. But I agree that it should be very smooth and easy for Rust devs to get up and running without worrying about the JS ecosystem. &gt; I think a documentation effort to become a web programmer entirely from the persepective of a Rust developer needs to be made and should involve no Javascript Absolutely! I am also a very experienced JavaScript dev, and I've long thought about writing some sort of blog/book. I think it's a very good idea. &gt; I think Async/Await needs to be finished as soon as possible so paradigms can be finalized. Trust me, they're pushing for async/await as fast as possible. It's already very usable on nightly, and they are working on stabilization. &gt; I would love to see an implementation of Rust based Web Components come to fruition. Web Component allows for other language implementations of front end technology ( javascript or other WASM language front ends) to utilized Custom HTML elements written in Rust. I see current front end Rust implementations as isolating and ignoring some of the upcoming advancements of browser tech that might be exploited through WebIDL (i.e. template string enhancements that are being used by lit-html ). There is some work being done on that. Personally, I'm not very enthusiastic about web components. They seem like a limited and bloated half-solution (just like most things on the web). There's a reason pretty much all DOM frameworks have gone the Angular/React/Vue/Ember route: because it just works better. Having said that, I agree that it should at least be *possible* to create web components in Rust.
I'm more of a lurker than an active contributor, but I'm from Nebraska as well.
&gt; As much as I wish WASM to come to mainstream as soon as possible - I've got a feeling that there's not that much momentum behind WASM - or maybe it's only the usually slowness when big players need to agree on a standard. Mozilla seems to be the biggest driver. The MVP is long ago ... In my experience wasm has a ***lot*** of momentum. It's just that as you said, standards committees move slowly. But the Rust Wasm team is very excited by multithreading: https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html We're tracking the multithreading progress closely, and we do give feedback to the wasm group and browsers, to ensure that the multithreading is as good as it can be.
Yeah, it's possible. Serde already handles the serialization stuff, so you just need an abstraction that will handle the HTTP (or WebSocket) stuff. It should be doable with some macro magic.
Indeed. And that weirdness is in a sense essential: Result is not an exception. So I feel uneasy about syntactical sugar that pretends Rust has exceptions. 
3k hour Rust player btw
Damn. I'm jealous of Boston right now. I wish there were so many Rust jobs in the market in the Bay Area.
Just yesterday, I programmed a Mandelbrot visualization in rust. That was a fun little project. It can be used to get into gui and game development libraries with 2d pixel graphics.
I think your workaround, which I also use, is a reasonable compromise. I personally would rather continue to do it that way than complicate the language with another feature.
If *everybody* had a borrow checker running (accurately) in their head when they wrote C++ I'd be a lot more interested in dealing with the language. A lot of Rust's features are there to protect you from other people's code. I am willing to put on my straitjacket to prevent getting shot in the foot by others. (Of course, I'm occasionally "other people" too, so the straitjacket is even easier to tolerate.) This is why `unsafe` (AKA "sort of C mode") is considered so suspicious in Rust libraries: somebody took their straitjacket off. We were talking on another thread about what the `unsafe` keyword should have named been in a hypothetical better universe, and my favorite replacement was `trustme`. After 30+ years of C programming I now see C and C++ programs as a giant `trustme` block.
I think `let foo_ref = &amp;foo` is the exactly right way to do it. I also happen to think that we shouldn't bother complicating the language by adding explicit capture lists; it will be a syntactical kludge that doesn't add any expressiveness. However, regarding capturing `self`, I think we should drive [https://github.com/rust-lang/rfcs/pull/2229](https://github.com/rust-lang/rfcs/pull/2229) into completion.
Thank you, this is exactly what I was looking for.
wtf?
Those are all great suggestions worth considering.
Squatting doesn't become "the process" simply because some bad actors do it. It's anti-productive as evidenced by your pain of having your name squatted. If you truly wanted to remain productive, then rename your unpublished project and move on.
I never did particularly like or dislike your writings and comments, but to me, the greatest reason why Rust has reached its current level of popularity today is because of your massive evangelisation. I have said the same thing many times before as well. I think Mozilla is making a big mistake letting you go on such terms. I don't know if Rust will take a beating now that it's garnered a sizeable community, but you never know. Some items that you posted are unacceptable, especially with regards to salary. I had always imagined that you would be getting paid in the top bracket considering your contributions to making Rust popular. That's really bad. In any case, good luck, and all the very best for your next endeavour! Hope to see you around. Just curious - where would you be usually hanging out on, in case something interesting (work-wise) pops up?
We have many laws in place preventing people from doing things not because if a few people do it then it's problematic, but because if too many people do it then it becomes problematic. If a few people decide to squat, there's only so much damage it can do. But when the "good guys" try to be "proactive" and engage in the same behavior that pained them in the first place, then the total pain becomes incomparably amplified.
Your code seems to be an instance of [this issue](https://github.com/rust-lang/rust/issues/40307). When returning a borrowed value, in some cases the borrow checker sees that value as living for the rest of the function, even if it shouldn't due to an early return. There are two ways to fix this: 1. [Use the `Entry API` from `HashMap`](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry). 2. Switch to the MIR-based borrow checker (NLL) by using the 2018 edition. This bug doesn't seem to appear with it.
Or you can design a system correctly and prevent it from ever happening in the first place. Why rely on the good nature of people when you can easily just use a different system that circumvents it entirely?
I think the core team will have to vote on the 2019 Roadmap to-be-written RFC. [Just like with the 2018 Roadmap](https://github.com/rust-lang/rfcs/pull/2314#issuecomment-363252257)
I believe the casts could also (mostly) be resolved using sufficiently clever const generics, and some (limited) compile time evaluation. If `Number&lt;1..10&gt; + Number&lt;1..10&gt;` would be defined to become `Number&lt;2..20&gt;`, it would improve both safety and ergonomics.
Here’s a useful crate: https://docs.rs/taken/
QT has a huge build and interface complexity due to having a C++ API. What exists is rather difficult to use if you even get it to compile. Azul/Conrod both are unfinished and honestly IMO not likely to ever reach proper usability. Both are developed by lone star developers and the job is too large for any single person.
The `Future` trait has been modified to use only a single `Output` associated type, so `async fn f() -&gt; Result&lt;T, E&gt;` translates to `fn f() -&gt; impl Future&lt;Output=Result&lt;T, E&gt;&gt;`. This is simple enough that `?` needs no special handling in async functions.
I recently wrote a 2048 clone in Rust that I transformed into an open source project for Rust beginners. See [A work in progress 2048 clone invites beginners to contribute](https://old.reddit.com/r/rust/comments/acbfzz/a_work_in_progress_2048_clone_invites_beginners/) and the Github repo [rs2048](https://github.com/KappaDistributive/rs2048).
Thank you for everything! 
`return Err(stuff.into())` is indeed annoying, which is why various error handling crates provide an equivalent `bail!()` macro. Perhaps there's an argument here for making such as useful macro available in the stdlib, say as `throw!()`. Point being, there is no need to a blow a whole new reserved word to implement it
There are many questions to ask to determine what might be best for you. But simply, to keep it lightweight, if you want HTML/JS UI but don't want to carry the disk burden of Electron you can leverage things like the [webview bindings](https://github.com/Boscop/web-view) to leverage on-OS browser engines (Windows is still just IE, but Edge API compat is coming along at some point (underlying Edge engine change shouldn't affect it)). But that still has runtime weight. Qt widgets are where it's at for large desktop apps, but yes bindings often leave a lot to be desired especially given the often need to subclass C++ classes. You could go the QML route or the C++ route and connect over C FFI to Rust. There are other [some bindings to libui](https://github.com/LeoTindall/libui-rs) which is a promising-yet-slow-to-mature C API to a minimal set of desktop widgets. You can also go with a ugly-outside-of-nix GTK binding. In general, Rust and other languages suffer from lack of cross-language and cross-platform desktop GUI libraries these days. The [awesome list](https://github.com/rust-unofficial/awesome-rust#gui) has plenty of other options I didn't mention, but again, everything has its tradeoff.
FTFY: `v.iter().sum()`. (`.cloned()` is not needed here due to [`impl&lt;'a&gt; Sum&lt;&amp;'a f32&gt; for f32`](https://doc.rust-lang.org/std/iter/trait.Sum.html#impl-Sum%3C%26%27a%20f32%3E))
That's my last section. If we reorganize the tarballs so that you don't have to run `install.sh`, we can still leave it in there for people who are relying on running it (or want to do some of the other things `install.sh` lets you do, like specifying individually where binaries/libs end up)
You should take a look to [relm](https://docs.rs/relm/) I was looking for the same thing to replace an electron app (Insomnia) because it is really slow to boot at the end, it consume to many RAM. And to many click for my usage. I've start building a tool, I am using every day, using relm and I am happy with it. I've fix what Insomnia angry me. (It is less feature complete of course) It is on my github account here: https://github.com/mardiros/rustaman Fill free to take a look at my code to see a more advanced relm app with many components. I prefer to keep rust stable so I don't use nightly features. And I am not an expert, maybe I do some stuff the wrong way :) 
If you're considering conrod, you might be interested in checking out [nannou](https://github.com/nannou-org/nannou). It's kind of like conrod but with all of the choices (like which graphics backend or how to make an efficient event loop) are made for you. There's a [simple_ui example](https://github.com/nannou-org/nannou/blob/master/examples/simple_ui.rs) that gives a demo of a very simple UI. It's worth noting that there's [quite a large release imminent](https://github.com/nannou-org/nannou/pull/240) with quite a few breaking changes, so if you're interested you may wish to wait for that.
I think the key point here is _efficiency_; we would want the lion's share of any funds to go directly to salaries of key technical people (and this totally includes the often-underappreciated area of documentation) with as little overhead as possible. There is a tendency for foundations to become self-sustaining organisms that _incidently_ do some useful work - it's almost a biological imperative with organizations. Better to have a well-regulated scheme where a company can fund a fraction of the salary of a core dev directly.
There is no danger in the code as-is. But there is (at least) one good reason to make `if let Some()` a habit for this kind of code, and it's got to do with maintainability. As we already stated, `if a.is_some() { a.unwrap() }` is perfectly safe, but it does contain an implicit, non-obvious dependency between the `is_some()` and `unwrap()`. Some day, your sleep-deprived poor colleague on a deadline might have to modify the code, missing the dependency: fn other_non_trivial_function(a: &amp;mut Option&lt;u8&gt;) { *a = None; } if a.is_some() { other_non_trivial_function(a); println!("A is {}", a.unwrap()); } This code will now panic on `unwrap()`, without the compiler saving your colleague. However, in the `if let Some()` case you will get a compile-time error alerting you of the problem error[E0499]: cannot borrow `*a` as mutable more than once at a time if let Some(a_unwrapped) = a { ----------- first mutable borrow occurs here other_nested_function(a); ^ second mutable borrow occurs here println!("A is {}", a_unwrapped); ----------- first borrow later used here } This is why `unwrap()` is viewed with suspicion in production code. Maintaining the implicit external conditions that ensures safety is simply error-prone over time.
I'd vote for `holdmybeer`.
The roadmap is a RFC that the core team decides on: https://www.rust-lang.org/governance
Heh, I first read that as 'horrorchecker'. Totally agree. The problem is that old habits die hard, so we shove all our data in a struct and then cry because we can't split the borrows in mutable methods. We then refactor into happiness, and in time learn to compose structs for maximum flexibility. 
Well both the package managers and the build systems came out more or less sequentially, so they were all indeed new and improved when they came out. :D The thing is before opam and jbuilder none of them were good enough for universal* adoption. \* opam really is universal these days. As for build systems, there are many older projects that still use the older ones, but I think anyone starting a new project would either use dune or use handcrafted makefiles.
Your JS `removeHead` is buggy (or at least has different preconditions than the Rust code, but given the conditional in the last line of the JS version, I'm going to say it's a bug): if the list is empty, `this.head.next` throws a `TypeError`. That's why the code looks different. It also shows how Rust protected you not just from memory errors, but from null pointer errors as well, by forcing you to explicitly branch on the null case. You could use `std::ptr::NonNull` instead of `*mut`. Since you put it in an `Option`, you don't need the pointer to be null ever, and this reduces the size of the field to just being a single pointer instead of needing a separate flag. `contains` doesn't need to take self as `&amp;mut`. It doesn't modify the list. Pattern matching on options is usually made much prettier by judicious application of `as_ref` and `as_mut` on the owning options. I've created a playground with all of these changes applied: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c3afae12f93cbaf3cd18b60ac3dac4eb
Long time ago Mozilla planned to add an API to Firefox to integrate social media, and Facebook was a the first target. But this project has been dropped long time ago.
Interesting. Can you please give any examples?
Nitpick: wouldn't `Number&lt;1..10&gt; + Number&lt;1..10&gt;` become `Number&lt;2..19&gt;`, since `..` is exclusive on the upper bound?
It was another top suggestion. I'm fine with either.
I was struggling with this for like an hour yesterday. I was trying to get a \`channel\` transmitter inside a \`par\_iter\` \`for\_each\` loop so I could send some shit and ended up giving up. If anyone knows how to get this done it would be a miracle for me.
Thanks for closing [an outstanding bytecount issue](https://github.com/llogiq/bytecount/issues/41)!
This was requested the other day, so I wrote up a somewhat informal overview of how `generic-array` works and what we have done to make it as safe and efficient as possible. If there is anything you don't understand, errors I made, or things I could word better, feel free to make suggestions on the [associated issue](https://github.com/fizyk20/generic-array/issues/68)
I have tried Tk. It is not the coolest UI library in the market, but there are many widgets to choose from, and, since it is written in C, it is simple to interface to. Another alternative is to have you app run as a web server and launch a native browser that connects to it at startup. There is work being done to provide a FFI to Dart that is compatible with C, so maybe later this year, Flutter may be an option.
That's the very essence of being data-oriented!
I've experimented with this over the past few days; have a quick+dirty approach where frontend and backend crate both call a third crate that holds the data structs.
safe **and** doesn't have any errors????? :O
Advent of code [https://adventofcode.com/](https://adventofcode.com/) &amp;#x200B; At least to me (frontend dev by day) it's the best thing that has ever happened to my programming skills since I started learning programming.
Thanks for your input! I'll look into the no\_std options. About the rng: for now this are only bindings, but a higher lvl api is on my todo. I'm thinking about using the rand crate for that.
That would be great but, the current Const Generic proposal don't plan to go that far.
Thank you for the suggestion and the code, I'll look into when I'm building the high level api for which I'll need the rng.
Nice work! Looks super handy. How confident are you that the deletion operations are well tested and safe (just want to check before I go running it with wild abandon)?
I don't know how much it would cost, but I'd be willing to contribute some money.
Thank you Steve and good luck!
You can run `cargo cache --autoclean --dry-run` which prints what would be deleted.
* [https://github.com/atom/xray](https://github.com/atom/xray) * [https://github.com/denoland/deno](https://github.com/denoland/deno) * [https://github.com/facebookincubator/fastmod](https://github.com/facebookincubator/fastmod) * [https://github.com/projectatomic/rpm-ostree](https://github.com/projectatomic/rpm-ostree) * [https://github.com/joyent/statemap](https://github.com/joyent/statemap) * [https://github.com/facebookexperimental/mononoke](https://github.com/facebookexperimental/mononoke)
Glad you could use it :)
I don’t think we want to be building GUI applications in rust. But what we very well might like is to build a GUI *platform* in rust, that could be bound to v8 or luajit or an embedded PyPy. 
I would assume they mean "doesn't have any errors" as in "compiles" (since that's what they're troubled with) and "safe" as in "no unsafe" (as that can be used to cheat the borrow checker… at the cost of making the program implicitly broken through UBs).
Curios that clap is so huge. 
Good luck in your future endeavors, Steve!
Have a look to gtk-rs. GTK+ is a mature toolkit and I find it much more elegant than other options I have checked so far. &amp;#x200B; GTK+'s main drawback has been, IMHO, subpar support on windows, with an unclear packaging (or building) story and a rather old default theme on that platform. Both of these are mainly documentation problems and you can find how to solve these problems on the internet. &amp;#x200B; Also, it's not an all-in-one solution as QT (which bundles its own sound, DB or even browser components), so you need to take additional pieces depending on what you intend to do. This can also be seen as a plus, because it's quite lightweight, and these components could be replaced with more Rusty ones in some cases. Another nice plus it that is built in C and has good bindings, so it's easier to integrate with Rust than other C++ solutions. As far as I can tell, the Rust bindings mainly lack ergonomic improvements. Callback closures are a bit annoying to write due to the need to clone references all the time to appease the borrow checker, and something similar happens with the usual shared global state (your appstate), so you'll see a workaround using Rc&lt;Refcell&lt;Model&gt;&gt; to cope with it. Relm tries to improve on this using a reactive pattern and may be a nice choice too. 
really nice writing style, and great pitch fr yourself. You should have something like this on your cover letter
Opam was really nice! I really have no complain about it :-) the things that were hard for me were: - scoping rules when importing opam packages, - declaring dependencies, - folder hierarchies for multiple executables, - splitting a library or an executable in multiple files My problem was that different tutorial were wildly inconsistent and that my use case was maybe unclear to me too. If I wanted to link C libraries OMake would have been perfect but I was searching for something like `cargo run` :-) (I suppose dune provide that, with dune I had problem when importing opam packages... I don't recall the particular problems)
Of course. Reddit should not allow me to post before 10 am
There is also [nuklear-rust](https://github.com/snuk182/nuklear-rust) which is a Rust binding to the single-header [nuklear](https://github.com/vurtun/nuklear) library written in C (ANSI)
Uh I'll check it out
More info on it? Which libraries exactly? 
&gt; How does Cabal resolve the issue of stale, unmaintained packages? Eg, something depends on A-1.0, but it will work with A-1.1, yet because the maintainer is gone it cannot be updated. That's literally the purpose of a dependency resolver
I am currently learning Rust by creating an Html5 parser that produce a read only document which can be queried with CSS selectors. Hppy: https://github.com/ducdetronquito/hppy The project is few days old, and I am planning to ask for a peer review from /r/rust in a week or two, when I will be more comfortable with Rust. Good luck to everyone for your own project :)
Saw somewhere that Aaron Turon is current project leader
Just namespace the damn thing already and don't force the stupid reverse DNS shit on us. Let us choose what we like. I would simply use my nickname or my parent project as a namespace. And once a namespace has been used, assign it to me and only me. Assign me a default namespace as well, using my login ID. Also allow sub namespacing.
Throwing in a personal vote of thanks + sadness. You have helped immensely in my journey with rust. 
Just a quick FYI: the fenced code blocks (those using triple-backquotes) do not work for users still on the old Reddit. Only the indent-by-four code blocks are supported.
You still haven't left the note
When did I ever oppose changing how the system works? I fully agree that a technical or social solution to the problem is appropriate. I am only drawing a light on this hypocrisy: criticizing people for engaging in destructive behavior and then using that as justification to engage in that same destructive behavior.
&gt; On the Mozilla side, I’ve been managing the Mozilla Rust team for a couple of years now. &gt; On the Rust project side, @nikomatsakis and I jointly lead the core team, but not in any formalized way; we operate by consensus. https://internals.rust-lang.org/t/farewell-rust/5776/7
I think that's one aspect. The other aspect would be that once there's money at stake, people can have very strong feeling about where that money should be spent, and get quite upset if it's spent differently.
If you're in a loop, then you'll probably need to clone the transmitter for every iteration. So maybe something line `let tx = tx.clone()`. If you can post some code, then it will be easier for us to help you.
Yeah there are definitely a few of us here in the Boston area who use it for work
Per cratesio policy it is allowed. See their responses in the top level comment above. It's first come, first serve, and they don't address squatting. So why not be first?
what about an emulator for something like chip 8?
Another promising GUI library is [OrbTk](https://gitlab.redox-os.org/redox-os/orbtk). It is developed as part of Redox OS but is cross-platfrom.
Mh, I'm already using ```` for the code blocks. What are indent-by-four code blocks?
1 - that sounds great 2 - do you have resources on chip 8? 3 - does a project like this teach me on the "weird pointer types" of Rust? Like Arc etc
&gt; as the compiler can't figure out that &amp;foo inside a move || closure was intended to capture foo by reference and not by value So that's why my code was not compiling! I thought it was just me. Isn't that actually a compiler bug?
four spaces instead of backquotes
I'm sure Shepmaster will read your comment. It would be useful to have more details about what didn't go well.
Susan G Komen
Don't church numeral style encodings in type systems usually balloon compile times though? I know there are similar packages for Scala and compile times rapidly balloon as N increases.
Yes, I kind of wonder that with this outpouring about Steve's efforts, others might be feeling forgotten. There are a lot of people putting serious time and effort into supporting Rust both on the community-facing and technical sides, paid or unpaid. Thanks to them too for their continuing work.
Yeah yeah yeah.
naw, there's huge potential here. cross platform native gui is one of the main uses of c++ and rust can take that over main problem right now is nothing is mature except gtk, and gtk doesn't give two shits about looking native or packaging easily for windows. Qt/qml would be ideal. guis are a HUGE problem and putting the work into qml bindings will pay off tenfold by coopting the decades of development that went into Qt, comparing to reinventing this
Whoa, that's awesome - will `Box` still be needed though? I assume this is futures `0.3` you refer to, I'll have to look for 0.3 support in Hyper. Thanks!
r/playrust is where you should be.
Rust even works on very constrained embedded devices like the STM32F4DISCOVERY with 1MB Disk, 192KB RAM, 168MHz CPU. ^(What you're probably looking for is) /r/playrust^(.)
Ok thanks, done. I hope this works for everyone!
For extra security I'll try to add a wrapper that honours `--dry-run` around the `fs::remove*` functions and make it the only function that calls fs::remove itself, all the other functions will have to to call the wrapper. It would be cool to have tests that assert this is really the only function calling `fs::remove` but I'm not sure if this is easily feasible.
A looooong time ago I asked about this very same question (related to how C++ does capturing) and I got an absolutely amazing answer: https://old.reddit.com/r/rust/comments/46w4g4/what_is_rusts_lambda_syntax_and_design_rationale/d08hee0/?context=1 Well worth the read!
I was using Piston. I just took this example and started hacking on it: https://github.com/PistonDevelopers/piston-examples/blob/master/src/paint.rs
I don't have much to say about this, other than that I am wholeheartedly in support of pretty much everything that you've said.
Writing `&amp;foo` accesses (and moves) the value of `foo` and creates a reference to it. That's why you have to take `&amp;foo` outside the closure if what you want to move is the reference. I think that's consistent and relatively easy to grasp; having `&amp;foo` not move `foo` would be confusing IMO.
&gt; Succinct names like "algorithms", i.e. the kind that people like to squat, lend credibility to packages that might be unearned. The connection to squatting seemingly that you believe that if names are squatted and sold, the buyers have a higher chance of being malicious. yes, that accurately sums up my opinion &gt; Whether or not moderators would remove squatted packages, anyone could choose to upload malicious code into a package with a succinct, trustworthy-sounding name, and then work to get it included in other code bases. To me, the latter part, the work to get it included in other code bases, is the security threat, not the squatting. this is true. In practice, a package with a succinct/good name that has been actively developed right from the time it was created has a much lower chance of *being created/developed* with a malicious intent. That's the only subset I think preventing squatting will eliminate. I continue to think that the benefits are much greater than the costs &gt; but I'm also going to look at documentation, blog posts, etc. I'm going to see a bunch of websites for a bunch of frameworks with people discussing them, and web, an astroturf package, is not going to appear in them That's fair. It's also the ideal way to do it. There are, however, people who first use the crates to see how they work out and *then* look at the docs if the initial experience is good. Their dev environment (which sometimes includes keys, etc. in env vars or in files in standard locations) could get compromised in such cases. It's not as bad as in npm (where pre/post install hooks alone can do the damage) I think but it is a possibility. &gt; It's possible to make web convincing, of course, by getting it into these posts, but the kind of coordinated effort that be involved to get it into the hands of well-known Rust programmers and then into these posts seems large and ultimately distinct from the fact that web started as a package squat It'd be reasonable to assume that anyone willing to buy a package name with malicious intent is willing to go the extra distance to make it appear like a good alternative. &gt; Others have proposed solutions to name squatting that, orthogonally, provide mechanisms for the curation of "approved" packages or something. For example, the proposal to mirror Docker and namespace all packages with a mechanism for lifting curated packages into the "global" (i.e. unprefixed) namespace. I agree that package curation efforts can prove helpful in increasing confidence in the package ecosystem and reducing the likelihood that people adopt malicious packages (at least when well-known non-malicious ones exist). Yeah, I've read the related posts. This definitely seems to be an ongoing issue. I also understand that it's not a simple one to address with resources not available (curation/moderation are time consuming). One way that seems reasonable is to use java like namespaces (I just read about that in this thread and it sounds like the best option). In the absence of something like that having strict requirements for registering package names might be the best option that requires the least resources.
I remember your post coming out a little while ago. It was really helpful, and I bought a handful of black pill boards because of it.
As I understand it the EU is already funding RustBelt.
I'm not ready but I'm closely watching this qml binding generator https://github.com/KDE/rust-qt-binding-generator
Yes, we are working on reading people’s posts and thinking about a draft of said RFC now.
Nice design. I’m still a bit peeved about most traits not being implemented for arrays of length greater than 32, and this is a nice way to work around this issue until const generics land. One question. It wasn’t clear from your write up if the struct definition uses #repr(packed) If it doesn’t, wouldn’t it be possible to land in undefined behavior when creating the slice?
Like many things, it makes sense when you understand it :-) I don't recall this being stated in any of the docs or books I have read.
&gt; I've personally been part of two different EU-sponsored projects related to software development I'm curious how you found it? We did an EU-funded project and it was a nightmare buried in bureaucracy. &gt; One of the Swedish regions even provides grants to fund the actual process of applying for EU funding! ! 
Yeah dune can do all this (though in a quite opinionated way). The equivalent of cargo run is dune exec. Normally adding a dependency consists in adding an item to the libraries field in your dune file, I don't know what might have gone wrong for you.
as someone who uses this technique a lot, it doesn't seem hard to understand at all. can you explain in more detail what is confusing to you about it? 
I've started learning Rust with AoC2018. What I've found is that AoC is an incredible opportunity to bootstrap the learning process of a new language but, very quickly, falls off in value. You probably get the most bang for your buck if you do only every 4th day and then move on, leaving the rest of the problems for lazy evening in front of the TV.
It happens to be that I talked about this with a couple of others just a few days ago. Would you be interested in helping making this happen or do you just want to throw it up in the air?
If you like it subscribe:)
Same problem [I mentioned for dirstat](https://www.reddit.com/r/rust/comments/ad978c/just_published_dirstat_a_simple_cli_to_show_disk/edg5v0n/) - `metadata()?.len()` returns logical size, not physical. This will give misleading results on systems with filesystem compression: -% du -hd1 ~/.cargo 153M /home/freaky/.cargo/bin 1.0G /home/freaky/.cargo/registry 108M /home/freaky/.cargo/git 1.3G /home/freaky/.cargo -% du -Ahd1 ~/.cargo 325M /home/freaky/.cargo/bin 1.4G /home/freaky/.cargo/registry 111M /home/freaky/.cargo/git 1.8G /home/freaky/.cargo
I would love a native Postman/Insomnia replacement. I've thought of jumping in on this myself and never had the time. I'll check out your code later today and see what you have.
You’re looking for r/PlayRust.
I think what you are describing sounds a lot like the "rust by example book" https://doc.rust-lang.org/rust-by-example/ and https://github.com/rust-lang/rust-by-example. There you will find sections and executable examples a plenty. 
I don't think you can....
There's several reasons I don't think both are feasible. It _might_ be a neat thing, it's tougher to sell than "here's the thing we know (LLVM) and here's the hole we know the size and shape of (a missing target)". Rust/WASM-&gt;C is a neat implementation, but WASM isn't meant as intermediate code. It might or might not evolve to that, but that's a bet. Also, it need to be throughly checked if the emitted code after compilation from C fits quality expectations. That's a lot of layers in between! And every layer might end up not _caring_ about your usecase. cranelift similarly is a great project, but it going somewhere is also a bet. It also has a long way to go until it optimizes well and generates the code your want. That said, I believe moving beyond dependency on LLVM is inevitable at some point in some way, but I'm not sure the time is now.
As someone that have review UI toolkits for several Langs and platforms, I advice you to list all the controls and features you wanna have. An pay special attention to the most complex controls. For example, I need grids/datatables and very good looking edit forms, with good error reporting and bindings. &amp;#x200B; You will be surprise how few toolkits are truly decent. Even among html/js one. Also, pay attention to performance. For example, I need fast scrolling/rendering for 1000 - 30000 items at least. You will be surprised how few controls are made for performance. &amp;#x200B; \------ One idea that I thinking after using a light web view + vue for a cross platform app (and regretting it) is to use native UI kits and put a messaging layer between the UI and the logic: &amp;#x200B; [https://www.reddit.com/r/rust/comments/9bapwt/thoughts\_on\_what\_a\_good\_gui\_system\_would\_need/e51o6mw/](https://www.reddit.com/r/rust/comments/9bapwt/thoughts_on_what_a_good_gui_system_would_need/e51o6mw/) &amp;#x200B; &amp;#x200B;
This isn't a simple church encoding; that is linear in n. Typenum uses a binary encoding.
One of the benefits of Rust is that you can use C bindings. :)
I've been really interested in understanding how to bridge this gap. I wanted to build a set of video tutorials that would build some real world application with each chapter highlighting an area of learning in Rust. I don't believe this is anything new for programming tutorials but for Rust I have struggled to find good material (that or I'm not looking hard enough). I find my best learning comes from seeing people work through problems. I would love if I or someone could help with that as I share the same view as the OP. The tutorials would be geared towards people who have made it through the Rust Book and now need to apply what they have learnt.
I don't want to say anything personal. Because we are all real people behind these keyboards. But create an account, ask anything about Rust, Shepmaster will find something wrong with your question and try to delete it. Even if nothing is wrong, as with my last question he will just mark it as duplicate. He doesn't make any effort to actually answer the question, or even understand it. This is usually after an actual helpful person answers the question. No other language has this problem with a moderator. I have to ask my questions on reddit because he won't stop. Every single one of my questions. It's so bad I stopped using stack overflow. 
Webview definitely looks promising, assuming it is actually significantly smaller than electron. I am not sure how much I want to do web based guis, but it is for sure simpler than most of the rust implementations currently.
You can start by making tutorials on confusing things about Rust!
Just today I was reading the elite orange website and somebody was talking about a project where qml code was written in rust and not JavaScript
The Rust team does not have a lot of huge fans of BDF(some period) style. We have a process for finding goals and teams to ensure that the goals are met.
My app should be pretty small and not actually require super good performance. As for functionality required, perferably actual menu capabilities, buttons, dropdowns, textboxes, ability to make graphs(or at least draw lines so I can make graphs myself), save to local storage. It will basically record information and make varied graphs on request and show statistics. Also, I like your gui ideas.
So much native gui is written in C or C++ so I definitely agree with you and feel like rust has room to grow in this area.
Probably true but rather depressing.
do you have a link?
Yeah, that was heard from fellow researchers in the department. EU H2020 projects are a bureaucratic nightmare where the goal is to produce the biggest reports possible once every month.
Another one that is not ready yet but I would consider promising is [druid](https://github.com/xi-editor/druid). It's currently Windows-only, but I am in the middle of making its 2d graphics [cross-platform](https://github.com/linebender/piet).
I didn't mean to sound condescending or anything; I just wanted to point out why this is the consistent behavior, and as we know inconsistencies lead to surprises, and surprises are bad for understanding code. It may well be that this needs better teaching. 
Your talking about a free service that is run by volunteers. A group of volunteers that is openly interested in having new members join. If you are compelled to make some change, there are better avenues than posting about it on reddit.
LOL fucking nerd get ark
btw this sub isn’t for the game rust lmaaaao
You were always fighting an uphill battle. It's really hard to produce quality documentation and teaching materials for a language in constant flux. For an open source project with limited resources it's even harder. Your constant outreach to the community all everywhere (Hackernews, etc) definitely brought a lot of people to Rust. Also, there is a lot of work to do on documentation, so I hope somebody will step up to fill that void. Much success on your future endeavors. 
I believe [servo/webrender](https://github.com/servo/webrender) of HTML+CSS components will be the next desktop application development environment. Therefore, the local webserver backend and web framework for this development is the big open question, ie [arewewebyet?](https://www.arewewebyet.org/)
Is there any reason why these need to be separate processes, as opposed to running the workers in different threads in the same process? If you used threads, then you could use channels (such as [crossbeam-channel](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel)) for the communication. If you really do want a separate process then you could consider exposing an HTTP api, perhaps using [hyper](https://github.com/hyperium/hyper). I *think* this ought to be faster than using a temp file, as it would bypass the disk.
I wouldn't call this a Rust-specific question per se. Your options with Rust are going to be basically the same as your options with Python or C, since it boils to the IPC facilities that your OS provides. Using a file is reasonable. If performance is an issue, you can just set `check_interval` to a relatively large value. The big upside of using files is that they're simple, and you won't really have to worry about any platform differences. Using a pipe would be another option. This is easy when one process is the parent of the other, because the parent can pass pipes to the child. That's not the case here, so you'd have to reach for something like `mkfifo` on Unix and `CreateNamedPipe` on Windows. (Various Rust crates are available for wrapping those APIs, like `nix` and `named_pipe`.) You'd also need to figure out some way to alert your runner loop when a message is ready on the pipe. The easiest way is to have a separate thread reading the pipe and then setting some kind of shared flag, but you could also consider doing non-blocking reads from your single thread (again contending with the relevant platform differences to set pipes to be non-blocking). Using a TCP socket locally would be similar to pipes, though perhaps the platform APIs would be more uniform. On the other hand, you'd need to somehow communicate the port number you're using to the other process, and if you're using files to do that it might be simpler to just use the entire file-based solution you were thinking about at first. My instinct is to stick with files unless you run into some kind of problem in practice.
This is how I understand it as well.. If you compile with rustc &gt;1.30, you are using 2018 edition with no extra thought required. Please correct me if I have mistaken this.
The companies I know that get significant income from EU funds treat it as a cash for papers game. Their business model is to get EU funds not produce actual products or research. 
Don't worry, I didn't take it as such, and your explanation and the one at the link posted by /u/RustMeUp both help with understanding what is happening. My misunderstanding is that I believe there are two ways of thinking about a `&amp;foo` inside a `move` closure and they are both **equally valid** - at least from a beginner perspective. I was assuming 'a reference to foo is moved into the closure' whereas you are saying 'foo is moved into the closure and then a reference taken'. And I am sure there are valid reasons for that. I definitely think this ought to be spelled out, maybe I will raise a PR.... In the Rust Book for example you have to read virtually all of this massive page before it even mentions `move`: https://doc.rust-lang.org/stable/book/ch13-01-closures.html Also I am just reading O'Reilly's *Programming Rust* for about the 4th time, and I don't recall seeing this technique mentioned. 
That is what Azul is based on.
&gt; where would you be usually hanging out on, in case something interesting (work-wise) pops up? email is the best way to get in touch for that kind of stuff, steve@steveklabnik.com &lt;3
seconded
&gt; If you are compelled to make some change, there are better avenues than posting about it on reddit. Could you give an example? If the problem stems from a policy, one which was unilaterally imposed by those running the show, how would you go about changing it? Mind you, I'm not specifically talking about crate names here, but more about decisions and policies that are imposed without real community involvement. Decisions like the new website where the majority of feedback was simply discarded. In situations like this, I think it's very reasonable and fair for people to complain on reddit.
How does it get the HTML+CSS?
beautiful :)
That is just another pointless electron flavor
&gt; Using a TCP socket Since they note it's a unix cli, they could use unix sockets. Doing socket-like machine-local IPC is exactly why they exist.
So, you want to develop UIs in something other than HTML+CSS and/or use a different renderer for GUIs than what the Servo project is working on?
Nope- `impl Trait` makes `Box` unnecessary. You'll only need it in cases where you're returning multiple types dynamically (not applicable to `async fn`, which collapses the whole state machine into one type) or recursive types (could apply to `async fn`, but only if you're trying to `await` across that recursion, which is probably a bad idea). Futures 0.3 is no longer where the trait is defined- it's moving into the standard library so it can integrate with the language. The crate will stick around to provide extra functionality that hasn't been moved yet, though.
It generates the HTML through rust. The CSS is added via file.
If it is html and css it is also js. Servo will never be seperated from js. So you can not use it for anything other then a pointless electron flavor. You can just use webrender which is something azul is doing.
What's pointless about it? 
I'd rather use [Tera](https://github.com/Keats/tera) to generate HTML. And I fundamentally favor "everything has a URI" at the OS level, similar to what Redox plans instead of "everything is a file" (kinda like what Electron does).
Just wondering, why do you think Azul will never reach proper usability? I've seen the GitHub and read about how much work needs to go in and how not-production-ready it is. Does the dev not accept help or something? I like the concept of Azul and was hoping it would advance over time into something good and useable, because of WebRender, and it's small and fast, etc.
Gui will not be written in rust but js. You can not seperate html and css from js in servo.
Just because it doesn't seem to be stated outright, can someone confirm if my understanding is right: The raison d'etre for this is to provide compile time assertions that operations on arrays are correct with respect to cardinality of those arrays (and, ostensibly, subsequent optimization benefits from said compile time proofs)?
Sweet. This is exactly why I lurk this sub
FWIW for progress-tracking a common protocol is to have it respond to a specific signal by dumping progress information on stderr. BSDs have SIGINFO specifically for that purpose, on Linux I think it's usually USR1 (though that's more risky as the default USR1 handler is to terminate the process).
&gt; If it is html and css it is also js. That's a narrow-sighted view, imho. iirc, there have already been two projects I've found on github to remove js or augment it at the IPC channel with Rust or another language for scripting. `&lt;script type=text/lua&gt;` is just another feature it could support, for example.
As somebody who has worked on a Horizon 2020 sponsored project, I would recommend trying to get on-board with Universities and the like, as well as large non-profits and companies such as Mozilla who are obviously already highly involved. I too see great opportunity for funding in Rust, considering it can be used almost anywhere. It's safe and secure and fast! My advice to you OP would be to try to flesh out an idea in relation to improving rust, yourself or with a few buddies and then get spreading! :)
Fair, you just would have to manually setup Tera with webview or webrender to make a desktop application from it.
This is kind of true... It does depend on the project but they seem to like their big reports and big meeting and fancy booklets, etc. Making real big headway in EU H2020 projects is... tedious at best, in my experience...
Ok, so, the font thing is no easy task but it looks like cairo is able to embed fonts in PS. It could do that for me. I'm now facing another problem: Unicode. I'm trying to read upon how to do Unicode but I'm confused. Looks like PostScript / Ghostscript doesn't really support it but I'm not sure. I'll try to look into how cairo does it. 
&gt; I think it's going to be challenging for Rust to adopt and embrace async, but Google's Fuschia operating system is doing some absolutely gnarly stuff with futures being a core part of the operating system. I spent a little while but was unable to find a specific link describing this. I'd love to read more about it -- can you provide a pointer? 
Personally, something like this: ```rust impl HelperHelperTrait for u8 {} impl HelperHelperTrait for u16 {} impl HelperHelperTrait for u32 {} impl HelperHelperTrait for u64 {} impl HelperHelperTrait for i8 {} impl HelperHelperTrait for i16 {} impl HelperHelperTrait for i32 {} impl HelperHelperTrait for i64 {} impl HelperHelperTrait for f32 {} impl HelperHelperTrait for f64 {} ``` feels considerably cleaner than: ```rust macro_rules! impl_helper_for { ($($t:ty),*) =&gt; { $( impl HelperHelperTrait for $t {} )* }; } impl_helper_for!(u16, u32, u64, i8, i16, i32, i64, f32, f64); ``` even if the former is a couple lines shorter
I don't suppose it needs to be a separate process. I'm wondering how you'd get the effect of the `myprogram progress` command above. I suppose I could leave the main process to display the progress in real time and catch `^c`, or keep a repl open.
And what happens when you need to do some kind of code or there is a lifetime change to the trait? Or a generic? 
&gt; setup Tera with webview or webrender to make a desktop application I see this is a backend vs frontend split. I'd rather generate the application code in the backend and focus on the rendering aspect completely within the client-side framework. The question of how to use Tera at that point is how well it can be integrated with general OS level features and data.
Is there something in std or a preferred crate for unix sockets?
IIRC there was a link on one of the RFCs for either async, pin, or futures. You'll have to dig through their source otherwise: https://fuchsia.googlesource.com/ Maybe ask some of the individuals involved with the futures RFC.
I worked on a number of H2020 over the past couple of years and we and our primary partners did lots of actual work. There is significant overhead, but whether that’s bureaucracy or because we are cooperating with some 10-15 international partners...
https://doc.rust-lang.org/std/os/unix/net/index.html
It wasn't part of H2020, but IIRC the pypy project benefited quite a bit from EU funding,
I wonder if we could scrape-up enough interested folk for a meet-up.
What are you even talking about, this is WebRender not Servo for starters lol
It is not explicitly packed, but is marked as `#[repr(C)]`, but even that doesn't seem to be required sometimes. I've tried to months now to get it to fail on oddly sized data, but it always seems to implicitly pack everything perfectly.
It's even simpler than that in the implementation, `O(bits(N))`, because types are only defined once, not for every "branch".
The reason for the crate existing? It's simply because Rust doesn't have compile-time const generics. `generic-array` is used effectively in the most popular Rust linear algebra library, `nalgebra`, for it's primary backing storage. The reason for this document is to explain how it works and the best ways to use it given the tools we have built. There are no rigorous proofs. I simply wanted to demystify a powerful tool in the Rust ecosystem.
I wonder how many PRs the official Rust repositories generate, just by themselves... *whistles*
How did you install Rust?
I used rustup, it was pretty automated
Which version, MSVC or mingw ?
You could join the crates.io team or the community team, complaining on reddit is fine but understand that no real change is going to come from it as it is not an official avenue of communication. 
It’s *almost* correct: rustc 1.31 can compile both 2015 and 2018 code. The default is now 2018, where in 1.30 it was 2015.
Not sure, how do I check?
What’s rustc —version —verbose print?
Working with a research institute is also likely to help with the overhead, since they’ll have experience dealing with the EU and with partner institutes. 
msvc
You are using the 2018 edition if either: a) you create a new project with the 2018 compiler or b) you opt in by using `edition = "2018"` --- The key is that projects previously using rust 2015 edition will continue to do so forever if no change is made, even compiling on newer compiles. The 2018 edition includes breaking changes, so it will always require an opt in to transition older projects to it.
Okay, so here's the deal: msvc's linker is called `link.exe`. cygwin *also* provides a program named `link.exe`, and so rustc is trying to call that random program instead of the linker. I don't use cygwin, so I'm not 100% sure what you're trying to do; if you invoke rust from powershell instead, it may Just Work. You also may be able to find the path of the real `link.exe` and put it before everything else in your cygwin shell and that may also work. Hope that helps.
I've seen C++ use `[&amp;]() { ... }();` to emulate block-expressions. Just like your example, it does work. It's also weird. I'd rather have proper support for it... ... however I am not sure `catch` is the right solution. Your example also allows using `return`, which is great to avoid rightward-drift, and `catch` doesn't help with that, so maybe what we really want is: let val = fn-block { let foo = bar()?; if (foo.is_done()) { return foo; } let foo = foo.move_it(); Ok(do_something_else(foo)) }; Where both `bar()?` and `return` short-circuit only the current block?
Yes, very true! If you get in with the right institute (esp. the tech savy ones) you could be greeted with a network of many organizations and characters. ofc I use the royal you lol
Nice! I tried something much simpler with `linked-array`, but this is clearly much more advanced and production ready. The auto-vectorization is absolutely incredible.
Hmm, sorry. I guess you've done the obvious "postscript unicode" search. I was using an old TeX font that doesn't directly support ISO-8859-1 either, so I was overprinting accents too. If you need more than 256 glyphs it looks like you have to use a filter to convert a bytestream into a series of glyph numbers or codepoints. When I was coding in PS I had a couple of tomes on it to refer to, but unfortunately they're in another country right now. I guess it depends on your font, whether the glyph numbers (which PS uses) are actually Unicode codepoints or whether the font uses a mapping.
Wow, that's definitely an odd issue. What do you mean by putting the rust link.exe before everything else in the cygwin shell? Also, I'm assuming simply uninstalling cygwin will get everything to work? Thanks
There is an order of magnitude difference between having all the components kind of working for trivial projects and having them working well enough that hitting issues in the framework is an unlikely event. Across all platforms and GPUs.
Yes, RustBelt is funded via an ERC Consolidator Grant. But note that there are multiple types of EU funding that work slightly differently. For example, ERC grants (e.g. RustBelt) are awarded to a single principal investigator, whereas FET or H2020 projects (as mentioned above) are typically awarded to a consortium of universities/institutes/companies. It would be important to select the correct type of funding. 
Possibly controversial take: there is no good option for native UI in Rust (I've written code to interface with the native layers, and it's not a simple thing to turn into a widely used project). Use WebViews for now and save yourself the headache.
As part of the PATH, the thing cygwin uses to find executables. But that only matters if you’re in the Cygwin shell. What shell are you using? And yeah, just removing it should also work, but if you’re using it for something else, that’s not ideal.
The cygwin installation includes something called "cygwin64 terminal", which uses bash
&gt; The default is now 2018... vs (from /u/daboross ) &gt; or b) you opt in by manually adding `edition = "2018"` &gt; projects previously using rust 2015 edition will continue to do so forever if no change is made double checking: is it really default, or do I have to specify it?
If you want to be fancy, you could use something like cap'n'proto here. Or maybe dbus.
For projects in Austria, I can really recommend [https://netidee.at/](https://netidee.at/). I think they are also sponsored by EU. 
Just released a new version (0.1.2) which fixes a panic that would occur when there were unexpected files in the cache directory (such as `.DS_Store` on mac os). Changelog: https://github.com/matthiaskrgr/cargo-cache/blob/master/CHANGELOG.md#version-012
Your main thread can spawn child worker threads and handle \^c and progress updates. The child threads can report their progress either with channels (crossbeam-channel as mentioned above or just \`std::sync::mpsc::channel\`) or by updating an atomic (\`std::sync::atomic\`) which the main thread checks ever x milliseconds.
In case you need help with handling the Ctrl+C signal, see this chapter in the CLI book: https://rust-lang-nursery.github.io/cli-wg/in-depth/signals.html
No idea why I'm being down-voted, but thanks for the response! I get what you mean, it's difficult to get it to a point where hitting issues is unlikely, and that's even harder across all platforms and GPUs as you said... So you're saying there's no chance, or that there needs to be a serious pickup development wise?
Found it: [https://github.com/rust-lang/rfcs/pull/2592#issuecomment-437695158](https://github.com/rust-lang/rfcs/pull/2592#issuecomment-437695158)
`cargo new` adds it by default now I think (but it has to be provided, the default is 2015)
You could also send the output to the syslog if e.g. the process doesn't have an stderr (because it's a daemon), and use `kill` to send the relevant signal to the daemon in that case.
I am a PhD student in a H2020 funded program, and wanted to look into getting funding for some startup-related stuff. But it all seems quite opaque to me (given that I have not applied for any funding myself). &amp;#x200B; I would love to talk to somebody with more experience, both in regards to Rust, medical, and IoT stuff (preferrably all 3). &amp;#x200B; Do you want to set up a chat of some sort with people who are interested?
I'd be interested in making this happen. If you plan to set up a get-together (in Berlin?) I'd join.
I'd like to find out the default edition for `rustc`, not `cargo new`.
The default for rustc is 2015. I was imprecise, I meant via cargo new above.
thank you
if no edition is provided, it's 2015 -- in order to not break old code.
Depending on what your goals are, and especially what types of users you're targeting, one thing you can do is write you frontend in HTML/JavaScript, and statically compile it into a Rust binary that runs as a web server. Then you can access it via something like localhost:8080. This is pretty niche, but works well for some things. I blogged about it here: [https://anderspitman.net/blog/static-react-rust-webapp/](https://anderspitman.net/blog/static-react-rust-webapp/)
thanks! added some of these
Depending on what your goals are, and especially what types of users you're targeting, one thing you can do is write you frontend in HTML/JavaScript, and statically compile it into a Rust binary that runs as a web server. Then you can access it via something like localhost:8080. This is pretty niche, but works well for some things. I blogged about it here: [https://anderspitman.net/blog/static-react-rust-webapp/](https://anderspitman.net/blog/static-react-rust-webapp/)
&gt; It is useful to note that because typenum is compile-time with nested generics, to_usize, even if it isn't a const fn, does expand to effectively 1 + 2 + 4 + 8 + ... and so forth, which LLVM is smart enough to reduce to a single compile-time constant. FWIW, typenum now also has associated constants. So `N::to_usize()` could be replaced with `N::USIZE`, providing a stronger guarantee that it will happen at compile time at the cost of potentially increasing the minimum Rust version required.
great! added
Find and replace can handle simple edits, and there are still ways to avoid macros even for more complex cases. For instance, using the num_traits crate: ```rust impl&lt;T: num_traits::PrimInt&gt; HelperHelperTrait for T { type H = Result&lt;Self, bool&gt;; fn foo(&amp;self) { ... } fn bar(&amp;self, other: T) -&gt; bool { ... } } impl&lt;T: num_traits::Float&gt; HelperHelperTrait for T { type H = Result&lt;Self, bool&gt;; fn foo(&amp;self) {...} fn bar(&amp;self, other: T) -&gt; bool { ... } } ``` As a last resort, macros are fine of course
imho, it would have made more sense to default to 2018 and to not break old code by making those who want to upgrade rustc but also keep their old codebase to have to put `edition = 2015`..
Ok. Don't worry about it. I shouldn't be making you my postscript tech-support anyway :) It seems to me that cairo has a lot of this stuff solved, but I didn't look into it yet. I'll see what can be done. 
In my experience testing Windows, [Cmder](http://cmder.net/) Full worked a lot better than cygwin. It seems to have problems though when installed outside of your user director, so don't put it in c:\program files; just unzip and run.
Before reading any code: Did you compile with `cargo build --release`?
Yes, and I meant to say that becaus I knew it would be the first reply if I didn't!
https://gist.github.com/codesections/9959d4ddaf23be19078802754482874d#file-robot_paths-rs-L48-L51 your problem is in lines 48-51 of the rust code, you clone your entire board 4 times for no good reason, use references, or if that does not work out Rc.
Heh, it always is :) Would have been too easy!
In the JS version, you pass a reference (`board`) into `robotPaths()`. In the Rust version, you `board.clone()` 4 times instead. I'm going to guess this is where the difference is coming from.
Thanks! That is significantly prettier—and your comment was very educational. 
Thanks. That makes perfect sense and is good to know!
I would guess it's because your cloning the entire board for every recursive call. Which has to realloc everything and copy it. The java script is toggling then untoggling the same board. 
Good luck finding something that both paying and fun to do!
But it's not just your code, it's also all of your dependencies. So in order to not force a giant update across the entire ecosystem it has to default to 2015.
"unsafe code guidelines", more like "copy down ubsan's whole brain into a markdown file and publish it"
The thing that jumps out to me is the way you're cloning every `Board` object each time you pass it into the function. 
A more complete diff: --- old.rs 2019-01-08 13:26:59.201134000 -0700 +++ new.rs 2019-01-08 13:26:44.644846000 -0700 @@ -34,8 +34,12 @@ } } -fn robot_paths(n: i32, board: Option&lt;Board&gt;, i: Option&lt;i32&gt;, j: Option&lt;i32&gt;) -&gt; i32 { - let mut board = board.unwrap_or(Board::new(n)); +fn robot_paths(n: i32, board: Option&lt;&amp;mut Board&gt;, i: Option&lt;i32&gt;, j: Option&lt;i32&gt;) -&gt; i32 { + let board = match board { + None =&gt; return robot_paths(n, Some(&amp;mut Board::new(n)), i, j), + Some(b) =&gt; b, + }; + let i = i.unwrap_or(0); let j = j.unwrap_or(0); if !(i &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n) || board.has_been_visited(i, j) { @@ -45,10 +49,10 @@ return 1; } board.toggle_piece(i, j); - let result = robot_paths(n, Some(board.clone()), Some(i), Some(j + 1)) - + robot_paths(n, Some(board.clone()), Some(i), Some(j - 1)) - + robot_paths(n, Some(board.clone()), Some(i + 1), Some(j)) - + robot_paths(n, Some(board.clone()), Some(i - 1), Some(j)); + let result = robot_paths(n, Some(board), Some(i), Some(j + 1)) + + robot_paths(n, Some(board), Some(i), Some(j - 1)) + + robot_paths(n, Some(board), Some(i + 1), Some(j)) + + robot_paths(n, Some(board), Some(i - 1), Some(j)); // Return the board to its original state board.toggle_piece(i, j); result 
Same in in the DC area
I always enjoyed being on the receiving end of your work, which is a source of inspiration for language advocates and community builders. All the best for the next stage of your career.
because of the clones something like this should be much better design &amp;#x200B; [https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=d0932812c1ccc03566ee9818c03f77b2](https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=d0932812c1ccc03566ee9818c03f77b2)
whoah.. interesting.. ..imagine the headlines "Rust Community in Frenzy Updating Entire Ecosystem for Latest Great Language Improvement" ..wild
Yep! That was a huge part of it (see edit above). Thanks!
Contrary to urban myths, the first non-C-something system language was created in 1961 for the Burroughs B5500 mainframe and was called ESPOL, thereafter replaced with ESPOL, and the modern version of those mainframes is still sold today by Unisys as ClearPath/MCP.
Since \`generic-array\` uses \`ManuallyDrop\`, it already requires a minimum Rust version of 1.20, which is the same version required for associated constants, I believe.
Indeed, when I run the updated version, it's twice as fast as the JS on my machine.
Amazing work up to now. I only hope we get to continue to watch your progress going forward. Fingers crossed...
Not really, on OS/2, Windows, Mac OS, UNIX CDE (Motif++/CORBA) the way was already for writing software in C++, with C being left for the lowest layer of the stack. It was the adopting of FOSS software and the GNU manifesto for writing GPL software in C that kind of gave strength back to C.
There’s also libui-rs 
We designed varlink for such use cases. See https://varlink.org and https://github.com/varlink/rust for the rust implementation.
When implementing callbacks for GUI widgets. Either put every accessed internal member data into Rc&lt;RefCell&lt;T&gt;&gt; declarations, or rewrite the code such that callbacks get the data that they need as parameters.
I just want to say that y'all are amazing—the rust community is every bit as welcoming as I've heard. Within within 10 minutes y'all provided six correct solutions, two withrunning code/diffs. And *none* of y'all called me dumb or implied I don't know how to program—even though I made a classic beginner mistake (solving ownership issues with excessive use of `clone()` instead of by understating my code better)!
I meant in this particular ranking! :) 
I love just translating libraries into rust. My dream is to compile a translated library and compile a normal application used it substituted. Unfortunately, I've had some trouble trying to get Corrode or C2Rust to work, so it's much less fun.
This is exactly the motivating case for [`for_each_with`](https://docs.rs/rayon/1.0.3/rayon/iter/trait.ParallelIterator.html#method.for_each_with) -- please give that a try! The difficulty is that `Sender` implements `Send` but not `Sync`, which makes it hard to use in parallel because you can't even `Clone` it from a shared instance. In `for_each_with`, we clone it behind the scenes each time we split the jobs for new thread.
BRB: building a package with Mesalink substituted for OpenSSL.
rustc probably going to have default 2015 for a long time in order to work with tools that don't know about editions.
I wouldn't be too surprised that the JS code is comparable with the rust code. JS is a surprisingly fast language (or really has surprisingly good implementations), neither version allocates any memory (in the hot path), and the function is short and recursive which doesn't leave much room for LLVM to run useful expensive optimizations.
Random notes: 1. I'd get rid of the `Option&lt;i32&gt;` params and always explicitly pass `0` in `main` (which is the only place you deal with `None`) 2. This might be cheating in comparison to the JS version but you can reduce the size/overhead of `Board` by using 1. a 1-dimensional vector instead of a nested one 2. a bit vector (see [bitvec](https://docs.rs/bitvec/0.9.0/bitvec/) or [roaring](https://docs.rs/roaring/0.5.2/roaring/) crates) that might be able to store all your 6*6=36 booleans as bits in a `u64`
Not really. GUI frameworks are hard. There is a huge gap between things "that just can draw shapes and have some events fire" and feature complete frameworks like Qt. And the problem is that anything in between is usually completely useless. Just drawing shapes and process events isn't enough for a good GUI application... you need a lot more... rust-qt-binding-generator is pretty much as good as it gets until there is some corporate-funded project emerge. 
I don’t imagine we’d ever bother changing it, frankly. There’s no upside and a lot of downside.
Thank you!
Or "Rust fractured by python 3 style breaking update"
You might want to try https://github.com/sciter-sdk/rust-sciter as a lightweight alternative to Electron.
Hi, I may have some or maybe even all of the course backed up somewhere. I had a suspicion it might be removed at some point. I'll see if I can find those materials for you tonight or tomorrow night. I think I saved the web pages or at least some of them. Less sure about the git repos and associated files, but I'll poke around my hard drive.
I would email Sergio benitez for the information if interested. He designed the course (and Rocket!) And would probably be willing to help
1 - thanks! 2 - sure! [here](http://devernay.free.fr/hacks/chip8/C8TECH10.HTM) is a really good resource for implementing the opcodes. 3 - you might come across them implementing an emulator, but then again that depends on how you structure your emulator.
So just for the fun of it I look at the footprint of a few of these frameworks. I did it with minimal-ish example applications from each framework. This is definitely not a scientific comparison but it gives a baseline and general idea. &amp;#x200B; |Framework|Executable Size(MB)|Residual Memory(MB)| |:-|:-|:-| |Azul|12.0|97.4| |Relm|4.0|28.6| |Piston Window|6.9|22.9| |webview|4.0|58.8| |Orbtk|4.4|23.6| |Qt|3.9|50.5| |electron|73|98.1| |vim (for fun)|3.0|7.6| &amp;#x200B; Side note, electron and webview are actually running the same elm basic counter application. At a minimum, electron makes really bloated executables.