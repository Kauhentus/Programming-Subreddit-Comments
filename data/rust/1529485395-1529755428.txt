Does it work to simply sum symlink the external `.cargo/` to `~/. cargo/` or do you have a local installation you don't want to override?
This helps everyone who happens to have seen this thread. I suspect that's a pretty small slice of the community.
Eh, it was a decision. I mean it's confusing once, then it makes sense. For more rational https://github.com/nox/rust-rfcs/blob/master/text/0940-hyphens-considered-harmful.md might be interesting.
I was reading through the updates from Rust Core section and noticed the PR [`impl Hash for !`](https://github.com/rust-lang/rust/pull/51404). Shouldn't `!` just impl *all* traits?
No, for example, it can't implement [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html), because one cannot create an instance of `!`. But you're right, there are theoretically a number of traits that it could implement, namely all those where it always appears in argument positions.
It would be good if the author mentioned in the readme that the community has highlighted some issues
&gt; It's like buying a golf kart and finding out its engine is an unshielded nuclear reactor. Do we still have that quote of the week thing?
&gt;I mean it's confusing once, then it makes sense. You could say that about a thousand things but if you have too many of these inconsistencies it's death by a thousand papercuts which is why every one of them needs a cost-benefit analysis weighted in favor of less complexity. Apparently, our error messages for that case sucks, too. error: expected one of `;` or `as`, found `-` --&gt; src/main.rs:1:19 | 1 | extern crate rustc-serialize; | ^ expected one of `;` or `as` here error: aborting due to previous error
A side question: what happened to PRs, usually it's 100+. Is there any event now, may be? Or it's just a coincidence? 
It can certainly impl Default: impl Default for ! { fn default() -&gt; Self { unreachable!() } } The problem this will conflict with mutually-exclusive traits i.e. `!: Trait` and `!: !Trait` would be simultaneously true. See https://github.com/rust-lang/rfcs/pull/1637 for the discussion why we postponed this. 
Trying to get built-in support for publishing to [crates.io](https://crates.io) on travis-ci: [https://github.com/travis-ci/dpl/pull/826](https://github.com/travis-ci/dpl/pull/826)
UnsafeCell is literally special. It is a lang item. It is UB because the compiler assumes that &amp;mut always provides unique access. If you research C aliasing and undefined behavior, you'll get a similar explanation and perhaps even done code examples.
Ah you're right, I'll give it a try.
I guess they could do special case lexer rule for externs with helpful error message
Thanks, I'll give it a try.
What topics would you prefer were covered instead?
From [that RFC](https://github.com/canndrew/rfcs/blob/d43c208bbafdb538c5aa24d32851c89f2c97c863/text/0000-bang-auto-impls.md#detailed-design): &gt;Any traits that have a unique, trivial implementation for ! should have that implementation automatically derived. This includes all traits except: &gt; &gt;* Traits which have a static method: If a trait has a method which does not take a self then there may be many non-equivalent ways to implement that method. &gt;* […] If you are allowed to use `unreachable!()`, then you can implement `Default` for *any* type. But this isn't useful, one usually expects `Default` not to panic. But for traits where every function has a `!` as a parameter, there's only one trivial implementation (because the function cannot be called either way). This is not the case for traits with functions that do not have `!` as one of their input parameters, like `Default`.
Fixed.
What's the point but destroying the protection offered by the type system (switching from a compile-time error to a runtime crash) ? One could also implement `Deref` for `Option` is you want to go this way : ``` impl&lt;T&gt; Deref for Option&lt;T&gt; { type Target = T; fn deref(&amp;self) -&gt; &amp;T { match self { } } ``` 
There *is* no nonconstructive criticism in this thread. The parent comment is implicitly denouncing everyone writing constructive criticism as assholes.
I like the idea of `Option::replace` it's a useful pattern, and it will be way easier to discover if it's part of the `Option` methods than it is currently with `mem::replace`.
The only reason this would error is that `validate(x)` consumes x.
The point of the type `!` is that is cannot be constructed and that you want a way to represent this in the type system. Hiding this with a runtime error seems like a terribl idea.
There is also meetup in Wrocław, Poland, today: [https://www.meetup.com/pl-PL/Rust-Wroclaw/events/251230941/](https://www.meetup.com/pl-PL/Rust-Wroclaw/events/251230941/)
Look like one of the maintainers has posted [a very reasonable response in the Github issue](https://github.com/actix/actix-web/issues/289#issuecomment-398691401). He's also asking for help from experienced developers to fix these issues: &gt; I am going to reopen this issue as there is clear evidence that the API exposed currently is not sound. Thanks @seanmonstar for pointing this out. I want to spend some time in helping to solve these problems. At the same time I want to set some expectations that this is going to be a process that will take quite a bit of time. &gt; I identified one issue #332 which is the core of a lot of this. It's that we currently use an inner type that is used among multiple clonable request objects and through it multiple mutable references can be obtained. It's also clear that this happens in practice. The solution will require some API changes and I want to find out what good ways there are to do this. That request object also sets a pattern that has been used in various places in actix so getting a good story there in place is likely to then set some guidelines of how to do this elsewhere. &gt; This is a topic that's very important to me and I would love if people with experience in that field would be able to assist us.
Given let a: &amp;u32; let b: &amp;mut u32; { let c = *a; *b = 77 let d = *a; assert_eq!(c, d); } The compiler can optimize the assert away because it knows that `a` and `b` cannot alias, because `b` is a unique reference. If `a` alias `b`, the behavior is undefined, because the compiler will optimize and change code under the assumption that they do not alias, and the code that those optimizations might emit can do things that you won't be able to reason about from the code above. 
I don't have any way to confirm this but I have a feeling that something like a `enum TargetFeature { AVX, SSE, None }` enum in a `lazy_static` along with a runtime match might be faster since the CPU could get really good at predicting it whereas I don't think that many CPUs can predict indirect jumps well.
There were a few infra-related problems this week, and also there was Mozilla All Hands so a few reviewers weren't available.
This exposes MIR for generic functions and functions marked `#[inline]`. MIR is pretty low-level and isn't significantly more readable than the generated assembly but it might be an issue.
Oof. I should probably go double check all my unsafes :P
The only thing I am criticizing is the attitude towards unsafe code. There is little excuse for somebody transmuting an `&amp;` into an `&amp;mut`. I've made this mistake so I understand that this is a mistake that can be made, but when it was pointed out to me I was ashamed and fixed it as quickly as possible and made sure that the solution was sound and asked more knowledgable people than me to review it because I had shown that I couldn't trust myself. However, when these issue was mentioned in the repo, the responses felt more like "this is intended". 
This is not a good metric. `unsafe` code can get broken by changes in safe code. Using this metric rewards projects lying about the safeness of the API they expose. I think the only way is to look whether the crate has any unsafe code and review all of it or look at a subset to gauge the trustworthiness of the unsafe code.
Absolutely a best practice to have hyphens in names. If your output is an executable with an underscore in the name, that's going to be very non-standard.
&gt; I really think a fundamental fix to the issue requires language features that are not there yet. The minimal fix would be to mark the functions that are unsafe as unsafe.
I think right now this would mean most functions sadly.
\`stdsimd\` supports AVX-512, but the CPUs I've used only support AVX2.
In the context of my path tracer I ended up doing the feature detection once and stored the result in a boxed closure so it only happens once. This got performance a lot closer to the statically compiled version. From 47.6MRays/s to 50.3Mrays/s for runtime detection versus 51.1Mrays/s for compile time. Actual changes https://github.com/bitshifter/pathtrace-rs/compare/spheres_simd_dynamic?expand=1 Perhaps this could be made faster still with a function pointer like what you are proposing here.
How do you vectorize to web-assembly? AFAIK web-assembly does not have vector instructions yet.
I duno I was pretty excited by this &gt;Hugh Gallagher merged the ResourceUpdates and Transaction types. I finally made it to a Webrender Newsletter 🎉🎉🎉🎉🎉
In that case a "cargo update" should be suggested imo.
What do you think about having \`Option::replace\_with\` method in the standard library? [https://github.com/rust-lang/rfcs/pull/2296#issuecomment-398723548](https://github.com/rust-lang/rfcs/pull/2296#issuecomment-398723548)
[removed]
Could we please not make use of fascist references in titles/content in this sub?
lol
You do the right thing! Thanks!
I am still processing this comment, and I don't understand how saying "make actix great again" is a fascist reference? am I missing something, please explain.
You get some speedup from the static version because \*All\* of the code, gets optimized with LLVM knowing it can use AVX2 instructions everywhere. Wheras the dynamic version cannot. This seems to cause a few &amp;#37; improvement even when almost all of your code is SIMD intrinsics.
Probably talking about Trump's Campaign :)
"Make Actix Great Again" is a reference to Donald Trump's campaign slogan, "Make America Great Again", which has now become a meme. The comment is asserting that Donald Trump is a fascist, and that referencing the meme which is his campaign slogan should be disallowed from this sub. Fascism is a political philosophy, movement, or regime that exalts nation and often race above the individual and that stands for a centralized autocratic government headed by a dictatorial leader, severe economic and social regimentation, and forcible suppression of opposition \[[1](https://www.merriam-webster.com/dictionary/fascist)\]. Fascism is generally regarded as bad.
I guess because it's Donald Trumps main slogan...I got a bit of a chuckle out of the title...but that's just me I guess
Sure, individuals are responsible for the safety of the code they use. However, there's also a huge difference between a few unsafe expressions and hundreds, with the former being excusable in most cases and the latter only really excusable in FFI situations. I think it would be interesting as well for the Rust project to have that data readily available so it could have goals of reducing unsafety in the ecosystem when doing things like NLL (e.g. reduce number of crates that have &lt;10 lines of unsafe by half), and have that backed up by graphs. Or someone could design a data structure for the more common use cases to eliminate large numbers of usages of unsafe. Having an idea for *how much* unsafety is used is more useful than simply knowing *whether* a library has unsafety. I'll skip over something that doesn't do FFI that has a ton of unsafety, but I might actually audit something with only a few unsafe expressions.
Thanks!
Can we please stop this nonsense? Trump's slogan is not facist
True.
I give you points for great title :D
Hmm... IIRC, this is pretty much what `check_for` should be doing: /// Performs run-time feature detection. pub fn check_for(x: Feature) -&gt; bool { cache::test(x as u32, detect_features) } and pub fn test&lt;F&gt;(bit: u32, f: F) -&gt; bool where F: FnOnce() -&gt; Initializer, { if CACHE.is_uninitialized() { CACHE.initialize(f()); } CACHE.test(bit) } where #[cfg(target_pointer_width = "64")] struct Cache(AtomicU64); #[cfg(target_pointer_width = "64")] impl Cache { /// Creates an uninitialized cache. const fn uninitialized() -&gt; Self { Cache(AtomicU64::new(u64::max_value())) } /// Is the cache uninitialized? pub fn is_uninitialized(&amp;self) -&gt; bool { self.0.load(Ordering::Relaxed) == u64::max_value() } /// Is the `bit` in the cache set? pub fn test(&amp;self, bit: u32) -&gt; bool { test_bit(CACHE.0.load(Ordering::Relaxed), bit) } /// Initializes the cache. pub fn initialize(&amp;self, value: Initializer) { self.0.store(value.0, Ordering::Relaxed); } } From the OP, it looks like maybe inlining failed here? cc /u/gnzlbg_ 
I don't think there'll be too much gain with switching from those closures to a function pointer: I suspect the way to get the last few drops out of this dynamic function route is to do some dynamic code-rewriting like GCC's ifuncs. As an alternative, one could try the suggestion of /u/stumpychubbins to switch from a call to a `match`, with the thinking that branches are better predicted than indirect jumps (although I'm not sure how true that is these days), but this also plays better into the hands of the optimizer.
This is a /s, right?
In this case, I think (but could be wrong!) the indirect jump is simple enough that CPUs will be [able to predict it](https://en.wikipedia.org/wiki/Branch_predictor#Indirect_branch_predictor) well enough. This however does help the compiler's optimizer by avoiding the dynamic call boundary, allowing better inlining etc, and so may still have a noticable impact.
Shout-out to non fascist US owned Concentration Camps. https://en.wikipedia.org/wiki/List_of_concentration_and_internment_camps#Separation_of_Immigrant_Children
What grinds my gears, independent of whether /u/regexident is right in his/her assertion about the slogan, is that it implies op is at fault for what good faith interpretation of it would be a short apolitical humorous pun. Finger pointing is obscenity. 
Not sure how it is related to my comment but ok? This awful imperialistic USA how could they!?
&gt; From the OP, it looks like maybe inlining failed here? `check_for` etc. aren't marked `#[inline]`, so it wasn't even attempted/possible.
Good post, much less good title. Using that slogan is normalizing the behaviour &amp; language of a problematic person/movement, but even ignoring that, it is clearly going to distract from the technical content. I'm going to remove this and ask you to resubmit with a different title.
We have the best coders, don't we, folks?
Sure, this can be done on UNIX platforms. extern crate libc; use libc::{fclose, fdopen, fgets}; use std::ffi::CStr; use std::fs::File; use std::os::unix::io::IntoRawFd; fn main() { let rust_file = File::open("/etc/passwd").unwrap(); unsafe { let c_file = fdopen( rust_file.into_raw_fd(), CStr::from_bytes_with_nul_unchecked(b"r\0").as_ptr(), ); let mut buf = [0; 80]; let ptr = buf.as_mut_ptr(); fgets(ptr, 80, c_file); println!("{}", CStr::from_ptr(ptr).to_str().unwrap()); fclose(c_file); } } This code won't work on any non-UNIX platform.
Standard library has extensions for platforms like https://doc.rust-lang.org/std/os/unix/index.html You may want to check it out
About the portage/cargo-ebuild point there is a discussion in this days about how to handle tools that need to be compiled with the same version of the compilers (clippy, fmt, bindgen, etc) . There are different opition about that and how to handle this. But this is not against "portage philosophy", go and other languages are handled in the same way. There are no plan in rust at now, as you can see from the [rfc](https://github.com/rust-lang/rfcs/issues/600): &gt;Rust has been committed to a stable language and API since 1.0, but ABI stability has never been claimed. Your code is compatible; your binaries are not.
&gt; Having an idea for how much unsafety is used is more useful than simply knowing whether a library has unsafety. Not necessarily. As I mentioned above, `unsafe` code kind of taints the whole module where it is used, so it is difficult to quantify how much "unsafety" the module has without rewarding code that lies about safety. 
I have vscode with rls installed. For some reason the status bar is stuck at "RLS: Starting". GOTO definition and error reporting works fine, but autocompletion does not work at all
`global_allocator` is stabilized! That makes me happy, because I've been following Philipp Oppermann's wonderful write-an-OS-in-Rust guide, and being able to define a global allocator is a huge step. Anecdotally, I was looking at the issue on Github before it was stabilized, mostly curious of the progress that had been made on it. Just by mere chance, the final commit that got merged was added about 15 minutes before I checked the page, and was in the process of going through unit tests. I'm always impressed with how on-top-of-it the compiler devs are.
I am trying to download a HTML page through **hyper** on windows10 and print it into console, but once I hit first non-ascii character I get `error=text was not valid unicode`. Any idea how to overcome this?
I believe that using [the never type (`!`)](https://doc.rust-lang.org/std/primitive.never.html) on `my_panic` should give the compiler the necessary information to make this work. I don’t have time to test it out now, but I would expect that to work.
The use of slogans like MAGA in supposedly harmless every-day use contributes (whether intended, or not) to making similar racist/fascist slogans socially acceptable, leveling the field. As to how "MAGA" is fascist: Hitler rose to power by claiming he would make Germany great again (and later even renamed the state to "Greater German Reich" a.k.a "Großdeutsches Reich").
Actually, it's guaranteed that Rust will use file descriptors on UNIX, due to https://doc.rust-lang.org/std/os/unix/io/index.html being stable.
LLDP, IGMP, ICMP, or basically non TCP/UDP tools in safe rust are hard to find discussion on, particularly if it's a non IP protocol like LLDP. I did start on an IGMP tester but never got around to having it do more than I needed for that project... could be a good one to go back to. libpnet is an **awesome** library for implementing packet manipulation or transport protocols all the way down to the data link layer and I don't see it mentioned enough even in my own networking circles. Basically anything in the world under IP where you either write it in Python because you want to analyze a couple of packets quickly or C because you need it to handle a trillion packets soon. It's a perfect place for Rust. I think the hardest part of getting Rust into this space is most people just end up doing things in the kernel or with kernel modules which, while not impossible, isn't popular or easy.
Yes, it's unfortunate but I think it would be better than the current situation. Of course, a fix that does not require this would be vastly preferable.
Trump’s methods are precisely what dictators throughout history have used to weaken the democratic norms that act as a check against their power. Dictators attack the press (“fake news”); They cultivate a key group with the ideas that others are the source of their misery (“illegal immigrants, trade deficits, bad nuclear deals...”) and that the dictator is the only one who can solve all these issues; They seek to undermine public education (Betsy DeVos); They silence opposing voices (firing anyone who may have worked for Obama); They work to stack courts and the judicial system with sympathetic or beholden individuals (numerous examples); They pardon loyalists even if they have done horrible things (Joe Arpaio, et al.); ...shall I go on?
Yeah Fake news attack Trump and Trump should just sit there and enjoy? I think he deserve right to troll them back and he done a great job at at Illegal immigrants should just go back and enter legally if they don't want to be persecuted by law (that's what law is for, it is not Trump fault) Considering that most in USA have no clue about what is actual fascist I think there is not much to undermine I would fire anyone who makes my work harder. Trump has been hired by people to do what he promised, not to be strangled by saboteurs Go on sure, but we all know that you don't like Trump just because his ideology is not aligned with yours
Hitler also owned a dog. I guess we should all be cat persons now?
Awesome, thank you! I already knew the article from the link, but I guess I got a bit confused by the fact that it is `self`, that the method takes ownership of, as it seems kind of strange to me to be able to just steal the object in a method of it. But I guess there could be cases, where this is useful, like a method that moves the object to somewhere. Anyway, thank you for the clarification!
See what I mean? It’s working perfectly on you.
Who was referring to Reagan's campaign... While I thought thebpun was funny, I do understand not everyone might feel that way.
Pet ownership is not as political as campaign slogans. Maybe pet ownership is not political at all, but I don't mind to be corrected on that.
cc also /u/dbaupp * `check_for` not being `#[inline]` is a bug AFAICT. The other functions are crate private and should be `pub(crate)`, and therefore, inlined into `check_for` when that's profitable. * what /u/dbaupp shows is different than `check_for`. /u/dbaupp does run-time detection just once - no need for `lazy_static!`, you can do this at the beginning of main if you use `AtomicUsize` to store function pointers. This means that once you set up the function pointer you can just call it without doing any branching. If you were to write: ```rust if is_x86_feature_detected!("avx") { foo_avx() } else if is_x86_feature_detected!("sse4.2") { foo_sse42() } else { foo_fallback() } ``` at worst you need two relaxed atomic loads, and bit manipulations, inside the two `is_x86_feature_detected!` invocations (and the branch is still there). By using something like `/u/dbaupp` suggested, you just need one unconditional relaxed atomic load, no bit manipulations, nor branches.
Based on some definition of fashism, what makes you think he isn't?
Gamedev: There are good bindings for all the important things you need, - SDL2, OpenGL, Vulkan, Dear IMgui etc, and performance is good. Slow compile times can be a downside for some types of gamedev. Michael Fairley has a nice blog entry on his experience making a game in Rust (which he released simultaneously on IOS, Android, PC and Mac) : [https://michaelfairley.com/blog/i-made-a-game-in-rust/](https://michaelfairley.com/blog/i-made-a-game-in-rust/)
&gt; Perhaps this could be made faster still with a function pointer like what you are proposing here. I think so. The atomic relaxed loads should be free. That way you just call the function pointer directly, avoiding any branching. If you are willing to use nightly, you can probably write callable structs: `struct Foo(AtomicUsize)` that implement the function traits, so that your code just does `Foo(x, y, z)` and the right function is called without branches.
Thanks for those references. I updated the post to link back to your comment.
awesome! i linked to your comment in my post under references and further reading. 
A couple of "tips": * The following function is missing a \`#\[target\_feature(enable = "avx2")\]\` attribute: \`\`\`rust #\[cfg(target\_feature = "avx2")\] pub fn add\_avx2(a: &amp;\[f32\], b: &amp;\[f32\], c: &amp;mut \[f32\]) { ... } \`\`\` * I have a PR to \`stdsimd\` that makes the run-time feature detection functions inlineable into the caller, could you give it a try and report back if it solves your issue? Otherwise, could you fill a stdsimd issue with a reproducer? [https://github.com/rust-lang-nursery/stdsimd/pull/480](https://github.com/rust-lang-nursery/stdsimd/pull/480)
How do you move something out of a closure? I'm making a small test program where you can configure the port of a Hyper service by either the command-line argument `--port PORT` or via the environment variable `HYPERPLAY_PORT` with a fallback to a default port, but I'm having trouble getting the borrows right. Code: https://gist.github.com/Ran4/0bf75686dd18876d7d09597c26309506 See the [`let port: u16 = ...` line](https://gist.github.com/Ran4/0bf75686dd18876d7d09597c26309506#file-borrow_out_of_closure-rs-L34) Any idea how I could rewrite this?
We should improve this for sure. Care to file a bug?
If you're not allowed to use a newer version of rust or an external crate, maybe just copy and paste the code from one of these?
SIMD doesn't let you fundamentally do anything different, it just lets you do things faster. They probably have a non-SIMD version and a SIMD version, and the wasm target uses the slower fallback.
Sorry, I'm a beginner at Rust. Where exactly would I copy the code from? Starting from the Rust github page - https://github.com/rust-lang/rust/tree/master/src - Where do I go from here?
As Lyon is France's second largest city, the title was slightly confusing ^^
Are you sure 1.25 is the actual requirement? [`join` has been around since 1.3](https://doc.rust-lang.org/std/slice/trait.SliceConcatExt.html#tymethod.join). `connect` should be the same thing, except it's the old deprecated name for it. The error you're getting seems to be due to you having a `Vec` of `()`, and `()` doesn't satisfy the requirements for `connect`. I would expect rustc to tell you that, instead of outright saying the method doesn't exist. Odd.
Are you sure you're original code doesn't compile. If not you could try changing the last line to: println!("{}", a.as_slice().join(",")); The docs claim that slice.join has been stable since Rust 1.3 https://doc.rust-lang.org/std/slice/trait.SliceConcatExt.html#tymethod.join
Fashism is national idea taken to the extreme. Overall its idea is total control of government in all areas of society. Liberal ideas and democracy is rejected in favor of national idea even at the expense people freedom. In the end it is the same communism idea, just replace class fight with national/racial fight (nazis are good example of merging fascism and socialism) I'm sorry but the day when Trump declares himself an emperor of USA people will take their guns and kill him. He is pretty liberal, especially because totalitarian systems would leave him without possibility to do business. Trump is only doing his job as president: caring about citizens of USA (illegal immigrants are not his concern because they are not citizens)
Congrats! 😃 
Please show your full Rust program.
Yeah that's the part that really shows off their approach, kind of a shame they put it that far down the page. For what it's worth, I got pretty poor results trying to compress source code and binaries, but that's probably not what Dropbox optimizes for.
&gt;My point is slightly different, do not use Rust because “it is awesome and I love it”, use Rust when it solves problems you have. I think any reasonable programming language (Rust included) should aspire (and be aspired) to: Use it when you can unless there are specific reasons not to. I'm not saying you should use always use Rust, but that there should be no real reason not to prefer Rust if it satisfies your requirements.
A `FILE` is for buffered stream I/O. It's more akin to a `BufReader&lt;fs::File&gt;`/`BufWriter&lt;fs::File&gt;` than a `fs::File`, which is itself a thin wrapper around a file descriptor on Unix systems. /u/Quuxy is right. There is no guarantee that `fs::File` will use libc at all. Given its semantics, it's a certainty that it will indeed never use `libc::FILE`.
Thanks.
Pretty sure you should be able to just put `do_something_else_with(x);` into an `else` block. That way each arm of the if/else statement will consume `x`.
Not a direct answer to your question, but clap supports env args and defaults. Arg::with_name("port") .long("port") .short("p") .env(PORT_ENV_VAR) .default_value(DEFAULT_PORT) ... let port = value_t_or_exit!(matches, "port", u16);
Not by the rust compiler, because the whole point of unsafe is to let you do things which rustc isn't capable of checking. However perhaps by a specialised tool, e.g. /u/annodomini pointed out [CRUST](https://homes.cs.washington.edu/%7Espernste/pubs/crust-2015.pdf)
Pinging u/llogiq
The gripe is that you'll add `serde-derive` to your Cargo.toml, then `extern crate serde_derive;`. It's just an annoyance.
Take a look at this: https://www.reddit.com/r/rust/comments/83o4el/a_place_to_buy_good_merch/?utm_source=reddit-android. I
Oh... Of course :) Thanks. 
Why can't this use the work that has already bean done at https://github.com/koute/stdweb
Found a pre-existing issue: https://github.com/rust-lang/rust/issues/48437
Ah, nice.
Rather than using the compiler target, you could use a build stage in the Dockerfile, copy from that into the main Docker stage. That make make it easier to package and build, and the cost of installing the base build system for the additional stage. It would allow you to capture the rustup and other initialization such that it would be more easily reproducible.
Have you tried bringing up those unsafes with goblin developers? The readme states that the parsers have been fuzzed. I've glanced over their fuzzing infrastructure and there are no obvious flaws there. But fuzzing can only prove presence of bugs, not their absence.
I've seen these prerelease stable builds for testing a few times now, but I'm unsure who they are meant for? I've CI set on my projects to test again stable, beta and nightly through rustup. Are there any best practices to integrate these prerelease builds in this workflow? 
&gt; I'm unsure who they are meant for? Anyone who wants to kick the tires before we tell the world. &gt; Are there any best practices to integrate these prerelease builds in this workflow? No; they're not really for this. This is more about a last-minute "give this a try" thing to be done manually; it's only really valid for a few days. By doing this, you're basically smoke testing the release infrastructure. Does rustup properly grab the new version? Does it install it in the right place? Does the compiler actually run when you try it out? etc. The beta channel catches many issues with the release overall; this is basically checking the diff from beta to stable. Often times, that's purely just a new build, no new commits or anything. But, it is a new build, and so should get some degree of checking.
Try checking out the pstring module in the ignite library. Use that instead of a string and see how it goes
With the new `dyn Trait` syntax, are bareword traits going to be phased out?
I would consider using c# for this. It has decent COM integration, and you can use the ADO stuff. I can't share any code, but I have used this stuff at my job and it works... as well as can be expected.
Adding to what u/steveklabnik1 said, not a lot of developers are actually using beta on their local machines, so the tools (like rls) and a few platforms don't get as much testing as we would like during the beta stage. A few regressions were reported after testing pre-releases in the past, so we started posting them around a bit more.
Yeah, that's the plan. See [RFC 2113](https://github.com/rust-lang/rfcs/blob/master/text/2113-dyn-trait-syntax.md)
More specifically, there's an allow-by-default lint in 1.27 against it. We don't plan on turning it on in Rust 2015, as far as I know, but is one of the things `rustfix` turns on and updates your code to when moving to Rust 2018.
That's very encouraging.
The link for "[The Rustc Book](https://doc.rust-lang.org/rustc)" is broken.
So, these are for people like myself who like to get on the new toys just a notch early? I read that if there are no issues these exact binaries will end up in the stable channel. Does this mean I can grab the stable version 'early' without having to rustup update stable when it actually goes live? In that case sounds cool and I'll probably start using them.
That link will become available when 1.27 will be released. It's already available [in the beta docs](https://doc.rust-lang.org/beta/rustc/).
A lot of usage of the word socialism misses the point: restricting/abolishing private property (NOT personal property, know the diff). Nazi's where not socialist by this def, just as socdems are not socialist by this def. Others in this thread have shown why Trump displays traits of a wannabe absolute leader (even when only for some term(s)). He recently said he "can pardon himself", seriously.
There is a "technique" used in HFT to get "branchless" code which could probably help here. The idea is that instead of having multiple function calls branching on the same condition over and over, you instead parameterize the whole block of functions by the condition, then do a single check at the top level. Applying it here, I could see using traits for it: trait CoreOperations { fn foo(i: i64); fn bar(); fn baz(); } fn bottom&lt;C: CoreOperations&gt;(core: &amp;C, i: i64) { c.foo(i); } fn top&lt;C: CoreOperations&gt;(core: &amp;C) { for i in 0..64 { bottom(core, i); } } fn main() { if is_x86_feature_detected!("avx2") { let core = AVX2CoreOperation; top(&amp;core); } else { let core = ScalarCoreOperation; top(&amp;core); } } Due to monomorphization, there will be multiple instances of `top` (one for each feature-set) which bloats the binary if the linker cannot merge identical bits... however a given CPU will only ever load a single version of `top`, so cache-wise there's no issue. This is even more optimizer-friendly than branch prediction, because it trivially enables *inlining*. On the other hand, it requires wiring all operations from "up there".
I want reproducible builds with more than one Rust toolchain on the system. This specific Rust version with this snapshot of libs and this workspace produces that executable. One stable setup that is then exposed via network mount as the reference, and at least another experimental one with Rust nightly, different libraries version, different workspace etc. in parallel in another directory. 
Note though that the _package_ name and _crate_ name don't have to be related. Unfortunately I can't think of an example published crate right now (though I know it exists), but your `package.name` and `lib.name` don't have to be related.
Not quite since the safety of `unsafe` code can depend on values computed outside the `unsafe` block (e.g. pointer or slice index adjustments). It is up to the code author to make the code easy to reason about or not, but at least `unsafe` does point out areas needing extra review.
Yet? C has been around for decades and the best tools we have to reason about it only pick up *some* issues. The Rust language is designed from the ground up to make memory-safety easy (or at least possible) to reason about.
You do realize that nazism stands for National Socialism? if you replace class with race, you get the same idea. They even used the same tactics as communists (note that communists were also the second most popular political force in pre-WW2 Germany). You find small group of people that everyone dislike and tell them that they are evil (in case of communism/socialism it is rich and in case of nazis it is jews) Similarly to communism/socialism nazism asked people to unite in fight against "evil" and sacrifice personal interests. Though of course economically nazi's choose different approach since Hitler disliked communists
I have generally found that looking at an unsafe block is enough to see something obviously wrong - however, I have also had to look for uses of the unsafe function to see if the constraints are being upheld. It's a very easy, deterministic path.
Does `discord-rs` do it? You `extern crate discord;`
That still doesn't help, because you can have many lines of code calculating some value then a single `unsafe` line doing e.g. an unsafe conversion.
I had missed Niko's PR about improving the NLL checker performance: [#51460](https://github.com/rust-lang/rust/pull/51460), the end result is [impressive](http://perf.rust-lang.org/compare.html?start=862703e05e275d77b0b594bb5d1a26a6340933f2&amp;end=b36917b33104dc0af4d26d53899b7cd064a40b22&amp;stat=instructions:u)! Throw in nnethercote [#51411](https://github.com/rust-lang/rust/pull/51411) and rustc got a good speed-up this week!
In the RustC Book, is this correct? ## [no-redzone](https://doc.rust-lang.org/beta/rustc/codegen-options/index.html#no-redzone) This flag allows you to disable [the red zone](https://en.wikipedia.org/wiki/Red_zone_(computing)). This flag can be passed many options: * To enable the red zone: y , yes , or on . * To disable it: n , no , or off . Should this be the opposite? I would expect "no-redzone=no" ("no" to "No RedZone") to enable the redzone whereas "no-redzone=yes" to disable the redzone ("yes" to "No RedZone").
No, their package name is just `discord` on crates.io. Your Cargo.toml is still `discord = "0.8". I think the examples I was thinking about are in the Piston project -- for example, package `piston-gfx_texture` provides the `gfx_texture` library crate.
[removed]
... I wrote this and I may have messed it up. Mind filing a bug so I don’t forget, please?
Yes and yes.
That's why I explained what I consider "real socialism". If it is not concerned with priv prop, it is not socialism. Na-socs and soc-dems are merely (ab)using the word in my opinion. But feel free to keep your own ideas.. 
The scenario you're talking about [is totally fine](https://play.rust-lang.org/?gist=665eaf62746d29bdf23ab9e0751d9088&amp;version=stable&amp;mode=debug), so I again encourage you to come up with a real actual example that you ca present with an error message. 
&gt;no-redzone &gt; &gt;This flag allows you to disable the red zone. This flag can be passed many options: &gt; &gt;To enable the red zone: y, yes, or on.To disable it: n, no, or off. Done: [https://github.com/rust-lang/rust/issues/51663](https://github.com/rust-lang/rust/issues/51663)
Thanks!
The reason I'm asking this question is thinking through what it might mean to "audit and sign" an unsafe block. A naive implementation would take the code inside `unsafe {}`, hash it, and sign the resulting hash. In this case, changing code inside of `unsafe` would invalidate the signatures and would require a re-audit. \ But as you correctly pointed out, it's not just the unsafe code that matters, but also the code around it that it interacts with. An ideal audit tool would be able to programmatically figure out what other bits of safe code the unsafe block is interacting with, and include that safe code in the hash signature. This would mean that changing safe code that interacts with unsafe code would require a re-audit. Note that the tool doesn't need to determine the safety (that's the job of the human auditor), but just be able to determine what is impacted. I wonder if it would be worth my while to implement the naive version of this tool as a proof-of-concept, and see if there is any interest in developing it further. 
Is there a particular reason the name is negated? Just `redzone=on`/`redzone=off` is possibly less confusing.
This, this, this, and this again. I couldn't agree more. Making your dockerfile copy the compiled results into the container goes against all the good principles of continuous deployment and reproducible builds. If there's not already, it should be relatively easy to make a rust-musl-libc docker image to be used as the base for building the binary, and then use the builder pattern to copy the compiled binary to a scratch container.
&gt; everyone who disagrees with me is stupid really makes my thought noggins joggin
And DPRK stands for Democratic People's Republic of Korea. It's not democratic, nor from the people, nor a republic nor the only korea. Just because they invented a name doesn't mean it makes sense.
If nothing else you could write a shell script to swap the symlink around when you need to. I don't know if you've used Docker before but complete control over the environment is one thing it was designed for.
gcc and clang's version of this flag flag is called `-mno-red-zone`, so I imagine it's in keeping with that. 
Thanks. I would love to have stickers of ferris, especially this one: http://www.rustacean.net/assets/rustacean-flat-happy.svg I did stumble upon this: https://www.redbubble.com/people/livbunn/collections/769600-ferris
&gt; HOST is the market leader in the ticketing industry For a moment I was wondering how it was possible, seeing as Amadeus and Sabre dominate the ticketing industry as far as I know. So, Amadeus and Sabre dominate the *airline* ticketing industry, and I guess that Ticketmaster is more about concerts/events? It would be useful to edit what kind of tickets it actually handles :)
I would like to ask about the future of Rust's module system. My biggest gripe is the need to write ... ``` mod foo; use self::foo::Foo; ``` ... all over the place. I've seen there is the new `non_modrs_mods` feature flag, which allows you to move these from a `mod.rs` to 
Yes. How do I get past this? Can I simply pass a reference of `x` to a function if I want to guarantee its destruction it in that function?
https://play.rust-lang.org/?gist=d9e6415d5be4772b86dca4df938c287b&amp;version=stable&amp;mode=debug So, this is true for the toy example, but for some reason it doesn't work in my actual code... 
Here's an example: https://play.rust-lang.org/?gist=20e8ec7914a800f9c3f62866dbec704c&amp;version=stable&amp;mode=debug It can be fixed by specifying `!` as the return type for `destroy_and_panic`. Surprisingly, this does not work in my actual code though...
Symlinking .cargo seems not to work: https://github.com/intellij-rust/intellij-rust/issues/2466 A Docker solution... if I pack everything into a Docker container for building that's fine, the problem is then to present the toolchain and libraries "inside" of the container to the "outside", the IntelliJ Rust plugin running on the host. Hmm......
I'm working on a C to Rust translator. No support for C++ yet and still maturing, but if you have any thoughts, I'd love to connect. Demo [https://c2rust.com](https://c2rust.com), any kind of feedback is greatly appreciated.
[removed]
Try removing things from your actual code until you either have a small enough example to post, or you find the problematic part. 
I'm trying to write a small program that gathers some error information from a file (from flake8). I'm able to to that in a loop but can't get it to work with an iterator approach. Maybe someone can help! extern crate regex; use std::fs::File; use std::io::{BufReader, BufRead}; use regex::Regex; fn main(){ // test.py:144:13: C812 missing trailing comma // test.py:152:24: C812 missing trailing comma // test.py:167:13: C812 missing trailing comma // test.py:176:26: C812 missing trailing comma // test.py:191:13: C812 missing trailing comma // test.py:200:29: C812 missing trailing comma // test.py:213:13: C812 missing trailing comma // test.py:220:27: C812 missing trailing comma // test.py:239:14: C812 missing trailing comma let re = Regex::new(r"([\w./]*):(\d+):").unwrap(); let log_path = "data.txt"; let buffered = BufReader::new(File::open(log_path).unwrap()); // let data: Vec&lt;_&gt; = buffered // .lines() // .filter_map(|line| line.okp()) // .map(|line| re.captures(&amp;line)) // .map(|cap| (cap[1], cap[2])) // .collect(); let mut problems: Vec&lt;(String, usize)&gt; = Vec::new(); for line in buffered.lines().filter_map(|line| line.ok()) { println!("{:?}", line); let captures = re.captures(&amp;line).unwrap(); problems.push((captures[1].into(), captures[2].parse().unwrap())); } println!("{:?}", problems); }
Yup, DivANS defines a Cargo feature called "simd". Using cfg attributes, DefaultCDF16 type is aliased to either non-SIMD version or SIMD version depending on features.
If I understood this correctly, then captures need to reference the matched `line` which does not outlive the closure - hence "`line` does not live long enough". To fix this you should join both `map`s into one: .map(|line| { let cap = re.captures(&amp;line).unwrap(); (cap[1], cap[2]) })
&gt;We don't plan on turning it on in Rust 2015 Does that mean this lint will at most warn, not error, in Rust 2018?
Nom was built with streams in mind, so it is unable to determine whether your input is complete yet (it could be extended and still be valid, e.g. 1.3334 as the last float). Generally you'll want to use the input type CompleteStr or CompleteByteSlice (depending on whether you work on utf8 or [u8]) They simply wrap &amp;str and &amp;[u8] respectively. Sadly some of the pre-defined functions of nom don't accept these new datatypes, but all macros certainly do. Feel free to hit me up with more questions, I'm by no means am expert but I think I figured out the basics.
That linked example works fine, so I'm confused why you linked it. If this isn't your actual code, would you mind sharing the structure of it and I can help you based off that? You can just use `unreachable!` liberally if you don't want to share the implementation details. (Here's [a version with the warning fixed](https://play.rust-lang.org/?gist=79eb21462f750131ebab32d3948d5dae&amp;version=stable&amp;mode=debug)).
And this new ecosystem could start from forking actix itself, because in all other means it's a great library. Make a fork, workout all `unsafes`, you're done. You will probably loose some % of speed, but who cares if UB code is working faster?
`wasm-bindgen` takes a different approach to inter-operating with JS than `stdweb` does. In particular `wasm-bindgen` has these goals: * Being half a polyfill for the [host bindings](https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md) proposal, so that we will be able to easily update to avoiding JS shims completely when calling DOM methods, and this should eventually unlock even faster-than-JS DOM manipulation. * Leveraging rustc's / lld's ability to only pay for what you use in terms of code size and functions emitted into the `.wasm` binary You can read a bit more in detail about `wasm-bindgen`'s approach here: https://rustwasm.github.io/wasm-bindgen/design.html
&gt; Rust 2015 - &gt; Rust 2018 What do those mean in ordinary version numbers?
The method "returns" a pointer, but not as a return. The caller needs `*mut void` back, so the method wants a pointer to where the caller will store the result. let result: *mut void = default(); the_function(&amp;result); do_stuff_at_memory(result);
No direct relation. This is part of the “edition” system, formally called “epochs”. Every rust compiler is expected to be able to compile all editions. So rustc 1.45 will have both. (Picking a far future one for example’s sake, the first composer supporting rust 2018 will come much sooner than that, but we haven’t guaranteed which.)
I’m not 100% sure exactly what the plan is regarding the idiom lints. I think so?
&gt; If I understood this correctly, then captures need to reference the matched line which does not outlive the closure - hence "line does not live long enough". Thanks, that was the trick. Just needed to make the result a `String`, but I think there's no way around that. let data: Vec&lt;(String, usize)&gt; = buffered .lines() .filter_map(|line| line.ok()) .map(|line| { let cap = re.captures(&amp;line).unwrap(); (cap[1].into(), cap[2].parse().unwrap()) }) .collect();
A `&amp;Vec&lt;_&gt;` is a pointer to a pointer. `Vec&lt;T&gt;` is basically `(ptr: *mut T, capacity: usize, length: usize)`. Because `Vec` is a layer of indirection: the actual data is on the heap in the dynamically sized array that `Vec` manages. `&amp;mut T` is just `*mut T` (with a lifetime). So if you have `&amp;mut Vec&lt;T&gt;`, you have a `&amp;`-pointer (the borrow) to the `Vec`-pointer (the indirection to the heap). Note though that these aren't the only reasons to have pointers, especially in C FFI. It could be basically anything, based on how the library is laid out. `*mut *mut _` is the same as `&amp;mut &amp;mut _`, just with raw pointer semantics rather than mutable reference semantics.
From an outside-in perspective, it seems to me that it would be as hard as writing CRUST, i.e. the tool can't tell the extent of the code that needs checking without actually doing the check and proving that no more code needs considering. However, perhaps you have a better intuition for this than me, so maybe you could find a better way.
Right, you want to use it from the IDE. What about adding the external Rust install as a custom toolchain to your local Rustup? https://github.com/rust-lang-nursery/rustup.rs/blob/master/README.md#working-with-custom-toolchains-and-local-builds
thanks - this is very helpful! I guess I retrospect I kind of knew a `Vec` was a pointer I just never thought about `&amp;Vec` being a pointer to a pointer. 
Nice article ! Just for information, if you want less sizes checks when you use `slice::chunks` and you know that the length of the slice is a multiple of the chunk size you could probably try to use the new [`slice.excat_chunks`](https://doc.rust-lang.org/std/primitive.slice.html#method.exact_chunks) method.
in this example, what is the signature of `the_function`? I thought you were saying that the error status is stored in `result` but I don't know if that's what you meant.
Ah I see that makes sense then obviously. So to fix my problem I should aside from using CompleteStr obviously, replace the nom::float_s call with the macro chain that the function actually does so I can use it still? As in the source of the function as defined here https://docs.rs/nom/4.0.0/src/nom/nom.rs.html#740-742
Hi there! I'm unable to reproduce the \`Incomplete(Size(1))\` error you mention. After a couple tweaks I was able to get your program's test to pass. 1. The 0.5 in \`make\_vertex("v 0.5 1.0 1.333")\` needed a negative sign. 2. I added \`#\[derive(PartialEq, Debug)\]\` above your \`struct Vertex\` declaration. Let me know if I missed something! Also, I'm on \`rustc 1.26.2\` and \`nom v3.2.1\`
&gt; I think the hardest part of getting Rust into this space is most people just end up doing things in the kernel or with kernel modules which, while not impossible, isn't popular or easy. I don't quite follow what you're trying to say here, could you elaborate a bit?
The problem is with nom4 which is a _lot_ more strict with Incomplete.
I believe so, yes.
Yes, correct, people in general have found it more useful than a hindrance. If you're writing this so often as to find it annoying, have you considered splitting code into fewer modules? I generally don't find `mod x;` to take any amount of time compared to actually writing each module. I'd usually avoid splitting this out unless you're getting into 500+ lines- unlike languages like Java, Rust doesn't have any necessary correlation between modules and in-code structures.
I never used rustup. I use the .tar.gz installer. Download installer once per release, create from that installation without depending on stuff from the internet -&gt; reproducible. Make .cargo snapshot of required crates. Use that until next release. With new Rust release rebuild whole installation from scratch. Move to new release - and hope nothing breaks or bugs. Now I want to run two (or more) installations in parallel, to have a defined upgrade path, or allow comparison, or debug environment, or... - and use my favourite IDE with it :-)
Thanks for the heads up. Looks like the post is back on the main page?
Thanks for the feedback. I have actually gotten similar feedback over the last few days. As a sports fan myself i thought Ticketmaster was a brand everyone was aware of. I have added their LinkedIn page in the post!
&gt; This is somewhat similar to GCC's function multi-versioning (except I believe that uses "ifuncs" + the dynamic linker to truly minimize the overhead). That's an upside and a downside. `ifunc` replaces some generic symbols with the ones of specialized functions depending on the results of run-time feature detection on ELF binary initialization. A consequence of that is that you need to actually have `call` instructions in the code that call the generic symbols. Which means that nothing can be really inlined anyways. Whether that is more efficient than just calling a function via a function pointer... I don't know, but I don't really expect that to make a big difference because you are always jumping to the same address if you call the function pointer in a loop (its value doesn't change). Also, `ifunc` only works on ELF linux binaries. 
I was able to fix the issue by better organizing the code :) 
I was able to fix the issue by better organizing the code :) 
This is way overdue but here is the Rust NYC channel with the two videos from the last meetup. https://www.youtube.com/channel/UCU4-2XNjgtTp4LqE8LldEyw
But if the wasm target uses the non-vectorized fallback, is it really vectorized? That was what was confusing me.
Btw next meetup coming up next week. https://www.meetup.com/Rust-NYC/events/251490499/
So there is no official merch to buy stuff and support Rust dev? 
https://play.rust-lang.org/?gist=49015312d676cc412de09ef9b54b62e4&amp;version=stable&amp;mode=debug
Sorry, I found the pun funny and it never occurred to me that people could be offended by it. I don't live in America and over here it is just a meme at this point.
Makes sense. Sorry about that. I found the pun funny and couldn't resist. It never occurred to me that it would invoke so many feelings. I don't live in the US and over here it is just a meme at this point. The "no memes" rule still applies, so thanks for closing this.
`*mut *mut c_void` is effectively the C version of `&amp;mut [T]`, but without any kind of type information.
Is there a particular reason why `x.destroy()` isn't just implemented as its destructor i.e. through the `Drop` trait? Destructors are run when the code unwinds via panics and at the end of the values scope. (I know this isn't really your question, but if you didn't know about the `Drop` trait this might be quite useful for you)
Ah, got it. Yeah with nom 4 I'm able to reproduce. Thanks!
[removed]
Indeed, ifuncs/compiler-driven function multi-versioning is a possibility for getting the last few drops out of the dynamic function approach, not something fundamentally different.
A pointer is a pointer. It can point to anything, even other pointers. Why? It's pretty common to use pointers to access arrays in C. A pointer to a pointer can be interpreted as an array with a pointer or an array within another array. Details are not straightfoward and a ton of bugs arise from this feature, but that's why you sometimes see a "double pointer".
That doesn't make sense if tomorrow crate used unsafe to call FFI function and the next day it adds a function with UB transmute.
There's no easy way to do this with the standard HashSet, afaik. You could try writing it yourself; however, the code will be quite finnicky, so it would be a lot of work. Fault-tolerant systems are hard. Some other alternatives: You could try using [`sled`](https://github.com/spacejam/sled), which is an embedded persistent key-value store. It should be a lot faster than an RDBMS since its embedded in your process, but it's still atomic and fault tolerant. It will be O(log n) for accesses though. You could also use a HyperLogLog and persist the whole thing to disk every few writes, which should be very fast and not use much space. Your workload will need to tolerate occasional false positives though. A third option is to create a simple log yourself: write to disk every time a value is added to the set. Then, when you start your application, create a HashSet and write everything from the log file into it. This gives persistence while being a lot easier to write, at the cost of startup time.
Stop trying to make smart contracts bound by the restrictions of physical hardware. They're running on a distributed system that has to be cross-architecture and extremely high-level anyways. WASM was designed the way it was to be fast on physical machines and to be compiled to by major application languages. But smart contracts are *very* unconventional applications so you don't need to be bound by the target of physical CPU microarchitectures. You don't even need instructions in the common sense. See Tezos, their primary smart contract language is more of an AST that's evaluated and applied to the state of the system. Of course Michelson is very hard to write normal programs in when you've not had experience in purely functional programming languages, but it can be used as a target for higher level more conventional languages like OCaml. Leaving out the step of generating Assembly machine instructions eliminates the need to doing complicated transformations when proving the correctness of your programs, and since it's "just" simple reductions from your higher level language to Michelson which is directly evaluates by the VM, which is implemented in OCaml and *already* relatively easy to formally verify.
I [mentioned it briefly](https://github.com/m4b/goblin/issues/36#issuecomment-323218268) back in August of 2017 but felt it wasn't my place to make such demands of someone else's codebase until I was ready to put in the time offer up a proof-of-concept pull request which starts to remove them.
Try it out using a sqlite database first. It's O(log(n)) to look up an index, but it has pretty great constants on that.
 Mmap is used in DBs. Mongodb uses it. Even postgresql used it (and move away from it)... But there is no magic with mmap. "Eventually", it will flushes your changes to disk. (You can force it too). If you pull the plug before it was flushed, your change is lost. If you pull the plug in the middle of the kernel flushing bits of your hashmap you end up with a corrupted file. 
Donate to Mozilla.
You migh want to use enums to hide away part of that logic.
I can't give any help, but I'm interested in what you're doing. Are you storing Nonces?
You might want to use enums to emulate a union type in a safe manner. Traits are also something you can use to replace inheritance. They are not drop in replacements because they are mostly sintatic suggar that needs to be resolved into a single type in the end. Since one of the latest stable versions, we also have impl Traits, that may help you in some cases too.
&gt; SIMD (Single Instruction Multiple Data) on x86/x86_64 is now stable 🎉🎉🎉
The abstract class here has the benefit of defining and documenting the common interface for the different platforms. I don't think this is a bad pattern. Without you can only rely on your multiplatform CI to know that the interface did not diverge on each platform, your editor cannot help you, and you don't have a single point you can document, so you increase the risk that the guy implementing platform B misinterpreted the contract. 
Yeah, I think the reason why is that an external library I am using is a very light weight wrapper around a C library (Vulkan), so it doesn't have too many bells and whistles in terms of memory management (unsafe blocks everywhere), and I am currently just handling clean up manually, as I don't intend to use the crate for long, or for very complicated tasks. 
Reddit sync for Android caches comments and highlights new ones when you refresh a comment thread. It's really nice specifically for this.
I am working on a text compression idea for fields with limited alphabets. I am focusing on natural language processing and genomics at this stage, but believe that I can pack arbitrary alphabets into log2(k) space, where k is the number of characters that need representing. I am hopeful that this can be a useful post-processing step once input text has been tokenized and normalized.
Which crate have you used for your linear algebra work? 
The lack of AVX2 in that example was intentional to show it's doesn't end up in the binary. I'm not sure I understand why you'd add it when the cfg would prevent if from being used? Awesome work on the PR! I will take a look and update the post (might have to wait for compiler explorer to update their nightly).
You're going down a long, long mountain road, here. Building a new database, essentially, and that is not a trivial task. First, obviously the existing hashset does not support this, so you'll be building your own. Second, building a correct implementation of this is not as easy as mmap'ing a bunch of memory and writing into it. You're relying on the underlying memory manager in the kernel doing what you want it to do. Narrator: It won't. Specifically, the memory manager makes no guarantees about when it writes pages to disk, or in what order. If you care at all about reliability, then you can see that this alone is a reason to seriously reconsider this approach.
*Distro* is the common nickname for distribution.
I'm im favor of not following that nomenclature. "Negative" flags can be confusing, and if we have the opportunity to make the name better, then why not?
I feel like they are using features wrong. Half their features seem to be subtractive, which breaks down if the crate is a sub-dependency of multiple dependencies. And since you can't have features based on the target you are compiling on, you can't use the feature for the DefaultCDF16 type if you are using this as a dependency.
A classic example is `rust-crypto` providing the `crypto` crate. 
LTO didn't seem to help, at least not in compiler explorer with `-C lto=fat`
That's an interesting idea, I will give it a try. The compiler might be able to inline more in this case which could help overall.
See also Simplicity(disclaimer: my co-worker develops this)
Seems to do what you want: [https://github.com/BurntSushi/fst](https://github.com/BurntSushi/fst)
Sounds like you want Redis. It has O(1) set operations built in, and the Rust bindings are great. 
Rusty way of returning a pointer where it can fail: fn the_function() -&gt; Result&lt;*mut void, Error&gt; This particular style (c-style) fn the_function(result_location: *mut *mut void) -&gt; Error Such that, the value will be placed at the pointer, where the value itself is a pointer, iff there is no error.
Yeah.
This works because the GCC flag is a boolean _flag_ (its absence indicates "yes"), not a config option which accepts both yes and no.
See also: http://aturon.github.io/sponsor/
Awesome work. Feel free to wave if you get stuck :) 
First crate and already made crate of the week! I looked into your GitHub and saw lots of languages there. How does Rust feel to you?
It sounds a lot like this - https://github.com/LiveAsynchronousVisualizedArchitecture/simdb You would have to put in fsync commands after the writes and deletes, but that's it. 
Looks very cool! Hadn't heard about that auto diff library either. 
Agreed. While I wasn't as clear as I could have been on it, my recommendation was to use a trait to define the interface and then use `cfg` to keep platform-specific `impl`s from colliding with each other.
Ah, ok, thank you. 
nofunallowed.jpg
Thanks for responding well. Just to reiterate, I encourage you to resubmit with a new title. :)
It does not support inserts. Requires the key to be sorted to build the fst. And finally it performs a bunch random seeks per get query. This is probably not what the poster wants here.
Postgres supports \[hash-based indices\]([https://www.postgresql.org/docs/10/static/indexes-types.html](https://www.postgresql.org/docs/10/static/indexes-types.html)). So you can save yourself from having to re-implement them. Worth noting also that you should be careful about assuming O(1) hash-set performance if other people control your inputs.
Unfortunately methods are static-dispatched, so there's no way to get that effect. A trait is the easiest way to achieve this, but a macro might also work. There's one to make mocks out of traits: https://github.com/DavidDeSimone/mock_derive but you could write similar code to swap out a concrete function's parameter types.
Rust has been hard to learn but I love the combination of standard ML features/syntax + C speed! I'm starting to get the hang of it. The SIMD library doesn't really touch on any of the hard to learn parts though, so that wasn't so hard to put together as I have done similar in C++ before. The rust package and documentation system are great! 
The only thing I'm iffy about is littering my production code with directives from my test suite. Are you saying that macros in Rust can rewrite function signatures of existing functions so I could switch the B parameter type for a test then switch it back to C?
Yup, this is correct.
Most every modern language has cross platform bindings for layer 3 or 4 sockets based on a Berkeley sockets style interface being presented by the OS. If you want to truly own the layer 3 or 2 processing (which you need to do in modern networking) you have to enter the land of writing OS specific, version spcific, build syste, specific, kernel modules in Rust (an enormous undertaking) or relying on C abstraction layers that actually do the work for you (DPDK, OVS). These abstraction layers are the areas that would get the best benefit out of Rust IMO as you're doing dynamic construction and deconstruction of foreign data in kernel space at up to 100 Gbps.
Mocking concrete structs is the main reason I made https://github.com/pcsm/simulacrum, you just have to use the Manual API. From there, you can use https://github.com/pcsm/test_double to swap them in if you’re on Nightly Rust. This is the setup I use in my own projects.
&gt; This author has seen multiple people write impl SomeTrait for AnotherTrait when they wanted impl&lt;T&gt; SomeTrait for T where T: AnotherTrait. Woah. What's the difference?
Huh! I was just searching this morning for a Rust autodiff/autograd library and I couldn't find one. Thanks for linking
Yeah, Rust certainly requires a mental shift, but I've found it rewarding. I haven't used vectorized code much but am interested in learning how to make use of them. Do you have any pointers to decent material (even in C++, Fortran, ...)?
Yes, I have! It's certainly one of those things that I will be looking into whenever I need a scripting language to embed somewhere. Looks super-cool
Looks like a pretty good proposal. The only issue I see is that the implementation of RFCs (the PR to rust-lang/rust itself) can't be in the RFCs' repo for obvious reasons. Would the discussion/code review take place in the PR to rust-lang/rust or in a dedicated issue on the RFC's home repo?
https://www.reddit.com/r/rust/comments/8sochx/proposal_for_a_staged_rfc_process/
I think I recall it being reported that RLS + VSCode still doesn't have stable/full auto-completion...I no longer use VSCode, but instead IntelliJ IDEA (community edition) with the Rust plugin. Couple of things duckduckgo searches brought up: * https://stackoverflow.com/questions/43898241/no-rust-autocomplete-in-visual-studio-code-for-external-crates-such-as-gtk-rs#43901712 * https://www.reddit.com/r/rust/comments/69em7x/question_vscode_an_rust_autocomplete/ Not sure if either will be relevant to you.
What is the preferred approach?
How understandable is this code snippet, in your opinion: https://www.reddit.com/r/rust/comments/69em7x/question_vscode_an_rust_autocomplete/? Should I use for loops instead, or is it good as it stands? A related question. Consider this playground example: http://play.rust-lang.org/?gist=64a0f36225f5bf7d624743fcba2fbe2d&amp;version=stable&amp;mode=debug How would you rewrite `toy function` using filters/maps and the like?
Excellent, I had planned to use postgres for my RDBMS persistence layer so I will simply use hash based indices from it. I didn't know it supported that! This is the ideal solution for me, thank you. 
It could have the patches in the rfc repo to provide context. Syncing is a pain but it’s definitely doable I think. 
I'm considering implementing a classical electronic currency system based on blind signatures. One of the centralized blind mixing based systems built on top of blind signatures. To protect from double spends in these systems the bank node needs to keep track of every single blind signature that is redeemed through it, which entails storing a hash value essentially. During electronic currency exchange the bank node needs to query an ever growing set of previously redeemed blinded IOU values to ensure none are double spent. However the authenticity of the electronic currency is cryptographically protected and it is made cryptographically computationally impossible for the bank node to track the flow of electronic currency on the application layer. It is pretty much the state of the art of electronic currency from say a decade prior or so, before Bitcoin was implemented and decentralized trustless (ie: decentralized blockchain based bank without centralized trust) zero knowledge proof systems like Zerocash were invented. 
I think one of the other mods may have approved it out of the spam filter, but the reason I didn't do that was because reddit doesn't account for time spent in the spam filter when ranking posts on the front page and so it basically just means that your post is going to appear at the bottom of the page for a short time before falling off, getting little to no exposure. For example, as of right now, this is on page 3, and I fear that not many will have seen it. If you choose to take me up on my offer of resubmitting, please let me know both so that I can monitor the spam filter and remove this copy of the post. :)
Great! It's like he read my mind!
Thanks for the answers guys. Indeed the conditional compilation seems to be the way to go. Also I think in this case I won't need the interface part, but I will need it in a different part, so thanks for both suggestions!
Called it https://www.reddit.com/r/rust/comments/8s5omp/aturonlog_listening_and_trust_part_3/e0x0lnj/ I think I'm telepathic. /s
By the time the code's written and proposed for merge, any high-level design considerations should already be settled in the RFC. All that should be left are implementation details, and discussion on that naturally fits in the PR itself. (Of course, sometimes we don't know the fallout of certain design decisions until after trying to implement them, but such implementations shouldn't be proposed for merge anyway; rather they should be stored in an implementor's personal repository and referenced in the RFC discussion on how to resolve the issues that came up.) Plus the actual act of using the Github interface to refer to the code is easier in the PR discussion than within the (unrelated as far as Github knows) RFC repository.
To not do it. `String`s being valid UTF8 is a property you may depend on in unsafe code. Even if you yourself do not depend on it, external code, including `std`, may do so, leading to memory unsafety from a malformed `String`. If you have to handle invalid utf8, then someone goofed up somewhere.
If the PR is attempted (period for final review) and someone brings up an issue then I assume they'll be told to file an issue in the RFC's dedicated issue tracker where that issue can be resolved before continuation with the PR. I don't see any reason discussion has to happen in the PR.
Thx, first link solved my issue. 
If you have to look at the uses of the function then it should be marked unsafe.
Great suggestions. As I mentioned in the post, the intent of the tutorial was to show the basics. I link to several more complete resources if you want to actually start using this in production. The reason I wrote this in the first place is that I remember playing with minimal go images a couple years ago, and wondered how easy it would be to do one in Rust. Turns out, pretty easy.
One part of my research was to write all mathematics by myself to proof if i am able to handle all needed kind of steps.
I actually think you're probably right. What a stubborn problem. Thanks for your thoughts!
Hey thats sounds great :). Currently if i come to a C part i have to transform into Rust i made a list of hints i can realize it, but not finished today. I will set your post on my todo list. If i finished my work then i will send you a message. 
Naturally. But if you're looking for actual bugs... it's the ones that aren't marked unsafe you'll want to take a look at in order to observe non-local unsafety.
Given that the channel is called "Knights Gaming", I believe this is meant for r/playrust rather than r/rust.
No. `&amp;mut [T]` in C-style would look like `*mut c_void` and `usize` together.
-&gt; for function return is fine by me; it visually seperates the return value from the inputs better.. especially if you have functions returning functions, that's handy IMO
Check https://crates.io/crates/mocktopus
I use to sell generic programming sticker along with a Rust one (no ferris) here: [https://hexstickers.com/](https://hexstickers.com/) Beware, do not put your credit card in there since I didn't renew the certificate yet. I will gladly send the rust sticker around if you guys pay for the shipping cost 2EUR in Europe, 3EUR outside Europe. You can use the paypal on the website.
Just add `stdsimd` as an external dependency from git directly, and use `#[macro_use(is_x86_feature_detected)] extern crate stdsimd; use stdsimd::arch::...`. I don't know exactly how the macro collision with `std` is handled though.
I understand, thanks for explaining.
Hi gnzlbg_, no worries. I didn't feel offended. I also didn't mean to imply you were a racist/fascist in any way. It just really worries me how right-wing language is steadily making it into every-day speech. And I'm a native German living in Germany ("Hi Aachen!" – Berlin), where the same is happening with AfD right now. Few years ago they were no more than a small bunch of losers. But ever since the media started to invite them into talkshows and newspapers started writing about them and citing their language they have been on a strong path towards becoming the second strongest party. Thanks to their repeated use of edgy fascist/racist language in the public we now find ourself in a (political) society where outright racist/fascist utterances don't even provoke an offended reaction by many any more, let alone having any consequences for the AfD. Memes like MAGA have a similar effect on the public perception. They shift the threshold of what's acceptable and what is not.
I looked at the linked material about this new `dyn` keyword, but I'm very confused. When is a trait not dynamic-capable?
Each node in Zerocash also needs to check if the coins used in a transaction are not double spent. It does this by associating each coin with a serial number, and checks that there are no duplicates. So it's the same situation as yours. AFAIK, ZCash, which implements the Zerocash protocol, just uses some sort of off-the-shelf key-value store for this, but the throughput of serial numbers is much lower than what I imagine it would be in a centralised service, so they can afford the hit of not being very fast. As an alternative, have you considered using a fast bloom filter combined with a slow, persistent key-value store? When the server sees a valid serial number, it adds it to the bloom filter (fast) and asynchronously adds it into the persistent store(slow but asynchronous). Later, it can check that a new serial number doesn't collide with a past one by first checking the bloom filter. If this check says that the number already exists, then you can go look in the persistent data store to confirm. This works because bloom filters have only false positives, not false negatives.
&gt; The abstract class here has the benefit of defining and documenting the common interface for the different platforms. The common interface is the class that contains a `PlatformSpecific` as one of its members; in the OP's code, it's the class `State` defined at the very bottom. The various platform specific structs are accessed only by the platform specific code and therefore don't need a common interface; in fact, any attempt to provide such is misguided. Note how the OP's base class has an explicit comment that it contains nothing. The interface is enforced through composition rather than inheritance.
&gt; The code is vectorized. Whether the browser can autovectorize the wasm, or the wasm itself is vectorized or not is relevant, but not really under the control of the DivANS crate. So this is what I don't understand. If the code is vectorized, there is no need for auto-vectorization because it is already vectorized. There are WASM extensions for vector instructions, but you have to explicitly generate them using intrinsics just like you do for x86. If you are not using those, then your code is not vectorized. It might at best be "suitable to autovectorization", which might trigger if you compile with the right LLVM options, and have the right browser. But those are a lot of ifs compared to explicitly generating the WASM vector instructions.
How can you enable SIMD for wasm? can you show the exact SIMD code that is compiled to wasm? If you are actually compiling `__mm_...` intel intrinsics to wasm, then that's actually a bug. That should error.
`String` and `str` are always valid `utf8`, no need to check anything for those. If you want to check for arrays of bytes, then use `&amp;[u8]` / `Vec&lt;u8&gt;`, `[u8; N]`, ... 
Actually that's what Mocktopus does: https://crates.io/crates/mocktopus It allows you to mock any statically dispatched function in your crate without littering production code (well, almost, you need a few lines in crate root). BTW I'm an author :)
https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html#object-safety-is-required-for-trait-objects
I believe https://github.com/dropbox/divans/blob/master/src/probability/simd_frequentist_cdf.rs is the relevant code. It does seem to use `_mm_movemask_epi8`.
Yes precisely.
I am absolutely astounded (in a good way) by the reaction of the "leadership" for Rust to all of the recent discussion on the forums and elsewhere to deficiencies in the RFC process (sometimes heated discussion). If this is the way that Rust is going to continue to operate, I would have to say that it is definitely becoming, more than it already is, a shining example of the best this field has to offer. As always, Niko and Aaron (in their Blogs) bring a lot of clarity to the issues.
The "repo per RFC" approach sounds very worthwhile, if just to make threads of discussion easier to follow! Question: how will these new RFCs be advertised? It would be nice to have a page showing all the RFCs in each stage or something.
Maybe in these cases the signature could be declared explicit without async keyword and have an async block in the function body?
I think it makes sense by allowing some projects to be trusted. It's more than nothing.
I was unaware of the existence of cargo-safety! &gt;&lt; . I just spent yesterday slapping together something similar: https://crates.io/crates/cargo-geiger
`impl SomeTrait for AnotherTrait` implements `SomeTrait` for the (unsized) type `AnotherTrait`. That's exactly one type. The second implements `SomeTrait` for each type that also has `AnotherTrait` implemented, which is a whole set of (sized) types. (Sized types are everything where the memory size is known, for example enums and structs, as long as they don't have unsized types inside)
&gt; And I'm a native German living in Germany ("Hi Aachen!" – Berlin) I also live in Aachen ;)
There's one technical difficulty with "multiple repos in one organization" model, it's GitHub notifications. You can't subscribe to an organization, so every time a new repo appears you have to go and manually "watch" it, while now I can subscribe to the whole rust-lang/rfcs repo and follow what happens.
I think that if during a PR review new issues are discovered, one can just fill in an issue in the rfc's repo to keep track of these and discussed. It is normal that implementations evolve over time.
&gt; - Use and enjoy! Blasphemy! It should be "- Use, share and enjoy!" Also, there should be an unofficial requirement that for large features for a graphic of Ferris standing in front of "Use, share and enjoy!" in three mile high illuminated (it's a special celebration) letters caved in and they dropped for nearly half their length while wearing a pig hat. And the name of the new feature somewhere. *continues reading the proposal*
Couldn't that be botted? Have a repo "notifications" in the org you can watch, and have a bot post issues about all new repos in that org. Not sure how feasible that is, though.
Is there a `github.com` issue about this?
Since the repo's will be created by a bot, maybe it could be made to also subscribe everybody who opts-in to the newly created repo if there is enough demand for it. Assuming the Github API supports it.
It's not always possible to tell from the name if you deal with a trait or type and with `x: Trait` it will be hard to tell that exactly function represents: is it a generic function or not? Does it return anonymous or concrete type? So `impl` removes this ambiguity. Same story with `dyn`, you can't tell what exactly `Box&lt;Foo&gt;` means, is it a heap allocated value of type `Foo` or trait object?
I have a question and a thought: Question: does this mean the implementation code changes that go into bringing a RFC to fruition on nightly go into the new RFC repositories? Or are those just for the RFCs before they are approved and merged into the main RFC repo. Also, where does the tracking issue for implementation live? Maybe a “demo RFC” could be created to lay out some of the specifics? Thought: Allow me to be an incredibly jaded cynic and be really mean for a moment; I don’t think the added formality is going to fix the real problem of people having their feelings hurt by a change they dislike making it in. The charge I observed was that it was too unclear about the changes that were happening. However, just based on looking at the history of the issues, if you were paying reasonably close attention throughout, you pretty much knew what was going on because all the actual change happened over the course of a year plus. Adding the index of changes and their states and having isolated repos for RFCs isn’t going to help anyone who isn’t paying reasonably close attention. If anything, splitting everything up into dozens of repos is going to destroy searchability. Hypothetical situation: there’s a contentious feature that gets into stable. The complaint about will be that the description in the RFC index isn’t what some people think it should have been. They will make arguments that the Rust team was hiding contentious features behind bad RFC descriptions. Or it will be that their thumbs down’s on comments were ignored. Or that the RFC they did like was not championed well enough. Short of moving to a system that actually eliminates community involvement, I don’t think this kind of contention can actually be resolved by any formality. /cynic Of course, maybe I’m just being overly negative because my feelings about most emotional arguments in communities is that they are really not about what they portend to be about and are in fact power struggles. All that said, I don’t want to impugn the effort to make the process better because I really think it’s coming from a place of earnest desire to have people be really involved and I do think that it’s going to make it easier for anyone tracking the language’s changes to understand the evolving state.
Thanks for working on this. This sounds just awesome. The new process is significantly better than what we currently have.
Search finds this one https://github.com/isaacs/github/issues/50
Link is a 404 for me
Maybe. I hope that's solvable by automation, that's the only way if github doesn't support it natively.
How about this? #[macro_use] extern crate rand; fn main() { use rand::{thread_rng, Rng}; use std::iter; let mut rng = thread_rng(); let len = 1024; let random_string = iter::repeat(()) .take(len) .map(|_| rng.gen::&lt;char&gt;()) .collect::&lt;String&gt;(); println!("{:?}", random_string); }
For those that missed the live stream, you can still view the session here: https://m.youtube.com/watch?v=JvBEzwvOHe0
`impl TraitA for TraitB` implements TraitA for the TraitB trait object type. Only dynamically-dispatched trait objects for TraitB will impl TraitA. This is a single type (the trait object). `impl TraitA for T where T: TraitB` implements TraitA for all types that also implement TraitB. These are very different things. You rarely want the former.
impl Trait vs. dyn Trait (or just Box&lt;Trait&gt; as input parameter) is the difference between static dispatch with monomorphisation and dynamic dispatch with a single function instance. When using "impl Trait" you are saying you are giving or returning some Type T that implements the Trait and the function will be appropriately monomorphisized (much more efficient in terms of CPU performance). If you use just plain trait (in input parameter position, or a Box&lt;Trait&gt; in return position) or use "dyn Trait" you are opting to pass/return what is termed a "Trait Object" which is effectively a fat pointer to the type struct instance and a pointer to the vtable for the trait method implementations - this can be then used to perform dynamic dispatch on the trait methods and does not require the function to be monomorphisized. TL;DR - It's about performance (static dispatch, impl Trait) vs. code-size (dynamic dispatch, dyn Trait/Trait/Box&lt;Trait&gt;)
Thanks for the reply. If I got this correctly, does that mean that Rust doesn't know whether an identifier is the name of a trait or of a type?
Compiler knows, but do You know? This change isn’t about helping software, but about helping wetware writing code. 
Thanks for the reply! :) I think you're describing the difference between dynamic and static dispatch, whereas my question is more or less why the compiler needs to have the `impl` in place instead of just having the trait name. It could be rephrased as: Is it possible to infer the `impl` by the compiler?
Ahh - so you're saying the `impl` essentially just helps people to distinguish between type and trait usage?
This is the most difficult part of Rust. :-|
No, `impl Trait` means monomorphisation, the point is that `Foo` itself didn’t carry information if this is dynamic dispatch or not, and this is bad. So `Trait` and `dyn Trait` are effectively the same (at least for now), the poor is to show developer that there will be used dynamic dispatch and you should be aware of that. 
The category index is [here](http://julio.meroh.net/series.html#Rust%20review)
If you simply use a memory mapped file, you will get unpredictable data corruption if your application or system crashes. You could try to work around that with well placed flushes, but that's quite tricky to get right. I'd rather look into WRITE_THROUGH/O_DIRECT. If your strings fixed power-of-two length and each update only consists of writing that value to the file, the complexity isn't that big and should be manageable. (Am I guessing correctly that you're talking about the blacklist for Chaumian e-cash?)
&gt; Just making your dockerfile copy the already compiled results into the container goes against all the good principles of continuous deployment and reproducible builds Couldn't they also use nix, guix or something similiar? 
If you just type Trait, the compiler will desuggar that into the actual struct you've implemented that trait on. The resulting code is faster and the compiler can catch some minor bugs ahead of time. If you type impl Trait, the resulting code will have to lookup a valid version of the function at runtime, which is slower and some bugs might slip by the compiler check due to said runtime checks.
Which of these feels more rustic: ```rust let port_string: &amp;str = matches .value_of("port") .ok_or(String::from("Missing value for `port`"))?; let port: u16 = port_string .parse() .map_err(|e| format!("Invalid port: {}", e))?; ``` ```rust let port: u16 = matches .value_of("port") .ok_or(String::from("Missing value for `port`")) .and_then(|x| x.parse().map_err(|e| format!("Invalid port: {}", e)))?; ``` ``` let port_string: Result&lt;&amp;str, String&gt; = matches .value_of("port") .ok_or(String::from("Missing value for `port`")); let port: u16 = port_string2 .and_then(|x| x.parse().map_err(|e| format!("Invalid port: {}", e)))?; ``` With the first and third version it's easier to see that there's two fundamental actions happening here (try to get a string; parse the string), but I think that the `?` kind of hides the flow control a bit too much (it doesn't look like getting the `port_string` is a "failable" operation in the first example). The third one solves this, but instead of seeing results being thrown around we might as well combine them into the second version. Any ideas? How would you re-write this to make it easier to understand at a glance?
Ok I think I get it - it's to be explicit whether dynamic or static dispatch is used. Thanks for the answers. However, if I write `Trait` it can only be a dynamic dispatch if used in a reference, such as `&amp;Trait` or `Box&lt;Trait&gt;`, and static dispatch if used as a bare trait, no? It seems to me like it's fully determined by its usage, I think that's where my confusion lies.
For those who care – [the link over https](https://julio.meroh.net/series.html#Rust%20review). ;-) (The op’s link does not specify the protocol and Fx defaults to http).
If I remember correctly, the plan is to deprecate `Trait` and `&amp;Trait` and then, in one of the later editions, make it no longer valid syntax.
Yes, but how do you know whether `Foo` is trait or struct? I mean you cannot differentiate between them basing on the name only. 
Using hash based indices from a RDBMS should amortize to the invariable efficiency of a bloom filter. There is actually a name for this distinction between amortized O(1) and O(1), but I can never recall it or how to put it, one or both may be constant time but in cryptography it is typically the O(1) of a bloom filter rather than a hash set that is referred to as constant time. So some efficiency may be brought by using a bloom filter, but I think it will be close enough that simply using hash based indices should suffice. I am not actually planning to run it as a service but simply to implement the three canonical systems of blind digital signatures; e-cash, anonymous polling, and revocable anonymity. Individuals will be able to use the implementations if they like, though I would be cautious to actually run a centralized E-currency service as they have not been treated by the legal system in the same manner as the decentralized ones. 
The main repo has a list of all others and the stage they’re currently at.
&gt; If you type impl Trait, the resulting code will have to lookup a valid version of the function at runtime This is backwards backwards. `impl Trait` is static dispatch.
Yes you guessed correctly. 
What is?
Understanding what epochs are. I think I like the new name better, though. It at least sounds as if it means _something_. ;-)
Ah! Well, we’ll have a preview of 2018 out sometime soon, which includes some explanation. If you happen to read it, feedback on how it’s explained would be very useful.
IMO It is big and complex enough that it deserves its own function with documentation. And if you do that, that function might as well use loops and return early (equivalent of \`nth(0)\`). On a side note, it can be simplified. The outer \`filter\_map\` can be removed if you change the \`map\` into \`flat\_map\`.
Huawhaattt?! I love this game. Is this yours?
/u/stumpychubbins match suggestion turned out to be a lot faster - from 50.3MRays/s with the closure to 52.7Mrays/s with the match. I didn't need to use lazy static, I just calculate the target feature when I create my scene struct.
fn f() -&gt; Trait would mean you return trait itself, which is not the case - function is returning "something that implements the trait". Returning Trait is atm not supported, but there were plans to allow this.
I just use `cargo fmt`.
Yeah but it's horribly, horribly wrong and abuse of notation. It should either be `len : &lt;T&gt; Vec&lt;T&gt; -&gt; usize` or `len&lt;T&gt; ( index : Vec&lt;T&gt; ) : usize`
No. The impl is what tells the compiler that you are consciously choosing Static Dispatch/Monomorphization instead of Dynamic Dispatch using a single function that takes/returns a "Trait Object". In other words, using impl vs dyn (or currently a Box&lt;Trait&gt;) is selecting for "Trait Object"/Dynamic Dispatch whereas using impl is selecting for static dispatch of a specific type through generic monomorphization.
What I don't understand is why `impl` implies static dispatch or stack allocation. When I think of `impl` I merely think of expressing behavior on a type, with the nature of the behavior open to the implementor's discretion. The choice of syntax had long confused me, and seems to go against Rust's philosophy of being explicit.
&gt;Do you have any pointers to decent material (even in C++, Fortran, ...)? I don't, but I may be giving an intro to SIMD talk at the Rust event in Austin in a month or two, if I do I'll redo it on twitch / youtube. 
Using phrases like "full r****d mode" to complain about other people not being nice enough is not a great look.
Read "impl" in this context as "an implementation of".
I consider style guidelines as a baseline for best practices. When you don't care about how you style something, using the guidelines will increase consistency throughout the ecosystem. But readability is an extremely important part of writing software, and I feel that it even ranks higher than consistency. If there's a diverging style for some parts that's more readable, I'll prefer that. An example that recently came up on the forums is this common construct in Rust: let value = if n &gt; 0 { Some(n) } else { None }; which I'll write as let value = if n &gt; 0 { Some(n) } else { None }; because it makes it harder to miss the binding introduction. Since shadowing is quite useful in Rust, I find having these stand out even more important.
I'm the opposite. I configured `cargo fmt` to match the style I habitually work in as closely as possible and would periodically run it, then use `git gui` to revert the lines which correspond to things I didn't want. (eg. it trying to enforce "either single line or too many linebreaks" in some places.) A few months ago, an update shoved some of the settings I wanted behind "unstable option" barriers and I've been too lazy to rework things to use nightly rustfmt, so I just went back to relying on my habits to enforce coding style as I code.
Because you don't think that some of them haven't been overly mean to the library's maintainers?
You have to make the stream in `Ok(stream)` mutable . Like this `Ok(mut stream)` You are borrowing `stream` here and you need to to borrow it mutably to allow any read or write operations. Another thing is that you don't need your stream to be mutable in the for loop because TcpListener.incoming() return a Result that will get unwrapped by your Ok match arm.
Auto-traits are cancerous
i think their choices work ok. coming from C++ i do like the &lt;T&gt; being 'inplace' in the signature, and c++ has a similar retrofit to allow trailing return types (to facilitate the use of decltype i think?)
Neville is pronounced nevi-me?
No, because don't call people "r*****s".
I found that in really really messy projects, when people do code reviews they tend to only look at style simply because people have "given up". It's simply become too difficult to understand the connection between the reviewed code and the rest of the project. With a less messy project and perhaps a team that work better together, I find that style becomes less important. Like, who cares if a line is longer than 80 lines? Of course one should be careful though, give it enough time and it might go messy anyway..
hehe reminds me of JAI. rust can do it this way because it has a dedicated keyword to introduce a function... what you're showing above makes more sense for a universal way of declaring things (wouldn't need the 'fn' infront). i think you'd have 'struct' behaving similarly if you wanted to go that route? rust is helpful in that the preceding keyword for declarations makes searching really easy .. grep (fn|struct|type..) .. thats sort of thing
When working with design proposals it's not always clear what a "thumb down" means — constructive comments or clear arguments are better. Which comes to the big difficulty with the current process — some issues get so many comments on multiple aspects that it becomes very hard for someone else to get involved. Having multiple issue threads per RFC should help here greatly.
Hi :) Okay so I've spent 2 hours trying to wrap my head around it and I can't quite get it. Say a struct has a method sayit(&amp;self). Am I supposed to Struct::sayit.mock_raw(|_| MockResult::Return(0)); Then what? Say I have a function that takes the struct type fn takeit(struct: &amp;Struct) How do I pass in an instance of Struct, but underneath its actually a spy/mock StructMock?
Nice crate! I'm trying to figure out how to use test_double to switch out real structs with mocked structs and still have functions accept the mock types as if they were real types. Is there a code example?
More like you could write a macro that takes your function, makes a variant meant for a mock (with `#[cfg(test)]` on it so it only compiles for tests), then returns both the original and the variant. Unfortunately, I don't think proc-macros are generally supported, and I'm a bit out of my depth here compared to the people who actually wrote frameworks like mocktopus.
You don't make a new struct so much as modify the existing one with this framework: `MyStruct::my_method.mock_safe(|| MockResult::Return(1));` Now your regular `MyStruct` has a mocked-out method `my_method`. You should still be able to get the effect you want regardless, since these are set-up on a per-test basis.
tyvm. Seems to work now. Did exactly what you said. It validates the acceptable hosts, but doesn't println the messages after listener accept. On the client (curl) it seems that the connection has been established, because there is no error message, ie. connection refused. 
How does that compare to the statically dispatched version?
This is a great tactic, but you don't need to take `core` as a parameter because all its methods are static.
Well actually, you could. And pretty easily of the whole thing is scripted. You'd just need two branches - a branch with the impl, and a branch with the rfc docs (and not the impl). I imagine the work flow would be 1. to fork whatever repo the impl needs to be submitted to, 2. delete all but the master branch (or whatever branch the impl should live in) 3. create an empty, orphaned docs branch for the rfc docs (for th proposal, explainer, faq, etc) 4. Set the docs branch as the primary. It ahold be pretty simple if it's scripted (sounded like it would be)
Thanks! Yeah, `test_double` is a pretty young crate still, so it could really use some more fleshed-out examples. You can see the basics under the "Substituting One Type" heading in the Readme, though. `test_double` relies on renaming imports, so it expects you to structure your code a certain way: * You'll need to have your structs-being-mocked in a separate module from where you're using them in your real code. * You'll also need to have your mock structs in the same module as your structs-being-mocked. In the file where you're using them, add `#[test_double]` immediately above the import for the struct-being-mocked (e.g. `use audio::SoundPlayer;`). This will import `audio::SoundPlayerMock` in tests, and `audio::SoundPlayer` in non-tests. If you'd like to change the name of the mock struct (which defaults to the original name with `Mock` on the end), you can specify it explicitly like `#[test_double(SoundPlayerStandIn)]`. Note that because you're swapping out the type that is used, you will need to substitute it everywhere you import the type in your whole crate, not just in the file you'd like to sub it in for. A headache, but I haven't figured out a way around this yet :P I hope that helps - please let me know if there's anything else I can clear up!
that is because `incoming()` is already accepting the connection. https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.incoming Your thread is currently blocking on `match listener.accept()` waiting for a new connection. If a new connection has been established your `Ok()` arm will execute as normal. After that the for loop starts again and blocks until a new connection has been established You would have to close connections that you aren't from IPs in your Vec manually on the server side for your concept to work.
I really think I need a full example. I've looked at their tests and I'm trying to imitate but I have no idea what I'm doing wrong or right. I want to believe when I do Real::sayit.mock_raw(|_| MockResult::Return(0)); that it "mocks it out", but what does that mean for Mocktopus? All future let real = Real{} are now mocks in the test function? ALl previous instantiations? Does it return a mock? Is the mock supposed to be used inside the anonymous function? I'm trying every variation and my Real struct is not returning 0, its not a mock.
Disclaimer beforehand: I work for Parity. These views are my own, however. That's simply not feasible for a technology that is supposed to facilitate interoperability and innovation. Michelson is essentially carved into stone without a hard fork. We see with the virtual machine used by Ethereum that new instructions are added often because many operations that smart contracts would want to do legitimately are infeasible to write in EVM without inflating the cost of executing your contract immensely. With wasm we can have on-chain code be (almost) as fast as in-client code, which makes innovation orders of magnitude faster - essentially the client updates are baked into the same blockchain data that you're sharing and acheiving consensus on anyway. Instead of having a _seperate_ consensus mechanism for chain updates (the ad-hoc consensus algorithm of "who updates their client") it gets baked into the protocol proper. This is simply impossible with a high-level bespoke language like Michelson because although you could theoretically make it faster than C with enough smart optimisations, the same "smart optimisations beat developers" mentality is supposed to make Haskell outperform C, but it does not. MIchelson is still slow, wasm is already fast and easy to make faster.
If you follow PRs to the main repo, you get a notification every time an RFC is created or moves stages.
The main repo has a list of all RFCs and what stage they're in; PRs get sent to it to transition between stages. So you can always see all of them there.
In Rust 1.27, released later today, there's a lint that's allow-by-deafult for the other syntax. `rustfix` can turn it on and use it to migrate your code. in Rust 2018, it won't be allow anymore.
&gt; I've heard it suggested that proper Rust style is to import up to the last module rather than directly to the items used, and then to use mod::item syntax. It's usually, "import types fully, import the module for functions". However, this is a very weak guideline; it's not *bad* to break it, it's just a good default.
From the learning curve section: &gt; writing Rust requires a very good understanding of the fundamentals behind a computer’s processor and memory model. "Very good" is probably too strong, but this was one of the reasons [Rust in Action](https://www.manning.com/books/rust-in-action) teaches systems programming alongside Rust. Very keen to hear from readers who started with very little experience in either. Hopefully you're much more comfortable with both now!
Fantastic, keep me posted
The specific quote &gt; The main RFC repository &gt; The main RFC repository (named rust-rfcs/rfcs or something like that) would no longer contain content on its own, except possibly the final draft of each RFC text. Instead, it would primarily serve as an index into the other repositories, organized by stage (similar to the TC39 proposals repository). &gt; The purpose of this repository is to make it easy to see “what’s coming” when it comes to Rust. I also hope it can serve as a kind of “jumping off point” for people contributing to Rust, whether that be through design input, implementation work, or other things.
I used to do this, then I started working on projects where I had to conform to *other* people's coding standards. Now I just use whatever the most convenient automatic formatter spits out, in any programming language. Handling unimportant details like formatting is what machines are for.
Cool.
It sounds like the intent is to have an "index" repo that provides a way to navigate the organization, so subscribing to that repo should at least let you know when there are new repos to subscribe to
&gt; Thought: Allow me to be an incredibly jaded cynic and be really mean for a moment; I don’t think the added formality is going to fix the real problem of people having their feelings hurt by a change they dislike making it in. &gt; The charge I observed was that it was too unclear about the changes that were happening. However, just based on looking at the history of the issues, if you were paying reasonably close attention throughout, you pretty much knew what was going on because all the actual change happened over the course of a year plus. Adding the index of changes and their states and having isolated repos for RFCs isn’t going to help anyone who isn’t paying reasonably close attention. If anything, splitting everything up into dozens of repos is going to destroy searchability. I'm hopeful. I will admit there are degrees of "paying close attention" though. If you are completely unplugged from the process, then yes, none of this will help. If there are specific RFCs of interest (module rework, exception semantics, simd/asm) you find out about by TWiR or having a watch on the index repo, then this will be a big help. Modules and exception semantics have had long conversations that are disheartening to keep track of, catch up on, know its status, accidentally miss status changes, etc. For these cases, I'm hopeful that this will make it easier for people to get a pulse of where an RFC is at without having to religiously follow the thread / PR. This will provide better jumping in points like summaries of past discussions (FAQ) and directed conversation about a problem (via dedicated Issues).
What about trying out gitlab for this one?
What about constants? :-D
"Like, who cares if a line is longer than 80 characters?" I do, for one. My vision is pretty impaired, so I normally work on an 80x24 terminal in a 20pt font. Long lines are a huge hassle to read for me.
https://doc.rust-lang.org/std/macro.include_bytes.html
Bare `Trait` was used at Rust 1.0 for dynamic dispatch - eg, in `Box&lt;Trait&gt;`. Later on it was discovered we needed anonymous static dispatch too, as in `impl Trait`. Some would argue that bare `Trait` should have been used for anonymous impls from the start. I wouldn't go that far myself though - there are other interesting things you could do, like Haskell's constraint kinds, so it probably pays to keep that syntax open for a while yet. Anyway `dyn Trait` is being added to make things clearer for humans, the old bare `Trait` syntax is being phased out, and then potentially that could be used for something else in the future.
I'd usually import them, just like variables.
Then, the better approach would be to spawn a new thread upon a new incoming. I'd have to pass the stream to that new thread, is that possible? 
There's no plans to do anything with gitlab at this time.
I've been meaning to propose something similar for a while now, having seen some of the scalability issues in the current RFC process. However, I haven't known if I'd really have the time to get such a proposal through, so it's good to see someone from the core team championing for this. &gt; Each RFC gets its own repository. These are automatically created by a bot. This permits us to use GitHub issues and pull requests to split up conversation. It also permits a RFC to have multiple documents (e.g., a FAQ). You could get most of the benefits of this, with less need for tooling, by still having one RFC repository, but allowing RFCs to be a directory instead of a single file, and just using tags to group pull requests issues by RFC. I feel like one repo per RFC could get pretty cumbersome to track. There are 71 open pull requests for the RFC repo right now. While perhaps there would be fewer active ones due to the filter between the "spitballing" and "designing/prototyping" stage, that's still a lot of repos to manage. Other than that detail, this proposal is pretty close to what I had come up with; which makes sense, as it's a pretty natural evolution of the current RFC process to make it more scalable.
Mocktopus has a different approach to what does it mean for something to be mocked. I can see, that you're already familiar with mocking in some OOP language, where every function is virtual. Mocking framework for such languages are usually based on creation of special OBJECT instance with modified VTable. The mock works only for a single object, because all the other have normal VTables. Function calls in Rust are in 99% cases dispatched statically, so usually there is no VTable to alter. What Mocktopus does is globally modify a FUNCTION, so it runs differently. No matter how many struct instances are created, when a function in its impl is mocked, it works on all their instances. You don't even need structs, you can even mock regular functions. The scope of the mock is only the current thread, so mocking a function during execution of test A does not affect test B, it can have it's own mocks or no mocks at all.
Oh, certainly for other people's codebases. For mine, I'm stubborn and picky to the point that I'm considering designing a "format canary" to tie into pull request CI checks so that, if anyone tries to commit unwanted changes that a stable rustfmt makes mandatory, the pull request will be blocked with an explanation of what changes to undo written to the CI log.
It's harder to track an individual RFC when it's all in one repo; there's no way to only get PRs sent to a particular sub-folder.
[removed]
Just a small question. For a program that needs root privileges to run, what's the best way to go about enforcing that? e.g., printing a \`Error: must run program as root\` message and exiting.
Thanks and I have tried looking at it like that. I assumed a macro rewrote the struct's function. After messing with code for another hour or so now I'm at a point where it wont even compile. I think my unfamiliarity with Rust's attribute system is leading me to misuse the attribute's your crate depends on. I have a complete and minimal gist of what I'm doing here and would really appreciate if you could point what I'm going wrong. Its just a toml and lib.rs file https://gist.github.com/SephVelut/0eb19dbfd35c4fad0f4225a5ec9baa50
nice!
Thank you! :)
Great talk, loved the fact that the slide deck was rendered using Rust/Lyon. I hope being able to take another look at Lyon soon!
&gt; If I remember correctly, the plan is to deprecate the non-intuitive syntaxes (eg. &amp;Trait) and then, in one of the later editions, make it no longer valid syntax so you have to use the more intuitive ones (eg. dyn Trait) `&amp;Trait` would be superseded by `&amp;dyn Trait` rather than `dyn Trait`, right?
This is not quite the way it is for historic reasons, but here are the new rules: - `MyType` is a concrete type. - `impl MyTrait` is a concrete type, but is only advertised as implementing `MyTrait` (users of the function can only use trait methods to access the type). This can be useful for encapsulation. - `dyn MyTrait` again can only be accessed using trait methods, but this time the compiler cannot work out the type at compile time (maybe there is more than 1 type that the value can be). So the compiler tags the value with type information, and resolves the trait methods at runtime. I'm reality if you use `MyTrait`(a trait) without `dyn` or `impl` then it will default to `dyn`. But I think explicitally writing `dyn` is clearer.
Here you go, I hope it helps :) https://gist.github.com/CodeSandwich/82e25d91f4868348adbeff356f49dfa8
How would GitLab help with this?
&gt; When working with design proposals it's not always clear what a "thumb down" means It's equally not always clear what a thumbs up means!
&gt; It is however the opinion of the author of this project that libraries choosing to abstain from unsafe Rust usage when possible should be promoted. I think that's a pretty reasonable stance. Thinking about it, I can see optional unsafe optimizations behind a feature flag becoming a thing if this point of view catches on.
I am doing the exercices in the rust book and got a problem running one of the example excercises: [https://doc.rust-lang.org/book/second-edition/ch12-02-reading-a-file.html](https://doc.rust-lang.org/book/second-edition/ch12-02-reading-a-file.html) When running this on windows and i copy the character's from the example it contains invalid utf-8 characters. Invalid characters: ’ — I am pretty sure i execute the assignment correctly, since after replacing these characters the example works fine, where to report?
This is a really interesting proposal - Turing bless her, and all who sail in her! Mechanics aside, do i understand correctly that part of this proposal is that as much discussion as possible will move from the internals list to the RFC repository? If so that seems really positive to me. IMHO, part of the unhappiness around RFCs has come from a feeling of disconnection between the "team" and the "community"; stepping away from having separate spaces for the team and the community should help assuage that. 
Internals was only for “pre RFCs” before, with all discussion happening for the actual RFC in the main repo. Now it would be almost entirely in the repo for that specific RFC.
Ah yes, in this specific case it should not be necessary since it is stateless. Actually makes me wonder if rustc is smart enough to cull the arguments list (ABI-wise), or if it just blindly passes a pointer anyway.
Oh! I was probably the one approving it. Hadn't realized it would fall off the 1st page so quickly :(
This is great, and I love the name!
Well idk they seem to use non IRC chat apps as well, e.g. gitter or discord. So why not do the same for Github too?
A colleague of mine used to work on an old Perl project with a couple of other, very opinionated, people. Everybody had their own preferred coding style, so what they did was basically: - apply the official style using perltidy - update their check-out - really their personal perltidy style They kept this up for years and we're pretty productive. When people have discussions about style guidelines, I always keep this in mind and push for anything as long as it's automated.
Neat tool! While I agree that unsafe code should be avoided if possible, there are many key areas where it is unavoidable or more efficient to use it. The whole point of many Rust crates is to provide a safe API over unsafe code which is guaranteed by logic or testing beyond what the compiler can provide.
Next step: classification of unsafe usage!
Thanks! This plot twist was indeed the thing around which I built the entire talk :) Let me know if you run into any issue with lyon. 
Yes. 
Can you specify default features in a cargo.toml, such that you can build with those features by only typing "cargo run" or "cargo build" at the command line?
Too late, I did.
Hell yeah! It's working now :D I'm guessing though that I wont be able to use a self reference mocked type with this? Originally my goal was to test if a node will call the same method from a node type passed into it. Something like ` struct Node {next_node: Option&lt;Node&gt;} // impl Node fn call_next(&amp;self) { match self.next_node { Ok(n) =&gt; { n.call_next(); }...... `
GitLab is just as much as third-party as GitHub is. While I use GitLab everyday at work, I just don't see any features that GitLab has that would make this workflow better. 
The best way to do it is probably to just try to do it and display a good error message if it fails due to a permission error. Checking for root is wrong, as it means that a user with all the required permissions as root wont be able to run the program.
I did something similar here: https://github.com/Dushistov/rust_swig/tree/master/c%2B%2B_tests/c%2B%2B/cmake I hope I will find some time to compare solutions.
Long lines also means it's difficult to have code side-by-side
Hi Kibwen, if you could please remove this from the spam filter that would be extremely helpful. Let me know when you need from me to accomplish this.
Rust doesn't provide a C++ FFi, you will need to write a C interface for C++ code in C++ for that.
It'd be really nice to have a way to whitelist certain crates and/or versions. It could make a very nice to have something like this as part of my cargo update process. The process I'm think of could go like this: 1. If a version of a crate, or all versions of it, are white listed it will display in yellow or maybe with a different icon. 2. I could walk through all my red dependencies, check to see if this risk is acceptable and if so add it to my white list. 3. Run cargo update 4. Now I could go through each new red entry and repeat step #2.
No, bindgen supports C++.
Yes. You can list them under a magic feature named `default`. [features] default = ["serde", "use_std"] 
Looks strange for me. I thought that `rls` become ready to use when it will have proper integration with `rustc`. At now real life projects just stuck. It reruns `build.rs`, doesn't use `cargo check` results at so on. Too heavy, too slow, too much disk usage. I can use it for small home projects, but for real one I can only use standalone racer.
Do you mean more classes of unsafe usage or actually trying to verify if the invariants are properly protected at the module level? Either way, +1!
This is the main reason I started this project! The whitelist feature will be implemented. I'm not going to have time for a while though, but please feel free to start a PR!
I was thinking of trying to determine whether `unsafe` was used: - for an inherently unsafe operation (FFI call, SIMD, ...), - or simply to "eke out" some performance (unchecked slice access, ...). The former is somewhat hard to avoid, but can be contained in higher-level libraries exposing a safe interface. The latter, however, should generally be eradicated: - it may be the result of "old code" which is no longer necessary, - or point to pain-points which the language/libraries should seek to address. Many a correctness crime was committed in the name of performance ;)
There is a big design flaw in this snippet, each Node contains another Node by value. This makes size of a single Node infinitely big. What could be done here is make inner Node a reference (or Box, or any other mean of not holding a value): Node&lt;'a&gt; { next_node: Option&lt;&amp;'a Node&lt;'a&gt;&gt; } Then comes a problem with mocking. If you mock call_next, every call to it will run mock closure. The design of Mocktopus is not prepared for such cases. What you COULD do is make mock change behavior for a particular address of self: https://gist.github.com/CodeSandwich/e2b600a9bef58b1d52626f35e60426ae Not pretty, but it works.
&gt; optional unsafe optimizations behind a feature flag I like this idea! That could mean that the optimizations can be benchmarked on and off automatically and notifying the author when a new compiler version has gained the ability to produce as optimized code for the safe version. I had one of those moments not too long ago when I updated to the latest stable and my safe code suddenly slightly outperformed my unsafe version. That was a magic moment and I hope for more of those :D 
Would automatic wrapping help? I tons to have it enabled in my editors and find it very comfortable. But my vision is fine, so I don’t know if that works for you. 
thank you
For something like whitelisting, can it all be done inside your crate or will it need to touch one of the upstream dependencies? I really like the idea of getting something like this in my CI pipeline.
Seeing `&amp;Foo` doesn't tell you whether `Foo` is a struct or a trait, unless you know it beforehand. If `&amp;dyn Foo` is universally used for traits, there's no ambiguity.
"Team champion" seems like a new name for ["RFC shepherd"](https://rust-lang.github.io/rfcs/1068-rust-governance.html). How are they different and how will the system be prevented from falling by the wayside like that one seems to have done? More specifically, how do you go about getting a team champion for an RFC that some team has not already put on their agenda? Of course, if a team member writes an RFC, they can be their own champion, but is there any mechanism for community members to help that priority setting, besides hoping someone notices the RFC repo appearance? 
Any plans to upload anything to Youtube for those of us who'd be interested but can't easily get there?
I've been wondering what happens to postponed RFCs. Is there some kind of visible tracking which says, say, "we're definitely not touching this again until &lt;condition&gt;/&lt;date&gt;" and "we must re-triage this when &lt;condition&gt;/&lt;date&gt; is met"? Could something like that make it into the new process? For instance, I was super excited about ticki's dependent types RFC(s) that are now postponed, presumably indefinitely. It'd be nice to know if/when such topics can be revisited.
I first saw this on twitter, my initial reaction there was this this seems designed for multi-year projects like NLL, and feels very heavyweight for "small" proposals. Maybe it would make sense to have a different process for different proposals? In a way this already happens, with std lib APIs being added as `#[unstable]` without an RFC, and with FCP happening in the tracking issue when stabilization is proposed. However it can be difficult to judge in advance which proposals are "small" and which are gonna attract many comments with multiple sub-issues being discussed (such that having separate threads of discussion would be helpful.)
Hmm, I don't think you can implement `replace_with` in a way that's both panic-safe (in case your `FnOnce` panics, what ends up inside the `Option`?) and at the same time more performant than simple assignments. Btw, it's equivalent to a combination of `as_mut` and [take_mut](https://crates.io/crates/take_mut) and take_mut does extra precautions to handle panics inside the `FnOnce`. Might be worth benchmarking that version too.
Sure, GitLab is third party as well. But you should always hedge your bets. Better have two third parties where you can switch between when one of them does something you don't want than being reliant on one sole third party. This proposal wants to create entirely new repos, so there is no migration cost involved. Definitely a good chance to try out GitLab, no?
Thaaanks! That's what I was lookin' for!
How borrow checker chapter starts: &gt; ... the dreaded enemy lurking within the Rust compiler ... I think it is wrong to call an "enemy" the very thing that in fact is your real friend, even if it is just a figurative speech... 
i always thought there should be a concept of safe vs unsafe crates, e.g. for the main application to know explicitely which imports have unsafe code (for many people wouldn't that just be 'the standard libs and nothing else')
Except that requires getting everybody to sign up for both Github and Gitlab to properly contribute to Rust, whereas it's possible to stay on one comms platform for whatever area you want to contribute to.
They're similar, but different. I left a comment on internals about this: https://internals.rust-lang.org/t/blog-post-proposal-for-a-staged-rfc-process/7766/11?u=steveklabnik
We're not sure about that yet; it's possible that, beyond the phases involved, there could be a postponed list as well. RFC 2000 was accepted, by the way. Not full dependent types, but a step. Those would need to at least make it to nightly before bothering to talk about extending it, so basically "not until next year".
Chris posted this on internals; not a direct response, but sorta: https://internals.rust-lang.org/t/blog-post-proposal-for-a-staged-rfc-process/7766/12?u=steveklabnik
It can be done in cargo-geiger. I stole... eh, borrowed... all of cargo-osha and cargo-tree so it should be fairly easy to add this feature. I merged the two git histories to make it clear that I did not write the while thing and to hopefully make it easier to depend on those two projects at a later time if they refactor into application and library parts. The main upstream deps are the cargo and syn crates.
... and may be a link to RFC / best practices ... May be a paragraph or two in the cargo book -- this topic is indeed hard to find any information on.
Yes, it's been removed from the spam filter for a while and it's ended up with about 500 views, which isn't too horrible, my comment above is just noting that it probably could have had more visibility given ideal circumstances. At this point, tell you what: if you're still seeking applicants for this position next week, then feel free to repost this job ad then, and if anyone gives you guff for posting the same ad then link to this comment to prove that you have the approval of the mods. :)
No problem, normally I click remove to get posts like this out of the queue so that another moderator doesn't end up doing just that, but I forgot this time. :)
It seems a sensible convention to put some kind of a reason for the unsafe in or near the unsafe, e.g. unsafe { // reason lolwhat(|wtf| omgbad(wtf)).unwrap() } or unsafe("reason") { lolwhat(|wtf| omgbad(wtf)).unwrap() } which means this is valid, too: unsafe("This is a paragraph about the reason this is super ok for right now maybe check back periodically?") { lolwhat(|wtf| omgbad(wtf)).unwrap() } Or something more technical unsafe(unsafe::reasons::OK_WHATEVER) { lolwhat(|wtf| omgbad(wtf)).unwrap() } All of which could be achieved now-ish with some kind of macro: unsafe_with_reason!(unsafe::reasons::OK_WHATEVER) { lolwhat(|wtf| omgbad(wtf)).unwrap() } which would maybe expand to something like unsafe { // unsafe::reasons::OK_WHATEVER lolwhat(|wtf| omgbad(wtf)).unwrap() } or unsafe { unsafe_recorder::record(unsafe::reasons::OK_WHATEVER); lolwhat(|wtf| omgbad(wtf)).unwrap() } 
Identifying pure FFI would be very nice indeed. &gt; it may be the result of "old code" which is no longer necessary, This would be super cool to identify, maybe rustfix or clippy could do a better job at such things or would it belong in cargo-geiger? The initial idea for this tool was to give a birds eye view of the entire project and its dependencies and not really dig into if the unsafe usage was sound or not. But this direction is very tempting. I will need to think about it. In the meantime please feel free to bombard with PRs and issues :)
You can sign into GitLab using your Github account. So you only have to register on Github. Surely there'd be some fracturing, but that hasn't prevented from some WG's being only present on gitter or discord.
It's kinda funny in the example that curl-sys is safe, despite it just being unsafe C apis.
&gt; i always thought there should be a concept of safe vs unsafe crates This is indeed the kind of itch cargo-geiger is trying to scratch.
Yessssss 👍
Depends on whom you have in mind to read your code and what you want to achieve. Since 99% of the code I write in Rust I really can't care much of if others find it readable I throw it all out and use a some-what lisp-like formatting style because that is more readable to _my_ eyes and I think: } } }); } Is highly distracting. If you expect your audience to have trouble with an unorthodox style because they're older or whatever then it might be best to stick to the standard; if you expect the reader to be more neuroplastic it might be prudent to even come with a new style specifically suited for the project's needs if you expect the audience to adapt to it quickly.
Yes I thought the same thing, my guess is that it uses bindgen from a build.rs script. Should bindgen generated unsafe count as unsafe? Seems like a special case, maybe a new metric?
The design is the fracture discussions within the RFC, not fracture discussion in general.
I certainly don't have enough expertise in this, but here is my implementation which seems to work as a drop-in replacement for the `mem::*` incantations of the `merge` implementation of the benchmark (the performance and the assembly code are the same): trait OptionExt&lt;T&gt; { #[inline] fn replace_with&lt;F&gt;(&amp;mut self, f: F) where F: FnOnce(Option&lt;T&gt;) -&gt; Option&lt;T&gt;; } impl&lt;T&gt; OptionExt&lt;T&gt; for Option&lt;T&gt; { #[inline] fn replace_with&lt;F&gt;(&amp;mut self, f: F) where F: FnOnce(Option&lt;T&gt;) -&gt; Option&lt;T&gt; { let mut x = f(self.take()); mem::swap(self, &amp;mut x); debug_assert!(x.is_none()); mem::forget(x); } } The `split_binary` implementation is trickier, I am still trying to figure out how I would use `replace_with` in that case.
Because the inconsistenties often serve a purpose and the logical structure of a program does not always match the human perception thereof. Some of these exceptions are built into Rust itself with how "else if" in Rust is special which it isn't in C to match the human intuition. If they didn't do that it every "else if" branch would indent one level deeper than the former if it just obeyed the logical structure. Like is it really necessarily to if your file is one giant `main` function and has nothing more to indent the _entire_ thing one level and waste an indent? I personally oppose that and many languages have such special exceptions like that in Haskell `module Foo where` does _not_ cause an indent even though in theory it should; it's a case of where the man and the machine disagree and ultimately readability is important to men and not to machines because no matter how you format it machines find it readable. I also personally believe that in practice this: if !condition { break } do_something; if !other_condition { break } Inside of loop really is worse than: if !condition { break } do_something; if !other_condition { break } And rustfmt generates the former purely due to the braces and if someone claims that the former is actually better than why doesn't the same thing apply to match blocks? The only difference is that braces are optional there and Rustfmt does a similar thing when you add the braces but when you don't put the braces it indeed puts it on one line. I think most men find: match something { Foo =&gt; break, Bar =&gt; continue, ... } To be a lot better and less distracting than: match something { Foo =&gt; { break }, Bar =&gt; { continue, } ... } And the same principle also applies to if-statements where braces are mandatory which triggers rustfmt to put it on its own line. When code becomes more readable if the clause is on its own line is a very subjective and human-like judgement call that machines are bad at. And in the end men make these calls all the time. When are positional arguments vs keyword arguments better for instance? You make a human judgement call based on what you think enhances the readability.
Thanks for the response! I do follow development relatively closely and that at least jives with what I had assumed given the multi-part proposal, roadmap, and general focus on the edition. Though my curiosity extends more generally than that one feature. Like, is it appropriate to revive discussion annually when the next roadmap is being planned to suggest &lt;feature&gt; be a goal for the next year? Is it required that &lt;other feature&gt; is in nightly/stable before discussion can even begin again? Is there any commitment to at least say by some date "we're still not considering this until &lt;revised conditions&gt;"? Given that something being postponed implies it's a good enough idea to revisit in the future it would be nice if there were some way to track, view, and otherwise ensure that future follow-through, even if that just results in further postponing for some reason or moving something from postponed to rejected.
Succinct and apropos
You make the claim that Rust is hard to learn, but apart from the historical wart, the dyn keyword makes the semantics more explicit, thus easier to learn.
Oh totally, I agree that this is an important set of questions; just figured I'd provide some context for the specific situation you mentioned.
&gt; Another confusing situation is returning a reference to a trait - this doesn't use dynamic dispatch, but will it still require the &amp;dyn keyword? Everything that uses `dyn` keyword would use dynamic dispatch (that's what the keyword mean ;)) &gt; Also confusing - is there any relationship between impl as used to impl structs, and impl as used to pass traits to a monomorphized function? Or are these effectively completely different meanings for the same keyword? (Reminds me of static in C++...) Yeah, it may be a little confusing. But you can think that there's a relation – `impl Trait` means "any Struct that has an `impl Trait for Struct { ... }`. &gt; IMHO, for somebody learning the language for the first time, Trait / &amp;Trait are more consistent with Struct / &amp;Struct than impl Trait / &amp;dyn Trait. There are more than two choices – it's not just `impl Trait` vs `&amp;dyn Trait` here: Note that there both `impl Trait` *and* `&amp;impl Trait` (and `&amp;mut impl Trait`) can be used in Rust! And also, there is a plan to make Rust support naked `dyn Trait` in addition to `&amp;/&amp;mut/Box/Rc/... dyn Trait`. For me, the hugest benefit for ditching bare `Trait` syntax is to allow an error message when somebody tries to eg. `fn foo(x: &amp;Display)`: _In Rust, a trait is not a type. To use dynamic dispatch, use `dyn Display`, to create a generic function, use `impl Display`_. (you can imagine `dyn` and `impl` keywords as "functions" that convert a trait to a type, both in a different way)
I think [colindean's comment](https://www.reddit.com/r/rust/comments/8ssjv2/_/e12dumj?context=1000) provides some neat ideas for that.
Agree, it gets more and more confusing.
I'd prefer to make it a warning if there is no (doc) comment before `unsafe`..
Really cool project! I'll definitely be using this myself if just to check it out :). That being said, which I think 0 unsafe code should be the goal, it's unrealistic to demand crates adhere strictly to that standard in the case of FFI and talking to hardware. I'm worried that the community is actively turning off would-be users with reactions like the one recently to the Actix-Web project. Reactions like "unsafe code is bad and this project is bad and you should feel" are damaging and will turn people off to the Rust community.
Amen to that. :) I'm actually from Berlin. ;)
I've read all of the parts in this series as they appeared, and found it really nice. It's a great overview from someone experienced with Go with how Rust works and why they have ported their project over. If you need to convince someone to investigate Rust, you could definitely do worse than pointing them at this stuff. 
I've been thinking about doing this. Or at least getting it started in my project READMEs. Maybe something like a "Use of Unsafe" heading and give a broad overview of how it's used, if at all.
I think every reaction in that thread was more nuanced than that (as it should be).
When it comes to `#[must_use]`, wouldn't it be possible for the compiler to add it to any function without side-effects? That is a whole class of functions that would be wasted if the result wasn't used, and I believe the compiler has enough information to classify functions as side-effect-free or not.
Maybe look for `extern "C"` symbols associated with the `unsafe` call and optionally exclude those from the list? You shouldn't need to track through generics (though `use` aliases can frustrate it) so it shouldn't be much more than a couple greps for an 80% solution here.
If you know the code compiles, yes. This sounds like the same rationale given by people who don't agree with type inference though, and my response here would be the same - if you don't even know `Foo` is a trait, then you probably don't know enough about it to understand how it's being used either.
&gt; I believe the compiler has enough information to classify functions as side-effect-free or not. This would be the part that I'm not so sure about.
Next year `rustfix` will be released, and also it will be the Year of the Linux Desktop. 
It's already pretty usable! https://github.com/rust-lang-nursery/rustfix
That explanation of impl &lt;-&gt; impl Trait is pretty good, thanks. I hadn't realized that &amp;impl Trait is possible, that does help clear things up. Would bare dyn Trait then take anything (&amp;mut/Box/Rc) that can do dynamic dispatch? That does at least make more sense. Traits not being a type is an interesting perspective to the whole affair. I don't understand what that practically means - although right now that seems like it just makes things more complicated. Sorry for the lack of formatting / quoting here, I'm in a bit of a rush right now but wanted to get a response off.
Interesting in the faster/SIMD example that the name of the operation is different `recip` vs `rsqrt`. Was that by design?
Awesome. Sorry if I seemed dismissive, I just wanted to make a joke about the sheer number of release announcements that say "rustfix will totally be able to do this for you Real Soon Now!". 
I agree, that seems like the whole `pure fn` debate again. There's no clear definition of "side-effect free". 
&gt; When designing the language, we *though* that the similarity here was a good thing typo
SIMD on stable! finally!
It helps, but really it's about the semantics of the line: when a human breaks a line, they tend to break it at a semantically-meaningful place.
Ah. So there's a difference here, in the comment you said `fn Option::replace_with(&amp;mut self, f: F) -&gt; () where F: FnOnce(T) -&gt; T` and above it is `fn replace_with&lt;F&gt;(&amp;mut self, f: F) where F: FnOnce(Option&lt;T&gt;) -&gt; Option&lt;T&gt;` - i e, now `f` takes and gives away `Option&lt;T&gt;` instead of `T`. Yeah, so in this version it probably makes more sense, if that's what's required for best performance - I would still prefer if the optimizer could be more intelligent about this though and skip dropping things that are always `None`.
Thanks!
It's cool, I totally understand.
I copied it from `faster`'s README, so you'd have to ask them.
Pick the best bits, weld them together, call it leadvest?
I'm also not too sure about it, but I could imagine a dumb version that checked whether any arguments are mutable, if not stick a `#[must_use]` on it. It would then still be wrong in if `unsafe` is used inside the body to mutate state somewhere, or if global mutable state is touched. Perhaps even more cases, but I can't think of any atm. A related thought, IIRC the compiler sometimes optimizes functions calls into no-ops if they aren't used. I'm not sure whether `rustc` is responsible for this, or whether it's LLVM, but perhaps this information could be used for the purpose of classifying pure-ness of functions too. This is just an uninformed tangent though, so maybe I'm completely wrong here.
&gt; that checked whether any arguments are mutable, if not stick a #[must_use] on it. Rust code can make all kinds of side effects even with immutable parameters. A single `println!` messes this heuristic up, for example.
Ah, you're right, completely overlooked that. It would be nice if it could be derived, but perhaps that's not possible.
Could it just check whether the function parameters have any mutable arguments? The only case where this would not necessarily work is if a function takes an immutable reference to something that has interior mutability like a RefCell, but I don't think that is a very common case.
It can't, you're missing tons of other cases. Globals, various form of I/O...
Is a load a side-effect? Or a store? Depends on the cache line or page it falls in, I guess.
That's a great idea. I'll look in to it for next time around. I know we have a Polycom video conferencing system in the room - anyone know how to record/stream a SIP call?
&gt;Who’s in control? One important thing to notice here – and remember this, it’ll be important next time when we talk about impl Trait – is who’s in control of the type when we’re dealing with generic arguments or generic return types. &gt; &gt;When we have a generic argument type, we’re basically saying “for any type T which satisfies this trait constraint, I will do the right thing.” That means that the caller in control of the type: when I call some generic function with a concrete type, I as the caller have control over the type that goes in. &gt; &gt;When we have a generic return type, we’re basically saying “I will give you some type T which satisfies this trait constraint.” That means the function itself is in control of the type you get back. &gt; &gt;This starts taking us into some interesting type theory ground – specifically, into universal and existential types. We’ll talk a bit more about that next time in the impl Trait discussion. For now, just try to internalize the notion that for generics with trait bounds in argument position, the function will take any matching trait; for generics with trait bounds in return position, the function will return some matching trait. You're getting confused here between `fn foo&lt;T: Trait&gt;() -&gt; T` and `fn foo() -&gt; impl Trait`. The former is a *universal* type in return position. The latter is an *existential* type in return position. Both are possible, but in the script you claim that all types in return position are existential, and that is not correct. For a more concrete example, in `iter.collect::&lt;Vec&lt;_&gt;&gt;()`, the *caller* clearly selects the return type, not the callee: it's universal. Hopefully this clears up the confusion but if you'd like I can provide a better explanation or (better yet) a source which can explain it better than I can. =)
There's an RFC for this at the moment: https://github.com/rust-lang/rfcs/pull/2450
See this discussion as well: [https://www.reddit.com/r/rust/comments/8sqiin/newbie\_question\_why\_is\_the\_impl\_and\_dyn\_in\_the/e11h1gt](https://www.reddit.com/r/rust/comments/8sqiin/newbie_question_why_is_the_impl_and_dyn_in_the/e11h1gt)
At this point they look about the same performance.
Ugh this is really confusing me. So I have a C module (acting to wrap a C++ api) that needs to be built when there are changes to it. (This is all Visual Studio 2017 - Community edition), and then the resulting libs are moved to the correct spot for linking the Rust code. However, when running a call to devenv.exe, I keep getting this error: "Access is deined. (os error 5)" If I run the exact same call and arguments in the same command line I ran cargo build in, the call works. &gt; Running command... "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\IDE\\devenv.exe" [".\\clr_c_api\\clr_c_api.sln", "/Clean", &gt; "static_debug", "/Project", "clr_c_api"] &gt; &gt; --- stderr &gt; thread 'main' panicked at 'Command failed! Access is denied. (os &gt; error 5)', build.rs:82:19 &gt; note: Run with `RUST_BACKTRACE=1` for a backtrace. What the heck is going on here? I'm stumped. Here's a quick paste of the relevant code: https://paste.ee/p/ggARL 
Formatting issue: The `dyn Trait` section header winds up having a font size that's about the same as the body. I think that's because the `&lt;code&gt;` tag hardcodes a specific font size that overrides `&lt;h3&gt;`. I'm not sure what the right fix is for that.
For the record, the Go community has since mostly moved to build stage based Dockerfile setups as well.
Ugh, thanks.
Is Fra-gee-lay?
Added the extern "C" idea to the FFI issue: https://github.com/anderejd/cargo-geiger/issues/6
It's Italian
The compiler is often able to optimise away non-polymorphic indirect calls but (without a JIT) polymorphic dispatch has a guaranteed runtime cost. A `&amp;dyn Trait`/`&amp;Trait` is *always* a fat pointer (i.e. a pointer to the object and a pointer to the trait's vtable). A `&amp;` to any non-DST is *always* a thin pointer. Not sure what you're referring to when you say: &gt; Another confusing situation is returning a reference to a trait - this doesn't use dynamic dispatch The closest thing to a "reference to a trait" is a `&amp;impl Trait`, but that's still not a "reference to a trait", it's a reference to an object that implements a trait.
There are two `sqrt` calls in the original, so `rsqrt` is not just replacing `recip`, but one `sqrt` and `recip`; it looks like a reciprocal square root operation.
Too bad the https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&amp;lang2=gpp site went away. Big C/C++ conspiracy?
Isn't this shutting down soon though?
Looking at [unreachable_unchecked](https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html), I can't even imagine the mayhem one could cause with it. And to think, in some languages, that's the status quo.
If it is, smells like a big C/C++ conspiracy to shut down the truth.
Yep, you're totally right – someone noted the same to me elsewhere. I'll issue a correction in the next episode. I originally had that discussion right next to the `impl Trait` discussion that is now going to be part of e025 and got myself turned around mentally when I split it apart. Much facepalm.
For people who want to try `rustfix`: ``` cargo +nightly install cargo-fix RUSTFLAGS='-W rust-2018-idioms' cargo +nightly fix ```
`use std::hint::unreachable_unchecked as nasal_demons;`
`use std::hint::unreachable_unchecked as nasal_demons;`
You can also use `cargo fix --prepare-for 2018` :)
At the same time I'm really excited to have additional capability to communicate invariants to the optimizer! But... Cautiously... I'd be interested in a flag that can swap between this and good old unreachable!(), with the note that it shouldn't be tied to release mode.
I tried it: ``` $ rustup toolchain list stable-x86_64-unknown-linux-gnu (default) nightly-x86_64-unknown-linux-gnu $ echo $RUSTFLAGS $ cargo fix --prepare-for 2018 Checking rust-dyn-trait-test v0.1.0 (file:///…/rust-dyn-trait-test) error[E0602]: unknown lint: `rust_2018_compatibility` | = note: requested on the command line with `-W rust_2018_compatibility` error: aborting due to previous error For more information about this error, try `rustc --explain E0602`. error: Could not compile `rust-dyn-trait-test`. To learn more, run the command again with --verbose. ```
They’re moving, I thinks
You can emulate this yourself with a cargo feature.
Has to be done on nightly.
I remember `eat_my_laundry()` was a proposed name, along with `undefined_behavior()`.
It would be nice if they upgraded to a computer that wans't from 10 years ago and reran all of the benchmarks, but even on that ancient machine, SIMD is important.
Why is `*const as *mut` undefined behaviour, but using UnsafeCell, which essentially does the same, is not? Does the compiler "know" about UnsafeCell (i.e. is it some special type in the compiler)? I mean I get that Rust optimizes `*const` and `*mut` differently, because it knows that `*mut` never has more than one owner at a time. What I don't get is what makes UnsafeCell so special - it [literally does the same thing](https://doc.rust-lang.org/src/core/cell.rs.html#1347-1349) - why is this not UB?
Awesome, thank you! `cargo-osha` has served its purpose then: to inspire other people to make something better. ;-)
&gt;Would bare dyn Trait then take anything (&amp;mut/Box/Rc) that can do dynamic dispatch? That does at least make more sense. If you're asking whether you can put `dyn Trait` behind any kind of pointer then right, that's exactly how it works. If you're asking about future Rust with naked `dyn Trait` support then... you're kind of right too. This would require for Rust to understand "move the object out conceptually, but don't free the memory", which is not really supported now. But that's a whole another topic and I won't dive into it now. &gt;Traits not being a type is an interesting perspective to the whole affair. I don't understand what that practically means - although right now that seems like it just makes things more complicated. Think about nouns and adjectives. The "car" and "lake" are nouns. The "pretty" is an adjective, not a noun. But "something pretty" can be used in a purpose of a noun. Similarly as `i32` and `String` are structs and `Display` is a trait, not a struct. But "something Displayable" can be used as a struct. The thing is, in Rust there are two ways to say "something" – `impl` and `dyn`. I hope it made things more clear rather than less :)
Hm. Barring internal mutability, I'd say "takes only references, or no arguments, and performs no system calls". I would imagine the compiler can determine this in the case of statically linked code?
Option.filter()! Yes!
&gt; TL;DR - It's about performance (static dispatch, impl Trait) vs. code-size (dynamic dispatch, dyn Trait/Trait/Box&lt;Trait&gt;) There is another reason to use trait objects: storing a collection of items that aren't necessarily the same type and that you don't know all the variants (so you can't just use an enum).
How would you compare this to https://crates.io/crates/send_wrapper ?
Is this a binding to the the reference implementation or a separate implementation?
Right now, it's a binding to the reference implementation. However, the API is designed so that once I write a separate Rust implementation (TBD), the user can easily choose to use it. Backend::C and Backend::Rust are just configuration options. However, Backend::Rust is not yet implemented.
Why would one want this, exactly?
/r/playrust
You're probably right that the community as a whole doesn't demand 0 unsafe anywhere, and I can only respond to own experiences - the reason I'm saying this is exactly because I did come away disappointed. This is probably not the right place to voice this, being a post announcing someone's personal project - but I feel it's worth saying just because of how disheartening it was to me personally.
Basically, it's a pointer to a pointer, where the kind of data isn't defined. The reason you might want a pointer to a pointer is if you might need to modify the pointer rather than the data it points to. In Rust, you might want a function that does this to take a `&amp;mut` to a `Box&lt;_&gt;` because you want to be able to modify the `Box` itself rather than just its contents. In C, this would be represented by `void**`.
Whoops. I thought this was r/playrust update patchnotes for a second and was very confused.
I think you got the wrong subreddit buddy
I also ran into a need for this when trying to implement the visitor pattern as a trait in my compiler. Hoping generic associated types come soon! :( /// A visitor over terms pub trait TermVisitor&lt;T&gt; { fn on_ann(&amp;self, term: T, ty: T) -&gt; T; fn on_universe(&amp;self, level: Level) -&gt; T; fn on_literal(&amp;self, literal: &amp;Literal) -&gt; T; fn on_var(&amp;self, var: &amp;Var) -&gt; T; fn on_pi(&amp;self, name: &amp;Name, ann: T, body: T) -&gt; T; fn on_lam(&amp;self, name: &amp;Name, ann: T, body: T) -&gt; T; fn on_app(&amp;self, term: T, arg: T) -&gt; T; fn on_if(&amp;self, pred: T, if_true: T, if_false: T) -&gt; T; fn on_record_ty(&amp;self, label: &amp;Label, ann: T, body: T) -&gt; T; fn on_record_ty_empty(&amp;self) -&gt; T; fn on_record(&amp;self, label: &amp;Label, term: T, body: T) -&gt; T; fn on_record_empty(&amp;self) -&gt; T; fn on_proj(&amp;self, term: T, label: &amp;Label) -&gt; T; // FIXME: Use a visitor for the elems // Requires generic associated types though :( // // type ArrayVisitor&lt;T&gt;: TermArrayVisitor&lt;T&gt; // fn on_array(&amp;self) -&gt; Self::ArrayVisitor&lt;T&gt;; fn on_array(&amp;self, elems: Vec&lt;T&gt;) -&gt; T; }
It can be used to eliminate conditionals, making your code a little bit faster. consider a simplified example from the description: a.unwrap_or_else(|| unsafe { unreachable_unchecked() }) When the compiler notices the **unreachable_unchecked()**, it is allowed to assume that you have proved that this cannot ever be reached. This means it can work it's way backward from there, to the if statement inside **unwrap_or_else()**, and delete not only all the code that would be emitted for the or_else path, but also the conditional and the branch, resulting in straight-line code that just unwraps the value without any checking. Of course, if the value in fact was None, this will cause UB and probably some kind of memory corruption.
Sometimes, you know better than the compiler. This is for those times.
Steve please stop making me want to bump Diesel's minimum supported version every release. Thanks. (This time it was `Option::filter`)
Thanks! Found a nice video on the Rust channel which covers this in more detail: https://www.youtube.com/watch?v=ctffjzdgGvc
&gt;Should bindgen generated unsafe count as unsafe? Of course, it's the code that rustc sees that counts
This is the location after the move IIRC.
This is the same as in C++ though. Those kinds of items need to be defined in a header.
Speaking of, I have an [issue open](https://github.com/rust-lang/rust-www/issues/1120) to fix this in the Rust FAQ that nobody has interacted with yet.
That's cool. I would also love to have a tool to Audit usage of unsafe code. Ideally, list unsafe blocks in my repositories and force myself to write a comment explaining why something is ok.
/r/playrust
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: /r/Serendipity/comments/8sxlzm/announcing_typedarena_version_140_now_with_no_std/
Should with for const fns
If you don't mind me asking: how are gas prices calculated on top of wasmi right now? Does this also mean that gas prices would go down comparatively because wasm is more efficient?
Have you tried following the bindgen [tutorial](https://rust-lang-nursery.github.io/rust-bindgen/tutorial-0.html)? It helped me get started. There are some [quirks](https://rust-lang-nursery.github.io/rust-bindgen/cpp.html#unsupported-features) when using it with C++. I would suggest reading [Generating Bindings to C++](https://rust-lang-nursery.github.io/rust-bindgen/cpp.html#generating-bindings-to-c) and the [FAQ](https://rust-lang-nursery.github.io/rust-bindgen/faq.html), then creating your own super small C++ lib that doesn't step into any of the bindgen unsupported features. After you can make this work, try to generate the bindings for a real library.
I am having the exact same issue. It started today for me.
&gt; IMO It is big and complex enough that it deserves its own function with documentation. Yup, it actually forms the entire body of a function in my code. I also agree that it might as well have for loops then. I am still trying to suss out when to use the "functional style" (not sure what to call it) versus the for loops.
I think there are some weird formatting errors going on, making it difficult to read stuff. I found that it is better to share code using github gists (or something like it), or the playground. Otherwise, you have to put 4 white spaces before every line of code. For some reason, reddit doesn't get triple `, like most markup.
Another idea but one with tons of edge cases, some kind of weighting system based on the errors if the unsafe block is removed, size of the block, or frequency of blocks. For example if the only errors when removing the unsafe keyword is a call to other unsafe code, it probably identifies an FFI or similar call. Similarly FFI calls or wrappers are likely to have pretty few LoC around the unsafe block (or at least the should), and some kind of metric for "probably safe" "unsafe" and "sketchy" would be helpful for knowing what is worth auditing first. 
Same for x86_64-pc-windows-msvc on Win10.
As I mentioned when this was being discussed in an issue, I *still* think the better, safer choice for 99.9% of users is to just make owned copies of whatever data is essential if they wish to make something `!Send` into something `Send`. A few copies is nothing compared to managing to screw up and trigger UB. XD
It looks like send-wrapper used `ThreadId`, which the OS is allowed to and will recycle. You could move a value off the thread, it can terminate, and a new thread can be started with that ID. Fragile uses a combination of a static atomic u64 and thread_local to increment it on each new thread, so less likely to be reused. You'd need to cycle through some quintillion threads before it wraps.
I have updated just now.
https://docs.rs/argonautica/0.1.3/argonautica/#configuration let mut hasher = Hasher::default(); hasher .configure_backend(Backend::C) // Default is `Backend::C` // 👆 argonautica was designed to support multiple backends (meaning multiple // implementations of the underlying Argon2 algorithm). // [snip] .configure_cpu_pool(CpuPool::new(2)) // 👆 There are two non-blocking methods on `Hasher` that perform computation on // a separate thread and return a `Future` instead of a `Result` (`hash_non_blocking` // and `hash_raw_non_blocking`). // [snip] .configure_hash_len(16) // Default is `32` // 👆 The hash length in bytes is configurable. The default is 32. This is probably // a good number to use. 16 is also probably fine. You probably shouldn't go below 16 ... This configuration example (every possible config + default values + explanatory comments) is super helpful. I love it!
/r/playrust
Note that this is already kinda possible if you synthesize void enums and "read" them. There's an `unreachable` crate that provides this
rustfix has been able to do most fixes for like a year now, and it's been improving recently both from a functionality and UX side. It's just that we're trying to coordinate announcements about the edition.
Same problem on Ubuntu 18.04.
In the benchmarks, what was the quality setting used for zlib?
Wouldn't this example be cleaner with something like unsafe { a.unwrap_unchecked() }
I think you're looking for [/r/playrust](https://www.reddit.com/r/playrust/)... 
/r/playrust
Enums
Make an enum containing each case.
[Use an enum](https://doc.rust-lang.org/book/second-edition/ch06-01-defining-an-enum.html). It's the one thing that all of the „traditional“ languages can't do. It's the first thing you learn when starting Rust.
oh yeah... *facepalms*
No. That would be a special case function that only solves that one problem. `unreachable_unchecked()` is a general solution that applies anywhere, not just with `unwrap()`. Creating a thousand insanely dangerous functions is not cleaner than creating a single one which can easily be grepped for. It shouldn't be "easy" or "clean" to use it anyways, since the decision to use it shouldn't be taken lightly. Typing out that code for `unwrap_or_else` is no real obstacle to implementation if careful thought has decided this must be done, of course.
What types do you want to return? Maybe you can use Any
You're looking for /r/playrust
/r/playrustserver
damn, more crates with no_std support make me an happy otter!
I honestly couldn't get `rustfix` to apply even a single fix when I tried earlier using the `cargo fix` wrapper. I tried using camelCase on a struct field, which the compiler definitely provided a suggestion on, and I tried unused imports, but I didn't have time to try much more. It was always saying it didn't find any suggestions.
Not too late, I removed your comment. Please follow our CoC when posting or commenting here.
This shirt reminds me of rust https://www.amazon.com/dp/B07DJ2M1CK?ref_=pe_2196150_146773810
\+1 on osx
Suggestion: reverse the order of the `any` and the `target_feature` clauses here: #[cfg(all(any(target_arch = "x86", target_arch = "x86_64"), target_feature = "avx2"))] It took me a bit to realise the `all` wasn't redundant, because counting closing parens in hard. It also doesn't help when you do vertical alignment, but align to the wrong thing :P
Excellent name choice!
What ever happened to that neural network that filtered these? I loved that talk!
The `Fragile&lt;T&gt;` type sounds like `SendCell&lt;T&gt;` from the [send-cell](https://crates.io/crates/send-cell). I've written that one a while ago for being able to send GTK objects between different threads (they are inherently not `Send`), or even into closure function parameters that *might* be called from another thread but the application ensures (and the compiler can't) that it is actually always called from the same thread again. An example of the latter is (`glib::idle_add`)[http://gtk-rs.org/docs/glib/source/fn.idle_add.html], which allows any closure from any thread to be scheduled to run on the thread that runs the main loop. As such the closure must have be `Send`, but if the application calls this very function from that thread already, the `Send` bound is not actually needed (it's the same thread after all).
I think you missed something :-D.
That single example would be (locally) clearer, but `unreachable_unchecked` is a general purpose function that can be used for micro-optimizing other things too, e.g. `match`s on any `enum` (`... SomeVariant(_) =&gt; unreachable_unchecked() ...`), or to convey assumptions to the compiler without dynamic checks (I suspect if `assert!(x.len() == 10)` is changed to `if x.len() != 10 { unreachable_unchecked() }` then there won't be any actual checks or branches, but the compiler may work out that `x.len() == 10` after that `if`).
When would one opt to use an arena? Considering Rust doesn't have GC, it doesn't need to reuse memory to alleviate that. Can anyone share their use cases?
Creating a copy of some type doesn't make it magically implement `Send` though, unless I'm misunderstanding what you mean. Creating copies can usually only solve the problem of not having `Sync`, and for that `Mutex` and `Arc` are other possible solutions depending on what actual behaviour you need in the end. See also my comment [here](https://www.reddit.com/r/rust/comments/8svbeg/feedback_wanted_fragile_crate_send_non_send_data/e13eil5/) for an use-case of such a `Send`-wrapper.
Same on macOS 10.13
I made a pull request to use unreachable_unchecked :p : https://github.com/rust-lang/rust/pull/51653
What? 😅
I filed a [bug](https://github.com/rust-lang/rust/issues/51699). 
Are there any lessons to be learned from there being so many soundness bugs in default match bindings? 
If you mean gas prices compared to EVM then yes!
I'm guessing he meant a link of some type to your project.
Edited the post 😅
There are two big difference between this crate's `Fragile&lt;T&gt;` and send-cell's `SendCell&lt;T&gt;`. The first one is an implementation detail: send-cell uses `ThreadId` which I think is not safe to use for this purpose. But the second is how it handles destructors. `Fragile&lt;T&gt;` will not panic if the enclosed type does not have a destructor and the dropping happens in another thread.
Is the Rust book already updated about this dyn Treat feature?
It think it helps with dealing with cyclic references, since your references are now just pointers into the arena. Borrowck doesn't cause issues any more
Ubuntu 18.04: $ rustup update info: syncing channel updates for 'stable-x86\_64-unknown-linux-gnu' info: syncing channel updates for 'nightly-x86\_64-unknown-linux-gnu' info: latest update on 2018-06-22, rust version 1.28.0-nightly (662c70a59 2018-06-21) info: downloading component 'rustc' error: failed to parse url: 1.28.0-nightly (662c70a59 2018-06-21)/2018-06-22/rustc-nightly-x86\_64-unknown-linux-gnu.tar.xz info: checking for self-updates stable-x86\_64-unknown-linux-gnu unchanged - rustc 1.27.0 (3eda71b00 2018-06-19) nightly-x86\_64-unknown-linux-gnu update failed - rustc 1.28.0-nightly (f28c7aef7 2018-06-19)
Hey, I contributed to rust for the first time during this release period (PR [here](https://github.com/rust-lang/rust/pull/50772)). Why do I not appear on the contributors list? Neither in the 1.27 section, nor in the all time section? :(
Rust is built on enums. I find I use enums _a lot_. Rust enums, combined with pattern matching is the feature I miss most when going back to other languages. 
If you have to allocate a lot of values, with little to no deallocation, an arena reduces the cost of each single allocation to a pointer bump, then when all those values aren't needed anymore, the whole arena can be dropped at once. This can improve perf measurably on some workloads.
Yes, I think your implementation is better because of both reasons. I didn't think of `ThreadId` being recycleable by the OS. Maybe I'll retire `send-cell` (less stuff to maintain) and make the last version a small wrapper around `fragile`. Also I didn't notice that `ManuallyDrop` is available from stable, that's great :)
Yes, by owned copy I meant a copy that is safe to send. For instance, if you had an `Rc&lt;String&gt;`, then I mean copying the full thing into a new `String`. I was thinking mostly in the context of `Fail`, as that was listed as a major motivation. For where it *sounds* difficult to make a safe copy, these are just errors. You can create a new string containing whatever debug information you want. I don't think you should use one of these in that case.
Thank you for that PR, it's an awesome improvement. :-)
this is a 90-minute answer to your question, but ive seen this before and it gives a pretty compelling presentation of custom allocation (including "monotonic" allocators, which I believe is what typed_arena is): https://www.youtube.com/watch?v=CVbnjydW5M0 
Agreed, yes. Also in that case it would potentially blow up on you again because `Fail` requires `Send` for a reason. You don't generally have the guarantee that your values don't end up being used in another thread and then panic.
`*const as *mut` in itself is not UB. UB is to modify a value that is reachable from some shared reference - compiler assumes that if you have an immutable reference then the value it points to is completely immutable. Of course in some cases you still want to modify the value - for example for atomic operations, mutexes, cells, and similar. In that case the part you want to modify must be wrapped in `UnsafeCell` - the compiler knows about it (it has `#[lang="unsafe_cell"]`) and knows that what's inside `UnsafeCell` can be modified under a shared reference.
Thanks for your contribution! Most changes (except for critical bug fixes) take two release cycles to land in stable, so your contribution will be in 1.28. See [this article](https://blog.rust-lang.org/2014/10/30/Stability.html) for how the release process works.
Thanks :)
I don't think generic associated types are needed to implement this pattern. I was able to implement the article's `StringifyVisitor` example in rust without them. [playground][1] [1]: http://play.rust-lang.org/?gist=da92cf5d1502423b6a3ca90c0a36be3e&amp;version=stable&amp;mode=debug
OH duh! You can just apply the type parameter in the associated type! Thank you! (To think I've been programming in Rust for years now...)
I guess your best bet then is to use `.cargo` symlinks to `~` and swap them out.
Now immortalized in my issue on [refactoring Pikelet to use visitors](https://github.com/pikelet-lang/pikelet/issues/75). I'm not in a hurry to switch (visitors look uglier than pattern matching), but it's nice to know I can do it! I kind of imagine this approach being handy for the codegen side, if you want to break you compiler into many small phases without neccessarily reifying your IRs between each intermediate stage. Thanks again /u/twisted_tree!
A pretty trivial but handy sortcut for round-tripping through iterators.
Same on WSL/Ubuntu 16.04.4
is there something similar for make?
Maybe at some point we could have a Rust polyfill library, that backports simple features to older rust versions. A standard library addition like this doesn't depend on any language features of the rust release right? The more scary option would be to couple the standard library a little bit more loosely to the language releases, but that sounds like a big can of worms to me..
&gt; Maybe at some point we could have a Rust polyfill library, that backports simple features to older rust versions. It's common that these features are "imported" from existing crates, so you can just use that. [option-filter](https://crates.io/crates/option-filter) was first released in late 2016, and the two releases since 1.0.0 were documentation changes. &gt; A standard library addition like this doesn't depend on any language features of the rust release right? That's correct, you could have implemented it yourself in 3~5 lines of code: https://doc.rust-lang.org/src/core/option.rs.html#641-648
Good looking crate! I think I may use it for a project of mine! For some feedback: There's the `?` operator in rust for easier result manipulation. From one of your examples: ``` let client = match DockerClient::new("unix:///var/run/docker.sock") { Ok(a) =&gt; a, Err(err) =&gt; { println!("{}", err); std::process::exit(1); } }; ``` Since Docker client::new() returns a result, you can replace that code with (not 1 to 1 though): ``` let client = DockerClient::new("unix:///var/run/docker.sock")?; ``` That desugars (to my knowledge?) Into a match with: `Ok(a) =&gt; a` and `Err(err) =&gt; return Err(err);` So it's not exactly what you have in your example, but the point of it is, that it helps you more ergonomically handle functions that return a `Result`. But, it means that any function you use it it in, including `main()` (just recently added), must have a return type of `Result` with the proper error type. I don't know if you already knew of this, but hopefully it helps! I'm also very new to rust, so if I said anything incorrect or explained it poorly, please correct me! Happy Rusting! I'm on mobile so sorry for any atrocious formatting.
You can make an arena in shared memory and create objects there to get infinitely fast serialization :D
We are pretty conservative right now, and require rustc to tell us which suggestions are auto-fixable. The amount of lints that rustfix can fix will only increase in time! (There [is](https://github.com/rust-lang-nursery/rustfix/blob/ab63ed8db73d3523289e13680e24ba6c443b78aa/cargo-fix/src/main.rs#L178-L180) also a to skip that check, though it's only meant for testing purposes. As the name suggests, use at your own risk.) If you want to help, have a look at/comment on [this issue](https://github.com/rust-lang/rust/issues/50723) -- it's pretty bare-bones right now, but there _are_ people who would be willing to mentor anyone who wants to help out with this :)
They could, but it's frowned upon. The idea of Dockerfiles is about more than just shipping a self contained image with everything. It's also about consolidating all the steps to reach that same image in one single place. The goal of a good Dockerfile is to go from a freshly cloned repo to a ready image in just one command: `docker build`. The Dockerfile itself should have all the necessary information to allow it to build everything from scratch without human intervention.
Yeah, WebRender based UI toolkits like [limn](https://github.com/christolliday/limn) are certainly very exciting :) (but meanwhile, the GTK people are working on version 4, which also leverages GPUs... even using Vulkan!)
You can already: unsafe fn dont_call_me() -&gt; ! { transmute(()) } It does weird stuff.
That’s basically the lesson; none of these bugs appear with NLL. We’re gonna put some commentary about it in the .1 release post.
The second edition is frozen; the 2018 edition, whose draft is in nightly, has.
Thanks for the reply! I realized the 2018 version is not hosted anywhere yet, is that correct? 
It is in the nightly version of the docs.
I keep forgetting that the docs are bundled within a rust release channel. Thanks,- I will add a nightly channel in my rustup setup and look at it myself. 
Very nice! I really appreciate the name :D
It’s all good! Note that we generally update the books once or twice a release cycle, so if you want the bleeding edge, you have to render it yourself.
As other folks noted, this is a good fit for an enum. Traits is an other alternative in some situations, where the return type is variable but statically determinable e.g. `FromStr::from_str`/`str::parse`.
insane can of worms != can of insane worms, though
awesome work
unsafe fn call\_me\_maybe() -&gt; ! { if rand::random() { transmute(()) } }
 Yeah, naming is hard and sometimes quite subjective what someone considers as better or worse. Somehow I don't quite like `dyn` and `impl`, because both don't more directly tell you that they've to do something with traits. They also feel a bit disharmonious, `dyn` hints to something dynamic but `impl` doesn't hint - at least for me - to something static. It would've been nice if the words would hint at trait and dynamic/static at the same time e.g.: `strait`, `dtrait`. Sure, I will get used to dyn/impl, it just feels a bit like a language design quirk, perhaps because Rust is such a greatly designed language. 
This is actually due to a relatively recent change. Rustfix used to auto apply all changes, but now it only looks for changes we tell it are autofixable (currently, all the edition lints, we'll add support for more later). There's a flag to opt out. It's changing a bunch for the edition.
That's a nifty project. I've been working for a while on something like that myself, but it's not quite public yet because it's a lot of _ugly_. I guess I'd love to have a collaborator. Unfortunately, we probably have different things in mind for this project, so we probably can't. Anyway, cool :-).
&gt;[...], since that code doesn't expose publicly the ability to hash with a secret key, which this library does (even though to do that it's just using the underlying non-public C code). Isn't it a bit dangerous, stability wise, to expose non-public functions. The C library is not bound to maintain API compatibility.
can’t you backport it? #[cfg(not(option_filter))] trait OptionFilterExt { fn filter&lt;P&gt;(self, predicate: P) -&gt; Self where P: FnOnce(&amp;T) -&gt; bool } #[cfg(not(option_filter))] impl OptionFilterExt for Option { ... } # #[cfg(not(option_filter))] use utils::OptionFilterExt
Is there a repo with versions of those benchmarks in rust that are submitted there? Ideally with a different crate for each benchmark, with benches and so on? The only version I found is one from texitoi but it was really hard to get it working due to makefiles and had no benches and no nothin.
&gt; unreachable_unchecked I wish `unreachable_unchecked` would have a `debug_assert!(unreachable())` in it, and that the std library would be shipped compiled with debug asserts (in debug and release) in such a way that `cargo` picks that one when one compiled with `debug-assertions = true`
Each RFC gets its own repo? What? Does that mean old RFCs not being implemented yet will also receive a repo? This potentially creates thousands of repos that will be linked and discussed cross-repo-wide. 
Internal mutability allows you to create side-effects via `&amp;`, so...
Better align this properly to make it more readable: #[cfg(all( any(target_arch = "x86", target_arch = "x86_64"), target_feature = "avx2" ))]
I love tantivy thanks for the great work
Is there a possibility for adding floating fast fields? Is there a reason there is only int fastfields?
I [created an issue](https://github.com/anderejd/cargo-geiger/issues/8) and included some ideas from the users.rust-lang.org discussion.
I [created an issue](https://github.com/anderejd/cargo-geiger/issues/8) and included some ideas from the users.rust-lang.org discussion.
You can use `font-size: smaller` and `font-size: larger` if you need the size to be related to the surrounding element.
congrats!
I'm itching to write a Python binding for this -- but it'd be so much simpler if it had a C API first. (I know you can bind directly, but I don't fancy much it)
In fact, part of Niko's idea combines the "pre-rfc" discussion, which occurs on internals, and the "rfc" discussion, which occurs on GitHub, on a single platform.
Transmuting ZSTs have strange behaviour in general
Also, since it’s just crashing, you can just use the expect method which lets you set the panic message. Rust will take care of exiting under that circumstance, though I don’t know if there’s a way to customize the exit code. In any case, if someone using your crate is really sure they want to keep going despite your crate panicking (usually if they are embedding rust code), they can also catch that panic too.
I actually prefer there would be a universal working way and a specific way, so this will always work and let the compiler choose static/dynamic fn say_hello(h: &amp;Trait) { println!("{}", h.hello()); } and if you wanna be specific fn say_hello&lt;X: dyn Trait + Clone)(h: &amp;X) { println!("{}", h.hello()); } fn say_hello&lt;X: static Trait + Clone)(h: &amp;X) { println!("{}", h.hello()); } fn say_hello&lt;X: Trait + Clone)(h: &amp;X) { println!("{}", h.hello()); } right now this works: trait Trait {} fn say_hello(h: &amp;Trait) { println!("{}", h.hello()); } but this doesn't because Clone makes the trait not a trait object trait Trait : Clone {} fn say_hello(h: &amp;Trait) { println!("{}", h.hello()); } which is weird to me because I didn't specially said h can only be a trait object, it looks like I said just give me a reference to Trait not sure if this makes sense in Rust or not
Why not? It means that your users won't be able to use or implement the trait directly but can still pass things to that function that have an implementation of it inside your module. Not sure if it is considered good style to do it, however.
Yeah, that's what I'm trying to achieve, but I don't get why the first snippet fails but the second one doesn't. You'd think the error would apply to both.
Have you done some work to use a fst for fuzzy search ?
You're right of course, but let me explain how I personally got comfortable with this issue for my use-case, but of course everyone should make their own decision. I guess the first thing to mention is that the secret key feature is the key feature for me personally (stress personally, as I have no idea if anyone else needs / cares about that) and basically why I wrote the library. Without that, I definitely would have used one of the other two (in my judgement excellent) argon2 crates in Rust. That said, I haven't really answered your question. So here it goes... First, I think the authors of the C implementation are very aware that they are writing reference cryptography code; so they try to keep the library as stable as possible. They don't use a semver system like we do, but they have essentially two ways of versioning their code. The first is that they expose an enum of what they call "versions" in the code itself (and are careful to maintain backwards compatibility to old "versions"). On that basis, there has been only a single new "version" since 2015 (the jump from 0x10 to 0x13). The second sense in which they "version" (and the much more important way as it relates to the non-public API) is that they update the repository very seldom and when they do they are careful to tag new versions. There have been 5 tags since 2015, each corresponding to the date they made changes. All that said, the reference C implementation, although very stable, is not perfectly stable; so there are a couple of things I do besides tracking changes to the reference C implementation's repository. First, argonautica uses a fixed git tag of the underlying C implementation and builds the C library from scratch every time you build your Rust code, meaning if the git repository of the reference C implementation changes, those changes won't be reflected for argonautica users until I explicitly change argonautica in order to have it build the newer code. You're never linking to a random C library that may have been built with one version of the C code on one machine and another on another. You're always building a specific git tag from scratch and using that (thanks to the wonderful cc crate). Second, I try to be very paranoid about testing that my code does exactly the same thing as the C library. I do that in two ways: First, in a separate testing folder that has no interaction with the argonautica library code, I create a fresh copy of the C code and make a very small number of changes to it manually in order to expose the secret key feature. I then test this slightly modified C version against the reference C implementation with a bunch of random inputs to make sure they output the same thing when not using a secret key (the thing they can both do). So in my Rust crate, I'm testing C code against C code in order to make sure I understand how the C code works regarding the non-public parts I'm using and ultimately exposing to my users in Rust. I'm not sure how many hashes with random inputs I create and test, but this testing C against C takes about 15 minutes and runs (with new random values) every time I run the test suite or push a change to the repository. The second thing I do is, for use-cases with secret keys, I test my Rust code against the slightly modified C code to make sure they're doing exactly the same thing. Again, this takes approximately 15 minutes to run, uses random inputs, and runs often. So, to conclude what is probably a way-too-long answer to your question, you're right to question this decision and you should make your own decisions on the topic. For me personally, it was important to be able to hash with secret keys, but my paranoia has led me to focus on testing this issue as much as I can in order to mitigate the risk and I'm comfortable with the measures I'm taking (although if anyone has any suggestions I'd always like to make them better!), but not everyone has to be. This is something everyone should make their own decisions on. Thanks for the comment!
This also has broken nightly builds on TravisCI fwiw
I think it's intentional, see [#46681](https://github.com/rust-lang/rust/issues/46681).
`undefined_behavior()` actually sounds like a fitting name for this, it literally is what this is. You should only ever use it if you do not care about UB happening if it is reached (i.e. either you can prove it is never reached or you are indifferent about the behavior of your code).
Is the compiler already smart enough to produce the same optimizations in that version?
That's how you get Spectre/meltdown :)
[There was a discussion on this topic](https://internals.rust-lang.org/t/pre-rfc-warn-about-inaccessible-types-in-public-function-signatures/5156) (for structs, but the same thing goes for traits). This discussion was before `pub(crate)` was stabilized. TLDR: It is technically a bug, but it has its use-cases, when you want a trait to be available for users of your library, but you don't want users to freely implement the trait for their types: &gt; I think rayon is actually doing this intentionally - they want the trait to be public but not implementable. There may be a better way to express this, but basically crates like rayon are exploiting this gap right now.
I don't know how to determine whether this is intentional or not (it seems to me like it shouldn't be allowed, but I know this area of Rust is pretty complex, so it's hard to be confident), but I can say that unless you have a particular reason to do this, you shouldn't export an item that includes a private trait in its type signature. There should be a way to actually hide it using wrapper types.
&gt; It's already pretty usable! So's the linux desktop!
[removed]
Thanks! As you probably already surmised, it's a reference to [this](https://en.wikipedia.org/wiki/Argonautica)
**Argonautica** The Argonautica (Greek: Ἀργοναυτικά, translit. Argonautika) is a Greek epic poem written by Apollonius Rhodius in the 3rd century BC. The only surviving Hellenistic epic, the Argonautica tells the myth of the voyage of Jason and the Argonauts to retrieve the Golden Fleece from remote Colchis. Their heroic adventures and Jason's relationship with the dangerous Colchian princess/sorceress Medea were already well known to Hellenistic audiences, which enabled Apollonius to go beyond a simple narrative, giving it a scholarly emphasis suitable to the times. It was the age of the great Library of Alexandria, and his epic incorporates his researches in geography, ethnography, comparative religion, and Homeric literature. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; if you want the bleeding edge, you have to render it yourself What? I thought the latest docs are available at https://doc.rust-lang.org/nightly/ Am I wrong? Is the `/nightly/` on the official website outdated?
You're not wrong, Walter, you're just an asshole.
I agree. We have some __builtin_unreachable()'s in code at work that are clearly reachable if the code doesn't behave exactly as the author imagined. E.g. after a switch() without a default:
As the others have said, that helper function seems a bit too niche and/or dangerous to be in std. However, you can use \`unreachable\_unchecked\` to make your exact code work on stable Rust today! I've built a proof-of-concept extension trait to make this happen [in this Playground](https://play.rust-lang.org/?gist=4c9c19a4625129fb60fc54e5440a4b03&amp;version=stable&amp;mode=debug).
Be mindful of glibc symbol versioning.
I saw a similar recent thread about this on internals for get_unchecked: https://internals.rust-lang.org/t/add-bound-check-to-get-unchecked-for-enabled-debug-assertions The comment about using these for a rust sanitizer is interesting.
How do I - spawn a child process - wait for it to output a certain string of text (e.g. 'Server started') - then continue executing the rest of the code while still leaving the child process running?
Thanks, that seems to answer it! Is there a general consensus to keep the bug around, or perhaps replace it with an actual feature that has the same effect? Marking the trait as `pub(crate)` gives the same error as the first snippet.
Ok, so in short you're version pinning the C code. That seems reasonable. And it's nice to see that you're also fuzzing your crate.
I'll just chime in here that hashing random hashes is kinda dumb. Truncating will give you the same performance. Given that, use a trie as the basis of your data structure.
&gt;From this perspective, I would think that removing the impl in impl Trait would actually be easier to learn. Yes, this would lead to automonomorphisation, You seem to have that backwards. Using 'impl', in parameter position, is equivalent to, "T : Trait" and leads to monomorphisation. Without 'impl' you get a "Trait Object" which will be dynamic dispatch. Perhaps you understand this and it just reads strange. If not, hopefully this will correct some misunderstanding. &gt;Another confusing situation is returning a reference to a trait - this doesn't use dynamic dispatch, but will it still require the &amp;dyn keyword? Again, you have it backwards. Using the "dyn" keyword absolutely will use "Dynamic Dispatch". That's the point.
What does this line do? [let chunks = &amp;mut *chunks;](https://github.com/SimonSapin/rust-typed-arena/blob/16646556bb407ebec73b7a265528cfa837b85d16/src/lib.rs#L98)
The nightly website is generated from the [rust repo](https://github.com/rust-lang/rust/). Some documentation like [the book](https://github.com/rust-lang/book/) is pulled in as a git submodule. The submodules need to be updated manually. The book submodule was updated a few days ago in preparation for the next release ([here is the 2018 edition](https://doc.rust-lang.org/nightly/book/2018-edition/index.html)), but in general the doc submodules are not updated frequently. If you want the latest, you'll need to clone the book repo and build it manually. 
Tantivy uses the fst crate for its dictionary. We use our own levenshtein automaton crate because the algorithm in the fst-levenshtein crate is inefficient. The fst vs automaton intersection is defined in the fst crate. Does that answer your question?
Thanks ! 
Beat me to it by five minutes. This is exactly right, thanks :)
Congratulations!
Thanks a lot ! Tantivy is a lot of work. Warmful comments actually mean a lot!
Thanks! I'll make sure the other contributors read your comment :)
No real reasons. So far nobody has needed it. Interestingly this was also the case in lucene. Floatfield only appeared in version 3 if I recall correctly. It would be quite easy to add them.
It was zlib -9 For the dropbox dataset I didn’t observe much difference between -6 and -9
&gt; Does that mean old RFCs not being implemented yet will also receive a repo? We haven't discussed how to transition older RFCs yet. &gt; Edit2: Does the documentation step include the Rust book? If not: Should it? Yes, the final step involves opening an issue on the book repo, so that I can update the book, yes.
We use the built in rust vector types and the built in vector ops here https://github.com/dropbox/divans/blob/master/src/probability/simd_frequentist_cdf.rs They get handed to llvm so at that point it’s up To llvm and browsers to do the right thing. 20% slower isn’t exactly what I would call right. But it’s somthing ;-)
The way I see it, \`impl Trait\` is telling us that the function is returning a type which implements Trait. \`dyn Trait\` is telling us that we have a dynamic type based on.
FYI I've created an [issue](https://github.com/rust-lang/rust/issues/51713) for it.
Seems better to just use the descriptive name. `unsafe` should already denote UB is possible if it's reached.
I've seen there has been a little work for fuzzy search using the fst crate on the project, because fuzzy is a little different than levenshtein (but also less precisely defined), so I wonder if the end goad it to do a fst-fuzzy-search automaton because I would be interested.
I am not entirely sure what you mean by fuzzy though. You can expect a decent fuzzy + prefix tokenized search to be available in tantivy 0.7.0. (Right now fuzzytermquery means that we work over a single term. We also do not do anything to include the levenshtein distance into the scoring.)
Thanks! It's been a lot of fun drilling more down into performance. I'd love to keep improving it too, I think we're just scratching the surface as far as raw power goes :)
Pretty much iirc
&gt;fuzzy I was thinking of doing a fuzzy finding tool like in sublime text / VS Code for recursive directories or whole disk. I thought fst would be a fine structure because of path sharing.
Yeah, I think it makes more sense to use this. For example code and in readme I will repalace the \`match\` handling with this. This is something I love about rust, great community and awesome documentation. Thanks for the feedback :)
[https://github.com/rust-lang/blog.rust-lang.org/pull/258](https://github.com/rust-lang/blog.rust-lang.org/pull/258) if you want the first fix that came to my mind.
Looks great! Merged, thanks :)
I think it might make sense to use panicking in some cases like examples and tests, but in my opinion a library must not panic rather it should provide a result to the user, so that he can handle it any way he want. Using expect does make sense in examples and I will update them. Thanks for feedback :)
I'm always excited to see progress on tantivy.
Tantivy has the code to work over any finite deterministic automaton. It is fairly easy to implement what you want. There is already a ticket ready for that. A proper code search is however much more than just fuzzy search.
Im a little confused about the simd thing. If you want these improvements/new instructions you need go out of your way to use it? Its not just something for free? I guess i need to read a tutorial or something about it?
*someone* needs to use it. The only way you get it "for free" is if a library you're using starts to use it.
I see, so it's not like every time I use map its automatically going to be faster. I would need to update existing programs to use something like that faster crate.
Correct.
That is the only one I know of.
I was looking for an action in Rust, if you help me with introductory details would love to help
Great job! Coming from Koa/Express background the way this framework is designed feels very familiar. Is Thruster supposed to work with rust nightly only? I can't seem to compile it using stable. you should probably mention this in the readme.
Yes, sorry about that! It's actually no longer fully dependent on nightly, but it does need nightly for benchmarks. The most recent push to master has all benching code commented out to work with stable, but I haven't had a chance to publish the changes yet :)
Aha! I missed that part, thanks!
how do we know that the whole can of worms hasn't gone insane?! :P
Ah, I just meant in the highlighted example that it could just be a panic rather than explicitly unwrapping the error and exiting. I think I was assuming that fdarling had been looking through your code and was commenting on some behavior where there was an unrecoverable error.
I just assumed since it seems like most rust web frameworks require nightly. If you're targeting stable that's even better.
Most probably, you don't want `AsRef&lt;PathBuf&gt;`. Try either `AsRef&lt;Path&gt;`or `Into&lt;PathBuf&gt;`.
What if my boss wants me to use `AsRef&lt;PathBuf&gt;` and I'm too new to tell him he's wrong?
That's the goal at least :). Your point is good though, if I find that we have to target nightly I'll be sure to mention it in the readme.
I'm a big fan of lisp, but we should just change the syntax to `#[cfg((target_arch == "x86" || target_arch == "x86_64") &amp;&amp; target_feature == "avx2")]`. 
I'm biased because I wasn't very enthusiastic about the default match bindings from the beginning. So take this with a grain of salt. But should they be turned off or linted until NLL is finished then?! How many soundness bugs are left -- and how many dependencies are starting to use the feature? 
Probably a more widely used term is syntax highlighting. I don't have the answer to your question but it might help with googling
We're not aware of any other bugs. That's the thing about bugs though: sometimes they pop up. You can't know about all of them. There are other features with soundness issues that we haven't turned off. I don't think this is anything particularly special.
[subtext](https://github.com/trishume/syntect/blob/master/Readme.md)
&gt; You can't know about all of them. Well that's what I'm worried about. If there's a cloud of "there's probably more bugs but we're reasonably certain NLL will fix them" then it seems to me it was premature to stabilize default match bindings. But I realize this is a kind of dogmatic position. 
Given recent discussions on usage of `unsafe` in web frameworks (and in general) I did a search in the repository: it looks like Thruster only uses `unsafe` [a single time](https://github.com/trezm/Thruster/blob/7cfeb54e9e6dd497bc616e493738fd845f483136/src/response.rs#L69). It might make folks even happier to add a comment there elaborating on the use case :)
The performance of the plaintext benchmark is indeed higher than even what Actix achieves! Setup: * Core i7-4710HQ (laptop) * Arch Linux, x64, 4.14.50-1-lts * Rust 1.27.0 * Max performance: ON Thruster (the implementation from the README) $ wrk -c 1000 -t12 --latency -d 30 http://127.0.0.1:4321/plaintext Running 30s test @ http://127.0.0.1:4321/plaintext 12 threads and 1000 connections Thread Stats Avg Stdev Max +/- Stdev Latency 4.44ms 4.52ms 234.34ms 86.96% Req/Sec 20.63k 4.27k 102.00k 77.48% Latency Distribution 50% 3.53ms 75% 6.43ms 90% 9.97ms 99% 18.07ms 7374340 requests in 30.07s, 731.40MB read Requests/sec: 245216.10 Transfer/sec: 24.32MB Actix (extracted from TechEmpower Benchmark - [https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Rust/actix/src/main.rs](https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Rust/actix/src/main.rs)) $ wrk -c 1000 -t12 --latency -d 30 http://127.0.0.1:8080/plaintext Running 30s test @ http://127.0.0.1:8080/plaintext 12 threads and 1000 connections Thread Stats Avg Stdev Max +/- Stdev Latency 4.96ms 2.94ms 50.99ms 80.99% Req/Sec 17.44k 1.47k 33.82k 78.31% Latency Distribution 50% 4.47ms 75% 5.75ms 90% 7.17ms 99% 17.78ms 6251274 requests in 30.05s, 775.02MB read Requests/sec: 208003.54 Transfer/sec: 25.79MB That is 245k req/s vs 208k req/s! Awesome!
Just know that they are wrong anyway. I agree that you want `AsRef&lt;Path&gt;` or `Into&lt;PathBuf&gt;`.
I asked him anyway and he told me to use into&lt;PathBuf&gt; thanks!
This is true of all bugs, in any feature. &gt; If there's a cloud of "there's probably more bugs I never said that :)
Of course this is a very basic introduction, but I still learned a bit: - The playground can run cargo test (instead of cargo run) if you use a `#[test]` function. - You can import macros individually with `#[macro_use(my_macro, other_macro)]` - instead of `#[macro_use]`, which imports all macros. And the example you gave for trait resolution (50:56) had an error, it should be `Person::greet(person)`, not `Person.greet(person)`. Otherwise, great introduction.
I know it won't be removed without something else to replace it, but I don't know if there have been any concrete ideas for the feature which would do this intentionally.
\`unwrap\_unchecked\` was suggested in [this closed PR from 2015](https://github.com/rust-lang/rfcs/pull/1095).
By the way, if you confine benchmark code in the `benches` subdirectory, stable will simply ignore it.
If you use [Criterion](https://github.com/japaric/criterion.rs), you'll get better quality benchmark results and your benchmarks will work with `cargo bench` on stable Rust. No nightly needed.
What I really dislike about many other programming languages, is that every time I switch project/team/company there is another dialect of that programming language. Many languages are like that, the biggest offender being C++. There is "Facebook C++", "Google C++", and a bunch of other local C++'s. Some differences are more fundamental (we use this, we don't use that - which C++ is famous for), but some are superficial like spacing. I cringe during every discussion about formatting. Sure, you don't want your code too look like an inconsistent pile of unreadable rubbish, but in my opinion, If you have strong preferences about how your code looks like, you are wasting yours and everybody else time. It doesn't matter (much if at all). The code is not there to aesthetically please you - it just has to be suitably readable. Let the robot autoformat it to look decent and consistent, and spend the time saved on more important things like fighting borrowck ;). When I code in Rust, I have "`rustfmt` on save" enabled and I completely stopped caring about formatting. I'm so sloppy now, and after `:w` my code automatically becomes good again. I love it. About naming and such: just try to be consistent with the mainstream. Let's not allow balkanization of the language like happened in C and C++. I would probably refuse using a library that exposes snakeCase API, etc. and I definitely would not contribute to a project like that. On the even higher level: there are certain patterns (eg. builder) that are considered idiomatic and these decisions might matter more, and there is more freedom for the author to consciously decide what to do. However, again, by default I would stick with the mainstream. 
https://crates.io/crates
It's still too late, I did it anyway.
Man, Rust syntax is so confusing. There is so much syntax it's so hard to read. I can read and understand most code in most languages without knowing much about the actual language, but Rust is so hard to read sometimes even when I have read the book 3-4 times. For example. &gt; let mut app = App::&lt;Ctx&gt;::create(generate_context); I understand every up until &lt;Ctx&gt;. I tried looking in the Rust book, but can't find anything close to this. This language will never be for me. I can't type that line of code out and be okay with how ugly it looks, even if it is good code. 
Thank you, English is not my native language, so sometimes I do not use the appropriate vocabulary.
Rust is different than all the other languages that makes it a bit challenger to translate from other languages, mainly because of the new concepts it introduces like borrows and memory allocation is controlled (sort of) through the type system. I understand your pain though, I've been there. \&gt; let mut app = App::&lt;Ctx&gt;::create(generate\_context); That is known as the turbo-fish operator. It is a type hint used in cases where the compiler can't infer the type. In this case App has a generic parameter which needs to match the return value of the function passed in as argument to create. Maybe a simpler way of thinking about it would be: \&gt; let mut app: App&lt;Ctx&gt; = App::create(generate\_context); This way, because the type was declared for app, the compiler can infer it. To be honest though, I think there are better way to 
It seems it simply cannot reason about the value of the heap-allocated value if the control goes to some other function, see my experiment: https://godbolt.org/g/5Ae2xs `f1` is never optimized to the point that the last `if` is inlined. `f2` has its last if always optimized, though if `f1` is not called, the whole `f2` gets optimized to a constant `1` return value (well, now I know that Rust follows C++ in optimizing out the endless loops: https://stackoverflow.com/questions/3592557/optimizing-away-a-while1-in-c0x) I failed to express the `split_binary` implementation with `replace_with` API, so I asked a question on StackOverflow: https://stackoverflow.com/questions/50985651/how-to-hint-rust-that-fnonce-will-be-executed-exactly-once-i-e-1-instead-of/50988630#50988630 (only unsafe solution was suggested, which is far from ideal :( )
Oh, ok, I see: first I must translate the markdown to html, and then I can add the syntax highlighting to the html, isn't it?
Even that can be removed. It duplicates the code from the [put\_slice](https://carllerche.github.io/bytes/bytes/buf/trait.BufMut.html#method.put_slice) method.
Yeah the reference was clear! Argonautica was my favorite work that we studied in my ancient Greek literature class in college
Have you perused and followed ALL link from the main Rust Home Website? I would recommend it. There is A LOT of information and A LOT of really good information: \* [https://www.rust-lang.org/en-US/index.html](https://www.rust-lang.org/en-US/index.html)
And sometimes you think you know better, and spend days chasing down a memory corruption. I know, I've got the scars to prove it :(
Yes that's right, that code is from when I was using tokio\_minihttp as a jumping off point! [https://github.com/tokio-rs/tokio-minihttp/blob/master/src/response.rs#L70](https://github.com/tokio-rs/tokio-minihttp/blob/master/src/response.rs#L70)
Great suggestion! Thank you!!!
Given some code along these lines: struct Foo { s: String } impl Foo { pub fn new&lt;T:Into&lt;String&gt;&gt;(s: S) { Foo {s: s.into()} } } Is the Into&lt;String&gt; ever not desirable? I was told at one point this should not be 'overused' - what does overuse look like? At 'worst' it hides a clone - but the clone is required. So maybe someone could pass in a &amp;String where they would have normally been happy to provide a String? And it adds compile time. Otherwise this just seems to always be exactly what I want. Am I missing something here re: overuse?
Crashes the compiler for me.
&gt; If there's a cloud of "there's probably more bugs There's a cloud of already existing soundness issues, and there's probably more bugs to come, which NLL will not solve. For example, there's a soundness issue when converting floating points to integer if memory serves, which comes directly from LLVM. I don't think freezing the language until all soundness issues are solved is realistic. I think it's a good idea to avoid introducing *new* soundness issues, but bugs slip in...
There's nothing special really about the default match bindings, they just had a bug. You could say "Stop all features until we are sure soundness bugs do not exist in them" - but the practicality of that seems unreasonable. Could there be more bugs with default match bindings? Yes. There may also be bugs with async/await. Or const generics. Or anything else. We could ask for more regression tests around soundness perhaps - unsure what that would look like. Maybe "this code should never compile"? I assume the compiler has lots of these - targeting soundness seems a bit ambiguous and tricky though. Ultimately, what I'd like to see is: a) Commitment to backport soundness fixes via point releases b) Generally a much, much louder announcement over soundness issues, not just when they're fixed (actually, in particular when they have not yet been fixed)
I've got several projects where search functionality will be needed. What kind of scenarios would I use Tantivy rather than.. say, Postgres full-text search, or Elastic? 
What kind of search scenarios are you using it for?
Not sure how up-to-date this is, but this used to be the one: https://github.com/rust-unofficial/awesome-rust/blob/master/README.md
https://github.com/rust-lang/rust/issues/51699
Rust uses pulldown-cmark to render it's markdowns, not sure if that's useful.
Something that can launch the missiles, obviously.
I'll update the example shortly, you actually do not need the type annotation there. The compiler is clever enough to use your \`generate\_context\` function to figure out the generic type of the App!
&gt; If you want these improvements/new instructions you need go out of your way to use it? Its not just something for free? It's complicated. The ELI5 version: - A binary is a blob of CPU instructions resulting from the compilation of source code. - Different CPUs have different instructions; and newer CPUs tend to include more efficient instructions for some specialized tasks. - The compiler will generally select the most efficient instructions to accomplish the task at hand, but: - it prepares a binary for a family of CPUs, unless instructed otherwise, and may therefore not use the latest and greatest instructions, - it may fail to notice that a particular sequence of instructions could be used, - it may not realize that a particular sequence of instructions would perform better. - When the compiler fails to use the select the most efficient instructions, or when guaranteeing the selection matters, you may wish to take over. If you find yourself in the latter case, then you can now use `std::arch` to manually pick your sequence of instructions. It also allows advanced usages, such as preparing a binary with a *set* of specially crafted functions, to ensure that the binary functions at optimal speed within a whole range of CPUs, instead of only a handful.
An extreme example of such a workload is the Benchmark Games' [binary-trees](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/binarytrees.html). The top competitors all use arenas. Even the GCed languages that don't explicitly include an arena are probably using a GC strategy that effectively provides arena-like performance. For comparison, the fastest malloc-based C program is 6 times slower than the fastest arena program.
If you're confused by this, don't even try Java. In Java, [it would look like](https://stackoverflow.com/questions/5297978/calling-static-generic-methods): App.&lt;Ctx&gt;create(generate_context); I prefer Rust here, at least the "generic" tidbit is clearly delineated with `::`.
Thanks you for the links. Unfortunately I already know most of the stuff written there. I used bindgen from the commandline though, because of unknown reasons it won't work if I do it with bindgen from rust, because I can't get the crate bindgen to compile properly. Always get 'can't find crate binden' error. I have clang and clang-dev installed, but somehow it refuses to work. When I use bindgen from commandline it generates quite nice bindings, but I can't get it to link when I try to compile. Damn :c
Do you have `extern crate bindgen;` in your `build.rs`?
But what if the missiles fly under the radar and fall into the ocean? Can I get away with that? 
Well as long as they were launched, it counts as a side effect. The launch is not idempotent, eventually you run out of missiles.
Does anyone have a link to the CommitStrip comic referenced around 11:30? I can't read it on the video.
Yes, that is probably the best method
Impl Display can also mean anything Displayable
OP author here. Thanks for the good comments and stay tuned. The series will conclude with a more detailed comparison of Rust against Go! Hopefully in about two weeks :)
Looks exactly the same on my phone. What's the difference?
You can look at cobalt and gutenburg as examples https://github.com/cobalt-org/cobalt.rs/blob/master/src/syntax_highlight/syntect.rs
Not really. Here it’s the undefined behavior is caused by unsafely creating a value of a type that normally can not have any value.
There are a lot of cute things you can do manually to have code read better. Like vertical alignment. Grouping two levels of indentation together. Maybe overindenting the where clauses and unindenting backwards the body. Sometimes, it just looks better because you choose which details are important to emphasize.
You can increase the quality by clicking on the gear, it seems to default to 360p but 720p is available and the strip is about readable then. Either way, the strip is http://www.commitstrip.com/en/2016/03/17/too-full-stack/
I have been the prevalent maintainer of awesome-rust for quite a while now and I can confirm that the list is still very much alive and that a major rework to improve the quality even further is coming in the foreseeable future
You might also want to use the complete! macro depending on the scenario. It can be easier to say something is complete that way currently. Also feel free to message me (vadix on Rust discord or reddit) if you have questions as well; I have used nom for a few projects and I had to dig into a lot of the complete stuff after migrating to nom 4.
What I meant with impl was that passing the trait type without impl would have the same behavior as with impl - so it’s proposing a language rather than code change. If I were just starting out, this would be the first thing I would try since that’s how you do it with structs. And as far as I know, it’s currently illegal. With the dyn return value, I don’t see how dynamic dispatch would happen in the act of returning a pointer. That being said, since someone else pointed out that the type of the pointer is different, it makes more sense now.
I’m surprised this isn’t higher. So you’re saying that the above example uses a thin pointer, and the bottom example uses a fat pointer?
I think that’s a good explanation, I’ll remember that analogy.
So I guess the implication there is that DST also use fat pointers but do not use dyn syntax?
Thanks. I didn't see the quality slider. Non-potato is much better
The outer `chunks` comes from `self.chunks.borrow_mut()`, which makes it a `std::cell::RefMut&lt;ChunkList&lt;T&gt;&gt;`. The line you reference will get a local `&amp;mut ChunkList&lt;T&gt;` by going through `DerefMut` and keep it as a reference. After that, it's using different parts of `chunks` mutably at the same time, for `chunks.rest` and `chunks.current`. Rust can keep track to make sure they're distinct when going through a direct reference. But if you tried to let it implicitly go through the `RefMut`'s `DerefMut` for each part, the borrow checker will stop you since `deref_mut(&amp;mut self)` has access to the entire mutable object -- aliasing the mutable references you already hold.
Lets have it also launch missile retrieval drones at the same time.
I use https://highlightjs.org/ to do this kind of thing client-side, without needing to render all that html directly. or rather, it's transformed into that by this library, rather than needing to do it ahead of time. makes it much easier to read via view-source.
We mostly use ES but we do not actually need that memory hog, as it is only 1-host and easily reproducible, so exploring of a possibility with a more embedded solution with Rust/tantivy
You have to spawn the process with piped stdio so you can read from it: use std::process::{Command, Stdio}; use std::io::BufRead; let mut child = Command::new("child command") // unless the child expects to read data on stdin .stdin(Stdio::null()) .stdout(Stdio::piped()) .spawn().unwrap(); let mut line = String::new(); child.stdout.unwrap().read_line(&amp;mut line).unwrap(); if line == "Server started" { // server is running } else { // see why the server isn't started // maybe try reading from `child.stderr` }
You are most definitely mixing up `&amp;` references and `*` pointers. It is UB to transmute `&amp;` to `&amp;mut` because the former may reside in read-only memory and would cause a segfault if it were written to. The only functional difference between `*const` and `*mut` is that the compiler forbids directly writing to the former, but it can be converted to `*mut` with a simple cast so it merely exists as an anti-footgun (and it's `unsafe` to deref raw pointers anyway). `UnsafeCell` is special in that the compiler is aware of it and so knows never to store it in read-only memory, so `&amp;UnsafeCell&lt;T&gt;` to `&amp;mut T` is explicitly *not* UB on its own.
&gt; With the dyn return value, I don’t see how dynamic dispatch would happen in the act of returning a pointer. Whatever you are returning here it is something that "dyn"amically will support calls to the trait methods. I could be anything that has an implementation of the trait. It will be returned as a fat-pointer to the actual struct of the type that is being returned at run-time and a pointer to the vtable for the implementation of the specific trait methods for that that type's implementation of the given trait. So, "dyn" always means a pointer to a struct coupled with a pointer to the vtable for the trait methods and "impl" always means a "Specific" type that implements the trait (no vtable/dynamic dispatch required because the compiler will know at compile time what the actual type is). The reason "Box&lt;Trait&gt;" and "Box&lt;dyn Trait&gt;" are the same is that "dyn" is added for symmetry with the new "impl". Eventually, they may eliminate the bare syntax (and require either "dyn" or "impl") and then later, they may bring back the bare syntax, but, it would now be equivalent to "impl". That way, the simpler thing is the more performant thing rather than having the simpler to type thing being the less performant option. I know I read some comments in the RFC discussions regarding that possibility, but, I'm not sure if that will ever actually happen.
What's the ownership and permissions on the executable file? `Program Files` typically requires admin permissions to write to, so if you're building in an elevated command prompt then it may produce an executable that requires elevated permissions to run.
IMO, the entire concept of code-formatting is an unfortunate artefact of legacy. It causes a secondary redundant structure in parallel to the actual syntax. One syntactic structure guiding the compiler, and then one visual structure guiding the eye of the reader. In the best case, these two agree. In the worst case, what you read is not what the compiler reads. I would love to see a language adress this, working directly with a compact AST as a source. Formatting should be considered the editors responsibility, and subject to personal preference. (Separation between data and representation) The closest we've come to this are language endorsed formatters like rustfmt. It's not a complete solution, but it removes a bit of bike-shedding, and I'm a strong proponent. It may be sub-optimal for readability in specific cases, but it's a huge global optimization for readability. As a further development, editors could do transparent translation between canon formatting rules, and the preference of the user. In addition I would argue that relying on manual formatting to convey the intention of the code, is a bad code smell. It indicates a discrepancy between the syntactic and visual structure of the code. While this improves readability for the first revision, it incurrs a maintenance cost. After a few edits by different authors, chances are that the two structures will diverge, so what humans see and what compilers see will no longer be the same.
&gt; It is technically a bug It's not a bug, but exactly the intended behavior. The basic (pretty old) document describing the rules is [RFC 136](https://github.com/rust-lang/rfcs/blob/master/text/0136-no-privates-in-public.md). The updated version (not fully implemented yet) is [RFC 2145](https://github.com/rust-lang/rfcs/blob/master/text/2145-type-privacy.md). 
I think tantivy would be useful as an embedded search engine right now. I could see it growing up into a full fledge search-server (like elastic or solr) in the long run, but for now it's more like lucene than elastic. So I would say, if you need a search engine *inside* your program, use tantivy!
Excellent, thanks!
How exactly are you building both versions? Because I sadly can't verify the claim at all. I cloned both the thruster and actix-web master branches, and put an extracted version of that TechEmpower Benchmark in a new actix-web example directory, and built both in release mode using Rust 1.27.0, and ran three interleaved `wrk` runs with the options from the thruster readme on my i7-7600U laptop, and this is the highest thruster and lowest actix-web results I got: Thruster: ``` Running 30s test @ http://127.0.0.1:4321/plaintext 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.85ms 1.96ms 30.61ms 72.64% Req/Sec 12.11k 1.60k 36.20k 74.39% 4341375 requests in 30.09s, 612.76MB read Requests/sec: 144255.77 Transfer/sec: 20.36MB ``` Actix-Web ``` Running 30s test @ http://127.0.0.1:8080/plaintext 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.14ms 2.25ms 34.48ms 88.78% Req/Sec 18.19k 2.77k 50.63k 77.55% 6526025 requests in 30.10s, 809.08MB read Requests/sec: 216832.56 Transfer/sec: 26.88MB ```
Learning to tell your boss that they are wrong is a valuable skill. Congrats on practicing that. It's usually not as bad as you think it will be. 
Here are the exact implementations I compile and run: https://github.com/frol/thruster-vs-actix `cargo run --release` for both.
As symlinking .cargo is buggy (see bug report above), now I set Rust compiler + library in project, and then call e.g. Pycharm with: CARGO_HOME=/there/.cargo/ /foo/pycharm/bin/pycharm.sh &amp; so all 3 directories are correct for the Rust plugin. And I can only edit one project at a time, but that's better than nothing. Wasn't there a Rust usage ergonomic initiative? How to tell them? The Rust plugin needs another configuration option and cargo itself needs a switch --cargo-home=/foo/.cargo so the Rust plugin can call it like that? 
Heavy use of Into/From might result in binary bloat, w.r.t. monomorphization? They might also be thinking that you might be/warning against specifying `Into&lt;String&gt;` in places you could have used `AsRef&lt;str&gt;`, and incurring unnecessary allocations.
I'd be willing to mentor someone on - [cobalt](https://github.com/cobalt-org/cobalt.rs): a static site generator - [liquid](https://github.com/cobalt-org/liquid-rust): A rust version of Shopify's template language. It is used in cobalt and I'm adding it to other crates due to not having a better option - [cargo-tarball](https://github.com/crate-ci/cargo-tarball): create tarballs for releasing crates as binaries to remove a lot of the boiler plate in the trust CI setup. - [stager](https://github.com/crate-ci/stager): Used in cargo-tarball (and hopefully more in the future) to describe how to aggregate and layout files for installers - I also have some [crate-ci documentation issues](https://github.com/crate-ci/meta/issues) that need addressing.
The plugin could just set the `CARGO_HOME` variable for each invocation, it doesn't necessarily require a change to Cargo I don't think.
So using those I get: Thruster: ``` Running 30s test @ http://127.0.0.1:4321/plaintext 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.70ms 2.33ms 70.40ms 82.11% Req/Sec 13.14k 1.73k 25.34k 73.19% 4708483 requests in 30.08s, 467.00MB read Requests/sec: 156550.49 Transfer/sec: 15.53MB ``` Actix-Web: ``` Running 30s test @ http://127.0.0.1:8080/plaintext 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.59ms 1.92ms 29.69ms 83.60% Req/Sec 13.63k 1.86k 23.43k 76.46% 4888074 requests in 30.09s, 606.01MB read Requests/sec: 162426.47 Transfer/sec: 20.14MB ``` So thruster is reaching about 10k more requests, while actix-web is slower. But if we're going to use git for one, it only feels fair to use the git master branch for both, so this is what I get with your repo and actix-web's master branch: ``` Running 30s test @ http://127.0.0.1:8080/plaintext 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.17ms 2.16ms 32.60ms 88.38% Req/Sec 17.53k 3.33k 47.47k 69.60% 6286064 requests in 30.10s, 779.33MB read Requests/sec: 208866.84 Transfer/sec: 25.89MB ``` So I can't get Thruster to achieve more requests per second that Actix-Web, and Actix-Web's master branch can handle a lot more.
thanks! 
... So I just realized that I hadn't updated my laptop, so these are runs actually with 1.27.0 using the dependencies as you specified them: Thruster master: ``` Running 30s test @ http://127.0.0.1:4321/plaintext 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.51ms 1.78ms 35.94ms 75.67% Req/Sec 13.74k 1.87k 42.47k 74.55% 4927363 requests in 30.10s, 488.71MB read Requests/sec: 163721.75 Transfer/sec: 16.24MB ``` Actix-Web 0.6.14: ``` Running 30s test @ http://127.0.0.1:8080/plaintext 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.40ms 1.88ms 37.02ms 87.56% Req/Sec 14.80k 2.13k 35.35k 74.03% 5312600 requests in 30.07s, 658.64MB read Requests/sec: 176653.22 Transfer/sec: 21.90MB ``` So as you can see both of them got faster with 1.27, but Thruster still can't beat Actix-Web. I wonder if it might be somehow related to Thruster being better at utilizing more cores than Actix-Web. Would explain why Thruster beats Actix-Web on your quad core, but the other way around is the case on my dual core.
In the first one if and let are on the same line in the second the if block starts on a new line
I was clear (when this came up some time ago) that I required a String. Though, similarly, I feel that when I want a &amp;str I'm happy to take a `T: Into&lt;str&gt;`. I'm surprised about binary bloat, wouldn't that all disappear at some point? I'd get that the compilation process would take longer - but the end result should be the same?
Crazy? I was crazy once. They put me in a home. I died there. Then the worms came. Worms? I hate worms. They make me Crazy. ....
So, here's a question I've always wondered, that seems on topic as we await the next nightly to be released :) ... Who/What determines the release content and release time of the nightly builds? Is it just bors (or another build tool) bundling together the current matter branch at some specific time? Or is the process more complicated than that?
[`extend_from_slice`](https://carllerche.github.io/bytes/src/bytes/bytes.rs.html#1483) is a one line replacement for the whole function (including the reserve call). That should be just as fast.
Perfect, I'll put this in the next minor release and we'll be unsafe free :-) thanks all!!
&gt; With the dyn return value, I don’t see how dynamic dispatch would happen in the act of returning a pointer. That being said, since someone else pointed out that the type of the pointer is different, it makes more sense now. Passing around a dyn reference doesn't entail dynamic dispatch, it's making method calls on the dyn reference that are dispatched dynamically 
But bindgen isn't a part of the Rust language. So if you don't want to rely on external tools you're kinda out of luck.
it happens every night at a specific time AFAIK. It's just whatever is in master at that time (remember that all unit tests run before every commit is merged).
All Praise Ferris! It has arrived!
The end result is only the same if you only instantiate the function once. Using `Into` shifts the 'marshalling' from the callsites to the function, so if the function is larger the the marshalling code or isn't inlined, then you end up with bloat compared to a non-generic function. I've seen a technique which I refer to as 'generic shims' to remedy this, especially for large functions by inserting an extra callsite to prevent code duplication outside of the marshalling, which is necessary anyway: // Will be inlined away anyway pub fn generic_function_api&lt;T: Into&lt;Thing&gt;&gt;(t: T) { generic_function_impl(t.into()) } fn generic_function_impl(t: Thing) { // code which isn't duplicated unless also inlined }
Oh shoot I didn’t expect it comes so fast ;-)
Edition guide looks great. Very well done documentation as always.
Interesting! Thank you.
Yes, but (currently) the only kind of DST aside from a trait object is a slice, and a fat pointer to a slice contains its size, not a pointer to a vtable, therefore the `dyn` syntax wouldn't make sense. There's no dynamic dispatch involved.
Can you talk a bit about your future plans with the project?
Do you have a recommendation for doing this better? I think feature flags were unstable only. How could we conditionally enable simd by default if the ability is available or if the version is high enough?
Mobile experience seems to be lacking pagination controls. Or maybe it’s just me?
They should be there; if not, please file an mdbook bug!
Thanks!
Thank you!
I couldn't get to the next page either. I'll read it from my laptop later
The edition transition guide is an awesome guide, it is not just a from this to that, but it explains why in a teaching way. Excellent work everyone involved!
Swipe right to reveal the table of contents.
Click the upper left corner; there should be an icon but even if not, it should work.
How are you planning on handling `multipart/form-data` uploads? Just shelling out to Middleware?
This was fixed in [#697](https://github.com/rust-lang-nursery/mdBook/pull/697), but there hasn't been a new release yet. In the meantime this could be fixed by adding a `.nojekyll` file to the gh-pages root.
The first version compiles because `Trait` is object-safe. In the second, it subtypes `Clone`, so it is [not object-safe](https://doc.rust-lang.org/book/first-edition/trait-objects.html#object-safety) (`clone()` returns `Self` and doesn't bound `Self: Sized`). `&amp;Trait` is always a trait object/fat pointer, therefore the referenced trait must be object safe. Both versions would compile if you replaced `&amp;Trait` with `&amp;impl Trait`.
Thanks! We’ll try to fix that soon...
I would love to! Thruster, in my eyes, is an idiomatic, performant, and modular web framework for Rust. I primarily work with web servers most of my day, and fell in love with how Rust manages memory the first time I heard about it. Rust is, of course, fast and efficient with a reasonable syntax and program structure. I think that Rust could easily become the backend of choice for the performant web application of the future, and I would really love for Thruster to be a part of that journey. To that end I think the most important things about a web framework are: - Having an intuitive API - Being extensible and modular enough so that other developers can easily write middleware to include in any app, for example, middleware for adding security headers to HTTP requests - Being performant whenever possible To these ends, stability is also a large goal that I'm currently working towards. I would very much like to somewhat lock down the signatures for the main API methods in the near future. In the shorter term, I would love to: - Think about, and generate a package for handling large data sets (i.e. multipart forms, application/binary etc.) - Nail down a pattern for managing web sockets - See if we can't figure out a better, more generic way to do `Context`s and `context_generator` functions rather than each non-trivial project needing a custom one. - Flesh out the `thruster-cli` a bit more to make bootstrapping projects easier I've been using Thruster on many of my side projects and found and fixed a lot of the pain points that go along with using it. It's been a great boon to the project to be consistently using it for real world applications rather than demos and todo lists. Phew, sorry, a little wordy there, but it's a project that I'm very passionate about :)
I'm not sure, as I haven't tried it, but could you use the num crate's [range_step function](https://docs.rs/num/0.1.42/num/fn.range_step.html) to create an iterator you can call rayon's par_iter method on? Again, I haven't worked with rayon or the num crate, but my meager googling found this.
To add another interesting point into the equation, I tend to develop on Nightly locally, so the tests in the Readme are using 1.28 nightly, which of course more line up with the later tests. Thruster is heavily dependent on parallel pipelines in order to be "fast", as the structure emphasizes no shared or persisted state between requests. These are super interesting benchmarks though! I'm currently working on getting Thruster into the techempower benchmarks, so please stay tuned there!
Are custom allocators still on track for 2018? I haven't seen much noise about this lately.
Yup! That being said though, I would really like to keep a core set of middlewares available via feature flag in the main package. Data parsing (form-data, json, binary,) are all middleware pieces that I would love to have in the main Thruster package simply for stability and not needing that constant `node.js` problem of "Which of these eighteen parsing packages should I pick again?"
Not trivially, but if you know the range of `newStartingBrix` you want to search over (as a vector), you can `par_iter()` over that and then see where you can stop. It's kind of wasteful if it turns out you only need the first few items of your vector to reach your target. Alternatively, consider doing a binary search? Start with a value that's too low, and one that's too high, try the mid-point, then recurse based on whether the midpoint is too low or too high.
Global custom allocators will be in 1.28. 
I'd be happy to provide integration in [multipart-async](https://github.com/abonander/multipart-async) though the API is built around the request body being a `Stream` of `Box&lt;[u8]&gt;` (or similar, like `bytes::Bytes` or `hyper::Chunk`). I see in Thruster you're reading the entire body to a single buffer. Since form-data uploads can be quite large it's probably not feasible to read the whole request body into memory at once. Are you planning on an abstraction for streaming request bodies?
We're almost certainly going to need that, somewhere above I mentioned being able to handle binary streams as well, but to be honest, I haven't gotten that far yet! I'm totally open to suggestions and concerns on the topic, perhaps it'll be best to open an issue for discussion!
Oh, I hope we actually get async and nll....
Sorry to double post, but I just opened an issue to discuss and implement a stream feature: https://github.com/trezm/Thruster/issues/34 thanks for kicking off this discussion here!
Yes, I was wondering why async story/generators was not mentioned
This [document](https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/ownership-and-lifetimes/default-match-bindings.html) is out of date. The only thing Rust 2015 doesn't do at this point is insert an `&amp;` before the `Some` on the assignment. Everything inside the `match` on "Rust 2018" works fine in "Rust 2015". [See here](https://play.rust-lang.org/?gist=4ba52a8de57edd6014cbce058e266b64&amp;version=stable&amp;mode=debug)
We’re not strictly talking about things that ONLY require 2018, but it as a total package.
Being that it's effectively brute forcing the maths, I don't think `.iter()` will work. But, u/christophe_biocca recommended a binary search, which I think will totally work. If you're seeing something I'm not in regards to making an iterator for it, I'm all ears. The relevant file is [here](https://gitlab.com/MonkeyLog/BrewStillery/blob/master/src/functions/increaseABV.rs).
They’re not gonna land before the initial 2018 release. You also can’t even try them yet, as the PR hasn’t landed.
NLL is in for sure. Soon!
Yup! Icons and links are there now on my iPhone using chrome.
I think you're spot on with the binary search. I think what I'll end up having to do is use `thread::spawn()` to break everything apart into logical chunks. I do know what a max value can be for `allInputs.desiredABV`, so I can break it up from the top from there.
There's also now a lightweight alternate: https://crates.rs/index
Have you looked at https://github.com/softprops/shiplift ?
Yeah, this is not my area of expertise, I just came at the problem you requested from the point of view of "We need an iterator to parallelize, and it looks like we don't do floating point step_by at the moment... wierd." I've just been messing around, and rayon requires you to implement a whole bunch of their traits which I don't really understand, so I think I'm out for now. If binary search solves your problem, that's great.
&gt; In Rust 2015, this would fail to compile, you would have had to write this: but what is written there is not necessary for Rust 2015?
Yeah, that’s a little overly worded; I write that before we knew it was landing in 2015. Mind filing a bug?
I just go with &lt;type&gt; reference, and pick a/an based on &lt;type&gt;. Seems easiest.
In highly ambiguous situations like this (where different readers will always be annoyed), I choose an alternative. In this case, "Span behaves similarly to &amp;str, except...", which treats them both as uncountable nouns and removes the need for a/an/the, which I think is valid. You're discussing the type, which is uncountable, not an instance of the type, which can be counted. In the world of C, the pronunciation of "char*" is probably one of the most hotly contested things.
One other fun option: "Span acts the same as an instance of &amp;str, except..."
I think you got that backwards. Actually [most web frameworks](http://www.arewewebyet.org/topics/frameworks/) in Rust work just fine on stable with Rocket being the exception.
&gt; In the world of C, the pronunciation of "char*" is probably one of the most hotly contested things. "char star" (char in the sense of "**char**red wood")
but it's a "character" so "car star" is the only way to go :P
I read `&amp;str` as "string slice" or a "reference to str/a string slice'. so I'm thinking I'd say "a `&amp;str`"
Aside from monomorphization/compilation issues, one could argue from a design standpoint that hiding the conversion leads to a less-clear API and a potential performance footgun. Anyone can impl `Into&lt;String&gt; for MyType` and that conversion might be expensive, but now the fact that it's happening is hidden at the callsite. Then `Foo::new(t)` looks like it could store the `t`, as if the struct were `Foo&lt;T&gt;{ t: T }`, but it's actually going to drop `t`, which itself could be expensive. One might not expect either of those things to happen when just reading the callsite. I think I'd consider this overly-generic for library code where potential uses are unknown, but I wouldn't think twice about it in an application where all uses can be easily determined. My preference is to have the conventional constructor methods like `new` be as close to direct passthroughs as possible and make intermediate conversions more visible. Maybe a blanket `impl From&lt;T: Into&lt;String&gt;&gt; for Foo` would work? At least then there would be a `t.into()` or `Foo::from(t)` which, while similar, uses the traits that are explicitly for conversions and so conveys the intent a bit more directly.
I don't know if this is the appropriate place to bring this up, but it's the first time I'm hearing about in-band lifetimes: &gt;To show off how this combines with in-band lifetimes in methods/functions, in Rust 2015: &gt; &gt;``` // Rust 2015 impl&lt;'a&gt; MyStruct&lt;'a&gt; { fn foo(&amp;self) -&gt; &amp;'a str // we have to use 'b here because it conflicts with the 'a above. If this weren't part // of an `impl`, we'd be using `'a`. fn bar&lt;'b&gt;(&amp;self, arg: &amp;'b str) -&gt; &amp;'b str } ``` &gt; &gt;in Rust 2018: &gt; &gt;``` // Rust 2018 // no need for the repetition of 'a impl MyStruct&lt;'a&gt; { // this works just like before fn foo(&amp;self) -&gt; &amp;'a str // we can refer to 'arg, rather than conflicting with 'a fn bar(&amp;self, arg: &amp;str) -&gt; &amp;'arg str } ``` In the first example, it's explicitly clear that the string ref we're returning has the same lifetime as the string ref we passed in, but in the new example, that information is missing. How do I know at a glance what the lifetime of the return string ref is?
I don't think it hides a performance footgun. Ownership is always necessary. You could force the caller to call `.clone()` - but why? It won't change anything about whether the clone happens or not. I guess then the caller knows 'this call might be expensive'... but is that important? I don't also expose algorithmic efficiency, or cache efficiency, or *other* allocations (so long as it's not a no_std lib) so I'd be exposing one minor performance implication and losing a lot of ergonomics. The Foo example is contrived, but yes your version works for the case of a single parameter.
Not care star?
I usually say "ampersand stir," so I'd probably go with an. 
 Not to give a solution, but to make your problem harder: I pronounce `&amp;str` as `Immutable String ref`. This seems like the kind of problem that is best solved with data. Whip up a survey and spread it around to ask how someone would pronounce a bunch of examples.
&gt; They’re not gonna land before the initial 2018 release. What does that mean for async/await? Will it require another edition?
[The doc](https://doc.rust-lang.org/std/primitive.str.html) calls it "a `&amp;str`" for what it's worth.
4 spaces in front of text makes it preformatted
I'd try nuking the `~/.xargo` directory and letting it rebuild itself if you haven't tried that already.
[Here](https://github.com/rust-lang/rust/issues/43751#issuecomment-373943419) is the justification I wrote when suggesting the name `unreachable_unchecked` and why I believe `undefined_behavior` would not have been the right name.
I still don't see any pagination buttons or the menu icon but I can at least hit the menu icon to get to other pages. iPhone with Safari and an ad locker 
Thank you
&gt; then the caller knows 'this call might be expensive'... but is that important? I think that kind of visibility is valuable. &gt; so I'd be. . .losing a lot of ergonomics. I'm not sure an extra `.into()` is a big loss but I can see your point. Like I said, I wouldn't think twice about putting this into an application. Libraries I'd be more judicious about. I guess my current thinking is sort of "what I do with my type is my business, but other than this minimal interface how you create my type is your business". Ultimately it's an API design choice I think comes down to a judgment call with respect to convention, clarity, and characters. Do more characters like `.into()` help convey useful information, or are they just repetitive boilerplate clutter and noise? How common is this pattern that people would expect and understand it? My impression is that the Rust ecosystem tends to favor the explicit and push information to the caller. As a data point, the Rust language and standard library itself doesn't usually do conversions for you without some kind of signal, but it certainly does in some cases like how for loops use `IntoIterator` and `?` will convert the error type. There are tradeoffs where you can make arguments both ways, and that's all I was trying to do.
\- **Some small applications:** your application is written in rust and introducing elasticsearch. solr, or lucene seems overkill \- **Some Exotic Applications:** you need a low startup time (not JIT, no class loading, everything is MMapped)\_, typically you are writing a command line application. We had a cool use case of interactive big data analytics. Tantivy made it possible to run each query in a different process. That makes it much easier to put resource limits at a query level, and write a bullet proof service. The lower startup time was a big nice-to-have for another use case, to make redeploy on hundreds of server faster. I assume it can also be very useful for use case where you have a lot of small indexes. (dropbox/gmail like). \- Having no GC is really business critical. I do not know any use case where this is THAT important but that's always a nice to have. \- **Some larger applications:** Your have a large business where search is VERY important. Search is critical enough that if you use Lucene you will rewrite most of the analyzers / scorer etc anyway. You have a clear trade-off, performance of search vs revenue, and gaining a bit of speed on search converts directly into millions of dollar. Soonish I hope to add : \- a proper suggest implementation. Last time I check Lucene is not great at that \- WebAssembly \- Android / iPhone app 
I pronounce `&amp;T` as `address T`, so "an". *Except* `&amp;str` is just a `string` so "a" in the one special case you chose. `&amp; 'a` is, "address alpha a" in my head (the alpha isn't redundant, `&amp; 'b` is "address alpha b"). I think that pronounciation came from the prof who first introduced me to sml (which has `'a` syntax for generics). So the answer is still "an". `&amp;'a str` is "address alpha a string", as an exception to my previous exception that `&amp;str` is just "string". Also I wouldn't worry about grammar :P
Nope. The keyword is already reserved. Editions are rolling, not static. It just won’t be at launch.
Cool, thanks for the clarification.
Yeah, sorry, I wasn't trying to argue - more just thinking it through. I appreciate the view.
I'm just 20 minutes into the video, and I can already recommend it now. Thanks /u/timglabisch, your didactic talk style is really great.
If just needing plaintext, then no configuration is required. A default listening `hyper::Server` will look at new connections and automatically determine if the request it received was HTTP/1 or HTTP2. Some *clients* may wish to only talk h2 to your server if you set up TLS and ALPN, in which case more work would be required, since hyper doesn't pick a default TLS implementation.
A remark: the behavior of \`cargo new\` has changed recently and defaults to a bin crate now: [https://github.com/rust-lang/book/issues/1166](https://github.com/rust-lang/book/issues/1166)
Would I need to reinstall xargo? 
Nah. That directory only contains the sysroot.
Sometimes it means some Struct that impls Trait
&gt; Extension: nightly versions pleaseee
I think of &amp;str as “a borrowed str” or “a borrow of a str” so my vote is on _a_
I find that with Rust's type system, actors are already kind of built in concepts. My approach would be to define each logical "actor" thing in a file. Sending messages can be done using `futures::sync::mpsc`. You get a queue built in, and you can manage queue size just by using the bounded channel. Any "actor" you wish to be able to message another, you just clone the related `Sender` of the mpsc and store it in the type that needs to send messages. From there, I'd implement `Future&lt;Item=(), Error=()&gt;` for each logical "actor". Lastly, you'd just spawn each one of those into tokio's threadpool. It has a work stealing strategy to balance your "actors" automatically as threads are available, and you can also configure how big of a pool of threads to have, how long they can idle, etc.
RE actix, you may get a better response on their gitter channel, it's quite active.
It's care star. 
Trying to draw a sin wave to a screen based on some values I pass, yet I'm having real problems getting cargo-build to work, having a hard time understand what I've done wrong. Here are the dependencies: [dependencies] sdl2 = "0.31" [dependencies.sdl2] version = "0.31" default-features = false features = ["gfx"] I have sdl2\_gfx installed, I have sdl2 installed, and if I run this it works just fine: [dependencies] sdl2 = "0.31" But when I try the top one, I get the following error, and I'm not sure what I've done wrong: error: failed to parse manifest at `/home/Projects/rust/sinusoid/Cargo.toml` Caused by: could not parse input as TOML Caused by: duplicate key: `sdl2` for key `dependencies` 
Yeah, even in this simple case: pub fn main() { let x: Option&lt;String&gt; = None; println!("{:?}", x); } ...if I read the assembly right, there is still a check if `x` is `None` at the end of the function. 
Amazing they did not kick off an immediate rebuild but waited for the nightly schedule to kick off....
24hours between problem being identified and a build being made isn't bad, considering there is not a guarantee that there will always be a nightly.
I might sound like a bit of a noob... (still learning) What does nll do? I tried looking it up, but did not find a clear explanation.
It’s a nightly build. If it’s broken for 24 hours it doesn’t really hurt anyone. If it does these people shouldn’t depend on unstable nightly builds. 
Regarding arbiters it is not necessary to run actor from within it. Arbiter itself controls event loop and you woulldn't need to start each actor in it. Instead you'd want to start System, and each actor using `Actor::start` But there are cases when you want to run your actor in a separate thread using `SyncArbiter` These cases are actors that require blocking calls (e.g. Database actor as most databases are not async). `SyncArbiter::start` basically makes your actor to handle messages using thread pool(you can specify number of threads for this pool)
That’s a stupid boss if he won’t take tips from a newbie and won’t explain why he forces you to use this type. Get the hell out of that toxic environment. 
It changes the borrow checker ruleset to be more permissive than the current borrow checker rules. It required that we generate a MIR (middle internal representation) instead of just checking on the AST (Abstract Syntax Tree), so it's probably the change that's required the most work since 1.0.0. The ruleset changes from being about scopes to being about control flow paths, at least as far as I understand it.
Thank you! Now I understand what people were talking about when I was looking it up haha
Why distinguish between the Rust version and the Rust "edition"? That seems like needless implementation complexity and mental overhead in translating between the two. In other words, how is rust="1.40" edition="2015" meaningfully better than just `rust="1.40"`?
_Sorry for being a help vampire btw_ I got this: ``` error[E0599]: no method named `read_line` found for type `std::process::ChildStdout` in the current scope --&gt; src/main.rs:43:25 | 43 | child.stdout.unwrap().read_line(&amp;mut line).unwrap(); | ^^^^^^^^^ error: aborting due to previous error For more information about this error, try `rustc --explain E0599`. ``` I guess that's because I haven't imported the trait that contains the `read_line` method yet. What should I import then?
So this is because `ChildStdout` doesn't implement `BufRead` like I assumed it did. You need to wrap it in `std::io::BufReader`: use std::io::{BufReader, BufRead}; let mut stdout = BufReader::new(child.stdout.unwrap()); let mut line = String::new(); stdout.read_line(&amp;mut line).unwrap(); However, if you're expecting an exact string, you don't need a buffered reader: use std::io::Read; let expected_str = "Server started"; let mut actual_str = String::new(); // read exactly `expected_str.len()` bytes child.stdout.unwrap().take(expected_str.len() as u64).read_to_string(&amp;mut actual_str).unwrap(); if expected_str == actual_str { // server started } else { // see why not }; 
Are you sure you're using the right tool for the job here? Because BEAM, the Erlang/Elixir VM can spawn millions of agents and pass lots of messages around without breaking a sweat. You could still do all the heavy number crunching in Rust using [Rustler](https://github.com/hansihe/Rustler) or something like that.
Even native speakers have a hard time trying to recall the proper term, it's not something to worry about. Here is a quote from one of the forums I joined: &gt; [Username redacted A]: In text editors there is a feature which highlights each piece of code in an appropriate color, what is it called? &gt; &gt; [Username redacted B]: That's called syntax highlighting. &gt; &gt; [Username redacted A]: Sorry I'm dumb.
It's not a very large problem, but generally once the problem is thought as fixed it should not be hard to run an extra round.
A panic is much better than a broken invariant and untested recovery code !
Not following the most recent developments I've felt a bit confused about these new additions to the language and like they were going to complicate things a lot. But now reading it put out like this is reassuring that indeed it is going to make code more expressive.
(…in most cases)
The 1.40 compiler will have an 2015 edition mode and an 2018 edition mode, meaning it can compile code of either flavour. This is a major motivation for the editions: breaking changes can happen in the 2018 edition but it is still able to directly interact with 2015 edition code because the differences are "just" a skin over the same underlying compiler.
The safety is strong in this one. But in all seriousness, kudos to OP for putting in the hard work necessary to implement a performant web framework without the asterisks of safety/soundness concerns. Rust by design demands a lot, that its programmers don't just find a solution that empirically works, but a solution that can be statically proven to work, and OP is doing great work to meet that challenge on a complex application.
Thanks a lot, everything is working fine now. *The blocking I/O model is driving me crazy. Now I have to invent my own "event loop" to listen for events fired by my server.*
Congratulations on this release!
thx :)
If you can be absolutely sure beyond a shadow of a doubt that a failure is impossible, I think it is okay. However if there is any doubt - any uncertainty - you need to assume the worst.
It depends. In library code, returning `Result` is usually preferred. In application code, as long as you have a proper panic handler, it's fine using it.
I personally tend to read syntax ’phonetically’ without rewording based on meaning. So `&amp;str` to me is just “and stir”, and it takes “an”. :)
still in implementation, love to hear your advice!
I insist on `expect("description of broken invariant")` over `unwrap`. As for your example case: * I'm fine with using `expect` in binary (ie. non-library) crates. * For library crates, only if it's something I couldn't possibly be expected to recover from, like a memory parity error. As-is, I'm paranoid enough about it that... 1. I wish I had time to write something similar in concept [cargo-geiger](https://crates.io/crates/cargo-geiger) or [cargo-safety](https://github.com/alexkehayias/cargo-safety/) but, instead, listing all non-whitelisted function calls in my program capable of panicking, broken down recursively to show the call trees leading to the actual `panic!` invocations. 2. I'm considering wrapping something like this example around every meaninfully atomic chunk which calls 3rd-party crates: for path in files { if let Err(err) = std::panic::catch_unwind(|| { // Code which calls into 3rd-party crates }) { // Code equivalent to `except Exception as err:` in Python } } (Yes, one of the biggest things that drew me to Rust was `Result`'s promise of exposing all recoverable failure paths in the type signature... something which it hasn't lived up to no thanks to the lack of good tooling for auditing for `panic!` abuse.)
That's just not how `cfg` works though :/ Note that there are many things that you can't do with `cfg`, like for example give that monstrosity a name so you can just do `#[cfg(foo)]`, among many other things. The `cfg_if!` crate lets you write: cfg_if! { if (#[cfg(target_arch = "x86")] || #[cfg(target_arch = "x86_64")]) &amp;&amp; #[cfg(target_feature = "avx2")] { fn foo() ... } }
I think you mean // no need for the repetition of 'a impl MyStruct&lt;'a&gt; { not // no need for the repetition of 'a impl MyStruct&lt;'a&gt; {
In my mind result =&gt; errors caused by user input or hardware or the network panic =&gt; errors caused by my code being incorrect If the hashmap I’m writing suddenly has its invariant broken, I don’t want to log that and move on, and there’s not really much I can do to recover from it at runtime. Panics shouldn’t happen in production, obviously. But if there are branches in your code that would only be reachable if the code itself has an error, then continuing on doesn’t seem like a good option 
I don't see the point. If someone tries to compile and it doesn't then they should just upgrade the compiler. Their code is guaranteed to work on a newer compiler.
This is what I do: I try to map everything with an descriptive error, which essentially makes the application panic close to it's entrypoint with a chain of errors using `failure`. This chain also describes a basic trace, which is useful to print for end user in an _error... caused by... caused by..._ fashion. I believe that panicking is the best most of the times to prevent weird states and broken recovery code from executing. When building an API I pass the chain of errors along to allow the user to decide whether to handle the situation at runtime or whether to panic. In some very exceptional cases I use a function which returns a `Result`, although the way it's used would never make it possible to return an error. In such cases I use `expect` to unwrap. 
If you're writing a library, you should avoid doing that in favor of returning errors. But sometimes invalid data can be unrecoverable errors anyway, so unwrapping would actually be the right thing to do. Expect is a bit nicer way of doing it, since you can leave a message. My advice on binaries is very similar. You should use it if the failing to receive a valid value would result in an invalid state of your program. So to protect your data, you crash and burn. Some people think it's better to dump a stacktrace on the user, so he can send you a very useful piece of data about the event and some people think that is a terrible idea and you should write some descriptive text about the error. In both cases you can use expect. On the former you would want to capture the panic and log the output, then display the message and finish the program. IMHO if you're going to do that, you should always try to use expect, since the message can help you find the bug faster.
Is it guaranteed that `Fragile::drop` doesn't run `T`'s destructor if it panics? [Some testing](https://gist.githubusercontent.com/purpleposeidon/8328f2d8a0f249aa19cd63bd1e588442/raw/633a07be274db9ea99dc7e4bd1fba1d1bbd1bb26/fragile_test.rs) suggests so...
That definitely makes more sense. `AsRef&lt;PathBuf&gt;` is sort of a nonsensical signature because `PathBuf` implements `AsRef&lt;Path&gt;` and there isn't really any use to disallowing `Path` as an input if you're just going to `AsRef` it anyway.
I really look forward to the new module-path system! I mix that up all the time...
I would say, you trigger undefined behavior (`std::hint::unreachable_unchecked`) if a failure is impossible "beyond a shadow of a doubt". You can use panics for the other cases.
Thank you for taking the time to write about the uses! This is helpful! Are there plans for documentation? :)
One thing I still don't get: Do I have all this if I am using nightly already? Or do I have to opt-in to the Rust 2018 edition on nightly as well? Because I swear just a few days ago: https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/modules/path-clarity.html#no-more-modrs definitely did not work for a project I solely use nightly (updated once ever weekish)
When is Rust 2018 landing?
I like the idea of passing the object to the callback - it's pretty much how every other event-driven framework does it, and it lets you share the callback between multiple objects if you ever want to handle multiple message streams.
Ah yes, thank you! Copying and formatting code is hard on a phone :/
Yeah. It will only invoke the destructor if the object gets dropped on the pinned thread.
I just realized I can't do that :/ Do you have a second favorite?
Why can't you do that?
(Which should be stable early August, seeing as 1.27 was just released)
I'm pretty sure you're incorrect about the `&amp;'arg` part, since it doesn't even compile: [play.rust-lang.org](https://play.rust-lang.org/?gist=5160ec13eec3ccae455dab3ba826e95a&amp;version=nightly&amp;mode=debug). It should be `fn bar(&amp;self, arg: &amp;'arg str) -&gt; &amp;'arg str`
Ahh, see, I was wondering if it might have been a typo. /u/steveklabnik1?
I wrap the callback C in another callback, let's say D. I have to pass D to an external crate when I create O. D would have to look like this: `|data_from_crate| (c)(data_from_crate, &amp;self)` where `self` is O. The problem is, I don't have `self` yet while creating O.
The point is if the developer cannot upgrade the compiler, for example if they have to use some version approved in some project. Still, for this to be really useful I think it needs cargo to be able to pick the latest version of a crate that still supports a particular compiler version. Otherwise it is still up to the developer to find that crate version and explicitly depend on it, and including a note in the README would be just as good for that.
I would prefer `unreachable_unchecked` to only be used if its "beyond a shadow of a doubt" + absolutely necessary for performance. 
&gt; Their existing code is guaranteed to work on a newer compiler so there's no downsides to upgrading. Ah, you sweet summer child! The last time my company updated from gcc 6.x to gcc 7.x, we had to wait until gcc 7.3 because 7.0, 7.1 and 7.2 all were miscompiling the code due to a bug in the 7.x version of gcc. Just because the language specification guarantees backward compatibility does not mean that the *implementation* successfully implements the guarantee. Also, in some environments such as embedded/military applications, a compiler version must be certified before using it is allowed. Such certification process is usually extremely stringent, and therefore costly both in time and money, and not undertaken lightly. The result? There are very good reasons NOT to upgrade the compiler.
Then why not make adding the callback a method of O? Then, inside that method, you also register D with the external crate. 
&gt; it needs cargo to be able to pick the latest version of a crate that still supports a particular compiler version "Versions resolution" tries to describe exactly this functionality.
Well, I had that thought too and it would work, yes. Why I don't like that approach is because I need 2 objects from the creation of O for registering D with the external crate. I would have to store them in the struct so that they are accessible from the method in O. I don't need them for anything else, though, so they would do nothing but take away space for most of the time.
Thank you for this release! It’s weekend but let’s deploy! Very great project!
Can't you just create those objects inside the method? Assuming the other crate takes them by value, there's no reason that won't work. 
Can you give [Vibora](https://github.com/vibora-io/vibora) a try on your laptop (it is )? Here is `app.py`: import sys from multiprocessing import cpu_count from vibora import Vibora, Response app = Vibora() @app.route('/plaintext') async def home(): return Response(b'Hello, World!') if __name__ == '__main__': app.run(host=sys.argv[1], workers=cpu_count(), debug=False, port=int(sys.argv[2])) It requires Python 3.6+ and `vibora` package (`pip install vibora`): python app.py 127.0.0.1 8081 For some crazy reason, it achieves 328k req/s on my laptop: wrk -c 1000 -t12 --latency -d 30 http://127.0.0.1:8080/plaintext Running 30s test @ http://127.0.0.1:8080/plaintext 12 threads and 1000 connections Thread Stats Avg Stdev Max +/- Stdev Latency 4.72ms 6.22ms 105.52ms 86.53% Req/Sec 27.61k 6.09k 69.75k 72.37% Latency Distribution 50% 1.86ms 75% 6.52ms 90% 12.98ms 99% 27.77ms 9868509 requests in 30.09s, 837.61MB read Requests/sec: 327949.20 Transfer/sec: 27.84MB 
[I already answered that on StackOverflow](https://stackoverflow.com/questions/39477684/should-i-avoid-unwrap-in-production-application/39478185#39478185) and the answer became quite popular there. &gt; **In summary**: use `unwrap()` when you are sure that the *recoverable* error that you get is in fact *unrecoverable* at that point. Bonus points for explaining “why?” in a comment above the affected line ;-) So it's absolutely fine to use it, if you use it correctly. But please read the whole answer to understand my arguments :) 
I think this is a bug in the Language – the English language, I mean.
My advice would be: - Write some more in the README. Get people interested if you want them to try it. What are your goals, what is different then in other editors etc.ppp. - Provide binaries.
According to this advice, if I published a crate with a parser that used regular expressions internally, then you would be against calling `Regex::new(...).unwrap()` on a pattern that is written by the programmer. That is, the unwrap failing is always a bug. We shouldn't be returning errors for every conceivable bug. Panicking on a violation of an invariant is perfectly acceptable. Moreover, exposing functions that may panic based on whether the caller upholds documented invariants is also acceptable. If you call the above "abuse" then I can see how you think it happens a lot. I'd just like to respond and emphatically say that I not only see the above as not abusive, but something that should be encouraged. I realize we don't agree on this point, but I'm tired of people getting the impression that they should be abiding unwrap/expect as if it were some terrible thing. Use it when you must to express broken invariants, and don't use it for error handling.
Are you new to Rust? They have extensive unit testing for this type of thing.
The entire point of Rust's guarantees is that you shouldn't need to care about compiler version. The thinking that you can't upgrade a compiler is legacy from non-Rust languages. What OP and you are talking about introducing just brings to the forefront things that people should NOT be caring about. It sends the wrong message.
I'd want it written something like `Regex::new(...).expect("valid regex from string literal")` When I say "`panic!` abuse", I'm specifically referring to things like the `panic!` that greeted me on my first attempt to run goblin against my little pile of test EXEs.
Rust's guarantees are not absolute however. For example, they consider it ok to make breaking changes to fix a serious bug. I agree with this policy, but it does mean that your code can break when upgrading the compiler. I have experienced a case where the 'ring' dependency broke between 1.15 and 1.16 and fixing it required updating ring, which in turn required updating other libs.
Does Rust 2018 work on the playground? It's not quite clear but maybe Rust 2018 creates a named lifetime for each local (or at least parameter) with the same name as the parameter?
Bullshit. There are a wide variety of good reasons "upgrade your compiler" is not a suitable answer. For one thing, there have been backwards-incompatible changes in rustc. (They were justified, and I won't comment on the validity of the justifications, but they were still backwards-incompatible changes.)
yeah 2018 edition works on the playground if you use nightly and use the correct features, [e.g.](https://play.rust-lang.org/?gist=5160ec13eec3ccae455dab3ba826e95a&amp;version=nightly&amp;mode=debug)
why not use some meaningful, unambiguous naming? compiler-version="1.40" language-version="2015"
Easy easy, I was being a bit sarcastic, and he's seen this post 😂
I would have to duplicate some lines of code and violate the DRY principle :/ It would work though, yes