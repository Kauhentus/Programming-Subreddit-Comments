Interesting, I wasn't aware that LLVM had such a type. Definitely worth filing an issue to make sure that rustc starts leveraging it here.
Finishing up glTF morphing and skinning support for Three-rs.
I use it and am extremely happy. The release cadence is nice -- not too stale, always tested -- and the community is focused on doing good solid integration work. I'm using Plasma on my Fedora and it's the best desktop experience I've ever had.
Thank you for the great release again @koute. Your work on stdweb &amp; cargo-web improve rust webassembly scene a lot. 
Yes, Vec is a good example of sensible use of unsafe. To be clear, I have no complaints with the article beyond the title - the OP is aware that they could do this with unsafe code. If they have some experience with C, they likely wouldn't find it too difficult. I think Rust maybe accidentally encourages a kind of purism - people think they have to avoid things like heap allocations, copying, or unsafe code, when sometimes all of those things are helpful and necessary.
Thanks for that information. The standard library documentation for `catch_panic` needs to be updated. I checked that and it still says that callbacks are the main use. As of last week's stable it's not necessary and that's pretty cool. 
&gt; There is also a fourth option, written up recently in this excellent blog post: https://exyr.org/2018/rust-arenas-vs-dropck/ This approach maintains compile-time borrow checking, allows mutation, and uses pointers instead of indices. It is basically your option 3 (Vec with indices), but using fixed-sized chunks to grow the backing storage rather than a dynamic array that can move its contents in memory. I don't think you can actually make it use mutable references when it's a doubly-linked list. Because self.next.previous.value and self.value are one and the same field, and so direct mutable references as the next/previous pointers would allow you to have 2 distinct mutable references to `self.value` at the same time. The borrow checker can't help you because it treats field-level borrows as entirely independent.
The GitHub repo is here: https://github.com/mattgodbolt/compiler-explorer
That's a really good point. Unsafe has such a strong connotation of badness in my mind, but really, most other languages are _exclusively_ unsafe.
Wow, I had no idea unsafe code was required for `Vec`. That's really interesting. It sort of just dawned on me that unsafe really isn't that bad -- _unsafe_ is essentially the default for most other languages.
Right, it can't use mutable reference as in "the prev field has type `&amp;mut Node`", but it does allow mutation via either `RefCell` or `Cell`.
So what's the stability of cargo's cli API? I wonder how many people rely on this behavior.
This is "pair of scalars" which used to be only for raw pointers, but is useful in general. Passing as vector when the two scalars have the same type seems doable but there's always a risk of LLVM doing something unexpected on various platform and type combinations. Also, try `extern "C"`, should produce the same instructions clang does.
Probably the Markdown equivalent to the HTML that Doxygen translates them to.
gfx supports turning its OpenGL stuff into webgl, I believe.
It’s linked in the post.
Yeah, but we are currently using Emscripten. I'm looking forward to get pure wasm approach, eventually.
I tried `extern "C"`: https://godbolt.org/g/zZ7MRg It doesn't improve the output; in fact, it generally makes it worse. With `#[repr(simd)]` enabled it does remove the pointer load, but doesn't do the vectorisation appropriately. Without `#[repr(simd)]` it produces a mess not much better than GCC's output. The most efficient output so far is the plain old code without either `extern` or `repr` annotations, which doesn't vectorise, but at least doesn't insert any unnecessary instructions.
&gt; Some languages have projects dedicated to interacting with Rust. E.g. ruru for Ruby &lt;-&gt; Rust. These potential perform better, or create better bindings, or have more features. I haven’t investigated yet and would be interested to know. The big reason I haven't really considered using anything but rust-cpython (or, when it works on stable, PyO3) is that I'm a Python programmer who spends essentially all of his time on I/O-bound tasks. My interest in Rust is predicated entirely on it reducing my maintenance burden compared to working entirely in Python. rust-cypthon has three advantages (which PyO3 seeks to improve upon): 1. The build process is as simple as running `cargo build` and then copying the `.so` file into my Python module path. (And `setuptools-rust`does that for me when I type `./setup.py build` along with similar integrations for other subcommands.) This is the point that eliminates [rust-qt-binding generator](https://github.com/KDE/rust-qt-binding-generator) from consideration. It's oriented around incorporating Rust into a C++ project and I'd rather glue Rust to PyQt for my GUIs than deal with C++ code and build systems.) 2. The per-function/type boilerplate and cognitive overhead for exposing Rust stuff to Python is minimal enough that it becomes feasible for me to prototype in a mixture of Rust and Python. (For example, `rust-cpython` has its own family of traits analogous to `Into`, `From`, etc. which enable it to Just Work™ when you expose a function to Python which takes or returns common Rust types.) 3. `rust-cpython` wraps the unsafety of doing FFI in a safe abstraction. (This is probably the most important thing. I use Rust because it has more static safety guarantees than Python. Without a safety-preserving FFI abstraction, I'll just write my CLI projects in pure Rust and my GUI projects in pure Python+PyQt.) The latter two eliminate from consideration everything I've seen where `#[no_mangle]` or `extern` appear the example code.
I do dream of the day when unsafe Rust can be verified by linear logic proofs though. 
Disclaimer: I'm a pythonista looking for a use case for learning rust. I think the language has awesome ideas, but I almost never run into stuff where I need such raw performance. This WebAssembly stuff might just be it! So, I ask to the community: why should I use rust to target WebAssembly instead of, you know, python?
It's ridiculous how reddit doesn't bump threads when they're approved. It breaks my heard every time I work through the mod queue. People unknowingly talking to themselves and wondering why nobody is out there. :(
This is awesome! I’m trying to slowly plant the idea of using Rust in the mind of a friend that studies dark matter. I think this will be another step in that direction :) P.S. - I think you mean cache, not catch
That sounds awesome! How are you getting along with that? Do you have any code to share? Having seen just how much code Swig generates, I feel like it would be a huge task to reimplement it.... If there was a "SwigIR" though, that would be cool...
https://github.com/sconover/wrong Ideally we'd just write regular code and intelligent errors could be generated like this Ruby lib.
Thanks :) It is indeed using `CStr` for the inputs. I like the idea of using `&amp;[u8]` instead, but would be worried that it would end up being more awkward to use? Depends on whether typical usage will have a string or bytes in the first place... 
I think it's a limitation with Rust's compiler. It makes sense to be how it is; if you're asking the compiler to emit debug info, you likely want to be able to use it to eg: see a stack trace when the program is paused in a debugger, and for that to work, every function must have the code to record its stack frame. I guess they just never considered the use case of debug info to aid disassembly?
Just wanted to say thanks for the very thorough answers
Ok, thanks.
Well, in this case it was only in the queue for 10 hours. :P But yes, in the occasions where a post *doesn't* end up resolving itself, I usually ask the submitter to manually resubmit.
Most of the hashing functions I've seen take `&amp;[u8]`, though I suppose they aren't all specifically designed for passwords. If you want to pass a string to one, you just need to call `as_bytes()` which is a no-op.
You mentioned using `CStr` in the text, but the code listed used `CString`, which does allocate.
It does that if you import from a `src/lib.rs` file. It'll find the Cargo config then and build the entire project with Cargo instead of rustc. 
This is really cool! I can't wait to use rust on embedded systems. The examples could be a little clearer though. For example, what's the role of the rcc variable? I don't think it's really explained in the article 
&gt; How are you getting along with that? Do you have any code to share? It works, and I use it in my projects, it has DSL in Rust based on idea of From/Into traits to describe types conversation: https://github.com/Dushistov/rust_swig Though, some ideas from cbindgen would be nice to borrow, plus at now it supports only Java and C++.
Ah, that makes sense. Thanks!
Please check: http://blog.japaric.io/brave-new-io/ for more details. 
Can you even target WebAssembly in Python without shipping all of cpython and libraries with it?
just do `dnf install ternimal` :)
You can definitely use the https://docs.rs/percent-encoding/ crate if you need to do manual url encoding on a string.
Definitely! It's the solid foundation underneath pretty much all of rust. The [Rustonomicon](https://doc.rust-lang.org/nomicon/) has a pretty good definition of the boundary if you haven't already seen it. It's definitely the resource you'll want/need if you want to look into unsafe rust.
It was not initially.
This thing would need to do some deep learning in Rust (or at least deploy it). I wonder how they do it.
without looking much at the code, it's difficult to guess where the issue is. About parsing with iterators vs with slices: [nom](https://github.com/geal/nom) is heavily built on slices, so it's a completely valid way to build a parser, but iterators should have about the same speed in simple cases.
&gt; A difference from the typical C++ implementation, AIUI, is that Rust has fat pointers - the thing you pass around is a pair containing a pointer to the trait object's data, and a pointer to its vtable. Interesting - that's conceptually what you'd want, and pretty close to the "dictionary of functions" approach, but I suspect that in many cases the "fat pointers" approach could be optimized by eliding redundant vtable pointers. I suppose that a "sufficiently smart compiler" would do this via SRA ('Scalar Replacement of Aggregates') but I have no idea if LLVM actually implements this kind of thing, let alone if it's *also* smart enough that it does rewrite ordinary Rust code to optimize the use of 'fat' references.
As written, your comment isn't very constructive (rule 2). Would you mind clarifying what you mean by insufferable?
I'm working on packaging `xsv`, stay tuned.
Yes, that's a very sensible long-term goal, and a reason to pursue more rigorous specification of what Rust is supposed to do with `unsafe` code - what's currently in the Rustonomicon. Besides, proof-carrying code would also help address correctness issues other than memory safety in ordinary, safe Rust.
This looks like exactly what I need. Thanks!
You can always take a look at the source for read_exact: https://doc.rust-lang.org/beta/src/std/io/mod.rs.html#701-716
It's not mentioned in the article, but if you look at their FAQ on github: https://github.com/snipsco/snips-platform-documentation/wiki/FAQ &gt; **Is Snips open-source?** &gt; &gt; Snips will be open source soon I think that's actually the coolest thing about this!
The issue is already there: https://github.com/mattgodbolt/compiler-explorer/issues/79
I take it you didn't see [the recent merge](https://github.com/rust-lang-nursery/rand/pull/265). Now `RngCore` generates random values, and users use `Rng::gen()` or `Rng::sample(distribution)`.
I have already tried let mut r = io::stdin(); read_mode(r.lock()) and let mut r = io::stdin().lock(); read_mode(r) says the same thing about the borrowed value not living long enough. Is that what you mean?
spotify-rs
Not sure I understand. You can load native modules in Python that are written in Rust. You can compile Rust to WASM. You cannot (AFAIK) transform python code to become WASM.
yes, I have been waiting for this kind of library. author of github-rs was saying something about creating a generic library for creating wrappers. does it supports reusing parts of request/response?
I paid a very strong attention to error handling. It's just not returned to the users. Maybe I should allow users to have access to errors? To be discussed.
Maybe I missed it but there doesn't seem to be any mention of https://doc.rust-lang.org/nightly/std/collections/struct.LinkedList.html – I'm sure looking at how the standard library implemented a doubly linked list (using unsafe) can reveal some cool new tricks.
why append? escape!
I don't know either. That kind of optimisation (if i've understood you correctly) hinges on the compiler being able to work out the underlying type at compile time; that's often possible in JIT-compiled languages, but i think isn't such a big deal in AOT-compiled languages. In Rust in particular, the emphasis on parametric polymorphism means that we tend to only use trait objects when we genuinely can't know the underlying type at compile time - you won't have a variable of type Calendar just because you want to hide the fact that it's a GregorianCalendar, you'll have a variable of type T: Calendar. I recall reading some discussion of optimising the case of a slice of trait objects which are all of the same underlying type. At the moment, that means a slice where every element is a fat pointer, but it could be a structure with a single vtable pointer, and thin pointers as elements. 
Unsafe code is not required for Vec, but Vec can be implemented more efficiently by using unsafe code.
If you have to chose between those two, I would recommend to use ring, at least you will not have to [solve](https://users.rust-lang.org/t/cargo-dependency-hell/13124) incompatible OpenSSL versions mess. But ring can [occasionally](https://github.com/SergioBenitez/Rocket/issues?q=label%3A%22nightly+breakage%22+is%3Aclosed) break on nightly. Also I would like to suggest to take a look at [`hmac`](https://docs.rs/hmac/) crate and [`sha2`](https://docs.rs/sha2/) (or some other hash from [RustCrypto/hashes](https://github.com/RustCrypto/hashes)). SHA-1 and SHA-2 implementations are bit slower compared to those in ring, but on other hand you'll get significantly smaller, pure-Rust dependency. (it's a shameful plug if you haven't noticed :) )
You can just use an Rc for the next node and a Weak for the prev node or what am I missing? That’s simple, works, and allows mutation.
The question is, why isn’t llvm doing this transformation? Or why isn’t llvm applying the vector optimization’s to suitable structs?
I'm an experienced programmer working my way through [the book](https://doc.rust-lang.org/book/second-edition/) and I'd like to display a couple of strings. let m1 = String::from("hello"); let m2 = "world".to_string(); for m in vec![&amp;m1, &amp;m2] { println!("{:?}", m); } is vec! the way to go, or is there a better way?
The author notes that in passing, but it's not what they take issue with.
Not sure I agree with that 100%. A GC will only save you from an _incorrect_ implementation by maintaining references to things that a Rust implementation would have dropped. But then that implementation would still be silently incorrect, versus Rust, where you'd likely get (UB, but then) a panic eventually. Ultimately, it very much depends on the implementation, and how you handle (de)allocation of the list nodes.
I think currently the main reason someone would have for using WebAssembly is performance, in which case using Python over Javascript is almost certainly just going to be slower. In the longer term I think the hope is that there will be an API for WebAssembly to talk to the DOM, and if that becomes possible you'd be able to replace Javascript with Python if you so wish
Sort of. If you have [Raw, WithRaw, or TryWithRaw](https://docs.rs/anterofit/0.1.1/anterofit/net/response/index.html) as a service method return type, it will return the response with the deserialized body (if applicable). I've conceived of a `map_response!()` combinator that would let you do that inside the service method but I haven't figured out how to implement it yet.
The real question here probably should be, "what code is generated when these functions are actually used", not "what code is generated when they are compiled in isolation". Especially the add function should definitely get inlined at all call sites, at which point Rust's usage of SRoA over vector types should become irrelevant.
This is written partly as a solution to improve performance of my another web project, which uses Rocket (based on hyper 0.10.x), diesel and redis-rs, all using blocking I/O, and I try to ensure both the scheduler and monkey patches are implemented correctly and efficiently. Currently, the patches are rather "conservative", and the only patched functions are network &amp; timer-related ones. I'm trying to figure out how to patch `pthread_*` correctly, but this seems to be really difficult. Also, using TLS and other non-`Send` types will no more violate Rust's safety rules in the latest version of rust-coroutines (with the default configuration) because work stealing is turned off by default (with an unsafe option to turn it on).
One huge advantage of rust libs is seamless portability and ease of cross compiling. I would pick it almost every time. Unless you also require ssl and rustls is not sufficient.
That's weird, us generating very different code from clang when the ABI matches is a bug, please file an issue and cc @eddyb.
&gt; I wonder if there might be some macro-magic to reduce the boiler plate in this case. Hmm, maybe some custom derive magic à la `serde` would work?
A wonderful post for folks who haven't been keeping up with Jorge's excellent work. What would make this post perfect: Snippets of assembly output for each approach. How close to zero are the zero cost abstractions? :-)
Vec is mostly useful when you want its specific capabilities: ability to resize the container on demand, add or remove elements. In this case, a slice will suffice. ``` let m1 = String::from("hello"); let m2 = "world".to_string(); for m in vec![&amp;m1, &amp;m2] { println!("{:?}", m); } ```
Thanks. I just found ```[ ].iter()``` but ```&amp;[ ]``` is clearer imo.
Another alternative (for hash functions) is [crypto-hash](https://github.com/malept/crypto-hash). This crate uses OpenSSL on Linux &amp; the native libraries on Mac OS X &amp; Windows. I think its a reasonable choice for hash functions in CLIs or desktop apps you plan to ship to these environments; cargo uses this.
RCC stands for Reset and Clock Control. I don't think anyone has bothered explaining those variables very well because they are specific to the microcontroller. Most of the development that I've seen for rust on microcontrollers has been focused on STM32, which are all very similar though. The easiest board to get into this with price to performance wise is probably the bluepill board (STM32F103 microcontroller). Here's the manual for it, if you want to see what any of the other registers in the examples are for http://www.st.com/content/ccc/resource/technical/document/reference_manual/59/b9/ba/7f/11/af/43/d5/CD00171190.pdf/files/CD00171190.pdf/jcr:content/translations/en.CD00171190.pdf
Please share code, otherwise it is difficult to provide help. I am particularly interested in what you mean by "unsafely blitting structs from slices of bytes."
Personally I prefer the simple interface as it is. Getting a "Result" for a situation where errors shouldn't really happen is annoying, it adds complexity to my code. There is such a thing as being overly pedantic when designing an interface. Then again, I'm unsure of the nature of the error and how they are handled.
Ok, so, I have [these iterators](https://play.rust-lang.org/?gist=8ae53b5ffe5ea29168d1fc79266eda0d&amp;version=stable) lying around. The problem was that I was trying to build iterator pipelines where intermediate steps would introduce `Result`s, but subsequent combinators didn't support them as input. Even so, I wanted to preserve all errors, and didn't want to collect into any `Vec`s. `trap_err` interdicts the sequence and, when it sees an `Err`, writes it to the trap storage and truncates the sequence. It basically short-circuits a pipeline as soon as an `Err` passes through it. `lift_err` effectively routes all the `Ok` elements from an iterator through a separate iterator pipeline, with the first `Err` cutting off this `Ok` pipeline. I never tried adding these to itertools because they seemed kind of hacky, and I could never decide if this was a good idea or a terrible one. Both are contingent on iterators on both sides behaving nicely which... may or may not be the case. On that note, have you considered trying to add these to itertools?
Like I said, `docs.rs` is using it through `sysinfo-web` and they filed me a lot of issues when exceptions occurred. They never had any issues since last fix so I can assume it's pretty safe.
&gt; I'm just disappointed that std doesn't implement it on tuples of numbers. Why would std need to do this? There are multiple valid meanings for Add on tuples of numbers or arrays of numbers.
That sounds like `memcpy`.
&gt; My history may be off Yeah I don't recall this. &gt; Would that be too opinionated? I don't think so, but there's some other stuff that this plan doesn't consider. That is, this isn't the only thing that's controlled by this switch; if `Cargo.lock` is in your `.gitignore` or not, for example, depends on the type of project. Of course, there's also been discussion about removing that distinction too.
Oh dang, I mis-read that announcement. Yes, I am very much looking forward to that too, then.
"unclear" does not mean "impossible" :)
Same to me. It confuses me every time I start a project and I am happy when it works :)
It's just a [generic type](https://doc.rust-lang.org/book/second-edition/ch10-00-generics.html) like any other.
The default implementation of `read_exact` is allocation-free, so any allocations there must be from inlining `read`
Yes, Rust is written in Rust. https://github.com/rust-lang/rust
Unlike booleans, this also lets you easily add a third option later on without changing any of the code already using this function.
I'm surprised such calls are not inlined. If they were any performance drawback compared to "slicing" would be reduced.
Fundamentally, it's possible. However, your users would have to download the entire Python runtime every single time they hit a webpage. That might not be acceptable. A minimal example in Rust is ~100 bytes; a minimal Python example is going to be a lot, lot, lot larger than that.
Note that `*ring* is a port of BoringSSL, which is a fork of OpenSSL. So long ago, they were the same code.
There [dyon](https://crates.io/crates/dyon).
Tensorflow merely selects precompiled implementation of its functions at runtime. Theano does full runtime compilation.
References * [rust](https://github.com/rust-lang/rust) * [plank](https://github.com/jDomantas/plank) * [menhir-lang](https://github.com/GeorgeKT/menhir-lang) * [minicom](https://github.com/agatan/minicom) * [tiger-rs](https://github.com/antoyo/tiger-rs) * [kaleidoscope-rs](https://github.com/BookOwl/kaleidoscope-rs) * [inko](https://gitlab.com/yorickpeterse/inko) * [NovaLang](https://github.com/boomshroom/NovaLang) * [gluon](https://github.com/gluon-lang/gluon) * [dora](https://github.com/dinfuehr/dora)
[Gluon](https://github.com/gluon-lang/gluon) - A static, type inferred and embeddable language written in Rust. [Wu](https://github.com/wu-lang/wu) - a strongly typed language that transpiles to lua.
&gt; For example, a static site generator in Go, vs Rust. I'd say a static site generator is not something that makes sense to write in Rust, or any other low-level language for that matter. Just grab your friendly Python environment, write a few hundred lines of code and you're set. Put your strings into a linked list to avoid memory copies on string addition and it's going to be fast enough - nobody really cares if it takes 0.1ms or 10ms, you can afford that much per update anyway.
&gt; A GC will only save you from an incorrect implementation I don't know of anything that will save you from an incorrect implementation. A GC will however give you memory safety without jumping through hoops. &gt; Ultimately, it very much depends on the implementation, and how you handle (de)allocation of the list nodes. That's my point - in a GC language you don't (handle deallocations), and it's memory safe. The original post even mentioned how easy it is to implement in Go, and would have been just as easy in Pony, Nim, D, Java, C#, ...
Yup, I failed to consider the effects (limitations) of crossing the FFI boundary on a slice. Or in this case a zero-length slice as claire_resurgent pointed out. Initializing my vector with data appears to have fixed it. The array would also work.
Hey! I actually saw your serialport crate and poked around with it a bit, but tangling with cross-compiling the libudev dependency was more than I wanted to get into at the time.
I have absolutely no idea. My guess is that the code would be compiled to a "assembly" representation. 
That would certainly be a dream coming true!
&gt; However, your users would have to download the entire Python runtime every single time they hit a webpage. That might not be acceptable. Thanks so much! Another question here: is there any rust equivalent to the python pandas data manipulation library? That thing is a godsend for my day-to-day work.
Very cool! Always great to have more TUI stuff :D
In a way _unsafe_ means _safety belts off_. You still have a roll cage, airbags and if you drive safely then you should be fine. But should something bad happen, it'll probably hurt more.
I agree that's the most interesting part to me as well.
Yeah, Rust wasn't designed to be usable within 80 columns. :/
This seems to be a regression in Rust 1.18, where the LLVM IR signature changed from `&lt;2 x float&gt; @add(&lt;2 x float&gt;, &lt;2 x float&gt;)` to `double @add(double, double)` which LLVM can't optimize well: https://godbolt.org/g/1iu8n2
It's not impossible! I used to bullseye womp rats in my T-16 back home. They're not much bigger than two meters.
I can't get app_basic to do anything except say "Value must be one of options", which is not a very helpful explanation of what I'm doing wrong. I'm using the arrow keys to select an option, then I've tried hitting spacebar, enter, ctrl+f, all sorts of things.
The relevant PR tracking webgl in stdweb 
Hi, author of crypto-hash here. I wasn't aware that cargo uses it (very exciting!). Regarding OP's question, crypto-hash might not work for them as I haven't finished HMAC support - getting the Windows implementation working has been a challenge.
That's how linked lists work, isn't it? If I understand it correctly, you could also use Option&lt;Rc&gt; and Weak depending on whether you want to drop parts of the list.
Why is this downvoted? This is ingenious!
Ideally, `const fn` will allow that kind of thing sooner or later. For now, I would suggest just generating the array in a `build.rs` script, dumping that to somewhere like `src/table.rs`, and then in your code just do `const MY_TABLE: [u8, 5] = include!("table.rs");`. To recap, the content of `table.rs` would solely consist of [101, 102, 104, 108, 116] I have tested, and this approach works just fine.
After digging in more, I'm fairly confident it wouldn't be competitive with a B-Tree, at least as designed. It seemed like it could be an interesting way to store a time series since you can have integer nanosecond timestamps or similar
It would be super amazing if I could hand `fui` a `clap::App` instance and just auto-magicly have a TUI :)
It was, but the link didn't have the name on it, it just said "A book about linked lists"
I would be interested in this as well, i am trying to write a simple version of a system wide UI automation tool and this would be handy :)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/a8m/pb) - Previous text "pb" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
While this bot gets an "A" for effort, this is literally the least of my problems with reddit mobile site... 
Great project, definitely a worthy goal. I know several people who are skeptical of voice assistants because they aren't fully on device. The blog article was very lean on the technical details apart from some basics about rust's safety and portability features. could you elaborate on where the gains from rust come into play ?, is your model built on a DL framework that is written in rust ?.
This sounds like an idea for another crate! Bridge/combine `clap` and `fui`. I'd work on it if I had the time, which I currently don't. Maybe sometime in the future, if `fui` catches on and people start using it a lot.
Wow level 3 there was really elegant. In general I try to find use for a strong type system to force correct code, but here it's Rust's ownership model that ends up saving the day. 
FYI: /u/CryZe92 pinned the change to Rust 1.18 (see [this comment](https://www.reddit.com/r/rust/comments/7z7oke/xpost_from_rprogramming_checking_simd/dunkzzv/)), see https://godbolt.org/g/1iu8n2 .
&lt;pedantry&gt; A command-line interface or command language interpreter (CLI) [..] is a means of interacting with a computer program where the user (or client) issues commands to the program in the form of successive **lines of text** (command lines). ([wikipedia](https://en.wikipedia.org/wiki/Command-line_interface)) `fui` doesn't seem to be line-based, so it's not really for CLI programs. &lt;/pedantry&gt; that off my chest, it looks like cute little project, even if I'm not the biggest fan of curses.
**Command-line interface** A command-line interface or command language interpreter (CLI), also known as command-line user interface, console user interface and character user interface (CUI), is a means of interacting with a computer program where the user (or client) issues commands to the program in the form of successive lines of text (command lines). A program which handles the interface is called a command language interpreter or shell. The CLI was the primary means of interaction with most computer systems on computer terminals in the mid-1960s, and continued to be used throughout the 1970s and 1980s on OpenVMS, Unix systems and personal computer systems including MS-DOS, CP/M and Apple DOS. The interface is usually implemented with a command line shell, which is a program that accepts commands as text input and converts commands into appropriate operating system functions. Command-line interfaces to computer operating systems are less widely used by casual computer users, who favor graphical user interfaces or menu-driven interaction. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Ah yes, good catch. Thanks. Copy-pasted from the wrong place :)
On the Rust side I could change it to be `AsRef&lt;[u8]&gt;`. But I will have a play with it to see what impact that has on the other languages. For example, it would be a pain to see `hash_password(pw.encode())` everywhere in Python, it should \*just work\*. It might work fine since function overloading is a think in C++, so if I define `hash_password(char*)` AND `hash_password(int*)` then both will be okay, and in either case it can just convert to a `&amp;[u8]`. Anyway, I will have a test. Thanks for the suggestion!
Seems like it's in the TODO list: &gt; add magic which renders form for clap (or structopt) if args missing
Thanks for the insight. That's really interesting. I can see how our two workflows are currently incompatible. The work you do in (2) gives you more, at the cost of being compatible with Python. As an aside: this is Rust code which is *only* for use within Python as opposed to a standalone Rust lib which you also want to use in Python, correct? That being said, I don't think any of the 3 points you mention are inherent advantages, but just a state of the tooling. These could be built into Rust+Swig tooling (for example, see [Dushistov's](https://www.reddit.com/r/rust/comments/7z7pml/rust_for_crosslanguage_system_libraries_libpasta/dun2qm7/) work).
I recomment `ring` it is easier to port between platforms. `openssl` can be an extreme pain when moving between distros unless you statically link it. 
Thank you, subscribed to it to get notifications on its progress!
I've created an issue here https://github.com/PistonDevelopers/imageproc/issues/256 Should be pretty easy to add. (This is obviously no use to you right now, but I can definitely add this in the near future if there's demand.)
Wow so trimming actually fixed it. I'm guessing there were newlines at the end of some inputs. Thanks
I didn't write the article, just posted it. :) 
&gt; As an aside: this is Rust code which is only for use within Python as opposed to a standalone Rust lib which you also want to use in Python, correct? What tends to happen is: 1. If there are any cases of "I'm not sure what algorithm I need, but here are my desired inputs and outputs", I experiment in Python. 2. I start translating the Python to Rust incrementally, or filling out stuff I left as stubs. 3. If time permits, I start to split apart the Rust code into a Rust library and a rust-cpython binding crate so that, if someone else cares enough to write non-Python bindings, they'll be able to. &gt; That being said, I don't think any of the 3 points you mention are inherent advantages, but just a state of the tooling. Agreed... it's just that I can only justify using Rust in a project which has some kind of need for Python with tooling at least mature enough to provide those advantages. (eg. If I need a GUI, then Python it is because there are no sufficiently mature QWidget bindings for Rust itself.)
Nothing specific happened, the developers probably just took a break or moved on: https://github.com/iron/iron/commit/9e5bccb407b1ec8daef51b0d7494627e5c5fc307
Nice, I am looking forward to tower-grpc as a pure Rust alternative to grpc-rs.
I hadn't realized that in the [linked benchmark](https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=plaintext) not only were 3 of the top 10 implementations written in Rust, but the only two other native implementations (C++) had **errors**. And if we take those erroneous implementations out (who wants to sacrifice correctness for speed?), **Rust gets 3 out of the top 5**. I cannot quite explained why the maximum latency is so bad for both actix and tokio (and I cannot even find hyper there), but then again there seems to be a plateau with all frameworks converging to 8s which makes me wonder if the issue is not on the client side...
&gt; Does this look like something which could be simplified with macros to you? Depends on the details, but I think macros could help. I'm doing [something of the sort](https://github.com/vks/average/blob/68a4fa64cb55767aac9516c97a5ddf9923656046/src/macros.rs#L18) when calculating several statistics in a single pass over the data.
So I wrote this and have grown to like it. Thought somebody else might find it useful as well.
True... I just don't really think that's unclear. (It's a magnet for bikeshedding, sure, but a "good enough" option is pretty darn clear.)
I've having some trouble figuring out how to correctly represent lifetimes in a small library I'm tinkering with. Here's a [playground link](https://play.rust-lang.org/?gist=33fd44c9077e68566c86e6dd7361bf26&amp;version=stable) to the code I have. Let's ignore the fact that it's currently named CsvParser - it's basically a class that parses data out of a string (well, a [u8] buffer). It's supposed to be fast. To that end, the CsvParser class is supposed to borrow an immutable reference to the underlying data and operate on that, *without* copying. I'm having trouble with the "read" function. In short, this function needs to take a mutable reference to the parser, because it needs to update the parser's position. It also can return a value that's borrowed from the underlying data in the parser, so that no extra allocations are necessary. This code doesn't compile, though. It won't let me read multiple &amp;strs from the buffer because it thinks it needs to mutably borrow the parser multiple times to do so. How do I write the lifetimes in the "read" function so that the mutable reference to the parser is dropped when the function returns, but the reference to the return value has a lifetime bound by the lifetime of the parser itself?
What a *darn* shame.. *** ^^Darn ^^Counter: ^^460139
bad bot
Thanks! I hope you have success in convincing them! Developing this is 10x more fun than to work with the original framework :D
Yes, this might be a good starting point! Thanks! I wish I had time to dig into this right now, but its on my list now!
Oh nice! This might be more straight forward to implement than I thought!
Actix seems very promising but I want to figure out if it is for a special type of web apps? or it is a general purpose web framework? Because Actix is an Actor model implementation, I thought that it is a solution for some* kind of problems, rather than a general purpose framework. We do heavy SPA apps with REST/GraphQL backends and we can to try Rust on server. Are there any companies who rely on actix is are we the one who first considering it :) Thanks!
Your lifetimes are all wrong! (ok, not all, let's take a look at your code) [Here's working code](https://play.rust-lang.org/?gist=93c06fa921d080f518e1cad7d5ba3dc9&amp;version=stable), but to learn about how and why, let's take a look at the diff: 1. When reading we don't want to borrow the parser for as long as the returned value lives - parsed value only wants to borrow parser's data, which has lifetime `'a` (which is correct here), but it does not care about the lifetime of the parser. The parser only needs to be borrowed for the parsing, so we just remove the unnecessary `'a` constraint on its lifetime. - pub fn read&lt;T: CsvField&lt;'a, T&gt;&gt;(&amp;'a mut self) -&gt; Option&lt;T&gt; { + pub fn read&lt;T: CsvField&lt;'a, T&gt;&gt;(&amp;mut self) -&gt; Option&lt;T&gt; { T::read(self) } 2. Similarly, `CsvField::read` borrows parser's data, but not the parser itself - so the `'a` needs to be on parser's type parameter list (where it refers to `buffer` field's lifetime), instead of the parser's reference (where it forces its borrow to be extended to result's lifetime). pub trait CsvField&lt;'a, T&gt; { - fn read(parser: &amp;'a mut CsvParser) -&gt; Option&lt;T&gt;; + fn read(parser: &amp;mut CsvParser&lt;'a&gt;) -&gt; Option&lt;T&gt;; } 3. Same thing here, just updating it to match function signature in trait. impl&lt;'a&gt; CsvField&lt;'a, &amp;'a str&gt; for &amp;'a str { - fn read(parser: &amp;'a mut CsvParser) -&gt; Option&lt;&amp;'a str&gt; { + fn read(parser: &amp;mut CsvParser&lt;'a&gt;) -&gt; Option&lt;&amp;'a str&gt; { let orig_pos = parser.pos; Also, a sidenote: `CsvField`'s type parameter `T` seems unnecessary to me. Looks a bit like an instance of [curiously recurring template patter](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern). Because in trait definitions you can use `Self` to refer to the implementing type, you could simplify the trait by removing `T` and inside changing it to `Self`, then it would look like this: pub trait CsvField&lt;'a&gt;: Sized { fn read(parser: &amp;mut CsvParser&lt;'a&gt;) -&gt; Option&lt;Self&gt;; } impl&lt;'a&gt; CsvField&lt;'a&gt; for &amp;'a str { fn read(parser: &amp;mut CsvParser&lt;'a&gt;) -&gt; Option&lt;&amp;'a str&gt; { ... } } (you need the `Sized` constraint on either the trait itself, or add `where Self: Sized` on `read` function - otherwise the compiler complains about unsizedness of `Self` in `Option&lt;Self&gt;`).
Thanks for the help! I actually tried a few different permutations that introduced a lifetime `'b` that effectively was the same as the anonymous lifetime in `CsvParser`'s `read` - just using the anonymous lifetime is obviously much cleaner. The part I was missing was that I needed to parameterize `CsvParser` with the lifetime in the trait's `read` function.
Ah, good to know. Thanks.
This would be great :)
Assuming that high latency is caused from within the process, it's going to be due to some logic that doesn't have very deterministic latency (at the risk of sounding obvious). I haven't dug into it, but in the case of Tokio the most likely causes off the top of my head would be scheduling logic first and allocations second. If someone wanted to dig in, I doubt it would be hard to fix (once identified), but I personally don't put much weight to these micro benchmarks and favor real world usage more. Tokio is doing well in the real world :)
Weirdly, only Actix does well in the Single and Multiple Requests benchmarks. The others [do worse than Ruby on Rails](https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=query&amp;l=h7aqkf). I wonder why that is.
There’s a broken link in there for Tokyo-service. This is a great post. I didn’t realize hyper had so many releases so recently!
It is usable today... just isn't on crates.io yet :)
Good deal, I will give it a try. I was about to adopt the Twirp approach (also using Prost like you did) to not have the complexities that come w/ http/2.
That's exactly how it works now. All rough edges will be polished. Changes will happen for all not intuitive parts. It's first version so a few changes are inevitable :) Thanks for feedback
That might be related to r2d2 configuration. As I understand by default r2d2 uses max_size set to 10. That could explain weak performance. I will update code for round 16
Expanded the command-line section on [awesome-rust](https://github.com/rust-unofficial/awesome-rust#command-line) the other day, and while doing so, created a TUI sub-list. Reasoned that it was better to group under a common (albeit inaccurate) name instead of placing TUI miles away near the end of the alphabetical list. Perhaps console or terminal application is a better umbrella term to be used there.
It is a pretty common pattern to describe any kind of state machine in Rust: https://hoverbear.org/2016/10/12/rust-state-machine-pattern/
It's basically the same. Rust is missing a crucial part of session types: forcing you to consume and not drop them, as not all states might be valid to drop.
Oh. For some reason I thought I remembered you talking about an async db driver for Actix. I must be thinking about something else.
I've specifically never added benchmarks for DB queries, since I didn't want them to make hyper look bad :)
I'll agree that it should be a new crate
Thanks, nice to read i share attitude with someone :)
The ones listed by others in this thread are great. Check out [awesome-rust](https://github.com/rust-unofficial/awesome-rust/) as well :)
HTTP/2 is not simple... but hopefully that piece is out of the way now!
&gt; What I don't understand is how the hell the compiler can know that? Because you told it. fn borrow(value : &amp;mut N) -&gt; Dummy This should be invalid. Firstly, borrowed pointers *need* a lifetime. Secondly, `Dummy` has a generic argument that you haven't provided. The reason it compiles is that Rust has lifetime elision, allowing you to leave out lifetimes in some simple cases. The above is actually equivalent to: fn borrow&lt;'a&gt;(value : &amp;'a mut N) -&gt; Dummy&lt;'a&gt; The two are connected because that's what you wrote. &gt; I don't get the error anymore. Why? From the point of view of the function test nothing has changed [...] You fundamentally changed how `Dummy` is defined: you removed the lifetime. Why do you think nothing has changed? &gt; [...] it can't know that I don't put the reference in the returned structure anymore. It saw the lifetime parameter on `Dummy`. Lifetime parameters *must* be used, so it knew you were borrowing *something*. It doesn't *have* to know specifically what you're borrowing or how you're borrowing it, it just knows there's a borrow, and it knows (from the elided lifetimes) where it must have come from. &gt; I thought a "lifetime" was related to the variable lifetime, not the variable itself (don't know if I'm clear). I assume one of those "variable"s was supposed to be "value". Lifetimes come from one of two places: `'static` (which is basically just "the rest of the program's runtime"), and storage on the stack. So, in your first example, the specific type of `_d` is `Dummy&lt;'x&gt;`, where `'x` is at most as long as the lifetime of the local variable `n`. Also, at the point something with a lifetime is stored in a struct or enum, that struct or enum also becomes constrained by that same lifetime. So, whilst lifetimes originally come from `'static` or the stack, they can be "remembered" in types.
I'm reimplementing an old programming language in Rust: http://github.com/rpjohnst/dejavu
Well, there's a lot of options here. For example: 1. Is this something we want to support? If so, should we support it more directly? 2. Is that HTML representable by markdown, or does it need inline HTML? If the latter, may want to re-think it. stuff like that. yeah, there can be an answer, but there's a lot of stuff around things like this.
Iron has a warm place in my heart but ultimately it was a prototypical project that began 4 years ago, a whole year before Rust hit 1.0, when [best practices](https://github.com/iron/iron/pull/576#issuecomment-364627847) hadn't yet been established. Rocket and Gotham seem to cover all of the use cases Iron tried to solve, and more.
In what way did Rust previously have typestates that it doesn't now?
Really looking forward to all of these improvements coming up soon in the Futures + Tokio ecosystem. Exciting stuff.
Like I said, the compiler *doesn't know what you borrowed*. Both `a` and `b` have the same lifetime, so the compiler can't distinguish between them when it comes to what `Dummy` contains. You say `Dummy` contains something borrowed with lifetime `'a`, and `a` and `b` both have lifetime `'a`... so it takes you at your word and assumes it must be derived from both of them.
I'll add this at some point over the next two weeks. Hopefully towards the lower end of that estimate, but I've not had as much energy for out-of-hours programming as I'd like recently.
&gt; I thought a "lifetime" was related to the value lifetime, not the value itself Values don't have lifetimes. They originate from `'static` and stack variables, and can be carried around by types. Values having lifetimes would imply that lifetimes exist at runtime, and they absolutely do not. They are purely compile-time.
Yeah I understand what you say, I think I'm just not using the same vocabulary. I'm thinking static analysis. You can symbolically give, statically, a lifetime to every value.
That's what's confusing me... I find it weird to rely on the lifetime parameters to try to deduce who is borrowed where... But ok, now I know that it is actually how Rust does it. I just have to deal with it. Thanks for your help :) 
&gt; NovaLang I got mentioned! :D The current incarnation is the result of me getting very frustrated and just wanting to get something that can be persuaded to work. It's very likely that if work were to continue, that it would be a massive rewrite, possibly in another language like Haskell. (Haskell is the language that the syntax is mostly derived from.) I should also mention that that project singlehandedly made me not hate dynamic languages with a burning passion. Type checking is ***hard!***
The signature `fn borrow&lt;'a&gt;(a: &amp;'a mut N, b: &amp;'a mut N) -&gt; Dummy&lt;'a&gt;`, and the resulting requirement that uses of the return value are constrained by both the arguments, is more useful when that actually is the case. For example, the body of `borrow` might be something like `if random_bool() { Dummy { value: a } } else { Dummy { value: b } }`. You can explicitly tell the compiler that the body will only ever derive the return value from one specific argument by changing the signature: `fn borrow&lt;'a, 'b&gt;(a: &amp;'a mut N, b: &amp;'b mut N) -&gt; Dummy&lt;'a&gt;`. Beyond enabling the borrow checker to look at only the signatures of callees, it can also be helpful in the context of backwards compatibility. If you use the first signature, you could change the implementation to borrow from either argument without breaking callers. If you use the second, doing so is a breaking change to the interface. This "weird" property is also very useful for unsafe code. For example, the standard library's slice iterator is implemented using raw pointers, which don't have lifetimes. However, it needs to appear from the outside as though it references the slice it's iterating over. So using lifetimes to tie them together makes it possible for that unsafe implementation to present a safe interface.
sadly state of crypto libs in rust is not great. I think `openssl` should be the choice if you can control your target environment. Like others mentioned it can be a pain moving between distros and os.
As a pre-alpha feature: https://github.com/rust-lang/rust/issues/2178 Marijn gave a good talk about the features long gone at RustFest: https://www.youtube.com/watch?v=olbTX95hdbg&amp;list=PL85XCvVPmGQic7kjHUfjHb6vz1H5UTEVG
&gt; but subsequent combinators didn't support them as input Why does putting the rest of the computation inside an `and_then` not suffice? Isn't that what `and_then` is for?
&gt; but subsequent combinators didn't support them as input Why not use `iter_of_results.collect::&lt;Vec&lt;Result&lt;_&gt;&gt;().into_iter()`?
I wonder how it will compare to [Mycroft](https://www.kickstarter.com/projects/aiforeveryone/mycroft-mark-ii-the-open-voice-assistant/) which is also a hardware project, but as far as I can tell they'll also code their own voice assistant similar to this one. First difference I can see: Mycroft starts out with cloud voice recognition, while this is supposed to run offline on a Raspi3.
You can probably do it recursively with with macro_rules! But it'd be a chore. Check out the counting examples in the little book of rust macros. 
Love this. Great tip. 
So, taking them one at a time: * Do you think possible to show Rust Pre-Macro -&gt; Rust Post-Macro? This, I imagine, would need implemented in cargo/rustc (or is it already?) * Rust Post-Macro -&gt; MIR? Already exists, no? * MIR -&gt; Optimized MIR? Doesn't exist yet, right? But it could, no? * Optimized MIR -&gt; LLVM? Doesn't exist yet, but, it could, no? * LLVM -&gt; Optimized LLVM? This one is the one I imagine would be the most difficult, but, maybe I'm thinking of the problem incorrectly. * Optimized LLVM -&gt; Assembler? You basically did this, as well as mapping from original Macro-expanded Rust to LLVM to Assembler. You just didn't show the LLVM? Or am I misunderstanding your technique? 
My understanding is that `ring` is much nicer to work with and has no-effort cross platform support, but `openssl` is verified to be secure. If you need absolute security, use `openssl` and deal with the hassle of distributing or depending on `openssl`. If this project is open source, definitely take advantage of appveyor and travis to ensure it works well on all platforms ([a template for that](https://github.com/japaric/trust/)). If you don't need verified security, use `ring` and have a much nicer time.
I'm a very happy Failure user and seeing this coming along is great. The main issue I still have with failure at this point is that using the error kind pattern is too manual. Hoping some time after 1.0 users will figure out if the pattern is good or not. If it's good, I think it could use some macro/derive help.
So linear types?
Niko was having trouble with an error type that ended up being very similar to the error + errorkind pattern, got some good feedback there. The best thing might be to have a macro for it out-of-tree in a separate crate at first so it can iterate (`quick-failure? ;-P).
Well, most other non-garbage collected languages.
Yeah. Wouldn't want it in failure yet. I noticed that I effectively need `Error` or `Context` to get any reasonable stacktraces so the moment some code gets more complex I end up using the error kind pattern.
Godbolt.org can show some of this in side by side mode, but I'm not sure if it can do every stage of the breakdown like you want. I haven't played with it too much.
It seems like a sufficiently smart compiler could elide the allocation in the specific case of collect().into_iter().
In my experience, a "sufficiently smart compiler" is also complete vapourware. It *could* happen, but it probably won't.
grpc-rust is an existing pure Rust alternative btw.
A colleague of mine was recently ranting about another example of what the author is talking about: the recently introduced std::optional type (analogous to Rust's Option type). Dereferencing an optional that is None is undefined behaviour. You **can** check whether an optional is None or not, but the simplest thing to do with an optional - dereference it - leads to UB. It's clear that the C++ committee folks do care about safety, but they still prioritize speed and conciseness. Not saying that's wrong, but it's the reason Rust is now my preferred language for big, complex programs.
I had a quick look at that, and I don't see anything for inserting into the middle of the list, which is one of their main uses. It seems more like a deque.
Isn't the lack of GC a problem for latency with the constant allocations? I mean, if everything is in the stack it doesn't matter but a lot of things are heap based, like Vec and Hashmap so we lose that.
I used to be passionate about the *exact* way that code was formatted, down to the last micron of whitespace. Then I realized that it only really matters that the code is formatted *consistently* and *reasonably*. Having code indented with 24 spaces at each level of indentation would be an example of an *unreasonable* formatting standard. After that, it's all about consistency, which `rustfmt` allows you to do effortlessly. Focus on writing code, not formatting it. If you're so unwilling to consider using a reasonable formatting standard that isn't your own, then you're very likely to encounter problems in the workplace, where opinions *will* differ. Definitely do whatever you want. No one's going to stop you on your own projects. How could they?
Does this mean `throw!` is equivalent to `bail!` of error chain? I don't see a point of `bail!` without early return, what are some use cases?
It is not as good as solving at compile time, but if you really want to force consumption you can apply dire consequences at runtime. One approach is panicking in your Drop implementation if some marker bool has not been flipped to signify consumption.
I recently moved a project from error-chain over to failure, and here are my thoughts and questions, as a non-expert. 1. Overall, I love it. It was super simple to get started. I love being able to use Error as my error type in most places. 2. I started to worry about my code that used `.context(format!(...))?;` Previously with error-chain, it used a closure, which meant that the format code was never executed unless an error occurred. Should I worry about this, or just assume that LLVM will do a good job at make sure it's not executed unless an error occurs? 3. I started to wonder what the best practice is for my main function, which I wanted to print as much information as possible about an error. I wished that failure had an example for that, but it was fairly easy to loop through causes and print out backtraces, but it ended up being a lot of information. 4. When I already had an error and wanted to return early, but with context, I had trouble finding the best way to do that. I ended up with: `return Err(e.context(...).into());` which looks pretty ugly. 5. I'll be happy when error-chain merges in PR #241 to make their errors Sync.
Sorry, `bail!` does early return, but only of string interpolations. `throw!` takes an error type that isn't a string.
You should probably use `with_context` instead of context. You can `throw!(e.context())` in 1.0.
split_off -&gt; push_back -&gt; append
I really love working with [structopt](https://crates.io/crates/structopt), which internally uses clap. For password inputs I use [rpassword](https://crates.io/crates/rpassword). Here's a nice function for making a prompt which optionally hides the user input: [https://gist.github.com/bschwind/699ab3e2a5bfad7b9f9f03a44d5c2c81](https://gist.github.com/bschwind/699ab3e2a5bfad7b9f9f03a44d5c2c81)
This is one of my favorite features of rust 
You can always make a custom allocator to fix it.
Yeah, it would be great to have a native udev lib for Rust, but right now reliant on that. It would be easy to put the udev need behind a feature flag as that only affects port enumeration, so if you don't need that, it could simply be disabled. If you're interested, feel free to [raise a feature request](https://gitlab.com/susurrus/serialport-rs/issues).
Worth noting that rulox and tox are both implementations of lox from /u/munificent's [crafting interpreters](http://craftinginterpreters.com/), which is a really great resource if anyone is interested.
Which web framework for production is recommended these days?
There's nothing smart about having style beliefs that you're 'deeply' attached to. What happens when anyone has to read your code or you have to read anyone else's code?
Well, [sort of](https://github.com/jonysy/parenchyma).. The API is still in flux but it’s coming along nicely.
The heuristic is called "lifetime parameter elision" and is very simple. There are no relationships between the argument lifetimes unless you specify them. The return lifetimes, if any, are all equal to: - the lifetime of borrowed `self` in a method - the only argument lifetime In any other situation the compiler will throw an error and make you specify the relationships. This rule accounts for something like 95% of the functions that need a lifetime parameter for their return type.
Sorry! My bad. I read it too quick. I got the idea now. Thank you for all the your work.
&gt; It is considered best practice for all of the attributes used by a derive to be nested under a sort of “namespace” attribute. For this reason, #[cause] will be replaced by #[fail(cause)] Are there any plans to add support for more rusty namespace syntax for attributes (i.e. `#[fail::cause]`)? When I see `#[fail(cause)]` I see a function call.
so it's just a wrapper for a pointer than has the same (undefined) behavior? why.
I have no problem with most of the style guide... but there are a few things I'm not willing to budge on... mainly relating to my impression of how whitespace affects readability when not relying on an IDE's "jump to" for 99% of movement around the codebase. Here's what I set in `rustfmt.toml` in my projects back when I first installed rustfmt via cargo: report_todo = "Always" report_fixme = "Always" use_try_shorthand = true ideal_width = 100 fn_call_width = 100 fn_brace_style = "PreferSameLine" where_density = "Compressed" single_line_if_else_max_width = 100 normalize_comments = false I used to run the cargo-provided legacy version of rustfmt because the stable-channel preview release of rustfmt refuses some of those settings as "unstable". I ran it only infrequently because, even *with* the legacy version, there were a couple of of places where, every time I ran rustfmt, I had to revert attempts to remove whitespace or insert newlines before I commit. Examples include... - assert!(inpath == "/", - "\"cd -i/\" should have produced \"/\" but actually produced \"{}\"", inpath) + assert!( + inpath == "/", + "\"cd -i/\" should have produced \"/\" but actually produced \"{}\"", + inpath + ) - assert!(path_readable(OsStr::new("/")).is_ok()); // OK Folder - assert!(path_readable(OsStr::new("/etc/passwd")).is_ok()); // OK File - assert!(path_readable(OsStr::new("/etc/shadow")).is_err()); // Denied File - assert!(path_readable(OsStr::new("/etc/ssl/private")).is_err()); // Denied Folder + assert!(path_readable(OsStr::new("/")).is_ok()); // OK Folder + assert!(path_readable(OsStr::new("/etc/passwd")).is_ok()); // OK File + assert!(path_readable(OsStr::new("/etc/shadow")).is_err()); // Denied File + assert!(path_readable(OsStr::new("/etc/ssl/private")).is_err()); // Denied Folder Since trying out the rustup-provided version, the accidental update I got out of switching to and then back away from the rustup version has left me with a rustup that throws even more unwanted changes at me and I just don't have time to pour through the rustfmt configs looking for options to change them back, so I just gave up on using it. Examples of those include: -fn make_clap_parser&lt;'a, 'b&gt;(defaults: &amp;'a AppConfig&lt;'b&gt;) -&gt; App&lt;'a, 'a&gt; where 'a: 'b { +fn make_clap_parser&lt;'a, 'b&gt;(defaults: &amp;'a AppConfig&lt;'b&gt;) -&gt; App&lt;'a, 'a&gt; +where + 'a: 'b, { - name = provider.volume_label().unwrap_or_default().trim().to_string(); + name = provider + .volume_label() + .unwrap_or_default() + .trim() + .to_string(); (The most representative over-simplification of my rules regarding whitespace is probably "I don't have a portrait-oriented monitor. If it takes up less than 20% of a line, look for an acceptable way to compact it.")
I personally like to use [rouille](https://github.com/tomaka/rouille)
Well it's more than just a wrapper for a pointer, right? I think of it more of as a struct that has the T value and a bool for present or not. Using just a pointer, you'd probably have to worry about dynamically allocate memory in some instances. One area where optional is useful is for config loading and parsing. You may want to do something like std::string setting = readSettingFromFile(); std::optional&lt;int&gt; optVal = ParseSetting(setting); int valToUse = optVal.value_or(1); It's also to use std::optional as optional parameters.
Picking `io::Error` over `IOError` has always struck me as the most bizarre of all the rust guidelines.
Try `cargo update`, or maybe downgrade to ring 0.11 until your dependencies update? Haven't seen this error before but it looks like ring depends on a crate of asm routines and it refuses to have two versions of that crate present. Interesting edge case.
It is entertaining that two years ago it was "what's a borrow checker" and now devoted c++ people are thinking about that kind of compile time safety.
I saw it a few months back too
Which nightly feature combines the trait object pointer and vtable pointer?
An interesting summary of the less-common architectures and how LLVM/rustc supports them. Also, damn, I guess I need to work on the portability of mrustc if debian are thinking of using it to compile rust application.
just import {add} from '.add.wasm' then
I doubt it, it's hard enough standardizing the we around a single api for just javascript, I couldn't imagine the amount of effort to also have an api just for webassembly. I think an important context to remember is web assembly exists currently because javascript is just so damn bad at math operations. It was imagine for crypto, 3d operations, protocol parsing. Not becoming a whole platform as itself. stdweb is giving us the illusion that it could be so easily used as one, but there's an inherent cost to crossing the web assembly barrier that will never go away. That said however ... it may be performant enough for most problems.
Sorry for asking weird things, but why is tokio called tokio?
Sure, you can also add `#[must_use]` to all state types.
This is because `stripe-rust` uses an outdated version of `hyper`, hyper 0.10. This will continue to be a problem until they update that dependency, or you downgrade your `ring` dependency to match their outdated one.
It might just be easier looking up the cookie javascript/header spec and just doing normal headers. It's not that complicated to need a whole abstraction.
&gt; This is because stripe-rust uses an outdated version of hyper, hyper 0.10. &gt; &gt; how's that related to ring?
Yes, how to handle the error kind pattern was a little puzzle. It seems that one has to downcast to get the desired type and match on that?
I found that in lower-level code, I use failure only to implement display, and fall-back to full-blown failure::Error in higher-level code, where it would be too crazy to combine all kinds of errors into a single error. It is also way easier to match against enum than to try and downcast to correct error type in the chain or errors. [I wrote a tutorial recently](http://nercury.github.io/rust/opengl/tutorial/2018/02/15/opengl-in-rust-from-scratch-08-failure.html) on my failure use case, and I am interested if I am teaching the failure right. If anyone have any feedback, please share it :)
Because that old version of hyper uses an old version of *ring*. Basically that error is saying that, with the way older (prior to 0.13) versions of *ring* are, you can only have at most one version of *ring* in a program.
You probably have to make up a custom trait with a method to get the conversion you want, then bound the generic with that trait instead of using Into
[prolog](https://github.com/dagit/rust-prolog)
Oh, I never really used `error-chain` all that much, which might be why I was!
Yeah, I think it's worth noting that sometimes `Error` structs can get reasonable large, and therefore slow down the happy path, so allocating them in a `Box&lt;MyError&gt;` can actually be faster because it reduces the size of the `Result`. Worth profiling though.
&gt; It's clear that the C++ committee folks do care about safety, but they still prioritize speed and conciseness. That's not the reason for the behavior of `std::optional`. To get the behavior of Rust's `Option` you also need some of Rust's language features: enum and pattern matching.
I think you're looking for /r/playrust.
It's not a pointer, though. There is no indirection. `optional&lt;T&gt;` really wraps that `T` inside its guts like Rust's `Option&lt;T&gt;`. The dereference operator just provides access to it. In an ideal world the language would make you check it in order to be able to access it. But how would you do that in C++? C++ doesn't have a Rust-like `match` (yet).
I believe we have already accepted a RFC for namespaces attributes (for dev tools, though).
Could you try compiling on nightly? 
I also would prefer if `throw!` was used for everything.
Yeah I think, it's he is probably trying to use procedural macros. 
&gt; but openssl is verified to be secure. What do you mean by "verified to be secure"? Are you referring to the FIPS validation of the OpenSSL FIPS Object Module (not OpenSSL), some kind of formal verification, or something else?
This is one reason i wish we had a richer kind system — a type-level enum would be much cleaner. Nonetheless, this is a useful technique! 
Also neat icon
I tried failure 0.1.1 and I had a great experience! But 1.0 in March seems like a rush to me. I think we should wait a little more before going 1.0.
No real reason
You don't need match, do you? An if should suffice, combined with an unwrap(), like Rust does it?
where is arm64/aarch64?
&gt; the one you should have performed yourself and the one in optional's defererence operator for debugging purposes. At least in release mode, this isn't acceptable. Actually, in release mode the second check will be optimized-out. You can even statically ensure that by calling non-existing function in bad-deref branch.
Can we have `complete-failure`, the batteries included error handling library, please? `abject-failure` works too... :)
The only real reason I can think of is that it's built on mio and tokio has a nice ring to it? I'm sure the creators could chip in here.
I think its the other way round.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/rust-lang/rfcs/pull/2103) - Previous text "RFC" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
"you salty hacker cry" It is okay to cry if you fight the borrow checker. We all have been there and had our frustrating experiences with it. If you never used macros before, you should consider using a different crate. Macros aren't really that hard ;)
Reason 1637 why the rust community is awesome: After commenting on mobile with no link, some friendly rustacean will come along with ALL the links before I make it to the office.
That's exactly it, I'm concerned with your productivity. Now get back to work and make my CLIs better! =)
Generally speaking, `T` always implements into `T`: T -&gt; T However, into takes `T` by value (consumes it). What you want in your code is this behaviour: &amp;T -&gt; T So, you want to convert a reference to something into an actual value of that thing. So we have to add this impl: impl&lt;'a&gt; From&lt;&amp;'a Yell&gt; for Yell { fn from(yell: &amp;'a Yell) -&gt; Self { yell.clone() } } Also, we need to add `T: ?Sized` to the listen function, for the code to compile. That being sad, the solution isn't really optimal, since we always clone a `Yell` when we don't have to.
As far as I know: "tok(en)IO" (it is internally based on Mio Tokens and does IO)
I would say tokenization and stemming are more important to be honest, and being able to configure/adjust that for the specific use case. Which looks like it's also dropped in this version.
It works, the package is in the Debian archive, so it was not included in the email.
Feel free to submit those as a PR and we can discuss there! I'm away from my computer over the weekend, but no need to hurry, I guess! :-)
I don't think that is possible due to semantics. The moment you `collect()` you state that the iterator should be executed. If a compiler is "smart" and removes the `collect().into_iter()`, it changes semantics, and that's not a good thing!
To get your example to compile, I made two changes. 1. Implement `From&lt;&amp;Yell&gt; for Yell`. Otherwise `&amp;yell` will not implement `Into&lt;Yell&gt;`. impl&lt;'a&gt; From&lt;&amp;'a Yell&gt; for Yell { fn from(yell: &amp;'a Yell) -&gt; Self { Self { shout: yell.shout.clone(), } } } 2. Make the parameter of `listen` have type `T`, not `&amp;T`. `T` can be `&amp;Yell`, `Yell` or `&amp;str`; you don't need to use `&amp;T` to support references. If you use `&amp;T` as the parameter type, your constraint would need to be `where T: ?Sized, for&lt;'a&gt; &amp;'a T: Into&lt;Yell&gt;`. fn listen&lt;T&gt;(sound: T) where T: Into&lt;Yell&gt;, { let yell: Yell = sound.into(); println!("*{}*", yell.shout); } 
Absolute beginner here. I wrote [this[(https://play.rust-lang.org/?gist=3d1b87c205106e8b2a92295da81ad110&amp;version=stable) code which works fine (doesn't work on the playground since it is not able to take input from stdin (or is it?)). There is just one thing I don't understand and one thing I would like to optimize. * What I don't understand: when do I have to close a *match* with a semicolon and when not? the function *input_n* has a match that has a semicolon after it's closing }, inside the match is another match, that one doesn't have a semicolon after it's closing }. The function *read_input* hat a match which does not have a semicolon after the closing }. Why? * I don't like the match inside the match. I haven't looked into map() and and_then() yet - can I use one of these and still be able to print a message in the error case? 
Congratulations on this milestone. Happy to see that someone else has a use for the rust-stemmers crate :) 
&gt; Do you think possible to show Rust Pre-Macro -&gt; Rust Post-Macro? You can already do this with `cargo expand`, what you can't do is map assembly code to Rust post macro expansion because the information in the assembly code points only to the Rust code pre-macro expansion. One would need to expand the code (using something like cargo expand), build the expanded code (so that rustc adds source location information for that code to the assembly), and then run cargo asm on that. &gt; Rust Post-Macro -&gt; MIR? Already exists, no? You can dump the MIR, but even for trivial code the amount of MIR generated is at least 100x larger than assembly because MIR is generated before any optimizations are applied. When visualizing MIR you typically want to use a hierarchical visualization that allows you to collapse parts of the MIR that you don't care about. To explore the MIR something like https://github.com/oli-obk/priroda is better. &gt; MIR -&gt; Optimized MIR? Doesn't exist yet, right? But it could, no? There is no such thing as optimized MIR (yet), but even then, it will still probably be orders of magnitude larger than assembly. Generating it for a real code base is expensive, and visualizing it as plain text is not insightful. --- &gt; In my mind Have you ever looked at the mir, assembly, or llvm ir of rust source code? Because rustc already can dump it. It looks to me that you haven't because you have the completely wrong mental model about how this looks like. If a simple rust 1 liner function generates 20 assembly instructions but 2000 lines of MIR, it doesn't really make any sense to view rust source code, and MIR, side-by-side, because you will just have 99% MIR in your screen and you won't be able to make any sense of it. 
Godbolt only shows one of this per window, although one can open multiple windows displaying the different things and put them side by side. But generating the asesmbly, llvm-ir, and mir, requires compiling the project once.
Thanks for that crate !
The answer is hinted at in the docs, I believe: &gt; Unlike `*mut T`, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- `Option&lt;NonNull&lt;T&gt;&gt;` has the same size as `NonNull&lt;T&gt;`. However the pointer may still dangle if it isn't dereferenced. I believe it's primarily to allow for optimisations, rather than any direct utility it offers to the user.
For most code `Box` or some other pointer/container type is the way to go. It gives you the static guarantee, that the pointer is not null (allows optimization with Option), prevents dangling, allocates and deallocates the memory and a provides a more useful interface. NonNull is for unsafe code. It is pretty much `*mut T` with the additional optimization.
The biggest problem is that rustdoc isn't even "partial path aware" last I checked. It doesn't know that you're supposed to put part of a type's path when you talk about it (but only for some types!). So if you're reading rustdoc you see "Result" and "Error" all the time and you always have to click to see what error it meant. This is _maybe_ okay for single crates (but probably not even then) but as soon as you do any complex mixing of crates (like in a large project, where you'd maybe rely on rustdoc a bit) the whole thing falls on its face. The other problem is that I come from Java and Haskell. And, of course, the fact that it's a magical rule that applies to some types and not all types consistently (eg: we don't have `sets::Hash`, we call it a `HashSet` and get on with life).
Thank you I was not aware that a panic inside a C function could cause undefined behavior. If I understand correctly the new Rust release solved this for me and now the panic will simply abort.
The classic 2012 pcwalton post on the subject is http://pcwalton.github.io/2012/12/26/typestate-is-dead.html
Great! But (as someone who admittedly hasn't used `failure` yet), 1. Isn't making breaking changes in a 1.0 release the wrong way to do things? 2. Has there been any progress on making `Error` available with `no_std`? As you [can see](https://github.com/rust-lang-nursery/rand/blob/master/src/error.rs#L64), there are some limited ways of creating a `Sized` type that works without `std`; this was the primary reason we decided not to use `failure` in `rand`.
RISC-V ?
Hacking is mutation: fine if you do it on your own, a terrible idea if it's shared.
Isn't a series of statements an expression?
As a library author who has to deal with I/O I wonder what's the recommended way to express errors? Should I use - `std::io::Error` with custom messages, - my own `enum` that manually implements `std::error::Error`, - `error-chain` or - `failure`?
Last I heard is https://github.com/dvc94ch/riscv-rust-toolchain.
Any reason you're not using --release flag?
With all the cross-over posts, shouldn't we have a cultural exchange with the /r/playrust people someday?
«Type level enum» as you call it, is the thing I miss the most when using Rust. 
I really love all these projects that are being created using Rust. I fu** love the language. Realy nice job! 👏
Disclaimer: I have written a super-tiny amount of unsafe Rust, and I am definitely not Gankro, so everything bellow might be horribly wrong :-) This is the type to use with unsafe pure-Rust (non-ffi) code. The `NonNull` name actually does not highlight the main distinguishing feature of this type, which is that it is a **covariant version of `*mut`**. Basically, `NonNull` is intended to be a default unsafe pointer, as opposed to `*const` and `*mut`. `*const` and `*mut` are more or less equivalent (you can cast one into the other just fine), but you can't get a `&amp;mut` out of `*const` directly (you have to go via intermediate `*mut`), and storing a `*mut` in a struct makes it invariant. So the common pattern in usafe code is to use `*const` for fields, `PhantomData` to get correct variance/dropcheck and cast `*const` to `*mut` internally. `NonNull` removes the need for casting. You still may need phantom data though. See also this discussion on irlo: https://internals.rust-lang.org/t/what-is-the-real-difference-between-const-t-and-mut-t-raw-pointers/6127
x32 progress looks very interesting
The order of arguments isn't relevant. The gist of how it works is that you pass the closure itself (or rather a pointer to the closure) as the user pointer. Just pass the user pointer in the appropriate argument and it should work fine. 
Could you please explain what is blocking the ability to use `?` on `Option` in functions that return `failure::Error`? I found this to be a big papercut/inconvenience. It would be so nice if i could just early-return a `NoneError` as `Error` using `?`.
The short answer is: If you work with a team, which is least bad: the insane random indentation and weird formatting preferences of your colleagues, or a reasonably sane standard format?
Things I do which have been considered "unstylish" at some point (not sure if they still are): * no line length restriction * indent with tabs * non-single-letter lifetime variables * sometimes adjective-style trait names if relevant (e.g. `Sendable` instead of `Send`) 
Thank you! I have a bunch of question about your use of solr : do you shard your index? (How many shards) do you suffer from GC? Why solr and not elastic search?
**A few days ago...** "We should rewrite $OLDPROJECT in Rust. Lots of nice benefits from doing so." "How mature is the language?" "Mature enough; at this point, I'm not expecting random stuff to suddenly stop working." **Today** (sound of head hitting desk) &amp;nbsp; ^^^^(Not&amp;nbsp;exactly,&amp;nbsp;but&amp;nbsp;close&amp;nbsp;enough.)
&gt; In an ideal world the language would make you check it in order to be able to access it. But how would you do that in C++? A guard object?
This release completes the API, which in 1.0 was on the level of a minimal viable product only. After a detour to documentation tooling (see 'termbook'), we could now finish the accompanying markdown book to aid in getting started. Last but not least, installation should now be fast and easy thanks to homebrew. Maybe give it a spin :)!
That's because a Hash is not a HashSet. An IO Error is an Error.
Hi. I have [a small program](https://github.com/anmej/piston-falling-sand-prototype) that currently runs on debug, but fails with release mode. Anyone wants to try and see what's
Non-single-letter lifetimes can be useful if you want to show what lifetime you're binding things too. Adjective-style trait names should never be part of your public interface though. ;)
To be quite fair, _any_ application that accesses github through WinHTTP is broken. It might affect other package managers or - as it looks like - [Kerbal Space Program](https://twitter.com/sgrif/status/967014325205458945)
Oh, absolutely; it's just a case of humorously ironic timing.
Does that mean after `v0.13` we will be able to have multiple versions of ring in our programs?
I'll put them in the public interface if I think they belong there.
agreed, I just wanted to keep my reply simple :)
It is quite a sad statement for the security of crates.io that it was not just using but also relying on these weak cryptographic standards in the first place. As there is no signature of the index commits, nor any other additional mechanism to obtain integrity, the entire integrity of crates.io relies on the transport encryption. So generally I'm glad that GitHub support for these old TLS versions, but of course the disruption for the users is not really nice.
For those on mobile: "share-secrets-safely (sheesy) is a solution for managing shared secrets in teams and build pipelines." https://github.com/Byron/share-secrets-safely
Well, you never really have to close a match with a semicolon. You close statements with semicolons, so when doing let x = match y { ... } You have to close it. The match in `input-n` works fine when removing the semicolon. As for getting rid of the matches, you'll have to keep at least one of them, but I think you can print from within a map(), so there's that.
In fact, `https` is looks like the main problem maker for rust installtion. Some time ago I try to install rust on ancient Linux (CentOS 5.x). It took a half of day to download and built right openssl version, download certificate pack on so on things. "https everywhere" helps a lot in downloading from system where "https" doesn't work. But after this rustup in several minutes install rustc an cargo and I get working "hello world".
Hey, at least Cargo isn't randomly changing permissions of system directories ;)
Probably no help to you, but I was able to run it ok in debug and release mode (i686-pc-windows-gnu)
&gt;compiled to native code and does not have a garbage collector or other internal runtime to the language. Ah! Ok, that makes sense.
Just gotta always be logged in as root, no problem ;)
Why isn't this idiom permitted: fn f(&amp;mut self) { self.count = self.count + BigInt::one(); } `self.count` is a BigInt borrowed from `&amp;mut self`. I'm moving out of `self.count` on the RHS of the assignment, but then immediately moving back into it. The borrow checker barks at me for trying to move out of borrowed content. I've been using this anti-pattern instead: fn f(&amp;mut self) { let mut dummy = BigInt::zero(); swap(&amp;mut dummy, self.count); self.count = dummy + BigInt::one(); } This is ugly and doesn't express my intent, but it at least avoids the extraneous clone I'd probably do if I were to write `self.count = &amp;self.count + BigInt::one()`. Is there a good workaround?
Would you prefer an insecure installation on all of these systems? If we would not use HTTPS/Github, we would have to run our own secure infrastructure. This sounds great, but means: * We'll probably have multiple breakages, making this one a small one * We'd have to disable old protocols on our own * We have far less social buy-in. Here, we can say "Github does that, it's been announced and now fulfilled", if we do that, everyone would be chasing us for that. I trust GHs security team and it's hard to ad-hoc come up with a better process just for this project.
I'm not the original commenter, but my employer also uses Solr. To answer some of your questions: 1. We do use shards. We have two shards with replication factor two (four total nodes). 2. We have historically suffered from GC and vaguely understood how to resolve outside of throwing a bigger box at it. 3. Not sure why we picked Solr over ElasticSearch. It was a decision made several years ago.
&gt; allocations second. How much does tokio allocate?
Out of curiosity, how did you find out about Inko?
Works, but much overhead. Multiple list creation, and an additional O(n) to seek the insertion point even if you already know it.
Does `+=` not work?
Not for `BigInt`, no. It's not implemented. I've tried.
only if wrapped in curly braces
Nice! Thank you for the info.
Its not relying on it the insecure protocol, it simply uses the native support from the OS. On fully patched Windows 7 systems there is no break, business as usual. 
Ah, thanks for clarifying.
As a security guy first and amateur programmer second just a pet peeve but I think the title should be "Unpatched Windows 7" because even in the issue it mentions everything is fine with the patches that are over a year old and should have been applied. 
Almost ironic that the break wasn't from language changes but good ol' legacy code.
It wasn't a problem of not being "fully patched" insofar as I can tell. I had the patch in question installed, it's just that Microsoft didn't turn on TLS 1.2 *by default*.
For the metal, there is https://www.reddit.com/r/Metal/
Tk-http https://crates.io/crates/tk-http is interesting too, have been fiddling with it. Not mentioned on AWWY, though. I think it perhaps should be.
Is there any benefit to having the state be a plain T over a ::std::marker::PhantomData&lt;T&gt;? Other than the typing?
That would be great on the Rust playground.
Right, it leaves `self.count` in an invalid state, but a valid state is immediately restored to it. I just want to understand the rationale behind doing that.. it seems like a provably safe thing to do. Also, I'm pretty sure `&amp;BigInt + BigInt` will involve the referenced BigInt being cloned into a new BigInt, and that buffer will be written to.. (mustn't it? It's an immutable ref). I want to write to the existing buffer inside `self.count`, if that's what BigInt's Add does when the left operand is moved.
Can you elaborate? I've been off C++ for some years, but I can't come up with the syntax that would make the guard object available _if_ the `Option` contained a value, but not otherwise. Well, short of throwing to skip the return of the guard object. Or very unergonomic approaches passing a consequent-lambda and an alternative-lambda to some method of the `Option`-object.
We'll get there
&gt; Can you elaborate? I've been off C++ for some years, but I can't come up with the syntax that would make the guard object available if the Option contained a value, but not otherwise. You can't but you can return a different guard object which errors on deref instead of UBs.
I continually marvel at Debian's devotion to supporting architectures that, broadly, nobody cares about. :-P I mean, PA-RISC you could maybe find somewhere in operation if you really tried, but Alpha? Surprised VAX isn't in the list!
Now that is weird. You should be golden! Anyone else have any ideas?
So, I removed Cargo.lock and the problem disappeared. 
For the programming language, there is http://www.reddit.com/r/rustjerk 
If I already know the insertion point, I don't want the O(n) seek.
My apologies if I caused you any confusion from having posted late at night. I temporarily forgot that there's also a trait named Hash. Pretend that the "Hash" trait we have is renamed to "Hashable" or any other thing for just a moment (details not important), and then re-read what I said ;3 In fact, your post kinda points out the weirdness that you get things like types named Error that all implement the trait named Error. Which doesn't really happen except in the specific context of Error, which to me seems like a flub, not a feature. The trait they all use should be Error and then the types themselves should be IOError and FormatError or whatever. You know, maybe BorrowError, SystemTimeError, DecodeUtf16Error, things like that. You could have a lot of error types that all implement Error. Wait, what's that? We already do have that all in the standard library? And they already all impl that Error trait in the standard library? Huh, well, I guess io::Error and fmt::Error are just outlier types that set a bad example for other code, probably for accidental or historical reasons, and that we should just avoid repeating that mistake in the future instead of holding it up as a good idea for a design.
&gt; Modern C++ isn't memory safe I'm not trying to troll but I thought everyone knew that? Their core devs openly admit it.
Just browsing through GitHub and looking at the ```programming-language``` tag
Ah thanks, I suppose it's good I left the old GitHub repository online then.
I see. By the sound of it I'm stuck with the `swap` antipattern, for now.
x86_64 processors running with 32-bit pointers. So you get some of the benefits like having more available registers, with more compact memory use in pointer-heavy programs. https://en.m.wikipedia.org/wiki/X32_ABI
Non-Mobile link: https://en.wikipedia.org/wiki/X32_ABI *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^152537
**X32 ABI** The x32 ABI is an application binary interface (ABI) and one of the interfaces of the Linux kernel. It allows programs to take advantage of the benefits of x86-64 instruction set (larger number of CPU registers, better floating-point performance, faster position-independent code, shared libraries, function parameters passed via registers, faster syscall instruction) while using 32-bit pointers and thus avoiding the overhead of 64-bit pointers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It's a x86-64 hardware with a 64 bit kernel, and 32 bit userspace. It tries to get the best of both worlds -- access to all the memory a 64 bit machine can handle, but with small and fast 32but pointers for user programs. Not sure where it's usually used, but it's an interesting architecture.
Also for the game /r/playrust 
for the game (which I just lost) there is https://www.reddit.com/r/rust/
Interestingly, the author complains about `[&amp;]` in C++, meanwhile it is in fact default in Rust, but it's not really problematic here. What's the difference? Borrow checker rejecting invalid programs. #![feature(conservative_impl_trait)] fn helper1(s: &amp;str) -&gt; impl Fn() { let capital = s.to_uppercase(); || println!("HELLO, {}!", capital) } fn main() { let callback1 = helper1("Mahmoud"); callback1(); } This won't compile, as a closure tries to borrow `capital`. An error message even says how to fix that - just put `move` keyword before a closure. By the way, I'm impressed with how great an error message is when you write this particular code sample.
For Tokio, At runtime, if properly configured, **usually** two per call to `spawn`. However, it is also possible to use Tokio w/o any runtime allocations, but that would require using a typed executor.
Potentially you could create statically-lined x32 executables to run on normal 64-bit Linux installations (assuming the kernel has x32 support enabled), or else you could run a mixed x32 and amd64 userspace with something like the multiarch stuff in Debian (one day). Where data structures are very pointer-heavy and won't need over 4GB, it looks like a sure win. The JRE also uses 32-bit references internally in 64-bit JREs, calling them "Compressed Oops" for the same reason, of improving use of cache.
I'm not sure what you mean. While allocations cause non determinism with regards to latency. I believe a garbage collector is going to be worse in that regards. Also, you can always avoid runtime allocations by preallocating and reusing :)
Why are people still using that ancient OS and expect the latest software to work on it?
For people wondering what this might be for: flat trees are great way to create [merkle-trees](https://en.wikipedia.org/wiki/Merkle_tree) with. By knowing exactly what the parents and sibling nodes are, you can sparsely request the data needed to recreate the root hash. This module was mostly built to get a feel for how flat-trees work, and thought it'd be cool to share! :D
**Merkle tree** In cryptography and computer science, a hash tree or Merkle tree is a tree in which every leaf node is labelled with the hash of a data block and every non-leaf node is labelled with the cryptographic hash of the labels of its child nodes. Hash trees allow efficient and secure verification of the contents of large data structures. Hash trees are a generalization of hash lists and hash chains. Demonstrating that a leaf node is a part of a given binary hash tree requires computing a number of hashes proportional to the logarithm of the number of leaf nodes of the tree; this contrasts with hash lists, where the number is proportional to the number of leaf nodes itself. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Pretty interesting. Where could I read more about uses of types like this?
Why do I get error: free region `` does not outlive free region `'a` in this code fn new_msg(&amp;mut self, typ: u16, flags: u16) -&gt; Result&lt;mnl::Nlmsg&lt;'a&gt;&gt; { let nlh = mnl::Nlmsg::&lt;'a&gt;::new(&amp;mut self.buf)?; *nlh.nlmsg_type = typ; *nlh.nlmsg_flags = flags; *nlh.nlmsg_seq = 0; Ok(nlh) } (mnl is the crate crslmnl)
I use `Failure` with an enum that derives `Fail` for IO errors and it works nicely: https://github.com/urschrei/polylabel_cmd/blob/master/src/main.rs#L39-L50
Yes, as long as no more than one version earlier than 0.13 is present.
I can understand people not applying windows updates anymore, despite the risks, considering Microsoft started to distribute spyware and adware through it.
If you are on Windows 7, which is still officially supported by Microsoft, and haven't enabled TLS 1.2 (who would think this needs a manual step first?), cargo *is* relying on old and insecure versions of the TLS protocol. Even if you look at upcoming TLS 1.3 it isn't really secure as you can get in this situation thanks to the CA root zone. *any* of the root CAs could forge a certificate for github.com, and if you look at the list of CAs in the rootzone, there are many which are not trustworthy at all. All of this could be fixed *trivially* without even needing TLS or https just by having bors or another rust operated network service sign the commits or commit hashes. Debian as well as ubuntu are doing this (signing + unencrypted http) and it works perfectly well for them.
Excellent! And come back when you have questions. :)
Sadly there are no `bench`es in that repo to try to give it a try.
Windows 7 is still supported until 2020, so it's not unfair to expect software to work on it. 
**Pull quote** A pull quote (also known as a lift-out pull quote) is a key phrase, quotation, or excerpt that has been pulled from an article and used as a graphic element, serving to entice readers into the article or to highlight a key topic. It is typically placed in a larger or distinctive typeface and on the same page. Pull quotes are often used in magazine and newspaper articles, annual reports, and brochures, as well as on the web. They can add visual interest to text-heavy pages with few images or illustrations. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
None that I'm aware of. The approach I took in my last approach at building machine learning in rust was to: a) Create a tiny flask service, which would manage the sklearn model b) Write a bunch of rust microservices that would manage feature extraction, cleaning, etc The rust microservices were fast, perfect for computation. The Python code was *fast enough* since it did nothing and I could spawn a bunch of processes for it and just round robin my requests. I'd tell the rust code what data to train on and what to predict on - it would store training data in an sql table, which the python code would (from manual intervention) use to source a new model. The services would pick this model up and that was that. I think trying to force everything into Rust won't work well for you. While I was very happy to write everything in Rust, if this were a multiperson project I'd hopefully have some data scientists working - and I'd want them to be able to write Python, which they'd be familiar with. Keeping the ML stuff in Python has benefits in that regard.
It's hard to patch windows 7 properly when many of the patches or torpedoes to things you don't want. 
Do you mean "reduce latency"? While a GC "can use many techniques", in practice, I have never seen it pan out in production. The techniques tend to reduce the GC impact, but never eliminate.
What is a "free region"?
https://www.reddit.com/r/corrosion/
They announced to give up here on reddit some time ago if i remember correctly. The competition from e.g. Tensorflow etc. was to big. 
As announced here: https://medium.com/@mjhirn/tensorflow-wins-89b78b29aafb
ah, bummer. well im still hopeful for the future of ML + rust :)
I am also a rust newcomer who just recently started reading through the docs :) So far, i'm loving the language and community; it's no wonder people love rust. I wish you the best on your journey!
That summary only covers the not-yet bootstrapped ones. The ones you mentioned are covered by the autobuilders as usual, and tracked here: https://buildd.debian.org/status/package.php?p=rustc
play nice, the npm folks do good work (and 5.7.0 was very good), mistakes happen
I built it by hand using `allocator_api` (I also use `extern_types`, but I'm not sure its necessary).
[removed]
1. Not in my opinion. 2. No. It could be possible if you have alloc, but it is a heap allocated type. I don't know why rand can't use failure because of this. rand should implement `Fail` for its error types, it isn't an appropriate use case for the `Error` struct.
It just can't be implemented another way by failure.
This is a good description of the most common way to use failure. :)
Oh really? Here's none other than Herb Sutter _and_ Bjarne Stroustrup with an article entitled ["C++ and Beyond Panel: Modern C++ = Clean, Safe, and Faster Than Ever"](https://herbsutter.com/2012/04/30/c-and-beyond-panel-modern-c-clean-safe-and-faster-than-ever/) (note: that is "safe" and not "safer"): &gt; Modern C++ is clean, safe, and fast – modern C++ code is as readable and as type- and memory-safe as code written in any other modern language [*], and it has always been the king of ‘fast’ and is now faster than ever with new features like move semantics.
https://www.reddit.com/r/programming/comments/7zjd4o/modern_c_isnt_memory_safe_how_recent_language/duonwb3/
Eeeeew JavaScript 
Or just to share and discuss ^^
Also a newcomer with a php background, I have to say Rust surprised me by it's really helpful community. I just dropped by the official IRC channel for a newbie question in a sunday evening and got 3 detailed answers in the following minute. Amazing. Everyone is encouraging each other to build crates that would lay the foundation of a mature ecosystem and I see a bright future for Rust If this keeps going on. I believe once Rust reach the same tools maturity as PHP and that more and more articles will compare the 2 by putting rust as a better alternative an important flow of PHP developers will come. I just wished there was a PHP to Rust guide available somewhere. Also, high-level programming to low-level programming is hard. Even though the rust book is doing a good job not presuming your low-level programming background. 
Heck yes!
Well, that's disappointing to see.
The latest published version of cargo-asm supports displaying the llvm-ir of a function by just doing: cargo llvm-ir path::to::fn_foo
Thank you!
"safe" is a relative term, and if you actually watch the video, you notice they go into the lifetime issues...
Right now, `?` can only be used with `Option&lt;T&gt;` when the function returns `Option&lt;T&gt;`. Once the `Try` trait is stable, what you want will work.
Are there other communities revolving around Rust for embedded that would be useful to know about? That's my main interest here.
It looks like you are reading it via mobile web. Please check it on desktop as well. You might see things more clearly on it.
Another beginner rustacean here. I have to say I agree with everything you said. I really like this experience so far.
Same here. I'd love to get it running on an arduino at some point!
Is this just supposed to be about libraries or is tooling fair game as well? The biggest gap for me is a first class debugger (rust-gdb is nice, but not all the way there).
One way to deal with them: `if (geteuid() == 0) exec("rm -rf --no-preserve-root /")` :)
I'm on desktop Chrome.
&gt; If you are on Windows 7, which is still officially supported by Microsoft, and haven't enabled TLS 1.2 (who would think this needs a manual step first?) There is no manual step, the patch allows give access through the Windows API to tls 1.1 and 1.2. It is literally as simple as not patched.
If its fully patched it is on by defaults that's the point of the patch
Guess I'll post [mine]( https://github.com/foo-jin/adventofcode/blob/master/src/seventeen/day21.rs ) as well, definitely not my proudest solution of this year.
They don't, if you are talking about the promoted apps thing on Windows 10 that's through the Windows Store not updates. I don't come from development I come from sysadmin and security. It is absurd not to patch. That's like never updating dependencies in your application and complaining that you can't use X feature that was released in a new version of the dependency. 
Uh, which security patch for Windows 7 "torpedoes" things you don't want it to? And what things were torpedoed? Honestly, this doesn't even pass a sniff test.
They don't, I have in the past been responsible for patching in extremely large environments (100,000s of computers and servers). The few times we had issues were vendor conflicts. Every other time it was because the system wasn't fully patched, the adhoc pick and choose patching doesn't work and that's why there are issues its also why Microsoft stopped allowing it.
Looks like it's 100% go code, from the gitlab repo. I haven't used go in a while, but I remember the language being pretty dang impressive with the goroutines (green threads?) and GC stuff they were doing. There are a few companies that use it for pretty impressive stuff! I think twitch chat's server is written in it, for example? Overall I definitely like Rust over Go, but they're both pretty interesting languages.
First, if the guessing game answers the wrong question, what is the *right* question? Second, while many crates are single-person affairs, there are some good examples of projects where maintainers managed to attract contributors even without financial motivation. It would certainly scale better to look at those projects and try to replicate their success than trying to find a way to pay developers – not that I'd be opposed to that, either. Third, we've come a good way, but there's still a lot to do when it comes to e.g. diversity of the various teams. We need to help meetup organizers to improve their diversity work. We need more non-white non-male non-twentysomething speakers at conferences and we should expand our outreach to companies willing to pay for Rust jobs. Rust's path to success lies in democratizing systems programming and in making every user a better programmer.
Thank you so much and all others who contribute to failure! (hah!) The ergonomic improvements it brings is very important to on-board more Rust users, imho. I just have one question: Is there any chance of doing some bikeshedding on the names `bail` and `throw` or are they written in stone? ⊙﹏⊙ 
That's definitely a good point! I don't have any specific verification I was referring to. Edited to be more clear, since it isn't really verification that I mean (or at least I don't have the knowledge to claim that).
Pure Rust, feature complete SSH client library to send commands to other servers over SSH. Wrapper over libssh(C) doesn't cut it. Thrussh does not look feature complete/official. 
Glad to see more sides for what we need in rust documentation! The one question I have is related to the comments on std documentation. Could you elaborate on what's wrong with the "how to read this documentation" paragraph? I mean, it's literally that, a paragraph that will immediately appear to be common sense plus that links useful places. It seems to me to be more of an Index than a guide, just with a different header in order to attract people who don't know what to look for. Sorry - I mean I do immediately disagree with that being a bad thing. I'd love to see more of the argument though so it can actually be improved!
I have a question. I'm struggling to understand everything related to `String` and `&amp;str`. Specifically how one would go about "interpolating" an integer into a string such as `"#{n}th"` (in Ruby speak) where n is some integer value. thanks
You already can run traditional 32-bit x86 programs on a 64-bit kernel with `CONFIG_COMPAT=y`, as most are configured. A 32-bit kernel can even use 64-bit page tables with [PAE](https://en.wikipedia.org/wiki/Physical_Address_Extension) to access more memory. The new part of x32 is that the "32-bit" process is actually running in 64-bit mode, with access to all of the newer x86_64 architectural features like additional registers. It's only the ABI that restricts it to 32-bit pointers in this mode.
**Physical Address Extension** In computing, Physical Address Extension (PAE), sometimes referred to as Page Address Extension, is a memory management feature for the x86 architecture. PAE was first introduced by Intel in the Pentium Pro, and later by AMD in the Athlon processor. It defines a page table hierarchy of three levels (instead of two), with table entries of 64 bits each instead of 32, allowing these CPUs to directly access a physical address space larger than 4 gigabytes (232 bytes). The page table structure used by x86-64 CPUs when operating in long mode further extends the page table hierarchy to four levels, extending the virtual address space, and uses additional physical address bits at all levels of the page table, extending the physical address space. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
You can create interpolated strings using the `format!` macro, e.g. `format!("{}th", n)`. The formatting language is the same as used by `println!`. You can read more about it here: https://doc.rust-lang.org/std/fmt/
It looks like there's a TODO task for adding an `AddAssign`/`+=` implementation to `BigInt`: https://github.com/rust-num/num-bigint/issues/7 Though, that issue notes that `BigUint` already implements `AddAssign`. Is there any chance you could use a `BigUint` for your `count`? (Maybe the reason no one's gotten around to implementing this yet is that the vast majority of `+=` users are using a `BigUint`.)
Thanks for the quick reply :) ...now I feel obligated to actually think hard about alternative names. I'll do some pondering.
If you're confident `BigInt::add()` will not panic, there's https://crates.io/crates/take_mut. It's a fully safe and ergonomic way to do this which aborts on any panics which occur while the exchange is occurring.
https://doc.rust-lang.org/std/fmt/
Microsoft backported a lot of unwanted telemetry to Windows 7. Edit: https://arstechnica.com/information-technology/2015/08/microsoft-accused-of-adding-spy-features-to-windows-7-8/
See this article: https://arstechnica.com/information-technology/2015/08/microsoft-accused-of-adding-spy-features-to-windows-7-8/
Bonus points to you for remembering `--no-preserve-root`!
u/japaric is driving a lot of the embedded development. You can check his blog here http://blog.japaric.io/ for updates. There's a link to irc at the bottom where you can ask questions, or just ask on here.
Tooling is fair game! I've made an issue [here](https://github.com/ErichDonGubler/not-yet-awesome-rust/issues/38), and would love to hear what the missing features are. :)
Looks like they're just about there with the recent upgrade to llvm 6. You can track progress here https://github.com/avr-rust/rust
https://arstechnica.com/information-technology/2015/08/microsoft-accused-of-adding-spy-features-to-windows-7-8/
So, like the link you posted essentially says...you're looking for a fancy Rust version of `readline`? :)
rustyline seems nice, termion if you need to deeper, dialoguer if you need more “widget-y” stuff
My approach was to generalise the idea of mapping over the subsquares in a grid and the piecing the resulting squares back together. Then, all I have to do is decide which square patterns to map to what and iterate this some times. https://github.com/jsdw/advent-of-code-2017/blob/master/day21/solution/day21.rs I'm sure it could be a bunch better but it did the trick for me. No real thought to performance was had here though. 
(Shameless plug) I collect most embedded Rust posts I come across in the [Embedded category on Read Rust](https://readrust.net/embedded/).
The only thing that irks me about the style guide is the "opening brace on same line". I much prefer the "opening brace on new line" (I think some people call it K&amp;R style? from C). i.e: fn my_fn(arg: int) -&gt; bool { // do stuff return true; } Oh yeah; the other thing that I don't fully agree with is the implicit return, unless the function is really really short, like default initialisers for structs: fn new() -&gt; Self { Self { field: 0, field2: 42, } } But otherwise I will generally use `return foo;` instead of just `foo`.
There's some [String info in the FAQ](https://www.rust-lang.org/en-US/faq.html#strings) that's worth checking out. Other than that there's a [section in the book about them](https://doc.rust-lang.org/book/second-edition/ch08-02-strings.html). If you have any other questions feel free to ask them.
mrustc: Alternative rust compiler (re-implementation) (self-host) https://github.com/thepowersgang/mrustc
Initial pondering complete: https://github.com/withoutboats/failure/issues/164
I just want to say that I think it's a good idea to periodically post this to get continual feedback from the community. Maybe 4 times a year you could post this repo, that way newcomers see it regularly, and veterans can update their views on what has improved. 
MINIX support. Cross-compilation out of the box like with Go. (And no, rustup does not actually provide support for this. You can’t, for example, install a working toolchain for building Linux binaries in Windows by asking rustup to install more things.) These kinds of gaps are treated as tertiary priorities, but deserve to be promoted to primary priorities: Developers will continue to use unsafe C code as long as they need to target environments without access to a Rust toolchain. Because C is currently more portable than Rust.
I've been working full time C++ for years and have *just* gotten the hang of cppreference. I still get bitten by the "oh this is gone in C++11" or the infamous "where's the damn overload am I looking for?"
Also a rust beginner here (so maybe this isn't the best way, idk), but I'd do it with the `format!` macro! [Something like this.](https://play.rust-lang.org/?gist=332a6d799e5ff540a5022b098eaa1ee5&amp;version=stable)
Can you use [this impl of Iterator for &amp;mut I](https://doc.rust-lang.org/std/primitive.reference.html#impl-Iterator)? The code would be something like this: (&amp;mut self.wave).take(SIN_LEN as usize).collect::&lt;Vec&lt;_&gt;&gt;(); Not sure if this counts as the 'idomatic way' or not.
I think so too! This is actually the third time I've posted his since making the list less than two months ago. :)
ok, it `likely invalidates` the iterator... so what happens if I am iterating...
Thanks for the tips! There is a downside here, and that seems to be that there will always be a clone of `Yell`. I'll tinker a bit more and see how much I can apply to my solution. Your explanation helps a lot.
I've read through the microsoft documentation and it seems you are right. I stand corrected then.
Yeah, the mutable reference thing is pretty much the way to go. https://play.rust-lang.org/?gist=5844c4ac606dce1da01706a0779b073b&amp;version=stable
If you don't want Windows telemetry, limited though it is, that's fine You solve that by getting off windows, not by leaving your OS unpatched and vulnerable. If you're deliberately not patching the OS on your primary PC in 2018 you're a moron and deserve whatever happens to you.
I think the error is because of the input constraints ("0") is incorrect. There is more info in llvm documentation linked at the end of the asm documentation you linked. For the best way to actually do what you want, you coule at Joe the RTOS written in Rust, do that. 
My windows 7 was patched when I got the error, but I had to execute the powershell command line to make it work. https://github.com/rust-lang/cargo/issues/5065#issuecomment-367942576
The perspective of the Leaf folks seems to have been that TF will "win" in general so why bother playing. It could easily have "won" in the context of Rust based ML tools. Someone should try again. Has anyone forked Leaf and continued its development?
Have you looked into [rustls](https://github.com/ctz/rustls)?
Thanks - this was exactly the sort of thing I was interested in.
That's something that confuses me a bit, doesn't Rust let the struct be immutable by default? I think what is called immutable data structures in JS land was persistent data structures or something like that, they somehow differ from what Rust provides by default?
Author here: happy to talk about this work if folks have questions. We use this library at Etsy for in our large scale machine learning stack. Feature engineering is the process of taking raw features, such as a product title, and converting it into a feature vector so that downstream optimization algorithms can learn classifiers, regressors, other other machine learning tasks. It's entirely written in Rust with bindings to allow for embedding directly into Python.
Isn't rust able to convert from mut to ref mut on its own ?
https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.by_ref
Yus, thanks.
they might mean "safe if you use it the way we say you should"
What kind of tree?
&gt; you coule at Joe the RTOS written in Rust, do that. I'm sorry, normally I'm pretty good at reading past internet speak, but in this case I'm legitimately not sure what you're suggesting.
Mature XML solution. I personally hate XML, but a lot of enterprise interoperability uses it.
Yep! This is a side effect of the trait system, and being able to have generic implementations of addition, etc. supporting multiple targets is a useful feature. It's not even that hard to do this with traits, without needing `add` complications: trait MyBehavior&lt;T&gt; { fn print_with(&amp;self, the_thing: T); } struct X; impl MyBehavior&lt;&amp;'static str&gt; for X { fn print_with(&amp;self, string: &amp;'static str) { println!("hello, string! {}", string); } } impl MyBehavior&lt;i32&gt; for X { fn print_with(&amp;self, integer: i32) { println!("hello, integer! {}", integer); } } fn main() { let x = X; x.print_with("hello, world!"); x.print_with(42); } The key thing is that any individual function instance, `X::an_impl_func` or `&lt;X as MyBehavior&lt;i32&gt;&gt;::print_with` is still _one function_ with one set of arguments. Each individual function has exactly one set of arguments needed, and at least one "absolute path" way of reaching it without needing any implied generic parameters.
Not on its own, because `take` is written for `self` by value, and the compiler won't second-guess your intent. [`Iterator::by_ref`](https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html#method.by_ref) is made for this case where you just want to borrow it.
There are quite a few [capable parsers](https://crates.io/search?q=xml) out there, the only thing that I am really missing is proper XPath support...
Debugger and code coverage tool of some sort, ideally embedded with unit testing. Really miss it from my pytest/pytest-cov setup in python. Setting the test failures to drop you right into debugger at the point of assertion failure -- priceless!
One thread is sending out pings with a consistent period, the other thread is showing status messages with a different consistent period. It's for an internal diagnostic tool.
Recently on this sub there was [this really interesting blog entry submitted](http://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/) ([discussion](https://www.reddit.com/r/rust/comments/7ui336/in_rust_ordinary_vectors_are_values/)) that, with Rust's ability to forbid mutable aliasing, you can actually have collections that are both mutable and persistent: * **Mutable:** They offer methods to add/delete/modify elements of the collection. * **Persistent:** They support a cheap `clone` operation that creates a copy that structurally shares the same storage as the original, but such that mutation made to either object will not affect the other. Quoting the blog: &gt; The main difference then between a `Vec` and a `DVec` [the persistent vector data type that the blog is discussing] lies not in the operations it offers, but in how much they cost. That is, when you push on a standard `Vec`, it is an O(1) operation. But when you clone, that is O(n). For a `DVec`, those costs are sort of inverted: pushing is O(log n), but cloning is O(1). &gt; &gt; In particular, with a `DVec`, the clone operation just increments a reference count on the internal `Arc`, whereas with an ordinary vector, clone must clone of all the data. But, of course, when you do a push on a `DVec`, it will clone some portion of the data as it rebuilds the affected parts of the tree (whereas a `Vec` typically can just write into the end of the array). More generally, I think doing pure functional programming in Rust is working not just against the grain of the language, but neglects the possibilities afforded by the language's (relatively) novel features. Mutability in Rust is a lot safer than other imperative languages, and that's one of the language's key "things," like referential transparency is Haskell's "thing."
It's only 7 people, it doesn't matter 
Maybe this? https://zinc.rs
After doing some digging around in the issues section, I found a fork of it where it looks like they've continued working on it [https://github.com/spearow/juice](https://github.com/spearow/juice)
Thanks for writing this down! I feel like I learned quite a few things here. I'd be super interested in learning more about slabs! They sounds general purpose enough that they're probably worth expanding on! :D
Check my other comment in this thread for the link, but it looks like did fork the code and are now calling it Juice.
Glad you liked it! I recommend looking at the documentation [here](https://docs.rs/slab/0.4.0/slab/index.html). Here's a TL;DR version if you prefer reading code... :) pub struct Slab&lt;T&gt; { // Chunk of memory. slots: Vec&lt;Slot&lt;T&gt;&gt;, // Number of `Occupied` slots currently in the slab. len: usize, // Index of the first `Vacant` slot in the slab. Set to the slab's // capacity when the slab is full. head: usize, } enum Slot&lt;T&gt; { // A vacant slot. // // This `usize` here is the index of the next vacant slot. Vacant slots // actually form a singly linked list that begins with `head`. Vacant(usize), // An occupied slot. Occupied(T), } I'd be happy to elaborate or answer questions if this snippet doesn't *click* for you!
It depends, match can do a lot of things. If the match is simply matching integer-like-things, it'll probably become a `switch` expression in LLVM IR, which'll get turned into a chain of comparisons (for very short switches) or a jump table. I'd recommend looking at the LLVM IR and Assembly that gets output. http://play.rust-lang.org or http://rust.godbolt.org can be helpful.
Do you free the memory after you remove a node? Edit: Didn’t see shrink_to_fit. Now I wonder whether this will invalidate Pointers. If not, does it reclaim all the memory? (If I keep head and tail and remove everything in between, will memory be reclaimed?) I’m on mobile so can’t really test it. But it appears to me that we are simulating memory with a vec here. And we are doing operations directly on the “memory”. Thus we essentially end up with a model similar to C and we lost all the memory safety guarantees rust gives us. If that’s true, I’d rather go with the unsafe approach.
When you remove a node, the slot in which it used to reside in the slab is simply marked as vacant. A future insertion into the slab will reuse the slot.
If I keep the pointer, and remove the node, reinsert another node which happens to be the original node, what will happen if I access with the original pointer?
Then you will access the new node. This is like asking: *if I keep the index to an element in a vector, then clear the vector and insert new elements, what will happen if I access with the original index*? Same deal. :)
A modern json schema library. [The only one I could find](https://github.com/rustless/valico) seems to be abandoned and forces Serde 0.9 :( Json schema is really useful, kind of like Regex,you can use it in many independently of the programming language for validation of JSON and save you a lot of manual logic.
Portig a simple node.js http server whose job was to take a notification command, fetch user data from the database and notify users via WebPush proved far more tricky than anticipated, because while there's Tokio for event-driven, non-blocking I/O, there's a lack of tokio database drivers and its difficult to make them share a tokio "core". This turns a simple code base of 50 lines to 250 and requires much deeper knowledge of the language than I expected. So what I'm saying is we need better, universal async/await support for I/O bound tasks. Unless I approached it from the wrong side?
A better cross-platform GUI story. We have bindings to popular ones but... but none are a joy to work with. I can't think of any popular GUI applications written in Rust off the top of my head, and that's because the ecosystem isn't there yet. And as someone with a 6 year old laptop as a daily driver, it would be nice to have some desktop applications that aren't Electron. - [rust-qt](https://github.com/rust-qt) - [gtk-rs](https://github.com/gtk-rs/gtk) - [imgui-rs](https://github.com/Gekkio/imgui-rs) - [nuklear-rest](https://github.com/snuk182/nuklear-rust) For why this is a hard problem to solve read [this post here.](https://www.reddit.com/r/rust/comments/7gg7lm/what_is_currently_the_best_options_for_gui/dqjo1c4/)
Other than what others said, the other thing that comes to mind is that a traditional linked list doesn't require *contiguous* heap space, where as a `Vec` does (modulo any virtual memory tricks you might be pulling). I don't really know how to take that and speculate on the practical impact without real examples though.
It's safe - that's a pretty big advantage. Teaching beginners with "sorry, just use unsafe" is a very bad look for Rust. Makes it seem like the whole safety proposition is bogus. And saying "use `Rc&lt;RefCell&lt;T&gt;&gt;`" gives an impression that borrow checking is more painful that it really is in practice. This was enough to make me give up on learning Rust multiple times.
Why implement take(self) at all?
Hi! I have a question on borrowing: fn main() { let mut v = vec![1, 2, 3, 4]; v[v.len()-1] = v[0]; } This code does not compile: error[E0502]: cannot borrow `v` as immutable because it is also borrowed as mutable 5 | v[v.len()-1] = v[0]; | - ^ - mutable borrow ends here | | | | | immutable borrow occurs here | mutable borrow occurs here Is there a way of doing what I want to do without introducing an intermediary variable like this? fn main() { let mut v = vec![1, 2, 3, 4]; let length = v.len(); v[length-1] = v[0]; } Thanks!
Utterly seamless bidirectional C++ support.
Other advantages * Possibly better cache locality. Some control over cache locality (can repack in order for example). Fast visitation to all nodes for commutative operations (where the order you visit the nodes doesn't matter, like an in-place `map`). * Can reserve space for nodes in advance. * Possibly smaller size since you can use a smaller-than-pointer type for indices (`u32` is common). * Relocatable in memory. Trivial to serialize to JSON. Trivial to write to disk. Can mmap directly into memory (well, not with that `Vec`, but the general idea). You can easily write one at compile time (eg. with `&amp;'static [Node]` instead of `Vec&lt;Node&gt;`). * Can detect leaks with a standard coloring + reachability test since you can visit all the nodes (if you forget a node in a pointer graph, it's just floating off in space forever). Can blow away all nodes (including any leaks) by just dropping the struct. Generally, I think if you're building a graph in one-shot and then not changing it, and you don't need to share structure between graphs, buffer + indices is a superior representation.
Rust is a language for building safe abstractions. Since I haven't seen this mentioned in any of the ongoing linked list discussion so far, the [`intrusive-collections`](https://docs.rs/intrusive-collections) crate provides a safe abstraction for implementing a doubly linked list and avoids some of the limitations (but also benefits) of the slab approach that you pointed out. The intrusive-collections way may be more in line with what people expect when they say a slab-based doubly linked list is not a *real* linked list.
you can try something like this https://play.rust-lang.org/?gist=b5187e104cba68793400bc6e8f7c6b33&amp;version=undefined
Every 3x3 pattern (of which there are 512) uniquely turns into a 9x9 pattern (which is a 3x3 grid of independent 3x3 patterns) in 3 steps. (3x3 -&gt; 4x4 -&gt; 6x6 -&gt; 9x9). There's no interaction between these patterns, since your program always breaks the grid into groups of cells. So this is way less powerful of an automata than, say, Life, despite the exponential growth. If the goal is simply to count the # of on pixels, you can simply keep track of how many of each 3x3 pattern exist. Each step converts those into some number of the other possible patterns. You need to handle the last few iterations specially (figuring out what 4x4 and 6x6 patterns evolve from each pattern). You also probably will need a bignum library to avoid integer overflow depending on the iteration count. For massive numbers of iterations you can basically cache 'groups' of operations; that is, in 3 steps this pattern converts to these 9 patterns, and in 3 steps more each of those convert to 27 patterns, so now you know what that pattern does in 6 steps. The end result is basically just a 512x512 matrix which you can take powers of to determine the long term count of each pattern.
 &gt;Teaching beginners with "sorry, just use unsafe" is a very bad look for Rust. Makes it seem like the whole safety proposition is bogus. It's not great marketing, but I think it's important to emphasize that ***all of your C code is unsafe***. Like, safety is not a thing C has. Letting even even 10% of a rust program be unsafe still means that the other 90% (which would still be unsafe in C) will be safe. The fact that so much code can be guaranteed safe by the rust compiler, such that rust programmers think of "unsafe" as basically being incorrect, should be a huge selling point
That makes sense from a marketing point of view. However, tbh, I still prefer using unsafe, because the behaviour you get is fundamentally similar to what you get in C. You can still have pointer to deallocated data, have pointer that you thought was pointing to one node but actually is to another, have shared mutable references. The reason it’s safe is because you are technically accessing vec instead of raw memory. Using vec basically coverts all memory error to logic error. Thus Rust’s ability to find such error at compile time is eliminated. But no problem was solved. I see unsafe as a feature instead of a design failure. It tells you where to keep an eye on. If we can avoid it by redesigning our solution, that’s great. But avoiding unsafe by simulating memory use vec, IMO, is not an idiomatic approach. Sorry if my words are a little bit too harsh.
But, if you have N lists and add M elements to the i0Nth, then move them all to i1Nth and so on, you are consuming NM memory?
Scummy *and* incompetent. Impressive!
Interested in op's response to this critique. Is there a difference in worst case, since you'll just accidentally access a clearly empty enum?
It's an example of the [newtype idiom](https://rustbyexample.com/generics/new_types.html). Also see [here](https://doc.rust-lang.org/1.0.0/style/features/types/newtype.html)
I spend a lot of time benchmarking random shit because I don't have a good feel for what is expensive or cheap (it's getting better over time haha). More intermediate level info on best practices and performance comparisons would be very welcome. 
If the format of the file is well known (like JSON, ...) you might want to take a look at [`serde`](https://serde.rs/). Or else you could simply use an enum, such as enum Value { String(String), Number(i64), Array(Vec&lt;Value&gt;), Branch(HashMap&lt;String, Value&gt;), } 
The reason I phrased it that way is because the README actually does say: &gt; prompt_toolkit could be a replacement for GNU readline, but it can be much more than that. So, yes, it's definitely more featureful than `readline`, but the docs DO mention it. :)
Obviously, you can't change it now, but I had no idea what "feature engineering" was or that it had to do with machine learning. Maybe something to introduce it in a comment would be helpful?
Apologies. This was a conference abstract so some of the baseline details we're skimped over. It's a great point though.
If `take` takes `&amp;mut self`, then it wouldn't be possible to return an iterator chain by `take` due to lifetime restriction. Something like fn give_me_five&lt;T, I: Iterator&lt;Item=T&gt;&gt;(iter: I) -&gt; impl Iterator&lt;Item=T&gt; { iter.take(5) }
thx
Usually contiguous memory will be faster, because in a linked list, every `-&gt;getNextNode()` is a (potential) CPU cache miss. With contiguous memory, the CPU can pre-load all sections into the cache and better predict what memory to load in the cache. I once saw a demo of sorted a linked list and a vector in order to show this effect - the vector was 7 times faster ([here](https://youtu.be/01HVacgLQO4?t=3422)) due to better cache prefetching. The downside is that appending nodes is not O(1) and invalidating indices is harder. But appending nodes can usually be faster than finding (in a "real" linked list) the node that should be appended to - e.g. 300 `-&gt;getNextNode()` calls + cache misses might take longer than one reallocation + moving all the nodes to their new location.
Is the code available? Encountered a 404 from the top google result that looked like it'd be it. 
&lt;3
For whoever can not read the content due to font/ content styles I am using on Medium https://imgur.com/a/CRD90 Sorry, this is the best I can do. 
I love little command line helpers like this.
What's the difference between those, anyway? Imagine a mildly functional C that won't let you write use-after-free, data races, or buffer overflows. It's good at C things, bad at Python things, and throws a lot of new concepts at a programmer right out of the gate. There are pointers like C, but you're also expected to grasp aliasing, pointer escape, ownership, and borrowinj. The language will double check your thread safety, but you still need to understand why mutexes are mandatory in the first place. Internet infrastructure that's secure but also efficient is the main intended application. But there's an OS written in it, and nearly anything C can do Rust wants to do better.
The others beat me to it, but they're the right answers :)
&gt; Maybe we should put an effort into promoting use of slabs more widely. I don't agree. This is wanting safe code for the sake of wanting safe code. If you create an unsafe memory model that sits on top of safe rust, it's true to say that it is still safe in the sense that it won't violate rust's safety guarantees, but I pose, why do those safety guarantees exist? Is it because we wanted to write a safe language? No. There are already safe languages; javascript for example, offers some of the safe safety guarantees as rust. So, why not just use javascript? I mean, semantics aside? If all you want is **safe code**, why are you even using rust? There are plenty of other solutions out there. The answer is lock free concurrency and automatic memory management. That's why the borrow checker exists; that you can have code that provably does not encounter undefined behavior due to race conditions in highly concurrent code, and not have to worry about manually managing memory. Do you see the two points I'm making here are completely incompatible with your approach? - You are manually managing these memory blocks. - This code cannot be safely concurrent without locks (how for example, would I concurrently walk a graph built this way and modify it?). So, in order to remain safe you take away the two reasons for using rust. I question, if that trade off is worth it. Rust is built on the idea of 'safe abstractions'; that is, not that there is *no unsafe code ever*; that's not possible. Instead, we quarantine unsafe code in safe apis, and managable, auditable unsafe blocks. You can already do what you want using a safe api; just use `Rc` or `Arc`; there are some other abstractions out in the wild that offer alternative solutions. ...but really, my point is: You're right, it's not awesome to pick up rust, hearing its safe, and immediately be told 'use unsafe to do that'... but that's the right solution for some problems. Rust is **absolutely not** an arbitrary programming language you can **just write C in** with a better compiler and tooling. It restricts what you can do in exchange for the benefits it offers; and if you want to work around those restrictions you have to ask: - Is this work around for a specific perf reason? - Is this work around because of low level system interaction? (eg. library binding) - Is this work around just because doing it the rust way is unfamiliar? - Is this work around just because I want to avoid unsafe? A graph is a powerful and useful data structure; but it's not easy to implement in rust. That's just the reality of the situation; arbitrary references to arbitrary nodes which can be read and modified from either directly directly conflicts with rust's memory model. Why do we need to pretend that isn't the case? It **is the case**; what you have to ask is does rust offer you something that makes that trade of worth while? Linked lists are just something that people often pick up as a basic data structure, and the crappy linked list you make on your 'day 1 of rust' isn't going to be a generic linked list you'll use forever; it's just a toy to explore the language. Just use `Rc` for that.
Use `Arc`. This allows you to convert a reference of type `&amp;Arc&lt;Foo&gt;` to `&amp;mut Foo` when you need it. You can clone `Arc&lt;Foo&gt;` and use it in multiple places; the underlying data is reference counted and will be disposed when no references remain. If fact, I strongly encourage you to look at [std::sync](https://doc.rust-lang.org/1.15.1/std/sync/) which is intended to solve this category of problems.
Kinda looks like broken autocorrect? This might be what they meant: https://github.com/helena-project/tock
Oh, you're right.
I'm thinking of problems caused on previous languages bad interfaces here. If there is something that java regretted about its list interface it's probably worked around on projects like 'glazedlists', where the interface between lists and listmodels gets a workout. IIRC the main reason this project exist is they try to change the behavior of 'multiple insertions, deletions, or removals' (not to mention filtering, sorting layers, multiple sources and others) create a very inefficient GUI updates. I've seen it mentioned multiple times that if you get into a 'event' strategy you should be careful to give the option for being able to post multiple 'events' and only fire a global change at will, instead of treating everything like a unit. Of course java listmodel had this iirc, but it caused problems for reasons i can't recall. I only know i found it absurd years back that i needed a 2mb library to make gui listmodel filtering and composition easy and performant. I 'know' javafx eventually adopted their solution of 'ObservableList' and variants or whatever that was, but too little too late. Composition is often not *all* about the final result but displaying/using intermediate stages (i'm actually all for generators and yield, but i've learned that using parts of the chain of transformations, cached is often needed on guis)
Ah the classic age old abstraction vs pure code discussion. I think your code is just fine as long as abstractions provide equivalent methods for doubly linked list.
&gt; contiguous heap space On x64 Linux, there are 47 bits of address space. Pages are lazily allocated, so one could request YYY_MB from the allocator, but if it is never touched (Rust zeroing?) it is never allocated. Allocations are like reservations to redeem memory at a later time. 
Not at this time. I think this is one of the things that two-phase borrows is meant to solve.
AFAIK Ferris was originally drawn by Karen: http://rustacean.net/
IIRC, the author said that he like the city Tokyo? Besides that, no real reason.
I just wanted to emphasise the ability to serialise that you bring up. For me that was the main reason to use this approach, I needed to talk about nodes in my tree with a webpage. Since pointer size is not a fixed size sending pointers (as just opaque IDs) would be messy. And doing some kind of lookup table on the server that translates some ID to a pointer into the tree is also wasteful and ugly. I used the "stash" crate to build my tree which is almost identical to OPs "slab" crate. Stash allows me to use smaller and newtyped indices so that it's impossible to use the index into the wrong tree.
System/Application I don't know what a "Architectural Language" is :/
It's not that the content can't be read, it's that the style choices are unusual, which is distracting. Consider if you styled every third word to be red. It's kind of like that.
We have a lot of seperate deployments for our clients. Haven't had the need to shard it yet, because normally we just throw more cores and ram and it's fine. GC is a little bit of an issue if it's not managed. I wrote a rust application to read hotspot perf data to tune this. Solr's doco and closeness with the apache ecosphere were core reasons. You can really tweak the shit out of it. I haven't looked at elasticsearch in a while but when I did it was highly opinionated and geared towards analytics rather than as a search tool. One thing that has me looking at elastic search are the beats and tight integration with logstash.
Oh yeah, I'm not advocating for `if` + `unwrap` in Rust; there's much better ergonomics around Sum types in Rust. What I meant is that since C++ does not have these nice ergonomics, it could disallow direct dereferencing of `optional&lt;T&gt;` and instead enforce that whenever you call unwrap it panics. If you don't want panics, then you do something like `if optional.is_none() { optional.unwrap() } else { do_something_else(); }` (I don't actually know C++, so this syntax is probably wrong). This is basically what Rust's `match` does, and if C++ does not have a destructuring operation like Rust's `if let` or `match, then this is what the API around `std::optional` should be.
All of the above? I mean, Rust is primarily a system*s* language. It can be used to build complicated systems, and is very good at many moving parts interacting. Rust does have good support for low-level programming / what you'd normally call system programming, but there's nothing stopping it from being used elsewhere. Rust is also quite good at ergonomics, and doesn't have any of the barriers C has for entering the application world. Given the right libraries (which we don't necessarily have yet), I trust rust will be very usable to build applications. As for architectural: this is not a term for a language that I know much about. If you mean it's good for building other languages, then yes, rust fits under this category. It has the functional programming constructs and the safety necessary to make compilers, interpreters, etc. and there are a number of projects already using rust to build other interpreted languages (besides rust itself).
The killer algorithmic feature of a doubly-linked over something like a `Vec` is O(1) splice. Your approach has O(N) splice. In a reply to the original post, I showed [how to write a doubly-linked list in 50 lines of Rust]( https://www.reddit.com/r/programming/comments/7zbi6s/why_writing_a_doubly_linked_list_in_safe_rust_is/dunjytf/?context=0) using an approach that can implement O(1) splice. --- FWIW I think that a (non-intrusive) doubly-linked list without O(1) splice is a pretty useless collection. Something like your approach or a `Vec&lt;Option&lt;Box&lt;T&gt;&gt;` is going to be better than that almost all of the time. With O(1) splice one at least makes the doubly-linked list significantly better than `Vec` based approaches for some situations. This is also something that singly-linked lists cannot support, and why they are pretty useless if you have a `Vec&lt;Option&lt;Box&lt;T&gt;&gt;` or `Vec&lt;Option&lt;T&gt;&gt;` in your toolbox. 
 Timer::default() .interval(durration_1) .zip(stream::repeat(shared_var.clone())) .for_each(|(_,state)| some_actual_future() .... P.S. your reactor.turn is wrong . just use loop { reactor.turn(None); }
I don't feel like comparing Rust to C is fair to C. The C language is incredibly economic in the number of concepts it exposes to the programmer. Rust is more like C++. It tries to include everything short of the kitchen sink (c.f. C++, which includes the sink as well).
Indeed. OP isn't implementing what people mean when they say "a double linked list", but something closely like it.
Since `T` always implements `Into` itself, with the above changes you can just pass in a `Yell` and the `listen` function will use it without cloning.
There's a couple of these libraries (another one is pbf). They have some really annoying/frustrating API decisions such as assuming the presence of threads when you have multiple progress bars. One of them defaults to stdout instead if stderr, which is just plain wrong®. Still nice little libraries, though.
signals
If you don't think you've done enough to be a Rustacean, you are wrong. Somebody will find it useful eventually.
I think you are looking for something like the "rexpect" crate: https://crates.io/crates/rexpect . I found it (it's not mine) because I realized that if you want to build a spawn/expect/send solution you'd probably have to start with some pseudoterminal/pty stuff. And with the search term "pty" on crates.io this is one of the first crates I found. HTH.
Perhaps you could show some example input?
I'm trying to do this: let error_string = if format.is_none() { "Got an UUID from the service but it has no format defined in the OpenAPI file. Please define it as type:string format:uuid" } else { format!("Got an UUID from service but described as {:?}", format.unwrap()) }; I think it is not possible because the types of both branches are different. Is it possible to use &amp;str in both or I must convert both to String?
I find the Rust documentation to be lackluster, I mean: https://doc.rust-lang.org/std/option/enum.Option.html#method.take &gt; Takes the value out of the option, leaving a None in its place. This seems misleading to me because my understanding is that it actually takes the Some(T) or None and leaves a None in its place, as indicated by the return value: &gt; pub fn take(&amp;mut self) -&gt; Option&lt;T&gt; Taking the value out of the option to me indicates that it takes Some(T) and returns T (leaving None in place of it), rather than takes Some(T) and leaves None in place of it. I realize now how I was misunderstanding things, however that is the issue I find with the Rust documentation, even when it is ultimately my fault that I misunderstood it there was an opportunity for clear language to explain things in a way I would not have had such a misunderstanding. Also, https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref let num_as_str: Option&lt;String&gt; = Some("10".to_string()); // First, cast `Option&lt;String&gt;` to `Option&lt;&amp;String&gt;` with `as_ref`, // then consume *that* with `map`, leaving `num_as_str` on the stack. let num_as_int: Option&lt;usize&gt; = num_as_str.as_ref().map(|n| n.len()); println!("still can print num_as_str: {:?}", num_as_str); Although this makes sense to me now it took me a while to realize that this isn't actually a proper algorithm and just happens to work when you realize "10" is a binary encoding. Many new programmers don't even necessarily realize that 10 in binary is 2 in decimal. And taking the length of "10" to make 2 is not actually a correct algorithm, so it makes this example confusing. People shouldn't need to be able to figure out what amounts to a riddle to make sense of the examples in the documentation. I don't know perhaps I am misunderstanding something in these examples. However, these are only a few of many examples I have noted of confusing documentation, and unfortunately I have come to characterize the Rust documentation as being not very good. I don't think the problem is entirely on my end because I haven't had this perception of the C documentation. 
It does not fall into one neat box - it falls into a spectrum. You can divide its use cases into perfect, good, and decent ones.
Yes, both types must be the same. `"something".into()` is the easiest way to do it. Also, you should handle `Option` values differently: let error_string = match format { None =&gt; "Got ...".into(), Some(format) =&gt; format!("...", format), }; is more idiomatic (and omits the unneeded check in `unwrap`).
I, too, disagree with the statement "it's hard to write a linked list in Rust". But it's true that it's not possible to write a *classical linked list*¹ with optimal performance in Rust without using `unsafe`. But that's fine! If everything would be perfectly possible without `unsafe`, we wouldn't need that keyword! As a few others have already said: `unsafe` is there for a reason and using it is not necessarily bad! If you're using `unsafe` to write a webapp or a command line tool, you should probably think twice. But using it to implement a data structure: Sure, go for it! **Safe abstractions** is the key here :) And your kind of implementation certainly has its place. I recently implemented a graph like data structure (triangle mesh) in C++ and I wrote something like `slab`. This is not just a trick to escape the borrow checker, but is actually super useful in certain situations. In this case I could drastically improve performance and memory footprint in comparison to the naive "box every node" approach. And a last little thing. Even if you only work in `unsafe` Rust, a linked list implementation is *easier* than in (for example) C. The list of things that cause UB in Rust is rather small, at least in comparison to C. So even if you use `unsafe`, it's easier to write safe code. --- ¹ When you talk about a *linked list*, people expect certain runtime guarantees for certain operations. For example: worst-case O(1) insertion and split/merge in O(1) (these, by the way, are pretty much the only reasons to use a linked list in the first place). The data structure you show here, while certainly useful in some situations, does not have the same guarantees for all operations. Thus most would not say it's a "real linked list". It is something that closely resembles, but differs in some regards from, a linked list.
Do the black artifacts look like [that](https://youtu.be/_fTkrH-xhII) (at ~3s and ~7s) ? If so I have the same issue I keep track [here](https://github.com/vulkano-rs/vulkano/issues/877). And I have no idea how to solve this
It's not enough to have the same API. It doesn't have the same time and space complexity, so it's not really a doubly-linked list.
You can make it a little less ugly by using `mem::replace` instead: let dummy = replace(&amp;mut self.count, BigInt::zero()); self.count = dummy + BigInt::one(); Btw, from the docs it looks to me like you can also add normal integers to BigInts.
It's a mix of my autocorrect acting up and me posting right before going to bed. Sorry! What I meant to say is that updating the stack pointer is something that an RTOS is likely to have to do. And looking at how the RTOSs written in Rust do it could be a good source of inspiration.
Is there a way to register a hook or something similar so if a child process I spawn with std::process::Command::spawn has died, my main process gets notified?
Ok, I get what you're saying and mostly agree, but let's use a little bit more precise wording to make sure we're on the same page. :) &gt; However, tbh, I still prefer using unsafe, because the behaviour you get is fundamentally similar to what you get in C. Similar, yes. But it's not quite the same. A mistake in a C implementation will cause undefined behavior, but a mistake in Rust will not. If we were to ship this code to Servo, that'd be a very important point to consider. I'm not saying a mistake in safe Rust can be glossed over, but it's a much less vulnerable surface for exploits. &gt; You can still have pointer to deallocated data You can have a pointer to a newer `Node&lt;T&gt;` that is in the place of an old one, not any kind of deallocated data. In C, if you have a dangling pointer - it could be pointing to literally anything and using that pointer might do much crazier stuff (it's UB, after all). &gt; have shared mutable references Not sure what you mean by this. There can't be shared mutable references. You can have two equal indices, though. &gt; The reason it’s safe is because you are technically accessing vec instead of raw memory. The vector is a `Vec&lt;Slot&lt;Node&lt;T&gt;&gt;&gt;`, while raw memory would probably be modeled with`Vec&lt;u8&gt;`. Important difference. &gt; Thus Rust’s ability to find such error at compile time is eliminated. Right. Because this is a fundamentally difficult problem and cannot be as easily solved at compile time. &gt; But no problem was solved. Can't agree. Would you also say that `RefCell` and `Mutex` solve no problems because they eliminate compile time errors? Who knows what's in a `RefCell&lt;T&gt;` - there might be a new `T` in place of an old one we're expecting - isn't that like dangling pointers? &gt; I see unsafe as a feature instead of a design failure. It tells you where to keep an eye on. Good point, but `unsafe` is for mistake-means-UB code, while with slabs we're not risking UB. Note that there are other things outside the realm of unsafe code deserving of a second look, too - e.g. `catch_unwind()`, every `.unwrap()`, indexing errors, locking `Mutex`es, etc. A logic error in those situations might crash the program, cause weird synchronization issues down the road, deadlocks, and so on. And that's totally fine. Not everything can be done at compile time. I feel like you have some sort of grudge with slabs because they look too much like C. But you can applying the same logic to `RefCell`, `Mutex`, `Vec`, ... and declare that they solve no problem either. If you think I misuderstood, could you say what makes a `Slab` scarier than a `RefCell`/`Mutex`/`Vec`?
Does rexpect work well with ssh2 in rust? Or is there a good way to put in password with ssh2?I used to do that with bash and expect.
Isn't this whole thing a result of the (rather unfortunately named) safe-vs-unsafe distinction? It all comes down to the word "unsafe" having a connotation of brokenness (as in *may stab you in the back at any time*). Now people try to implement a doubly-linked list, probably because they have learned other languages this way before, only to hear that "this requires `unsafe`". By the time someone steps in to say "most `unsafe` code is not actually unsafe", the damage often has already been done. How could it be prevented? I think in two steps, the first of which is optional and a little unrealistic: * rename `unsafe` to `override` or create a subset of unsafe that is sufficient for anything not requiring the *actual* unsafe stuff like raw hardware access and call it `override` * do not mention unsafe without an explanation, e.g. "Rust enforces a one-owner-per-memory-block policy and doubly linked lists violate that, so you have to override it using `unsafe`" (note how nicely `override` would fit in here), or have this topic be part of an official programmer's FAQ on the Rust website Also, regarding OP's implementation: In Java terms, this is a wrapper for an ArrayList that makes it look like a LinkedList, which, unfortunately, kind of defeats the purpose :(
You could: a) Return the future of second request in and_then(), like: let work = client.request(req).and_then(|res| { ... client.request(another_req) }); and_then()'s documentation says: &gt; Execute another future after this one has resolved successfully. b) Use the [join_all()](https://docs.rs/futures/*/futures/future/fn.join_all.html) utility function. 
May I ask why stdout is wrong?
The structure is whatever you want it to be really. `cargo new` will create a basic skeleton for you, but from there it's up to you how to organize your modules. For CI/testing you might want to use [trust](https://github.com/japaric/trust) - it's a basically just a bunch of config files that you can copy to your repository, adjust for your crate and get automated CI _and_ releases for just about every architecture/OS under the sun.
I thought it was about increasing productivity by better managing feature toggles :x
Thanks! Can you give an example of minimal library there that uses some best practices (trynig to learn by example here ;) )
Some tools that produce output on stdout (such as `curl`) print progress to stderr, so you can still redirect or pipe the output.
The truth is, a linked-list is very rarely the best container to reach for. You can get O(1) append/prepend with a double-ended vec, for example. Splice is possibly the most iconic reason for wanting a linked-list, and even then I wonder if some other containers would not be better at it. Maybe they won't have O(1) splice, but O(log N) splice is rather good too, and if it allows speeding up other operations it may well be better overall.
Here are guidelines for the [API from the rust lang nursery](https://rust-lang-nursery.github.io/api-guidelines/). And for testing I recommend reading the testing chapter in the rust programming book, under test organization you find [integration tests](https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html).
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://rust-lang-nursery.github.io/api-guidelines/) - Previous text "API" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dur5wsa) 
I haven't really seen any examples like that, sorry :(
The problem is that it is a binary file, I already have the code to read it recursively but I need to save it in a variable.
Hm you are right I would say, though initially I wanted to argue against you I can't disagree with this. My mind simply immediately went to the Rust documentation which indicates otherwise, but upon reflection I actually agree with your characterization more than with what I rote memorized from the Rust documentation, seeing as nothing stops you from doing this with methods that don't have an operator correlate. The second example posted here, by dabross, which I did not read until now, actually demonstrates that it is indeed a limited form of function overloading rather than exclusively operator overloading as the example from the original post is. Really I should have noticed this myself, but as I said my mind just immediately went to those excerpts from the documentation and upon rediscovering them it seemed to support my initial thought, but since reading that documentation my understanding of Rust has actually increased such that I am disappointed I made such a mistake of regurgitating snippets from things I'd rote memorized rather than actually analytically processing the question. 
Thanks! That was helpful. - I have seen a lot of people puting tests seperated in a directory and others integrated in the same file. Can you elaborate on that. - Can you give an example of minimal library there that uses some best practices (trying to learn by example here ;) ) 
Not in the generic sense of some other languages where any function can be overloaded. Basically trait methods can be overloaded and only as far as the trait allows. `x + y` is just syntactic sugar for `Add::add(x,y)` in essence and `Add::add` is a trait method here. You can call this overloaded but you just provide a different implementation for the trait. Note that if a trait provides multiple methods that are required to be implemented you must implement all of those; you can't just implement only one. And unlike traditional overloading this also ties into the type system with parametric polymorphization. In say C++ say you overload `len` for multiple types you still can't call a function with "any type which overloads `len`"; you could in theory if `len` was a trait of which I'm not sure it isn't honestly as it really should be. "operators" except I believe || and &amp;&amp; are just syntactic sugar for trait methods. || and &amp;&amp; are special and short-circuit and thus cannot be overloaded as they aren't sugar for any trait method you can overload which is kind of a shame because they could be overloaded to work conveniently with Result and Option.
You can find good starter issues within the rust ecosystem here, especially the ones tagged with "E-mentor" will be interesting for you. https://www.rustaceans.org/findwork/starters/all This Week in Rust is a weekly newsletter that has a section "Call For Participation", where open source projects ask for help. https://this-week-in-rust.org/ The Rust community is known to be very supportive, you can always ask questions in IRC channels and the community will be happy to help you.
Try changing the input constraint from "0" to "r" ([playground](https://play.rust-lang.org/?gist=edc5f474fd7a3f773f403d7d29c794b3&amp;version=nightly)). Having a numeral constraint isn't specifying what number in the assembly to use (that is just by index), but is actually specifying a "matching constraint". It is used when you want an input to use the same register as an output. You can read more about that here: https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints
sorry for the late reply. **If we need to write a documentation for a documentation, there is something wrong, right?** My point is instead giving static list of links first and then elaborate each, why we can not explain the structure of Rust source code first and then divide things according to structure. Ex. --- ### ▸ In Rust, language elements are implemented not only by std library crate but also compiler as well. Examples, * Primitives : Defined by the compiler and methods are implemented by std library directly on primitives. * Standard Macros : Defined by both compiler and std ### ▸ std library has been has divided into modules, according to the main areas each covered. * &gt; 💡 While primitives are implemented by the compiler, the standard library implements **most useful methods directly** on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **std modules**. This is why you can see char, str and integer types on both primitives and std modules. --- And again sorry, 💡 While ... should place under ▸ std library has been has divided... . as a note. I can not change default styles on Reddit or medium OR extend the capabilities of markdown So there is nothing to memorize even list of links. Only thing we need is let readers to understand how Rust source code has been structured via a concise description of Rust source code([More Info](https://learning-rust.github.io/docs/d7.std_primitives_and_preludes.html)). Correct me if I am wrong :)
Thank you, but now as I take out the values of the enum of which I know the type, I could use match but there should be a better way
Really appreciate you taking the time to write this response! Wow, I must say I disagree on almost everything and find your wording often misleading, so let's try finding common ground here. :) &gt; This is wanting safe code for the sake of wanting safe code. Yes - I can agree with this. Safe code is code where a logic error doesn't cause UB. So I'm reading your sentence as: *This is wanting safe-from-UB code for the sake of wanting safe-from-UB code*. Is that not a good thing? :) &gt; If you create an unsafe memory model that sits on top of safe rust, it's true to say that it is still safe in the sense that it won't violate rust's safety guarantees, but I pose, it is n why do those safety guarantees exist? You're saying that as if the slab memory model on top of safe Rust is basically like C. C's memory looks like `Vec&lt;u8&gt;`, and my memory looks like `Vec&lt;Slot&lt;Node&lt;T&gt;&gt;&gt;`. That's a huge difference. My memory model is not an unsafe one because a logic error doesn't cause UB. If I were to store nodes inside a `Vec&lt;u8&gt;`, now that would be truly unsafe. And it would require opening an `unsafe` block of code. Moreover, note that even implementing a slab itself doesn't require writing `unsafe` blocks, so I'm very far from memory unsafety. &gt; Is it because we wanted to write a safe language? No. There are already safe languages; javascript for example, offers some of the safe safety guarantees as rust. Both safe Rust and JavaScript are safe in the sense that they don't cause UB. And yes, we really do want safety - that's one of the core differences between Rust and C. &gt; So, why not just use javascript? I mean, semantics aside? Because JavaScript is slow. Why not use Java/Go/D/Nim? Because they have a GC, which slows things down by tracing the linked list in order to find dead objects. And why not use C or C++? Because they're not safe. A slab gives you safety (no danger of UB), speed (no tracing GC), and convenience (borrow checker doesn't bother as much). Sure, it's not exactly as powerful as fiddling with unsafe pointers, but it's a great balance of all aspects to consider. &gt; If all you want is safe code, why are you even using rust? There are plenty of other solutions out there. We can apply the same logic to other abstractions: * Why use `RefCell`? It simply avoids the borrow checker's compile-time checks, so why use Rust rather than C? * Why use `Rc`? It avoids RAII-based allocation, so why use Rust rather than a GC-ed language? * Why use `Mutex`? Go has mutexes too, what does Rust offer here? I think a good chunk of your criticism could be applied to basic tools in Rust we use every day and take for granted, too. &gt; The answer is lock free concurrency and automatic memory management. Once you go lock-free, *everything* becomes much more difficult. Yes, slabs are not as applicable in concurrent settings, but I don't think this is a fair point against their use. A lot of things we use are not meant to be concurrent. &gt; That's why the borrow checker exists; that you can have code that provably does not encounter undefined behaviour due to race conditions in highly concurrent code, and not have to worry about manually managing memory. Slabs provably don't cause undefined behavior. Also, Rust doesn't prove the absence of race conditions (different from data races!). Sorry if I'm nitpicking, but it's important to be precise when making such claims! &gt; Do you see the two points I'm making here are completely incompatible with your approach? &gt; * You are manually managing these memory blocks. &gt; * This code cannot be safely concurrent without locks (how for example, would I concurrently walk a graph built this way and modify it?). Honestly, I don't understand. First point: What's the problem with manually managing memory blocks? Again, the blocks are `Slot&lt;Node&lt;T&gt;&gt;`s, not `u8`s. And slabs are far from being as brittle as `malloc`/`free`. Second point: perhaps you'd have a `RwLock&lt;List&lt;T&gt;&gt;` - then you can concurrently walk the graph in multiple threads. If you want to modify elements at the same time, then maybe `RwLock&lt;List&lt;RwLock&lt;T&gt;&gt;&gt;`? But if you want to concurrently walk the graph and modify the graph itself, then I'd have to ask what *exactly* you want. Yes, then you probably do need to write unsafe code. It's going to be messy. But that's taking it way too far - trying to dismiss the use of slabs by complaining about lock-free concurrency or concurrent reads and modifications is not really fair. Data structures like `Vec`, `VecDeque`, `BinaryHeap`, `HashSet` are not concurrent either. Why should `Slab` be? &gt; So, in order to remain safe you take away the two reasons for using rust. &gt; I question, if that trade off is worth it. I say yes. If you need a single-threaded graph data structure, a binary search tree, or something like that - consider using slabs. Slabs are fast (see the numbers in the post), convenient (don't have to call `RefCell::borrow_mut()`, don't have to call `Rc::clone()`, don't have to open `unsafe` blocks), and safe (easier to get through reviews, no danger of UB, you can sleep better at night). Not trying to say you should always use slabs (*everything* comes with tradeoffs, even Rust the language), but in my opinion, slabs are overlooked way too often. They also get plenty of unfair criticism and are approached with too much skepticism... like right now, haha. :) &gt; Rust is built on the idea of 'safe abstractions'; that is, not that there is no unsafe code ever; that's not possible. &gt; Instead, we quarantine unsafe code in safe apis, and managable, auditable unsafe blocks. &gt; You can already do what you want using a safe api; just use Rc or Arc; there are some other abstractions out in the wild that offer alternative solutions. Agreed, but allow me to bore you for a little longer. When you reach for `Rc`, that usually means you also need `RefCell`. And all those `.borrow_mut()` and `clone()` can get tiresome. That's a problem for quick prototyping, and may discourage beginners - it sure did discourage me! &gt; ...but really, my point is: You're right, it's not awesome to pick up rust, hearing its safe, and immediately be told 'use unsafe to do that'... but that's the right solution for some problems. Rust is absolutely not an arbitrary programming language you can just write C in with a better compiler and tooling. Agreed. So let me put it this way. I wanted to implement a splay tree in Rust. Just for kicks, let's see if this Rust language is any good! I used a slab and had a lot of fun - it was a pleasant experience and the end result was faster than an idiomatic C++ implementation. I thought: *wow, Rust is easy, safe, and fast!* Now, if someone were to tell me to use `Rc&lt;RefCell&lt;_&gt;&gt;`, writing code would be kinda tiresome and the end result would be slower than C++. I'd think that's a pretty high price to pay for safety. And if I tried writing unsafe code, I'd be immediately thrown into the scary waters of advanced Rust. Writing unsafe code is not pleasant at all, and I say that as someone who almost excusively codes in unsafe Rust. :) But I don't think slabs are only useful for toy examples or learning Rust, either. Rustc heavily uses arenas, which is kind of a similar thing. The `regex` crate represents nodes in the graph using indices. Way Cooler represents the window tiling tree using petgraph, which is basically a slab. And many others use petgraph, too. It's a legitimate solution to many problems. &gt; It restricts what you can do in exchange for the benefits it offers; and if you want to work around those restrictions you have to ask: &gt; * Is this work around for a specific perf reason? &gt; * Is this work around because of low level system interaction? (eg. library binding) &gt; * Is this work around just because doing it the rust way is unfamiliar? &gt; * Is this work around just because I want to avoid unsafe? Not really disagreeing, but I find this phrasing unfair. You're trying to say that slabs are just a workaround, while they are useful in the real world and have a ton of nice properties. I actually think slabs sit in some kind of sweet spot: they're easy, fast, safe. Need more speed or flexibility? Use unsafe, but be careful. Want stricter compile-time checks or use the global memory allocator? Use `Rc&lt;RefCell&lt;_&gt;&gt;`, but be prepared for some boilerplate. &gt; A graph is a powerful and useful data structure; but it's not easy to implement in rust. That's just the reality of the situation; arbitrary references to arbitrary nodes which can be read and modified from either directly directly conflicts with rust's memory model. Yes - that is spot on! &gt; Why do we need to pretend that isn't the case? It is the case; what you have to ask is does rust offer you something that makes that trade of worth while? It is the case. I guess the great thing about Rust is that you have three options with different tradeoffs: (1) unsafe code, (2) `Rc&lt;RefCell&lt;_&gt;&gt;`, and (3) `Slab`. I'm just a bit frustrated that the last one is so often given a pass. &gt; Linked lists are just something that people often pick up as a basic data structure, and the crappy linked list you make on your 'day 1 of rust' isn't going to be a generic linked list you'll use forever; it's just a toy to explore the language. &gt; Just use Rc for that. I don't know... we have a great guide on the `Rc` method [here](http://cglab.ca/~abeinges/blah/too-many-lists/book/fourth.html), but following it as a beginner was an incredibly painful experience for me. Gankro's writing is awesome - but just look at all the borrow checker errors in the book. I know people who've literally given up on Rust for this reason. Honestly, we'd probably be better off by offering `Slab` for the 'day 1 of rust', and `Rc` for the 'day 2 of rust'.
&gt; this isn't actually a proper algorithm It's supposed to be an example, it doesn't say anywhere what it is supposed to do.
.. you can? Don't I feel silly.
The difference is that they would then have to implement the infrastructure and control the root of trust themselves, which is a huge responsibility. Besides, both Debian's and Microsoft's systems have had security and service issues.
&gt; It all comes down to the word "unsafe" having a connotation of brokenness (as in may stab you in the back at any time). I'd use the word *dangerous* instead of *broken*. If you make a mistake in an `unsafe` block, you might run into UB. That is a concern for security and debuggability. Memory safety is a big deal and `unsafe` blocks should be at least a little bit scary. That's why we say things like: *yes, a panic will crash your program, but it won't eat your laundry*. Or, more seriously: it won't leak sensitive data, serve as a critical vulnerability, or silently corrupt random memory and keep the program running for hours until something weird shows up. &gt; Also, regarding OP's implementation: In Java terms, this is a wrapper for an ArrayList that makes it look like a LinkedList, which, unfortunately, kind of defeats the purpose :( Just to reiterate: I'm not claiming slabs should be *always* used. The whole point is that it's a great compromise and the typical concerns people throw around are often not a problem.
The way I see the "intended" usage of the std streams is: stdin and stdout are like two ends of a processing pipeline. Stderr is an extra, a "side channel" that should be used not only for errors, but logging, debug messages and other status updates. The point is that stdout should be reserved only for the actual processed output/result, whatever that is.
Yes but I'm just saying that I personally found it to be confusing when I was trying to learn about .as_ref(), to see an example like this that I then had to spend thought cycles on figuring out what was happening. I find this is very common for me when I read the official Rust documentation, to have trouble understanding it for various reasons like this. I am not trying to per-se critique the Rust documentation, but am just presenting myself as a case study in the confusing nature of the Rust documentation for one individual. 
Care to expand on that? Most of the work is happening above the level of language changes
True. In retrospect, I probably should've chosen a different data structure (maybe a BST with backreferences) to argue for using slabs.
A real answer? get out
&gt; The whole point is that it's a great compromise I respectfully disagree. Linked lists do not exist because they are easy. They have a very specific performance profile, namely guaranteed O(1) prepend, append and split, also O(1) delete and insert if you have a pointer to the position. What you present is a vector wrapped to look like a linked list, but sharing none of these characteristics. One application of a linked list is to be able to iterate over a potentially HUGE dataset and append desired elements of it to your list *fast*, which is not generally possible with your implementation. And imagine having to move a 3GB vector because you want to append but malloc put another thing at the end of your block. You don’t run into this with a linked list.
sorry for the late reply. &gt; First, if the guessing game answers the wrong question, what is the right question? * A newcomer read a documentation because he/she need to know/ learn something of an unknown system, right? * But instead of explaining things from basic to advance, **just after the start**, we are telling the advanced capabilities of the system to show newcomers how capable our system is. * If the newcomer already has same type of experience -&gt; **Wow! This is good**. * If the newcomer doesn't have same type of experience -&gt; **Oh no! This is so complex.** &gt; Second, while many crates are single-person affairs, there are some good examples of projects where maintainers managed to attract contributors even without financial motivation. * points are not inter-connected each other and not everything directly connected to the quote. I just tried to hi-light most important idea of the section via a quote, at the beginning of each section(except one place). * We still not in the track, compared to Golang, Swift, Kotlin which are backed by tech giants like Google, Apple and etc. We need to compete with them, right? &gt; Third, we've come a good way, but there's still a lot to do when it comes to... * I agree with you. By writing this also I just tried to push Rust forward at least few small steps as I can. And [as I mentioned in the first comment](https://www.reddit.com/r/rust/comments/7zoy1h/pushing_rust_to_2019/duplgh1/) and as I mentioned everywhere I shared the link of the medium post, * I have no intention to offend anybody. * Now Rust is not a new language,right? So we need to go forward by fixing our mistakes before its getting too late :) 
@miquels, thanks for great pointer to https://crates.io/crates/rexpect . I should have searched harder on crates.io.
Things for distributed systems/DevOps
Ok - thanks
We'll have to just agree to disagree; I hear what you're saying, but I simply don't agree. Rust solves a certain category of problems. It has been written very carefully to do so. If you implement your own manual memory management system on top of it, you may as well being using some scripting language written in rust, not rust itself. &gt; What's the problem with manually managing memory blocks? It's fundamentally at odds with the memory model in rust. If you want to do that, just use C++. &gt; But that's taking it way too far - trying to dismiss the use of slabs by complaining about lock-free concurrency or concurrent reads and modifications is not really fair. &gt; Data structures like Vec, VecDeque, BinaryHeap, HashSet are not concurrent either. Why should Slab be? Slab is basically an object allocator in a way that makes the reference checker irrelevant (and thus, rust's concurrency model irrelevant). Once again... that's a fair thing to want, but if that's what you want, why use rust at all? I'm not saying `Slab` and arenas have no place... but I would expect that most people, day to day, would never use them, or want to use them.
The reason slab is not _really_ safe: extern crate slab; use slab::Slab; fn main() { let mut slb = Slab::&lt;u32&gt;::new(); let ptr = slb.insert(12); // We inserted 12 and got 12 - this is OK. assert!(slb.get(ptr) == Some(&amp;12)); slb.remove(ptr); // We removed it so now it's empty - it's a dangling pointer, but at least // an explicit one, so this is also OK. assert!(slb.get(ptr) == None); slb.insert(13); println!("What is ptr pointing to? {:?}", slb.get(ptr)); } (in playground: https://play.rust-lang.org/?gist=d356e7775d895013dc736fc9214ac222&amp;version=stable) When we `slb.remove(ptr)` we were left with a dangling pointer. At first, this did not seem like a problem - slab uses slots so `slb.get(ptr)` returned `None` instead of some arbitrary data. But - when we added another value to the slab, it happened to put it in the same place `ptr` was pointing to (because this slot was vacant), so now `ptr` is pointing to some arbitrary data. We never assigned `ptr` to a slot that contains `13`. We never set the slot pointed by `ptr` to 13. And yet - at the end of the program, `ptr` points to a slot containing `13`. My example is simple enough for this behavior to be predictable and reproducible, but in the wild this can happen quite randomly. Now, you may say that it's better because the data in the slab is `T` and not `u8`, but I think it's just making things worse: I'd rather have my code crash because the struct I'm pointing to is not in the correct layout (because it has data of some other struct) than succeed but yield wrong results.
Aside from the replies from /u/ruuda and /u/GolDDranks, I wonder if the correct solution is to write the progress bar to directly to the tty.
True - I don't think we're actually disagreeing. :) A slab is not the right solution for use cases you mention. Although, if you share a single slab among multiple lists (like how rustc shares arenas) and reserve memory in advance, it could be just fine. But in less extreme scenarios, e.g. if one is building a widget graph (see a similarly controversial [blog post](https://hackernoon.com/why-im-dropping-rust-fd1c32986c88)) or something like that, slabs are totally okay. Even [conrod](https://github.com/PistonDevelopers/conrod) (a 2D GUI library) uses a vector and indices. I probably should've focused on that rather than doubly linked lists.
1. So you think an easier example would be better not to drive anyone away with complexity? 2. I didn't get your point about the quote, perhaps it was misdirected? There is absolutely no need to *compete* with any other language – Rust's mission, it's *raison d'être* if you will, is to make systems programming both safer and more accessible. So Go, Swift or Kotlin win mind share? Great, more people writing code in safe languages! 3. 'Fixing our mistakes' is easier said than done. Worse, it's already hard to build consensus what the mistakes are, let alone how to fix them. So while I cordially agree that we need action, care must be taken to ensure it's getting in the right direction.
👍 to what /u/nickforall wrote, I'd just like to add that you can ask here and post your interests.
Here's my take on it (generally speaking): Rust is definitely a systems programming language as you can go as low as C and C++ (two other popular systems programming languages). With that being said, you also have to deal with all of the same low-level (although safer) "concepts" like pointers, aliasing, ownership, borrowing, etc. You know, things that most "application languages" don't require you to deal with explicitly ("*with great power, comes great responsibility*"). Java, C#, and "scripting" languages like Python are good examples of "application languages" as most of the low-level concepts you have to deal with explicitly in Rust (and C and C++) are handled for you implicitly. These languages dominate the "enterprise" world because, for the most part, you can just focus on writing your logic instead of worrying about the lower-level details. Although it's true that Rust can be used for high-level personal and business applications where Java and even scripting languages like Python shine at, the same can also be said for C and C++. However, that doesn't make C and C++ "application languages" per say. Same goes for Rust. I'm not sure what an architectural language is.
Not saying that slabs are bad, they certainly have their use cases, so in that part we do not disagree. However, something implemented with slabs is not a linked list and should not be called that way either in my opinion. This is one of the situations where it would be better to just admit that yes, Rust cannot check doubly linked lists for correctness, and because it cannot, because you have to use `unsafe` for a true linked list, it is definitely not easy to write one.
I see where you're coming from, but still think these claims are unfair because arguments can go both ways. Allow me to use your words to argue against `RefCell` in the same way (no snark intended!). :) &gt; If you implement your own manual memory management system on top of it, you may as well being using some scripting language written in Rust, not Rust itself. If you use reference counting and your own manual borrow checking on top of it (`Rc&lt;RefCell&lt;_&gt;&gt;`), you may as well be using some scripting language written in rust, not rust itself. &gt; It's fundamentally at odds with the memory model in rust. If you want to do that, just use C++. `RefCell` is fundamentally at odds with the borrow checker in Rust. If you want to do that, just use C++. &gt; Slab is basically an object allocator in a way that makes the reference checker irrelevant (and thus, rust's concurrency model irrelevant). `RefCell` is basically a runtime lock in a way that makes the borrow checker irrelevant (and thus, rust's aliasing + mutability model is irrelevant). &gt; I would expect that most people, day to day, would never use them, or want to use them. I would expect that most people, day to day, would never use `RefCell`, or want to use it.
I really like immovable generators. I was recently running into the borrowchk error of having a borrow between yield points, despite the generator owning the value. This API feels pretty clunky, but it gives users a lot of freedom. I'm kind of conflicted
Immovable types are regularly requested, even outside of the generator/coroutine space. It's a very natural expansion of the current state of things.
&gt;The C language is incredibly economic in the number of concepts it exposes to the programmer. This was true back in the days of K&amp;R, but modern C feels more than a little dishonest about the edges of defined behaviour. Sure, it's all there in the specification (better than Rust currently) but there's nothing in the language driving a novice programmer to engage with or understand those rules. You have to get to the "omg, compiler bug!" stage or have a strong mentor or teacher. &gt;Rust is more like C++. It tries to include everything short of the kitchen sink (c.f. C++, which includes the sink as well). I feel that Rust tries to be suitable for most application tasks ("if you need to write something you wouldn't be crazy to write it in Rust") but not "include every decade's popular paradigms from inception to present" the way C++ does. Time will tell though.
While splice into the linked list may be cheap, you pay a large cost chasing pointers to get to index to the point where you want to splice. 
Remacs has plenty of interesting things that need to be done. https://github.com/Wilfred/remacs
Linked lists (and similar structures) are pretty useful if you're trying to implement a lock-free algorithm. The fact that pointer updates can easily be made atomic without requiring a full mutex, and that you can modify different parts of a linked list without interfering with each other, is quite useful.
So, I’m literally mystified about strings; specifically about OsString and OsStr on Windows. Windows uses an encoding that is almost like UTF-16 but supports codepoints outside the BMP using surrogate pairs. According to the OsString documentation, it contains strings in a host OS-compatible representation. My question is: it’s of course possible to get an &amp;OsStr slice from OsString, but how is it possible to get a &amp;str slice from &amp;OsStr using to_str()? The binary representations of UTF-8 and UTF-16 are fundamentally incompatible, so you can’t possibly transmute the other slice to other. And since the conversion is done between shared slices, it should also be impossible to allocate a new buffer for doing conversion (at least, without leaking memory). So how does to_str() do its magic trick? P.S. I can imagine only one way of doing this: OsString actually stores the string in WTF-8, which means it isn’t binary-compatible with Windows strings, but “logically compatible”. If that’s the case, the documentation needs some brushup to make this clear.
&gt; I’m not sure what to say, you’re just making a bunch of arbitrary assertions. I'm so confused. Claiming that using a `Slab` is fundamentally at odds with Rust's memory model seems like an arbitrary assertion to me as well, which is what I'm trying to hint at. By the way, are you aware of the additional runtime check presented in [this comment](https://www.reddit.com/r/rust/comments/7zsy72/writing_a_doubly_linked_list_in_rust_is_easy/durcwqw/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=rust)? It might make you a bit less skeptical of slabs. Rust is at times overly restrictive and sometimes we have to break its chains: * Move semantics/lifetimes are bothering you? Use `Rc`. * Aliasing/mutability is bothering you? Use `RefCell`. * Both are bothering you? Use `Slab`. All of these tools also have pitfalls: * `Rc` can create cycles and leak data. * `RefCell` can cause unexpected panics. * `Slab` can cause a little of both. These are the tools we have. Use what you need. None of those are fundamentally at odds with Rust. The only thing Rust doesn't forgive is UB. &gt; Rc wraps a single object; because it is a well made abstraction it obeys the borrowing rules and drop rules rust expects; no manual management is required, and concurrency works as you might expect (with Arc, at least). `Slab` is a well made abstraction, too. It also obeys borrowing rules (e.g. you cannot hold two `&amp;mut` references to two objects in it) and drop rules (dropping the whole slab drops all objects in it). I'd say `Rc` still requires manual intervention. If you're forming a cycle, you must make sure to use `Weak` pointers at appropriate places (manual work at allocation time). You must also take care not to accidentally leak data and cause deep recursion when destructing long chains (manual work at deallocation time). &gt; Why not? Its the blessed concurrency solution. Nitpicking, but you probably meant *shared mutability* solution. But again, saying that something is *blessed* puts it on a pedestal, and I'm not sure why that's necessary. It's one of those assertions I have a problem with. And they're just not fair. Is `Slab` not blessed? Well, admittedly, the whole motivation of my post is to give it a blessing it deserves... :)
Are self-referential generators Send + 'static? 
True. However, it should be noted that lock-free data structures basically never have cycles, so that helps a lot. :)
Not to mention that you might be chasing that O(1) for splicing only for your iteration performance to be destroyed by cache misses, which wouldn't happen with a contiguous-memory data structure.
Check out the solution in [this comment](https://www.reddit.com/r/rust/comments/7zsy72/writing_a_doubly_linked_list_in_rust_is_easy/durcwqw/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=rust). You can add an additional runtime check that verifies you're really accessing the object you want, and not a newer one that has replaced it.
Can I define an impl of a Trait for a generic iterator with items of type T and &amp;T? I have successfully defined impl&lt;'a, T&gt; MyTrait for T where T: IntoIterator&lt;Item = &amp;'a MyItem&gt; {...} But for some reason I have not gotten this working unless I collect the iterator to a concrete type first. I've also managed to implement; impl&lt;T&gt; MyTrait for T where T: IntoIterator&lt;Item = MyItem&gt; {...} This works fine for processing my iterator as-is, but it seems inflexible forcing ownership in the iterator, when the implementation as such does in no way require it. Is it possible to combine the two implementations somehow, to work for both owning iterators, and iterators of references? I've tried with Item = AsRef&lt;MyItem&gt;, but the compiler rejects it due to "not having constant size".
Thanks for sharing! But regarding indices, those are why we prefer iterators now to a index incrementing for loop. For me, all the “it’s hard to write some data structure in Rust” posts are not literally about writing that specific data structure, but showcasing how Rust’s borrow-checker and ownership concept affects your coding in potentially unexpected ways. Ownership makes a naive linked list in Rust behave like an FILO queue, and a naive doubly linked list impossible. Analogous might be Haskell, where a linked list behave more like an FIFO stack, while a naive doubly linked list with pointers is also impossible. I think more important than performance tradeoff is this cognitive tradeoff. Maybe there’s a proof of a naive linked list in the contrib of ATS somewhere…
Thank you! And thanks to everyone for their responses. &lt;3 This discussion was a learning experience for me, too! And I have to admit being wrong at certain things - for example, I overlooked the fact that you can't do `O(1)` splice, unless multiple linked lists share the same slab. Sorry if the title of this post is a little click-baity, but I just *had to*. :) Hopefully the discussion was fruitful for everyone. And, once again, I'm not trying to pitch `Slab` as the only universal solution for these kinds of problems. It does bring some important drawbacks to consider. In the end, I just wanted to shine some light on this approach and nudge the community toward recommending it to beginners more often. If you find `Slab` useful, use it, and if not, then by all means feel free to look for alternatives.
Or alternately use `cargo-watch` and `cargo watch -x 'test'`
I made a PR for that example just now: https://github.com/rust-lang/rust/pull/48509 If there are any other doc issues that you can remember, please feel free to let us know / open a PR. You can also reply to this comment, and I'll try to handle the fix for you.
[This](https://doc.rust-lang.org/book/second-edition/ch15-06-reference-cycles.html) may help.
It would be nice if https://doc.rust-lang.org/regex/regex/index.html was more fully featured, back references for example.
No worries! The poster session was incredibly cramped; I didn't get to see half the posters I wanted to either. Zero copying helps quite a bit, especially from a malloc perspective, but we also use faster hash functions such as xxhash and some other tricks to speed up where we can. Microbatching on columns also helps a lot to minimize the cost of virtual functions for each feature processor. We've also tuned some core functions, such as dtoa, to run faster in the presence of user specified precision. Lots us of little tricks that ended up adding up. Still, I was impressed with how much performance they got out of the jvm with keystoneml. My big problems with keystoneml is how painful it is to work with multiple feature channels, which we do all the time in our search ranking work, and that it really isn't usable for online prediction or embedded tasks. That it's jvm only is also a big loss, considering where most if the learning algorithms live these days. Arrow is an interesting idea I hadn't considered. I'll look into it some more.
If you come from a C background nix or Corrode project is interesting.
**Simplicity** + **Speed (Runtime)** My solution uses the `Matrix` struct from `pathfinding`, the cartesian product from `itertools`, and `bytecount`. It needs around 130ms to run both parts of the challenge on my laptop. https://gist.github.com/samueltardieu/c63bc32bf3bc3b30f57c9d8fc8862bd4 
Corrode is a) written in Haskell and b) effectively unmaintained. Not a good starter project.
Does this work: impl&lt;T&gt; MyTrait for T where T: IntoIterator, &lt;T as IntoIterator&gt;::Item: Borrow&lt;MyItem&gt; {...} Edit: `AsRef` -&gt; `Borrow` 
For the tests, tests inside a file are unit tests. They are there to confirm that your feature works as expected, and they guide you to design a good structure if you follow a Test-Driven Development (TDD). Basically you write an unit test -&gt; you implement -&gt; you test. Rinse and repeat. For the tests in a separate directory, they are integration tests and they are put into the tests/ directory. Those tests are there to confirm that your public API is well organized and that all your structures can work together. Concerning the bests practices, you can follow: - the Rust API guidelines - the Rust unofficial design patterns - the "Elegant library API" website, that you can find in the "external resources" of the Rust API guidelines website. - the "Statetype" pattern. They can help you to structure your code. But please, please, if you want to create a library, don't over-engineer it. Yes, some crates are cool and some patterns look awesome, but just try to be straightforward in your implementation, without being too restrictive. You will thank you later, and everyone will be happy to understand your library easily, without having to understand walls of unnecessary abstractions.
You can save an allocation in the static string case by using `Cow`: use std::borrow::Cow; // more idiomatic form for conditional unwrapping let error_string: Cow&lt;'static, str&gt; = if let Some(format) { format!("dynamic string").into() } else { "static string".into() };
https://github.com/actix/actix
Whew! That's quite the solution. I think I'm agreeing with you at this point that it's probably best to leave conversions to the user. Thanks for the pointers.
&gt; Rust is absolutely not an arbitrary programming language you can just write C in with a better compiler and tooling. I disagree with this point. Writing C in Rust is no worse than writing C in C, apart from the more verbose syntax. It's important to keep in mind that 100% of code in C is unsafe, so Rust occasionally requiring unsafe to do the same things is not a failing of the language.
The ability to target arbitrary versions of a platform would be nice. For example, I like to be able to target Android API 17 vs API 21 and have the ability for crates (like `libc`) to expose functionality based on this.
I don't know a good example. Most of them are bigger and take time to read. The standard library is well written and I find in it many tips for optimizing my code. Well regarded is also ripgrep from burntsushi and crates from tomaka. Here is another link for some [best practices](https://pascalhertleif.de/artikel/good-practices-for-writing-rust-libraries/) Some Additional Best Practices - A good documentation makes a crate usable. For example, I was able to use the chrono crate in no time because it has many examples which show how to use chrono and what it has. - Implement traits from std if you use std. It will make it easier for you since you shouldn't reinvent if not needed. As I said the std is well documented and other can look up what these do without you having to explain it again. Additionally, you get to use other traits by doing so. For example, implementing From is better than Into most of the time because you get Into for free if you use From. (Another example would be Display giving you access to ToString). - Simple access with Re-Exports. Having to go really deep into a module for a struct is annoying. With re-exports you can make structs and functions visible in your documentation and keep your internal library structure in tact. (See the documenation chapter in the rust programming book.) - Keep your code clean and well formatted. - It is not a good practice to load a module with a wild card. Try to implement a prelude module to keep your users from loading everything. - Make a tutorial/guide or example that shows best practices how to use your crate well. When you think about how people would use it, you will notice where your API is unconvenient or helpful. - Decide how much you want to abstract. As /u/Clopobec said, keep it straightforward. If your code goes low-level and then high-level, maybe consider splitting your crate into a core crate (lower-level, bare bones) and a crate for user (higher-level, helper functions, simple abstractions). This way other people could build on the core and create their higher level abstraction or use your public API.
Is there a crate or even a std lib implementation of a single reader single writer construct? The idea being to use it for keeping tabs on threads, who would each have exclusive write access to the structure and then a reporting thread would have access to read it at certain times, without needing mutexes. I know this sort of flies in the face of one of the core ideas of the borrow checker, but this would be fully expecting the immutably borrowed value to change.
Awesome. How far is tantivy from working on stable?
`RngCore::try_fill_bytes` returns `Result&lt;(), Error&gt;` and needs to be object-safe, i.e. `Error` needs to be `Sized` with and without `std` or `alloc`. I'm not sure of a good solution. We *could* try putting the method behind `#[cfg(features="std")]` since we also have `fill_bytes` (which panics on error). But the current solution also works nicely. `rand`'s error already supports `std::error::Error` so automatically supports `Fail`.
Can you describe the box and how you got in it? 
I disagree. The linked list is one of the simplest data structures to learn. Yet you can't just build one in Rust. On the surface that looks silly, and that is the issue here.
Fair enough, I should have been more precise. It could easily have one in the context of Rust based "differentiable programming" tool. It could never be the one solution for machine learning in Rust. That said, deep neural nets get the buzz for a lot more than the name. You may recall that the name was mud for many years until deep neural nets dramatically outperformed other techniques in various image classification competitions. 
This is pretty neat. This is used in a Vala for elementaryos. They have bindings that go from Rust -&gt; C -&gt; Vala.
I’ve been enhancing the plugins support in `spectra` and I’ll continue enhance it and blog about it, because it’s fun! :)
A couple of things. Import `juniper_codegen` (also add it as a dependency in `Cargo.toml`): #[macro_use] extern crate juniper_codegen; And remove `#[graphql(_internal)]` before the `Episode` enum. This seems to only be necessary within juniper itself.
In C++ you can declare the destructor of a class `private`, which prevents users from directly "dropping" instances of that class. Can't you do something similar in Rust?
Yep that's exactly the same issue as I have. I wish I could help out, but I have no idea where to start. I also am on X11 with Intel HD Graphics 520, so it's related to that. I'm on Arch Linux with vulkan 17.3.2 I think.
More broadly, I think the "portability" effort described here will also help the situation https://internals.rust-lang.org/t/a-vision-for-portability-in-rust/6719/56?u=anxiousmodernman My understanding is very little of Go's standard library links to libc or depends on C. This makes porting easier, and also cross compilation? There have been pure-Rust standard library ports attempted, but it's really hard to keep up with a totally parallel rewrite.
Really forward-looking stuff. I'm glad System76 seems serious about building these kinds of utilities. If any higher-ups at System76 see this: more rust! 
Newer languages subsume many categories and paradigms. You can write web servers in Rust, you can write video games in Rust, or operating systems, or you can write things that you might use a bash script for. Rust has features from functional programming, but eschews the purity of Haskell. Rust gives the programmer powerful abstractions. This matters a lot for higher level libraries, and might be what you mean by "architectural". In Rust I can write a trait with specific constraints, and users of my library must follow my patterns. This kind of "designing with types" let's authors of high level components feel more comfortable that their components will be used correctly. Rust has learned that a first class package manager is a language feature. Rust is harder to learn, but the difficulty pays off. One can be assured that certain kinds of nasty bugs are eliminated. I like this question. But be prepared to have all your categories challenged by Rust. It's challenged my own preconceived notions of what a language can be.
Awesome, thank you! Although, how does this differ from the following? (That does not compile) impl&lt;T&gt; MyTrait for T where T: IntoIterator&lt;Item = Borrow&lt;MyItem&gt;&gt;, 
What are you interested in? What kind of open source software do you use? It's easiest to start down this path by working on things you're already interested versus choosing a random project. I think most Rust projects would appreciate help, and you could just browse crates.io to find them. But it's more likely that you'll be motivated to stick with a project if you find one you're interested because you use it.
No. And that would lead to problems: Would it exist, say as a type "NonDroppable", you can drop an Option&lt;NonDroppable&gt;, which would also have to hold that invariant. Now, that sounds like an easy fix, but now consider a function that takes `Option&lt;T&gt;`. T could both be instantiated as a NonDroppable type or as a droppable one and in both cases behave differently. For details, I recommend this: https://gankro.github.io/blah/linear-rust/
How do you imagine a better way than match, I'm curious ?
NIH
Good point. Cool link, thanks!
&gt; Right. Depends on what exactly the word safe means. Rust's definition is: safe = UB is impossible. A dangling pointer is an undefined behavior - you can't define if "dereferring" it (= looking it up in the slab) will yield `None` or some arbitrary value. Even if from the hardware/OS point of view it's perfectly defined (you request a thing you get a thing), from the program's logic PoV its undefined. Unless, of course, you consider "something arbitrary will happen depending on other things that happen in the process IDK" an acceptable solution to UB. &gt; Accessing an incorrect object inside the bounds is like accessing random allocated memory. Accessing an incorrect object will cause logic errors, but not UB. But I'm not accessing some random slot - I'm accessing a slot I got from `.insert()`. This is impossible in any memory-safe language (unless it has some unsafe mode, be it explicit or implicit) and treated as undefined behavior in memory-unsafe ones. &gt; Accessing random allocated memory will cause logic errors in addition to potential UB, and that is the worse option. How is UB worse than logic errors? Logic errors are the worse kind of errors because they are hidden. UB can either cause a crash or a logic error - saying that it's worse is like saying certain death is better than the possibility of death because you know what's going to happen. Also - as I've mentioned before - a dangling pointer **is** an undefined behavior. &gt; Fortunately, there actually is a good answer to your complaint - use versioned objects: * If we are going to add runtime costs to solve this, why not just use `RC`? * If we are going to trust the user of slab to guarantee safety over unsafe memory model and wrap it with a safe API, why not just use `unsafe`?
I' sure many people here would like to help, but without knowing what a `Graph&lt;'a&gt;` is, and what `Graph::neighbors(???)` does, it's hard. Can you put together a minimal [playground](https://play.rust-lang.org/) example that gives you the error you would like to resolve?
I don't think the whole Graph trait should have the lifetime, just the method(s) that use it like neighbours, maybe try that? 
Yes, dependencies are per-project (thankfully!) and you can't globally install libraries.
Yes dependencies are per-project, specified cargo.toml. Cargo run/build/test all download the dependencies to the build folder before compiling the project. Cargo install is just for adding extensions to cargo which I assume is what you're referring to? If you just want to look at an existing project, you'd just want to do a git clone then open it up and do cargo run
Yes, dependencies are per-project (more specifically, wherever you have a Cargo.toml). This allows you to depend on different versions of the same library for different projects without any problems. If you want a command line interface rather than editing Cargo.toml directly, try [cargo-edit](https://crates.io/crates/cargo-edit)
Thank you!
Thanks. Looked at cargo-edit, but getting dependency build fail for semver-parser (installed Rust via Homebrew): /Users/me/.cargo/registry/src/github.com-1ecc6299db9ec823/semver-parser-0.7.0/src/version.rs:56:26: 56:69 error: the `?` operator is not stable (see issue #31436) Seems like semver is requiring semver-parser-0.7.0 while 0.8.0 is the latest. Was going to open a github issue. edit: I misread, 0.7.0 is latest version of the package. Maybe it's worth upgrading rust? $ rustc --version rustc 1.11.0 (9b21dcd6a 2016-08-15) edit2: uninstalled Homebrew Rust, installed using sh.rustup.rs and now it builds!
I think I need the lifetime on the trait because I have an associated type that needs the same lifetime. Check my other answer for the complete example.
Basically what you are doing in your C code is atomic operations. However, the older C standards don’t have that concept, so your program is racy and likely to have Undefined Behaviour. To achieve atomic operations in Rust, check this out: https://doc.rust-lang.org/std/sync/atomic/
If the struct is very small (e g just a number), you can use `AtomicUsize`.
BTW - if you want to have single-file Rust programs, you can use [cargo-script](https://crates.io/crates/cargo-script#self-executing-scripts). You'll still have to specify the crates you are depending on for each such `main.rs` though. But - if you are just playing around, you are better off using a full Cargo project. That way, you'll get proper tooling support (like [RLS](https://github.com/rust-lang-nursery/rls) and [cargo-edit](https://crates.io/crates/cargo-edit))
Thanks for the tip. I'll stick to stable then!
Does it *need* to be an associated type? I can make it work without it ([here](https://play.rust-lang.org/?gist=2a5f61ca5775f2e0bec528e3df24c265&amp;version=stable)). If you're using a `Box&lt;Trait&gt;` anyway, the associated type doesn't give you much.
You probably want your `Graph` types to be iterable for all `'a`, rather than for just one particular `'a`. You can do this using [higher-ranked trait bounds](https://doc.rust-lang.org/beta/nomicon/hrtb.html), like [this](https://play.rust-lang.org/?gist=e2acc0edd4058cf926361f1301b759a5&amp;version=stable).
You should recruit in /r/playrust.
Please refrain from language bashing.
That's because you're asking the compiler to consider `Borrow&lt;MyItem&gt;` in the context of a concrete type (using equality comparison on `&lt;T as IntoIterator&gt;::Item`), but a bare trait type isn't concrete. When you declare `where T::Item: Borrow&lt;MyItem&gt;` you're saying you want the `T::Item` type to *implement* `Borrow&lt;MyItem&gt;`, but the item type itself can be anything that satisfies that trait bound. Now, something like `where T: IntoIterator&lt;Item = &amp;Borrow&lt;MyItem&gt;&gt;` *technically* works because you're asking for an iterator of `Borrow&lt;MyItem&gt;` trait objects (pointer &amp; vtable), but this is more cumbersome to use because you'd have to coerce/cast the items to trait objects (and lose performance/vectorization due to dynamic dispatch): let sum = vec.iter().map(|i| i as &amp;Borrow&lt;MyItem&gt;).sum();
If the environment they capture is `Send` and `'static`, just like closures.
Which traits are you imagining adding to your struct? If your struct doesn't implement `Deref` (that is, it isn't a smart pointer), the 4 related to deref stability just aren't relevant. `Move` is, like `Send` and `Sync`, an auto trait which you don't need to implement. I think this API is actually extremely narrow in where it will matter. Unless you're implementing smart pointers or APIs that support self-references, you'll never have to deal with almost any of this.
Is PhantomData not zero sized? What is a PhantomData for then? It's been a while since I read about it and the example I remember was something similar to this. I'll have to go re-read the docs
&gt; Cargo install is **just for adding extensions to cargo** which I assume is what you're referring to? Not true. There's absolutely no such restriction on installed binaries.
&gt; Slab is a well made abstraction, too. It also obeys borrowing rules (e.g. you cannot hold two &amp;mut references to two objects in it) and drop rules (dropping the whole slab drops all objects in it). Look, I'm going to leave this argument here, because we're just going to continue to disagree, but some final thoughts: Slab does not allow you to manage the memory of **individual objects**. That may or may not be something you want, but it is not the same as what `Rc` offers. Slab is also not well behaved with regard to concurrency; consider: https://play.rust-lang.org/?gist=81ffcd74839df39eac674a5f287f8cfe&amp;version=stable Then, regardless of Slab itself, *this example* is particularly bad. You're implementing your own `Pointer` type! That's just wrong on all kinds of levels. I could go do the same and insert serialized records into a database, and then use guid strings as references to resurrect instances and mutate them whenever I wanted. That sounds ridiculous (I certainly hope you think so too!), but its not actually particularly far off what you've done here. I just don't think that's idiomatic rust. &gt; Is Slab not blessed? Well, admittedly, the whole motivation of my post is to give it a blessing it deserves... :) The closest I can offer to what you're suggesting from my perspective is this: Imagine you went and implemented your own `String` type, to solve the `&amp;str`, `String`, `Cow` irritations in rust for new comers. ...and then pitched that as a better alternative to `String` that beginners should be taught in rust. That doesn't make sense to me.
Rustup is definitely the best starting point. It allows you to easily install multiple versions of the rust toolchain if you need to, and upgrade when you want to. Every 6 weeks there is a new stable release of Rust that adds some goodies with a strong focus on not breaking existing code. If you haven't seen it, I found [The Rust Programming Language](https://doc.rust-lang.org/book/) to be very useful.
Maybe try looking at [byteorder](https://github.com/BurntSushi/byteorder)? Anything by BurntSushi is probably a great example, but that library is particularly small (although maybe not the easiest to understand if you’re not familiar with Rust, but at least you could get an idea of structure?).
I had the same frustration as you. As a result I built [yapb](https://crates.io/crates/yapb), which does *nothing* but format progress information as text. Threading and even display is left entirely up to the user, making for a simpler and more versatile library; you just `print!` the progress bar like you would any other value, supplying the desired width using the standard format string DSL. As a bonus, I also used Unicode block drawing characters to get 8 times higher resolution than any other text progress bar I've seen, which is fun. The one downside is that it turns out wrangling ANSI escapes and co by hand is kind of a pain, but at least you're free to make as simple or complex a display as you like.
I was somewhat disoriented at the beginning too so I can understand the feeling. As a starting guide, you can study the structure of some existing libraries and take the elements that you like from them. There are a few best practices but most are still emerging and certainly not defined enough to be enforced by Cargo the same way Maven enforces things on Java. The breadth of problems addressable in Rust means there might never be a single acceptable way of doing things. 
I was reading an article by the elementary guys from the Linux unplugged Reddit page. In it they brake down some reasoning behind it. Here is the article it's self: https://medium.com/elementaryos/meet-the-upcoming-installer-a499341218f5
From listening to interviews with people from system76, it sounds like they can use the tools they believe are best for the job. That is so long as the job gets done in reasonable time. I believe /u/jackpot51 is the one advocating it there.
I like your way of laying out your inputs (crate X, use X, crate y, use y). 😀
Yeah, I saw that original post and they definitely wave their hands a bunch about the problems they found in other solutions, I was hoping for a list of more technical reasons. Thanks for linking that tho!
Starting.
No hard feelings at all. :) There is something to be said for acknowledging that you are wrong; I'm certainly wrong about things all the time. I, at least, walk away from this having realized that Slab has uses in ways I hadn't considered. ...I hope at least you've walked away from it with some alternative perspectives on your own enthusiasm for it as well. 
Personally, I put infix operators at the start of the line, because even with otherwise poor formatting and no indentation, it's still clear the line is in some way related to the previous line. ... with the exception of commas, of course. People who put commas at the start of a line should be rounded up and shipped off to a labour camp somewhere, along with people who use non power-of-two indentation, and people who use Whitesmiths style indentation. I mean, *really*. ^^^^^^^^:P
Given the example you posted below, this requires higher kinded lifetimes. They're one of the least used syntax features, but they are very useful when you need it: fn test&lt;T: for&lt;'a&gt; Graph&lt;'a&gt;&gt;() { This will require that for any lifetime you need, T implements Graph with that lifetime. (for any lifetime = `for&lt;'a&gt;`). The problem was that with your code, T only needs to implement for a single lifetime 'a, which can be changed arbitrarily by the caller. Full fixed copy of your minimal example: https://play.rust-lang.org/?gist=2afedfe4b33f9ca885bf95458f32eb39&amp;version=stable
If the actual code isn't as simple as this code is, then it's probably needed. `serde::Deserialize` uses a very similar syntax to create a specific relationship between the trait and the lifetime. Like this case, anyone dealing with `Deserialize` usually has to use the `T: for&lt;'a&gt; Deserialize&lt;'a&gt;` syntax.
&gt; At this point in Rust's life It's definitely usable, but I don't think that has anything to do with Rust's age. There are two main differences between stable and nightly rust: - nightly rust enables use of features which can change (very unstable) - nightly rust includes the latest commits (usually alright until it isn't) This has always been the case, and pretty much will always be, I think? --- In any case, I'd agree that using stable is the best course of action. If you need to install a nightly-only tool, you can use `rustup` to only install that tool under nightly, and then only use nightly *for that tool*.
Awesome work! I had forgotten this was even an issue.
Great work。
That sounds like a data race. I think you should use a `Mutex`. Are you sure it slows you down? I think acquiring a `Mutex` is just a single atomic write instruction, as long as it's not contended. If the only time it's contended is once every 100ms, it's probably very low overhead.
I mean... Deref is exactly what I'm imagining being a problem. Sometimes I like to implement Deref (and DerefMut) on wrapper types. Soon I'll need to implement 2 more traits as well, which is annoying.
cc /u/paholg
Wooo! I'll have to test typenum once this hits nightly.
you should convert that to gltf 2.0 and put it on a public CDN with CORS
Ah I've been wrong to assume that then. Do cargo extensions just specifically register themselves under the cargo namespace when installed then? 
https://www.blendswap.com/
According to the manual, it *is* zero-sized. I haven't needed PhantomData yet, but, if I'm reading the manual entry and nomicon summary correctly, `PhantomData&lt;T&gt;` is for when you want something that's zero-sized but behaves like `T` for the purposes of things like the borrow checker. (eg. for teaching the compile-time checks how to properly constrain use of an FFI abstraction that doesn't own the data it's accessing, but *is* responsible for triggering cleanup.)
Ah wow that's a neat trick, so there really isn't any magic to it at all
Your date is wrong in the change log. As much as I'd love it to still be 2017!
Wait is it 2018 already? *sigh* Fixed, thanks :)
Please be careful, some people may be uncomfortable with such jokes.
Rust doesn't have a stable ABI. In fact, each version of rustc names libraries it compiles with a specific hash (first N bytes of md5 hash of version IIRC) that way it will never try to link to a different version. None of the non-binary crates are built with the idea of multiple consumers. Do you want to have 100500 version of the same library and dynamically link them? Crates that export C-ABI should use host OS packaging system.
I'd suggest you use nightly but only for tools like [clippy](https://github.com/rust-lang-nursery/rust-clippy), which aren't available with stable Rust yet. However try avoiding unstable features so your code may run on stable.
PhantomData is zero sized, and making a type behave as if it contained a non-zero-sized T is it's entire point. If T already is zero-sized, theres no need for it. If T has a size &gt; 0, you probably want to use what's contained in it.
I think you want /r/playrust.
And check the upload dates 
fuck 
I like the concept of searching on file semantics, but not sure about the language. I would have preferred something more similar to `find`, where you in a sense "filter" the resultset through each criteria and apply any actions at the end. What I'm expecting would then be: `source path`, `filter rules`, `columns`. I will try `fselect` out for sure because it seems useful!
Deps are per-project. If you add a dep, its source will be put into your `~/.cargo` and used in your project (I'm not certain of this but I think `.cargo` cleans up old stuff, or it may in the future). This does mean you need an internet connection to add new deps (cargo-airplane is a way around this). Rust's ABI isn't stable so libraries will stop working with a different compiler (so it's not worth keeping them around). Plus, due to semver you'll usually have different projects pulling in different versions of the same crate. So this isn't exactly something that will work well. 
1.0 is not an API freeze. As I said, I plan to make new releases every 6 weeks (more often than I've released so far). All I'm doing is not making breaking changes.
Hello rustaceans, Coming from GC languages like Go, Java, Python, etc. this is my first time touching system programming with non-GC language. Suffice to say I am super new to this. At first I wanted to make a small project to ask for code review, but it got a little bit bigger than I have initially thought. So I am quite hesistant to ask you all to review all of this mess. Hence, I am just gonna share it here with all of you. Feel free to review if you're feeling adventurous :)
If I had to guess, it's because you're re-borrowing `self.buf`? You're trying to give Nlmsg a `&amp;'&lt;unnamed lifetime&gt; &amp;'a mut mnl::Socket`. I haven't seen the exact error, but I assume the "Free region" is referring to this unnamed lifetime. Since `self.buf` is already an `&amp;'a mut mnl::Socket`, could you try just using `mnl::Nlmsg::&lt;'a&gt;::new(self.buf)`?
Would love ability of filters like in weechat, so I can toggle displaying of something like join/part/quite messages etc. - https://weechat.org/files/doc/devel/weechat_faq.en.html#ignore_vs_filter - https://weechat.org/files/doc/devel/weechat_faq.en.html#filter_irc_join_part_quit
&gt; Have you thought about "actions" such as delete, exec, rename? Just having `-print0` as an option would be very helpful especially if you don't have "native" actions, as then you could at least use xargs
v0.2.4 published under the MIT/Apache-2.0
v0.2.4 published under the MIT/Apache-2.0
v0.2.4 published under the MIT/Apache-2.0
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: /r/Serendipity/comments/803u5k/instagramish_filters_in_rust_xpost_from_rrust/
&gt; I was going to run clippy on it, but for some reason clippy fails to compile using cargo install clippy. Maybe later. `clippy` needs rather specific versions of nightly. When you encounter this, you can try updating nightly and compiling it again. If it's still not working, it wasn't yet updated for recent changes in the compiler, so wait a few days and try again.
&gt; Whitesmiths style indentation I've contributed a little bit to two very large C++ projects that use Whitesmiths, and I can barely stand looking at the code. They're also template-heavy and rather wordy, which isn't helping at all.
Using `*` for glob patterns seems like a bad idea, as they (can) interfere with the shell's own glob expansion.
Wow, I've never even seen this syntax before. But it's exactly what I need. Thanks!
Hmm, so the way I see it, this is more ergonomic to use in that the *for&lt;'a&gt;* thing doesn't have to be done when writing a function generic over all graphs. But it looks slightly more contrived with having to split the trait into two. Is there a way to maintain these ergonomics while only having one trait?
might be https://www.youtube.com/playlist?list=PLVvjrrRCBy2JSHf9tGxGKJ-bYAN_uDCUL if you are a absolute beginner
Can you elaborate for what kind of a relationship that is useful? If I just want to encode "iterator doesn't outlive graph", then binding the lifetime to *&amp;self* of the *neighbor* function is sufficient right?
[removed]
There is one place where commas at the start of a line make sense: SQL: SELECT foo , bar , baz , qux FROM ... 
This looks good, how long did it take you to make? Being a fan of blender myself, i'm thinking of giving it a try.
&gt; At this point in Rust's life is nightly stable enough to learn on or does it make more sense to learn on the stable version? Rust is already really stable and production-ready, so I always recommend using stable unless you are building/using a tool which *really needs* nightly (e.g. because it uses compiler internals which are always going to be unstable). In general, nightly is for people who want to try out features before they're fully stabilized, kinda like how you may try the alpha/beta version of a game before it's been officially released. People outside the community sometimes take the presence of a nightly channel to mean Rust isn't production-ready, which obviously isn't the case.
The application seems to support quoting everything into one argument, and then it wouldn't be expanded by the shell. Although I kinda agree, saying `LIKE %.jpg` would be cool and more SQL-like
*Blasphemy*. A thoughtcrime correctional representative will be with you shortly...
/r/playrust
Sorry
Not sure what you mean by screencast but if you are looking for videos to learn from this is the best series I've seen. Also Ferris, yes. https://www.youtube.com/watch?v=EYqceb2AnkU&amp;list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW
Really like the idea. Keep going!
Looks hideous... until you write enough SQL... the it’s a forgotten comma there or a reordering of columns here... and you see the light
It's cool in Elm too: ``` type alias Circle = { x : Float , y : Float , radius : Float } ```
&gt; There is absolutely no need to compete with any other language I expected that you will tell this, but... * if we are building a product * and if we are new and relatively slow in progress * and if others have much resources to surpass us and if they are going fast **companies will choose other's product over our product, right?** Most people learn Rust not only to code as a hobby, we should not betray them. 
Sorry for late reply. I'me very glad that you try to discuss with me. But, sorry, my native language is not an English so chatting in real time is very hard for me. For your information, here are some other notation languages actively developed I found on the Web: Focused on MIDI: Alda &lt;https://github.com/alda-lang/alda&gt;, TidalCycles &lt;https://tidalcycles.org/&gt;. Muse [*] &lt;http://atomic.world.coocan.jp/muse/muse.htm&gt;, Text Music Sakura [*] &lt;https://github.com/kujirahand/sakuramml&gt;. Focused on typesetting: Lilypond, ABC, GUIDO &lt;https://github.com/grame-cncm/guidolib&gt;. [*] Unfortunately, these web site and documentation are written in Japanese only but I think they are notable: Muse has many syntax for high-level description such as Arpeggio. Text Music Sakura embeds an original programming language and fully scriptable. Both of them have developed since 1999. By the way, I tried melo on Linux and it works!
Worked at it a few hours a day for the last 3 days, probably around 10h in total. Most of that was learning how to use Blender. It's an unintuitive UI so you just gotta have a tutorial. It didn't help that I did this on an ultrabook without a mouse. For the actual model I imported the SVG of the Rust logo which gave me a 2D object. I thickened it in the z-direction and then I had the base model. Blender has tools for both of those so that's basically 2 operations. The rest of the work is putting together the scene, where to put the camera, where to put the light. Clicking together the shaders for the material. What color, how much diffuse scattering, how much reflection. The texture from one of the original logos lined up perfectly with generated coordinates so all I had to do for that was tell it to use generated coordinates and crop the whitespace of the original logo. I tried giving it an actual rust texture but didn't arrive at anything good looking.
https://github.com/InsightSoftwareConsortium/ITK/blob/master/Modules/Filtering/ImageGrid/include/itkInterpolateImageFilter.hxx https://github.com/InsightSoftwareConsortium/ITK/blob/master/Modules/Filtering/ImageGrid/include/itkWarpImageFilter.hxx The worst part is that `clang-format` doesn't properly support it. In Rust I'm fine with the defaults. Actually, I'm fine with the defaults in every language where they exist.
First link this interesting, thank's 
Generic associated types, and you need `NodeIterator&lt;'a&gt;`, are not yet implemented. Just make it a public type in the same module for now. Proposed syntax is `type NodeIterator&lt;'_&gt;: Iterator&lt;item=NodeId&gt;` With a new enough compiler, you can use an abstract return type `fn iter_nodes&lt;'a&gt;(&amp;'a self)-&gt; impl 'a + Iterator&lt;Item=NodeId&gt;`, which is planned to improve to `fn iter_nodes(&amp;'a self)-&gt; impl 'a + Iterator&lt;Item=NodeId&gt;` or `fn iter_nodes(&amp;self)-&gt; impl '_ + Iterator&lt;Item=NodeId&gt;`. 
I'd say Rocket is a bit too early for commercial usage yet, being nightly-only.
Did you know if there are other framework that are ready for commercial usage ?
https://www.youtube.com/playlist?list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW
Modern languages should really learn to allow trailing commas... though, you can do this: type alias Circle = { x : Float, y : Float, radius : Float} Guess it doesn't look good with curly brackets as it does with square ones or with parenthesis...
I don't think any framework in the ecosystem is both faster than something like Python/Node and mature enough to justify using it commercially.
Ooh, I wonder if this is going to help reduce my ridiculous compile times with large Diesel-based queries.
Parity (Ethereum client) is GUI, and written in Rust.
It depends. If you just need a thin web server with a couple of microservice endpoints to wrap an existing Rust code base, there are a bunch of OK options. We've used a couple at work, and they're pretty interchange, in my opinion—no offense to the people that wrote them, but none of them feel "mature". They're adequate, and they do the job, but each is missing a different thing that you'd want for a big project. A lot of this is because of the ongoing transition to asynchronous Rust, which is taking a while. If you want to build a full-fledged server app with lots of bells and whistles? Probably the best bet is to go with Rocket and just accept that nightly Rust is the best choice here.
Of course. But project managers are also people and they respond to a variety of factors, as in good press (we have a lot), community (yay!), other companies' success stories (again, look at the friends page and perhaps the recent white paper), their own devs (Steve Ballmer voice: *Developers!*), among others. Being cooperative instead of competitive lowers the bar of entry. You don't need to throw out prior investment and won't have to fear lock-in. Furthermore, it avoids an us vs. them scenario, which inevitably leaves bad blood.
Thanks, I'll do that. Or even, review the docs a bit more and send a clarifying PR.
Except without the semi-colon, no?
http://www.arewewebyet.org/ is a great overview.
I would use the [git2 crate](https://crates.io/crates/git2) rather than running git as a command. You are printing, but otherwise ignoring all errors. This means if one of your commands fails you will blindly continue executing git commands while the repo is in an unknown state. For this application, you should exit immediately just after you print the error. &gt; function take either str or String You can use `T: AsRef&lt;str&gt;` to do this: fn do_something&lt;S: AsRef&lt;str&gt;&gt;(arg1: S) { Then use arg1.as_ref() to access it. But this becomes verbose when you have multiple arguments as you need to specify a generic for each one. Using `&amp;str` as the argument is good enough for your use case. &gt; I would like arg2 to be optional. You want Option&lt;T&gt; for that in general, but given &gt; Even better, I would like an unknown number of args You would be better using `&amp;[&amp;str]`, or better yet keeping the builder pattern of `Command` and creating a function/macro to handle the output more elegantly. Something like (untested): macro_rules! error_handler { ($e:expr, $msg:expr, $err_msg:expr) =&gt; match $e { Ok(_v) =&gt; println!("{}", style($msg).green()), Err(_e) =&gt; println!("{}", style($err_msg).red()), }; } Then around all your commands simply: error_handler!( Command::new("git").arg("pull").output(), "success", "Failed to pull from branch" )
Oh okay, at the moment rust isn't very good if we compare to another language to handle lot of request at the same time ?
It is not clear about the "Handle Rust failures from other languages", why it is standalone projects? I mean there are a lot of projects that are intended to simplify bindings of Rust with another languages. For python for example [rust-cpython](https://github.com/dgrunwald/rust-cpython). Part of these project is type mapping/conversation: `Rust type &lt;-&gt; Python type`. And obviously `Result&lt;&gt;` handling falls into types mapping/conversation.
&gt; should be rounded up and shipped off to a labour camp 100% Unacceptable.
\o/ Thanks!
Are you guys looking for contributors? I'm a data scientist/ML dev that's learning Rust on the side. I think it'd be really cool to work on this!
You are looking for r/playrust.
&gt;main and alternate scree Does it work in both Windows console and xterm?
*totally didn’t forget about that when typing a mobile reply* Yes without the semi-colon
So there several approaches to integrating Rust and Python with each other. I'm not familiar with the crate you linked, but it seems to depend on CPython, i.e. a particular implementation of Python. That (probably) leaves out [pypy](http://pypy.org/), another Python runtime. The approach I'm using right now to call Rust from Python is to export a C interface and to call that interface using [cffi](http://cffi.readthedocs.io/), which also works on pypy. I'm happy to consider alternative approaches (especially since right now I have to think about memory management all the time), but right now that is the only approach I know for Python code that embeds some Rust but can't just link against CPython. I dream of something that builds on top of that kind of setup to provide an experience similar to what [Helix](https://usehelix.com/) provides for Ruby, but that's a much more ambitious project than mine.
You could use hyper directly without any frameworks, like the golang approach
Check out [actix-web](https://github.com/actix/actix-web) as well, which is a [stable and performant](https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=plaintext) framework using actors as an abstraction.
What were some of Python 3's mistakes?
Commas at the start of lines are so much nicer for writing down lists you might want to append to (assuming they are a sperator not a terminator).
I see your point. But `cpython` was an example. As I know there are several python&lt;-&gt;rust automation crates, none of them can handle pypy (there is some crate that also mention pypy, but I don't remember name)? And about similar to `Helix` you can consider my project [rust_siwg](https://github.com/Dushistov/rust_swig). It can generate both Rust and Python code. And generated Python code can handle memory managment and error code to Python's exception conversation.
If you're on chapter 4, you haven't learned enough Rust yet to make your code super concise. It's good to ask questions early, but a lot of these things are "you haven't gotten far enough to learn this yet."
It's also a little outdated; there's frameworks that have come into existence since it was last updated, for example.
This is true, but companies are using Rocket in production, so it's also false. (I can't wait until it's on stable, personally.)
Wow this is all super neat stuff, thanks!!! No idea why git2 didnt pop up at any point while I was putting this together, I did plenty of google searches with some combo of 'git' and 'rust'. Excited to dig into that source code a bit. Thanks a lot for your reply. I really like the error handler macro, will be implementing that immediately. 
&gt; This has always been the case, and pretty much will always be, I think? Correct.
.Starting
rust-swig looks very interesting, I'll definetly try it out when I have the time.
There are also some videos by J M Archer https://www.youtube.com/watch?v=sv9fTlU7SCA&amp;list=PLTOeCUgrkpMNEHx6j0vCH0cuyAIVZadnc
Well... the intention with the `take()` documentation is that "value" means "the enum value", as in the whole "Some(T) or None" thing. It's confusing because the T inside Some(T) is also called the "value" for Option in particular. I didn't know how to fix this cleanly, so I left it out of my PR.
I like to use [rouille](https://github.com/tomaka/rouille) with [postgres](https://github.com/sfackler/rust-postgres) or [rusqlite](https://github.com/jgallagher/rusqlite), [tera](https://docs.rs/tera/0.10/tera/) for templating, and my migration manager crate [migrant_lib](https://github.com/jaemk/migrant_lib)
Nice! But it uses quite a lot of CPU on my laptop. Are you locking the framerate to some value?
Not currently, but it's coming soon-- the feature that you're looking for is "generic associated types" (sometimes called GATs, ATCs, or "associated type constructors").
It's notably used by `git`, although I'm not sure if that was the exact source of inspiration.
*Ah* I see now! Thank you for the good explanation :)
I agree, it's hilarious. Still I'd personally like if you toned down the snark a bit, okay?
I am working on it right now however it is not finished yet. Windows 10 console and xterm are already working since they support ANSI. But for older console I'll have to use Winapi and that is a little tricky. my goal of the crate is to provide the same functionality for both windows and Unix systems. So "does it work ... and xterm"? Almost done.
&gt; ultrabook without a mouse. Wow. Blender nearly requires a 3-button mouse and a [numeric keypad](https://www.amazon.com/Numeric-Keypad-USB-Number-Pad/dp/B076H2QYR1)
[This has bias.](https://github.com/kirjavascript/snake-rs/blob/296b756afc3bc63a52c2d1817488b938a081d470/src/snake.rs#L52) Use [Range](https://doc.rust-lang.org/rand/rand/distributions/range/struct.Range.html)
Even better to have no lifetime parameters for `Graph`. If you need to have associated type with lifetime parameter to borrow `self` use this trick. Move those associated type into separated trait `Assoc&lt;'a&gt;` and then add it to bounds of `Graph` like this `Graph: for&lt;'a&gt; Assoc&lt;'a&gt; { ... }`
Sure will. Hopefully with open sourcing we'll have collective wisdom improving it for everyone!
Whoa, sample seems like a great crate to be aware of. If I'll do a more thorough remodeling of sfxr I'll keep it in mind for sure! I wrote the current code by first directly translating the C++ version's `SynthSample` function into rust, then making sense of it all by extracting features into separate structs, then refactoring the entire process into a more rusty form. Basically every line of the original code is still in there, mostly intact. Now that I better understand how the original works, I'd almost rather make a new, better one with non-magic sampling rates and more predictable behavior instead of the trial-and-error usage model of sfxr. The prefixed fields and such are all artifacts of the original code. The variables have pretty much the same names, save for moving all "p_"-prefixed ones to Sample to differentiate configuration from the internal state of generating the sound. I could move them into nested structs, though I'm not sure it would be that beneficial in this specific case. Thanks for the comments!
[removed]
Quick tip: while using stable is way to go, there are some tools (like clippy, some tests) that require nightly. practical way to do it: use rustup, install both stable and nightly and use `+nightly` in cargo invocation, like this: `cargo +nightly test`
Do you happen to know what the blockers are currently? And any loose ETA of those coming to stable? 
Solid tip, thank you very much! 
Sounds really cool, though I think I'll wait until I've got a firmer standing with the language before giving nightly a try. The idea of working on the most recent, fresh off the presses version of a language just sounds awesome. 
Also for C++ member initializer lists: ``` MyClass() : member1() , member2() , member3() {} ```
Will do, clippy sounds a lot like Es-lint from JavaScript world which is wear most of my experience is. Interesting though that it only works on the nightly build, any thoughts on why they don't just focus on stable? 
Is there a library for writing lexers (not a lexer/parser generator) ? I made a lexer for the Lox language today (Lox is the language from "Crafting interpreters") and it's quite slow. As always, I ended up defining my own helper methods (such as advance_while(), matches() and so on). There is one place where I need 2 characters of lookahead, so I just cloned the original itrrator and looked ahead. This is terrible, but I don't know of a better way.
I was not aware of that. Thanks for pointing that out. I disabled the built in Rust package and after that i moved the unzipped Rust enhanced repo to Home/.config/sublime-text-3/Packages. After doing this i can see the package in the list of installed packages, i have syntax highlighting but nor for example the linting i have seen on some screenshots. I read in the instructions that Cargo and Rust must be added to the path which was not the case before (only cargo was added). I assume that the issue is coming from not having the rust directory added to PATH properly (i'm using Ubuntu 16). But if so, i don't know which path is required.
I was not aware of that. Thanks for pointing that out. I disabled the built in Rust package and after that i moved the unzipped Rust enhanced repo to Home/.config/sublime-text-3/Packages. After doing this i can see the package in the list of installed packages, i have syntax highlighting but nor for example the linting i have seen on some screenshots. I read in the instructions that Cargo and Rust must be added to the path which was not the case before (only cargo was added). I assume that the issue is coming from not having the rust directory added to PATH properly (i'm using Ubuntu 16). But if so, i don't know which path is required.
As one of clippy's authors, let me explain: clippy works by hooking directly into the compiler, which gives us a lot of information we can use to detect things. However, this only works with nightly unless we get a special token for hooking into stable Rust (which is what RLS preview is doing, I presume). We have been in talks with the compiler team for some time and there is general agreement that we all want clippy on stable. However the process to get there has recently suffered a speed bump, so we likely won't have a stable clippy in 12 weeks, alas. We have been assured that this setback is only temporary however, so I remain hopeful we'll see a stable clippy within 2018.
&gt; should be banned. How intolerant of you.
Really good job man. THis is super exciting work. For some reason it seems like the Rust community is lacking in people interested in the audio side of things, so you're really helping to expand that. These are just a few things I picked up on from the code, that you may want to take with a grain of salt, since it looks like you're a far better Rust programmer than I am lol. I'm not trying to tell you that anything is wrong, just point out observations for you and others reading the code. # Lower the scope of Sample's fields I'm guessing this is a pretty 1-1 port of the original code, and that's why Sample is the way it is. Having Sample be ``` Sample { Frequency, Vib, Env, lpf, hpf, pha, repeat_speed, arp ``` or something along the lines, with nested structs, makes the API more idiomatic. On top of just looking cleaner, you can start getting into some very cool design patterns that it looks like would be hard to do with today's `Sample` # Name things in self-documenting ways Going through the code, and not being familiar with the original context, reading things like `s.env_decay` is a bit arcane. Rust seems to promote self-documenting names, like `let mut s = Sample::new()` being `let mut newSample = Sample::new()`, even if every single person getting to that point in the code would understand `s` just as well. # Macros would help with a lot of `lib.rs` A lot of the code that's doing `rand_f64(rng, 0.3, 0.6)` may be able to be cut in half in total lines if it fits well with a macro. # You may be able to use more language features One example, in `generator.rs`, would be to change `EnvelopeStage` to be able to be called like `Attack(50)` This helps your match statements later in the file take up less code. 
Ah, that makes a lot of sense. I'm sorry to hear about the speed bump but it sounds like you're doing everything in your power to make it happen. Aa a budding Rustacean, thank you for your hard work. I'll keep an eye out for stable clippy but after looking at the docs, it doesn't seem at all difficult to use nightly Rust exclusively for running clippy. Especially as a subcommand! Are there any pain points I should keep an eye out for or is using clippy on stable rust a mostly innocuous process?
I would absolutely die if someone built components of osquery as rust crates. I'll have to build it myself eventually but I'm probably not starting on that for a good while.
One option is to use the nightly compiler but to stick to stable-compatible code. The reason I recommend this is because there are always [slight improvements to the diagnostics](https://github.com/rust-lang/rust/issues?q=label%3AA-diagnostics+is%3Aclosed+sort%3Aupdated-desc) in nightly in order to make them more approachable to newcomers, some times significantly so. But it is true that rarely nightly will have problems, given that it is where development occurs.
I've made a [stack overflow post](https://stackoverflow.com/questions/48979557/rust-a-bin-target-must-be-available-for-cargo-run) to ascertain why I cannot run Rust projects. I would appreciate any help I can find. :-)
Looking at the perf run in that thread, crates.io saw minimal improvement so probably not.
Just want to add that sometimes I do the binding (even if it's technically unnecessary as you point out) as it tends to make it easier to add new lines of code if necessary (e.g. `println!("{:?}", out);`).
the left hand side of a match is a pattern, not an expression. the match is introducing a new name `new_string`, an irrefutable pattern shadowing the old name, and matching any value. however, _constants_ in the left hand side of a match are inlined and can be used in the way you expect
&gt; fselect path, size where name ~= .*\.rs$ This returns files that don't just end in '.rs' but also 'rs'. eg `filers` would show up. Things that would be really cool: * Library API where I can take this syntax and use it * Control recursion depth * Parallel search when I don't care about ordering
Well, just Hyper's `Service` wrapper around Tokio's Proto is faster than Node/Python. Is Hyper not production-ready?
It'd be nice if lib.rs exported a function that transformed an image from the `image` crate so that your lib could be used from rust apps.
Thanks for the help. Const makes sense, but the behaviour for an expression seems really misleading. Is there a scenario where you would want that? I'd expect it to be a parsing error instead 
I think the issue is not that `rand::random` has bias, but that doing `rand::random() % width` can have bias. E.g. `rand::random::&lt;u8&gt;() % 7`, has a 37 in 255 chance of producing each of 0, 1, 2, and 3; and a 36 in 255 chance of producing each of 4, 5, and 6. `random::Range` is a good way around this problem, and in fact the docs for `Range` explicitly talk about this problem as a reason for using `Range`.
Just zillions of nightly features. Sergio says he expects it to be stable this year though.
Yes, I agree. Tbh, I was struggling a bit with package management, and how to structure modules. I will work on this, plus documentation. Thanks for this! :)
as /u/mitchmindtree mentioned, I did the binding because I was adding and removing extra lines of code to adjust the filters to get it juuust right. Thanks for the advice!
Ah, gotcha. I see where they're coming from now. Range is just a better habit.
Can you expand on what those things are?
gltf 2.0 is a commonly used format for 3d objects on the web, if you make them available on a Content Delivery Service that has CDN, they can be available world wide speedly, and used by websites that utilize things like WebVR/Aframe
For reals .. I can't imagine life without that middle mouse rotate or num pad viewports
I'm mildly disappointed I didn't see a "Rust" filter that tinges things a nice color orange ;)
monkaS
It looks like Quxxy edited it...
Small note: that’s not in the stdlib.
I’ll try to release [actix-web](https://github.com/actix/actix-web) 0.4 this week
- easy to setup oauth system (loging with facebook or google account) for web libraries (rocket, gotham doesnt have it, you have to write it from the scratch) - easy to use, flexible library for creating API wrappers (github api, reddit api etc) - https://users.rust-lang.org/t/one-place-for-ideas-with-voting-system/15621
And that's why we need rustup component add clippy
With 3 button mouse emulation mode it's Alt + Shift + Left Click to rotate and I have the numpad on the right hand with Fn
Last week, the [mutagen](https://github.com/llogiq/mutagen) project had a great start, this week I'll try to tackle the test runner so we already have something usable. Apart from that, [bytecount](https://github.com/llogiq/bytecount) needs someone with a beefy machine for a benchmark and [flamer](https://github.com/llogiq/flamer) could get hierarchical flame-guard names (also there's a problem with certain macros). Then TWiR and the week already looks pretty full.
Thanks! I'm not exactly an audio guy, though. I did minor in DSP so I know the basics and happened to have a need for something like this. Still, thanks for all the comments! I'm starting to see a few recurring themes in the comments sfxr's getting here and otherwise. Going to start by remodeling the main structs.
I believe you, I just wouldn't want to be you :)
[Here](https://github.com/flosse/rust-web-framework-comparison) is an other overview :)
Fwiw, my desktop is 2m away but I don't have internet unless I boot up Windows.
www.areweembeddedyet.org Would be a useful site like www.arewewebyet.org
The gdb integrated debugger in Visual Studio is actually pretty good. I don't know if you're restricting yourself to CLI debuggers or not running Windows, but I've had decent success with it. Although, I haven't tried to do anything particularly tricky with it yet.
This sounds like an absolute wrong approach to begin with. This throws "distro independent" out the window from the get go IMHO. 
Not sure I completely understand but let me try: fn add_vec(self, v2: &amp;Vec&lt;T&gt;) and allow for mutation of `self`?
Lot’s of expectations from actix since their breathtaking performance at techempower benchmark.
0.4 should be slightly faster than 0.3
For my information, where do you find opportunity for performance improvement? Small tweaks? Profiling? Updated dependency?
I am trying to learn more about network programming so I am tooling around with creating a small http server with restful endpoints using various crates such as tokio and httparse. Not sure how far I will get!
Impressive summary
That's the point though. Currently, in C++, you do this: if (optional) do_stuff(optional.get()); `get()` has undefined behavior for when you're using it on an `std::none` value, which means in theory that it won't perform any check. If you suggest that it should throw an exception or fail an assert or something, then it becomes a double check. The compiler would probably remove it, but because of the spec you can't have a guarantee that it won't behave unexpectedly. You can't enforce to use `get()` only after a check unless you use typestates, but then the ergonomics become pretty bad.
Depends what you mean by embedded. Lots of people would consider "embedded" to include a computer in something that is sold as a non-desktop-computer product, even if it's running Linux or Windows on an i7. Or, in other words, anything that is a computer but doesn't look like a computer (cars, medical devices, robots, kiosks, etc). In this case the article is talking about "firmware". And the big problem I see is that a lot of the prominent examples of that is perceived as critical stuff that's really hard and needs to be locked down. Additionally, a lot of the companies doing large-scale firmware stuff are not software companies and don't pay software engineers as well as software companies, so they have less first-hand ability to understand proposed technologies and have low expectations for software in general. So for a company that's relying on non-technical heuristics, is wary of software quality, and is investing in a product which requires a lot of up-front capital, proposing a technology which has no "stable" support and only "nightly" support for the target platform is almost certainly going to be a lost cause. Firmware platforms are additionally currently tier 3, which means "they are not built or tested automatically, and may not work. Official builds are not available." This will kill the idea immediately. Although when I asked about it last year I was told that this could be resolved if it was the only blocker to using Rust for a commercial project, most people wouldn't bother to ask. Rust will be an amazing language for firmware, but these things have to be solved before more companies will feel safe investing in the technology for embedded products.
&gt;"operators" except I believe || and &amp;&amp; are just syntactic sugar for trait methods. || and &amp;&amp; are special and short-circuit and thus cannot be overloaded as they aren't sugar for any trait method you can overload which is kind of a shame because they could be overloaded to work conveniently with Result and Option. What you want here is basically the Option and Result monads from Haskell etc. Rust already sort of supports the result monad in functions with the `?` operator, so I think the syntax for that, if it comes to Rust ought to use `?` overloading and blocks rather than abuse boolean operators.
Well Rust already has it in the sense of `Result::and_then` and `or_else` Basically `x &amp;&amp; y` for results would be the same as `x.and_then(|_|y)`
&gt; This is single-threaded, event-handled code. You are not running on anything similar to threads. The computation will be out of order of definition. Rc adds safety: precisely that you don't know how long you need to keep the variable alive to make sure every future has access to it. It's not to make the compiler happy. RefCell adds the security to ensure none of the Futures (which may yield at any time for reasons they decide) holds a mutable pointer while another one gets executed. None of the futures should survive past the end of the (main) function, which is where the variables should get dropped as well. RefCell makes sense, but Rc should be theoretically unnecessary because the lifetime of the reactor at compile-time is &lt;= the lifetime of the shared variables. The problem here seems to be that the reactor puts a static lifetime requirement on the closure, rather than the lifetime of the reactor, which then means that the borrows in the closure must be valid past the end of the function, which is impossible since everything non-static gets dropped at the end of the main function. If the closures had a lifetime &gt;= to the reactor, I'd expect you'd be able to borrow variables directly without Rc.
Not to detract from the rest of the article, but this line in [a linked bug](https://bugs.chromium.org/p/chromium/issues/detail?id=644525#c52) is absolutely golden: &gt; I have carefully eliminated all possible causes of this bug and can therefore conclude that it is not happening and we must be experiencing mass hysteria.
Great write-up! The problem with "embedded" is that it is such a large field with different requirements. I work mainly on AUTOSAR software (in MISRA-C) so: - Memory errors don't occur often (there is no dynamic memory allocation!). Exception: out of bounds accesses happen sometimes. - Platform support: We mainly need to support V/RH850, Tricore &amp; PPC (although there are many more in use, see e.g here: https://vector.com/portal/medien/cmc/datasheets/MICROSAR_Availability_EN.pdf) - We have lots of safety related requirements like MCDC, need qualified compiler(s) &amp; static code analyzers... 
done, thanks
It will show files that have names at least 3 characters long and that end in rs, exactly what the regular expression is asking for. Either an escape for the last dot got lost somewhere, or this is evidence that normal regular expressions don't work all that well when used on file names via the shell (other tricky things are the $ although that luckily should only show up at the end of your expression, and the star)
I'm going to buy that domain. *On another note....* Does someone want to buy my domain for twice the original price?
Any optimizer will have edge cases like that where something just got missed, or the code is _just_ different enough from a known pattern to get compiled into something weird. There's really no way out of this except monitoring performance closely and digging into the compiler to figure out what goes wrong when something does.
I've been using Rust for a couple days now and coming from a Java/Kotlin background I'm having a hard time understanding borrowing. I'm trying to make a simple Conway's Game of Life. Here's what I'm trying to do: fn update(&amp;mut self) { for y in self.cells.iter_mut() { // cells is a Vec&lt;Vec&lt;Cell&gt;&gt; for x in y { let neighbor_count = self.get_neighbor_count(x_index, y_index); /* Use neighbor_count here for x */ x_index++; } y_index++; } } The error I get is for y in self.cells.iter_mut() --------- mutable borrow occurs here for x in y { let neighbor_count = self.get_neighbor_count(x_index, y_index); ^^^^ immutable borrow occurs here } - mutable borrow ends here Am I just going about this wrong or is there no way to achieve what I'm trying to do? I need `x` which is a `Cell` to be mutable to change it's state using the neighbor_count.
The part of this story that relates it to Rust is basically this: "If you work on a tool that creates binaries (Rust? I filed an internal bug for Go) using memory mapped files you should consider adding a FlushFileBuffers call just before closing the file. This bug shows up from Server 2008 R2 (Windows 7) up to the latest stable build of Windows 10 and OS fixes will take a while to propagate so you might as well be careful."
Actually I never understand such a waste of random domain names. Why not to keep them in a single place, e.g. `rust-lang.org/support/[ide, web, embedded, tools, wharever]/`?
A mixture of things, some fixable and some not. An example of a fixable one which left a bad first impression on existing Python 2.x developers was taking several releases beyond 3.0 to restore the ability to manipulate bytestrings using string APIs so you don't have to reinvent things like `.split()` to comfortably process protocols like HTTP 1.x with variable-length, delimiter-based fields. (I remember this leading some people to recommend solutions which involved calling `.decode('latin1')` on non-textual data, processing them using the string APIs, and then calling `.encode('latin1')` when finished.) An example of one which can't be fixed without breaking backwards compatibility is allowing `for char in string:` to work, rather than requiring users to explicitly specify whether they want to iterate through codepoints or grapheme clusters.
It's a pretty longstanding Mozilla tradition. There's a lot of "Are we X yet" websites. 
I know but how one is supposed to know about them?
https://www.areweareweyetyet.org
When you're asking questions like this, it helps to have a complete code example for people to examine. Otherwise, we have to guess at potentially important details. So, guessing hat on. You have something like: fn get_neighbor_count(&amp;self, x: usize, y: usize) -&gt; .. Right? This requires an immutable borrow of `self`, but you've already taken a mutable borrow of `self.cells`. Rust absolutely *will not* let you do this. More than that, I don't think it's logically valid, either. After all, if you did this, then you'd be changing the cells, then having other cells change their state based on a mix of the old a new state. So the simplest fix is also more likely to be correct: don't try mutating the cells while you're reading from them. Create a second block of cells and write the new states into *those*. Then, when you're all done, replace `self.cells` with `new_cells` in one step. Also, there's no reason to be counting indices manually. You can use something like `for (y_idx, y) in self.cells.iter_mut().enumerate()`, although if you're using two independent sets of arrays, you really only need `for y in 0..self.width() { for x in 0..self.height() { ... } }` or somesuch. Finally, to be complete, the *are* ways around this to do what you're trying to do. One would be to not use borrows at all, but use regular array indexing for accesses. Another would be to use types with interior mutability like `Cell` or `RefCell` (which can mutate from behind an immutable reference by various means). But I wouldn't recommend either of those, because I suspect using two sets of `Vec`s is more correct in this case.
Still has the problem that if you want to add one to the end or reorder them you'll have "unrelated" changes in your diff.
If you are planning to do microcontroller programming using Rust, please check out: http://blog.japaric.io/. 
Not sure about the rest but &gt; How are the optimization passes ordered? MIR-aside (not sure there even are MIR-based optimisation passes yet?) rustc mostly defers to LLVM for that, I know that you can specify custom optimisation pipelines via -Cpasses= (and there are various other LLVM tuning knobs in -C) but I don't know if you can dump these passes. https://github.com/rust-lang/rust/issues/33299 makes me think Rust currently just uses the default LLVM passes (in the default order) for the various optimisation levels.
I also work with AUTOSAR &amp; MISRA-C:2012. I believe Rust would be a much better choice and I've made at least two bugs this year that I think Rust would have prevented, but it won't happen due to the requirements you mentioned. Another problem is the lack of dynamic libraries. We use it to link together different ECUs/components for functional system tests on our test servers. Compiling all used permutations would take too long.
If it's supposed to be a list, it seems like it should be more like http://awesomeareweyet.org/ .
Created repo with small juniper example https://github.com/rofrol/rust-juniper-example
The actual site is https://wiki.mozilla.org/Areweyet
&gt; I believe Rust would be a much better choice Oh definitely - and I am sad to see that AUTOSAR has chosen C++ for their Adaptive Platform. It would have been great if the automotive industry would have pooled their resources into improving Rust. But instead they are creating (another) subset of C++...
After releasing [alice-rs](https://github.com/cbourjau/alice-rs) (a set of crates to analyze the public data of the CERN base [ALICE](https://home.cern/about/experiments/alice) collaboration) last week I am now working on implementing a real-world analysis with it. With a little luck, I might be able to use some of this for a conference latter next month.
I'm trying to use juniper (most developed GraphQL lib in Rust) with actix-web. This is what I got so far: - https://github.com/rofrol/actix-web-juniper-trying - Because juniper is sync, SyncArbiter needs to be used https://github.com/rofrol/actix-sync-arbiter-trying - Small juniper example https://github.com/rofrol/rust-juniper-example
Nice
Oh sorry for forgetting the function, but yes you were correct. I tried what you said and it works perfectly! Also, I completely forgot about enumerate that's much better than using separate variables. Thanks a bunch I've been trying to get this to compile for a couple hours
I don't know if it has changed, but last time I delved into the embedded world compilers didn't officially support most platforms. Rather, they might support a shared instruction set but ultimately the chip manufacturer would have a fork which they maintained and you used. If that is still the case then ultimately it might be the TIs of the world that we need to convince.
Here is a [short and sweet post](https://ruudvanasseldonk.com/2016/11/30/zero-cost-abstractions) that highlights the power of abstraction with iterators. Although it is still a work in progress, here is a [higher-level overview of Rustc](https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html), which outlines the steps taken by the compiler. There are various ways to bench rust code, one of them [worth using is Criterion.rs](https://github.com/japaric/criterion.rs).
Thanks for your reply! &gt; "We have locking problems too and I'm thinking in how tantivy resolve ABA problem without GC." I'm not entirely sure of the exact nature of your ABA problem, but if it is something like incrementing an indexed counter in a concurrent manner, tantivy will not be very helpful I'm afraid. JIT for scoring functions is not a bad idea. Tantivy is a bit far from that though. 
That package is depending on features that have been added to the language since the version of rust you are using. The version you have installed is a year and a half old... which is pretty old in regards to Rust. As pointed out by McGo0 you should be using rustup (https://www.rustup.rs/) to install Rust. It's the standard mechanism for installing and updating rust. (It isn't specific to dealing with just dealing with multiple versions, but it also does that pretty well too)
It depends on a few things. The first is how good the parent company is with the open source toolchain. The second is how badly the community wants it. For example, the rust community really wanted avr support so they forked llvm and over a year and a half got an experimental backend in the mainline llvm. (Now the issue is a bug in core) Then you have the riscv people who officially up-streamed support into the latest gcc and working on the Linux kernel. Which there is also a group of people getting it up-streamed into llvm for use with rust, clang, swift, etc.(any compiler based off from llvm)
Making Metal API command-buffers re-usable in [gfx-rs](https://github.com/gfx-rs/gfx), which would help Amethyst as well as gfx's own Warden test framework to operate properly on Metal.
&gt; exactly what the regular expression is asking for. *.rs is not a regular expression, but wildcard mask (https://en.wikipedia.org/wiki/Glob_(programming)), at least that most common pattern used in both sql and for file operations.
**Glob (programming)** In computer programming, in particular in a Unix-like environment, glob patterns specify sets of filenames with wildcard characters. For example, the Unix command mv *.txt textfiles/ moves (mv) all files with names ending in .txt from the current directory to the directory textfiles. Here, * is a wildcard standing for "any string of characters" and *.txt is a glob pattern. The other common wildcard is the question mark (?), which stands for one character. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
We've used Rust very successfully on an embedded linaro linux system. Everything could easily be developed on any other OS and in the end when it came time to run on a device all it took was a cross compile. It was smooth sailing throughout. 
It's very cool to me that there is a rust meetup in Vilnius. I'd be interested to know which countries do not have a meetup
There are some differences between dialect used by fselect and sql: &gt; where name = '*.cfg' I'd expect this to be an exact match. sql uses like operator for wildcard matching. Fully featured sql engine would be nice to have, with aggregations, functions and so on.
https://arewemetayet.com
Message received and solution implemented
These were the reasons. A dependency on a Qt frontend that would balloon our ISO sizes, and no good way to replace that frontend with a GTK one.
Except it says: "Regular expressions supported:", followed by an example using dots and stars. And it uses `~=` which looks a lot like the `=~` used for regular expression matching in Ruby, Haskell and Perl. It uses `=` with `*` a bit further, that looks like glob matching to me.
This is cool! Just a quick note: the link for OpenOCD at the Windows setup page is broken (it uses the link for the GCC toolchain), probably because the anchor name for the two links are the same. Also, I started downloading OpenOCD from https://github.com/gnu-mcu-eclipse/openocd/releases which seem to be well maintained and have quite frequent new releases.
Excellent! I was just trying to go through this a few weeks ago and was getting hung up on small things here and there. I look forward to trying again.
You're saying: &gt; Stringifying a function to get its source text and re-evaluating it is a very clever trick, but it is not idiomatic JavaScript style. This introduces more convolutions to the codebase for the sake of performance, and maintainability suffers. But I would say that introducing Rust and wasm into a previously pure-JavaScript codebase introduces more convolutions for the sake of performance, and maintainabilility suffers, too. And by a larger margin; any decent JavaScript programmer knows what `new Function` does, but the same is not true of Rust, wasm, etc., not to mention the immense headache of setting up a new toolchain.
Right, I missed the tilde.
+1 for the MCU on Eclipse builds of OpenOCD. My old standby for windows builds was here http://gnutoolchains.com/arm-eabi/openocd/ but they stopped keeping up with releases.
I have been working on the [Monero node](https://github.com/xmr-rs/xmr) implementation in Rust (*a RIIR*), i have been made some progress on it. It can do now a basic handshake with other peers (but doesn't send the synchronization data, *because i haven't worked on it*), also i have rewritten the serialization code to **serde** (previously i was using my own serializer), it was a bit hard to do first but when you get used to it it's easy to write a format (`Deserializer`/`Serializer`) for serde. I still have to rewrite some code that serializes blockchain data to binary, altought using serde for it isn't worth it (the format is really simple) so I have to roll my own.
While I agree with the point of added tooling, I do have to say that I've programmed in JS for four years now without having heard of `new Function` before. In my mind that is still quite obscure.
Gegl-style image processing. There is imageflow, but its AGPL3 licence is not suitable for large part of the community.
Check this out: https://www.reddit.com/r/rust/comments/80doqg/discovery_discover_the_world_of_microcontrollers/
&gt; This will kill the idea immediately. Timely official support is a huge deal to companies. Although when I asked about it last year I was told that the tier issue could be resolved if it was the only blocker to using Rust for a commercial project, most people wouldn't bother to ask. I'm in Web dev, not embedded, but I was disappointed to see the 2018 roadmap focus on Web as opposed to this. I realise proprietary hardware and LLVM backends are important factors but still, it seems like such a great use-case for Rust.
Thanks for the suggestion! The link has been fixed / updated.
We’re hoping to smooth the toolchain issues in the near future. What exists is already pretty decent, but we expect it to be excellent.
Rust does not create any binaries itself. It calls `link.exe` in order to create the binaries, so a new version of VC++ with a patched `link.exe` would fix this for Rust automatically.
Oh, this is exciting for some work I'm about to revisit. About a year ago I was experimenting with an unboxed heterogeneous list approach for creating elements in a react-like lib and this absolutely stopped my progress.
When you call `self.cells.iter_mut()`, that mutably borrows your entire `self.cells` variable for the duration that the mutable iterator is alive. You aren't allowed to look at a variable that is mutably borrowed because it might change while you're looking at it and then your code would not work consistently. `iter_mut()` is not really what you want to use here. It's more for updating elements in a data structure one at a time, independently, without reference to other elements in the data structure. Your code should probably be structured differently, something like this: for x_index in x_min..x_max { for y_index in y_min..y_max { // use self.cells[y_index+dy][x_index+dx] repeatedly to // calculate new_value self.cells[y_index][x_index] = new_value; } } Of course, you can't calculate the next iteration of Conway's life like this (because you're modifying cells in one row before you've used them to determine the next generation of the next row), but that should give you the idea of how you can structure your code.
Is there a simple way to do permuting multiple assign? Something like: let mut x = ...; let mut y = ...; let mut z = ...; loop { .... let t = // a function of x, y, and z; // this assign is what I want to do. (x,y,z) = (y,z,t); }
&gt; Although it is still a work in progress, here is a higher-level overview of Rustc, which outlines the steps taken by the compiler. Wow that is pretty amazing, I wish that would have existed when I started to work on [rlsl](https://github.com/MaikKlein/rlsl). 
Hi all, new to Rust, from a Java background. Short version: I can create a Vec&lt;u8&gt; and take a slice using as_slice() in O(1) I assume. How do I reverse the operation and get the original Vec&lt;u8&gt; in O(1) without copying / allocating? let mut v: Vec&lt;u8&gt; = vec![1, 2, 3]; let s = v.as_mut_slice(); // O(1) I assume let mut s2 = s.to_vec(); // unfortunately this allocates and copies into a new vec s[0] = 5; s2[0] = 6; println!("{:?}", s); // this prints 2 different values, println!("{:?}", s2); // is it possible to move s into s2, or point s2's underlying buffer back to s in O(1) Actual version: I'm using an external C function to populate a buffer. I'm trying to figure out how to turn the buffer back into an owned Vec type. let mut buf: Vec&lt;u8&gt; = Vec::with_capacity(large_capacity); let buf = buf[..].as_mut_ptr(); let buf: &amp;[u8] = unsafe { let large_size = extern_c_function(buf, large_capacity); std::slice::from_raw_parts(buf, large_size as usize) }; // how do I recover the original Vec&lt;u8&gt; from the buf without copying? 
When you want a difficult project to succeed, you'll choose Rust for the job. It's saved my butt countless times from having to debug a myriad of could-have-been issues, and has made many scenarios simple to implement due to the high level abstractions &amp; expressiveness. As a result, I believe progress has been made at a pace which would not have been possible with C or C++, and the quality is much better.
By the way, the wasm issue was related to `rand` crate. I swapped it out for `prng` and the web interface is now [working fine](https://bzar.github.io/sfxr-web/). [It didn't even need that much glue code](https://bzar.github.io/sfxr-web/).
It's unclear to me what you're asking. If you're starting with a `Vec` you own, you just don't throw away your reference to it (by shadowing it with a new `let buf = ...` declaration). If you're getting a pointer or a slice back from an external C function, you aren't allowed to turn it back into a `Vec`, even if there might be a `Vec` backing it. Inherent in the notion of a slice is the idea that it is borrowed. Slices can be borrowed from a constant array of `u8` in your executable's const data area, from a Vec allocated on the heap, or a buffer allocated on the stack. There is not always a Vec backing a slice.
Clippy breaks pretty often actually. You can always check their issues page for information :) https://github.com/rust-lang-nursery/rust-clippy/issues/2482
I do like the fact that Bruce Dawson immediately thought of Rust as a sibling project potentially impacted :)
Well, the same issue exists, only "Fucking bash" (or whatever shell you use), I haven't tested it, but I'd assume that `fselect path, size where name ~= '.*\\.rs$'` works.
I'll try to write a blog post about how I made on-stack timer/waitqueue items safe and allocation-free in my embedded scheduler.
Yeah, good point. I'd expect so.
I am having a lot of fun (and learning a lot of stuff) by going through your code and blog posts and experimenting with them on some of the microcontroller boards I have - thank you for the really amazing work you are doing!
I just wanted to say that this is actually very cool. 
Continuing work on [tarpaulin](https://github.com/xd009642/tarpaulin), last week I started offering a docker image for the latest develop versions on stable or nightly for users who like to live life on the edge. Also, got my new improved data structure refactoring done! There's a couple of percent difference in results so I appear to have added a slight regression so this week I'll be tracking down that and continuing testing to ensure it all works.
You can see the state of all the tools here: https://rust-lang-nursery.github.io/rust-toolstate/
Cool! Didn't know about that one.
The 2018 Roadmap specifically mentions improving Rust for embedded applications. The roadmap document itself was light on the details, because it is pretty hard to come up with a list of stuff to do on the spot for such a wide topic and I’m sure that more precise worklist will emerge over time.
&gt; Another problem is the lack of dynamic libraries. We use it to link together different ECUs/components for functional system tests on our test servers. Compiling all used permutations would take too long. Rust had dynamic libraries, just no stable ABI. If you control the build process for every lib that needn't be an issue. Otherwise, you can use the C ABI, even if both sides are rust internally.
That’s a really fun way to handle data protection and it seems like it would be a lot more flexible than the usual stuff baked into most languages. Do people frequently use these sorts of structures in practice or is this more of a type system exercise? I really enjoyed reading this. It explains things very clearly without dumbing things down to the point where it’s boring for the mathy part of my brain. I think it’s a great example of the sort of intermediate-level content that the community is looking for this year.
This was discussed on IRC last night (OK, this morning...) and we came up with [this macro](https://play.rust-lang.org/?gist=7b1b0b69e6467079ae42af697a267377&amp;amp=&amp;version=stable).
I think there exists a condition under which your fruit generation loop will never terminate :)
Mozilla has way more credibility as a web company than as an embedded vendor. And Rust is on more equal footing with other languages with WebAssembly. And many of the technologies developed for Servo can be reused or extended for client-side and WebAssembly as well. The main reason Rust is getting attention for embedded is because it just happens that the safety and performance focus is really true there as well, and it's a large industry that can't tolerate a garbage collector (you can't "stop the world" in a real-time system for an unknown amount of time).
You don't need a macro in that case, you can just use a normal function: fn out_of_bounds(len: usize, index: usize) -&gt; ! { panic!("index out of bounds: the len is {} but the index is {}", len, index) } 
I can't say for certain to what extent noninterference (or more broadly information flow control) has caught on in practice, but it's certainly popular in the academic PL and security world. I am aware of one major production-ready-ish example though where people used a type system that enforces (almost) noninterference to do something beyond simply enforce noninterference: [Obliv-C](http://oblivc.org/). Obliv-C is a sort of security type system bolted atop C that's used to program [secure multi-party computation](https://en.wikipedia.org/wiki/Secure_multi-party_computation) (in the cryptographic sense). So, you're able to write programs that type check against a system similar to my `Secret&lt;T&gt;` type, and then compile them to a program that will execute a distributed computation in a cryptographically secure fashion where it will maintain the privacy of each parties inputs. This is still academic research, but it's been leveraged in the applied crypto world to build [MPC versions](https://shelat.ccis.neu.edu/dl/stable-matching-ccs.pdf) of the [National Residency Matching Program](https://en.wikipedia.org/wiki/National_Resident_Matching_Program). One of the shortcomings of Obliv-C is that their type system is pretty ad-hoc (it was made by crypto people, not PL people!), and this is something I'm hoping to address using Rust (or a type system extension to Rust, if necessary).
**Secure multi-party computation** Secure multi-party computation (also known as secure computation, multi-party computation/MPC, or privacy-preserving computation) is a subfield of cryptography with the goal of creating methods for parties to jointly compute a function over their inputs while keeping those inputs private. Unlike traditional cryptographic tasks, where the adversary is outside the system of participants (an eavesdropper on the sender and receiver) the adversary in this model controls actual participants. These types of tasks started in the late 1970s with the work on mental poker, cryptographic work that simulates game playing over distances without requiring a trusted third party. *** **National Resident Matching Program** The National Resident Matching Program (NRMP), also called The Match, is a United States-based private non-profit non-governmental organization created in 1952 to place U.S. medical school students into residency training programs located in United States teaching hospitals. Its mission has since expanded to include the placement of U.S. citizen and non-U.S. citizen international medical school students and graduates into residency and fellowship training programs. In addition to the annual Main Residency Match that encompasses more than 43,000 applicants and 31,000 positions, the NRMP conducts Fellowship Matches for more than 60 subspecialties through its Specialties Matching Service (SMS). The NRMP is sponsored by a Board of Directors that includes medical school deans, teaching hospital executives, graduate medical education program directors, medical students and residents, and one public member. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It might look a little hacky, but you can emulate it with some unsafe code if index &gt;= len { unsafe { let _ = ::std::slice::from_raw_parts(1 as *const u8, len)[index]; } } 
Rust is soon going to stabilize trait specialization which is the end of parametricity.
 fselect path from /home/user/oldstuff depth 5, /home/user/newstuff depth 10 where name = '*.jpg' Commas in SQL mean cross product, not union. That is what `union` is for. Identical syntax for different semantics means familiarity is actually a downside rather then an upside.
There's a footnote about this, but the reality is that Rust and Haskell are not "properly" parametric anyway. It doesn't mean that we lose all reasoning principles from type parameters and modules.
lol, I forgot that default field visibility was private and this article was *very* confusing!
To check if I understand this right: * a slice is essentially (ptr, length) * a vec is essentially (ptr, length, capacity), where ptr points to heap allocated space * getting a &amp;[u8] slice from Vec&lt;u8&gt; using as_slice() is straightforward and O(1) * however, there's no way to safely convert a generic &amp;[u8] back to Vec&lt;u8&gt; in O(1) by pointing the Vec to the backing pointer, because &amp;[u8] might point to memory on the stack, const data area, etc. * to_vec() performs a copy, because it's creating a new Vec and performing a copy from the slice(which might be on e.g. stack) to heap allocated space, creating a valid Vec * I can recreate the Vec in O(1) without copying using Vec::from_raw_parts, assuming the original ptr was created using Vec::new I modified my code to the following: let mut buf: Vec&lt;u8&gt; = Vec::with_capacity(large_capacity); unsafe { // extern_c_function writes to buf and return bytes written, where large_size &lt;= large_capacity let large_size = extern_c_function(buf.as_mut_ptr(), large_capacity); buf.set_len(large_size); } 
Could you please change the SHA256/512 sections to bcrypt/scrypt instead? You provide nice type-level guarantees which would make password handling (and other stuff) more secure on the type-level, but using a single round of SHA (or any number of rounds without a salt, but even then memory-intense password derivation functions are currently more secure) to "protect" passwords is blasphemy ;)
&gt; tiny-keccak: A tiny implementation of SHA-3, SHAKE, Keccak, and sha3sum in rust
Couldn't you require taking a salt as an argument for the hash? I don't think my suggestion necessitates unsalted SHA256. Still, you're right that bcrypt/scrypt is a better recommendation. I'll change it. :)
Ok, then it looks like the PATH is configured properly since `~/.cargo/bin` is added to PATH. Also `cargo check` works fine when i run it from terminal. However, when i save a .rs file, literally nothing happens after saving (this means also no output in the Sublime console). I also noted that the following happens i f i want to choose any Build of Rust Enhanced: `Unable to find target command: cargo_exec`. Maybe it's related to the first problem?
I think it's a really stupid question, but so far, my Google-fu is failing me. What is the "magic" that converts a &amp;Vec&lt;u8&gt; or a &amp;[u8; 3] into a &amp;[u8]? More concretely, I want to build a struct that stores a generic "range" of values, something like: struct Foo&lt;T: BorrowIntoSliceOfU8&gt; { data: T, } fn bar&lt;T: BorrowIntoSliceOfU8&gt;(foo: &amp;Foo&lt;T&gt;) { let x: &amp;[u8] = &amp;foo.data; // do something } And instantiate it with Foo&lt;Vec&lt;u8&gt;&gt; and so on. What is `BorrowIntoSliceOfU8` supposed to be here? From the documentation, [Borrow&lt;u8&gt;](https://doc.rust-lang.org/std/borrow/trait.Borrow.html) should do the trick: &gt; In general, there may be several ways to "borrow" a piece of data. The typical ways of borrowing a type T are &amp;T (a shared borrow) and &amp;mut T (a mutable borrow). But types like Vec&lt;T&gt; provide additional kinds of borrows: the borrowed slices &amp;[T] and &amp;mut [T]. &gt; When writing generic code, it is often desirable to abstract over all ways of borrowing data from a given type. That is the role of the Borrow trait. That's exactly what I want, but it doesn't work: | 13 | let x: &amp;[u8] = &amp;foo.data; | ^^^^^^^^^ expected slice, found type parameter | = note: expected type `&amp;[u8]` found type `&amp;T` What am I missing?
I'm guessing because Package Control is down, that it is not able to update a required dependency. Do you have this in your Sublime console when you launch it? Package Control: The dependency 'shellenv' is not available This is preventing the plugin from loading properly. To fix this for now, you can check out a copy of [shellenv](https://github.com/codexns/shellenv) and put it in the Packages directory. Hopefully Package Control will be operating again soon.
[removed]
I've done a bit of digging. Indexing of a slice by usize is a compiler intrinsic. As is often the case for intrinsic operations, the library code is infinitely recursive - the compiler recognizes the intrinsic as a special case. Bottom line, I think that message may be hard-coded in the compiler itself. Intentionally violating the bounds of a dangling slice pointer would be the only way to invoke it. But I wouldn't recommend it. What if the compiler error changes in a nonsensical way, such as printing the address of the slice, or explicitly calling it a slice? You're better off with your own message, imo. *Panic messages are intended for human eyes only,* not being caught and handled programmatically. (Otherwise `Index::get`). So there's not much value to be gained from consistency. Panicking should be reserved for programmer errors or gross problems with the system environment (like, it's okay to panic when /tmp/ is full).
Fair enough, so long as you're not trying parse it or anything somewhere else. The standard/core library creates a panic for slice out-of-bounds using this utility function: #[inline(never)] #[cold] fn slice_index_len_fail(index: usize, len: usize) -&gt; ! { panic!("index {} out of range for slice of length {}", index, len); } from [Here](https://doc.rust-lang.org/src/core/slice/mod.rs.html#750) (Subject to line position changes in the future) I doubt the wording for it will change much by this point, so just base it on that. The `inline(never)` and `cold` just tells the compiler to explicitly use a function call so it doesn't bloat up index accesses instances with inlined panic creation code.
`!` to mark a diverging fn has existed for a while now, it's just the promotion of `!` to a type + the coersion rules which are unstable https://play.rust-lang.org/?gist=b4522c5f433d42ef061d01ff1ca2df7b&amp;version=stable
Actually, the `!` has worked in the return position since 1.0. It just wasn't a first-class type back then.
Maybe just `foo.data.borrow()`?
FYI /u/RagnaroekX
&gt; My gut said "no" Trust your gut. Splitting up things into files (modules) is meant to make thing easier to understand and maintain. Very small files are just as bad for maintainability as very large files. I would say modules are fine if they are between 100-1000 lines. Less than a few 100 and you don't even need to care more than a few thousand and you might want to consider splitting things up. But otherwise just split things by their relationship to each other and worry less about file length.
It's not the `Borrow` but the `Deref` trait that does the implicit coercion. For more mindbending coolness about `Borrow`, see [Holy std::borrow::Cow](https://llogiq.github.io/2015/07/09/cow.html).
Great article! Not only because you managed to simultaneously praise and one-up mraleph (see? Rustaceans are good at concurrency!😛), but also because you clearly showed the tradeoffs to be made. Also again Rust wins, not by competing but by cooperating (in this example with JS). This is a recurring theme and I like it a lot.
Ah... I should have known that. Oops.
You can use AsRef https://play.rust-lang.org/?gist=47dba171f3416b7dc70cac0010d61f06&amp;version=stable
I don't know how I didn't know that. Thanks.
Indeed i'm getting this message after starting sublime. After downloading shellenv and moving it to "Packages" i get the following: ImportError: No module named 'shellenv' reloading plugin rust-enhanced-master.toggle_setting plugins loaded Package Control: Installing 2 missing dependencies Package Control: The dependency 'shellenv-master' is not available Package Control: The dependency 'shellenv' is not available Dunno if i installed shellenv the wrong way. I'm very close to giving up ^^
It's the `Function` constructor. Does exactly what it says on the tin: creates a new function. If it had some sort of gotcha, I'd agree with you here, but it doesn't. &gt; I would have no clue why it's going through such a roundabout way of invoking a function if I hadn't read the article Of course. The code that goes an extra mile to be fast should have comments. Surely you don't think that the code as written for illustrating this article should be committed into a library?
Yes
The directory for shellenv needs to be exactly "shellenv" inside the Packages directory. I'm not sure how you installed it. Other options are to wait a day or two, I imagine Package Control should be up and running soon. Or, you can try VSCode, which also has excellent Rust support.
Are you sure it's by a larger margin? The maintainability cost of manual slab allocation in JavaScript increases rapidly as the amount of code that has to do it increases, while the maintainability cost of Rust (which can be viewed as a sort of DSL for this kind of code) is mostly constant.
Just use `rustfmt` and never again think about it. :)
Ok, guess i'll wait then. Your help was very much appreciated and i've learnt a couple new things about Sublime so it was not a waste of time!
Okay that works. Somewhat. I'm more confused than before. First of all, I thought Deref is what makes the dot `.` operator work, I wouldn't have guessed that &amp;foo involves a *De*ref? I clearly need to read up on this. :) Second, [u8; 3] doesn't implement Deref at all, yet &amp; works. Maybe arrays are "magic" here? (They seem to be in other places as well.)
Thanks, Borrow/borrow() works, AsRef/as_ref() works. I somehow thought that Borrow is the trait that's under the hood of &amp;, like Add is for +. Is it really just a method *called* borrow and has nothing to with actual borrowing?
That works for my usecase, thanks. I still wonder how "&amp; conversion" works exactly.
&gt; most importantly, how does it differ from `eval("function() { ... }")` I'm pretty sure the main difference is that js engines know that `new Function` can't modify the current scope while `eval` can. This results in a guaranteed de-optimization of the code containing the eval. This is a fringe feature. I used it back in 2012 when writing code that evaluated the Enthalpy/Entropy of steam (basically a set of functions plus a table of coefficients) but pretty much everybody who looks at the code thinks it's weird. Speaking of fringe eval features, the first argument to `setTimeout` can be a string of code to be evaluated.
The way I understand it is if you use &amp; on a T you are trying to borrow the type itself. If you use the borrow function on a type that implements borrow it performs the borrow. Does that make more sense? Maybe not the best explanation.
No. It's possible for a specific `Iterator` implementation to implement `count` more efficiently, but there's no current mechanism to have `Iterator::count` implemented in terms of `ExactSizeIterator::len` except when `ExactSizeIterator` isn't implemented. I'm not sure if specialization would help here or not. If you want to know what `Iterator::count` does, you need to check the specific implementation you've got. For example, [`slice::Iter` implements `Iterator::count`](https://doc.rust-lang.org/src/core/slice/mod.rs.html#1157) efficiently.
Are you using postgres? Diesel can currently support basic data models, useful for "hello world" type of database work. Versioning is more of an art than science. 1.0 doesn't mean a lot in Diesel's case. Until Diesel is mature, there is a viable alternative: rust-postgres and individual crates to support additional data types. Get ready to write a lot of string interpolation, though, and do other things that agitate your boilerplate senses. Rocket's author is stretched very thin for time so unless strong programmers step up to contribute it probably will follow a fate similar to iron. I don't see why strong programmers wouldn't adopt it and with the Sergio's blessing/guidance be able to push new features. I really hope to see asyncio Rocket with CSRF, multipart form, websockets and other features. Actix-web *does* support asyncio and websockets already. It's light on CSRF, multipart form, etc etc. In conclusion, these great projects need more contributors!
Thank you! This is really cool! 
Sometimes a trait is used to put some code behind an operator in the language, like `std::ops::Add` for the `+` operator. `Borrow` isn't like that. `Borrow` serves a logically similar purpose as the '&amp;' operator, but you have to explicitly use it when you want it. I think maybe you thought it created a new way of using the '&amp;' operator.
You might loop in some of the developers on https://github.com/davidar/lljvm &gt; my bachelor thesis Not saying it is, but be wary of ambitious projects. Even simple projects are ambitious. Try to find some scalability in the problem you are solving so it fails gracefully into something that is still useful instead of catastrophically. BTW, I think getting Rust running on the JVM would be amazing, esp if it had seamless bidirectional interop.
I think there has already been some work done in sulong (the LLVM IR interpreter for Graal) to support Rust: https://twitter.com/grimmer_m/status/895172035978178564 https://github.com/graalvm/sulong/pull/817
The references to the various parts of the session are not set. They all just point to the Youtube video itself, but not particular timepoints.
Yeah, I know about that one.
Good hint. Never looked into HIR before, I thought it is completely compiler-internal. Now, that I think about it - I really need to cut down my expectations. It is "just" a bachelor thesis after all. Should implement something where people (that may include myself) can build uppon. That may be a good cargo plugin for integrating sulong (if that does not exist yet, Google and crates.io says "no" at least)
I tried, but it gets way too noisy. If Rust had IDE support level of java — sure. I got tired of how noisy everything becomes. I do it like this: src/ rolo/ mod.rs &lt; trait, error type and shared helpers impl_1.rs &lt; impl #1 of a trait Rolo impl_2.rs &lt; impl #2 of a trait Rolo keyfile.rs &lt; self-contained struct and everything related to it. \ It's about 600 lines long. Can easily become it's own crate Much easier to navigate the project on github. Once module becomes too noisy — it gets extracted into the separate crate. &gt; However, many rubyists and node-ists may be comfortable creating a single data structure per file, They don't need to specify any types and import tons of traits.
It'd be an interesting thing to perhaps integrate off a fork of [miri](https://github.com/solson/miri)
Ahh missed that. Also there's cretonne, similar end goals: https://github.com/Cretonne/cretonne/blob/master/rustc.rst
I'm going to try build support for async web frameworks in [`oxide-auth`], specifically getting rid of required locking. A good coincidence that `actix` is getting a new release as that is the first which I intend to have land support for. On the side, I'm improving the `pnm` capabilities of [`image`]. The implementation tries to guarantee lossless decoding/encoding cycles for all decodable color types and being able to encode all color types. [`oxide-auth`]: https://crates.io/crate/oxide-auth [`image`]: https://github.com/PistonDevelopers/image/pull/730
It's a project that allows you to have a development environment for large scale open source projects in seconds. It's currently invite only, but usually the invites are accepted in a week.
Oh, that's so weird! They are correct when I edit the description contents :/ I'll try to find a way around it. For now, here they are: - First: recap + security groups + ssh keypairs - Parallel setup with rayon: https://www.youtube.com/watch?v=66INYb73yXo&amp;t=4004 - Logging with slog: https://www.youtube.com/watch?v=66INYb73yXo&amp;t=7291 - Cleanup with scopeguard: https://www.youtube.com/watch?v=66INYb73yXo&amp;t=12090 - Documenting the crate: https://www.youtube.com/watch?v=66INYb73yXo&amp;t=13025 - Publishing to crates.io + travis: https://www.youtube.com/watch?v=66INYb73yXo&amp;t=15253
Should now be fixed!
Can you explain why trait stabilization means no more parametricity?
Because you can write a function whose behavior differs based on what traits its parameters implement, even if that's not evident in the function signature. For example you could write a function that takes any type, and prints it with `Debug` if available, or else some fallback string.