I guess the most _current_ info about this is here: https://github.com/rust-lang/rust/issues/49177. But I can't really tell from that what the "mental roadmap" is for experimenting with Chalk inside rustc. I'm wondering things like: - Is this still super-early days, or are the authors optimistic about using Chalk for a small token subset of queries in nightly rustc soon-ish? - Is this work mostly in service of GAT experiments, or is there already a commitment to making Chalk "feature complete" with the current implementation? - How big of a task is that? (I assume _enormous_.) - What do we know about performance so far? I find this stuff similarly exciting as the integration of Miri for constant evaluation, so I'd love to hear more commentary from people who actually know what's going on! :) 
Well - Prometheus is a metrics framework, so I totally understand that it wouldn’t fit the bill (we use Prom extensively). Definitely seems similar to nagios et. al.
Wouldn't these crates be in the vast minority, and hence, an opt-out would make more sense than an opt-in?
With syntax highlighting, is a comment really that non-obvious to warrant making things harder for people having it harder to begin with?
Ada went beyond the Steelman requirements. E.g. addition to embedded it adding for general-purpose programming and OOP in ada95. Pre 95 it was only used for embedded systems. So Steelman isn't today Ada. :)
Ah yes. Logging. Always the first thing we should tone down when doing any sort of benchmarking :)
The "logic" is just a macro that generates a default implementation of the trait. In that sense, it's no different to any regular, non-marker trait you might write which *also* can't have opt-out implementations. Also, in general, Rust prefers things to be opt-in rather than opt-out. Opt-in means there's an explicit part of the source code that triggers something to be generated/included/called. Opt-out *would* be more convenient, but you could make that same argument about a lot of traits.
Makes sense - if it's not a marker, then it generates code, and code generation should be explicitly asked for by code. I would probably be more onboard with this if I didn't find the annotation syntax so ugly.
&gt;The OP appears to be a fan of Ada, and in my experience people well-versed in Ada are frustrated that Rust appears to have successfully appropriated the terminology of "safety" that Ada has been unsuccessfully trying to use as a marketing tool for several decades. OP, I'm a fan of Rust. Ada is a better language for embedded reliability. So we could of it in general. :) 
Yeah it would definitely need to become a language feature, which yeah I agree may not be the best idea, but it could in theory be solved, even if it's some effort. But yeah it may just not be worth it.
Are you perhaps not a native English speaker? I don't mean to be rude, you're writing is mostly fine. I just don't understand what you mean by: &gt; I'm going to question some of a increase post too began a discussion Are you quoting someone else and objecting? Or are you quoting yourself from somewhere else? I also don't understand what is meant by "write-only language." From context I think you mean it's designed to write your intended semantics, but not designed to be easily or readily read. If so I think Rust is quite readable once you are able to write it. Rust certainly forces the programmer to work through the design aspects of system code. Long-term maintenance has long been part of Rust's story, given it's commitment to backwards compatibility. Due to it's type system, this also enforces every programmer on a project to respect a systems data, and function signatures in Rust present a high degree of inherent documentation. This makes refactoring efforts far easier and mistakes or violation of a project's extant designs obvious. These aspects that promote maintainable code also promote implementation and design. I'd need more specifics on what precisely Ada is doing that Rust isn't if the claim is that these things are not seen in Rust. I see the disparity between the two languages more in the realm of what compiler enforced guarantees are first class language features, which affects the viability of a language in particular use cases. I certainly can see Rust maturing into many of Ada's use-cases.
Sure - but presumably the developers of winapi would be competent enough that they would recognise the need to opt-out of debug, and this would therefore be a non-issue? Unless the very act of opting-out would itself be a compile-time cost?
You could write a macro and derive_debug! { struct Foo { ... } struct Bar { ... } } if you really don't want to see the annotations. ;)
The person you're responding to is quoting a comment from the linked thread.
Their compiler isn't available yet to the public. They are slowly rolling it out to larger groups over the next months though.
I'm having trouble with the borrow checker here: https://play.rust-lang.org/?gist=26ef938f2547dd346ccedb6b651ddd02&amp;version=undefined I'm following along with cs198, and I've build a binary search tree, BST&lt;T&gt;, and written an iterator for &amp; BST &lt;T&gt;, and I'm trying to write an iterator for &amp;mut BST&lt;T&gt;. I seem to be struggling with being able to return a reference from Iterator::next() that has the lifetime of the actual IntoIterator object. I'm at a bit of a loss. Any ideas?
Is project for torturing heretics and Jews into converting to Catholicism? 
Thanks!
It looks like a bot has discovered and linked the crosspost anyway and linked back to here, so people interested in the continued conversation can make their way here anyway.
It seems like it would be possible to autogenerate the derive for any type that didn't have it when the `{:?}` formatter was used. Maybe turn that off for release builds.
I almost wonder if something like that could be written in as a plugin for the typechecker?
You asked for it: https://github.com/boomshroom/Neos It's not actually Pony, but it was one of the inspirations for it.
I'd argue for explicitness in order to more easily restrict breaking changes. We know some types don't implement Debug. Raw pointers, for instance, have no best Debug implementation, and some structs can opt out in order to save compile time. What happens when a struct deriving Debug has a non-Debug field? With Debug deriving opt-in, the compiler can explicitly error if there's a non-debug field. If it were opt-out, this would mean the structure just doesn't hove Debug if its fields don't. This brings us back to something similar to why Copy isn't automatic and why types are explicit at function boundaries: Rust's ideology includes making _breaking changes explicit_. If a structure automatically implements Debug, and a library author adds a field to it which does not implement Debug, then that structure suddenly also does not implement Debug. This change could then be very subtle, and allow the library author to accidentally commit a breaking change in a minor/patch version. Having deriving Debug explicit means any structure implementing Debug has at least one line of code which will fail to compile if that structure's layout changes and it's no longer Debugable. This means one less way for seemingly innocent commits to be breaking changes.
This might help. Unfortunately, rust doesn’t allow trait objects of multiple unrelated traits. For example, `Box&lt;Any + Debug&gt; `is not allowed. The [mopa crate](https://github.com/chris-morgan/mopa) lets us get around this by deriving all of Any’s methods for a new trait `AnyDebug` with the bound `Any + Debug.` `AnyDebug` now allows downcasting and printing. #[macro_use] extern crate mopa; use std::fmt::Debug; trait AnyDebug: mopa::Any + Debug {} mopafy!(AnyDebug); #[derive(Debug)] struct Foo; impl AnyDebug for Foo {} fn main() { let foo: Box&lt;AnyDebug&gt; = Box::new(Foo); println!("{:?}", foo); } [Here is example showing how fold a list containing different types.](https://gist.github.com/henninglive/0b111ce749803247ff3739d770f73398)
I think it's about philosophy and consistency. Nothing should be derived by default, everything should be opt in. No magic is done in just for "debug" or whatever the next good-to-implement-most-of-the-time trait may be, even if it costs code. I appreciate this lack of surprise.
I'm not sure how helpful this really is. I hope I can offer some criticism you might find helpful. You start by briefly explaining the concepts of the stack and the heap, but I'm not convinced that you can really introduce and explain these concepts in a way that helpful in under two minutes. So then, the video is only really useful to someone who already has some idea what these concepts are. Given that, I'm not sure that super basic analogy is the best approach, since what you really want to do is make sure the audience *remembers* these concepts so you can expand on them. You then introduce the various rules of ownership in order of complexity, but I think this is a bit of a mistake. The notion of deconstructing/dropping is the most complex of the rules, but it also motivates the other rules. *Why* can we just copy something on the solely stack, while we have to move something that owns heap storage (especially when so many other languages don't have this distinction)? Because we want to drop it exactly once*, and make sure no one tries to use it after we do. One of the example you use is kind of confusing. You mention how the stack part of a String can't just be copied because if the string contents are changed, the one of the Strings would suddenly be wrong. IMO this is a bit confusing because it's only true for mutations that change the length of the string, changing "Hello" to "Hellp" is the first example I think of when you say this, and that wouldn't cause any problems. Plus there's no intrinsic reason this has to be true for strings, a different implementation could get around this issue if it weren't for the problem of dropping the strings. I feel like I've rambled to long complaining, so to end off I'd like to say that I do really appreciate the effort your putting into teaching people rust concepts, and that I really like your animation style. *Well ideally at least
I can see three reasons: 1. as /u/143778963214 remarks, code bloat could be an issue 2. as /u/Quxxy remarks, having an opt-in means the author of a type is aware of its restrictions and will be alert to the auto-derive's requirements 3. It's [easier to forget an opt-out](https://www.ralfj.de/blog/2017/06/09/mutexguard-sync.html) than we'd like, and some types may contain sensitive information, so they absolutely positively shouldn't auto-derive `Debug`.
How do generics get around this? Some fn(T) -&gt; T can't be preemptively reified for every type, right?
I don't understand how those are related.
afaiu generic functions aren't monomorphized unless they are used, so the concept is abstractly similar 
Yes. Relying on syntax highlighting is a crutch. Of course most editors have it, but it's less common in tools such as diff/merge tools. You asked for actual reasons, and I provided them. As far as I know the only reason for block comments is "nicer to work with for deaf programmers" which is almost certainly less than 1% of all Rust programmers. The Rust team made the right decision in making line comments the default. I hope they continue to make the right decision and push back against changing the default to block comments.
Never heard of it before, but looks pretty neat!
Firstly, I want to say thank you for the comment! I will explain some of the rationale, but honestly loved hearing your examples, thoughts and critique. I definitely agree that the stack and heap examples are not comprehensive. For starters, I don't properly explain adding your own blocks with curly braces, where you could access the outer scopes. Anyone who knows the memory machinery will not need the analogies used. On the other hand, the person I tested the script on, was most receptive to this grossly simplified example. So a bit about that. My test audience member is someone from a dynamic language background, who never wants to think about the stack or heap. When I was writing the script, I had more about dropping and double freeing, but the content fell flat. It's was hard to convey the dropping of memory as a problem to someone who has never needed to think about dropping memory. This is where the variable indirection to the heap example came from. I agree that "Hellp" is a fantastic counter example which I legitimately didn't think of!!! I still hope some people get the underlying point that two owners through a pointer would be bad. I need more test subjects, and if anyone wants to help review scripts, I would love it!!!! I hope I provided another take on this area of Rust, and provided value to someone. Thank you again for the comment. I will strive to make future videos better. 
... but generic types are a language feature and `Debug` isn't, which leads back to what I said about what making `Debug` a language feature would entail.
In c++ library authors will often have a default template parameter to avoid code bloat. This could translate to rust, although it's quite hacky. trait Debug { fn fmt&lt;T = ()&gt;(/*params*/); } It doesn't require `Debug` to be a language feature, but it does require a new language feature.
&gt; As far as I know the only reason for block comments is "nicer to work with for deaf programmers" which is almost certainly less than 1% of all Rust programmers. Blind programmers, not deaf.
I just opened an [issue](https://github.com/rust-lang-nursery/fmt-rfcs/issues/120) in the style guide to see if there's any interest in changing that default. :) Thanks for highlighting that!
See it in action here: https://godbolt.org/g/ohRiwt The code for `bar` gets generated, but not `foo`
I know no one else in this thread but I vouch for this poster: I have known this person for years and can confirm that he/she is a real person and their assessment of the person above is good enough for me.
Thank you for watching :) (and the feedback)
Eheheh. Nice.
Can you also test with the Java version?
Wait could you implement FnMut in a way where you can do recursive calls? 
Maybe Rust could use intrinsic like: ``` // works for any `T` fn unsafe_force_debug&lt;T&gt;(any: T, f: &amp;mut Formatter); ``` which would output string like as `#[derive(Debug)]` was applied to `T`.
As much as I'd hate to lose yet another Meetup member to Berlin, best of luck!
eh, I'm not particularly interested in that for a couple of reasons. To get Java to perform at that rate requires some tuning, etc, and generally you won't get it out of the box. What was most intriguing to me about that performance was that it was done with an out of the box solution, and not async at that. That's what really startled me and my coworker which is why we immediately attempted to repro it.
Thank you for writing this up. It appears clojure-sawwy translates quite well into Rust-sawwy. Regarding completions, may I suggest you try IntelliJ with the Rust plugin? It may be a long shot from emacs, but the features are *very* good. Apart from that, if you want your code to become more idiomatic, grab a nightly compiler via [rustup](https://rustup.rs) and `cargo +nightly install clippy` so you can `cargo clippy` your code, giving you many more suggestions than plain rustc.
Thank you for your comment, I'm definitely checking my code with tools like clippy, when I get a chance to spend some more time on the project. Regarding intellij I'll try it out, but I find myself the most productive when using emacs.
Fair enough. I was asking to see if the ratio stays the same on your hardware/setup, but it's not that interesting. Were the tests done on an empty database? Being sync would probably make it slower if the database was on a different machine or took longer to respond, or with a larger concurrency level.
Hi. It seems we're using the same thing. Spacemacs' layer uses racer, which I also use in my emacs setup. The problem is that 1. It doesn't complete macros 2. It doesn't work for anything derived directly or transitively from macro return value 3. Sometimes id doesn't work due to inferring, it just fails to give any completions at all So I'm not saying that it doesn't work. I'm saying it doesn't work well enough. At least for me.. it's possible that there is some misconfiguration on my side, but I certainly saw a note about macro completion in racer
We tested with the setup from the articles linked repo, and yes it was an empty MySQL DB. Definitely not a real world work-load, but still fun. I think async with something like actix-web and/or gotham, would be interesting as a comparison. Neither of those is quite as simple as Rocket though. Once all the features Rocket is relying on stabilize, I’m hoping it’s fancy annotations could be ported to those other libraries. I haven’t had time yet myself to see about doing that now with nightly...
&gt; The most important change is that fui now also automatically generates CLI interface from its TUI config. That's the feature which makes me sit up and take notice of `fui`. Given that you're building on top of `clap`, do you also have a mechanism in place for taking advantage of clap's support for generating shell completions?
Thanks for the feedback! &gt; My project is not big, but I think with incremental compilation this workflow could work on big project as well. I hope you're right but I have a lot of doubts to be honest.
Yes, I admit that this part arguable and I also have doubts, but there should be a way and I will look into solutions as projects that I make in Rust grow in LOC.
I realize this post is now 2 months old- but this information should be useful to anyone else looking at it. I just found a crate which seems to match the OP exactly, and remembered not having a good answer to this post when answering it before. https://crates.io/crates/route-recognizer is a web-server-independent URL routing crate.
Another suggestion here: Visual Studio Code with the Rust plugin (uses RLS) is quite good. You've already stated multiple times that you prefer emacs, so you probably won't care about VS Code, but maybe just give it a try. It's become my daily rust driver, despite the fact that I'm veeery wary when it comes to electron-based editors :) ...Now that you've mentioned emacs, that reminds me, some day I gotta go back to Spacemacs and properly learn it. Such a great development environment.
Hi thanks you for the suggestion. I used to watch some channel with tutorials in Rust. I think [this one](https://www.youtube.com/playlist?list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW), and it seems like it works well. But I think RLS that you mentioned and LSP that I tried to use are the same thing - language server protocol. [Here](https://github.com/emacs-lsp/lsp-rust) is the package, it says that it works on top of RLS. I couldn't make it work in emacs in a reasonable amount of time, so I went racer which I already had set up.
They were simply designed that way originally, I think. There was no special *need* for commas when the whole expression was surrounded with `{}`, since those remove any parsing ambiguity. Looking through the RFC repository, it looks like this has been how matches worked since they were originally introduced, and there wasn't really a formal design mentioned for why they were introduced this way. https://internals.rust-lang.org/t/clarify-the-syntax-of-match-expressions/451 is one of the earliest discussions I found about the issue.
To me as for many other people emacs is not only about code editing, it's about powerful git integration (I think magit is the king in this field), ease of extensibility, transparent editing over ssh, terminal, etc in a single tool. But I'm definitely checking out intellij, vccode and other as soon as I have time for that. Then I'll decide whether their functionality worth a switch or not.
I use spacemacs and the rust layer comes with auto completion that just works. It also has red squiggles under code that does not compile and hovering that shows compilation errors. 
Yup, I can totally see that. I never *really* grokked magit, and, well, emacs in general, but I can see how you fall in love with those tools. GDB integration, too....man I gotta get back on emacs.
Please refer to this [comment](https://www.reddit.com/r/rust/comments/868suv/rust_first_impression_from_clojure_developer/dw3cx4i/) on my thoughts about racer. It works for me as well, but not always
Haha, I'm glad that my post makes some good influence, even if it's not about rust
The number one reason I decide to check out Rust was the design of the Send and Sync types. I have programmed a lot of concurrent software and have had to debug some very nasty issues while writing that code, or fixing code that wasn’t originally concurrent. For 15 years, I had never seen a language that convinced me that it was safer and faster than Java. Ada has the memory safety, but the syntax never looked pleasant to me. It is too Pascal like for my taste. C like syntax has allowed me to quickly jump into various languages, like python, Ruby, C++, Java, Rust, Go, etc. I’m definitely more likely to try a C like language than anything else because it’s familiar. So when Rust came along with this added data-race safety built-in, plus being memory safe I had to try it, and the syntax was welcoming and made the transition easier. Some of the comments in the original thread make it clear that that bias exists, but exactly in the opposite direction for the ada devs. I was of course aware of Ada, but I looked at it, didn’t like the aesthetics and never looked again. There was no loss, why? I had Java and it was good enough. The bigger thing I get from that thread, that worries me more is that there is an idea that Rust doesn’t have staying power. I’m of course biased, and think it’s the greatest language of all time, warts and all, but that idea that it’s not going to stick is the thing I think we need to fight most. I do believe the language will grow, there are new products everyday it seems reaching first releases, and that makes sense given it’s only been stable since 2015. Anyway this is a long rambling way of me saying, the Ada devs have stuck with Ada for decades, I doubt they’ll be changing soon, and they will be put off by the aesthetics just like I am by ada. But I don’t think that’s necessarily where our growth will come from. I think it will come from people who start recognizing that they can get all the safety they have in their high-level languages, but without any of the trade offs, and a better type system. But first they have to make it through 3-4 weeks of fighting the borrow checker and persevering. That first month is the critical period while people learn the language, and it’s where I see the most people turn away and go back to the warm comfort of Java (or favorite language here) deciding it’s just not worth the effort. How do we get people to realize that learning Rust is worth it if they haven’t hit major bugs in their career around concurrency and/or memory safety? Ada May provide some lessons here. 
Make a `README` my man
In Rust costs are explicit and opt in: you don’t pay for what you don’t use. If you derive default automatically, you make everybody pay for something they might not use.
Quick question: am I supposed to not get any help with function args with VS Code and the Rust plugin? With other languages I get this as I type (can be explicitly brought up via ctrl+shift+space): https://i.imgur.com/WyrEcSV.png Doing the same thing with Rust, I get nothing of the sort. I have to hover my mouse over the function name to see the signature, with no indication of which argument I'm currently typing.
Nice to read that, thanks.
Sure, that sounds good.
i guess this is the expected behavior, atleast i'm not getting any completion for args aswell.
Author of _directories_ here. Nice to see that `app_dirs` gets some maintenance again! `app_dirs` and `directories` have a different design philosophy, so give them a try and figure out what works best for you! _directories_ tries to be as minimal as possible, while trying to make sure that users never have to assemble paths by hand (which can be error-prone and unintuitive). You basically have three structs: `BaseDirs`, which provides you with the generic paths to config, cache, data, executable, and runtime directories. `UserDirs`, which provides you with paths to download, document, music and video directories. `ProjectDirs`, which allows you to derive the correct config, cache, data locations for your application. This is more tricky than most people think, and the API is designed in a way to obey the various operating system conventions without requiring users to know the exact details. That's why the `ProjectDirs::from(qualifier: &amp;str, organization: &amp;str, application: &amp;str)` function looks the way it does. You provide the API with information about your application, e. g. ProjectDirs::from("uk.co", "Mega Corp", "Bar App"); and you get the correct application paths for each operating system. The above call for instance would use - "barapp" on Linux - "uk.co.Mega-Corp.Bar-App" on macOS - "Mega Corp\BarApp" on Windows This is one of the things other crates don't seem to get universally right. Also, the _directories_ crate does not create any directories or check for their existence, it only conveys where the directories _should_ be. This is intentional, because the decision on whether to create/use those directories is often very application-specific. For instance if you still need to support some legacy ".app" directory scheme, you might want to use that directory if it exists, and forgo the creation of the more correct directories completely.
Random reads are 2 orders of magnitudes of slower than sequential reads but SSDs offer parallelism, so you can send concurrent read request and achieve near sequential performance on SSDs. There are many other optimizations which are possible.
Huh. Interesting. Same thing on my end, never really thought about that. I think this may just be...not implemented yet? Would definitely be a nice feature. Tangentially, I'm still hoping Rust gets named arguments someday, in my experience those help readability a lot :/
Also with very large types. (Stylo has some enums with multiple hundreds of variants each.)
&gt; How do we get people to realize that learning Rust is worth it if they haven’t hit major bugs in their career around concurrency and/or memory safety? Libraries, Libraries, and Libraries. Oh, yeah, and more Libraries. Did I mention Libraries? Let's not forget, documentation.....for Libraries! Seriously, everything else is secondary when it comes to convincing people to use and/or convert to a language. Syntax can be learned. Semantics can be learned. But, most just don't have the time to create ALL the libraries they need. The more the community focuses on good, solid, useful libraries/crates the faster the community and Rust will grow. It's as simple as that IMHO.
It would be helpful if you could provide a more complete code sample, as this might be related to type inference. Intuitively, I agree `&lt;Self::Hasher as Hasher&gt;::Output` should only be required to disambiguate.
**[Live Twitch Clip (Clip + Chat) on Streamable](https://streamable.com/tn9wb)** Credit to [twitch.tv / thesuperNem](https://www.twitch.tv/thesupernem) for the content. --------------------------------------- ^(Bot to preserve unique live stream experience forever by rendering chat as part of the mirror video. | ) [^feedback](https://www.reddit.com/message/compose/?to=LiveTwitchClips)
Thanks for sharing! I've done the same journey, programmed Clojure, then did a front-end thing in Elm and fell in love. Now doing Rust for my low-level project. Thanks to it being mostly expressions (you can pry the lambdas from my cold dead hands...) and having the _amazing_ ownership- &amp; type-system, I can be confident in doing really low level stuff which would be far too boring in C. I miss being able to C-x C-e any expression very much, but if I have to choose between that or the speed and types of Rust, I choose Rust. Now, a Rust written in S-expressions would be something... 
&gt; Now, a Rust written in S-expressions would be something... [well, lol](https://github.com/JunSuzukiJapan/macro-lisp)
I offer him free skin verification and he kills me, what gives ?
r/playrust
I have a very unclear feeling about ML family of languages. It looks cool on paper, in books, in tutorials, but from my personal experience the real code in real software looks unreadable. Often people go so deep into type theory, so their code stops making any sense for normal human beings. I'm talking mostly about haskell, but I don't know if situation improved in elm. Rust looks like a thing that you can totally use in real projects without going too crazy about abstractions. You might want to check out [this](https://github.com/carp-lang/Carp) one. It's a statically typed lisp without gc. Almost rust in S-expressions, but I'm afraid it's not mature enough to use in real project.
Yes, as you noted we don't have the cycle breaking / garbage collector in Rust, so it is not exactly the same.
Did you try to use Reddit's search? https://www.reddit.com/r/rust/comments/7zh64m/iron_framework_no_longer_maintained/
I too can recommend Intellij with the Rust + Cargo plugins, it works better than RLS + other editors. But it is a full blown IDE so if you want something lighter than that you are out of luck I think.
I don't know why, but when you switch from physical to [cloud hardware](https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=cl&amp;test=db), looks like the performance they measured go down a lot. Measurements are worse for every framework, but actix loses its place there. They uploaded their cloud results around a week ago.
Actix just needs some tuning. I didn’t know about cloud benches when wrote test code
This subreddit is about Rust programming language. For the video game Rust, visit [r/playrust](https://www.reddit.com/r/playrust).
Not sure if I'm, understanding this correctly. I think this is a valid concern, but I think something like this is best addressed in a more high-level library, maybe something discussed in the [CLI-WG](https://github.com/rust-lang-nursery/cli-wg/issues/7). Correctly handling paths in Rust seems to be a lost cause to me. The `PathBuf` API is just broken. That's not Rust-specific, but a repeating pattern where not cleanly separating relative paths from absolute paths will lead to error-prone APIs irregardless of the language.
Is there a good reason for tokio-minihttp to be that slow?
Actually, I think the attribute syntax can work with procedural macros. Rocket had an experimental port to those, but it wasn't merged because it regressed the error reporting for its lints (it can warn about e.g. unmapped routes). For Gotham, I think https://github.com/gotham-rs/gotham/issues/11 might be worth watching.
Thanks for mentioning this! Hadn't I read reddit, I wouldn't have known. I feel like there is a discoverability problem with Rust events in Berlin. :-/
`Send` and `Sync` are derived by default, to be fair.
It was never really designed for more than hello world, so who knows.
Love it. Tock is such a cool project.
You might want to use CLion instead of plain IntelliJ; it's their C/C++ focused build.
I think the kind of operations you want to perform on an enum is sufficiently different from an Iterator. But if you want to persuade me then show me some examples :-)
True, but I think "similar" without any elaboration feels like a bit of an understatement.
I think all the things I am missing are similar to features that Ada has since lot of time. No full dependent types required.
You pay something to have static typing in a language, so better to reap the benefits of static typing as much as possible, especially in a language as Rust where correctness and safety was one of its few main design points since lot of time.
What benefits does CLion has over Intellij CE? Debugger?
It works for me, currently with racer, though. Before, I used the vscode extension rust code (or similar name) with rls. There I had no arg preview but instead the arguments were filled in with place holder names.
That's the biggie, in my understanding. I'm still quite new to it and JetBrains products in general.
Well, it's not a lost cause because in this very topic there is a crate doing 'unofficial v2'. Maybe it should have been moved out of the stdlib though. I'm honestly pretty pissed as a user in general that i can't move cfg files from windows to linux and vice-versa without doing \\ &lt;=&gt; / manually.
Someone is going to downvote me here, but what I don't like about JetBrains products in general is that they don't offer **lifetime** license. I don't care if it would cost 500 dollars, but I just want to purchase it once and use till the technological singularity happens.
I appreciate that. The initial post of the newsletter even had the date wrong, as we missed updating the calendar: https://github.com/cmr/this-week-in-rust/pull/617. It's poor quality. We also want to grow the meetup by making the talk even more regular again, but we're just out of time. The most aggressive fix for that: take that off the hands of me and Johann. I'm only half joking, we're both involved in organising the all-hands, have some leadership capacity in the Rust project and keep the event going every 2 weeks. We'd be very happy if we found someone who took reponsibility of that.
Ack, yes, of course. I still stand by my point though.
Yep, unfortunately that's not implemented yet. The tracking issue is at https://github.com/rust-lang-nursery/rls/issues/97, but there hasn't been much work on this recently. (We'd love contributions though!)
Those are zero-sized and are only relevant at compile time.
He did show it off multiple times and I‘m pretty sure he was talking about millions at least once during those times. But tbh it‘s been a while, so I may just misremember it. It doesn‘t quite matter though, the point I was trying to make is that your compiler can be very fast and have debug for everything, so it‘s not a valid point to claim that it would make the compile times unbearable. Maybe at rustc‘s current state yeah, but in general this is not true.
Do you mean *lifetime* == *updates for a lifetime* or *lifetime* == *can use it indefinitly*? Because you get [#2](https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-perpetual-fallback-license-) 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-perpetual-fallback-license-) - Previous text "#2" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Ideally both :)
I'm quite time constrained myself, but let's see what I can do. Let's talk at the meetup next week.
Awesome, thanks for the write-up! I'm not a very experienced Rust developer yet, but one rule helped me with the functions that return `Option`, and that is to replace every instance of `unwrap` with `expect`. Basically if you call one of these methods, it means your code has an invariant. You should put the description of the invariant in the parameter string of the `expect` method invocation, and it will work like an assertion. So this hypothetical Rust: socket := listen("localhost:8080").expect("Could not listen on localhost:8080"); Would be a bit like this in a less pretty language: socket = listen("localhost:8080"); ASSERT(socket, "Could not listen on localhost:8080"); The main difference being of course that Rust forces you to make the assertion, either silently using `unwrap`, or loudly with `expect`. And in this case I see no argument for doing such a thing silently, if you're doing it anyway.
I'm actually thinking of just finding a specific date for that and just see who comes. But yes, let's talk!
Hi thanks for the feedback! I divide unwrap and expect into the same group of stuff that I'm going to get rid of. Both of these functions panic. While in real production it's unacceptable. For example I had an unwrap call in iron http handler, which made iron thread panic. I general every unwrap or except call should be replaced with match with logic that properly handles both cases, or with map, unwrap_or and other kind of stuff which Option and Result structs have lots of. That said I think in your example panic is totally fine, because you couldn't start a server and there is nothing else to do other than exiting with an error.
No memory is wasted, the first array is 10*4 bytes long and the second is 5*4 bytes long. I have used a new syntax: a second optional semicolon that allows to specify the index type. The compiler allows you to use only that type to index (the default is "; usize"). The first array starts from the 'A' index, this means the compiler removes b'A' from all indexing operations. The impl you have shown seems OK. The advantage of having a way a built-in way to specify more strongly typed indexes is that nearly no one writes your impl , and you can use it for free array types like Arr1 too.
Just submit PR
I’m not currently on a device that would permit me to do that, nor am I sure exactly where to submit said PR. I would appreciate it if you could reverse this ASAP given it was not something the Gotham community wanted or was ready for - thankyou.
No worries, I was puzzled too.
Sure I totally inderstand this point, that's why I said I'm going to be downvoted for this. We're not in perfect world and there are no miracles. That's one more reason why all my development tools are opensource.
Did you try in fact Scala? I gave it a chance and I recall it as a very pleasant experience lasting three months. Well, in the end I found some incompatibilities with my way of doing stuff (lack of complete and easily accessible documentation forces to dig into source code, hard to use build tools when I want it to just work and very poor Play documentation as I hoped I could build a website with it without so much trouble). What I'm trying to say is that Scala (with it's ecosystem) may not be your next favorite language but it still have many great features and &gt; may or may not fail at runtime with a java.lang.NullPointerException doesn't seam familiar to me at all… I've just never experienced it even though I was using Java libraries with Scala. &gt; and needs a 4GB JVM running also not sure if that really could happen. ----- &gt; Mutability is allowed, so you can get smashed with side effects smashed? ----- Overally your experiences sounds quite familiar to me. I've tried Go once but coming from Java to it didn't make me fill it's a progress in any way while at the same time I took away other things I took for granted.
&gt; Well, to be honest, it’s not really at “some totally random point” that it started not to feel right anymore, it was when I started to enjoy programming with a strongly typed language: Elm. Technically, Python too is strongly typed – it won’t let you do string operations on ints for example. But it is *dynamically* typed in contrast to *statically* typed Elm, or Rust.
Is it possible to restrict the maximum cache size? I'm running spotifyd on a raspberry pi and looking to use a tmpfs ramdisk for the cache to save unnecessary writes to the SD card.
I don't think so, since you would get invalid json. E.g. `[Foo]` is not valid, but `["Foo"]` is.
&gt; First feeling: learning Go was so easy. In one evening, I was able to compile a Proof Of Concept of the project with basic features developed and some tests written. Now that's the kind of learning curve we should aspire to.
PR: https://github.com/TechEmpower/FrameworkBenchmarks/pull/3443
I see your point and I'm kind of on the same page. I've also got some karma to burn, so let me chip in: if you choose unpaid software to develop software, someone, somewhere is paying the bill for you. (this brings us dangerously close to "there is no ethical consumption under capitalism...") IntelliJ is definitely for professional services where I see the price very justified. I'm constantly surprised which prices are seen as too high in the IT industry where others only laugh. A friend of mine installs fire detectors and carries around at least twice the worth of my computing equipment just in material and tools. Not to talk about the car he needs for that.
I would ask community
Why doesn't someone write a modern syntax front-end (or source-code translator) for ADA, then? That could get it some more interest, like Elixir for Erlang. Honestly I did try learning ADA and SPARK many years ago. It didn't ignite any kind of enthusiasm then, though. However, Rust is a superset of the language that I'd been designing in spare moments every time I got frustrated with C.
I case people are interested, I'd like to note that IntelliJ is very friendly and hands out licenses to FOSS developers. https://www.jetbrains.com/buy/opensource/
CLion would still force CMake to be the project file for Rust projects, right?
That's great news! And I think it might else engage more interest into making open source software
Because it's a topic that seems relatively easy while being strongly related to people's personal sense of aesthetics and other personal preferences. (And yes, `..=` makes my eyes bleed but I can see how `...` vs `..` could cause bugs.)
I pretty much agree with everything you just said.
I'm playing around with [circle packing](https://github.com/whostolemyhat/circles) using Cairo. Got it working in [circles](https://raw.githubusercontent.com/whostolemyhat/circles/master/example2.png) and [polyhedrons](https://raw.githubusercontent.com/whostolemyhat/circles/master/star.png) so far.
I personally consider the Haskell set of languages (Haskell, Elm, Purescript, etc) to be a different family than the ML set (SML, OCaml, F#) even though both are derived from ML. They have similarities but I find the mindset of the two communities to be different and that's reflected in the libraries. &gt; I'm talking mostly about haskell, but I don't know if situation improved in elm. The Elm community deliberately avoids all this stuff. The language itself is something of a minimum viable haskell and it drops a lot of fancier features (most notably type classes) in favor of writing more code and being easier to learn. The community motto is something like "let's bring functional programming to the masses." So the subset of the community that comes from Haskell will occasionally dip into the math/type theory terminology but everybody else tries to use non-math terms. When I was tracking it they would regularly have threads where they worked out how to explain some concept without the terminology. After exploring it, I decided I didn't want to do Elm. I don't like the purity and would rather do Fable (F#) or Reason (Ocaml) for frontend stuff even if they're less mature at the moment.
I disagree. There are plenty of things that are both worth learning *and* impossible for most people to learn in a single evening. Of course there should not be complexity for no good reason, but there is some inherent complexity in RAII and lifetimes that you just can't avoid. In addition, these things depend heavily on the experience of the one learning a new language. The author has years of python experience, so they have plenty of experience with garbage collection. In addition, they have probably seen a curly braces language before. So Go will be relatively easy to transition to. Rust doesn't have a GC and is very strict about avoiding use-after-free. Had the author been a c++ developer, they would have picked up Rust much faster. Being learnable in a single evening is not a realistic goal for rust, except for developers who already know all the concepts and are only missing the syntax.
It's even [optionally statically typed](http://mypy-lang.org/) these days. Though most existing libraries are not type annotated, which kinda reduces the usefulness of that…
Maybe it should be read as "can't unpin"?
The uniqueness rule of FnMut is a little weaker than "this function is not reentrant" in C documentation. The call method is still a *function* which keeps its locals in a stack frame, and if you intentionally write it recursively that can be safe. (Trust the borrow checker.) FnMut means that you can't accidentally cause recursion by calling another closure, or calling a closure with a closure, callbacks, etc. That sort of wacky functional stuff is safe in functional languages that don't allow mutation, and in Rust with `Fn` closures. And if you need to protect a strictly "no reentrancy" C/FORTRAN/assembly function, you can use locking, but a `&amp;mut self` method on a singleton is sufficient to guarantee that the proper locking is done elsewhere. (You may also need `impl !Send`.) These guarantees go away if &amp;mut references aren't unique. But in that situation the compiler's guarantee to faithfully translate your program *also* goes away. 
&gt; This is maybe only me, but from an outsider, the Haskell mindset seems elitist, the documentation and practical examples are lacking and it’s hardly accessible to a beginner. IMO this is couldn't be further from the truth, Haskell people are among the most welcoming programming community I've ever participated in, the people want to help you learn and care that you understand the underlying concepts. haskellbook.com has a wonderful book for Haskell. Scala is also a wonderful programming language, it's got abstract data types, great type system features... honestly it just seems like you made some knee-jerk decisions and decided to share them Still, I'm glad you're enjoying Rust and I wish you the best of luck.
&gt; [...] the Ada devs have stuck with Ada for decades, I doubt they’ll be changing soon [...]. But I don’t think that’s necessarily where our growth will come from. Imo that is very unfortunate. Not in terms of growths, but experience. I image that people who've spend decades building reliable software in a language that prioritises safety could have valuable input on Rusts further development.
&gt; don't offer lifetime license [IntelliJ is Open Source](https://github.com/JetBrains/intellij-community) and [MIT Licensed](https://github.com/JetBrains/intellij-community/blob/master/LICENSE.txt). Here is the [source](https://github.com/intellij-rust/intellij-rust) of the Rust plugin. 
Huh, I could have sworn they didn't, hm. Still, some structs do opt out of implementg Debug.
I think the important part is "aspire to" - as you note, we will probably never be able to make rust learnable for someone without a significant low-level language background in one evening, but that doesn't mean we cannot try to strive for making things as easily understandable as possible.
The topic is CLion though, which isn't.
My comment was about Clion in particular
I feel like your response is kinda rude. The OP wanted a lifetime access to the dev environment, my linked artifacts not only gives them that, but the full source. So while it doesn't supply a native debugger, it gives them everything else. 
I’d really like to help out with this, but it’s hard for me to tell by looking whether you’re looking for non-SI units for the open issues regarding new units. For at least a few of them, you’ve implemented SI units but they’re still open, so I assume this is the case; however, I don’t see any mention of non-SI units in the source as-is, or any issue mentioning a non-SI system. Is the intent to add non-SI before closing these issues?
Also 5D: Steelman forbids first-class functions.
I also agree about Scala. Rust and Scala are currently my favourite programming languages. I'd choose Rust where speed and low overhead is crucial, and Scala for anything else basically. Scalas ecosystem for backend development is huge and the Scala type system is really intuitive and powerful, although there are some warts in terms of type inference etc. (mostly fixed in Dotty though). In fact I see Rust slowly moving towards Scalas feature set (more powerful associated types, HKT, GC etc). And if you don't like the JVM, there's also ScalaJS and Scala Native.
I went the other way by learning Rust first and then Go. I really like Rust and _want_ to use it, but after trying Go it's been hard to justify the loss in productivity and the lack of mature libraries. Personally I think the standard library is too slim, and/or there are too few 'official' crates for the most common tasks. Looking open source projects written in Rust that target end-users (i.e. not libraries), most of them seem to be "isolated" and not interacting with anything other than the OS. I get that it's a systems programming language, but it would be fun to be able to write a CLI for an API with Rust. One day.
Have you looked at this?: http://cglab.ca/%7Eabeinges/blah/too-many-lists/book/second-iter-mut.html The key thing is, that `BSTMutRefIter` should look like this: pub struct BSTMutRefIter&lt;'a, T: 'a&gt; { next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;, } If I'm not mistaken, you don't want to operate on `&amp;mut Link` directly, but need the Option to take ownership over the thing you iterating over.
No, the comment you replied to wanted lifetime access to the JetBrains products, which are the things built on the platform. These are all non-free. The Debugger is the crucial feature of interest. Responding with a one-liner that explains that the base platform for those is open source is sidestepping the issue and evokes equally bad feelings. It's derailing.
Can you go further into the strategies actix uses to beat out other Rust frameworks, and how it intends to continue improving its performance?
Compared to native code, JVM stuff is much more memory hungry, that's just fact of life. But sometimes it does not matter much. I experience too many NPEs in Scala when interacting with Java libs, which is unavoidable in many situations. A also: Whole implicit things must have been designed by somebody under heavy drug influence.
Oh, cool! Given how much they've dragged their feet for working with Meson, I was concerned that it might be an issue for Cargo as well.
CPython does not check types though. CPython only supports optional type information and another tool has to be used for type checking.
&gt; Though most existing libraries are not type annotated, which kinda reduces the usefulness of that... [Typeshed](https://github.com/python/typeshed) is an initiative to provide external type annotations for those libraries which are not type annotated yet.
Yeah, but actually going into them and discussing how they affect your code and how the language handles these things - e.g. "why boxes? how are they different?" does require discussing the stack and the heap.
&gt; I think the standard library is too slim For a system language it's pretty fat.
Sure, but I think it's best to keep your aspirations realistic. If you aspire to be able to do one-armed pushups, you have something that is achievable for most healthy people (although some may have to work harder at it than others), and you can measure your progress and create some form of roadmap to get there. If you aspire to be able to do one-armed pushups while an adult elephant sits on your shoulders, you're just a deluded fool. :p I think it's wonderful to have ambitious aspirations, but silly to have impossible ones.
&gt; In Rust costs are explicit and opt in: you don’t pay for what you don’t use. &gt;If you derive default automatically, you make everybody pay for something they might not use. I disagree. Rust has all sorts of hidden costs if we include compile time - generics, for example. I don't see the slower compile time being a very significant issue.
Really, the way it should be is: * Maintain the opt-in nature (I'll justify below) * Have derive(Debug) or some alt-derive not care if a field doesn't impl Debug, just put a placeholder like the field name - there is a crate for this, and it's the more sane behavior The reason not to have 'debug' by default is, for me, security. Many things should not be printed to the screen - like passwords. Debug can also allow for 'tricks' to turn secrets into strings, and then display them. The real friction is when you want your struct to impl Debug, but some field doesn't - this is addressed by just putting in a placeholder.
"... we are going to relentlessly chase perfection, knowing full well we will not catch it, because nothing is perfect. But we are going to relentlessly chase it, because in the process we will catch excellence."
&gt; When people start saying stuff like "Go is a progress compared to Python", I unfortunately fail to take their conclusions seriously. They're both there occupying different spaces. I don't really like this attitude. People have difference experiences. For example, if I were inclined to this style of thinking, I might say something like, "When people start saying that Python has a good package manager, I unfortunately fail to take their conclusions seriously."
* to write performant code you actually need to do profiling and performance optimizations. running wrk and comparing results with nodejs or python is not enough. * measure, you can not go blind. TechEmpower actually helps a lot, their tests provides valuable information about regressions. * tests. performance optimizations work is extremely error prone
This is actually a pretty great solution - seems to maintain most of the existing semantics while removing a major point of friction. I wonder if there is some architectural reason why this couldn't be done, because if not I'd genuinely like to see it implemented.
I think there are still limits where we should not compromise the language for the sake of understandability.
I don't know that it would be backwards compatible to make the Debug crate work this way. I can't see how it wouldn't be. Just needs an RFC. The downside is that it may be 'unexpected' - for example, I derive Debug on a struct, print it out, but a field is missing! Maybe I care and would have wanted to know earlier. This is solvable too: ``` #[derive(DebugPartial)] struct Foo&lt;T&gt; { can_print: u64, #[skip_debug] cant_print: T } ``` Now it's explicit which fields won't be added to the debug impl.
&gt; Technically, Python too is strongly typed Technically, "strongly typed" means jack shit, so it's not like the author is using it wrong, you can't use a meaningless term the wrong way, aside from using it at all.
It could be implemented lazily. I don't know the details of the compiler but it doesn't strike my as hard to do.
If you implement the derive lazily, nobody pays for it unless they use it.
&gt; I don't really like this attitude. That I'm saying they're both there occupying different spaces? You're right. How obtuse of me to think they can both coexist.
Your point about security is a good one. How about (lazily) deriving the trait by default, but prompting a warning for each non-explicit use of it? That way it removes a bit of friction when prototyping, while still making potential security issues conspicuous.
"A witty saying proves nothing." It is easy to say you're chasing perfection, but without defining what perfection means, that seems pretty meaningless. In the context of that quote it seems pretty clear: the goal is a football team that plays as well as possible (and presumably is the best in the world). I'm pretty sure "a new player should be fully ready to participate after 1 training session" and "players should run 100 miles per hour" are *not* goals in that chase for perfection. If we must *relentlessly* chase learnability, then the path seems clear: change the semantics and syntax of Rust into those of Go, and we've already reduced the time it would have taken the article author to learn Rust by over 92%. Learnability isn't the *only* goal of Rust, and thus cannot be chased relentlessly; there are also goals such as 'can be used to build a cool browser engine' and 'as fast as C' and 'memory safety'. Perhaps we could say it is "chased, but only to the degree that it doesn't interfere too much with other goals"? I suppose that doesn't sound as cool.
That's what expect does, right?
I think you're reading way more into it than I intended.
TIL about `cargo watch -x test -x run`. Thanks!
No, this part: &gt; I unfortunately fail to take their conclusions seriously. 
&gt; although I don't think I ever met someone actually using a linked list he/she implemented Who does use code he wrote in his first year learning programming?
What common tasks are you missing?
Yeah, I believe it only seems easier to teach C over Rust because we all learned C first (or something like it) and so Rust seems "Advanced". But, if you start with learning something like Rust, it would just seem natural. IMHO.
Exactly. I also like the idea of still doing comparisons in C in a Rust course so the student would know why the compiler throws a warning and when it may be ok to drop the compiler checks using 'unsafe'. I'm pretty sure you can do straight C in those. So have exploitable unsafe C vs when it's fine for an optimization. 
That's actually pretty common in embedded development, along with not allowing recursion. This makes it easier to obtain a static high watermark for stack usage.
&gt; it would be fun to be able to write [...] a CLI for an API with Rust. One day. Oddly enough, we have the [CLI Working Group](https://internals.rust-lang.org/t/announcing-the-cli-working-group/6872) and would love your feedback on areas you find lacking in this space! If you haven't already, adding your voice to the [CLI Survey](https://goo.gl/forms/lqUTazC78j26ISu53) would be awesome and much appreciated :)
Yes, I think it's just an argument to practically never use `unwrap` when you can at least `expect`.
I don't agree with the conclusions of the link you cite or with the assertion that "strongly typed" is meangingless Modern programming language folks have a pretty clear and consistent definition of what "strongly typed" means. Without a formal language definition it's hard to formalize the notion of type safety, but the basic idea is that a program will not exhibit undefined behavior because of a failure to detect usage of a value of a type that does not match the context of use. Languages can be "strongly statically typed" like the safe sublanguage of Rust: the compiler guarantees type safety. They can be "strongly dynamically typed" like Python: the language checks types carefully at runtime. They can be "weakly typed" like C: many type problems are caught by the compiler, but not all. They can be "monotyped" like TCL: there's only one datatype (in TCL it's string) so the language is strongly typed by definition but the type system isn't doing anything useful. Fortran IV is intended to be strongly statically typed, although I don't recall how well it achieves that goal. I think Perl is strongly dynamically typed, although I don't know the language well enough to know what holes there are. Understanding the type system is a useful tool to me when I'm evaluating a programming language. I prefer strongly statically typed languages: they eliminate a whole class of runtime errors that otherwise do crop up in my programs. Failing that, I prefer strongly dynamically typed languages: at least the program won't do something weird or produce wrong answers in a bunch of important cases.
&gt; Compiler messages are not always straightforward to understand, especially when you’re combining futures and their strange long types. I agree that this can harm learnability. Here's a fun example (from my own project, not from the original submission): error[E0271]: type mismatch resolving `&lt;tokio::prelude::future::Select&lt;tokio::prelude::future::Map&lt;tokio::prelude::stream::ForEach&lt;tokio::prelude::stream::MapErr&lt;tokio::net::Incoming, [closure@src\main.rs:13:18: 13:49]&gt;, [closure@src\main.rs:14:19: 16:10], tokio::prelude::future::FutureResult&lt;(), ()&gt;&gt;, [closure@src\main.rs:26:25: 26:35]&gt;, tokio::prelude::future::Map&lt;tokio::prelude::stream::ForEach&lt;tokio::prelude::stream::MapErr&lt;tokio::net::Incoming, [closure@src\main.rs:20:18: 20:49]&gt;, [closure@src\main.rs:21:19: 23:10], tokio::prelude::future::FutureResult&lt;(), ()&gt;&gt;, [closure@src\main.rs:27:25: 27:35]&gt;&gt; as tokio::prelude::Future&gt;::Error == ()`
Interesting write up. I found that Go was just terribly annoying to actually get working correctly. GOPATH/GOROOT were just frustrating. Rust has cargo. Which I love. Its build system is just glorious. Yes, Python has tons of examples and libraries to use. Go has a rapidly expanding collection of libraries, but the documentation is two hundred miles left of annoying. I could only WISH it was merely annoying. Rust is growing. Other than that, I worry that learning rust will be a waste of energy when Mozilla abandons it.
I'm not him, but as a Python, Go, and Rust user, here are some of the kinds of things I find myself wishing was in the standard library when it comes to writing little CLI and related tasks: HTTPS client - (`urllib2` in python, `net/http` in go, 3rd party `reqwest` crate in rust). Reasonably wide variety of compression algorithms/common container formats - (`lzma`, `gzip`, `tarfile`, etc in python, `compress/*` in go, 3rd-party `flate2` in rust). All sorts of encoding/decoding capabilities including what's basically a weak version of `serde` built into the language - it's nice to save state/read things from JSON into structs easily (`json`/`pickle`/`marshal` in python, `encoding/*` in go, 3rd party crate `serde` + another 3rd party encoder/decoder in rust). Being able to write a u32 as a 4-byte big-endian integer kind of thing - (python's `struct`, go's `encoding/binary`, 3rd party `byteorder` crate in rust). some nice to haves come to mind: HTTPS server Some level of certificate/cryptography support A good-enough CLI parser like python's `argparse` or even go's very bare-bones `flags` (the `StructOpt` crate is my favorite 3rd-party library though!) The real target market that Rust misses, I think, is people who want to deploy Rust to accomplish small microservice-y and CLI tasks without a lot of boilerplate/searching for libraries/needing a C compiler. If I want to have a component make an HTTP request, grab some gziped JSON, and deserialize it into a known structure in Rust, and do some math/manipulation of the results, and store it to disk. I might be wrong here, but I think I will need these packages: - `serde` - `reqwest` (uh-oh, I'm on Linux, so I need to make sure I have the right version of openssl installed everywhere and a C compiler + toolchain) - `flate2` (compiler again...) I can do all that in python and go from the stdlib, and it makes a huge difference.
&gt;The problem is that, not providing a value to a struct is not a problem in Go. This value will default to it’s zero value and everything will compile. There's a lot of valid criticisms of Go (personally, I can't comprehend their "package manager"), but.. This is the deal breaker? Defaults for value types? If you want it to be mandatory to provide a value for a new struct, shouldn't you be using a constructor/factory instead?
Why specifically does this need to be in the standard library, though? The parent was saying packages they missed; this comment is largely a list of packages that exist.
Why does it being in the stdlib make a difference? The parent was saying that packages are missing, but your comment is mostly demonstrating that those packages exist. So, that seems to be the only difference. I don’t understand why one line in a file makes the world of difference here.
And here is the explanation I've found accidentally (it has been posted on on hackernews a few hours ago) and it explains the connection to the continued fraction approach: http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fractions/fareySB.html
That ^^^ :)
Just curious, why? 
I said "programming language folks", not "random people on the Internet". See e.g. Mitchell, *Foundations of Programming Languages*, sec. 4.5.4 for a definition of "type soundness" which is essentially type safety. Warning, though: the notation is a bit dense. [This is just literally the first book I grabbed off my shelf.] I'm not sure why you prefer "memory safe" to "strongly typed"? I know of no preferred definition for the former: it depends on what you want to be "safe" from. In operating systems, for example, a process is "memory safe" if it never tries to read or write in an area of memory that does not belong to it. That's not much, by programming language standards. People may misuse a technical term like "strongly typed". That doesn't make the term meaningless or worthless. Otherwise we'd have to give up on "quantum" altogether.
&gt; I would say that – unlike the strong-weak axis – the extrema of the static-dynamic axis are well defined (no static type checker on one end and no type information in runtime while having static types on the other), but I’m not sure I could unambiguously order everything in the middle – so I wouldn’t say that the whole axis is really well defined. Sure, that's fair, I'd say that the axis is not necessarily well-ordered or has a bit of give, but it's like physical directions, on macro-scale everybody agrees more or less where north is, on micro-scale things can get fuzzier (unless you're a Guugu Yimithirr or a Thaayorre and your entire system of direction is cardinal rather than relative). &gt; And I think that the continuous nature paired with no clear extrema is the problem of weak/strong distinction. To be meaningful, when speaking about strong language, you need some reference middle point. That's where I disagree, because when speaking about "strong typing" different people will give entirely different directions, and furthermore most of those directions are already on relatively well-defined axis (type safety, memory safety, static typing, manifest typing, …), so the entire strong/weak axis is inconsistent and ill-defined, and based more on personal preferences than anything useful e.g. somebody who does not like implicit conversions will define javascript or C as weakly typed, somebody who doesn't like dynamic typing will put python and lisp there, somebody who doesn't like loopholes will put java there and somebody who doesn't like memory unsafety will put C there.
&gt;I can do all that in python and go from the stdlib, and it makes a huge difference. That is very questionable. It can be a *huge* difference in Python, since it doesn't have an “official” way to manage dependencies. You have to handle them by yourself with external tools (virtualenv, requirements.txt, etc). Dependencies in Rust are first-class resources. For me, there is no real advantage between a create like flate2 and something like `std::compression::flate`.
Not the OP, but there being an "official" library for certain things makes a difference. It gives you a default, safe (in the sense that you know it won't go away or change rapidly), idiomatic choice. Right now in Rust you're often presented with a wide array of different libraries to choose from, all of which are in different states of completeness, may not be maintained next week, etc. Rust's dependence on third-party libraries for what a lot of other languages consider basic std lib stuff is a bit of a sore point for me, too. Not a deal-breaker, though, and I admittedly work mostly in C# which has a massive std lib.
Maybe their physical tests use a more modern hardware. The JVM is pretty good generating code for the underlying hardware. Rustc will not enable that kind of optimizations unless explicitly set.
&gt; (uh-oh, I'm on Linux, so I need to make sure I have the right version of openssl installed everywhere and a C compiler + toolchain) &gt; (compiler again...) I take this part more seriously than the simple fact that some functionality is in a 3rd-party crate (which is normally for a good reason -- it's easier to evolve it than if it were in the standard library). It's true that an ideal experience wouldn't rely on platform-specific toolchains and libraries for a 3rd-party language being installed -- particularly if Cargo can't do it for you. 
The OP is dangerously close to one of my (**IMHO**) most substantial criticisms of Go: it makes encapsulation hard. This isn't a veiled criticism of the lack of generics (if it were, I'd say "Go makes *abstraction* hard"), although it is somewhat related, and it is possible that more expressiveness in the type system would help. What I mean to say is, "just use a constructor/factory instead" isn't actually the obvious answer you might expect. This is because once you hide all of your data, it becomes very hard to provide callers with an ergonomic API that one might have come to expect. For example, let's take a simple example where your type represents a sequence of identifiers: type Idents struct { ids []string } Now lets say you want to provide an API that lets you iterate over all of the identifiers. The simplest thing you can do is return the `[]string` slice and let consumes do what they will. But depending on what you're doing, you might have just violated encapsulation by exposing the fact that your ids are represented by strings, or even permitting callers to willy nilly modify the identifiers in your collection. Go doesn't have any standard iterator protocol (although there are patterns, e.g., `bufio.Scanner`), so you can either provide an ad hoc iterator over your identifiers or break encapsulation. For this reason, in Go, you often forgo encapsulation altogether and just open up your structs. Go's "default value" semantics (coupled with appropriate linting) mean that adding a new field to a struct isn't generally considered a breaking change, which is definitely not the case in Rust. What I mean to say is, opening up a struct in Rust presents one with API inflexibility in semver compatible releases *and* breaks encapsulation, where as in Go, all it does it break encapsulation. Of course, I am presupposing that you're in a situation in which you've already determined that encapsulation is important. That isn't every situation. (N.B. I'm hoping this doesn't promote a discussion of how many different ways Go could fix this "problem." This is the way Go is, and this problem is very deeply rooted in the design philosophy of the language. So it's less about "they designed it wrong" and more about "we have varying degrees philosophical differences," which is totally cool.)
&gt; I said "programming language folks", not "random people on the Internet". You are a random person on the internet and Mark Jason Dominus is not, now what? &gt; See e.g. Mitchell, Foundations of Programming Languages, sec. 4.5.4 for a definition of "type soundness" which is essentially type safety. Warning, though: the notation is a bit dense. [This is just literally the first book I grabbed off my shelf.] So your argument that "strongly typed" is well-defined is that one of your books uses a completely different term? &gt; I'm not sure why you prefer "memory safe" to "strongly typed"? You're asking me why I prefer Logitech to pencil. &gt; I know of no preferred definition for the former And I know of no preferred definition for the latter. &gt; People may misuse a technical term like "strongly typed". That doesn't make the term meaningless or worthless. When the term is "misused" more often than it's "properly used", maybe it's not a technical term at all no matter how much you'd like it to be? &gt; Otherwise we'd have to give up on "quantum" altogether. We have. Outside of quite specific context, "quantum" is meaningless. "Strong" is essentially the opposite, it is generally and intuitively meaningful in most contexts but not with respect to typing discipline. I don't see any oddity with that.
Well for one, the std lib will be maintained as long as the language is, where all these 3rd party crates could take their libraries off crates.io whenever they want. Not to mention stability and guaranteed comparability with the language, plus reliable documentation.
```Why doesn't someone write a modern syntax front-end (or source-code translator) for ADA``` I don't normally down-vote comments, but, I've read yours several times and I just can't figure out what you are getting at. Could you explain?
No, debugging information will be generated only at called library.
Don't think there's more I can constructively contribute here. Sorry that I've gotten you so upset: was not my intent.
You mean that there is enough information in a compiled rust crate (compiled code + “metadata” in an rlib) so that the caller library can generate this? I'd guess there isn't that, that we need to extra information when compiling the crate that is used by the caller library.
For my personal use, it really doesn't. At work, to talk people into using Rust, I need to be able to convince them that it's not going to come back to bite us later. In addition to Zigo's comments, I have two problems with `cargo` as it exists today. 1. Licensing: It looks to me like crates can be licensed under any "permissive" license. This doesn't work for me because it means that for every crate that isn't exactly "MIT/Apache 2.0" or "MIT", I have to get legal review to make sure that the license works for my project. That means there's suddenly a huge barrier to entry for the first X licensed crate I add to my project for each X that isn't MIT or Apache. It also means i have to review every single dependency, and the current Rust ecosystem seems to love having dozens of small dependencies. 2. Stability/Availability: It's not clear to me that any published crate is absolutely guaranteed to be available in the future. While this is *probably* the case, it's a lot harder to make that claim about a crate than it is about a standard library module.
Design a modern syntax for Ada, then make a program that just converts that syntax to the existing Ada syntax (you might call it a transpiler)
&gt; Speaking of Google, their project to adopt Mercurial for their massive, internal monorepo is picking up steam. A percentage of people at Google are now using the `hg` client for interacting with their monorepo. (I can't share more detailed numbers, sorry.) Wow. I didn't know there was such a project at Google. It seems like it could be a serious boon to the Mercurial project.
So clearly I'm mixed up here but the following seems like it should work: ```rs use std::path::Path; fn parent_exists&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; bool { path.parent().map_or(false, |parent| parent.exists()) } fn main() { println!("Parent exists test: {}", parent_exists("/test/one")); } ``` But I'm getting this error: ``` error[E0599]: no method named `parent` found for type `P` in the current scope --&gt; test.rs:5:10 | 5 | path.parent().map_or(false, |parent| parent.exists()) | ^^^^^^ error: aborting due to previous error For more information about this error, try `rustc --explain E0599`. ``` I'm having a heck of a time figuring out what the issue is. Any insight you can offer is appreciated!
Such code is generated :) But yeah any `match` with an arm per variant (not just `derive(Debug)` can also contribute to code bloat with these enums.
&gt; For Debug to be generated lazily and automatically, it'd have to become a language feature Is there any particular reason why "derive on demand" couldn't be a language feature? I.e. only when it needs to know whether something implements Debug will it try to derive it. 
Sadly that’s not how derives work, particularly across translation units.
As a winapi user, I respectfully disagree.
How would you recommend developing in a way that ensures your solution will be compatible with your docker deployment? Your answer doesn't have to be Rust specific. :)
Couldn't you just mount your rust code with a docker volume? 
I'd say making things easier through docs, community, and tools is definitely something rust should do. However, changing the language is where the line should be drawn. The language shouldn't compromise itself for the sake of easy learning. Other languages have made that mistake and they carry the baggage with them for a long time.
You could try going through the steps from the articles I liked to. Specifically: * [My Rust Dockerfile](https://blog.sedrik.se/posts/my-docker-setup-for-rust/) by Fredrik Park * [Docker Multi-Stage Build](https://blog.jawg.io/docker-multi-stage-build/) by Jones Magloire 
iirc the [rust-clique](https://github.com/rust-clique) group was created to house crates for creating CLIs (can't remember what the acronym stands for). Not sure if we've considered criteria for projects joining it or how it'd function. Probably reasonable to reach out about it on [gitter](https://gitter.im/rust-lang/WG-CLI). Also, the CLI-WG has had some discussions on what crates to consider for [directories](https://github.com/rust-lang-nursery/cli-wg/issues/7). 
Instructions unclear, [did pushups on elephant](https://www.upi.com/Odd_News/2017/01/18/Man-performs-22-push-ups-on-elephants-back-in-Thailand/8271484770200/).
To be clear, it isn't that compile times are not a problem, it's that the language already has features that seriously negatively impact compile time without any syntax that would make it explicit.
They just said it's a Monty Python reference.
Cool. I'm building something extremely similar to this - a pluggable monitoring tool, in rust. Different long term goals though. Very nice to see someone else exploring a similar space :)
Go back about 10 years or so and replace everywhere you said Rust with Python and everywhere you said Python with VisualBasic and you'll find the exact same thing being said. Funny how what is acceptable changes when it is proved productive.
Also, Jetbrains has a generous open-source license that you can renew each year.
Interesting to see this guy talking about Rust. I do find it hard to believe that the mass of Javascript devs are going to transition to Rust anytime in the next century. WebAssembly could enable a world where apps built on web technologies become dominant, but I expect it will be a very multilingual world.
expect is still an ugly panic, it just string concats your message before the error. but that's pretty common in cli tools, like python programs giving you its traceback. if you want something most user friendly, i suppose you would print to stderr and exit(1).
after trying to get my own framework on techempower and running the suite myself, i realized how useless the results are. though good for marketing. but expect results with a variance of 1000x on each run. which is one of the reasons their cloud vs physical results are so different.
Thanks very much for jumping in to help here. I see the PR was merged as well which is great. I’ll add a comment over on GitHub once I get onto my laptop in the next few hours.
Those partial runs are a mess... Anyway, congratulations for the impressive performance of Actix web. I will use it in my next hobby project. I've taken a look at the repo and I like how you manage it, you got plenty of examples and a focus on performance. All I like is in there :) Thanks so much for creating this wonderful framework. 
These companies and organizations are living in the past, and they may continue to do so. Cargo dependencies are almost always MIT / Apache 2.0 licensed, and may be vendored locally, using semantic versioning rules. The Cargo tooling strongly supports building software with modules, so taking advantage of the module approach, rather than the monolith approach, is a no-brainer. If this were C, C++, Java, etc., where it's difficult to import and maintain dependencies, I could see that point of view. But that's simply not the case with Rust. Go's a bit iffy, because it pulls directly from git, and doesn't support semantic versioning.
If "strongly typed" just refers to how a language predefined string operations behave (and that seems to be the only example people can come up with) it's not a very interesting property at all.
As for #1, luckily most crates are licensed as MIT / Apache 2.0, especially library crates. There's also tools you can use to automatically perform a recursive check of licenses used in your project. And as for #2, Crates.io is immutable, so once a crate is published, it will always be published. It can't be taken down.
From my experience, results are pretty consistent across different runs. 
We use [tshell](https://github.com/auseckas/tshell/) to build a CLI that fronts a restful API here.
Discoverability is the primary reason.
Here is shown how to compile and/or run rust in docker: https://hub.docker.com/_/rust/
I think main difference is in number of db workers. But for sure, jvm jit helps java benchmarks, especially json
Some of these crates are maintained by the Rust team. Literally the only difference between them and the stdlib is the default inclusion. &gt; never guarantee with a crate I mean, std is just a crate like any other.
Are there docs anywhere about what has actually been stabilized? I know there's been lots of back and forth about it, and I've lost track of what kind of new powers we'll actually get in stable Rust.
For me stronger type systems prevent uses of values of type A as type B and avoid, potentially surprising and leading to obscure bugs, implicit conversions between types. Does the language do automatic conversions between different numeric types? Does it always allow me to assign value of type A to a variable of a different type B without a (compile time or runtime) error? Does it do any implicit conversions between types? The more no answers, the stronger is the type system. It’s not inherently just about string operations, but it is an obvious example when referring to Python, as it requires explicit conversions to `str`s, when even some pretty strongly typed languages do those automatically, sometimes with surprising effects (cf. `2 + 2 + "!=" + 2 + 2` in Java).
Learnability is one of Go's focal goals, and it's amazing how easy it is to pick up, but it stands in the way of powerful functionality being added to the language. Learnability is an awesome goal for a language, but I feel it needs to be balanced with a healthy dose of pragmatism.
After looking at the features the author wants I think the author should also keep trying to learn Haskell. I think someone who would consider Rust to be the "perfect" backend language would have a different set of features they want (mainly safer mutability instead of no mutability, and predictable performance instead of expressiveness with concurrency). I wish Haskell had more practical examples online instead of small "cute" examples though. It makes the learning curve way harder than it should be.
I bought the book hence I was searching for an easy entry in rust network programming. In short, the book is okay for this purpose. This is not a beginners book for the rust language itself, you need to be familiar to the basic concepts of the rust language. This is not a networking book, you need to be familiar with UDP/TCP etc. The author scratches on the surface of Arpanet, the OSI-Layers and generally networking. Nothing to learn here if you ever wrote any networking code or had a computer course in school. The author explains the borrow checker and lifetimes in a simple way, but you don't get any deeper understanding of it. Scratching the surface again... The code quality of the examples is medium. There is an error in code examples of the UDP server and client. The author returns the whole 1500 byte buffer to the network client, even if you intend to send only 1-2 bytes. This causes even packet fragmentation on a typical configured ethernet system, that is very bad behaviour for a network protocol, even considering it is only an example in a book about rust network programming. The author uses unstable features of the nightly-branch. This means that if you buy the book some time after release these examples dont work anymore. That happened to the example where he is using std::net::lookup_host(). This makes the book incorrect for no reason. The packet dumper example does not work on actual Windows versions, because it uses winpcap. So you can be pretty sure the author never tested if his examples work on all OSes. The dns resolver example needs openssl installed and in PATH of your MSVC environment. That isn't a big deal but you should be prepared you need to do some work to get the examples running. He should inform about the prerequisites for working code examples. This book is far away from the quality of O'reilly etc. Nice short overview over tokio, mio, async-calls, diesel, grpc, rocket, hyper and some more... The code examples are public and available on github. just search for the title of the book. so check them out for your own opinion.
&gt; For me stronger type systems prevent uses of values of type A as type B Python does not prevent this. 
Judging from the contents of the PR it seems that both use cases did in fact make it. - universal_impl_trait: Allows `impl Trait` in function arguments. ``` fn check_display_eq(iter: &amp;Vec&lt;impl Display&gt;) { fn check_display_eq(iter: impl IntoIterator&lt;Item = impl Display&gt;) { ``` - conservative_impl_trait: Allows `impl Trait` in function return types. ``` fn foo() -&gt; Box&lt;impl fmt::Debug+?Sized&gt; { ``` 
/r/sbubby
Hi I have a file src/lib.rs and in it I started it with: #[macro_use] extern crate text_io after which I attempt to then use `read!()` (within a public function) but then it tells me that an extern crate must be at crate root. If I remove the `#[macro_use]` then it tells me `cannot find macro read! in this scope`. Can someone help me? Thanks.
Now we only need `impl Trait` in traits! I know it is not as simple as it sounds, though ...
&gt; urllib2 in python Actually it's recommended to use the non-stdlib `requests`.
That is exactly what I meant.
No, `expect` is still an ugly Rust panic. The difference is that the panic message is something customized and more meaningful, rather than simply "Panic in thread main". But you still get the ugly Rust panic message with info about RUST_BACKTRACE, etc. Panics are not a legitmate or user-friendly way to handle errors. They are only intended to be used for things that should actually never happen under normal circumstances and are considered sofware bugs if they do (out of bounds array access, a violation of an invariant of some custom type of yours, etc...). Something like not being able to listen on your server socket is something that can genuinely happen under normal circumstances and is not indicative of a bug in your program. A panic is not appropriate. In production software, you should handle it, print a user-friendly message or do something else to properly inform the user, and terminate with an appropriate error code. Panicking in such a condition is only acceptable as a temporary hack in experiments/prototypes.
I've been struggling for the last couple of hours with the long build times, your first link helped solve my problem. thanks
There's no formal structure in documentation comments; they're just plain commonmark markdown. If you want an example of (what I think is) pretty decent macro documentation, see for example [UNIC's internal-use `char_property!` macro](https://docs.rs/unic-char-property/0.7.0/unic_char_property/macro.char_property.html). Part of great `macro_rules` macro documentation is proper indentation of the macro definition, as that does show up. We should probably also hide the `__impl` implementation details, if I'm being honest. With macros, the key importance is to document the accepted syntax constructs and the output that it corresponds to. The further that it gets from regular-looking Rust code, the more difficult it is to do so cleanly. Because documentation is normal prose, use markdown `# headers` to split up your paragraphs into scannable (and section-link-able) divisions on the page. For example, the `# Safety` section is basically defacto standard for `unsafe` fn. For a DSL macro, I'd expect a `# Syntax` section that goes over the syntax within the macro. For best results, the used syntax should be Rust-like when possible, and simple otherwise. Syntax errors at the use site of `macro_rules` macros are unfortunately really hard to debug as a user, so you want to be as nice as possible.
No, that is not what I meant. Read my long response to the comment you replied to.
&gt; The static/dynamic axis is a well-defined one I disagree, dynamic types are a subset of static types, so it is not really an axis.
I had this fun one. Recursion man. https://imgur.com/fL1WcYa
I'd argue this is actually the most important use case for `impl Trait`
Isn't the entire point of impl trait to do this without the Box?
`Box&lt;impl Trait&gt;` doesn't use dynamic dispatch, as the final type is statically known to the compiler. It also doesn't require the trait to be object-safe. If you know the type will be `Sized`, I expect you would want to avoid the heap too, just `fn foo -&gt; impl fmt::Debug`.
What `diff` library does it use?
Thanks! This is apparently a [known shortcoming of the compiler](https://github.com/rust-lang/rust/issues/38078).
`Box&lt;fmt::Debug&gt;` does work now, as a trait object.
There are two cases where a `Box` was needed, the first whenever you want a heal allocated struct for any reason, and the second where you didn't want to name a type, o lying the interfaces it implements. In the first case you still need the `Box`, because `impl Trait` doesn't do allocation, but in the second case you no longer need the box to just not name the type.
Why do you think this?
Since cargo keeps its compilation cache in ~/.cargo by default, I imagine that you have to do more than just bind-mounting the source directory in the docker image used for rust builds.
Yes, I agree, but something is better than nothing! The current `impl Trait` at least allows writing methods/functions that return `Future`s and `Iterator`s conveniently, so that's already quite good.
When asking about problems in Rust code, it helps enormously to show a complete, compilable example of what doesn't work along with the full error message. You've eliminated so much detail in your question that what you're describing works perfectly.
Could the language definition be changed to include it? Of course it could. Would that be an easy change to actually make in the compiler? I'm not so sure; the limit of my knowledge is that compilation is divided into very distinct phases, and doing this would require being able to go back from type checking to syntactic analysis, then back to type checking again on the fly. I don't know that the compiler is designed in a way that this is possible.
You are right, my bad. I guess he just used a bad example, then.
Never thought I'd live to see this day! Does this include the "abstract type" sugar that lets us use impl Trait in traits via associated types?
Not perfect, but you can do something like this: ```rust trait Foo { type Item: Debug; fn bar() -&gt; Self::Item; } ```
Real World Haskell? Right now the haskell situation is kinda weird with it being kinda split between haskell.org and haskell-lang.org . Once the community solves that the situation should improve.
We'll need a blog post with all those new goodies, examples, etc.
I develop in docker in order to have a repeatable build environment. Although building the container itself is slow and annoying, between the docker image cache, bind mounting my source tree, and the fact that you can attach and detach from docker containers (like screen) I don't rebuild anything during a typical workday unless I'm intentionally testing the full build.
What's Google currently using for their monorepo, Perforce? Something homemade?
I wish had known this was happening in Boston, I would have scheduled an emergency Boston Rust meetup and invited you. :)
Thanks to /u/mitsuhiko for contributing this long awaited feature! This had the most 👍 reactions of any Serde issue on GitHub.
Well, whaddya know. Thanks for helping clearing it up. I wonder how come it's still not solved. It seems fairly common
It was Perforce once; now it's a homegrown equivalent that presents a similar interface but is much more scalable. Also hadn't heard about their Mercurial project. Interesting move.
Yes, but that is not `impl Trait`, i.e a type inferred by the compiler. You have to specify it.
Wait ... ... in that case, what is the problem with simply desugaring trait methods that return `impl Trait` into anonymous/unnamed/hidden associated types on the trait? 
Any resources on each of the ways `impl Trait` can work and what they de-sugar to?
It can be yanked, though, which will make subsequent builds (and crates) fail. If you already depend on a crate and that crate gets yanked, the next time you want to install your library on a different machine, it fails. Which means that, yes, left-pad can happen with cargo. Other crates can't take its place, but the build process is still ruined. I see people say that cargo is immutable, but I've simply experienced the opposite.
I'm very excited for this. I could see this being helpful in sharing logic between a command line and a config file, making reusable structopt structs, like for managing logging policy, etc.
I wholeheartedly agree with this comment. I remember when I was a wee dev, I would get endlessly confused when trying to design my code in "good OOP style", and I noticed that it was tempting to create cycles in object ownership. An order should have a user who created it. And a user should be able to produce a list of his or her orders. But really, the ownership should always be one-way, regardless of which way you choose to do it. Especially when data is mutable, it makes it possible to reason about updates in a way that is almost intractable otherwise.
AIUI yes, `impl Trait` in arguments is meant to be a nicer way to write generic bounds. I think you still need generic bounds if the concrete type is needed in multiple places -- similar to the rules for lifetime elision.
This allows for declaring the trait, but no way to implement the trait without manually writing out the type. There is no stabilized way to have an implementation's `Item` be a unnamable type here.
&gt;object-safe What's that?
Cool, I can remove a custom Serialize impl now!
I believe that this doesn't handle the situation where you *require* the same type to occur times `fn&lt;T&gt;(T, T) -&gt; T`. I'm not certain exactly when people would require that, but it's a thing.
Yes, [`erased-serde`](https://github.com/dtolnay/erased-serde) is full of impls like this. - [`impl&lt;'de, 'a&gt; serde::de::DeserializeSeed&lt;'de&gt; for &amp;'a mut DeserializeSeed&lt;'de&gt;`](https://github.com/dtolnay/erased-serde/blob/0.3.3/src/de.rs#L523) - [`impl&lt;'de, 'a&gt; serde::de::Visitor&lt;'de&gt; for &amp;'a mut Visitor&lt;'de&gt;`](https://github.com/dtolnay/erased-serde/blob/0.3.3/src/de.rs#L667) - [`impl&lt;'de, 'a&gt; serde::de::SeqAccess&lt;'de&gt; for &amp;'a mut SeqAccess&lt;'de&gt;`](https://github.com/dtolnay/erased-serde/blob/0.3.3/src/de.rs#L754) - [`impl&lt;'de, 'a&gt; serde::de::MapAccess&lt;'de&gt; for &amp;'a mut MapAccess&lt;'de&gt;`](https://github.com/dtolnay/erased-serde/blob/0.3.3/src/de.rs#L765) - [`impl&lt;'de, 'a&gt; serde::de::EnumAccess&lt;'de&gt; for &amp;'a mut EnumAccess&lt;'de&gt;`](https://github.com/dtolnay/erased-serde/blob/0.3.3/src/de.rs#L780)
Yup, exactly. It's a problem that's very obvious if you've written a large go/python/ruby/C# project and then a large C project doing similar stuff. It's just not even close to the convenience/idomaticness (ok, not a word) of having it live in the standard library. Rust is very obviously more on the C side of things and that's unfortunate. I'd prefer if that was more opt-out than opt-in.
Haha, I expected both of these responses, and even had a comment about it that I removed as it detracted from the point. Basically, yes, requests is what I use for basically everything and it's one of the few globally pip-installed libraries on my systems. But at work, when deploying small utility work to some systems, I have actually chosen to use `urllib2` over `requests`. But more importantly, I don't think the library in the stdlib has to be the best possible library! It just has to be there. `urllib2` is actually a great example IMO of what I want in my standard library. It's definitely un-ergonomic and a bad user interface, but it is good enough to get things done. And you can find better stuff out there if you want that. See also `argparse` vs `clap`.
Real World Haskell doesn't seem to cover nested state with lenses which is useful for a lot of "real world" apps with lots of nested data. It seems to spend a lot of time trying to explain what is already there instead of teaching how to build your own stuff, especially in the transformer section. It also seems outdated and a some of the examples may not work correctly right now. When I was still learning I would stumble upon some Real World Haskell pages and end up even more confused. Hopefully it can be improved though.
It's described in the book here: https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html#object-safety-is-required-for-trait-objects
That's a great reason to use _`impl` Trait_ whenever possible - the types in the compiler error messages will be shortened to the `impl` Trait notation.
I never knew I wanted this. Awesome!
I don't know if that would've helped because I received the item as &amp;mut and passed that reference as &amp;mut into a recursive call, so I was passing &amp;mut &amp;mut (and so on). 
Yeah, it's not enabling that yet. I think I saw talks on making this snippets possible: struct Baz; impl Foo for Baz { }
A “secret” is that Rust is actually an ML family language hiding behind C++-like syntax.
Ah, yeah - that'll be nice when we get that! IIRC the eventual syntax will be something like `existential type Item: Debug`. (how it's specified in https://github.com/rust-lang/rfcs/blob/master/text/2071-impl-trait-type-alias.md) I was just meaning we don't have anything actually useful for `impl Trait` in traits until then. I definitely agree it's going to happen, but it isn't even in nightly yet, and isn't stable now.
`fn map&lt;T&gt;(x: Option&lt;T&gt;) -&gt; T`?
For the uninitiated: What dies r+'d mean?
This is an open problem with no existing solution. See https://github.com/rust-lang/cargo/issues/3494.
There is certainly value in a community's blessing.
 #[macro_use] extern crate text_io; pub struct Item { title: String, effort: u64, result: u64, priority: f64 } impl Item { pub fn get_item() -&gt; Item { let title: String = read!(); let effort: u64 = read!(); let result: u64 = read!(); let priority: f64 = effort as f64 / result as f64; Item { title: title, effort: effort, result: result, priority: priority } } } If I delete `#[macro_use]` then it gives me the error `cannot find macro read! in this scope`, but oppositely if I have `#[macro_use]`, then it says `an extern crate loading macros must be at crate root`. Sorry about that, I presumed that simply telling would be sufficient.
wow, i was looking for exactly this feature 2 days ago
&gt; but still a "must" in an introduction to programming Why? In 10 years of programming I have never needed to use a linked list, let alone one I implemented myself. I'm not saying there aren't important use cases, but as a *must* in an intro course? IMO learning things like dealing well with concurrency and structuting maintainable programs are far more useful. Low level details can always be learnt later...
You don't need to go out and download them outside of the first time. Commit your dependency to the project VCS. Then you have the source code for as long as you want.
Yanking a crate only means it won't be returned when cargo asks "what's the latest version for crate foo?". If you have a `Cargo.lock` file that says "use version 1.2.3 of crate foo", cargo will always be able to retrieve it, even if that version is later yanked.
Hi. Rust beginner here. What is the significance of this work and why the special attention?
Right now, Mercurial uses mostly a homegrown diff codepath. xdiff is off by default, but *much* faster.
I've contributed to git in 2006 and have been using it ever since, but I've always liked Mercurial's model with an official API, despite it being Python. And I also was envious of Mercurial's alternative, safer history rewriting mechanism and designed CLI experience. Therefore it's very nice to see that large repo/team support in Mercurial is getting optimized by Facebook and Google. And parts being rewritten in Rust is just icing on the cake. It's a good thing if git gets a contender that is better in some areas. Innovation through competition. I hope they make some of the local operations of Mercurial faster. hg status, hg grep are much slower than git equivalents.
Yeah, but that doesn't work for the dependencies of crate foo, which is the problem. Not sure if this is a bug or intended. See, I wanted to use a library on crates.io. The library looked normal, so I copy-pasted the version into the Cargo.toml file. And whoops, it doesn't build. Why? Because a dependency of a dependency of a dependency of that library was yanked (also, without any reason, I think the developer made a typo and thought it would be a good idea to just yank the whole crate). So even though the crate was available, it didn't build anymore. Of course the developer of library foo was unaware of this, until I notified him. He had to yank his crate too and publish a new version, to make it clear that this version doesn't build anymore. So yes, you can get libfoo-v.0.1.0, but if foo depends on libbaz-0.0.3 and that crate gets yanked, say goodbye to any build using libfoo. Which just highlights the problem of a potential left-pad incident. You just have to have enough dependents, yank your crate and boom, nobody can build anymore.
https://webcache.googleusercontent.com/search?q=cache:02EKNh54oW8J:https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us&amp;client=firefox-b-1-ab has some good details (cache link because the ACM site seems down at the moment)
&gt; Rust is very obviously more on the C side of things and that's unfortunate. No, it really isn't. The C ecosystem doesn't have Cargo.
I don't believe so - it hasn't yet been implemented in nightly rust, let alone stabilized.
Basically what Microsoft did before they moved to Git. They started off with Perforce and had a custom fork of it later.
It's open source and on GitHub. That's not a good place to put something you don't want others to use nor scrutinize. I am throwing a yellow flag on you and giving you a ten yard penalty.
I put that in a `src/lib.rs`, and it works just fine. You're still leaving out whatever the actual cause is. The only things I can think of is that you *aren't* putting this code in `src/lib.rs`, you're doing something weird in the manifest, or you're using this file in a weird way.
Is it possible for these to become default impls on the trait instead? Or is there a specific reason for making them an impl only on a trait object and not on specific implementors?
How is that?
Got it, thank you for explanation
I'm in a similar situation and my conclusion was that, now that I'm interested in tasks that Python isn't suited for, it's bothersome enough keeping the caveats for dealing with superscalar CPUs in mind without also having to keep a mental model for a language like Haskell which is lazy and purely functional. I think Rust is just perfect for the balance point between "Ugh. I have to poorly ape type system guarantees in my test suite." and "Ugh. I have to understand arcane DOs and DON'Ts of the compiler's ability to optimize my code if I want effective resource utilization."
Sometimes you don't want to, or can't, put a type in the public contract of a function. For example I want to have a `.iter()` method that promises to return something you can iterate over, but I don't want to garintly that is is always going to be `Peak&lt;Map&lt;VecItter&lt;PrivateInerType&gt;, CostumeInerFuntion&gt;&gt;` because I have plans to refactor to stop using the `Vec` deep in my private inerds, not to mention how long and ugly it is. So this lets me say `pub fn iter(&amp;self) -&gt; impl IntoIterator&lt;Item = u32&gt;` witch means that I will tell rust the exact type that it shud use, but I won't tell you. You, uere of my library can only use it as an Iterator. Tomorrow it may be a different Iterator, but it will be an Iterator. But rust will know (infer) the exact type that I return, and apply all the optimizations it would have had I spelled it out exactly.
Even if in a vacuum an stdlib package and a third-party crate could be logistically identical, over time the cultural effects are different. There is decision fatigue from the community: Eg (hypothetically) which of the 5 http packages should I be using this month? hmm, X is not maintained anymore, Y doesn't support the latest nightly features, Z is maintained by a toxic person). Then there is maintainer fatigue. There's a big difference between a package that is maintained by an individual on their spare time for years and years on end, vs a package that is officially supported by core. By supported, I mean in terms of resources, in terms of people, consistency with the rest of the toolset. I created Python's urllib3 over a decade ago (relied upon by ~every Python user today). It was entirely done on a volunteer basis. We did well with what we could and too many maintainers were burned out over the years--yet we'll never be able to compete with something like Go's http client in the standard library. It's night and day.
Further support for enums is being tracked in [serde-rs/serde#1186](https://github.com/serde-rs/serde/issues/1186) and [serde-rs/serde#1189](https://github.com/serde-rs/serde/issues/1189). If neither of these is what you are seeing, please file an issue.
A very compelling use case will (eventually) be to have a function that returns a closure without having to `Box` it. Closures have *unnameable* types, which is, in part, responsible for them being very efficient for passing into arguments of other functions. The gotcha, is that without being able to name the type, you cannot return it in stable rust! fn foo() -&gt; impl FnOnce() { || println!("hi") } This would make writing the code you want easier and faster. But at the moment, it needs `impl Trait` and `unboxed_closures` to work.
Try .org?
That url doesn't load anything for me - perhaps your ISP is intercepting the call? As /u/IntolerableBalboa said, the domain you're looking for is https://users.rust-lang.org.
I haven’t yet tried to run Redox. With this rewrite, do you think it’s appropriate for a port of trust-dns to get started? I have quite a few dependencies, the Resolver is a little slimmer so I could start there. Any thoughts on how much time I should put aside for porting?
There's a variety of Mozilla-isms for reviews that Rust has inherited, and (some of which) link into the bots: - "r+": review approved - "r-": review rejected - "r? @someuser": requesting a review from 'someuser' - "r=someuser": review approved by 'someuser' (e.g. if a pull request was r+'d by someuser but needed to be rebased or other changes that don't need a rereview) - "r=me": usually conditional ("r=me when you foo the bar"), approved under my name once the conditions are met, meaning the submitter can "r=myusername" 
perfect, #1189 is my use case
I think this ends up being morally equivalent to generic associated types and is therefore blocked on that. 
Am I right to say that this makes it possible to return values from a function, that you can't put in a struct, like this: // library fn bark() -&gt; impl Display { /* ... */ } // library user struct Dog( /* what goes here? */ ); fn barking_dog() -&gt; Dog { Dog(bark()) } There's nothing that can be put at `/* what goes here? */` that makes the example compile. If this is true, I would argue please please PLEASE do not use this feature, at least not in your library's public functions. Being able to put return values somewhere is really basic functionality for a programming language. (For returning closures you might not have an option, but for everything else, there is newtypes.) 
Python is strongly, implicitly, and dynamically typed. **Strongly:** It won't silently convert from one type to another as you'd find in languages like PHP where you can run `print("1 egg" + 1);` and get `2`. **Implicitly:** You don't have to declare what types your variables are using tokens like `int` and `str`. **Dynamically:** You can reassign what type a variable is at any time and mix arbitrary types in lists. Rust, by contrast, is strongly, semi-implicitly, and statically typed. **Strongly:** Same as Python except that Python allows lossless numeric coercions like `1 + 2.0` while Rust requires you to manually ask for that conversion. **Semi-implicitly:** Rust requires to to be explicit in function signatures and struct definitions, but tries to infer types everywhere else. (However, since it's done at compile time, you may have to give it some help.) **Statically:** Each variable's type is fixed at compile time and that type must remain the same throughout the variable's lifetime.
`struct&lt;T: Display&gt; Dog(T);`?
&gt; I do find it hard to believe that the mass of Javascript devs are going to transition to Rust anytime in the next century. What's cool to me about webassembly is that it has a chance to do what node did, but in reverse -- node let web devs build their server without learning a whole new language, and so opened up the backend and middle tier to people who had previously only written JavaScript. Webassmbly, in the fullness of time, could do something similar and let a whole crew of people who write backend and middle tier code to move to the web without having to learn JavaScript from the ground up. I'll know it's real when you can compile jvm languages to webassembly without much extra work.
Because languages like Perl and PHP still exist, where you can write `print("1 egg" + 1);` and get `2`.
Other than map, whose entire point is to do transforms, yes these are great examples. Collections in particular need identical types for a variety of patterns.
Uh... when I wrote `map` I meant `unwrap`... oops. `map` is also a good example though, `fn map&lt;T, R&gt;(x: Option&lt;T&gt;, f: impl Fn(T) -&gt; R) -&gt; Option&lt;R&gt;`
C/C++ is not strongly typed, to point out the elephant in the room. Untagged unions are one obvious type hole. You mentioned Forth. It's easy to forget that a lot of older languages didn't insist on strong typing. Omitting expensive runtime type checks made some sense on painfully slow machines. On modern fast hardware it's not so advantageous. It's also not always obvious whether a language is strongly typed, even at runtime. Type holes are a real thing. A big part of the definition of Standard ML is a formal proof that statically well-typed programs don't have runtime type errors. Anyway, it's not like I'm some kind of strong type salesperson. Everybody should have fun with their chosen terminology, and use whatever languages make them happy.
I feel that C is such a minefield that it makes approaching programming very difficult for a beginner, especially if the student performs better with a more results-driven approach, as opposed to being dumped into the sea to swim with the pointers. It's pretty difficult for a beginner to get up and running with a complete application in C. They lack the high level abstractions, tools like Cargo, and modules. API documentation leaves much to be desired in many cases, even for established C libraries that have existed for decades. Most C courses will therefore focus primarily on teaching algorithms, and largely reinventing the same ancient wheels, instead of writing interesting tools and libraries. At least with Rust, they are given a modern systems programming base, with a wider range of programming concepts. Where they may struggle to wrap their minds around runtime segmentation faults and pointers in C, Rust will give them a very detailed analysis from the compiler, pinpointing potential sources of memory access violations that must be addressed before the program can compile. So rather than having to ask the teacher, the compiler readily points out what's wrong with their code. It's a very powerful feedback loop. And rather than trapping the beginner into a small box with C's standard library, where they may feel very uncomfortable, with Rust they have access to a significantly-expanded standard library, Cargo for building their projects and managing modules, third party crates readily accessible from Crates.io, and high quality API documentation provided by Docs.rs. It's very easy to get up and running with legitimately useful applications and libraries, with minimal code. As such, I personally feel that Rust is an ideal first systems language. C can come shortly thereafter, where approaching C with a Rust mindset is much more manageable. It's easier to learn C after you've learned Rust, but not so much in reverse.
Aha! That part was lost on me. Also it seems like `fn barking_dog() -&gt; Dog&lt;impl Display&gt;` is working. Thanks! 
&gt; I don’t think I’d recommend using Docker during development. Feels like it adds unnecessary complexity to the development process. If your application interacts with an RDBMS, message queue or similar external resource, Docker is in fact a great resource. Being able to get a fresh database instance in a few seconds with a command like this: docker run --rm -d \ --name testdb \ -e POSTGRES_PASSWORD=mysecretpassword \ postgres ...is extremely valuable. More generally, Docker is one of the best tools out there for integration testing. 
&gt; steelman requires contracts to be enforced at run-time, Well, that's crap. Steelman does not enforce runtime or compile time, it just says it needs to be enforced. All of the runtime checks can be disabled, but you should disable them once you know your program can run without errors. Anything that can be statically checked, won't have the checks at runtime. You obviously know nothing.
and https
Awesome! Hope to see higher-level crates using numeric-array in the future. I'm guessing no, but is there any way to get nicer errors for length mismatches? Changing the length of one array on the crates.io example gives this somewhat opaque error: ``` --&gt; src/main.rs:12:15 | 12 | let c = a + b * nconstant!(2); | ^ no implementation for `numeric_array::NumericArray&lt;i32, generic_array::&lt;unnamed&gt;::UInt&lt;generic_array::&lt;unnamed&gt;::UInt&lt;generic\ _array::&lt;unnamed&gt;::UTerm, generic_array::&lt;unnamed&gt;::B1&gt;, generic_array::&lt;unnamed&gt;::B1&gt;&gt; + numeric_array::NumericArray&lt;i32, generic_array::&lt;unnamed\ &gt;::UInt&lt;generic_array::&lt;unnamed&gt;::UInt&lt;generic_array::&lt;unnamed&gt;::UInt&lt;generic_array::&lt;unnamed&gt;::UTerm, generic_array::&lt;unnamed&gt;::B1&gt;, generic_arra\ y::&lt;unnamed&gt;::B0&gt;, generic_array::&lt;unnamed&gt;::B0&gt;&gt;` | = help: the trait `std::ops::Add&lt;numeric_array::NumericArray&lt;i32, generic_array::&lt;unnamed&gt;::UInt&lt;generic_array::&lt;unnamed&gt;::UInt&lt;generic_array::\ &lt;unnamed&gt;::UInt&lt;generic_array::&lt;unnamed&gt;::UTerm, generic_array::&lt;unnamed&gt;::B1&gt;, generic_array::&lt;unnamed&gt;::B0&gt;, generic_array::&lt;unnamed&gt;::B0&gt;&gt;&gt;` is\ not implemented for `numeric_array::NumericArray&lt;i32, generic_array::&lt;unnamed&gt;::UInt&lt;generic_array::&lt;unnamed&gt;::UInt&lt;generic_array::&lt;unnamed&gt;::UTe\ rm, generic_array::&lt;unnamed&gt;::B1&gt;, generic_array::&lt;unnamed&gt;::B1&gt;&gt;` ```
Try looking up another non-existent domain. Your ISP or DNS provider may be advertising on them. You also may have been infected with adware
not related but thanks for explaining why this may happen
For the functional crowd, here are some basic higher order functions: fn compose&lt;A,B,C&gt;(f: impl Fn(B)-&gt;C, g: impl Fn(A)-&gt;B) -&gt; impl Fn(A)-&gt;C { move |x| f(g(x)) } fn first&lt;A,B&gt;(a: A) -&gt; impl FnOnce(B)-&gt;A { move |_: B| a } fn second&lt;A,B&gt;(_: A) -&gt; impl Fn(B)-&gt;B { move |b| b } Unfortunately, I wasn't able to get `curry` to work since I needed a return type of `impl Fn(A)-&gt;(impl Fn(B)-&gt;C)`.
One tip is to not insult your users. I know it's sometimes funny to be a little harsh in error messages for tools only used by yourself, because you essentially talking to yourself and I am also rude to myself :P But now you released it to the public and people are looking at it and potentially try your code and it's really not nice to be called an "asshole" by a programs error message after making an error. 
On second thought, will this be a leaky abstraction? Compare with: // crate A pub struct NewType( /* ... */); impl Display for NewType { /* ... */ } pub fn bark() -&gt; NewType { /* ... */ } // crate B pub struct Dog(NewType); pub fn barking_dog() -&gt; Dog { /* ... */ } In this case, it does not leak through that `Dog` contains something that implements Display, which it does if you use `impl Trait`. Whereas in the `Dog&lt;impl Display&gt;` scenario every struct containing a `Dog` will also have a `&lt;T: Display&gt;` part. So using a newtype still seems better from an information hiding / refactoring perspective. Right? 
Working on user-experience with the [`serde-aux`](https://github.com/vityafx/serde-aux) library. Figuring out common use-cases which could be implemented there for helping people. People, please don't do your own solutions based on `serde`, help each other and contribute to `serde-aux` if you think your thing could help others!
See also https://www.reddit.com/r/rust/comments/7y7tz0/is_there_a_reason_rust_does_not_derive_fmtdebug/
Thanks for these.
Is there something in the works that would allow us to directly store the return value in structs?
Rust was originally implemented in OCaml. Some of our syntax was taken from it. The languages used to be a lot closer, but even now, there are some similarities.
The "-&gt;" specifies the return type and "||" defines a closure without arguments. With arguments you would write "|x| println!("value: {}", x + 1)" Here are the relevant pages from the Rust book: https://doc.rust-lang.org/book/second-edition/ch03-03-how-functions-work.html https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html
Here is the tracking issue that links to the individual RFCs and some more documentation: https://github.com/rust-lang/rust/issues/34511 I'm sure that the blog post for the stable release will have more information.
Wow that's quite surprising to know I guess as I dig more into rust I'll discover those similarities.
I found this, but there is and there is talk about external configuration but no tips where to actually put these variables (Cargo.toml, cmd, some external system file somewhere?): https://github.com/alexcrichton/pkg-config-rs
I edited my original comment, the "-&gt;" was just my Reddit client acting up and rendering it literally as `-&amp;gt;`. But the closure makes sense now that you mention it. Thanks!
You shouldn't store a `PhysicalDevice` in your struct. Instead you should store the index of the physical device, which will allow you to retrieve the handle to the device if you need it. More generally in Rust, everything with a lifetime should be treated as a temporary object that shouldn't be stored in anything long-lived.
Did log out and back in again or reboot the machine after setting that environment variable? If you didn't, it might not have propagated correctly. Also, you can set environment variables for a console session. `set VAR=value` for cmd, `$Env:VAR = "value"` for powershell.
Thank you! This solved it. I had never heard about environment variables before. One learns something new every day.
What does this mean? (both in general, and for rust specifically) Alternate question: Why is this interesting? _please note I'm not trying to be rude, but wording things in a nice way right before going to sleep is not one of my strong suits, I am actually legitimately interested in this_
Thanks for sharing. It's cool; I went to bed between then and now myself :) I think this discussion has been useful overall.
How do you tell the difference? Is there a list somewhere?
Their maintainers are listed in the Cargo.toml, and on the crates.io page. Additionally, their repositories are located in a project-affiliated organization.
I had the same concern, but see [below](https://www.reddit.com/r/rust/comments/86f3h6/impl_trait_stabilization_was_just_rd/dw561dd/)...
I can only tell what happened to me. I am not trolling, this is what happens. I mean, you can try and see for yourself if you don't believe me.
&gt;I think this is where a lot of the perspective difference comes in; in my experience this is far less true. stdlib is where stuff goes and is never maintained. Looking at crates.io, I beg to differ. _Nothing_ hits v1.0.0. And since Rust follows semver and this is what semver.org says about "How do I know when to release 1.0.0?": &gt;If your software is being used in production, it should probably already be 1.0.0. If you have a stable API on which users have come to depend, you should be 1.0.0. If you’re worrying a lot about backwards compatibility, you should probably already be 1.0.0. Looking at the 10 most downloaded crates, 7/10 are still v0.x.x. So that implies that they aren't used in production, don't have a stable API, or both.
That’s true, and I wish it happened more often, but most people don’t actually treat 1.0 that way. This isn’t Rust specific. I think we also may mean different things by “maintained”. A lot of those crates are at less than 1.0 because they’re undergoing lots of development and maintenance. Whereas stdlib libraries, in other languages, haven’t been touched in ten years. They’re slow. They have bad APIs.
It is a philosophical choice from Rust to keep the stdlib minimal and rely on the excellent package management to make up the shortfall - this is the only way they can realistically have their fast development cycle producing quality backwards compatible code. It has led to this situation where there are some *de facto* stdlib creates - like `serde` and `futures` - it's just you have to already know about them, the discovery of this "extended stdlib" is more difficult because it's not all in one place. I think it's a fine design decision from Rust, but they could make it a bit more obvious on the docs that this is an active choice and not just negligence.
&gt; A lot of those crates are at less than 1.0 because they’re undergoing lots of development and maintenance. Which is fine I guess. And to some extend I like it for personal projects (I mean, who doesn't like reading changelogs!), but I'm a bit reluctant to use a library that is still v0.x.x and undergoing heavy development for business use.
Yeah, I hear you. At this point I’ve built enough businesses on such things that I’m less averse to it. Totally understand though.
The big I miss most in Git, by far, is revsets. gitrevisions(7) is a horror show in comparison to the simplicity of revsets.
I have a problem regarding trait implementations. This is the code: impl&lt;I&gt; LogicalShift for I where I: Integer { fn shift_left_logical(&amp;self, shift: &amp;Value) -&gt; Value { ... } } impl&lt;I&gt; LogicalShift for IV where IV: IntVec { fn shift_left_logical(&amp;self, shift: &amp;Value) -&gt; Value { ... } } Now the compiler is complaining about conflicting implementations. I, as the developer, know that a struct that implements Integer can never implement IntVec and vice versa. Can I somehow give this info to the compiler so it knows that the implementations do not conflict?
Both PHP and Perl are "strongly typed" according to po8's definition.
I think he's just saying that if the author fails to recognise that Python / Go / Rust have different (albeit overlapping) use cases then they do lose some credibility. I think the author did allude to this by explaining some of the drawbacks of moving to Rust, but it was still presented as some sort of universal progression which is clearly missing the mark.
Yeah; I’m from ruby which is sorta splitting the difference. The stdlib is fully featured, but nobody uses it because Bundler is awesome and the stdlib is old, bad, and slow. Python and Go just don’t have the same ease of working with packages, though both are getting there!
Mozilla are incorporating rust into their core product - why do you seem convinced that they will abandon it? I feel like Firefox would have to be abandoned for that to happen. Is this just gloomy fatalism or do you have some evidence for why it might happen?
&gt; I think Perl is strongly dynamically typed, **although I don't know the language well enough to know what holes there are.** I *do* have some experience with both of them, though more with PHP than Perl. They're both either comparable to C or worse, depending on how you evaluate them.
Cool! Didn't really pay attention to the authors before, but it does indeed say "The Rust Project Developers". That's nice! I wouldn't mind having something extra to emphasize it though, like a small icon or something. Especially useful in the listing view. But maybe there are downsides to that as well...
Servo to the rescue.
&gt; Can I somehow give this info to the compiler so it knows that the implementations do not conflict? Not that I'm aware of. I don't think specialisation would help here either since neither impl is more specific than the other. 
and dnscrypt-proxy?
After ten hours, I suppose I'll try to give you *some* kind of answer. :P It depends. I think the preference is generally for a verb that describes what the trait lets you do (Read, Clone, Display), failing that a noun that describes the class of things that implement it (Iterator), failing that the name of the property the trait represents (Sync, UnwindSafe). But that could all just be ~~orbital wobble~~ subjective.
This would require negative reasoning, which is problematic: https://github.com/rust-lang/rfcs/issues/1834
This might just be because I'm new to Rust. But since Rust is touted to have "zero cost abstractions", couldn't you just take something like h2o (which is #2 on the fortunes test) and port it to Rust and call it a win? Or perhaps more general, what makes it slower than the top C/C++ frameworks?
&gt; **I don’t believe the compiler currently uses trait bounds when deciding if two impls conflict.** Can’t locate this exact issue but it’s related to specialization113. Taken from [this discussion](https://users.rust-lang.org/t/solved-conflicting-implementations-of-custom-trait-on-std-types/5114). So if this is correct, then this: impl&lt;X&gt; T for X where X: A {} impl&lt;X&gt; T for X where X: B {} is the same as this: impl&lt;X&gt; T for X {} impl&lt;X&gt; T for X {} according to the compiler.
In addition to what /u/dodheim suggests, isn't it also possible to use a trait object? struct Dog(Box&lt;Display&gt;); fn barking_dog() -&gt; Dog { Dog(Box::new(bark()) }
I believe the reason for using both verbs and nouns is that Rust's trait serve multiple conceptual purposes. Traits are our only tool for polymorphism. If a verb is used, we normally mean a single behaviour or aspect. We can define a `Woof` trait, for all things that can `woof` like a dog. However, if we define a `Dog` trait, we imply more complex rules. E.g. a dog can not only `woof`, but also `eat`. So the rule of thumb is: can it do something: use a verb. Is it something: use a noun. 
Why isn't that released in a minor version, if it is a new feature? Like 1.1.0?
So the workaround is to leave the implementation for Integer as is, and for IntVec, implement LogicalShift for every struct that implements IntVec seperately? This seems strange to me, since it will require lots of copy pasting (or maybe a macro can help?)
&gt; Aside from lacking facilities for raw memory manipulation (ie. malloc() and pointers), PHP and Perl are either comparable to C or worse, depending on how you evaluate them. Perl and PHP are completely memory-safe and "carefully check types" at runtime (with an error handling strategy of implicit conversions), again, *according to po8's definition* these are strongly-typed language. If Tcl is strongly typed, there isn't much that ain't as long as it performs *conversions* rather than reinterpretations. And you're demonstrating my original point (and MalenaErnman's to an extent), you have a very different definition of strong/weak typing than them yet will apparently go to extensive length to define this axis despite your understanding of the term being incompatible with the other big defender of the term's, how is a useful category when no two people understand these terms the same way?
So: let x: impl Debug = foo(); does not work ? That's a bit disappointing.
[Phoronix wrote about this release](https://www.phoronix.com/scan.php?page=news_item&amp;px=Redox-OS-0.3.5-Released) and expressed interest in the possibility of doing some Redox benchmarks in near future: &gt; Hopefully soon it will be time to begin trying some benchmarks on this Rust-written, modern open-source OS.
If you think about it, parametric polymorphism is basically a fancy macro. In the end the generated code should be very similar, only that we have to do some "manual work. You could write a custom derive macro (which isn't so fun to do) and use it like this: #[derive(IntVec)] struct MyStruct {...} Or just use `macro_rules!` (waay simpler) and do this: struct MyStruct { ... } derive_intvec!(MyStruct); There are also some [libraries](https://github.com/DanielKeep/rust-custom-derive) trying to make deriving traits more programmer friendly.
Sadly that's a really complex one. I think it will require some larger changes on the traits to introduce some sort of native buffering mode that can then be used by different deserializers at different levels. Right now `flatten` and untagged/internally tagged use separate buffers.
How is that an antipattern?
&gt; like decent debugging, package manager, etc. Delve is a good debugger, recently released as 1.0, nicely integrated in VS code. A package manager is probably soon part of the standard Go distribution with the recent vgo proposal by the Go project lead.
That's because a deque is faster, but you're not going to understand a deque unless you understand a linked list first. Never use a queue or a stack on the job? Link lists are taught so one understands trees, graphs, priority queues, and and just about every other complex data structure from skip lists to splay trees. Concurrency is a good point, but it's going to be hard to understand a [threaded binary tree](https://en.wikipedia.org/wiki/Threaded_binary_tree) without understanding a linked list.
**Threaded binary tree** In computing, a threaded binary tree is a binary tree variant that allows fast traversal: given a pointer to a node in a threaded tree, it is possible to cheaply find its in-order successor (and/or predecessor). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I'd overlooked that detail about po8's definition. That said, until now, everyone I've interacted with has agreed with the definition I've been operating from, so I think "when no two people understand these terms the same way even as they aim to defend it?" is a gross overstatement.
Is there a crate providing stuff like this ready to use? It would be nice now that `impl Trait` is being stabilized.
Hey OP, C seems easy to us because we learned it first, but watching kids learn (especially younger than college level), they tend to struggle with C more than languages that support natural types, native or added later. Eg, a std::string is easier to understand than a char\*. (For more information checkout the video https://www.youtube.com/watch?v=YnWhqhNdYyk which is a great talk imho.) While it is a great idea to start head first into Rust, I do not recommend it. It's certainly possible, but not ideal. imho Python as a first year class, and then Rust as a second year class might be ideal. The advantages of this are more than meets first examination. Python is a bridge to almost every kind of programming from GUI, to data science, to systems and Rust and friends, to web dev, and more. Not only that, but it's easy for first time programmer to jump into. Me, I hate Python, but the advantages are undeniable. You should seriously consider throwing C out of the curriculum. Sure, the bridge between Python and Rust needs to be a bit longer, but not so much it should be a problem.
I find it super useful since it allows trait objects to be passed to generic functions. [Example](https://play.rust-lang.org/?gist=738d49cbb49cde04f58577255969a2be&amp;version=stable).
I suggest you look at [Ketos](https://github.com/murarth/ketos) as a starting point. Ketos is/has a bytecode interpreter, but it put quite some thoughts in interop between Rust and a Lisp'y language. Questions on implementing languages in Rust seem to surface regularly, and the community has implicitly been making a singly-linked-list of reddit posts linking to the previous discussion, so [here](https://www.reddit.com/r/rust/comments/83zqrq/what_interesting_compilers_and_interpreters_are/) you go.
Hmm ... this may or may not be a good thing. On one hand, it will give Redox more publicity. Also, having benchmarks could help identify areas where Redox could improve its performance. On another hand, Redox is quite new, early in development, yet unoptimised. Most benchmarks would probably be leagues behind FreeBSD/Linux/etc. This could make some people naively judge it by those performance numbers, get a bad impression and conclude that Redox is worthless crap.
It is schemaless in that sense, yes. The only reason I use the SQL database + structure at all is because I needed an easy way to index (for quick queries =&gt; quick API calls) and persist data to the disk. I though SQLite will be efficient enough for that purpose. I've though about the issue a bit and the only common metric I could think of between all things one could need to monitor is when the observation was made and one what machine (hostname and timestamp). I didn't want to have the system dynamically define a new table for each plugin since that added complexity, rather, I though it may be better to handle it via having some structure in the messages for various plugins (most of the ones I wrote use a JSON message structure if a structure was needed at all). I don't think there's much of a difference between what I'm doing now and plugin defining their own database model, other than the fact that in what I have right now you need to query the plugin-specific format and in the other you need to query the plugin specific database. The current approach can be slightly slower, but testing with rather large amounts of data it seemed reasonably quick to me, still, the current web endpoint may start lagging once you have 1+ months of data from hundreds of machine (but that's still in a very rough state). However, having the plugins define their message schema dynamically also leaves more room for plugins that wouldn't fit a SQL schema very well (e.g. plugins where messages have a somewhat dynamic schema). Having the plugins define their schema inside the message (e.g. via a JSON) affects performance but give flexibility in design and makes plugin easier to use. The slow down on the agent -&gt; receptor communication will be almost unnoticeable after I add a compression layer (something like xz level 4), I hope. Overall, I think the trade-off is worth it. If you'd have an argument as to why you think adding a schema for certain plugins would benefit this I'd be all for hearing this, the project really only had me (and two friends which I can some stuff by) thinking about it, so maybe the conclusions I reached are wrong. There's tow other alternatives other than those: The first is forcing all plugins to adhere to a certain schema (but that will limit the plugins that can be created). The second is creating some sort of "intermediary" schemas that a plugin can use, this means that if you have a plugin that doesn't fit any schemas, you can create a new one. It also means that you could easily create endpoints that would have "catch all" way of reading those schemas, rather than having to modify the endpoints you want to read the plugin format you want. 
Semver only requires incrementing the minor version if the changes are backwards-incompatible. In this case, nothing prevents you from using serde 1.0.0 code in serde 1.0.34.
Exactly.
Mostly a few people in his company. Some other developers he knows get to test it out though.
Rust has two very different meanings for the `mut` keyword. When used in `let mut foo = ...`: To avoid accidents Rust has decided it's a good idea to mark mutable variables explicitly. This is completely unnecessary for safety, it is always safe to modify a local variable that you have ownership over. When used in `&amp;mut foo`: This syntax is used to indicate that this reference is **unique** and there are no other ways to access this particular referenced data without going through this exact reference. Here I would link a specific article I read a long time ago explaining the mutapocalypse by one of Rust's core developers but I cannot find it...
Gloomy fatalism. I feel like the universe sees that I'm enjoying something and finds a way to take it away. Not literally, just a cynic.
Mesa has a software OpenGL backend
But semver says also &gt; MINOR version when you add functionality in a backwards-compatible manner [...] That means when you _add functionality_ ... which is what happened. It further says &gt; MINOR version when you add functionality in a backwards-compatible manner Which clearly did not happen. That's why I'm curious.
Unfortunately, because of how `generic-array` works around the lack of integer generics, that's about as clean as the errors can get. Additionally, `numeric-array` does not implement the functional parts. You'd have to convert it into `generic-array` via `as_array` or `into_array`, map/zip it, then convert it back. That's intentional because the specialization techniques used to optimize `generic-array` aren't transferable between crates. Once real specialization is stabilized we can improve that. However, what is *not* intentional is the lack of `Float` trait implementation. Oops, I'll fix that now...
I also seems hard to fix. ¯\\_(ツ)_/¯
Any details on what was rewritten and why?
Right, that's what I meant to refer to when I talked about collections and Item types. All legitimate, I should have thought for at least a second before I said "I'm not sure when people would require that". Thanks for the examples!
I assume most of the usage is to deserialize exotic external JSON data, which you have no control, without hand-rolling a "deserialize" implementation. A couple of attributes are much less error-prone than implementing yourself.
You've perfectly captured my feelings about this article as I read it.
Perhaps we're missing the word "variable" here: * `bar: &amp;mut Bar` is an immutable *variable* containing a mutable reference to Bar * `mut bar: &amp;mut Bar` is a mutable *variable* containing a mutable reference to Bar
It seems astonishingly entitled to me to expect everyone to license their work under your favourite license.
is is this? https://air.mozilla.org/rustmeetupparis-mozilla-what-new-in-rust-by-felix-s-klock-ii-special-mutapocalypse/
I can't really disagree with you on correctness grounds... but to be honest, I've *never* read it like that. Too many syllables, not enough confusing ambiguity.
Interesting! One use case for this would then be a constructor declaration in a Trait specification: pub fn from_settings(settings: Settings) -&gt; impl MyTrait
Not that, but it certainly sounds relevant! I found the article, here: http://smallcultfollowing.com/babysteps/blog/2014/05/13/focusing-on-ownership/
Are guitar scripts ban-able does anyone know ?
Sounds good :p users are a relatively new concept to me, lol
Use Rust, and get them to do everything in unsafe to start with. To begin with use things like `let mut i = 0; while i &lt; 10 { i = i + 1 }, then show how the language makes this better with iterators. Do stuff with raw pointers, like linked lists. Introduce Vec and explain that even though it occasionally has to copy itself, it's still the best collection in the vast majority of cases. Maybe show serde and teach them how a data structure with indirection and pointers is transformed into a single block of bytes, as a very common programming task.
Here's an example of doing that: https://github.com/xliiv/fui/tree/master/examples/shell_completions Now it's possible only from master and it will be released in next version. Thanks again for idea.
If you want to hide at all costs, you may `impl DogTrait for Dog` instead of `impl Dog` and then just return `impl DogTrait`.
This is awesome -- I think it is very much worth adding to the [Rust section of Arch Wiki](https://wiki.archlinux.org/index.php/Rust)!
Out of curiosity, why use a separate crate for numeric-array? Couldn't they have been combined?
As I feared. Thanks for the link!
I didn’t realize that. I’ve seen work related to redox in many of the libraries trust-dns depends on that I thought that had been completed. I guess I should look at helping out in that area first.
Although I've contributed a lot to `generic-array` lately, I'm not the original author, and I didn't want to clutter up the `generic-array` crate with the tons of trait implementations that `numeric-array` has.
I believe, you're on the wrong subreddit. /r/playrust might be what you are looking for.
&gt; Typing strength is a continuum, not a binary distinction. So maybe you should stop making claims of absolute classifications? &gt; Python's bool is a subclass of int for backwards compatibility reasons. True and False are instances of 1 and 0 with various special methods overridden. And thus the backtracking starts. &gt; The former is an unambiguous operation with sensible semantics, while the latter is not. The latter is both completely unambiguous and arbitrarily sensible, just as the former is. &gt; This "do what I mean" ambiguity There is no "do what I mean" ambiguity, the language defines whatever steps it wants. PHP's `+` adds numbers, the language thus *defines* adding non-numbers as trying to convert the operands to numbers before adding them. &gt; Implicit conversion for the purposes of string formatting is a very different beast than PHP's implicit integer parsing behaviour with "do what I mean" truncation. And all of a sudden "Is it str + str(int)? How should it be formatted and how do you justify that format?" is forgotten… &gt; If you want to see a hot mess of weak typing take a look at the Operators and Variables sections of PHP: a fractal of bad design. That PHP is garbage has nothing to do with the question at hand, which is the coherence and consequences of your classifications and assertions. &gt; Perl's most visible example of weak typing is that it has separate "numeric" and "stringwise" versions of its comparison operators because it will readily convert back and forth between numeric and string interpretations of data. Or it has separate numeric and stringwise versions of its comparison operators because it wants the developer to clearly specify the *operation* they want, and said operation will then perform whichever conversions are necessary, what's weak about that? Seems like pretty strong operations there. &gt; I'm not familiar with Scala and I'm not familiar enough with C++ to comment on them. Conveniently.
Whats wrong with the official tutorial for cross compiling to windows? http://gtk-rs.org/tuto/cross
Have you tried to compile a project with gtk based GUI **in Windows** with that tutorial? I didn't manage to make it work. The problem is it is for Linux and there is a lot of misleading information. I found a lot of discussion about the subject on my way and right information was really hard to find. I promise to buy you a beer if you manage to make a GTK Application window with button to really pop up in Windows with that information :)
The `Float` trait is now fully implemented for `numeric-array`. Now you can use `c.tanh()` directly, with `num_traits::Float` in scope.
Writing and supporting a fully-featured network stack is a non-trivial task, so the old stack has been replaced with a new one based on [smoltcp](https://github.com/m-labs/smoltcp).
Aren't these the instructions on official `gtk-rs` docs [here](http://gtk-rs.org/docs/requirements.html)?
You can store the `Arc&lt;Instance&gt;` though, and get back the physical device by id later.
There are many Scheme's with implementations of various levels of completeness on crates.io
Ah, thanks. I did not see that you are indeed compiling *from* windows to windows - that makes sense.
The entire motivation for this feature is to "erase" the type, but still have a concrete type at compile-time. So, you can think of this as a sort of compile-time trait object (though I'd consider the phrase really imprecise).
i guess, it is obvious.
Your title uses `bar` as a function argument, but it's worth mentioning that the syntax and semantics are the same for declaring `bar` as a local variable. In other words, the answers in this post are just as relevant for explaining the difference between `let bar: &amp;mut Bar = blah;` and `let mut bar: &amp;mut Bar = blah;`. I mention this because newcomers are far more likely to encounter the `mut` keyword in variable declarations than in function arguments (both support pattern matching in the same way).
Wow, I hadn't actually looked at `actix-web` before... skimming the docs now, it looks very, very nice.
I'll provide a more elaborate example of what I mean, maybe I am just too cryptic :)
I keep it simple -- is it a breaking change or is it not a breaking change? There is a continuum between bugfix and feature that I don't feel inclined to arbitrate every time we need to release.
Can you show how to do that? Looking at the example of vulkano I can't imagine right now (but I am only starting with it and don't know all the API)
OK, given how consistently your most recent responses seem to be attempting to "win the argument" rather than to have a constructive discussion, I think I'll make this one last response, go to sleep, and let you have the last word. &gt; So maybe you should stop making claims of absolute classifications? It was never my intention to make claims of absolute classifications. Temperature is also a continuum, yet it's still useful to talk about "hot", "cold", "hotter", and "colder". &gt; And thus the backtracking starts. Umm... what? I'm not even sure how you get from "Python worked within the type system to declare "bool" as a subtype of "int" for backward compatibility" to "ssokolow is backtracking". &gt; The latter is both completely unambiguous and arbitrarily sensible, just as the former is. If you're going to summarily dismiss the list of examples I gave without even attempting to discuss them, then I don't think we have anything more to discuss on this point. &gt; There is no "do what I mean" ambiguity, the language defines whatever steps it wants. PHP's + adds numbers, the language thus defines adding non-numbers as trying to convert the operands to numbers before adding them. I was referring to the overall design philosophy embodied by PHP's operators as a whole, such as the various failings of PHP's `==` operator (eg. the non-transitive nature of `==` comparisons as elaborated in the page I linked.) as well as the questionable advisability of allowing `+` to do best-effort parsing of integers in strings to the point that "1 egg" is a valid input for an arithmetic operation. Given the tone this conversation has taken on, I don't really feel motivated to go dig up more examples to reinforce my argument before I end things, so feel free to believe whatever you want. &gt; And all of a sudden "Is it str + str(int)? How should it be formatted and how do you justify that format?" is forgotten… It's two separate issues. First, the question of whether it's a good idea to define `+` for strings and integers, given that no single interpretation is significantly more correct than the others. Second, the topic of whether its fair to consider the string-plus-integer concatenation *already supported* in Java and JavaScript as a design decision comparable to PHP's approach to implicit integer parsing. &gt; Or it has separate numeric and stringwise versions of its comparison operators because it wants the developer to clearly specify the operation they want, and said operation will then perform whichever conversions are necessary, what's weak about that? Seems like pretty strong operations there. Because the type is associated with the operators rather than the data. While conversion may not be manual, like in assembly language, making type out-of-band information by tying it to the operators is still a characteristic associated with the weak end of the type system. &gt; Conveniently. No need to snipe at me. I'm primarily a Python, PHP, Shell, and JavaScript programmer (with more minor experience in other languages) whose only exposure to C++ is a single semester of it at university and I have no formal backing in language theory.
The clue is right at the end: error[E0271]: type mismatch resolving `&lt;..&gt;::Error == ()` The compiler can't prove that `xd`'s associated `Error` type is `()` (which is often used to mean "no errors possible"). In this case, "can't prove" likely means "knows for certain it's a completely different type" as opposed to "not enough information to be sure", but the error message is the same either way.
Maybe you're not understanding the suggestions? /u/tomaka17 knows a think or two ;)
How does it compare to [HolyJit](https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/)?
Wow, very cool. He didn't take the easy way out either: Dora features a JIT compiler with backends for multiple architectures; is a statically typed language with variable-sized arrays and subtyping; has a (or perhaps two) exact, cycle-collecting garbage collectors (yay, Cheney's algorithm); and does all that with very reasonable performance. Thanks for posting this here.
Good Bot.
Impossible, you say? ```rust #![feature(conservative_impl_trait)] struct Struct&lt;F&gt; { value: F, } fn get_callback() -&gt; impl Fn() { || println!("Hello, world!") } fn main() { let s = Struct { value: get_callback(), }; (s.value)(); } ```
&gt; class Point(let x: int, let y: int) Have you considered a Scala-like declaration without `let`? class Point(x: int, y: int)
I think a dedicated wrapper object featuring standard fields + a generic Object- or string-type field would be more clearly defined than injecting the fields into different kinds of objects.
But there are protocols that already exist that require a flatten like feature. 
You are right, I was probably interpreting your comment uncharitably, sorry about that. It sounded to me like you are suggesting that Cargo should not allow non-MIT licenses.
Sp why not `Iterate`?
At a wild guess, do you *also* have a `src/main.rs` with the contents `mod lib;`? I've seen that mistake before. 
or rather "binding" :)
Can I export a global variable in Rust? It's required to use the gpu for some laptops. C ex: extern "C" { _declspec(dllexport) DWORD NvOptimusEnablement = 0x00000001; } or int NvOptimusEnablement = 1; int AmdPowerXpressRequestHighPerformance = 1;
It probably would make sense to add this to the gtk-rs website. I've created a [ticket](https://github.com/gtk-rs/gtk-rs.github.io/issues/70) for that Also note that for Rust/MSVC support, only [this](https://github.com/alexcrichton/pkg-config-rs/issues/59) would have to be fixed... which in the best case is a one-liner plus some testing.
At this point, abandoning it seems that Mozilla's only path to abandoning rust (in the next decade) would be if Mozilla itself vanished. Even then, rust is open source and others could carry the torch. So hopefully Mozilla stays a robust organization. I think they have made really good strides over the last three years towards a much longer term vision. But you never know
Is there a reason for the static `APP`? I'd rather setup the `APP` in main, to avoid quick-n-dirty access from all over the place, which is a disaster in waiting.
Is it possible to have a `let match` return structs which implement a trait? The following doesn't work: trait Shape {...} struct Circle {...} impl Shape for Circle {...} struct Triangle {...} impl Shape for Triangle {...} let shape = match particle { Particle::Circle =&gt; Circle::new(x, y, radius, colour), Particle::Triangle =&gt; Triangle::new(x, y, size, colour) }; // match arms have incompatible types, // expected struct shape::Circle, found struct shape::Triangle The structs `Circle` and `Triangle` both implement `Shape`, and I'm trying to create a vec of one shape - could be either, but will always be homogenous (so no vecs of both circle and triangle). 
I was taught Ada and C but not Rust at uni. Personally I think students would understand the reason for Rust better if they had some slight knowledge of formal methods, namely how difficult it is to prove programs. At least that's the case for me - Rust didn't make much sense until I've done a few logic courses and started learning formal methods myself. So if you can add some motivations from formal method sides of things(i.e. Rust's model proves a lot of things implicitly), I think the students would get it better. Our lecturer started the Ada courses with similar motivation. He would mention Ada is used for flight controllers, railroad management systems, things that demand REALLY high integrity. Then the idea starts to sink in and people go "right, yep, C absolutely can't beat that" and Ada starts to make a lot of sense.
That isn't directly possible. You can't have `shape` taking two different types at runtime. The two main options you have for situations like this are: 1. Define a new `enum` that has a variant for each type. In this case that's what you already have, and you're trying to get the types out of it, so this doesn't really help you. 2. Use have `shape` be of type `Box&lt;Shape&gt;`. That's a trait object, which can contain anything that implements `Shape`. It sounds like what you really want, though, is a `Vec&lt;Circle&gt;`. If you know that `particle` is a circle ahead of time, you can replace the `Triangle` branch with something like `_ =&gt; unreachable!()`. That would allow the match to return a `Circle` from the one reachable branch without confusing the type checker. If you don't know ahead of time whether you've got `Circle` or `Triangle` objects, and you're using some info you have at runtime to figure it out, you'll probably need two matches that each use that strategy.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://doc.rust-lang.org/std/mem/fn.transmute.html) - Previous text "doc" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Just to clarify this is not my work and I just wanted to bring some attention to Dora.
Quite different. Dora is a method-based JIT-compiler that basically emits Assembly-Code from the program's Abstract Syntax Tree (the AST for a Dora program). (I am the author of Dora) HolyJIT works more like Truffe if you know that, so all you need to do is to write an interpreter for your new programming language with a few magic functions/annotations from HolyJIT and HolyJIT will basically provide a JIT-compiler for your language. Writing an Interpreter is way easier than writing a (JIT-)-compiler, so this potentially saves a lot of work. Personally I am looking looking forward to HolyJIT, I am pretty sure this would be quite popular in the Rust community. Although the repo doesn't look like there was a lot of recent work on it. A side node: this is a project of a SpiderMonkey developer, I think it is unknown if they will ever be able to reach the performance of their current hand-written JIT-compiler for JS with HolyJIT. It will take them a lot of work to find that out.
I did this some time ago and I might have even thought about that. I did it this way because you could then do something like: class Foo(a: int) { let value = a * a; }
Thanks for your detailed explanation! &gt; I think it is unknown if they will ever be able to reach the performance of their current hand-written JIT-compiler for JS with HolyJIT. If I remember correctly they hoped that due to reduced development time they could focus on other performance improvements instead.
By that logic, will you always remain at 1.0.z for non-breaking changes? Or is there some significant milestone that you feel may warrant 1.1.0?
Thanks for your additions, that opened things up a bit. I was a bit confused since I got the feeling that this was not a virtual machine (I have some experience with Virtualbox in Arch), even though it looked similar. Then what comes to your question: from the ticket below you can see that the response is that there is already information available. I'm not enough interested in politics to start trying to change anything. I guess the information does exist (in not perfect form, but almost), but the problem is that it's "hidden" in the sea of not as relevant information. There is no "newbie corner" where information would be filtered to bare minimum to "get things going". Newbies who don't yet have capabilities to ask the right questions but to write "rust gtk gui windows" in google, youtube or reddit, that information is almost unreachable. I think the official (or somewhat official) rust documentation is really good and there is plenty of it. For newcomers, maybe even too much. There are webpages like https://rustbyexample.com/, https://doc.rust-lang.org/book/second-edition/ and http://gtk-rs.org/, but those are targeted to professionals. I'm not talking about the same audience. I'm talking the audience of lifehacker. There are different kind of people with different kind of needs and this is people who don't have a strong background, but they get excited about the new stuff and start learning. They join the reddit page and write "windows gui" in search bar, follow the instructions and start playing with stuff. Then, when they get hooked, they will start looking for more. I think it's great if there is something available for them as well. I think rust is revolutional and it's only a matter of time when people who wanted to start writing C++, but found it too difficult, will find rust and start exploring new waters with it.
As someone who contributed to `pnet` a while ago, I'm curious what the major differences are between `pnet` and `smoltcp`.
Sure. More and more people use Rust since it has been added to [CodinGame](https://www.codingame.com/) although the main principle is indeed "get round data from stdin, compute a few things, output decision to stdout". Also, although Python was allowed to be used in the [SWERC ACM-ICPC](https://swerc.eu/) programming contest in 2017, the 14 best ranked teams chose to use C++ rather than Python for all their problems, although some of them had no potential for exceeding the alloted run time even when done in Python. Some people just prefer using statically typed languages, even when they could use disposable Python scripts.
Most of the top ranked competitors use Java or C++, so statically typed languages are more than appropriate. The problems in the later rounds are *definitely not* as easy as a 15 minutes problem solved with a dummy hashmap (even in the qualification round). The bottleneck is normally the algorithmic part, not the implementation so if there were an added cost to write in rust it may not be prohibitive. Furthermore some people are proficient enough in rust for it not to be a problem (this was not a problem for the Advent of Code for example). &gt;Why would you use anything other than python? And nost importantly: because rust is fun.
(HolyJIT author here) This description is correct. At the moment, my interest is to get resources allocated behind HolyJIT development, such that this would no longer be a one person spare time project. Awesome word on making a JIT compiler, this is quite a challenge when starting from scratch! 
Thank you, now it clicks. From the docs for `tokio::spawn` I see ` F: Future&lt;Item = (), Error = ()&gt; + 'static, ` So the error type needs to be `()`. It's kind of confusing however as the error I see in Sublime is expected struct `std::io::Error`, found () when it seem like `()` was expected but I was giving `std::io::Error`
I am testing my library with an entirely separate test binary to make sure that it works. The test binary is using a macro from my library, but it is compiling and working even without a #[macro_use] anywhere in the code. This is unexpected to me, am I exporting the macros from my library improperly, or should I leave it be?
Thanks a lot! We've even talked at the VM Meetup in Prague ;) Hope you are successful with getting resources for HolyJIT! Awesome idea, awesome project.
&gt; Eventually you become a more experienced Rust programmer, but things don’t get much easier. There’s always another wall waiting around the next corner. The horribly anti-user futures system, compiler messages generated by a misused macros that are second only to C++ template errors in how egregiously difficult they are to parse, universally terrible documentation and lacking examples, unstable APIs, type annotation hell, and so much more. Well, let's stay tuned for the follow-up, they promised to go into details.
If it's fixed in the git repo, just pull the repo via git instead of crates.io. Though you should probably pin the version at that commit, since you normally don't want to pull directly from master to avoid breakge. Relevant section on [cargo docs](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories)
The crate app_dirs has just gone through that. They created app_dirs2 on crates.io. (See https://github.com/AndyBarron/app-dirs-rs/pull/29 for the discussion.)
&gt; universally terrible documentation and lacking examples Really? I've had the exact opposite experience. The documentation has been much better than most. Individual crates could use some TLC in their documentation department but the language documentation is fantastic. &gt; Even something as simple as abstracting a new helper function often turns into a veritable odyssey because getting type annotations right can be so difficult (especially where a third party library is involved). I can't speak for Futures based code since I haven't dipped my toes in there yet (I hear it's problematic) but type annotations are almost never a problem. When passing around data, either as arguments or return values, the compiler tells you exactly what it was expecting vs. what you gave it. Seems pretty clear to me. Rust is definitely hard to get into but, in my opinion, it gets *far* easier after getting over the first few humps.
I'm kind of with the author on futures, but I have high hopes for the... No, I'm not gonna say it. ...I have high hopes for *better usability of futures going forward.*
I believe the author changed directories-rs to directories: https://crates.io/crates/directories
I disagree. Rust is a language that becomes easier the more you use it. After my first 3 months or so, the compiler errors I was getting were pretty much only related to double borrowing (and general forgetting simple stuff, like `match` all cases). I've been using rust for about 6 months and have yet to use the lifetime annotation `&lt;'a&gt;`, so no lifetime issues for me so far. Maybe try structuring your code differently, or take a different approach, say, instead of using `&amp;` just `clone`. Maybe the author is having problems with the `futures` only, and it ended up clouding his judgement on the language as a whole. &gt; I estimate that I spend about 5% of my time building new domain logic, and 95% of my time fighting the compiler over problems I think the author is not trying to understand why Rust is complaining, and instead keeps trying to write the same code that would compile under a C-like compiler. I know for a fact that I'm pretty bad at programming, and that Rust takes a lot of effort (initially) to get going, but once you stop with the "(Language X) would not give me these compiler errors." mentality, and instead you start approaching Rust with a "Oh! So this value was moved and bad things would happen if I tried using it here!", you'll get your _Eureka_ moment, and Rust will become a breeze to use.
Yeah, and Rust community seems very friendly. I was thinking about "just leaving this here". If one searches for GUI and Windows in /r/rust, this pops up now semi easily. Also I tried to formalize the title so that it pops out for relevant people. If the information is worth it, this will keep living somehow when people copy the good bits to their own collections. If not, natural selection will bury it deep in :) I think Monero's (cryptocurrency) community is somewhat similar. Friendly and a lot of brilliant people around. I think their strategy is great: in Reddit there is one pinned discussion where there is all relevant info for beginners in compact package and one pinned discussion for newbies to ask stuff. Rust already has one pinned discussion for newbies and I think that's great. Only the pinned beginner info is missing. Here's how it looks like there: https://www.reddit.com/r/Monero/comments/7hhgjx/monero_gui_01110_helium_hydra_megathread_download/ For Rust it could have something like: 1) What is rust? -&gt; Link to a collection of youtube videos about good talks already there 2) How to get started? -&gt; Link to download page and probably few youtube videos and tutorials which explain how to boot to Hello World! Remember that many people don't know what the compiler is even though they may know some javascript, php, vba, html, css, sql... It's easy but just new information. 3) How to make and compile simple GUI? -&gt; Link to step buy step guides how to boot basic window with button for 1) Linux 2) Windows 3) Mac 4) Cross compilations in Linux. These guides should be separated to avoid any confusion. Also link here https://github.com/gtk-rs/examples 4) Short explanation to few key websites and what should one look from there, how the information can be found and what is the logic behind the structure of the websites: https://rustbyexample.com/ https://doc.rust-lang.org/book/second-edition/ http://gtk-rs.org/ I can even take care of the content for the pinned thread, if needed :)
I have [extended this](https://github.com/musoke/ipfs-search) to index text to tantivy.
&gt; When passing around data, either as arguments or return values, the compiler tells you exactly what it was expecting vs. what you gave it. Seems pretty clear to me. I don't have specific error messages to cite, but sometimes this cat get tricky. Sometimes when the compiler tells you it expected a different type, it's not because you passed a bad type, but because of some error somewhere else that through type inference bubbling up made the compiler expect a wrong type at the error site. Especially with lambdas and/or more complex types this can be confusing. 
I can see why he thinks Futures are anti-user (they are), but documentation? Overall documentation in Rust generally seems to be very good. Unless he's referring to Futures/Tokio again, documentation of which is pretty confusing. I can't say whether this is because the documentation is not written well or because the design of Futures/Tokio is confusing itself. Might be a combination of both. 
Lllplllplpll
Sure, that makes sense. I don't hit that too often but maybe that's just me.
I commend the work but I honestly don't really like when libraries use generic array's. It just complicates things, and it's nowhere near as clear as just having first class integer generics. If this is really something the community needs for libraries... please just put it in the language?
The last time I followed the codejam, the earliest submissions were almost always written in C++.
&gt; There are valid file names that cannot be represented as a String. Can you give an example? 
If you are using hyper, you need to manually follow the redirect. Read the appropriate header and emit a second request. For higher-level interaction, use [reqwest](https://github.com/seanmonstar/reqwest)
I agree it does need to be in the language. It's needed to be in the language for many years now. Whenever that eventually happens I'll gladly port my work over to it. However, until then, `generic-array` and `numeric-array` actually exist and do work, and for extremely computationally intensive workloads being able to squeeze out performance via auto-vectorization optimizations and stack allocation are a huge win.
did you consider using bridge library like [pyo3](https://github.com/PyO3/pyo3)? there is [setuptools-rust](https://github.com/PyO3/setuptools-rust), it simplifies rust integration. also check milksnake https://github.com/getsentry/milksnake
I have a possibly dumb question about the syntax: if `fn foo() -&gt; SomeTrait` is currently illegal, why did they have to introduce a new keyword? Couldn’t the above syntax have simply become legal with the impl meaning? 
I believe wasm32-unknown-emscripten is the old emscripten target, the new one you should use instead is wasm32-unknown-unknown.
I agree with him that the documentation generally feels quite poor. It could just depend which background you come from, but for me anything on docs.rs is fairly difficult to follow - it just doesn't seem to be structured in an intuitive way, and reading the source code actually seems a lot easier to follow (to me at least) than reading the documentation in a lot of crates. Apart from that, my experience of Rust has been that it is difficult to start but that learning curve levels off after a month or so. There are some weird catches, like floats not implementing Eq - but typically once you read up on why you can understand the design decision and work around it.
I wish I could, but I have a dependency that requires emscripten for web assembly (glultin)
Maybe because they always mix Futures and Tokio in"all" blog posts and confuse the hell out of everyone. If you just want to learn Futures, all the Tokio input is worthless.
i don't need gtk on windows platform, winapi is enough for me. gtk on windows another layer, means that another bloat.
That's the plan!
I don't have windows, but cross-compiling from linux produced the api.dll just fine. in src/api.rs: #[cfg(target_os = "windows")] #[no_mangle] pub extern "C" fn test() { println!("I was called from Python"); } in Cargo.toml: [package] name = "apidll" version = "0.1.0" authors = ["outroot"] [dependencies] [lib] path = "src/api.rs" name = "api" crate-type = ["cdylib"] compiled with: cargo build --lib --target=x86_64-pc-windows-gnu produced: tree target/x86_64-pc-windows-gnu/debug target/x86_64-pc-windows-gnu/debug ├── api.d ├── api.dll This is on rustc 1.25.0-nightly (0c6091fbd 2018-02-04). What compiler version are you on?
Yea I think I did, why?
There's no indication of the generated code in the docs I linked. The only indication is the effect section, which takes a very high-level approach. At some level the user needs to know what comes out, as they will be interacting with it when they use it later. Though this is a declaration-level macro (e.g. it creates a structure who's layout approximates that shown in the syntax used within the macro). An expression-level macro has a lot more room to hide its implementation.
It's not a dumb question! I honestly forget the answer, but there is one... hrm. (This is sometimes called "bare trait", maybe searching will help)
The post author replied with this, by the way: https://news.ycombinator.com/item?id=16662470
It's sorta kinda both. There's efforts to simplify things, and efforts to completely re-write the docs.
Reference documentation is pretty good, but it requires extraneous knowledge. You won't learn Socket programming simply from looking at Rust's Socket documentation, but Socket's aren't really "Rust." However a lot of what is Rust is limited to reference docs, the justification for a lot of language features are a bit opaque if you aren't reading through RFCs and the like. Of course intermediary documentation is on the Roadmap and I think is of community wide interest. I think [LRWETMLL](http://cglab.ca/~abeinges/blah/too-many-lists/book/) is a good example of the sorts of Rust features that at one point where inaccessible, and there are features that are still yet to really be distilled for those wet behind the ears.
&gt; Individual crates could use some TLC in their documentation department but the language documentation is fantastic. Most people, when making comments about docs, don't draw this distinction. Crate docs matter.
From my understanding, references passed into a new thread must have static lifetimes. Since Thruster is multithreaded, it needs to be able to use app's resolve function in a thread closure. That's why it is static at the moment. If that's not the case, I'm more than happy not make it static -- I agree that accessing it from anywhere else would be an antipattern and discouraged. That also being said, I'm not entirely sure why you'd want to access App outside of setting it's initial middleware functions, but I'm sure someone will find a use at some point :)
I think it's because you can't do the same in nested positions, like the trait object `Box&lt;SomeTrait&gt;`. When we switch to `Box&lt;dyn SomeTrait&gt;`, then we'll have a clear distinction between the two. `impl Trait` is existential, and `dyn Trait` is universal. RFC 2113 touches on this some, like [here](https://github.com/rust-lang/rfcs/blob/master/text/2113-dyn-trait-syntax.md#dyn-trait-vs-impl-trait-is-much-nicer-for-teaching-and-ergonomics-than-bare-trait-vs-impl-trait).
As far as I see it if you try learning Rust to make anything that requires using tokio and futures you're pretty much setting yourself up for failure. You may have been using Rust since the pre 1.0 days and have done async stuff in countless languages, even implemented your own reactors and event oriented libraries in few of them, at the end of the day the difficulty of type tetris you end up needing to play every now and then is just beyond grandmaster level. And I honestly don't see that as something the futures crate can solve as long as composition is used, because you'll always end up playing type tetris, async/await would help but that's also not a change in futures as far as I see it, it's just the compiler becoming a TAS for type tetris. It's kind of sad seeing tokio and futures harvesting another soul tho.
Command Line Interface (as opposed to Graphical User Interface)
Hold my beer
I don't think `rust-lang.com` is owned by anyone affiliated with Rust or Mozilla, so you're probably getting redirected through a similar affiliate network to the one `giigle.com` is a part of. I get a CloudFront error when I try to go to `rust-lang.com`, and `users.rust-lang.com` doesn't resolve for me, so whatever you might've seen, it's down for me. Or u haz virus.
What exactly is wrong with ada syntax?
I'm not currently home, but I'll try and upgrade when I get back and use that specific command, then I'll hop over to Linux and check that. I have a feeling it has to do with windows. 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/carllerche/mio) - Previous text "mio" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dw6piyv) 
Sorry if I wasn't clear. I meant I couldn't remember what "CLIQUE" stood for.
Personally, I would submit a literal PR which bumps the version, adds an entry to the changelog, and does any other changes which you can see are done on previous releases. If the author doesn't respond, and they don't give any other indications of maintaining the crate, maybe send an email to the email linked to their git account? If they don't respond to that within a few weeks, then the only option left is to fork the crate. If you feel like you could maintain it, you can do this, or you can make a post here in /r/rust asking for possible maintainers who could do the maintenance and be co-owners of the forked crate.
Generics struct: struct&lt;T&gt; Point&lt;T&gt;{ x: T, y: T, } You can't derive Debug from this struct without imposing the constraint of implementing std::fmt::Debug for T. I'm making a simulation of a solar system with various crate, and I needed to use generic structs. By default the Debug trait for T is non implemented. The right approach is manual implement Debug with the major constraint, so there is Debug only if T have Debug. This approach is not automatic with #[derive(Debug)]. (sorry for the poor english) 
Genuinely interested: what makes the documentations unintuitive to you? For me they feel fairly intuitive. Especially looking up Trait implementations on a class in core. I could see some crates having poor docs, but I'm puzzled as to what you find problematic with the core documentation.
There are solutions on the horizon for many of those issues.
I actually initialize the device and queues I need in the 'vulkan window' `new` I don't need PhysicalDevice after except to recreate swapchain it result in something like this: pub struct Graphics { device: Arc&lt;Device&gt;, queue: Arc&lt;Queue&gt;, uui: [u8; 16], // pipelines // render passes // framebuffers // ... } impl Graphics { pub fn new(window: &amp;Arc&lt;Surface&lt;::winit::Window&gt;&gt;) -&gt; Graphics { // instanciate device, all queues and everything else } // This is the only method where I need physical device again pub fn recreate(&amp;mut self, window: &amp;Arc&lt;Surface&lt;::winit::Window&gt;&gt;) { let (new_swapchain, new_images) = { let physical = // get physical from uuid; let dimensions = window .capabilities(physical) .expect("failed to get surface capabilities") .current_extent .unwrap_or([1024, 768]); self.swapchain.recreate_with_dimension(dimensions) }; // replace old swapchain and image } } 
Might be more appropriate to call zero a garbage producer rather than a garbage collector :P 
Mostly the navigation panel which I find un-intuitive and layout of the docs which find it very verbose (code-wise) and cluttered but at the same time very minimal on written explanation. I might just be used to a different format and struggling to get used to it, but as an example take a common crate like Serde which is fairly extensively documented - the docs.rs page is quite cluttered with the different overloadings of each function/method and automatically generated docs, E.G: impl&lt;'de, T0: Deserialize&lt;'de&gt;, T1: Deserialize&lt;'de&gt;, T2: Deserialize&lt;'de&gt;, T3: Deserialize&lt;'de&gt;, T4: Deserialize&lt;'de&gt;, T5: Deserialize&lt;'de&gt;, T6: Deserialize&lt;'de&gt;, T7: Deserialize&lt;'de&gt;, T8: Deserialize&lt;'de&gt;, T9: Deserialize&lt;'de&gt;, T10: Deserialize&lt;'de&gt;, T11: Deserialize&lt;'de&gt;, T12: Deserialize&lt;'de&gt;, T13: Deserialize&lt;'de&gt;, T14: Deserialize&lt;'de&gt;, T15: Deserialize&lt;'de&gt;&gt; Deserialize&lt;'de&gt; for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) https://docs.rs/serde/1.0.34/serde/trait.Deserialize.html This might be helpful if you are getting in to the finer implementation details, but when first investigating a crate it can be bewildering.
I can't remember what specifically blocked me, but I remember some of the fundamental string functionality was hard to find because it was derived from traits and not documented more directly.
```&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="refresh" content="0;url=http://searchassist.verizon.com/main?ParticipantID=euekiz39ksg8nwp7iqj2fp5wzfwi5q76&amp;FailedURI=http%3A%2F%2Fusers.rust-lang.com%2F&amp;FailureMode=1&amp;Implementation=&amp;AddInType=4&amp;Version=pywr1.0&amp;ClientLocation=us"/&gt;&lt;script type="text/javascript"&gt;url="http://searchassist.verizon.com/main?ParticipantID=euekiz39ksg8nwp7iqj2fp5wzfwi5q76&amp;FailedURI=http%3A%2F%2Fusers.rust-lang.com%2F&amp;FailureMode=1&amp;Implementation=&amp;AddInType=4&amp;Version=pywr1.0&amp;ClientLocation=us";if(top.location!=location){var w=window,d=document,e=d.documentElement,b=d.body,x=w.innerWidth||e.clientWidth||b.clientWidth,y=w.innerHeight||e.clientHeight||b.clientHeight;url+="&amp;w="+x+"&amp;h="+y;}window.location.replace(url);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; ``` This is what I get and it redirects to sears. Don't use Verizon people.
Certainly: #[no_mangle] #[allow(non_upper_case_globals)] pub static NvOptimusEnablement: i32 = 1; 
I'm going to guess that it's due to missing the `path = "src/api.rs"` line.
Yeah I was going with the terminal too. Partly because Rust doesn't have a great GUI solution, but also because I kind of wanted it to be scriptable (for whatever reason). Also I find clap and structopt to be the best argument parsers I've ever tried, although I haven't tried many. However, I tried relm recently, and I found it pretty nice to use, for my small little program. The only real problem with it might be that it uses GTK, which might make it hard to run on any other platforms than Linux.
&gt; There's efforts to simplify things I wonder what these are. The design decisions behind Tokio always seemed quite weird to me. I remember reading [this blog](http://aturon.github.io/blog/2016/09/07/futures-design/) and [this blog](http://aturon.github.io/blog/2016/08/11/futures/), but they seemed confusing and in some ways I believe even factually wrong, such as when there's a "callback approach" being ascribed to IOCP, while IOCP is not based on callbacks or anything resembling the API described in that section at all. There's two questions about Tokio off the top of my had I wondered about since its inception: Why is Tokio, which is meant to be cross-platform, based on `mio`, who's API pretty much copies one specific OS API (epoll) _including its implementation details_. Seems to me it would be better for Tokio to have its own more OS-agnostic I/O abstractions. (Aside: I always wondered how bad mio's overhead is on Windows, but never found any numbers and neither tried to measure myself.) Why was the `Future`-based approach chosen some over sort of a coroutine-based approach? I understand that the latter would require runtime support including a scheduler, but then again Tokio basically has to have that too... 
These Rust solutions usually are fast as hell though. That's what makes it fun to work on with me. 
The great garbage leaker.
That's saying the same thing: the type checker has reached a point where it expects two different types at the same point. If you try to conflate `Vec&lt;i32&gt;` with `Vec&lt;f32&gt;`, this happens: error[E0308]: mismatched types --&gt; src/main.rs:3:23 | 3 | let b: Vec&lt;f32&gt; = a; | ^ expected f32, found i32 | = note: expected type `std::vec::Vec&lt;f32&gt;` found type `std::vec::Vec&lt;i32&gt;` The compiler will tell you that it `expected i32, found f32` to point out which *part* of the two types differs. After all, it *could* be buried in a huge pile of deeply nested generics. It then adds some extra detail to the message with the complete types for context. If Sublime isn't showing you the extra context in any way, well... sorry, but that's not Rust's fault. :P
The other commented that it’s a problem with Futures - Sublime shows the error correctly, as reported by Rust. When I meant to say it’s backwards - I meant the message. For example, it’s as if your example stated “expected i32, found f32”. 
in my Cargo.toml ``` [dependencies] normints = { path = "C:/[path]/normints" } ``` and in my main.rs ``` extern crate normints; use normints::*; fn main() { println!("{}", ni32!(0.1)); } ```
I like the new name!
Ok, so the macro is being pulled in by this line: use normints::*; As far as I can tell, *it's not supposed to be*. There are plans to eventually have macro visibility work using `use` like everything else, but insofar as I can tell, that's not in the language yet. Except the above works all the way back to Rust 1.15, which was the release with non-plugin custom derive (*a.k.a.* Macros 1.1). Being able to use `use` wasn't part of that RFC, so ... this snuck into the compiler and no one noticed? The RFC even calls this behaviour out as something they'd like to add to the language in the future. I went back and checked all the release notes for every release from 1.15 up, and there's nothing about this going into the language officially. Unless someone can point out an officially accepted and implemented RFC that defines this, I'd stick to using `#[macro_use]` as, otherwise, this is a bug, and the behaviour may or may not change in the future.
no, i don't think anyone without a chip on their shoulder will thumb their nose at rust because one of its [many web frameworks](https://github.com/flosse/rust-web-framework-comparison) is no longer actively maintained. i really don't think it's reasonable to keep a crate on life support just to put up a facade of activity. libraries come and go in every language. it's just a fact of life. that said, if you care about iron, you can make a fork or send the maintainers a note and see if you can take it over.
I forgot that I had the compiler on nightly, that's probably what it is.
Hmmm.....this seems to highlight and important speedbump to the whole Rust Crates ecosystem. There probably needs to be some kind of override/out for this. None of the solutions proposed in the comments seem to really be a satisfactory solution to the problem. So, what happens with "Abandoned" crates? Will it always require a fork/rename of a new crate? Could things end up like: * cool-crate-rs (0.75, 1.0.0, ... 1.2.11 .............no one maintaining, no one responding from owner of crates.io account or corresponding GitHub repo) * cool-crate-rs-2 (created by some kind soul....makes it up to version 3.7.2 and then.........owners hit by bus....aaaahhhhhh....not maintainer.....) * cool-crate-rs-3 (created by a different kind soul....continues with newer versions.....until??????) Is this the only way things can go with crates.io? Shouldn't there be some sort of, "Take over abandoned crate option?" 
Has anyone prioritized the backlog of issues?
Hey, very nice documentation btw. Sometimes those things are not praised enough but it certainly shows more care was given to the usage of a library.
People new to rust read things like this: https://github.com/flosse/rust-web-framework-comparison Which might point some of them in Iron's Direction. "Libraries come and go", I wish Rust had a standard library that included HTTP Support, since I don't think HTTP Support is something that should "Come and Go", but rather "Stay and Improve", in a similar Fashion of Go and Python, which both have standard HTTP implementations. Should I just use Go instead of complaining about Rust?
I believe multiple frameworks use Hyper, which would make it something of a de facto standard. You could just use one of the other decent frameworks in Rust, no? Or use Iron? You haven't even mentioned any real problems here.
I took a brief look at your repo(presumably this [one](https://github.com/manuels/stun3489/)), and I'd say using nom would absolutely help with at least the following functions - `fn read_address(c: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;SocketAddr&gt; { ... }` - `pub fn decode(msg: &amp;[u8]) -&gt; Result&lt;(u64, Response)&gt; { ... }` I can't think of anything that would be better than using `byteorder`(I didn't know about it otherwise I would have used it as well) for encoding really, so maybe that's the best you can do atm, short of writing a DSL to do protocol implementation generation.
Work on type-level integers is progressing, so we'll get there eventually. I've been following the tracking issue with anticipation: https://github.com/rust-lang/rust/issues/44580
I'm getting the following error: = note: expected type `std::option::Option&lt;&amp;str&gt;` found type `std::option::Option&lt;&amp;std::string::String&gt;` I thought that a &amp;string is a &amp;str? I don't fully understand. .to_string and dereferencing don't work because it is an option type, not sure how to get around this one. Thanks for any help!
I agree. I haven't looked into either Gotham nor Actix but this is a big minus for Gotham in my opinion. Especially since they promote Gotham for being fast. Though I totally get wanting to make benchmarks yourself. But it needs to be done. 
&gt; As far as I see it if you try learning Rust to make anything that requires using tokio and futures you're pretty much setting yourself up for failure. Nothing requires tokio. 
Maybe it's just me, but I _still_ find the `expected... found` error message confusing. If I'm passing an argument to a function and it says, expected `A` found `B`, I have to remember that it's talking about what it `expects` for the argument _to_ the function, not the parameter _in_ the function.
right, that's what I linked. iron is marked as deprecated, so I'm not particularly worried that people are going to be misled. web frameworks are not at all the same as http support, and http support in rust *is* stable and improving. as /u/IntolerableBalboa said, hyper is the de facto standard for http, and it's been around for quite a while. that doesn't mean it will be around forever, though, and I don't think it has to be. but if it goes defunct, rust will either be dead or there will be a replacement, because http support certainly is critical for many applications. also, be aware that rust is first and foremost a systems language, not a web language. that doesn't mean it's a bad fit for web use, just that the web isn't always going to be the first priority. it would be nice if there were an http implementation in `std`, but I don't really think we need it. it would be way more opinionated and high level than almost anything else `std` provides, so it probably fits best as a crate right now. by comparison, go is pretty much built to run web servers, and it and python are both higher-level and more opinionated than rust, so it makes sense that http support is included in their standard libraries. as to what language you should use: pick whatever works best for your project, or what you want to learn. it may be rust, it may not. that's ok.
No, `&amp;str` and `&amp;String` are two different things - one is a pair of pointer to memory and length, and the other is a pointer to a structure that contains a pointer, capacity, and length. You cannot just assume that the second is the same as the first. However, because of `impl Deref for String { type Target = str; ... }`, if you try to assign `&amp;String` to `&amp;str`, the compiler will automatically insert the conversion for you. But it will only do that if the type is just `&amp;String` - but not if it is wrapped in `Option`, or any other struct/enum. To actually convert the `Option`, you can do let x: Option&lt;&amp;String&gt; = ...; let y: Option&lt;&amp;str&gt; = x.map(AsRef::as_ref); 
This is an awesome project! Great work!
Great blog post! The language sounds interesting, although I don't like the exceptions so much. I spotted one small typo, "staticaly" instead of "statically".
If the location is relative, I need to keep uri the same, but change the request location header, yes?
Am in support of the "Take over abandoned crate option?". Perhaps allow a period of 6 weeks after attempting to contact owner. The alternative of creating more names for same original source is just dirty, and messes with the ecosystem.
Indeed. I think that this "bad feeling" that you get also extends to other Rust constructs, most notably, `unsafe` blocks. There are plenty of comments out there saying that you should **avoid** `unsafe`, but this is a little misguided IMO, as you should try to **minimize** the use of `unsafe`, not completely avoid it like it's some kind of taboo. The big thing is that there are plenty of people coming to Rust from all kinds of languages (languages with GC, dynamic types, C++, ...) with all kinds of purposes (web, embedded, games, ...) , and the impression they are getting (IMO) is that there is some kind of "the perfect Rust code" which makes all your problems go away. Kinda like how the "zero-cost abstractions" quote is usually misunderstood as meaning "free performance". I hope to see Rust being treated more as a great modern language, instead of as some Holy Grail. This would probably help lowering the tension we have with other programming communities.
 &gt; I'm not naming the crate since, you know, the authors have already put in a substantial amount of work that I'm not paying for, and looking at the profiles of people with commit access, they're heavily active in more important crates. This is a good observation. If the developers are heavily active *somewhere*, chances are they will be friendly enough to publish a new version on crates.io for you, if you just find the right way to get their attention (since they're not listening to issues on github). Finding that right way can be a bit bewildering, so if you don't want to name the crate or the people publicly, then maybe contact someone who knows a lot of people? If I didn't know where to go I'd probably start at the Rust community team. 
I also struggled using the docs in the beginning and still find them less intuitive than Haskell docs. A few reasons: * Scrolling through the contents to find the traits, functions, etc. sections can be tedious. * It can take some clicking around various modules to figure out where a struct is defined. * There isn't a concise list of all methods for a given struct. I must scroll through the often verbose trait implementations. 
Yeah, fortunately, not that much code. It's basically just one more trait. An additional advantage is that it loosens coupling between implementor and user. Uncle Bob would be proud. :)
Some thoughts on why it might be nice to bump minor anyway: * Big numbers are harder for people to distinguish from another. 1.1.0 is easier to remember than 1.0.33. * Someone new to serde might look at the version number and think "Why do they have so many patch releases, maybe they needed a lot of bug fixes?"
I remember the same experience when learning `Vec&lt;T&gt;` - of course, I expected the docs to give all the methods! But a number of very important methods are defined by traits. So introductory material needs to set out _how to read_ the docs.
If we get specialization like this blog post, it might: http://smallcultfollowing.com/babysteps/blog/2018/02/09/maximally-minimal-specialization-always-applicable-impls/ We'd be able to then do: impl&lt;I&gt; LogicalShift for I where I: Integer { ... } impl&lt;IV&gt; LogicalShift for IV where IV: IntVec { ... } as long as there's also a block: impl&lt;I&gt; LogicShift for I where I: Integer + IntVec { ... }
Why? Because that's what caused the problem then! Cargo actually compiles `src/main.rs` and `src/lib.rs` as two entirely separate crates (the "binary" and the "library" respectively). The idea is you put all the potentially reusable functionality in the library, and then your command line glue code or whatever in the binary. Then if you publish to crates.io and someone wanted to make a similar program, they could pull in your library. Meanwhile your binary uses stuff from the library the same was as this hypothetical dependency would -- by writing `extern crate name_of_your_crate;`, *not* `mod lib;`. So what happened in your case is Cargo compiled the library crate (presumably successfully), but *then* it tried to compile the binary crate, which pulled in `src/lib.rs` as a module, so it wasn't the crate root anymore, hence the errors about `#[macro_use]` not at crate root. 
I would like to use iterators to do a calculation that might fail, but I cannot figure out how to handle errors (I'm potentially missing something obvious). The following simplified function demonstrates what I'd like to do. It should either return Ok(sum) or Err if there are any negative numbers. Currently I'm using an explicit for loop to get around the issue. fn get_sum() -&gt; Result&lt;i32, String&gt; { let data = vec![10, 20, 30, -10, 40, 50]; Ok(data.iter().fold(0, |acc, v| { if *v &lt; 0 { // Err("must not be negative") } acc + v })) } Thanks! 
Cool! There's a minor formatting issue in the readme/crates.io page: &gt; '9/11` (this if using `Dialect::Us`) Looks like the second `'` became a `\``? &gt; A week-day works in the same way: 'friday' means this coming Friday, relative to Tuesday - it is simply the Friday of this week. 'last Friday' and 'next Friday' are unambiguous. Unfortunately I don't think "next Friday" is unambiguous to humans: I'd personally interpret it (Australian English) to mean the Friday *after* "this Friday" (which is the one in "this week", and is thus "this/next Friday" are a little clunky/confusing if used on a Saturday). That is, modifying your example: $ p 'this fri 8pm' '2018-03-14' base Wed Mar 14 00:00:00 2018 +0200 calc Fri Mar 16 20:00:00 2018 +0200 $ p 'next fri 8pm' '2018-03-14' base Wed Mar 14 00:00:00 2018 +0200 calc Fri Mar 23 20:00:00 2018 +0200 See also https://english.stackexchange.com/questions/3841/which-day-does-next-tuesday-refer-to and https://english.stackexchange.com/questions/36419/next-friday-vs-this-friday (etc), which seem to imply it isn't purely an Australian dialect thing.
1. As I understand it, there's no `Edition="1.24"` at all. 2. There are adjectives for which this isn't the case (though I am failing to remember or find the linguistic term). E.g. a sea cucumber is not a cucumber.
Thanks for the eagle eye. Yes, English is a seriously underspecified language. The 'next friday/last friday' is straight from `date`. Actually, now that you mention it - people here will also mean what you think it means - it isn't 'this friday', it's 'next friday'!. I shall think about this. We're in the 'principle of least surprise' territory here. 
Some seem to agree with `date` here: https://www.quora.com/Is-next-Friday-the-same-as-following-Friday. My fellow South African /u/tshepang_dev suspects that this is the American meaning. It remains a marvel that we can all still communicate with each other. It's a particular problem for a fairly dumb library which needs fixed and unambiguous patterns
Is Redux capable of running real-time applications properly?
 fn get_sum() -&gt; Result&lt;i32, String&gt; { let data = vec![10, 20, 30, -10, 40, 50]; data.iter().fold(Ok(0), |acc, v| { acc.and_then(|acc| { if *v &lt; 0 { Err(String::from("must not be negative")) } else { Ok(acc + v) } }) }) } 
&gt; I believe it was accidentally stabilized If you were feeling *rather uncharitable*, you could say that about sums up the macro system in general. :P
I found an [existing question on this](https://github.com/Rust-SDL2/rust-sdl2/issues/582), where the answer appears to have been: "no". I couldn't locate anything newer on the question. The hard problem *appears* to be that `rustc` doesn't export public symbols from executables.
Rust does not understand the notion of exporting symbols from an executable, so it does not have first class support for this currently. Maybe in the future things will improve. In the meantime, you could use `cargo rustc` with `-Clink-arg` to pass `/EXPORT:symbol` to the linker to tell the linker to export that symbol.
Thanks for the great feedback, darrenldl! ;)
Thanks! I usually name all of my quick projects after soda, but I thought this one was getting big enough that it deserved a real name :-)
If you're just cloning then you're losing the performance which the borrow checker gives you w.r.t. references
Yes its very situational/context dependent, will be hard to pin down. /u/stevedonovan lets not even get into South Africanisms like now now. ;-)
Cheers!
If you have any ambiguities, you could perhaps prepare a survey and post it here, URLO, and maybe some other places to find out what people *think* it means.
I would not inflict "now now" and "just now" on people already confused about how to say "next Friday" unambiguously! (The Welsh say "now in a minute" :)). That's the heart of the problem, when you try to interpret "English" expressions. As a human writing on a Saturday, I'd say that "Monday" means "next Monday" (by the simplistic rules in this crate). It appears that even "next Monday" is a dialect thing!
Ah, I see. First of all, to clarify, to be able to send an arbitrary `T` to a thread it must be `Send` and with the standard library implementation it must also be `'static`: `T: Send + 'static`. One important note is that the `'static` bound does not mean that `T` itself has a `'static` lifetime, but instead that if `T` contains any reference, those have no less than a `'static` lifetime. In your case, you are sending a `T = &amp;App&lt;Ctx&gt;`, and therefore indeed `App&lt;Ctx&gt;` needs to be `'static` here. You could, however, send another type, such as `Arc&lt;App&lt;Ctx&gt;&gt;`. Or hide the `Arc` instead `App` (wrapping the router, the function pointer will not be an issue): struct App&lt;T&gt; { router: Arc&lt;RouterParser&lt;T&gt;&gt;, context_generator: fn(&amp;Request) -&gt; T, } (I think the former would yield slightly better performance, as it will avoid one indirection for functions taking a `&amp;App`).
Kiwi chipping in here. I interpret "next Friday" as the Friday that follows today + 7 days. Next week's Friday vs this week's Friday.
&gt; As far as I can tell, it's not supposed to be. There are plans to eventually have macro visibility work using use like everything else, but insofar as I can tell, that's not in the language yet. It's implemented, but it's supposed to be gated behind the `use_extern_macros` flag. If you try to import the individual macros by name you should get an error about it. It looks like this was reported last September but no one's touched it: https://github.com/rust-lang/rust/issues/44750
I LOVE that idea!! Thanks so much for the pointer! I'll try that out this weekend :-)
&gt; There isn't a concise list of all methods for a given struct. I must scroll through the often verbose trait implementations. This! Very often I have an idea of the signature of the method I wish to use. For example: I have an `Option&lt;T&gt;`, if it is none I want to call a closure to generate another `Option&lt;T&gt;`, what's the name already? Scrolling starts... I think a quick summary of all methods (with NO explanation, just signatures) at the top of the documentation, sorted by number of arguments *then* names, would be invaluable for quick eyeballing. Then clicking on the method name would send one to the full-length explanation. So, for example, you land on [Option](https://doc.rust-lang.org/std/option/enum.Option.html) and before the **Methods** section you have: &gt; ## Methods Index &gt; &gt; Option&lt;T&gt; &gt; &gt; fn as_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; &gt; fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt; &gt; fn is_none(&amp;self) -&gt; bool &gt; fn is_some(&amp;self) -&gt; bool &gt; fn iter(&amp;self) -&gt; Iter&lt;T&gt; &gt; fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; &gt; fn take(&amp;mut self) -&gt; Option&lt;T&gt; &gt; fn unwrap(self) -&gt; T &gt; fn unwrap_or_default(self) -&gt; T &gt; &gt; fn and&lt;U&gt;(self, optb: Option&lt;U&gt;) -&gt; Option&lt;U&gt; &gt; fn and_then&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt; &gt; fn expect(self, msg: &amp;str) -&gt; T &gt; fn filter&lt;P&gt;(self, predicate: P) -&gt; Option&lt;T&gt; &gt; fn get_or_insert(&amp;mut self, v: T) -&gt; &amp;mut T &gt; fn get_or_insert_with&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut T &gt; fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt; &gt; fn ok_or&lt;E&gt;(self, err: E) -&gt; Result&lt;T, E&gt; &gt; fn ok_or_else&lt;E, F&gt;(self, err: F) -&gt; Result&lt;T, E&gt; &gt; fn or(self, optb: Option&lt;T&gt;) -&gt; Option&lt;T&gt; &gt; fn or_else&lt;F&gt;(self, f: F) -&gt; Option&lt;T&gt; &gt; fn unwrap_or(self, def: T) -&gt; T &gt; fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T &gt; &gt; fn map_or&lt;U, F&gt;(self, default: U, f: F) -&gt; U &gt; fn map_or_else&lt;U, D, F&gt;(self, default: D, f: F) -&gt; U &gt; &gt; Option&lt;&amp;'a T&gt; &gt; &gt; fn cloned(self) -&gt; Option&lt;T&gt; &gt; &gt; Option&lt;&amp;'a mut T&gt; &gt; &gt; fn cloned(self) -&gt; Option&lt;T&gt; It's coarse, but incredibly compact (notably because there's no trait bound, and that's very intentional). I'd also bring in all methods obtained by implementing `Deref`, but I am afraid bringing the methods implemented by commonly derived traits like, `Clone`, `Hash`, `PartialEq`, `PartialOrd`, etc... would be very noisy. /u/steveklabnik1 thoughts?
My wife agrees with you, so at least we have the Southern Hemisphere sorted. Now for a simple "Friday", currently interpreted as the day of the _current_ week. 'Current week' has different interpretations (as _chrono_ itself makes clear) so I'd suggest "Friday" be interpreted as the "the Friday after today" instead. (Yesterday is then definitely "last Friday")
I don't think this is useful. "Losing performance" isn't an absolute. It always depends on workloads and goals.
It's ok if the fields are public, but otherwise it would leak implementation detail to users of the struct. For example, [`str::Chars`](https://doc.rust-lang.org/std/str/struct.Chars.html) contains [`slice::Iter`](https://doc.rust-lang.org/std/slice/struct.Iter.html) as a private field. If \[T\]::iter() returned a `impl Iterator&lt;Item = &amp;u8&gt;`, str::chars() would have to return a `Chars&lt;impl Iterator&lt;Item = &amp;u8&gt;&gt;`.
Requests have no location headers. You must fix the path
I think you can workaround around this by using `impl Trait` more. Instead of returning a struct that contains `impl Trait` in it, you can return `impl Struct`.
I guess its because your project is a library, not a binary Try creating a binary with main like this: ```Rust extern "C" { fn emscripten_exit_with_live_runtime(); } fn main() { emscripten_exit_with_live_runtime(); } ```
That library is pre-custom derive as implemented in the compiler. Custom derives as they are used now are actually pretty straightforward. There's even a chapter on them in the first edition of *The Rust Programming Language*: https://doc.rust-lang.org/book/first-edition/procedural-macros.html * Parse the type it's being applied to using [`syn`](https://crates.io/crates/syn) * Generate the impl using [`quote`](https://crates.io/crates/quote) The former step gives you [nice, strongly typed, abstracted output](https://docs.rs/syn/0.12.14/syn/struct.DeriveInput.html) while the latter step ends up looking a lot like how you'd do it with a `macro_rules!` macro, except it's actually a lot simpler being able to process the input dynamically, as anyone who's had to parse and transform Rust syntax in a macro knows all too well. A macro might be fine for a trivial trait like `Copy` but if you have to dig into the guts of the implementing type, I'd take a custom derive any day of the week.
Not sure if that's an easy question, but how do I access WinMain arguments? I'm looking for nCmdShow specifically.
either add a main.rs file with a main function or uncomment the `crate-type = ["cdylib"]` in Cargo.toml. I would prefer the latter one because your crate is meant to be used as a lib, not binary.
&gt; A macro might be fine for a trivial trait like `Copy` but if you have to dig into the guts of the implementing type, I'd take a custom derive over a macro any day of the week. Ok, now that's just *egregiously* overstating things. Macros are mostly simpler for direct, uniform expansions (*i.e.* the same transform over all fields for things like `Add`), a mixed bag beyond that up to about `Serialize` levels of complexity, and not worth the effort beyond that. I'm still rather disappointed that there's no way to map derivations to macros for simpler cases.
After reading the blog post I get the impression that the author is quite new to using a language with static typing and that most of the expressed frustration comes from that. A stronger focus on examples in documentation could help but if the problem is general lack of experience the brick walls will still be there. Perhaps a "Learning Rust as your first language book" would be useful not only for complete beginners but also for people coming from the background of exclusively working with dynamically typed languages?
rustdoc has crappy but existing support for searching by type signature. &gt; (notably because there's no trait bound, and that's very intentional). The problem with this is, then you get "why can't I call this method, it's right there in the docs"...
&gt; I wonder what these are. * the new changes in futures 0.2 * the new changes in tokio 0.1 and 0.2 * async/awit * the new pin stuff, which, when used with async/await, transparently allows you to borrow across future chains, no more `'static` dance * "Async programming in Rust", an entire book focused on explaining the stack, in detail. &gt; Why was the Future-based approach chosen some over sort of a coroutine-based approach? They're not exclusive. async/await is a way of using generators (aka co-routines) to write out your futures chains in a simpler way. &gt; but then again Tokio basically has to have that too... Futures are useful for more than just Tokio.
&gt; So introductory material needs to set out how to read the docs. The front page of https://doc.rust-lang.org/stable/std/ includes "how to read these docs." In other threads, people are complaining that it exists at all. It's really hard to satisfy everyone.
&gt; The problem with this is, then you get "why can't I call this method, it's right there in the docs"... Would you? Maybe. But would it be a problem? I think not.
&gt; Most of the top ranked competitors use Java or C++ Most top ranked competitors participate in organized coding competitions where those two languages already have a strong presence due to being on the allowed list and fast. The fastest language on the allowed list will always dominate in the top contestants. I'd love it if coding competitions moved to being data oriented (wasn't GCJ based on data and not code?) instead of uploading your code to an online-judge, you opened a websocket connection to get problem sets. It would be awesome if the [ICPC](https://en.wikipedia.org/wiki/ACM_International_Collegiate_Programming_Contest) started allowing Rust, I think we would see a huge uptake at the CS level within universities. Competitive Programmers basically have zero reason to learn Rust. 
Brit here and I would do the same, but my parents would interpret it as this Friday, so it's not something you can assume on geography.
Nice pointer, thanks! I was looking for an std extension, turns out WinAPI has a function for that. Neat.
Thanks, good to know. My knowledge is a bit of out date, I guess.
Sure, but chaining multiple macro-based derives is gonna get kinda ugly (or may not work at all if they don't expect impl blocks). And when generics get involved, all bets are off. You also have little to no control over error messages. Derives are a little more complex for the author but they're overall a lot nicer to use, and I don't think that can be understated. It's also mostly a tooling thing, but the IDEA Rust plugin kind of treats macros as a black box (because they'd have to reimplement the macro expander), so goto-definition just stops working when the type in question was created by a macro. I could use an IDE with an RLS-based plugin but I'm used to IDEA and the plugin is otherwise pretty great.
Yes, I've even experienced this myself! Consider this code: struct Foo; struct MyError; fn main() { let x: Result&lt;Foo, MyError&gt; = Ok(Foo); x.unwrap(); } This doesn't compile. Do you know why, off the top of your head? In this specific case, the compiler errors have gotten way better, and so it will help you fix the code, but previously, it was *very* confusing. I'm not sure how a newbie would deal with the error, good or bad.
When I uncomment `crate-type=["cdylib"]` in my Cargo.toml, I get an error saying that cargo cannot produce a cdylib for the project because the target `wasm32-unknown-emscripten` does not support these crate types. Is there a workaround for this?
Agreed - hopefully not a thankless task! I made [some effort](http://stevedonovan.github.io/rust-gentle-intro/5-stdlib-containers.html) to explain the details for `Vec&lt;T&gt;`. (I believe this was recently republished in a more attractive format :))
Parts of it certainly could, yes. Other parts (notably the various sockets) are merely thin wrappers around OS provided constructs, so they cannot.
What if you need your app to run in windows and linux?
What do you need emscripten for? 
In addition, this is why some of us have been advocating for shared github orgs. Teams can be used to limit access unless you disappear. The ways this still fails the bus test are `cargo publish` and appveyor. iirc Travis uses an org's permissions but appveyor creates a per-user configuration. For example, got a release process tool? maybe move it to crate-ci. We can set. Got a command line library? maybe move it to rust-clique.
Additionally, you're in a unique position to help make oxt happen. http://oxtweekend.com/
I'd like to compile my rust code to a format that will run in a web browser. My plan was to compile my library into web assembly and call a start function defined in the library from the javascript. I need emscripten to compile the library into a format that a browser can understand.
&gt; It can take some clicking around various modules to figure out where a struct is defined. I find that the search bar is really nice for this. 
I didn't know about the pin stuff and the book, I'll look into it! Thanks for your answer.
I'd like to, but I need emscripten for one of my dependencies (glutin). Is there a way to create an opengl context using wasm-unknown-unknown?
Ah that's why I asked what you need emscripten for. Though seems like glutin doesn't support unknown-unknown yet. Maybe try with by adding the main file with an empty main function? Though I doubt that would work.
I find the docs fairly confusing, generally for crates rather than the language itself. I tend to end up on a page to find out what a crate can do and how to use it, but the main landing page for a crate lists enums, traits, modules etc which really doesn't help me work out how to get started.
0.1.1 just uploaded - "Friday" now works properly and agrees with `date`; "next fri" is same as "fri" for `Dialect::Us` and is plus 7 days for `Dialect::Uk` - i.e. always the Friday of next week. Relative date expressions like "1 April" are still always evaluated using current year by default, with "next/last" forcing the direction.
Creating an empty main function solves the issue of cargo not creating the proper wasm files, however when I load the wasm file from Webpack, I get this error: ", we need the wasm binary to be preloaded and set on Module['wasmBinary']". What does it mean to set the Module['wasmBinary']? It doesn't look like Module is a valid object reference.
Actually I started playing with wasm just two days back, so I don't have a clear answer. What browser? And I assume the error is on the browser-side?
Thanks for the timely link. I pushed my viewpoint that a 'cfg' abstraction should only permit vetoed relative paths by default - that get turned at runtime into cfg.parent().join(relative) - and panic otherwise. Which is probably something too radical, but i'm really sick of 'portable' configuration files and standards that aren't actually portable as soon as you try to think of the 'if i place this in a removable flash pen it will work on windows or linux without the user editing cfg files?'.
Very nice article! Even though I am coming to hate dynamic typing more and more, I dearly love Python. Despite whatever warts you may find in it (a good friend of mine calls it "a crippled Scheme"), it has 20+ years of refinement, polish and engineering to it, and it shows in so many places that are worth emulating. Half the things he talks about are things that both Python and Rust inherited from functional languages (lambdas, single-line if's), but if there's a language out there that did iterators *really well* before Python did, I'm not aware of it. Icon, maybe???
Regarding relative/absolute paths, you want something like ``` AbsolutePath::join(&amp;self, path: RelativePath) AbsolutePath::replace(&amp;self, path: AbsolutePath) RelativePath::join(&amp;self, path: RelativePath) ```
I have felt that the serde documentation is a bit confusing, but the inclusion of implemented traits has been actually really nice, and it’s on the bottom which puts it out of the way of most of what you need to begin with. It’s nice (and important) because it helps me find things already implemented or find that function and which trait I need to use to make it work. I think it feels messy at first, until you need it, then it’s a godsend.
What I think you're missing in my rant is that you can't tell 'from' where a user inserted cfg path came from even if it's relative. There is simply no way that `RelativePath::fromLinux` would work on a text format the user opens and inserts something that will 'work' (a path with '\' in a filename for instance) and transfer it to Windows without the interpretation windows side to be completely failible (ommiting or replacing 'forbidden characters' ) Thus i find it much more preferable that it's simply a error. User inserts string into 'portable' cfg in linux, tries to run the program, gets a exception because he used ':' or '\' etc.
Except when it’s slow ;) I built a generator of random data in rust and used clone to get it done fast. Trouble was that it was still taking hours to finish and my memory bloated. By using `Arc` and cloning the smart pointer I got static memory usage and faster runtime (10x faster). I still ended up “cloning” for ownership but knowing what you are cloning is important. In this way the explicitness is good. However, it’s also important to teach/understand *what* you are cloning. It’s import
When using single line if statements don't forget the semicolon at the end!
I agree that Rust is rather Pythonic, but it's also the “other way around”; Python is a system programmer's dynamic language, and it's very C-ish in some parts.
You can the code getting benchmarked at https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Rust/tokio-minihttp/src/main.rs and considering it's #1 for the plaintext benchmark the DB code here (or the libraries used for the DB connection) are going to be the problem.
Isn't `if ... else ...` really the same thing as a ternary operator, since Rust is an expression oriented programming language?
If you're worried about what newcomers are going to think and do, you should measure it. Anybody can invent a phantom to throw punches at.
&gt; C approach of just using some pointers and you're done, compared to what you need in Rust to achieve the same goal To do the same thing in Rust, you just use some pointers and you're done. The difference is that you you highlight where things can go wrong by wrapping them in `unsafe`, and if you did that, it would be fairly clear why Rust exists.
Linked lists are excellent pedagogical tools to explain pointers, and data structure tradeoffs. If you start by comparing a linked list to an array, you get a lot of fundamental programming concepts to explain from a fairly simple exercise.
Thank you for this, I was working on a comparison like this but never finished it!
For the tuple example in rust, wouldn't that just Copy the tuple rather than alias it? I think you'd need some refs somewhere.
Sorry, I'm a bit of a noob, what does that mean?
`unwrap` requires `E: Debug` to format the panic message, so `MyError` needs a `derive`.
Don't forget "Friday week," which is common at least in Australia (and I prefer it to "next Friday," because it's less ambiguous).
Actually, the `actix` [implementation](https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Rust/actix/src/db.rs#L62-L76) doesn't look great, because it allocates. It would be better to use [`get_result`](https://docs.rs/diesel/1.1.1/diesel/query_dsl/trait.RunQueryDsl.html#method.get_result) instead. Actually, I recall someone asking here on Reddit why that code is slow, and people probably made the same suggestion. cc /u/fafhrd91
It's probably a combination of maturity -- both in libraries and in the benchmark implementations -- language trade-offs (Rust does array bounds checks and is stricter in general, while in C you can play fast and loose), compiler issues (like the parallel codegen that was recently enabled and sometimes makes code slower) and LLVM, which often, with clang, at least, generates slower code than GCC. These will all get better in time, but I expect the progress to be rather slow (maybe years). In the meanwhile, if you feel like it, you can contribute at chipping away at the slower parts. See e.g. [my other comment](https://www.reddit.com/r/rust/comments/86a716/rust_is_now_top15_in_techempower_db_query/dw7zckf/) in this thread.
Yeah, it's just longer which is a bit annoying when you have a few of them in a method call.
Absolutely! I need to get back to this issue...
That is also perfectly possible. I merely thought that maybe we have a misunderstanding, given the fact that english is not my mothertongue :)
To complement your post, the context of this discussion is also important, we're talking about someone using clone in their first "100 days with Rust", absolute performance is a non-goal when you're learning something. Even if we take out the context of this post, you should still benchmark before saying something like "losing performance", will losing 100 nanoseconds impact the 10 users of your Rust backend? And what the version that does not lose 100 nanos looks like? Is it worth writing 100LOC to get 10 nanoseconds? What about 500LOC to get 25 nanos back? You have to benchmark and analyze if it's worth it for **your use-case**.
You're right (of course). The only little annoying thing I face then is that I have to clone the `instance`, otherwise ownership is gone and it doesn't live long enough. So it becomes: ` let instance: Arc&lt;Instance&gt; = { let extensions = vulkano_win::required_extensions(); Instance::new(None, &amp;extensions, None).expect("failed to create Vulkan instance") }; let x= instance.clone(); let physical: PhysicalDevice = { vulkano::instance::PhysicalDevice::enumerate(&amp;x) .next().expect("no device available") }; ` But that is a minor thing, I just dislike
And you do it with https://docs.rs/vulkano/0.9.0/vulkano/device/struct.Device.html#method.physical_device I assume? :) Thanks, works perfectly fine!
TIL: There is a collapse all button :( Since I always jump to the Methods section, I had missed it. Maybe it would be worth having the button repeated at the entry of each section?
My point was that the beginner asking would not be a problem. They could be prompted to read the *full* entry of the method. It was however pointed out to that there is a nifty `[-]` button at the top of the page, which I had missed because I always jump straight to the Methods section, and that clicking on this button makes the Methods section very close to the index I proposed in conciseness (though not sorted).
Problem with serialization is that plenty of unix style tools expect to have their cfg files always user writable, come hell or highwater. Any form of metadata that is even slightly inconvenient to that would get the 'cfg' crate dropped with prejudice. That's why i suggested a shebang to support the 'FromXXXX' functions. (unless what you mean by 'platform-independent' serialization is still user-readable but with some rules like 'only use / and : as separators and only use quotes for spaces' in which case i'm all for it.
Agree. Rust seems much more ruby-ish than python-ish IMO. Even the lambda syntax is inspired by ruby.
With Python 3.6(?) there's cosmetic type annotations, so they're slowly working their way to more static/gradual typing. I'm okay with this. I really need to play with Julia more though.
I wrote this because people sometimes tell me that they're interested in giving a talk but they don't have any ideas! So here are a few ideas :) what talks would *you* like someone to give at RustConf? what do you want to learn about?
Hey I am coming from python background, and interested in both Clojure and rust. Would u recommend learning Clojure first or rust ? 
Sure, I will update code. But I am not sure you’ll be able to see difference at 200k req/sec 
Linked lists in Rust. I know there are some good written articles/posts about this, but a talk about this could serve as a platform to touch on many important concepts.
Oh, i think i get it now. You want to negate the need for a shebang by making every PathBuf need to be passed to a 'FromLinux' function that would transform it to a linux compatible path (if not absolute) and force the users to write a relative linux style in the cfg for paths always. That's... not the worst idea because linux is by far the OS with the least forbidden characters in the filename. Mmm.
I think getting higher up in these benchmarks will require throwing everything at them. Even 1% wins add up eventually.
Sorry i didn't see your responses before deleting my comment. I was thinking of what you meant and writing the other comment.
I find people massively underutilize `yield` in Python, which I have long considered by far the cleanest way to handle these problems. Python allows you to define scoped generators inline with total ease. What would be let values = &lt;some complicated iterator combination&gt;; for value in values { ... } in Rust is just def values(): &lt;straightforward iterative code&gt; for value in values: ... in Python. I wouldn't be surprised if I use something like this more frequently than I use the shorthand comprehensions. 
pycharm will warn you if it finds out you're breaking the type declarations which is nice but once you hit run you're on your own and its just that: a warning. not an error
To be honest, I've seen so many Rust talks for beginners (explaining ownership and borrowing again and again) that I'd be really glad for some other talks: - either evolution/criticisms of the language, - or what is being built with it, and why Rust is a good fit.
[The ultimate in garbage collection.](https://groups.google.com/forum/message/raw?msg=comp.lang.ada/E9bNCvDQ12k/1tezW24ZxdAJ)
`IntoCFG("windows\exotic\path;another")` from windows turns into in the cfg file `windows/exotic/path:another` `FromCFG("windows/exotic/path:another")` in windows turns into: `windows\exotic\path;another` and `IntoCFG("c:\lol/linux/path:another")` turns into `c:\lol/linux/path:another` and `FromCFG("c:\lol/linux/path:another")` turns into `c??lol\linux\path;another`
Sure :) I am on board 
**Windows Subsystem for Linux** Windows Subsystem for Linux (WSL) is a compatibility layer for running Linux binary executables (in ELF format) natively on Windows 10. WSL provides a Linux-compatible kernel interface developed by Microsoft (containing no Linux kernel code), which can then run a GNU userland on top of it, such as that of Ubuntu, openSUSE, SUSE Linux Enterprise Server, Debian and Kali Linux. Such a userland might contain a Bash shell and command language, with native Linux command-line tools (sed, awk, etc.) and programming language interpreters (Ruby, Python, etc.). When introduced with the Anniversary Update, only an Ubuntu image was available. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I would personally love to watch any of these. (And these would make great blog posts as well!)
And in Python, which is not an expression based language, that really is a dedicated ternary operator, just with a somewhat more verbose syntax.
**UTF-8** UTF-8 is a variable width character encoding capable of encoding all 1,112,064 valid code points in Unicode using one to four 8-bit bytes. The encoding is defined by the Unicode standard, and was originally designed by Ken Thompson and Rob Pike. The name is derived from Unicode (or Universal Coded Character Set) Transformation Format – 8-bit. It was designed for backward compatibility with ASCII. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I'm trying to get this the unstable feature --error-format short referenced [here](https://github.com/rust-lang/rust/pull/44636) working, but I can't find a way to make it function with cargo. How is this supposed to work? 
[Currently](https://github.com/rust-lang/rust/blob/master/src/libtest/lib.rs#L763) it is calculated as the difference from the max and min. [See this issue here](https://github.com/rust-lang/rust/issues/44358).
Arguably the python one is more of a ternary operator than the rust one because the python one is a competely separate syntax whereas the rust one is literally just an if-statement. 
Hi. I think it depends on what you are looking for, but in general I would learn language that has less similarities with you current language. It would give more impact and let you look a things from different angle. Clojure and Rust are both good candidates. Clojure is dynamically typed like python but it's functional language and it's a lisp. It teaches you some very interesting concepts and changes they way you're thinking about programming. It also changes the process, you have repl driven development and experimenting with Clojure is fast and fun. Clojure as any other lisp is very small and you can learn it in one week. It has great support in all major editors and ide (emacs, vim, intellij). Ecosystem is quite mature, you can easily make a project from template, find any linraries you might need and start hacking. Programs in Clojure are very short. And less code means less bugs. Last time I was interviewing to one company, I had about 3 files of no more than 300 LOC total and they asked me "hmm that's it?" while my solution even had clustering architecture implemented. Clojure can be compiled to js, JVM, .Net platforms which allows you to make full-stack solutions in a single language with even sharing bits of code between platforms. At my job we make full stack web applications and it's an awesome process. Rust is imperative language like python but it's statically typed and has a unique way of dealing with memory. Rust is safe and won't let you make most of the mistakess a newbie might make. It removes whole classes of bugs from your code due to borrow checker and static typing. The process is gonna be slow, you will learn a lot, you will have many problems with compiling your core. But once mastered I think you can be very productive with rust. Rust is native language which opens such targets as Arduino and bare metal. There is also web assembly support and you can try making a frontend in Rust. I think Clojure and Python cover much more common ground than Rust and Python. Rust is a language for system and embedded programming. Learning Rust introduces another tool in your toolkit while learning Clojure will mostly replace Python and give something more. If you'd like to have some pure fun and you'd like process to be quick do pick up Clojure and play with it for a couple of weeks, or even better make some project in it. If you want to expand your arsenal do the same with Rust. It's gonna be more terse but still very fun.
you're in the sub for the Rust programming language :) you probably want [this sub](https://www.reddit.com/r/playrust/)
Rust definitely suited for console apps. You can check out [clap](https://github.com/kbknapp/clap-rs), which is a great library for console arguments, and really just start coding! Or, you could go to /r/playrust and ask about the rust *video game*, which is not what this subreddit is about.
This is the subreddit for the rust programming language. You probably want /r/playrust instead.
I thought Cargo.lock pinned all dependencies direct or not, is this wrong?
&gt; To be honest, I've seen so many Rust talks for beginners (explaining ownership and borrowing again and again) Please note that talk selection must factor in that many people will be new. That's sometimes a bit tough for more experienced people and for recurring visitors, there may be reruns. 
You're saying that the python one is closer to being a ternary operator because it can *only* be used as an expression, whereas the rust version works either as an expression or as a statement?
I'm refering the `impl` Trait feature, which [just got stabilized](https://www.reddit.com/r/rust/comments/86f3h6/impl_trait_stabilization_was_just_rd/). It allows writing the trait the type returned from a function (or passed to a function) implements and letting the compiler fill in the concrete type. Aside from the ergonomic advantage, and the newfound ability to base types on closures inside the function, this feature also means shorter and simplified error messages! Consider this example: #![feature(conservative_impl_trait)] pub fn first_10_explicit_type&lt;I: Iterator&gt;(iterator: I) -&gt; std::iter::Take&lt;I&gt; { iterator.take(10) } pub fn first_10_impl_trait&lt;I: Iterator&gt;(iterator: I) -&gt; impl Iterator&lt;Item = I::Item&gt; { iterator.take(10) } fn main() { let iter = (0..10).map(|i| i + 1).filter(|i| i % 2 == 0).map(|i| i * 100); first_10_explicit_type(iter).bla(); first_10_impl_trait(iter).bla(); } https://play.rust-lang.org/?gist=3b391d37c4800ecc1a768522040107e9&amp;version=nightly When you build it, both lines that call `bla()` fail - because there is no such method on the return type. But look at the error messages: On the first one (that uses the explicit type), the message is: error[E0599]: no method named `bla` found for type `std::iter::Take&lt;std::iter::Map&lt;std::iter::Filter&lt;std::iter::Map&lt;std::ops::Range&lt;{integer}&gt;, [closure@src/main.rs:12:28: 12:37]&gt;, [closure@src/main.rs:12:46: 12:60]&gt;, [closure@src/main.rs:12:66: 12:77]&gt;&gt;` in the current scope The type in question is printed in it's full glory - 202 characters long! And compared to what /u/eminence and /u/kurashu89 showed, it's a rather simple type... On the second one, it's: error[E0599]: no method named `bla` found for type `impl std::iter::Iterator` in the current scope The length of the type name is just 24 characters. And it shows you the relevant information - the trait you are coding against - without the need to figure out which traits the full type is implementing.
Would that have helped in my instance though? Mine wasn't a return for error, but rather something along these lines: fn recur(x: &amp;mut T): if exit_cond: return recur(&amp;mut x) //whoops Except not as obvious as I was recursing into a parent call.
Thanks! I have to say that that is quite unintuitive, though I'm not sure how to improve things and maintain the pretty output format. Changing it to standard deviation would be a bit weird given the +/- label.
I know you like giving that link on like, all game subreddits and all, but... Can you at least look before you post? You meant to post this at /r/playrust, not here.
Oh I am so sorry. I misslooked.
Yeah - I have to agree. I’ve experimented with Tokio a few times (with an eye to generating Thrift stubs) but never proceeded far. It feels incredibly...sharp...to use, and this coming from someone who’s written async code in C, C++, Java (bare NIO and Netty), Scala and Python.
All great suggestions that I would also like to see. 
And an unusual order of subexpressions: trueValue if condition else falseValue
I sympathize with the user, but I’ll give a piece of advice I hope is useful to people interested in learning a language (or any domain, really): try to tackle only one axis of “unknowns” at a time. For example: trying to write a library for a super-hard concept? You should probably use a language you already know and are very comfortable with, so that you can focus on the concept you’re trying to explore and express. Trying to learn a new language? Maybe focus on a very simple problem domain that you’ve explored before in a few languages. Oh, and, if you’re exploring a new language: *use the golden path*, i.e. straightforward, well-supported libraries for which there are a ton of SO answers and it seems like everyone in the community uses.
...yea, I don't see how it can help in this case...
That's what the question mark operator does. It requires that the function returns an `Option` or `Result`, though.
`unwrap_or(return)` doesn't work like you think it does. `rustc` should be giving you a messaging saying there's unreachable code.
gasp. You're right. Can I do something like `unwrap_or_else(|| return)` ?? rustc is saying no, but I thought `return` and `loop {}` are like `-&gt; !` and can be accepted in places like this, even if the types don't align?
I'd also like to see more advanced talks. I realize Rust is still at the point where it needs to be attracting new developers, but one thing that made C++ such a great language to learn was how deep I could go into it. Watching talks by Scott Meyers and Herb Sutter was the most rewarding part of learning C++. Perhaps this is not the type of talk for RustConf though. To me what I would always want RustConf to be is a sort of 'this year in rust', as told by members of the rust community. It would be nice to have a talk that was more focused on advanced concepts too.
Yes, i will make two Native GUI for each platforms. X11 gui application is not hard to implement. and it won't take long (except for very large application). i am asking back to you, do you feel comfortable when gtk application on windows platform? (me, NEVER).
No, it's not. That `return` *always happens*.
Ok, that seems to work, I guess I was missing the `--` bit in the middle 
One such macro that is fairly close to what you want would be [try_opt!](https://github.com/crumblingstatue/try_opt/blob/master/src/lib.rs#L30-L37) just without the `None` part
Next stream happening next Saturday! https://twitter.com/Jonhoo/status/977662091724296192 We'll take a step out of the weeds we got into last time and integrate the new async_ssh crate with the tsunami crate from the first two videos. That should give a good overview of how to *use* futures (instead implementing them yourself as we did in this stream).
It took me a long time to understand what on earth was happening with `yield` and generators more generally. The turning point for me to understand `yield` was this snippet: def f(): yield 'a' yield 'b' For some reason this just clicked for me. I also use generator expressions all over the place, even if it decreases readability for less experienced programmers. It just feels so wasteful to create a full list rather than processing items as they are encountered.
There's an `unwrap_or` macro used in some places in the Rust compiler, FWIW.
I'm a huge fan of the subexpression ordering for Python's ternary operator. To me it's so much more readable. Combined with Python's English logical operators, you can write practically valid sentences: x = value if value is not None else 'n/a' In English I'd say "`x` gets `value` if it's not `None`, otherwise `x` gets `'n/a'`" which is pretty much how the code reads. Yeah, it breaks from tradition, but I think it's worth it once you get used to it, at least in a language where readability is a top priority.
I've been looking to maybe relocate to the Portland area so I wouldn't mind flying up there to see how it is in late summer. But would anyone care about a talk on macro expansion in the frontend?
Yeah, yield really is an awesome feature in Python. It also lets you do cool tricks even outside of generator logic, like contextlib's `contextmanager` decorator: @contextmanager def mul2(num): print("enter") yield num * 2 print("exit") with mul2(5) as x: print(x) ... which would print "enter", then 10, then "exit". You can do all sorts of metaprogramming with yield, and it's just the perfect way to do lazy implementations of things. On that note, generator comprehensions are amazing as well.
IMO, this may sound abrasive but I'd rather expose less experienced programmers to generator expressions and that sort of thing rather than coddle coworkers and expect everyone not to use the more advanced and expressive tools in python. It's worth the 5 to 30 minute conversation teaching them when they ask, which allows them to do better work and grow as a result. If you're a beginner, it's a much better deal to be exposed to stuff like this on the job so you're better prepared in the next one. Where I work now, there was a python talk about context managers and my coworker learned a lot from it, but honestly I think that's the worse way to learn. If it were me, I'd rather run into it in the code base I work on. There's context, as in you know the problem trying to be solved and it's a real world problem, and you see the elegant solution right there. Instead of trying to find a way to force something you learned into a problem you're facing, you see where it naturally comes up and you have a better idea why people use it in the real world.
&gt;1. map/flat_map/filter/fold style idioms should not be described as the same as list comprehensions, which are non-compositional in nature (which is a drawback). Why are they not compositional? 
If you were looking to improve it, then all of these things would be a great start. Since it's a fairly simple tool, there's no reason why you couldn't make it work for different platforms besides just Linux, maybe by either looking into crates that give you these kind of directories, or by using [conditional compilation](https://doc.rust-lang.org/book/first-edition/conditional-compilation.html). How about not hardcoding the search query and resolution size, and let the user provide their own arguments? You could look into using [structopt](https://github.com/TeXitoi/structopt) for instance (it's super easy and amazing!)
Like the idea. See a few potential problems with the details of their proposal. I also think it's kind of a band-aid. Something substantial needs to be done with crates.io: it's starting to look more and more like the mess that is all of these flat minimally-curated package repositories. They're honestly often more of a hindrance than a help in my opinion: I can get that kind of thing from Github. I really want packages to be substantially organized, evaluated and reviewed: I'd be willing to help with that effort if there was a system in place. Today I went looking for a fixed-point package. There are three different ones in crates.io that were linked from a page I found from a Google search. Typing the keyword "fixed-point" into the crates.io search box shows only one of them and returns two obvious false positives. Flat namespaces, even with keywords, just don't scale. crates.io needs to scale.
Some attention to embedded programming would be nice too.
If you introduce an errortype and rewrite all the methods to return a result, then you can use a [question mark](https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html) to unwrap or "propagate the error". enum MyError { SomethingHappened }; fn parse_backslash(&amp;mut self) -&gt; Result&lt;(), MyError&gt; { // self.current_token() must return a Result&lt;(), MyError&gt; // the question-mark unwraps the token or propagates the error let tok = self.current_token()?; // Do stuff and return return Ok(()) in the end Ok(()) } 
thanks for explaining. I probably won't end up doing this, but I'm glad you explained it because now I understand how this all works.
I'm saying that the rust one is just a normal if-statement rather than a separate construct that was added to the language. 
You are welcome. Alternatively I woul recommend the [try_opt](https://github.com/crumblingstatue/try_opt)-macro that was mentioned by /u/izikblu. It works very similarly. IIRC there are plans to have the questionmark on options as well, but I cannot find the link. 
Hey all, trying to install rust-doc via apt, however it's dependency fonts-open-sans its not installable, what are my options?
&gt; See a few potential problems with the details of their proposal. Such as? &gt;I also think it's kind of a band-aid. I mean I agree it isn't ideal, but what is a better alternative? You seem to have put some thought into this problem, and I'd love to hear about your thoughts.
I imagine syntactically its an issue. You can compose 5-10 map/filter/flatmap type operations pretty cleanly. If you do that with comprehensions, it will get ugly real fast.
Hi, given this: struct Bar(Foo); is it possible to coerce a `Box&lt;Foo&gt;` into a `Box&lt;Bar&gt;` and vice-versa? I assume `transmute` is an option, but is there a safe way? (Context, in case I'm going at it the wrong way: I have a `struct Grid([Cell])` and I'd like to construct it using a local `Vec`.)
Details of PEP 541 that seem a bit troublesome to me: * Allowing someone to reclaim the name of an old abandoned crate for a new crate. In a flat crate ecosystem, this seems like it will cause old webpages to confuse users. Just yesterday I tried to install the Mongoose web server with npm and got a completely different thing also named "Mongoose" and then spent some time figuring out I'd been fooled. It would have been worse if the instructions I'd been reading had told me to install the Mongoose webserver via npm and then the package with that name had been replaced. * A project is apparently invalid if it violates patents. If taken literally, this would invalidate pretty much the whole repo, given the current state of software patents. * In general, the idea that a bad actor can get a project removed from the repo by merely initiating an "active" lawsuit seems at least a little prone to abuse by proprietary bad actors wanting to reduce the ease of open source competition for their wares. As for alternatives to the flat-repo Wild West that is the current state of package managers, I don't have any single solution to the problem, but I think there are things that can help: * The current state of reports and analysis of these packages could be improved. The Wine database is a good example of a situation where each application is assigned a status based on testing and evaluation, and user reports of successful and unsuccessful use are collected and grouped with the package. * One of the things that makes Python special is that a huge range of functionality is blessed and included with the distribution. The Rust community is conflicted: on the one hand, they want to keep all "non-essentials" out of std, but on the other hand, the next category down is being just a random crate in crates.io . The Haskell "Batteries Included" approach has been mostly a failure here as far as I can tell: for whatever reason it has not become a standard of use for the community. I think the new Rust working groups need another level of packages: not in std but shipped with the distribution. There's already a couple of things like this, alloc being the example that springs to mind. More would be better: mio is a good example to my mind. As the Linux folks have found, moving things into the official distribution gives huge incentive for third parties to pick up support, documentation and maintenance in perpetuity. * There probably needs to be active humans — paid or volunteer — in the repo loop. The idea of just automatically uploading whatever and suddenly it's in the repo has been surprisingly successful, but it has also had some bad fails (remember the bogus npm packages a while back?) and I expect it to get worse for Rust as the ecosystem grows. There's a lot of wisdom floating around in the various Rust application domains that deserves to be made accessible and maintained. Over the last year or more as I've learned Rust I've found myself being more and more conservative in searching for and depending on external crates. I've learned about a half-dozen that everyone needs and are going to be there forver: lazy-static, random, serde and its various ancillaries, etc. Other than that, I think really hard about whether I am going to use other people's stuff. That's too bad, and I think it's partly a consequence of the state of crates.io.
It does. I don't know why I added that.
I think they've got the basics right: - don't mess with live projects ever - only act of somebody makes a formal request - let the requester proof more than just intent - author/maintainer in the widest sense (not just official listed email address) - decent grace period before declaring project abandoned But a similar provision against name squatting would also be reasonable with the added provision that a possible squatter is now required to provide prove of more than just intent on using the name. Something like a link to a repository that shows continued activity and a list of concrete plans when they expect to make formal releases. As long as there "squatter" can make any reasonable claim, they're in the right (no discussion about the better fitness of the requester and the defender). There other possible improvement would be to separate name claims from discoverability: A request for "delisting" can be made. Possible reasons being: empty project, project is not (anymore) releasing through crates.io, abandoned project unresponsive to submitted security bug fixes or general crates.io policy violations. A project should also be possible to be delisted on there indication of the maintainer. Listings should normally be restored when a new release is done. Projects that are active and actively release through crates.io should never be delisted. Delisting is not a reason for transfer of ownership of a name, just a means of improving discoverability of sensible crates.
!
I think list comprehensions are bad for readability; I've been bitten many times by misunderstanding what parts are flattening, mapping etc. in even the most simplest of cases. So they might be convenient for writing, but respectfully, I don't think they help in understanding.
Yes, exactly! It is also not as clear, even in simple examples, which parts are mapping, flattening, etc.
Purely because the breath of tools to support IIS/C# we kept that side as is. It doesn't currently make economic sense to migrate that. The servers that did all the work are the ones being migrated
Unless it actually is an error it should be Option not Result
You seem to imply the Google method is undesirable but why is that? Why attempt to reinvent search just for crates.io?
Sure, I understand that. However there's only so many times I can watch a talk about ownership/borrowing without my eyes glazing over ;) I do think that 1/2 talk each in the medium and deep end of the pool would help diversifying though. And as noted, talking about what is being built in Rust is rather language agnostic, yet at the same time helps show-casing in which domains Rust can be used successfully.
Yeah I just assumed it was 1 standard deviation. The fact that it's max/min does explain why the range is wider than i would have expected
Interesting, thanks. This is the first time I have seen anyone defend epoll when compared to IOCP. &gt; IMO, the non-blocking I/O model is much superior to IOCP's completion model for the simple fact that it does not conflate wanting to do an operation w/ actually performing it. From my understanding, they are both non-blocking. The difference is that epoll signals when it is ready to perform the next operation, while IOCP signals when the requested operation has been completed. Where am I going wrong with that? From what I have read, many of the difficulties arise because it is hard to express completion-readiness (IOCP) in terms of operation-readiness (epoll), while it is easier the other way around. With most people starting their abstraction efforts from epoll, they experience these issues and just say "IOCP is bad!". I'd love to get your take on this.
I've built a TCP proxy that handles a bunch of sockets using mio, thinking I could easily add TLS later. Now I can't seem to find a TLS crate that looks like it'll play nicely with mio, and I'd like to avoid moving to tokio just so that I can use tokio-tls. Can anyone point me in the right direction, or is tokio the way to go?
Even with the collapse button, there is soooo much additional stuff in the listings that make it hard to search for things. For instance: - where clauses – they should be moved to the right of the signatures and have overflow hidden, instead of ending up on their own line. - nightly warnings – come on, grey out the signatures, or add a "lab icon" to the left. The warning takes up more vertical space than the signature itself! - deprecation warnings – please, just use a strike-through or an icon.
I think there was a talk about this. Probably by Alexis. Google gave me https://air.mozilla.org/toronto-rust-meetup-october-2014/ but I think there was another one.
I honestly don't see a real reason why packages need to be identified by name at all. Is it really so much work to copy say 16 or 32 hexacedimal characters around into a Cargo.toml to serve as an id with a crate itself defining a default name it wants to be called by which can of course be renamed if it conflicts? I really do not like this first come-first serve thing because the first person to claim the obvious name has an unfair advantage in competition. `johns-openssl` is going to have a hard time competing with just the `openssl` crate.
Even with the collapse button, there is soooo much additional stuff going on in the listings that make it hard to find things. For instance: - where clauses – they should be moved to the right of the signatures and have overflow hidden, instead of ending up on their own line. - nightly warnings – come on, grey out the signatures, or add a "lab icon" to the left. The warning takes up more vertical space than the signature itself! - deprecation warnings – please, just use a strike-through or an icon. - methods that take `self` should be clearly separated from methods that don't, currently this often happens by accident, because methods are listed in the order in which they are written in the source file. - the signatures really need to be aligned properly, so that names, types, parameters and return types line up properly. The way documentation is presented is in my opinion the worst part of Rust currently. There is no API documentation where I felt more lost than Rust's. The left pane is especially egregious. I have no idea what the various thing are or what they do when I click on them. For instance the "Crate Foo" header makes it look like as if it's possible to navigate between different crates, but it doesn't. The whole column is barely useful at all. It's interesting to see how much navigation docs.rs adds at the top, which should be the default, not some (third-party?) extension. /u/steveklabnik1, do you know of any efforts to overhaul the documentation presentation in that regard?
Sorta yes, but also sorta no. We'll see.
In previous years we've had a single track so we've tried to optimize for talks that target nearly the entire community. This year this is changing around, so you should expect some advanced talks (as well as some area-specific talks and beginner talks and other things that only target a subset of the community)
Regarding method ordering, I'd prefer if methods were sorted by: 1. Static first (those not taking `self`, `&amp;self` or `&amp;mut self`) 2. Number of arguments (pushing more complex methods toward the bottom), 3. Spelling. It may not be "optimal", for whatever criteria of optimal one goes for, but I think it would be a good first step.
Agree on 1., not sure about 2. though. But even just having 1. would be a vast improvement.
I'd be happy to submit targeted pull requests for the things that have consensus. If you are interested, what would be the best way forward?
TIL that `T: 'static` only applies the static lifetime requirement to the references inside T. Thanks for saying this!
No -- this would mean that core would be dependent on networking APIs existing. This fills a similar function as liballoc -- when you want a part of std without pulling in all of it.
just started 2 days ago. And it was a though start to say the least. But after a couple hours I began to see how it works.
&gt; Zero Also known as the 'Britain 78' GC.
Although there are exceptions, it is actually quite similar to Rust's exception handling mechanism. So only functions marked with `throws` are allowed to throw an exception and functions that throw exceptions need to be invoked like this: `try foo()` or `try obj.foo()`. This means that the exceptional control flow is obvious from reading the source code just as in Rust. There is also `try! foo()` that's basically like `.unwrap()` in Rust and as soon as there is an option-type in Dora there will also be an `try? foo()` statement. There could also be an expression like `try parseInt(someString) else 0` just as in Swift. The advantage of exceptions is that they keep exception handling completely out of the normal control flow and out of the L1-cache. Functions signatures are simpler too. IMHO exception handling in Dora is one of the things I like best about the language. For a low-level language like Rust exceptions would be quite problematic. For the JIT-compiled and GCed Dora not so much and I honestly think that Dora's approach is a good compromise between exception handling and return codes. That said, my initial motivation for adding exception handling was more about the challenge of implementing it, e.g. finding the right exception handler from the current stack trace, etc.
Do what by file?
It's too early; I appreciate it, but you'll have to wait for an announcement, possibly this week, maybe next week. There'll be lots of opportunity soon :)
Cool, thanks for the heads up!
Turn off warnings?
Perhaps this is a silly question, but why is this? It’s not immediately apparent to me what the lexer sees that would cause that to always return; I’d expect a syntax error, if anything.
The fact that I can manually edit my Cargo.toml is great; cargo is so ergonomic. While the first-come-first-served this isn’t fantastic, I think replacing package names with random hex is not the solution
I don't know, that seems like a really minor inconvenience to have to copy that unique identifier just once from a place you looked it up at. I mean one might argue that copying it in many cases is faster and certainly less error-prone than typing it over for the long ones.
It's not a "real" type - `()` is generally the ["unit" type](https://doc.rust-lang.org/std/primitive.unit.html) that represents the lack of value. In this context though, it's used to refer to an unknown type - some internal representation of your struct and its vtable as generated by the compiler.
You’re missing the point - you shouldn’t just be shoving a crate in your toml once and forgetting about it. What if I want to remove a dependency I no longer need? Do I then need to go into crates.io and manually search the crate for its magic number and then look through all of them in the toml to get the right one? Over just opening the file and removing the line?
Well, return is an expression (of type `!`) and function arguments are evaluated eagerly. So when we evaluate `.unwrap_or(return)`, we first evaluate its arument, then call the function. But evaluating `return` causes the enclosing function to return :)
Fair enough. I hope you get it figured out!
I don't believe it's a special case in the compiler - it's usually better to use `c_void` in this case though, or a pointer to an empty enum. 
Pointers to empty enums sound dangerous. Isn't the compiler free to assume that instances of an empty enum type don't exist?
That's exactly the point - there's no safe way to create one, so you can guarantee there's no mixup. In fact, this approach is explicitly recommended in the Nomicon. 
I don't see how non flat namespaces are any better What do you do if ownership of a package is transferred? How do you distinguish between Some.guy.fixed-point and Random.Company.fixed-point I do think statistics about use of crates and sort by popular might help
It would be great to have some mechanism to get name of not supported any more crates. For sake of security it should be not simple process, but I suppose it should be to not get names like crate2, crate3, crate-ng and so on.
I'd say it depends. If you need high levels of "polish" then yes, I'd agree. But it is a more expensive route as you are basically supporting 2 applications. It makes sense for commercial applications. If you are creating a utility / tool -- I'd prefer writing it once. You just need this thing to work and there isn't much upside to having 2 super polished versions.
I also wrote a recursive descent parser few days ago and used the .and() combinator to reduce some boilerplate (only to find, that .and() evaluates the argument even if option is None, so it's completely useless for a parser).
What I find nice about (2) is that often time method complexity increases with the number of arguments. For example, taking `Vec`, `is_empty`, `len`, `capacity`, `iter`, ... are quite simple. Another way to simply would be considering the receiver (`self` vs `&amp;self` vs `&amp;mut self`) however this separates `iter()` from `iter_mut()` even though conceptually they are very similar. I know that splitting on number of arguments is not perfect; it separates related operations such as `unwrap` and `unwrap_or` for example. Yet, at the same time, I find that for indexing it's pretty neat since you generally have an idea of the number of arguments you would want to pass.
I'd use petgraph. It has the best API, and a graph can be used to emulate a tree and/or forests.
How do we make the left pane less confusing? It makes no sense to me, I feel like there is something I am supposed to know and don't. It seems like a lot could be achieved having people read the docs, record their frustrations, then live edit the html in Chrome and-or literally screenshot and paste something that looks like the desired outcome. Actually fixing the documentation generator to work on prototypes would slow down iteration during the discovery phase. Can the docs be dumped as XML or JSON so they could be loaded into Python or Ruby? 
A hesitation I'm hearing on Rust adoption from peers is that the cargo site still isn't as good as the npm site in conveying quick examples of how to use a crate, what it does, and important notes. Basically stuff that allows you to tinker and sort out what crate fits the bill within an hour or so of browsing. I've had the same frustrations. The autodocs are great, but they're better for after that decision. I dont want to spend a long time breaking down the detailed manual only to find it wasn't really what I was looking for. Are things in the works for polish or increase consumability of the cargo site? If not, then it should be compared against the npm site and discussed. Without a doubt, when I ask people why they adopted node, the npm site was very high, if not highest on the list. i.o.w. ease of finding and sussing out packages. Other pros of node/npm often took a back seat to that, though they were definitely still part of the decision. 
Thank you.
It is important to acknowledge someone's frustration, the number of people who who will make a 100 day slog with a new language and then also writeup a post mortem is small, this post is a gift. &gt; solve problems in another language If this is true, we should probably have better Rust-for-X guides. 
Honestly if I read this the "Python idioms" are basically common to _a lot_ of languages and Python certainly didn't invent them or even popularize them. These are just things that are found in so many languages; nothing about it is particularly linked to Python.
I've used [rust_radix_trie](https://github.com/michaelsproul/rust_radix_trie) for some projects (n-gram frequency and boundary entropy) and have found it very nice. 
With the new [extern types](http://rust-lang.github.io/rfcs/1861-extern-types.html), it'll be better to use those. In this case, it'd look like: extern { type Data; type Vtable; } struct TraitObject { data: *mut Data, vtable: *mut Vtable, } Unfortunately, that'd be a breaking change, so it will have to stay units.
Not quite sure what you're asking? crates.io already has search. It doesn't work very well, because of the way the repo is structured. Are you suggesting we just get rid of it altogether? One *could* just abdicate the whole darn thing to Github. Ditch crates.io and just make reference to an online Git repo the standard. There are upsides to this approach, but also some pretty big downsides, I think.
What a *darn* shame.. *** ^^Darn ^^Counter: ^^494456 ^^| ^^DM ^^me ^^with: ^^'*blacklist-me*' ^^to ^^be ^^*ignored*
[removed]
You could sort things by number of args, but could group methods with a common prefix...
I'd remove the left panel altogether. Everything in there seems to only exist because the main panel is so cluttered with methods expanded.
*Ownername.packagename* is one model for a hierarchical namespace. It has been used semi-successfully by Java for packaging in spite of a really dumb implementation (why yes, I really needed all my packages with domain names ending in "com" in a different directory hierarchy than the ones ending in "net" for some reason). It does have the problems you mentioned. One can imagine other useful namespaces. Haskell tried grouping by semantic category, but as a soft scheme and with limited success. Of my 12 packages on Hackage, most are either namespaced as Data.\* or Text.\*. As with crates.io, applications are sort of second-class citizens compared to libraries in Hackage. Should they be there at all? Name forwarding is something that needs to happen regardless of naming scheme. Projects get renamed: need a way to deal with that.
There are enough trade-offs in this space that I believe that any library will have to either be opinionated enough that it might not quite fit your requirements and preferences, or try to be general enough that the API becomes less convenient. Consider growing your own trees? Lately I favor [the arena approach](https://exyr.org/2018/rust-arenas-vs-dropck/), though maybe you can get away with something simpler if you don’t need cycles (such as going from a node to its parent). &gt; mostly read-only (not many modifications required) Unfortunately "not many" doesn’t make much of a difference: data structures are either mutable or not.
&gt; The advantage of exceptions is that they keep exception handling completely out of the normal control flow That's exactly what I consider the main disadvantage of exceptions :P 
&gt; It matters if you don't want to pay the cost of coroutines. Hmm. Is there a practical example of futures being used this way somewhere? Seems to me like _someone_ has to call `Furure::poll(...)` in some fashion in the end anyway... I mean, I sort of get what you mean in that Futures as well as the whole stack being subdivided into many pieces offer a great deal of flexibility and allow people to compose the async runtime in custom ways, potentially reducing costs, at least theoretically. However at the same time that flexibility and modularity makes matters _much_ harder for an ordinary Joe user like me who falls in the &gt;=80% usecase bucket... 
Ownership in HashMaps The keys are moved into the HashMap but can't live outside the loop they're created. I've tried String::from(), .clone() etc. to no avail. Any ideas? The error message: error[E0597]: `line` does not live long enough --&gt; a.rs:56:48 | 56 | let (symbol, trade) = parse_trade(&amp;line); | ^^^^ borrowed value does not live long enough ... 68 | } | - `line` dropped here while still borrowed 69 | } | - borrowed value needs to live until here The code (compile with `rustc a.rs`): use std::env; use std::string::String; use std::fs::File; use std::io::prelude::*; use std::io::BufReader; use std::collections::HashMap; use std::{thread, time}; type Time1000 = i64; #[allow(dead_code)] struct Trade { time: Time1000, price: f64, amount: f64, } struct MarketData { trades: Vec&lt;Trade&gt;, symbol: String, } type MarketDataHash&lt;'a&gt; = HashMap&lt;&amp;'a str, MarketData&gt;; fn get_args() -&gt; Vec&lt;String&gt; { let mut args: Vec&lt;_&gt; = env::args().collect(); args.remove(0); args } fn parse_trade(line:&amp;str) -&gt; (&amp;str, Trade) { let cols = line.split(" "); let cols: Vec&lt;&amp;str&gt; = cols.collect(); let time = cols[0].parse::&lt;Time1000&gt;().unwrap(); let symbol:&amp;str = cols[2]; let price = cols[3].parse::&lt;f64&gt;().unwrap(); let amount = cols[4].parse::&lt;f64&gt;().unwrap(); let trade = Trade { time, price, amount }; (symbol, trade) } fn main() { let sleep_dur = time::Duration::from_millis(200); let args = get_args(); let file = File::open(args[0].clone()).unwrap(); let mut market_data: MarketDataHash = HashMap::with_capacity(100); let mut reader = BufReader::new(file); 'main: loop { let mut line = String::default(); let length = reader.read_line(&amp;mut line).unwrap(); line.pop(); // Remove newline if length &gt; 0 { let (symbol, trade) = parse_trade(&amp;line); if ! market_data.contains_key(&amp;symbol) { market_data.insert( &amp;symbol, MarketData { trades: vec![], symbol: String::from(symbol) }); } if let Some(mut market_data_symbol) = market_data.get_mut(symbol) { market_data_symbol.trades.push(trade); } } else { thread::sleep(sleep_dur); } } } 
It's a different thing. I need something like a DOM tree.
Imagine making a bot this useless and spammy...
*Beep boop*, I am a bot, *darn it*. *** ^^Darn ^^Counter: ^^494481 ^^| ^^DM ^^me ^^with: ^^'*blacklist-me*' ^^to ^^be ^^*ignored*
&gt; Consider growing your own trees? I already have one in the `svgdom` (rc-tree). It does a good job when you have to change the tree structure a lot, but panics are killing me. &gt;if you don’t need cycles In the `svgdom` I even have a `Rc` cycles, which I resolves manually. For me, the ideal solution is some kind of mini-GC. All nodes belong to Document/Root and as soon as it goes out of scope all nodes became invalid. Basically a mix of id-tree and rc-tree (with own Rc implementation). This will allow cycles and simple API, but will require a lot of unsafe and testing.
computer science in a nutshell
Now that I think about it a bit more +/- does actually seem like a reasonable label for standard deviation, but I'm not sure how useful it is if the data is non-normal. Perhaps it would make sense to have a verbose mode that did more statistical work. It could apply a t-test and tell us if the data is normal, report the standard deviation and a 95% confidence interval and also report the spread size.
What's your end goal here? This sounds like you're trying to do something really weird.
This is very very very well-trodden ground. One-sigma error bars are useful even if the distribution is not normal; you construct them from the corresponding percentiles instead. I'll post about this on the issue, but it seems like a good first contribution to me.
That kind of stuff is up to the authors of packages not the site itself. The site renders READMEs on the main page these days, but if a crate author doesn't fill out their README, that doesn't help.
That is a great idea (removing left panel) and having a floating/hideable ToC. 
that's what weakreferences are for! /YOLO GC Language programmer But seriously, weakreferences saved my life more than once. I appreciate rust and wish it will eat C++ and C but i still love GC languages for several reasons.
My goal, as I already mentioned, is to have fine-grained control of how fast I am putting packets onto the wire. The purpose isn't really relevant...
Doesn't seem that weird to me. The `rsync` command for example has a `--bwlimit` flag that lets one do precisely this. I use this sort of thing frequently to avoid saturating my Internet connection for my entire house.
One option is to use `String` keys and the entry api. [Playground](https://play.rust-lang.org/?gist=77d3b1de9c476c5d1546b5756bf144d0&amp;version=stable).
Neither [rustls](https://github.com/ctz/rustls) nor [native-tls](https://github.com/sfackler/rust-native-tls) have a dependency on tokio. Maybe one of them will work? Rustls has a dev dependency on mio which seems to indicate it can work with mio, though I've no idea how nice it would be.
It look like you are not accounting for any of the time it takes to send the packet. Basically, you need to sleep *less* than 1ms if you want to send 1000 packets per second.
You're right. I dug more into npm's stuff thinking there was a form/policy requiring good documentation. All the packages that came to mind just have a nice markdown file. As far as npmjs's documentation is concerned, there was no policy, but I did find this in doc for adding a new package: "Before you begin, please look at some of the package pages to get ideas for the information you can add to your readme file, and to see why this is so important." I don't see similar on crates.io/cargo docs. When I try and find something like that, I find links to the cargo docs with great how you can use cargo, but nothing like general good practices to follow/stressing the importance of a good readme.md. With that in mind, authors, please start to fill the readme's out some. The jenkins-api crate is more like what I wish were more common. When learning it really helps. 
The code is [here](https://github.com/xmr-rs/xmr/blob/bc6dd3b70b9ade5b63a7dbc5e53080a1dfb4c0dd/crypto/src/lib.rs#L29) (pretty unsafe btw).
Great, thank you!
There are multiple reasons for this behavior, and they accumulate. First, and foremost, your code does not run infinitely fast. That is, if you remove the `delay` altogether, and send 1000 packets as fast as you can, it will take say 100 ms. Now, if you add the sleep back, execution will take *at least* 1,100 ms: - 100 ms from sending packets, - 1000 * 1 ms from sleeping, - some extra overhead from the OS. From then on, it really depends how close to *exactly* 1ms you wish to get. 1. Use `sleep_until`, not `sleep_for`. 2. Wake up more often. #1. Use `sleep_until`, not `sleep_for` Instead of sleeping for *at least* 1ms in between packets, sleep until 1ms has elapsed since trying to send the last packet. In pseudo code: for _ in range(1000): last = now() send_packet() sleep_until(last + 1ms) This will mostly negate the time it takes to send a packet, thus getting you way closer to 1000 packets/s. This still suffers from the OS not being realtime, and therefore not waking up the program at exactly the time specified. #2. Wake up more often. There are various versions. A simple one is to wake up every 100 us (instead of 1 ms) and check whether it's really time to act or not. Another is to sleep for half the time until the target instant, until the target instant is close enough. Some versions even use spinning for the last few moments, if you're willing to burn CPU for precision.
Me too! That's some powerful knowledge :)
Alrighty, looked into it, tried it, changed it! Doesn't seem like there's any sort of performance impact either! Enjoy not having to use lazy static in 0.3.3! I think it looks quite nice, https://github.com/trezm/Thruster/blob/master/examples/hello_world/main.rs#L56-L67
There was an RFC for a very similar feature: https://github.com/rust-lang/rfcs/pull/1303
&gt; Hmm. Is there a practical example of futures being used this way somewhere? The vast majority of future usage is w/o coroutines right now. So, I'm not sure what you are asking. &gt; I mean, I sort of get what you mean in that Futures as well as the whole stack being subdivided into many pieces offer a great deal of flexibility and allow people to compose their async stack in custom ways, potentially reducing costs, at least theoretically. The stack is being built up. It takes time. The foundation has to be solid before building higher. If you want easy + are willing to pay the cost, honestly Rust might not be the right language. IMO Rust is #1 about not compromising performance and **then** figuring out how to make things easier.
Except that it's not a statement, it's an expression, just like the ternary operator. Semantics &gt; syntax.
Yeah. I've never actually designed anything with weakrefs, but that's probably a decent use case for them.
Neat!
For data this large, I'd suggest allocating it on the heap instead. Maybe reuse the allocation by passing a `&amp;mut` into the function.
You don't need a single `transmute` for those conversions, just `as` casts should work.
Thanks for tracking that down. I vaguely remember the discussion, but couldn't find it. Rust has grown a lot since 2016. It would be interesting to see if sentiment has changed as the name squatting/namespacing issue becomes more real.
Yes. 
[Removal of an abandoned project](https://www.python.org/dev/peps/pep-0541/#removal-of-an-abandoned-project): &gt; Projects are never removed from the Package Index solely on the basis of abandonment. Artifacts uploaded to the Package Index hold inherent historical value. &gt; &gt; An abandoned project can be transferred to a new owner for purposes of reusing the name when ALL of the following are met: &gt; &gt; the project has been determined abandoned by the rules described above; &gt; the candidate is able to demonstrate their own failed attempts to contact the existing owner; &gt; the candidate is able to demonstrate that the project suggested to reuse the name already exists and meets notability requirements; &gt; the candidate is able to demonstrate why a fork under a different name is not an acceptable workaround; &gt; download statistics on the Package Index for the existing package indicate project is not being used; and &gt; the maintainers of the Package Index don't have any additional reservations. I'm not so sure I agree with letting old package names be reused without some serious reworking of the package manager. I know this is /r/rust not /r/python but I would hope that this would incorporate changes into pip as well to: 1. Use lockfiles with static properties (CDN URLs, hashes, author names, etc.) 2. Have a hard error requiring manual interaction to notify the user that the package maintainer has changed I have serious concerns over some really obscure package in someone's dependency graph getting compromised this way and being a mechanism to push down malware.
People need names. Content addressing is fine for machines that work in bit patterns, but people use language. A package name also allows for a stable name across versions, which I can't imagine would exist in the case of content based naming. Re `openssl` vs `johns-openssl`, I agree. But using a hash digest doesn't really help in my opinion. As library choices are made on the basis of what other people are choosing, there will naturally be a power law to usage. That's a social phenomenon. Would opaque identifiers make it easier for John (who has built a better wrapper than the original but released his code later) to gain adoption? Unlikely, but possible I suppose. It would be an interesting experiment
Which crates are the most popular when it comes to handling time/calendar? Coming from C# I would like to find something like DateTime and TimeSpan classes in C#.
&gt; People need names. Content addressing is fine for machines that work in bit patterns, but people use language. A package name also allows for a stable name across versions, which I can't imagine would exist in the case of content based naming. Why not? You can just use: `4ff84aeg = "1.1.0"` like it does now. &gt; As library choices are made on the basis of what other people are choosing, there will naturally be a power law to usage. That's a social phenomenon. Would opaque identifiers make it easier for John (who has built a better wrapper than the original but released his code later) to gain adoption? Unlikely, but possible I suppose. It would be an interesting experiment Well it would certainly be easier for new projects to pick the best one rather than the one with the most obvious name.
That's exactly my point. In rust the ternary operator is absolutely identical in every way to its if-construct (you're right I shouldn't have said statement), whereas in python the ternary operator is a competely separate construct. So to me it doesn't really make sense to me to call it a ternary operator in rust because it's not a separate thing, but it does make sense to call the python version a ternary operator because it is a different thing. 
I had once similar problem and created a crate to deal with it: https://crates.io/crates/rpm-timer The version is still 0.0.x but it should already do the work.
&gt; Basically, you need to sleep less than 1ms if you want to send 1000 packets per second. I've just reduced my delay from milliseconds to microseconds and this seems to do exactly what I want. In my mind 1ms seemed like a very short time-frame already, when in fact i needed to drop down onto a microsecond level of accuracy. Thank you so much!
&gt; You must sleep for much shorter periods of time Exactly this, working with microseconds works, thanks!
&gt; Have a hard error requiring manual interaction to notify the user that the package maintainer has changed Would requiring them to bump major be sufficient?
Right now, the only way search for the functionality you're looking for in crates.io, as far as I can tell, is by some combination of crate name and *ad hoc* keywords. There is little guidance for crate authors on how to choose either. As a result, it can be hard to find things. Once a set of things is found, it can be hard to evaluate the things. ----- Suppose I want to make a UNIX pipe. So I go to crates.io and search for "pipe". The sixth hit, "os_pipe", looks promising. It's popular, at least as measured by relative all-time and recent downloads. Inspecting its documentation, it looks like it'll do what I want. The "os_pie" documentation also suggests that I might instead use the "duct" crate for a higher-level interface. I didn't see "duct" in my search: looking for it directly, I find that probably most of the "os_pipe" downloads were probably the indirect result of downloading "duct". I also see a crate named "duct_sh" which is apparently a split from the "duct" crate and has apparently rarely downloaded. I wonder if I would need both to use current "duct" with a shell? If so, why is it so little-downloaded? There's no author information anywhere in crates.io (neither in the search results or on the documentation page), but a look at the Github repos reveals these crates were all written by the same person. I am told in the "duct_sh" documentation that "duct" is a "multi-language library": sure enough, the "duct" documentation explains that this was taken from a Python equivalent with an "identical API". OK, I've probably rabbit-holed here. I really just want "os_pipe", and it will probably maybe work fine for me. It *looks* high-quality. Let me check for alternatives. There's a "pipefile" crate on the second page, but it's UNIX-specific (do I actually care?) and relatively few people have used it. After that, the results seem to trail off into eight more pages of irrelevancy. All in all, I'd consider this a modest success. After 15 minutes of search, I have a candidate crate that I should be able to use for my task. I'm not super-confident I've selected a good solution, but it seems promising. ----- Now let's look for a "fixed-point" math library like I was doing yesterday. A search for this keyword yields "fixed" and "staticfraction". Which one should I use? Neither crate has a documentation link in the search results, which is a bad sign (I think?). Clicking on "fixed" takes me to a page that does have a documentation link: the documentation looks great. Hitting back in my browser causes the documentation link to appear in the search results: OK, some kind of crates.io bug, apparently. Maybe "staticfraction" is the same? Nope, its page doesn't have a documentation link. Checking the repo reveals that it does have rustdoc, though. Apparently it's not set up to display properly. Based on what I've found so far, I'm leaning toward "fixed". It looks pretty fancy. Let's try some other keywords, though. "fixpoint" just yields a fix function crate. Searching "fixed" yields the "fix" crate in the first page of results, and nothing else interesting-looking. Let's try a quick Google search. The first hit on "rust fixed-point crate" is an October 2017 document describing the possibility of integrating fixed-point arithmetic into Rust. A comment there indicates that "there are at least three fixed-point crates on crates.io: fixed, fpa and fp". Hmm. Let's do a quick crates.io search for these specific names. Yep, the "fpa" and "fp" crates exist. "fpa" looks pretty promising, actually. The "fp" crate has the documentation bug reported above, but looks to be pretty much a work-in-progress at this stage. Given that "fp"'s description is "Fixed Point Arithmetic", maybe I should try that. A crates.io search on "fixed point" returns the three crates above on the first page, and nothing else promising-looking. So that hyphen was messing me up, maybe. I expect another hour or so of evaluation would tell me which of "fix" and "fpa" to use. But have I missed something important? Are either of them any good? I would consider this search a modest failure. I found a couple of crates with the functionality I was looking for, but it took quite a bit of struggle, and I'm still not confident about any of my conclusions. Search was not so great: that appears to be a combination of my poor searching skills, a bug, a not-great search algorithm, and the unstructured nature of the repo. The first three things are presumably fixable. The latter is harder. ----- Probably several people need to run 20 searches like this and document their experience. There's a lot of room for improvement, and measuring the user experience would be a good place to start. Anybody know where I can get a low-latency Rust messaging crate that works uniformly for inter-thread, inter-process and inter-machine communication? I don't want Tokio's complexity, but I want something more sophisticated than straight mio. How would I find such a thing, or convince myself that it doesn't yet exist? I spent some time on crates.io and Googling around, but I don't have a solid answer yet.
Thank you very much for your suggestions. I will try to incorporate them in the following days :)
Thank you for your input. I will try to some research for the other platforms. I sadly only have a windows and a linux+gnome3 machine. What kind of platform are you on?
Thanks for your feedback. I'm gonna change them asap
Honestly, it sounds like much of your experience boils down to t his: 1. crates.io search could probably handle hyphens (and similar) things better. The recall on `fixed-point` vs `fixed point` is pretty dramatic, and I'd probably call that an IR bug to be honest. 2. The relative immaturity of the ecosystem of crates you're looking for and less to do with crates.io. If there are no obviously good candidates in existence, then there doesn't exist any kind of search experience that's going to make that better. If anything, it seems like crates.io has at least done its job in mostly surfacing what the current state of things actually is. (Which means you're going to need to dig your heels in and do a full on evaluation of your candidates.) I mean, in general, yeah, there are things that can be improved. But I also think you need to strongly acknowledge the subject matter that you're searching too. A real evaluation of crates.io search needs to includes lots of things. For example, if you type `json` as your search query, will you be lead to the right answer? (This is an interesting example I've picked, because the second result of that search is probably the right one, but the first result is actively developed. Regardless, the download counts are a good heuristic here.)
&gt; The vast majority of future usage is w/o coroutines right now. So, I'm not sure what you are asking. I guess I'm still confused as to where the zero-costness comes in / what it means when someone says "Futures are zero-cost". The docs says that a Future "requires pushing along the computation to produce [a value]", ie. there needs to be an executor to keep calling `poll()` as appropriate. I don't think any executor is zero-cost (except perhaps for polling one future in a loop, which is eqivalent of sync code). So, if I understand right (???), the zero-costness of Futures referes specifically to the their composition, that is, usage of combinators like `AndThen`, `Join` et al. What I don't understand is how this is that much different from coroutines - a coroutine scheduler seems to me to be pretty much the same as a Future executor. As for combinators, well, the equivalent of `AndThen` would be just scheduling another coroutine at the end of one or just calling a functions as part of the same coroutine. `Join` is a bit trickier, it requires explicit support of and interaction with the scheduler. In Golang, for example, this is done with their `WaitGroup` thingy. Is it very costly compared to `Join`? It should be noted that `Join` and `Select` really aren't entirely zero-cost either, at least if my understanding is right, because when polling a Future composed of a bunch of `Join`-ed and `Select`-ed subfutures, _all_ of the contained futures will get polled even though only one or subset of them is actually ready to be polled. &gt; The stack is being built up. It takes time. The foundation has to be solid before building higher. That is fair. &gt; If you want easy + are willing to pay the cost, honestly Rust might not be the right language. IMO Rust is #1 about not compromising performance and then figuring out how to make things easier. Well, a pragmatic (and also a bit selfish) approach would be to use something else and come back to async Rust when things have progressed along... 
I think the in-progress guide is at https://rust-lang-nursery.github.io/rustc-guide/
&gt; From what I have read, many of the difficulties arise because it is hard to express completion-readiness (IOCP) in terms of operation-readiness (epoll), while it is easier the other way around. &gt; &gt;With most people starting their abstraction efforts from epoll, they experience these issues and just say "IOCP is bad!". Yes, this is exactly my impression as well. `mio` even has names of some of its API elements copied from epoll directly. 
Well as you point out it's search is fairly limited. I just think a better use of that effort would be serving up static content to search engines rather than improving the existing search.
Lol, why wouldn't you use C++? 
You can also set `RUSTFLAGS="-C link-args=-Wl,-zstack-size=4194304"` as an environment variable.
In Python there are two constructs — one is an expression and one is a statement. Rust only has one, an expression; while it looks like Python's statement, it is obviously closer in semantics to the expression. Again, don't get hung up on syntax.
what kind of tree?
I didn't have much to say for the actual code, but I love how many people chipped in and shared their knowledge and insights! I just love the Rust community for that :D
If you want to send 1000 packets/sec on avarage, instead of one packet every 10ms, you should probably look into scheduling algorithms like https://en.wikipedia.org/wiki/Token_bucket
This is not at all true. `()` is a perfectly normal type with exactly one value - `()`.
`()` is nothing like `void *`. It's much more like an empty struct.
I'm really chuffed about it -- a lot of the feedback is *really helpful,* yay.
Yeah, Habitat's really interesting! I wanted to build something that could work with existing systems easily, though, rather than requiring major changes to existing projects. In my experience, gradually introducing stuff &amp; not interfering with existing workflows can really help adoption in legacy systems &amp; team context. At least from Habitat's documentation, it seems like it really needs to control a lot of one's environment -- is this correct? Or am I misreading it?
&gt; panics are killing me. What is it that panics? RefCell borrows? If so it might help (I don’t know whether you do this already) to move interior mutability to be "more interior": instead of `RefCell&lt;Node&gt;`, have individual fields inside `Node` be `Cell`s (where possible/practical) or `RefCell`s. &gt; For me, the ideal solution is some kind of mini-GC. All nodes belong to Document/Root and as soon as it goes out of scope That part sort of sounds like an arena.
The only process supervisor I've used in the past is Python's `supervisorctl` (and a bit of `monit`). How does this compare to `supervisor` and/or `monit`(If you have used/considered these).
Since you said "fully correct", a tree also has the property that every node has at most one incoming edge. A directed acyclic graph isn't necessarily a tree. 
I concede; we found the better pedant. Don't tell my professor, please! /s
The intention is to easily work in brownfield environments. We don't do a good job of advertising building software without rebuilding your app using our kit. You can absolutely still rely on system libs, you just lose the portability. We actually just did a wiki article around using rpm2cpio to repackage rpm as hab packages. We definitely want you to build using our glibc and friends to get the full portability benefit but we are also super open to feedback. 
If you REALLY want to be pedantic, you could change &gt; ...a tree is a subset of a graph. to either &gt; ...a tree is a special case of a graph. or &gt; ...the set of trees is a proper subset of the set of graphs.
Right now, it's much stupider than either. :) This is very much a `0.1.0` situation. One of the reasons I'm asking for feedback now is that there's a tangle in the middle of my code that I don't quite know how to untangle yet, and while it's bearable for the moment I know that as I build out all the features I want to build it *will* start to block progress. I haven't worked much with either `supervisorctl` or `monit`, but it doesn't look like they -- or anything -- have the feature I most want to build. Right now, one of the bigger blockers I observe in trying to get folks to really *use* structured logging is that structured logs are painful to use in development. So developers wind up using a parallel log format in development, and information that could/should get captured by the production logger goes un- or under-captured. What I'm hoping to do is build in some log formatting &amp; aggregation that will make development log tooling "feel more like" production log tooling. Hopefully, that will make the process of building observable &amp; operable software more organic, and less of a point of contention between dev and ops teams.
&gt; where the zero-costness comes in A "zero-cost abstraction" means that the abstraction costs nothing compared to to the equivalent version written without the abstraction, not that the underlying execution takes zero time. &gt; a coroutine scheduler seems to me to be pretty much the same as a Future executor The difference doesn't isn't about the scheduling, it's about stack management. Usually, a coroutine requires setting up some stack (Go does this). Stack management is not free. This is why the coroutine abstraction is not zero cost, because adding the abstraction adds cost compared to what you would write without the coroutine abstraction. &gt; It should be noted that `Join` and `Select` really aren't entirely zero-cost either Again, it's not that the operation is zero cost, it is that the abstraction adds no cost.
You can use `peek!` to read kind of header and `take!` to skip to offset (after `peek!`, `take` will count from start of input). `rest` is useful too, for example you can put it at start of `do_parse!` to refer to "whole file" later. For example, this parser returns filenames in Quake/Quake2/Half-Life `.pak` file: #[macro_use] extern crate nom; use nom::le_u32; use std::io::prelude::*; use std::fs::File; named!(pak_filenames&lt;&amp;[u8], Vec&lt;String&gt;&gt;, do_parse!(o_s: peek!(do_parse!(tag!("PACK") &gt;&gt; offset: le_u32 &gt;&gt; size: le_u32 &gt;&gt; (offset, size))) &gt;&gt; take!(o_s.0) &gt;&gt; filenames: count!(do_parse!(name: take_str!(56) &gt;&gt; _offset: le_u32 &gt;&gt; _size: le_u32 &gt;&gt; (name.to_string() .trim_matches(char::from(0)) .to_string())), o_s.1 as usize / 64) &gt;&gt; (filenames))); fn main() { let mut buf: Vec&lt;u8&gt; = Vec::new(); File::open("/Users/kolen/.quake2/baseq2/pak0.pak").unwrap().read_to_end(&amp;mut buf).unwrap(); for filename in pak_filenames(&amp;buf[..]).unwrap().1 { println!("{}", filename); } } 
I used to be pretty vocally against flat namespaces, but have relaxed my stance over time. I would however like an opt-in version of namespaces so things like the `router` crate could have been `iron/router` and still leave room for say a `rocket/router` or a general putpose `router` (whatever that would have been). Of course this isn't too much different from if they had done `iron_router` in the first place. At least opt-in would allow us to start to de-clutter the top level namespaces with *new* package names. There's also been a lot of discussion over the years about "officially blessed" crates, but it never really goes anywhere because it's a lot of work to curate the crates. And reasonable people can disagree about which crates to choose for a given domain. Add to that, what happens when a new crate "overtakes" an older one? The metapackage discussion kind of touched on this a while back, but being attached to the "Rust platform" idea I think it generally received negative responses. As for the linked PEP, like many others I think it's a good idea overall, but disagree with a few of the details.
"Most"? Maven Central (probably the largest in usage) never did. npm (probably most packages) migrated away from it.
thats what I'm doing.
Doh! I didn't check your implementation first :)
This is awesome. Installed. Back when I did more web dev work, I remember hunting around quite a bit for a good color picker. It never occurred to me that I could do it with just a little bit of X11 fussing. :-)
Thank you!
I think you need to try to write some simple programs. Message try exercise.io
It's interesting to see the packages registered "Because someone might copy paste 'something' into the terminal and install a package which is a security risk." While I agree that *could* be an attack vector, I'd find it pretty hard to believe the crates.io/Rust team wouldn't take down a package which was blatantly doing this. The same could be said for the person who wanted to register `rg` to `ripgrep` because someone might `cargo install rg` thinking they're getting `ripgrep` (and maybe they *do* get a functioning `ripgrep`) but then also got a tiny back door installed as well. Again, I think the crates.io/Rust team would probably be ok removing a malicious `rg` crate. Of course, things like `cargo` code signing could help this particular problem too. ([rust-lang/cargo#4768](https://github.com/rust-lang/cargo/issues/4768) covers code signing)
[Because `extern "C" fn`s are in the list of implementations for `Pointer`, but `extern "system" fn`s aren't](https://doc.rust-lang.org/src/core/ptr.rs.html#2212), presumably because whoever wrote that code totally forgot they existed.
Isn't `TraitObject` still behind the `raw` feature gate? Aren't breaking changes to such things allowed?
It's just me that's developing, so far.
Am I doing the translations right? I'm not sure how it should be done in Rust yet. Other suggestions how to make it a good reusable crate are welcome as well.
For info: it formats `std::time::Duration` into a string like `5 days ago`. Initially created when discussing [short file date in exa](https://github.com/ogham/exa/issues/270).
I'm not actually the author of the article (I think /u/lynaghk is).
I remember this being debated but I can't find the issue. I think implementing it for more ABIs was considered to cause too much code bloat. 
As much as I sympathise with (and have defended) the implementation difficulties... it'd be really nice if Rust got some kind of solution for this. :P
[rustlings](https://github.com/carols10cents/rustlings) - small exercises to get you used to reading and writing Rust code. [Rust By Example](https://rustbyexample.com/) - a collection of runnable examples that illustrate various Rust concepts and standard libraries. [Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/) - a collection of simple examples that demonstrate good practices to accomplish common programming tasks, using the crates of the Rust ecosystem.
You should practice with Rust by solving Advent of Code challenges while referencing the API documentation.
&gt; exercise.io I think you meant exercism.io.
Apparently it is! I could have sworn I'd used it before on stable, but apparently not. So then, it very well could be changed!
I agree that names are not perfect, but switching to some code is not the answer. The fact that I can find a crate on Github (or where ever), open up `Cargo.toml`, and read exactly what crates they are using without looking up a code on another website is invaluable.
I would say put it in! You've got nothing to lose from putting a talk in
Which at least still works with this since ? Also wroks on option now! Just gotta change the type signature :D
"Blatantly" is a relative term. I'm sure the crates.io folks would take down something if it caused a lot of obvious trouble, but I'm skeptical they're going to be able to track a large volume of packages accurately. 
id-tree author here. I'd love any feedback you can provide on the API. I tried to make it as usable as I could for my own use-case, but I know that doesn't mean it will work well for everyone. I'd love to hear about your experience using it and any issues you had if you've got the time. Thanks!
I agree on not restricting 'advanced' features because some people don't (yet) understand them, but I've found pythons list comprehensions to be pretty unreadable in all but simple cases. It's a shame that map/reduce/filter and friends are so unergonomic in python (that it's impossible to define a multi-line lambda being the main problem).
No, of course. I didn't mean to imply the crated team should watch every single package for malicious behavior. Only that if this sort of thing did start to happen, hopefully "someone" would notice and report it to the team for investigation. If the allegation is specific enough it shouldn't be too difficult to verify being that all crates contain their source. I was actually agreeing with you that I think this sort of preemptive registration/squatting (no matter how nobel the purpose) is a bad thing, and I'd actually prefer it if those crates were freed back up for use.
list comps can actually do some complex logic while still being readable. I like to split them up across lines like this: results = [ row_to_dict(x) for x in read_rows(f) if x[0] == pk ] ... and if the conditions gets complex, then you can write it as a function and just have `if is_valid_row(x)` at the bottom. The same of course works for generator, dict, and set comprehensions. Also, you can use parens to do a multi-line lambda: rot_left = lambda x: ( None if not x else x[1:] + [x[0]] ) print(rot_left([1, 2, 3])) # prints [2, 3, 1] https://repl.it/@darkarchon/AlphanumericDamagedTree Anything that opens with `(`, `[` or `{` can extend multiple lines without any `\` (otherwise of course you can just put `\` at the end and continue onto the next line).
Honestly, I have some crates up that aren't being significantly used (from what I can tell), so I would voluntarily give the names up if someone asked. Some mechanism could exist to propose that certain crates have their names changed for such reasons. Obviously, a problem exists if somebody is trying to use a crate downstream and it changes on them, but if the versions come after the crate that is replaced that issue could be avoided. By that I mean, if I release a 1.0.0, the crate which replaces it could be 2.0.0 and be completely different, yet still compatible from a semver perspective so it wont break downstream.
What's your programming background? Is Rust your first language or are you coming from another language? Finding/writing something similar to what you already know is a good start.
For the installation section, I remember that you can do "cargo install" inside your folder.
Is this basically just inheritance or am I missing something?
[removed]
You have the lifetime parameter in the wrong spot. You want it like so: impl&lt;'a, N, M, L&gt; Vec3&lt;N&gt; where N: Mul&lt;Output = M&gt; + Clone + Copy, M: Add&lt;Output = L&gt;, L: Add&lt;M&gt;{ pub fn dot(&amp;'a self, other: &amp;'a Vec3&lt;N&gt;) -&gt; L::Output{ return self.x * other.x + self.y * other.y + self.z * other.z; } } playground: https://play.rust-lang.org/?gist=306b1422d6225c23f66a99982fd70a0f&amp;version=stable
I've been writing my final year project in rust - it's about behind learning. It's getting to the end of the year so I should probably write the report or polish the implementation a bit ready for the final hand in. Instead I've been writing a completely different, more general machine learning crate. I've found it to be petty fun, and ndarray is surprisingly easy to use. I'll probably continue with that, and maybe write a blog post on how rust has been for writing the project in. 
Oh, that makes a lot of sense; thanks for the tip. Do you know where in the documentation I'd find more information for this kind of stuff?
Hm, not particularly haha. I think there's some stuff in the book about it and yeah I'm not really sure other than that :P
Thanks anyways
Working on a [Rust implementation of the cryptocurrency Nano](https://github.com/termhn/nano-rs). Trying to figure out how/if I can get serde to fit my needs and if it's worth it currently. At this point I'm thinking I'll be using it for doing JSON ser/de but writing the binary part myself because of the way the Nano protocol is designed is just quite inconvenient for use with serde.
For this kind of thing, Gotham, Actix-web, or Rocket would probably be good choices because they're fairly higher level and have good momentum as far as development going on. I used rppal in a little project I did a few months ago and it worked flawlessly for my needs. As far as how to do this, I think the easiest way would be to set up a web page with an interface which sends JSON requests to the server that it's hosted on. Then this server (any of the above would work) looks for json requests, parses them, and executes whatever command is contained. For example you might have a JSON POST with the body: { "action": "on" } which would turn the LED on and { "action": "off" } would turn the led off. In Rust you could map this with serde to something like #[derive(Serialize, Deserialize)] enum LedState { On, Off, } #[derive(Serialize, Deserialize)] struct JsonRequest { action: LedState } or something like that
As a follow up, Poking around I did find a way to write the same thing a little closer to what I was originally trying for: impl&lt;N, M, L&gt; Vec3&lt;N&gt; where for&lt;'a&gt; &amp;'a N:Mul&lt;Output = M&gt; , M : Add&lt;Output = L&gt;, L: Add&lt;M&gt;{ pub fn dot(&amp;self, other: &amp;Vec3&lt;N&gt;) -&gt; L::Output{ return &amp;self.x * &amp;other.x + &amp;self.y * &amp;other.y + &amp;self.z * &amp;other.z; } } 
Exactly like GitHub user projects versus group (is that the term?) projects, with some heuristic to expand an unqualified crate name to a crate with an identical namespace. This may not be the most aesthetically pleasing solution but superficially it seems like it could be retrofitted onto the current state. It's not as robust as the Java and Maven model, though.
I haven't had much free time for Rust recently, though I have been chipping away towards UNIC's table revamp. But [I did a Tetris thing in Python](https://twitter.com/CAD97_/status/978130546269282304) for part of a class that I'm pretty happy with!
It's not really such an achievement *right now* - getting others to join outweighs the need to show off. It will be when Rust has taken over the world (hey, maybe it will happen), and this subreddit still doesn't read like most C related communities I've seen. And I think we can manage that!
&gt; So I think at the end of the day I'm having a hard time figuring out how this relates to the flatness of crates.io... There are several ways to get an information retrieval (IR) system to deliver higher "quality" results. One of them is to build fairly advanced IR technology to try to work with limited information. This is what the big team at Google has done over a couple of decades. It works OK for primarily-textual content which can be mined for semantics and relationships. Trying to do this kind of IR on cargo.io seems inherently hard to me, especially given the limited resources to develop it. Crate names aren't a very strong indicator of content (would you have guessed "fpa" was a fixed-point arithmetic crate if you hadn't been told?). If the other source of information is *ad hoc* keywords, then they better be really well-chosen to get any kind of generalization and specificity. Libraries have had to deal with this kind of problem for decades, and their solution has been to create a curated semi-hierarchical namespace — Library of Congress or Dewey Decimal in the US — that tries to improve generalization and selectivity by associating related works. This is a lot of work for authors, publishers and archive administrators, but it really pays off. In the "Information Age" we've tried to replace that with some combination of fancy metrics: in the case of crates.io things like download frequency and recency are such an indicator. (Note, however, that there appears to currently be no way to filter or order search results by this metric.) I don't *have* fantastic answers here. It's not like I can hold up some other package repository out of the dozen or so I've used and say "this is how it should be done." Here's a few things I think might be worth trying: * Provide a distinguished set of "official keywords" that are highly-encouraged or required for a crate iff the crate matches. Police this somehow. * Provide some kind of review or feedback mechanism for crates. This could be crowdsourced or official: ideally the most "important" crates would have both. * Provide some sort of "related-crates" information, and give a mechanism to encourage or enforce its use. The UNIX manpages have a nice "SEE ALSO" header that is really helpful in this regard. * *Maybe* do topic-hierarchical crate organization. With dotted names, this would allow several crates with the same basename, which would be nice. It would also help group the crates. It's really hard, though. I'm concerned by reports I've read recently of folks who have been scared away from Rust by what they perceive as organisational issues with crates.io. As our repo grows to Hackage levels and then to the levels of things like PyPI and NPM I fear this problem can only get worse.
I agree completely that the crates.io maintainers should be free to "do the right thing" and that we can help. Sorry if I sounded argumentative above: it's a personal weakness I need to work on. I just have observed that unless the system is set up carefully sometimes major damage is done before anyone really notices. I *am* worried about reusing crate names for legit crates that were actually active at some point. That seems fraught with peril.
I don't know which one would be considered more ideomatic, though I think maybeadd\_trad is more readable. You can however also do the following, matching on both options at once: let c = match (a, b) { (Some(a_content), Some(b_content)) =&gt; { Some(a_content + b_content) }, _ =&gt; None, // This matches (Some(_), None), (None, Some(_)) and (None, None) };
http://exercism.io/ should definitely help.
Again, you are just repeating my exact point. 
/sigh I am saying the exact _opposite_ – you have repeatedly called Rust's `if` a statement, when it is an expression like other languages' ternary operator. I have no idea what miscommunication is occurring here, but I give up.
I have to rebase my PR because the docs got a long-due overhaul. Also I'm working on auto-generating some matchers for mutagen's opportunistic mutations, so we can replace various `std::ops` traits with each other without much hassle.
This feels a _little_ like the Go way of using &lt;github-name&gt;/lib as module references directly. It does not end well, because then you have to find the _person_ who is keeping the 'canonical' version maintained. And it isn't always the original author.
You should try `and_then` instead of `and`.
Rust is expression-based, so is Ruby. map/filter/reduce were in Ruby far before they were in Javascript, and work the same way. Range syntax in Rust is the same as in Ruby (more or less), lambda syntax was explicitly inspired by Ruby (the |foo|` syntax) and the package manager (Cargo) was explicitly based on rubygems/bundler and was even written by the same people.
&gt; Perhaps it would make sense to have a verbose mode that did more statistical work That's what other benchmarking harnesses like Rust's Criterion do. What we need is an easy way to use those instead of libtest for benchmarking.
Trying to get the gratuitous `Clone` constraints out of my "[self-initializing vector](http://github.com/BartMassey/sivec)" code. The only thing that actually needs to be `Clone` is the one initializer, but I'm rabbit-holing pretty hard trying to untangle it all.
&gt; [...] the c compiler that rustc invokes (usually gcc), Confused - doesn't rust use LLVM?
I am working on getting text layout for [azul](https://github.com/maps4print/azul) done. I've live-streamed my past work [here](https://www.youtube.com/playlist?list=PLQVv8W1LkpaYQP0Ad_heGb5o_R39yB3du) (playlist is in reverse order). Then I only need to do event filtering and translating layout constraints from CSS to cassowary - and then the GUI system is almost done for a 0.1 release.
&gt; What is it that panics? RefCell borrows? Yes. &gt;move interior mutability to be "more interior" Can you provide an example? Most of the panics are because I usually have a reference to node's attributes and then trying to remove it's children, which requires this node to be mutably borrowed. And a lot of similar cases. The main problem with GC/arena is to allow many mutable references to the underlying vector. Which rust doesn't like. 
Cool, I'm working on eventually getting an embedded Bluetooth module working myself. Still trying to get the board playing ball at the moment though. 
id-tree: tree.insert(Node::new(2), UnderNode(&amp;root_id)).unwrap(); ego-tree: tree.append(2); 
[usvg](https://github.com/RazrFalcon/usvg) - an SVG simplification tool (beta).
It would be much better if you could share the rust code you've done. `&amp;var` and `&amp;mut var` will let you take reference of a variable.
I think /u/rebootyourbrainstem was referring to `*mut ()`, not `()` being the analogue of `void*`.
Typing this from the All-Hands as we speak. As chair of the No-Memes-WG, I'll be leading a discussion on how best to eradicate our most hated nemesis, /r/rustjerk. AMA
Cheers, I wanted to be able to pass an argument to be able to switch between circle and triangle, so I went with the `Box` option, which seems to work nicely!
Just Windows myself.
Well, it's related to my point somewhere at the top. If you don't prove `Release` is enough, do you prove `SeqCst` is or do you just hope?
[The search implementation also looks like a database lookup on a full-text-search column](https://github.com/rust-lang/crates.io/blob/7d6fc89756389bafdd4c716a183450b45de4759f/src/controllers/krate/search.rs#L70-L92). I don't know how good those are in practice (better than `LIKE`, certainly) but moving to a dedicated search tool like Solr might help IR as well.
How do you represent the links between nodes in Rust? `Rc&lt;RefCell&lt;Node&gt;&gt;` for the children links and `Weak&lt;RefCell&lt;Node&gt;&gt;` for the parent link?
&gt; There are several ways to get an information retrieval (IR) system to deliver higher "quality" results. One of them is to build fairly advanced IR technology to try to work with limited information. This is what the big team at Google has done over a couple of decades. It works OK for primarily-textual content which can be mined for semantics and relationships. Eh. I don't really buy this. At least some significant fraction of the effort that Google puts in must deal with scale. crates.io right now has 14,000 crates. Even when that reaches 1,000,000, that kind of scale is paltry compared to what Google needs to build. That means we have a bit more freedom than they do; we can come up with a relevance metric tailored specifically to our use, and it doesn't necessarily need to be web scale. There are various other things that can be done other than just indexing names. Indexing README or documentation content, for example, might help a lot in a simple TF-IDF system (or Okapi BM25 if you're hip). &gt; Provide a distinguished set of "official keywords" that are highly-encouraged or required for a crate iff the crate matches. Police this somehow. I think crates.io already has this. They are called categories: https://crates.io/categories OK, so it sounds like you're not a fan of folksonomies. But they have their place and aren't necessarily all bad. Wikipedia is one big folksonomy for example, possibly for the reasons you've mentioned: it is hard to setup a true taxonomy and stick to it. I think having both is a good idea. The problem with a curated taxonomy is that it would ideally be infinitely granular as more crates are added. But no one set of curators will have the domain expertise to create this taxonomy. A folksonomy isn't a perfect solution to this problem, but it's definitely better than just having a curated taxonomy. &gt; Provide some kind of review or feedback mechanism for crates. This could be crowdsourced or official: ideally the most "important" crates would have both. This is hard to do, and I think a lot of the difficulty is a social problem. &gt; Provide some sort of "related-crates" information, and give a mechanism to encourage or enforce its use. The UNIX manpages have a nice "SEE ALSO" header that is really helpful in this regard. This is certainly a nice bit of information. But I'm not sure how to do it. &gt; I'm concerned by reports I've read recently of folks who have been scared away from Rust by what they perceive as organisational issues with crates.io. As our repo grows to Hackage levels and then to the levels of things like PyPI and NPM I fear this problem can only get worse. Which organizational issues exactly? I'm still having a hard time understanding the nature of your critique here. It feels like on one hand you're saying "crates.io just needs a few tweaks to make it better," but then comments like this suggest something more fundamental is amiss? I think that saying what the ideal crates.io looks like is relatively easy. Actually engineering that into reality is much much harder, and many of the hardest issues to tackle relate directly to how humans behave. &gt; (Note, however, that there appears to currently be no way to filter or order search results by this metric.) There is a drop down menu on the search result page that lets you search by relevance, all-time downloads or recent downloads.
It looks like that's using PostgreSQL's ts vector search? If so, it's not bad. It's major "weakness" is that it doesn't take corpus background frequencies into account, which makes it difficult to know which terms are "rarer" (and thus more "important") than others. But it can work well in practice, and a rule based ranking system has certainly found success in products like Algolia.
Working on implementing `LISP in Rust` here: https://github.com/vityafx/LIR Feel free to post your opinion there or right in the [reddit post](https://www.reddit.com/r/rust/comments/86jm7m/thinking_about_lisplike_language_with_rust_interop/).
That implicit thing in Scala is a workaround for separating interface and implementation (like separating trait and impls in rust). If you want to provide an implementation of an "elsewhere-defined" trait for your type, or if you want to provide an implementation of your trait for an "elsewhere-defined" type. I don't like it either, we use it very carefully. And really easy to abuse (akka-http's implicit hell). When interacting with Java libs: we wrap everything to Try { }. It is not nice, but at least it's a monad.
https://twitter.com/jimmycuadra/status/978140687194468352
Sure did. 
Ah, I must've skimmed that paragraph, sorry! In any case: I believe `SeqCst` on all shared memory locations is always enough for memory safety. It "just" becomes a question of correctness rather than data races and undefined behaviour, and reasoning about correctness is easier too because the model is so much simpler and more intuitive (no time travel!). I think the JVM is evidence of SeqCst not being *bad*, per se: it offers "relaxed" (similar, but having defined away any undefined behaviour) and sequential consistency with no acquire/release, and yet is generally regarded as the platform with the best/widest-variety of high quality concurrent data structures.
This is exactly what happened to Ruby as well. It wasn't good.
It uses the c compiler for linking. This might change in the future with LLD, but so far LLD is only used for the wasm32-unknown-unknown target.
https://twitter.com/Argorak/status/978243629666963456
&gt; The difference doesn't isn't about the scheduling, it's about stack management. Usually, a coroutine requires setting up some stack (Go does this). Stack management is not free. Yes, that's true, I can see how Futures are lighter in this regard. Maybe I'd consider mentioning something along those lines in the docs? The docs are kind of vague about this, but then again not having the bigger picture I don't think I'm able to suggest concrete improvements... I'll try to look into it... 
Continuing to work on my game trying to get it into a playable state. I am hoping to find the time to expand on my [steamworks](https://github.com/Thinkofname/steamworks-rs/) bindings so I could implement steam multiplayer at some point.
I'd love to see this in the official docs! Last time I checked they just link to LLVM docs which are much denser than I'd like.
Are you going to use `harfbuzz` for text shaping? I need to add a few things to the `harfbuzz` crate to let it be usable, but the `harfbuzz-sys` that Servo uses is pretty up to date now ...
In your current setup, each `Node` owns its children (it stores `Option&lt;Node&gt;`s, not `Option&lt;&amp;'a Node&gt;`s). To make the "add a random node to this tree" logic work, I'd have `add_random` take a `Node` rather than a `&amp;mut Node` and move the `Node` into the tree, like so: pub enum Op { Whatever, Something, } pub struct Node { op: Op, // an enum children: Vec&lt;Option&lt;Node&gt;&gt;, f: f32, } impl Node { fn add_random(&amp;mut self, node_to_add: Node) { let mut rng = rand::thread_rng(); let index = rng.gen_range(0, self.children.len()); let child = &amp;mut self.children[index]; match *child { None =&gt; *child = Some(node_to_add), // Borrowed value does not live long enough Some(ref mut node) =&gt; node.add_random(node_to_add), // Cannot move out of borrowed content } } } 
Herb Sutter in his "Atomic Weapons" talk [strongly cautions](https://youtu.be/KeLBd2EJLOU?t=1h2m) people against using anything other than SeqCst, unless you're certain you need it &gt;.&lt;
I recently took over maintenance of the `z3-sys` and `z3` crates from Graydon and have been working on them. I've published a new version of `z3-sys`and I'm working on updating the `z3` crate. ([Repo](https://github.com/endoli/z3.rs).) I've suggested a [custodian](https://github.com/rust-lang-nursery/ecosystem-wg/issues/14) team as part of the ecosystem WG and hope to have some feedback on that. Along with that, I've been submitting custodian / janitorial patches around various things in the last couple of weeks and plan to continue. I've published a long overdue update to my `lldb-sys` crate that brings is close to being up to date, and this week, I'll update the `lldb` crate for the newly bound features. (Repos: [lldb](https://github.com/endoli/lldb.rs), [lldb-sys](https://github.com/endoli/lldb-sys.rs).) I'm slowly working on some RDF-related stuff as well as Linked Data, but not sure what I'll get done this week on that yet. The final thing for this week is that I'm writing something to use some code borrowed from `serde-json` to provide serialization / deserialization between Rust and JavaScriptCore. I maintain bindings for `javascriptcore-sys` and `javascriptcore` and would find it useful to use `serde` to translate values back and forth.
Thank you! That is fascinatingly simple. 
I'm a fan of the feature, but the last time I checked it had some unacceptable (in my mind) tradeoffs. That was maybe January. Don't know what the current state is. Not sure if I can remember exactly what the problem was, but I want to say that it didn't play nicely with all the different ways you can write generic function signatures.
Thats it? So we are talking about bounds? https://rustbyexample.com/generics/bounds.html#bounds 
Writing a "something" with the title "why you should try Rust"
If you have time, another similar question. I tried using the same approach on another function that fills the tree with leaves. So add_random is called to build up a tree to a certain size. Then I fill up all the dangling None children with Nodes that are leaves (have no children) by calling add_leaf until add_leaf returns false, like so: fn add_leaf(&amp;mut self, leaf: Node) -&gt; bool { for i in 0 .. self.children.len() { let child = &amp;mut self.children[i]; match *child { None =&gt; { *child = Some(leaf); return true }, Some(ref mut node) =&gt; { if node.add_leaf(leaf) { return true } } } } false } Because of the loop, I get a use after move error, that makes sense, the compiler can't prove that I'm only going to be doing that move one. I suppose one solution would be to use iterators to do this without looping? 
hi only going to be doing that move one
I think it would be more correct to say that bounds are an aspect of the system. You could argue that associated types are also part of it, but bounds are probably the most important and most immediately visible part of it.
&gt; It "just" becomes a question of correctness rather than data races and undefined behaviour, 🤔 I don't think that's true though. Your program most definitely contains non-atomic writes, and those are still undefined if they race anything else in any possible interleaving. (*factorial blowup*) Most languages offer a choice: pick two of concurrency, safety, and raw shared mutation. Java is concurrent and raw but not safe. Data races are UB. CPython is safe and raw but not concurrent. One big lock enforces interleaving execution. There's no guarantee that all interleavings will do the same correct thing. Ada and Erlang are safe and concurrent but not raw. *These* are the languages where concurrency is easy and painless. Safe Rust should, in principle, be similar to those languages. It's less powerful (Ada has transactions!) but the guarantees are there. Unsafe Rust, specifically `unsafe impl Sync`, sticks to the "like C but with guidelines" theme of unsafe Rust in general. You can perform the racey operations yourself in unsafe code. Or you may pass references to safe code. If you pick the latter, you must provide the ordering guarantees of `Mutex` or `RwLock` - and those can be implemented without SeqCst. As far as I understand, the power of SeqCst over Acquire is negative reasoning. If I *don't* see a particular signal value, it *hasn't* happened before the barrier (but some other thread may make it happen before I do). However I didn't consider myself expert enough to get into details. *SeqCst still has sharp edges*, they're just more subtle. I do know that the standard library mpsc uses SeqCst. 
I'd reccomend you start solving practical task and ask questions (here, irc, stackoverflow, gitter - whatever). The book is good, but it contains a lot of information, and it's hard to accept all of it without practice. The Rust community is really awesome, friendly and helpful, so don't be afraid to ask questions.
Well, you'll always be a noob at something, but, hopefully you won't have problems for your entire lifetime. :) Seriously though, couldn't resist based on the way you phrases the title.
I'm still working on Rust support in lldb. I have a good chunk of the expression evaluator working now. Next steps are to finish the evaluator and then work on some polish.
`Duration` is likely the wrong type for creating user-facing strings. It only counts seconds and thus cannot account for leap seconds, months with different amount of days and leap years. In fact, looking at the current implementation, a month is hardcoded as [~30.4 days](https://github.com/vi/timeago/blob/e137253d36e1f79fb93d1aa51e788410ed9c60de/src/lib.rs#L530) and a year is hardcoded as ~365 days. This does not match the natural language surrounding dates IMO. Example: On March the 31st, it will tell me that my file created on March the 1st was created "one month ago", but on March the 1st, it'll tell me the file created on February the 1st was created 28 days ago.
Thanks for an interesting report! My thoughts: &gt; For microcontroller crates with the split TX/RX implementation users will have to add an additional serial HAL implementation which abides by my driver’s requirements. I think this is the correct approach. In case it is annoying for people it'd make sense to make generic wrapper `BiDirectionalSerial&lt;R: Read&lt;u8&gt;, W: Write&lt;u8&gt; { /* ... */ }` which implements `Read&lt;u8&gt; + Write&lt;u8&gt;`. &gt; The proposed solution is to automatically handle the error when it occurs. However, is auto-resetting the error the correct way to handle this situation? I'd like to see two traits: one low-level and one high-level which handles resetting automatically in some way. This way the user has fine control, but can also use high-level approach, if it's sufficient. &gt; Currently if there is an error during a state transition, my driver will return that error and destroy the `Rn4870` object You can return `Err((Error, Rn4870))`. This is what `futures` crate does and is a good approach IMHO.
Thanks for the link. Jerk subs are my favorite subs on reddit.
How does it feel to be on the wrong side of history? Memes are, like, the future, man.
This is more of a "should I make this a crate" question instead of a problem. In my weekend projects I tend to reimplement a couple of things all the time. One of those is string wrappers. In it's last iteration it looks something like `Text&lt;K, D&gt;` where `K` is a text kind, like `ResourceId` or `PageTitle`. The `D` is the dynamic storage (`String`, `Rc&lt;String&gt;`, `Arc&lt;String&gt;`, ..). The text kind has checks attached to it that verify the string contents (`NotEmpty`, `SingleLine`, ..). Usually this happens over time. It gives me the following: * Special storage for `&amp;'static str` values. * Cheapish copyable strings when required. * Different types for different kinds of strings. * String values have their constraints verified. * The value checking abstractions make nice, consistent error messages. * Transition from one dynamic storage to another (e.g. `Rc&lt;String&gt;` to `Arc&lt;String&gt;`) without redoing checks. * Transitioning from one kind to another while possibly reusing the underlying storage (if it's shared). It's not a complicated piece of code. Currently doesn't even have ways to mutate the value, though I'm planning on that. It's not super efficient, but is usually enough for me, otherwise I'd reach for a simpler wrapper around tendril. So, my question is: Would it make sense to release this on crates.io? Are there better alternatives I haven't found yet?
I am working on a CLI app for doing online banking.
`Duration` is simple, especially for usage like `format_5chars`. Trying to account calendar makes everything more complex, and probably adds some dependency. If you want actual calendar-based approach, create Github issue asking for it. It may be added to `Formatter` as some separate method, maybe gated with separate Cargo feature; somday. And is using actual calendar + i18n = caring about non-Gregorian calendars?
We recently saw an `app_dirs2` because of `app_dirs` being abandoned. I'm running into this on several fronts - For my CI work, I've reached out to an author for a crate I want to improve but heard nothing - For my assert_cli work, there are two well rounded predicate crates that seem like good points for collaboration but neither have responded. So I'm having to decide if I want to fork and come up with a reasonable alternative name or figure something else out.
I stumbled upon this and I thought I'd post this here, as most of those bugs are both really interesting and something that would not happen in Rust, thanks to a stronger type system and the borrow checker.
[removed]
Why does this sound so much like an ad...
I have no answer for you, but i'd say part of the problem is in your last question: it's not easy to find such a specialized crate. So if you decide to take the jump and make the crate (why not ?) please make it easily discoverable, with a good title, good summary line and clear readme.
Keep up the great work. I'm eagerly following your progress :)
Yes, probably - it would be nice if there was an easy-to-use harfbuzz library. For RTL-layout I'll probably use servos version, too. 
If you borrow them mutably, no one will be able to share them anymore.
[removed]
[removed]
If I'm not mistaken, this is about the inability to use `impl Trait` in return position in trait methods.
One option would be to return the reference out of the loop and then set the leaf after the loop. A better option would probably be to try enabling `#![feature(nll)]`. Doing that enables more complex lifetime analysis. That said, it won't work as it stands since node.add_leaf consumes the value whether or not it fails. One way around that is to return a `Result&lt;(),Leaf&gt;` instead of a boolean so you can get the leaf back in case of a failure. If all else fails, `Clone` it. Cloning fixes everything.
&gt;Developer of PVS-Studio static analyzer.
There are a number of uses of `SeqCst` in the standard library, especially in [`std::sync:mpsc`](https://doc.rust-lang.org/1.24.1/src/std/sync/mpsc/shared.rs.html). It would be interesting to see an analysis of whether those are necessary, and why or why not. The [`Arc`](https://doc.rust-lang.org/1.24.1/src/alloc/arc.rs.html) source is also an interesting case, since it uses a mix of all the different orderings (including `SeqCst`) with comments explaining why.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://doc.rust-lang.org/1.24.1/src/alloc/arc.rs.html) - Previous text "Arc" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
[removed]
Thanks for the kind words. This project is mostly curiosity-driven, so yes, I'm also happy about all progress we make. That said, we seem to be slowing down a bit. Many low-hanging fruit are picked already, timeouts and bounded loops are next on my list. Then perhaps parallelizing the runner and/or statement removal (though that's really something). 
Thank you and best wishes to all of you.