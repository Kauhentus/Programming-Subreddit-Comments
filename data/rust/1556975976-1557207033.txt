&gt; Edit: Though if you don't mind me asking, what's wrong with using tabs for indentation instead of spacing? Is it purely a preference thing? Can it eventually seriously mess up your code? The only thing "wrong" with it is that the wider Rust ecosystem generally uses spaces, and not tabs. So if you use tabs, you'll catch a lot of folks by surprise. It will not mess up your code, but it's more than just a preference thing I'd say. There is a fairly strong culture in the Rust ecosystem against using tabs.
An annoying problem with parenthesis in general. Thankfully editors these days can colorize and highlight matching pairs, which helps a lot. With `prefix-mandatory` the brackets atleast stand out, too.
I don't think that's what's going wrong here. I notice that if I instead write it such that its `State&lt;T,T,F&gt;` (my mistake, it was TFF not TTF before), it compiles just fine. So the `::Not` seems to be part of the problem. https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=68e2e6ff3ffe13bc2d718a9b6122ce17
Not entirely sure why you got downvoted (possibly because of the 'outlandish' idea that we mightall pull in different directions), but I've also come to appreciate the idea of postfix-macro, which as /u/Manishearth argues is useful in its own right. Rust likes to flow left to right, and the ! keeps us awake :) &amp;#x200B; The idea of a *magic field or method* strikes me as bizarre and surprising.
I mean you could just render the SVG once on game startup and even cache them to disk. Tbh SVG sounds a lot like a simple form of procedural generation
No, you cannot remove a crate from crates.io, it's a permanent archive. The only way to introduce change is through versioning. You need to add a badge or update the README of your crates stating that you search for a new owner of the respective crate. The Cargo Book contains information on how to change ownership. The new owner might want to develop your code further (licensing needs to clarified) or start completely fresh. (The latter is only done correctly with a new major version. In such case, it will beneficial if the crate hasn't hit 1.0.0 because then, merely the middle version component needs to be increased (Cargo-flavored semver) staying at 0.n.m as opposed to a jump from let's say 1.n.m to 2.o.p which signals stability at first glance)
I thought postfix was the way to go, after seeing this I've done a 180ยบ and I'm in love with prefix-mandatory. Comparing it to the macro: 1. You clearly (at least more than a macro) see where it ends, making chaining easy to read. 2. It doesn't matter if the await may or may not be directly implementeed by the user, which matters to me because I dislike 'magic macros that aren't really macros' as much as 'magic attributes that aren't really atrttibutes' 3. It is not heavy to type, it is the same number of characters as the macro 4. IMHO the curly braces pop more to me than the macro does, which I belieeve to be important for this kind of control-flow keyword 5. IMHO now that I see it in context it is way more pretty than I thought, making it I'd say consistent with clousures
Same here. It's the least strange one visually, and it's similar to how it looks in other languages while avoiding the weird precedence issues entirely. Kind of weird, I thought I liked the postfix method variant but after seeing this code I'm firmly in the `await!` macro camp.
Try it I guess? The pathfinder repo's default example app can load an SVG file and shows you the frame rate. You could make one with tons of duplicated sprites in it.
I am struggling with conflicting trait implementations. I've got a small example here: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1beb3b0bf17792083bbf86a6eac8deaa I've got two impl blocks for my trait `Advance`. The first block is for all `State&lt;_,_&gt;` but excludes `State&lt;T,F&gt;` and the 2nd is just for `State&lt;T,F&gt;`. When both are present, I get "conflicting implementations" for `State&lt;T,F&gt;`, but when I remove the 2nd one, Advance is not defined for `State&lt;T,F&gt;`. I know its got something to do with the `::Not` part, because if I try to recreate this problem for `State&lt;T,T&gt;` (which does not require `::Not` on line 25), it compiles just fine. It seems like the compiler "changes its mind" about whether the first impl block applies to `State&lt;T,F&gt;` between checking for conflicting implementations and actually checking if it applies. Any ideas?
Ah, yeah that makes sense. I should probably get used to to spaces over tabs then, especially if I plan on working with other people at some point in time. Thank you for the info.
&gt; I fixed the mem::uninitialized UB (see post for updated code Awesome, this looks good now! &gt; That means that the docs for mem::uninitialized are completely wrong... it says that creating uninitialized values is fine as long as you overwrite them before reading them. The example even creates an uninitialized Vec&lt;u32&gt; which could presumably include a bool. Yeah, this is finally getting fixed by https://github.com/rust-lang/rust/pull/60445. &gt; I changed the implementation of FnOnce to actually consume the contained object (rather than just forwarding to Fn) by adding a new MoveCall mode to the "vtable" function. This made having both wake and wake_by_ref in the Waker implementation trivial. That's not really the same thing -- the point in `Waker` is that the user gets to implement both of them separately, and `wake_by_ref` might be more efficient.
The callable that the user provides to `Waker::new` can have different implementions of `FnOnce` and `Fn`, so there's no loss of flexibility...
As mentioned on other threads, it's consistent with method chaining and the try operator
Looks useful in automatically keeping versioning shown to a user consistent. &amp;#x200B; Any way to get a git commit hash as well? Having "3.5.1-9fae4cd" can be useful.
Sure but it's important to remember that it fits in other languages because they have different syntax. In Rust where so many things are postfix it seems highly non-idiomatic
Ok cool. I'll do that when I have time.
If you `impl SomeFalse for T`, why should one impl be chosen over the other?
you're right when you say that impl SomeFalse for T would cause it all to fall apart. but it should work \_until\_ I do this, and I can avoid anyone else doing it by making SomeFalse private
wasm-bingen is made old redundant people who still belive JS will survive and worst is they promote Node, so i tried stdweb but that is severely limited due to examples with JS! macro, and Yew is MVC hence is of no use to innovative men like me, so i guess webAssembly will have to wait 10 more years to become useful or programmable through rust
That's why he said **in practice**. Although it's possible to find pathological problem instances, it turns out most of the time the problem is you will ask a SAT solver to do for you are solve relatively quickly.
`?` is a sigil, so if you want consistency with `?` you should go for a postfix sigil. And although you're right that postfix method/field syntax allows for method chaining more smoothly, I think that matching syntax with method/field syntax should be avoided as it has a semantically completely different meaning.
&gt; Looks useful in automatically keeping versioning shown to a user consistent. True, but if all you want is user output, you can just use `env!("CARGO_PKG_VERSION")` which gives you a `&amp;'static str`. This crate is a bit more specialized. My use case for this is in [`zathura-plugin`](https://docs.rs/zathura-plugin), where I wanted to automatically specify the plugin version (which is stored in a `static`). &gt; Any way to get a git commit hash as well? Having "3.5.1-9fae4cd" can be useful. This does sound useful, yeah. The current solutions like [`built`](https://docs.rs/built) all do stuff in `build.rs`, which isn't as ergonomic as just invoking a macro. Determining the revision, date and dirty status should all be possible by shelling out to `git`/`svn`/etc (I don't think I want to pull in libgit2 et al as dependencies). We're also missing a macro that expands to the *whole* semver version (currently there's no way to access pre-release version or build metadata).
I don't know whether `tail` it has optimizations that kick in if the file is seekable (probably), but, given that is accepts stdin as an input, tail must at least be *falling back* to an algorithm which follows this abstract model when you use `-n 1`: 1. Allocate a buffer (eg. `String`, `OsString`, or `Vec&lt;u8&gt;`). 2. Push each character you encounter onto the buffer. 3. If `\n` is encountered, mark the buffer to be cleared. 4. If a character is encountered and the buffer is marked to be cleared, clear it before adding the character. (This deferred clearing prevents a terminal newline from resulting in an empty return.) 5. Upon reaching the end of the file, return the buffer. For seekable files, the simplest optimization would be to seek to an offset near the end of the file (My first impulse would be 4K, since that's the native block size of Advanced Format hard drives, so the kernel's going to read at least 4K whether or not you ask for it) and then start processing from there.
My personal opinions are that this is shows a pretty strong argument for some sort of postfix syntax. Using parentheses with complex code makes it hard to tell what exactly is being awaited. Using braces isn't so bad though. Also interestingly, the `await?` idea becomes useless when you're adding `.context` to the result.
I don't think Rust considers privacy when looking for trait conflicts, so that won't work. The Rust compiler will assume it will be valid to provide this impl as it checks for conflicts. (If it didn't, you'd have a serious design hazard: you could build a huge codebase with no conflicts, but then you suddenly need a simple trait impl somewhere, and the only way to solve it would be to redesign the entire application. So trait impls are 'open' by design.) You might want to look into the specialization feature, because it gives you tools to resolve some of these conflicts.
Can you say a bit more about what you're trying to accomplish? There is no need for your `mutex` global, and something similar to substring is already available if you don't care about Unicode. (If you do care about Unicode, your `substring` will most likely not work).
More like flappy bird or Zelda yah
I had the same reaction, but IMO, postfix field seems too much like magic. Accessing a field shouldn't have "spooky action at a distance." postfix method is preferable, if postfix is the path that is gone down.
Sorry, can't really solve it, but can explain what's going on. - it's not clear how lock is useful there in the first place - taking lock 2 times around loop + for each char in loop, that's definitely wrong - something along `let s = String::from(self[start..end]);` can replace the loop altogether - the issue you posted basically says that you can't return something while it's locked Ways to consider for workaround: - return mutex, caller will unlock and access content if needed - return copy (I'm not sure how to do it with `&amp;str`, but it's easy with `String` type)
I wonder, how many of the developers working on Amethyst have experience working on a successful commercial game, or a major game engine, or in a professional game studio? Also, I am happy to hear that Amethyst will be doing the dogfooding efforts. I am a strong believer in "if you haven't made anything useful with your own library, it is unlikely that anyone else will". There is a reason why the major successful game engines started as a game first. Someone actually made a successful game and then took the code from it and turned it into something more general and usable for other games. Code needs to be purpose-built. If you just try to write general code without using it for anything in particular ... you just end up with code that isn't actually very useful for anything in particular.
From what I understand, your best bet would be to just build your application on CentOS 7 (or older), for example in a Docker container. (The Rust compiler is built on CentOS 5 for old-libc compatibility, IIRC).
Normally, you'd do it like this: fn main() { let somestring: &amp;str = "gecko"; println!("{}", somestring.chars().take(4).collect::&lt;String&gt;()); } It's far faster than what you're doing. If you want to play with Mutex anyway, recognize that what the mutex owns isn't yours to reference arbitrarily. That's what Mutex is for. So, you can't just take a ref to the thing the mutex owns and return it. Instead, you'll end up returning a reference to the mutex itself, or maybe the MutexGuard. I think it's also problematic that you're calling lock several times. I don't think that's what you want. If the whole static/mutex rabbit hole is there so you can return an &amp;str rather than String, you should just slice self: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f54618301d5a718f88bea171a7d3aa58
No he was correct. I said something wrong, that has now been edited out.
\&gt; Am I right in saying that once we have created an instance of a struct, we can no longer change the SharedPointerKind from an Rc to an Arc? &amp;#x200B; Yes, you cannot change that. The idea is that you either commit to \`Rc\`/\`Arc\` or you parameterize the \`SharedPointerKind\` to delegate that decision.
Right. A binary that was originally linked with an older glibc can also run with something newer, but not vice versa.
Perhaps it might be useful for code generated by some crazy macros, to hide implementation details in there.
Sure, I feel the same way. I think the reason for the initial pushback is that the MVP rustaceans have Rust in the forefront of their minds, they know about all places the rust ecosystem touches, and having everything in as few places makes their life easier. So they're resistant to change that makes them slightly less efficient temporarily. But for people who use and know their platform more/better, rust is just one sub-ecosystem that should integrate and play nice. So the people whose voice is most important have the least understanding of the benefits.
Could you give some examples of things that are postfix in Rust but not in other languages? There's `?`, but as I mentioned I don't find that a particularly strong example because error handling always comes after the call.
I'm trying it out right now, is there any easy way to draw text?
It should be fine. Remember, that's how Flash games used to work :) Pathfinder is designed to make the case of rerasterizing vectors from scratch every frame fast.
All the pieces are thereโ`font-kit` for loading the fonts, `skribo` for laying out the text, and Pathfinder for rasterization. But I haven't gotten to wrapping it all together in a simple API yet. It's probably my next TODO :)
I have an off-topic question: Do you know how hard it would be to adapt your SAT solver to find a satisfying assignment with at most k true variables for some k (then the other variables have to set to false)? I guess it would make most of the search strategy obsolete.
Fixed in the post, thanks.
Fair. I can tell I'm toying around with something that would be "brittle". I am still not sure I understand why Rust compiles this in the `State&lt;T,T,F&gt;` case but not the `State&lt;T,F,F&gt;` case. I agree that specialization seems like it might solve this problem... maybe. It doesn't seem like its actually implemented, though. Perhaps I can achieve my goal another way? Ultimately all I really want is some trait Advance which is implemented by every `State&lt;_,_,_&gt;`, but depending on which patterns the arguments match, some associated type changes.
You'll probably have more luck with gir: https://github.com/gtk-rs/gir/ That's how all other binding crates of glib-based C libraries.
So I'd have to have large pattern matches just to access methods that are shared by all variants? That seems a bit hacky, don't you think?
Thanks!
Next step: an in-browser WASM version via canvas. ;)
wasm bindgen should be forked with a goal to KILL JS.
Note that there's not really a need to explicitly render to a texture, because Pathfinder works by generating tile images. You can just save the tiles and blit them over and over between frames. Note there's not a good API to do this yetโit's mostly a question of figuring out how best to handle it. The biggest issue is that if some parts of the scene are moving while new objects are being created, then you have to cache some tiles while invalidating others. This means you need some sort of malloc for tilesโa *concurrent* malloc, in fact, because Pathfinder generates tiles in parallelโwhich is, needless to say, hairy :)
I found a workaround for now. For some reason, the associated type `Not` was screwing everything but, but a wrapper type `Not&lt;_&gt;` where `Not&lt;T&gt;` implements SomeFalse compiles just fine.
I'm coming from Rust with a Python background, so this doesn't seem that novel to me. My normal thoughts with Python: * Building packages with dependencies on third party libraries means you are downloading and executing third party code. Take any normal mitigations in your build environment to handle this. E.g. run as restricted user, locally cache versions of the libraries you have checked, think about network access, etc. * If shipping a production product really check every single dependency on your dependency tree
You can encode at-most-k constraints compactly as CNF, so you wouldn't have to change anything at all :) Unfortunately there are many different ways to encode such a constraint, and the best one likely depends on the problem you want to solve. I find the encodings also not that straight forward. I'm aware of a [paper that compares some](https://www.it.uu.se/research/group/astra/ModRef10/papers/Alan%20M.%20Frisch%20and%20Paul%20A.%20Giannoros.%20SAT%20Encodings%20of%20the%20At-Most-k%20Constraint%20-%20ModRef%202010.pdf) and [another paper](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.182.1394&amp;rep=rep1&amp;type=pdf) about encoding linear equations over boolean variables (called pseudo boolean, which has at-most-k as a special case). It would also be possible to add at-most-k and general pseudo-boolean constraints to Varisat. It wouldn't change the search strategy at all, it would only affect the propagation code. Far out in my roadmap I plan to add a constraint API that allows adding custom constraints. For pseudo-boolean constraints I think it might be worthwhile to have builtin support so that might arrive earlier. There are still many many other things I want to do first, though, so I wouldn't wait for that. If you don't mind using a non-rust solver, AFAIK [google's cp\_solver](https://developers.google.com/optimization/cp/cp_solver) is a CDCL SAT solver that natively supports pseudo-boolean and other constraints and is actively developed and maintained (although I haven't used it yet).
NPM is for losers who love JS and have no brain to see why JS MUST BE discarded, see most humans are like you , Pathetic and absolutely shameless about being brainless, thats why JS survived this long. you sick sheeple!
Regardless of the security implications (which I admit, are less than stellar, but at least the Public Suffix List has a history...), I'm actually less enthused about the fact that the behavior of the library potentially changes on each build -- builds should be hermetic and reproducible. The security issue here would then be moot. The right way to handle this is to issue point releases when the Public Suffix List is updated, distribute the list already embedded in the library. Control that with a feature flag so folks can avoid including the default list if they want and use their own list. This way, the only person taking the risk is the person downloading that version of the list, and that'd be an excellent time to apply data validation to eliminate that risk before compiling the library. At the very least, include the Public Suffix List as a submodule (this is what we did at my last company.) The build process would bump the library version if the submodule had updates. (https://github.com/publicsuffix/list is the repo version of this.) This is a good example of when data should be versioned.
Thank you for your detailed answer :) I'll check out the links you provided
Thanks!
Its much better than python-tldextract which downloads that list at runtime! And it tries to save it where its installed (a packaging headache).
their tutorial clearly asks to install node, these Mozilla monsters have no idea how much we Genius guys HATE NodeJS after JS. The advent of Node was an epitomity of intellectually bankrupt among humans world wide, bloody remnants of evolution.
...or, if you're not linking against any C libraries, using one of the `*-unknown-linux-musl` targets would be an easy option. Those statically link [musl libc](https://www.musl-libc.org/) into your binary so that the Linux kernel's syscall interface is the only external dependency and the musl targets Just Workโข for pure Rust projects once you've used `rustup target add` to install them.
I don't understand any of this but I feel smarter after reading all of it anyway.
About 5+ of us have or are still working professionally in the games industry. Iโd say Amethyst right now is best suited for the โespecially interestedโ. If your game design greatly benefits from ECS then youโd probably still benefit from being an early adopter. The impending 0.11 release will be a good time to jump in.
I would still just use an external test framework. I've had my own test framework for a long time in my C++ code base, and it works just like I like it to. It also completely separates tests from testing code, and it creates very nice reports that can be for human or automatic evaluation in a well defined format. I'd likely do the same in Rust. I might use Rust's stuff for some bootstrapping tests of the very lowest level code I guess. And I'd sort of argue that, if you have full coverage of the public API, anything that isn't getting tested internally can be removed because it never gets invoked by actual usage anyway. I can understand the argument of maybe testing them separately, but ultimately the only usage that counts is usage that can actually occur in real applications.
If you really want such a target, you could build a cross-compile toolchain for that. It'd be much harder than using docker or lxc or the like.
Does this work: `self.fields.iter_mut().map(|x| &amp;mut **x).collect()`
it means you have no idea how many of us are waiting for the fall of Node so that we can do webassembly without being insulted at every compile.
Before using lazy_static in something you expect to be a library be aware of the way rust resolves dependency hell: it bundles both versions and mangles names. So something you expect to be a singleton, might in fact be two or more singletons ignorant of eachothers but still operating as if they were alone. This sometimes is better than the alternative, sometimes worse, but always uncertain to a user of the lib.
Box implements `as_mut`, which should do what you need: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6a08a44ca77c23a403571831ad9e95b6
Very nearly! The lifetimes didn't line up, apparently the type inference isn't smart enough to shorten lifetimes automatically, and storing the buffers in a `Box` made them `'static`. That said, it wasn't hard to fix! fn fields_mut&lt;'a&gt;(&amp;'a mut self) -&gt; Vec&lt;&amp;'a mut dyn ParsingBuffer&gt; { self.fields.iter_mut().map(|f| &amp;mut **f as &amp;'a mut dyn ParsingBuffer).collect() } Thank you so much!!
Itโs about consistency. Check out the pep8 for python. People will rage on you with the discussion of 3 versus 4 spaces. When code is consistent people like it because it increases readability. Spaces versus tabs are less issue than no indenting however.
&gt; I think an example showing implicit await and explicit deferral is worthwhile. I strongly feel it's been dismissed out of hand because of questionable reasoning about what constitutes surprising behavior. I _could_ add a branch with another syntax -- the repository is not official, and I have no connection with the lang team -- but I wouldn't like to second-guess them, and I don't think that there's appetite for reconsidering anything outside of what's in the writeup, which is why I've asked the contributors to stay within its limits.
Great success! That works, thank you! Do you have any intuitions as to the tradeoffs between this approach and the one /u/diwic suggested?
I actually hadn't checked the itinerary yet. (Work, life etc) Linux from Scratch in Rust, eh? Interest level: piqued
If it's doing visualizations, then a screenshot in README would be in order. :)
If you're doing elapsed time measurements, please use [`Instant`](https://doc.rust-lang.org/std/time/struct.Instant.html): let start_time = Instant::now(); ... let elapsed_time = start_time.elapsed(); I notice similar issues in your [async template](https://github.com/trezm/thruster-cli/blob/a68e177f5d6cfbd2f2b4c7cd4c29a6fb18c50a34/src/main_async.template.rs#L36).
I agree! However, in this case the visualisation part is on user's side - they choose and set up the plotting library, Plotka only hosts the files in the directory specified by the user. I don't provide any default JS script so there's nothing to show until the user hosts their own script. I will consider adding some demos though.
The point of having the internal unit tests is to manage complexity by allowing you to test stuff that may be difficult or awkward to trigger externally (eg. error cases where you trust that the higher-level glue will deliver them correctly, but the runtime quickly adds up if you have to run through the whole stack rather than testing the delivery once or twice, then using tiny unit tests to quickly check all cases which could be delivered.) There's actually a blog post about the Django web framework for Python which I've run across a few times which encourages people to cut apart the ready-made infrastructure for exactly that reason. (To test smaller pieces so your tests run more quickly.)
Yes unfortunately this limitation applies to all built-in derives AFAIK.
Or you implement the method in the enum itself that does the matching. You can also use a Trait object. Maybe box it .
If you don't need to link against other system libraries then musl target (`x86_64-unknown-linux-musl`) may work. It links libc statically and creates self-contained executable.
I recommend looking at the generated assembly (in release mode) to be sure, but I'm pretty sure they're the same. The source code for [`Box::as_mut`](https://doc.rust-lang.org/src/alloc/boxed.rs.html#859-863) definitely suggests that. As to why the lifetimes are mismatched and need a cast, I am unsure.
&gt; The source code for Box::as_mut definitely suggests that. Lol, yeah it does.
Awesome! That worked! Thank you!
Thanks, this is a really helpful way to compare. My thoughts on each one: * The current `await!` macro isn't bad, but a little heavyweight * `prefix-sugar` feels like too much magic * `prefix-mandatory` isn't bad, but a little heavyweight * `postfix-field` just feels wrong, no thank you * `postfix-whitesace` just feels wrong, no thank you * I actually like `postfix-method` the best. It flows well reading the code. You initiate an action, then you can either wait on it now, or store that future away somewhere and wait on it, poll it, select on it, or whatever else later. While `await()` does affect the control flow, and so isn't really a method, in a lot of ways it behaves in context like a blocking call within the control flow of the `async` method. It doesn't really feel that much different than a `sleep()` call, or a `select()` call, or a `pthread_mutex_lock()` call, or the like; these all have the effect of suspending your current computation until something completes, they just happen to do so on the thread level rather than as part of an asynchronous coroutine in the language. So I'd rank them as: * `postfix-method` is my preference * `await!` macro is OK * `prefix-mandatory` is OK * `prefix-sugar` is too magic, I'd prefer something else * `postfix-field` I really don't like * `postfix-whitespace` I really don't like
Wasn't `?` the first postfix sigil and it was a big deal for that reason? Lots of code can be written postfix style but that is the flexibility of traits not a fundamental syntactic choice best I can tell.
`sed -ne '$s/(.* )?([^ ]+)$/\2/p' ~/.xinitrc'`
[discussion moved here](https://www.reddit.com/r/rust/comments/bkkwk2/conflicting_implementations_of_trait_false/)
Eh, I probably could have organized it with multiple files in one branch, but then it wouldn't have been possible to use GitHub's Compare view to see the diff between variants -- AFAIK that only works across commits. A quick way to open the same file in two branches is to open it in one of them, duplicate the tab, and select another branch from the drop-down in another tab. That's two extra clicks.
Non-sigil, non-\`await\` alternatives (e.g., postfix \`await\`) would need to be in a new edition, likely 2021 at the earliest.
You beat me to it, damn it
just in case anyone stumbles across this in future, the final reviewed guide ended up at https://matrix.org/docs/guides/moderation
*dr\_evil.gif*
Prefix await with sugar looks pretty good in my opinion. You can still use parantheses if you'd like and the `await? ` is just a nice bonus in some cases. Also, verbosity is not an argument since `(await x) ` is just 9 characters, while `await!(x) ` is also 9, `await {x}` is also 9, and `x.await!()` is 10 characters. There is also little chaining in the pieces of code, so I am not sure if that is a strong argument.
`sed -rne '$s/(.* )?([^ ]+)$/\2/p' ~/.xinitrc`
Rust is a very fast-moving language. Of all of those issues, only few are "bugs" in the sense of the language being broken (I-unsound and I-ICE, denoting memory unsafety holes and places where the compiler crashes). The rest are improvements, feature suggestions, and slow or high memory usage issues - in other words, ways the compiler or language can be improved, not ways in which it doesn't work. Rust provides very good stability gurarantees. With very minor exceptions, any code written for Rust 1.0 will still compile today.
Issues are just one way of managing a project. They're used to track feature proposals, bug fixes and even Q&amp;A in some projects. They're not some stability yardstick. There are three release channels for Rust currently. Each is promoted to a more stable channel given enough testing and time has passed, so if stability is your thing 'stable' is what you want. There's also 'beta' which I suppose just works as a stopgap between stable and nightly where fixes are routinely merged in, and of course 'nightly' in which more cutting edge features can be enabled.
Not necessarily. Issues arenโt all bugs or errors, sometimes theyโre feature requests. Just look through some of them. Also take a look at Pythonโs issue page, they have around 7000 issues logged on it. https://bugs.python.org You can even consider them a good thing. It means people are actively using your product or service and are willing to contribute by pointing out errors.
You can look at other big projects, for example: clang 6265 https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;limit=0&amp;no_redirect=1&amp;order=priority%2Cbug_severity&amp;product=clang&amp;query_format=specific gcc ~10000 https://gcc.gnu.org/bugzilla/buglist.cgi?bug_status=__open__&amp;limit=0&amp;no_redirect=1&amp;order=priority%2Cbug_severity&amp;product=gcc&amp;query_format=specific
I'm honestly extremely surprised that everyone has such different opinions. In my view, this code sample makes a strong case for any postfix option. It's so easy to see what's being awaited on. I think the prefix-sugar option is the hardest to read. The right-and-left reading and parentheses make it hard to see when exactly await is being called. Surprisingly, with braces, it's not so bad. The concept of `await?` is kind of ruined whenever you want to use `.context` on a result.
No, I'm not sure, maybe it's even a compiler issue? But you can shorten it to `&amp;mut **f as &amp;mut _` if you wish. ๐
Is there a way to determine at compile time if there an extern function exists? For example, this will just panic on platforms without `isatty`: use std::os::raw::c_int; extern "C" { pub fn isatty(fd: c_int) -&gt; c_int; } fn main() { unsafe { isatty(0); }; } Is there a way to prevent the error and use a fallback? (`isatty` is just an example)
Then the title is misleading, as it doesnโt have anything to do with visualization and is not making it easier. Something like Google Charts does, as example.
IMHO, their TechRadar is pretty bad, with plenty of really dubious technology choices.
Any updates?
I couldn't come up with a better title. I wanted Plotka to make displaying data in browser easy and it does (at least for me) but I know it's not the best way to describe what it is. Sorry for that. I can't change the title now but if you have any better idea I'll change it in the repo.
I believe you're looking for /r/playrust. This is the subreddit for the Rust programming language.
Yes of course, I'm just not very familiar with wasm web projects so I was wondering how that ties in to things :)
Great point!! Just updated the main repo and published the change to the cli. Thank you!
&gt;\#rustic I'm afraid it's not related to the game either, a better fit would be [/r/palletfurniture/](https://www.reddit.com/r/palletfurniture/)
Yeah it's pretty crazy we published so soon after one another. I must admit I also had a good look at quirc for some of the error correcting stuff, unfortunately the spec is pretty hazy about it in some parts... The image size thing is mostly optimisation. A smallish QR in a huge image can still be found, it just takes "ages" ;)
Does that mean Rust is one of these dubious choices too? Itโs certainly fair to claim that if it would be paired with an argumentation.
I only worry about projects that have very few or many but mostly dated issues. It is an indication that the project is dead, no longer maintained. Having many new issues mean that the project is alive.
Right you are.
They're functionally equivalent. `String`s are heap allocated and as with any other item that implements `Drop` are freed once they go out of scope. The only actual difference between the examples you gave is when this call is made, which would be at the end of the `main` and `helper_function` for the first two respectively and before the `// other stuff` portion of your third, but there's no significant overhead either way. As for the semantics I would probably go with the former, unless the computation is very self contained and complex enough to warrant its own unit in which case I would prefer the second option. Nested blocks are fine if you want to avoid polluting the outer scope.
Well their Radar is full of really bad bets. For example, they went 'all in' with Ruby even admitting that Ruby is slow but that slowness is "irrelevant". If you look at their radar across several years, you'll notice there's no system to their choices beyond the "ooh, shiny!" approach. Which I suppose is okay for a consulting company where different teams can just work on whatever they want to work on so long as they are enjoying it. I'd argue that a consulting company's 'radar' is of limited use to, say, a product company that needs to select a set of tools and stick to them for years, if not decades. When your products don't change you get more value from being able to hire and grow expertise in a few 'boring' areas such as C++/C#/Java rather than fiddle around with weird tech that you might not even be able to deploy to customers because, e.g., you're making thick-client apps.
Thanks a lot for the clarification, I found it very valuable! To me, the tech radar is as diverse as Thoughtworks is.
If I'm seeing your intended update, it's still backwards: &gt; A reference of an object that implements `Send` is `Sync` and the other way around. In other words, `T: Send` implies `&amp;T: Sync` and `&amp;T: Sync` implies `T: Send`. It should be: &gt; A reference of an object that implements `Sync` is `Send` and the other way around. In other words, `T: Sync` implies `&amp;T: Send` and `&amp;T: Send` implies `T: Sync`. If it helps, think about the fact that `&amp;T: Copy` too. When you `Send` a reference to another thread, you actually just give it a copy, and you still your own have access. Thus the type behind the reference must be shareable among threads -- `Sync`.
Great to hear that. I had a quick look into the issues but couldn't figure it out the labels if they were bugs, features or improvements. I'm looking forward to dig deeper into the language.
You are totally right. I missed that (Q&amp;A and proposal in the github issue section) for a minute. Makes total sense.
We have a partial pretty printer back to C sources, but it's not complete and may never be unless that is a priority for someone else to implement. We don't have any APIs for modifying the C AST, but that's something you could build on top of the basic data structures. &amp;#x200B; Yeah... a nice C AST library built on a Rust version of the clang AST would be ideal, but I don't know of one (yet).
Yeah, definitely. The question is it was stable enough was more because I couldn't understand well the issue labels to se if we're a bug, improvement, feature request and etcetera and to thing rust is relatively new in the game. But I'm learning a lot about the ecosystem of rsut here, besides the downvotes in my question. Hehehehehe
You're totally right! The number of issues came up in a discussion with some friends and that was my first argument with them, but as I'm new to the language came here ask to make sure.
I've never read about returning from scoped code anywhere. Can I write something like this? // stuff { if foo { return; } // skipped } // continue here also: is there a case where you would recommend this over a function? let foo = { let a = bar(); baz(a)?; Ok(a) }
Ha! I was thinking the same ๐ค
Found it: https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bd2df6e57d33be4d31d0ce3a5f6c7e50
Thanks! I went back to play.rust-lang.org on the same computer and it was still there: https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bd2df6e57d33be4d31d0ce3a5f6c7e50
&gt;trying Does not rocket support websockets?
Need a better website design!
The standard library's threads don't have a way to guarantee that the child threads join at a certain point, so as far as it knows `arr` could go out of scope while the other threads are still doing stuff with the chunks. If you're just reading you can put it behind an `Arc` and pass a clone to each thread, then have each thread look at a different offset to do its work. If you're also writing I'd pass out an `Arc&lt;Mutex&lt;T&gt;&gt;`, keep a local buffer on each thread, and then at the end have it lock that mutex once to write all of its data back at once.
&gt;The standard library's threads don't have a way to guarantee that the child threads join at a certain point, so as far as it knows arr could go out of scope while the other threads are still doing stuff with the chunks. If you're just reading you can put it behind an Arc and pass a clone to each thread, then have each thread look at a different offset to do its work. If you're also writing I'd pass out an Arc&lt;Mutex&lt;T&gt;&gt;, keep a local buffer on each thread, and then at the end have it lock that mutex once to write all of its data back at once. Thanks for the response. I am going to be writing into it. I noticed you mentioned looking at different offsets, so would using chunk not work? Is there a way o wrap each chunk with a an Arc, then unwrap each Arc getting a mutable reference to the arc?
Ah yes, thank you!
thank you :}
Thanks for the kind words @etaoins :). Took a look at arret, and it looks great! Can't wait to go deeper.
Specialization requires the nightly compiler and `#![feature(specialization)]` annotation. What you'd do is `impl Advance for State&lt;_, _, _&gt;` to provide a default implementation for everything, then specialize it by giving more refined implementations for the parameters you want it to behave differently for.
Thanks for advice phil\_gk! I'll update the post with the changes and a note of thanks :)
Go on r/playrust plz
Not without `unsafe`. There might be a crate that provides a derivable trait that lets you view one type as another, but if there is, it would have to use `unsafe` under the hood.
That's cool, I didn't know that `Instant` was a thing. &gt;here is no method to get "the number of seconds" from an instant Isn't that exactly what the `elapsed` method does? https://doc.rust-lang.org/std/time/struct.Instant.html#method.elapsed
Issues are probably a better measure of popularity than they are stability.
`rowan`'s [`TransparentNewType`](https://docs.rs/rowan/0.5.0/rowan/trait.TransparentNewType.html) does exactly this, actually. If you have a `#[repr(transparent)]` type, it's safe to `mem::transmute` between the wrapper and the contained type (transitively, even). I don't think any current newtype-utils crate offers this yet, though.
Glad you found it n\_girard :) -- the final gist is essentially the entire github repo, so I thought best to keep to gists
Cheers Gray\_Jack\_, and thank you :)
From a type perspective, you can convert them using a `mem::transmute` as long as you have `#[repr(transparent)]` on `Row` and `Column` so that they have the same layout as an `isize`. From a safety perspective, that might violate LLVM strict aliasing rules - I'm not 100% sure about it, though. You probably shouldn't `transmute` except as a last resort.
If thread-local behavior is acceptable: thread_local! { pub static STRING: RefCell&lt;String&gt; = RefCell::new(String::new()); } pub fn main() { STRING.with(|string| { let mut string = string.borrow_mut(); string.push_str("hello"); println!("{}", string); }); } If sharing across threads: lazy_static! { pub static ref STRING: Mutex&lt;String&gt; = Mutex::new(String::new()); } pub fn main() { let mut string = STRING.lock().unwrap(); string.push_str("hello"); println!("{}", string); }
&gt; That's cool, I didn't know that `Instant` was a thing. I liked it so much I [ported it to Ruby](https://github.com/Freaky/monotime). &gt; &gt; there is no method to get "the number of seconds" from an instant &gt; Isn't that exactly what the `elapsed` method does? They mean the underlying value it represents. e.g: Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond) =&gt; 7541021384119939 That corresponds to the number of nanoseconds since the OS booted, but that's just an implementation detail, it's not documented as such. But take two calls to the same clock and you can calculate a meaningful *difference* between the two, which is what `elapsed` provides.
You probably want /r/playrust.
its a guilty pleasure these posts
It's not exactly the same. 3D games use polygonal meshes, which the GPU has native support for rasterizing. SVGs use complex curves and color gradients, which need computationally complex conversion into polygons. The biggest problem with rendering vector images real-time is that while a polygon mesh does not typically change its mesh topology frame-by-frame (the mesh data stays in GPU memory, while the much less complex [skeleton](https://en.wikipedia.org/wiki/Skeletal_animation) gets manipulated to implement animation), an animated svg would probably need to send a completely new geometry every frame. Considering the biggest performance bottleneck in GPUs is usually sending data to and from the GPU, that makes pre-rendering SVGs to a bitmap texture a no-brainer.
&gt; Is there a way o wrap each chunk with a an Arc, then unwrap each Arc getting a mutable reference to the arc? Each `Arc` needs to own the thing that it's pointing to. You can't have multiple different ones each "owning" different parts of the same allocation. &gt; Also anyway you can give me an example of getting a unique offset? I don't think Rust has an easy way to get a unique id per thread (that starts from 1..n) Declare a variable inside the loop, then capture it as part of the closure's environment. So something like for idx in 0..num_chunks { threads.push(thread::spawn(move || { for p_acc in arr[idx*chunk_size..(idx+1)*chunk_size] { doSomething(); } }));
Looks good overall. A couple little things: When you have a function argument of type `&amp;String`, it's conventional to take `&amp;str` instead. A real `&amp;String` will automatically coerce to a `&amp;str` (a "deref coercion"), and the latter gives you the option of accepting other types of strings as well. For example, a `&amp;str` could be a static string, or it could be a reference into a buffer of raw bytes extracted via `str::from_utf8`. You probably don't want to use `unwrap()` in your command parsing. You're going to want to make a parse error recoverable, and that means returning a `Result` instead of panicking on errors.
I mean, stable comes down to how you define it. Python is considered stable yet I just went through a semi painful process to upgrade python code to version 3, and each point release adds backwards incompatible features (I consider this careful forward movement to be a good thing) Rust will be the same way, possibly more so even. That said it's "1.0" according to its developers and that's good enough for me to consider it "stable"
On Linux there's `libc::dlsym`. You can see it in action in the standard library: https://github.com/rust-lang/rust/blob/1.34.1/src/libstd/sys/unix/weak.rs#L67 Other than that there's the `#[linkage]` attribute, but I think it's nightly-only? https://github.com/rust-lang/rust/issues/29603
'Return' was actually the wrong term in this case, since you're not actually returning anything, instead the entire block evaluates to its last expression. So you can't return from/break out of arbitrary blocks, at least no on stable _yet._ There is an RFC in the works that would allow you to break out of named blocks, which is very similar to what you asked about. Your example would look something like this instead, // stuff 'label: { if foo { break 'label; } // skipped } // continue here you can also return values, // stuff let _: usize = 'label: { if foo { break 'label 42; } // skipped }; // continue here As for the second question, considering what I mentioned above (the `?` operator will return from the function), then yes, I would definitely use that over a separate function (minus evaluating to `Ok(a)`, you can just have `a` as the last expression). Again, depending on the complexity of the block and its versatility and so on. But you have to keep in mind that the block won't evaluate to some `Err` if `baz` fails as if it were in a separate function, so in this case the two aren't functionally equivalent.
I'll give it a try. I'm using libm currently, but don't need high precision. Thanks for writing this.
This is not possible, which is a Linux bug. (There is no such problem on Windows and macOS.) https://github.com/rust-lang/rust/issues/57497 has details.
Ok thanks. So about if "doSomething()" mutated an array, I am having trouble mutating arr. Is having a local buffer the only way? It seems pretty inefficient, is there some work around with this?
Is there a way to just have all of the crates within a workspace get the same version? It won't ever be worth having them separately versioned since they'd never be delivered other than as a whole, and having to go through lots of them and change that would be an error prone mess.
That's a lot info. I appreciate that you took the time explain all of this. Thank you. Also, sorry for the late response. Today was the one day I just happened to be busy.
And why, oh, why doesn't Rust have exceptions? If you write lots of general purpose code, where none of that code in any way really cares what went wrong, it just wants to clean up and pass the error up the chain to domain/program aware code to deal with, exceptions are immensely useful and a clean way to deal with errors. Given that Rust already has scoped based cleanup, there's no advantage to not having exceptions. And I don't think that having all cleanup being done by objects going out of scope (which have no real larger view of what has happened) is just not a good thing. But, without exceptions, there's no single point of cleanup at the end, and you'd end up with the horrible old 'one exit point' scheme. With this and the lack of formal constructors, I just think Rust is trying so hard not to be C++ that it's causing itself more trouble than benefits.
The borrow checker won't let you give mutable borrows to the thread because it can't guarantee that the thread joins before the main thread destroys the original collection. If you use `Arc` to let each thread keep that collection alive, then it still won't let you mutate it without atomics or a mutex because it can't tell that you're accessing disjoint ranges. If your program makes sure to join them and to prevent two threads from accessing overlapping ranges, then you can use `unsafe` code and raw pointers to give them access to the data. At that point I'd rather just use a library like crossbeam or rayon to handle the data sharing, though.
*Jake And Amir Deep Pull* That's a bad amount of crates, dude
`await!` seems pretty clearly more "Rusty" to me than anything else. I do not understand at all, honestly, why there is so much debate about this. Are people obsessed with the idea of async being some kind of "special" *language-level* feature or something? Who cares, as long as it works?
&gt; I'm not sure I understand the benefit other than to say we have an await keyword. There's not one.
You probably want /r/playrust unless you mean the Rust programming language.
Yeah I meant playrust thank you.
Not really a question, I'm just looking for a project to contribute to. Gamedev-related would be a plus. If you're looking for a contributor, hit me up!
Just an average `node_modules` download, we can do better!
Ahhh that would make sense to do a `&amp;str` instead of `&amp;String`, because `&amp;str` essentially references a `String` right? So it wouldn't make much sense for a `&amp;String`
The funny thing is that if you just post the question you'd probably get helpful answers or something but this definitely isn't the way to get work done for you :3
Iโll do it for 8 reddit gold
\`.name\` is for fields and methods, use a keyword as postfix feels totally absurd.
For those who will look for `concat_bytes!` macro, you can use [`byte_strings::concat_bytes`](https://docs.rs/byte-strings/0.1.3/byte_strings/macro.concat_bytes.html) which uses procedural macros under the hood. There is also an [RFC 2509](https://github.com/rust-lang/rfcs/pull/2509) which proposes to extend `concat!` macro to accept byte arrays.
Got 3 messages :) "for me", you mean hiring someone? It's of course definitively a way to get work done for me...
Thanks for sharing
&gt;I'm coming to Rust with a Python background, so this doesn't seem that novel to me. My normal thoughts with Python: &gt; &gt;Building packages with dependencies on third party libraries means you are downloading and executing third party code. Take any normal mitigations in your build environment to handle this. E.g. run as restricted user, locally cache versions of the libraries you have checked, think about network access, etc.If shipping a production product really check every single dependency on your dependency tree You are right, thanks for sharing. That's because you already know the risks involved, but there are many people who don't know the risks. For example, someone else submits the server password to GitHub.
The Post meaning is that it is very necessary to be vigilant.
No news yet.
/shrug Glad it worked out for you
Yeah `&amp;str` references any contiguous slice of valid UTF-8 bytes. Those could live in a `String`, or be compiled into the binary itself (string literals like `"foo"`), or be parsed/validated from any slice of bytes from any other source. Notably, a `&amp;str` could be a _substring_ of any of the above also (for example from `str::split`), while `&amp;String` always refers to an entire independently allocated string. The only reason I can think of to take `&amp;String` would be if you want to check `String::capacity`, but you didn't want to actually mutate the string. Kind of a weird scenario, but I'm sure it's happened somewhere :)
I should make a note that I take requests for any unimplemented operations called out in the README. I can take a look at `powf`
 await { wlan_svc.list_ifaces() }.context("error getting response")? I think prefix-mandatory looks great. Postfix is a nice idea, but all proposed syntaxes so far are just too hard to read. You would still need some kind of syntax like prefix-mandatory's `{ }` to make awaiting stand out.
The [`ref-cast`](https://github.com/dtolnay/ref-cast) crate provides a safe API for doing the conversion correctly. let i: &amp;isize = ...; let row = Row::ref_cast(i); // row is of type &amp;Row
This looks like an interesting approach: https://stackoverflow.com/revisions/40519989/5
What will you do for a simple upvote?
Postfix macro would be less magic, unfortunately it's not in this repo.
Sad there's no postfix macro version, which imo from previous discussion was the most popular.
I hope that counter is not stored as an `i32`!
did you look at [https://crates.io/crates/semver](https://crates.io/crates/semver)
Thanks for clearing that up. It's been a great bit of learning seeing these two approaches to the problem. Appreciate the help.
What are underscore lifetimes? I can't find any documentation on them.
```println!(โthis log happenedโ)```
Awesome, let me know if you have any questions! One of my aspirational goals is to split out my parser (currently [arret-syntax](https://github.com/etaoins/arret/tree/master/syntax) as a separate crate for use in other Rust Lisps. I think I'd want to make it use [codespan](https://github.com/brendanzab/codespan) first, though.
&gt;Are you mixing blocking and non-blocking (mio / tokio) code? I don't think so. What would put my code into non-blocking mode? What's even weirder is that it doesn't do this anymore after a recompile.
Is there somewhere a table that gives a rough overview on glibc compatibility among distributions? I ran into this problem AFAIR once, built a Rust binary on Ubuntu 18.10, but all the servers run 18.04 LTS (and will be for some time...) with an older glibc. So yes, binaries for server deployment have to be build in an older environment...
It's already possible to do this within the size parameter of an array: [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9dec5716d0806ae304d726901e88f076](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9dec5716d0806ae304d726901e88f076) &amp;#x200B; trait Foo { fn foo() -&gt; [u8;{ impl Foo for u32{ fn foo() -&gt; [u8;10] {[0;10]} } 10 }]; } While this is technically allowed,I would not recommend putting any medium to large piece of code as a const-parameter.
We should totally switch rowan to ref-cast
Crate Downloads, not crates* :)
Thank you!
&gt;I'm afraid it's not related to the game either "starter base" makes me think it is. :P
Underscores are used as "placeholder" names for things that require naming. For example, if you're implementing a function for a trait and you don't use one of the parameters, you can name it as `_: u32` to discard it. Same applies for lifetimes: you're creating a new lifetime, but you don't care what it's called. It's documented in more detail the [2018 edition guide](https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/the-anonymous-lifetime.html).
Cool, maybe a marriage with [https://docs.rs/flot/0.1.3/flot/](https://docs.rs/flot/0.1.3/flot/) would be useful.
Great idea. I didn't know about this crate. I think the best solution would be to release plotka_core library and let people use it however they want. What's your opinion?
Looks interesting! Would it makes sense to simply the approximate operations, and then pass a wrapper type (say `ApproxF64`) that uses those operations as a type parameter to an existing linear algebra crate? That way you would not have to implement all the vector/matrix/quaternion operations yourself. For example the [nalgebra](https://www.nalgebra.org/) supports `no_std` targets (see [there](https://www.nalgebra.org/wasm_and_embedded_programming/#for-embedded-development)) by using `libm` for those targets. Supporting a type like `ApproxF64` mentioned earlier shouldn't be too difficult either.
Why not use the [hex crate](https://docs.rs/hex/0.3.1/hex/fn.decode.html)?
Maybe https://www.reddit.com/r/rust/comments/bf65l3/evolution_island_amethyst_showcase_game_looking/?
hex\_crate doesn't output u64;4, I'd also like a native (without crates) function as I did for u8;32
You can use [byteorder](https://docs.rs/byteorder/1.3.1/byteorder/) to read a slice of u64s from a slice of u8s. If you're really set on implementing it yourself, you'll have to either use `std::mem::transmute` (unsafe!) or move the bits manually.
About your edit: yeah, it only makes sense for await to be a method if it's a (unimplementable) method of `Future`. But then you need to drop it as a keyword.
Wouldn't it be smarter to just directly do it in u64 instead of "converting"?
Well, every hex digit is a 4 bit value, so you can build an u64 directly from them if you really want to.
Yeah but I'm a bit confused about how to approach it (which was my initial question), i'd really like to avoid any transmute
It depends on the endianness you want to get, but generally it will involve an accumulator and then shifting said accumulator and adding the next digit repeatedly.
So much this.
I managed to solve the problem without lazy-static. I used a static `Vec&lt;String&gt;` to store the string in and I accessed it from there.
That depends. What are you using it for? Global state is generally a bad idea.
The GitHub issues aren't really how Rust changes anyway. Even adding a simple API first has to go through the formal RFC process, where people have time to comment on the proposal and it's often decided to not do something because there are more important things that should be added first. And even when an RFC is approved people have time to try things out on nightly before it's enabled on stable. Rust moves pretty fast, but also tries to move very deliberately. Breaking changes are a big no-no. They even have `crater` to test bigger compiler changes by recompiling a large percentage of all public Rust software to see if anything would be broken by accident.
I'm using it for global access to a mutable variable.
And why do you need global access to a mutable variable?
I need a globally accessible, mutable vector which I can store certain values in.
Why?
You didn't need a global variable in your string slicing code you posted yesterday. A local one sufficed.
The problem is that it breaks Rust's most important safety principle: Aliasing + Mutation should never happen at the same time unless the mutation is synchronized.
Because I need to store strings in it so I can manipulate them. It's hard to explain the rest. Here's the link if you need more info (My code is pretty bad): [https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=988227a024c27eb009174a6960ea6c48](https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=988227a024c27eb009174a6960ea6c48)
This code is different.
If you look at \`parse\_hex\_iter\`, here's what I think needs to change: * At the top it \`assert\`s that the length of the hex string is a multiple if 2, because you need two hex digits to make an entire u8. This needs to be changed, because you need more hex digits to make a full u32. * It iterates over the digits in chunks of 2, again because you need two hex digits to make an u8. You need more digits to make an u32. * Then finally it combines two hex digits into an u8. This needs to change as the current chunk now has more than two hex digits, and we need to combine them all into a u32. This will involve shifting them by bigger amounts than the 4 that's already there. One thing to watch out for is that \`from\_hex\_nibble\` returns an \`u8\`, which is inconvenient as you can't shift that very much before some bits fall off the end. Maybe just make it return u32 instead.
I'm confused. What are you actually trying to achieve with that code?
I had a quick google around and now sort of understand how this would work. Definitely something I'll keep in mind for a future project :D
Global mutable state makes the reasoning of code a lot harder. You canโt easily see what the inputs of a function are. Non mutable global state, which is initialised at the startup of the application and used at a lot of places, is somehow ok, but mutable one can be a big problem and shouldnโt be used in most cases and replaced by explicit arguments.
IIRC using static mut isn't thread-safe. You can use [thread_local](https://doc.rust-lang.org/std/macro.thread_local.html) which is thread-safe.
The manipulation of `&amp;'static str` , which apparently works because there are no errors and I got my expected output.
Yes, but _why_ are you trying to achieve that? Why does your string need to be static? Why are you reimplementing string operations that (mostly) already exist in the standard library? What is your end goal with all of this?
Ah, I see. That would not be usable on stable though (otherwise, while your implementation requires nightly, the API does not). Also, there might just be more general cases where the user has a bunch of operations they want to "fire" on this type-erased object (basically, an arbitrary trait/vtable). The approach should scale to that in principle, but at that point I guess you'd need procedural macros or so to implement it.
Well it could just be your local environment, If some program put stdout in non-blocking mode and it crashed or hit some other bug, it _is_ possible that the stdout filedescriptor for your session (e.g. your tty) was already in non-blocking mode before you even started the program. i don't think I've ever seen that happening, but it is a possibility in theory.
I usually don't have any specific reason for making all of this random stuff, I just find it fun.
You haven't really tested your code then, well, depending on what you'd expect. What happens when you say, let gecko = somestring.reverse_str(); let otherstring: &amp;'static str = "lizard"; otherstring.reverse_str(); println!("{}", gecko); If you actually want to learn Rust and not C with Rusty syntax you shouldn't try to fight against the type/borrowchecker (what's the point of learning Rust if you're just going to ignore it?). Leave out the unsafe calls. They're not needed for string manipulation, and I think you'll realize not only why what you're doing is super weird but why global state is awful in general.
Sorry..? I'm trying to fix it now. I did test my code, just not in the way that you did.
Alright yeah so here's the problem. As I pointed out in my comment above, the problem is unsynchronized mutation + aliasing. If I modify this program such that I store the result of reverse\_str and print it later, then that &amp;'static str is being mutated while it is aliasing it, and everything breaks. Click Tools -&gt; Miri in order to see it break: [https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=3d9f45aa2b8a3a3ff101b5e4be3afee6](https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=3d9f45aa2b8a3a3ff101b5e4be3afee6)
Well yes, that's what I'm getting at, if I understood your code correctly. What you're trying to accomplish cannot work with such global mutable state (at least not without jumping through some major hoops), so you should probably rethink your entire strategy (not using static string slices would be a major improvement).
Then I guess you can do whatever you want. I'd restructure it to be a struct that implements a trait though - that way you can avoid globals entirely.
I'll just avoid global variables, this is dangerous.
You got it! That's actually a bargain. I've seen way worse code for a much higher cost.
Thanks for the link!
Why not store it in a struct (or wrap it in a newtype) and have your functions be method on that struct (or newtype)? IMO the only time mutable globals should be used (in any language) is if their use is dictated by the environment or the libraries that you're using (e.g. `errno` in C).
I'm not against the practice itself, but aren't there boards for that kind of thing? I'd rather keep /r/rust for technical discussions, announcements and other "community" things. Your request is pretty much one-to-one and would be better suited to a market of sorts. If there aren't enough Rust coders on for-hire websites yet, maybe post it there first and _then_ link to it here, to get the ball rolling. IIRC, you could get an even better price if you ask the right place :)
A static item is similar to a constant, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. When a variable is marked as `static mut`, then it is allowed to be modified by the program. This can introduce race conditions that come from having mutable shared global state and thus requires `unsafe` to read or write to it. In your case, with the (code you linked here)[https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=988227a024c27eb009174a6960ea6c48], it looks like you're using that variable `VECTOR` as a means to creating a `&amp;'static str`, which is a fair conclusion to come to. Unfortunately, as already brought up, this means if you try to more than 1 of your functions in `StringManipulation`, then strings you returned from earlier calls will change unintentionally. This is because all of those strings are sharing the same backing buffer, that static `VECTOR` variable. I believe it would make more sense in your case to operate on `String` instead of `&amp;'static str`. Your substring function would instead look like: ``` pub trait StringManipulation { fn substring(&amp;self, start: usize, end: usize) -&gt; String; } impl StringManipulation for String { fn substring(&amp;self, start: usize, end: usize) -&gt; String { let mut new_string = String::new(); let chars: Vec&lt;char&gt; = self.chars().collect(); for c in start..end { new_string.push(chars[c]); } new_string } } fn main() { let somestring: String = String::from("gecko"); println!("{}", somestring.substring(0, 4)); } ```
Thanks for the link :)
You just need to adjust "parse_hex_iter" to work on u64 (chunks of 16 nibbles): pub fn parse_hex_iter(str: &amp;str) -&gt; impl Iterator&lt;Item = Option&lt;u64&gt;&gt; + '_ { assert!(str.len() % 16 == 0); str.as_bytes().chunks_exact(16) .map(|c| Some(u64::from_str_radix(from_utf8(c).ok()?, 16).ok()?)) } then adjust the caller(s) to match.
Put a semicolon at the end and we have a deal!
Hey! Any plans for arbitrary precision arithmetic? Iโve been working on making num_bigint work on no_std without alloc, but itโs more of a hack than a usable library :/
This sounds like a classic case of the http://xyproblem.info/.
Yes, but I needed to mirror the `env!("CARGO_PKG_VERSION_{MAJOR,MINOR,PATCH}")` API. I'd accept a PR that expands to a `semver::Version` constant though.
See https://github.com/rust-lang/rust/issues/53639.
If you use chunks() and from_str_radix() it's shorter and easier. Note that I used as_bytes() to convert the string into a byte slice on which chunks() works, and then back to a string with str::from_utf8 to use with from_str_radix. pub fn hex_to_u64(b: &amp;[u8]) -&gt; Option&lt;u64&gt; { let a = std::str::from_utf8(b).ok()?; u64::from_str_radix(a, 16).ok() } pub fn parse_sha256_to_u64(str: &amp;str) -&gt; Option&lt;[u64; 4]&gt; { if str.len() != 64 { return None; } let mut out = [0u64; 4]; for (idx, val) in str.as_bytes().chunks(16).map(hex_to_u64).enumerate() { out[idx] = val?; } Some(out) }
Yo that costs extra
Fighting the borrow checker with money?
Because having global mutable state is considered harmful in all languages. Java/C#/C++/Python/younameit drastically discourages you from having it. Rust is a small step forward because it can constraint it via type system, but it brings to new ideas here, just enforces old ones. And you know, you can write useful programs without mutating any variables at all. I know guys who writes Haskell programms in pure immutable fashion and they outperform C++ code doing the same thing. Worth thinking about it.
Global mutable state is a terrible idea in any program in any language. Rust rightfully call us out for it and forces us to use unsafe. If you truly want to write horrible software that people will hate you for then use lady_static! and race condition your way to infamy.
There is a lot more to software than just language syntax. Google โglobal mutable stateโ and start reading from the top.
Iโve switched to crossbeam as well. Iโd like to have the std updated to include better versions of some tools, crossbeam and parking_lot specifically for better channels and fair mutexes.
looks like it wouldn't be too hard. I hadn't heard of FMA before, since I'm not that into the math side, had to look it up. Just realized I can get away with powi, just libm didn't have it. That should be easier.
I've thought about making a `#[repr(transparent)]` wrapper for `f32` (something like `f32a` or `F32Approx`) like you suggested. That would allow the substitution of approximations when the crate is `#[cfg(fast)]`. It seems nalgebra does indeed link on a `thumbv7em-none-eabihf` target so that does seem promising. One problem though: here's the size difference when I try to drop it into my accelerometer demo. Before: 21232 bytes After: 102396 bytes The device I'm targeting has 512kB flash, so that isn't a showstopper, but that's a pretty big size increase (possibly trig tables, used vicariously through `libm`?) `micromath` is specifically optimized for a small code size, and one of the ways it does that is by avoiding constant tables, which I'm guessing is what's happening here.
Unfortunately not. I'm not sure what options there are for `no_std` bignums, but I'd probably suggest using libraries that specialize in exactly that.
In short, it's because it's very difficult to avoid UB with `static mut`. When `lazy_static` had UB due to use of `static mut`, what hope do rest of us have? Even `static` storing `UnsafeCell` is safer. If you really, really, really need a mutable global, considering using statics storing atomic integers or `lazy_static` storing a `Mutex`.
How about taking your string slice of hex and dividing it into 16 hex digit chunks, mapping those to u64 values and then taking those 4 at a time for [u64:4] values?
This is along the lines of my comment as well.
Why did all of my comments get down voted to oblivion, when I up voted literally every comment here other than mine? I think people should "strive to treat others with respect, patience, kindness, and empathy", like the code of conduct says.
Seeing this reinforces my idea that reusing field/method syntax is confusing, highlighting or not. There's [a fork](https://github.com/PrototypeNM1/await-syntax/blob/prefix-pipeline/bin/wlan/wlantool/src/main.rs) that mixes a bit of everything. I find the `@await` postfix syntax stands out nicely, chains properly and removes the confusion with fields. Postfix with mandatory delimiters works too (but that's just like the current await! macro, which is nice but incurs some noise when chaining).
Great, would appreciate a PR to add `powi`!
A couple bits of feedback: 1. Rather than manually parsing arguments, I'd use something like [structopt](https://github.com/TeXitoi/structopt). This should allow you to display a nice help message to users as well, indicating what the difficulty level options are, rather than silently using a default if they misspell an option. That said, I probably would use a default difficulty if they didn't pass any argument at all. 2. To your comment on passing the GameConfig to the Map::new function, try passing an &amp;GameConfig. 3. I'd create an enum of the allowed command options in command.rs, and switch on that in your main game loop, rather than switching on the
How advanced are we talking? Most things are covered in [The Book](https://doc.rust-lang.org/book/); language things that _aren't_ covered in the book are probably covered in [The Rustonomicon](https://doc.rust-lang.org/nomicon/), but it's not something you're going to reach for often.
The short answer could be "it's bad because it's unsafe." Then the follow up questions could go in one of two directions. - Why is it unsafe? Because the compiler has no way of proving that you don't get two `&amp;mut` references to the same data. - Why us unsafe code bad? Because you have to carefully audit it for memory safety, both when you write it and whenever you change it. (Not the end of the world of course, but it's a good reason not to write unsafe code when you can avoid it.)
What version of Rust are you using?
I am very harsh and wish I wasnโt. My original comment was simple, an expressed desire for more examples of how many functions and traits are meant to be used within the documentation. Nothing specific, not directed at anyone, just a general comment and feedback for for document authors. I was then called out a noob for not figuring out the obvious myself and lazy for not reading the rust book(s) thoroughly enough. How dare I ask for more examples, how rude and unreasonable of me? The only contribution I wanted to make was simple: more examples = more useful docs. That is all. The rest is BS, I didnโt even say I had a problem with it. I use the docs, std and 3rd party continuously without issue. Sometimes some help with how to use something as the author intended would be helpful, especially for people who are coming from other languages and donโt intrinsically understand rust idioms. All of my junior devs struggle with with it when they first start using rust in anger (except one but heโs not human). They read the docs like they are C functions or C++ classes and follow the wrong path for far too long. Idiomatic examples are very useful. I need to train every single developer joining my team to write idiomatic rust. Nobody joins my team already knowing how to write rust. Go ahead and try to hire an experienced rust developer. They donโt exist. Rust is different and itโs rare. A good community doesnโt attack people for providing feedback especially when itโs asked for.
These are the responses from rustc and cargo &gt; rustc --version --verbose &gt; rustc **1.34.0** (91856ed52 2019-04-10) &gt; binary: rustc &gt; commit-hash: 91856ed52c58aa5ba66a015354d1cc69e9779bdf &gt; commit-date: 2019-04-10 &gt; host: x86_64-pc-windows-msvc &gt; release: 1.34.0 &gt; LLVM version: 8.0 &gt; &gt; cargo --version --verbose &gt; cargo 1.34.0 (6789d8a0a 2019-04-01) &gt; release: **1.34.0** &gt; commit-hash: 6789d8a0a54a96d95365c4e1fb01d47a5eed9937 &gt; commit-date: 2019-04-01
How are you building your code?
I think NLL allows this by ending the borrow of `numbers` early. But good on you that you are learning the original edition :-)
The problem is with your Rust edition. You need to opt in to the 2018 edition in order to use NLL.
To me it almost makes the borrow checker sound like the name of a loneshark or something. "Don't fight the borrow checker. You'll lose."
`fn first_word(s: &amp;String) -&gt; &amp;str {` `let bytes = s.as_bytes();` `for (i, &amp;item) in bytes.iter().enumerate() {` `if item == b' ' {` `return &amp;s[0..i];` `}` `}` `&amp;s[..]` `}` okay, so what does `b' '` do here? and generally, while reading this book I've met things like this but never found any explanation so far.
I just did a find and replace
It's an ASCII byte literal: https://doc.rust-lang.org/book/appendix-02-operators.html#non-operator-symbols `b' '` is the same as `32u8`.
Nice article. Recently, I was thinking about this way of doing assembly. &amp;#x200B; \&gt; I keep track of the two available loop counters on the DMA engine, initialize them when I spot a DMALD, and commit them when I spot a DMALDEND. &amp;#x200B; Did you mean DMALP and DMALPEND?
main.rs looks like this mod vectortets01; fn main() { vectortest01::run(); } and then i do **cargo run**
What is the content of your `Cargo.toml`?
I see, it sure sounds like I would enjoy having the NLL. Can I run rustup with some parameter to opt in for the version with NLL? I found [this](https://github.com/rust-lang/rustup.rs/blob/master/README.md#installation) but could not see a good command line param.
It's a classic version! ;-) Is there a command line param for rustup to switch to a version with NLL?
Yes, but you have to pass \`-- --nocapture\` to disable the second override.
Cargo and rustc support both editions. (This allows editions to be mixed within the same project, which is crucial for backwards compatibility.) You control which edition you're using with the "edition" field in Cargo.toml.
you've gotten a lot of other great replies about why we like to avoid `static mut`, so i'll just focus on the alternatives. often, the easiest and most correct thing to do will be to take all of your `static mut` items, put them into a `struct`, create an instance of it on the stack in `main`, and pass (references to) it through your program explicitly, like: #[derive(Default)] struct MyProgramState { foo: Foo, bar: Bar, } fn main() { let mut state = MyProgramState::default(); state.run_my_program(); do_other_stuff_with(&amp;mut state.foo); } if you actually need a global variable, though, you have a few options. - if you need concurrent access to a global variable from multiple threads, use [lazy_static](https://crates.io/crates/lazy_static) with a concurrent container (usually a `std::sync::Mutex`, but sometimes a `std::sync::RwLock`). this might look like: lazy_static! { static ref FOO: Mutex&lt;Foo&gt; = Mutex::new(Foo::default()); } fn main() { let mut foo = FOO.lock().unwrap(); foo.do_stuff(); do_other_stuff_with(&amp;mut *foo); } - if you need thread-local storage, you should use `thread_local!`. i believe the documentation for that part of rust is mostly in [`std::thread::LocalKey`](https://doc.rust-lang.org/std/thread/struct.LocalKey.html), which i won't bother to repeat here. - if you just want a stupid global mutable variable, and don't care about safety or best practice, and you're just getting angry that rustc makes you write ugly red `unsafe`s all over your code, just switch to c or c++ and save yourself the trouble
You can opt in by putting `edition = "2018"` under `[package]` in your `Cargo.toml` :) IIRC projects created with `cargo new` should already have this line but that might be a nightly thing.
Thanks!
Oh, try using the clone url: https://github.com/rust-lang/rustlings.git I think the windows docs are slightly wrong.
It had no edition at all, so I now tried setting it to edition = "2018" and it made the code work! Thanks for the help!
Great, I'll try to remember that. Thanks!
There is basically no situation where static mut is useful where you won't need an UnsafeCell anyway. In rust sharing mutable references, or mutating immutable references is undefined behavior. This isn't a notion of UB that C or C++ have by default (it's roughly equal to `restrict` in C, but by default) The UnsafeCell type instructs the compiler to turn this off for a given contained object, which is how Cell and RefCell are not UB. If you're using `static mut` without some cell type, it's undefined behavior due to the above. But if you _are_ using a cell type, then you don't need the `mut` at all, just use a regular `static`. So yeah, it's bad, because it often misleads people into writing UB, and it doesn't provide any new powers over existing features.
Omg, how should have I found this out until the end of the book? Thanks.
I've never used EventSources beforeโwhen would you use them instead of websockets?
When you only need to stream data from server it is much nicer option and not so complex as a websocket server
And note that the latest IntelliJ allows you to press Ctrl twice and type `cargo test`, which will automatically create a run configuration and run it.
It's unsafe, not bad. The core problem is that Rust has decided that safe code should be able to use multiple threads. This makes sense. Consumer hardware has been mutli-core for 15+ years and if you need more than a trivial amount of CPU time, new software should be able to split the work over multiple threads. That shouldn't be unsafe. On top of that design decision, Rust wants to make it difficult to write bugs and impossible to write undefined behavior without misusing unsafe code. Undefined behavior means that your program may, in certain situations, do bad things depending on how the compiler, operating system, and hardware decided to handle it. It's chaotic - small changes to the compiler version or random timing differences mean that bugs can appear and disappear. UB is hard to test for and hard to debug. Worse "bad things" can easily include security vulnerabilities such as ignoring privilege tests, overwriting or spilling unrelated data from memory, or executing data as machine code. One type of undefined behavior is a data race. This happens when one thread writes to a location, another thread accesses that location, and either the hardware *or the compiler* is allowed to make them collide in time. Data races can be prevented by limiting accesses to one thread, preventing writes to memory, or by using locks or memory barriers to ensure that any potential collisions are resolved into consistent ordering, even when the compiler and hardware behave strangely. And the compiler is the tricky part. It likes to reduce the cost of instructions in a loop. So it will usually try to read before a loop and write afterwards. This can turn many operations into one - but remember there's nothing preventing you from writing a loop that lasts a long time. If the compiler reschedules a memory operation out of a long-running loop, the window of opportunity for a data race can be minutes or hours instead of microseconds. Java tries to limit the amount of mischief that can result. Rust doesn't - the compiler is free to optimize, but when you step outside safe code, there's a lot of responsibility. Especially with `static mut` because it allows any thread to write. So, they're not necessarily bad, but they're an easy way to write severe bugs or to make multi-threading impractical to add later. If you don't want to deal with the details, putting a `Mutex` inside `lazy_static` is the way to go. And it doesn't require `mut`.
Now everything makes more sense to me! I was kinda doubtful that \`SeqCst\` inserts a real memory fence because it would've caused the memory flush which is crazy expensive. Fixed now.
Perhaps put it in a struct where the field type is Rc&lt;Refcell&lt;your_type&gt;&gt;. Then you can clone it to pass the rc different places and borrow_mut() to mutate.
This is a false positive by Clippy. It's trying to guard against bugs like this where you copy and paste code to implement a bunch of binary operators, and accidentally forget to change one of the copies: * sub: a - b * add: a + b * mul: a \* b * div: a \* b Your code doesn't have a bug like this, so you can just mark this function as `#[allow(clippy::suspicious_arithmetic_impl)]` to silence this lint.
Thanks!
The `self.t.allocate(&amp;AuthorizedLine::new(line))` part is wrong, because the `AuthorizedLine::new(line)` expression creates a new *temporary* value with lifetime bound to invocation of that function, so unless you **move** it somewhere else, it will get dropped at the end of the function - that's why you've got a lifetime mismatch (you cannot _force_ an expression to have the lifetime you want). Since you're creating a wrapper, why don't you just do: `pub struct AuthorizedLine&lt;L&gt; { l: L, }` and call it a day? Why do you have to use references?
#~~3~~ 1 Billion Devices Run ~~Java~~ Rust
`L` comes in as a reference via the trait - I can't own `L` in `AuthorizedLine&lt;L&gt;` because the trait requires `allocate(&amp;mut self, &amp;L)`. No? I would totally own it if I could. And actually, what I'm attempting here is a refactor of the trait using `Rc&lt;L&gt;` instead of `&amp;L`. `&amp;L` fits better, so I'm trying to refactor the code to support references rather than _requiring_ Rc's. Requiring Rc's proved awkward when doing this wrapper line. The code ended up looking like `self.t.allocate(Rc::new(AuthorizedLine::new(line))`, and any wrapper continually allocated new Ref counts. So `&amp;L` felt better to me, conceptually at least.
It might be worth looking into avr-rust, a fork of Rust for AVR (which I think still has relatively significant issues, and will probably be merged into upstream Rust when it's in a fairly good state). This issue relates to the fact AVR is Harvard architecture: [https://github.com/avr-rust/rust/issues/53](https://github.com/avr-rust/rust/issues/53)
You're using Rust in hard mode, you need to switch to easy mode by changing the edition in your `Cargo.toml`.
I was thinking of something like this: https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=68707b9aeb1abcc0b76913cd863a9b70, but that's a no-go if you cannot change the trait anyway :-/
Look at the implementations at [https://doc.rust-lang.org/std/primitive.array.html](https://doc.rust-lang.org/std/primitive.array.html) Without const generics, traits have to be implemented individually for \`\[T; 1\]\`, \`\[T; 2\]\`, \`\[T; 2\]\`... Which also means that though the standard library provides trait implementations for arrays, it only does so up to a certain size. TIf you have a fairly large array, none of the standard library traits are implemented for it.
when will Rust force everybody to explicitly pass the allocator to every single function that might need to heap allocate
This depends on what type of content you're expecting to get with such a tutorial. Documentation for `std` can be fairly advanced, especially for more complex APIs or those dealing with `unsafe`. There is also the [advanced features](https://doc.rust-lang.org/book/ch19-00-advanced-features.html) chapter of the book, which covers some of the finer points of the type system as well as `unsafe` and macros.
Small crates are a blessing since they can be used to make wasm games even faster to load :)
The `Allocate` trait is weird to me. Where is it coming from? It seems conceptually wrong to call something allocate if all it does is store a reference (and it cannot do anything else, because the function is passed a reference and returns nothing).
If Rust ever had a Python 3 moment, something has gone terribly wrong.
For sure. Rust has had the benefit of a much more "together" development cycle.
Itโs an internal company term, has to do with what a line is and processes it. I perhaps should have renamed it for this example haha. In essence it takes a line and โallocatesโ some of an internal resource in math. Nothing to do with memory allocation, sorry for the confusion
Note that the amount of data Pathfinder needs to upload to the GPU is highly compressed. It's usually only a few hundred KB per frame, which is quite manageable given typical GPU transfer speeds.
I haven't gone through all the details, but couldn't another solution be a thin pointer to a fat trait object? See [Simon Sapin's comment here](https://www.reddit.com/r/rust/comments/bea97e/flat_appendonly_buffer_of_dsts_for_a_deferredcall/el5zgzb?utm_source=share&amp;utm_medium=web2x) for some related stuff.
I don't understand OP question. But are there any examples in other programming language?
&gt; which you can avoid in various ways Can you expand on that or link an article?
PHP does it: https://www.php.net/manual/en/function.strlen.php I could have sworn PostgreSQL used to have comments in their docs, but I don't see them any more and the Internet Archive isn't much help. While comments can be useful, I'd probably prefer them being rolled into making the actual documentation better.
You can't do much better than a two-letter keyword.
Oh, I see. But since most of documentation in doc.rust-lang.org can work offline (`rust-docs`), I don't think we could add comment sections. Anyway, Rust accepts documentation contribution by making either GitHub issues or pull requests.
no.
tl;dr: comments and suggestions have a place, which is the issue and PR trackers. We had this request from time to time for Python. While it's a "trendy" idea, it just generates content that needs to be reviewed, curated and kept up-to-date, which you would need a large team for. Weeding out spam and related crap alone would take hundreds of volunteer hours a month. And any comment worth keeping / suggestion worth making should be integrated into the main text or docstring anyway, using the normal issue+PR workflow. So instead, a focus could be to make the latter easier by giving direct links to edit the relevant location in the source file online on github, and create a PR from there.
For next time you can use \`\`cargo init\`\` to create a project right away. Cargo will add version 2018 itself.
ยดa &amp;&amp; (something(), true).1ยด (Please dont do this)
Isn't this just `a &amp;&amp; { /* Do something */ }` and `a || { /* Do something */ }` ?
It is also here, in a pretty early chapter: https://doc.rust-lang.org/book/ch03-02-data-types.html
s/panic/fail to link/ The usual way is to have a `build.rs` script that makes the necessary checks, and generates some glue code that is included in one of the crate's module. In many cases you can also just use `bindgen`, which takes a C header (that should only declare things that exist on the platform), and generates the extern "C" glue.
 trat IfTrue { fn if_frue(...) -&gt; bool } impl IfTrue for bool { .... } a.if_true(|| dosmth())
The collectiong of chars is quite an overhead, because you copy the whole string just to get some chars. Collect can also collect ionto a new string. fn substring_fast(&amp;self, start: usize, end: usize) -&gt; String { self.chars().skip(start).take(end - start).collect() } \-&gt; The beauty of iterators in rust ;)
One possibility is to write your own derive-macro which behaves differently from the builtin derives. (derive macros aren't restricted to only derive the trait they're named for, although it overwhelmingly makes sense to do that.) So you could for example have a #[derive(MyClone)] struct Foo&lt;T&gt;(T); which expands to an impl of `Clone`, or even multiple impls.
What about something like this, where static mut is just used to get a variable in scope, not share concurrent access: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=312a89a25cfb6abf39762845be1697d9 Obviously for it not to be UB, the ffi component would have to be single threaded. You can of course rewrite it with an UnsafeCell that unsafely implements Sync, but the resulting syntax isn't exactly pleasant to work with. In this case would there be UB without UnsafeCell? I understand it's a massive footgun and am not advocating it's use, but it's a problem I currently have and would love a better solution for.
IIRC Rust does not have strict aliasing rules.
The rule is: don't version control Cargo.lock for libraries; do version control Cargo.lock for applications. [The Cargo docs go into a bit more detail](https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries).
It should probably be said that it's either edition = "2018" or edition = "2015" but if you don't include it the default is 2015. Should be fully backwards compatible though.
You want /r/playrustserver.
I can change the trait, but I think I need to either use references or an Rc&lt;L&gt;. I've also debated using just `L`, and in places that need to actually have an `Rc&lt;L&gt;`, I could simply share the resource. Since this post has not yet provided a fix for this issue, I think I'll try to make `Rc&lt;L&gt;` more ergonomic. Allowing me to own `L`, but when multiple owned values are needed I'll use something like `AsRef&lt;Rc&lt;L&gt;&gt;`, so I can get a clone-able reference. Hopefully that will improve the ergonomics.
I believe you're hitting clippy issue [#3215](https://github.com/rust-lang/rust-clippy/issues/3215). For now, please just disable the lint.
I saw a lot of people telling you that you need to change the edition, but few people explaining why. Basically, in the 2018 edition, something called Non-Lexical Lifetimes was introduced. This essentially allows the compiler to see situations where borrows can be prematurely dropped within a scope as opposed to always being dropped at the end of the scope. This really just helps for circumstances like this in which it makes sense for the previous borrow to be dropped.
Thank you, i didn't know where to post it.
This library looks awesome! One question: why did you choose to make weights optional, rather than encoding weighted/unweighted graphs at the type level? In my experience, a graph's edges are usually all either weighted or unweighted.
Okay, thanks! Would this be a general recommendation about lock files, or just relevant to rust?
Hard to say. Different package managers do dependency resolution differently wrt lockfiles, so I don't want to say that it's a general rule for all cases.
Would you be ok with using core::intrinsics::powif64 and powif32? That's what I used, but it's nightly only.
Thanks, it seems like a nice improvement to make our life easier :-)
I see! I will try and remember that. Thanks.
You can pass variables down the stack, or pass references. There are tools for if you need to own the data in different places. Static mut is like everyone owning it at the same time and interfering with each other
``` use lazy_static::lazy_static; lazy_static!{ static ref STATE: Mutex&lt;MyState&gt; = Mutex::new(MyState::whatever()); } ```
Fair enough, thanks for your insight!
I remember from looking at ndimage that has a struct for custom pixel types. not sure if it's fully implemented though
What is the benefit of putting a use statement inside a function. My assumption is that it narrows the scope, but does this have any side affect other than not allowing people to access "things" where they should not in other parts of the code? Some examples I was browsing today are in the image-rs crate [https://github.com/image-rs/image/blob/f55a73bd75b5c5bb1579aa3af8b2ae5f3e727467/src/png.rs#L196](https://github.com/image-rs/image/blob/f55a73bd75b5c5bb1579aa3af8b2ae5f3e727467/src/png.rs#L196)
is this going to be put into stable (i.e., default edition)?
If you take a look at how the library is implemented it looks to be generic, meaning you should just be able to swap u8 for u16 in the code. ``` pub struct Rgba&lt;T: Primitive&gt; { pub data: [T; 4], } ```
Using `zip` avoids the bound checks. And `map` feels unnecessary since we have a `for` loop anyway. for (chunk, slot) in str.as_bytes().chunks(16).zip(out.iter_mut()) { *slot = hex_to_u64(chunk)?; }
I looked at that. But at one point I hit a function with -&gt; [u8] hardcoded :/
Uh. Not sure you know what Arc does... Graphs don't need Arc. pub struct Graph&lt;T&gt; { vertices: HashMap&lt;Arc&lt;VertexId&gt;, (T, Arc&lt;VertexId&gt;)&gt;, edges: HashMap&lt;Edge, f32&gt;, roots: Vec&lt;Arc&lt;VertexId&gt;&gt;, inbound_table: HashMap&lt;Arc&lt;VertexId&gt;, Vec&lt;Arc&lt;VertexId&gt;&gt;&gt;, outbound_table: HashMap&lt;Arc&lt;VertexId&gt;, Vec&lt;Arc&lt;VertexId&gt;&gt;&gt;, } Could be reduced to something like: pub struct Graph&lt;T, W&gt; { nodes: Vec&lt;T&gt;, edges: BTreeMap&lt;VertexId, BTreeMap&lt;VertexId&gt;, W&gt;, } for sparse graphs; or for dense graphs, you'd rather use arrays (perhaps [ndarray](https://docs.rs/ndarray/)). Or just use the popular [petgraph](https://docs.rs/petgraph/), which includes the above directed graph and more compact undirected and acyclic directed graphs with a nice set of functions generic to the appropriate variants.
2018 IS the default edition now. It is in stable. If you create a new project with cargo it sets the edition to 2018 :) the separation is simply to not introduce issues with code written before the 2018 edition came out. From my understanding there were some breaking changes.
And then to your other comment about not using \`unwrap\`, that is another good point. I was using that at first just to get a quick first version. For better practice, it'd be good to go back and take out those \`unwrap\`s!
Though not that many crates...
Ah I see, image::DynamicImage is relatively annoying in that case. I'm not sure why the authors decided to not implement a generic case there and made the library somewhat flexible in other areas.
&gt;Uh. Not sure you know what Arc does... Graphs don't need Arc It does if the stored data is shared between threads.
They are not optional, all edges are weighted. If you do not set the weight the weight of that edge will be 0. When you have multiple edges with default weights or the same weight, they will be followed in lexicographic order based on their ids which are a random string of 12 bytes.
oh okay, i wasn't at my computer when i wrote that so i assumed OP was using the default stuff already. thank you
`atoi` and `calloc` don't come from Rust so there is some other language in there (likely C), `realloc` and `abs` though do exist in the standard library with `println!` probably being used only in Rust. I have no clue how it ended up there but I think the question is more "where does Word get its suggestions from?" than "what did rustup/this plugin I use do?". I am unable to help with any of this from a lack of knowledge (macOS and Linux user here) but I suggest focusing on how Word works because I don't think this question is particularly Rust-related.
Think its here: https://github.com/rust-lang/crates.io/blob/master/src/schema.rs#L591
I think that falls in the region of it not necessarily being UB but without a formal memory model it's hard to tell. A macro that does the cell shenanigans for you would be nice. In fact that's what `static mut` _should_ have been: sugar for `static ..: UnsafeCell&lt;..&gt;`
But you're sharing the wrong structure. The VertexId is already Copy, it doesn't care about threads. The T is the data that you may want to share. Arc&lt;T&gt; is shared but immutable. Arc&lt;RefCell&lt;T&gt;&gt; or AtomicCell (crossbeam-\*) for mutability.
&gt;Awesome! Thank you so much!
[removed]
The only difference is that it narrows the scope of the import.
wrong subreddit my friend lol
Actually, you are right. I seem to be quite tired. The reason I used arc for vertex ids is because it uses less memory to reference the same thing (8bytes instead of 12). But this is negligible and could be discarded and VertexIds could just be copied around. Maybe it is better if you open an issue in the repository regarding this? We could definitely change this thing and make it better.
where i should post it
Yes you can use the underlying png library like so: [https://github.com/mpizenberg/visual-odometry-rs/blob/master/src/misc/helper.rs#L13](https://github.com/mpizenberg/visual-odometry-rs/blob/master/src/misc/helper.rs#L13)
This is for rust programming language, I'm sure a subreddit for rust the game exists I just don't know it off hand
I'm good. But if you want another quick review afterwards, just ping me.
From looking at the code, I see you're using webkit. Does this mean my Tether window supports WebGL and WASM? Thanks!
Essentially, there are two different defaults here. If you hand-write a Cargo.toml with no "edition" key or you have an existing Cargo.toml without that key, you get Rust 2015 because of compatibility. If you create a new project via `cargo new`, you are set up to use Rust 2018 because it's better and there is no pre-existing code that could break.
I may be missing a use case here, but could you restructure the API to use something like a builder pattern to ensure that the user calls \`start\` before trying to send anything?
Thank you!
Something i overlooked for a long time was the [Rust reference](https://doc.rust-lang.org/reference/index.html). No need to read cover to cover, but if you are trying to use some specific language feature the reference is, well, _the_ reference on exactly how features operate. After reading The Rust Programming Language (colloquially โthe bookโ) if you really want to deepen your understanding of Rust, write a bunch of programs yourself and keep the reference close at hand.
Could be, didn't think about it. Is || short circuit?
What's "this", to which of the this do u mean?
I understand your post as primarily critical of Rust's lack of support for inheritance. I wonder if this is because you're so used to it, it's hard to move away. For a different anecdote, coming from a Python background, I've never missed it. Perhaps this is because OOP in python leads to verbose syntax, and getters/setters are uncommon. There there are always alternative approaches, but if you enjoy inheritance as a default for common problems, perhaps Rust isn't suitable.
I think CiliateStudios is talking about [this](https://www.techrepublic.com/blog/microsoft-office/use-windows-tags-property-to-manage-office-files/), which is an OS-wide tags system that was first introduced in Windows Vista and gets exposed by the OS-provided Save dialogs.
It's not because I'm used to it, it's because it really is a good tool for various things. I mean, unless you think that everyone for the last twenty years has been hallucinating, clearly inheritance is a useful tool since it's been very widely used. So I find it disheartening that a new language would just toss aside such a useful tool.
Wondering why you're taking the "official" lua interpreter as a target and not luajit.
&gt; And, speaking of exceptions, I think that not supporting exceptions is also a mistake. The error return system, for reams of general purpose code that could care less what went wrong and just wants to clean up and let the error propagate past them up to application/domain aware code, will just make things more time consuming to write, less readable, and more brittle than exceptions would. I have to disagree there. I find that using `?` and a suitable approach to converting between error types is *more* readable because it makes the secondary control flow paths clear and doesn't significantly slow me down. If anything, the thing I dislike most is that Rust doesn't go far *enough* in practice and I have to rely on `std::panic::catch_unwind` as more than just a safety net wrapped around the "unit of work" level of my call graph in case some 3rd-party dependency author made one too many assumptions about the forms untrusted input might take. &gt; I understand at this point this is sort of like spitting into the ocean, but I felt the need to be a good citizen and say my piece. As someone who has to use PyQt as glue to stick a Qt GUI on top of my Rust code, I feel your pain, but it's not merely a matter of "we don't want it". I lurked in the various threads discussing this sort of thing and there was also an issue of how inheritance would have to be implemented under the hood. There are lots of trade-offs that have to be decided on when you go beyond "A trait object is a pointer to the `struct` instance's data, plus a pointer to the `impl`'s function table" and, while there *is* interest in providing some sort of implementation delegation, all the effort has been focused on getting async/await completed and all the requisite infrastructure stabilized. (eg. `impl Trait`, `Pin`, futures, etc.)
&gt; coming from a Python background, I've never missed it. ? inheritance is prevalent and used with great frequency in python code of any substance.
This is the kind of rant that might be interesting for a language in its nascent stages. But Rust is not nascent. It's not going to suddenly flip its error handling mechanism from values to exceptions. While there was an effort to add some form of inheritance to the language a while back (IIRC, the Servo folks wanted), that appears to have completely lost momentum. The only way I see OOP coming to Rust is 1) years from now and 2) some particularly _critical_ and _well documented_ use case is impossible to solve without inheritance. So in that sense, if inheritance is a hard requirement for you, then I'd either: 1. Skip Rust. 2. Research alternative designs that don't require inheritance. If it works, great, then you can use Rust. If it doesn't, then publish your research and perhaps others will learn from it.
Can you give a concrete example of a case where inheritance was what you really needed, but wasn't supported by trait relationships? For instance, you can do this in Rust: trait Polygon { fn points(&amp;self) -&gt; Vec&lt;Point&gt; } trait Rectangle: Polygon { fn height (&amp;self) -&gt; isize; fn width(&amp;self) -&gt; isize! } trait Square: Rectangle { fn size(&amp;self): isize } impl&lt;T: Square&gt; Rectangle for T { fn height (&amp;self) -&gt; isize() { self.size() } fn width(&amp;self) -&gt; isize() { self.size() } } I've found that you can pretty easily use traits to express pretty much any relationship you might need with inheritance and then some, because every traits can have relationships, structs can compose, and concrete types aren't bound to a single type graph like they are in Java and C++
If you haven't come across it already, [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/) is a really good semi-advanced tutorial.
About there not being a lot of Rust jobs I don't think that's the case. Yes you'll struggle to find "Rust developer" positions but many of my friends are using Rust in their day job. Usually it's when developing internal tools where there is more flexibility in choosing which tools to use
As a Python programmer, I can say that it depends. In Python, inheritance is still the most convenient way to do things like making custom variants of existing GUI widgets or implementing a set of HTML scrapers where most of them use simple arguments for configuration (URLs, CSS selectors, regexes, callbacks, etc.), but one needs custom code that doesn't lend itself well to being passed in as a callback.
&gt; some particularly critical and well documented use case is impossible to solve without inheritance This is a nonsensical bar, which I assume you know. All programming problems can be solved with C. All of them. Based on the requirement of "A feature should only be added if a problem is impossible without it" rust actually should not bother existing, because C can already solve them.
The kind of situations I'm talking about are just many orders of magnitude larger and more complex than that. In a UI framework or a graphical UI framework, the controls or widgets have a large number of common stimuli that they need to respond to, in addition to a bunch more that are related to the graphical editor's needs as well. And they come in various families each of which will have potentially a good number of variations, which add their own new stimuli that have to be dealt with. You would end up with enormous amounts of forward code that would be really messy it would seem to me. And I don't see how you could provide the equivalent of default functionality in the base class, which can vastly simplify things in a lot of cases?
Beat me to it...
Exactly! And you don't really need internet access for that: just create wifi access point, connect 2 devices directly and exchange files without any intermediate servers, etc.
Coming from Java where OOP and Exception are arguably even more fundamental than in C++ I find myself more and more preferring Rusts models. Checked Exception are good as they enforce handling but have functional gaps (like across streams and various generics scenarios involving erasure). Runtime Exceptions are notorious for errors sneaking that are missed in documentation. Rust doesn't suffer from either issue. You can elide handling whenever you like, but you must do so explicitly. As far as OOP goes, the guidance in modern Java has seemed to be, for a while now, to prefer trait-like interfaces over type-hierarchies in any exposed edges of your application. I've been using OOP languages for 25 years and the move away from OOP has its reasons (though, like any language paradigm, often overstated by it's evangelists). In my experience it's the simpler examples that OOP shines at, but that large solutions become inflexible and the tail begins to wag the dog.
Please not exceptions again. I sling Java in my dayjob and having these eldritch things rocketing through your callstack like a flaming arrow of divine wrath is not fun.
All solutions basically become inflexible at large scale. It's the nature of the beast. The complexity of the solution itself becomes part of the problem. Not using OOP doesn't change that, it just moves the problems somewhere else.
Yeah the image crate is unfortunately not generic enough for my use cases either. Their filters use clamped sampling, there is no option for wrapping or bordering like I want from an image processing library.
It kinda did with the 2018 edition, but that was handled correctly and without problems.
Anything can be misused. I use them to VERY good effect in my C++ code base. Of course I only have a single exception class and that's it.
To save some clicks, look at [the Dyon feature proposal](https://github.com/PistonDevelopers/dyon/issues/610). In particular, an example transliterated to Rust syntax: let a = |x| x + 1; let b = |x| x + 2; let c = a + b; println!("{}", c(5)); // prints 13, i.e. (5 + 1) + (5 + 2)
Composition and the Deref Trait. If members are more than just a common interface, they should likely be broken into components that are composed over.
I 100% agree. It reminds me a lot of what happened with JavaScript. For a long time JavaScript preached prototype based object orientation. Like in Rust, you would declare your object and it's methods seperately. People defended the prototype based approach hard. What happened was we ended up with bazillions of 'class as a library' implementations. No one wanted to use prototypes. Today JavaScript has regular classes. It's actually syntax sugar for prototypes. No one uses prototypes anymore. To the point that there is a whole generation of new JS developers who don't know how to use prototypes, and what they are. I don't feel like Rust has taken it to the same extreme. I still think it's a problem. It especially makes adoption really hard. Experienced developers don't like feeling like they have to go back to day 1 to learn a language. With Rust you kinda have to do that. Especially details like declaring structs and their implementations seperately. It just feels pointless.
I think this is just one of those bitter pills that comes with actually sticking to a design philosophy. It's worth nothing that all of your points are about things that Rust doesn't have, yet the main issue with C++ that you brought up was the overwhelming complexity. I was/am the same way in that everything I would change about Rust involves adding something to it, but ultimately I always circle back to the realization that almost everyone has a different 'if only Rust had...' lists (inheritance and exceptions are not on mine), and it's a slippery slope between you, me, and everyone else adding what we want and the language getting crushed under itself.
I'd like to split the issue tracker into two parts, users having trouble with execution and users having trouble with implementation.
Use clippy ``` rustup component add clippy ``` Or you can use [rr](https://rr-project.org/)
I don't mean to be rude, but I don't think you're arguing in good faith here. Your post starts out by bashing the whole idea of any language that isn't old C++ (by first bashing new C++ and then _all other programming languages_), moves into name-calling regarding core features of the language you definitely knew about before trying to write any Rust, and concludes by essentially saying "revise your core assumptions or else I won't use your thing. Oh and C# sucks too." You came to Rust, it sounds like, with a pretty negative attitude: &gt; I'm not convinced Rust ... will be able to move beyond a niche status. ... putting in a lot of time to learn it is somewhat of an issue and/or act of faith at this point ... Rust probably has a better than average chance, though I think the average itself is still pretty low. Rust's designers specifically chose to use a [Hindley-Milner](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system) type system without inheritance for specific and explicit engineering reasons, not as "just a reaction"; indeed, the type system is based on existing languages, and Rust _does_ support the most fundamental benefit of OOP, polymorphism, through traits. In addition, Rust basically _does_ have exceptions. The difference is that the type system is more totally explicit than the type system in C++. In C++, a function that is declared as `int whatever()` does not (in Rust terms) return an `int`; it returns a `Result&lt;int, any exception&gt;`, _even if that function does not ever throw any exceptions_. In Rust, we can know whether or not a function "throws an exception" (can return an error) or not, statically, at compile time, and work with those as values (like [this pattern](https://nora.codes/tutorial/chaining-fallible-operations-with-combinators/)). This was an explicit design goal. Indeed, both the issues you identify are critical to the identity of the language. Why is it, if you disagree so strongly with those ideas, that you feel this language might be a good fit? &gt; I can't see how any language that turns its back on one of the most powerful tools available to tackle a particular set of common problems is going to compete against one that doesn't, other things being roughly equal. This is a question that is very easy to find an answer to - the designers of Rust (and other languages!) have written about it at length. It's not as if Mozilla doesn't have experience with inheritance-based polymorphism, given that they maintain several active projects with &gt;100kloc of C++ _each_. &gt; The existing mechanisms in Rust don't provide such, IMO. What's wrong with just having no way to get at a type except by calling one of the approved associated functions, like `::new()` or whatever the type's author has defined? It's like a constructor but without adding a special case to the language, and allows library authors a lot of functionality. For instance, in `iui`, I use this capacity to great effect, by allowing either creating UI controls safely (`fn new()`) or from existing raw pointers (`unsafe fn from_raw()`). Those are fundamentally different functions: `*uiControl -&gt; UIContext -&gt; Control` vs `UIContext -&gt; Control`. Why should they have the same name just because they return the same type? All of these things are explicit design decisions, made collectively and in the open. If you want to know why we have or don't have some feature, you can almost always just look! Rust is a tool. I've found it to be a very useful tool, in both personal projects and in a professional capacity. If you don't think it's useful, don't use it and leave it at that. Bringing criticism you know can't be acted upon (how would one even go about adding inheritance or exceptions to Rust at this point?) with a negative attitude and a threatening tone ("if you don't do x I'll leave!") is not constructive. **TL;DR**, this reads like a rant, not constructive criticism. We value your ideas but it's hard to see them through the anger and negativity here.
Well, to be fair, the complexity in C++ is sort of different. It's not to do with fundamental capabilities being added, but layer after layer of non-fundamental stuff. Whether someone thinks that inheritance is good or bad, I think they'd agree it's a fundamental, big ticket item, and that not supporting it is going to turn a lot of people away.
There was zero anger. People are such over-reactors on the internet. It was a completely dispassionate and honest evaluation.
I actually am writing a UI framework (`iui`), and I have not found that traits are concretely more difficult to use than inheritance for that use case. Indeed, in my current work on refactoring our API, I'm moving more and more toward compositions of traits - almost an entity-component model - than OO-style encapsulated objects, and it's leading to a reduced amount of boilerplate and (in my opinion) an easier to use and harder to _mis_use API.
"Your language doesn't have these features I like, therefore it's bad." "I come from a language with those things, and I like that Rust doesn't have those things." "Well, any solution will be bad at large scales, so it doesn't matter if you have it or not!" This is self-inconsistent. You're arguing that it's a huge problem that Rust is missing particular features, and yet you're saying that "All solutions basically become inflexible at large scale." So, what does it matter if Rust has one solution or the other? It'll become inflexible at large scale either way, right?
&gt;This is a nonsensical bar Isn't that the point? Rust has *chosen* not to have inheritance/OOP because it relies on a different way of framing problems. Needing OOP to implement something in Rust *suggests* that the problem has been framed in a way that might work *better* in Rust using some other pattern or some other way of understanding how the information needs to be organized, and if it's not possible or too uncomfortable to frame the problem that way, then Rust isn't the right tool for you to use.
Sigh... You are obviously in love with Rust and can't take any sort of criticism without over-reacting. I said none of those things. The fact that all techniques get to be difficult once the scale reaches a particular point doesn't mean that it doesn't matter what techniques you use on the way there.
I don't doubt that you're good with them. I've seen them misused in Java enough to be pretty competent in their use as well. However, I've seen enough interns and junior engineers struggle with it to decide that if a language feature requires a thousand papercuts to learn to use effectively then that feature is a bad idea. Rust's declarative error handling with Result is clear. There's no ambiguity involved, no chance of an exception violently tearing through the stack frame with no indication in the code. I really like having the code tell me what it's doing, rather than having to implicitly understand that something different may happen at runtime. That's valuable, and that's going to contribute to a more maintainable program over the long term.
&gt; Of course I only have a single exception class and that's it. How's that different from abusing `panic!` and `catch_unwind` in Rust and using `.expect()` or `.unwrap()` to convert other people's `Error`s into that?
&gt; There was zero anger. Among other things, your closing came off as quite passive-aggressive, at least to me. Let's chalk this one up to the difficulty of communicating emotions (or lack thereof) over a text-only medium, I suppose. &gt; And I have a personal code base of 1.1M lines of code, so I have a fair bit of experience in what works and what doesn't in the real world myself. I've used inheritance to enormously good effect. Glad to hear it! I've built a lot of bikes using double-ended ratcheting socket wrenches, so clearly anyone who doesn't use a ratchet on their wrench, or only has a single socket on the wrench at once, is just wasting their time... Levity aside, this doesn't address the main question: why look at a language, see that it wasn't designed with your goals in mind, and then show up in that language's community to threaten that you'll leave if we don't totally change the foundation of the language? It just seems very unconstructive, to me.
I don't get exactly what you are asking?
Because I think it's interesting and I'd LIKE to use it. But it's just frustratingly falling short for me, and how will any language's designers know what people want if they don't speak up?
&gt;&gt; There was zero anger. &gt; &gt;Among other things, your closing came off as quite passive-aggressive, at least to me. Let's chalk this one up to the difficulty of communicating emotions (or lack thereof) over a text-only medium, I suppose. All his posts end like that. He's been moping around /r/cpp for months.
&gt; Sigh... You are obviously in love with Rust and can't take any sort of criticism without over-reacting. Not only is that not true, it's kind of funny how untrue it is. I have _huge_ issues with the language as is, and spend a lot of time thinking about how it can be improved, or if it's even the right tool for me to use. Often it's not; I'm a very active Python developer, a very traditional OO language. &gt; I said none of those things. Not in so many words; that's why I summarized to point out the flaw in the argument. You _did_ say that you didn't think Rust would be successful if it doesn't adopt inheritance and exceptions, and your response to someone disagreeing with you _was_ to say that it doesn't matter because the Rust solution has problems too. This is a classic moving-the-goalposts argument; you're essentially saying that any _drawbacks_ of inheritance don't matter because it has so many benefits but that any _benefits_ of trait-based composition don't matter because it isn't perfect. To speak more constructively - what problems does inheritance solve that composition doesn't? I'm not asking for code samples or anything, I just genuinely can't think of a problem class that's significantly better served by inheritance than composition. If B is A with an extra field, B stores an A. If B is A minus a field, well, then A is really B plus a field, which we've already solved. If A and B have a set of overlapping fields C, then aren't they just both C plus something?
Geez... I didn't said it WOULDN'T be successful if it doesn't implement inheritance. I said ANY language at this point probably has low odds of going beyond fairly limited breadth of adoption. It's a crowded field and there are existing languages that cover a lot of territory and have very well developed ecosystems. I think it probably would help if Rust supported inheritance because then it could appeal to a wider range of people. As other have pointed out, anything can be done with any tools. But the obvious difference is that if B stores an A, then B doesn't automatically have A's interface. The whole point of inheritance is that if B is an A then it can be used anywhere an A can be used, without the user of it knowing or caring, or any tedious forwarding and such.
If you're only using a single exception class, then how is that different from the behaviour you can get from abusing Rust's `panic!` as `throw` and Rust's `std::panic::catch_unwind` as `try`/`catch`?
Well, my exceptions don't terminate the program for one, right? Unless I want it to. And I can catch my exceptions along the way and do any cleanup I need. And I can throw one of my exceptions back across a client/server call as well.
I think you're still missing the point. One of the major value propositions of Rust is that it does not have exceptions or inheritance. If that's not valuable to you, then that's ok! Rust is designed for use cases where it is valuable. This is why I took the time to point to specific points you made. It's not as if you came to suggest a new feature ("I really need `i256` to do my scientific computing!") or to point out problems with something that's in progress ("The new async/await syntax options all look really confusing!"). Instead, you're demanding that the designers change the very foundation of the language. You're asking the manufacturer or a ball-peen hammer to get rid of the ball and add a nail-puller.
But all code in an exception based system assumes an exception could happen. It's not like it's violent or anything. It's a given that it can happen. All code, just as in an error return based system, has to deal with errors coming back and clean up if they need to clean up and either deal with it and continue or pass it on. It's actually not that difficult to deal with in C++ and presumably the same in Rust since both provide the ability to clean up when objects go out of scope. Most code in a C++ program doesn't need to do anything to deal with exceptions at all. They will clean up no matter how the method is exited.
&gt; I can't see how any language that turns its back on one of the most powerful tools available to tackle a particular set of common problems is going to compete against one that doesn't, other things being roughly equal. Rust โ "any language", so I don't really see how those are semantically different. &gt; if B stores an A, then B doesn't automatically have A's interface. For me, this is an advantage, since it allows the newtype pattern. I do see what you mean, though - this is a tradeoff. For designs where there is a lot of newtype-passing-through-all-behavior, I can see how inheritance is a good fit.
Nevermind. I know where this conversation is going...
Maybe I'm just salty because in Java we don't have RAII and any resources have to be explicitly cleaned up by hand in a finally block. :)
It does make things a lot harder for sure.
This seems to be your go-to response, based on your past posts in /r/cpp. I'm sorry if I'm going somewhere you don't want to go, and I hope you find a language that suits your needs better than either C++ or Rust!
It's just common sense to stop an argument that's just going to go around in circles. I'm too close to the grave to waste time on that.
All of those things are possible with panics today.
That seems like an uncharitable reading. We all know all languages are equally expressive in the computer science sense. In this context "impossible to solve" has to mean that it simply doesn't work in a way that's even remotely ergonomic, so it's impossible to solve in the sense that it's impossible to use the language features to get a reasonable design that solves the problem.
I mean consider something like React for web development. It doesnโt support inheritance for components and encourages composition. Initially this was a pain point for me but I actually think the pattern works really well for UI development.
I have no problem allocating data on the heap and using dynamic dispatch to employ heterogeneous type polymorphism. If that's all objects are (with a dash of modules for encapsulation and message passing) then I'd be fine. That's basically all it is in Go/Rust, a direction I think both get correct. I do have a problem with Classes (C++/Java style) and Inheritance. Classes because they are bad modules, have issues with extendability by the client/consumer, they conflate data and behavior organization &amp; definition, and the accessing of that data &amp; behavior throughout the code base. Inheritance because it takes the issues of the former, and ratchets it up to 11. Aside of all the issues of everything on the heap and globes of vtables and pointer chasing in heap-everything languages like Java (you can easily do that by convention in any language,) you still have all the structural issues of the code in C++ even if your lucky to get things to even optimize down. The moment you want to add something to multiple subtypes, but not all subtypes, you run into a problem. The parent can't have something, unless you are inheriting more than what you want to allow. Or you have to multiple subtypes implementing a singular notion in multiple places. OR what you do is you make multiple custom wrappers in the desired subtypes that call out to a single sub-system that defines the shared behavior. All three of those scenarios are bad. In the last one you've just gone and usurped the type-hierarchy and the code you tried to compose in by convention yet it lacks recognition at the type level, both in ignoring the composed behavior and continue to model the lie that is a pure inheritance structure. The repetition model keeps things pure, but is also a lie. In every inheritance model that is pure (very few even ever are,) it didn't actually need to be written that way. There is further no actually protection of inheritance purity through the compiler. Maybe artificially at the type level, but certainly not for data and behavior, the real things you are trying to model. For every model that was prematurely made into an inheritance hierarchy, it will become a monstrosity if it ever needs to organically grow. So it's better just having those small "pure" infant models be done through a clean compositional model, because you can't always anticipate how other's will grow and extend the code. The ability to have people reach for Classes and Inheritance is not something I want to even be possible in the code-bases I'd ideally be working in. Even if things start out as small and well conceived, these abstractions turn into monstrosities. Especially with regards to shared mutable state. I really suggest OP to checkout `D` or `Swift`, they are both quite dreamy in their own ways and do offer the OP exactly what they are looking for.
Well, if you can catch a panic, then it's not really what I was sort of lead to believe it was. Everything I was seeing seemed to indicate panics are for unrecoverable problems and should only be used for that.
I don't do web development. Well other than a few bits. I work on large scale code, mostly distributed and client/server stuff and large general purpose frameworks.
Panics can be caught. They're not intended to be used as part of a program's normal control flow, unlike error result values. I personally think that catching panics should only be reserved for extremely exceptional usecases, but I feel the same way about exceptions in C++ so *shrug*
But we get into the issue of not being interested in a language just because it's there. I don't think D has any chance of being widely used enough to justify learning it, and Swift is just Apple, right? I have no interest in that ecosystem. Rust, as I said, probably stands the most reasonable chance of getting some traction, however low that may be. Your other claims are obviously proven wrong by the existence of very rational, powerful software written using inheritance. My code base, for instance, has been around since the 90s, and has grown immensely over time, and I mean immensely. But it's not in any way brittle or out of control.
This isn't an argument for or against your position, but if you haven't, you might want to check out how GTK takes a C++ inheritance object model and models it in rust. https://gtk-rs.org/docs/gtk/struct.Button.html impl IsA&lt;Bin&gt; for Button impl IsA&lt;Container&gt; for Button impl IsA&lt;Widget&gt; for Button Using the `IsA` trait, you can make functions that take in any type that `IsA&lt;Widget&gt;`. It's not perfect, but it works. On the topic of exceptions, I find that in C++, you always have to be in the mindset of "anything, anywhere, might possibly throw an exception, either now, or in the future". And you have to strive to make all of your code "exception safe". I personally find the explicit return points much easier to understand and easier verify that my code is correct.
But, as I said before, there will be large amounts of general purpose code that just doesn't care in the slightest what went wrong, whether it was that the universe ended or a file wasn't found. It just cleans up what it was doing and passes the problem on. In a language like C++ or Rust, that's trivial most of the time and takes no code at all, because the objects will go out of scope and clean up. It will just get rid of so much busy-work code.
Some forms of inheritance can be performed in Rust, and examples are in the standard library. Take a type like `Arc&lt;T&gt;` for example, which transforms any `T` into an `Arc` while retaining `T`'s immutable behaviors. Traits like `Deref` / `DerefMut`, and / `AsRef` / `AsMut`, can be implemented to enable treating the new type as the defined base type when dereferenced. I've used this with GTK Rust applications on a few occasions to build specific views upon a base view. That said, there are often better paradigms that you can use instead of inheritance. ECS and ECS-like architectures are a common approach that can quickly become both more performant, and increased flexibility. You can pass around 32-bit entity IDs which may possess any number of random properties available to the world. OrbTk is making use of its DCES library for this exact thing. if let Some(text) = widget.try_get::&lt;Text&gt;() { eprintln!("widget contains text property: {}", text); } Which is syntactic sugar for this lower-level operation: if let Some(text) = ecm.borrow_component::&lt;Text&gt;(widget.entity).ok() {}
I write OOP a lot in my day job, and Rust has also recently come into it too. IMO the only difference between inheritance and a trait is that inheritance means โis aโ and a trait means โcan act like aโ. In practice, Iโve never seen anything Iโd consider supported by inheritance and not by a trait. Perhaps Iโm just sheltered from some use cases, but as I work in a very broad domain, Iโd be surprised if there is a use case common enough for inheritance to be *required* and Iโd never even heard of it. A lot of it is just accepting that things are done differently and adapting to them. Nobody ever ports code line for line, and thereโs a reason for that.
You either learn a language for yourself and your own projects, or learn the language you've been given to work in. The job landscape is already highly fractured, and there is a lot of reason to learn any number of niche languages. Swift is open source and usable outside of Apple's platforms, it simply targets LLVM. D is often used within C and C++ code bases. D literally just landed in GCC 9. It's not like seeing a big mix of C, C++, Fortran, Ada, D is uncommon. The claim wasn't you can't write code with inheritance, it's that it would be structurally better for having not. Inheritance mostly got pushed when Java (a research language experimenting with hierarchical type systems) was being branded as OO and pushed out as being the defacto enterprise platform during the early web. The ubiquity has more to do with hype and early capital injection that it does with the integrity of underpinning type system.
Wha? Inheritance has been in C++ since almost forever, and of course C++ got it from other languages that came before that. It's been a fundamental technique since before most people around here were probably even born.
Since Java 7 `try` gives you pseudo-RAII for anything implementing AutoCloseable: try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); }
&gt; This is a nonsensical bar, which I assume you know. No, you assume wrong. It's not non-sensical at all. Reducing everything to C is pretty silly. I would never make that argument. Look at GATs, async/await and const generics. All of them have exceptional motivation with compelling use cases that drove (and are driving) their design.
I should say "Inheritance as OO got pushed with Java," "Classes as OO got pushed with C++ and others." The whole type hierarchy hype is rather fascinating and its confusion with it being part and parcel to OO stems from issues in how the business world tracked academia. This was back in the 70's. Barbara Liskov has provided a very good account of this, and even her substitution principle was the rather. But inheritance as a paradigmatic good really does get pushed with Java, in C++ you had plenty of other options to break out into. It was never as foundational as it was in early Java.
I have zero context for the linked project, but your example here is similar to a couple types of composition in haskell. For one the Semigroup instance on functions (`Semigroup` is for things which have a combination/concatenation operation, which has the associative property): &amp;#x200B; `Data.Semigroup&gt; let c = (+ 1) &lt;&gt; (+ 2)` `Data.Semigroup&gt; :t c` `c :: (Semigroup a, Num a) =&gt; a -&gt; a` `Data.Semigroup&gt; getSum $ c 5` `13` &amp;#x200B; An interesting difference here is that our \`c\` function is polymorphic in the right-hand side, i.e. the caller can decide what \`&lt;&gt;\` means: &amp;#x200B; `Data.Semigroup&gt; getProduct $ c 5` `42`
The word โimpossibleโ has a simple, binary definition that is not sensitive to context that you are choosing to ignore to re-interpret someone elseโs comment in a way that suits you.
The web-dev thing is irrelevant here. Itโs just the fact that a large, very successful UI system has been built with non-OO patterns.
This is more than just "if", if that's the two letters u r talking about.
Thank you this is what I meant. The UI paradigm can work very well with a pattern that realizes heavily on composition rather than inheritance.
But the thing is, I don't use UI frameworks to write applications, I write UI frameworks (amongst many other things.) I'm assuming React is built on top of HTML and the DOM? It's one thing to expose an API around the DOM for people to use, but another altogether to create a fundamental UI framework that would include the equivalent of all of the DOM stuff and more. That's a much more complex undertaking.
Either way, you are clearly just expressing opinion that it's always better to do it without inheritance. That flies in the face of a huge body of successful software that uses it, my own included. It's not some horrible technique that got pushed on people against their will. It was taken up because it's powerful and it works. It can be done badly as can anything, obviously.
Even back at Rust 1.0, when there wasn't a stable way to catch panics, they still only took down the thread they were running in (unless it was the main thread). You *can* make them uncatchable in the name of efficiency by setting `panic = 'abort'` when building your binary, but the general idea is that you allow panics to unwind things up to either an FFI boundary (because C has no concept of stack unwinding) or until your "unit of work". (eg. You don't want a panic in a single request to take down your web service or a single unexpected input file to kill a batch thumbnailing job.)
Not really any more reason to respond to this thread. It looks like it was removed, or hidden at least. I don't see it in the list. Oh well, so much for open discussion. If that's the way of it, I think I'll definitely look elsewhere.
Thanks for the PR, fixed
Apart from 'not polluting the namespace', which is a matter of taste, putting `use` statements in the same scope as their use can allow reuse of `#[cfg(..)]` attributes without getting an unused import warning.
&gt; After installing the appropriate plugins (including RLS and CodeLLDB), it works - except that when the program runs under debugger, I cannot pass user input to it: either the debugger or the console grepper intercept it and interpret as their commands. User Settings &gt; Extensions &gt; LLDB &gt; Launch: Terminal. Change the terminal type from Console to Integrated. Or in settings.json: "lldb.launch.terminal": "integrated" The description of the "console" default is: &gt; Use VScode Debug Console for stdout and stderr. **Stdin will be unavailable.** Seemed like an obscure default to have, but there you are.
Yep, and this is a nice pattern as far as band-aids go. It's still opt-in, so if you forget it... congrats on the leak, it's a file! There's no strong guarantee that close is ever called. There's some interesting things in Java 9 with phantom references, but it's all patching around the real issue that there is no destructor that is guaranteed to be run when something falls out of scope. For most Java, this isn't a big deal, but for any resource (files, streams, etc) it's a real irritant and noises up the code with all kinds of manual handling to things that ought to be automatic - and if you forget one, you have a bug.
That makes sense. It should be noted that Servo implements the DOM in Rust (I think their team also were the ones wanting more OO in Rust, so thereโs that). In my experience there are still some rough spots that OO would make smoother, but the Rust language team are taking care of in other ways (like Specialization which I think is supposed to land this year). Moving from OO to a trait / generics paradigm was definitely a bit of a head-spin to start, but now that it clicks I find that I can be pretty productive and only very occasionally miss OO.
Still working on [Nimiq](https://github.com/nimiq/core-rs): We are now implementing Proof of Stake with probabilistic byzantine fault tolerance using BLS12-381 aggregate signatures and other features that have even more impressive names :D
That says more about what you intend to get out of it than anything else. I'm interacting with *you* in the hope of reaching some kind of common ground and I don't care whether anyone else sees it. Also, it's *always* iffy whether "X whines about Y" comply with the rules for this subreddit, even when they're unarguably constructive. (We try to maintain a certain standard for content here. Remember that /r/rustjerk also exists, for example.)
`Rc&lt;RefCell&lt;T&gt;&gt;` You'll see lots of them.
 &gt; Cellular automata You're almost certainly writing a bug. Mutability everywhere means your program produces different answers depending on the exact order it iterates through cells. Cellular automata usually aren't specified that way. The state of a cell in step *i* depends on the state of it and its neighbors in step *i-1*. Those are different things and you can't update in place. If you implement a CA correctly, it won't be too hard to satisfy the borrow checker. On the off chance you *do* need to overlap mutability, consider the `std::cell` module.
What I want to get out of it is to make my wants known, as others should. No one is going to guess what we want if we don't say it out loud and debate it. If they are just going to whack it, that can't be achieved, so I don't see the point in continuing.
&gt; Mutability everywhere means your program produces different answers depending on the exact order it iterates through cells. That would be the point in this case, because this is a rather new idea for CA, where the cells can essentially change their order according to certain conditions that arise amongst their neighbors. &gt; On the off chance you do need to overlap mutability, consider the std::cell module. The name of that module checks out. &gt; The definition of CA must have changed when I wasn't noticing. I was thinking Conway's Life and Brian's Brain and such. This is a far more complicated scenario where the cells have way more freedoms than those classic implementations.
Iโve been in the same position. Have a look at split_at_mut function to get two mutable slices of an array. Then you can modify two elements. Iโve used this to implement a cellular automaton.
thanks that helps a lot
Oh, well that explains why they removed it. /r/rust/ isn't the proper forum for that. Rust development has a defined progression of steps to follow from idea to implemented feature, /r/rust/ is not part of that progression and, even if a team member *did* see it here, you haven't said anything that hasn't already been said in the prior discussions *within* the formal process, which were shelved pending the stuff like async/await which can see more results more quickly. (/r/rust/ is more for announcing what you created, asking for help, or sharing interesting developments you encountered elsewhere.)
For 3, in order to improve performance, you can implement an elimination array to create what's known as โElimination Back-off Stackโ. An alternate is to implement descriptors but this has an overhead that can be avoided in this case
Thanks for the clarification.
Thanks for the clarification.
Working on a rust macro [toy](https://web-ra-syntax-node.herokuapp.com/) , which helps rust beginners understand how `macro-by-example` works. Maybe polish it if anyone have interested :)
Why do so many std functions return their own type? Like why does String::split return a Split and splitn return a SplitN? Why not some common type, maybe an iterator, or at least a shared type?
Those types are iterators, and by having a concrete type, Rust can monomophize them, thus allowing all kinds of neat performance tricks that wouldn't be possible with dynamic dispatch. Also the standard lib was written before impl Trait and introducing it now would break code, so ๐๐ฆ
GDAL should work, although the high-level bindings could use some help.
That feels like a good way forward. [flot.rs](https://flot.rs) is limited because it just generates static documents. Someone asked if there was a way to integrate with regular web frameworks and this is both interesting and tricky1
Instead of doing a lot of revision I've been working on the compiler for [tox](github.com/lapz/tox) again . I've added an item and I've started working on liveness analysis.Here's some pictures of the [ir](https://i.imgur.com/hADT3le.png) and [liveness analysis](https://i.imgur.com/b2O0SbR.png)
Just some quick notes: What you've implemented is called Treiber's stack, there is a [blog post](https://aturon.github.io/blog/2015/08/27/epoch/) by Aaron Turon on the design and rationale behind \`crossbeam-epoch\`, in which he uses the same data structure as an example, you might want to look at the memory orderings he chose. The way you used \`Relaxed\` ordering for everything is definitely incorrect. \`Relaxed\` should never be the default ordering if you aren't sure about these things, btw. On x86-64 you might be ok, since regular stores and loads have acquire/release semantics by default, although it is still possible for the compiler to reorder \`Relaxed\` operations as it sees fit, which could also break your code. From a formal perspective, it's certainly incorrect, though. As for the benchmark, I've only taken a quick look and it seems you use 256 threads for your benchmark. That is probably to much, unless you are running your benchmark on a many-core processor. At that number of threads, the OS busy doing context switches (which take forever) between all those threads. Better go for a number closer to the hardware concurrency of your machine, usually 4 - 16 these days.
What do you mean by 'interactively'? Like changing chart's settings and reloading it? If so, you can just change your static files and reload the page. Plotka will send all the data it had received up to that point, so you don't lose anything. I think that integrating those features would be an overkill. Releasing separate pieces of software to do these things is better IMO.
Cellular automaton iterates in rounds. You my use rayon. Ex. rule 110 using rayon. [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=022ef779ef2629e97224f8a1ef896a95) // Current pattern 111 110 101 100 011 010 001 000 // New state for center cell 0 1 1 0 1 1 1 0 use rayon::{iter::ParallelIterator, slice::ParallelSlice}; fn main() { // 00010011011111 let mut state = vec![ false, false, false, true, false, false, true, true, false, true, true, true, true, true, ]; for _ in 0..40 { // inefficient prepend; should just move a cursor state.insert(0, false); state.insert(0, false); state.push(false); state = state .par_windows(3) .map(|x| match x { [true, true, true] | [true, false, false] | [false, false, false] =&gt; false, _ =&gt; true, }) .collect(); // padding for _ in 0..60 - state.len() { print!(" "); } for b in &amp;state { print!("{}", if *b { "#" } else { " " }); } println!(""); } }
Here is the repo for anyone looking for: https://github.com/RedisLabsModules/redismodule-rs
But yours sounds way more fun to watch.
Is this page barely readable for anyone else? Links are default blue on black background, the right side is black on dark gray background, and the long lines of small white sans-serif letters on the black background just feel blurry and unstable.
Using the Result type in โCrate help in terminalโ to handle errors better. https://github.com/peterheesterman/chit
As already mentioned, you'll need to change debug session's terminal type to either "internal" or "external". Regarding rust-lldb: CodeLLDB already contains data formatters for many Rust std types, and with more features. So using rust-lldb will not gain you much, and might actually break visualizations due to conflicts. Also: in the last couple of releases I've been experimenting with bundling LLDB binaries with the extension, so that users would have a consistent experience even if using older distro versions, which don't have the latest LLDB. The bundled version was forked from the one if Rust repo (with a few Windows-specific fixes), so it includes native Rust support. You can try it out by setting "lldb.adapterType": "native".
&gt; ndimage You mean ndarray?
&gt; Seemed like an obscure default to have, but there you are. Well, the "external" terminal seemed too obtrusive to be the default, and between "integrated" and "console" I chose the latter, because on Windows "integrated" is not supported and I thought it'd be better to use the option that works across all 3 OS families.
Yes, this feels correct. I suppose I was dreaming about the ideal situation. Let me have a look at plotka once I've calmed down a client :)
By the way, it seems that all you do here is cloning the list - so it's a memory-bound task (contrary to cpu-bound one, like raytracing), so it seems like multithreading should \_decrease\_ its overall performance.
I put together a basic guide. It seems like youโve already installed the necessary components. But you might try downloading my example project and seeing it works. That might help narrow the issue. https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/
Several things at once, which is dumb but how I roll. Spent today working on [samplr](http://github.com/pdx-cs-sound/samplr), a sampling synthesizer demo project for my sound and Rust classes. My intent is to live-code the rest of it, but I wanted to get the WAV-read, sound-play and MIDI-read functionality in place first since it's a lot of fiddly code and took many hours to get functional.
&gt; I could have sworn PostgreSQL used to have comments in their docs, but I don't see them any more And that is one of the big problems.
https://github.com/Robzz/ndimage haven't used it yet though!
The past month I've been trying to get the libwebp C library working without using emscripten by only linking it to Rust and then compile it to wasm32-unknown-unknown. It works kind of that it can't convert images lossless or that have alpha. The latter is my biggest problem but I think I've found the problem and it is probably my fault. I was using the sort_unstable_by function from the library on a u8 slice for my qsort implementation. The problem is that it ignores the size of the elements meaning that only two bytes are swapped at the time but it has to be of size. The same issue also happened with my bsearch implementation which I should have kept instead of using bsearch. It shouldn't have the exact same issue but it should faster to do it manually. I hope to post very soon my demo working.
It depends on the mode of distribution. For example, in .NET, packages are always distributed as binaries so the argument that the lock file will force a version on downstream users is nonexistent.
Ahh, wasn't aware of the differences on Windows. Appreciated the explanation, thanks.
Do the .NET people statically link libraries then? I haven't used it in a long time, but I remember some form of dynamic linking being there.
Ah, yeah, that's a typo. Thanks for catching that!
No, dynamically. But the dependency listed in the dynamic binary is looser than what's in your lock file (if you even have one, Paket has had them forever but NuGet has only added then recently).
The past month or two I've been trying to use the C library libwebp without using emscripten but with Rust's wasm32-unknown-unknown target. I've managed to create a simple demo last week! However, lossless setting and images with alpha fail with memory out of bounds. I've come to the conclusion that it is my fault which is great because it means I can actually fix it. To make it work I have to supply some C std functions that do not exist on wasm32-unknown-unknown and Rust's corebuilt-ins (at link time we get memset, memcpy etc. implementation for free). Two of them is qsort and bsearch. This is probably where I messed up. I thought I would be very smart to use the methods from slice but the problem is that it is an u8 slice meaning only bytes are swapped at a time but the number depends on the passed size. This means for example an array of structures is messed up in every way. Fixing that and also bsearch (probably it works but not as fast) will hopefully make it work. I hope to post my demo very soon.
So they basically do the same thing Cargo does, right? Except the runtime dependency information is compiled into the binary itself and not stored with the source code?
yes. do not do this. This whole thing reads like 'how can I make the other programmers hate me' code. &amp;#x200B; just do an if, it's there for a reason.
Might I also suggest commenting the reason for the disable (ie, that you are running afoul of issue #3215, with link). Nothing like having some new person start fiddling with this type of thing and wondering why they got a bunch of new warnings. Just commenting why you are doing something like this usually keeps this kind of "but why can't I turn off warnings, it's done here!" to a minimum.
First and foremost: Onion routers do not "block trackers", nor do they provide "real" anonymity. [Anonymity Trilemma: Strong Anonymity, Low Bandwidth Overhead, Low Latency---Choose Two](https://eprint.iacr.org/2017/954) includes a nice set of anonymous communications protocols. [HORNET](https://arxiv.org/abs/1507.05724) is the state of the art in Onion Routers. But if you want true anonymity, you'll need a mixnet. Mix networks can resist passive (and sometimes active) global adversaries. Onion Routers like tor and HORNET crumble immediately under the presence of a global passive adversary. Unfortunately, as the first paper demonstrates, mix networks cost either high latency or high bandwidth overhead. Riffle is great for eventual file transfers. Loopix is great for email and the [Katzenpost project](https://katzenpost.mixnetworks.org/index.html) is extending on it with reliable delivery. (The others are good too but I know these three protocols best.) Okay. Now dystopia, odd name. Anonymous communication protocols help recover from dystopias, they aren't dystopias. Do you have a design document? At a **quick pass** over the code I see you're using TCP, like tor. Poor UDP and other traffic feel left out! RSA? Eh. Please use something modern like [curve25519](https://doc.dalek.rs/curve25519_dalek/index.html) or IMHO better [Ristretto255](https://doc.dalek.rs/curve25519_dalek/ristretto/index.html). I haven't found the code to confirm this, but I guess you're using tor-style telescoping? A establishes a connection with B. Then A establishes a connection via B with C. This is an inefficient connection setup, resolved by HORNET (and [Sphinx: A Compact and Provably Secure Mix Format](https://eprint.iacr.org/2008/475), which it and Loopix build on) using unidirectional channels and a blinded Diffie-Hellman chained-handshake. This has the added benefit that a node does not know where along the path it is, reducing leakage. Following tor-style, the "cloud" service delivers the complete set of all nodes to the gateways. A trusted and centralized set of very powerful nodes. I am working on an onion router building on the work of HORNET, HIPv2, S/Kademlia, and PIRs; to support UDP-et al traffic, to reduce the cost on relays, and most importantly to eliminate the trust in third parties. The PIR services exist only to bootstrap the DHT. A PIR, Private Information Retrieval service enables the client to lookup a few entries in the large set without the server being able to influence nor learn which entries the user requested or received. If the PIR service goes down, users must either find new PIR services, or bootstrap via their peers. The fault tolerance of the system does not rely on a trusted service to function. I'm glad to see your interest in onion routing and Rust but fear your design is quite dated, as dated as tor's design. On the other hand tor has been battle tested and it would be really cool if your tor-like were simply tor. Do you have any design decisions that differ from tor that warrant a separate protocol? Good luck!
As author of the crate:- &amp;#x200B; &gt;I'm actually less enthused about the fact that the behavior of the library potentially changes on each build -- builds should be hermetic and reproducible. The security issue here would then be moot. &amp;#x200B; Currently, one can supply their own list for reproducible builds. &amp;#x200B; &gt;The right way to handle this is to issue point releases when the Public Suffix List is updated, distribute the list already embedded in the library. &amp;#x200B; This is exactly what I plan to do at some point. This is one of the reasons why the library has not reached 1.0 yet.
I did create and issue for that. They said they were looking into opencv style border types. But yeah. open source. You get what you pay for xD
I must say, this has become a little mini goal setting thread for me week to week. Works well to keep motivation and interest high. Also, inspiring to read what all you clever humans are doing. :)
What's this, I don't understand your version of English. I think "false.map_false(|| true)" is perfectly readable.
This is awesome ! Some macros are really complex, your project could be very useful.
You shouldn't need to set any env vars to use cargo. &amp;#x200B; What dependencies do you have in your Cargo.toml?
I personally tend to never commit \`Cargo.lock\` because I expect the ecosystem to respect SemVer. But I know this is not the case (some people make mistakes, etc.). I do it from time to time for binaries, though.
Maybe I miss something, but I'm not sure there are a lot of use case for this feature. It seem far too much magic for me. Writing `let c = |x| a(x) + b(x)` seem pretty clean.
**libc = "0.2"** is the only dependency.
Nice, I didn't know that lib. I just searched [crates.io](https://crates.io) but it seems they have not published any releases.
Hmm, seems to work on my machine. Maybe try running the command with verbose flag: cargo -vv run
What is the reason for not commercializing Noria?
At the moment c = a + b would not compile as "+" wouldn't be a supported operation for closures However, the following works: let a = |x| x + 1; let b = |x| x + 2; let c = |x| a(x) + b(x); println!("Result of c: {}", c(0)); // prints 3 I am new to these concepts. Can you please help me understand where the proposed idea would help and how it would be used?
Do not set those env vars, I once set them to get the prereleases and forgot about them but they horribly broke my rust installation later. Removing those env vars and rustup updating things fixed everything.
&gt;This is a far more complicated scenario where the cells have way more freedoms than those classic implementations. Doesn't really matter. It the system has turns (rounds) it is always a lot better to produce new state as a function of the old state, keeping old state immutable. This way you simplify your life dramatically.
It would require starting a company, spending a significant amount of engineering time on making it "production ready", which is not generally a goal of research projects, and solving a bunch of other mostly-orthogonal challenges like providing bindings in other languages, supporting more odd SQL keywords, etc. In general, I don't think there's a good reason not to, it's just that that's not the focus for us as the authors of the work for the time being. We're doing research on a distributed data-flow database, not aiming to disrupt the commercial database scene :)
Have you checked `clang-rs` out?
It's kind of fascinating. The code is a mess of duplication and misunderstandings because I'm not very good at Rust, and I still rely on python to draw everything for me, but it's still really fun and rewarding to work on!
This shows why in few years Rustlang is gona over run JS scripters with Wasm, the era of Programmers is just beginning; if you are a scripter you better upgrade yourself or be ready to Perish. :-p
Iโm just learning the language, so for some experience I am writing a module to easily configure some default endpoints for astrix, such as ping, request counting, info, etc.
Aah, I'd prefer to support stable Rust if possible, however leveraging intrinsics on nightly as an alternative would indeed be interesting as well
So going through the links, this is a one man project, thatโs based on some paper from advancedresearch, which is a one man github .org, where the paper was merged in a PR there without receiving any feedback, and the paper and the PR and the merge were all authored by the exact same person, which is the same one thatโs working on dyson. Funny.
I removed the environment variables, but that made no difference. Using the verbose flag isn't giving me any additional information. It's getting a little farther along, though...25% instead of 15%.
Not too sure about the memory usage but i can recommend checking out [fern] (https://crates.io/crates/fern), it lets you specify how to log even on a module level and much more
Thanks for suggestion. I just did a high level reading but wasn't able to get anything related to thread safety. Is it thread safe?
to my knowledge all loggers that use the log crate api should be thread safe, so im pretty sure this one is threadsafe as well
Just saw, crate size is too big - 0.29 MB. While stlog is of 10.48 kB.
Will new features be implemented using impl trait or using concrete types for consistency reasons?
fern does not seem to support `no_std` development at all
That's the source archive size, you shouldn't use that to make decisions based on code size, which is something else. Try building a minimal example with each and check how the flash usage changes.
I've successfully used the regular old [`log`](https://crates.io/crates/log) crate on microcontrollers. You can implement a logging backend however you like, on MCUs this is unfortunately very application-dependent (do you want to log through a UART, through ITM, via semihosting?). I've done this using [`bbqueue`](https://docs.rs/bbqueue/0.3.2/bbqueue/) as a buffer for logging messages. There's also the new [`ufmt`](https://github.com/japaric/ufmt), which is a much more lightweight alternative to `core::fmt`, but not its own logging framework.
Oh ok, that makes sense. I think the documentation could be a little clearer then. I read "returns the weight of the edge, if it is listed" as "if [the weight] is listed", but I guess you meant "if [the edge] is listed". I'd also mention the default weight in `add_edge`.
Learning Rust by applying The Book's examples on real-life functionality my day job requires. Currently studying structures and aliases. I like that most is immutable by default. I take issue with HashMap, as it needs to be mutable to accept any entries. Wrapping my head around moving values and borrowing references.
Good analysis. I'd also mention that onion routing has certain flaws and that garlic routing would be better to implement.
Yeah, you are right. The documentation should be changed to reflect this more. It should also explain the lexicographic sort.
Rust has a focus on accessibility and openness, so I expect the barrier to opening a new issue is lower as well.
IIUC garlic routing is just onion routing with redundant routes per packet and a degree of bundling of packets (not sure if even I2P implemented the latter?). It adds more bandwidth cost but I haven't seen any research to challenge if it is ever worth it. If you want multiple routes, you can do that at the endpoint level without enabling packet amplification attacks by splitting at the nodes.
(I edited my reply)
I will be using a wrapper on freeRTOS to access file system. If it is what you asked. (Noob here)
I personally always commit Cargo.lock. This allows having a publicly available โknown goodโ version of your dependencies. It makes it much easier to track heisenbugs introduced by newer versions of dependencies: I can run the reproducer/tests on the latest version and the known good versions, and bisect until I find the offending dependency/version. By making it publicly available, anyone can follow the same process.
I had errors looking like that because of my corporate proxy. I had to configure the proxy in a cargo config file.
I'm actually not very clear on how garlic routing works differently than onion routing, but I believe it was designed with the intention of eliminating specific weaknesses (like timing attacks). Last time I delved into this stuff, onion routing appeared to have a whole host of weaknesses.
Recently I haven't been able to use the ? operator, and everything can only be unwrapped. Is there a reason that STD::result::Result had to be unwrapped instead of using a question mark?
Thanks for the big comment and giving me many ideas! Dystoipa is super early stage now, and I'm noob on this area. so I'll try to apply the ideas as possible. I don't know about the HORNET, so let me make it as out of scope of this comment. Sorry. &gt; At a quick pass over the code I see you're using TCP, like tor.z Yes. UDP should be supported as well but not for now. &gt; RSA? Eh. Please use something modern like curve25519 or IMHO better Ristretto255. Sounds cool! I might change the implementation as you said. Could you tell me the critical problem of RSA? &gt; Tor is not fixed at 3 hops, the client can decide how many hops it wants. Oh I didn't know that. Will remove it from docs. Thanks. Again, thanks for giving me many ideas and teach me many things! I'll read whole including the paper when I have much time.
Unfortunately there are quite a few claims that I2P provides stronger anonymity with weak conjecture and no citations to papers (at least I haven't seen any). Even [I2P's own documentation on garlic routing](https://geti2p.net/en/docs/how/garlic-routing) doesn't have any concrete definitions. But they focus on the bundling, not redundant routes; so perhaps I had a few details backwards above, but even tor does some degree of bundling due to its use of TCP. The worst detail is the use of Elgamal in every packet. Asymmetric operations are relatively expensive, especially compared to symmetric crypto. HORNET for instance only uses asymmetric operations for the setup and uses only (fast!) symmetric operations afterwards. Better, HORNET relays don't need to store any per-connection state (as the state is embedded in the packets) they can be implemented with multiple threads or on multiple servers without synchronizing connection states.
I agree, writing it explicitly makes more sense and making the program much easier to read
Have you been using `?` within a function that returns a `Result`? If you were trying to use `?` within `main` for example it wouldn't work.
This *HORNET* you are mentioning sounds idealistic, but is it realistic? Are you one of the authors of the paper you linked? And is there any code out there yet for this?
Thankfully there is no critical problem with RSA, it's just that we have better cryptography based on ECC now. Keypairs can be significantly shorter and the algorithms overall are less computationally expensive.
Trying to implement multiplayer version of my [Ludum Dare game](https://ldjam.com/events/ludum-dare/44/lifeshot)
I've been writing Rust for the first time this week. And for the life of me, I can't figure out this one simple idea. I have three fields, `[u8;12]`, `[u8;3]`, and `u8`. What is a decent way to destructure a `u128` into these three fields? Getting a `[u8;16]` from the `u128` was pretty straight forward. Then I tried `split_at`, but that returns a slice and not an array, so I take a hit in converting it back into an array. I've resorted to the following, but it just feels like there should be something better. let a: [u8;12] = [bytes[0], bytes[1], ...]; let b: [u8;3] = [bytes[12], bytes[13], bytes[14]]; let c: u8 = bytes[15];
What's the reason for restricting weights to -1 to 1? That seems a bit restrictive because it may make it harder to model things like a road network with distances (everything has to be scaled). Additionally, my impression is 1 is often a more reasonable default: e.g. using weights of 1 for an "unweighted" graph means a shortest path algorithm will automatically work (and compute the least number of edge-hops required, as one would expect for a unweighted graphs), whereas I don't think 0 has this property.
Differences with tor += UDP support! RSA has large keys, is slow, and is rarely constant time. You either need to spend lots of extra time to make RSA constant time or use dedicated hardware. RSA keys are on minimum 256-bytes while ECDH keys can be as short as 32-bytes (or shorter, but lets say 32 because curve25519). Curve25519 is safe as-is for Diffie-Hellman and Schnorr (X25519 and Ed25519 respectively); however Ristretto is safer for more complicated complicated protocols without adding complexity. For instance I need Ristretto to implement the handshake in Sphinx. I recommend it for either use nonetheless. Glad to help. BTW: If you'd like to follow my projects, they can be found on [Gitlab /sio4/](https://gitlab.com/sio4/). I haven't published much yet (basically nothing). The description in my first comment is probably more useful than the empty repos. ;-)
Lots of code review for PRs to [`uom`](https://github.com/iliekturtles/uom) (Units of measurement -- type-safe zero-cost dimensional analysis) over the last week. I also submitted a [PR](https://github.com/rust-lang/rust/pull/60562) to rust to fix `missing_docs` warnings in proc-macro crates.
I believe the preferred logger in the MCU is The Collector. He does collect any and all objects of interest, like infinity stones, Howard the Duck, etc.
The library still doesn't yet have a shortest path iterator :(. This should be in the v0.4 release. I am quite focused on [Purple](https://github.com/purpleprotocol/purple) at the moment but when I find the time I will also try to implement shortest path iterators. I will take into account what you said when I do so. Also, if you are interested into contributing to open source you are welcome to open a PR for this.
You are saying that you are on windows right? Libc is not compatible with windows and is build for Linux systems only.
I believe it is more realistic than tor. No I am not one of the authors of any of the linked papers. The authors of HORNET have their own simulator for HORNET but they haven't published it. My implementation is partial and not published yet, I'm mostly working on its dependencies under my extended design. All my code will be public on [Gitlab /sio4/](https://gitlab.com/sio4/). Currently the repos are mostly empty. HORNET was designed to run on [SCION architecture's network](https://scion-architecture.net). SCION's HORNET is designed to run at the network layer on their ASs. Though I'd appreciate SCION superseeding BGP and IP, I'd rather follow Tor with respect to volunteers running the relays, not the ISPs, and that the user should be able to select any routes, not just the routes directly reachable by the ISPs. SCION have also designed a sister protocol to HORNET, known as [TARANET](https://arxiv.org/abs/1802.08415) which at the cost of 5x the latency of HORNET, half the throughput of HORNET, and the loss of endpoint anonymity; is able to defend against active global adversaries, IIUC using some techniques from Loopix (linked earlier). The users aren't anonymous among themselves but the network can't link them. Due to the necessary user load, I don't find TARANET as realistic though it is interesting and may find its uses too.
Trying to convince my teammates to write new web services in Rust instead of Go. In the meantime, I've built a small auth service using Actix+Diesel+GraphQL and it's working great!
Yeah, I don't like that the definition of c gives no indication that it accepts a parameter. What if you defined it as: `let c = |x,y| a(x) + b(c)` Called as: `c(5,7)` The implicit default to bind the parameters to a single source parameter is very unnerving. Both from language design, and moment to moment usability. It will be one of those gotchas you shake your fist at but are forced to learn to live with it because it's stable and everyone has learned to cope.
&gt; I'm noob on this area Ugh. Security amateurs making security applications a bad combination.
Just digging through random projects, fuzzing, looking for bugs. Also taking a chance to update the rust fuzz book.
Why does it matter?
Agreed. It would be nice to see this note lifted into the documentation. A toy network with no review from cryptographers etc disclaimers.
So I'm working on something interesting, a [2D renderer that uses modern GPU compute](https://github.com/linebender/piet-metal). My immediate goal for the week is getting that to demo state (rendering the Ghostscript tiger correctly) and writing a blog post. Also preparing presentations for the [Libre Graphics Meeting](https://libregraphicsmeeting.org/2019/), which is coming up.
From the โpapersโ there is also this huge red flag to me: &gt; It is very hard to argue why the building blocks of path semantics requires publishing to be reviewed for correctness, since they are already widely used in mathematics. Equations and commuting squares are not new. Some new syntax with an equivalent equational form does not introduce unsoundness, although it could be interesting to read. My argument here is that this might be published because the audience finds it interesting, not because they expect to find errors, but this depends on the audience. &gt; They are widely used in mathematics. Funny that Iโve never heard of them before. &gt; Some new syntax with an equivalent equational form does not introduce unsoundness, although it could be interesting to read. In other words path semantics shouldnโt be published because it doesnโt actually offer anything new compared to type theory? So then why did you write all this stuff?
that's funny, everyone else just does this: !value
That's some classic /r/iamverysmart material.
Is there any reason the actions are stringly typed instead of using an enum on which you pattern match to get the right function?
There is also [macro_railroad](https://github.com/lukaslueg/macro_railroad), which is quite nice for viewing macros, [demo!](https://lukaslueg.github.io/macro_railroad_wasm_demo/?m=macro_rules%21+count_exprs+%7B%0A++++%28%29+%3D%3E+%7B+0+%7D%3B%0A++++%28%24e%3Aexpr%29+%3D%3E+%7B+1+%7D%3B%0A++++%28%24e%3Aexpr%2C+%24%28%24es%3Aexpr%29%2C%2B%29+%3D%3E+%7B+1+%2B+count_exprs%21%28%24%28%24es%29%2C*%29+%7D%3B%0A%7D%0A).
Instinctively I would do this by reading in bytes, transmuting then, and then checking endianness. However it's probably better to do this without unsafe (even though it is safe)
Not exactly tutorials, but this guy does great Rust live coding streams [https://www.youtube.com/channel/UC\_iD0xppBwwsrM9DegC5cQQ](https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ) &amp;#x200B; I have learned a lot watching that.
Here implemented in Rust (without `+` syntactic sugar): [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1d1de4aa2d0abe3e68c1ee2c259ab086) use std::ops; fn add&lt;T, Lhs, Rhs&gt;(lhs: Lhs, rhs: Rhs) -&gt; impl Fn(T) -&gt; T where T: Clone + ops::Add&lt;T, Output = T&gt;, Lhs: Fn(T) -&gt; T, Rhs: Fn(T) -&gt; T, { move |val| lhs(val.clone()) + rhs(val.clone()) } fn main() { let a = |x| x + 1; let b = |x| x + 2; let c = add(a, b); println!("{}", c(5)); // prints 13, i.e. (5 + 1) + (5 + 2) }
I think you want the lazy\_static crate, or possibly the phf crate.
&gt; We will make a final decision in the May 23 meeting of the language design team. Until then we will do our best to actively engage with the community discussion of this proposal and its justification, and are open to hearing counterproposals. &gt; [...] &gt; I firmly hope that everyone will extend to us good faith that we have considered this decision at length and very seriously, and have discussed and thought about all options. Given the passion that syntax discussions tend to stir up, I ask everyone who intends to comment in this thread to keep this in mind.
Is because moving. Each iterator operation need to "pass" data to the next and moving into a struct is the way.
r/playrust
Your are on the Rust programming language reddit channel. You are probably looking for the Rust video game channel r/playrust
While I was initially a very strong supporter of the prefix syntax, even with the various issues interacting with `?`, etc, I have to say I think `.await` is a very reasonable choice and I'm glad to see this being resolved. Kudos to the whole lang team for working on this so long even through the massive amount of community feedback!
I see. I might change it for the performance reasons.
I still think that prefix await and a sigil as a pair of syntaxes would also be good but I like the idea of expr.match
Thanks! I'll watch your project.
Happy to read that this finally get's resolved.
It seems someone add nodes to your public cloud! Thanks!
You may like [this crate](https://crates.io/crates/im) for immutable data structures.
We could just use `โฝ` as the sigil for parity with `?`... ๐
While I preferred prefix, all of the reasoning in the article was very well considered and having a decision brings a good wave of relief. It also means that I can start the rewrite of some of my crates with the new syntax before it's fully stabilized.
I prefer the left to right unicode character, because that will make all the await code very spicy.
Well, you can specify that main returns a Result now so that the ? operator works.
Interesting. I personally would have taken possibly any other approach (except method syntax, which makes no sense). The justifications are sensible to me, though I don't think I really buy the argument against the postfix macro. The argument against the macro isn't so much "here is the downside" but "it lacks consistency". I don't buy that the postfix \`.\` operator being expanded to encompass this is any less consistent, practically. While postfix await! may have been 'invisibly' a builtin like format\_args!, it would have fit in with a more abstract mental model of what "looks right" in rust (assuming that postfix macros were generally accepted). Anyway, I really don't know anything at all about language design, and I trust the rust lang team, and I honestly don't care that much because in the end I think all of the downsides are going to have extremely minimal impact on me, personally.
I find this genuinely suprising, since the 'magic field' syntax was one of the most (if not the most) disliked option from the discussions I've seen thus far. I believe the lang team is looking at this from all angles, but find it concerning that recent community sentiment hasn't been discussed (that I've seen). I'll admit the argument could be made that recent reddit polls/discussion, IRLO discussion, etc. aren't indicative of the entire community (and reddit specifically can be negatively biased), but I don't see any better way to get the pulse of the community. I wonder if it's more an issue of missing the forest for the trees? It's easy to be too close to the problem, and thus difficult to see how jaring certain decisions or proposals can be to those who arne't so heavily involved (yet just as invested). The only thing you can do about that is query the community over a long period of time (in order to give those who arne't so active a chance to voice opinions). I personally think the magic field syntax is too far a departure from standard Rust syntax. And the fact that it opens the door for other similar ways to do things (`foo().bar()?.match`) I *really* don't like and it almost looks like it could cause a rift between the various ways in which to do something in Rust. I haven't yet seen any concrete reasons why 'await blocks' (either with `{}` or `()`) aren't a good (enough) solution? The only mildly compelling argument I've seen is deeply nesting await statements suffers the same issue that `try!()` did (`try!(try!(try!(foo()).bar()).baz())`). I believe deeply nested await calls are far less common than deeply nested Results. I would imagine more than two or so await calls in a single expression will become difficult reason about no-matter the syntax and thus a code smell (unlike Results). These are just my thoughts, offered in good faith.
https://github.com/rust-analyzer/rust-analyzer/ is one of them. The simplest explanation is that you don't _need_ to use argument-position `impl Trait`, but it's an option you have.
I'm not convinced that your analysis applies beyond the simplest case of "I need to copy a lot of stuff relative to the cache sizes on a UMA machine." If the copy will be modified in place, then each chunk should be copied by the thread which will modify it. The increased write coherence decreases inter-core traffic and avoids latency. Even though it doesn't make the copy faster it sets up for a faster modification. I'm still trying to understand what OP is trying to do, but if it's a clone-map pipeline then it makes sense to parallelize both. (Especially since current AMD vs Intel performance make a strong argument against Intel's one big fast cache concept.)
The \`try\_into\` way is the best. Your code does't have to panic, since you can handle \`try\_into\`'s \`Result\` which way you prefer. &amp;#x200B; You can use [unions](https://doc.rust-lang.org/reference/items/unions.html), but it will involve using \`unsafe\`... &amp;#x200B; You could, potentially, have a "makeshift union" with an \`enum\` (tagged with \`#\[repr(C)\]\`) and have one variant be your \`u128\` and the other a tuple with the 3 arrays... I know this sounds crazy, because it is.
I (ab)used it [here](https://github.com/axelf4/lis/blob/36a0d653f3653104f4d0aabfa67bea98b870000a/src/lib.rs#L244) in my LIS diffing crate, a whopping 7 times in the same function.
I'd like to thank the lang team for demonstrating their willingness to thoroughly engage with the community and take their time considering all the proposals (some might say they were over-willing, but I'd say that's the better side to err on). I haven't participated in the syntax discussion but I have been (sometimes glibly) in favor of `.await` from the start, though that statement alone obscures the truth of my feelings: that Rust (and every other language trying to bridge the past to the future) is unfortunately poised at the confluence of classical prefix notation and the postfix, method-style, "fluent" notation that emerged with Smalltalk in 80s, accelerated with OO in the 90s, and exploded via dynamic languages in the 00s. Any attempt to enforce both styles simultaneously runs the risk of C-style "spiral interpretation" madness, which is not only the key point of tension in this discussion, but also for the prior `?` discussion. I think that, for English-speakers at least, programming languages will continue to trend towards postfix notation; my hypothesis is that the subject-verb-object order of English makes it more natural for these people to intuitively understand `subject.verb(object)` than `verb(subject, object)` (much to the chagrin of Lisp users). Of course, others may disagree, which is why I'm eager to see future proposals in the vein of those mentioned at the end that would allow certain keywords to be either prefix or postfix, in the same way that UFCS (or whatever it's called these days) allows method calls to be either prefix or postfix; I'm not generally in favor of language maximalism, but in this case I think it will help assauge the tension between those who favor subject-verb-object and those that don't, as well as allowing subject-verb-object thinkers to express ideas that are more naturally expressed in prefix (not all statements need to have a "subject" (e.g. a command), in the same sense that not all functions need to be thought of as having a receiver. I support this proposal as a path forward to at last getting Rust's async story out into the world for its users to finally benefit from.
I've given this a lot of thought. I know the `.await` syntax seems to be unpopular, especially on reddit. But over time, I've warmed up to it being the most reasonable, despite it's major flaw of "looking like a field". Postfix seems to be the proper place for it, and `.` just seems to be the way to "chain" something on the end of an expression. I just have to shift my thinking from `.` being for "fields and methods" to also include "postfix keywords". I hope that we can all get through this without too much public backlash, whatever the decision ends up being.
[According to this survey](https://www.reddit.com/r/rust/comments/bju8di/asyncawait_syntax_survey_results/), the 3 different options that had more "yes" votes than "no" votes were: * The "obvious precedence" syntax: `let str_response = (await http::get(url))?.to_string();` * The postfix macro syntax way: `let str_response = http::get(url).await!()?.to_string();` * The mandatory delimiters way: `let str_response = await { http::get(url) }?.to_string();` I know this wasn't an official poll, nor that popular poll results are always the valid choice, but can we get some explanation as of why they weren't chosen? AFAIK only the 2nd option was explained to be "not possible" in this article, but nothing was written about the 1st and the 3rd. I even thought that until now the default would have been the first option. Could we get some more explanation on that side?
I am utterly confused what you're trying to do. Could you describe what the CPU should be doing, step by step but not using a programming language or Rust-specific vocabulary?
I'm very excited about the possible addition of `expr.match`! I use the ["Magic Completions"](https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/features.md#magic-completions) of the [`rust-analyzer`](https://github.com/rust-analyzer/rust-analyzer) project a lot because they make typing much easier. Supporting this syntax in Rust itself sounds like a great idea!
Another [example](https://docs.rs/hyperminhash/0.1.1/hyperminhash/struct.Sketch.html#method.add).
This is really unconvincing. The magical field access syntax is disliked by 67% of the community and thus cannot be the 'least bad' solution. Even if you ignore this appeal to popular opinion, special casing field access for control flow is just super weird and I'm not even a rust beginner.
It was at the start. They categorized all options as prefix or postfix and the majority of the lang team wanted postfix. Thus it wasn't about all the options but just the postfix ones.
I dont know if it was proposed, but what about `-&gt;await`? The arrow already exists in the language, in a completely different context (function signature) so there cannot be any confusion, and it avoids the confusion with the field syntax.
The fact that this was one of the less popular choices is why this post discusses what the team sees as the problems with the other postfix choices at considerable length (the debate between prefix and postfix having been the subject of the previous lengthy post). The unpopularity of this choice in polls and discussions is directly acknowledged in my post. I don't know how you could interpret this as not engaging.
I still canโt get to like any of the postfix syntax ideas. I tried to like them but they donโt fit.
I had similar thoughts about match at first, however it would actually be nice for removing nested matches since you would be able to chain them. There are already multiple ways to do the same thing where the "correct" answer isn't necessarily clear (e.g. for ... in vs for_each and generic return vs impl trait). I'm not saying adding more ambiguity is okay, rather that it's an opportunity to tackle the issue more systematically using guidance and lint rules.
Postfix vs prefix was the main subject of the previous summary post; the language team (except for me) either mildly or strongly favored postfix for the reasons laid out in that summary post. This post focuses on other postfix syntaxes because the trade off between prefix and postfix syntaxes was already described at length.
While I agree that \`.await\` is a reasonable solution, I would argue that the subject verb order goes in favor of prefix syntax. Subject verb order for me would really be [subject-verb-*object*](https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object). I believe that would look like this: ``` let subject = verb object; // Translates to: let result = await request; ```
If only we had holographic keyboards already in common usage.
Before reading this article I was firmly in the postfix `@` camp. However, this writeup has convinced me that a postfix `await` is the correct way to go, primarily because of the suggested future expansion to `.match`, which would be ๐ฅ. However, I think that reusing the `.` operator and field access syntax specifically feels icky. On the other hand, it's important to remember that Rust has already pushed the design space of `.`. That is, methods may be defined in a variety of locations, not just at the type's definition site. ยฏ\\\_(ใ)\_/ยฏ
I like the arrow myself. It would also look fine for their idea of postfix "match". foo().bar-&gt;match { ... }
I am glad they made a decision but sad that it is \`.await\`. It is already an uphill battle to get teams to adopt Rust, this is just one more thing that is just weird to outsiders. Any time you have to describe a feature as a "magic" whatever, people tend to look at that feature unfavorably. All the things written on how \`await\` isn't really a macro, also apply to \`await\` isn't really property access.
Wouldn't subject-verb-object be an argument in favor of prefix notation? As in: ``` let subject = verb object; // Translates to: let result = await request; ```
I was also in the prefix-camp before, but I really think these reason are well laid out. the `.match` syntax gives a really good example of how this syntax can be expanded to apply to other keywords as well. Overall, I'm just happy a reasonable conclusion was reached, and I hope that we can now conclude this tribal war.
I had posted that early on in the interals thread. From the wording, I don't think the want any special sigil.
I'm surprised it wasn't the mandatory delimiters way, since `match { }` and `if { }` was a thing I don't even care, I'm just surprised
I'm thrilled to see this approaching resolution. I was admittedly not an enormous fan of the postfix dot notation, but I find the language team's arguments compelling. I'm especially excited by the the idea that we might think of `.` more broadly as a sort of pipelining operation.
Oh ok. The wording in the article did let me think that they did not want to use a new sigil.
It's possible for something to be "the best" and "not the least bad" at the same time. "Least bad" tends to prioritize familiar options with limited risk and limited downside. But the "best" option could be something with high risk and big downsides, yet even bigger upsides. I think the outcome here is that most of the lang team _agrees_ with you about the downsides, but they also see even bigger upsides.
While I would've preferred the postfix-macro syntax (mainly for the "magic is happening here!" argument), I'm happy with the dot-keyword syntax. But I'm glad this discussion is finally close to its end and that async/await is finally on track to reach stable (it felt like we could've been bikeshedding this forever) Great job to the lang team for sifting through all the discussions!
I started firmly in the prefix camp because it's what I knew. It's what I had learned. Familiarity was the only reason I wanted prefix syntax. Yet we need to step back and consider that async/await is still a relatively new construct in programming languages. Just because there's precedence and familiarity with the prefix syntax, does not mean the prefix syntax is the correct syntax in the end. I've thought this over a lot myself, even posted on internals about it and I feel like in the end, especially the way rust is evolving and the way current rust code is written, that postfix syntax is the correct way to go for the language. I was more in favor of the method like syntax, but in the end the () just ends up being a superfluous appendage to the operator just to make it feel more comfortable. Going with the "field-like" syntax, the more I reason it through, is certainly a viable choice. Especially given that we already have to disambiguate between various things that can follow the . operator as it stands. It's not hard to mentally add another branch to that reasoning. In the end I'm more happy there's progress being made on this feature, because it's at the top of my list of my most desired, upcoming rust features.
You could certainly implement a logger that writes to a file then
Yes, ultimately the bikeshedding has to stop. I was a fan of .await() (i.e. pretend it's a method, maybe backed by a trait) or even .avait!() (we are a postfix macro!) but further thought that we are used to *prefix* keywords (if,match,etc) and find *postfix* keywords odd. And comes from familiarity with the Algol family of programming languages - there is no God-given reason.
Overall, I'm still processing before deciding what of my thoughts are beneficial to post but I do want to call out one part: &gt; First, by using a reserved keyword, it will be differentiated by any syntax highlighting system. While I use syntax highlighting where possible, I find reliance on code viewer/editor features should not have its place in language discussions. The features are not universal. Not all forums will do syntax highlighting, hiding important control flow in discussions. Its also less common to have it when viewing diffs of code which is where control flow should be the least subtle.
depending on if you're willing to work with unsafe code(given you don't like the idea of using code that could panic you probably won't use this) in one of the most unsafe ways possible you can use [mem::transmute](https://doc.rust-lang.org/nomicon/transmutes.html) to transmute a u128 into a tuple of [u8;12], [u8;3], u8 [Rust playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=404f9a2f483863deaa1078e2f3ae7846) use std::transmute; let x:u128 = (insert num here); let n:([u8;12],[u8;3],u8); unsafe { n = mem::transmute::&lt;u128,([u8;12],[u8;3],u8)&gt;(x); }
It is only hinted at in the conclusion, but there does appear to be a hopeful suggestion that someday this notation will be slightly generalized to allow `await` to appear in prefix notation where preferred.
I've always found that prefix match is quite unergonomic, having to move the cursor back in front if the method call once you realise that it returns an enum that you have to deal with.
&gt; some members of the language team are excited about a potential future extensions in which some โexpression-orientedโ keywords (that is, those that evaluate to something other than ! or ()) can all be called in a โmethod-likeโ fashion I'm sure everyone carefully avoided predicating "dot await" on this idea, which makes sense politically (too much to argue about all at once), but it definitely makes me like "dot await" more. A "dot match" syntax would be so awesome.
This is very exciting! It would be nice to have a roadmap to alleviate the expectations. Looking forward to seeing the clusters API covered.
I am afraid that the field access syntax would make rust more unfriendly to the new learner or users unfamiliar to the async/await. &gt; Even if not using highlighting, many users will be familiar with languages using an async/await syntax; while those languages will probably have a different syntax for the await operator, they will still recognize the await keyword as indicating something unusual is happening. I think the above reasoning in the proposal is weak. In reality, there will be a large amount of users have zero knowledge on the whole concept of async/await. And this is fine since there are way more many user cases not involved async/await at all. For example, a data scientist doesnโt need async/await to build machine learning algorithms (See python as real example, async is rarely used in PyTorch). So for such users who donโt use async at all, the proposed await syntax would be almost certain to be understood as a field access operation when they come across one. Considering rust already has such a deep learning curve, I am afraid this proposal syntax would make rust even more inaccessible to new users. My take away is that although we are talking about async/await, the whole concept would only make one small portion of the whole language (arguably an important one). There will be many rust users who donโt use it at all. Therefore, I think consistency in language syntax is important.
I apologize, I didn't want my post to come off as negative towards all the work you and the lang team are doing! Yes, I'm not in favor of dot expr syntax, but that doesn't mean I'm not immensely greatful for all the work that is being poured into this. I just wanted to voice my thoughts on the syntax before it was too late to do so. I think what I wanted to say above, was similar to Manish's post on IRLO in that the proposed solution is predicated on several facts and doesn't go over the *why* or how those facts contrast with recent community feedback. The previous Dropbox paper did an excellent job setting up the discussion and explaining the various tradeoffs, but it felt like the very next thing from the team is a conclusion. I guess I just wanted more back-and-forth from the team on how the conclusions were reached after addressing community feedback. Either way, I trust the lang team to make the final decision. Thank you for all the time and effort you've put into this feature!
Picking a risky, unpopular option doesn't magically give it significant upsides. Special casing innocuous field access should trump any upside there is, because it's too weird to control flow by a field access.
&gt; name of module Careful, that's a homonym for a different concept. A cell in that sense is a mutable memory location - one where you can't rely on `&amp;` references being non-mutating. A "cell" in the sense of "part of the simulated state" is a data record; it probably corresponds to `struct` in Rust. I'm expecting each "cell" in a CA to update simultaneously (from the perspective of the simulation rules). There's nothing in the rules that describes or depends on before/after distinctions smaller than a step. Obviously your rules may be different. Rust's `cell` enables situations where the execution order of the computer is likely to leak out and affect your results whether or not you intend it to. And `std::sync` does the same thing, but at least the problem is more obvious. Everybody knows that threads can be interleaved however the computer chooses. (Interleaving might not even be a 100% accurate model.) It's shared mutable state, not concurrency, that exposes a program to order-of-execution effects. The only thing that's easier about a single-threaded program is that the order of execution is (almost always) specified by the program. If you write something using map-reduce techniques which don't depend on shared mutability, it won't matter what order the threads are executed in. That's why `rayon` in Rust is such a big deal: when it fits your algorithm, you don't have to think about how the concurrency happens. It just works.
This also sounds very reasonable to me. Thanks for sharing
Most of the arguments against the alternatives were things that I had not personally considered all that deeply, but which make some amount of sense. Overall I was very impressed with the reasoning and tone of the article. I have no problem at all believing that the decision made by the lang team will be better in the long run than a decision made by a community poll.
They discuss this in more detail [here][1]. [1]: https://boats.gitlab.io/blog/post/await-decision/
Is it? That's not how I read that at all.
Me too; I'm happy with the proposal. Good work!
For reference, I think this shows how the proposed example would look like in a project: [https://github.com/inejge/await-syntax/blob/postfix-field/bin/wlan/wlantool/src/main.rs](https://github.com/inejge/await-syntax/blob/postfix-field/bin/wlan/wlantool/src/main.rs)
"!value" is far from a solution, it would consume any true value when map_false() would explicitly pass any true value. See: https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err
And then what does rustfmt pick? What should I pick?
You cannot make those claims about those numbers at all. And Rust has never been a language where we simply make design decisions by taking polls.
/u/desiringmachines Can I write code like this? let x.await = returns_future(); let (x.await, y.await) = returns_pair_of_futures? (that is, can we do destructuring / pattern matching on await ?)
Seems like it would make more sense to introduce it as a prefix operator, consistent with other keywords, and then (possibly) generalise all keywords to appear in postfix position at a later date, if it's determined to be worthwhile?
You can do this. You'll almost certainly need unsafe, and you'll probably need to make system specific calls for it, so try to find a crate that abstracts that for you. The way this works with native code is that the application is somehow (via input or configuration) aware of the location of one or more files that are dynamically linked libraries. Each library is a plugin. The program asks the OS to load and link that library into its executable at runtime, using some sort of system call. The system call(s) provides some way to interrogate the library, find its functions, and make calls to them. The bit of code that does the loading then attempts to abstract the library's functionality behind some nice interface. In Rust, that would probably look like a trait object. So what you want to end up with is something like: fn loadPlugin(path: &amp;str) -&gt; Box&lt;dyn MyPluginTrait&gt; { ... } Filling in the dots is ultimately system specific, not trivial, and probably requires unsafe, but ultimately not rocket science.
Yes that was my last option if none of the existing options work and I wasn't too sure about thread safety in existing crates as it wasn't clear in the documentation.
Right now we are only adding await in expressions.
Wasm based plugins with wasmer.
That was it. I was inside main. Thanks for the info.
Makes sense to start there, thanks.
Hello! Yes, I have researched into converting the str (which comes from a Struct, populated by serde from JSON). However, I would still have the issues: * Large match blocks for matching the string to the possible enum variants * Although I have looked into using the `enum_derive` crate which brings the `EnumFromStr` macro which lets me avoid manually coding the match block * I would still have to construct the HashMap with the each enum variant against the appropriate function. Also, serde can't coerce the JSON string value automatically into the new custom enum (AFAIK, maybe it can?), breaking my ability to simply use `let action: QueuedAction = serde_json::from_str(action_json.as_str()).unwrap();` By having str, I can avoid the need for the large match block in the string-to-enum and each variant in the HashMap construction.
While `.await` wasn't my preferred syntax, I'd rather have something decided upon than have my preference be the decision. I've seen enough syntax bikeshedding in my day to know that everyone will forget about the alternatives after spending a couple of weeks working with the new standard. Kudos to the language design team for weighing the available options so carefully, and for making a well-thought-out decision!
I actually don't mind unsafe... But this will keep native byte order, right? I didn't mention before, but I do specifically want BE / network byte order. I'm calling `to_be_bytes`
I don't really understand this choice. `await` is, at the end of the day, a control flow modifying operations. For every single other control flow modifying operation (sans `?` which I'm not a huge fan of to be completely honest) we have a prefix, standalone keyword: `if`, `loop`, `while`, `continue`, `break`, `match`, `return`, etc. Suddenly adding a postfix dot operation that conflicts with field access is honestly mind blowing to me. Why isn't a prefix keyword acceptable? It works perfectly fine for C# and JS, is non ambiguous, and is a well known paradigm. &gt; In particular, some members of the language team are excited about a potential future extensions in which some โexpression-orientedโ keywords (that is, those that evaluate to something other than ! or ()) can all be called in a โmethod-likeโ fashion. Yes, let's now fracture the language into two. This sounds like an absolutely fantastic idea.
I've looked into this and this seems to be exactly what I want! I'm currently checking into whether or not this is instantiated once per thread or if it's global. If it's global I will need to be careful otherwise I could end up waiting on locks a lot since some actions can take a few seconds to process and that would cause other threads to stall. I'm experimenting to see if defining the lazy static inside a `thread_local!` macro is compatible which would resolve problem since each thread would then have it's own copy of the dispatch table. A tradeoff of memory vs. speed which I'd be happy to make.
&gt; mainly for the "magic is happening here!" argument That argument is why when you declare a "struct foo" in C, the name of the type is "struct foo" and not "foo". Once people are comfortable with a thing, it doesn't need to stand out.
_If_ author intents to modify that data in a clone-map fashion, then yes - multithreading _might_ be beneficial. I was referring solely to code provided by OP, where no further work except cloning is being done (that's why my entire comment is just one big `by the way`) :-)
This is a good beginner question and a more concrete answer may help you get a handle on the type system later. The reason is that the trait method `Iterator::next` must do different things in different situations. It might make sense to combine the types `Split` and `SplitN`. It certainly doesn't make sense to try to also implement the features of `FilterMap` in the same struct. Instead, the standard library uses composition - `Map` etc. are each wrappers around the underlying iterator or iterators until you finally get to state for iterating over a memory structure - something like `&amp;str` or `btree_map::Iter`. All the iteration state (induction variables, closure upvalues, etc) is collected in the outermost iterator struct. `next` is implemented by the outside level and calls `next` for the inside level as needed. This continues until reaching a `next` implementation which understands the underlying data structure. The calls are done with static dispatch as much as possible, so that optimizer can inline functions. With some luck the result is a loop that integrates everything the compiler knows about what you're trying to do (splits and filters and folds etc) and also how the data structure works. There *are* ways to try to encapsulate all that stuff under concepts that exist in a type system. But that level of abstraction has a reputation for being more trouble than it's worth and certainly a lot to throw at newbies. ("I โค`&gt;&gt;=`" would make a great t-shirt for geek swag, though.) Rust is cautiously integrating those type system features. `impl Trait` is one step.
`match` is currently prefix, but the article hints at opening it up to postfix dot syntax. Thus the same should be possible for all expression based keywords (`return`, `break`, `continue`, `while`, `if`, etc.). So if all expression keywords open up to be allowed in postfix dot syntax, it would follow that await would similarly "go the otherdirection" and allow prefix syntax as well.
I don't see the reason to need to handle a `Result` at all. I'm starting with an array of 16 bytes, and it's obviously able to be split into 12, 3, and 1 bytes. Makeshift union will use native byte order, right? I didn't mention it before, but I do specifically want BE / network byte order.
...you are missing the point. Somewhere, someway, you use that bool value. It comes out and goes somewhere. You can always negate it there. This is the right way to do this instead of adding in a function call for no reason.
&gt; But over time, I've warmed up to it being the most reasonable, despite it's major flaw of "looking like a field". This is called Stockholm Syndrome.
`lazy_static` is global. if you want something to be thread local then just use `thread_local` on its own without lazy_static
match statements definitely are more code, but I suspect it'll give better performance than a HashMap of function pointers. Personally I prefer the type safety an enum would give (i.e. errors would be detected at the deserialization boundary), but that a trade-off that you have to make. However, [the documentation of serde](https://serde.rs/enum-representations.html) gives some useful techniques to deserialize directly into an enum.
I'm very happy that a decision was reached, and also happy that `.await` was chosen. As a C# user, I've frequently been frustrated by the inconvenient precedence of prefix standalone `await`, and as a German keyword user, I'm happy that there won't be even more braces to type.
Might be a stupid question, but the article states: &gt; In this world, the dot await operation would be generalized so that await were a &gt; "normalโ prefix keyword, but the dot combination applied to several such &gt; keywords, most importantly match Would this mean that it would also be possible to call `await` in a prefix way (`await foo()`)? Personally I still only understand very partially the whole async/await thing, but I'd prefer consistency in keyword usages (e.g. if you can call `match foo` and `foo.match` then you can also call `await foo` and `foo.await`). I am not fan of the "only keyword who is postfix" but if it leads to extending the language to allow more possible flexibility everywhere which can just be seen as syntactic sugar, I guess I'm cool with it. (Not that I think my views on that matter are that relevant anyway ^^).
The same is true for Result is it not?
I feel like the argument against a postfix macro is pretty weak. Yes it technically isn't a real macro, but there's so many builtin macros and derives that people already don't expect a lot of these to actually get expanded to surface syntax. So it would entirely be fine to have a .await!() postfix macro that simply expands to MIR level syntax. This not confusing and people already know from the very first time they encounter Rust with the hello world, that macros are not just normal functions.
&gt;In brief: we intend to make a final decision on May 23, and we currently favor adopting the โdot awaitโ postfix syntax This is bloody retarded. Even if you justify it by initial confusing will pass, it is still butchering existing syntax as dot is used to access methods/fields as of now. Instead you create fucking keyword that starts with `.` Just use existing keyword `await` and stop treating `await` as if it would be applied to values rather than expressions.
The poll also lacked the opinions of people like me who couldn't vote because there was no option for "I found all the opinions to have sensible arguments behind them and can live with any decision the team makes".
I was always in the postfix camp _but_ I'm very against introducing new special cases into a language (especially into the syntax of the language), so I'm glad to hear there's been some serious thought about generalising this syntax (might even mean the prefix folks get their cake and eat it too).
I can't help but feel there are far more confusing areas in Rust (macro's for example) that users struggle with even with the docs at hand. This definitely scores low on the confusion scale and considering how useful macro's are, a lot of people still don't get them. I would like to assume new Rust users wouldn't be eyeballing code without doing some digging into the documentation or the various learning resourcing available. If we also consider the vast number of blogs posts and discussions that will spawn when this is stabilized, you won't have to look far before you have a material that completely clears up any confusion someone new might have. Rust has become an extremely popular language despite its difficulty barrier. This feels like a walk in the park when you look at the language holistically.
No. It can have more than a bool, it acts as a wrapper around the concept of 'this item or an error' and the mapping concept can work on errors which need to be handled in one way, or items, which need to be handled in an entirely different way. We have a construct in the language for this. &amp;#x200B; if &amp;#x200B; Could you create such a thing just to continue the same pattern as map on Result? Sure. But it would be bad. It's like those programmers who create c/c++ macros so they can turn c into pascal syntax. Good luck getting another programmer to read the code. The same can be done in English. Here watch, every time I say 'snagle' I mean 'not not not', not don't collapse that idea, it's clearly important to contain three negations, it's an emphasis over a single negation. They evaluate to the same logical result but my special term 'snagle' is intended to convey extra umph! Now that can work in specialized areas (technical language, jargon, and in-group language exists) but it serves a purpose. This just seems to be all around collapsing a concept into another for no extra purpose when we already have such a thing baked into the language and specialized that way to convey a very specific concept. Convention alone would say this is a bad idea.
&gt; In this world, the dot await operation would be generalized so that await were a โnormalโ prefix keyword
You can make it thread-safe by passing all messages through a queue, and then draining the queue in a low-priority logging task. Since you're already using FreeRTOS anyways, it should already provide the necessary primitives.
&gt; I'm expecting each "cell" in a CA to update simultaneously (from the perspective of the simulation rules). There's nothing in the rules that describes or depends on before/after distinctions smaller than a step. Ah so I guess my idea is a little different. I was thinking more that in a single threaded mode, the order in which they execute or mutate would be based on elections of each cell's properties.
Thanks I will look into it.
The main reason postfix is preferred than prefix is composability with method and ? Operator. However, that can be solved by implementing either a postfix macro (correct my if Iโm wrong, but if we already have a prefix await operator, itโs possible to implement a postfix await keyword) or a postfix keyword later on. The price we pay is that before we actually implement one of the postfix syntax sugar, the community needs to write ugly code. But I reckon thatโs a fairly small price to pay, especially we get the benefit of being less alien to programmer coming from another language. Now letโs lay out what will happen if we take the postfix keyword approach. 1. Implement postfix keyword await. Syntax is weird to new rust programmer but play nicely with methods and question mark operator. 1.1. Implement generic postfix keyword syntax and promote await as a prefix keyword. Easy to learn the keyword and generic postfix syntax. Everyone is happy. 1.2. Postfix generic keyword doesnโt end up being a thing. Postfix macro becomes a thing. We can implement await as a postfix macro but postfix await is still an alien and special case syntax. Neither postfix await nor postfix await macro is easy for new comers to learn. Not so happy. 1.3. Neither postfix macro nor postfix generic keyword becomes a thing. Still has poor learnability but good method and question mark operator support. Now if we take the prefix keyword approach. 2. Implement prefix operator. Easy to learn. Initially, doesnโt play very nicely with methods and question mark operator. 2.1. Implement generic postfix keyword. Everyone is happy. 2.2. Generic postfix keyword didnโt end up being a thing. But postfix macro end up being a thing. Implement postfix macro for await (based on the await keyword). Everyone is still happy. 2.3. Neither postfix macro nor postfix keyword become a thing. Still easy to learn. Still doesnโt play nicely with methods call and question mark operator. In summary, I think we need to consider how likely postfix generic keyword and postfix generic macro are going to happen. Implementing a prefix operator gives us the flexibility that as long as one of the postfix features gets implement, we will end up being in a very sweet spot. I would say I favour implementing a prefix operator here because even if neither postfix generic features ends up happening, we can still have a postfix macro-like await as a special case for awaitโs composition with methods call and question mark operator. And (I personally feel that) that special postfix macro wonโt feel as alien as a special postfix await keyword. (Note that it should Be implementable as a macro when we have the actual prefix operator).
Thanks for this post. Initially I was skeptical of postfix notation. However, this post has convinced me that it is the best option. The options have been thoroughly considered and .await comes across as the best path forward. I am also excited about the possibility of postfix match.
That style guidelines would obviously be made when the change is introduce, but one possible suggestion would be to use prefix if you're awaiting the entire expression otherwise use postfix.
No one suggests making decisions by popular vote. Why can't I make that claim? Sure, that percentage is not perfectly unbiased and not perfectly representative of the whole community, but it does consist of opinions of people who browse the internals forum and care about the language enough to participate.
`if thing.is_err(): Result&lt;T, U&gt; { /* Do something */ Ok(whatever) } else { thing }` This is identical to map_err(), is it not?
&gt; In this world, the dot await operation would be generalized **so that await were a โnormalโ prefix keyword**, but the dot combination applied to several such keywords... Emphasis mine.
&gt; match is currently prefix, but the article hints at opening it up to postfix dot syntax. I sincerely hope not.
Yeah my guess would be native byte order... Or, well, what's in the u128... To convert from a slice of bytes / array of bytes back to longer types there are conversion functions that specify endianess
I think I've come up with a solution while I was coding a way to create a connection pool for redis and Postgres per thread without passing around the references in the function parameters all the time: thread_local! { pub static PG_POOL: RefCell&lt;Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;&gt; = RefCell::new(create_pg_connection_pool()); pub static REDIS_POOL: RefCell&lt;Pool&lt;RedisConnectionManager&gt;&gt; = RefCell::new(create_redis_connection_pool()); } So I did something similar for my AVT: thread_local! { pub static AVT: RefCell&lt;HashMap&lt;&amp;'static str, fn(QueuedAction)&gt;&gt; = RefCell::new(make_dispatch_table()); } then: pub fn process_action(queued_action: QueuedAction) { /// Try looking up the action type in the Action Vector Table (AVT) /// This saves us having to make lots of string comparisons in cumbersome match logic AVT.with(|cell| { let avt = &amp;*cell.borrow(); let lookup = avt.get(queued_action.action_to_take.as_str()); match lookup { Some(func) =&gt; func(queued_action), None =&gt; { error!("Encountered a Queued Action with an unknown action to take, skipping") } } }); } And I can also do something similar for the DB connections: fn set_realm_busy(realm_id: &amp;i64, state: bool) { PG_POOL.with(|cell| { info!("Setting realm busy: {:?}", state); diesel::update(realm.find(realm_id)) .set(busy.eq(state)) .get_result::&lt;realm_model&gt;(&amp;(*cell.borrow()).get().unwrap()) .expect("Could not update realm busy flag!"); }); } And since these objects live for as long as the thread does and never change, it seems worthwhile to do it this way. And now my log output is like this (filtered for Realm 3): [2019-05-06 17:57:27.191956 +01:00] T["RealmThread3"] INFO [src/worker.rs:38] Current system time 1557161847 [2019-05-06 17:57:27.192446 +01:00] T["RealmThread3"] INFO [src/worker.rs:40] Updating data for realm 3 [2019-05-06 17:57:27.203913 +01:00] T["RealmThread3"] INFO [src/worker.rs:75] Setting realm busy: true [2019-05-06 17:57:27.271649 +01:00] T["RealmThread3"] DEBUG [src/worker.rs:56] There are 1 actions to process [2019-05-06 17:57:27.272262 +01:00] T["RealmThread3"] INFO [src/worker.rs:86] Getting actions from queue [2019-05-06 17:57:27.277377 +01:00] T["RealmThread3"] INFO [src/worker.rs:88] Processing action [2019-05-06 17:57:27.278019 +01:00] T["RealmThread3"] DEBUG [src/actions/mod.rs:45] Preparing Action Vector Table [2019-05-06 17:57:27.278464 +01:00] T["RealmThread3"] INFO [src/actions/build.rs:6] Building something [2019-05-06 17:57:27.283500 +01:00] T["RealmThread3"] INFO [src/worker.rs:75] Setting realm busy: false [2019-05-06 17:57:29.308432 +01:00] T["RealmThread3"] INFO [src/worker.rs:38] Current system time 1557161849 [2019-05-06 17:57:29.308833 +01:00] T["RealmThread3"] INFO [src/worker.rs:40] Updating data for realm 3 [2019-05-06 17:57:29.322993 +01:00] T["RealmThread3"] INFO [src/worker.rs:75] Setting realm busy: true [2019-05-06 17:57:29.362056 +01:00] T["RealmThread3"] INFO [src/worker.rs:86] Getting actions from queue [2019-05-06 17:57:29.361648 +01:00] T["RealmThread3"] DEBUG [src/worker.rs:56] There are 3 actions to process [2019-05-06 17:57:29.375278 +01:00] T["RealmThread3"] INFO [src/worker.rs:88] Processing action [2019-05-06 17:57:29.375725 +01:00] T["RealmThread3"] INFO [src/actions/build.rs:6] Building something [2019-05-06 17:57:29.391045 +01:00] T["RealmThread3"] INFO [src/worker.rs:88] Processing action [2019-05-06 17:57:29.391492 +01:00] T["RealmThread3"] INFO [src/actions/build.rs:6] Building something [2019-05-06 17:57:29.403367 +01:00] T["RealmThread3"] INFO [src/worker.rs:88] Processing action [2019-05-06 17:57:29.403808 +01:00] T["RealmThread3"] INFO [src/actions/build.rs:6] Building something [2019-05-06 17:57:29.417084 +01:00] T["RealmThread3"] INFO [src/worker.rs:75] Setting realm busy: false Notice how `Preparing Action Vector Table` is only encountered once. So now I have one copy of the AVT per thread, evaluated only once!
Rust is already an ugly language, so what the heck, why not throw in one more wart.
I'm sorry, but I consider dot-field to be the worst possible outcome. While I still don't completely but the idea that it can't be a macro since it can't be implemented manually, or even that it can't be implemented manually at all, the field like syntax implied that you're accessing something that already exists with minimal computation. A field access causing the function to return is about the most surprising thing it could possibly do. With method or macro syntax, you at least know that something is going to happen beneath the hood.
&gt; The magical field access syntax is disliked by 67% of the community and thus cannot be the 'least bad' solution. That's not how polls work: - Not 67% of the community: 67% of the participants. - Participants were self-selected, thereby introducing bias. - The poll itself may have been misleading, incomplete, etc... notably, it may not have randomized the orders in which options were presented, thereby introducing further bias. There is no conclusive evidence that the numbers given by the poll are in anyway representative of the community. --- &gt; Even if you ignore this appeal to popular opinion Thankfully, Rust is not a democracy. There's no indication of the level of expertise of the poll participants, or indeed the community as a whole. It is actually likely that many members of the community will reach for the familiar syntax rather than investing the time and effort to consider all potential ramifications; it's a human thing. The community helps by gathering the pros and cons, and helping weighing them, but ultimately the decision is reserved to people with both have the expertise and have spent time considering all said pros and cons. Thankfully.
https://boats.gitlab.io/blog/post/await-decision/ So what other implicit magic will you be adding?
In \`variable.await\`, await isn't the subject, but the object! \`await\` is an imperative, so \`await variable\` would be the natural way to express it in English.
I think this is great news. I was really disheartened when I saw the polls :) I realize the weirdness of suddenly allowing a field access to do something magically. But it's very ergonomic and in my opinion, from teaching colleagues rust, easy to explain. So I don't agree with arguments stating that newcomers will find this confusing. It's easy to explain that this async / await thing exists and we'll get to it later. After explaining the entire async model, with polling, pinning and lifetimes, a simple detail like a keyword is nothing :)
I am actually wondering about that too :)
That's the worst syntax they could have picked. There's a reason no other language does async/await like that. It's very unintuitive and ugly.
Interaction with `?` generally shouldn't be a requirement as the `?` interaction with `From`/`Into` commonly obscures error details, and promotes non-local error handling. I'll admit I'm in an extreme minority of folks who consider `?` and `try!` to be a code smell. This won't get backported into `edition="2015"` right? So I don't need to re-name struct fields?
I'm really upset that the language team decided that Buoyant's code-golf was more important than not obsoleting all existing documentation about Rust.
The justification against postfix macro seems slightly weak. &gt; the await operator is not and cannot be either a method or a macro. If there was a prefix await (even though I favor postfix), and a post-fix macro feature, then this is trivial. This is almost a "why not both" type of solution, which I'm not sure has been discussed at length. However, postfix macros are a big feature in their own right, and I guess nobody wants to block a postfix await syntax based on a big feature that has not had any vetting, consensus or even real design.
\&gt;app (webapp) that you want others to be able to create plugins for it For server side there are at least several dlopen wrappers. From here you need either API allowing plugins to insert hooks into processing pipeline or use even-driven architecture and let plugins to subscribe to events. For user side I wouldn't bother with rust, JS is literally designed to mush together heterogeneous components.
&gt;I think that, for English-speakers at least, programming languages will continue to trend towards postfix notation; my hypothesis is that the subject-verb-object order of English makes it more natural for these people to intuitively understand `subject.verb(object)` than `verb(subject, object)` I'm inclined to agree, but I do think await is more the structure of `verb(object)` or `object.verb` as the subject seems to be the program itself. And now we're talking active vs passive voice in a programming context...
Hmm, why are you suggesting to start with "Custom Launch" configuration, and not, say, "Launch a New Process"? The latter would be much closer to the end result you want. By the way, you can debug with LLDB on Windows too, if you switch to the "native" adapter (see my other post).
I'm a fairly conservative person by nature, so of course I find the postfix syntax jarring :) Then again, I've trusted Rust in the past to make my non-conservative programming-language-related decisions for me and it's worked out tremendously well, so here's to hoping this one does too.
I did not take part in the poll because as I considered it misguided.
`unwrap` and `expect` being replaced by macros would be amazing! No more `panic in Option::unwrap`!
It was a hard sell, but I think they got me. I'm one of the people for the postfix macro solution. Good write-up.
I don't think that `(((await)))` was given proper consideration either.
using ? within main now works.
I am happy this was chosen. I am especially excited for `.match` or `.if`, coming from functional programming this kind of pipe-lining would come in very handy at times.
If you're never going to mutate the HashMap after creating it, there's no reason to wrap it in RefCell, you can get an immutable reference to a thread\_local no problem. You could also then change it into a lazy\_static, because if you're not mutating it after init, there's no reason it can't be global
Let me be clear that Iโm perfectly happy with the postfix keyword approach if we are certain that we will get postfix generic keyword. But other than match, I canโt think of any other keywords that can be postfixed. And, while I trust and appreciate that Lang team must have throughly considered a lot of options, letโs now forget the majority, if not all, of the Lang team are experienced rust developers. They many not represent the new or potential future rust developers. They are also an important part of the community.
This seems to be saying that it's fine to make the language less intuitive because it's already unintuitive. It's that really the direction you want to go? Don't you want to try making things *simpler* for beginners?
Thereโs no stable Rust ABI so youโll have to load libraries and use a C API to communicate.
That's backwards for patterns, like using `*` or `?`. Patterns use the same syntax as construction, so it ought to be something like `let async { x } = ...` by analogy to `async` blocks.
Because its fundamentally inaccurate. Polling is difficult, and throwing up a random one doesnโt really tell you much. But even then, โsome of the people who browse internals and cared to and we able to participateโ is clearly a different set of people than โthe rust community.โ
I assume you're using Linux. Do you have any C compiler installed?
I believe we should weight what feels unintuitive with the supporting material that will be available. It appears the syntax is being opposed by people who understand what async / await is and how it's used in other languages. For someone completely new to async / await and Rust it simply becomes another chapter in the documentation. I doubt this will be very confusing at all.
If I'm not mistaken, `return`, `break`, `continue`, and `while` don't return types other than `()` and `!`, so they're not likely to be expanded to postfix dot syntax.
I've been fully convinced that postfix await is the way to go, which is unfortunate because I also agree with many commenters that all of the proposed syntaxes are ugly in some way. I'd like to humbly propose a compromise, which is double dot: `request()?..await?`. My thinking here is: - we don't want to introduce new punctuation or use whitespace - we want to hook into the natural meaning of `.`, which is a "then" operation. - we don't want to conflict with field or method access. The double dot, to me, seems to be a good compromise on these points, because it's immediately obviously that this is *not* a field access, but it's similar enough that it still fits cleanly into chained operations: let response_json = request_builder() .POST() .URL(...) .header(...) .build()? ..await? .error_on_4xx()? .body() ..await? .parse()?
๐ People are saying that its behavior is confusing, but addition (and multiplication) of functions is a well defined and standard operation in math. `f = g + h` if g and h and functions, is in fact defined as `f(x) = g(x) + h(x)`. Keep in mind that math trends to treat multi-argument functions as taking a tuple. Specifically it's to apply the given operation at every point on the graph, unless you're doing something vector specific like dot product, because functions are effectively vectors in a way.
it won't keep it in native order but I think you can just reverse the order of the bytes to get the native order
.await seems like a decent option, but I still much prefer (await future)? It's obvious that await is a special operation, it does not add a new context to the . operator, it follows the standard of other langs, and the first thing you notice when reading async code are which expressions are awaited For example: doA().thenB().await.finallyC() It's not immediately obvious to a reader that this code is being awaited, but this is (await doA().thenB()).finallyC() I need to go back and read the postfix article again but it seemed like giving ? precedence over await and using ()s wasn't really given a fair shake
(I wonder how many of us there are that feel unqualified to express an opinion that have been completely silently watching from the sidelines for ~~months~~ years. Just excited to see it moving forward!)
Continue rewriting the client side code of [diwata](https://github.com/ivanceras/diwata) from elm to rust using [sauron](https://github.com/ivanceras/sauron) web framework. Adding improvements to sauron as I go along. It's been pretty smooth ride, I never knew I could replace elm architecture with a rust one. Diwata is now purely coded in rust, both server side and client side.
Thank you! &amp;#x200B; I have revised my code to: thread_local! { static AVT: HashMap&lt;&amp;'static str, fn(QueuedAction)&gt; = make_dispatch_table(); } pub fn process_action(queued_action: QueuedAction) { AVT.with(|avt| { let lookup = avt.get(queued_action.action_to_take.as_str()); match lookup { Some(func) =&gt; func(queued_action), None =&gt; { error!("Encountered a Queued Action with an unknown action to take, skipping") } } }); } Which seems much cleaner since I can remove the deref and borrow.
&gt; as a German keyword user Perhaps you meant _keyboard?_ ;)
which bls library are you using, how does it compare to Java jpbc(If you have prior usage of jpbc)?
I very appreciate the transparent discussion process. I love a lot about rust. But I need to admit that I always disliked it because of all the edge cases you need to remember. Because of its verbosity. Rust is great, but visually it's a mess. I like consistency and I like it when I can read the code and understand what I see without knowing the implementation details. And I think that a postfix dot notation would make it worse. Here is my example. A few day ago I've learned that you can implement a trait on a function. What if this function returns a Future? Something like this: trait Async { fn foo(&amp;self) -&gt; Future&lt;...&gt; } &amp;#x200B; impl Async for F where F: Fn() -&gt; Future&lt;...&gt; { fn foo(&amp;self) -&gt; Future&lt;...&gt; { &amp;self() } } &amp;#x200B; fn asyncFn() -&gt; Future&lt;...&gt; {} &amp;#x200B; fn main() { [asyncFn.foo](https://asyncFn.foo)().await } So at the end you are using a function that looks like enum/struct (object), that is calling a method, that accesses a field. And nothing of it is true. I'm sorry, but this is simply mind-boggling for me. May be it's just me and all of this is just unfamiliar, but I dislike this notation!
I don't think this specific syntax choice is going to harm adoption. I think it's possible that the combined ecosystem complexity of async/await---especially at first---could be quite daunting though, and that might be a hard sell. But that's a different challenge for another time. IIRC, /u/fgilcher has a saying about, called an "odd fact," and that's exactly what `.await` will be I think. And I think that's OK. This kind of stuff is nothing compared to other stuff in the language. Try explaining why overlapping and orphan impls aren't allowed in the language to a newcomer, which they could trip over. That's hard. (And I mention this because I just tried this last week. I think I explained it okay, but it wasn't easy, and I'm not even sure I got all the details correct. And I've been using the language for a very long time.)
Thank you for the hint, I will look into the JSON -&gt; Enum parsing, I too, would also like it to be strongly typed as you previously mentioned. I also agree with you on the part where having many match comparison statements would most likely be faster than an O(1) lookup in a HashMap with dynamic dispatch.
Why can't we have both? Prefix magic sugar one and the postfix one?
&gt; and as a German keyword user As a FIN/SWE keyboard user: I concur.
&gt; I find this genuinely suprising, since the 'magic field' syntax was one of the most (if not the most) disliked option from the discussions I've seen thus far. I don't think it's possible to quantify popularity judging by online discussions posts. Eg. I think postfix operator was the least-bad idea (just as the lang team, it seems), but I have better things to do than repeat my arguments over, and over, and over, and over again, and read though people repeating their arguments over and over and over again.
Honestly using Common Lisp fairly heavily for a few years is what pushed me into the postfix-easily-chainable camp for just about any โobject syntaxโ. (second (first x)) Vs x.first.second
&gt;There is also the fact that a user who knows anything about the semantics of the await operator will quickly realize that its not possible that await is *actually* a field access. In contrast, you need to know a lot about the semantics of Rust to understand that await cannot be implemented as either a method or a macro. That is to say, a user who is initially confused about the relationship between this construct and field accesses will come more quickly to understand that this is a built-in construct different from field access than they would be if we used methods or macros. That is an interesting argument. I am still trying to decide if I agree. But I do know it's an interesting argument worth considering. So, we have to break some rules somewhere, and you're saying we should break the rules of the simplest\* construct in the language so that it will be obvious something special is happening. My initial reaction was that you should break the rules and do something magical in the syntax space that is already considered most magical, macros. \* "the simplest" loosely speaking. Field access is very straightforward in comparison to traits, macros, etc.
Would it be possible to leverage macros (as in, real/userland macros) to create the postfix syntax at a later date, using the "obvious precedence" syntax as an initial stepping stone to that? My proposal would be to, as a first step, implement the "obvious precedence" syntax. This obviously has the problems of not being postfix, which I know is very ideal, but it is a syntax that is satisfactory and adequate to most people, and it is above all else obvious and clear. Then, as a second step, the language team implements postfix/chained macros, probably as some sort of UCFS, but the details of that are worth discussing and not 100% relevant to this proposal. Ultimately, the only necessary part of the proposal is that it is possible to chain macros like any other method call. As a third step (immediately after, or even simultaneously with the previous step), the stdlib then ships the `await!` macro, a postfix macro that leverages the existing `await` language feature to await an expression. Essentially, it would look something like this: macro_rules! await { ($expression:expr) =&gt; await $expression } I believe this provides an optimal level of support for people who use the language in a lot of different ways. It provides support for chaining expressions in an obvious way (and the explicit macro syntax would clearly indicate that something above and beyond a simple method chain was happening). However, it also provides support for people who prefer a more "SSA-like" style. In these cases, writing `y = await x` is generally more logical (at least by conventional English grammatical styles) than `y = x.await`. (Assuming here that x is a small expression, e.g. a function call, rather than a complex chained expression.) Indeed, I would argue that this is actually pretty much the ideal syntax for everyone, although I know that's a very bold claim! However, I really do think it keeps postfixers and prefixers happy, while also satisfying all the constraints that the language team have added (quite rightfully, for what it's worth). As I see it, there are two major flaws with this proposal. Firstly, if `await` is a keyword, it's not entirely clear if it would be possible to create an `await!()` postfix macro. That said, I simply don't know if that's the case. I've seen some talk about workarounds that are a bit uglier, but could work in this case. Alternatively, by the time the postfix macro is to be stabilised, it could be that an alternative name for it has been decided, although I think given the implementation of the macro, giving it a name other than `await` would probably cause confusion. Secondly (and significantly more importantly) is that this proposal would essentially add two syntaxes, and spread them out over a significant amount of time. I don't think this is a terrible thing. For a start, in my experience of writing non-Rust `async`/`await` code, chaining futures is often best done with combinators, rather than explicit `await` calls. I suspect that most often, the bare `await` will work fine. However, I also expect that it will take some time to find good patterns of working with futures anyway, and the "ideal" syntax should be kept as flexible as possible until the community can eventually converge on something that works in most cases. By having a relatively "boring" (but also obvious) syntax to build on, and given the promise of tools such as postfix/chained macros, I think the Rust community will have strong foundations to approach something that works well in practice, rather than the Rust language team having to decide an ideal syntax immediately. I'm really sorry if you're fed up reading proposals! There was a brief mention in the blog post that you guys still seemed up for discussing new proposals, and I haven't really seen this considered, so I figured I'd throw it out there. If there's a better place to post it, please let me know. If it's something you've already considered, no worries! I'm not really a language design expert by any stretch of the imagination, I would be surprised if I've managed to come up with something totally original here... :P
Another way (using the `Applicative` instance for `(-&gt;) r`) \&gt; let a = \\x -&gt; x + 1 \&gt; let b = \\x -&gt; x + 2 \&gt; let (&lt;+&gt;) = liftA2 (+) \&gt; let c = a &lt;+&gt; b \&gt; :t c c :: Num c =&gt; c -&gt; c \&gt; c 5 13
You might be missing a linker. Can you try installing `binutils` or `build-essential`?
I'm okay with this decision. I can definitely understand where a lot of people are coming from that what looks like a 'magical field access' is a bad way to go, but I'd like to present a counterpoint. Say for a moment that we have this theoretical programming language where method call syntax doesn't exist. You only have `my_struct.field_access` and `function_call()`. At some point, they decide to add a notion of functions that are associated with a struct. These functions implicitly have the struct as the first argument. But there's disagreement on the syntax for calling these 'associated struct functions'. Why would we want `my_struct.method()`? It looks like a magical field access since there's a first param that isn't there! And it's ambiguous with function pointer fields that are part of the struct! What a terrible idea. Why can't we just do `method(my_struct, ...)`? I hope you can see where I'm going with this. Yes, a postfix notation is new and strange, but I see it less as a 'magical field' and more as 'field, method, or postfix keyword'. The meaning of a dot is already overloaded with fields and methods, just that we're already used to it. I don't think it's so out of the question to add a third meaning.
I consider myself an intermediate Rust user. I don't understand their consistency arguments in regards to other macros (like \`line!()\`, \`format\_args!\`, and \`macro\_rules!\` that were mentioned) because I don't know those other macros. To me \`foo!()\` just means "magic here". Through my intermediate eyes, it would have been consistent for \`await!()\` to also mean "magic here". In contrast, \`expression.await\` will appear magical to all. Which is argued to be a good thing: &gt;There is also the fact that a user who knows anything about the semantics of the await operator will quickly realize that its not possible that await is *actually* a field access. In contrast, you need to know a lot about the semantics of Rust to understand that await cannot be implemented as either a method or a macro. That is to say, a user who is initially confused about the relationship between this construct and field accesses will come more quickly to understand that this is a built-in construct different from field access than they would be if we used methods or macros. I would have thought that keeping inconsistencies as subtle and hidden as possible would be best, but it is interesting to think about making inconsistencies plainly visible. (I'm being genuine here, I do think it's an argument worth considering. Though I'm not sure I agree.)
I agree so much! I remember that I've already missed postfix macro several times. If await would be a postfix macro, even built-in one (it is ok and nothing really different from the magical built-in field), then things like .format! or .match! could be simply provided by libraries (or stdlib?), without the need of complicating compilers. Postfix solution is ok, field-like operator is definitely confusing.
I don't think it is so simple as postfix vs prefix (also infix). In Haskell you can use both and from my experience it depends on particular *identifier* or particular type of function whether one is more readable than the other. When I first looked into Rust documentation on how to round number, it felt very unnatural to me writing something like `(x * 0.1).round()` as opposed to `round(x * 0.1)`. I don't have any background in OO languages. Postfix await syntax makes me cringe. I can get over it, but I can't say it is more readable than prefix notation in case of await keyword.
Why have the plugins be in-process? I'd imagine it's much simpler and easier to maintain stability by simply having them exist out of process and provide an API. I would probably create a grpc client library where clients implement the server side, 'register' with the main app, and then the main app can call into the clients. This way you get fault isolation when plugins misbehave.
It is not the worst, don't forget that postfix `@` was also considered ;)
Thank you, guys, for answering! I noticed that in order for `"terminal":"integrated"` to work, I had to increase timeouts, at least on Python components of VSCode. Once that was done, the debugging started working as expected, and the app input got delivered to where it belongs. &amp;#x200B; @vadimcn, thanks - I will experiment with `"lldb.adapterType": "native"`. And I took notice that I shouldn't really need `rust-lldb`. @forrestthewoods I think your guide would become even better if you add the setting for integrated terminal. Without it you cannot debug a program that requires user input (and expects it via stdin). &amp;#x200B; As for `clippy`, we are talking about *debugging* a program, not *linting* it.
&gt; Thanks for the big comment and giving me many ideas! Dystoipa is super early stage now, and I'm noob on this area. I'll try to apply the ideas as possible. &gt; &gt; If you're a noob please take a basic network security course before trying to create a network security protocol.
Might as well add `.try` to the list. Would be easier to goole than `?` anyway.
I find the argument "dot await is the weirdest option, therefore it is the best" to be somewhat baffling. I agree that newcomers won't necessarily understand that await is not and cannot be a method call or a macro, but I consider that a feature, not a bug. For example, in Scheme, the `if` conditional `(if test-expr then-expr else-expr)` is (and must be) a special form, despite looking just like another function. However, you don't actually need to think about that to use it most of the time, and it looks very natural and fits in with the rest of the language. Students are able to learn this "weird fact" about `if` when it comes up, say "oh, cool", and move on with their lives, rather than stumbling over a syntax irregularity every time they use a conditional. I believe a method-like syntax for await (or, less preferably, a macro-like syntax) would benefit from this same property. I do not anticipate getting used to ".await" anytime soon. To give an explicit accounting of my biases: I strongly prefer prefix solutions, especially `await {}` but including `(await foo)`, and don't consider `.` and `?` binding tighter than `await` to be a real problem - no matter what the order of operations decision, I would always use parenthesis anyway, just like I do for e.g. `as`. Of the postfix options, I prefer method-like, followed by macro-like, and don't consider any of dot-await, space-await, or sigil-await to be "acceptable" solutions. But ultimately, I don't care too much about this result, because I don't use Rust for tasks which benefit from `await` very often anyway. I would, however, probably hate `.match` et al.
On to the next syntax battle! Beauty awaits! :)
I'm not a huge fan of `impl Trait`, but I really like `fn foo(path: impl AsRef&lt;Path&gt;)`. It is also nice for `impl Display` and several others.
I would prefer `@` to `.await`. It's not the perfect sigil, but aside from `;`, the only other postfix sigil is `?` which has similar behavior.
I don't really see the issue, isn't it up to the users of these libraries to decide which ones they deem trustworthy? What's wrong with security amateurs getting more familiar with the concepts by implementing some of the stuff in Rust? You'd be an idiot to use this for any serious purposes, but I don't think anyone is to blame for publishing stuff like this.
Language design aside, using the same input for both functions is the standard in mathematics. The idea is that you add the result of each function at every input. The same applies to subtraction, multiplication, and division. It's the same as adding vectors component-wise, but rather than a fixed number of values, you have one value for every possible input.
Do people in need of serious cryptographic libraries really need such disclaimer, though? Isn't it obvious that stuff like this is unfit for real use cases?
fut.!await
As a general point about language design, I do think that it's reasonable to consider syntax highlighting as a factor in our calculus. This is not to say that the drawbacks to `fut.await` looking like a field access would be completely nullified. However, I believe highlighting is a mitigating factor. Almost all of my time spent reading, reviewing, and writing code is spent with syntax highlighting enabled. For example, both my editor and GitHub renders with highlighting including with diffs for the latter. About the only place today where I don't have highlighting is in `git diff`. So yeah, I think we should take advancements in tooling into account. We should not be held back by decades old technology.
Not sure if anyone will read this but... As far as I understand, `.await` can be invoked for anything that implements the `Future` trait, right? If so, why it is not possible to define simple prefix `await` keyword and create this: ```impl&lt;T,O&gt; FutureExtensions for T where T: Future&lt;Output=O&gt; { fn await(self) -&gt; O { await self } }```
By all means, build stuff to learn, but don't misrepresent your exploratory project as something reliable and production ready. This project does so by claiming to provide "Real Anonymity on the Internet" and it even has a logo!
&gt; Try explaining why overlapping and orphan impls aren't allowed in the language to a newcomer (who doesn't have a Haskell background), which they could trip over. Hah; even if you have Haskell background like I do, the specifics of the orphan rules in Rust tripped me up in my introduction to Rust. =P
Some people learn better by building stuff, and that's fine. What isn't fine is misrepresenting your pet project as something reliable.
It is only an idea, nobody knows for sure whether the community would agree to that. Committing to the proposed await syntax does not mean we are committing to the prefix/postfix syntax for match and other keywords. (This is just my understanding, as a random Rust user.)
I purposely abstained to vote on that poll because I felt unqualified, you're not alone :)
How about `.await!!()` ? Has no new sigil and is also not a macro (but a macro is still the closest thing to it - which makes sense in my opinion).
Hi! I am the creator of The Piston Project and AdvancedResearch. Who are you?
I used it in Scala at dayjob, and I miss it in Rust now. Might be the only thing that Scala has, that I miss in Rust. :)
Hi! I am the creator of The Piston Project and AdvancedResearch. Who are you?
I disagree. Async await is already compiler woo. This decisions hides that behind property access syntax instead of highlighting it.
You seem to be intentionally missing the point. &amp;#x200B; I could change dialog in a story to use the \* character instead of the quote character. It wouldn't make it unreadable. It wouldn't be so strange as to obstruct the entire meaning. But we don't. There is a convention which conveys a specific meaning and changing it for no reason is *bad.* This is enough of a reason not to do it unless there is a very good reason. You are asking me why technically we don't do what you want, and I'm telling you we don't for *social* reasons. It's not convention. It's a bad idea because it makes it harder for people to read the text and understand it. It's not a technical difficulty. It's bad in the same way that making fish in the break room microwave is bad. Sure, the microwave can cook it just fine, but if you do it, people will dislike you for doing it. Get it?
If a postfix `await` might be a problem, how did you went through borrowck in the first place? :D Postfix vs prefix is actually quite a surface level barrier. The way how futures works internally (poll based) vs how they work in other languages, might be much, much bigger issue.
I've seen C++ code that overloaded `operator,`, and meta-programming tricks to create DSL languages in C++ that used temporaries in way were introducing named temporary variables to break long expressions would actually cause crashes at run-time. I've seen Java code where use of reflections allowed injecting field/method names in classes, remove the final qualifier of fields/singletons, and other "wonders". Where I am going? There are always things that some will consider elegant, or at least hacks enabling elegant code, that others will consider obfuscation/abominations. Fortunately, just because they are possible, does not mean they are used, or that *you* need to use them (or libraries which use them). There are many tricks possible in Rust already, especially with macros, but so far the bigger libraries have proven conservative in their APIs.
Youโre making syntax highlighting a soft requirement on the language though.
Fair enough, that could have been a little less fancy looking :)
Similar here, I'm typing `await` in Node on a daily basis. The way it binds with other operations is driving me nuts. Then again, a lot of things about JS syntax and semantics is driving me nuts. :D
You can choose to view it that way. I view it as: At the end of the day, the use of syntax highlighting is pervasive and to not consider it as a factor would be a disservice to most users of the language. Again, this does not mean that it is the only factor or even *the* factor. It's one factor among many.
No, being different because it's always been different is the same as changing because everything changes... The two cancel each other out, some times something that is different is changed to be the same as everything else and other times something that's the same as everything else changes to be different. Language is always evolving, for example English could change so there is jus one spelling of the word two instead of three.
&gt; It works perfectly fine for C# and JS I write JS at dayjob. It does not work perfectly. Far from it.
Yeah, i really think the argument is just backwards. \`expression.await\` is visible to like 100% of Rust users as an "oddity" or at least a new thing to have in mind whereas \`expression.await!()\` not being an actual macros is discoverable to a very less &lt;&lt;100% amount of people. I don't really want to make up numbers here but i would say a serious amount of Rust users will never write their own macros and go this deep into the field that they actually "wonder" what is happening with the strange \`.await()!\` macro and how it is impossible to write it them self. This is just a "strange" expert view, that very few people even care about. Having strange behavior on a field access will be discovered by like 100% of Rust users. This reasoning strikes me really odd.
&gt; In the long term, await cannot be defined as a macro in this way because the form of yielding it represents cannot be expressed by the user in the surface syntax. Therefore, await is not a macro. I'm not convinced by this argument. There are a handful of "macros" in the language that are entirely compiler constructs, and can't be expressed in user-land either.
As do I. JS's `async/await` works pretty damn well. There are some intricacies about creating Promises, but async/await as a whole is very solid.
Thanks after looking into that and the other libsecret rust binding project\[1\] I had found that uses that I got that one to build. I had to change some toml file variables but those changes were accepted and merged. &amp;#x200B; \[1\][https://github.com/antoyo/secret-rs](https://github.com/antoyo/secret-rs)
&gt;Yeah, i really think the argument is just backwards. `expression.await` is visible to like 100% of Rust users as an "oddity" As long as it's a lone exception to the rules. But with .match and maybe others it no longer sticks out.
Why do we default to `field` like access for async? To me `foo.async()` makes more sense. While neither a field nor a method indicate what happens under the hood, I think masking `async` as a function call is more fitting. That being said, fantastic blog post. Thank you for keeping us up to date.
That may or may not happen. Just because we agree to an await syntax does not mean we have agreed to the postfix `match`. However, it is a possibility worth considering.
Stuff like `(await fetchQuote()).length` is easy to forget about/get wrong, then lack of the compiler to catch it early, and general JS wonkiness is making me wish I was using Rust all the time. Much better than `bluebird` + and `yield` that I was using before, but perfect? I don't really think so, but I understand it's subjective.
For your `await()` to use `await`, it would have to be an `async fn`, which means that it returns a future that must be awaited to obtain the value, and now you have `await future.await()`, where the `await()` call effectively did nothing.
&gt; Stuff like (await fetchQuote()).length is easy to forget about/get wrong Which is due to.... &gt; [a] lack of [a] compiler [to throw errors/warnings] It's also because `await fetchQuote().length` is *valid*. It's not correct, but it's valid because you're allowed to `await` on anything, and if it's not a promise it will resolve to the value of the expression (in this case most likely `undefined`). This isn't an issue of `async/await` in JS. This is an issue of JS being a terrible language for doing any sort of work that benefits even the slightest from static typing.
Yeah. This makes a lot of sense, I'm happy with it, and glad we can be done with inane bikeshedding
&gt; My code base, for instance, has been around since the 90s, and has grown immensely over time, and I mean immensely. But it's not in any way brittle or out of control. The vast majority of programmers don't write code like that. I'd rather have something that's difficult for most people to screw up rather than something that's difficult for most people to get right.
How is await not a verb here? I agree it's not the subject, but it is a verb
Dynamic in what sense? What kind of message? It sounds like what you are looking for is simple HTTP Rust server, by fast googling, I found \[1\] tutorial which shows how to deploy apps on heroku, not sure how outdated tho. For logging, heroku uses standard output for logging, so you can either use logging crate or just print to STDIN/STDERR directly. \[1\] [http://www.randomhacks.net/2014/05/30/rust-heroku-rustful/](http://www.randomhacks.net/2014/05/30/rust-heroku-rustful/)
I'm might be wrong about the terminology as I'm not a a native speaker, but I think the two describe a different fact. The word is a verb in the imperative mode.
rustfmt wouldn't pick either, in the same sense that rustfmt doesn't make the choice to translate method calls to maximally-qualified trait-method syntax. I would use `.await` in the context of a chain, and `await {}` in standalone context, in the same sense that we have the `for` keyword and `.for_each()` method on iterators (and with the postfix-keyword proposal, maybe `.for` would replace `.for_each()` in idiomatic code).
Under the hypothetical postfix keyword proposal, I might expect a hypothetical prefix version of await to look like `await { }`, with mandatory braces, for symmetry with `match { }`, `for { }`, etc.
Finally, the long awaited (heh...) conclusion! Seems well enough reasoned, composes better than prefix. Possible future extensions of this syntax to match seem great for ergonomics. I think I can live with it. I still want my method macros however!
This is an unfortunate development. I always preferred mandatory delimiters because it has nice uniformity with unsafe. let foo = unsafe { unsafe_stuff(); }; let bar = await { async_stuff(); }; At least the postfix keyword notation can be generalized. Hopefully it actually happens, so this can be just gross, not gross and strange. Hopefully unsafe is generalized as well.
IPC is a lot slower and is a huge performance hit. Probably fine if you are absolutely sure that CPU time is in excess, but this assumption is a luxury that sometimes is not available.
The end of the post alludes to this possibility, by potentially introducing the general concept of allowing certain keywords to be used in both prefix and postfix position (including `await`). As for "why isn't this happening right now", I suppose it's because it's not immediately necessary since there's nothing stopping the Rust devs from adding it in the future, even without the hypothetical postfix-and-prefix-keywords RFC.
Well, I'm done. &amp;#x200B; You asked why not. I told you. You don't like the answer, but it's still the answer.
Thanks. So it's a Windows feature, not a property of PDF files. I wonder where &amp; how Windows stores or finds the tag suggestions. And I wonder, if and when I find out, what I can do with that knowledge. Perhaps create a program to hyper-auto-organize my file system, or maybe use it as the storage a user/machine wide hash set (who needs the registry now?). But I probably won't do anything much with it.
&gt; `expression.await` is visible to like 100% of Rust users as an "oddity" If it's at the end of a long line then it's not visible at all!
It can't get backported into 2015 because someone could already be using that keyword as a field name. AFAIK the only thing that was "backported" to 2015 was the new borrow checker, and that was to fix holes in the old borrow checker, and any code broken by that move would had to have been unsound.
`.await` is weird, but I'll get used to it, and I like (unironically, I should be clear) that it can be extended to `.match`, `.if`, `.yield`, `.return`, and `.while`
That the poll calls it field notation when `await` is not a field is already biasing the poll.
Thanks for posting this. Unfortunately I now have to read through every line to find `.await`. Postfix removes the ability to quickly scan through.
&gt; This isn't an issue of async/await in JS. Hypothetical `fetchQuote().await.length` in JS would have no problems like this: an order of operations is the same as order of elements in the expression. I think the previous comment https://www.reddit.com/r/rust/comments/bld06g/a_final_proposal_for_await_syntax/emnix4n/ describes well. Personally I think that postfix keywords are clearly superior to prefix ones and I'd like to see all control flow keywords as postfix. The only arguments against them I see is "our grandfathers were using prefix keywords and they spook all the potential users that want Rust to look like they previously used language". Which is a valid point, IMO.
I think `break` can return a value. Eg doing `break 5` will return a `i32`.
I wonder whether it would make sense to eventually implement Future for tuples whose members are all futures; then you can do the above, just appending '.await', and it feels like quite a natural thing to want to do.
Is there a good resource for more information on the "compiler recovery" considerations w/r/t space-await? I find that variant a lot more aesthetically pleasing than dot-await, and I'm sure that the considerations are realโI'd just like to know more about them.
Thanks for this! I initially lent more toward the prefix syntax owing to my familiarity with other languages, but the reasoning for this syntax in the context of Rust makes a lot of sense to me :) I'm looking forward to getting to play with said syntax more, but a lot more than that, I'm looking forward to the rust ecosystem taking full advantage of std Futures!
Hm, I might have missed something. I thought that `await` 'unpacks' the future and the type of `await foo` is `O`, not `Future&lt;Output=O&gt;`.
An intro to SIMD in Rust: [https://www.youtube.com/watch?v=4Gs\_CA\_vm3o&amp;t=834s](https://www.youtube.com/watch?v=4Gs_CA_vm3o&amp;t=834s)
Same here! Postfix flows very nice when writing code. Back when `try!` was still a thing it was very frustrating to write an expression only to realize you got a result and needed to go back to wrap the expression. The postfix `?` operator improved the situation considerably. I like consistency in a language, postfix macro makes sense to me. I enjoy macros and am still hopeful we'll get postfix expression macros someday. Here a new piece of syntax is introduced, consuming some of Rust's [_strangeness budget_](https://words.steveklabnik.com/the-language-strangeness-budget) which is fine. withoutboats also teases potential future extensions to alleviate the inconsistency with syntactically similar keywords which seals the deal for me personally. Good stuff!
I did not understand your argument. If you read my notes about publishing, I suggested "probabilistic paths" because they are more self-contained. The way I read your comment is as if you got the impression of me not wanting publishing. I do, it's just that few other people understand the math well enough, have the expertise of publishing and are interested in it. Are you saying that you don't understand commuting squares/diagrams? Or, do you claim that there is indeed unsoundness?
Yes, and postfix keywods in JS would preclude you from being able to have a property called `await` defined at runtime on an object. And what happens if `fetchQuote()` returns undefined? `undefined.await.length` would error out in an unexpected place, since you lose the context of whether `await` was supposed to be a postfix-keyword or an object field. It's not that postfix keywords are "spooky", it's that they're inherently harder to reason about from both a cognitive and parsing perspective. `await` is particularly bad because it's a verb. If you're going to go with postfix operators, it makes sense to make verbs past-tense - eg, `fetchQuote().awaited`, or `watchTable().looped` if we really want to get into the weeds with postfix keywords. The keyword *must* directly relate to the component being operated upon, otherwise it becomes very difficult to reason about. For something like `fetchQuote().await.length`, it parses (grammatically) as if you're waiting upon a property access which is just bizarre, when in reality you're waiting for the fetch to complete - eg `fetchQuote().awaited.length` (which, honestly still looks like garbage to me, but at least solidifies the target of `await`). As for your link, the top comment in that thread makes a similar point about the suffix verb issues in English.
&gt; Any time you have to describe a feature as a "magic" whatever, people tend to look at that feature unfavorably. Agreed, but it's way too late for this. The entire async/await feature, as currently planned for release, is "magic". It's its own execution-style, with its own `do`-notation. It is apart from Try's `do`-notation (and of course Try itself), it is apart from Iterator (which has no `do`-notation), it is apart from generators, and it will surely be apart from whatever Monad abstraction gets built upon GATs.
Indeed! This property of functions is a sub-set of Higher Order Operator Overloading (HOOO), as `+` is well-defined for the return value of `f(x)`, `g(x)` and `h(x)`. HOOO states that this is true for every well-defined operator. You are also pointing out a syntactic incompatibility between HOOO and linear algebra for functions: The dot product operator makes sense for polynomials, but HOOO treats the dot product component-wise in the "vector" (function), so it would have to be a function returning vectors to make sense in HOOO.
This may not be the best place to ask, but I've been intrigued with Rust for a while, and I've thought about exploring the language by compiling to webassembly. I've been following Mozilla's intro guide [here](https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm), and I'm curious, is npm required for .wasm to run? It seems somewhat silly to have this nice small Rust program and this small .wasm but then it needs to download 432(!!) node modules to run.
Problem is, `.match` opens an entire new can of worms: that would make both `something.match` and `match something` valid, while `something.await` is valid but `await something` is not.
Probably not that useful because of performance reasons, but if you need to run untrusted code, you could use a WASM interpreter. There was a blog post here recently about how to do that.
Me too. I of course had my own opinions on syntax, but I care more about moving forward and choosing something after applying reasonable logic, more than I care about my personal preferences.
Yep me too
Huge is relative, but sure, it's an "if you can get away with it, this will vastly simplify things".
I don't know that anyone has ever cared that format_args! can't be hand rolled.
For example, in geometry you can define a circle like this: let a = |x: f64, y: f64| x.pow(2) + y.pow(2) &lt;= 1.0; The type of `a` is `f64 x f64 -&gt; bool`. I can construct a circle that is located at a center (10, 10) like this: let b = |x, y| (x-10).pow(2) + (y-10).pow(2) &lt;= 1.0; If you want to take the intersection the two circles, with Higher Order Operator Overloading (HOOO), this becomes: let c = a &amp;&amp; b; Notice that HOOO doesn't understand geometry. It just fits naturally with the intuition we have. This is just a small use case. HOOO can also be used to partially evaluate functions, do some fancy theorem proving, optimize closures by in-lining and as a debugging tool for mathematics. The example above used Boolean Algebra for geometric shapes. However, HOOO generalizes to *any higher order function*, meaning that there are shapes with higher homotopy type that you can do Boolean Algebra with (if you understand the terminology of Homotopy Type Theory). HOOO is not limited to just Boolean Algebra, but generalizes for any operator/function calls: E.g. in ray tracing, there are signed distance field functions used to construct scenes, and these can also be combined algebraically in the same way.
`impl Trait` has the disadvantage that the concrete type is not caller-chosen. See this example ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=22602b02c7b5b4d2591ba741ab6bffd4)): fn map1&lt;I: Iterator, B, F: FnMut(I::Item) -&gt; B&gt;(iter: I, f: F) -&gt; Map&lt;I, F&gt; { iter.map(f) } fn map2&lt;I: Iterator, B, F: FnMut(I::Item) -&gt; B&gt;(iter: I, f: F) -&gt; impl Iterator&lt;Item = B&gt; { iter.map(f) } fn main() { let slice = &amp;[2, 3, 4]; println!("{:?}", ExactSizeIterator::len(&amp;map1(slice.iter(), |x| x + 1))); println!("{:?}", ExactSizeIterator::len(&amp;map2(slice.iter(), |x| x + 1))); } errors with error[E0277]: the trait bound `impl std::iter::Iterator: std::iter::ExactSizeIterator` is not satisfied --&gt; src/main.rs:21:22 | 21 | println!("{:?}", ExactSizeIterator::len(&amp;map2(slice.iter(), |x| x + 1))); | ^^^^^^^^^^^^^^^^^^^^^^ the trait `std::iter::ExactSizeIterator` is not implemented for `impl std::iter::Iterator` | = note: required by `std::iter::ExactSizeIterator::len` In `map1`, the return type is `Map` with some generic parameters. If the underlying `Iterator` of the `Map` knows its exact length (here, it does because slices carry along their size), the `Map` can report its own length because `Map` yields exactly one item for every item in the `Iterator` and none beyond that. In `map2`, the only thing we know about the return type is that it implements `Iterator&lt;Item = B&gt;`. Information about its concrete type has been erased, and although monomorphization would very likely result in the exact same code, the Rust compiler rejects it because part of the point behind `impl Iterator` is to not leak information about the concrete return type. I don't think there is an easy way to conditionally add the `ExactSizeIterator` bound to the return type either.
&gt; Yes, and postfix keywods in JS would preclude you from being able to have a property called await defined at runtime on an object. And what happens if fetchQuote() returns undefined? undefined.await.length would error out in an unexpected place, since you lose the context of whether await was supposed to be a postfix-keyword or an object field. Sure. My example was hypotetical, to show that `await` in JS is not perfect. &gt; It's not that postfix keywords are "spooky", it's that they're inherently harder to reason about from both a cognitive and parsing perspective. await is particularly bad because it's a verb. If you're going to go with postfix operators, it makes sense to make verbs past-tense - eg, fetchQuote().awaited, or watchTable().looped if we really want to get into the weeds with postfix keywords. I dissagree. &gt; The keyword must directly relate to the component being operated upon, otherwise it becomes very difficult to reason about. For something like fetchQuote().await.length, it parses (grammatically) as if you're waiting upon a property access which is just bizarre, when in reality you're waiting for the fetch to complete - eg fetchQuote().awaited.length (which, honestly still looks like garbage to me, but at least solidifies the target of await). I dissagree again. Anyway, my point is that `await` in JS does not work prefectly.
I disagree that it is about the grammatical structure of English is relevant here, I find a much better point that `object.action1().action2().action3()` is in the correct temporal order from left to right (compared to the "wrong" one `action3(action2(action1(object)))` ) &amp;#x200B; The difference is event stronger when the methods have arguments as locality is completely shattered. &amp;#x200B; moreover the prefix function application is derived from mathematical functions and even in algebra/category theory it is a common opinion that function application is often better postfix.
The justification they gave is true, but it's a little weak because it is true of the chosen syntax as well. The await operator cannot be a field either, just as much as it cannot be a method nor macro. At least in the case of a postfix macro, the presence of compiler magic feels more obvious to me as a long-standing Rust programmer.
There are always trade-offs in language design. Sometimes you need easier syntax to work with more powerful ideas in order to inspire new ideas. Since Higher Order Operator Overloading (HOOO) is not implemented in any programming language that I know, it makes it very hard to study. By testing this in a fork of Dyon, it gets much easier to understand. It is not certain that this will become a part of Dyon, but if the trade-offs are worth it, it will. Of course, there will be a lot of testing before this happens.
Not trying to be snarky - why is this a problem?
Sure, but tons of compiler woo is hidden behind functions (intrinsics) and no one ever minds. Also, as Rust fields cannot have the same name as keywords, there's no collision once you are used to scanning for `await`.
This wasmer sounds really interesting.
Hey guys! I've been working on this for a week or two for a fun little program I'm making (just a pure rust version of lolcat). I plan on writing a rust terminal emulator down the line, so this was going to be needed anyway. It currently implements most escape sequences, although there are still a few to go. I will be adding them in the next few days likely, whenever I have the free time. Either way, it is now at a mostly usable state! So if you'd like to check it out I'd love some feedback. The best idea for how to use it is in the gitlab README (it's really really simple).
I just want to vent a little: I completely disagree that it is a good idea to mimic a spoken language structure in a programming language. spoken syntax only works because it is extremely inconsistent and complex. Essentially the main point of the whole discussion is to allow for easier chaining of successive steps, English essentially has no way to handle an implicit chaining of actions. &amp;#x200B; I am answering to you for no reasons, it is just that I do not understand why so many people care so much about such a superficial and exception-ridden grammatical trait.
Yeah, if we're talking about "future cool things we could do" with .match and .if, which are super questionable in my mind, macros should be the blatant winner - they've been requested in the past.
&gt; IIRC, &gt; /u/fgilcher &gt; has a saying, called an "odd fact," and that's exactly what &gt; .await &gt; will be I think. And I think that's OK. Yes, that was me. `.await` is not my preferred syntax, but I see no issues on that front. People _will_ learn it. Just as everything else. I'm happy that there is a decision upcoming.
That's addressed in the post &gt; In this world, the dot await operation would be generalized so that await were a โnormalโ prefix keyword...
Because a language should really be understandable on its own without requiring syntax highlighting (imo). Itโs like making bold and italic text necessary to understand English instead of being used for emphasis, etc. Not being snarky either just trying to add to the discussion :)
One can think of Higher Order Operator Overloading (HOOO) as a generalized form of function composition. For example: f . g (in Haskell) Becomes in HOOO: f(g) (in HOOO) However, unlike function composition that requires special syntax, HOOO is inductive: Since the same syntax is used as normal calls, it holds for all higher order functions.
Haskell has had the ability for it for quite a while, and it occasionally gets bandied about as a "this is clever" (not always in a good way): https://wiki.haskell.org/Num_instance_for_functions
I totally agree that postfix is the proper place for it. That said, I find the argument against making it look like a macro very weak. Macros, prefix or postfix, clearly indicate that "magic happens here", regardless of how they are implemented. Field-like access, on the other hand, indicates nothing. If we really go with the field-like approach, I would prefer some special indication for keywords (e.g a bang sign, like `expression.!await`). This would make them clearly distinguishable from fields and open possibilities to introduce more postfix operators in the future without causing any conflicts.
&gt; Because a language should really be understandable on its own without requiring syntax highlighting I guess, to me, this is already not the case. I can't write rust without an IDE, or any language. This is a huge part of why I like static types - they give super powers to IDEs; auto refactoring, jump to X definition, expansion of macros, etc.
Granted, but you can't learn cryptography theory by _just_ building stuff. There's fundamental ideas that have been learned through decades of hardship that can't just be learned by experimentation. You need to learn that from book material.
Remember that they would "jump out" visually when syntax highlighting catches up, so this may be less of a problem in practice. (I'm not trying to dismiss your concern; just hoping to assuage it. ๐)
So, how do we distinguish `.await` from an actual field access? I would assume we need some special indication for postfix keywords, like `expression.!await`. If we don't do this, we'll have to worry about possible conflicts between fields and postfix operators (like the suggested `.match`) for the foreseeable future.
For me itโs less about the chance of collision and more about readability. Your last point sort of nails it in that I shouldnโt need to scan for await. It should jump out at me.
I must say that (even more if await is keyword-colored by syntax highlighting) is easier to spot Where the code is awaited. add another await and a few more parenthesis and then i would get totally lost as tho where each await happens. &amp;#x200B; rust is essentially stabilized on a practice of "procedural code as successive method call" (which some could say it is a beautiful monad-like construct) so keeping the property of left-to-right as before-after in order of execution is deeply valuable. &amp;#x200B; A few years ago I there where a lot of people complaining about how haskell completely broke this left-before right-after consistency resulting in almost unreadable code. &amp;#x200B; In my opinion `future.await` and `await future` (where `await future?` = `await (future?)` ) should coexist as one is better standalone and one is better chained.
Also the `.match` proposal sort of implies that in the future there can also be a prefix await
Nice! Do we need to announce our lightning talks in advance?
Higher Order Operator Overloading (HOOO) lifts for any operator. However, the semantics is different, depending on how it is implemented. In the Dyon PR, HOOO in-lines, so you can use it similar to a symbolic algebraic system.
No less than `?`, and syntax highlighters can highlight it as control flow. Also, rustfmt's defaults eagerly chop down long lines.
I mean, we could *also* have postfix macros. If anything, that would fit the theme of more stuff having dual prefix/postfix forms. I think that would be awesome.
I don't quite see the point. People are also scanning for `.unwrap` and tons of similar methods and that works just fine.
Once syntax highlighters are updated, that will be less of an issue. It could be highlighted red there. Also, in that example it's appended to end of the line even as part of a chain. If it had its own line it would stand out more.
The syntax has the same capabilities as generics, but have a big downside: you cannot use the turbofish syntax (yet): `foo::&lt;Bar&gt;()`. This is why most people avoid `impl trait` in arguments.
I don't think I follow. How would replacing `expect` and `unwrap` with a macro remove the need for a panic when there's no value?
Right but unwrap isnโt doing anything magic behind the scenes. Await carries the context that the preceding call was actually asynchronous and possibly on a different thread.
Oof, that feels like mixing paradigms, do not like. Also, I've not seen any examples of doing like a fan-out await. How would you do an async/await through a loop without accidentally making it into a serial process. Can you await on multiple things?
This looks awesome! But why does it expect tests to be in their own file? Iโd like to add several dozen lines that should each fail to compile. I donโt want a file per test case. Is that possible?
As someone who went into the deep end with DataMatrix, be warned that most of the encoders are questionably-designed. In particular, very few of them actually work hard to optimise the encoding of your input data. DataMatrix has something like 5 different encodings which can be changed dynamically during the datastream, so you could create the optimally-short encoding by switching modes (but I've not seen any project actually do this). I wrote down a DP algorithm to do it but didn't end up having time to write the generator. This is all in addition to that fact that DataMatrix has two different error-correcting modes depending on the version of the spec you use (which have different barcode sizes) and that most readers can't read the largest barcode sizes if they contain too much data.
We forked from [str4d/bls](https://github.com/str4d/bls) and extended it to suit our needs. Later we integrated it so much with our existing code-base that it doesn't make sense to have it as a independent crate anymore (It's still a seperate crate, but has dependencies into our other crates, nimiq-hash and beserial). I've never used jpbc.
Absolutely -- you can point it to one file that contains multiple errors. The library will test whatever errors the Rust compiler emits throughout the whole file.
They probably mean that the top line in backtrace would be 'panic in my_func_name' instead, because macros are "inlined".
It would make the panic message gives the location of the `unwrap!()` call, rather than where `Option::unwrap()` is defined.
It doesn't remove the panic; it makes the failure message point closer to the cause (no more generic messages I believe is what was intended)
Durations without explicit time units are confusing and thus error prone. Itโs a good idea to either put time unit name into the variable (`timeout_ms`) or take a type that specifies the number and the unit both, like `chrono::Duration`.
So then there would be postfix macros and the postfix field identifiers? Why? Macros already imply control flow changes (even if it's not always the common case).
Ahh, thanks. That makes sense.
Working on using the improved C-variadics ([PR](https://github.com/rust-lang/rust/pull/59625)) to translate C code using \`va\_copy\` with [C2Rust](https://github.com/immunant/c2rust). This means we'll be able to handle many important C projects without any "massaging". Very exciting to get closer to feature-complete translation ๐ช
That is true, but the result of an async fn is then "packed" into a future. This is easier to see if you look at what your example desugars into: impl&lt;T,O&gt; FutureExtensions for T where T: Future&lt;Output=O&gt; { fn await(self) -&gt; impl Future&lt;Output=O&gt; { async { await self } } } The `await self` unpacks the `O`, but the `async` block wraps it back up again, making this a no-op.
Well,maybe you want to look at my [abi\_stable](https://github.com/rodrimati1992/abi_stable_crates) crate.. Here are the caveats: * It only supports native dynamic libraries right now,since afaik `extern "C" fn` with arbitrary types is not supported in the WASM abi. * It requires that you use an alternate stdlib for the values you'll pass through ffi. * It's still immature,lacking a `Map&lt;K,V&gt;` type for example,since I've had to reinvent the weel for many Rust types. **Other projects that do something similar-ish:** [wasmer-plugin](https://github.com/FreeMasen/wasmer-plugin/): Which uses serde to serialize/deserialize parameters and return types when calling functions in the dynamic library.
I have GCC installed. I'll try the linker installation the person above suggested.
binutils is installed. Should I try build-essential.
self.par\_iter().flat\_map(|(\_, v)| v.list.clone()).collect() Here, I'm using v.list right? Transferring into the "global Vec", now I want to do something with v.list BEFORE actually putting in the Vec, I'm just confused on how do it.
This is a webapp not a game. Ipc would be absolutely fine.
*I have 10M keys in this Vec, so I do not believe that is true*
Same. I don't really like any of the choices, but was mildly leaning towards prefix `await`, mostly for the same reasons as /u/desiringmachines. But looking at some of the code examples and chaining, in addition to the lang team's justification, does bring me more towards the postfix syntax, personally.
This was my concern with `?` (which I voiced on the original RFC for it), and was very skeptical of adding it at all for this very reason. In practice, it turned out to not be a problem in my experience, and I think the same will hold for `await`.
The `arrayref` crate has an `array_refs` macro that's useful for this case. It uses unsafe code internally, but it exposes a safe interface.
What about people with impaired vision? I would love to see something like Haskell `do` block for monad, which transform every dot in sequence with await if method returns Future.
Perhaps take a look at [cnx](https://github.com/mjkillough/cnx) for inspiration.
Doing the last commits on the \`0.3\` branch of \[abi\_stable\]([https://github.com/rodrimati1992/abi\_stable\_crates/tree/0.3](https://github.com/rodrimati1992/abi_stable_crates/tree/0.3)),which I plan to release this week. Most of what I'll be doing is adding/modifying documentation,adding examples to docs ,and writing more tests. What I did last week was: \- Adding 7 traits to DynTrait (the ffi-safe multi-trait object) ,some of which needed type system changes. \- Made DynTrait significantly more flexible,making it constructible from non-'static/ !Send/ !Sync,as well as adding reborrowing of the pointer it wraps(this isn't as trivial as it sounds).
Yea if we added `foo.match` I assume we would also add `await foo` to "retcon" await as part of this feature.
Just finished writing up a little Rust side-project I've been working on -- a [fast CLI pretty-printer](https://github.com/clarkema/x12pp) for X12 EDI files. The write-up is at https://www.lambdafunctions.com/articles/racing-sed-with-rust
As with what A_Kyras said, you're most likely looking for web server development. I would take a look at popular libraries in Rust such as Rocket, Actix Web, Warp and more. Cloud Infrastructure like Heroku are just ways to deploy applications you've developed already with some nice additional features.
Newcomer to Rust here, Iโm a Typescript developer getting in to Rust hopefully order to improve performance of hot paths via webassembly, and I have to say the postfix await notation comes as a pretty big surprise. Weโve had async/await (prefix keyword for both) for a couple of years now in JavaScript so this choice will certainly stand out as an odd one to others coming from the js world. So far, rust has felt like a pretty natural transition given modern idiomatic typescript is also very functional. Still, it wonโt turn me off entirely, that would be absurd but it is a bit of a downer
Indeed. We do not wish to consider `x.match { .. }` at the very least during this year as it is not a roadmap item. I personally think it would be a good idea to let `x.await` bake for some time on stable before we move towards considering `x.match { .. }`.
Problem turned out to be that libc6-dev wasn't installed. Works perfectly now!
I don't think it has to be so black and white. Understanding is to some extent a matter of speed and degree. How *fast* can you understand something and *how much*? If you can make tooling such as IDEs work for you in language design (e.g. `.` triggers auto completion which will help with `x.await`) then that is a plus. Over-reliance on tooling can be problematic if it means that the language does not work well without said tooling. In the case of `x.await` I think we have good reasons to believe that highlighting will help but I think we do not rely on this. Another good reason why I think `x.await` will work fine is that it will often be read as `x.await?` and due to the colocation of `await` + `?` this makes scanning easy. Moreover, it's trivial to `grep` for.
Wow, this is mind blowing to me. I will admit I tend toward a prefix solution (\`(await something)?\` is not so awful to write), but I could easily get behind any other solution than \`future.await\`. The previous summary talks about feature orthogonality, but I have no idea what will happen if I have a struct with a field named \`await\`! Some might say this isn't an issue - it is only defined on Futures! But, then, if the proposed syntax is extended to include \`match\`, which works on basically all types, will I be limited in what my fields can be named? It should either be prefix or some postfix syntax that looks sufficiently 'here be dragons' that allows suspension of understanding. For many, that is \`future.await!()\` and it's ilk - I know how macros work, but writing them is still quite tricky and with procedural macros, even veteran could easily believe it could be implemented that way. It wouldn't be the first time we have magic in the compiler masquerading as a normal implementation (see \`Box\`'s empty definitions, for example). I really appreciate this write up, but I'm not sure what to do with this information. I'm glad the language writers are excited, but I do feel that adopting this proposed syntax would be a mistake. There have already been calls to slow down the experimental nature of Rust. Surely this qualifies as too fundamental to Rust's future to devote such an experimental and controversial syntax to. What can we do to make our voices heard without bombarding the language team?
I'm not sure this would be the right order of doing things then. Granted I'm in favor of prefix, I'd say it would be probably be smarter to start with the prefix await option and then work on a generalized postfix proposal having thought out all pros and cons for the generalized options. Starting with just postfix await and maybe not having thought out all the consequences for a generalized postfix notation seems like it could cause issues in the future.
That's true of `?`, too, and I've found I've gotten used to it there
I'm sure the team carefully weighed out many proposals, but I wish this article mentioned the `await { }` syntax with mandatory braces. This syntax solves the issues with prefix notation (IMO), but it appeared late in the debate and didn't get the traction it deserved.
I agree with this very much. Generally I'd like to see `await someCall()` but `someCall.await()` would definitely be desirable with the builder pattern
I think it would be clearer if we set aside the Rust and talk about what the computer should be doing. A `Vec` is three values which identify a chunk of memory: starting address, how many items can be stored there, how many items that are actually stored. When you start, is the data stored in a `Vec` or in something else, such as a btree or hash table? When you say "insert into a database" does that mean calling a function? Manipulating a data structure you control? Performing I/O? That matters because it impacts whether it's a good idea or not to use `rayon` and multiple threads. If the database can only do one thing at a time, multiple threads are just an unnecessary complication. `clone` performs a copy operation or similar which turns a `&amp;T` into a `T`. The exact details depend on the type `T`. Cloning a `Vec` causes the memory allocator to find a chunk of unused virtual memory at least as large as the data contained in the original Vec. It then calls `clone` on the contained type to copy the elements - one at a time. It's a strange thing to do inside a parallel `flat_map`. I'd want to copy the data *directly* into the destination allocation created by `collect`. But that `clone` creates many intermediate copies. This isn't as bad as it sounds - `rayon` may also decide to create many intermediate Vecs, merge a linked list of them, and finally (one thread only) copy each one into the destination. But it's not a necessary copy. And in some cases (when it can exactly size the par-iterator) `rayon` "drives" data directly into its destination using all threads. So that's the level I'm trying to understand. How (almost as if you were giving detailed instructions to a group of people) are you trying to do what you're trying to do?
I have been thinking to do one for myself as well. Take a look at the ncurses or signature crates.
There's no doubt that it is "odd." The question is whether it actually serves as a concrete roadblock to actually using the language. I can't see how it would be. JS is a very different language than Rust. It's no surprise that there are very different concerns at play here. Most notably, Javascript uses exceptions for error handling where as Rust uses plain old values. That alone is a substantial difference with a huge impact on the language design for await syntax.
That crate looks promising! The readme basically calls out the issues I'm finding regarding lack of QoL around arrays.
Thank you, I should *really* study about the Orderings further. I also changed the number of threads to 8, and running the benchmark again shows... that this is now reliably slower than the mutexed version. Strange. I googled a bit to see if this is expected, but nothing solid came up. Guess I'll call it a day and be happy with the somewhat slow implementation I have, at least I learned something.
I'm generally against things that require syntax highlighting to be easily recognizable. It should stand out in a `diff` without any help.
I love your project! But &gt; Dystoipa is super early stage now, and I'm noob on this area. You should add this to the README!
You can try something like https://github.com/emoon/dynamic_reload or https://github.com/draivin/rust-hotswap
We are forking Rust [https://github.com/tokyoplang/crust](https://github.com/tokyoplang/crust) to use prefix await.
Ok I will!
I disagree. A democratic approach toward language design would yield a terrible language. I'm totally okay with a "small elite language team" making the final decision, as at least then they guarantee consistent ideology. Also the people working most on the language should have majority say, not everyone's vote is equal here.
You can't have a field named await because it is a keyword.
You can't have a field named await because it is a keyword.
&gt;prefix There are certainly failure examples here. But this doesn't suggest this approach is fundamentally flawed.
&gt; uses prefix await and remains compatible with Rust. Are you going to also _allow_ postfix dot-await? Otherwise I don't see how you can claim to be compatible. This is not a good trend to support. I would not be receptive to pull requests on any of my crates to alternate await syntax, nor any other forked language decisions folks might choose. You're within your rights with open source code, but good luck forming a community...
I'm not the biggest fan, but I suppose I can always write a macro to let me use prefix notation like `wait!(expr)` expanding to `expr.await`.
I've been holding back precisely because I'm confident the language team would produce something that's even better than what I thought I wanted. And I feel like that was a good bet. `.keyword` is *exactly* one of those things I never knew I wanted. - `.await` is cool and I'm looking forward to it. `.match` oh yes please! - `await` isn't a method call. In fact it's the opposite - it pops from the call stack instead of pushing. Making the magic more obvious is going to be a big boon for learning and teaching. - in hindsight maybe `as` should have been `.as&lt; &gt;` - as a silly proposal: `as match` and `as await` and `as try` are kinda okay - `-&gt;` is the only other token that comes close to competing with `.` for this purpose.
Also please up-vote this so we could have a valid discussion.
I don't see any benefit of trying to fracture the community to support a slightly different way of doing the same thing, but okay.
&gt; annoyingly clever Scala has postfix `match` and, well, you're not entirely wrong because "annoyingly clever" is one of the more apt accusations that can be leveled at the language (in general). I think code review should be the solution though. I know almost nobody marks up printed listings anymore, but part of me wants to imagine someone somewhere putting "No golfing!" in red pen next to that kind of thing.
You should be able to use the recommendations from this post https://stackoverflow.com/questions/418791/drawing-on-desktop-in-mac-os-x with winit https://github.com/rust-windowing/winit/blob/master/src/platform/macos/window.rs not totally sure winit supports all those options though.
&gt; I can't write rust without an IDE, or any language. Can I be mildly critical and recommend taking that on as a personal challenge? Not having features like the tab key of power or automated function parameter listing makes you more sensitive to good API design. Are vocabulary items such as functions and methods easy to remember? Do parameters have a consistent logic? Are return types clear in the context where they are used? It's like a keyboard musician singing or playing a fretless instrument - the limitations of the tool force you to become more sensitive to harmony. I think simple editors are particularly good for practicing code reading skills and thus developing a readable style. Nothing wrong with IDEs though, same for pianos and organs.
I think asmx85 is talking about "visibility" as in "*awareness*" or "*knowledge*". All users will become *aware* that the field access syntax has special cases. You're talking about "visibility" as in "*readability*". You are concerned that `.await` will not be noticed when quickly *reading* code. That's not quite the same thing. I personally wonder how much effect exposing new users to special cases right away will have. New users are likely to encounter the special case of `.await` while still evaluating the language. Whereas, even though I've read the entire Rust book, I still view `foo!()` as meaning "magic here" (repeating myself) and `await!()` would appear to be consistent to a beginner.
Thank you. Will definitely try these
People tend to be bad at describing what they want; it's one of the most annoying cognitive biases. [If you have 20 minutes to spend on a TED talk.](https://youtu.be/iIiAAhUeR6Y)
I'm converting a school project that I wrote in C into Rust. It has to do with packet analysis. I'm very new to the language, so this seemed like a good way to jump in. I'm a little frustrated that the Rust compiler is marking my defined constants (to avoid magic numbers) as unused code, even though I invoke the constants in struct definitions, etc.
As much as I respect the time and effort put into all of this, I think the first public discussion should have been whether we need to change the plan *at all*. I think it is a mistake to throw away the obvious syntax without giving people a chance to fight for it. I maintain that none of the suggested changes are any better than `(await foo())?`, and I particularly dislike the one in this final proposal. Given the reactions people are having to *all* of the suggested syntax changes, should we not re-introduce the option of "keep what we had"? Yes, `(await f())?` isn't fantastic, but basic shadowing would make it neater: ```rust let bar = await foo(); let bar = bar?; ``` This type of shadowing is already fairly common in the Iterator space, so it's not outlandish as a suggestion to deal with the issue. At the very least the syntax is extremely obvious, and is very familiar for **everyone** (including outsiders) in the case of using `await foo()`. I feel it's minimal in terms of controversy, and it's also what we were going to go with anyway (so we don't have to shift timelines around, etc). Given that one of the goals is to ship the feature, sticking with what we had would help things. At this point, any other syntax feels a little rushed. The post was opened a few days ago to gather feedback, and we're already on a final proposal. For something we're deeming so critical, this feels a little fast and I hope we're not going to regret what we choose.
But how does that make the scanning different? People will have to learn "await" as special in any case.
We were aware of the syntax-- it's been on the table for the last year or so along with all the others. This blog post didn't discuss it because it was focused primarily on postfix syntaxes. The previous post laid out the rationale for postfix vs. prefix, so this one didn't address it as heavily. One quick thing to note on \`await { }\` specifically: my personally worry was that it would lead to confusion with the parallel \`async { }\` syntax, while the two are nothing alike and shouldn't be used similarly. That is, one would reasonably expect that \`await { }\`, like other block-like syntaxes in Rust, could be used to contain multiple statements, which everyone on the language team agreed would be unidiomatic and a misuse of the feature.
who cares
I really really disagree with this. Syntax highlighting is like capital letters and punctuation. you can read text like this and you can understand it but even though that's how we talk it's probably not ideal to writing big chunks of text
What differences do you plan for this fork to have? If the only change will be await syntax, I can't see this improving the situation. Even if you disagree with the team's decision, you must at least trust the team itself. What you refer to as an "elite group" consists of the most significant contributors to the language and in my experience they have been extremely considerate, reasonable, and well-motivated in their decisions. However, to borrow the wording of a team member, inclusivity should happen at the level of the design process, not of the language itself. Supporting More Than One Way to Do It has downsides, and sometimes those downsides outweigh the limitations of supporting only one. In such situations the language must necessarily be opinionated, and I don't think it's important enough to fracture the community over.
This is not worth a fork, not even close. I think this is a bad idea.
Oh, I just think that it's natural that `await { }` could contain multiple statements. It may nudge people in the wrong direction, but I don't see this as a big deal, because fundamentally any expression can contain a block with multiple statements. (Also I think it's kinda neat that Rust enables `myfun({ a(); b() })`, even if it's not particularly idiomatic either)
This is odd...I managed to get it to work by connecting to a VPN before running cargo build.
It is? I have seen others using it on Windows and it appears to be working for me now.
Why not create a macro that allows people to use `name_of_macro!(expr)` and have it expand into `expr.await`? That way, you can avoid forking the language. Also, if people use the macro, then you can make a strong argument that prefix-await should be allowed.
You can use the join! macro which is defined in futures-rs for that.
Or even some kind of preprocessor that turns prefix into postfix.
It's not that anyone needs to care for it or desire to uphold it arbitrarily; it's merely the idea that code that reads as though it has fewer dissimilarities to one's native tongue could be easier for those people to parse, with fewer mental contortions required to achieve understanding. There's no need to go full COBOL or full Literate Programming; at the end of the day we can't deny on the fact that computer languages are precise where natural language is ambiguous. But that also doesn't necessarily mean that we have to avoid any attempt to make computer languages similar to written language where such an effort doesn't compromise the language's unambiguity (for example, the fact that code reads left-to-right instead of right-to-left).
Announcing RHP! A new PHP-like version of Rust, made by YOU! The people!
`break` can carry a value out of a block (loops only? I don't remember right now), but after `let foo = break 5;` `foo` has type `!`
That's one way to make a point, but with a change of such magnitude, you should pick an entirely new language name, lest people be confused by the persisting existence of this soon-to-be-totally inferior language called Rust. A cool japanese name would lure many more projects requiring _proper_ asynchronous dispatch syntax to your new language. I will not suggest any for fear of committing cultural _faux-pas_, but I'm sure you can come up with something better. All sarcasm put aside, I agree the proposed syntax exceeds the bounds of good taste and am thoroughly unconvinced by the arguments brought forward to justify it, but will resign myself to it and keep my voice low should it really come to pass.
Not quite; I believe the return type of `break` (as in, the ??? in `let x: ??? = break 42;
I don't think any part of this discussion precludes the idea of method-like macros. If anything, I'd say that allowing postfix-keywords would strengthen the case for method-like macros by further encouraging postfix notation in general.
I would like to have result = await + coroutine: callback
Iโm with this guy ^!!! Go create something or solve some outstanding issues, entitlements like this slow down the progression of the language
Really cool. I'm very interested in doing audio programming with rust and will definitely be using this as a reference.
I have no problem with `?`. I can't quite tell you WHY they're different in my head except that when debugging deadlocks in C# I've found it very useful that `await expr` "leaps" out at me and that's what I focus on. There's more of a cognitive burden with `await` than the early return that `?` provides.
I feel like this postfix syntax is the worst option available. Firstly it adds parsing ambiguity to the human side by forcing me to remember that "no that isn't a member variable access" from the name used after the dot. Pointlessly overloading already standard syntax used in almost every language made in the last 15 years is a very bad move from a readability and simplicity standpoint that the prefix notation doesn't create. The generalisation justification used with the example of match is a horrible example and points directly at the biggest flaw with the argument. You can't chain match calls, so why would you want a .match operator? It just adds more syntax for humans to parse for. I believe chaining await calls is a bad idea in general. Trying to encode so many control flow switches into a single statement is just going to cause debugging and readability problems. Cases like `foo.bar().await?.baz().await?` encode so much information it becomes far too dense to be useful. First we're calling a member variable that returns a future, that we then wait for which will yield control flow to an async scheduler, which we eventually get control back from when the task is done, which we then check for success and propagate an error for with a single character operator, which we then call a member function on (type unknown to the reader without more context), which we then await on, go back in and out of a scheduler, propagate errors on until we finally have our end result. Let me just set a break point on one of tho... Oh I can't. Await is not even close to being as trivial as a member access, we shouldn't pretend it is by overloading member syntax.
When the website was released I didn't have favorable opinions of it, but all over twitter I saw rust folks tweeting overwhelmingly positive things about it. At the time I thought "huh, must just be me" and didn't really feel the need to comment on it, so I'm surprised now to see that there was a lot of negative (and perfectly reasonable) feedback.
How is this working in a pattern? \`\`\`for future.await in stream\`\`\`?
This is a building block for some future plans I have for Rust client-side applications, and it's the first procedural macro I've written. I'm not completely satisfied with it yet but it's in a usable state and I'm open to feedback to improve it and figured I'd share it now. Hope someone finds it useful!
False. You cannot conclude that the community didnt like it based on a _straw_ poll. Even the name of the poll suggests it's unreliable. There's bound to be sampling bias. Furthermore, this is a terrible strategy to deal with language changes you don't like. Should we all behave like that, we'd have a lot of rust forks, and no community.
I'm sure I'm missing something, but is that ever useful for generics in argument positions? Turbofish is definitely useful when you have a generic return type, but I'm having trouble thinking of an example where you'd use it for an argument.
Clojure has the threading operator which makes this nicer (could be easily defined in another Lisp): (-&gt; x first second) It's kind of similar to how Elm, Haskell, F#, OCaml etc. use reverse composition (although this leverages infix operators and currying rather than macros, and Haskell tends to favor forward composition): x |&gt; first |&gt; second Note that the downside is that you have to pull stuff into the current namespace to call them directly, but the upside is that the same system can be used for all functions, not just methods.
We would but unfortunatly all the major issues about the design/color scheme are A) Closed and locked and B) [already solved](https://github.com/rust-lang/www.rust-lang.org/issues/421#issuecomment-443098003) &gt; entitlements like this slow down the progression of the language How is it entitlement to ask where the retrospective on this issue *they promised* is? They hear the communities concerns and want to work through them they said, "we'll discuss what went wrong, how we can improve, and post about it", they said. They still havnt. It isnt "entitlement" to ask where the promised discussions are.
You get closer to filling out the table of {prefix, postfix} X {methods, macros, keywods}. Prefix/postfix becomes a whole new axis of syntactic expression. I guess the next thing would be prefix field accessors, but I'm not holding my breath for that.
I've warmed up to it a lot. However, there is no way to navigate to Rust Forge the last time I checked. I also think it would be nice to have the Contribute page back to focus people on getting involved with that particular aspect. Both of these a discoverability issues. I also think the early Rust tagline "Blazingly fast... yada yada" and the Feature list where great at offering up a clear impetus as why someone might choose Rust, I know these things are easily discoverable elsewhere but it's still nice having them reaffirmed front and center. Perhaps they were meme'd to death by detractors or over-zealous rustaceans (and yet this sticks around.) I don't see that as a good reason to nix those though. Having a code sample front and center was also really nice, and it's real shame that it went away. I love the little trial demo that Haskell has for newcomers.
Syntax highlighting is but it wishful thinking, e.g. look at the screenshots in https://www.reddit.com/r/rust/comments/bfa44w/what_about_official_rust_syntax_for_vs_code/.
See the screenshot in https://www.reddit.com/r/rust/comments/bfa44w/what_about_official_rust_syntax_for_vs_code/ for an example of how well that works.
Wouldn't it be better to ask the core team this directly?
[It should be released some time in May.](https://internals.rust-lang.org/t/followup-on-website-concerns/9018)
You might have to live with copying a trivial macro into your projects and writing `Await! {}` instead. The capital is far from ideal, but I doubt they're going to free up the await keyword.
[One man paper](https://github.com/advancedresearch/path_semantics/blob/master/papers-wip/history-of-path-semantics-illustrated.pdf) &amp;#x200B; [Paper](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf)
Hi, I work on the Dart team. Dart uses a prefix `await` syntax. In many cases, basically when it's used at the top level of an expression statement or assignment, it looks nice: var foo = await bar(); await baz(); But if you have to chain it, which happens fairly frequently, it gets really ugly really quickly: (await (await foo()).bar()).baz() Code like this does happen pretty often. We've talked about introducing a postfix syntax with high precedence to specifically address this. We don't have any definite plans to do so, but it does encourage me to think that Rust is making the right choice by going with postfix.
It would be `.match{}`, which neatly avoids the problem where the English language biases you to read `foo.await.bar` as `foo.(await.bar)`. Sure, it might be something you grow accustomed to after the first week, but isn't the learning curve bad enough already?
&gt; I've warmed up to it a lot. The design itself has a lot of good points, in general that was never the problem, it just needs some polish. The colors in particular, and [this solution](https://github.com/rust-lang/www.rust-lang.org/issues/421#issuecomment-443098003) was presented back in December that a lot of people, including myself, loved. That and general process improvements, a lot of people didnt like how sudden the design came up and how close the deadline was when it was announced, in general how the entire thing was handled. A lot of stuff was broken when it first came out too. &gt; I know these things are easily discoverable elsewhere but it's still nice having them reaffirmed front and center. Yeah, they may be elsewhere, but the front page of the site is for first timers, beginners, people just looking into rust. They shouldnt have to explore to find features and example code. The new site still doesnt even say it's a programming language When i recommend Rust i still link to https://prev.rust-lang.org/en-US/ Unfortunately the new design [targets managers and CTOs](https://github.com/rust-lang/www.rust-lang.org/issues/431#issuecomment-442985053) When you look at other languages sites, [go](https://golang.org/), [python](https://www.python.org/), [haskell](https://www.haskell.org/), [koitlin](https://kotlinlang.org/), they all prominently feature code examples, say they're a programming language, have consistent limited color schemes, primarily target developers, etc. It's night and day compared to our site. We still don't have [syntax highlighting](https://github.com/rust-lang/www.rust-lang.org/issues/349) for the [getting started](https://www.rust-lang.org/learn/get-started) page
What are you basing that off of? Thats the read linked in my post, and it doesnt give any release date except for "early 2019" and "after new years/holidays". It is now mid-2019.
What if `foo.await!()` was a normal macro that expanded to `(xXx_YOLO_Swag_internal_await_keyword_๐ฉ๐ฉ๐ฉ_420_xXx foo)`? "It's cheating by delegating to a non-macro implementation" would still be more consistent, and for `await!(foo)` would give the programmer the option to write `await! {foo}` instead when they feel that a LISPful of closing parens is a bit too hard to pair up manually.
&gt; I find reliance on code viewer/editor features should not have its place in language discussions. I don't understand the hate editor features that make code easier to write get. It's been decades since we physically wrote code on paper and manually fed it into machines. Even if you hate IDEs, smaller editors like `vim`, have syntax highlighting too! If a forum doesn't have syntax highlighting, thats the fault of the forum and a bug to be fixed. Programming languages should not be designed around old forums. Theres no reason websites can't have syntax highlighting, and many do. Even Discord has syntax highlighting. There are established, well supported, web libraries for this. If your diff software doesn't have syntax highlighting, the solution is to fix the diff software, not redesign the language. Vim has diff editing, and it has syntax highlighting i believe. So does VSCode.
&gt; Itโs like making bold and italic text necessary to understand English instead of being used for emphasis, etc. You just described how they're required. They're required for emphasis. ???
Seems to me it'd be better to improve syntax highlighting, rather than redesign the language.
Jeez, if they did unsafe as a postfix, I'd really need a strong article to convince me. If, while, for, match, etc. are all fine being postfix, in my mind. But unsafe? That *needs* to be in block form. The point of unsafe is to make things slightly annoying, so that programmers don't reach for it naturally. Unsafe with block notation *is* that. It's fine to chain tons of awaits, all together. But unsafe? You *need* to be really careful. Having unsafe being the only outlier is fine to me, because it already is an outlier. Unsafe is its whole special things.
I'm trying to create a trait which other structs contain by using a box: trait Texture : Clone { fn value(x: i32, y: i32) -&gt; Vector3; } #[derive(Copy, Clone)] struct ConstantTexture { color: Vector3, } #[derive(Clone)] struct Material { tex: Box&lt;Texture&gt;, } However, the compiler complains: trait `texture::Texture` cannot be made into an object note: the trait cannot require that `Self : Sized` It seems like this should work, since Box is a pointer that has a constant size. Can anyone point me in the right direction?
&gt; I haven't yet seen any concrete reasons why 'await blocks' (either with {} or ()) aren't a good (enough) solution? I agree. It seems to me that `await { expr? }?` is simple, easy, and clear. Add stuff like `?` in there and it's precedence is clear from where you put it, inside or outside the braces, the orthogonality problem from the earlier paper seems solved to me. It's not like the syntax is unusual either, you can already use blocks that way, with `match` or standalone, `println!("{}", {{{ "oof" }}}.len())` is perfectly valid.
 foo["await"] The real problem with precluding it in JS is that it'd be backwards incompatible with code that already has "await" properties on it. I don't think we need to care about conjugating verbs in a programming language. Everything can be the infinitive.
What alternative do you propose? Stop using Rust entirely?
&gt; Hi, we are a bunch of language researchers (...) I imagine the language research you choose to forgo, to pour your time into maintaining a fork of a huge, fast-moving programming language that no one in their right mind is going to use because you have no track record of successfully maintaining a language, all just because of a petty syntax quarrel. Pity. On the other hand, as researchers you sure look *unconventional* if you decide that some newly decided syntax warrants a fork without having tried it in actual code โ perhaps you might want to give `.await` some time and an actual test drive before you commit to such a huge project. Either way, I wish you best of luck. *To everyone else here: The rust community has grown considerably over the last year. This appears to include folks who like drama more than programming. If you belong in that group, grab your popcorn. Otherwise: Nothing to see here, move along. In either case, please stay civil.*
As /u/epage mentioned, not all places have syntax highlighting available, and the post I linked shows that, even when it exists, it's unreliable. So the whole "syntax highlighting will fix this" argument feels hand-wavey. And it's not like this is the only disadvantage of the proposed syntax, as most criticism to the other solutions also apply to it, as [others](https://internals.rust-lang.org/t/a-final-proposal-for-await-syntax/10021/14) have pointed out [before](https://internals.rust-lang.org/t/a-final-proposal-for-await-syntax/10021/15).
You can take a look at some of the spoons in hammerspoon. They do things like rainmeter.
I guess I don't see "filling out the table" as a goal in and of itself.
I guess maybe this is where my "I'm not a language designer" thing kicks in but adding both of those constructs seems super weird. I find the idea of postfix control flow field access to be \*the weirdest thing\* I'd have to explain to someone about rust, I think.
&gt; The postfix keyword approach actually introduces new syntax, so it's not like the opponents of it are trying to redesign the language. Semantics. If syntax highlighting isnt reliable, the solution is to make it reliable, not design the language around not having it. It's been decades since we physically wrote code with pen and paper, manually punching it into machines. We're not in the dark ages anymore. There are plenty of well established libraries, including for the web, that can provide syntax highlighting. Even if you hate IDEs, smaller editors like vim, have syntax highlighting. Anything meant to work on code, software or website or something else, that doesnt have syntax highlighting is, quite frankly, broken IMHO.
Honestly, my IDE breaks enough that I don't need the extra practice.
Good question. I honestly don't know? I have no idea how blind people program - I know they do, I know there are tools, and I can't speak to them. So it's really hard for me to say how to optimize for that situation, which I should probably consider as something to fix.
This might be a crazy idea, but what about "..." (three periods)? It even gives the appearance of trailing off...and then coming back.
Hi all, I'm currently working on Pushrod, and I have a Piston question. It has come to my attention that drawing using `draw_2d` is very inefficient, as it uses the CPU to draw. "No duh," many of you may be saying, but it's an exercise in ... let's call it "constructive guessing" :) So far, I have been drawing to the screen every drawing cycle using draw_2d, which means each invalidated object gets redrawn every 30-60 FPS. I am trying to mitigate this by drawing to a 3D texture (for each on screen object), then drawing their contents to an image, and drawing the image, but only changing it if an object invalidates. This means, if no object invalidates, all that is shown is the static image. Does anyone have any tips/code that they can direct me to to help get a grasp on this? I want to release a solid 0.2.x release of Pushrod, but I am stuck here. If I am forced to use 2D drawing, the CPU will be _pegged_ at 20-30% at idle, as it's redrawing everything. If I can use 3D drawing, I'm almost guaranteed a 0-1% usage at idle, so you can see, this is a very important update. Any help or tips would be GREATLY appreciated. I'll even send virtual beer!!
Message i meant packages with data to transform and make calculations and send data back to client's desktop app, to be more clear i want to setup a simple udp game server on it via udp sockets.
As a data point, some rustc-internal iterator functions used to return `impl Iterator` (I haven't checked if that's still the case). IIRC there were problems with not being able to `.clone` them (so they'd need to be `impl (Iterator + Clone)`).