I have tried that already but in that case if the tests module is in a different file i cannot access the private functions in the previous file 
one can always use \`include!\`, but that's not recommended 
After go it just feels weird this way but its the idiomatic rust way to write unit tests in the same file at the bottom right ? 
well i heard about this macro for the first time :) i am just trying to get comfortable around and if its not idiomatic way of doing things i wouldnt do that just it feels so weird after getting used to go
eli5 functors?
There's a great [blog post](http://xion.io/post/code/rust-iter-patterns.html) on this topic.
In a tests module, yep. For unit tests, anyway. integration tests go in the tests folder. Go and Rust are very different languages :)
This isn't a Rust language feature, but rather a standard library function I thought was nice. [split_paths](https://doc.rust-lang.org/std/env/fn.split_paths.html) I recently needed to check if the currently running executable was contained in the `PATH` environment var, and it needed to be cross platform. If you have a `path_var` String which holds the value of that env var, and an `exe_folder` which contains the PathBuf of your running executable, the check is as simple as let exe_is_in_path = env::split_paths(&amp;path_var).any(|p| p == exe_folder);
Usually the fact that it nukes stack traces, which can make it harder to track down the exact location of runtime errors. But for Rust, the biggest hurdle seems to be implementation details: many of the target platforms (ie WebAssembly) make it really hard to implement guaranteed explicit TCO without significant troubling tradeoffs.
I always use `Iterator::flat_map` instead. It does the same thing but works for all iterables, not just `Option&lt;T&gt;`.
If I would be able to write 100% perfect bug free code, without memory leaks, dangling references and data races, Rust wouldn’t be so attractive to me. I am not that good programmer yet.
If you define and instantiate a macro inside a lexical scope, you can directly reference variables defined in that scope in the macro definition. For example: ``` fn foo() { let x = 1; macro_rules! bar { ($arg:expr) =&gt; { return $arg + x; } } bar!(42); } ``` This is a big help when using macros to abstract away repetitive code.
Mutually recursive functions can become a mess when transformed into one huge loop.
Sorry that was a mistake, it supports truetype fonts not opentype fonts. It seems like Fira Code also has a truetype version, could you try that?
Use nm as with C libraries too
ELI5: A functor takes a boring things and turns them into fancy things, and takes boring functions to a fancy functions. And it does so in a way which is especially nice. In math, this usually means going from a geometry, which can be bendy, curvy, and hard to think about, to something easier to work with, often an algebraic object which reveals some truth about the geometry. In programming, the example that usually jumps to one's mind is the `List`. Given any type `T`, you can make a list containing things of that type, `List T`. So `T` is boring and `List T` is fancy. To make it a functor, though, you also need to be able to turn boring functions `A -&gt; B` into fancy functions `List A -&gt; List B`. The natural way to do this is to simply apply the boring function to each element in the list and give back a list of the results. Mathematically, functors are about [diagrams](https://en.wikipedia.org/wiki/Commutative_diagram) and they allow you to take a boring diagram and turn it into a fancy diagram. And so if I have a diagram between, say, smooth manifolds with a distinguished basepoint, I can transform it into a diagram about vectorspaces by looking at the tangentspace at each point. And all of the smooth maps relating my smooth manifolds (which are gnarly and hard to think about) turn into linear function (aka, matrices). Life is good!
Amazingly enough, not only that, it will also short-circuit and stop reading the iterator as soon as it encounters an `Err`.
Hmm apologies if I'm not understanding, but once you mutex pages it is impossible for any resizing to happen concurrently. I think what you want to do is loan out members of said array to other tasks and still resize. You should be able to do this if you make a vec of Arc of your items ( Mutex&lt;Vec&lt;Arc&lt;Item&gt;&gt;&gt; ). Even though the vec may allocate, your Items will still be safe across threads through atomic reference counting. If you want to make your items mutable then you need to mutex your items individually (Mutex&lt;Vec&lt;Arc&lt;Mutex&lt;Item&gt;&gt;&gt;&gt;).
Thank you!
Fwiw you can also do that with methods eg `a.foo()` desugars to `A::foo(a)` (assuming `a: A`), so you can `bar.map(A:foo)`
Yeah, I've worked on LD_PRELOAD libraries in Rust in the past so it didn't take me very long. I did the initial rewrite in one night, and I fixed some small stuff in the following week.
Thank you. I think in my case output would be the right thing, am I wrong? It's just one echo (that's how mdb-sql works, you should just echo a query string to it). Am I right?
You're not wrong, Walter, you're just an asshole.
Bad bot
err its onyl 1 file ?
I don't want resizing to happen concurrently, but reading can always happen, even while resizing. This is the reason why your approach does not work, or at least not the Vec part. Arc would be an option but Rc is probably better here, since it's locked behind a Mutex. However I still have reference counting which I don't need because it should be well defined, that I always have exactly 1 pointer pointing to one page. Thanks for answering anyway! 
Those two examples don't really make sense ... numbers can't be used as functions (unless you have weird orphan Num instances).
Excellent overview of the language, ecosystem and community. Thank you for writing it.
Functors are type constructors `F&lt;_&gt;` that support a `map` function: fn map&lt;T, U&gt;(self: F&lt;T&gt;, f: Fn(T) -&gt; U) -&gt; F&lt;U&gt;; // pseudo-Rust syntax The `map` function needs to be "sensible", meaning that: m.map(|x| f(x)).map(|y| g(y)) == m.map(|x| g(f(x))) Functors are difficult to express in Rust due to various complications (including the lack of higher-kinded types). There are some *conceptual* examples such as `Iterator&lt;_&gt;`, `Vec&lt;_&gt;`, `HashMap&lt;K, _&gt;`, `Option&lt;_&gt;`, `Result&lt;T, _&gt;`, `Result&lt;_, E&gt;`, `Future&lt;T, _&gt;`, `Future&lt;_, E&gt;`, etc, which can all be mapped over.
So what are programmers problems? 
Well if you use `output`, you can't write to stdin - only pass arguments, as far as I know. So you must use `spawn`. You don't need to run `echo`, because you already have access to `cmd_mdb_stdin`. Just write your query directly to it [like this](https://stackoverflow.com/a/32069040), using the `write_str` method.
Hey all, I'm struggling over learning about borrowing and lifetimes in Rust. Here's my code: ```rust struct Journal { tags: Vec&lt;&amp;'static str&gt;, } fn new_entry(subm: clap::ArgMatches) -&gt; Journal { Journal { tags: match subm.value_of("tags") { Some(tags) =&gt; tags.split(",").collect(), _ =&gt; vec![] } } } ``` Compiler complains about the segment `subm.value_of("tags")`, and says ``` explicit lifetime required in the type of `subm` ``` I do not get this error if instead I enter ```rust struct Journal &lt;'a&gt;{ tags: Vec&lt;&amp;'a str&gt;, } fn new_entry(subm: clap::ArgMatches) -&gt; Journal { Journal { tags: match subm.value_of("tags") { Some(tags) =&gt; tags.split(",").collect(), _ =&gt; vec![] } } } ``` This confuses me, because I'm not sure why the lifetime of subm matters. I also figured `static` is kind of the `less strict` and would be easier to use. I sort of understand that the variable `tags` is created in that small scope, but after splitting and collecting the string I don't get why it still is related to subm's lifetime. I tried to look for ways to copy &amp;str to be a &amp;'static str, but I seemed to be barking up the wrong tree. If I kept the struct the same, how could I change the method while keeping the function signature the same? Note: I know I can use String, but I want to gain a practical knowledge of ownership, String seems to take care of this for you. 
&gt; I want to sort a Vec using a fallible key-function, where failure is an error that I want to propagate to the caller as soon as it occurs, a la try!(x :: Result&lt;T&gt;). So why can't you write a sort method that does this?
For one thing, computers have too many bits in them. They make a mess when they get stuck in the tubes.
Note that I did not state that Monads are useless. I said that nobody has made a good case for which value would monads add to Rust. What people fail to realize is that Rust is not Haskell. For example: &gt; Charlie has a similar task as Alice, except his key-function might actually return multiple results for an item, and he'd like to produce all the possible valid orderings so that the caller can choose between them. So would the sort function return multiple vectors? If so, it would need to allocate memory for multiple vectors, copy stuff (if `T: Copy`), etc. That feels very un-Rusty.
Currently embedded in OOP due to education, but can you go more in depth about what you say? Specifically the state and mutability part
Oh sure, but it should be understood that `unsafePerformIO` and `unsafe { .. }`, while able to brick the type system and cause undefined behavior, is an implementation detail meant for use to build up safe abstractions that respect type system invariants. They shouldn't be thought of as "impure" in that sense. In the case of Haskell, there's also `SafeHaskell` which allows you to statically reject `unsafePerformIO` in the code. I don't think linear dependent types are enough to get rid of all needs for backdoors out of the type system. There's always FFI, which a compiler cannot reason about fully. And languages like Agda have postulates and such mechanisms to also subvert the type system.
Great article. I think that I prefer crashes over logic errors / memory errors though. I don't think there's any shame in some asserts.
I do think completely pure functions are of huge utility. Most code bases consist of mostly pure code, it's just that there's no way in the type system to declare segments of code as pure or check things. Thus, without `const fn`, or the separation of pure/IO that Haskell provides -- and the nudging that it implies, pure and impure code get jumbled together in one mess. This makes for untestable and brittle code. As an example, I am currently a teaching assistant for a course on OOP design, supervising a few students who are writing projects (involves domain &amp; design models, and such things...). I supervise 4 different groups. The only group that had real trouble with their design was the group that mixed threading, network IO, global static state, and pure code. It took them quite a while to untangle the mess they created. Gary Bernhardt has given an excellent talk on the subject of ["Boundaries"](https://www.destroyallsoftware.com/talks/boundaries).
When you borrow a temporary value in an expression, and store that borrow, the compiler silently does this: let s = String::new(); let x = &amp;s; 
Only now realized that meetup.com is not free. So maybe meetups are going to continue, but without meetup.com?
Oh, cool. No, I did not have a case where I went along with a compile error, I just knew beforehand that I needed an `Option&lt;&amp;T&gt;` from an `&amp;Option&lt;T&gt;` and investigated. The docs gave me the idea to use `.iter().next` which felt funky but ok, and I simply missed `.as_ref()`. But I'm going to try and see what happens if I remove it and see if the compiler gives that usefull hint :)
I thought this was going to be an article about AI in Rust, but I was pleasantly surprised it was not. :) (there's nothing wrong with AI...) I loved the framing with the 3 laws; made a lot of sense. Thank you for writing this. It was a joy to read!
I noticed that the Rust version doesn't check if mmap succeeded. The C version does the check.
I knew about them, but I didn't know that it can require to implement a trait !
Good catch! Thanks!
Note that using \`u8\` to encode the response status code can't handle all valid status codes. A status code is defined in RFC7231 as a three-digit integer :)
I've [opened a PR](https://github.com/Shnatsel/libdiffuzz/pull/5) to fix this. Does this look correct to you? I'm a little unsure about the cast from libc::PT_NULL, I feel I might be using the libc crate wrong.
Yep. Sometimes you don't need 5000 lines of code to do something useful.
What does it mean Serverless?
[Discussion in r/haskell](https://www.reddit.com/r/haskell/comments/9p8rhn/is_rust_functional/)
It depends on what you mean by "most games", OOP and ECS. AFAIK numbers-wise Unity is the most popular game engine on the market, and it uses a component-based (though not [full ECS](https://unity3d.com/unity/features/job-system-ECS) yet) game object system, with very little inheritance. It's still OOP to a degree, but at the same time a far cry from complicated inheritance hierarchies of the late 90s and early 2000s.
The `Acquire` when loading `self.len` in `push` is redundant (you can use `Relaxed` here) because the mutex `lock` already synchronizes-with the mutex unlock so the `self.len` changes are seen correctly by all *writers*. The store still needs `Release` to synchronize-with the `load` in `fn len` however. The big problem however is that there is no ordering for `pages_pointer` that can make `get` safe in the presence of concurrent writers. Referring to your playground link, there is nothing to prevent the following sequence of events: * `reader` line 84 * `writer` lines 70-72 * `reader` line 85 In this case `reader` has a dangling `pointer` on its stack and accesses the page array through that dangling pointer. In fact there is nothing to prevent the reader thread being suspended after line 84 and a bunch of writers running several entire `push` function calls to completion before the reader thread resumes on line 85, with a dangling `pointer` that is long gone.
You did not post the full error message. It also tells you a lifetime of `'static` is required for `tags.split(",").collect()`, and suggests changin `ArgMatches` to `ArgMatches&lt;'static&gt;`. Your problem is that you defined `tag` to contain `&amp;'static str`, which means those elements live for the whole duration of the programm. By the signature of [value\_of]([https://docs.rs/clap/2.32.0/clap/struct.ArgMatches.html#method.value_of](https://docs.rs/clap/2.32.0/clap/struct.ArgMatches.html#method.value_of)) though, you get something that lives as long as `ArgMatches`, which will carry over it's livetime via `split`. `ArgMatches` however maybe doesn't live for the `'static` lifetime, so the compiler suggests you specify that. You can do that (and then you run into the next problem, not fully related to this one), but the function will basically be unuseable because you're not gonna get an `ArgMatches&lt;'static&gt;` struct in a meaningfull way. I'm not fully sure where you're going with that, but you will probably need struct Journal&lt;'a&gt; { tags: Vec&lt;&amp;'a str&gt;, } so your `Journal` struct carries with it the lifetime of the references. You will need to arrange things so that `ArgMatches` outlives `Journal`, so that `'a` can refer to the lifetime of `ArgMatches` (because that's where the references are pointing). That will require `new_entry` to take `ArgMatches` by reference so it does not get dropped at that end of that function. If that was unclear or I should spell it out more specifically, let me know. I figured you're learning so I did not just want to write down the solution (also, I'm not fully sure where you're going with that).
In the 1.30.0 beta, [you can now import and reexport macros from other crates with the `use` syntax](https://github.com/rust-lang/rust/pull/50911/). I tried this with [*clap*](https://crates.io/crates/clap)’s [`app_from_crate!`](https://docs.rs/clap/2.32.0/clap/macro.app_from_crate.html) macro, but that macro uses four other macros internally. So instead of what I would expect: use clap::app_from_crate; I had to include five macros in the `use` statement: use clap::{app_from_crate, crate_authors, crate_description, crate_name, crate_version}; Is this how the feature is intended to work, or is this a bug?
google is your friend (well, no, but use it anyway): https://en.wikipedia.org/wiki/Serverless_computing
Answering my own question, this is [not an issue in rustc](https://github.com/rust-lang/rust/issues/54642#issuecomment-425481512), and there is already an [open issue in *clap*](https://github.com/clap-rs/clap/issues/1349).
I'm not familiar with Scheme. What do those lines do?
Thank you very much! I see, why the \`Acquire\` is redundant as long as I only store the length in the same scope. The second one is indeed a problem I hadn't considered. Do you know a solution to this without introducing a fixed size pointer array? 
You'll need to add the line `mod tests` (assuming your tests are in a file called `tests.rs`) somewhere in your production code file, and a `use super::*` as typical in your tests file, then it should work. 
Not sure if this helps but you can use `pub(crate)` so the functions are visible by the whole crate
Downvoting the question is not helpful when not giving a feedback at all.
\`cons\` take two arguments, a and b, and returns a closure of one argument. Calling the closure with another function argument applies the function to the original a and b. \`car\` takes a function x as an argument and applies it to another function that takes two inputs and returns the first input. \`cdr\` takes a function x as an argument and applies it to another function that takes two inputs and returns the second input. Together, these three functions have the following property: (car (cons a b)) = a (cdr (cons a b)) = b That is, together they form the abstraction of an ordered pair, with \`cons\` being the pair constructor, and \`car\` and \`cdr\` being the first and second element accessors, respectively. It's definitely not the easiest or the most intuitive way to create the idea of an ordered pair, but what makes this example interesting is that they are defined purely in terms of lambda. Nothing else is needed. This one of the examples often given to show that the lambda calculus is a deceptively powerful construction. &amp;#x200B;
...huh. neat. Thanks.
Thanks, that works.
Is there a reason that the documentation here doesn't help? https://docs.rs/mysql/14.1.1/mysql/
That looks to be documentation for MySQL, maybe you linked to the wrong place?
I highly recommend putting pre-RFCs on internals.rust-lang.org as well. Many of the people involved in language design and the RFC do not frequent Reddit at all.
And you did not said about it?!
I was only there for just over a day; I had no time to see anyone :( Hopefully next year I’ll have actual time.
I agree that crashes are better than logic errors, but I wouldn't be to dogmatic about that. It is not that hard to come up with examples where logic errors are preferable to crashes. Like... &gt; Your alarm clock, due to an off-by-one error, will pick not the song you have chosen but the next song in the list instead. Luckily an assertion caught that and made the alarm clock program crash instead of playing the wrong song. You continue to sleep soundly. Or... &gt; Your email client fails to load the font of some curved text in the fancy signature of a mail you have received. Instead of printing that part with blank squares, the client crashes. You can't read the actual body of the mail. Of course, in other cases logic errors are worse than crashes. For example, when proceeding with a logic error could corrupt your data. But crashes could also corrupt your data (half-written files). So it's really a case-by-case thing, but if I have to choose, for a specific case, if I want a crash or a logic error - the fact that I get to choose means that I'm aware of the bug, so I should just fix it. The reason we should prefer a programming style that favors crashes over logic errors is to improve testability. We'd rather not have these bugs at all, and a crash will fail our tests when the conditions for it happen, while a logic error will only fail the test if the test had made sure to verify the actual results affected by that logic error.
My apologies, I read your question wrong and didn't know there was a difference between MySql and Microsoft SQL Server.
I think we have different problem domains in mind. I've mostly been using Rust for codebases which are either "much more reliable shell scripting" or where there are a lot of smarts involved, but they're intrinsically tied to traversing a filesystem (eg. Heuristic code to identify a game's icon given only the path that arose from running `unzip` or `tar xvaf` on its install bundle.) and my future plans include web scraping and other I/O-centric tasks. In situations like that, `const fn` is of very limited use to me and, on the testing side, the most useful tests tend to be more in the vein of integration tests where you pour a test corpus into a harness and then it gives an accuracy score and a list of inputs that didn't produce any of the outputs listed as acceptable.
Author here. Thanks for posting this and for the positive feedback :)
I saw that. And it looks interesting. I'm not really sure what ODBC means. Some kind of standard. The documentation looks pretty scarce. Not much example code. I would like to know what the difference is between that and a regular driver.
I missed this documentation when googling. This might be the most documented code I've seen so far
Link?
I hear what you're saying. But they both would get caught at QA and fixed. The bug about playing the next track is fine until it happens on the last track and nothing happens or you get UB. That's a much harder error to fix than one that panics on a specific line. The second case is how to deal with bad input - different from some invariant buried in your own implementation. 
You still need to have 1 module for each file, but you can 'pub use' everything you want in the same namespace to achieve that from outside the module 
This is a nice addition to the Rust command line utility library. Is there any particular reason behind the "blotchy" coloring scheme? In other words, the pattern to match on doesn't correspond to the highlighted text. For instance: if ruplacer 'something' 'stuff' returns a result: -- Have I ever told you s**ome**t**hing** about ruplacer? ++ Have I ever told you st**uff** about ruplacer? the colors confuse me
`println!` takes named format parameters! println!("omg: {foo}, {bar}", foo="fdsa", bar="FDAFDASF"); MIND. BLOWN.
Hope it helps! It took me the longest time to find it too when searching for ms-sql / transact-sql handlers in rust.
Nice idea, but how do you solve the parsing ambiguity between \`..T\` as \`RangeTo&lt;T&gt;\` and \`..T\` as unfold? For example with your syntax \`..(1, 2)\` could be both \`RangeTo&lt;(i32, i32)&gt;\` and \`unfold (1,2)\`.
&gt; is an implementation detail It's not a implementation detail it is exposed to the users. At that point, it's part of the interface. I don't necessarily think it's best to judge a language on the worst code you can write using the worst features, but I also don't think it's smart to try and ignore those interfaces don't exist.
Even in such a shell script, it seems to me that you have algorithms and decision taking functions that are independent of file systems. If the shell script is of any notable size (like 200 LOC+) then separating out side effects from the algorithmic logic is a good thing. I think even in the most FFI-centric of applications it is useful. That isn't to say that you shouldn't *also* write integration tests; but having unit tests improves confidence in your integration tests and minimizes the number of integration tests, which may be expensive execution time wise, you need to write. Every time I've written Haskell I've been glad that there's a type system that forces me to be strict about side effects and not do the convenient, lazy thing (pun intended) of mixing side effects and pure model logic.
&gt; Nobody likes a “squatter”, but finding good rules that define squatting that can be applied mechanically is notoriously difficult. Have you studied Maven's ecosystem? They've got a "group id" for every artifact, basically a namespace, and I never heard about squatting problems there. As a Maven user at least, I never had any problems, it just worked for the last 15 years.
My big beef with tiberius is that it uses `sp_prepare` instead of `sp_executesql`. The problem with prepared statements in SQL Server is that they effectively use this “optimize for unknown” query hint, which does not evaluate the query in light of the parameters you pass and instead assumes a statistically generic data distribution. This means that you won’t have good query plans or performance, the best you can hope for is “meh”.
We are aware, yes.
nm &lt;BINARY&gt;
Can you elaborate on `The rate at which this user uploaded packages eventually resulted in our servers being throttled by GitHub, causing a slowdown in all package uploads or yanks.`? What is/was `crates.io` doing that allowed it to be throttled by GitHub? 
This is correct. We will be moving this to be asynchronous soon, which will have the same effect, but rather than taking longer to get a 200 from the server, it'll just mean it's longer until the crate is live if we get throttled
Oh, certainly. There's a reason I said "of limited utility" rather than "of no utility". The shell script case is a poor one to latch onto, though, because, most of the time, the logic which *can* be separated out like that already is, in the form of subprocesses like [gaffitter](http://gaffitter.sourceforge.net/) and D-Bus APIs like [MPRIS](https://specifications.freedesktop.org/mpris-spec/latest/) and [udisks](https://launchpad.net/udisks). Going any further would be like trying to use Rust to gain greater safety in some of my PyQt projects which are too simple to have much of a "backend" that could be encapsulated. It'd wind up being 50%+ boilerplate for the transitions between the two realms, just so that one or two lines could be called in the safer realm as a matter of principle. For my shell scripts, the main benefit Rust brings is the monadic error handling and faster startup times compared to Python (which I migrated to from shell script to gain `try`/`except`/`finally`, `os.walk`, a proper list type, and sane quoting and string manipulation.)
Would batching make sense in that context? E.g., monitoring notices intake of more than say 5 crates per sec, so it commits locally and pushes only every minute. In abscence of stress it could continue as normal.
Honestly, I wish it took some inspiration from GitHub's separation between ordinary users and organizations and had namespaced packages beside un-namespaced ones. That way, I could "publish early, publish often" under `ssokolow/...` and gain the benefits of glueing together multi-crate projects using crates.io rather than GitHub URLs (which, currently, serves more as a disincentive to publishing or splitting up my projects) without having to worry about taking up scarce top-level identifiers. Then, once I feel I have something that's ready to really share around, I could give it a top-level name based on the same mental heuristics GitHub users rely on to decide when something should be owned by an organization.
But like is there a way to do this from Rust source without shelling out?
No problem! I saw it on lobste.rs and really liked the formulation of the "three laws." Cheers 🍻
[Here you go.](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
Or possibly even batching per user? And then process the users with the least amount of packages first.
Not OP, but here: https://internals.rust-lang.org/t/variadic-generics-pre-rfc/8619
To be honest I don't find this kind of expressions representative what FP is sold for. Pure lambda calculus is not even how Haskell is used in the real world. But in this particular case it's more about static typing, Rust is not dynamically typed, neither it has HM type system, without parametric polymorphism it doesn't require 4 lines: ``` let cons = |a, b| move |f: &amp;Fn(i32, i32) -&gt; i32| f(a,b); let car = |x: &amp;Fn(&amp;Fn(i32, i32) -&gt; i32) -&gt; i32| x(&amp;(|a, _| a)); println!("{:?}", car(&amp;cons(1, 2))); // =&gt; 1 ``` I can easily write the same thing in Ruby in two lines also, but it doesn't make Ruby functional language, does it? I wonder if it's possible to parameterize such thing in Scala, which is considered nearly FP language, I believe it's not easy also as Scala is not HM typed also.
That error was [added to the compiler very recently](https://github.com/rust-lang/rust/pull/54568), so it's possible that it's buggy. 
Use an explicit stack. You have to do that anyway since user data is untrusted.
You could probably do this with a build-script that calls cranelift-faerie at compile time and links the produced object in.
Is there a name for the cute lil owl that shows up in my code sometimes, like `Result&lt;(),()&gt;`
The 's' and 't' were both in the original word so they weren't really changed.
&gt; Regardless of whether this incident had this intent, the cratesio team would like to reiterate that taking actions such as the one we experienced on Tuesday is not an appropriate way nor effective way to contribute to dialogue about crates.io policy. We will be adding a policy making it clear that attempting to disrupt crates.io in order to make or further a point is not approrpriate and will be considered a malicous attack. We will be deciding on the exact wording of this policy in the coming weeks. So what you're saying is that the next mass squatting action is ok as long as it is rate limited and doesn't pretend to be official. :/
Because many traits require implementing methods that take `&amp;self`
Even in FP languages fold et al. are basically a replacement for TCO. I can't think of cases when I desperately need explicit recursion.
Exactly. I've opened a bug about that [https://github.com/SuperTanker/ruplacer/issues/15](https://github.com/SuperTanker/ruplacer/issues/15) but it may takes some time to solve.
It's just "the owl", but if you have an idea for a more appropriate name let us know. :) https://twitter.com/isislovecruft/status/839333846415998976
&gt;This is a nice addition to the Rust command line utility library. Thanks! That's exactly what I was looking for. `fd` and `ripgrep` were indeed a nice source of inspiration ;)
This is a very impressive project! I personally have been thinking about making a emulator and every time I see one implemented it tingles that urge. I think what's stopping me is that I feel like there are so many instructions to handle that it feels a bit overwhelming. I have one tiny tip based on what I saw. In the function `Instr::from`, you have a `panic!("impossible")` which is the final branch to satisfy exhaustiveness, and as writing it will never occur because of `a &amp; 0xF000 &gt;&gt; 12`. There is actually a specific macro for this usecase which panics if evoked, in the same manner, but it is perhaps a bit more idiomatic. See [`unreachable`](https://doc.rust-lang.org/std/macro.unreachable.html). It doesn't add that much value but it's easier to understand straight away that the match arm should be unreachable without looking into the code. 😊
I wonder when next time the moderators will abuse their powers and lock down this thread. I mean, in the previous threads about this that were locked down, has anyone violated the Code of Conduct? If no, then it's clearly abuse of powers which I believe is the case. Either, this locking needs to stop or the Code of Conduct needs to be amended. Right now it's worth nothing if moderators just do whatever they want anyway. This isn't the only incident btw.
Reddit's rules are more than just the code of conduct; that's in fact only one of six rules.
Oh sure; purity will have more and less utility in some applications. The larger the application (in terms of code base size), the more utility it will have. The less FFI an application has, the more utility purity will have. Especially in large algorithmic code bases purity is super useful I think.
It's a part of the interface that can be rejected in the language using static analysis; thus `SafeHaskell` can be 100% pure. Even so, I think refusing to call Haskell a pure language is missing the forest for the trees; it seems unnecessary to blow such a small detail out of proportion when it is 99.999..% pure.
Oh indeed, missed those 5 additional rules applying to reddit. Still, I wonder which of the rules the last thread has violated. There is no rule of the form "little bit of constructive criticism is okay but if a lot of you agree and we don't then we'll lock down the thread".
I'm not a mod, but I think "chill out" likely applies.
Haskell 98 was a pure language. (There are, as far as I know, so maintained implementations.) Haskell 2010 isn't; it specifically allows treating impure foreign functions and pure functions. GHC Haskell, which is what most people seem to mean when they say Haskell (it doesn't actually match any published report) is definitely not a pure (in the absolute sense) language, while it still encourages a pure style,. It's certainly more pure (in the relative sense) than many other languages. I do not think you'll get a 5-nines purity ratio if you go through hackage; I would guess that there's a call to `unsafePerformIO`, `unsafeInterleaveIO`, or something "worse" / less well known every 10k-100k lines of code (not whitespace or comments), so maybe more than 4-nines and less than 5-nines. That not bad; I think `unsafe { }` on crates.io is probably more than that, for example. Heck, the Idris code I've written has way more `assert_total` and `idris_crash` calls. I think it's disingenuous to pretend the impure parts of GHC Haskell (and Haskell 2010) don't exist. They have good reasons for existing!
Github themselves once ran an alternative Ruby gems host like this. It was a terrible mess.
This is a terrible way to frame things. There are an ample amount of people outside the creates Team that support the current policy.
I don't know about on mobile, but the full reddit website has an "Other Discussions" tab up that the top, that is automatically populated when the same link is submitted to multiple subreddits. There's about 4 reddit threads on this topic right now.
There seems to be a current flowing strongly against (even optional) namespaced packages for reasons I can't discern ¯\_(ツ)_/¯ It's bewildering. Hopefully the new communication channels will result in some clarity around this.
&gt; **Motivation** &gt; fn types [need a reform](http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/) The “need a reform” link being a blog post from 2013 puzzles me. 
&gt; Especially in large algorithmic code bases purity is super useful I think. I definitely agree with you there. One area where I anticipate purity being useful once I have time to get it caught up to the various language improvements is my heuristic filename→title guesser. Takes a string slice, returns a string. The closest thing to a side-effect is reading from a few `const` arrays that provide bits of domain knowledge.
This. The fact that \* means very different things in C (make a type a pointer type, dereferencing pointer and multiply) causes a lot of confusion when learning that language.
&gt; Define that the layout of (i8, i8, i16) is the same as (i8, (i8, (i16, ())) FWIW, this is what C++ does (`std::tuple` is defined recursively like this).
&gt; Purity and immutability are the two strongest selling points of FP. Purity / referential transparency has advantages. Immutabilty by default has advantages. Either has much to do with first-class functions. The "Functional" in FP refers to a specific language feature: first-class functions. Lisp, for example allows unchecked mutation and has "functions" that are called only for their (untracked) effects. It is still a functional programming language, in fact it was one of the earlier languages to proudly wear that badge.
No, zooming does not seem to have any effect.
Very thoughtful interface. Looking forward to trying this out next time I need to runame something!
\&gt; But it is important, that every asterisk type parameter is the last type parameter. &amp;#x200B; I think this will make you strictly less powerful than C++. You might be wondering how you could possibly pass multiple variadic lists, but often template parameters are inferred from the types being passed into a function, and those types may both be variadic generics. For example: &amp;#x200B; `template&lt;class... Ts1, class... Ts2&gt;` `void takes_two_arbitrary_tuples(std::tuple&lt;Ts1...&gt; x, std::tuple&lt;Ts2...&gt; y)` `{` `// stuff separately referring to Ts1 and Ts2` `}` &amp;#x200B;
Wow, I did not know this. I can simplify so much code now.
I haven’t heard of any other alternatives, but maybe we can [contribute to the project itself](https://github.com/integer32llc/rust-playground/issues/25)?
Hm. Some digging makes me wonder if it's at all connected to [#54918](https://github.com/rust-lang/rust/issues/54918), which was patched three days ago. I'll update my nightly and see if that helps.
I agree, the same problem of ambiguity arises for the \`..\`-syntax. We'll probably require different syntax. Any suggestions?
I read the summary by @canndrew about this. I thought that you can't reference the tail of a tuple. See the \`Destructuring\`-part. Would you consider this a necessary feature?
You may want to raise this concern directly on the RFC.
You have to parse a library (the binary file) to do that. `.so` are [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) binaries, you could inspect [elfkit](https://github.com/aep/elfkit) or [libelf](https://directory.fsf.org/wiki/Libelf) for example. I don't know much about `.rlib`, such libraries contain compiled Rust code, I think you should ask on \[[http://internals.rust-lang.org/\]](http://internals.rust-lang.org/]) about it or inspect `rustc`'s code generator
I wasn't involved with the last thread, but I'd like to comment with some general insight as someone who has been an /r/rust mod for a few years now. "We" in the following refers to the /r/rust moderation team. * We are a tiny team - currently just 13, compared to the 44k rustaceans that are subscribed (900 of which are online as I type this) * We are a bunch of geographically diverse *volunteers*, who care about Rust and its community * We are not the official moderation team (though there is some overlap) We do our best to moderate per the guidelines set out in [the /r/rust CoC](https://www.reddit.com/r/rust/comments/2rvrzx/our_code_of_conduct_please_read/). This is not always an easy task - particularly in the case of active, heated discussion. I can't speak for other moderators, but I know I have personally failed to follow the procedure properly in the past. If you're a lone moderator in a heated discussion, it can be very difficult to moderate effectively - it takes time to write eloquent, level-headed PMs and comments to steer things in the right direction. Even with the support of the rest of the team - it still takes time to collaborate and decide the right course of action. Sometimes it's easier to wield the moderator hammer and shut the whole thing down. It's a blunt instrument, and everybody hates it, but it's certainly effective. To users, this can often seem like "if you don't agree we'll shut it down". More often than not, a better summary would be: "this is a topic people feel strongly about, and we don't have the capacity to moderate this effectively right now". Again, I was not involved in the specific incident you refer to, so I can't comment as to what happened. I am, however, sorry that you feel our moderation was not effective, and that your views aren't being listened to. You can always reach out to the /r/rust moderation team by sending a PM to us if you have concerns about particular incidents. You can also contact the official moderation team at rust-mods@rust-lang.org if you feel that /r/rust moderation is not up to scratch. We do genuinely care about getting things right, even if it doesn't seem that way.
It is only ambiguous when you are explicitly passing the generic arguments. In the C++ example they are inferred from the function arguments when you call the function and pass in tuples that have already known types.
For some context, that looks copied verbatim from eddyb's post from 2013: https://github.com/rust-lang/rfcs/issues/376
yup, I figured the motivation is still the same, and didn't check the link.
Chip 8 is a great place to start with emulators. It has a small instruction set so easy to get started. 
Would be great. Unfortunately my web-frontend skills are shoddy at best, and as I wrote, my time for Rust is extremely limited. 😒
[jon gjengset] (https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ) makes some great videos where the purpose is to display moderate to advanced usage of Rust in libraries / applications. Highly recommended! 
&gt; "this is a topic people feel strongly about, and we don't have the capacity to moderate this effectively right now". Worth explicitly calling out: Deletion/locking does not mean that everyone there (or even anyone there) violated the rules, it can mean that the thread was problematic or going down that route and it was nipped in the bud.
&gt; sp_executesql Why not open a bug as well as saying this in reddit? https://github.com/steffengy/tiberius/issues
\`...\` is the obvious one, but given that you're using that elsewhere, I assume there's a technical reason it can't be used there (ambiguity?). &amp;#x200B; Other than that, I think something like \`\^T\` or \`+T\` might work, assuming no other ambiguities.
You need to include wasmi as well to actually run them, but this can work, yeah.
The rationale for not using namespaces is laid out in great detail [here](https://internals.rust-lang.org/t/crates-io-package-policies/1041). Honestly, I find their logic compelling, and am fine with a no namespace system.
+1 for `unreachable!`. I believe at one point it was actually used by the compiler to help "optimize-away" cases that the user knows can't happen, but that may have been generalized for anything that returns `!`.
That sounds interesting! Do you have any examples or ideas of how that was done? 
My bad, I gave some wrong information in the original comment. It's unsafe to assume that a branch will never be reached, so the macro can't handle that, but there is an unsafe function that can be called that triggers the optimization. Original comment updated.
 &gt; I believe at one point it was actually used by the compiler to help "optimize-away" cases that the developer knows can't happen. I believe that is [unreachable_unchecked](https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html), which is not to be confused with the `unreachable!` macro.
Could you elaborate on why this feature is necessary?
Are you compiling in release mode?
I can only imagine what the deleted subthread was, but this comment is exactly right. The current policy is malicious compliance bait. I just don’t understand the vehemence of the single-namespace advocates. It’s like walking in the street when there’s a really nice sidewalk right. over. there. Sure, the cars shouldn’t run you over and it’s usually fine. But why take the completely pointless risk?
I have a wasm-to-rust compiler: https://github.com/CryZe/wasm-to-rust It spits out a rust file with a trait that you need to implement providing all the imports. The only real issues is that the code generated often takes rustc like 20 minutes to compile (for no real reason).
CHIP-8 is a great system to write a first emulator. I once wrote one in Elm, but ran into trouble with loading ROMs. I also have an interest in static recompilation. My 2 main candidates for that would be CHIP-8, for which I get intimidated by graphics, and PEP-8, which is a virtual machine that was used in one of my computer science classes, but is notoriously hard to find resources for.
I did initially but found that it caused a lot of repetition in the text that you just don't get when using YAML. Also, as an FYI, using config-rs means I can just arbitrarily switch between supported config formats which is nice!
Agreed. Before they added category tags to published crates, it was pretty much impossible to find anything if you weren't religiously following reddit/user-rustlang/HN/etc because the colorful names that they see as a feature makes it hard to know what to search for if you don't know the name ahead of time. Like, how is anyone new to the Rust ecosystem going to know that "nom" is a byte parser, or "tokio" is a library for building asynchronous applications?
As I said I'm building it to learn rust, whilst I'm not going to build ALL of it from scratch I am building the ECS. that said It wouldn't solve the problem that I'd still have to figure out a way to transform the text of the template into a resulting type. Also, I already have component storage solved and I'm already using [typemap](https://github.com/reem/rust-typemap) to hold onto each component store, with each store only holding components of one type; the key is the entity ID and the value is the component struct so you end up with a structure like `typemap&lt;ComponentID&lt;Component&gt;, Store&lt;Component&gt;&gt;`
Oh man, the change is [so silly](https://github.com/rust-lang/rust/pull/55128/files). That's wonderful.
By Haskell I do mean GHC Haskell; Not Haskell 2010 or 98. In practice, this is the only Haskell that matters. Tho, eta-lang and such things are interesting. I'm not going to debate whether it is 4-nines, or 5-nines :) It's still a lot of nines. =P My main point is that using `unsafePerformIO` in an impure way is undefined behavior, just as it would be to use `unsafe { .. }` in a way that violates rules around mutable aliasing. While there may be packages or crates that do violate this, it doesn't mean that Haskell is impure or that Rust has mutable aliasing. There are type system invariants, and there are escape hatches out of those. I also agree that usage of `unsafePerformIO` is likely much smaller in Haskell than `unsafe { .. }` is in Rust. All in all, I think it is correct to say that Rust is a language without mutable aliasing and that Haskell is a pure functional language.
Fist question: you are using `—release` right?
I believe [SIMDeez](https://crates.io/crates/simdeez) crate features runtime detection. This is not mentioned in the post, so not sure if the author is aware of it.
When you compile Rust for windows it generates a pdb file just like it does for C/C++, so even though it doesn't work perfectly, you can debug your application by changing the project's settings (change Debugging -&gt; Command to your executable path).
Yeah no; I don't agree and we are unlikely to get any further here. Also; Sam Harris is not a person I respect, and the idea that we should never tell white lies baffles me. If you were describing Haskell and Rust to a beginner in an introductory course, would you say "Haskell is pure except for this &lt;insert&gt; detail"? I would not. The language is used as a pure one, and every realistic language has escape hatches.
I'd be very interested in your thoughts on my crate SIMDeez: [https://github.com/jackmott/simdeez](https://github.com/jackmott/simdeez) &amp;#x200B; &amp;#x200B; &amp;#x200B;
C++ version is bool Sphere::hit(const Ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const { Vec3 oc = r.origin() - center; float a = dot(r.direction(), r.direction()); float b = dot(oc, r.direction()); float c = dot(oc, oc) - radius * radius; rec.mat_ptr = mat_ptr; float discriminant = b * b - a * c; if (discriminant &gt; 0) { float temp = (-b - sqrt(b * b - a * c)) / a; if (temp &lt; t_max &amp;&amp; temp &gt; t_min) { rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center) / radius; return true; } temp = (-b + sqrt(b*b - a * c)) / a; if (temp &lt; t_max &amp;&amp; temp &gt; t_min) { rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center) / radius; return true; } } return false; } Rust version is: fn hit(&amp;self, ray: &amp;Ray, t_min: f32, t_max: f32, record: &amp;mut HitRecord) -&gt; bool { let oc = ray.get_origin() - self.center; let a = ray.direction.dot(&amp;ray.direction); let b = oc.dot(&amp;ray.direction); let c = oc.dot(&amp;oc) - self.radius * self.radius; record.material = self.material_id; let d = (b * b - a * c).sqrt(); let temp = (-b - d) / a; if d &gt; 0.0 &amp;&amp; temp &lt; t_max &amp;&amp; temp &gt; t_min { record.t = temp; record.position = ray.point_at_paramater(record.t); record.normal = (record.position - self.center) / self.radius; return true; } let temp = (-b + d) / a; if d &gt; 0.0 &amp;&amp; temp &lt; t_max &amp;&amp; temp &gt; t_min { record.t = temp; record.position = ray.point_at_paramater(record.t); record.normal = (record.position - self.center) / self.radius; return true; } return false; } One obvious difference is that in the Rust version, you are always computing sqrt() of the discriminant, whereas the C++ version first checks if the discriminant is positive before calling sqrt().
Maybe it would be better to introduce a pair of keywords. Something like `pack` and `unpack`. let a = (2, 3, 4); let b = (1, unpack a); // instead of (1, ..a); let (first, pack rest) = b; // instead of (first, ..rest) // in pattern maching the keywords are swapped // not sure if this is a good idea though fn foo&lt;T, pack U&gt;() {} // instead of fn foo&lt;T, *U&gt;() {} This is a bit longer but I think it's more readable this way. Also, while `..` is similar to `...` from C++ and can be kinda intuitive (this one thing is actually a list of things), the asterisk IMO does't really make a lot of sense in this context. The other places where it's used in rust is dereferencing and multiplication. And rust is arguably already too punctuation heavy.
gather is part of AVX, there are still lots of cpus out there without it, but I think all the i3/5/7/9 cpus being sold now have it. The performance is not great on most (all?) cpus though. &amp;#x200B; If you are asking about SIMDifying things like 4d vector libaries? That can work well for some operations like add but then gets messy/slow for other operations (like normalize for instance) &amp;#x200B;
Right, somehow I missed this in my searching, obviously I wasn't too thorough. I think yours is a very practical approach to reduce code duplication, but I'm trying to do some things SIMDeez does not: I automatically generate the runtime-detection shim, and, perhaps most significantly, users of fearless_simd don't have to include any architecture-specific or unsafe code at all. So, among other things, when arm simd lands in stable, code should just work. Obviously you're a lot more complete in supported types and operations, I've mostly been sketching out what I need. If somebody puts together a more comprehensive approach combining the two, I think they can borrow heavily. Regarding rounding, this is complicated! Your round operation has different tiebreaking semantics than `f32::round`, which I think is fine but needs to be documented. The `roundps` instruction has been around since SSE4 (about 10 years), so I haven't decided I'm going to do any SSE level below that (other than scalar fallback). But that looks like a useful technique if the int size limitation is ok (it certainly is for my sinewave example) and SSE2 is targeted.
Thanks for catching this!
Just described my idea in [this](https://www.reddit.com/r/rust/comments/9pj79j/variadic_generics_prerfc/e82z4jz/) message
Yes I've been thinking about whether I can reduce the need for the user to do any runtime detection on their own, maybe with a macro or something. I'll need to study your code and see if I can borrow some ideas. I'm not sure if I want to try to expose a safe interface, so often in SIMD code you will do innately unsafe things like reinterpret casts and so on. Note there is a fastround (int limitation) and another round without. 
Updated the original comment, thanks!
Ah yes, your SSE2 round is good stuff, I might have to adapt that (with your permission) if I do decide to target SSE2. A few days ago, I started going down the path of macros but wanted to see how far I could get without them, just using traits. Definitely feel free to adapt the ideas if you find them useful. There's nothing about my runner idea that requires using the highest detected level (and I touch on this in my blog post). There absolutely can (and probably should) be an additional preferences enum which is checked along with runtime feature detection.
I am not a member of the crates.io team, but I believe I understand some of their reasoning: * Changing the crates.io technology (adding namespaces or WHATEVER) would take a large amount of time and effort and change bloody everything in the current Rust ecosystem, one way or another. They have shit to do, they don't get paid for this as far as I'm aware, and everyone and their dog is going to have an Opinion about how to do it best anyway. * Changing the crates.io policy would increase maintenance burden and it seems likely to just lead to more sophisticated dodges by abusers. They have shit to do, they don't get paid for this as far as I'm aware, and they don't want to participate in an arms race against spammers. I also generally *agree* with their reasoning, and find it *usually* not an actually big problem *so far*. Single namespaces don't bother me; `pip` and `opam` and other languages mostly get on just fine without them. This case got special attention partially because it looked like it was pretending to be an official maintainer action, which is just abusive no matter what. That said, the current crates.io policy leads to a Prisoner's Dilemma situation: Even if your goal is not to be abusive, if you squat names, you are more likely to get the names you want. If you take names as you need them, someone else may be squatting it, and not respond to emails (I'm looking at you, [M Farkas-Dyck](https://crates.io/users/strake). So the OBVIOUS best move is to squat every even mildly interesting crate name possible as soon as you can, just out of sheer self-defense. At some instinctive level we realize this, and apparently absolutely hate it, and so people get really worked up. The obvious technical solution is namespaces, but that has a distinctly real cost to it as well; see the [original squatting policy](https://internals.rust-lang.org/t/crates-io-package-policies/1041) for an overview, and even then someone has to implement the damn thing and make sure it doesn't break literally everything in the process. The obvious social solution is to have an abuse/revocation policy, but constructing and maintaining such a thing is *hard work* to do well, and if not done well it just becomes a venue for abuse anyway. So that's why we are in the place we are today. What can we do? * Nothing. Life doesn't get better, it slowly gets worse as the namespace fills up, but by the time all the *really* interesting crate names are taken we probably won't be writing Rust anymore. * Do something to lower the social cost for managing name squatting: Volunteer to help moderate/adjudicate crates.io more. Have a community exchange for crates where I can say `WTB chromatic` and someone else can say `WTS chromatic` and it gets handled without needing to deal with it personally. Come up with a better squatting policy that isn't subject to abuse, convince the crates.io team that it's a good idea via an RFC or other community interaction processes (instead of random flame wars every time some new abuse makes the news), and help implement and enforce it. * Do something to lower the technical cost of changing crates.io: Fork the damn software, add namespaces or whatever, and stick up an alternative site. You can have it automatically mirror crates.io in a namespace of its own, you might be able to name-mangle crates in an easy way that makes it possible for crates.io to host your namespaced crates or something, and get people to use it. Having alternative crate registries is a very desirable feature anyway, heterogeneity in an ecosystem is good, and I've more than once considered the idea of a site other than crates.io that can do nifty things like offer better recommendation algorithms or such without risking breaking the entire universe in the process. Like Mark Twain said... "Everyone talks about the weather, nobody does anything about it".
Great post! I'm super excited to see where the Rust SIMD ecosystem goes. :-) Getting valuable experience like this is a really important step!
I think that insisting on at most one variadic parameter should be enough to avoid ambiguity in arity resolution. 
But I don't think saying "Haskell is a pure functional language" is a lie. You might think so, but it is an accurate description to me. To say that it is "mostly pure" seems instead grossly misleading given how Haskell is actually used. Talking about guarantees of System F / Fω / FC seems like a supremely bad idea to folks who haven't done any functional programming before; that's a great way to scare them off. Also remember that such an intro course to FP is not a course on PLT where you learn type theory. I think you only have so much time, so talking about `unsafePerformIO` at all is a waste of time. You shouldn't even get to that before discussing GADTs, Monad transformers, and such things, in my opinion.
And, importantly, the cited single namespace example of NPM actually [bothers to forbid squatting](https://www.npmjs.com/policies/disputes) Single namespaces work just fine, if you don't allow people to take every relevant name at the start and never use them. Conveniently people usually fail to mention that when pointing at NPM. I wonder why. I looked at RubyGems but it seems a lot less defined in general. They don't seem to have a TOS or policy at all, it's an [open issue?](https://github.com/rubygems/rubygems.org/issues/1336). Though i did find precedent for staff mitigation on squatting, but most of it was from like 2013, and some recent but resolved between the owners. Not sure what rubygems is doing here. Considering the lack of policy on anything, not sure they're a good example to point to for cargo.
Thank you
did you get any performance fixing this?
Works for me in Nightly/Linux. Can you try in a new profile?
What I'm trying to do is something this (pseudo code): component: name initial_value: bob which turns into: //component is a generic name that references a component called Name //initial_value has the value from initial_value in the data //the value is passed to the constructor of Component which //does something with the data and then stores it in value and //returns the initialized component component = Component::new(initial_value) // value returns the value "bob" component.value // Component then gets stored into an appropriate storage, with the entity ID acting as the key storage.insert(entity_id, component) 
I want to create a Hashmap lookup table that is, more or less a const static global variable. Is there a way to do this? https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f5db537639c0826cd92c9e6d7a8c4e66 The compiler suggests possibly using const fn. How would that result in an elegant solution? Perhaps a const fn that generates a hashmap at compile time and returns a reference to this singleton? That sounds ugly (and probably wrong). Help please! 
Single-namespace isn't terrible as long as it's properly policed. If they were willing to actually ban these accounts and revoke package names for clear cases of squatting, this wouldn't be a problem. Maybe this suggestion is a bit too authoritarian, but personally, I'd say that if you don't do anything with a name for 6 months, they should start sending automated weekly emails warning that if it remains unused and they can prove that they own the name in some other respect (i.e. let's say that KitWare want to reserve the name "cmake" so that it can't be used by impersonators), it will be revoked after 3 months have passed.
The converse argument to the last point is "oh, no one uses `the-great-quux/i2c`, use `fratley77/i2c`". It's exactly the same. In reality the search and quality metrics (downloads, dependent crates, whatever) in the package repository are far more important.
In C++ you use float arrays and index with [], not at(). In Rust you use vec and every access to their contents are by [] and no iterator. A guess could be that every single access is getting bounds-checked. Perhaps change your Vec3 to use x, y and z fields? Not a fun change to make, sorry.
I wonder if I'm missing something here. I have no horse in the namespacing race. All I really want(ed?) from the Crates team is to explicitly say "if you are an obvious name squatter we will revoke those names and maybe ban you". Why's that hard? The original policy says "finding good rules that define squatting that can be applied mechanically is notoriously difficult", but... why do we need that? This is why we have Real Human Persons. As long as they're reasonably conservative in their judgements, I see no reason we can't rely on the manual intervention of the people with the power. Maybe I'm naive but "bad mistakes and regular controversies" seems a lot less like an actual problem than name squatting (which I've seen several people suggest isn't a real problem). Is this the fear of "controversies", a lack of resources, or just the programmer mindset gone awry? Or am I missing something else?
The search of docs.rs is actually waaay better than the one from crates.io I personally only use crates.io to see the populariry (number of downloads) and with crates.rs it looks like I can switch completely off it for discovery.
Yeah, I've had this confound some comparison results before. Definitely give this a shot. Alternatively, like u/OldShoe mentions, you can use an std::vector in C++ and use the bounds-checked accessor there instead of converting the Rust code. 
Thanks for the great response. That clears it up. It's not super clear to me when the lifetime is established— is it once when the variable is created? I think I was under the impression that by using static it would just lengthen the lifetime of reference. So basically I thought if a variable has a short lifetime, if I pass that reference to something that is expecting a static lifetime, it would just 'coerce' it to be static. I guess I don't quite understand why if I have a variable, say \`&amp;'a str\` why I can't just copy that into a variable \`&amp;'static str\` and let it live on. It definitely makes sense to use pass \`ArgMatches\` as a reference in this function. I am used to c++, where you wouldn't really tend to pass a pointer or reference unless you wanted to modify the original object. But now I see with rust, you just 'lend' the variable to be used in the function, then it returns ownership original scope. I guess you would pass full ownership (a non-reference?) of the variable if you did not plan on using it outside the function. Thanks again!
global mutable data is indeed considered unidiomatic most of the time, but `lazy_static` is the standard answer to your question for when it's needed.
\&gt; practically does not work at all (on Chrome/Android) &amp;#x200B; Can you provide more specifics? I know that multiple people have used the playground on mobile devices reasonably well. It works OK in Firefox 62.0.3 on a Pixel running Android 9, for example. One thing you can do is to \[disable the advanced editor\]([https://i.imgur.com/yCtV3Mq.png](https://i.imgur.com/yCtV3Mq.png)) in the config menu. This turns off syntax highlighting and a few other features, but you just get a browser-native textbox, which should work in almost any context.
During compilation or setup, I wan't to run some benchmarks to know the data threshold at which I should enable parallelism in certain functions. What is the best way to do that? I was thinking that I could copy the functions into a `build.rs` as part of the build scripts and have the build scripts spit thresholds into a file that I could read in during compilation. But that leaves the potential for the functions to get out of sync between the build scripts and the main crate. Thoughts?
What you ended up with is an ecosystem in which there were often 5 different versions of the same gem under different namespaces - often diverging. People would still colloquially talk about "are you using act-as-paginate?" "yes!", not getting that they were talking about two very different products. In any case, GH has shut down that host at some point and rubygems.org got improved on many levels.
This doesn't explain the 5x difference you're seeing, but it looks like you're computing 20% more pixels for the rust version as compared to the c++ version ([height=288](https://github.com/TuckerBMorgan/Mars/blob/master/src/main.rs#L32) vs [height=240](https://github.com/TuckerBMorgan/CudaTetris/blob/6d6126507dfb6857c12c12973a297fba38a9192d/cudatetris/BackBufferController.h#L30)):
Great article. The 3 laws are such a good way to explain what you would want from a programming language. 
Nice, I made a similar one, here: https://github.com/GrayJack/algos
Hmm, there's a game called rust, and there's a coding language called rust. You're in the coding language rust sub Reddit 😂 not sure if the game has a sub-reddit, but it sounds like you might have more luck there! :)
&gt; If you are asking about SIMDifying things like 4d vector libaries? yeah a cg math 3 or 4d vector. w passed around usually as 1 or 0. Allows aligned 128bit transfers for vector types. Some platforms were built for it and had had 4d dot product or component broadcast multiplies (eg acc+=src1.xyzw*src2.yyyy), and the gpu's used to work like that too. But a safe way to work on them is to cluster dot products done 4 at a time wherever possible whilst it seemingly went out of fashion in favour of wider SoA, I wonder about the new nvidia 4x4 tensor cores .. and ask what if the world had stuck with the 4D idea as a balance between scalar code and big matrix code (imagine a chip with 64bit registers useable for 8x8, 4xf16 or 2xf32 or 1xDouble , as a balance for AI (8,16bit), game code (3d f32 vectors taking 2), pixel blending (16bit), scientific code (doubles getting a whole reg with no packing) 
Thank you! Lol
To paraphrase an old teacher, that second suggestion is like saying that to make this Rust program run like the C++ version, we should tie C++'s shoelaces together. :p
Yes, his streams are great.
One question: Did you not read through this sub before posting this? This is the wrong subreddit and it is getting really annoying because this happens all the time. Where did you post this from? Did you go onto this subreddit and then click "submit a text post". Or did you do this from your Reddit Startpage and just assume that /r/rust must be the correct sub for your game?
I am using the nalgerbra library, I was hoping to avoid having to write my own Vec class, also where are you seeing me use \[\] when indexing into Vec\[\]? Is it the buffer\[index\]?
For anyone who cares, a Linux `perf` report for the top 20ish functions is here: https://gist.github.com/icefoxen/0428a5193630d6d7816721269a1e9307 Data collected with just `perf record` running the program for a couple hundred frames, and analyzed with `perf report`. The program was built in debug mode but with `opt-level=3`. 
cargo build --release, and simply setting the compile mode in Visual Studio to the release target, which I am making an assumption that it works in a similar fashion to cargo release. 
Yes to what?
Simple syntax thing that I cannot figure out: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=4e2f42358923e8a3eeb6f8ee52a2fe84 Where can I find the relevant docs for this type of pattern matching? 
You could just cache your target folder.
Your Scala counterexample is good. Purity is closely related to context and dependencies, and since all Scala functions run within a class, and classes can have mutable context, it easy for impurity to creep in. Rust has a good case on how mutability can be done in a "pure" way, by being explicit on what is and what is not mutable, and by using ownership to create an explicit flow throughout the entire program execution. I don't have the experience with it to tell if the rest of the feature set helps the programmer to maintain purity in some parts of the code, but it surely looks promising! 
By glob import you mean `use super::*`? It imports private things from the parent module in the typical case when the test module is inside the production code module. Would it not work if rather than typing the test code inside the production code module you used `mod tests` in the production code module? 
Thank you! I thought that maybe using the library was screwing me up, looks I am going to have to sit down a write my own Vec3 lib.
You need to set the cargo home to .cargo (relative to the build directory), then you can cache that. For example: https://gitlab.com/inko-lang/inko/blob/f39ce802c871e97bb3bbf7f709c856124896e56c/.gitlab-ci.yml#L4 
I would use [struct update syntax](https://doc.rust-lang.org/book/second-edition/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax) ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=5d61bc127b60dbd20fb546ef3967e41d)).
After seeing your comment about euclid I am in the process of switching to that. 
Also npm has namespaces now. 
I'm not arguing for namespaces. I'm arguing for not writing off the consumption of simple names as a feature
A community-run alternate registry that implements namespacing in a backwards-compatible way is probably the right way to do it. Proposing a namespacing or squatting policy to the maintainers, no matter how well thought out, is a dead end because they've said many times they won't consider it at all.
I still miss the GitHub gem host. My take on it is about as polar opposite as you can get. I can't recall a single situation where a colleague and I had a whole conversation about two different gems with the same name. Instead, the ecosystem was much more vibrant. People didn't feel this huge stigma about publishing a gem. And at the time, Bundler didn't exist, so if you wanted to share code you couldn't just point at a git repo -- you had to vendor it in your source tree. &amp;#x200B; Setting aside our differences in interpretation, I'm legitimately curious how this is any different than when a fork becomes more popular than the original. Particularly when the original gets to sit on a gem name that's essentially abandoned. That is a situation where I have seen someone install the "wrong" gem in several instances. Granted, I don't think namespacing fixes that issue, other than by not allowing any one user to have the authoritative name.
Probably. I looked at it once and had a general idea, but that was over 2 years ago. The trickiest bit is that you need to add support for the length of a variable length field. 
Hm, I'm not sure if what you want to do is possible in Rust. Maybe someone else can chime in, but I think the only way is to destructure the tuple and assign the fields manually ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=87d198a75ece54db23689d44b8a27e52)).
I think the difference is someone isn't sitting on the "i2c" name in your example. I think many people assume the simpler name is the authoritative one and it becomes the default. And it'll probably rank very highly in whatever search algorithm you use.
It's unfortunately not possible to assign to a tuple of fields like this. The syntax does not exist in rust - manually assigning each field is the only option. It's possible to destruct a structure into multiple new variables, but not to destruct-assign the values into existing places.
If I were to use your API I think I'd prefer an explicit setup function to be called at runtime with some sane defaults. Numbers in the build script mean nothing because that's compiled and run on the host machine; what happens when the user is cross-compiling or just compiling the binary on one machine but running on another?
If you'll pardon the dumb question ... If you prefer Rust over Java today, then why did you choose Java over OCaml ten years ago? ^(I ask because, AFAICT ... the latter's weaknesses in comparison to Rust, are wholly performance-/efficiency-related, and Java has very similar kinds of performance drawbacks; yet, Java also lacks in the FP-esque maintainability+correctness benefits that Rust and OCaml share.)
Remember that those ways to construct Haskell expressions that are not referentially transparent are undefined behavior because the operational semantics AFAIK assume purity. If you think this means that Haskell is not pure, then Agda and Coq are not total and are inconsistent as logics. The problem with saying "Haskell is mostly a pure language" is 1) that it is highly misleading; given the description above about UB and how little that actual UB would arise, "mostly" feels like saying "85%" -- for Haskell to be "impure", not only do you have to use `unsafePerformIO`, but use it incorrectly; 2) you then also have to make statements: "Rust is mostly free from data races", "Rust mostly prevents mutable aliasing", "Agda and Coq are mostly consistent as logics". This becomes supremely unhelpful because someone might also say "OCaml is mostly pure" and it's not comparable.
That’s awesome! I’ve always thinking of using wasm in browser extensions and you made it. By the way, would there be a Firefox addon in the future?
&gt; (say someone reported the winapi-* crates for example) Wouldn't a real human look at that, go "oh, okay, I get it", and then just move on? This is basically my point - I don't think the "inevitable gray area" is actually that large, and I think we do have enough room in the crate namespace to err on the side of not removing anything questionable.
Wow. Even better. Scoped packages? Been in npm for 3 or so years now? How convenient that it's never brought up that rusts primary argument that single namespace is ok has long realized single namespaces are ***not*** ok. 
&gt; operational semantics AFAIK assume purity. No, they don't. Imprecise exceptions are impure as well. And some things like unsafeInterleaveIO actually have specific guarantees if used right, we just can't get the compiler to check if you've used it right. Finally, I'm not 100% sure we have a formal operational semantics... the report mainly focuses on denotational semantics. I'm fine with giving specific caveats, I think that's better than misrepresenting reality. I'm also find with comparing the qualities of specific languages. I don't actually know much about any Coq infelicities, but I'm generally careful to call out postulates in Agda, potential issues with axiom K (which is still on by default), etc. and much more rich sets of problems in Idris. I'm really not convinced it's helpful to pretend these things are their ideal. Letting people know where the "sharp edges" are actually helps them avoid them rather than stumble into them, which I think actually make it easier to promote pure code. It's a nice shorthand, but you seem averse to actually going into the details!
I believe the issue is that `load_texture` is returning a texture with a lifetime of only as long as the Result which gets dropped after the match. Therefore it can't get inserted into the HashMap because that would require it's lifetime to exceed the match statement. 
It's not large, but it is inevitable, and people differ so there will be differences of opinion. Should the main architect of tokio reserve plausible sounding tokio-xyz names?
I'm not confused, you've just misread my comments twice. :) I explicitly said they can be different types. &amp;#x200B; I'm not really a huge fan of your example though, because \`let Fido = Dog { ... }\` and \`let Spot = Dog { ... }\` typecheck and still swap pets. You'd need \`impl Pet\` to go from a dog to an iguana, but at that point I just question what kind of establishment you're running.
There are actual arguments against having mandatory namespaces, it's not just "eh why bother". It's more like "it doesn't solve the problem" (in their opinion). This has been discussed to death a billion times on internals at this point, go take a look.
r/playrust
Are "lto = true" and "lto = fat" the same thing? You want "fat" for sure.
Where is the newline in your write...?
This post (I'm not the author), [Even faster rust builds in Gitlab CI](https://vadosware.io/post/even-faster-rust-builds-in-gitlab-ci/), contains a section on caching that might be helpful.
 [r/playrust](https://www.reddit.com/r/playrust)
/r/playrust
I’ve used the packed_simd crate and rayon for this. It worked Better than I expected but it’s not as good as ISPC. The ispc_rs crate let’s you easily use ISPC kernels from Rust, which also worked better than I expected, but I preferred a Rust only approach.
It's brought up every single time. Python also rather suffers under the lack of namespaces. It's fairly evident that the debate is not really rational. Apparently it's just more important to pretend 14 variations of "oxidised ferrum" is creative.
Lots of npm packages will start appearing as WASM modules in coming years. That would explode the libraries available to rust if they were easily consumable.
What does the rust code look like? Rustc is known to perform poorly on large match statements, enums, etc 
Note that `nalgebra` will be as fast as `euclid` when LTO (link-time optimization) is enabled. You simply need to add the following to your `Cargo.toml`: ``` [profile.release] lto = true codegen-units = 1 ``` And run a `cargo clean` before rebuilding once those configurations are added.
There is a problem with Firefox where the WASM-module fails to load; it works on Firefox for MacOS yet fails on Linux. I'll need to figure that out and create a package for AMO. You can always go ahead, build the extension yourself and load it from "about:debugging" locally. It will persist through sessions.
I mean, it's not like mandatory namespaces are the only solution here. You've also got optional namespaces like NPM has, which provide a lot of support to individuals who want to reserve group prefixes (`@tokio/*`, etc), mandatory namespaces with GitHub-style organisations, or even just a new policy that actively opposes squatting, as opposed to effectively just condoning it unless it actively damages the Crates "brand" (as in this case). To be quite honest, the most irritating thing about this whole situation is the complete lack of communication, movement, or recognition of the problem. It feels like a decision has been made from on-high, and no questioning of the decision will every be accepted. There doesn't seem to be much else in the Rust ecosystem that works like this - almost everything else is subject to community discussion and criticism, and people are actively encouraged to take part in discussions about the future of the language and its tooling. All except for the squatting/namespacing policy, which is apparently now unchangeable and undiscussable.
No problem! Thanks for the help! It's working now.
The Three Laws really remind me of a past work life where I got tasked to spend a bunch of time educating coworkers on the six ISO 9126 Software Quality Characteristics: http://www.sqa.net/iso9126.html. Kinda drab, but actually pretty relevant IMO.
&gt; also where are you seeing me use [] when indexing into Vec[]? Is it the buffer[index]? Sorry, I misread your code.
Ha, right! I reset the profile (I don't have a lot of config, I simply invested like 10 Minutes), and everything's ok now. Thanks!
Uh-oh, fonts are hard. I investigated as far as I could, it was indeed using a non-monospace font, but one I had not configured to be used, and no config within firefox changed anything about it. &amp;#x200B; Fortunately, someone suggested a new profile, and so I just went with that and everything's in the clear now. Thank you!
In [sozu](https://github.com/sozu-proxy/sozu), we use unix sockets to communicate with child processes (and also to talk to sozu's configuration interface). Unix sockets can integrate well with mio based event loops or tokio.
&gt; but neither address the problem of runtime selection of SIMD capability level. FWIW in `packed_simd` (`std::simd`) at least this is by _design_. `std::arch` provides run-time feature detection primitives, and `std::simd` provides compile-time portable packed SIMD functionality. Combining both one can design many APIs that use run-time feature detection to select which code gets executed, but since there are many trade-offs at play, that's something that should be done on top of these libraries.
Did you see how the rust standard/core library display this little blue message that is related to a feature attribute ? https://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html
 Here are a few differences between ruplacer and good old find+sed: * As far as I know, there is no easy way to implement the '--subvert' feature with sed * ruplacer has pretty colors and dry-run mode. You may argue you can just run sed followed by `diff` or `git diff` to inspect the changes to achieve the same result. * Command line syntax is easy to remember and works everywhere (sed may behave differently depending on the operating system you use) I happen to think those are valid reasons for trying out ruplacer. But it's fine if you don't want to use it ;) PS: I'm not sure about performance. All I can say is that ruplacer feels "fast enough", but I was already thinking that back when it was written in Python. Maybe I should measure it some day ...
Thanks so much for this recommendation. I am kind of over the most basic introdructions to Rust and struggling to find some intermediate/advanced content for learning Rust. His channel provides exactly that and he manages to explain everything in a very detailled yet simple way. Two thumbs up!
It's not a dumb question. :) I was programming in OCaml when I was a student. Many of my professors were very involved with OCaml (ex-Crystal team at INRIA). I liked it very much as a language, but the ecosystem sucked. The community was small -- mostly the language research community. I switched to Scala then, because it was very similar to OCaml but with access to the Java ecosystem. I took a job where I could do some Scala (but it was mainly Java). However Scala had a lot of implicit cost and made it difficult to understand the runtime characteristics of the JVM, and among other things that led me to focus on Java. Java is lousy as a language, but the tooling, the community and the ecosystem make up for it to some extent. Also, there's no shortage of Java jobs. Back to OCaml, things have improved in the recent years and another valid question would be to wonder why I didn't switch back then. The answer is that I am not satisfied anymore with working in an environment I don't fully master (runtime, compiler, libs, etc) and jumping ships from Java means a lot of extra work for me. OCaml has changed in 12 years, the ecosystem has changed, etc. I need to be convinced the time I will put into it will be well spent. So it's about betting on the right horse. No horse seemed worthy of my money until Rust showed up, and it's not only the language (which is excellent), but the energy and the dynamics at play in the community. I have not seen any language move that fast between the times I had looks at it. I looked at Rust around 2012, when it still had a GC (and did not find it very appealing), at Rust 1.0 in 2015 where things were starting to look good, but there was no non-blocking ecosystem (I was doing a lot of network heavy stuff / distributed systems), and now in 2018, and I'm fascinated by how much got done. 
Personally I find 1. controversial, as I rarely need to change all possible casing, and when this is the case then `sed 's/foo_bar/baz_quux/g; s/FooBar/BazQuux/g; s/FOO_BAR/BAZ_QUUX/g'`. About 2.: yes you can, and this is pretty simple TBH: `diff file &lt;(sed 's/foo_bar/baz_quux/g' file)` in Bash/ZSH (`psub` is needed in Fish). This is more or less true, but (as always, there is but) there is standard that when you keep to it and it doesn't work, then it it problem with implementation, not your script. So good for you, interesting project, however I do not think it will find it's place in my workflow (like `fd` didn't as it didn't provide any value over `rg --files`). The same goes for `bat`. For now I use only `tokei`, `rg` and `concurr` from time to time.
Thanks! \`unreachable!()\` is exactly what I was looking for.
Oh god, I’ve looked plenty. I think the arguments against namespaces are either specious or outright disingenuous. I frankly think it’s a weird turf/power issue at this point. I’m sure that suggestion will be well received.
So I did a quick and dirty performance test, using the [kakoune](https://github.com/mawww) git repository, and replacing 'old' by 'new'. Using `fd --type f --exec sed ...` is really slow compared to replacer, because you'll fork a new process for each file. If you avoid forking a new process for each file by running `git ls-files | xargs sed` or even `sed -i 's/old/new' **/*(.)` (the zsh syntax to recursively find all files in the working directory), then ruplacer is about as fast. 
Yeah, `must_use` is a pretty big advantage. I reply to you *now* because I just learned that the part `&lt;(),()&gt;` [has been titled _(cute) owl_](https://www.reddit.com/r/rust/comments/9oa2zs/hey_rustaceans_got_an_easy_question_ask_here/e82emkw/). Fitting, right? It's not as uncommon as I first thought it to be.
Why not use a git repo local to the server?
If you replace reddit.com with removeddit.com in the url for this page, you can read them.
I really don't see how optional namespaces is a huge feature. It basically just involves allowing slashes in crate names, that's it. The actual namespacing is purely on the side of the registry host (crates.io). Cargo doesn't need to know the namespacing rules.
For 8 bytes, you don't need SIMD, as `u64` compare will suffice (be careful with alignment, though!).
I read them, but I'm still not convinced that this is necessary. Can you hand me a link to a full explanation, or name a function I am not able to implement without this?
Wow. That's awesome.
&gt; All except for the squatting/namespacing policy, which is apparently now unchangeable and undiscussable. Again, nobody is saying that it's not discussable. Nobody has also said that it's not changeable. What *hasn't* happened is that nobody who wants these features has even made a formal proposal. The teams don't change policies based on what happens on internals. Policies require RFCs. And part of why *this* is is because there are so many details, so many options. That's why there's so much discussion. The team not weighing in isn't due to some sort of total ignorance of the issue, it's that the team weighs in on proposals. 
This is for SDL2, right? I've dealt with this too. Here's my implementation of texture manager: https://github.com/sunjay/robo-quest/blob/master/src/texture_manager.rs Feel free to use any or all of the code. You can see how I use it here: https://github.com/sunjay/robo-quest/blob/9a1ddebc9deb3295d51479a4abecaa3deed08d14/src/main.rs#L69-L70 I have to be really careful to make sure the lifetime of that variable is as long as possible so I create it very early. 
Nice! I'll be sure to use this!
It‘s just a bunch of local variables (ints, floats), ifs, loops, and very low level mathematical operations. Very rarely there‘s a match (on integers) sprinkled in.
thanks, done. :)
There is a typo: "langauges"
/r/playrust
Nice work! Looks like an interesting project, might take a try at it myself. Did you have low-level any experience creating this? Any resources you found useful? 
Expand the "Trait implementations" section and you'll see `read_line` is part of `impl&lt;R: Read&gt; BufRead for BufReader&lt;R&gt;`.
What is the preferred formatting for associated types specification: `Iterator&lt;Item=Foobar&gt;` or `Iterator&lt;Item = Foobar&gt;`? In other words, do I put spaces as in a normal assignment, or do I do the Python things for keyword arguments.
i see now but this is really confusing. I mean since i use that method and i think it is supposed to be listed in the methods section 
I feel like this is a perfect example of what I meant with my internals post. It starts out with community frustration, which is met with "it's been discussed to death", which leads people to think core isn't interested at all. It reads (subjectively) like "It's been discussed a million times and you're annoying us by now". I know it's not meant that way. Saying "We know it has a couple problems, but there hasn't been a unified push from anyone to gather all the problems in one place, look at the possible solutions and evaluate them. If someone would like to start that, I'd encourage people to investigate the internals threads as a starting point" seems like it would be more productive. If the response "it's been discussed to death" is a lot more common than "core would love a good solution, but is too busy because it is in fact a complex problem" that will hinder movement and the search for solutions. Even if the sentiment is just "it would need an RFC since it's complex" instead of "been discussed to death" would be a win and encouraging to many people.
Thanks for letting me know. I’ve been trying to figure out why this issue is special; policy changes and major features have always needed RFCs. Why would people assume this is any different? We said in 2014 that this could possibly change; why would people assume otherwise? It’s not even the most discussion that’s ever happened around a particular feature.
&gt; We've continued to encourage discussion (though there's been attempts to keep it on topic and only have one thread instead of 6). Here's the thing: Nobody feels encouraged to get together and try to come up with solutions. When threads are closed it doesn't feel like there's a wish to put people together to work on things, it feels like it is done to keep down the "noise".
I agree with you. I guess my line in the sand about when to use crates needs to be drawn closer. So in this case, if I wanted to restructure my code to not have it be a static global hashmap, what would I idiomatically express my static global lookup table as instead? Guess I'm looking for the pattern to use when a global lookup table is needed. Is lazy_static the answer? Thanks!
I think everyone knows that at the end is an RFC as consolidating discussion/decision making basis. Honestly there's just way to little signal that core is really interested. If every message you get feels dismissive, it doesn't matter how encouraging the thoughts behind it were. Why do you assume people want change without an RFC? They want the feeling that their thoughts are appreciated, and their issues taken seriously, and solutions considered. The tree of progress needs fertile ground to grow.
&gt; Nobody has also said that it's not changeable. Every time the discussion is brought up, it is said it's not changeable, the decision will stand, discussing it here or internals or anywhere won't change their minds, its not changing, etc.
I believe you pick the wrong subreddit! ;)
No, no, tell us more about these large Maps. Are they HashMaps? BTreeMaps? How large are we talking?
The only threads that have been closed have been on reddit, where no official work is done.
I really wouldn't read it as that. I read it as people feeling like they can't even get to the point of where someone would come up with an RFC. Many others probably feel like it would be a waste of time even if they did.
What I see, is that even among the people who want namespaces, there are a ton of options, and there’s not even consensus among that group of what the solution is yet. How are we supposed to make decisions about changes when we don’t even know what those changes should be yet?
Ah, totally forgot about that. We're still waiting on the recording (which hopefully worked -- we used a telepresence system).
&gt;whoooopsy!
Hey, I'm glad you were able to get it to port 😁. Incidentally enough, [here's another port](https://github.com/immunant/lua/tree/5.3-4). Most tests pass, but some don't which I suspect are due to setjmp and longjmp.
You're fixating on the "considering changes" point. We're very far from that, probably further than when this all started actually. We're at a point where people are feeling there's no point in coming together and work on solutions. That's why posts to the subreddit are made only out of frustration or by people new to the issue. The only discussions about solutions happen in small pockets inside those threads, like further above in this comment section. From a non-core perspective, it seems similar to the issue the Go community had with progress on generics. The core team wasn't opposed, but discouraging. And that snowballed, and ended with people going around saying "Go is designed not to ever have generics" even though the core sentiment was totally different. You're not supposed to make decisions yet. You just need to say "yeah, those are problems" and encourage the community to come up with solutions.
Thanks, it's nice to know I'm not the only person using it. Also, I'm totally calling it cute owl :)
Did someone request `cratesio`'s crate names?
They are specific instances of various higher-kinded types. I wrote a blog on this on [urlo](https://users.rust-lang.org/t/monads-and-functors-and-applicatives-explained-badly-in-rust/15187)
Effective messaging consists of a lot more than just locking or not locking threads. Do you really feel like the core team has been encouraging people to work on solutions?
Glad i inspired someone else to try the same thing... But the part of minimp3 I ported is like, 3k loc. The other 120k is 3rd party libraries included in the `player` example!
The "methods" sections is for "intrinsic" methods, those implemented directly on the structure itself. To me, it makes sense that trait methods are in the "trait implementations" section. I really don't like the new "folded" default because you can't even search the method you're interested in without first unfolding the entire page though.
As that wiki page states, people mean one of two things when they talk about combinators. 1. The “formal” definition: a function with no free variables. Practically this means a function that doesn’t reference variables outside its own lexical scope. 2. The “informal” definition: a style meaning you can combine things together into more complicated pieces based on smaller component parts. I think it’s fair to call the methods you named “combinators” under either definition. It doesn’t matter that much though. I wouldn’t call them “combinators” unless I were talking to a group of people who already knew the terminology, because otherwise you risk over complicating what is a very simple concept 
Bind mounts should work here, at least on Linux. mount --bind src target 
That's part of the problem. At first some people felt their issues were dismissed. That started snowballing because there never really was encouragement to figure out solutions. Then throw in some regular posts with a tone like [this](https://www.reddit.com/r/rust/comments/9pjmjz/update_on_the_october_15_2018_incident_on_cratesio/e8455mm/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=rust): &gt; This does not mean you should expect team members to continuously debate on internals threads or reddit with anyone who wants to relitigate arguments we've had a thousand times. and &gt; You'll be hearing us repeat this a lot more in the coming weeks. There seems to be this odd expectation that discussion on Reddit or internals threads is how changes in policy happen. That is not how Rust has ever operated. which are everything but encouraging, with some parts even bordering on assuming bad faith. Why should anyone want to put themselves through the work of putting things together when they can expect that attitude to await them at the end?
Sorry, but I compiled both project and the rust version runs at 54fps while the C++ version only 1\~2 fps, both with release build
Nobody involved thinks the situation is ideal. Truly. On the flip side of this, it’s also literally true. The various name spacing threads haven’t really brought any new information to the table. It’s been the same discussion, over and over again, for years. There’s so much to do, and very little time to do it, and so people stopped prioritizing responding. In return, we get accused of ignoring things, when we’ve already replied, sometimes many times, over and over again.
Then what was the reasoning for deleting them, as a further action after banning the user and disabling their account?
Yeah thanks, it clarifies things to see how that motivation applies to each action. Deleting the crates has the side benefit of making the names available to the community again, though. :)
👍❤️
&gt; but we don’t have dictators. Setting aside that technically if more than one person is involved it's "oligarchs", not "dictators", &gt; dictator &gt; n. An absolute ruler. &gt; &gt; oligarch &gt; n. A member of a small governing faction. To quote [RFC 1068 Rust Governance](https://github.com/rust-lang/rfcs/blob/master/text/1068-rust-governance.md) &gt; Rust is governed by a core team, which is ultimately responsible for all decision-making in the project. Specifically, the core team: &gt; &gt; * Sets the overall direction and vision for the project; &gt; * Sets the priorities and release schedule; &gt; * Makes final decisions on RFCs. &gt; &gt; [...] &gt; &gt; The final decision to accept or reject an RFC is made by the core team. In many cases this decision follows after many rounds of consensus-building among all stakeholders for the RFC. In the end, though, most decisions are about weighting various tradeoffs, and the job of the core team is to make the final decision about such weightings in light of the overall direction of the language. &gt; Some people have said that because that’s their opinion on the current temperature of the team, but that doesn’t make it actually true. Well, yes it does. If everyone feels like thats the teams position, it doesnt matter what they think their position is, because they sure havnt made it clear to anyone else. Good intentions and all. phaylon already made a really good point about how the response to these things has usually been "it's been discussed to death" and not something "we would love a solution, we welcome you to write an RFC.", which i find extremely accurate. I've lurked a good number of these discussions and never got the impression the discussion was welcomed, [Especially with comments like these](https://internals.rust-lang.org/t/crates-io-squatting/8031/39). And, noting the fact that you're [supposed to have discussion before making RFCs](https://github.com/rust-lang/rfcs#before-creating-an-rfc), so every discussion being shut down with "it's already been discussed", "we're not changing our policy", "we see no event that will cause us to change this policy", etc etc. Well that sure doesn't inspire anyone to make an RFC. &gt; As a rule of thumb, receiving encouraging feedback from long-standing project developers, and particularly members of the relevant sub-team is a good indication that the RFC is worth pursuing. Comments like from team members like withoutboats sure aren't encouraging. It's been made clear long standing project developers don't consider this worth pursuing, so really we shouldnt even be making an RFC. With arguments against action against squatting like "Prominent community and team members squat and want to continue to be allowed to squat". Just.. really?
Not really. If a package is named "tokio/core" than that's all Cargo needs to know. It won't conflict with a package named "alot_the_murdered/core" because those full package names are different. It's all on the registry host to let users claim a prefix and then disallow anyone else from creating packages in that prefix. But that's not something Cargo has to concern itself with. As far as Cargo is concerned, package names would simply have slashes in them.
Web browsers take CLI parameters. `firefox reddit.com` I just use it to open pdfs half the time though lol. Good on you for completing your project though :)
I think that you’d find the team is significantly more split on the issues than you’d think.
We're going in circles here. There is no fertile ground for finding new information and working on solutions. Everyone is discouraged, so the only thing that happens is people are venting frustrations. And then core replies with frustrated discouraging messages, and the circle begins again. I know it sucks being in a leadership position. It's like a universe made up entirely of catch-22's. But it is what it is. The only solution I see is that core stops saying "it's been discussed a million times and you guys never come up with new information" and really encourages the community to form threads and discussions and working groups and such to move towards the RFC stage. And you need to message willingness to let people work on and solve the issues, and signal that you're willing to help them when things are ready and the time comes. A first step would be to believe the community that they are discouraged, without being accusatory about that.
What happens when you depend on tokio/core and another crate named core? This doesn’t mean that the question is un-solvable, but these are the kinds of questions that need design work, and are what a proposal would need to contain.
Nothing. Well, nothing special. You depend on "tokio/core" and "core". Those would be separate crates, one named "tokio/core" and the other named "core". I realize it's not the only option, there are certainly others. But it's not like this is an unsolved problem. Plenty of software package ecosystems support namespaces - probably more than don't, to be frank. The real issue, as I see it, isn't that the problem is hard and needs to be discussed, but that such discussion is just being shutdown entirely. I have yet to see a good reason to *not* implement other than "maybe we can get away with not doing it", but that's clearly tenuous logic that won't hold up forever. We should be discussing *when* and *how* we add namespacing, not *if* we add it.
tokio/core is not a valid rust identifier, so that does not work. Why do you think the discussion is being shut down? We not only have not closed any of the internals threads, but actively posted telling people that we don’t plan on closing them so that people can continue the discussion.
Interesting thing about this project is that while I was trying to compile it the biggest problem was not translated code but macros. I added a few macros instead of variadic functions but could not build the code because compiler could not find them. It appears that if you have macros in one module and want to use it in another one in the same project you have to put `#[macro_use] pub mod macro_mod;` declaration before others (in lib.rs and/or main.rs) where it will be used. Otherwise compiler doesn't see it. I didn't find this information in the documentation (or just overlooked it) and had to spend quite some time to find a solution. Compiler messages also doesn't help in this situation.
I think you'll find that *that doesn't matter*. Intentions don't matter. Actions do. We don't see you behind closed doors. When a team member says the position is X, and nobody else is saying they disagree, why wouldn't people accept it? It seems that theres simply a serious communication problem going on here, which is also being dismissed because "well we know what we meant!". And yes, your comment seemed dismissive. Out of everything i said, all you got out of it was that "well we know what we mean!"? Really? 
Only in one function it put some strange/unnecessary return value. After removing it I only needed to deal with variadic functions. But as I said I can't run Lua tests yet so probably there are more other issues.
It’s not being dismissed; that’s why I’m putting so much effort into replying here. I’m trying to figure out what happened and is happening. “Actions matter” goes both ways. It’s also frustrating to see people paint everyone as some kind of monolithic block based on a few comments.
OSX also has that feature built-in, the shortcuts are just an alias or shell function away. `open` can open any file path or URL, so `open https://www.google.com` launches that site in the default browser, `-a &lt;application&gt;` overrides the default handler.
I presume you mean [this thread](https://internals.rust-lang.org/t/crates-io-package-policies/1041)? The official statements/responses make it very clear that namespaces are completely off the table and all discussion of them really seems like shouting into the wind.
&gt; and now as "well you have to make a full fledged perfect RFC before we'll even consider the idea that we should consider making *any* changes" No, that is not what anybody is saying. What we are saying is "don't start an internals thread and then get mad at the lack of action" Nobody is saying don't have an internals thread, or that there should be no discussion. What we are saying is that is not where it ends, and yelling at us for not acting on the internals thread is not ok. Honestly it feels like there's no way to win here. If we don't reply to these threads, we get yelled at for not responding. If we do respond, people complain that we're stifling discussion by responding. 
No, I mean ones like this one: https://internals.rust-lang.org/t/namespacing-on-crates-io/8571 or this one: https://internals.rust-lang.org/t/crates-io-squatting/8031 The thread you linked to says, as the *first* part of it: &gt; In general, these policies are guidelines. Problems are often contextual, and exceptional circumstances sometimes require exceptional measures. We plan to continue to clarify and expand these rules over time as new circumstances arise. 
What was the function? I personally use rust-gdb, I haven't given rust-lldb a try yet; for the most part rust-gdb gets the job done, with the occasional hiccup
Yeah but my point is you can just create the relevant alias to get more or less the same e.g. `alias as_g='open https://google.com'`, and if you really want to that can be hidden behind a shell function.
But core *is* a block. If a significant amount of the core team gives discouraging messaging, and the ones interested don't really speak up, where is the productive energy to come from? A couple people on the relevant core team thinking it's not worth it can end a proposal. So from a community perspective, these individual voices do matter. And as such, core would need to adapt a unified message of encouragement and openness. And call each other out when they aren't. I'm wondering if the community team shouldn't come into this as sort of a buffer, but I'm unsure how that would work, or if that's even part of their responsibilities. 
So, the core team doesn't really have control here. It's the crates.io team. To be clear. &gt; if that's even part of their responsibilities. It's moderation's job to step in if someone is out of line.
but I think it's easy to learn/ understand them, if we have some categorization on these functions.
I also think that, they should not belongs to combinators.
I think you might want to use `u64::from_bytes(_)` if your Rust version is sufficiently recent. Comparing u64 is equal to comparing 8 bytes. If you only need equality, that will work nicely.
Yeah, I totally understand you. However, Anyshortcut is a productivity tool and anyshortcut-cli is an extra, their share user's shortcuts by using API. If I bind G to google, not only I can use this shortcut in Chrome or Firefox, but also in the terminal. There is no additional step for the users.
I tend to just say core team as a placeholder for whatever team is responsible. Though in this case I meant the actual community team as mentioned on [this page](https://www.rust-lang.org/en-US/team.html#Community-team). But it seems to be more about community organization.
I'll have to look at this when I'm not on my phone, but thank you so much for the reference. 
Honestly I don't remember what was that and I don't have that change in my commits. Trying now CodeLLDB plugin for VSCode and it works pretty good.
hi. ashley here. i am on the [crates.io](https://crates.io) team and i the person in april who decided it seemed really important for a team to exist. i have been working closely with sean griffin and other folks to get this team off the ground. &amp;#x200B; the team is very small, we have 9 people, some of who participate to help us coordinate with cargo. 2 of us are on call for [crates.io](https://crates.io) service ops. we also maintain the website, the database, backend services. it's a lot of work for a small team. &amp;#x200B; we have a set of priorities that we have agreed on for 2019. there are a lot of things we want to work on- from improving the [crates.io](https://crates.io) website, to expanding the ops team, to policy work. in fact, policy work was very important to everyone when we talked about priorities. &amp;#x200B; it turns out, however, that the priorities have different urgency. you might be surprised to discover that we have \*significant\* \*urgent\* policies we need to work on. as much as i genuinely care about this squatting/namespace situation, it turns out this is not even close to the most urgent situation we have. i can discuss this at length if you'd like, but i won't do it here. &amp;#x200B; i have personal experience handling squatting/namespacing because of my 3 year tenure at npm. i have a lot of thoughts. you may be surprised that i might not even disagree with you as much as you might expect. the members of the team are excited to work on this, but we have to analyze our priorities, our team members availability, and address things as best makes sense. &amp;#x200B; i am replying here and will only write this, no more. i am replying because we have been accused of not listening, and then not engaging. i have very much been listening. i can also say that the team members are also all listening. to the extent that we haven't engaged, there are several reasons: &amp;#x200B; 1. we cannot prioritize this work right now because we have very urgent things (ops, other policies that involve lawyers) that we have to do first 2. i, personally, cannot imagine how to engage in a way that won't further escalate or derail this conversation. after thinking about it for a while and discussing this situation in my keynote at rustbeltrust this morning, i have decided to try my best. this is that response. &amp;#x200B; fundamentally, we need more people. we aren't trying to shut folks up or out. we want you help in fact we need it. if you are interested in joining the team, please email [help@crates.io](mailto:help@crates.io), dm me on discord, or email me personally at [ashley@integer32.com](mailto:ashley@integer32.com).
&gt; It’s also frustrating to see people paint everyone as some kind of monolithic block based on a few comments. To me that just seems like "We know what we meant!" worded differently. Leadership is *supposed* to be clear and united. You're supposed to be a monolithic block. You need a united front. Like it or not, thats the way it is. If one team member says nothing anyone says or does will change X, that will be seen as the teams position. Like it or not, when you speak, you speak for the team. Reddit gets this right for moderators, who can distinguish their comment to signal they're speaking officially, and otherwise are speaking as normal users. Unfortunately, non-mods and other platforms don't get that luxury. There really isn't an easy solution for this, sadly. I'd suggest making an effort towards *one* official position, making that position clear and publicly *known*, even if the position is "We don't know yet", and clarity when speaking as a team member or a user. I think by default people will assume you're speaking as a team member, and most won't even question it. For example, I didnt think about whether you're speaking as a team member or not until i wrote this sentence, 32 minutes in to writing this comment. &gt; It can’t both be “team members say that this feature isn’t wanted” and “team members are ignoring us” simultaneously. Sure it can. Different team members or at different times. This is a unification issue. For a monolithic block it can't be both, but for individuals it can.
&gt; Leadership is supposed to be clear and united. You're supposed to be a monolithic block. You need a united front. Like it or not, thats the way it is. Maybe this is really the root of this. This is *not* how it works in Rust. We think it leads to bad software.
&gt; But is it true that the other compilation steps can run during the build script execution? I meant that other crates might be getting built at the same time. If you're talking about how many threads to spawn, if you're using Rayon it will use the number of logical CPUs in the machine by default, and I guess it chops up data based on cache lines. If you want to manage your own parallelism, the [num_cores](https://crates.io/crates/num_cpus) crate is the *de facto* standard for getting the core count.
Maybe it would help to have a group doing that. They could gather community opinions and maintain them in an issue tracker with references and such. It would also provide the relevant team members with a way to respond once in a place for them to have discussions, what they care about and such. Then there could be easier messaging where they go back to the community and say "Unable to fix that until a solution for X is found, because Y" or "we'd need help there from the community in gathering info about Z" or simply "noones opposed but everyones busy to design". They could decide to start tracking tickets specifically to solve hold-up issues and encourage people to join in there. I wouldn't be surprised if the same friction mechanics aren't involved in most of the controversial issues that exist now or in the past.
/r/playrust
I went with `read_u64` from the byteorder crate for now. The speedups are insane! Should `u64::from_bytes` give the same result as `read_64` from byteorder (provided the same endianness)?
Yeah, maybe. I'm not sure, but I'm also not sure why I'm not sure :)
I think you're not getting responses because people don't really understand your question, and what you want to achieve. At least I don't.
Probably because it would be a lot of work that we all feel shouldn't be necessary in a perfect world. And we're probably frustrated that it is necessary because everyone has their own definition of perfect :)
&gt; Additionally, npm's squatting policy and our squatting policy is very very similar, I can see how you would think that, but those are two very different policies. Crates.io's entire squatting policy consists of &gt; We do not have any policies to define 'squatting', and so will not hand over ownership of a package for that reason. Which explicitly isnt a policy. NPMs policy is to actually have a policy, and for that policy to be against squatting. It asks you to politely ask the owner first, and they'll step in if theres no reply. It's unclear to me what happens if they do reply, but in the negative, but given that they define squatting as explicitly unacceptable content and say "Don't squat on package names, user names or organization names. Publish code or move out of the way.", i doubt it would be favorable to the squatter. The process may seem similar but the actual policies are entirely different. Asking the owner is always an option regardless of policy, of course it'd be the same. &gt; This happens extremely rarely. I'm going to hazard a guess that that has something to do with squatting not being allowed in the first place. It's in the rules, people don't commonly break the rules do they? So if the npm community knows that squatting is not ok, it seems natural that squatting issues will be rare. If squatting were allowed theres no reason not to, and if anyone asks you can say no despite not planning to do anything with it. Not so on npm, where you should " Publish code or move out of the way.". Try to squat and get called out, you know you have no justification so why cause a fuss.
Awesome thanks! I didn't get a chance to go to this workshop and it was something I was excited for. Now I just need to find the logging workshop info.
&gt; It's unclear to me what happens if they do reply, It's exactly what I said. Which is the only difference. Yes, npm may say more things about what they think squatting is, but the only different outcome of the policy is what happens if the owner doesn't respond. You also didn't quote the part where we will also email the owner on your behalf if you wish. The only difference is that if you don't reply; if you do reply, and say you don't want to hand over your crate, npm won't take it, and neither will we. &gt; So if the npm community knows that squatting is not ok, it seems natural that squatting issues will be rare. No, I mean, squatting happens quite often. But the person not replying at all is rare.
&gt; i, personally, cannot imagine how to engage in a way that won't further escalate or derail this conversation. after thinking about it for a while and discussing this situation in my keynote at rustbeltrust this morning, i have decided to try my best. this is that response. Thank you for this response, I do believe that this is an example of really helpful messaging. Especially giving context like &gt; have a lot of thoughts. you may be surprised that i might not even disagree with you as much as you might expect. the members of the team are excited to work on this, but we have to analyze our priorities, our team members availability, and address things as best makes sense. is very helpful in deescalating a rift that is likely smaller than it appears to many.
On slide 54: &gt; We can use finish (or f) to continue execution until we return to the caller. I think this is a mistake. The `f` command (at least in lldb) isn't an abbreviation for `finish`, it's an alias for `frame select 0`. This prints the source code showing where the next line will be executed, though I believe `finish` does what the slide says.
Found it. It was function `b_str2int`. Inside loop there was an if block that returns some value but after it c2rust put another value to return. Should take a look at it closer. Maybe that causes crash. Also I found several places where I changed function pointer casting from using **transmute** to just direct cast. Probably this is also causing a problem.
&gt; This is not how it works in Rust Like it or not, thats how leadership works. If leadership isnt united, then you get "`“team members say that this feature isn’t wanted” and “team members are ignoring us” simultaneously.`" &gt; We think it leads to bad software. That's why the RFC process exists; The team doesnt always have to agree, it's ok for the teams united front to be "We want to discuss this with the community". But when theres no consensus, definitive statements like "this policy will not change no matter the circumstances" shouldnt be made. And at the end of the day, the core team has final say on RFCs anyway. Theres no easy solution to this and it isnt as easy as just be united, because that can lead to just always agreeing, it's complicated and subjective and context dependent, and possibly the alignment of the planets is involved.
npm's namespacing is _optional_, and npm existed _without_ namespacing considerably longer than it has existed _with_ namespacing. Consequently, squatting in npm is not a valid argument against having namespaces in Rust. Look instead to Maven Central (Java) or Packagist (PHP) where namespaces were always mandatory, and namespaced forks a feature.
Speculating about what Rust would have been like with namespaces from the start isn’t really useful; we will always be, at best, in the same boat. That’s an argument that Maven Central and Packagist aren’t as relevant to our situation as npm is.
Consider this playground example: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f69b451ffe790425067f51115d1d70c6 Is there a nicer way for a struct to take ownership of its self, and then return ownership, apart from what I have done there?
npm employees have told me differently. That’s what I’m going by. Maybe this changed sometime recently?
Honestly that seems like such a cop out to me. "Oh well i was told differently, thats why i didnt bother actually reading the linked policy" 
Yes, when I do the background work by talking to other package management ecosystems to see how they tackle these problems, it’s reasonable to believe what they say. That does introduce the possibility of miscommunication, or not being aware of changes. Or that stated policy and actual implementation are different.
&gt; The core team doesn't decide this policy. Are you suggesting it could change through an RFC? But with final say on all RFCs, they would have to accept an RFC limiting their powers, wouldnt they? Not to say they wouldnt, but my point is leadership is complicated.
That's definitely the idiomatic way to do it. That said, it's more idiomatic to use `&amp;mut self` than to use `self` by value, when you have a choice. (Apart from complicating the return type, self-by-value is difficult to use with struct fields or values behind references, because you need to swap in a replacement instance while the method is running.)
anyway when i try to use `read_line` i get `no method named read_line found for std::io::BufReader` error
String and slice equality uses `memcmp`, though, which already does this trick under the covers. It could be that your problem is that you're looping over slices to compare them, rather than just using `==`?
But they're not just one person? They're a team member, on the language team, saying that this won't change under any circumstances, and an rfc is a circumstance, and no other team members in the thread saying thats wrong?
&amp;#x200B;
They are a team member, but that doesn’t mean that they represent the entire team. And again, just because there’s no reply on internals doesn’t mean that the team feels this way. Official decisions of the team happen when RFCs are accepted and/or rejected. Internals posts are not how policy is made, RFCs are. Additionally, people’s opinions sometimes change. You can feel super strongly about something, but then when new things come to light, change your mind!
its already in the scope thats the weird thing ```rust use std:: { fs:: { File }, io:: { BufReader } }; ```
oh i see now i need to bring those separately to scope too just bringing bufreader alone is not enough
Yeah, something like that would be neat! :)
I'll have to give it a try, thanks for the recommendation 😎
My bad, you want `use std::io::BufRead`, which is the trait itself.
&gt; And again, just because there’s no reply on internals doesn’t mean that the team feels this way. Well we arent mind readers, we read what a team member says and listen, and if thats wrong but another team member doesnt come along to correct the situation, how should we know? &gt; Official decisions of the team happen when RFCs are accepted and/or rejected. well it sounded official and authoritative &gt; Additionally, people’s opinions sometimes change. You can feel super strongly about something, but then when new things come to light, change your mind! we're not mind readers, unless we're told they changed their mind we won't know.
And apart from the noise created by other crates building at the same time, you might also need to ask "what's the system workload like when this code is actually running?" If you run your benchmarks when there's nothing else going on, but the actual production code runs when there's a ton of stuff going on, there's a good chance that the Optimal Settings are different in those two cases. Running benchmarks during the build is in some ways the worst of both worlds: it's much more complicated than just hardcoding some defaults, but it's also liable to give you the wrong answer. That said, you had a specific question: &gt; that leaves the potential for the functions to get out of sync between the build scripts and the main crate I think the solution to that particular problem is to split this function out from your main crate into its own sub-crate. Then the main crate can have it in both `[dependencies]` and `[build-dependencies]`, and you don't have to duplicate the implementation.
Yeah, it isn't exactly emphasized, but macros are the only elements whose declaration **must** appear **before** their actual use, including when ordering imports. Thankfully in Rust this never leads to substantial problems. We're actually lucky this behavior only applies to macros. In most languages, order of declaration matters (unless some boilerplate is used). 
No, I did not do that. You can see the functions in question \[here\]([https://github.com/KillTheMule/nvimpam/blob/impro/src/card/keyword.rs#L89](https://github.com/KillTheMule/nvimpam/blob/impro/src/card/keyword.rs#L89)) and \[here\]([https://github.com/KillTheMule/nvimpam/blob/impro/src/card/ges.rs#L15](https://github.com/KillTheMule/nvimpam/blob/impro/src/card/ges.rs#L15)). That's of course before transformation to comparion \`u64\`s, which gave me a speedup of easily 50%.
I think the benefit he is trying to promote is that he has his own bookmark syncing service that you can subscribe to. So you can sync between Firefox and Chrome. This is adding that to also work via the command line.
[Read this](https://stackoverflow.com/a/46419872/13924)
Threads are closed on reddit because they get flamewar-y. That's a wholly separate issue. Reddit is also an unofficial venue and does not reflect the opinions of core. Internals threads have not been closed, y'all have been free to discuss it as much as you want there.
I'm not aware of any valid argument against TCO. I'll just debunk the ones proposed here: &gt; nukes stack traces So does async. You want to use execution traces instead because the stack is a low-level implementation detail. &gt; the optimization can disappear due to seemingly arbitrary changes if you're not familiar with what the compiler is doing in the background TCO means an unbounded sequence of calls in tail position require only bounded stack space. Tail position is any position right before a function returns. Quite simple and predictable IME. 
&gt; fold et al. are basically a replacement for TCO. Eh? You mean you use library functions rather than rolling your own tail recursive functions. &gt; I can't think of cases when I desperately need explicit recursion. I use tail calls mostly for state machines and continuation passing style. 
I'm interested in seeing how you changed the code. Are you still using `match`? It looks like (https://godbolt.org/z/JGdvTo) `match` and `==` can both produce the same code with strings, but maybe something about the number of cases you have there made the compiler decide something different?
Typeclasses are better in the small (e.g. for arithetic) whereas higher-order modules are better in the large (e.g. for mocking). 
&gt; OCaml feels different, it has a much greater emphasis on immutability. AFAICT, purely functional data structures are a nightmare in Rust but easy in OCaml. 
&gt; But is does have type inference Eh?
RiiR may be seen as unproductive a lot of the time, but going through the process yourself without bothering the original developers is a great exercise. And hey, of you manage to convince some people to adopt your code, then that's a win for safety.
I think a lot of this depends on the use case. As I've made clear, I have in mind music DSP, which is generally not considered that CPU-intensive by today's standards, and so these algorithms are at pretty large risk of not being SIMD optimized at all. My idea is that the _default_ is that the user writes portable code and the runner picks the highest capability available (at least up to AVX2, to me the jury is still out on AVX-512), but there are mechanisms (not yet implemented in the fearless_simd crate) to customize the behavior more. &gt; You should probably compare the performance of this benchmark against packed_simd with its crate features enabled (to get fast sin, sin_pi, etc. methods) to get an idea of the "cost" of portability. Ok, this was more painful than I hoped, as I got build errors for sleef-sys on both my mac and windows machines (problems finding libclang), but on Debian after installing clang and libclang it built. That box is an Intel i7-3520M @2.9GHz (Ivy Bridge). With target-cpu=native, I get 30ns for the best result from fearless_simd (essentially the same as my Windows i7-7700HQ @ 2.8GHz), 251ns for packed_simd sin_pi with sleef-sys, and 673ns without. That last is slower than the scalar fallback of calling f32::sin(), weighing in at 523ns. I'm not claiming fully scientific benchmarks yet (there are _sooo_ many variables to control), but I think this provides at least rough evidence that the portable approach I'm advocating can provide quite good performance.
I'd be happy if they were just usable but from what I've seen they're all nightmarishly difficult to use in Rust. 
The ask is a bit unclear so I'm going to focus on: &gt; As a generalized concept, I'd like to be able to take a vec of functions where each ones output type is convertible to the input of the next function -- much like a promise chain in JavaScript or a future chain in Rust. The only safe static type for your vector elements is `type Chainable&lt;T&gt; = Fn(T) -&gt; T;`. What would happen if I call v.swap(0, 5)? It's a valid method on a vector, but it would break what you're trying to enforce. However all is not lost. If you're willing to drop the idea of using a `Vec` for your array of functions, you can define a middleware trait, which is implemented both by standalone functions, and by chains of functions: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=dfd811cce9bd0a6c63634ac67c2d71a6 The difference here is that the middleware has distinct types for the input and output and you can only append at either the beginning or end, so this keeps you safe.
In what sense are those persistent data structures? 
Functional programming is trendy and Rust wants to be trendy, therefore Rust is functional programming.
Haskell was designed to be good + all languages are designed to be good =&gt; all languages are extremely similar to Haskell in design and philosophy
That's a common special case also done in C compilers. In the context of FP, TCO means guaranteeing to eliminate all calls that are in tail position, e.g. a call to another function that was passed in as an argument. 
Same as C.
With big step semantics?
Shameless plug for [debug-here](https://crates.io/crates/debug-here), a little library I wrote to drop into the debugger quickly.
&gt; adds extra runtime cost ~10x slower. &gt; complicates the ABI significantly as callers might need to be aware of it It is a global change to the calling convention that, for example, can no longer be the C ABI. Also, it destroys all stack traces and makes interop really hard. 
Huh, that seems kind of backwards to me - clearing out deadwood sounds way less controversial than eminent domain. Can I ask why you've ruled that option out?
Yea I know that the TCO only works because of llmv TCO optimizations, that's what I said in my original comment.
It's a starting point. Once it's been translated into Rust, it becomes easier to progressively add safety incrementally.
You wouldn't want to use the c2rust code directly, but instead use it as a starting point for refactoring into idiomatic Rust.
You can use a macro see the constify macros in my simdeez lib: &amp;#x200B; [https://github.com/jackmott/simdeez/blob/master/src/macros.rs](https://github.com/jackmott/simdeez/blob/master/src/macros.rs) &amp;#x200B; I stole this from the stdsimd lib. &amp;#x200B;
Because often people actually are just reserving a name that they intend to use, and we have other things to do that we won't have time for if we're spending it hunting down every empty crate that nobody wants. There will always be exceptions, and exceptional circumstances require exceptional action (like Monday). I also don't like using the term "ruled out", here. People can change opinions over time. This isn't something we've discussed at length as a team, just briefly and informally.
The second form is preferred (source: running `rustfmt` on this).
D'oh. Somehow the simplest solution didn't occur to me. Thank you!
My gosh -- I think you somehow managed to decipher my terribly worded question! This looks like an ideal solution, thank you! This kind mentorship/advice is why I love the rust community.
See this [thread](https://internals.rust-lang.org/t/6709) for const function arguments proposal. Until (and if) we'll get such functionality we have to use macros similar to [`constify_imm8`](https://github.com/rust-lang-nursery/stdsimd/blob/master/coresimd/x86/macros.rs#L3).
Thanks! I saw something about \`constify\` macros in a Github issue but couldn't find them in the standard library documentation. I guess I was looking in the wrong place. I'll try these out and see how performance looks (I'm guessing these crates have been benched though)
...which makes no sense
I missed u &lt;3
My question is more about if what I am tying to do is even possible. I have recently uploaded my first crate to crates.io, simplebase, https://crates.io/crates/simplebase . I have implemented a trait that automatically stores data and converts various data types to a String and then it is stored in a struct, with the type of the data stored as well. My question is, since I know what type the data is, can I automatically return the data as a particular type; eg return a f64 or u64 or a String, using a single method/function. I have tried various approaches to this (such as returning enums, using structs for each type) but I am not making much progress. Is what I am trying to do (returning a generic type) even possible? 
You're looking for /r/playrust 
Thank you haha sorry, just wanted to say that I'd give Rust another chance.
Glad to see the nanosecond precision! Still haven't had a chance to test drive this but definitely on my todo list. Keep up the great work!
Hello, I will do in the correct group. Sorry for that. Thanks &amp;#x200B;
I wonder if it's possible to just have virtual vector instructions in LLVM that operate on completely arbitrary vector lengths. LLVM could have a pass that rewrites these instructions to ordinary instructions, allowing the user to choose at compile time between cpu specific instructions, fallback instructions, and runtime detection. That way this would stop being a rust problem and benefit C and other languages as well. Plus it'd be nice to just write code in terms of arbitrarily long vectors instead of manually splitting long arrays into the appropriate vector types.
Yes and no. The entire protocol layer lives in `service.rs`, so I could just export the non-protocol layer for use as a library. So yes in that the code is already designed with this in mind but no because I haven't done it.
It also requires merge and commit threads running in the background, so it's not really usable in a short lived process. Furthermore, the internal low level apis are not very convenient (performance). You might be better off running it as a process and have it listen on a Unix domain socket.
So implementations of your trait for different data types all return the same (non-generic) struct, which contains a `String` and and `enum` value indicating the type encoded by the `String`? &amp;#x200B; The struct could implement methods like `fn get_i32(&amp;self) -&gt; Option&lt;i32&gt; { ... }` for all the different supported types. It could also return an `enum` with the different possible encoded types as variants, e.g., `enum ContainedType {` `Int32(i32),` `Float32(f32),` `...etc...` `}` and let the receiving code deal with the cases. &amp;#x200B; But if you want a *single* method `fn get(&amp;self) -&gt; T { ... }` that automatically returns the correct type, the struct itself would need to be generic over the encoded type; I don't know if that is OK for your use case.
That's because the Result used there is an `io::Result`, which only takes one type argument. You probably didn't do the import, so you're using the `std::result::Result` type instead, which needs 2 type arguments.
The description on that page suggests always referring to that type as `io::Result` instead of importing the name directly, because of that exact point of confusion.
Your formatting broke and it's kind of unreadable. 
So I actually didn’t stumble upon mentat until recently. Very sad to see it stop as a project. My partner and I’ve been building a nosql document store that syncs using a CRDT to handle conflicts. It’s all built in rust. Then we built a networking layer that uses both client server and P2P to handle the syncing. So it’s totally able to handle a mesh! Here’s it working on iOS, completely syncing between WiFi Access Point, Bluetooth, and even WiFi Direct. Collaborative Text (https://youtu.be/FXFxM_q9eO4) Collaborative P2P inventory (https://youtu.be/XoyUjs-Mwh0) We are hoping to open source it soon. But if anyone is interested in building all the features of a P2P syncing data store. Let me know!
To me, combinators are what Haskell states (you quoted it). For instance, the `parsec` has a lot of combinators (all doing things in the `Parser` monad.
For some reason all of their lines seem to end in Unicode Character 'FULLWIDTH NOT SIGN' (U+FFE2), Given the line numbers, probably some weird behavior from wherever it was copied from.
This sub is for the programming language, not the game
How did you end up here? This doesn't look anything like a gaming forum.
Thanks you, your answer gives me some idea what I am dealing with and that what I am trying is possible.
Wonderful! Thank you! Can this allsow work for the mackrows on doc.rust-lang.org?
That's really cool! I wish I had known about that earlier.
Ashley, Thank you. Thank you for all the work you put in keeping the services we rely on up. Thank you for working to gide this community to more open and respectful communication. Thank you for sharing your vast amount of hard earned perspective. I look forward to you sharing your thoughts on squatting when that is the most urgent topic on the teems agenda. In the meantime I look forward to the team continuing to share what it is working on and how we as a community can help.
Is the goal to lazily initialize `self._reader` by only creating a `BufReader` from `self._file` at the time that `read_line` is first called? The [`get_or_insert_with`](https://doc.rust-lang.org/std/option/enum.Option.html#method.get_or_insert_with) method on an `Option` will do that. You pass it a closure that initializes `self._reader`, and then it will return the inner value after initializing it with that closure if it hasn't yet.
Does it hang on any url or only particular ones? Name resolution is a notorious spot for problems, `strace` should tell you more.
Have you tried splitting up the hanging line into multiple calls to narrow down where the error is happening? You're doing quite a few things on that one line.
all I want is actually being able to use a pointer to the structure instead of every time when I call read line to copy the same structure allocate memory for it and deallocate again but seems rust encourages that behavior but all these malloc ing and freeing is a runtime cost I funny understand how it would be more performant 
what's wrong with just having a pointer pointing to the file ? the problem is that I don't want to malloc and free a possibly large struct every time when I call read line function it's just not logical 
Is your struct definition something like this? struct MyFileReader { _reader: Option&lt;BufReader&lt;std::fs::File&gt;&gt;, _file: std::fs::File, // more fields } In a structure like this, `_reader` cannot contain a reference to `_file`, since if `MyFileReader` is moved that would invalidate the reference to `_file`. Rust has no move constructors, so there isn't an opportunity to update that reference to the new location. Some alternatives are: * Use the crate [`rental`](https://crates.io/crates/rental) to allow that self-reference, which only works if you put `_file` behind a pointer (e.g. `Box&lt;std::fs::File&gt;`) so that it doesn't actually move when the struct moves. This doesn't exactly work here, since `BufReader` needs to take ownership of the underlying reader. * Use `File::try_clone` to make a second handle that you can move into `_reader`. I think this is the copy you're trying to avoid. * Make `_file` also be an `Option`, so you can move the value out of it and into `_reader`. * Don't do lazy initialization. Remove the `_file` field and initialize `_reader` when you construct the struct.
Thanks!
Any idea how I can strace an android app?
Good suggestion, this is the line that hangs: let client = Client::new(); 
&gt; Any idea how I can strace an android app? Bound to be a way. Do you have an `strace` binary, for starters? Kernel has PTRACE enabled? If YAMA is enabled on your kernel also check `/proc/sys/kernel/yama/ptrace_scope`. If you can't get `strace` going, try doing the steps that `reqwest` would do independently. (1) resolve the name to an address, (2) connect to the socket via TCP, (3) if necessary start TLS session, (4) issue the `GET`/`POST`/etc command. Also: &gt; Does it hang on any url or only particular ones? Take the hostname from the URL and try it with `dig`/`nslookup` or similar. If the name resolution works, try connecting to that port via a socket (either write a rust / python / C program or use wget/curl/telnet/bash). I realize that doing any of these on android is harder than typical x86_64 linux but one of them is bound to succeed.
This is awesome. Any chance you'll add support for changing file/directory names (while still changing strings)? I would get a lot of use out of that. It would be really helpful when changing a class name in Unreal Engine for instance, because that involves changing both the strings and filenames for it to not break anything.
wouldn't any hash function be used for your purpose? check out [https://docs.rs/seahash/3.0.5/seahash/](https://docs.rs/seahash/3.0.5/seahash/)
"Derive Functor" in Haskell has saved me hours of boilerplate writing, I'd say it's more than neat.
Where would that heap allocation be and for what data structure?
Hey, I don't have much experience with compiling to android, but here is what I found that may help a bit, but will need you to do some more digging on your own. I would recommend building a version of your app which point to a local version of reqwest and 'print-debug' this with a bunch of print statements step by step. Good way to find places to put prints into * Creating a new client code is [here](https://github.com/seanmonstar/reqwest/blob/v0.9.3/src/client.rs#L277) * That creates a new client builder which is [here](https://github.com/seanmonstar/reqwest/blob/v0.9.3/src/async_impl/client.rs#L56) and the only 'complex' part there looks the 'TlsConnector::builder' call * And that seems to just be setting up a struct [here](https://github.com/sfackler/rust-native-tls/blob/v0.2.0/src/lib.rs#L444) so should not be a problem. * After creating that, the 'build' method is called on it. I would say this is a prime candidate for their being an issue, as it seems to have some complicated steps [here](https://github.com/seanmonstar/reqwest/blob/v0.9.3/src/async_impl/client.rs#L82) Then again, I could be wrong, this is just the approach I take usually when debugging any unexpected issues with dependencies. I checkout my dependency, checkout the tag that points to the version I'm using, and change my cargo file to point to it like [this](https://stackoverflow.com/a/33025972/537028). Hope you find the solution to your problem. 
So, regarding the DNS lookup and all that, the exact URL worked before when the app was using hyper directly. This is why I think it's an mio/tokio issue specifically. I loaded strace on my phone and tried attaching to the running apk (I have root) but no dice. I'll keep digging here. This is a great suggestion. Thank you.
This happens to me when I use my mouse to copy and paste from vim without mouse support enabled.
Hmmm I think it looks right to me? It looks like the amount to shift by needs to be an immediate value: https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srai_epi32&amp;expand=5396 I think if we dropped the requirement for const here, you'd wind up with codegen errors in the cases where llvm can't determine a constant. The problem is I guess that you can't propagate this requirement on stable Rust.
The count to shift by is an immediate value, so it must be known at compile time. This is as true for C as it is for Rust. When you use a match statement, you basically allow the use of a dynamic value, but if the compiler can determine a constant, then the match statement should be compiled away. This probably requires inlining your function. So this makes it work at the cost of a potential performance bug. I think eventually you should be able to define your own const parameters. At which point, you can just propagate the constness requirement. &gt; The only way I could figure out how to get data in and out of the __m128i type was by reading the regex crate source code to see how it was done there. Isn't that how you would do it in C too? Current SIMD support is quite nascent and intended to just expose what's provided by the vendor. Docs should improve over time.
[tokio](tokio.rs) has some great tutorials and also has a runtime (eventloop) for running futures to completion. The docs are currently being improved, so if you have any comments or discover any typos, please make an issue at [tokio-rs/doc-push](https://github.com/tokio-rs/doc-push). 
You can try using the cpp crate: [https://docs.rs/cpp/0.5.1/cpp/](https://docs.rs/cpp/0.5.1/cpp/) Could look like somthing like this (untested) cpp!{{ #include &lt;intrin.h&gt; // NOTE(casey): Required for AES intrinsics #include "meow_hash.h" }} fn meow_hash(buffer: &amp;[u8]) -&gt; [u8;512] { let len = bugger.len(); let ptr = buffer.as_ptr(); cpp!(unsafe [len as "size_t", ptr as "void *"] -&gt; [u8;512] as "meow_lane" { return MeowHash1(0, len, ptr); }) }
ping /u/imperioland
Huh, repurpose hardware AES as a non-cryptographic hash? Clever.
I've already updated the extension to work on doc.rust-lang.org as well.
phaazon\_ is not wrong. what you're trying to do is something people do in C, but it's not idiomatic rust. This comes close to what you are trying to do, and does compile: use std::io::{self,BufRead}; use std::fs; struct Nefthias { name: String, reader: Option&lt;io::BufReader&lt;fs::File&gt;&gt;, } impl Nefthias { pub fn read_line(&amp;mut self, line: &amp;mut String) -&gt; Result&lt;usize, io::Error&gt; { let reader = match self.reader { Some(ref mut r) =&gt; r, None =&gt; { let file = fs::File::open(&amp;self.name)?; self.reader = Some(io::BufReader::new(file)); self.reader.as_mut().unwrap() }, }; reader.read_line(line) } } However noone would write it like that. I would do something like this: use std::io::{self,BufRead}; use std::fs; struct Nefthias { reader: io::BufReader&lt;fs::File&gt; } impl Nefthias { pub fn open(name: &amp;str) -&gt; io::Result&lt;Nefthias&gt; { let file = fs::File::open(&amp;name)?; Ok(Nefthias { reader: io::BufReader::new(file) }) } pub fn read_line(&amp;mut self, line: &amp;mut String) -&gt; io::Result&lt;usize&gt; { self.reader.read_line(line) } } fn main() -&gt; io::Result&lt;()&gt; { let mut nf = Nefthias::open("hello.txt")?; let mut buf = String::new(); let len = nf.read_line(&amp;mut buf)?; print!("read {} bytes content: {}", len, buf); Ok(()) } Good luck :)
Thats probably the future. Cross language and plattform library usage thanks to wasm. I can't see why that wouldn't be the most excellent idea for programmers 
In the internals post I'm referencing, it's not just about team members but also how the attitude is picked up by other people. It's certainly an attitude that seems rooted in the attitude presented by core members when they do respond. It also doesn't help when you say things like &gt; As steve has said multiple times here and elsewhere, open an RFC. That sounds like a passive aggressive order. We're talking here about how people are too frustrated to even be able to work towards an RFC, and how encouragement would work better than discouragement. Your response cancels that good will out, and you're giving directions to frustrated community members, even though you're not on the team. This again increases the perception that there is a general "don't bother" sentiment. And the fact that this spilled from the crates team to you is a perfect example of the problem.
No speed comparison to the original implementation that I can see though, and the entire point of meowhash is to be fast.
Sure, please open an issue and I'll add it to my TODO list. :)
I'm a little puzzled about this comment by Centril: "\[...\] I would suggest creating a PR against your o\[w\]n repository \[...\]" ([https://internals.rust-lang.org/t/variadic-generics-pre-rfc/8619/3](https://internals.rust-lang.org/t/variadic-generics-pre-rfc/8619/3?u=memoryleak47)) It seems, I'm less familiar with git than I expected, how would I do that? The repository in question is [https://github.com/memoryleak47/variadic-generics](https://github.com/memoryleak47/variadic-generics). &amp;#x200B;
&gt; I tried using lldb in android studio and got about as far as setting breakpoints into my native rust code, but am kind of lost after that. Have you tried letting it run up to the hang point, and then stopping in the debugger and getting backtraces for all threads?
I was about to do that too 😅
Found this thread while looking for same. I often get warnings when I ask my GPGPU questions in computervision channels lol, it'd be nice if there were a dedicated channel for it.
Well I'm glad you reopened the issue at least! It would be pretty sweet too have. You already went this far, might as well go the whole way right? ;)
Isn't {{Iterator::flat_map}} the method I'm using in my example?
Thanks, I was looking for his nick. :D
I feel you. &lt;3
Lldb definitely works with Rust. If a particular line hangs, can you just step into that code and advance line by line until you narrow down the problem?
Yeah, the notation didn't make any sense to me either. I still think the rust language design philosophy should inherit some useful thing from the _Zen of Python_ i.e. **There should be one and preferably only one obvious way to do it.** I think there would be less barrier to entry and intermittent player (such as myself) would still feel easy with the language construct after much gap. While I consider the explanation given by /u/__fmease__ as sufficient but I wouldn't have known it, If I hadn't stumbled into this thread. Would someone on the language team care to shed some light onto it. I know it would be a breaking change, but would it be a feasible task for the next version of rust to remove the grammar that allows such kind of behaviour?[ _just a thought_]
Also a beginner and have stumbled over this as well. I don't really find this very confusing. I made the mistake a few times in the beginning but then you just learn to look for it. What would be confusing though is to constantly have to figure out what name the result type has in each and every package.
Nice! You should expand it to offer something like Shields where you can generate GitLab/GitHub badge images based on http routes.
[Not everyone has an ASCII-only name.](https://iavatar.herokuapp.com/img/%C3%B6)
Because things can happen in between you reading two lines - for example, an external program might close stdin, or kill whatever is writing to your program's stdin.
Because your local cargo fetches from the GitHub repo to learn about available packages/versions.
Yippee! I'll take it for a spin
Yeah, I'll look at that one too! Thanks for the example :-)
It has to be a scalar but not a constant. The intrinsics guide convention is to [put `const`](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=5387,420&amp;techs=SSE4_1&amp;text=const%252525252525252525252525252525252525252525252525252525252525252525252520) in front of parameters that need to be known at compile time (otherwise, how is the C code working?).
If the library is well crafted it should return Result on errors, not panic.
If you are working with a function that can panic, you can use something like: [https://doc.rust-lang.org/std/panic/fn.catch\_unwind.html](https://doc.rust-lang.org/std/panic/fn.catch_unwind.html) &amp;#x200B; To deal with panics. It is a good question whether there is a way to identify if a function you are using can panic other than pouring through the source. I don't know.
Is this the only reason why line read will fail? Would it fail if there was a buffer overflow?
The operating system blocks the input stream when its buffer is full. There’s no failure condition there.
But there's no reason it couldn't fetch from crates.io.
By "safe", we only mean "memory safe" in Rust; that is, we wish to prevent buffer overruns, use-after-free, double-free, data races, and other sorts of *undefined behavior*. In our Rust-specific terminology, panics are safe, and so are memory leaks. Rust does also not prevent all race conditions and neither does it ensure dead-lock freedom and starvation-freedom. That said, `panic!()`, `.expect("my random logic error")`, and `.unwrap()` should only be used when: 1) An irrecoverable error, such as out-of-memory, under which scenario it would be unreasonable for the program to continue execution. 2) For the normal operation of testing frameworks such as [proptest](https://github.com/altsysrq/proptest). 3) When you are sure the panic will never happen and when it would be a programmer logic error otherwise. Otherwise, you should prefer [`Result&lt;T, E&gt;`](https://doc.rust-lang.org/nightly/std/result/enum.Result.html), [`Option&lt;T&gt;`](https://doc.rust-lang.org/nightly/std/option/enum.Option.html), or similar mechanisms to handle errors due to user action. To make this ergonomic, you should use [the `?` operator](https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html#the--operator-can-only-be-used-in-functions-that-return-result). Rust currently does not have any mechanism to statically prevent panics. However, you can use https://github.com/dtolnay/no-panic to improve the situation somewhat.
Crashing with panic is completely "safe" - it's defined behaviour (unlike crashing because of a segfault), and not generally exploitable for attackers. This is what Rust means with safe. When an invariant is violated, it's usually a better idea to shutdown the program as fast as possible, instead of trying to recover. Of course, as others have pointed out you generally don't want to use functions which can cause panics in normal operation, such as `unwrap` when you aren't 100% sure an `Option` or `Result` has a value. There's no language feature for marking which functions can panic, but the standard library (and most crates, hopefully) tend to document this.
“Safe” in marketing materials refers to memory safety and absence of undefined behaviour in “safe” code. Panicking, given correctly written (unsafe) libraries, violates neither of these two properties. In fact, panics are usually employed to maintain them! Robustness is an entirely different property, unrelated to "safety", which panicking *does* affect, however this is a property that is up to libraries and ecosystem to deal with. The language does not guarantee anything wrt robustness, but it also does not prevent ecosystem from providing such a property. &gt; Is there a way for me as a developer to be warned about code that can `panic`\`unwrap` by a complier and handle some cases of it I’m not aware of any way to get warned, and panics are not intended to be “handled”. If you receive a panic because of some handle-able error condition, I would consider that a bug in (most likely, library) code.
I appreciate your effort, but could you give your project some other name? On crates.io we already have [lua](https://crates.io/crates/lua), [rlua](https://crates.io/crates/rlua) and [lua-rs](https://crates.io/crates/lua-rs).
"Safe" is a term with a [specific meaning](https://doc.rust-lang.org/nomicon/what-unsafe-does.html) in Rust. Safe Rust code is guaranteed not to execute "undefined behavior"; what this generally means in practice is that it won't segfault, access arbitrary memory locations, or start executing arbitrary code (as can happen in C, for example, if a buffer overflow vulnerability is exploited). It is *not* guaranteed not to panic, deadlock, leak resources, or otherwise do things you don't want.
Hello! I'm trying to use a library that requires me to activate a feature. After reading through the manifest documentation, I learned that I need to compile with "cargo build --features std". (in this case I want to activate the std feature in the library). I am able to successfully compile and run the library's tests but I cannot compile my own program in my own project. After executing the cargo build --features std command I get an error "Could not find \`StdBusManager\` in \`shared\_bus\`". So it appears that I am not activating the "std" feature in the library. I checked the library's [lib.rs](https://lib.rs) and I found the cfg attribute that I need to activate: #\[cfg(feature = "std")\] so I'm not sure exactly what I'm doing wrong here. My Cargo.toml file has a \[features\] section with a std = \[ \] line. I must be missing something else in my manifest. Any help would be greatly appreciated! The library I am trying to use is: [https://github.com/Rahix/shared-bus](https://github.com/Rahix/shared-bus)
Hmmm. I see. If it doesn't need to be const, then yeah, that's a bug. &gt; (otherwise, how is the C code in the post working?) I think we'd probably need a full program to check this? If everything gets inlined and `bit` is itself a constant, then I think the compiler is happy (assuming that the shift width does indeed need to be const).
The description of the lines method indicates that its iterator returns instances of `io::Result&lt;String&gt;`. Further it points to [read_line's](https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_line) error description. From your [Lines](https://doc.rust-lang.org/std/io/struct.Lines.html) link, you'd need to dig into the Iterator in "Trait Implementations" to see Item type is [Result](https://doc.rust-lang.org/std/io/type.Result.html). Besides possible IO errors, a big one is checking for valid UTF-8 encoding. Even once you have the bytes, attempting to get to a string can be an error.
Is there a better way to write this ? ``` match &lt;an_expression&gt; { d @ 'U' | d @ 'R' | d @ 'D' | d @ 'L' =&gt; println!("{}", d), _ =&gt; (), } ``` I don't wan't the result of the expression to be affected to a variable outside the matched clause so this is **not** an option: ``` let d = &lt;an_expression&gt;; match d { 'U' | 'R' | 'D' | 'L' =&gt; println!("{}", d), _ =&gt; (), } ``` 
I've nearly gotten the todo list example to work on Windows using the GNU toolchain for Rust and MinGW versions of QT and make, but I've run into an error towards the end. I managed to get the binding generator to compile by commenting out the section related to the runtime information library (was giving me errors when configuring in cmake), generating MinGW makefiles and using \`mingw32-make\`. So I put the location of \`rust\_qt\_binding\_generator\` in the system PATH for the time being. Then I went to go compile the todo list example by making a build directory and generating MinGW makefiles again and doing \`mingw32-make\`. It appears to compile the Rust and C++ parts fine, but then it fails upon trying to link to the Rust library (linking to \`librust.a\`), so I tried changing the CMakeLists to use \`librust.lib\` (since that was compiled in the Rust target folder). But even then, I couldn't get it to link to the Rust library. I'm not too sure how to get around this error (very new to cmake). Here's the full output for the todo list example: &amp;#x200B; C:\\Users\\Jon Pacheco\\Documents\\Repositories\\GitHub\\rust-qt-binding-generator\\examples\\todos\\build&gt;cmake .. -G "MinGW Makefiles" \-- The C compiler identification is GNU 8.2.0 \-- The CXX compiler identification is GNU 8.2.0 \-- Check for working C compiler: C:/msys64/mingw64/bin/gcc.exe \-- Check for working C compiler: C:/msys64/mingw64/bin/gcc.exe -- works \-- Detecting C compiler ABI info \-- Detecting C compiler ABI info - done \-- Detecting C compile features \-- Detecting C compile features - done \-- Check for working CXX compiler: C:/msys64/mingw64/bin/g++.exe \-- Check for working CXX compiler: C:/msys64/mingw64/bin/g++.exe -- works \-- Detecting CXX compiler ABI info \-- Detecting CXX compiler ABI info - done \-- Detecting CXX compile features \-- Detecting CXX compile features - done \-- Found Cargo: C:/Users/Jon Pacheco/.cargo/bin/cargo.exe (found version "1.29.0") \-- Found Rust: C:/Users/Jon Pacheco/.cargo/bin/rustc.exe (found version "1.29.2") \-- Looking for pthread.h \-- Looking for pthread.h - found \-- Looking for pthread\_create \-- Looking for pthread\_create - found \-- Found Threads: TRUE \-- Found RustQtBindingGenerator: C:/Users/Jon Pacheco/Documents/Portable Apps/Utilities/rust\_qt\_binding\_generator/rust\_qt\_binding\_generator.exe \-- The following REQUIRED packages have been found: &amp;#x200B; \* Cargo \* Rust \* Threads \* Qt5Core \* Qt5Gui (required version &gt;= 5.11.2) \* Qt5Network (required version &gt;= 5.11.2) \* Qt5Qml (required version &gt;= 5.11.2) \* Qt5Quick \* Qt5 (required version &gt;= 5.6.0) \* RustQtBindingGenerator &amp;#x200B; \-- Configuring done \-- Generating done \-- Build files have been written to: C:/Users/Jon Pacheco/Documents/Repositories/GitHub/rust-qt-binding-generator/examples/todos/build &amp;#x200B; C:\\Users\\Jon Pacheco\\Documents\\Repositories\\GitHub\\rust-qt-binding-generator\\examples\\todos\\build&gt;mingw32-make Scanning dependencies of target rust\_target \[ 9%\] Generating ../rust/target/release/librust.lib Finished release \[optimized\] target(s) in 0.03s \[ 18%\] Built target rust\_target Scanning dependencies of target todos\_autogen \[ 27%\] Automatic MOC for target todos \[ 36%\] Built target todos\_autogen \[ 45%\] Automatic RCC for qml.qrc Scanning dependencies of target todos \[ 54%\] Building CXX object CMakeFiles/todos.dir/src/main.cpp.obj \[ 63%\] Building CXX object CMakeFiles/todos.dir/src/Bindings.cpp.obj \[ 72%\] Building CXX object CMakeFiles/todos.dir/todos\_autogen/mocs\_compilation.cpp.obj \[ 81%\] Building CXX object CMakeFiles/todos.dir/todos\_autogen/EWIEGA46WW/qrc\_qml.cpp.obj mingw32-make\[2\]: \*\*\* No rule to make target '../rust/target/release/librust.lib', needed by 'todos.exe'. Stop. mingw32-make\[1\]: \*\*\* \[CMakeFiles\\Makefile2:105: CMakeFiles/todos.dir/all\] Error 2 mingw32-make: \*\*\* \[Makefile:83: all\] Error 2
&gt; I tried to loop up this in detail in the documentation, but was only able to get as far as https://doc.rust-lang.org/std/io/struct.Lines.html &gt; Anyone know more detail? `Lines::next` calls `B::read_line`, that calls `io::read_until`, which calls `B::fill_buf`, which calls `R::read` which calls `stdio::Stdin::read`. What happens afterwards depends on the platform, for unix it's going to call `FileDesc::read` which wraps a `read(2)` calls in a [cvt call](https://github.com/rust-lang/rust/blob/master/src/libstd/sys/unix/mod.rs#L138), which converts a result of `-1` into [creating an `io::Error` from the current `errno`](https://github.com/rust-lang/rust/blob/b9adc3327ec7d2820ab2db8bb3cc2a0196a8375d/src/libstd/io/error.rs#L285). And so there you are, if fetching the next line needs to re-fill the buffer, and in doing so performs a failed `read` on the underlying stream you'll get an Err. You can see the various possible errors in your local `read(2)` man page, though not all apply (e.g. stdin obviously is not a socket). The main one would be that the fd is closed (`EBADF`), more rarely some unknown IO error (`EIO`) or that some a-hole gave you a directory as stdin (`EISDIR`).
For more context, see [QuietMisdreavus' tweets](https://twitter.com/QuietMisdreavus/status/1054014849884205056) - exciting to see this finally starting to come to fruition :)
Not true. The use-cases for panic and result are simply different. It's not the case that "good" is result and bad is "panic". RE: other comments in this thread.
There is no buffer overflow: the caller provides a buffer and says how many bytes they can handle, `read(2)` will return *up to* that number of bytes. A related possibility on some systems (OSX's man page mentions it but neither Linux's nor FreeBSD's) is that the kernel itself runs out of buffers (`ENOBUFS`) or memory (`ENOMEM`), but then you're in a pretty bad way.
Thanks for the clarification. I read in a few places comments like 'if it complies it will run without crashes', so I assumed that safety is more than just memory safety. &amp;#x200B;
&gt;if it complies it will run without crashes That is a little over-zealous. If you change it to "exploitable crashes" it is a much more accurate statement. That being said, some don't define "panic" as "crash". Panic is "I'm stopping this program in a controlled well-defined fashion in order to avoid undefined behavior and/or a 'crash' because the state we have now entered is either due to programmer logic errors (which cannot be fixed without fixing the program) or hardware failures (that similarly cannot be fixed at run-time)."
The more accurate statement is, perhaps, if it compiles it won't segfault. (Provided you didn't use any unsafe code.)
It doesn't sound sensible at all to me, however, I think that has much more to do with your requirements being unsubstantiated. Why does it need to be static? Why do you need to make an enum out of one particular part? Those things are pretty contradictory without context; if I needed something static, I'd turn it into a macro, and let the compiler do everything else. I would generate this macro via a build script. Are you able to explain what actual work the primary project does using this data?
Considering to add SVG option as a output. Thanks for the suggestion! 
And provided the unsafe code that you transistively used (Say, in the stdlib) has no bugs that you triggered. And provided that the compiler is generating correct code. In any case, valgrind is a good tool for tracking down bugs.
Small note: When causing undefined behavior, one should only be so lucky as to cause a segfault and be killed by the operating system =) What would be much much worse is for the program to continue its execution and then for the UB to be an exploitable security hole or to cause real damage in case the software is mission or safety critical.
You are welcome. :) As others have noted, "crash" refers to segfaults, not causing controlled exists, which panics are, even though they are often indicative of a logic bug. At least, they are not exploitable and mostly untraceable hisenbugs.
&gt;GitLab/GitHub badge images That sounds great! Try to do this whenever I have some spare time.
Well, by now there are lots of (free) font families out there that support enough Unicode. Just use one of those. The next tricky bit is what to do about non-Western names :)
What you need to do is to specify the dependency like so (and remove the cfg flag from your lib.rs as well as the [features] section): ``` [dependencies.shared-bus] features = ["std"] ```
&gt; There should be one and preferably only one obvious way to do it. As both a hobby language designer and a programming practitioner, I understand your concern, I really do. When programming, you compose smaller language features to solve larger problems. Thus, if there are many similar building blocks, one might easily get confused: "Which syntax should I choose?" Or when reading somebody else's code: "I didn't know this syntax exists, does this mean the same thing as X?". A designer should reduce the amount of basic language features â€“ atoms. The whole system should be powerful enough to express itself with fewer ideas. That's the main intend of the quote. Unfortunately, it stops there: There are unbelievably many reasonable algorithms which solve one given problem. Each of them has its own advantages and trade-offs. Classic example: Sorting algorithms. Sometimes, the advantage is minor: In Rust, `for in` vs `for_each`. The former might _look better_ with simple iterators like `1..5` and the latter with a large chain of `map` and `filter` (actually, there are some more differences). Let's get concrete. In which cases should you prefer `â€¦, Variant(), â€¦` over `â€¦, Variant, â€¦`, `struct X&lt;&gt; { â€¦ } â€¦ impl&lt;&gt; Tr for X&lt;&gt; { â€¦ }` over `struct X { â€¦ } â€¦ impl Tr for X { â€¦ }`, `fn f&lt;&gt;() {}` over `fn f() {}`, â€¦? E.g. in `macro_rules`: $( $T:ident )* =&gt; impl&lt;$( $T ),*&gt; =&gt; impl&lt;&gt; T =&gt; impl&lt;T&gt; T U =&gt; impl&lt;T, U&gt; T U V =&gt; impl&lt;T, U, V&gt; Same with all the other cases listed. There might be use cases you didn't consider but are perfectly valid. Not only simplicity is important but also consistency (e.g. `Ã¬mpl&lt;&gt;` being part of Rust). Consistency allows programmers to use the language by assuming and be right about it which leads to a more fluent work-flow. What you suggest: Allow constructors/functions to be of type `fn(T, U, V) -&gt; R`, `fn(T, U) -&gt; R`, `fn(T) -&gt; R` and `R` except `fn() -&gt; R` because they don't add value as they are pure. **You artifially restrict natural occuring patterns of the language**. In your world â€“ applying your rule consistenly â€“, the function `fn foozle() -&gt; i32 { 2 * CONSTANT + 4 }` is illegal â€“ **without seeing the bigger picture**: In this case, `foozle` might be the implementation of a trait method. This is why `Variant()` has the total right to exist. I hope you understand my reasoning. Have a nice day \_\_fmease\_\_ 
Is this different in the 2018 edition as you don't need macro_use anymore?
&gt; I think that has much more to do with your requirements being unsubstantiated. Yeah, I might not have explained things properly, I'll try :) &gt; Why does it need to be static? It doesn't need to be, but it is. It's basically the "syntax" of a certain type of text file - an input file from the FEM solver pamcrash. I know it beforehand, it's just a huge list in the documentation, and to parse such an input file, I need to transfer the definitions to my program. &gt; Why do you need to make an enum out of one particular part? Because there are several alternatives for this part, which are mutually exclusive. For example, if you look at the [`Cell`](https://github.com/KillTheMule/nvimpam/blob/master/src/card/cell.rs) type, those are just the possible entries of a line, given by how pamcrash input files are structured. &gt; if I needed something static, I'd turn it into a macro, and let the compiler do everything else I don't see any way to usefully use a macro here. I've made one for the [`part cards`](https://github.com/KillTheMule/nvimpam/blob/master/src/carddata/part.rs#L9), because all those cards share a common first 5 and last [`Line`], but other than that I don't see how to generate this data other than simply writing it down the way I did. &gt; Are you able to explain what actual work the primary project does using this data? Sure :) It's a plugin for the editor neovim, but never mind that. What it does is: It reads pamcrash input files, and produces folding data (folding as in contracting lines visually in the editor, just to have a better overview over a large file). You can see an example for such a file [here](http://www2.ifb.uni-stuttgart.de/fem/Tutorial8_Crash_SimpleTruck/Explicit/Truck_Front.pc). If you forward-search for "PART", you see between the words "PART" and "END_PART" an example for a card. Every second line is a comment, explaining what field is below it (although the exact columns might be off, it's not unusual). E.g. the word "DTELIM" means that the "0." below it denotes the parameter value of "DTELIM" for this particular card. The static definition for the card is [here](https://github.com/KillTheMule/nvimpam/blob/master/src/carddata/part.rs#L86). I don't think a lot will be recognizable, however this static definition says e.g. that [the first line](https://github.com/KillTheMule/nvimpam/blob/master/src/carddata/part.rs#L13) starts with the keyword (which is "PART / " here), and then has 6 fields of length 8 with different types, and thusly ends after colum 56 (you will notice it is of type `Provides` in my code; that means that the line carries some additional information I need to parse and save for later use). Now that I have the start of the card in the input file, as well as my static definition, I can compare them to do several things, think e.g. of syntax highlighting. Right now, what I do is count if the number of lines in the file fits the static definition, and if yes, I tell the editor it can fold the card into one line for a better overview. Does that make more sense? I hope I did not write too much :)
How long does it usually take for docs.rs to get new docs from crates.io? I pushed a new version of a crate several hours ago, but the docs still haven't updated. Makes me worry that I forgot some step in publishing process.
Set up a new branch (`git checkout -b mybranch`) and push it to origin after you committed your changes (`git push mybranch origin`). The push message should contain a link to the github page to create a PR. Otherwise go to the main page of your project where a yellow bar with a link to the PR creation page should appear after a while.
I'm not going to publish it on [crates.io](https://crates.io) any time soon so I'm not sure if it's really necessary. If/when I will publish it then for sure I'll rename it. Or there are some other problems with this name duplication?
&gt; That sounds like a passive aggressive order That's ... not what passive-aggressive means. Nor is it an order, it's mentioning the way the policy is changeable, in response to a statement that it isn't. It's an example, not an order. Could be phrased better, but it's not an order. ------ This discouragement people keep talking about -- I just don't see the evidence for it. And I've been watching this discussion go on for four years now. What I see is this: - People ask for specific cases of squatting to be dealt with - Team refuses, citing policy - People get frustrated I also see: - People bring up namespacing/squatting - There's a long discussion - Team members participate a tiny bit, sometimes disagreeing (but not in any way stronger than any other technical disagreement in any other proposal thread, as in they give a reason why, a reason which you are free to provide a counterargument to) - discussion eventually peters out What I _don't_ see is proposals to change policy being shot down (disagreed with, sure, not "we don't want this, go away"). It's kind of absurd to get frustrated at the team for standing by the current policy -- that's what they're supposed to do! They're not _supposed_ to change policy just like that! [This thread](https://internals.rust-lang.org/t/crates-io-incident-2018-10-15/8568) is understandably frustration-causing because team members express exhaustion there and are dismissive, but the chronology is wrong -- this thread started out with a post that mentioned multiple ways to discuss policy changes (one of them being an rfc, the other being reaching out directly to the crates team). There also was a comment from the team asking people not to discuss namespacing on that thread, redirecting them to the other thread. There was also a comment explicitly saying that the nobody wants to shut the discussion down. Steve got frustrated with a community member painting it as an "us vs them" scenario, and left a frustrated response, which could have been worded better, and then ended up having a back-and-forth with you on that topic. That's ... basically the _only_ comment I can find that comes close to a dismissive, frustrating, response. This is a comment left two days ago, which I doubt most folks have even seen, and it's _one_ comment, not something that would discourage the community from opening RFCs IMO. The team definitely could be communicating better here (and they've recognized that and are doing so! ag_dubs left a good comment below), but honestly this is a discussion that has gone in circles for so long that it totally makes sense for them to disengage from it as much as possible until it's in RFC form. 
No. First of all, there's other cases where syncing doesn't get executed properly (such as kernel panics etc.). Second, fsync itself may return errors, such as the disk being full, which `eatmydata` will also happily ignore.
Very nice step! Love to see this central part of the rust ecosystem being pushed further!
There's also a detail which helps to make the distinction more visible: With the default unwind-based panicking behaviour selected, panicking functions like a very limited exception mechanism and will unwind the stack, calling `Drop` implementations along the way to perform cleanup. With a crash, the only cleanup you get is the cleanup the OS performs when *any* program exits.
This makes sense. This is probably the route I'll end up going. Thanks!
&gt; The for loop will already unwrap lines() iterator items, so what's with the second unwrap()? Others have added more detail, but I just wanted to emphasize that this is kind of incorrect. A for loop doesn't unwrap results. If you were to call `next` on the iterators manually, you'd get an `Option&lt;Result&lt;String&gt;&gt;`. The Result part represents the success or failure of underlying IO and UTF-8 validation. The Option part represents whether there are any more lines remaining in the stream. So the for loop "unwraps" the Option (probably "matches on" or "destructures" is more accurate), but the Result gets passed to you.
Why not parse the data into a more convenient format as a separate phase of the build? There are likely better ways, but one way is to generate a .rs file that just instantiates a bunch of static variables.
The problem is, that the master is already on the newest commit, therefore adding a branch \`mybranch\`, which is also at the newest commit will create an empty pull request. Therefore I added a branch \`newbranch\`, which I \`git reset --hard\` to the first commit, and now I started a pull request from the \`master\` to that \`newbranch\`, will that suffice? And think you meant \`git push origin mybranch\`, btw.
Yeah I’m not sure why it’s far fetched to expect lots of wasm modules from Go and C showing up on npm. If they were easy to consume, why wouldn’t you? Maybe npm will be the one module registry to rule them all
Hello everyone, I was going to announce this later. &amp;#x200B; Thanks to all hard work from QuietMisdreavus and jonhoo, every [docs.rs](https://docs.rs) specific change have been implemented to rustdoc. This means we can finally use official rust builds in [docs.rs](https://docs.rs). Maintaining a custom rustc and cargo and rebuilding them for 6 different architecture was a real burden for me, and now we can easily update rustc with rustup. This will allow us to update rustc more frequently in [docs.rs](https://docs.rs) and focus on project instead of a maintaining a custom rustc. rustdoc team also have full control over repository and server since everything became so much easier to maintain now. &amp;#x200B; Currently, [Docs.rs](https://Docs.rs) is rebuilding every crate that have failed to build since last rustc update. &amp;#x200B; I can't tell you how relieved I am after this update and we can finally focus on future of [docs.rs](https://docs.rs). This is really great news for [docs.rs](https://docs.rs) and rust community, congratulations to everyone!
Well, crates.io is the first place to find some crate, and it is widely known, so people familiar with lua-rs ar crates.io will be confused to see some other Rust program with the same name but by different author.
Thank you onur for all the time you have invested into this over the last years. I know it hasn’t been the easiest of times as things broke with newer rustc versions.
FYI, I finally got strace working and was able to narrow the problem down. [pid 24827] 10:04:46 write(2, "Client failed to initialize: Inner { kind: Tls(Normal(ErrorStack([Error { code: 185057381, library: \"x509 certificate routines\", function: \"X509_STORE_add_cert\", reason: \"cert already in hash table\", file: \"x509_lu.c\", line: 370 }]))), url: None }", 247 &lt;unfinished ...&gt; So it looks like it was caused by my android app overwriting the root SSL certs to make Let's Encrypt a trusted root. I disabled all the root cert overriding code and now requests are sending again! Seems it's throwing a panic but the panic is getting lost. I might spend some time tracking this down more (should be easy with an actual error type) so I can file an issue where appropriate. Thanks for the strace tip, I would not have thought to use it. I sometimes forget android is based on linux. For future reference, I had to do setenforce 0 In the adb shell to let strace attach (not sure if that needs root or not, but I did it as root).
Why did docs.rs need a custom rust?
Btw there is a similarly big limitation of Rust's thread safety promises. It only promises the absence of data races in plain datastructures, not the absence of every kind of race condition or deadlock.
You mean like: Write the data in csv, during build parse that to spit out a `.rs` file that contains the definitions? I might think about it, but that's not fully my question, because those definitions would just be what I have now (albeit automatically generated). I'm questioning whether defining the struct `Card` this way is reasonable or not :)
Great to see it finally become part of the Rust project! I've been a bit wary about using it, but now I have no qualms about it. Thanks to onur for making it and everyone involved who made this happen 🎉
I like the difference highlighted between "pulling over the side" and "running into a telephone pole". Both result in the car being stopped, of course, however one lacks control... and induces damages to the environment.
What I saw from a brief reading is that tokio is a great library when you need to use certain specific non-blocking operations (for example, reading from file or socket). But it doesn't seem to have anything on writing my own, or integrating my own poller with their poller (for example, have an event fired on key press).
Sorry for jumping the gun on your announcement, excitment got the better of me 😅 Thank you so much for all your hard work!
There is now a Firefox-version here: https://addons.mozilla.org/en-US/firefox/addon/macro_railroad/
You can solve your immediate problem with: ``` let mut subResults = [0.0f64; 1000000]; ``` But you probably don't want to allocate an 8MB array on the stack in the first place, so you'd be better off using a Vec instead: ``` let mut subResults = vec![0.0f64; 1000000]; ```
`next()` method on lines iterator is returning `Option&lt;Result&lt;String, io::Error&gt;&gt;`. For loop "unwraps" the `Option` part, while the explicit `unwrap` unwraps the `Result` part. Of course, the error handling is not properly written - one should use `?` operator instead of `unwrap` or explicit handling via `match`.
You need to initialize your variables: fn findpi() -&gt; f64 { let mut subResults: [f64; 1000000] = [0f64; 1000000]; let mut divisor = 1.0; let mut result: f64 = 0.0; for i in 0..1000000 { subResults[i] = 4.0 / divisor; divisor = divisor + 2.0; } result }
You might be interested in the [_What Unsafe Rust Can Do_](https://doc.rust-lang.org/nomicon/what-unsafe-does.html) chapter of the Rustonomicon. Here's the most interesting bit: &gt; Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the core language cares about is preventing the following things: &gt; - Dereferencing null, dangling, or unaligned pointers - Reading uninitialized memory - Breaking the pointer aliasing rules - Producing invalid primitive values: - dangling/null references - a bool that isn't 0 or 1 - an undefined enum discriminant - a char outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF] - A non-utf8 str - Unwinding into another language - Causing a data race &gt; ...Rust is otherwise quite permissive with respect to other dubious operations. Rust considers it "safe" to: &gt; - Deadlock - Have a race condition - Leak memory - Fail to call destructors - Overflow integers - Abort the program - Delete the production database Some of that is kind of surprising. Suddenly aborting the program is safe. Deadlocks are safe. Leaking memory is safe! You might even ask, what's the value of "safe" code if there are so many problems it doesn't prevent? I think there are three answers to that question: 1. In the real world, where the OS and the hardware itself might fail sometimes, there's limited value to proving that a program can never crash. For example on Linux, the default memory allocation settings are such that under very high memory pressure, the OS might just kill your program randomly. In that environment, there's not a ton of value to handling allocation failure gracefully, since the OS might not even give you a chance to handle it. (_Sometimes_ it's important, for sure, it just might not be the best practical default for most programs.) 2. Some types of bad behavior are expensive to categorically prevent. For example, if you want to prevent `Arc` from creating cycles and leaking memory, you either need a cycle-collecting garbage collector, or you need a type system that strongly limits what you can put in an `Arc`. Both of those things would limit the usefulness of Rust, and the tradeoff isn't considered worth it. (Though again, there are scenarios where a different choice makes sense, and some things are possible in libraries.) 3. None of the "safe" behaviors can lead to truly undefined behavior. This is a big difference when we our programs can accept malicious input from the internet. Writing through a dangling pointer or out of the bounds of an array can make your program do _anything_, including installing a rootkit on your machine or sending all your passwords to evil.com. Preventing those sorts of security problems is extremely valuable. If an attacker can only crash or deadlock your program, that's still bad, but it usually can't escalate into Front Page of the New York Times levels of bad. It's _well defined_ bad behavior. (And if you're the autopilot on a 747 or the safety governor in a nuclear power plant, I sincerely hope you aren't accepting input from the internet.)
Getting I/O errors uploading the asciinema video, but here's a preview: https://streamable.com/4hoqh
I mean a web page where I would enter the code and patterns. I'm often doing this on small snippets and it's a bit of a pain to open a new tab in text editor, save the file as something unique, look up that unique file in the shell, type out --subvert and --go, and all of that for every single file. A webpage with a text field that's automatically processed and updated in real time, so it doesn't need --go, where "subvert" is a checkbox and that remembers your replacement settings from the previous time would be more convenient.
you can .collect() to a vex
Looks pretty cool! How do you move and resize the windows?
I got slammed by a "no such process" error, while reading lines from a file in /proc while a process terminated. It was a bit of a surprise, but at the same time reassuring that Rust error handling can handle obscure corner cases like this with elegance.
Every window is drawn to a virtual buffer before it's drawn to the screen, so windows can be hidden but still print output
[Extend](https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod.extend), which is implemented on `Vec`: fn main() { let mut v = vec![]; let s1 = &amp;[1, 2, 3]; let s2 = &amp;[3, 4, 5]; v.extend(s1.iter().map(|e| e+1)); v.extend(s2.iter().map(|e| e*2)); println!("{:?}", v); } =&gt; [2, 3, 4, 6, 8, 10]
I just did some initial quick performance comparison with the C version and for me currently the rust version was unfortunately running at 1.73x the time of the C version, right now at least (and assuming I measured correctly). Would be interesting to investigate what is causing the difference, opened up an issue here: [https://github.com/bodil/meowhash-rs/issues/1](https://github.com/bodil/meowhash-rs/issues/1) &amp;#x200B;
You are on the right track. What you are missing is that `take` returns a new iterator, it does not yield a value. So you could do this, for example: for elem in some_iterator.take(10) { some_vec.push(elem); } Or, if you don't have a pre-existing vec to push onto, you could do it using `collect()`: let v: Vec&lt;T&gt; = some_iter.take(10).collect();
Ha I had a similar Idea and thought to myself: "Okay if I really do this I should go and see an psychiatrist". Great that you agree with me! I will still check it out tho. All hopes of sanity are lost anyways ;-)
Got it working now. &amp;#x200B; Thanks guys! &amp;#x200B; Here's the final code. It's not very accurate though: fn main() { let mut sub_results: [f64; 111000] = [0.0; 111000]; let mut divisor = 1.0; let mut result: f64; for i in 0..111000 { sub_results[i] = 4.0 / divisor; divisor = divisor + 2.0; } result = 0.0; for i in 0..111000 { if i % 2 == 0 { result = result + sub_results[i]; } else { result = result - sub_results[i]; } } println!("{}", result); } &amp;#x200B;
Why do you absolutely want the callback to take ownership of the value instead of it just getting a mutable reference to it? Note that a mutable reference still lets you replace the value (`*e = new_value`).
I think people here are missing the point. `take()` doesn't work because you want the "original" (modified) iterator to continue iterating after you take 10 elements. I don't think there's anything in the standard library that will do this. You might to roll your own. You might also just use a for loop. let mut vec = Vec::new(); // you might already have this laying around for i = 0..n: if let Some(v) = it.next(): vec.push_back(v) // you still have "it" for you to continue iterating
But will `some_iter` move over to the 11th position after, for the next next() command? 
&gt; Nobody is saying don't have an internals thread, or that there should be no discussion When team members reply "This has been discussed to death a billion times on internals at this point, go take a look." it's no wonder people feel like there's no point doing an RFC. This is like the impl trait discussion all over again, when it's only ever the community's fault.
Thank you, this answers my question. 
You borked your markdown.
https://internals.rust-lang.org/t/namespacing-on-crates-io/8571/53
I've been using the `delegatemethod` crate a lot (also in combination with `getset`), how does this one compare to it? 
&gt; I think people here are missing the point. take() doesn't work because you want the "original" (modified) iterator to continue iterating after you take 10 elements. My answer covers this. `let vec: Vec&lt;_&gt; = (&amp;mut it).take(n).collect();`
Does that compile? It looks like [take() takes "self" by value and therefore takes ownership of the "inner" iterator](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take).
&gt;&gt; Are you able to explain what actual work the primary project does using this data? &gt; &gt;Sure :) It's a plugin for the editor neovim, but never mind that. What it does is: It reads pamcrash input files, and produces folding data (folding as in contracting lines visually in the editor, just to have a better overview over a large file). You can see an example for such a file [here](http://www2.ifb.uni-stuttgart.de/fem/Tutorial8_Crash_SimpleTruck/Explicit/Truck_Front.pc). If you forward-search for "PART", you see between the words "PART" and "END_PART" an example for a card. Every second line is a comment, explaining what field is below it (although the exact columns might be off, it's not unusual). E.g. the word "DTELIM" means that the "0." below it denotes the parameter value of "DTELIM" for this particular card. &gt; &gt;The static definition for this particular card is [here](https://github.com/KillTheMule/nvimpam/blob/master/src/carddata/part.rs#L86). I don't think a lot will be recognizable, however this static definition says e.g. that [the first line](https://github.com/KillTheMule/nvimpam/blob/master/src/carddata/part.rs#L13) starts with the keyword (which is "PART / " here), and then has 6 fields of length 8 with different types, and thusly ends after colum 56 (you will notice it is of type `Provides` in my code; that means that the line carries some additional information I need to parse and save for later use). &gt; &gt;Now that I have the start of the card in the input file, as well as my static definition, I can compare them to do several things, think e.g. of syntax highlighting. Right now, what I do is count if the number of lines in the file fits the static definition, and if yes, I tell the editor it can fold the card into one line for a better overview. &gt; &gt;Does that make more sense? I hope I did not write too much :) It doesn't help make more sense of your original question, but it does help me ask a subsequent question. I'm assuming there are two data inputs, and one data output. One data input is considered static at compile-time, but there are many variations (a spec for each type of pamcrash). This means you must recompile for every different type of pamcrash, and it's effectively a different plugin each time. The other data input is dynamic at run time, where you use the definition provided at compile time to generate the output (which neovim wants back). So, my question is now, what is the output? If I were approaching this problem, I would go one of two directions, but it appears that you're somewhat halfway between the two. The first would be to not have the specification read at compile-time, and instead read at runtime, perhaps caching the parsed version, or even caching said parsed version with a 1-off as a post-compile script. The second would be to have the parser represent the specification using code generation. The parser-state becomes just the execution model, taking the input and simply spitting out the format neovim wants. The cards and cells become functions, not represented in readable memory, but rather executable memory.
Based on this example from the [`by_ref`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.by_ref) function, the following should advance the iterator using only `take`: ``` let a = [1, 2, 3]; let mut iter = a.into_iter(); let sum: i32 = iter.by_ref().take(2).fold(0, |acc, i| acc + i ); assert_eq!(sum, 3); assert_eq!(iter.next(), Some(&amp;3)); assert_eq!(iter.next(), None); ```
Ah, sorry I am a bit tired and missed that. In this case I think `some_iter` would be invalidated in this case (as it is taken by value). Taking `some_iter` by mutable reference as nightcracker suggested works as intended though.
point 3 is pretty stupid: I once "found" such panic call when my web-server daemon failed, just because author of xml parser library had that "brilliant" idea to panic if parser made something "impossible". Ok, you have an error in your parser, but my web-server would survive it easily, just return the fucking error, don't panic just because you can.
I personally have Travis build artifacts for all the targets I need, using https://github.com/japaric/trust (That's the only way to write that answer so I don't have to mention that `cross` is based on Dock– damn)
This may not be the Rustiest solution but it's the cleanest I could come up with: const CHARS: &amp;str = "URDL"; // we know the string is always ASCII so indexing is fine if let Some(d) = CHARS.find(expression).map(|i| CHARS[I]) { //... } Or if you're fine with having `d` be a string instead of `char`: if iet Some(d) = "URDL".matches(expression).next() { //... }
Yes, the trait `Iterator` is implemented for any `&amp;mut I` where `I: Iterator`. So in this case `self` is actually `&amp;mut I`.
In that case you can also find the origin commit (by `git log`) and copy the hash, then you can `git rebase $HASH` your branch. And yes, I meant `git push origin mybranch`. Thank you, autocorrect... 
As you can see here the `Iterator` trait is implemented for `&amp;mut I` where `I: Iterator + ?Sized`, which means that the `take` implementation for a `&amp;mut` Iterator takes the mutable reference instead of ownership. 
Huh. TIL.
In Chrome, the "fancy" editor is almost impossible to use. When editing, it's zooming in waay too much (1cm font height, roughly). When trying to select text, I cannot mark the text I'm trying to. The browser-builtin popup for actions on selected text covers the selected text, and does not go away until I reload the page. When pressing enter, the last character of the last line is removed... Going to simple editor, the zoom problem is still there (and highly annoying), but it's at least usable. But, great news; I tried installing and running Firefox instead (on my Fairphone 2), and even the zoom works (decently)! It's still not a perfect mobile experience, but perfectly usable, and works for my needs :)
I think the better question is, why do you think what you're doing is legal? I don't see any reason to believe that `Arc&lt;u8&gt;` and `*mut u8` should have the same representation in memory, so I therefore think you're use of transmute here is UB. If you want to convert between `Arc` and raw pointers, then use [`into_raw`](https://doc.rust-lang.org/std/sync/struct.Arc.html#method.into_raw) and [`from_raw`](https://doc.rust-lang.org/std/sync/struct.Arc.html#method.from_raw).
I believe they do have the same in memory representation: https://doc.rust-lang.org/src/alloc/sync.rs.html#201-204 And again, since the Arc with null as a pointer is never used, it should be fine. Perhaps the NonNull in the Arc struct definition is to blame. If i could use from_raw with just a junk value as the pointer perhaps I could avoid the transmute, but I'm not sure if that'll lead to a run time error.
The issue is that you're synthesising invalid values out of thin air. **Don't do that.** The crashes are probably because the code is trying to destroy an invalid pointer. You shouldn't be using `unsafe` unless you know exactly how everything anywhere near that `unsafe` works, plus everything in [the nomicon](https://doc.rust-lang.org/nomicon/).
Also, what you've linked to shows that it's a non-null pointer to an `ArcInner&lt;T&gt;`, not a pointer to a `T`. Even if you were not putting a null in there (which is still UB even if you don't use it) it would also be undefined behaviour to cast (and then use) a pointer to an `ArcInner&lt;T&gt;` to a pointer to a `T`, as they definitely don't have the same representation. It seems like you're jumping to use unsafe code here when there's really no need. If you want a "nullable" reference counted pointer type, then use an `Option&lt;Arc&lt;T&gt;&gt;`. If you can't make the compiler happy without writing unsafe, then it probably means your code is actually wrong, not that you need to use unsafe. If you have some working code that is completely safe, but need to make it faster and believe you can do a better job than the compiler at optimising it, *only then* consider using unsafe code.
Transmuting null pointer to Arc, which internally uses NotNull is UB. Debug printing Arc dereferences null pointer, which also is UB. If you want nullable Arc you probably should Option&lt;Arc&gt;. Because of internal usage of NotNull, Arc and Option&lt;Arc&gt; will have the same size. You can read more on what UB is and when it appears in [reference](https://doc.rust-lang.org/reference/behavior-considered-undefined.html) and more on transmute in [nomicon](https://doc.rust-lang.org/nomicon/transmutes.html)
`unsafe` is for when you know what you're doing and you need to do something you can't do with safe code. If you use it as a substitute for learning the normal way to do things, you'll have no end of trouble. If you want a smooth Rust learning experience you shouldn't type `unsafe` for the next year or so. Depending on [what you are actually trying to do](http://xyproblem.info/), what you want is going to be more like Option&lt;Arc&lt;Node&gt;&gt;.
The example I gave doesn't debug print the Arc, it debug prints the pointer that the Arc is composed of (or, thats what I thought it should be doing).
Thanks for your hard work! :D
The major difficulties I had with Futures were how lifetimes interact with them, it made it really hard for me to get shit compiling.
https://doc.rust-lang.org/stable/src/alloc/sync.rs.html#1384-1388 impl&lt;T: ?Sized + fmt::Debug&gt; fmt::Debug for Arc&lt;T&gt; { fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result { fmt::Debug::fmt(&amp;**self, f) } } If you _have_ to have an unsafe `Arc` around, you _need_ to use [`ptr::NonNull::dangling`](https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.dangling) instead of [`ptr::null`](https://doc.rust-lang.org/stable/std/ptr/fn.null.html). _However_ in this case you're handing off the unsafe `Arc` to `&lt;Arc as Debug&gt;::debug`, which (rightly) assumes a safe `Arc`, so will be undefined behavior if you give it a unsafe `Arc`. Use `Option&lt;Arc&lt;T&gt;&gt;` for this. `Arc` cannot be a null pointer such that it is _guaranteed_ that `Option&lt;Arc&lt;_&gt;&gt;` is represented as a nullable `Arc` (`None` == `ptr::null`, `Some(arc)` == `arc`). In 99% of cases you shouldn't be writing `unsafe`. You should _never_ unsafe without profiling to make sure it's necessary for performance over the safe solution -- LLVM does magic optimising Rust programs _because_ of these strict guarantees provided by the language (or you when writing `unsafe`).
`Option&lt;Arc&lt;T&gt;&gt;` won't work because I need to atomically change the value of `Arc`s. From what I've found, that can only be done by leveraging the fact that Arc is internally represented as a pointer, and using the `AtomicPtr` that is in the rust standard library (unless I were to use some sort of transnational memory library). I need to use an `Arc` instead of just a pointer for garbage collection. Though there is a place that I can place an option, i wanted to avoid it because it will only be empty for a short amount of time, then from that point on it will absolutely have a value, but unwrapping code will have to run anyways. Will probably do that now just so I have something that actually works, and I'll figure out a better solution some other time.
Either way, you created what Rust thinks is an `Arc`, and when it's time to destroy that `Arc` (which is pretty soon, since you're not storing it anywhere), it will call the `Drop::drop()` implementation on `Arc`, which will definitely dereference the pointer.
The code example I have prints the pointer though, not the Arc, so the Arc's debug implementation doesnt get ran. I didn't know about the `NonNull::dangling` function, thank you! I am using unsafe because I'm writing a concurrent data structure for a class, there are a lot of points where unsafe code just seems to be the most straightforward solution. I'll have to just write a safe(er) version so it actually runs.
Actually I handled that case in my code.
Actually, if you didn't want a panic in the XML parsing code to crash your web-server, you should've used "catch\_unwind". A panic can happen in nearly any code at any time. If you want to be able to recover from panics, it is up to you to code the necessary logic. That is what "catch\_unwind" is for.
I think even C compilers check const-ness of intrinsics pre inlining, but I am not sure.
No, panic can't happen in any code, in Rust it can happen only if you call panic() or use things like unwrap(). Some people write code like trash (they just don't care) that's why their code should be wrapped with catch_unwind. But it's not a rule, it's just bad code.
Here's some code that does what you want: [link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=fb6bd48b1d3859aeadcb538f88fc696d), but unfortunately it doesn't implement Iterator. You have to call `next()` explicitly. I've run into this problem a few times; it's hard to use Iterator when you want to return a ref to something internal, because then you need to specify a lifetime, and the Iterator trait doesn't allow you to specify an explicit lifetime.
Even after the floating windows working so well, I was not expecting 1:12. Bravo &amp;#x200B;
That is not correct. You need to go read up on panic and what can and can't panic. Anything that performs standard math ops can panic (depending upon compiler flags etc).
well, bitching about integers overflow doesn't make you look smarter. My point is simple: when people write "panic()" just because they can - it's shitty code.
What is wrong with you? Seriously?
Answer for yourself.
OK, since you are determined to be an asshole, let me tell you something. Keep being a smart-ass. My name is: Gerald E Butler 2807 Summit Road Copley, Ohio 44321 Feel free to come by and visit me and I'll teach you some fucking manners you worthless fucking prick!
Hey now, perhaps we've misunderstood one another's motivations here. Ham and Wine? Now we're talking. If you ever do get to Ohio, USA, I'll be happy to offer up some local beer, wine, and queso.
ripgrep can do multiline replacements, but it will just write the result to stdout and won't modify the file for you. e.g., $ cat short.txt THE HOUND OF THE BASKERVILLES By A. Conan Doyle Chapter 1. Mr. Sherlock Holmes Mr. Sherlock Holmes, who was usually very late in the mornings, save upon those not infrequent occasions when he was up all night, was seated at the breakfast table. I stood upon the hearth-rug and picked up the stick which our visitor had left behind him the night before. It was a fine, thick piece of wood, bulbous-headed, of the sort which is known as a "Penang lawyer." Just under the head was a broad silver band nearly an inch across. "To James Mortimer, M.R.C.S., from his friends of the C.C.H.," was engraved upon it, with the date "1884." It was just such a stick as the old-fashioned family practitioner used to carry--dignified, solid, and reassuring. "Well, Watson, what do you make of it?" $ rg '\w{6}\n\w{2}' short.txt -U --passthru -r $'foo\nbar' 1-THE HOUND OF THE BASKERVILLES 2- 3-By A. Conan Doyle 4- 5-Chapter 1. Mr. Sherlock Holmes 6- 7-Mr. Sherlock Holmes, who was usually very late in the mornings, save 8:upon those not infrequent occasions when he was up all night, was foo 9:bar the breakfast table. I stood upon the hearth-rug and picked up the 10-stick which our visitor had left behind him the night before. It was a 11-fine, thick piece of wood, bulbous-headed, of the sort which is known as 12:a "Penang lawyer." Just under the head was a broad silver band foo 13:bar inch across. "To James Mortimer, M.R.C.S., from his friends of the 14-C.C.H.," was engraved upon it, with the date "1884." It was just such a 15-stick as the old-fashioned family practitioner used to carry--dignified, 16-solid, and reassuring. 17- 18-"Well, Watson, what do you make of it?" 19- screenshot: https://imgur.com/a/It2531Z With that said, I think having a dedicated tool for this is great! You'll also want to check out https://github.com/SuperTanker/ruplacer and https://github.com/facebookincubator/fastmod
If you l'île the tui mode, you may love [gdb-dashboard](https://github.com/cyrus-and/gdb-dashboard)!
Does this been we'll get `std` docs?
It's UB, believe me it's extremely hard to make a AtomicArc, I tried for far too long before using ArcCell from crossbeam, it's the best you can get while still being safe.
Why the hell does this work in serde? I have this struct ``` DataContainer { field1: String, field2: Vec&lt;String&gt; } ``` This is the format of the "JSON" ``` [ "item1", [ "listItem1", "listItem2" ] ] ``` And when I parse the JSON, serde correctly does what I want it to. 
I guess where I'm going is this: your current organization (based on my not-too-detailed reading) seems like you're doing a fairly superficial parse of some textual data into rust data structures, after which you'll do more meaningful processing at run time. It's generally much better to figure out *how you want to use* the data, then encode it in a way that's conducive to that. In other words, first design the API for using the data, and then work backward from there to derive a good organization. Then put the work of converting text file -&gt; data structure into the build process. This has some other benefits too, like if you want to change your program to load/switch that data at runtime, then your API doesn't change (at least not much); you just need to move the text-&gt;data structure parsing from the build system to your main codebase. The only way you can paint yourself into a corner here is if you design your API poorly- in that case, just think carefully about it, and work through all the uses you will make of it in the rest of your program.
&gt; termion Wow. Just what I need. Thanks! 
Oh, very clever! This lets you replicate chunks from slice, do you know if you could do window as well with something similar? I suspect maybe not.
Also note: even if you were to get what you wanted (atomically swap an Arc) you would still be left with a race condition: it's not possible to atomically update an Arc whilst other threads may be reading from it, because cloning an Arc is not atomic: it first reads the pointer from the Arc, and then dereferences the pointer. This means that your thread swapping the Arc may drop the old Arc whilst other threads are still reading from it. This is a very well studied problem, and the only wait-free solutions are to introduce some kind of tracking on the reader side, via hazard pointers, epochs, or some similar mechanism. Check /u/pleurplus's response for some examples of these solutions in Rust. I don't recommend you try implementing them yourself, unless you want to spend a good deal of time learning about this stuff.
You mean use `.window` method on a slice? 
Thank you for such a detailed answer:). However, Im still not convinced completely. I would like to know the use cases of such pattern. Jumping to rust-lang IRC. Thank you.
*Hopefully* anybody willing to use a package called "eat my data" knows enough about it to tell when it's appropriate.
if you have to stop using all Microsoft products, it's like cutting your own nose to spite your face. If this were on Github I would have loved to make a few pill requests. Anyway, maybe stop using virtual consoles because Xenix introduced them, or your camera because it has fat32. Or R because Microsoft owns it. 
&gt; Okay if I really do this I should go and see an psychiatrist I am not sure where does this sentiment comes from. Back in the good old days we had Borland C++ IDE in DOS terminal using [Turbo Vision](https://it.wikipedia.org/wiki/Turbo_Vision) -- it was a masterpiece! I was kind of disappointed by (n)curses TUI interfaces when i switched to linux (~2000) -- they seemed so pedestrian compared to what has been available in DOS. Midnight Commander was a far cry from DOS Navigator's TUI. I don't think anyone needs to see a psychiatrist here. The bar that has been set in mid 1990's is yet to be reached in 2018!
Gitlab is a superior product. You'd be silly to not use it.
Exactly. GitHub might have a nicer interface, but GitLab has free private repos, open source self hosting and mirroring. Thanks for having my back /u/mmstick :)
Why is it a problem to create GitLab account? Also, the author made a choice to use GitLab so if you want to submit a PR to _his(er)_ project -- it would be good to respect the author's choices. Microsoft will need to do many more good deeds before people change their mind. Rome wasn't built in a day. Would you start believing a pathological lair after he said first thing that is true? 
That's the thing, I don't even mind GitHub. I have a GitHub mirror for most of my projects, including this one, and always accept PRs from both. Some people just assume everyone is out to hate them and their favorite products and get all defensive :|
&gt; Currently, Docs.rs is rebuilding every crate that have failed to build since last rustc update. When will that be complete?
Thank you, posted there too! After putting myself through this insanity I need that karma to heal :P
I'm guessing it's related to llvm failing to optimize out bounds checking.
Shouldn't underestimate the importance of the interface, though. I'd use gitlab in a heartbeat but i just *can't stand* the interface, i find it confusing and hard to navigate and just weird.
I'm not asking you to trust them, I'm asking you to have some integrity and stop using them everywhere and not just where you can pretend to be superior.
This looks really cool, thanks!
I'm quite happy that this database is still under development! Congrats on the new version. I'm still waiting for: * A benchmark * Support for dynamic sized data
Dumb question but what is WM? 
Window manager.
Cool, thanks
You're going to need to interface with the C++ compiler because only the C++ compiler knows how to call C++ functions. Last I checked, that hadn't changed. (The way to call C functions is standardized. That's why you can call a C dynamic library so easily from so many languages. For other compiled languages, it's not standardized like that. That's why, when C++ programs intentionally expose APIs for other languages, they use `extern "C"`.)
&gt; I’m not sure what the initial intent was about with this type, but in order to use it, I had to add the `proc_macro_span` feature. Judging by the discussions I've seen in RFCs, it's for allowing proc macros to produce error messages which tell you where the invalid syntax is when something is accepted by Rust's parser but makes no sense in the proc macro's DSL.
crates.io has updated its compiler toolchain and is rebuilding a lot of crates right now. So it probably has a rather long backlog at this point, but it will get to your crate eventually.
You can find out if a call will panic in the documentation. Over time you just kinda memorize which calls can panic, they're usually pretty straightforward. For example, the documentation for std::option::Option's [unwrap](https://doc.rust-lang.org/beta/std/option/enum.Option.html#method.unwrap) method says: "Panics if the self value equals None."
you can use the streaming-iterator crate. I've used it successfully [here](https://github.com/wagnerf42/grouille/blob/master/src/utils/iterators.rs).
I didn't try IntelliJ but VSCode doesn't support multiline substitution (regex starting with (?m)).
Docs.rs is being migrated to the nursery, might be related to that 
TBF the library could be built in C++ but expose a C interface, at which point it *would* be callable pretty directly from Rust.
A lot of other people are going to tell you that you can't do it, or not reasonably. My question is, what functions do you want to call, and why? What's the problem you're actually trying to solve?
Doc.rs has been [https://www.reddit.com/r/rust/comments/9q41wv/_/e86ne5q?context=1000](rebuilding a lot of crates) due to some changes to how it works with rustdoc so yours probably got caught in the queue. It may or may not be updated by the time you read this but I recommend patience. You are getting this for free, remember.
Since this seems to crash on release and not in debug, I think the issue is with a compiler optimization. Specifically, `Arc` contains a `NonNull&lt;&gt;` pointer (https://doc.rust-lang.org/src/alloc/sync.rs.html#201-204 as you've pointed out). Since you are using `mem::zeroed()`, you're making a null non-null pointer. The compiler is allowed to assume this cannot happen, and thus you've invoked UB. This code invokes UB 100% of the time it is run _simply because an `Arc` exists with a null NonNull pointer_. Since it is always UB, the compiler optimizes it down to an illegal instruction! That's shorter byte code than having anything else happen, so why not? The compiler assumes this case cannot happen (NonNull containing a null pointer), so when it does, an illegal instruction is a completely valid thing for it to do.
I've been using `musl` to run my Rust on an ancient RHEL6 box. Works perfectly!
You learned VB4 in 2012? Not even VB6? You poor soul.
The main reason is to consider the update of the library in the case we used. We hope that after the C++ code is updated, we can record the different versions of the update. Moreover, the use of dynamic libraries has a small capacity, which helps to reduce the burden of background services. I don't want to use cc crate to compile in rust, I want to make rust and c++ code make different people responsible.
This is similar with Futures, and many of those do panic on subsequent use.
That's my favorite way to do it as well, but some people prefer using `gen_range`, which is equivalent. (However, it does not permit reusing the `Uniform` struct and can thus be slightly less performant in some situations.)
Update: https://blog.github.com/2018-10-21-october21-incident-report/ GitHub webhooks have been down during the issue, though actual git access is fine. So crates should be functioning normally during these issues while docs.rs, if it's running off of webhooks, will likely miss anything published during the incident. GitHub is claiming they'll be back up and serving consistent data by 8:00 EDT. Depending on how many back-events they do, it may take some time for bots and automation to return to speed beyond that. If we're lucky, we'll get a more in-depth postmortem after the incident is resolved. I know I'd be interested in what led to the over 12 hours of service issues. (Maybe it'd help to RIIR /s)
This is very nice! Well done.
The official resources: https://doc.rust-lang.org The most important being The book: https://doc.rust-lang.org/book/2018-edition/index.html and Rust by Example: https://doc.rust-lang.org/rust-by-example/index.html
Even if you will not use it all the time, it is still useful to go through the 2018 book. You will go over a few concepts that will refresh your memory, and also learn to watch for the meamory leaks, prevent data races,... , and learning how the borrow checker works makes you think twice when working with anything else
Do you have a use-case in mind for a merger that would panic? If you're panicking, enough things are already on fire that you shouldn't be worrying about discarding an entry in a map. Your map entry will get dropped and cleaned up as the process exits anyway. This isn't worth introducing unsafe code imo (again unless you have a particular panicky merger in mind that would benefit from this somehow).
if you're serious, try this: http://shop.oreilly.com/product/0636920040385.do it has really helped fill in the blanks from the official book, espcially in regards to slices, strings and vecs
In that case, are you able to ask the people responsible for the C++ code to expose some `extern "C"` stuff? Then both the Rust and C++ code would be communicating through the common standard of the C ABI.
I'll continue preparing my workshop (now at last knowing the topic will make this much easier ☺), update TWiR and find some other stuff to work on.
Is it impossible to operate without exclusively depending on github? This feels like putting all your eggs in the same basket. Monoculture is almost never a good idea.
For my long-term personal project I needed some kind of stateful fault-tolerant isolated subsystems communicating via messages. Moreover these subsystems regularly perform some data processing using and updating their state. I tried actor libraries (actix and riker), but none of them satisfied my needs. Supervisors in actix don't supervise panics, and it seems it's impossible to implement proper thread restarts externally, and riker doesn't have much docs so it's not even clear how to make sure actor is running in its own thread. So I decided to roll my own version of actors. Mostly finished the basics and the last thing missing from first working implementation is a supervisor owned mailbox to make sure every message was processed successfully (not lost due to panics during message processing).
I bought this, it has been good so far. What's a laugh is that I used to buy e-books directly from O:Reilly, but now you can't, you can only get it though Safari with them. So I bought it through Google instead, so they made less money.
Go is based on lifelong experience of some of the greatest minds in computer science and practice. The Bell Labs Computer Science Lab historical wisdom was brought to Google by Pike, Thompson. Richie, Cox et al. Griesemeier brought in some very influential work from ETH. Other members of the team are as clever. A million small and big things flow from this. The “implicit interface” concept and the “type embedding as inheritance” concept, and the goroutines/channels are the most important. But there are a hundred other details done right. Explaining every one of them would be tedious. They form an orthogonal harmony without creating unnecessary complexity. I don’t claim to understand the beauty of all the details. I learn every day. A telling example is, that Rob said that it took a very long time to get the slice concept right, to fix the classical C confusion between array indexes and pointers. I suspect there are some instincts that resulted in designs that even the creators didn’t appreciate fully until later. No feature was left out without a reason. These guys certainly know everything of language theory, operating systems and hardware. Everything that is in the language and everything that is missing has been carefully thought out and balanced with complexity, which costs as optimization difficulty, tool design difficulty, slow compilation, bugs and security vulnerabilities, learning curve and rigidity for future changes.
I've posted this project here before but many people have joined the community since then. It's pretty [well documented](https://docs.rs/static_assertions/) with both passing and failing examples. As of v0.2.5, it lets you assert: - One or more `const` expressions evaluate to `true` - A type implements a given set of traits - Multiple types have the same size - A type has a given field - A `#[cfg]` option is set - A trait is [object-safe](https://doc.rust-lang.org/book/2018-edition/ch17-02-trait-objects.html#object-safety-is-required-for-trait-objects) I hope you find this to be useful! Feel free to [let me know of other assertions](https://github.com/nvzqz/static-assertions-rs/issues/2) you'd like to see implemented, preferably with real-world examples/use-cases.
"Go: 90% Perfect, 100% of the time" https://talks.golang.org/2014/gocon-tokyo.slide#1
&gt; Is it impossible to operate without exclusively depending on github? This feels like putting all your eggs in the same basket. Monoculture is almost never a good idea. It is possible to switch off of github with little trouble. (Adleast for Cargo and Crates.io) As we can switch to any other git host. We can even host the git index ourselves. But GitHub is free and very well cached around the world, and very likely to already be let thu a developers firewall. Moving off using git as a communication protocol between a Registry and Cargo would be harder. And would mean that we are the unique snowflake that is making its own standard without the help of other communities. (But may be worth doing anyway.)
A vector is passed to these two functions, one taking a reference and the other isn't. I know a vector is some kind of data structure, probably containing a length and a pointer to a length of memory in the heap. But what confuses me: is the "&amp;" doing double duty as a borrow operator as well as passing the memory address to the vec data structure, and is the non borrowed version just doing a copy when passed into the function? If the above is correct, does that mean its impossible to pass a reference to a function without a borrow? In other words, if I pass a huge struct (I'm using a struct because I think there's no fancy indirection like a vec lurking behind the scenes), is it impossible to pass it to a function as a reference but give that function ownership as well? fn pv(v: Vec&lt;i32&gt;) { println!("{:?}", v); } fn pvr(v: &amp;Vec&lt;i32&gt;) { println!("{:?}", v); } fn main() { let v = vec![1, 2, 3]; pvr(&amp;v); pv(v); } &amp;#x200B;
I am going to try to go over some documentation or finish up implementing `Display` for [`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis).
OCaml is one for sure. The original rust compiler was written in it and shares lots of syntax and features. &amp;#x200B;
See the [influences-section](https://doc.rust-lang.org/reference/influences.html) of The Rust Reference.
lol and git was intended to be decentralized
&gt; no reason not to use proper X11 WMs That's what Microsoft thought when they rolled out windows. Look at us now. In remote server management console reigns supreme. I could name a dozen or so server management apps could benefit from TUI option in addition to 1000s of command line parameters...
Thank you so much! It means a lot. I'll take those things into consideration, especially the part about the images. I feel like code examples would've been a good thing too, but I couldn't figure out how other people were doing it, so I didn't do it myself. My GitHub stuff is at https://github.com/NateDogg1232 but nowadays I use GitLab and my account there is https://gitlab.com/NateDogg1232
Yep. Back then I took what I could get, haha.
Thanks for reading!
Is there an idiomatic way to remove multiple elements at arbitrary locations from a vector? I've got a program that uses a vector to keep track of network connections in order to know which hosts to send updated information too. If the connected client closes, I remove the connection from the vector the next time the program tries to communicate and gets an error. To do this, I keep a vector of the indexes of terminated sessions, which is then used to know what to remove. Here's the code for removing the bad connectsion (bad_conns is a vector of indexes, rc_vec is a vector of registered client connections): let mut shifted = 0; for bad_conn in bad_conns { if bad_conn &gt; rc_vec.len() as u32 { continue; } rc_vec.remove((bad_conn - shifted) as usize); shifted += 1; } It works fine, but is there a way to do something similar to remove(), just with multiple indexes? It'd be less prone to copy/paste errors and make the code clearer.
I think you want r/playrust Might wanna delete this before you lose a ton of karma.
A program which gets prices from my mysql database (in EUR), changes them to Bitcoin, shows a BTC payment request QR and waits to receive the BTCs in order to send a GPIO signal. 
One of my colleagues has it on his desk, he's also very positive. 
Your code currently works only if `bad_conns` is sorted in ascending order. Sort it in descending order instead, then do just this for bad_conn in bad_conns { rc_vec.remove(bad_conn); } Alternatively, use `HashMap` instead of `Vec`, or use [slab](https://crates.io/crates/slab) or [slotmap](https://crates.io/crates/slotmap) or a similar data structure.
Is there a way to fix the "cannot have partial borrowing when using accessors"? There should be something like Haskell's "pattern matching views", so that you can use "match" syntax against different inner states and/or define abstract "partial borrows", and have all of these use accessor functions under the hood, irrespective of the actual type definition. But I assume this would require changes to the language itself?
arg, you're right, sorry, total brain fart. Indeed, `flat_map` does look more useful. Thanks for the tip and for being patient with my wrongness :-P
Are there any resources that go into detail on defining structs with life times? I have read most of the available documentation, and am comfortable working with lifetimes in other scenarios, but when I am trying to define my own structs that intended to hold references, I never feel like i am doing it correctly and end up cloning values instead.
# Join https://discordapp.com/invite/rust-lang instead!
I've been meaning to start following along with these posts. Would you say it's a good way to learn Rust, assuming senior-level with other (albeit non-system) languages?
I just hate the lack of mono space font in code examples. I love the book though. 
Nice post, I started with VB4 too,,good times ..
Still working on polishing up the [Atlas Coverage](https://github.com/samsieber/atlas-coverage) tool that work let me open source. It's for converting code coverage data on minified javascript files into code coverage on the original files, by traversing the source map files. I'm working on the node integration and adding a documented example project. I'm also working on a small SMS driven budgeting app. Sort of SMS driven (via twilio/maybe plivo). Uses SMS for basic data entry and notification, but actually stores everything in google spreadsheets for easy access / editing / manipulation. Using warp and sqlite for the http server &amp; data storage.
down for me too
Thanks for the tip, I'll take a look at those.
"Also keep in mind that such an RFC would not only need to describe why this is a change we want, but also why it is important to prioritize this right now" That statement poisons the well. It very clearly and effectively says: "You need to make an RFC to achieve change. And make sure to address the fact that your RFC is pointless and/or already presumed to be low priority." It lays out the team's objections to the supposed RFC even while ostensibly encouraging it. That you think this is an example of encouraging discussion leading towards an RFC id really tone deaf.
There is some ideas on [borrow regions](https://github.com/rust-lang/rfcs/issues/1215#issuecomment-333316998), but they don't have enough traction yet.
I think that Docs.rs becoming a rust-lang-nursery project is just to awesome for the Github Universe to handle, which is why both services are experiencing issues right now.
I would like to know as well!
I think if you have no experience with this subject and rust either then it is probably not the easiest method. You will be learning two things at the same time and one of them will be expressed in rust which you don't know. I am not saying it's a bad idea but there are probably better ones:)
I mean I have a degree in CS, I just haven't worked on any system stuff professionally.
i know right, I got it through the humble bundle, book is a seriously good resource though, easily worth 30 bucks. The only downer is the language still moves super fucking quick at the moment.
Thanks for pointing out the typos. I'll have a look at jsonwebtoken 👍🏽
Oh that's not great, thanks for the link. I will get that sorted ASAP
The closest thing is either doing let destructuring or mem::swapping in temporary values.
Yeah it's got diagrams on how slices and smart pointers are actually mapped to memory, so it actually digs deeper into the "plumbing" side of things without getting bogged down in the theory and talking about how great rust is.
References inherently borrow. "Passing an argument as a reference but give ownership" doesn't make any sense in Rust. &gt; is the "&amp;" doing double duty as a borrow operator as well as passing the memory address to the Yes, that's one way to think about it.
It's certainly not the best way because it explicitly removes whole chunks of the standard library, doesn't explain the features it *does* use in detail, and isn't how you normally write Rust anyway.
My hobby project is a game with low poly art style. THE plan is to make a roguelike but in real time. Last week I was learning how to do everything on a Rust way as I was trying to design components using C++ habbits. I thonk I got basics. This week I am working on a simple OpenGL renderer with flat shading.
I I haven't used Diesel yet but, from my experience with other ORMs, I can guess one possible reason: Typically, SQL tables have lowercase, plural names (eg. `persons`) but ORM models have titlecase, singular names (eg. `Person`). It's possible that, for lack of explicitly being told what table names to use, Diesel is generating best-effort plurals from the model names.
&gt;faliure fixed
I see - this makes sense. I’ll stick to optionals for now then. Thanks for the explanation!
Thanks for the feedback, guys. I think using a `while let Some(x) = it.next()` loop is a good solution!
Do you have a schema set up? The schema creates a bunch of types under the hood.
Correct, but those types are generated from macros that define the schema, which OP doesn't appear to have.
Thank you kindly, stranger! I knew about `rustup doc` and then I gave up, but it always bothered me that I couldn't view docs for non-std crates this way.
Actix might be what you're looking for. It's a library implementing the actor model.
This is more a property of the toolchain rather than Rust, but yes: https://rust.godbolt.org/z/ZKQN5C
Rust for Jupyter (https://github.com/google/evcxr/tree/master/evcxr_jupyter) is awesome for playing with Rust! Standalone single notebook works. Importing things from extern crates works. But... how can I start a notebook in a project dir /src and locally import some subfunctions from .rs files? use ::foo::* does not work for me :-( Either this is not implemented or I'm missing something?
Rustc is smart enough to only store it once and reference that. [example](http://godbolt.org/z/SCliUP)
Others have shown how to solve the immediate error, but imho it would make sense to refactor the loop into iterator and `collect` the vector from it
This is what I have in my [schema.rs](https://schema.rs) file. It was autogenerated when I did \`diesel migrate run\` I believe. &amp;#x200B; `table! {` `address (id) {` `id -&gt; Int4,` `housenum -&gt; Int4,` `street -&gt; Varchar,` `}` `}` `table! {` `person (id) {` `id -&gt; Int4,` `address_id -&gt; Nullable&lt;Int4&gt;,` `name -&gt; Varchar,` `age -&gt; Int4,` `qualified -&gt; Bool,` `}` `}` `joinable!(person -&gt; address (address_id));` `allow_tables_to_appear_in_same_query!(` `address,` `person,` `);` 
Ok so I'm not crazy, down for me as well.
http://docs.diesel.rs/diesel/associations/trait.Identifiable.html#deriving Second paragraph
I am not an expert but your "causality" line item might be a real problem, since that implicitly says that each send operation needs to be synced with other ones, in potentially very complicated ways.
using underscore as a word split character is a nice feature...but feels like it's a surprise as it is. In my own work I've found dozens of edge case system where I may want one type of split while not another. My final solution was to build two split functions (split and split\_with\_punctuation). The first just does what you think it would. Splits on whitespace and whitespace related characters. &amp;#x200B; The second takes a data structure with options (do you split on hyphens for example)? 'low-tier' should be one 'word' but - and this is important - that should not be split into blank splits. Underscore is another example I use, etc etc. In my function I build up a split regex, compile it, then store it memoized based on the data structure input. Slick as snot and gets the job done nicely. Also, some nice additions would be things like Levenshtein distance or some of the other fun querys.
Not really contributing to the OP discussion, but I just wanted to be a dorky friend for a second and shout out to my buddy /u/ricochet1k for pushing the `lifetime` fragment specifier to completion. :)
 https://reddit.com/r/rust/comments/9oa2zs**//**hey_rustaceans_got_an_easy_question_ask_here Just an FYI, link to the last week's thread has a spurious '/' that's breaking it.
It just requires each send to be sync. A sends to B, wait for ACK B received from A Then A sends to C etc. Unless I missed something. Now now, if he wants the whole thing to be kind of async it would be much harder
Interrupts would be used to execute code that signals some queue that can be checked by an Event loop elsewhere. So the answer would be that a future could register a check to poll for such an event.
I can't tell you how to use it, but I can tell you what I wish for here.. I hope they can make a solution for emulating C++ style 'thin pointer objects' reasonably eventually: they can be hacked via unsafe code (in a way which has no guarantee of future support) but imagine if there was a safe way to describe the vtable pointer for a type and trait, and to assemble a trait-object from such a pointer and data. Then you could imagine some middle ground where some subset of C++ interfaces could be called (there's a lot of code that does stick to single inheritance) , if they dont take/return collections in their interface etc.. and where Rust could expose C++-friendly objects aswell. Whilst far from perfect I think this would be a step up from *just* C interfaces (although those are a pretty good baseline) 
This is a bit difficult to answer, because everyone learns in a different way. For me, operating systems had always been fascinating and experimenting with an own little OS kernel was a great way to learn Rust. So I certainly won't say anything to discourage you. If you are interested in operating systems and interested in Rust, why not give it a try? The blog isn't written as an introduction to Rust, but I tried to explain more advanced Rust features or at least provide links for them. I would recommend to keep [the book](https://doc.rust-lang.org/book/second-edition/index.html) open in an extra tab in case you find a Rust feature confusing. And always feel free to ask questions (e.g. in the comment section below each post).
Hey, being happy for your friend is awesome! It's good work. :D 
I'm not sure if I agree that it's a nice feature: it feels like a major limitation to me. It makes more sense to take some predicate function which takes a single character and returns true if the character is a separator. 
This looks great! I have clients who still have key workflows built in Excel &amp; VBA macros. Some of this is numerical and simulation code which Rust is a great fit for (I've used C or C++ in the past), but the COM wiring is always tedious. The approach to Variants is similar to something I started experimenting with and neglected a while back and looks very convenient. I'll give this a shot next time I have to interact with the Excel world!
&gt; This means you must recompile for every different type of pamcrash, and it's effectively a different plugin each time. No, sorry, I've not explained it properly then. All the "types" (I assume you mean what's called "card" in pamcrash) can occur together in an input file, it can call be mixed somewhat arbitrarily (most input files only use a certain subset, though). There's no need to recompile, I just need a static definition for each "type". &gt; and instead read at runtime That's certainly possible, but I'm not sure how that would improve the situation. I'd still have to define one or more types that represent cards in my plugin, and then make instances of this type via the data I read in. This is basically what I'm doing right now, just at compile time. &gt; The parser-state becomes just the execution model, taking the input and simply spitting out the format neovim wants. The cards and cells become functions, not represented in readable memory, but rather executable memory. That sounds... like I don't understand it :D Maybe you could give a small example, or do you know some other code that implements something like this?
Glad to help! I saw a lot of answers for why this wasn't a good idea in general but not much explaining the exact reason this code gives an illegal instruction.
Awesome! I hope its useful for you. Let me know if you have any questions or issues! 
My comment was the one that sparked this discussion, and I'd like to say I appreciate your and /u/geeal's discussion here. You may not convince each other, but you raise some important factors for those considering which approach to take (e.g. me) to weigh against each other.
cleaned up the globals for better async loading in my rust engine, after the rollercoaster of frustrations its nice to run into the places where I can see the extra solidity actually helps (I saw cases where something would certainly have *worked* in C++, however, the signatures leave the program open to damage if someone changes the wrong thing.. I do actually like how the borrow checker forces you to communicate the dependancies 100%.) 
I was working on a futures executor for no_std environments, but certain constraints make it rather difficult. Namely the question of whether to run tasks even if they haven't called wake yet. Async/await, at least in the standard library, requires std because it uses thread local storage to pass the arguments that would otherwise be passed directly.
ah nice! I started up a side project using actix-web, just getting the basics of actix &amp; diesel working together. This looks like a good next read :)
What would a typical use case for this be? 
I think you'll be fine, although you may want to read /work through thw rust book first. Shouldn't take you more than a couple of days to quickly read through with your background.
&gt;Are you sure the proper method of handling it in general is to retry the message? Probably not, but it works fine for some scenarios. &gt;I believe a different fault handling mechanism should be triggered that at least checks for or even roll backs unwanted side effects Sounds cool but impossible to implement in general case. Probably the closest realistical alternative is a some kind of limited DSL with invertible actions, or just an API to let user do everything himself case by case, something like lifecycle method `on_error` which should return `Skip` or `Repeat` to let supervisor know if message should be resent. For example if actor during message processing may store something in DB, this method could somehow check this DB and if it already has data associated with message it may remove it and return `Repeat`, or maybe just leave it and mark somehow and tell `Skip`, or whatever else fits the concrete scenario. It sounds quite complicated and error-prone itself, so now we also need some way to deal with effectful errors inside \`on\_error\`...
True, I would be fine with a function which splits by default on whitespace. Any other kind of separator feels too 'opinionated' to me. Of course, when separators and data become more complex, it can be easier to write a parser using a library like nom.
/r/playrust
I’m basically doing the same. It’s hard to break C/C++ design habits when putting together a rust game engine 😅
Cool! I must admit I'm a noob in these things, so I'm not sure a cross-distro RPM is a good idea, but I can try. However building .deb from an .rpm based distro and viceversa sounds complex, so maybe I need to do something complex anyway. 
I believe Actix spawns an OS thread for every actor, so having hundreds of thousands of those around is going to be a strain on the OS, and millions is out of the question.
just out of interest , is anyone who's making OS's from the ground up in rust trying anything like 'SSI' (virtual memory across a network, to make a cluster appear like one big machine). the overlap would of course be more concurrency, and perhaps leveraging propper immutability to know you can have read-only pages copied as sources in multiple machines. imagine this running on an r-pi cluster or whatever else
I did some CPU mining for a while with my own core loop in assembly and a barebones pool client I wrote in Rust. Since then, prices have changed and Monero has tweaked their algorithm enough to break all my opcode-level optimizations, so I'm no longer mining at scale; I figured I'd open-source the project. I wrote a core for the new algo in Rust based on stdsimd intrinsics (and found a [rustc bug](https://github.com/rust-lang/rust/issues/55249) in the process), and now it's pure Rust except for deep dependencies like libc and some ancillary hashing functions (which I rewrote the buffer munging for in Rust, but used the C/ASM simd code from their reference implementations). The miner itself is quite simple, and just hooks together two constituent libraries with some efficient synchronization: the simd pipelined-hasher implementation: [yellowsun](https://github.com/kazcw/yellowsun) the stratum protocol client: [cn-stratum](https://github.com/kazcw/cn-stratum)
By all means, have a look at &lt;https://github.com/rust-embedded/cross&gt;. In the worst case, you can read by weird things they did to make the docker images work :)
Exactly! Which is why I suggested a standard 'split' then an split with a bunch of options. I've had specific issues and needs for whitespace splitting which is specific (such as split but not on zero width white space, or 'find the first zero width whitespace or any of these common split acceptable patterns such as yes/no/maybe', etc etc. In my company library we have all kinds of fun stuff like finding inc or the German GmbH, and properly capitalizing it. Title case (so we ignore capitalization on 'the' or 'and') as well as fun stuff like expansion (which tries to expand any common abbreviation in our industry). etc etc etc. Some of this makes sense in a library, some in a library for a specific context, and some makes sense only in a specific program. I just don't know the context and goals of this library so there is only so much we can say about it.
Well, there are two established solutions for parallelism in Rust: the OS threads, which you cannot spawn a million of and expect the OS to cope with that, and Tokio, which is an event loop (closer to what you're after) but designed for tasks mostly blocked on IO, and can be rather hard to wrap your head around. If I were writing this, I'd just avoid any general-purpose frameworks. This is a rather uncommon use case, and the ways to optimize it can be significantly different from what general-purpose frameworks expect. For the MVP I'd go with something like this. Every network participant stores some state and has a function that processes a single message. This maps to OOP concept of object or Erlang/Elixir concept of process, `gen_fsm` specifically. Every participant also has an incoming message queue, identical to Erlang message box; I'd go for the standard library's VecDeque for implementing it. I'd write my own trivial scheduler that just picks a network participant out of a global queue of network participants with non-empty message boxes and calls the "process one message" function on it. Then, if the message box is still not empty, puts it into the end of the queue of the network participants with non-empty message boxes, and moves on to the next network participant. I'd go for single-threaded approach first as a proof of concept, and see how this works compared to Erlang/Elixir implementation forced into single-threaded mode. If that works, spread it over to multiple threads. Switching to multithreaded should be as simple as replacing VecDeque with [crossbeam-deque](https://crates.io/crates/crossbeam-deque) and running multiple schedulers in Rayon's thread pool. This will give you a simple system that's very easy to understand and hack on, and where you have enough control over its inner workings to tune performance to your hearts content.
I'm planning on having a "deep work" week after a bunch where I was blogging, chipping at things, and dealing with other life stuff. Mostly I plan to get the synthesizer in better shape, with actual module placement and wiring. I also plan on doing some work on xi-win-ui, partly to support the synth, and partly to support open source contributions to xi-win, which are starting to warm up. I'll probably also make progress on fixing [slow float rounding](https://github.com/rust-lang/rust/issues/55107) in Rust, and maybe do the SIMD operations for my analog scope emulation (it [looks beautiful](https://twitter.com/raphlinus/status/1053543806711123969) and is reasonably performant even with scalar code), because SIMD optimization is always fun.
I'm working toward a semantic grep tool based on the ideas from the [comacro prototype](http://comacro.lambdaverse.org). The first step will be a regex library that's like regular expressions, but extended with the ability to work on trees (e.g. count brackets) and support *limited* backrefs. I've found that both of those things can be done without backtracking or doing anything else terribly inefficient, and I should have something ready to release "soon" for general use (if anyone else needs regex for trees?) and to use as a building block for the next step.
Maybe I'm just a day learner, but I come from a JS background and I didn't find rust hard to learn. Maybe the projects I decided to learn with were better chosen than some. The only frustration I had was sub-par IDE integration but that's being worked on.
[bindgen](https://rust-lang-nursery.github.io/rust-bindgen/introduction.html) can automatically generate Rust bindings for a subset of C++ headers.
Thanks. I didn't notice that. Would be easy for a new comer to trip on that
&gt; and the compiler keeps shouting at me for various reasons That's sad. We try to make the compiler error experience to be closer to a tutor than a drill instructor. Would you have some actionable items/feedback that we could look at? It'd be invaluable in making `rustc` easier not only for you, but for anyone else out there that's trying to learn Rust and has the same mental model as you do. We try to keep our "fresh eyes" for as long as possible, but sometimes it is just impossible to do so, so overlap between people able to fix diagnostic issues and the people with fresh enough eyes that they can _see_ the issues is very narrow and shifting over time.
Is there an easier method of getting user input in Rust? Currently, I have the following code, which prompts the user for input, and if there is an error, tries again: ``` fn read_value_from_input&lt;T: FromStr&gt;(prompt: &amp;str, error_message: &amp;str) -&gt; T { let result: T = loop { print!("{}", prompt); io::stdout().flush().expect("Unable to flush STDOUT!"); let mut input_value = String::new(); io::stdin().read_line(&amp;mut input_value) .expect("Unable to read input!"); match input_value.trim().parse() { Ok(value) =&gt; break value, Err(_) =&gt; { println!("{}", error_message); continue; } } }; result } ``` Is there an easier (or more idiomatic) way of achieving the same result? Coming from a Python background, this is exceedingly verbose. For example, in Python 3 I might write: ``` def read_value_from_input(convert_type, prompt, error_message): while True: input_value = input(prompt) try: result = convert_type(input_value) return result except ValueError: print(error_message) ```
I am unfortunately not able to recall the specific issues but I have been following the Programming Rust book from noStartch Press. I have implemented moderately complex classification algorithms in c++ so I am not that dumb (for the lack of better word) but programming in Rust seems scary. I also do not have any functional language expressive. And also the way things like .expect and match work was a bit difficult to understand. I will most certainly return to rust and try to learn it better but I have to find better resources. Thanks for the amazing work. 
The "runtime" bit in the bottom right seems kind of buzzword-soupy.
&gt; I am not that dumb (for the lack of better word) but programming in Rust seems scary I understand that, and I wouldn't claim that you were. In my own case, I tried picking up Rust when 1.0 landed and I failed miserably. It wasn't until New Years when I had some time to better dig into it that I could get started. Things should be easier/clearer now than they were then, but there's still a lot of work ahead of us. &gt; I also do not have any functional language experience. That is certainly a possible issue. I had Scala experience before learning Rust, and that made the learning curve slightly easier. &gt; And also the way things like .expect and match work was a bit difficult to understand. I can see how destructuring can be hard to learn (again, knowing Scala helped me), but don't see how `expect` is hard to understand. I'd be interested in hearing more around that. &gt; I will most certainly return to rust and try to learn it better but I have to find better resources. Fair enough. I'd appreciate it if when you do and have frustrations, no matter how small, you write them down. Even if it's just stream of consciousness and we can't actually fix it all, it would be valuable to inform our future work. &gt; Thanks for the amazing work. It's the work of lots of great people :)
Awesome. [Already started!](https://github.com/tom-james-watson/learn-rust/)
I've got a `cargo`-related question: Whenever I use `cargo doc`, it recompiles my crate and all its dependencies. That makes sense, but it also seems to clobber the incremental build data of my crate and its dependencies. Similarly, a `cargo build` seems to clobber the incremental build data of the `cargo doc`. This is inconvenient, since in practice this means that any invocation of `cargo doc --open` will _a.)_ take long and _b.)_ make the next build take long as well. As a minimal example case: when I run `cargo build; cargo doc; cargo build` the second build always builds all crates from scratch. Is that the expected behavior? If so: why?^† If not: how could I start debugging this issue in my setup? †: I get 'why' `cargo` might consider a doc-build to be different from a normal build, but I don't get why that means it (seemingly) throws away its incremental data. For comparison, `cargo build; cargo build --release; cargo build` never builds any crate from scratch in the third build.
a little bit every day
in the past didn't rust used to have the exact same 'green threads' - but it was ditched because it prevented reaching C++ performance for standard 'handful-of-threads' code. Would it be possible to resurrect this with an alternate version of the standard libraries if need be... or does Go fill that niche hence no demand ?
In Rust *reference* specifically means borrowing, but you can pass a `Box&lt;Thing&gt;` by value to transfer ownership of the contained `Thing` by copying only the `Box` (usually just a pointer).
All of these points have already been raised in the lengthy RFC comments, as well as counter arguments for them. &gt;English bridges the international gap here It's an accident of history that this is the case, and the fact that this is the case now doesn't mean that it should be so in the future. &gt;it's simpler and faster for compilers and parsers Is it? Because the compiler is already dealing with unicode identifiers, even if it is rejecting them with an E0658. &gt;And the RFC suggests all sorts of complicated and hacky lints to solve the problem of confusable identifies, a problem that wouldn't exist without it in the first place! Confusables already exist even within ASCII, and the lints are to make sure we don't introduce undesired interactions with other parts of the language. &gt;It just needlessly complicates the language, and ***i*** don't see it being useful in the real world anyway! Emphasis added. You don't see it being useful in the "*real world*", but that doesn't mean that it won't be useful for people. &gt;Few, if any, projects can actually use it. This is, I'm afraid to say, showing lack of imagination :-/ &gt;A public project can't use it, Why shouldn't an open source project that's intended only for people on a single locale (think a specific's country's tax preparing, for example) be in that locale's language? &gt;but even in private code i see it being unwieldly to use because you'd constantly have to switch input methods between your native language and English just to use the standard library and tooling! There are lots of people with languages well served by Latin-1 who program on their native keyword layout. Shouldn't be up to people in other locales to decide wether switching between layouts is too annoying? &gt;And if someone doesn't know enough English to come up with a variable name, i'm not sure how they're using the standard library, which is in English. Above all, it'll be inconsistent. Constant jumping between languages. I don't know if you've seen bilingual/multilingual people interact among each other, but they usually switch languages pretty free-form, depending on what they're talking about. On some cases, they will talk in one language, use a single word or phrase in another, and switch back. Or continue in the other language. This is all very context dependent and, more importantly, seamless for everybody involved. &gt;Speaking of the standard library, I don't think the docs are even translated! That is IMO a bug that no-one hasn't had the bandwidth to deal with. &gt;And it "hypothetically being easier to teach" is nowhere near enough justification for this kind of change, IMHO. That is a value judgement that seems to me to, again, betray lack of imagination or experience outside of your own culture. It is also a sentiment I do not understand, as no-one is *forcing* you to implement or even use this new feature. &gt;non-ascii identifiers will always be a huge minority even if allowed, a significant cost with little benefit, to a minority of people. An accessibility feature only affecting a number of people doesn't mean it shouldn't be done, for the same reasons that curbs should be wheelchair accessible. And even then, on Earth, only \~20% of the people speak english *at any level*.
Coming from a Python and JS background, rust didn't strike me as hard to learn. It uses the same concepts that are fundamental to all imperative langues, although with different syntax. Knowing when to borrow can be tricky, but the compiler is extraordinarily helpful with that, to the point where a new person can trial-and-error it until it works. For context, I found Haskell difficult to learn and frustrating.
If you're interested, just go for it. It doesn't really matter whether the way you learn is "optimal" or not. Being interested means you're much more likely to spend the energy to figure things out in the first place. That does wonders for any learning.
I set up a proxy at https://docsrs.brun.one/ if anyone needs access to it right now
I already made comment a few days ago, but I thought I should share this link as it gives you something to think about: https://www.gamedev.net/blogs/entry/2265481-oop-is-dead-long-live-oop/
Is that really the only comment you can make after reading the entire article?
I looked into this recently and found plenty of discussion online about how the Rust standard library doesn't provide a succinct way to do this. &amp;#x200B; I did find [this crate](https://crates.io/crates/promptly) that attempts to make the pattern ergonomic. The design chooses to re-attempt on parse errors and panic on stdin-level errors.
IIRC there were problems with stacks taking up too much space, or else performance problems with using segmented stacks. Go can do tricks to avoid these problems because it can relocate stacks. Having stacks on the heap (i.e. coroutines and async/await) appears to be the more Rust-compatible solution to the same problem.
I think Pony has similar causality guarantees in a multi-threaded runtime, so they must have solved it. It could be per-thread queues with actors assigned to threads, or a single global queue.
I have some quibbles about naming. `assert_eq_size_val` sounds like it is a dynamic assertion. A `const_` prefix would make it clearer, and would match `const_assert` and `const_assert_eq`. Relatedly, the crate is called `static_assertions`, but `const_` is the prefix used (in some places). A `static_` prefix would match the crate name.
Sometimes you have a type that you want to be a particular size, e.g. because there are many instances and you've carefully optimized its size/layout and you don't want it to get bigger.
Nice, thanks. If it's just a proxy, how does it work? Is docs.rs still up somewhere? Did they get rid of all the nice extra themes like Ayu? :( 
Ah cool! I have a project where I'm doing exact that. Although, in my particular case because I also want to deal with the case where T: ?Sized, I had to define a trait that represents the additional metadata necessary to reconstruct a fat pointer. Thus my wrapper looks like: struct Ref&lt;T: ?Sized + MemRef, P: Ptr&gt;(...); That said, I may just use an inner enum that has markers based on P: enum Inner&lt;T,P: Ptr&gt; { Rc(Rc&lt;T&gt;, &lt;P as Ptr&gt;::SupportsRc), Ref(NonNull&lt;T&gt;, &lt;P as Ptr&gt;::RefLifetime), ... } Basically if that type of use isn't supported, the appropriate associated type marker is set to !. This has the disadvantage that users of the library can't easily add new point types, but it's a lot simpler to implement as you don't need any unsafe methods.
At the moment [docs.rs](https://docs.rs) doesn't work on IPv4, but it's still reachable over IPv6.
It's not public yet. But it should be soon!¹ 1) Those of you who know me from elsewhere might guess this is my proofmarshal project, which I've been saying will be done soon for something like two years... :) Still in "architectural design hell"
You're looking for /r/playrust 
oh,fuck, urm thanks
Thats really odd. So thats just how docs.rs looks now then? All the good themes are gone?
I published my first crate, a Rust wrapper around NVidia's OptIX GPU raytracing library: [https://crates.io/crates/optix](https://crates.io/crates/optix) It's a bit rough around the edges still but I was keen to try the publishing process, and it's full-featured enough to write a simple cornell box with it. I broke that out as a separate repo to use as an example, since because it relies on a 3rd-party dynamic library, the build process isn't as simple as a normal crate. Going forward I will be using that crate as the basis for a pathtracer I'm writing in Rust, which won't be open source(yet, anyway) but anything related to optix will be. &amp;#x200B; Similarly, I've also been working on a color library to be used as the foundation for the renderer as well: [https://github.com/anderslanglands/color-space-rs](https://github.com/anderslanglands/color-space-rs) The API on this one is still in a bit of flux so I won't publish for a while probably. It already handles conversion between spectral, XYZ, Lab and various RGB spaces. As I get into the renderer I'l add XYZ-&gt;spectral and flesh out the types in there some more. Once that's done I'll probably put it on [crates.io](https://crates.io) too. &amp;#x200B;
Wacky and delightful. I look forward to more!
Coming from a C/C++ background, I found rust _interesting_ to learn. The learning curve was surprisingly gentle and I found that the borrow checker and error checking was more insightful and instructive than the C++ error messages that clang/gcc would produce. Given some of the convergent evolution in both communities, it wasn't painful at all. Racer + flycheck + clippy + rust-mode + Emacs worked like a charm. Honestly the tooling is excellent, can't wait until RLS becomes more usable.
Interesting that so many who came from js/python found Rust easier to learn. &amp;#x200B; I came from C++ and struggled for weeks, and I felt that my C++ background was quite helpful for understanding things like move semantics. &amp;#x200B; Then again, C++ taught me that building a linked list was a great first project, and should be trivial. And the subtle differences between it and Rust might have led to more pitfalls. &amp;#x200B; I suppose I likely had to unlearn a lot more than someone coming from js/ python?
Wonderfully in-depth, as usual! Great article.
I learned Ruby first, there is a lot to learn when moving to rust.
Coming from C it seemed logical to reason about borrow checker and other safety guarantees. Though I will admit, I am no expert but it makes sense to me because I avoid mallocing memory in my C code as much as possible anyway. I prefer to use compiler provided constructs, so it is very helpful to use rust. 
I guess I would have assumed that cast to be UB in C for violating the strict aliasing rules, such that you'd wind up using a union for legal type punning.
Good crate find. I'll have to remember that for recommendation next time this kind of question pops up. Maybe deserves a crate of the week mention in TWiR?
Hey I just graduated from high school! I've been working on this [https://github.com/sharexin/sharexin](https://github.com/sharexin/sharexin) since the summer before my senior year of high school. Rust is great I learned it after using Python a lot. Took some CS courses my senior year and learned Java, now in uni. it's all Java right now. Keep it up!
&gt; Then again, C++ taught me that building a linked list was a great first project, and should be trivial. And the subtle differences between it and Rust might have led to more pitfalls. This seems like an important point. The biggest difference between people coming from different languages might be what sort of projects they choose. If your first project is messing with strings and files, you're probably going to have a gentle introduction to the language. But if your first project is designing a data structure, you're going to front load all of the hardest parts.
I just have a question: Why bcrypt when argon2 is miles better and far more future proof? Tutorials can be followed to the letter by some people, so making sure the community isn't harming itself by defaulting to the safest option seems like a worthy goal!
The link seems broken?
Yes，if need call c++ from rust. Because c++ lib is mainly used to get user information in the background. And a part of function also use thread.
It's an onion site. You have to use the tor browser.
Don't have TBB on hand right now to see the link. Is there a link to any code anywhere?
Not yet. We need to clean things up a bit. But I'll post it soon.
This is one of those things that's really cool but also kind of horrifying at the same time
How does a Tor search engine work? How are you indexing sites?
I think the implementation is similar but it doesn't otherwise seem to fit what OP is looking for (a programming model, rather than an efficient implementation of that programming model). Obviously not the same, but if [yew](https://github.com/DenisKolodin/yew) can add termfest as a back-end, then we'd be talking.
That's not normal. Is it a public project you can share? One thing you can do is run `RUST_LOG=trace cargo build` to get some debug info from cargo. Look for the lines that start with `cargo::core::compiler::fingerprint` and it should explain why it thinks it needs to recompile. (Cargo stores information about each crate in a fingerprint file to know if it needs to be recompiled.) 
OSX for tarpaulin would be GREAT!
More 👏 anarchist 👏 crate 👏 names
I\`d like to learn about File System. Are you planning to write about it?
Absolutely adore Lin Clark's post! 
Wow. That is ultra cool. They also are very open as far as how to get involved. Roadmap is interesting. One of the goals is integration with Plume, "Federated blogging application, thanks to ActivityPub" (https://plume-org.github.io/Plume/). 
These are generally very useful guidelines, and a lot like what I tell people when they ask how to write idiomatic code. Unfortunately few things in Rust come without caveats: * "pass references to methods wherever possible" -- Unless the types implement the `Copy` trait in which case they're probably small and you're fine passing them by value. * "Make sure Result&lt;T,E&gt; objects are mutable, and derefence anything needed in 'match' or 'if let'" -- actually I'm not sure why you want the `Result`to be mutable. Learning to use the combinator methods on `Result` also makes life simpler sometimes, but honestly there's nothing wrong with just taking the `Result` apart yourself. * "Don't return references from methods. (might not be possible)." -- mainly only possible when it's returning a reference to something that was passed as an argument already * "Make sure one function is only capable of throwing one type of error, in my case, its std::io::Error." -- Definitely very helpful; there's good ways around it (the `failure` crate) but we're still sort of figuring out the best style for using them.
&gt; pass it to a function as a reference but give that function ownership as well It sounds like what you're talking about is an operation that has the performance characteristics of a reference, but which calls the destructor of the object immediately after the function in question exits? `Box` certainly does that, as /u/salty_c_dog pointed out, if you're ok with heap allocating the object. If you want to do it on the stack, you could do it manually with an `&amp;mut Option&lt;T&gt;`, where you explicitly set it to `None` when you're ready to destruct the object? Maybe I could give a better suggestion if I had a specific use case in mind. Why does your function need ownership specifically, rather than just an `&amp;mut T` to your huge struct?
I came from a Go/JS background. My first application in Rust was a web server that is in being used even today! and I hadn't had any issues with it in the last 13-14 months. I used Iron+postgres+hyper+serde_json+r2d2_postgres. I remember being frustrated because iron's docs were not the best but it was fun when I completed the project. 
How has your experience with `Rc`s and `Cell`s?
This is my first rust crate, that I wrote as I was learning the language. I would be keen on getting feedback !
I've learned Rust during my last highschool year and since we were only doing C# it was so much more interesting. As someone once wrote(not exactly 1:1 but the meaning it's the same): "Rust isn't a new language, it's an old one that we wished to have back at the beginning" 
I like the sound of "PWSIX", I have no idea how it shall be pronounced, but I'm sure it's awesome! As a non native-speaker, I imagine a charming "pew-six"... And [`wasmtime`](https://github.com/CraneStation/wasmtime) looks interesting, it will be maintained by the Firefox team, so I think we can expect pretty good performance, and some maintenance guarantees. 
Either "pew-zix" or "pwuh-zix", probably.
&gt; a fairly superficial parse of some textual data into rust data structures, after which you'll do more meaningful processing at run time Sounds about right, yes. &gt; In other words, first design the API for using the data, and then work backward from there to derive a good organization. Hmmm ok, that sounds like a good idea, but also feels a bit like "I did that already". I'll try to sit down and think that through, thanks for the idea!
You'll have to share your code if anybody is to have any hope of helping you :)
&gt; Make sure Result&lt;T,E&gt; objects are mutable No. In fact, the compiler warns you in the snippet above that it `contents` doesn't need to be mutable. Also, use `match` rather than `if let ... else`. You can also benefit from implicit return. So if we start with this: pub fn retrieve_data(id: &amp;Uuid, location: &amp;str) -&gt; Data { let mut contents = read(id, location); if let Ok(v) = contents { return Data {data: Some(v), id: Some(*id)}; } else { return Data {data: None, id: None}; } } First you can drop the `mut` and use `match`: pub fn retrieve_data(id: &amp;Uuid, location: &amp;str) -&gt; Data { let contents = read(id, location); match contents { Ok(v) =&gt; return Data {data: Some(v), id: Some(*id)}, Err(_) =&gt; return Data {data: None, id: None}, } } Then you can use implicit return: the return value of a function is the value of its last expression; the value of a match statement is the value of its selected branch. pub fn retrieve_data(id: &amp;Uuid, location: &amp;str) -&gt; Data { let contents = read(id, location); match contents { Ok(v) =&gt; Data {data: Some(v), id: Some(*id)}, Err(_) =&gt; Data {data: None, id: None}, } } And finally, you can inline the `contents variable`: pub fn retrieve_data(id: &amp;Uuid, location: &amp;str) -&gt; Data { match read(id, location) { Ok(v) =&gt; Data {data: Some(v), id: Some(*id)}, Err(_) =&gt; Data {data: None, id: None}, } } 
Thank you for your answer, that looks like a good solution and possibly easier than diving into complex frameworks such as Tokio or Actix.
Thank you, from the description this is exactly what I'm looking for!
Hi, thanks, I got one step further. I've apparently mischaracterized what I was doing. The first of my builds was done through my IDE. The `cargo doc`'s were done on the command line. It appears that the difference was due to the use of the command line vs. invocation through the IDE. Obvious in hindsight. So the question instead becomes: &gt; Why do `cargo build` (on the command line) and the cargo build command run from [emacs' cargo mode](https://github.com/kwrooijen/cargo.el) clobber each other's incremental build data? The `cargo::core::compiler::fingerprint` helps moving me in the right direction: apparently, "RUSTFLAGS has changed". I'll have to figure out how I can get the emacs mode to use the `RUSTFLAGS` and other environment variables that are exported in my `~/.bash_profile`. I'll keep you posted when I resolve it (or run into other issues). Thanks again.
Awesome looking project! I note that Mastodon is mentioned in the readme (also that people already use it) but I'm quite interested to hear how the project plans to differ from [diaspora](https://diasporafoundation.org/). diaspora was probably the first decentralised FOSS social network but it's been far from a success. Have you studied or taken learnings from their approach?
nice work!
I wrote a runtime assembler and Scheme-&gt;amd64 JIT over the weekend. I think that my approach to handling the runtime is probably bad though, so I need to figure out what I should be doing there. Also getting segfaults that I think are from unaligned writes (repr(packed)) but I haven't fiddled with it yet. Interestingly, I'm also getting segfaults from interacting with the runtime, but they're consistently inconsistent. `(define x 5)` does a define operation on the runtime and works just fine, but running `(define y x)`, which does a lookup followed by a define doesn't work. The lookup operation is fine, but for some reason it segfaults in the define operation. I'm not sure why it works in one situation but not in another.
That was remarkably clear! Thanks.
Nice! The member functions in Rust are much nicer than in c. E.g. [gtk_tree_model_filter_set_visible_column](https://developer.gnome.org/gtk3/stable/GtkTreeModelFilter.html#gtk-tree-model-filter-set-visible-column) vs [TreeModelFilterExt::set_visible_column](http://gtk-rs.org/docs/gtk/trait.TreeModelFilterExt.html#tymethod.set_visible_column) The struct level documentation (e.g. [GtkTreeModelFilter](https://developer.gnome.org/gtk3/stable/GtkTreeModelFilter.html#GtkTreeModelFilter.description)) is not there yet it seems. A link to the C version of the documentation would help. 
Probably not. He'll probably talk about disk i/o and might touch on a simple format like FAT, but I doubt he'll spend much time talking about filesystems.
I kind of wanted to do something like that where the OS would scale across multiple networked machines just like across CPU cores, but it's way above my skill level.
The [mailmodel crate](https://crates.io/crates/mailmodel) uses the [rust_qt_binding_generator crate](https://crates.io/crates/rust_qt_binding_generator). You can have a try with that if you want. The blog/documentation of using the rust_qt_binding_generator crate is not done yet.
Thank you ! Did you have a look at the code ? I would love to have feedback on whether it looks idiomatic enough or not...
just try and do it, and your skill level will rise appropriately :)
Just a little thing, but instead of prefixing some modules with `json`, you could have used a submodule: src - bin.rs - json - base_types.rs - list.rs - object.rs - string.rs - value.rs - lib.rs - utils.rs 
If I'm not mistaken, one could even write: ` pub fn retrieve_data(id: &amp;Uuid, location: &amp;str) -&gt; Data { read(id, location).map(|v| Data { Some(v), Some(*id) }) `
congratulations this seems to be a well written and useful library, not bad for a first crate! let mut buffer = Vec::with_capacity(512); self.write_json(&amp;mut buffer).unwrap(); maybe a SmallVec could help here by removing heap allocations for small values.
In case you wonder what it is (like mute): &gt; Amethyst is a data-driven game engine built for high parallel performance and easy prototyping.
 // This is safe because the bytes we emit are all valid UTF-8 String::from_utf8(self.to_json_buffer().into_vec()).unwrap() You can then skip utf validation with: fn from_utf8_unchecked(bytes: Vec&lt;u8&gt;) -&gt; String
It works by proxying to IPv6 since their hosting provider only had problems with IPv4 routing. It's basically a Caddy reverse proxy running on my geographically closest node (to minimize latency) proxying IPv4 (what most people have) and IPv6 requests to the still available IPv6 IP.
Not OP, but I've never heard of argon2. Could you give a quick explanation of why argon2 should be used instead of bcrypt, since I thought bcrypt was supposed to be a decent hashing algorithm?
It looks like SmallVec implements `Write`, so it can already be used with json_in_type today ```rust let mut buffer = SmallVec::&lt;[u8; 512]&gt;::new(); my_json_val.write_json(&amp;mut buffer)?; ``` I am a little bit reluctant to add it as a dependency, because having a method that returns a standard `Vec` is convenient...
I follow avidely this project: this is the best Rust game engine by far in my opinion. Keep doing this great job!
Here : https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2015&amp;gist=436013c149f788a4f3cd4bbb33ebf02e time of wget: real 0m4.870s user 0m0.077s sys 0m0.439s time of rust release build: real 0m4.727s user 0m2.049s sys 0m1.059s I have some code here that rechunks the data, but this does not affect the CPU usage as I can see it.
That's better indeed.
/r/playrust
delete?
Right. You could always as a user use an unchecked to_string wrapper on top of to_json_buffer. And you should do that in performance oriented code.
Why do you need sub\_results at all though? This could all be done with a single loop: &amp;#x200B; `fn main() {` &amp;#x200B; `let mut divisor = 1.0;` `let mut result: f64 = 0.0;` &amp;#x200B; `for i in 0..1000_000 {` `let sub_result = 4.0 / divisor;` `if i % 2 == 0 {` `result = result + sub_result;` `}` `else {` `result = result - sub_result;` `}` `divisor = divisor + 2.0;` `}` `println!("{}", result);` `}`
You could also utilise the fact that if statements return a value: result = if i % 2 == 0 { result + sub_result } else { result - sub_result };
Great article! (Unsafely) transforming HKTs back and forth between the bound form and the unbound, 'flattened' form is an idiom well-known in JS and Elm land. Great to see how it can be used in Rust as well! :D
That doesn't give you the filled-with-nones version.
Nice, there is probably some overlap with https://github.com/cristicbz/rust-doom
Documentation in gtk-rs is a bit behind. We try to use C doc as much as possible (which means almost everywhere). But we're open to rust adds. :)
&gt; Ok, this was more painful than I hoped, as I got build errors for sleef-sys on both my mac and windows machines (problems finding libclang) Yep, `rust-bindgen` requires `libclang`. On Mac it should "just work" as long as you have `xcode` properly installed (which might be non-trivial). &gt; 251ns for packed_simd sin_pi with sleef-sys, and 673ns without. For an AVX2 CPU I get pretty much the same timing difference here between +/- `sleef_sys`. &gt; That last is slower than the scalar fallback of calling f32::sin(), weighing in at 523ns. That's weird, `packed_simd` without `sleef_sys` just calls `f32::sin` 8 times (once per element in the 256-bit vector) and has the exact same performance as `f32::sin` (x8) in my benchmarks. &gt; while the guarantee for both packed_simd and f32::sin is probably in the ballpark of -132dB (feel free to provide a more precise bound). All `packed_simd` float math functions have an error of 0.5-1 ULPs, unless when otherwise stated: some functions are suffixed with an `e` for "estimate" but estimates of the trigonometric functions are not implemented yet (sleef_sys provides estimates with an error of 3.5 ULPs that you might want to consider). 
It's coming in 0.10 with the new 3D stuff so that we'll have good looking stuff to showcase! Some people are showing off their work on the Amethyst discord server if you want to see stuff getting done.
Thank you, I'll check it out! Thanks for the project.
Well, I do have some experience with C. This helped with getting my mind around Rust memory model (not that there was anything complicated required in this project) as well as bit fiddling. Other than that I just looked at the official docs. I'd say this was not much harder to implement than in any other language, e.g. Javascript or Python.
Is Webassembly supported as rendering backend?
Brooks Builds on youtube
I've found that most things I've done with Rust have been multithreaded, so I've used `Arc` and `Mutex`/`RwLock` a lot more than `Rc` and `Cell` much. As long as you are happy to pay this synchronisation cost, they seem pretty straightforward. They do come with a bit of boilerplate (you have to resolve a lock on the mutex every time), but I'm working on a library to allow you to centrally register dependencies, and resolve them into standard reference automatically.
From JS it's even easier, because the syntax is really similar.
Came across this on GitHub today. It's written in Rust.
You can use hyper with a single threaded runtime. Instead of `hyper::rt::run`, use `tokio::runtime::current_thread::Runtime`.
wasmtime is mostly maintained by /u/sunfishcode and a few other people. It definitely needs more contributors. Personally, I'm ripping the wasm runtime out of nebulet and working on getting it to run standalone in a number of environments. They will fulfill similar roles.
Started doing a bit of consulting related to tantivy for a startup. Also, restarted indexing common-crawl with tantivy.
I wanted to look at the benchmarks and compare them to the criterion report but it seems like there are four benchmarks under `encode simple object with derive` in the report but only two in the benches directory. Is one or the other out of date?
I don't think I've ever clicked a link faster. Can't wait!
Huh. That *is* strange. The docs don't mention `Window` having a `Drop` implementation *or* having a function to manually trigger destruction. That said, if you don't mind it invisibly hanging around until your program exits, it looks like `window.hide()` should give the appearance of closing it. (Disclaimer: I've never used Winit.)
Oh, good catch! I renamed the benchmark test cases to remove `with derive` at the end, and did not see that criterion did not remove the old names from the report. I will regenerate the report when I come home.
I'm using winit version 0.17. My OS is Ubuntu 18.04 LTS with GNOME desktop, running Xorg.
To be honest, I'd prefer someone else to chime in first. It seems like an unlikely enough thing to be expected to do that I worry it'd be more likely to cause something to break. That said, if it *is* what you're expected to do... WindowExt is a trait which provides the platform-specific methods. After you bring it into scope, you'll have one of the following methods on your `Window` object, depending on which platform you're building for: * `get_xlib_window` (X11) * `get_wayland_surface` (Wayland) * `get_hwnd` (Windows) * `get_nswindow` (OAX) * etc. The problem is that, if you're going to pull in bindings for the platform's native API anyway (to feed the window handle to), why bother using Winit at all?
&gt; The problem is that, if you're going to pull in bindings for the platform's native API anyway (to feed the window handle to), why bother using Winit at all? I'm new to low level coding (relatively low level) and native applications - I don't know much about where to start, how stuff works, why stuff works, etc. I've done web dev, where you write HTML, CSS, &amp; JS - and stuff just works. Mostly no compatibilty issues, just sometimes some browser-specific and resolution-specific stuff. So this is all mostly new to me, and complicated as well.
I've added my code and output, check them out. Dropping the variable doesn't *seem* to be closing the window, might be something wrong with my code though.
I've been writing a lot of CLI programs to convert between different formats of files. Lexers, parsers, generation. I think it's good practice to touch on a wide range of language features. Embedded must be a tough one since you can't really user std. It's in a bit of flux right now too. I've been meaning to explore it one of these days.
What is the difference between using this and something like duckduckgo? And could you make the page more customizable? Like a dark theme for example.
It looks like the problem is that you're not running your `EventsLoop` , which is a case winit often isn't tested for. (Though, for our X11 implementation, running the `EventsLoop` shouldn't actually be necessary to close the window, *but* the underlying `XDestroyWindow` call won't be sent to the Xorg server until the command buffer is flushed in the event loop.)
Well, if I run the event loop, I have to wait till I receive user input before I can close the window, right? If not, then tell me how... And can I manually flush it?
Can't wait for 1.0 to try it out :)
As my usage involves showing the window again, I think `window.hide()` is good enough, and now I don't need to build it again each time - I just need to set the configuration options each time. Thanks! :)
See also https://twitter.com/rustlang/status/1054752714863927297
You can just use `EventsLoop::poll_events`, since that returns basically immediately whether there's an event queued or not (`EventsLoop::run_forever` is the one that blocks until receiving an event). It's possible to manually flush, but I don't recommend doing it: ```rust use winit::os::unix::WindowExt; let xconn = window.get_xlib_xconnection().unwrap(); xconn.flush_requests().unwrap(); ``` It would be trivial to add a flush to the `Drop` implementation, but I'm not comfortable making the guarantee that closing the window should be possible on all platforms without the event loop running.
Neat. It's just a TPM-aware ssh client. Should be pretty simple, which is good!
\&gt; Why does your function need ownership specifically, rather than just an &amp;mut T to your huge struct? &amp;#x200B; I was just thinking of an example that contrasts to a borrow/ref. Sort of like a thought experiment.
Ok, thanks! Because my application involves showing the window again, I'm currently using `window.hide()` and `window.show()`. How do I show text, images, and user input boxes in the window? And how do I make an icon appear in the right side of the GNOME top bar, like Google Chrome, Mailspring, or Gitter do, beside the wifi/nightlight/volume/battery icons?
Any plans on supporting "Create method 'some\_method\_not\_yet\_implemented' in 'SomeStruct'" action which allows a dev to call the method as if it already exists to then go ahead and start implementing it. &amp;#x200B;
I'd really recommend using a tokio-specific sender/receiver channel and keeping it all in the tokio runtime. I can't test how much that affects it but it seems like it could help. You're also only allowing 3 chunks to be buffered, which I would judge to be a bit low? Beside that, I imagine there are some things wget is handling transparently which `hyper` doesn't. For one, I don't believe it will request `gzip` data without an explicit header being set. `hyper` is a fairly low level http library and expects higher level interfaces to deal with such things. If your data is easily compressible, I imagine that does a lot to help.
nice work. I would find it interesting to know how serde and json\_in\_type scale with the number of values, for example if there are 10000 elements in the last benchmarks array.
My poor self thought this was /r/playrust 
heh, related: I recently wrote [the port](https://github.com/freebsd/freebsd-ports/blob/master/net-im/fractal/Makefile) for [Fractal](https://gitlab.gnome.org/World/fractal). They make nice release tarballs with all Rust dependencies `cargo vendor`-ed, it looks like a normal Meson package. Awesome! Except they have vendored an old version of some openssl crate — which doesn't support OpenSSL 1.1 — so my package broke on FreeBSD 12. (Same with the one on Arch Linux, probably somewhere else too.) And seems like there's no easy way to update *some* of the vendored crates.
I'm so excited about this engine! I haven't followed the development of anything this closely in a long long time. Hoping to get better with Rust so I can start to contribute!
So, I followed along with the pong tutorial docs, and then continued working on my pong game by following the example source code. I'd be happy to help write more chapters for the tutorial if that's needed :]
For what it’s worth, this is basically type-parameter erasure (like Java’s) done manually.
You are looking for /r/playrust
The last benchmarks array contains only `f64`. I think making this array very large would make the benchmark time dominated by the serialization of `f64`, which is done by the same library in serde and json\_in\_type. So you wouldn't see any difference. If we wanted to see a difference, we would have to add a benchmark with the serialization of a large array of json objects or lists.
Looks like I can no longer run tests. I can not build with the `--all-features` flag and I don't see how to turn it off. It did not add it to the command like in the previous version.
That would be fantastic! Feel free to [visit our Discord server](https://discordapp.com/invite/GnP5Whs) so we can talk about it!
**2. Keep comments constructive.**
Only after the fully macros support (which is coming soon!)
Nice work! Looks like there is quite a difference in compile time between Serde's macros and these... Here is the comparison I tried: [*main.rs*](https://gist.github.com/rust-play/9fe084b75f65221f4e0e77ff66849c03). Cfg-ing out one mod at a time, the Serde one compiles in 5 seconds and the json_in_types one takes more than 7 minutes (and runs slower). Is this something that can be improved?
By default all files (that are not gitignored) are packaged, and can be found from the `env("CARGO_MANIFEST_DIR")`
Or just leave the body empty to create a bootleg do-while loop...
How do you guys test your libraries for FreeBSD on CI?
Thanks, this seems to help a lot. I had to decorate your solution a little: let mut rt = tokio::runtime::current_thread::Runtime::new().unwrap(); rt.spawn( fetch_url(url, tx) ); rt.run().unwrap(); But the runtime is down from 3.1 seconds to 0.35 seconds, which is a definite improvement.
I assume you're trying to run `curl https://sh.rustup.rs -sSf | sh`? What Linux distribution are you using? What's the output of `curl --version`?
Rust is lagging a little behind on GUI libraries because existing ones tend to have complex APIs which depend heavily on classical inheritance, so adapting them to Rust is a lot of work which can't be readily automated.
Well, tried playing with musl, but reqwest complicates things. Tried switching to mio\_httpc, but that also led to other rabbit holes...
It sounds like you want something that's more of a full-stack widget toolkit binding like relm or gtk-rs. Winit's job ends at producing and managing the window itself. It's meant to delegate actually drawing in the window to something else like an OpenGL binding. As for showing an icon, I'm honestly not sure how GNOME Shell does it these days. I'm a KDE user and all of the other desktops have standardized on a design known as Status Notifiers or AppIndicators but, last I checked, GNOME Shell only supported them via an extension. (AppIndicators being an intentionally crippled but compatible subset of Status Notifiers).
I looked at the diagram first then read it, which may have been a bad idea.
I've a similar issue with sccache. sccache strictly requires reqwest 0.8.8, that, at the end, needs an old openssl crate (0.9.x) that doesn't support openssl 1.1.1. A solution is possible (adding openssl 1.1.0 as external dependency or add a static openssl 1.1.0 or 1.0.1, so it can be used to build the crate). currently, I'm a bit short in time, but it's something I'm willing to fix.
I am using ubuntu Output is: curl 7.58.0 (x86_64-pc-linux-gnu) libcurl/7.58.0 OpenSSL/1.1.0g zlib/1.2.11 libidn2/2.0.4 libpsl/0.19.1 (+libidn2/2.0.4) nghttp2/1.30.0 librtmp/2.3 Release-Date: 2018-01-24 Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP HTTP2 UnixSockets HTTPS-proxy PSL
Interesting! I'm not sure there is a real use-case for a static json array of 500 elements, but a 7-minute compile-time is just huge. I wonder what rustc can be doing during all that time. I'll have a look, but I think it's the compiler that can be improved in this case. 
I don't get this type: struct TreeNode&lt;T, P: RcPtr&gt; { val: T, right: P&lt;TreeNode&lt;T, P&gt;&gt;, left: P&lt;TreeNode&lt;T, P&gt;&gt;, } Is P parameterized or not? Or is the idea of HKT that it's parameterized _only_ when being used? I found this an interesting read, but what I'm missing is applying the type you're constructing to actually use in this TreeNode struct or similar. I seems to run into having to construct an infinite type signature when I try...
Try removing the `S` from the command: `curl https://sh.rustup.rs -sf | sh`
"Rust is installed now. Great!"
Then you should be all set.
One way to deal with that would be to make `JSONValue` an unsafe trait. This would signal that anyone implementing the trait has to uphold certain invariants, (UTF-8 compliance in this case) otherwise any resulting UB is their fault. Not sure if that's necessarily the solution you'd want to use, but it is one potential option at least.
...but there's a 10 mb limit per crate, iirc.
\`cargo install\` is not meant to be the final method of packaging and shipping a program. Maybe you want to look into other options to package and distribute your app such as \`deb\` or \`pkgbuild\`. maybe something like flatpack will fit your need. &amp;#x200B; Also a download of a tarball with an install script could be an option.
Is there a way to automatically remove unused imports? I tried `rustfix`, but it doesn't seem to handle unused imports. I was doing a bunch of refactoring, and now I don't want to go to every file and remove them by hand. Somebody save me pls.
I'm sure there's also a massive sampling bias here: people who came from JS/Python, were able to learn rust, and kept up with it are far more likely to follow this subreddit. On the other hand, C/C++ people without Rust experience, or who tried but couldn't grok it altogether, might follow this sub anyway, due to it being close to their work, and it could be useful later.
But they only live as long as the cargo build cache does. If it is cleared, then it's all gone.
Ah, interesting. Thank you!
Perfect example [here](https://github.com/pauldix/monkey-rust/issues/2). He's trying to port an interpreter from Go to Rust but it leaks due to the lack of GC. 
I came to rust from a Javascript/Go/Haskell background and while I didn't find it hard to learn in theory, I still wouldn't call myself great at working with borrows. I think the project you try makes a big difference though. My first real rust project was a functional compile-to-CSS language and that was a great experience. Ownership worked nicely, very fast, makes great use of enums and such. My current project is a networking one using warp, websockets and a bunch of futures for file streaming, and it has definitely been a struggle figuring out how to satisfy the type checker (notable pain points include hyper response bodies needing to be the same type which was a pain - perhaps I can box a trait here to work around it? - and consitionally returning different futures from a function means either boxing them or, if only a couple, future::Either). I haven't tried async/await on nightly yet because I'm waiting for other libraries to catch up etc, but I'm hoping that will alleviate some of my pain points. Either way, I definitely feel like I'm learning a lot, but I am sad to say that I could have written my networkingy thing a lot lot quicker in Go (a language I have a somewhat love/hate relationship with) .
How does Amethyst compare to something like ggez? I've thought about making a game but I'm not sure which to go with.
&gt; Is P parameterized or not? Or is the idea of HKT that it's parameterized *only* when being used? The latter - HKT allows you to have an `M: MyTrait` which still has some parameters unbound. Variables have to have concrete types, so you can't do `let my_var: M = ...`, you instead have to do `let my_var: M&lt;T&gt; = ...`. So in this example, `P: RcPtr` still has an unbound parameter, and so `right: P` wouldn't be valid because `P` isn't a type. `P&lt;TreeNode&lt;T, P&gt;&gt;`, on the other hand, is a valid type. &gt; I seems to run into having to construct an infinite type signature when I try... This isn't valid Rust today. The point of the article is to demonstrate that it's possible to *emulate* in today's Rust. But yeah, if you try to construct something like that directly (rather than using a hack like is demonstrated in the article), you'll run into various problems.
&gt; One example of deviation above was the lack of tail call optimization. But this fits in perfectly with Rust’s goal of predictable, high performance. How is TCO unpredictable and slow?! 
Can you write the TreeNode type + a type instance that compiles in Rust using your trick?
Here it is, I updated the report: https://lovasoa.github.io/json_in_type/docs/criterion/report/
So, any news as to what the DMCA takedown request that brought the site down was about?
You can indeed! I link to a [full example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=d280c71819f6d698e05ab3ec448f2394) in the blog post.
This post is hitting on the main reason I don't get to use rust day to day. Not being able to call directly into Qt and opencv via c++ .so's and .h makes it impossible to use rust everywhere for me. I really hope someday we'll figure out how to work directly with vtables, even if it's through unsafe code.
I thought about that, but them I'm not sure of where I could put them. As cargo doesn't allocate some kind of folder, besides the home directory which I'd prefer to avoid, I'm not quite sure.
Sweet! Keep keep them coming and thank you!
Argon2 is memory-hard, meaning that you can't use specialised hardware to brute-force it like you can do with bcrypt. It's easy to use, won the [Password Hashing Competition](https://password-hashing.net/) in 2015 that had plenty of scrutiny. Don't get me wrong, bcrypt is still decent today (emphasis on today), but Argon2 is by far better, and future-proof.
Yea, I was originally thinking how I could Wrap Option around the struct for data, but this is absolutely right. But can i ask, what is the difference between \`&amp;\[T\]\` and \`&amp;Vec&lt;T&gt;\`?
/r/playrust
No way to automatically remove them as far as I know. Do you need to identify which ones to remove? 
As explained in other comments, this is unlikely to happen at sale in a generic fashion anytime soon because C++ does not have a standard ABI. There is no way to know what the calling convention is for a compiled vtable implementation. So you could make it work in certain conditions, but it would break as soon as you ported the code or rebuilt the C++ code with different flags. It's not really Rust's fault, any language would have trouble doing so.
The explicit &amp;self when doing methods.
What would the IDE have that Clion + IntelliJ Rust don't offer? 
While I know my answer is pretty shit for your question, I just want to point out that if you do any Python development, PyCharm is *way* more useful than IDEA + IntelliJ Python. If you do Django development, it's night impossible to go back to anything else.
OP here, thanks for pointing out, I had heard about it before but never paid much attention, bcrypt has been my go to algorithm for password hashing so far. I'll definitely have a look Thanks for the suggestion 
Unless you're a programmer and consider writing code a game, you probably wanted the /r/playrust subreddit. Feel free to stick around if you're interested, though!
Huge thanks to everyone who worked on making this happen! I absolutely love intelliJ and its support for Rust! You all rock \ (•◡•) /
What's the language on this side of things y'all play rust???
 fn main() { gtk::init().unwrap(); // Create the main window. let window = Window::new(WindowType::Toplevel); // UI initialization. // ... // Don't forget to make all widgets visible. window.show_all(); // Handle closing of the window. window.connect_delete_event(|_, _| { // Stop the main loop. gtk::main_quit(); // Let the default handler destroy the window. Inhibit(false) }); // Run the main loop. gtk::main(); } I believe this example should be updated to conform the gtk3 style. Something like extern crate gtk; extern crate gio; use {gtk::*, gio::*}; fn main() { let uiapp = gtk::Application::new("org.gtkrsnotes.demo", gio::ApplicationFlags::FLAGS_NONE).unwrap(); uiapp.connect_activate(|app|{ let aw = gtk::ApplicationWindow::new(app); aw.set_default_size(320, 200); aw.set_title("simple_example.rs"); aw.show_all(); }); std::process::exit(uiapp.run(&amp;std::env::args().collect::&lt;Vec&lt;_&gt;&gt;())); } might do. Any reason to follow the gtk2 style?
`&amp;[T]` can be part of a collection, while `&amp;Vec&lt;T&gt;` is always an entire collection. `&amp;Vec&lt;T&gt;` can do whatever operations are listed [here](https://doc.rust-lang.org/std/vec/struct.Vec.html) that take `&amp;self` as a parameter, but `capacity` is the only non-trivial one that slices can't also do. `&amp;mut Vec&lt;T&gt;` can add or remove items in the middle of the collection, while `&amp;mut [T]` can only edit the elements themselves.
Is there anyway to get a quick code review, or even a guideline I can judge myself against? I’ve written a small library interpreting Brainfuck, (just as a toy to learn the language) and I’m wondering how well it’s a being a good rust citizen. 
Considering this is the 36th most downloaded crate according to crates.io, there should be a few people that have an opinion. Everything looks clean to me. Implementing the Error trait as wezm suggested is only obvious thing I see as well.
help us cure electron ram cancer
No. `cargo check` shows all of them, but it just seems tedious to go through them by hand.
I picked the wrong day to learn rust...
Publishing a link here usually leads to reviews!
Pretty cool to see the ray tracing demo run with 8 threads on my phone!
I've been using this library for a personal project, the only problem that I had is that "normalized" is a very big word, I would prefer something like "levenshtein\_ratio"/"ratio\_levenshtein". Besides that, I never had a problem using it!! Great work btw
Solid crate. I've been using this in a project that needs to process a lot of data and respond quickly. Most of the methods allocate a Vec to compute things, and to gain a little performance I wrote an implementation that re-uses the same allocation over multiple calls. Maybe such a pattern could be added to the crate, I'm thinking something like this: let mut matcher = strsim::Matcher::new(); matcher.levenshtein(a, b);
Wrong subreddit. You're looking for /r/playrust
Hmmm, it might not be amazingly fast, but it seems doable without getting ridiculous on complexity using some kind of Trie
Add new gitbook layout to https://github.com/rust-lang-nursery/mdBook :)
Given that the next version of Ethereum is using wasm for its chain-code, this makes a ton of sense. Nice too see Ethereum entering the rust ecosystem this way. 
Heads up there's an installable cargo subcommand to build deb packages, probably others too.
/r/playrust
great work!
Looks cool! I think more people would be interested if they knew up-front this is a `make` alternative. Took me a bit to get that but after realizing that, looks nice! (I originally thought it was a cargo replacement, which seemed like a much stranger project to take on)
You may take some inspiration from the arewe*yet sites: http://arewegameyet.com http://arewewebyet.org http://arewelearningyet.com https://areweideyet.com
"cargo new hello &amp;&amp; cd hello &amp;&amp; cargo run ." did not work. It generates a library target, with no main.rs to build. 
Went to Rust Belt Rust, which was thoroughly awesome, and played with my distributed hashtable experiment more. I'm using the `quinn` rate for networking, which is on the one hand great 'cause it uses the QUIC protocol and that adds some very nice features, but on the other hand it's still in heavy development and there's the inevitable bugs. Currently working on refactoring the communicate-y bits out from the decision-make-y bits so I can test them both independently, but it's tricky in such a fundamentally network-based program. Also did some work on ggez, a cross-platform 2D game framework, cleaning up bits and pieces and trying to hammer down on neglected issues a little. I promise we'll have version 0.5 before the end of the year, honest!
Don't have to wait either :)
&gt; "cargo new hello &amp;&amp; cd hello &amp;&amp; cargo run ." did not work. That's because you did it wrong. Go back and check the syntax *carefully*.... even a period out of place matters.
With or without the period it doesn't work, as "cargo new hello" generates a library project, not an application. 
As my native language is a Romantic language, I feel the same, since we use the "same word" origin to say the same, but when I read statistical books and papers in English, I often saw "ratio" being used as synonymous for "normalized", probably because it is a way shorter word. As a programmer, a feel that functions and methods should be clear of what it does, but I also feel that if there is a way to still be clear and have a shorter name, it should be chosen the shorter one.
&gt; Can't wait for AV1! I'm hoping to store my movies using AV1, Opus and Matroska in a near future As soon as I found how far along they really were after the code freeze, I stopped converting everything to hevc in anticipation. 
Levenshtein and LevenshteinDamerau could be considerably accelerated if the distance was capped.
I meant, I want to test that my crate compiles for freebsd targets, and that all tests do pass there.
The issue is that `Read` trait has `std` only methods like `read_to_end` and `read_to_string` which do in fact depend on `std`. Unfortunately, I don't think it's currently possible to have the trait only enable those when you are using `std`.
Supporting alloc is doable, but duly noted in general. I may end slicing it out by hand but definitely not ideal.
We updated examples but not documentation. I'll open an issue for it. Thanks!
Hi. I have a follow-up question on this: When I need to create a \_large\_ interface between my two components, say, I have mulitple rust data types which need to be transferred, both components need to call eachother (not only one calling the other) and so on... would it be possible to use the rust ABI interface? I think of something like this: The loading component uses a C interface to check whether the lib is in the right version to work with (for example \`get\_major\_version()\`, \`get\_minor\_version()\`, \`get\_patchlevel\_version()\`, and if everything is correct it continues with the Rust-only interface? Does that make sense to you/would this be possible?
While it would probably be backwards incompatible, there's the possibility of extension traits. Something like: #[config(alloc)] pub trait ReadAlloc : Read { fn read_to_end(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt;; fn read_to_string(&amp;mut self, &amp;mut String) -&gt; Result&lt;()&gt;; } #[config(alloc)] impl &lt;T&gt; ReadAlloc for T where T: Read { ... }
I sometimes do Django development in IntelliJ Ultimate with the Python plugin. As far as I've seen, the only real difference to PyCharm (which I've also used, but it was a while ago) has been that PyCharm is less cluttered, since it does not have any Java-configurations. Is there something that is exclusively in PyCharm that I'm missing?
The problem with a Trie is having a substring not starting at a larger string like `"hello world"` and `"world"`. With a Trie you'd need to put in it every substring starting from every position until the end of the string, like `"ello world"`, `"llo world"`, ….
That's the cost of heterogenous lists, might be improvements in rustc but most of the obvious wins have been done already (it used to be much, much worse at these kinds of nested types). I think it's possible to encode the lists as binary trees instead (or N-ary trees perhaps) which would reduce the depth of the types being generated which should in turn reduce compile times.
I saw many libraries that implement string similarity metrics in different programming languages and I found one thing which is important for me that is always missing - a way to get what characters in string are different. I want to highlight what characters from my query are matched in a list of the results: &gt;query: ABBC &gt; &gt;Results: &gt; &gt;**ABC** &gt; &gt;**AB**D**C** &gt; &gt;**ABB**B**C** &gt; &gt;**BBC**D &gt; &gt;DD**AABC** I've tried to do this with fst-levenshtein but failed since I don't know the theory of how to make it happen (I made only a half-working frankenstein).
Because nobody has given you some thumbs-up here yet: This looks like a really useful library! Thank you for sharing!
Hi, How do I convert a json string value to an enum, where each known alternative maps to an alternative with no payload, and unknown strings maps to Unknown(String)? I’m using serde to convert some Json to my own data structures. Part of this json contains a string field that describes the type of problem something has. Most of these strings are known, but every so often the server that gives me the data gives me something new. 
Frunk seems super cool! Its HList could very well be used to store json objects and arrays. I will play with it when I have time. However, it doesn't seem to be using the btree trick you mentioned above. It also generates types of depth n for lists of size n, doesn't it ?
Here you have a nice overengineered FizzBuzz: https://gitlab.com/snippets/1768330
Ultimately I want the tool to target Windows and macOS as well, so I'm not sure deb packages would be ideal here. I liked the cargo install approach because it was cross-platform and relevant to the Rust development environment.
"Transformation" programs where you just have to change some input to some output and then you're done are probably the easiest type of program to write in languages with restricted state access (Rust, functional languages). They're mostly just pure functions with very little global state. That's why you see so many parser-type programs written in functional languages (e.g. pandoc). Interactive long-lived programs like games, GUI programs, and servers are a lot harder.
What do you use as engine? Amethyst?
I mean it gets the right auto-complete list maybe 10% of the time for me. That might be "alright" if you're coming from Python, but compare it to Java (rock solid 100%) or even C++ (probably 80% depending on the IDE) and it's pretty awful. And actually even in Python there are two autocompletion tools I know of that do a pretty amazing job considering it is so dynamic - PyCharm, and Microsoft's new VSCode Python Language Server. Both are much more reliable than RLS or Racer and they don't even have type information.
Things you did not do: - Check the if the subreddit you’re posting to is the right one.
Why thank you, good sir!
&gt; curl https://sh.rustup.rs -sSf | sh No. I will not do this and you should not not put this in your tutorial. This is a bad habit for obvious security reasons. Please don't propagate this idiom. 
I think this can work as an intention even without macros (b/c false positives are ok in intentions)?
Have you an other safe way of doing this ?
Rustup is in many distros package manager.
cross platform gui with the same feature set as electron but better performance. see ya in 5 years! &amp;#x200B; IMGui clone written in pure Rust (more realistic) &amp;#x200B;
What do you have planned for lesson 2?
Nice. Are any PRs welcome for the [examples](https://github.com/gtk-rs/examples) repo?
I prefer grouping by type and that's also what I've seen in the standard libraries, hence I think that is preferred. 
The author is /u/snoyberg
Thanks for the ping /u/rustcvswvj. I'm going to be covering some basic walkthrough of ownership and borrowing, and stepping the reader through implementing a simple "game" with a bouncing ball. I'm experimenting a bit with the format, but so far it seems to have worked for my test audiences. Feedback will definitely be appreciated so I can fine tune things.
I have now replaced `..` and `*` by `...`, as requested by many folks. Thanks for the feedback! :D
Working on [subdivision surface](https://en.wikipedia.org/wiki/Subdivision_surface) this week: [issue #67](https://github.com/wahn/rs_pbrt/issues/67) 
but endusers need to have the rust toolchain installed then.