You say "mediocre" like it's a bad word?
Why the downgrade?
A few other Rust contributors made this comment when we saw the first preview. Glad to see it's a shared feeling!
I can currently think of two approaches: * Indeed using an iterator of `Option`s plus combinators: s.chars().rev().enumerate().map(|(i, c)| match c { '1' =&gt; Some(2u32.pow(i as u32)), '0' =&gt; Some(0), _ =&gt; None, }).fold(Some(0), |acc, cur| acc.and_then(|acc| cur.map(|cur| acc + cur))) I don't know how well this is going to be optimized by the compiler — or how human-readable this is. * Via classic imperative loop: let mut sum = 0; for (i, c) in s.chars().rev().enumerate() { sum += match c { '1' =&gt; 2u32.pow(i as u32), '0' =&gt; 0, _ =&gt; return None, } } Some(sum) 
Onward :D 
I find Topology one of the most beautiful things in mathematics actually .
Good idea
Programming is rarely a goal by itself, and with other systems programming languages the barrier is often high enough that they're not worth reaching for to solve the problem at hand.
That's pretty long ...
ThisOneIsMoreOfAStickerReally
i suspect that there are a lot of companies that will provide desktop and server RISC-V systems, and i know that redhat (through fedora) is already thinking ahead in the direction of servers: it's why Richard Jones made sure that fedora was one of the very first distros to be available for RISC-V. so... you'll get your wish, i'm pretty sure :) yes there's RISC-V dev boards... ok, what they actually have is a stonking-great really good FPGA break-out board, on which it's possible to put a soft-SATA / soft-PCIe implementation, using the FPGA's dedicated high-speed general-purpose differential pairs. the costs are... unfortunately, quite mad for a "user", however for from a product development perspective they're extremely reasonable. 
&gt; It's what we hear from a *lot* of our users, especially those that come from non-C++ backgrounds. "I didn't think that I could do this kind of work, but with Rust, I can." And, it is one of the goals of the project overall. I can very much see where you're comming from, but I don't think that experience can be conveyed in one sentence/slogan. It's a sort of a _"No one can be told what the matrix is, you have to see for yourself"_ thing, if you pardon the dramatic movie adage. In other words: A reasonably easy and more direct access to an experience will be much more convincing than a slogan which, while true, still _only describes_ what the experience is like. Some other guys mentioned the Go tour as an inspiration. I believe we already have that with the Rust-by-example, originally created by japaric if memory serves. I can see Rust-by-example is no longer linked from the new website. Why? I would say it needs **more** exposure, not less. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rust_gamedev] [Should I learn C++ or Rust for game engine development](https://www.reddit.com/r/rust_gamedev/comments/a1r4s2/should_i_learn_c_or_rust_for_game_engine/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt;I haven't seen the talk by Kathy Sierra that inspired Dave Herman's blog post Do you a link to those two things? There's plenty people name Dave Herman that have a blog... Cannot find something. 
&gt; Even though it is not that useful when you don't work with graphics. What I love about having studied topology (a long time ago) is that it instilled in me the expectation that one problem can be transformed into another problem in a more intuitive setting, and a basic set of tools for applying the transformation. And so much of it is taught with respect to geometry, which is perfect for gaining intuition about abstract problems. 
Thank you very much!
&gt; new versions of rustc have been compiled by the previous versions of rustc Then the produced compiler from that stage is used to compile the current version (again).
C++
I don't like powerful to define a language, It can mean pretty anything : - The ability to do something few lines of code. (Perl is powerful) - The ability to make advanced metaprogramming (LISP is very powerful) - The ability to write anything and have something that seem to work ( JavaScript is very powerful) - The ability to guess how compiled code will look like (C is very powerful) - The ability to learn the language quickly (Go is very powerful) - The ability to do what my favorite language do (My favorite language is very powerful) 
&gt; And given how you ignore my example of outright hostility when a woman integrated the team, that’s just illustrating my point. or you didnt actually give an example of anything and just said random usernames expecting me to magically know what the you're talking about, let alone any evidence. Mostly the no idea what you're talking about though. &gt; No one is entitled to someone else’s emotional labour. Exactly. So your friends aren't entitled to everyone else bending over backwards, kidnapping them and forcing them to be in the community to show how welcoming we are?(Because you've made it clear they're incapable of being in the community themselves, obviously the only option is to force them somehow. Then they can see how welcoming it is and be willing members!) Think whatever you want crazy, but you're, well, crazy. You're living in a fantasy world with a bunch of made up enemies, and want everyone else to somehow include you when you *explicitly* don't want to include yourself? You can't be included in something you don't want to participate in, crazy, You can't be represented as part of something you're not part of. It's not a hard concept. ---- i'd like to note you still havnt managed to respond anything i've said, though. You've made replies, sure, but you havnt *responded*. Again, how do you expect people to be represented as part of a group they *explicitly* don't want to be in, when you *actively refuse to be represented*.
I'm on the same page as you in general. As a matter of fact I'm currently holding off finishing a kext audio driver for my sound card (macOS driver) because the only option is writing it in C++ and I just don't want to do so. I'd rather put in the time to generate the Rust bindings and write it with it. Also, I've been working (kinda) full-time Rust for around 2 years, so don't worry; Even though I'm leading the engineering at my company so it's easier for me to introduce arbitrarily new technologies to the stack, I've made the right move, and I'm literally STARVING for Rust applicants. (PS: If you're in France -or looking forward to move there- and want to build IoT/graphics/backend/critical tooling stuff with Rust, hit me up)
Unpopular opinion here apparently but I think it looks great. I will admit to missing the code tester. 
Welcome to Reddit. Before posting to a subreddit/forum/community, you should check to see what that subreddit is for. This includes reading the sidebar and the rules. You should also pay attention to warnings that you're posting to the wrong subreddit. Check /r/playrust.
Yikes! If there was ever an identifier likely to be misspelled!
Wrong subreddit. This is for the Rust programming language.
You were *told* this is the wrong subreddit half an hour ago on your other post.
someone pointed out that those key features are mentioned in the immediately next section of the site.. but those "next" sections don't matter to sites like Twitter and others. All they grab is the site's title which is obviously the new slogan - that doesn't tell what it's about. &amp;#x200B; The new slogan is also feels Abstract
[Nymi Careers ](https://nymi.com/careers) We have one SDK developer position posted but we are actively hiring a number of on-site Rust developers from those who have experience with Rust through to talented junior developers with some work experience who want to learn Rust and use it everyday. We aren’t looking at remote candidates right now as we are building out our core team in Toronto. Relo and sponsorship may be possible. If you want to apply send me a link to your resume and portfolio (github, LinkedIn, etc) privately. 
Content is OK. But consider reducing contrast a bit more. I see that the black header text is not completely black already, but I wish it was a bit more grey. Another issue with contrast is jarring colors. Please focus on content. When reading a header, now it is hard to focus on actual content, instead I keep thinking "wow, It's the first time I see two contrasting colors meet up in the middle of text". Also, it is difficult to make such different colors work, because they have different intensity. A white text on one color should not be the same white, they should be tweaked independently to look good, because the human eye sees the same color on different background differently. If I tried to offer direction how to do it, I would say "make it more analog" "use colors in the same context (i.e. background) that look pleasant together". Also I don't think that the beauty is in the eye of beholder in this case. We are all human, and we are all react to content in similar way. If you open the page suddenly, try to track where you gaze lands first. Currently, it is everywhere, because each element in the page tries to stand out, and they try to stand out in different way. The main rust text is bold, the tagline "Rust The programming language that empowers everyone to become a systems programmer" to way too black, GET STARTED is all caps, Why Rust is completely inverted color and Build In Rust has another header background for some reason. It is not clear where to look, everything demands attention, at once. Each new section having a different color feels like another banner. It is possible to tone down some things and make the reader gaze flow naturally over content. Look at https://www.python.org/ site. It is by no means a masterpiece, but they have at least chosen what we should pay attention to. First thing we notice is this yellow color, that invites us to look and try the language. When we are done with that, we notice white section bellow with more information. Headers there don't scream "look at me immediately!", because that's not necessary. The Blue and White background separate different exploration contexts: blue seems to be "sneak peek" of the features, and white - let's do actual work. In the beta rust site background means "I am another section". We can do better.
Being fast, and preventing bugs at compile time . I do most of my work in julia (which is a dynamic language) but have been trying out rust for some small stuff like a ray tracer and quite like all the help you get from the compiler. 
[try\_fold](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold) is useful here. It works like [fold](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold), accumulating over an iterator, except it will return None immediately the accumulate function returns None: fn from_binary(s: &amp;str) -&gt; Option&lt;u32&gt; { s.chars().try_fold(0, |i, c| { match c { '0' =&gt; Some(i + i), '1' =&gt; Some(i + i + 1), _ =&gt; None, } }) } &amp;#x200B;
Yeah, shouldn't have done a single selection poll. One of the Rust guys said about 5% of people downloading Rust documentation is win7, that would probably be the most accurate statistic. Was curious what the whole spread would look like.
I agree with you, except that most of our community are not experienced advertisers and these are high-stakes communication ways that easily backfire. It's a terrible standard to set.
The new slogan is bad, imo. The blog states that you're not sure you like the term "systems programming," and yet the new slogan manages to remove everything that actually explains it (fast, safe) while still leaving the term itself in. The new slogan effectively tells the reader nothing, except that rust is a programming language. &amp;#x200B; I also think the language of "empowering everyone" is kind of meaningless and dishonest... it's not true that everyone can become a systems programmer, and it isn't clear who the set of people that couldn't be one using C but could be one using Rust is.
Neat!
[Here](https://github.com/rust-lang/rust/pull/31954) is the initial pull request adding it, but keep in mind this is pretty old and things have changed since then.
Oh, thanks much, I dont know why I did not think about looking at pull requests... Lol.
If "Safe" is subjective, then most of the information on the new homepage is subjective too - there are remarkably few hard facts. We could use a somewhat vague initial statement, and describe the characteristics more precisely in the following paragraphs. E.g.: "Rust is a safe and expressive systems programming language." Safe: * guaranteed memory safety * threads without data races * easy-to-use testing &amp; fuzzing Expressive: * zero-cost high-level abstractions * pattern matching * type inference Systems: * C-like speed * minimal runtime, no GC * efficient C bindings The bullet points themselves can be further expanded via links. I'd also like to mention Cargo prominently, because C++ folks can appreciate a good package system, but I can't come up with a concise way to do that.
I really like to introduce rust to my friends with fizzbuzz [playground link](https://play.integer32.com/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=99e6ce419624257a9944164af7ce9453) I like it because it uses a familiar algorithm with one of rust nice features so even people unfamiliar to rust can probably follow the example and hopefully think it's a neat feature. 
Yea, crypto is cool, but I was just wondering why a lot of the jobs posted in this subreddit seem to be for crypto companies.
It's pijulman! Do any of these algos also detect movements? 
I was aware that you could use RLS with vim. I think the feature I like most from RLS isn't the autocomplete but type discoverability w/ hovering over functions/variables. It's the feature I use the most, I'm sure it's available in vim also. In VSCode I have a hotkey which activates the hover functionality so I don't have to use my mouse. I also use the vscodevim extension to add vim-like functionality to vscode, it works well enough.
Not sure I get it?
"Knocking against bare metal" is programming directly against the hardware and not through several layers of abstraction and frameworks.
You like everyone else are ignoring the fact that regardless of the *overall model* of the engine itself, there will never be a day when Unity, an engine where the API is exposed in C#, does not contain large amounts of nested, straightforward single inheritance (something that again *does not preclude* what you're calling a "data oriented design" in my opinion). You're focusing on something that is not directly related to the issue I'm talking about. I don't care about having any kind of childish "OOP" vs "not OOP" debate because I'm not interested in sitting around framing things with vaguely defined terminology in the first place.
I care
Are these long-running tasks? Process creation is quite heavy 
Never heard of that figure of speech, to be honest. Furthermore, not everyone is familiar with the "knock knock, who's there" jokes.
To be honest, I tried googling for it right now and get no results for that expression. I don't think it's common enough to be an accessible pun. But then again I'm not a hardware programmer so it may just be a very deep inside term that I'm not aware of or could find.
No. I don't know how to detect movements. Also, it's still unclear how Pijul would handle movement, its theory is not really ready for that.
Considering how horrid the Rust is for the beginner (it's delightful but it needs you to start thinking in different terms) I feel that the new design is over-simplifying the premise to the point of being slightly ridiculous. The old page told me: this language means business, you can solve a really specific nasty problem that you have with it and we guarantee a no-nonsense service. It did it so solidly I was sold on the language by reading an article and looking at the web page. Then I read the book, tried out cargo and it was a delightful experience. What the new one does is like.. Like tank salesmen had gone to an agency that usually promotes haircare products and let them set up their home-page. The company tells you're not selling death, you're selling security. So we hide the nasty tank and show you a picture of calm peaceful downtown neighbourhood that your tank could provide. I feel that the truth might lie between the two designs. Lose some of dryness and lose some of that soapy salesman vibe.
...it's a good question. Dunno, never go around to that. Also, I _believe_ the that `FnOnce` would be a better fit for a Lambda handler, because handlers only get called once per Lambda invocation.
&gt; we are building out our core team in Toronto You might want to add that somewhere -- https://nymi.com/careers/embedded-software-developer shows "downtown location" but doesn't specify which continent has the downtown where you'd work. ;)
So, since \`r##\` and ilk are language features, it makes sense that it wouldn't be in documentation for libraries like \`std\` or \`hyper\`. Steve has given you a link already to the correct source -- I just thought I'd add my two cents trying to explain why they're not there. :)
You’re making the assumption that it all fits in memory; nowhere near. 
After working through a bunch of these, I feel like there's some linting opportunities. :D [\#2](https://dtolnay.github.io/rust-quiz/2) in particular stood out to me. Yowzers. On the other hand, how likely is it that someone would actually write that by accident? Maybe not very...
Seems like there's two easy options. Use something like `bindgen` to automatically turn ABI-less Rust code into something other things understand, which sounds like what you're suggesting. Or define an ABI but not use it by default. So instead of `extern C` you could do `extern RustABI_1.3` or whatever.
I second this. I'm not a big fan of the word systems either. For me a system is just like a process, something that we name a flow of actions and that doesn't necessarily have anything to do with a computer. What wouldn't be a systems language? I'd say that low level or closer to the hardware is a better term, but I don't think that fits in a punch line either. 
All crypto companies have started running in the last 10 years, broadly speaking. The more recent ones in the last two. They chose modern, popular languages to build their core protocols with, as opposed to established companies who are encumbered with old technology. And also Rust, and strongly typed FP languages along with C++ lend themselves well to building the protocol for a distributed blockchain. 
The new slogan sounds a little bland and doesn't say much, agreed.
Yeah, my theoretical lib would be a bit like bindgen, just for Rust &lt;-&gt; Rust. Don't know how much is possible with macros, I think the scope of traits could be one problem, since the compiler has to know where they come from.
That won't work for the same reason there is no ABI now: nobody is willing to commit to specific representation of all those concepts (and new ones can be added). Also when ABI will be defined (and this will most likely happen at some point in the future) Rust would be stuck with supporting two of them.
I dislike the color scheme. It feels very incoherent. I would use a two tone at most, and probably use something red/orange since that seems to be Rust's branding. Maybe add the mascot to make the page feel fun, since Rust's biggest issue is intimidation. &amp;#x200B; I also don't like the headers, they don't feel very professional. The contrast on some of them with the foreground text color is jarring. &amp;#x200B; You should add the same program back, people should get a taste of what Rust looks like on the homepage. &amp;#x200B; The slogan is bad. Systems programming is at once overloaded and also limiting.
Since there is no roadmap for ABI now, it could still be far into the future. So I think it's worth exploring the possibilities. At the point one is defined, other solutions would just become obsolete - nobody would need them anymore. I agree this would be a problem when included in the compiler - one reason it has not already been done.
I liked the new marketing, it is much better. The visual, however, is worse than the old site.
It wouldn't be the first time such a thing has been thought of. I've mentioned the idea of a `Rust &lt;--C--&gt; Rust` binding in passing on various occasions because, currently, if I want an acceptably convenient option for dynamically loaded plugins, I resort to architecting my projects such that the PyQt+rust-cpython frontend is responsible for plumbing all the Rust backend bits together. (eg. using a Python plugin framework and then passing function pointers to the Rust backend to connect everything together.)
Does this library support any standard output formats? eg, [unidiff](https://en.wikipedia.org/wiki/Diff#Unified_format) 
It's not OOP vs DOD. It's that DOD is fundamentally different than what you are assuming, and making arguments about how Unity will never change even with DOD in there, not understanding what you are saying. DOD is not based on some programming abstraction, it's based on the physical limitations of how computers function. It is more akin to graphics pipeline programming. And OOP and GC were invented before these physical limitations were known. So they have a big job ahead of them to resolve that in Unity. They will have to change to support it. Most likely they will provide two APIs, one for DOD and one for legacy, and encourage movement to the new one, and eventually remove the old one. The new one will probably not be based on inheritance but based on how shaders work where you define transformation pipelines between data formats. 
Do you have any pointers if there were similar discussions before? Maybe macros have improved enough that this is feasible now when it wasn't before.
"Doing a get request in C++ is like trying to summon a devil" why would anyone even use c++ for that? I use c++ because literally all other languages lack the libraries I need. *Every* modern language has good tooling for those trivial tasks... I would actually even purpose using a more tailored (erlang based?) language for that.
I switched from C++ (and D) to Rust in late 2014, no regrets :D 
This!! This!! I'm a programmer, and not a skript kiddy. I want information, not marketing. Programmers pick a language in order to solve a problem, not as a lifestyle choice. Tell me what problems this tool solves. Rust is \*clearly\* not for everyone, at least currently. Systems programming is \*clearly\* not for everyone. Claiming that either of those is true is disingenuous. I'm all for promoting Rust, but lets promote it on its real merits, not some fuzzy aspirational nonsense. I see little in the new site to recommend it. I can't say I've been wishing for a change in the first place. &amp;#x200B;
How far is toy-lang from usable in production? How limited is it and how much further do you intend to extend it? 
Thanks for mentioning our VST crate at the end :) I hope that Rust will become more popular for writing VST plugins.. Btw, do you know if any company in the audio DSP industry is considering using Rust in the future?
If you're interested in a crate that takes care of some boilerplate when writing VST plugins in Rust, to make it easier, I invite you to check out my [easyvst](https://github.com/Boscop/easyvst) crate :)
it's terrible on desktop too.
you can just use `#[no_mangle]` and `extern "C"` in your public API declarations? then just about anything can link to you.
Totally as per your convenience - I'm happy to watch the recorded videos later as well. Thanks a lot for considering this :) 
I'm the author of [soup](https://crates.io/crates/soup) and though it does not offer the selection syntax you're looking for, I can write your example with soup like this: doc.tag("img") .attr("src", Regex::new(".png$")) .find_all() .collect();
Church–Turing
But I think selling "systems programming" is not the right pitch for most people, especially not if they associate it with pointers, segfaults, low-level code.. Why not sell Rust as a general purpose application programming language that also runs blazingly fast, prevents segfaults etc. Because most programs that people will write in Rust wouldn't be considered in the "systems" domain, but normal applications (web servers, cli tools, data processing etc.). Also, I think it makes sense to show different code examples on the front page (like the D website) but also using other crates. E.g. there could be an example that uses reqwest to make a GET request, one example that uses rocket to respond with a greeting, one serde/json example, etc. The same "most used crates" that are included in the playground would be good crates to use for these examples. This is what gets people interested!
Ich8
Of course it doesn't fit if you need MapReduce. But that's the whole point of this new generation tools, to keep as much possible in memory and to bulk transformations on a single read. But anyway, I was just being curious and it looks your current setup works well for your use cases :)
Also I forgot, thanks for open sourcing Efflux!
I won't steel it.
How on earth did they debug that into a working shape?
Thoughts on documentation and examples?
It doesn't have string or dictionary types, so it wouldn't be very usable for basic scripting in its current form. One could add such things, provided one adds runtime support. I don't have specific plans to extend it any further right now, because my main goal was just to give an example of how to use the Cranelift APIs.
&gt; The precision might be good for a spec, but not for a document which is trying to explain and gain some interested people to help. This might be the core issue, actually. This document *is* written and intended as a spec; which is why it errs on the side of accuracy, at the cost of verbosity. I am thinking that I should probably add a "short" section toward the top which explains "in a nutshell"; a sort of "motivation" section, with short examples of how one can *use* existing reviews and *publish* their own reviews. &gt; Anyway, I don't want to shut you down. A lot of people give me a skeptical feedback, and I don't worry much. I give you skeptical feedback, don't worry much either. :) No worries! Positive feedback is good for feelings, but negative feedback is good for improving :)
No, but that would be a great contribution!
well most interpreted/dynamic/scripting languages don't implement their own interpreters (python, clojure, ...), so I think the "compiled" qualifier is valid
I have a type `Wrapper&lt;T, U&gt;` that holds a `T` plus some extra data `U`. I want it to act like a `T` in almost all cases, including conversion. Thus, I want to impl `From&lt;V&gt;` or `TryFrom&lt;V&gt;` if `V` implements them and just carry the `U` to the new object. Because of the blanket impl on `TryFrom` though, there's a conflicting definition of the `TryFrom` impl. Is there any way around this?
I'd love to watch too if you end up doing it!
They're all very good. We've got some larger examples and documentation in the works.
compiling to human-readable C might be interesting? e.g. turning trait-objects into structs holding function pointers, but in general the name mangling would get out of hand .. that's just the nature of a highly polymorphic language 
Keeping things at u8 makes a lot of sense! The [book chapter](https://doc.rust-lang.org/book/2018-edition/ch20-00-final-project-a-web-server.html) is where I got the convert-to-string code from. Cool @ using `get`, I didn't know about that! I was struggling a lot with trying to deconstruct the string with, say, `let [verb, path, protocol, ..] = request.split_whitespace()`, but nothing resembling that would work. Is there anything like that that could work? I don't really care about supporting more verbs - honestly, other than cleaning it up based on feedback like this, it's done. I just wanted the educational experience of writing it. :)
Having an ABI would enable the creation of binary repositories and possibly do wonders for compilation time, an oft-cited pain point of Rust. See vintage Delphi/ObjectPascal .dcu files for reference. Blazing compilation speed, great component ecosystem.
Constructive feedback would be better: which parts do you like in the old site that you'll miss, which parts don't you like in the beta site that you'll loathe?
&gt; explain exactly how they think "something that contains something else" is in any way a functionally similar paradigm that can serve as a direct replacement for "something that is a slightly modified/extended form of something else" Sounds a bit like the difference between a skeleton and an exoskeleton: They're in different places, but they both provide the structural reinforcement needed by their owner.
They only used a subset of Pascal, so the interpreter could be simple.
I think the issue is that *most* languages proclaim that they run fast, so it's hard to give the idea to someone unused to *real* speed that they're missing out. I've regularly seen languages claiming to be "as fast as C", when in practice they were from 2x to 10x slower in general; guess the footnote "for one specific benchmark" was forgotten :/
r/rust is not an official venue, which may explain why it's left out.
Yes, definitely. I'm batch-processing thousands of high-resolution TIFF images so these are processes that I start at the end of the day and let run overnight. I have multiple Java implementations that can do this; none of them perform at the same level as my novice Rust implementations. This was basically me before discovering Rust 2 months ago: [https://www.youtube.com/watch?v=XEELKEZboBI](https://www.youtube.com/watch?v=XEELKEZboBI)
Rust is hard to learn. I do not feel like it is *too* hard to learn. However, everyone has different experiences. A javascript programmer coming to Rust is going to be stuck with TONS of concepts that they have never seen before and there is no good guides that I know of for the "I've used python/Javascript for a year and want to learn Rust". If you look at the survey, almost 7000 votes for 'most comfortable language' were Python and Javascript. C++ programmers are going to use Rust and feel pigeonholed because Rust lacks the flexibility and paradigms they are used to. A Java or C# developer will struggle because their object oriented approaches are fundamentally different. Developers with functional backgrounds probably have it easiest, but there are still habits to break. Rust is *different* and that makes it difficult. All my programming background is with a 'make it work' mentality. It took me a couple months to make anything work with Rust. But now when I go back to Javascript or Python (or powershell!) I despise that I have to run my program to figure out what types I'm working with. 
Yep. Sounds accurate to me. I love Rust. I think it is revolutionizing what we can do with programming and what we should expect from a programming languages. But it's legitimately hard. I've been working with rust on hobby projects on and off since shortly before 1.0. It took me three tries and a detour to learn OCaml before I felt comfortable with it, and I still get tangled up in lifetimes and type issues at times (mostly when trying to sort out long chains of combinators, these days, particularly in Tokio). By way of contrast, when I tried to learn Go, I felt comfortable and relatively proficient after 2 days. But Go is in many ways a language whose ambition is to make daily programming easy. It has some interesting work in it, like the deadlock detector and the first class channels, but as a language, it's pretty boring. By design. I audited a class on distributed systems last year that used go, and it was a great choice, for those exact reasons: It's easy; it's boring; it does channel-based concurrency really well. Rust is hard, but not arbitrarily so. It's hard because it solves hard problems. Brahms's piano sonatas are harder to play than Mozart's, not because Brahms wanted to make them hard, but because he wanted to express things that Mozart didn't even think about expressing.
Is python the fastest because they keep the interpreter running and just throw new code at it as opposed to starting up an entire new process? I don't know how these are implemented. I wonder if your Rust code could be built as a shared library and have an always-running Rust process that loads in the library and executes it.
I'm not even sure how that end up capitalised! 
Additionally you also need `#[repr(C)]` on all public types
why is Mario anywhere on their page at all? it is literally someone else's active IP, and the slogan under fire mario is silly and doesn't inspire confidence that this is a real, usable product that has a right to be weighed alongside other options as a tool to get the job done.
is the likeness of Mario used with permission from the owners of the IP [ie Nintendo ]? it dilutes the message of Rust being a serious tool to me, even if i like the language in general. 
That's pretty much how I feel. I have C/C++ background from 1988, so I understand the importance to control lifetimes without garbage collection. But at first it's not easy to understand the compiler errors due to ownership changes. It's an unfortunate barrier to newcomers.
I had a sizable project in C++ and came to a similar conclusion. The language itself isn't too bad, especially modern C++, but the tooling in Rust is just so far ahead in comparison. I spent way more time maintaining the build code than I did writing the application code. New features would very often work on Mac or Linux, but then break on Windows or some library would be missing on Android. CMake was more complicated than it needed to be, and it was just never any fun to deal with these problems. Cargo and rustup solve pretty much *all* these problems and it lets me focus more on the code and less on the build infrastructure. Other languages offer that ease of building and running on other platforms, but the fact that Rust programs are competitive speed-wise with C++ programs is what makes it such a sweet deal.
For the second year in a row, my colleague u/Alistesios and I decided to take part in the [Advent of Code](https://adventofcode.com), a puzzle-solving advent calendar, using Rust. We designed a small CLI tool to help us organize, run and benchmark our solutions. We will soon be releasing an online platform to host the benchmarking, and invite everyone on r/Rust to take part on the challenge with us ! Happy advent of code !
I think there's a danger in the framing that "Rust is [not] hard..." in that it elides where the learner is coming from. Is it hard to learn for someone who has never before had a compiler slapping the back of their hand with a ruler every time they make an edit? Yeah, probably. Is it hard to learn for someone coming from a similar language like Swift? Probably not so much.
It is a sequential problem by nature since there is dependencies between the elements. I'd guess you'd only make it slower by parallelising. Though I can recommend the `scan` method instead of `map` for nicer code.
ohh, that's brilliant! Thanks!
Rust takes time and people tend to rush it by not only learning Rust, but going for async IO(which is let's be honest i awful user-wise) which results of course in tons of difficulties. The problem is also that people are inpatient as they are coming from simple languages with VMs where you don't need to worry of such "unimportant" things like memory management and etc I'm pretty sure for C++ programmer Rust would be quite easy to get on though
Thanks for that! Another guy suggested `try_fold`, which is very much like your first one, only with the None value just stopping the entire production. This type of stuff is so beautiful in Rust! I'm learning a lot from reading these responses. :)
My first experience writing a complete application in rust went pretty smoothly, to be honest. Sure, concepts like traits, ownership and lifetimes will take time to get used to, but they've always felt reasonable to me. I think, though I have no particular reason to believe so, that many people who are interested in learning rust will try to implement a tree-like data structure as a beginner's exercise. Unfortunately, this is rather difficult to do in rust and many users will experience that as a major hurdle. 
We need a reverse bindgen for Rust, so you can convert C-ified Rust interfaces back into Rust.
`scan` actually _is_ parallelizable.
Where are you based? I know Ferrous does Rust training: https://ferrous-systems.com/rust-training/
It took me about 3 weeks before understanding the borrow checker and the type system (I just threw .clone() behind everything in the beginning) But it was hard to learn, even though I had a much easier time learning it, because that was around the time I started getting interested in functional programming.
Both of these look very cool. I would ask that you please ensure that you maintain the input in a local file and do not request the input again if that file exists as the input will not change for a given user. It looks like cargo-aoc does this, but not aoc-tools. 
Structs with function pointers are runtime systems, whereas traits can be applied at compile time and optimized for more efficiency of static patterns.
There was a discussion about something like this on internals recently: https://internals.rust-lang.org/t/pre-rfc-nonnan-type/8418 The problem essentially boils down to the fact that there are many, many possible representations of a NaN value, so...which one is canonical?
`aoc-tools` doesn't dictate where the input goes (it just writes it to stdout). I don't really expect anyone besides me to make use of it, so I doubt it'll be an issue. In my own workflow I do ensure that it's downloaded only once. 
Why does that matter? The value _isn't_ a NaN.
This is mostly an aside for my own understanding, but I was under the impression that floats are considered partially ordered instead of ordered not because it includes NaN, but because floating-point precision errors could cause non-deterministic sorting behavior across successive operations. Is this right? Is it both?
I thought for a long time I want a stable ABI but now I'm quite convinced I actually just want a way to expose Rust to a C ABI automatically and have a reverse consumer for such a Rust ABI exposed to C.
The NaN thing is certainly real, regardless of other issues.
&gt; I also wonder if it would have been a good idea to require that division only takes NonZero types for the divisor. Putting aside the ergonomic implications, in practice this would simply move the error from the division operator to the place where you call `NonZero::new`, which would give you a `None`. If anyone out there would like a version of division that returns `None` when the divisor is zero, you can use the `checked_div` method in the standard library: https://doc.rust-lang.org/std/primitive.isize.html#method.checked_div
I'm the colleague, here to answer any question about the soon-to-be online benchmarking platform if you have any :)
I'm pretty sure that for any 2 bit patterns, IEEE-754 defines ordering in an unambiguous way. Yes, doing two "equivalent" operations can give you results that aren't equal anymore due to floating point, but while sorting the data doesn't mutate, so it's safe to expect non-NaN comparisons to give the same result reliably.
Seems i'm in the minority here in that i found it quite easy to pick up on. My background is (modern) C++ and Python, but the "hardest" part of Rust is often said to be lifetimes and ownership. I got into Rust pretty recently though, and things seem to be much easier than they were even not too long ago, so i guess I got in at the right time, and its only getting easier with NLL and 2018 edition coming up. The thing is, thats how i was already trying to architecture my code, already thinking about how long stuff lives and who uses what where. The fact that Rust can do all that for me is pretty great. A lot of people seem to be coming from more high-level dynamic languages like javascript and Python, where stuff like "ownership" or "lifetimes" is pretty much non-existent/automatic anyhow, so i imagine it can be intimidating or challenging to jump into "low-level" Rust *and* two entirely new concepts you have to handle everywhere. I think a more worthwhile comparison would be how long it takes people from similar backgrounds to be comfortable with writing safe modern C++ or C, and how rust compares. Some things are just hard to learn, and theres no way to change that, especially coming from a completely different background.
I mean every possible NaN would be a spare niche right? I know you can have more than one because that's what char does.
Oh, great! Didn't know 'bout `try_fold`. Thanks for informing me, learned something new today, too. Cheers
Totally agreed, but we were unsure about the welcoming of our tool. Like, how many people are interested in the quality of the solution, at all ? Submitting a solution might be a cool feature on cargo-aoc ! We considered adding it, but I'm not sure about the usefulness of such a feature, since when you have a valid answer you still have to go on the website to get the rest of the puzzle ...
Here's what the book has to say on `PartialOrd`: https://doc.rust-lang.org/book/2018-edition/appendix-03-derivable-traits.html#partialord-and-ord-for-ordering-comparisons I don't know if precision errors can cause nondeterministic sorting (if you apply the operators in different orders perhaps, but only if the order of application is nondeterministic, I'd think), but that's beyond the scope of `PartialOrd`. All it cares about are the two values that are ultimately its inputs; whether or not any precision errors occur before calling `partial_cmp` is the responsibility of the person calling the function.
could you give an outline of how it might be done?
&gt; I don't know if comparing NonZero to a hypthetical NonNan type makes sense, because it sounds like NonNan is intended to aid correctness, but NonZero is intended to enable memory optimization Perhaps `NonNaN` could enable rustc to perform optimizations like [Nan-boxing](https://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations)?
Can confirm, `fn scan` https://github.com/rayon-rs/rayon/wiki/Iterator-Trait-Parity
&gt; provided one adds runtime support What does that mean? I would think if it already handles functions that is has a runtime, but I have little point of reference what's going on underneath.
Actually, yes. But I'm not really deep into systems programming, I'm just experiencing. My main language is still Java, and my hobby projects mainly use Python, C, and JavaScript.
The proposed new name mangling has a version field, so having a versioned ABI seems likely.
Nah, it's NaN. Floating point math is entirely deterministic, it's just hard to predict from a user's point of view — and even if arithmetic were nondeterministic, that wouldn't preclude total ordering as long as comparison were deterministic.
I'm extremely new to Rust. Is there any difference between `let x = [0, 1, 2];` and `let x = &amp;[0, 1, 2];`? I've seen both used in the documentation and they seem to behave the same way. What does the `&amp;` do here?
This subreddit is for the rust programming language. You're looking for r/playrust
Floating point operations are deterministic, unless you're using x87 operations and messing with the environment flags. They're not associative or commutative, which makes mathematically-equivalent operations sometimes not give the same result.
Oh my bad haha 
Check out [Zola](https://github.com/getzola/zola) if you do!
C++ programmer here. Rust wasn't particularly easy to learn, but Rust was a breath of fresh air. It's got all the goodies C++ has been promising for years.
Wow, this is some hot garbage. Terrible new site design &amp; slogan.
You can already implement nan-boxing in library code iirc, and in that case you *wouldn't* want to use a NonNan type, since you don't want use of the NaNs to be undefined behavior.
NaN-boxing is a much more complex and in-depth optimization than I think rustc could/should ever do on its own. I've written several implementations myself ([shameless plug, for those with an academic interest](https://github.com/gefjon/saturn_tagging)), and it's fascinating, but the whole practice relies *a lot* on things that are basically UB (e.g. which of the `2^48 - 2` possible distinct `NaN` values will be the result of `1.0 / 0.0`?), and do not translate to platforms other than `x86_64`.
Having had a few attempts at working through The Book, I eventually had a project in mind that seemed like a perfect fit for Rust so I just started hacking it together, referring to The Book, sample code for the various crates I'm using (particularly Hyper and Nom), and existing OSS projects. I just made the project public because somebody asked to share some of the code, so if anyone's interested you can check it out here: https://github.com/RendleLabs/interflux I started my career writing C code on Unix systems, but that was nearly 30 years ago and I've forgotten most of it. For the last 15 years I've mostly been using C# and JS, so obviously Rust is a lot more complicated than that (although lately I've been getting into non-allocating code and the new high-performance APIs in .NET Core). Ownership was a bit of a struggle at first, but I'm starting to get a feel for it. Lifetimes are definitely more complicated, and I find myself adding them to things without really understanding what I'm doing; I just change things until the compiler stops complaining and the tests pass. Here's an example of something that's easy in .NET but that I struggled with in Rust. I often create a `Dictionary&lt;string, Action&lt;...&gt;&gt;` that is basically immutable after creation, and share it around for processing data. It's easy, you have a reference to an object and you can pass that reference around as much as you want. If you're feeling lazy you can just make it a static property on an arbitrary class. I wanted something similar in Interflux, created up front based on config and used in a route function. In Rust, that meant wrapping a HashMap in an Arc, then cloning that Arc in the server fn, and then cloning it again in the service_fn lambda. Oh, and I had to specify `move` on both those functions, but I'm still not sure why. I can see that Rust has some kind of static variables, but I have to use lazy_static if I want to set them when the application runs? As for writing async code with futures and streams, well, for someone coming from C#'s async/await semantics, that's a whole other level of difficult. Probably not much more than C# used to be before async/await, though, and once Rust gets those stable and properly documented I think that'll make a huge difference. One thing that felt like a lightbulb moment was when I realised I was trying to write object-oriented code and Rust didn't want me to. Once I understood that and started using a more functional approach, I felt less like I was fighting the language. Oh, and obviously as a C# guy, I've been very spoiled with Visual Studio and ReSharper/Rider. I'm using CLion with the Rust plug-in, and it's good, but obviously still early days. I feel like I've been very negative here, so I'd like to call out some things I'm really liking and not struggling with. Rust's type system is great. `Option` and `Result` and proper enums and things, I love it. Also the pattern matching. Oh, and traits, which I'm kind of getting to grips with slowly. Macros. I don't 100% know what's going on with these, and I'm a long way from even thinking about writing my own, but macros are definitely good. Cargo is brilliant, and I'm a huge fan of the inline test code and `cargo test`. To sum up, yes, Rust is challenging to learn and there are a lot of new concepts to get your head round, but I feel like that's because it's trying to do something new and exciting so I'm OK with it. I intend to get my little project to a point where we can use it in a real environment, and the next time I need something similar I will probably use Rust again. Next step on the project is to create some aggregators that can be called from the processors (or maybe chained on) so that for each incoming request, the lines can be collected into multiple `BytesMut` instances, one for each upstream server, and then sent. Wish me luck :)
Yes, maybe the most common use case for this is to replace the diff tool, right? So, adding a bin to this crate, taking care of just that, could be a good idea. One possibility is to write a \`struct D&lt;'a, 'b&gt; { old: &amp;'a\[&amp;'a str\], new: &amp;'b \[&amp;'b str\] }\` implementing \`Diff\`, where the \`delete(old, len)\` method just prints to stdout in the right format that \`len\` lines from \`self.a\` are to be deleted, starting from line number \`old+1\` (lines numbers start at 1, indices at 0). &amp;#x200B; Same thing for the \`insert\` and \`replace\` methods. One important trick to produce usable results is to call the \`diff\` method on \`Replace::new(D { a, b })\` instead of just \`D { a, b }\`. &amp;#x200B; Then you can just send a patch to https://nest.pijul.com/pijul\_org/pijul.
I started learning early this year and having already worked with both C++ and Haskell, I didn't find it outrageously difficult, although I did find Haskell very difficult for the first month or two. The things that I found trippy were the things that get left out: * Lifetime elision made it easy to fall short of understanding of the relationships between different lifetimes in a function signature, which resulted in a few "WTF?" moments long after I thought I had a handle on it. IMHO we should at least experiment with liberal use of explicit lifetimes in pedagogical materials. Maybe even automatically generate them in reference documentation. There's an algebra of lifetimes appearing on both the input and output sides of a function signature that is actually pretty elegant and intuitive. * Same with type annotations. I remember trying to learn Hyper and just being really turned around because I didn't know what were the types of the example variables. Nothing specifically against Hyper as every project does it. It's painful to go directly from the front-page example to deep inside the reference documentation just to understand. Also there's two different learning curves in play. There's the syntax-and-semantics learning curve which we all know about. But there's also a large-scale software-architecture learning curve that can take months or years to work through. The inability, for example, to simultaneously hold a mutable reference to a thing and the collection that contains it, while correct, makes some software architectures that I take for granted in other languages unworkable. Even if I intellectually understand the former I may not intuitively grasp the implications of the latter. It's possible to become heavily invested in a project and only run into a problem like this at a later stage.
Something you could do for your get thing get thing is calling `get` for each value and storing the option for each in a variable, and then leverege rust's pattern matching abilities like this: let verb_opt = request.get(0); let path_opt = request.get(1); let protocol_opt = request.get(2); if let (Some(verb), Some(path), Some(protocol)) = (verb_opt, path_opt, protocol_opt) { // handle request } else { // bad request } The downside of this approach, you're losing the ability to handle detailed errors, but if you're just responding with bad request it doesn't really matter. If you want to get deeper into it then you might want to look into using a parsing library like nom or combine or something of the sort. You could also read up on some parsing strategies in general.
Although it appears that nikomatsakis himself [isn't sure what he meant](https://github.com/rayon-rs/rayon/issues/329#issuecomment-308198359) :D
No, it is what's needed for automatic nan-boxing, as it would allow something like `Option&lt;NonNan&lt;f64&gt;&gt;` to be the same size as f64: None can be represented by NaN, because the compiler knows the value inside the Option can never have that bit pattern. (And similarly for things like `Result&lt;NonNan&lt;f64&gt;, i32&gt;`, using the NaN payload bits.)
That's usually referred to as niche optimization in rustc-land, but I guess that could be considered a form of NaN-boxing.
I also seemed to find it not too difficult to pick up. Maybe it's just because I've not done anything really complex yet, or maybe it's just I was thinking along similar lines to the ownership system to begin with? To be honest, compile-time ownership was what attracted me to Rust in the first place; I'd never seen it in another language and was curious as to what it would be like to program with it. I ended up really enjoying the language, and started picking Rust over C#. Most of my programming experience has been with C#, but I have done a little C++ (Arduino, so no heap allocation, almost no template usage), and a little assembly (68K, no OS).
The thinking with a NonNan wrapper type is that none of the NaN values is the result of division by zero: it's a float that is never NaN at all, so the compiler knows that it can fit small values in there (e.g. `i32`), even if it doesn't use the spare bits of a pointer to fit a pointer in (which isn't nearly as necessary in Rust with static, unboxed types).
I was trying really hard to determine if the use of "real" here is a pun or not.
AFAIK, nan-boxing is an optimization where you have a heap-allocated float, but are able to store the value of the float within unused bits of the pointer, so you can avoid a pointer chase (for the cost of a branch and a bitmask). Since Rust already allocates on the stack by default, I'm not sure where it would apply.
In my case, I need a library that I can feed two multi-line strings and get back a unidiff. I'm looking through your docs.rs to see how to do that from what you just said. I don't quite understand the mechanics of it, but the algorithm is obviously iterative over lines... Any more pointers?
This talk gives you everything you need to know about how AWS Lambda works under the hood, including the new stuff that's coming with the (built in Rust) Firecracker Micro VM. [https://www.youtube.com/watch?v=QdzV04T\_kec](https://www.youtube.com/watch?v=QdzV04T_kec) For what it's worth, I tested a total cold-start invocation time of a "Hello World" Rust Lambda, and it was 31ms total duration, inclusive of the cold-start penalty, and a repeat run was 1.36ms, so the cold-start penalty seems to be \~29ms for an n=1 test. Based on previous benchmarking, the Python cold start penalty is \~52ms.
I don't think it's hard to learn (but my perspective is from C,C++, grew up on asm) But the thing that makes it harder to *use* is the need to lookup more helper functions to do every little thing. If 'dot-autocomplete' gets better it might help mitigate that. I personally think the language could do with a bit more visual streamlining: safety imposes an extra load which could be offset with a few concessions elsewhere . It loses the middle ground which C++ has. references are not safe, but safer than raw pointers. In rust you have the full safety (with all the extra helper-function lookup) or raw pointers (made more verbose inside the unsafe blocks), and nothing in-between.
Did you include crate asdf in your dependencies list in Cargo.toml?
well, under \[build-dependencies\] I wasn't too sure what to put given that it's not coming from [Crates.io](https://Crates.io) as far as under \[dependencies\] it's not included there either, but it doesnt seem that [main.rs](https://main.rs) complains
Huh... Welp I'm not sure then sorry bud
no problem thanks for replying. However, I'm going to now kill myself. 
Ok, first of all I totally agree with you. Secondly, thanks for listing these because I wasn't aware of Nim and it looks great. Adding it to my list to learn along with Rust :)
The second one uses an odd but sometimes useful feature of the language that compiles as if you had written this: let x = [0, 1, 2]; let x = &amp;x;
In this case I think part of it is that, unlike `char`, which can handle 2^11 different tags, all possible NaN values have to be treated as `None` because platforms are free to produce any of the possible NaN values on every float operation, so you don't actually have more than 1 bit of play despite the zillions of possible values. (I also think that focusing on how many NaN values there are is sort of a digression, because I'd disagree with the above poster and say that the linked discussion doesn't really boil down to how many values NaN has, but rather boils down to how float operations are all partial so you'd have to do the `None` check after every operation, and how this operation can't be as fast as the `Option&lt;&amp;T&gt;` check because comparing against zero is fast while checking for NaNs requires testing multiple ranges, and that the only point of using floats at all is speed, and if you take away performance then floats are completely overshadowed by other numeric implementations that you should prefer to use anyway.)
Looks awesome! Nice work! One small bit of feedback - would it make sense to have a 'copy to clipboard' icon next to the commands shown?
It's really bad tbh
But you won't win them over by making Rust difficult... There's already C and C++ for that
It's the term used to describe the technique on floats when applied to other languages. It's not a particularly special thing for rustc, but is for other languages/implementations.
Try adding `[build-dependencies]` in your Cargo.toml and add the crate to it. The error would also occur if you only listed crates under the dependecies section and use them in the script. `[build-dependencies] asdf = [version of your crate]
&gt; [version of your crate] can you help me understnad what to put here? Given that my crate is local and not on crates.io I wasn't sure how to do 
You're thinking about the is non-associativity of floats, which basically means that `a + (b + c) != (a + b) + c` in the general case. This happens due to the limited precision of floats, since there are only 32 or 64 bits in any given float (and not all of those are used for precision itself), so adding a relatively small number with a relatively big number necessarily means that some precision must be lost. The compiler should maintain the order you apply math operations upon floats though for this very reason, since if you do the math in the same order you always get the same result, bit for bit. This matters a lot in scientific computing as you are trying to minimize the error in your result. For example, instead of summing every float in a `Vec&lt;f32&gt;` by adding it to a single collective sum, you might sum each consecutive pair in the slice together to get a new `Vec`, and then do this again and again until you arrive at a single number, with the reasoning being that each consecutive number is about the same size, so there is minimal truncation error compared to simply adding it to a single, potentially much large sum number.
I love the new Rust colors!
possibly ``` asdf = { path = "." } ```
Oh, and on the new rustup site I like that, besides the recommended installation option by auto-detecting the OS, you also have the downloads for other systems directly on the first page.
That does make sense! The current website does not have that ability, but my prototype now does. [https://youtu.be/Omvq2bZ-xy0](https://youtu.be/Omvq2bZ-xy0)
Elixir might be a good choice as well. TDD is almost fun using it.
I used to hate typing snake case, but then I realized that underscore is basically a special space, and shift + space wasn't doing anything, so I remapped it to produce an underscore. Massively useful
Elastic, currently one of the most successful marketing operations in the FOSS sector uses "empower" _a ton_. Others do, too. https://www.google.com/search?q=empower+site%3Aelastic.co&amp;ie=utf-8
Sorry I don't follow what this solution looks like. Could you post what the change was that worked?
&gt; It's something that you'll see more in social programmes than in marketing for tools for working professionals. Elastic, currently one of the behemoths of software marketing, uses the word "empower" a ton. Others do, too. https://www.google.com/search?q=empower+site%3Aelastic.co&amp;ie=utf-8&amp;oe=utf-8&amp;client=firefox-b-ab
Life changing tip! Shift+ space I think is probably used by input method on windows and Linux but I will try and remap on vim
I'm building a scripting language and floats is a (small) problem here. I certainly need ways to sort and compare floats (is for a in-memory relational lang, so similar to rdbms) but rust is telling me is bad. Now, the question is what can I give instead? - Is possible to treat NaN as None/null - Forbide NaNs? Panic on NaN? - What good compromise can be done? 
That's super neat! I'll try to keep up with 2018's edition. I write my implementations as libraries (one per day, inside a workspace). Then I write unit tests that validate any example from the site or that I come up with myself. One of the test will be given the input file data, which is `include_str!()` directly in the test binary. See https://github.com/nbigaouette/advent_of_code_2018 The proc macro approach is interesting to handle multiple functions. One thing I wonder, is how does cargo-aoc handles benchmarking? Is it simply measuring the execution time of the solution? It can't provide different input size to measure time/memory complexity, or can it?
This sounds like a circular dependency to me. A build script is compiled and run before compiling the crate it's part of, so you can't use the crate that a build script is for inside the build script itself. I suggest you factor out the common logic into a subcrate. Inside `asdf` run `cargo new`, then you can add to your `[dependencies]` and `[build-dependencies]` `asdf-core = {path = "asdf-core"}`.
I feel like it'd be less intrusive if the notification of having it copied to the clipboard didn't change the textbox and instead were a small badge somewhere outside, but touching, the textbox. Some people might be very quick at clicking + ctrl+a + ctrl+v and might accidentally end up copying "Ready!" instead of the command.
If you're on Linux, you can change it globally by adding an entry to your xmodmaprc. I could send you mind if it would be helpful
The two ways are: use a separate total ordering predicate (*i.e.* sort NaN before everything else) or forbid NaN entirely. Both are valid. You're the only person who can answer which is better for what you're doing.
Perhaps on some puzzles it could, but many of the inputs aren't susceptible to variation.
The issue is that the `build.rs` file is compiled and run before the rest of the crate so it can't refer to things in the crate itself. That means that you can't import asdf within it because asdf simply doesn't exist at that point. You should either remove asdf from the build script or break out the needed functionality into another crate and depend on that instead.
Agreed, I'm not sure how this would work otherwise. Unless there's a way to specify otherwise, `build.rs` will be used when building the lib crate, and therefore cannot depend on the lib crate to be already built.
https://www.reddit.com/r/linux/comments/9ee12x/rant_why_is_curl_bash_still_a_thing_with_this/
https://integer32.com/ offers training.
Thanks. I am on my windows boot right now but I think shift+space is taken by my fcitx on Linux. So ill have to do something vim specific. That said, could you please post your xmodmap so I will get some ideas on things..
I think you’ve got the wrong subreddit. You’re likely looking for /r/playrust. This subreddit is about the rust programming language. 
Same here -- I chose Windows because that's my primary deployment target, but I build all my personal projects on Arch Linux, and though I target Windows I actually develop the programs on Mac OS at work. In my experience if it builds on Mac OS it will generally build on Linux just fine, and vice versa. Windows is where things get interesting: I've run into lots of link-time issues i.e. crates expecting OpenSSL to be there instead of using `native-tls`/schannel, needing to pass environment parameters to get SQLite to build, etc. I will say though the natviz integrations w/ Visual Studio's debugger just keep getting better and better -- if I ever need to debug a Rust program I almost always turn to Windows for that.
It's a small price to pay for long term convenience. Would be questionable if it wasn't versioned.
I'm not the speaker, but I also hope rust will become popular for VST and all kinds of audio apps! I know u/raphlinus is going all in on Rust for audio with the [sythesizer-io](https://github.com/raphlinus/synthesizer-io) project.
Thanks for this! I'll try it out and report back.
AFAIK, Debian and Fedora refuse to package rustup, because of a blanket policy about not providing packages whose purpose is to install other software.
I don't get the impression that the core developers are deliberately averse to stabilizing an ABI, but it represents an enormous amount of discussion, specification, and implementation work when there are other things higher on the list to focus on. At the very least one could imagine stabilizing only a calling convention and still requiring users to `repr(C)` any types they pass through it, to avoid the need to specify type layouts. &gt; Would it be possible to export advanced concepts (Strings, Traits, lifetimes etc.) by defining a binary layout that only gets applied when the developer actively enables it? This still requires specifying an ABI, because having an implementation-defined ABI doesn't do much good when the whole point is to call code built with different implementations.
Nice work op, it will be fun to see rust up redesigned. Thanks for putting in the work. I am not a designer by any means. but here is some feedback. &gt; menu and rust logo looks too small &gt; Alignment of Content need work, from logo to footer. &gt; "rustup" title looks too big. maybe a better font that is clear to read. &gt; in Footer "install rust" has a big underline. it makes it hard to read. but its totally a personal preference.
I was using this crate. https://github.com/kubo/rust-oracle When I write a line like this from the sample: let conn = Connection::connect("scott", "tiger", "//localhost/XE", &amp;[])?; I got an error along the line of "A function that ends with a ? must return a Result". I can't help but notice that the "connect" function in the crate returns Result&lt;Connection&gt;, but apparently Result needs two parameters. So I'm not even sure how the crate works.
How does it compare to the nix crate?
As someone who didn't like the rust-lang.org, I think this looks wonderful. Color and emphasis on the right things with more information density than before while keeping it clean. 
sunfishcode means that you would have to add support for strings, dictionaries, etc to the language.
That's simply the reason I've overheard in the past for why distros are happy to ship rustc and cargo, but not rustup. Nobody here would object to distros shipping rustup if they chose to. If you're volunteering to create and maintain the external Debian package for rustup, that's great, but it's not currently a priority of anyone who gets paid to work on Rust. `curl | sh` is fine for https connections, because they aren't getting MITM'd, and if you don't trust the Rust developers not to inject malware into the script then you shouldn't be seeking to install the Rust binary provided by the Rust developers in the first place, which would be far easier to inject malware into.
aoc-tools can still create a cached version of the file in an app-directory, invisible to the user. Just because you use it that way and you dont expect anyone else to use it, doesnt mean that anyone else wouldnt use it differently..
Cargo-aoc's bencharmking is powered using \[Criterion\]([https://github.com/japaric/criterion.rs](https://github.com/japaric/criterion.rs)), so ... Actually it's only launching the solution a big number of times, extracting informations on the go :) 
This comment marks the urgency of having a rustjerk quote of the week.
We need more video tutorials on rust. for me watching a 5m or 10m video is easy rather than going over 5m of text. 
Now that you say it, I think this would be a very sweet optimization, and I bet it could be implemented as an attribute-style procedural macro.
No code reviews, I take it?
Speaking as someone who hasn't used either the IRC channel or Discord group (but who does lurk in #rust:matrix.org), I'm saddened by it too (although not surprised in the least). That page still does link to #rust though, and hopefully they're going to maintain it in an official status for people who want to use a free alternative.
Awesome, glad my crate was useful for you! If you run into any problems or have suggestions, please feel free to open issues [on GitHub](https://github.com/olson-sean-k/decorum)! When I learned Rust, I was actually excited to see that floating-point primtives did not implement `Eq` and `Ord`. Many languages do not express this nuance in their type system, let alone attempt to prevent programmers from making some subtle mistakes with floating-point values. But sometimes, with some understanding of the details, there's a need to hash floating-point data! In particular, I needed `decorum` for another crate: [plexus](https://github.com/olson-sean-k/plexus).
+1. As a user, I don't know what "systems programmer" means and I don't care (why would I want to be a systems programmer?). However being "fast", "safe", and "preventing segfaults" are things that most programmers will probably be familiar with and be interested in. 
Sure it can, I just haven't bothered adding such a feature. I might add it in the future, but as I mentioned, I'm only catering to myself so far so I don't see it as a priority.
I can recommend James and Felix. They know their stuff, and know how to teach it.
This was really cool to use for day 1. The ease of benchmarking and not needing to manually load the input file are nice. Thanks for making this!
&gt;Oh, and I had to specify move on both those functions, but I'm still not sure why It's has to be a `move` closure so that it takes ownership of the `Arc`. Otherwise the closure would take a reference to the `Arc`, which is a local variable stored on the stack. And since the closure runs after the function returns, and the local variable is only accessable during the function call, the compiler complains that the closure does not live long enough. However, the actual value the `Arc` points to will stay accessible as long as the `Arc` is alive. So if you take ownership of the `Arc`, you don't have to worry about the local variable being accessible, because you already have its value and don't need to read it after the function returns.
Ugh sorry about the missing spaces, I wrote that using gesture typing on my phone, and it doesn't insert spaces before or after special characters.
CPU: Ryzen 2700x RAM: 64 GB Kernel: 4.17.19-1 arch: x86\_64 remarks: not optimized python: Python 3.7.1 rust: 1.32.0-nightly (d09466ceb 2018-11-30) gcc: 8.2.1 20180831 clang: 7.0.0 (tags/RELEASE\_700/final) ./smp-gcc gcc md5er returned "2995f9ab6976da7997fb14378d5a280e" in 318.392731s ./smp-clang clang md5er returned "2995f9ab6976da7997fb14378d5a280e" in 320.570709s cargo run --release crypto::md5 md5er returned "2995f9ab6976da7997fb14378d5a280e" in 473.931909462s md5::Context md5er returned "2995f9ab6976da7997fb14378d5a280e" in 528.851059442s md-5::Md5 md5er returned "2995f9ab6976da7997fb14378d5a280e" in 380.151347326s RUSTFLAGS="-C target-cpu=native" cargo run --release crypto::md5 md5er returned "2995f9ab6976da7997fb14378d5a280e" in 462.700186163s md5::Context md5er returned "2995f9ab6976da7997fb14378d5a280e" in 510.742509274s md-5::Md5 md5er returned "2995f9ab6976da7997fb14378d5a280e" in 374.805266022s+ cpython smp.py cpython md5er returned "2995f9ab6976da7997fb14378d5a280e" in 319.3589630126953s pypy NA &amp;#x200B; &amp;#x200B;
I do something similar, although I make I binary for each day and use the assert\_cli crate to the the generated binaries. See [https://github.com/zayenz/advent-of-code-2018/](https://github.com/zayenz/advent-of-code-2018/)
Getting it up and running seems to be a little rocky. I left an issue on the repo, happy to help troubleshoot.
Grepping for `ExprKind::Try` will find you a bunch of relevant places in the codebase, I think.
I think you're looking for r/playrust, read the details before posting
No I'm not, read the post before commenting ;)
/r/playrust
Some context: [Advent of code ](https://adventofcode.com/) is an Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like. People use them as a speed contest, interview prep, company training, university coursework, practice problems, or to challenge each other.
I haven't kept up with web framework progress too much, is Rocket still the framework of choice with all the work happening with Tokio, Actix, async/await, Tower, etc? I wish someone did a 2018 Rust web framework rundown, similar to how [this article](https://da-14.com/blog/10-best-nodejs-frameworks) does with JS frameworks.
As far as I'm aware its also useful for simply cramming a bunch of types into a uint64 without needing an extra tag to tell you what kind of type it is. If you assume that nans have enough bits free to store a pointer, you know whether or not a type is a float or a pointer simply by inspecting the bits instead of having to keep an extra type around to tell you what's there
Rust is already secure. Amirite gaiz?
You can have a look at the [recent survey](https://rust-lang-nursery.github.io/wg-net/2018/11/28/wg-net-survey.html) by the networking working group. 
Sorted (my fault)!
You put it really well. And I agree, it took me a long time to get comfortable in rust as well, and I still struggle with lifetimes. But I've learned so much over the time I've spent with it and I genuinely feel that it has made me a better engineer for doing so. 
Could you elaborate more on this? I'm curious as a lot of discussion comparing Rust and C++ seems to mention the more complex features from C++ missing from Rust. 
If I understand correctly, then If we look at the [`TcpStream documentation`](https://doc.rust-lang.org/std/net/struct.TcpStream.html#impl-Read-1), we see it contains `impl&lt;'a&gt; Read for &amp;'a TcpStream` This makes it generic over any lifetime(`'a`), for *read only* references of that lifetime(`&amp;'a TcpStream`) IE, references to a TcpStream are themselves Read/Write. This means a function`fn func&lt;R: Read&gt;(_stream: R) {}` can be called like `func(&amp;stream)`. Self, or from `func`s perspective R, is the reference here, and `Read::read` for example takes `&amp;mut self`, where `self` represents the current trait object of type `Self`, which is `&amp;'a TcpStream`, not `TcpStream`, making such a mutable reference is allowed. I believe the final type would be `&amp;mut &amp;'a Self`
No one cares about this stupid game. /r/playrust /r/lostredditors
Stupid post for the language for the stupid game ever called /r/playrust.
If you ever want what you're describing in the second paragraph, take a look at https://docs.rs/itertools/*/itertools/trait.Itertools.html#method.tree_fold1 -- it's exactly that, but over general iterators in a no_std compatible way that only needs logarithmic stack space.
Rocket has 27% and Actix-web has 24%. 
I put an example [here](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=02102ae9065f6b9166f6e31463b3e6ed). It doesn't show the decrypter and encrypter, but it does show how you can use the TcpStream as both a Read and a Write.
If you do choose a total ordering predicate, please use the `totalOrder` one that the IEEE standard defines. Some discussion about it and code for rust: https://github.com/rust-lang/rust/pull/53938
&gt; Rocket is the most popular followed by Actix FTFY Anyway Actix really catched up in the last months i guess. I have two projects currently one with Rocket and one with Actix. I like both of them but with respects to their features. My current Rocket project is a webportal for our clients scheduling appointments. It works great, its a childsplay to use but have to mention that the build process borked every now and then due to nightly unfortunately. Nothing mayor yet and you have an issue on the tracker soon after by someone else and a fix or workaround is really quickly available – just a thing to have in mind. My current Actix project is a "high" throughput micro service for push messages and websocket stuff. Impossible to break this thing down (we managed this in the java/node version we previously experimented with). Very stable, had some minor bugs that where fixed in the process of writing, developer is quite responsive. After all i am quite happy with both of them but Actix tends to feel a little bit "boilerplatly" because of the actor system and takes like an afternoon to get familiar with if you never used something similar – but it gives you great performance in exchange. Not that Rocket is slow, quite the opposite. Its has solid performance but if you really take advantage of the actor/async stuff in Actix you can really get ahead of it. 
It's incredibly freeing to be able to just pass borrows around without needing to think through on a whiteboard whether what I'm doing is going to explode in my face. With the compiler helping I'm willing to try things in Rust I would never have considered in C++.
Here's the PR in which I changed it to the current `Try`-based desugaring: https://github.com/rust-lang/rust/pull/42275
 impl &lt;T: Float&gt; NonNan&lt;T&gt; { pub fn new(f: T) -&gt; Option&lt;Self&gt; { if f.is_nan() { None } else { Some(NonNan(f)) } } pub unsafe fn new_unchecked(f: T) -&gt; Self { NonNan(f) } pub fn div(self, rhs: Self) -&gt; Option&lt;Self&gt; { if rhs.is_zero() { None } else { unsafe { Some(NonNan::new_unchecked(self/rhs)) } } } } At no point should the hardware's nan come into play. If it's given any null, it will return the NaN the compiler selected and treat it like an integer. You won't be able to use the value as a float unless you unpack it from the Option.
looks great. I recommend not capitalizing the command itself (`CURL ... -SSF | SH`), although I do think it looks better I don't think it will work! ``` $ CURL -bash: CURL: command not found ```
• nix depends on std; unix does not • nix calls libc; unix makes raw system calls (and i intend to drop libc dependency altogether, to avoid linking to it, but it's a long-term goal) • APIs make different trade-offs, for example: unix has separate `OpenFlags` and `OpenMode`; nix does not • nix is more complete 
1. When you need to make a generic function, i.e. one that takes arguments that "have certain methods", but aren't all of the same type. If you only need a method on your struct, you can also just `impl` it on your struct. 2. Traits can be implemented for all types. 3. That means that implementing a trait for a type is only possible if it only implements the other trait. I.e. `S: T` means that the trait `S` can only be implemented for traits that also implement `T`. 4. They describe how functions can be used generically, which is mainly usefull in combination with closures, see https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html. Did you read the book I linked yet? It's very well written and might answer your questions better than I can.
Can you also be the guy who reads the subreddit description before posting? 
Stupid game ever called /r/playrust /r/lostredditors
Right, so I'm moving the ownership of the variable into the closure. That makes sense. See, that's one of the things that .NET just does, and of course that's also one of the causes of memory leaks in .NET applications, especially with things like event handlers. OK, I get it now. Thank you!
&gt; If you're trying to sell rust to developers then the new redesign is doing a very poor job. This is by design. The new website is built to sell rust to managers, CTOs, and similar. I'm not even being cynical - that's literally what one of the Rust core team members said on the Github tracker: https://github.com/rust-lang/beta.rust-lang.org/issues/431#issuecomment-442985053 And for the record -- since I hope at least some of the feedback in this thread will make it to the design team -- I do feel this is the wrong direction. Rust is open source. It's built by developers for developers. Its primary website shouldn't be designed with the goal of selling Rust to businesses - it should be designed *for the community*. To go a step further, there should have been more input from the community throughout this redesign. It wasn't responsible to just spring so many **big** changes on us with only a week's notice. And yeah, I know it's super painful to read through all that feedback, but Rust has been developed in the open with standardized feedback processes in the form of RFCs, etc since near the beginning and that's a huge part of how we've built such an enthusiastic and productive community. The website really does serve as an image of Rust itself, and of all it encapsulates. It's a big enough part of Rust that it should have been subjected to similar feedback mechanisms. Open source is hard. At the very least, hopefully this can be a learning opportunity. [](/rarityjudge)
&gt; unix makes raw system calls (and i intend to drop libc dependency altogether, to avoid linking to it, but it's a long-term goal) I think Linux is the only platform that has a stable syscall ABI; as far as I know every other platform requires binaries to dynamically link libc or some equivalent system-provided library. In particular, I believe this is true for FreeBSD and macOS (and Windows, although that's probably not relevant to a crate called "unix"). OpenBSD doesn't even have stable userland ABI, never mind syscalls. If you consider Linux-specific code to be a flaw, you'll probably have to put up with a libc dependency.
I'm not aiming for binary portability, merely source portability. I'm primarily a Linux user, and have little experience with other Unices, so i may re-evaluate my goals for them at some point (and allow a libc dep), but on Linux at least i want to avoid the infelicities its infelicities as much as possible. 
It may be long, but you can't say this name isn't descriptive (I now know what Unpin means) 
I hate it when people come steal all my zero cost abstractions! 
I agree with your rundown, but looking at the list of features rocket added in the `v04` candidates it does make me very excited. I would argue that Rocket has the upper hand for serving web pages, while Actix is more suited to high throughput micro-services. Just my 2 cents though.
So, this is Rails for Rust. Okay. What, then, it is in Rust which allow me to do same things as import "net/http" in Go 
Sadly we operate (like most tech stuff in France) in Paris :/
The same weird design as for rust lang one... I wish people wouldn't make use of too many color sections
Out of interest why are tree structures so difficult. If I think of a binary tree, is ownership and lifetimes of nodes not just those of the parent?
Nice work! Good spacing, it is clear what to look at, nicely highlighted (yellow) the primary action, there are not too many colors (I think this should be the max), the color behind "Installing Rust" does not distract because it matches the background color well. One small nitpick: shell commands should not be upper-cased. For the record, I disliked the style of the beta site. But it looks what I disliked was the way the style is used, and not the style itself.
I don't use Go, but you're probably looking for Hyper https://hyper.rs/guides/
The hyper crate?
Could you post the context of your `connect` call? It could be helpful. As to `Result` having only one parameter, it's not unheard of for a library\module to define a type alias of `std::result::Result` with a library-specific error type - in fact, it is even done in standard library, [in the io module, for example](https://doc.rust-lang.org/std/io/type.Result.html). If you click the link on `Result` in `connect`s signature in the crate's docs, you'll see exactly that.
Maybe you did that in main, which returns nothing? Try .unwrap() instead, or put this in another function retuning Result (you may need to map between types)
In this case you would do something like: let old = "a\nb\nc\n"; let old_lines = old.lines().collect::&lt;Vec&lt;_&gt;&gt;(); let new = "a\nx\nc\n"; let new_lines = new.lines().collect::&lt;Vec&lt;_&gt;&gt;(); let mut d = Replace::new(…); diffs::diff(&amp;mut d, &amp;old_lines, &amp;new_lines); 
Awww, Go evangelists aren't *that* bad. Just stick to the facts and debate respectfully.
I'm referring to features like type inference (auto/decltype), closures (lambdas), concepts (traits), modules, borrow checker (static ownership analysis), result (expected), enums (variants), futures. With C++ some of these features have been in development for years and still aren't quite done (concepts, ownership), some didn't/don't work as promised at first (lambdas), all of them are completely optional and might not be widely used, and a lot of them aren't available unless you have a bleeding edge compiler. I think it's great that c++ is adding new stuff, but in the recent past, actually using new features in production has been a challenge.
Trees are difficult in rust because each node references some other node. If you use native rust references to do this, you can build a tree, but how do you modify it? Any time you try to take a mutable ref to the tree, the borrow checker slaps you. You have to use unsafe pointers, refcells, or store the nodes in a vector and build the tree from indexes instead of actual references. None of these solutions are intutive, and this exercise is trivial in most other languages which makes rust seem insane.
The sentiment is good, but I don't like using the word "empower" or "empowerment" in any way. It has too many strings attached in a way that does not seem at all fitting to a programming language.
So basically \`&amp;\[0, 1, 2\]\` creates an array and then borrows from it at once?
Or just take a look the others posts. I can't understand how someone can go to a subreddit, see everybody taking about programing and think "Oh, this seems like a nice place to post about a game". 
&gt; I think what I'm trying to say is the article isn't wrong, but it wrongly makes that sound like rust is somehow failing. I also think that the problem with the survey is that it didn't correlate difficulties of learning Rust with current programming languages familiarity. I'd expect an experienced C or C++ programmer to grok ownership and borrowing quickly, simply because while the concepts are not "in your face" in C or C++ they are clearly implied and therefore the programmer would already be familiar with them to a degree. On the other hand, a programmer who is only experienced in Garbage Collected language must, for the first time, think about ownership and aliasing. Well, it's a completely new skill! It doesn't matter whether they are good (or not) with their current languages, new skills take time to understand and learn! And this is not a "Rust" issue, it's a non-GC issue, which would equally affect a transition to C or C++... albeit without the safeguards. Of course, it doesn't mean that we should not do what we can to make learning this new skill easier; however I don't see it as a failing of Rust (or C, or C++). 
&gt; I'm pretty sure for C++ programmer Rust would be quite easy to get on though This was my experience indeed. I was already fully proficient with C++ when I learned Rust (measured in invoking UB only once every month/other month) and if anything Rust made me a better C++ programmer: instead of applying rules of thumbs to gauge whether what I was doing looked safe or not, I could instead apply the Aliasing XOR Mutating principle to *know* it.
I had it in a function, and when I tried to set my function to return from the connect function, it gave me type errors. If my function returned Result&lt;Connection&gt; it would say "Result requires two parameters", and if my function returned Result&lt;Result,Error&gt;, it would say type mismatch. 
As James20k mentioned, nan-boxing is just about cramming stuff in NAN, so it'd be equally usable for putting enum discriminant bits.
I did it at work and I'm home right now, so I don't have the context with me. It was just me trying to return that conn variable from a function. 
Deterministic, but not intuitive. I had a surprise this week when applying an algorithm which was supposed to produce only float values which are a multiple of a parameter (for example, only multiples of 1.0 or 0.2). Well, turns out that there was a difference of 1 ULP between: - rounding X to the nearest multiple of base. - rounding (X - base) to the nearest multiple of base and adding base. In insight, it makes sense, but I was surprised when my tests failed on it.
I assume the version of enclosing function you've got your original error about `?` from did not return a `Result`, correct? `?` doesn't really *handle* errors, it simply propagates them to the function's caller, and you can't do that if the return type of the enclosing function doesn't support error signaling in some way. Hence the error. When you changed the function to return a `Result`, you fixed that part, but I'm fairly sure that you used (implicitly imported via prelude) `std::result::Result`, not `oracle::Result`. This would explain the line about two type parameters. For the `Result&lt;Result, Error&gt;` - do you remember exactly how the return type went? A `Result` inside a `Result` (not to mention that the second `Result` having no type parameters) is extremely odd.
I'd like to use the opportunity to plug my [overflower](https://github.com/llogiq/overflower) crate, a procedural macro to select the nature of arithmetic operations in any item per attribute (e.g. `#[overflow(saturate)]`). It's nightly only for now, alas, because it requires specialization.
So, here's my take on it: This redesign is well done but not well thought-out in the slightest. The actual design with all the issues peeled back? Fantastic. I enjoy the typography and the colors used immensely and think it has the potential to have a very unique visual design that could be equally as functional as the current site. I'll try and examine every issue I have with it in depth, because it is making me very unhappy that what I considered to be one of the best landing pages for a language is now somehow worse than almost any other I've seen: &amp;#x200B; It falls short on a lot things. I did say I like the colors used, but I definitely do not like *how* they are used. I like the typography, but I absolutely do not agree with how the layout both has so much padding and so little content at the same time. The first thing that stands out to me is that the most useful resources are now not only hidden behind other pages, but also those other pages' links are now tiny and tucked away in the corner. There is no point to this other than it looks like other websites with the same bad design decisions. &amp;#x200B; I understand the argument of not having a code sample because one is hard to pick, but that is not acceptable. Ever. Everyone judges a book by its cover, we don't have time for anything else. But besides that it is simply sacrilege to advertise something without actually showing it, which is indeed what this is doing. It gives you information in entirely the wrong order: first the hook, how to install, then how to use it? Who does that? Yeah, let me just install this 300+ megabyte compiler (which takes 40+ minutes to install under some conditions) because I was told by a website that it's good. This is ridiculous, especially because if I actually want to see code, I have to scroll through a ton of information which may not be relevant to me, only to be given an example I have to run on my computer using overly complex code that does not even show me a single thing about the language other than it can make a little crustacean say hello to me. And then the example is ended with a "read the manual" anyway, not allowing you room to expand on your early learning, probably before you're even convinced you'll use it. If you can't pick a good example, why not pick the already existing one? You can toy around with it and see what it does. Prodding at something is a much more effective hook than just talking about it. *Show, don't tell.* &amp;#x200B; Honestly, all that I ever needed to convince me to try out and eventually write almost all of my code in Rust was a little bit of text telling me what makes it unique and a little bit of code to try out. The beta website does not provide that, and if past me were looking at it to see if I'd want to try it out, I would not have done so. The "Why Rust?" section on desktop is bad because it packs less information into more space. If it were simply text leading after the slogan explaining more succinctly than 3 run-on sentences how the language is unique, it would be a great improvement over the current site's design. &amp;#x200B; I would also like to note that the beta not only increases fluff but has omitted an absolute ton of information which is very important to people starting out in the community. There is a single link to the #rust channel, completely ignoring the over 35 channels previously linked, which are all great entries into the community and active support. There's no link to This Week In Rust or even this subreddit. And then it needlessly splits one page into two whilst also omitting almost vitally useful information. Somehow the team listing being a few lines of text explaining each team by name wasn't enough, and now it's some weird matrix of boxes which makes absolutely no sense from a UX perspective? And as far as I can tell the Contributing page has been entirely removed in favor of the Governance page, essentially discouraging people from joining the Rust team, as that page is much more of an advertisement than an actually useful source of information on currently important goals. &amp;#x200B; In short: We've now got less content, more things that put people who would actually be interested off, and sadly lots of bickering that seems like it will not make any difference in the end. The landing page is an important factor of getting people into the community and the new design has entirely ignored that. I would really love to see this new site work out, because it could potentially be a great improvement to what we've got now! The events area and making the project and community's standards clear is a great improvement, and as I said before, the typography and color choices are fantastic. But I really hope that the team takes a while to consider that pushing out something new without a lot of intentional, community-driven design will really seriously harm the future community! The entire reason I picked up Rust is because I came to the site, saw a clear and decided goal of a growing language, and took off from there. Things can be a lot better! I really hope to see improvements on these issues before the new site is launched fully, especially with Rust 2018 right around the corner. &amp;#x200B; (Also, Ferris is adorable and thank you for mentioning them on the getting started page.)
Sexy, I needed this
Sorry, that was a typo. It was Result&lt;oracle::Connection, oracle::Error&gt;.
I updated my rocket/slog integration crate to match: https://crates.io/crates/rocket-slog-fairing
Hm. This should have worked, unless you did something the compiler did not like at your function's call site, and it was complaining about that rather than the innards of the function. Sorry, I'm out of educated guesses here. Are you allowed to post your code from the work here? If you are, please do when you have the chance, I'm really curious about what's going on here.
Will do. It's not work code, it's stuff I'm working on on the side. I'll try to remember to post it on Monday.
Blogspam for ad money
Ooh, that's nice. 
And I'll try to remember to check Reddit when I get home. Until Monday then.
Hope you update this every few month. Can you do a pdf version too?
One possible issue with this survey is the group of people who haven't been learning rust for a month yet, but still aren't productive. They fall into the category which gets interpreted as worst for learnability, but really they are unknown data points.
Much thanks. We would probably have our team meeting in Canada or maybe the US.
I got it!
Hey thanks this is awesome. 
Lol go outside troll 💩
[Zola](https://github.com/getzola/zola) is split in many relatively self-contained small crates so adding something/fixing a bug is easy enough.
Isn’t there fast math in LLVM for non-nans?
The book is also sold in many ebook formats by [no starch press](https://nostarch.com/Rust).
OSX has a case insensitive filesystem (by default), so it works there, which is probably how it ended up on the site
Yes, unfortunately there's not a lot of love for actix usability outside of actix-web. I've thought about using actix for an application recently, but was turned off by the lack of examples and the lackluster quality of docs for the base actix crate. There's apparently a newish crate called `actix-net` that provides better support non-HTTP servers, but it is still called "experimental".
We also have one for the Rust Community Discord server, which has an Advent of Code channel that you can discuss the daily problems with other Rustaceans! The leaderboard is 107174-787aa8bc and the invite to the channel is https://discord.gg/YSaq6ef
I came from a JS background, and I also found Rust pretty easy. Ownership and memory management was new, but well explained in the book. And most patterns that are common in JS transferred pretty well into Rust (e.g. map, filter and friends, duck typing -&gt; traits). Now that I think about it, you do have to be quite aware of when you're copying in JS, because equality of objects is done by reference identity, and this is exploited quite widely in libraries like redux which use it as an optimisation for mutation detection.
You can desugar it to function calls like some other languages: arr[i] = j --&gt; set_array_index(arr, i, j) Whether it's a function only for array or defined by some special trait that can be implemented by other types is not very interesting in that regard.
See https://www.reddit.com/r/rust/comments/9zqljh/why_turbofish_is_ugly/eautsam/.
I've used Actix some time ago for a private project. I don't remember all the details (sorry), but I did struggle like you to understand how to use it and searched through the documentation and all Actix code I could find. After creating all actors I had the problem that they dependent on each other and that the type system wouldn't let me connect the Actors as needed (it was a mess). Then later I discovered [SystemServices](https://docs.rs/actix/0.7.7/actix/registry/trait.SystemService.html) which cleared up the code a lot. Now most of the code uses system services, is much shorter and runs without problems. // to get the address of SystemService use System::current let addr_copy = System::current().registry().get::&lt;CopyActor&gt;(); // important part of the CopyActor declaration #[derive(Message)] pub struct CopyStart(pub PathBuf); pub struct CopyActor { to: Option&lt;PathBuf&gt;, } impl actix::Supervised for CopyActor {} impl SystemService for CopyActor {} Maybe the code above helps you a bit. Btw. if anybody has a tip on how an actor system is usually stopped, since there are a lot of uncoupled parts doing there thing, so terminations suddenly becomes a problem (my current way of stopping feels more like a hack than anything else).
You should call it `linux-abi` or add `#[cfg(os = "linux")]` around everything then.
And generics get less nice.
Yep. It feels a little magical when we do it to an array like that, but consider how similar it is to this line: let s = "foo"; This `s` variable is an `&amp;str`. Where does its data live? As long as the borrow is valid for the scope of `s`, we don't really care :) Often these cases gets compiled into the binary's "data segment" with all the other static strings, but note that it is possible to force the compiler to allocate a local temporary with something like this: let s = &amp;"foo".to_owned(); Or even this: let v = &amp;mut [0, 1, 2]; for x in v.iter_mut() { *x += 1; } assert_eq!(v, &amp;[1, 2, 3]);
You could use the nightly `#![feature(specialization)]`. But until https://github.com/rust-lang/rust/issues/31844 lands I don't know if there's a way to solve this on stable.
I tried to write a generic function that reads from a specified file and into a destination container of my choice, e.g. a `Vec&lt;isize&gt;`. I tried the following: ``` use std::path::Path; pub trait Input { type Destination; fn read_from_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Self::Destination; } impl&lt;T: std::str::FromStr&gt; Input for Vec&lt;T&gt; where &lt;T as std::str::FromStr&gt;::Err: std::fmt::Debug, { type Destination = Vec&lt;T&gt;; fn read_from_file&lt;P: AsRef&lt;Path&gt;&gt;(_path: P) -&gt; Self::Destination { /*let file = File::open(path).unwrap(); let reader = BufReader::new(file); reader .lines() .map(|line| line.unwrap().parse::&lt;T&gt;().unwrap()) .collect()*/ Vec::new() } } ``` I want to use it like this: `let _input: Vec&lt;isize&gt; = read_from_file("foo.txt");` However, the compiler complains with "error[E0425]: cannot find function `read_from_file` in this scope" It works, if I do this: `let input = Vec::&lt;isize&gt;::read_from_file(input_file);` (So, it basically works, but isn't quite as ergonomic as I'd like it to be..) Does anyone know, why the first one doesn't work and what I'd need to do to make it work? Or is there a better way to achieve what I want?
[Actix and Actors in Rust — Nathan Hawkins](https://www.youtube.com/watch?v=W-hvnVeRJzs) [Actix-Lua])(https://github.com/poga/actix-lua)
Thank you, you just madr my everyday subway journey a lot better :) 
There is this very well crafted project [bible.rs](bible.rs)
To be really honest with you FAST input/output doesn't really count. efficient solution is what you need
There appear to be several flags for opting into various subsets of fastmath semantics, and not-nan is one of them: https://llvm.org/docs/LangRef.html#fastmath , although whether or not this recovers the overhead of performing the check elsewhere would need benchmarked, because the reference doesn't mention which parts of the optimizer actually leverage this flag (other than two experimental vector operations).
I am reading that book. For accessing data in s struct, we can create methods. Why we need traits ?
Hey, that’s super cool! Actually, just yesterday I built the book from its GitHub repo with `crowbook` (or something like that - I can’t remember at the moment), but it just didn’t turn out as nice as this one. This version looks much better!
Most other platforms change parts of their syscall API from version to version, so this library probably won't work properly on any of them unless it somehow is able to detect the platform version of the platform where the binary is running.
&gt; I'm not aiming for binary portability, merely source portability If you're performing raw syscalls directly, /u/thristian99 is correct: your only portability will be between various Linux kernels, and possibly Linux kernel emulations / personas on systems like Windows (WSL) or or Illumos/SmartOS. For other unices, raw syscalls are *at best* unsupported, and at worst breaking semi-regularly, as Go's maintainers discovered (after everybody repeatedly told them it was a bad idea in the first place) with e.g. OSX: the abi of `gettimeofday(2)` changed several times during the Sierra beta, and broke go every time. OSX actually forbids statically linking libSystem statically so it's not like that was a surprise.
Hey everybody – you'll want to take a look at [the errata in the show notes](https://newrustacean.com/show_notes/e027/#errata) – [@centril](https://github.com/centril) was listening as I recorded the show live and caught an important mistake I made, which I explained and covered in that writeup!
Write a tool you need for something.
You're right, my bad. 
What's the difference between a `SystemService`and an `ArbiterService`? Is there one instance of a `SystemService`? I wish there was more documentation in Actix.
If the implementation doesn't leverage hardware NaN then that would allow more tags to be stashed, but this also more than doubles the amount of runtime overhead for the operation relative to the prior comment (not only is one checking for nan both before and after each operation, but also consider that the div function also needs to test that neither the numerator nor denominator are negative or positive infinity, in addition to the test for zero), which makes the concerns about performance even more acute. I also suspect that these checks preclude vectorization. The easier path forward would probably be to take after noisy_float and allow users to have NaNs panic in debug mode, mirroring how integer overflow is handled, though sadly it's conceivable that some people might actually want the ability to receive NaN (just like some people want their integers to overflow), and it may or may not be too late to change the default operations to panic on NaN in debug. Would be an interesting RFC. This also wouldn't preclude any potential `NonNan`, type in the future.
I'm curious, how did you guys handle websockets with actix? And, yes that's the heck impression I got after talking to people about the two frameworks. 
What do you mean exactly by "how to handle websockets"? Any specific question or in general? There are some examples in the repo and I am really just doing the same things.
That's mostly it actually. I should've gone through the repo. I didn't realize that it had built in support for websockets. Thanks :) 
That's mostly it actually, I didn't realize actix had built in support for websockets. I should've gone through the repo. Thanks :)
That's super helpful, thank you.
I'm curious why do you prefer pdf over epub?
Again, very helpful. Thanks.
I'll give that a try, see if it makes more sense than Arbiter. Thank you.
Compared with OOP languages, - Structs like classes without methods - traits like interfaces. But can have default implementationsl inside it. - impl use to define methods for types like Structs, enums or any custom type.
&gt; This Post is just a quick thank you, to whomever decided what `f64` should not implement `Ord`. I *think* that may have been me. At least, at the time the fact that floats implemented Ord really bugged me in Haskell, as it meant that NaN was inconsistently handled based on random decisions of the optimizer, and I wanted to avoid that in Rust.
"Make every detail perfect and limit the number of details to perfect." __Jack Dorsey Unfortunately new site is exact opposite of it :(
My first project were for both actix-web and actix alone(for IRC/Discord bots) https://github.com/DoumanAsh/roseline.rs It can server as good example how you can use actix itself
For desktop use ...and I never considered using an epub reader on windows till now.
`SystemService` is basically global service available to everyone (as it belongs to system) `ArbiterService` on other hand belongs, as it say to particular Arbiter. Arbiter itself is basically wrapper over event loop and controls future execution(You actually can run own arbiter without system itself) so serivce would be only available in context of this arbiter, while system itself becomes more or less global. But to be honest the way it is made right now, it serves a little purpose as user is likely use `System` itself rather than `Arbiter`
Taken straight from TRPL book's [section on pattern matching](https://doc.rust-lang.org/book/first-edition/patterns.html): If you’re using if with multiple patterns, the if applies to both sides: let x = 4; let y = false; match x { 4 | 5 if y =&gt; println!("yes"), _ =&gt; println!("no"), } This prints no, because the if applies to the whole of 4 | 5, and not to only the 5. In other words, the precedence of if behaves like this: (4 | 5) if y =&gt; ... not this: 4 | (5 if y) =&gt; ...
You can just stop system using its static method https://docs.rs/actix/0.7.7/actix/struct.System.html#method.stop_with_code But you might also design it in a way that you send shutdown messages before actually performing shutdown (I usually make separate actor with which others are registering to receive shutdown notification)
Hi, Florian from Ferrous here. We can do both, with appropriate lead time.
Thanks! That's what I figured.
Yup. Nailed it
One of the biggest problem in C and C++ is the way they are thought. The teachers treat them as simple and powerful languages, giving to the students a misdirectioned sense of security in their capacities and knowledge. They stick with old standards, sometimes never acknowledging C99, old practices, and do not spend time to actually teach of the most common mistakes and without telling about Undefined Beheviours. &amp;#x200B;
If I'm not mistaken it is supposed to be implemented for &amp;str so try &amp;url to automatically coerce it into &amp;str
Thank you for your answer, I have read that section in TRPL book, so I know that the guard applies to both patterns. What I want to know is, whether there is a way to achieve this: 4 | (5 if y) =&gt; ... with the match operator. I tried the to use normal parentheses like they do here, but this doesn't seem to be valid rust code.
Thanks for the cool tool! There appears to be some problem with running it using nightly though: ``` --&gt; src/day1.rs:8:1 | 8 | #[aoc(day1, part1)] | ^^^^^^^^^^^^^^^^^^^ | = help: message: use-after-free in `proc_macro` handle ```
You could help me with tallyman: https://github.com/phayes/tallyman This is my “learn rust” project. Each module is pretty self-contained, and of moderate size. As a project, it’s right at the correct level of difficulty for me. I would love another hand if you’re interested. 
It was actually the fact that the rust-lang.org website has a text-transform in their stylesheet for it. I assumed that because it was just CSS that the text would copy correctly, but turns out it doesn't so I'll be changing that.
Thank you!! Now I can read it in my Kindle on the go!
All the things you mention are things I stole directly from rust-lang.org's new design language. I think a lot of it just comes down to taste, but I'd rather have the sites all be uniform rather than dictated by what I think would look better.
That worked, but I don't understand why. I need to pass a reference of url to the get?
true
Implementing a trait on a struct means that any functions become an associated function of that struct. Trait impls cannot be freestanding functions, far as I know. However, based on how you want to use it, I think you're better off using a generic function, like so: ```rust fn read_from_file&lt;T, P&gt;(path: P) -&gt; Vec&lt;T&gt; where T: std::str::FromStr, &lt;T as std::str::FromStr&gt;::Err: std::fmt::Debug, P: AsRef&lt;Path&gt; { // code goes here Vec::new() }``` The tradeoff is that since Rust does not have function overloading, you cannot write more functions that have the same name but different parameters/bounds.
Well if you think about it this way, in the example you gave, you had a match arm that looks like: None | Some(i) =&gt; println!("{}", i) // ?? what's i when we match None? AFAIK, for this reason (and possibly others) there's no way that you can apply a conditional to one part of a match arm
That makes sense, I didn't consider this. Thanks for the explanation.
I have a small rust library for generating 3D meshes: https://github.com/turnage/immense. I’d love to hook it up to a 3D mesh viewer to get real time updates to the mesh users are working on. Right now they have to click refresh in a 3rd party viewer. I think adding a viewer is a relatively small but interesting project. Uses some 3D math, touches on IPC, some just-beyond-novice usages of traits and lifetimes, and some basic GPU usage. If you’re interested I’d happily be available for some calls to discuss it, answer your rust questions, etc.
I get the same error, haven't been able to figure it out, tbh I got a lot of different errors until I updated to the latest nightly (mine was maybe a month old). 
If you need to read an EPUB on Windows, you can use Edge
Ok, that means what I wanted to do is probably not possible.. (I not only want it to be generic over T, but also over the container, Vec is just the first (and only) one I implemented.) I guess I could define an empty struct and make the trait generic over the container and implement it like this: ``` use std::collections::HashMap; use std::path::Path; pub trait FromFile&lt;D&gt; { fn read_from_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; D; } pub struct FileReader; impl&lt;T&gt; FromFile&lt;Vec&lt;T&gt;&gt; for FileReader { fn read_from_file&lt;P: AsRef&lt;Path&gt;&gt;(_path: P) -&gt; Vec&lt;T&gt; { Vec::new() } } impl&lt;K, V&gt; FromFile&lt;HashMap&lt;K, V&gt;&gt; for FileReader where K: std::cmp::Eq + std::hash::Hash { fn read_from_file&lt;P: AsRef&lt;Path&gt;&gt;(_path: P) -&gt; HashMap&lt;K, V&gt; { HashMap::new() } } fn main() { let _input: Vec&lt;isize&gt; = FileReader::read_from_file("foo.txt"); let _input: Vec&lt;f32&gt; = FileReader::read_from_file("foo.txt"); let _input: HashMap&lt;usize, f32&gt; = FileReader::read_from_file("foo.txt"); } ``` I actually quite like this. This might even allow me to use the builder pattern on `FileReader` and make some of the behaviour (e.g. separator) customizable without having to define a trait with a dozen different methods... Thanks for your input, that helped lead me in a different direction :-)
The OP was very responsive to issues on the repo, perhaps add one there? [https://github.com/gobanos/advent-of-code-2015/issues](https://github.com/gobanos/advent-of-code-2015/issues)
+1 here, would be down to tune-in!
Because that's function is generic that accepts anything implementing `IntoUrl`, which is not implemented for String, so you need to pass &amp;str(which you get automatically from &amp;String)
So `reqwest` requires arguments to `get()` to implement a trait (`PolyfillTryInto` it seems). This trait is implemented for `&amp;str`, but not for `String`. `&amp;String` derefs to `&amp;str`. Hence let resp = reqwest::get(**&amp;**url)? should work.
In erlang you'd have all of your actors running under supervisors. This means (among other things) that you can send a stop signal to the top level supervisor and it will propagate the signal all the way down the supervision tree, allowing the entire system to gracefully shut down.
Reverse it and have Some (i) if i &gt;= 5?
Others have explained why you need to pass a reference, but not why the API is designed that way. The reason is that in Rust, if something only requires a reference, you can still use the string afterward. If you had to pass an owned string to something that only reads it, it can be a waste of the allocation - if you wanted to use the URL afterward you'd have to clone it.
Is there a way to attach additional pages to the documentation with rustdoc that don't correspond to a source object? I would like to create some "detailed discussion" pages linked from the crate root that a user can reference if interested, but that doesn't make the crate overview page super crowded.
There is this: https://wiki.python.org/moin/PyPy
Not currently. 
Traits are needed be able to use the methods in a generic function, are useful to share and reuse code (look at std::iter::Iterator for an example, you have to define 1 method but get many other for free), and allow for dynamic polymorphism like what virtual gets you in C++. They are also a way for other code to interface with your objects, without knowing exactly what your object is.
&gt; * cargo &gt; * cargo &gt; * cargo This. A "rewrite it in Rust" PR on my project didn't actually improve safety because it's a custom memory allocator we're talking about, those things are inherently unsafe. In theory it also reduced portability, and my project is kind of tailored for obscure platforms... But, I don't want to be tweaking my makefile repeatedly for the next two years and eventually ending up with .in.in files, and it's not like the C code would compile and work as intended on 32-bit SPARC running Solaris as-is even after I go through all that effort. So I thought "buck it", accepted the PR, the code now works as-is for all the platforms Rust supports, and if you're on Haiku you can grab the legacy C code and tweak the makefile - which you would have to do anyway, but this way you have to tweak a simple 10-line makefile instead of an m4 macro and a bespoke autogenerated `configure` that throws an obscure error on line 74183 when processing a file ending with `.c.in.in`.
The invite is expired sadly, I'd love to join to be able to discuss AoC in Rust.
/r/playrust
?
It's not so bad when you omit back references. But people should just use petgraph :-)
This subreddit is for the programming language called Rust, not the game called Rust. The subreddit for the game called Rust is /r/playrust.
Ok ty I’m still fairly new to Reddit 
Yeah, I would love to get a better undestanding as well for this. I have an actix project that basically acts as a kubernetes operator and syncs state using the kube api with in-memory state. But it's all done with just manual Arc&lt;Mutex&lt;State&gt;&gt; and having a thread continuosly watch and update changed to that state in a separate thread. Wrapping it up in nicer Actor traits sounds like a potential way for me too. I doubt you'll extract much usefulness from it, but [link](https://github.com/Babylonpartners/shipcat/tree/master/raftcat) 
It's not expired and it works for me 🤔
That looks quite comprehensive, thank you
Hi, I just wanted to say that this podcast is amazing and I love it. Thank you for all your hard work, it's really helpful.
“Bare metal who?” “Bear met a llama and they’ve been friends ever since.”
fwiw, I prefer pdf generally because the styling is more consistent across my devices and readers (desktop/ereader/mobile), especially when code blocks are involved. With epub, the style and format is more dependent on the reader, the stylesheet, and the devices screen size, which for some might be why they prefer epub. Epub is more flexible for user stylesheets, which is preferred when a pdf is poorly formatted, but there are enough beautifully formatted PDFs by LaTeX etc that lead me check out the pdf first.
So would this compile down to a single add instruction? let n = Some(NonNanF32::new(some_float)); n.map(|k| k + 1.0)
https://dtolnay.github.io/rust-quiz/10 &gt; This question contains a trait method Trait::f as well as an inherent method f on the trait object type dyn Trait. &gt; As far as I know, given that these names shadow each other, the inherent method is literally uncallable. There is currently no syntax in Rust for calling the inherent f on dyn Trait. Welp.. this sounds like a bug / misdesign?
Same. I filed an issue here: https://github.com/gobanos/cargo-aoc/issues/7
Nevermind, it worked when I joined from the Discord app but not by clicking the URL. Thanks.
I've used [Calibre](https://calibre-ebook.com/) for epubs and the like before with success. As a bonus it's free and open source.
I like this. I wonder if it would be possible to unify the navigation with rust-lang.org so that they feel like the same site...?
Awesome talk, thanks for sharing. The serialization design is interesting. One thing I'm wondering and need to look at the code more to see is how they handle "deferring" packets w/this architecture. eg. When sending an IP packed for which an ARP ethernet address mapping doesn't exist yet.
I can only see a 404 :(
I like it! This is also very important for language.
You are constructing a new iterator each time, so you'll just keep getting the first grapheme. Move the `s.graphemes(true)` call outside the while loop - it should only be called once at the start.
You want /r/playrust.
Oh shit ok my bad
Oh, of course! Thank you!
How can I make a struct that has some methods that can be overwritten by the users? For example, I have a `CustomVec` and I want the growing strategy to be configurable: there is a default `grow` function which doubles the vector capacity, but I want users to be able to define their own `grow` functions optimized for their use case. I first thought about function pointers, but that would add an unnecessary indirection, and I am looking for zero cost abstractions. My current solution is to use a trait, and make the struct generic over that trait. trait GrowStrategy { fn grow_s(... trait AnotherCustomFunction { ... trait Params: GrowStrategy+AnotherCustomFunction {} struct CustomVec&lt;T, P: Params&gt; { p: P, v: Vec&lt;T&gt; } impl CustomVec { fn grow(&amp;mut self) { self.p.grow_s(&amp;mut self.v) } } But I'm wondering what's the accepted pattern in the Rust world, because that seems unnecessarily complicated.
Don't have a github account, but here's mine: https://gitlab.com/JMS55/advent-of-code-2018
it's more idiomatic to write for x in s.graphemes(true) { f.push_str(x); }
Rust is hard to learn for me but I’m coming from a background of Go, Python, and JavaScript. I’m a self taught software engineer so no formal CS background either. That being said, I don’t think it’s at all a fault of the language- Rust aims to be a low level systems language with emphasis on security and stability. Coming from higher level languages with a GC and duck typing of course a lot of the fundamental concepts are tricky. I’ve never had to think about whether my variable is on the stack or heap before! That being said I think learning Rust is making me a better programmer in general. I’m going extra slow and working through the book with no pressure to produce anything soon. One day I hope it all clicks and I can start working on some of the projects I have in mind
Well yes, but what I was actually doing was some more logic on each grapheme and pushing them to different strings etc.
Have you guys considered posting the podcast to Google Podcasts? I use that for all the other podcasts I listen too. Overcast doesn't have an app (that I can see) and Pocket Cast's app isn't free.
For desktop use, you could just use `rustup doc --book`.
Check out [`std::mem::swap`](https://doc.rust-lang.org/std/mem/fn.swap.html). fn switch_boxes&lt;T&gt;(boxes: &amp;mut (Box&lt;T&gt;, Box&lt;T&gt;)) { let (left, right) = boxes; std::mem::swap(left, right); }
You can pretty easily use `std::mem::swap(&amp;mut boxes.0, &amp;mut boxes.1)`. Here's an [example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f72cdefd9625385fb5527536dcbda8f0).
You're my hero. Thank you!
If Google Podcasts works with rss it should already work. If not, Podcast Addict is good podcast rss tracker.
Fantastic work. Will have to give this a try when I'm on my Nvidia machine again
I gave a presentation to my organization on Rust in HPC just this week. For the section on Rust + GPGPU, I basically just pointed to your blog post on the topic and said "Eh, the story is pretty weak right now". I wish I had waited a few more days and I could have pointed to this instead!
Google doesn't have a way to subscribe to an RSS feed. I'll try Podcast Addict. Thanks. 
I think the compiler tagging attributes for certain stdlib functions, and having (audited) libraries be able to tag their functions, would be the only thing necessary from rustc. Everything else could be tooling, as you say. Theoretically a compiler plugin could probably do that for you, but doing the tagging in-tree is probably better IMO.
https://github.com/anowell/advent-of-code It's also running as an API as part of a competition between colleagues with different language preferences.
Oooh, this crate could do with a maintainer, https://github.com/Lolirofle/enum_traits Stuff that needs doing: * Update dependencies * Move to the new proc macros API * Cleanup formatting
For something like this, I think you can just convert handle_request to an async function that returns a Result, so: async fn handle_request(req: Request&lt;Body&gt;) -&gt; Result&lt;Response&lt;Body&gt;,hyper::Error&gt; and then use something like the `backwards` function I wrote in the blog post in the callers of `handle_request` to turn it back into the old-style `Future` type expected eg: service_fn(move |x| backwards(handle_request(x))) I hope that helps!
Two XML libraries for Serde have come and gone. Someone should write a polished strongly typed XML library, probably built around an XML-specific custom derive macro.
It would still be nice to be able to use conditionally-bound variables in guards even if they can't be used in the expression itself.
Maybe the hash is badly handled by your Reddit client. Try this [https://github.com/BenoitZugmeyer/RustyAdventOfCode](https://github.com/BenoitZugmeyer/RustyAdventOfCode#other-rust-implementations)
Thank you, I added it!
I hope Khoros will get their stuff together and produce a decent spir-v compute standard that can take on CUDA. This vendor lock-in is just embarrassing.
Can't wait to try this out when I have the time and see how it holds up to nontraditional CUDA kernels.
Np
Your first link 404s
[SpaceHelmet](https://api.rocket.rs/v0.4/rocket_contrib/helmet/index.html) is a nice thematic touch. Remember helmet was a very useful security module for node.
Looks like https://bheisler.github.io/post/state-of-gpgpu-in-rust.md should be https://bheisler.github.io/post/state-of-gpgpu-in-rust/
Well, it fits that a shitty developer like he is working in a shitty company.
Why not AsRef&lt;str&gt;?
I publish \`aoc-runner-derive\` 0.1.4, which solve this problem. &amp;#x200B; If your are curious, see this issue : [https://github.com/rust-lang/rust/issues/56420](https://github.com/rust-lang/rust/issues/56420)
Agh. I keep making that exact same mistake. Fixed. Thanks!
Non-traditional in what way? It should be able to load and execute any valid PTX/cubin/fatbin file. Please do give it a shot and let me know what you find, though.
Some folks (including me) have started up a group(*) to direct efforts towards improving the CUDA situation. You might be interested. https://github.com/rust-cuda (*): Not a working group yet, though we'd like to be once the core team has the bandwidth to take on more subteams.
Take for example two structs which share some behaviour (like speaking), but other than that have very little in common. struct Cat; struct Dog; These structs may have completely different internal structures, but if you want them to share some behaviour all it takes is to create a trait which they will both implement. trait Speaker { fn speak() -&gt; () } impl Speaker for Cat { fn speak() { println!("meow!"); } } impl Speaker for Dog { fn speak() { println!("woof!"); } } The cool thing about this is that you can make certain functions generic over traits, in order to allow cats and dogs to be used interchangeably: fn speak&lt;S: Speaker&gt;(speaker: S) { speaker.speak(); }
That would be great, yeah. Competition is always good. In the meantime though, I figure I might as well build with the tools I have.
Absolutely. CUDA is best-in-class for the time being. This is a *great* looking library. 
Super cool to see more GPU Compute work done in/for Rust, awesome! &amp;#x200B; Btw do you have a Patreon/OpenCollective page? I'm sure a bunch of people would be happy to back it, myself included.
The conversation is interesting, especially regarding the optimizations. I also wanna point out that I find especially funny the term NonNan like "Non Not A Number" aka "A Number"? :)
&gt; I was actually doing was some more logic on each grapheme Uhm I think that calling .collect() on intermediate steps will result in unnecessary allocations.
I use https://github.com/Peternator7/strum and it is mantained, may be merge missed traits?
I'd definitely be interested! I'll check it out.
The [kafka-rust](https://github.com/spicavigo/kafka-rust) lib could use a maintainer. The original author hasn't worked on it in over a year. I had done some work to improve its integration testing, but since my daughter was born, I don't have the time any more.
What serde macro are you trying to use and what edition of Rust are you trying to use?
hi ive updated the question
iirc that is defined in serde_derive.
thats exactly what im importing under macro use 
I see. Your OP says you are importing serde not serde_derive. Anyway I’m pretty sure this is part of the proc macro for Serialize or Deserialize or both. So you use it on a field of a type which is deriving Serialize or Deserialize or both.
 #[serde(rename = "error")] struct Error {} 
I’m not sure what you’d expect that to do. Read here: https://serde.rs/derive.html That’s an intro on derive and the very next page explains how to use attributes.
It would totally be possible. I didn't change the footer at all, and I thought I'd have more things to like to when I redid the navigation. It might be better to move those links elsewhere and unify that component.
Well it didnt explicitly explain if you dont have derive attribute your code will fail to compile with other attributes. 
Just lib.rs. You also don’t need to do it at all anymore in 2018 edition.
I wouldn't create a one-function trait for each behavior but a single one with multiple default (static) functions: use std::marker::PhantomData; pub struct CustomVec&lt;T, B = DefaultCustomVecBehavior&gt; { inner: Vec&lt;T&gt;, _marker: B } impl&lt;T, B: CustomVecBehavior&lt;T&gt;&gt; CustomVec&lt;T, B&gt; { pub fn new() -&gt; Self { Self { inner: Vec::new(), _marker: PhantomData } } pub fn grow(&amp;mut self) { B::grow(&amp;mut self) } } trait CustomVecBehavior&lt;T&gt; { fn grow(vec: Vec&lt;T&gt;) { /* default impl */ } fn foo(vec: Vec&lt;T&gt;) { /* default impl */ } fn bar(x: i32) -&gt; i32 { /* default impl */ } } enum DefaultCustomVecBehavior {} impl&lt;T&gt; CustomVecBehavior&lt;T&gt; for DefaultCustomVecBehavior {} enum AnotherCustomVecBehavior {} impl&lt;T&gt; CustomVecBehavior&lt;T&gt; for AnotherCustomVecBehavior { fn grow(vec: Vec&lt;T&gt;) { /* custom impl */ } } fn main() { let v = CustomVec::&lt;i32&gt;::new(); // default let v = CustomVec::&lt;i32, AnotherCustomVecBehavior&gt;::new(); // custom }
thats cool thanks 
Yes plz this would be yuugggee!
You might want to group your daily solutions together rather than create independent cargo projects for parts 1 and 2. Its not uncommon for part 2 to use the result from part 1 or there is a solution for part 2 with a small modification to your existing part 1 solution. Reduces the tedium of copy and pasting code around.
Yes fuck nvidia they want to own us all
As someone new to Rust, this is fantastic! I finished day 1, only to look at this and realize my code is garbage. &amp;#x200B; Can anyone explain why he has to redefine `Result`? I want to take advantage of the `?` operator like he's doing, and I see that if I don't redefine `Result` I get compilation errors telling me that some very long error trait isn't implemented in `std::io::Error`. Is this just a shortcut to allow any Error types to be propagated by `?`? It seems like Rust encourages you to write functions that return `Result`, but requiring this redefinition to make that work seems kind of clunky. 
&gt;developer Someone's mad
I see; thanks for the info! Hopefully things continue to develop.
All the better!
Now now, there's no need for that kind of language here... (Seriously though. I didn't realise Edge had an epub reader built-in. Maybe it is useful for something)
What about https://athemathmo.github.io/rulinalg/doc/rulinalg/matrix/index.html? Among the ndarray-like crates was the one that was complete, yet small enough to fit my case..
The redefinition just defined a Result type where the error variant is already known. It is no different than using result directly with that variant (Box&lt;Error&gt;) What you are likely running into is that the errors of results being propagated with `?` need to have an `Into` implementation. In this case Box&lt;Error&gt; has an Into implementation for every type implementing the trait Error. If the type doesn't implement Error then it still won't work.
Stack Overflow has screwed me over multiple times, so Reddit is fine. carnix and buildRustPackage are the main methods. carnix reads a Cargo.lock file and generates build instructions that bypass Cargo, while buildRustPackage simply calls out to cargo. As always, The [Nixpkgs](https://nixos.org/nixpkgs/manual/#users-guide-to-the-rust-infrastructure) manual is the best resource. Its information on carnix is outdated. Currently, you can simply run `carnix build` in the project directory and it will update Cargo.lock for you and generate `crates-io.nix` and `Cargo.nix`. `crates-io.nix` collects the downstream crates and acts as a reflection of `crates.io` in Nix. `Cargo.nix` contains the information for the main project and provides a attribute with the same name as the crate that you can subsequently build with `nix build -f Cargo.nix $CRATE_NAME`. If you want to generate the files without building or updating Cargo.lock, then you use `carnix generate-nix --standalone --src ./.`. `carnix build` essentially runs that in the background. Removing the `--src ./.` flag will cause carnix to try to fetch the crate from `crates.io`, and removing `--standalone` will give a file that can be imported with `callPackage`. [A pull request](https://github.com/NixOS/nixpkgs/pull/50923) was recently added to Nixpkgs to update carnix, so this may be invalidated soon, in which case you should check the [carnix repository](https://nest.pijul.com/pmeunier/carnix). `rust.buildRustPackage` requires making a file manually, but the contents are just the same as a `make` package, but with `rust.buildRustPackage` instead of `stdenv.mkDerivation` and with an additional `cargoSha256` field that you fill in after getting the hash of the dependencies. (Give it a dummy value at first just like with the source's hash for nonlocal sources. The build will fail and tell you the real hash to substitute in.) You want to use the nightly compiler? Unfortunately, neither carnix nor nixpkgs support nightly rust and you'd have to use `https://github.com/mozilla/nixpkgs-mozilla` just to get the compiler, then use `makeRustPlatform` to get an environment that you can use `buildRustPackage` with. To add native dependencies, you can use `buildInputs` with `buildRustPackage` just like with other derivations. I'm not sure how to do it with carnix though. --- If you have any other questions, feel free to message me! It's always nice to see a fellow Rust user who also uses Nix. A little more information on your end will make my job much easier. I should ask how familiar you are with Nix as a whole, as that will greatly affect the course I'd recommend.
The kernels are nontraditional in the sense that they have the potential to have call stacks that can go anywhere from 4-8 calls deep, and the threads are acting closer to something you might see in an OpenMP program. I'm currently working on something similar in a C++ program at work, and I'm curious to see if I can accomplish the same using Rust. 
Thank you very much for the reply. I haven't finished reading all of the Rust documentation and Rust by Example and I see that what he's doing is explained here: https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html 
Being able to check out a path is a major win for monorepos (already beating GIT and mercurial). Win number 2 would be permissions in an os transparent manner on server/middleware level 
Ah thanks for the tip! Yeah I might revise my organization. This is my first time doing AoC, so I wasn't sure what to expect.
Can you point us to your GitHub repo?
This is a nice collection! Always interesting to compare solutions. Here's this years for me: https://github.com/udoprog/rust-advent-of-code-2018
Because it is general rust rule, not serde specific.
The project the language was made for - servo.
Even though `std::mem::swap` is what you are looking for I must say that it is possible do write your own `swap` with unsafe code. fn myswap&lt;T&gt;(left: &amp;mut T, right: &amp;mut T) { unsafe { let l: T = std::ptr::read(left); let r: T = std::ptr::read(right); std::ptr::write(left, r); std::ptr::write(right, l); } } Just to reassure you that `unsafe` is allpowerful and you can do literarly anything with it. But you know, with great power comes...
[wxRust](https://github.com/kenz-gelsoft/wxRust)! Rust _desperately_ needs a good GUI library, and wxWidgets has a mature C interface, and compiles to platform-native widgets. If I knew more about it and had more time I'd contribute/take over.
Shameless plug, https://github.com/solana-labs/solana :). 
Really. That's interesting, I would have assumed the same thing, if the body copy is lowercase, and it's just styled to all-caps.
Thank you for doing this! I'm coming from Python, so I'm hoping to compare my solutions to yours and learn a lot about writing idiomatic Rust.
Your assumption that https://docs.rs/unix/0.6.7/unix/process/fn.fork.html can be safe is problematic; see https://github.com/rust-lang/rust/issues/39575 for discussion.
&gt;This is how we used to do it, and it almost always backfires. Plus, since we've done it so much already, this style has already reached as many people as it's going to reach. Honestly, this is my big takeway. I think there are some good suggestions here, but what I would really say is that the new website is for a different demographic than most of the people giving negative feedback. Unfortunately, you can only have one website. This needs a hulu style, "choose your own marketing experience".
With everything being async already, what would it take to put the Futures API over this?
I don't know, but I do plan to explore that at some point. It ought to be possible, since CUDA does allow you to request a callback after some work is done.
Very cool. And nice work!
Agreed. Pick *any* language. There's little that beats a browser engine for complexity and safety needs.
Quick question: Any reason you do writeln instead of println? I just noticed it in your day 1 code. Didn't know if I shouldn't be using println for a reason. &amp;#x200B; Also, thanks for doing this! I saw some unneeded extra steps I was taking in my code that I could have easily gotten rid of for day 1.
Glad you like it! And yeah, I use `writeln!` because it returns an error if it can't write output where as `println!` will panic. I'm trying to write these programs as if I would in a "real" program, and in a real program, I rarely use `println!` for this reason (aside from debugging of course). If I were treating these programs like the toys they invariably are, then I'd be `println!`'ing and `unwrap`ing everywhere. :-)
Rust itself
That won't change much if NVIDIA doesn't add support for that to their drivers. OpenCL 2.0 has been out for 5 years and is soo much closer to current CUDA capabilites than OpenCL 1.2, but support for it has never really spread, since NVIDIA is keeping their cards at 1.2.
An operating system perhaps? In which case there's also Redox, I think it's called.
Awesome that crate looks great! I made an issue asking if they are interested in me porting over the traits I need from `enum_traits`.
I'm back to working on tiny rust projects after several months of absence. To get back in the groove I am building a command line based diary/todo application type thing. I am using it myself on Linux but it should also work on OS X. https://github.com/abhijat/ya2d2
Leaf was kind of a big deal early on, then went belly up one day.
Thanks for a very thorough reply. I'm not that familiar with nix, I haven't really been using it that much yet. I am familiar with lazy functional programming in general and I have written a few simple derivations for C applications/libraries, but nothing more than that to be honest. Recently I have been a bit frustrated with deploying rust applications using docker, even after using multi-stage builds and the empty project hack to avoid rebuilding dependencies. I feel like a good understanding of nix could help me out in simplifying those kinds of deployments in general, and for rust applications in particular.
I created a private leaderboard for rustaceans. (Wait... is that how you spell that?) ID: 407350-aa6a1089
`unwrap` takes `self`, not `&amp;self`. `println` is a macro, so it can take and print a borrowed value or an owned value just fine. Try doing `album.artist.as_ref().unwrap().as_str()` and `album.songs(&amp;client).as_ref().unwrap()` instead. Note: if you don't do the second one, I think you'll also have the same error, too. If not, it might affect or fail to compile if you add other code.
Maybe not the largest, but a few important ones outside Mozilla: Redox OS, Habitat by Chef, MicroVM by AWS called Firecracker (very recent), Rocket (web framework), Hyper (HTTP lib) , Exonum (blockchain solution), Parity-Ethereum (ethereum client), Diesel (ORM). So you see Rust's been used from building things as high level as web frameworks to as low level as MicroVMs, OS'es. Besides there's also lot happening on the Gnome libraries' Rust bindings front (gstreamer, gtk). See GNOME+Rust Hackfest for more.
My solution for part 1 was very similar to yours -- only I used a Vec instead of a HashSet to check for 'seen' items. Switching to that container reduced my solve time from 1.9s to 0.01 (both in release).
Rust mongodb driver, it was a "test" project but a lot of people use it in production. It leaks of async interface.
I'm kind of hoping that Vulkan will force their hand, since it includes first-class support for compute shaders and they won't be compliant without supporting them...
On a similar note, the machine learning crate he built rulinalg for could also use a maintainer. https://github.com/AtheMathmo/rusty-machine
Unfortunately not, it's a corporate project.
Yeah would have been awesome to have such an ambitious machine learning framework in rust. There was an attempt to fork and continue it, but I don't think too much progress has been made: https://github.com/spearow/juice
Good stuff! I forgot to even think about using `zip` in day2, and I haven't used that result trick before for easy error propagating so I'll keep that in mind! I found `cycle` a little more elegant than looping on day1 part 2 to repeat the iterator until we break out of the loop :)
I would recommend keeping a tab on /u/birkenfeld’s as well: https://github.com/birkenfeld/advent18 Really makes you feel like you don’t know jack about the stdlib. 
In a real program would you typically leave error-handling as it is, or replace some instances of `?` with `.expect()`, or handle the errors some way differently? I added some random letters to a line in the input and the message you get is just `Error: ParseIntError { kind: InvalidDigit }` instead of an `expect` message that might provide more information if there were multiple places you could get a `ParseIntError`. 
I did the same recently but I saw you include a static version of openssl, xz and zlib. Why is that? I guess it's required if you need to compile crates that use those libs? &amp;#x200B; (My simpler version: [https://github.com/collibra/wait-for-postgres/blob/master/Dockerfile](https://github.com/collibra/wait-for-postgres/blob/master/Dockerfile) (doesn't include any lib))
Thanks! In that case, I think I'll try to make it a little more obvious where different things come from; I have added a few external things to my prelude to make writing the code quicker. (MVP is, of course, itertools, which is such a heaven for these kinds of problems...)
I'm quite new to rust so I hope you don't mind me asking. But there's something I'm not quite understanding from the example. If your library is a Rust Wrapper around the C API, why does it expose an unsafe function? Shouldn't the unsafe*ness* be handled by the library and let the exposed API to the Rust user be completely safe?? 
[TiKV](https://github.com/tikv/tikv) A distributed transactional key-value store
HashSets are awesome for their use!
...great headache when reviewing the code.
I love the idea of ensuring that nothing panics, I shall refactor my solutions now to do that too. 
Now that I've done that, I've found myself using: Err("some message")?; Rather than explicitly using `From::from()` -- which would you say is more "idiomatic"?
Might be worth adding a description of what the tool does and the reasons you might want it to the README. I had a quick glance at the code and two things that immediately stuck out was the println! Calls in the code. I’d suggest replacing these with log calls (debug! for example) from the log crate. This coupled with env-logger lets you turn on logging when you need it but not have it output normally. Secondly I would recommend replacing the use of the die function and process::exit in various parts of the code base will bubbling up errors to a high level error handler that can report the error to the user (probably on stderr) and then exit. This way you encode which things can fail into the code, whereas the current code doesn’t make it clear which functions can fail and exit and which one last won’t. 
That's actually quite interesting. I guess there may exist extensions for the other browsers as well. I was gonna comment that pdf is nice because it has built-in support in basically all browsers, and I guess that point still stands, but this is quite nice! 
Even more elegant when you combine `cycle` with `take` to prevent [effectively] infinite looping on input like `+1` https://github.com/anowell/advent-of-code/blob/master/src/day1.rs#L19
Nice to see you on AoC ! &amp;#x200B; I published a helper for it : [https://github.com/gobanos/cargo-aoc](https://github.com/gobanos/cargo-aoc), you might be interested ! Right now, it won't allow \`Result\` as output, but I think I can add this feature, is anyone interested ?
[https://github.com/gobanos/advent-of-code-2018](https://github.com/gobanos/advent-of-code-2018) AoC if for me a great way to make fast progress in rust, and to discover the ecosystem !
It woudn't be nice to has patterns like `Some(i+5)` as short version of `Some(S(S(S(S(S(i))))))`
The difference is that one is made for production and the other is a test project.
Which is pretty much what `std::mem::swap` is doing behind the scene (though it does use an optimization for values less than 32 bytes): [https://doc.rust-lang.org/src/core/mem.rs.html#633-637](https://doc.rust-lang.org/src/core/mem.rs.html#633-637) [https://doc.rust-lang.org/src/core/ptr.rs.html#183-201](https://doc.rust-lang.org/src/core/ptr.rs.html#183-201) `unsafe` is powerful buy dangerous - which is one of the reasons why functions like `std::mem::swap` exist in the standard library - so that we don't have to write unsafe code ourselves.
[redis-rs](https://github.com/mitsuhiko/redis-rs) is missing support for redis streams and other redis features. Also [badboy](https://github.com/badboy), [mentioned in a ticket](https://github.com/mitsuhiko/redis-rs/issues/162) that he would be happy to guide external contributors in implementing that.
You have old information .. Go was used only for early prototype but it is rewritten to Rust because of GC.
Yeah, this should never be brushed aside. Compilers are hella-complex and difficult to code.
It's experimental, but I don't think that's to say that it doesn't involve significant and serious work. It may not be ready for production usage right at the moment, but then, as I understand it, neither is the majority of Servo - rather, it's being used as an experimental platform to design technology that can be moved into Firefox.
A substantial part of Firefox is written in Rust by now: [https://twitter.com/eroc/status/1061049330574884864](https://twitter.com/eroc/status/1061049330574884864) &amp;#x200B; Some important parts of the Dropbox infrastructure also seem to run on Rust: [https://qconsf.com/sf2016/sf2016/presentation/going-rust-optimizing-storage-dropbox.html](https://qconsf.com/sf2016/sf2016/presentation/going-rust-optimizing-storage-dropbox.html)
You can further up the elegance by using `find` to terminate the iteration by returning the result of the insert directly. A running sum would even make find’s result be the exercise’s but implementing one via scan was worse than closing over the frequency imo. 
No worries, this happens about once a week!
Thanks, this is certainly better, and I can just create two variations of the new function: `new` which uses the default behaviour and `new_with_behaviour` which is parametrized over `B`. But I'm still missing some functionality, for example you can't add new methods this way. I think it would be solved with some variation of class inheritance but still. I found a crate which provides a macro to extend an existing struct, but I forgot its name.
Listed "decorum" in [my special crates list](https://users.rust-lang.org/t/list-of-crates-that-improves-or-experiments-with-rust-but-may-be-hard-to-find/17806).
FYI, [cross](https://github.com/rust-embedded/cross) supports that too, and there image looks like [this](https://github.com/rust-embedded/cross/blob/d02960f5e6e0abea26473b177ab110d83fc2ec07/docker/x86_64-unknown-linux-musl/Dockerfile) (note the scripts for setting up musl and openssl).
I used `yaserde` for serializing and `serde-xml-rs` for deserializing but I wished there was one crate that can do both..
100 days later
thanks for your feedback. i will go over all the points. thanks really appreciate it.
This works :P let val = Some(3); let satisfies_guard = 0; match (val, satisfies_guard) { (None, i) | (Some(i), _) if i &lt; 5 =&gt; { println!("value too small"); } _ =&gt; {} }
Sigh. [r/playrust](https://www.reddit.com/r/playrust).
Last I checked, Servo was also experiment that's never meant to actually be used in production - it's just that parts of it are being backported to Firefox, with the eventual goal of replacing everything in Firefox engine with Rust code, but one that's not exactly Servo.
If I want to make something iterable should I generally implement `Iterator` or `IntoIterator`? I know they are different things, but in the end both are concerned with making things iterable and since `IntoIterator` seems to be by default implemented for all `Iterator` traits, when do you fall back on implementing `IntoIterator` manually? 
would be more relevant if the rust game was written in rust, eh?
 let answer = commands.into_iter().fold(0, |sum, command| match command.operation { '+' =&gt; (sum + command.value), '-' =&gt; (sum - command.value), _ =&gt; sum }); Why is this giving me this error: thread 'main' panicked at 'attempt to subtract with overflow', src\main.rs:33:16 note: Run with `RUST_BACKTRACE=1` for a backtrace. commands is a Vec&lt;Command&gt; struct Command { operation: char, value: u32 } 
I would usually provide additional context on the error. Typically enough information such that the end user has an obvious path to fixing or avoiding it. I would never used a panic to expose an error to an end user. If an end user sees a panic, then I always consider that a bug, without exception. Outside of that, if you want backtraces on your errors, then you should use the failure crate, which will handle that for you.
Mine is here: [https://github.com/djc/aoc-2018](https://github.com/djc/aoc-2018)
Yeah sure, I have a stronger preference towards loops than longer iterator chains, all else being equal, because I tend to find them easier to read. YMMV.
I don't know that I'd say there is a strong answer here. I would say however that using `?` as a terser way of invoking From::from is definitely a thing. I tend to see it more work the Ok branch though, e.g., `Ok(something()?)`.
On the other hand, wxWidgets has a horrid API with a lot of legacy, looks like an eyesore on any platform you run it on, and makes it incredibly hard to support modern features such as high DPI screens which other GUI libs give you almost for free. I would love to see Rust's GUI story improve, but I'm afraid wxWidgets is not a feasible solution.
The `Iter` values should not implement `Copy `, which would lead to all sorts of footguns. The collections however might. So having a different type in between makes the whole system more flexible.
That's a great workaround, thank you.
I use `return Err("Msg")?;`. `return` is noop here, but it emphasizes unconditional early return.
Yes and no. Compilers are still mostly batch processes: File I/O, with maybe some relatively simply multi-threading. Compared to a Browser which adds Graphics and Network to the mix, with a lot of asynchronous events, timers, etc... a compiler is child-play. It may implement complex algorithms, but in isolated silos.
I have pretty much the same impression. I'm not fluent with it yet, but maybe after my next hobby project.
Doesn't seem very important (usage) nor very large (codebase size).
I tried parallelizing the day1 solution personally but it seems it’s not without mathematically modeling the problem accurately and I’m kinda lazy to do so :/ Used HashSet from hashbrown too
Amazon \[Firecracker\]([https://aws.amazon.com/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/](https://aws.amazon.com/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/)) is a good contender in the future, depending on adoption.
Weird. My program as written runs in "finger response" time (33ms).
Doe someone know how to do an online-backup with sqlite &amp; r2d2::diesel? With rusqlite there is [an example](https://docs.rs/rusqlite/0.15.0/rusqlite/backup/index.html] but I don't know how to do this with diesel :(
Nice job! Always good to see Rust expanding into more domains
You can use [`Duration::from_secs`](https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.from_secs) at [`src/helper.rs:11`](https://github.com/ooooak/sql-split/blob/master/src/helper.rs#L11)
Not exactly true for “modern” compilers, which are capable of supporting a feature-rich IDE. In this setting, you have that annoying setup of long-lived state which changes over time according to user’s input. Of course that’s still far easier then the browser, because you don’t have network, but it is significantly more complex then a phase oriented batch job.
Is there a way to find the type of a variable? For example: x = PUZZLE.lines().filter\_map(|s| s.parse::&lt;isize&gt;().ok())\` How would I find the type of x? In python I would just print(type(x)). Do you just know it from the functions you used? Do you have to look up their signatures every time? Or is there a better way? &amp;#x200B; I find myself writing wrong code so I can at least get type information from the error messages. 
Currently, most people use the following trick: Annotate the type of the binding with `()` (empty tuple) which of course fails to type check (in most cases) and then read the error message: "expected [type] but got ()". In this case: x = PUZZLE.lines().filter_map(|s| s.parse::().ok()); let _: () = x;
`command.value` is of type `u32` (as defined in your struct `Command`) which only holds unsigned (non-negative integers). An input like `[Command { operation: '-', value: 1 }]` tries to subtract `1u32` from `0u32` which panics in debug mode. An easy fix would be to change `u32` to `i32` but you could also use `u32::checked_sub` in combination with `try_fold`.
gfx-rs could be a pretty big deal imho - with opengl about to no longer be a viable cross platform 3d api, gfx-rs gives you a solid cross platform target amethyst game engine
Well, how about a way to get the part two ? Cache it in a file too ? Get the &lt;main&gt; and maybe transform it in Markdown ? &amp;#x200B; But I agree that not very useful.
What is missing wrt compliance? I am using vulkan with compute shaders on a gtx1080 for quite a while now...
My money's on Redox, the operating system.
Actually this would be a plain old bypass of the website. IIRC AoC is sponsored and needs the money to keep the awesome event going on. The scope of this project was to provide a tool and a small framework for developers, not a way to bypass the website :) 
Thank you for your answer. This is horrible.
I'm guessing what they mean is they originally stored the "seen" items in a Vec, and switching to a HashSet made it go from 2s to a fraction of a second. Which makes sense given (at least on my input set I don't know if everybody gets the same) it takes close to 150,000 changes to get a duplicate frequency, and since there's no hit before that you'll be traversing the entire vector every time unless you keep it sorted and do a bisection search (though I don't know how costly that would make *inserts*).
GitHub Project: https://github.com/oconnor663/bao Slides from the video: https://jacko.io/bao_presentation/presentation.html This is a talk I gave at the Rust NYC meetup on November 27, 2018. Speed demos are at 3m48s and 43m08s, and the encoding/decoding demo ("Barney the Demosaur") starts at 12m36s.
&gt; This is horrible. That's true. I hope that some day, there will be a macro like `dbg_type` or `print_type_of`which'd be just a thin wrapper around a compiler instrinct. For bigger projects, I use VS Code + RLS (rust language server) where I can just hover over a variable and displays its type and documentation. But does not work 100% of the time :/
Why can't Vulkan compute shaders take on CUDA? What exactly is lacking in them?! Why can't everyone just use Vulkan for everything?
Do you have an example of that?
OOOOOooo... :-) I completely misread the parent comment. Makes sense now. Thanks for explaining that! I'll blame AoC. It's throwing off my sleep schedule. It's been a long time since I stayed up past midnight.
I'm not clear on something: Does this get data from a database table and convert it into sql files?
Agreed. If one were to go down improving bindings I'd say Qt would be the best target, even if it's only for QML support.
it's basically SQL dump splitter. suppose we have 1gb of SQL file and we want to split it into small files.
Then go the extra mile and get it from the database directly. The reason being, to generate a 1gb SQL file will take a fair amount of time single-threaded to only then split it at the end. If you can create an app that multi-threads that downloads and splits the output file, that could be quite useful. 
You should use references for that, or a Rc.
Use a Rc/Arc with a mutex? Maybe weak pointers but probably not.
This is great to see! I'm also trying out AoC in Rust and am very open to suggestions for improvement: https://github.com/sremedios/adventofcode2018
RAINBOWS
&gt; Any code that handles coroutines generically will have to be monomorphized in order for allocations to be elided. Isn't that exactly what happens in Rust? If you call a function handling a generator with lots of different generators, it gets monomorphized. You can avoid that with `dyn Generator` but of course then you get an allocation again. &gt; coroutines that are put into a std::vector will always have at least one additional heap allocation per coroutine. However, to do that in Rust, I'll likely need a `Vec&lt;Box&lt;dyn Generator&gt;&gt;`, won't I? Even Rust needs a heap allocation to obtain a uniform run-time representation, which `Vec` requires. I'm probably missing something, since you got an example, but these issues you are bringing up here seem to equally apply to Rust.
Hashes aren't used only for that. For example, if you're verifying data checksums, you want the fastest algorith possible.
I was referring to the rainbow artefacting from the camera, making all the slides in the stream look wildly colourful.
I tried that, but there is still some link missing that i dont understand. [I changed my code to use references,](https://play.integer32.com/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=e650bd25b39c0269e17aac37ea7bfe3a) altough i'm not sure thats quite the right way to do it. Anyway, the message i get now is the trait `Object` is not implemented for `*mut A&lt;'_&gt;` which doesnt make any sense to me, since object is implement for A?
There *is* [rust-qt](https://github.com/rust-qt/cpp_to_rust) available to be contributed to and the last commits to the generator repo are back in December 2017. I'd try it instead of using PyQt with rust-cpython, but "Creating custom signals from Rust code" is still on the generator's [TODO list](https://github.com/rust-qt/cpp_to_rust/tree/master/cpp_to_rust/cpp_to_rust_generator#qt-specific-features-coverage).
Fast is good, but low collision rate is better. For example, we can simply add n bytes with overflow. That would be super fast, but has a high collision rate. There is a reason CRC is so popular in the data verification space.
There are examples in the vulkano-rs guide/repository that are probably easier to follow than my messy stuff - also less confidential :)
Someone's not mad. Someone's sad. Someone's happy. Come on, Java/hidden Rust dev, you can do better.
Intellij with the Rust plugin annotates bindings with their types automatically.
Haha! I thought you've mocked the hash function because it would be easier to scan password hashes with rainbow tables if it's faster to compute :)
Yes, those libraries were required by crates in the project I used it in!
Yes, when compared to servo. But the scope is pretty large. 
Thanks, I'll look into cross!
Optimization gets pretty difficult though
Unsafe isn't really in my already small wheelhouse, but *mut A is a mutable raw pointer, IE a different type from an A. https://doc.rust-lang.org/std/primitive.pointer.html Also the docs for Box::into_raw say that it consumes the box you pass it, so passing it twice in a row is probably not going to work. FWIW the chapter on RC in the book implements a list type with nil/cons cells; it is implemented differently but might give you some inspiration. https://doc.rust-lang.org/book/2018-edition/ch15-04-rc.html
I don't think anyone is going to stop using OpenGL just because Apple says "use Metal now plz".
Not that much when a lot of it is just "here you go LLVM, do your magic".
Actually, many optimizations passes are relatively simple in isolation. There is a lot of studies on super-optimizers which are devoted to finding the best combinations (ordering/repetition) of simple optimization passes for various scenarios. Like: here are the bricks, go build something!
In a conversation earlier here on Reddit someone mentioned the `#[non_exhaustive]` attribute. I've tried using it recently, and the (stable) compiler complained that it's an experimental feature, and refused to compile. Well, ok, but how comes it is used then on `std::io::ErrorKind`? Do they use the nightly compiler to compile the stdlib?
True, incremental compilation adds a whole new dimension. Unfortunately, in my experience very few compilers have direct support for this; it seems separate tools are used instead.
Obligatory: Password hashes have opposite design goals from other hash functions, and the two must never be swapped. I wish we didn't even call them "hashes".
Dropbox use Rust for their backend (search for their blog posts on magic pocket)
The best answer depends on what you're trying to do. C pointer homework? Use `unsafe` and raw pointers. Note that sort of code needs extensive testing and review before it can be put into security-sensitive production. Rust `unsafe` just brings the gotchas closer to the surface. Do you really need to deallocate memory in the middle of an operation? No? Put them in a `Vec` and use indices to implement the links. Drop the whole thing when done. This is frequently how directed graph structures are handled in Rust.
In a perfect world, yes. RustaCUDA does hide as much of the unsafety as it can. However, launching a compute kernel (which may be written in another language) is inherently an unsafe thing to do. The Rust compiler can't verify that the kernel expects the same number and type of parameters as the programmer is passing, it can't verify that the kernel doesn't do something unsafe (for example, the kernel could write invalid values into memory buffers that could be copied back to the host), and it can't verify that the programmer won't try to copy device memory back to the host before the kernel has finished (which would cause a data race, and is thus unsafe). Ultimately, in this case we have no choice but to assume the programmer did everything right, so we make the programmer wrap it in an unsafe block as a sort of promise to the compiler that they did.
But `rustc` *does* have support for incremental compilation.
Relatedly: Have you seen [Learning Rust With Entirely Too Many Linked Lists](http://cglab.ca/~abeinges/blah/too-many-lists/book/)? It's a great read.
One big difference is that `rustc` contains the `nvptx` LLVM backend, which means it can compile Rust code to CUDA kernels(*). The SPIR-V LLVM backend is a third-party unofficial project which isn't available in `rustc`, so we would have to use a modified compiler to compile Rust to SPIR-V. (*): Some of the time, anyway. It's not well-supported or tested, but we're working on that.
Not immediately, but in 5 years when OpenGL has progressed and there's features that new GPU's support and you can't use them on MacOS... then a lot fewer people will want to use OpenGL.
If you’re not coding around your cats and they don’t wake you up for food...you probably don’t have cats. 
Do you know which ones have the lowest collision rate?
The second part seems like a solid enough argument for me. But the first part of the number of arguments and their type I don't quite get. Assuming (I've never programmed in CUDA so I could be entirely wrong) CUDA gives you an error when you try to launch it with incorrect parameters, shouldn't the library catch it and properly represent it in a Rust error (panic-style)?
Most browsers are more complex than a lot of minimal operating systems are, now. I'm not even kidding.
AWS Lambda Function*
You’ve posted in the wrong subreddit. You’re probably looking for /r/playrust This subreddit is about the rust programming language. 
AFAIK no modern 256-bit cryptographic hash function has a known collision. That said, making a general-purpose fixed-length hash function with no collisions is mathematically impossible due to the [pigeonhole principle](https://en.wikipedia.org/wiki/Pigeonhole_principle). Collisions are just so extremely rare that they don't practically happen.
People are already starting to decide to not use opengl because apple deprecated it. The version you have to target is already old, and now it is just going to get older, and there is no assurance it will keep working in the future. 
To be clear, you're referring to how password hashes shouldn't be too computationally cheap?
You'll often see the term "key derivation function" as an alternative!
Qt would also be a good option. QML is probably the only option for Rust since Qt Widgets relies so heavily on class inheritance...
Right. General purpose hash functions are designed to have as much throughput as possible and to use almost no memory, while password hashes are designed and tuned to have as little throughput as possible/practical and to use lots of memory.
Looks really strange, you use musl, but ubuntu? Why not use alpine distro and use prebuild versions of all libraries from package manager?
Just call it a tree. Rc&lt;RefCell&lt;_&gt;&gt; would do the trick but they are an absolute pain. I usually go with storing an Index into a Vec&lt;Obj&gt;. Petgraph is the best crate for tree's I've come across. In general tree's are very hard to do right and fast ( in any language ). If possible , pick a different data structure. 
No, but they use a special key to make the stable compiler allow unstable features. This is also how clippy compiles on stable btw.
That's really interesting. Solely out of curiosity - I'm _not_ comfortable putting it into my code - how is it activated? It doesn't seem to be in clippy's `Cargo.toml`, and the project is just too big for me to find it on my own. Is it some kind of environment variable?
"with a buffer of indices as well as buffer of indices"?
&gt; I was an avid D user What changed? If you have moved to Rust, how do you deal with such an inadequate standard library? The majority of the 3rd party libraries (crates) are far from v1.0, and undermaintained, I wouldn't be surprised if crates.io suffers from the same disaster as NPM recently. But unlike JS, Rust isn't one of the languages that encourage you to do stuff by yourself as it's cumbersome to fight the BC and such.
Should be "with a buffer of vertices as well as a buffer of indices". It is fixed now, thanks!
I went back to a `Vec` and it ended up being more than twice faster than a `HashSet`: [github](https://github.com/CasualX/adventofcode2018/blob/master/src/bin/day1.rs#L31-L54). However I use the `Vec` as a bit set of 0.5GiB to detect if I already seen a frequency. If I use unsafe code to ignore initialization of the vec (the OS has zeroed this memory anyway, so the extra initialization is extra work) it takes off a few ms.
Thanks for the elucidation! 
Consider big, important applications like Blender that are based entirely around OpenGL though. It's not as though they're going to create a whole separate backend just to support Mac.
&gt; such an inadequate standard library Any particular examples? &gt; The majority of the 3rd party libraries (crates) are far from v1.0, and undermaintained In my experience, it's the other way around: average quality (and maintenance) of Rust crates exceeds that of D packages. Plus, most crates would be fully documented, just because rustdoc makes it very simple. There are exceptions, of course, but I personally believe it's true overall. For instance, I was recently looking for a package that efficiently generates prime numbers at runtime -- a quick search in dub yields two packages, both last updated two years ago, and only generating them at compile-time; a quick search in crates.io yields a whole bunch of crates with tests and documentation, updated recently; some of them using quite advanced non-trivial algorithms. But that's just an example. Another thing is that D community is sometimes too crazy about is the whole compile-time thing - e.g., some packages are compile-time-only (like primes packages mentioned above); quite often an otherwise trivial package turns into a gigantic mess of meta-stuff, static ifs etc, just so the author could claim it's "CT", even where it doesn't make a difference. &gt; Rust isn't one of the languages that encourage you to do stuff by yourself Not sure what you mean here; there are universally-useful crates like [itertools](https://docs.rs/itertools/0.7.11/itertools/), [hashbrown](https://docs.rs/hashbrown/0.1.6/hashbrown/) or [parking_lot](https://docs.rs/parking_lot/0.1.0/parking_lot/), just to name a few that I've used myself lately. &gt; it's cumbersome to fight the BC and such I don't know... once you have some experience behind your back, you don't really fight BC anymore (it may be somewhat tough at first though). It has also become much easier to handle some edge cases with the recent addition of non-lexical lifetimes.
I don't have the math chops to sufficiently answer that. Good Crypto-hashes will have excellent distributions (wouldn't be a good crypto hah if it didn't). However, they tend to be slow. Hashes I've seen/heard that have good distributions and are fast are murmur 3, fastfnv, and City hash. These aren't crypto hashes because it is trivial to create colliding inputs. I'm not, however, up to date enough to say which is "best".
There's popped up [a question on SO](https://stackoverflow.com/questions/53573575/creating-a-rust-shared-library-that-returns-a-struct-of-function-pointers-to-c-m) recently, where the author wraps his pointers to functions (in a struct designed to interface with C) in `Option`s. I have a few questions about that: 1. Is there a point to do it? Don't pointers have `null` functionality baked in? 2. Will C side actually accept an `Option`-wrapped pointer where it expects a plain pointer (well, without UB)? I suspect the answer is no, but I've never tried interfacing with C from Rust before.
Awesome! I'm trying to boost my Rust skills and am doing AoC 2018 in Rust as well: [https://github.com/theonewolf/aoc2018](https://github.com/theonewolf/aoc2018) It's really awesome seeing other people doing this too!
Sent in a pull request for my repo ([https://github.com/theonewolf/aoc2018](https://github.com/theonewolf/aoc2018)). &amp;#x200B; Thanks for organizing this!
To be honest, I hope that this kind of npm-like crates with just a few lines of code don't proliferate in the Rust ecosystem. The simple\_input crate (at version 0.4) provides a single function, consisting of 6 statements. The metadata in Cargo.toml contains just as many key/value pairs as there are statements in the code, FWIW.
Pointers (as in `*const x`) have a built-in `null` option, while refs (as in `&amp;x`) are guaranteed to be non-null. Therefore, 1. no, an `Option&lt;*const T&gt;` doesn't make too much sense. However, an `Option&lt;&amp;T&gt;` does, because it is conceptually equal to a (possibly null) pointer. 2. No. This won't work and is probably UB.
Sort of. It's a secret cargo option, if I recall correctly. And it's not within the clippy project repository. I don't use it either, because I build clippy with nightly anyway. You may be able to see it if you ask rustc's bootstrap cargo for verbose output. Also you're right not wanting to put this into your code. It is unsupported and at that point, you might as well use nightly, where no secret key is required.
256 bits is almost (off by a little more than three orders of magnitude) enough to index every subatomic particle in the visible universe (10^(80)). It can handily index every unique binary file stored on any man made storage medium on Earth today.
Just some feedback that I find this serif font really hard to read on my phone. 
As long as big/important/popular/etc one's doesn't depend on them, it should be fine IMO.
&gt; perhaps the fastest hash function in the world Looks like this goes at ~1GB/s/core (based on talk and README, though I don't know core speed). I recently became aware of [meowhash](https://mollyrocket.com/meowhash), which is cited at ~64GB/s/core on a 4.2gHz machine when in cache. That's explicitly not a cryptographic hash, however, and it strictly requires AES instructions. There's a [crate](https://crates.io/crates/meowhash) for it. I'm not particularly well versed in this domain. Would the cryptographic requirements fully account for that speed difference? Makes me wonder how fast the two would go if meowhash could be parallelized across cores like bao or if bao can gain anything from the meowhash implementation.
This just sounds like a poorly written Makefile. Maybe you should raise an issue on the newsboat repo? In this case, I think you could have added environment variables for `RUSTUP_HOME=/your/home/directory/.rustup`and `CARGO_HOME=/your/home/directory/.cargo` and that would have *probably* worked without installing a second copy of the toolchain.
&gt; Any particular examples? First things that come to my mind, you can't - * Generate a random number without 3rd party library * Cannot calculate permutations without 3rd party library * Parse terminal commands without 3rd party library * map/reduce in parallel ... * can't compute SHA1 or 2 hashes ... &gt; you don't really fight BC anymore As I mentioned in other thread, if need be, I'd be willing to get my hands dirty and implement graphs myself in D, or in C or C++. But with Rust? Probably not.
Agreed, there is no harm if it doesn't get excessive use. To add some more constructive criticism of that crate: &amp;#x200B; \- There is a \`Cargo.toml.orig\` in its source, most probably an oversight. \- The \`Cargo.toml\` contains a \`THIS FILE IS AUTOMATICALLY GENERATED BY CARGO\` comment section, which should probably be removed. \- It would be more general if it didn't panic on I/O errors, but instead returned a \`Result&lt;String, io::Error&gt;\` (which would, somewhat ironically, further cut down on amount of code in this crate). \- It could use \`io::stdout().flush()\` instead of using \`io::Write::flush\` explicitly. \- The use of \`return\` is not idiomatic. \- The comments are partly redundant with the code; let the code speak for itself, if possible (the only reasonable comment, aside from API docs, IMO, is "// Remove the newline character".
I meant that nVidia can't cripple the compute shaders (to help promote CUDA) without loosing Vulkan compliance, so using a Vulkan back-end may have better compatibility than OpenCL (every version of which I've used has had noticeable bugs).
I've clarified my post -- yes, I ran `make`, then `sudo make install`. `make` works, `sudo make install` doesn't. I never actually installed a second copy of rust in `/root`, by then I figured something must be off. Adding the two environment variables to `/root/.bashrc` allows root to run `cargo`, but `sudo cargo` gets me `sudo: cargo: command not found`. `sudo make install` still has the same problem. I'm unfamiliar with rust's build system, but if `sudo cargo` is something that *shouldn't* work, or shouldn't ever be needed, I can take this up with Newsboat.
Yeah, I mean cargo is just used to build the libraries/binaries that are needed. make install should literally just be copying those binary artifacts into some directory on the system, it shouldn't be running build commands for any language.
Hi, the following is quite inefficient: for i in 0..s.len() { if s.chars().nth(i).unwrap() != s2.chars().nth(i).unwrap() { diff += 1; } else { buffer += &amp;s.chars().nth(i).unwrap().to_string(); } if diff &gt; 1 { break; } } Rust Strings are UTF-8 and as such cannot be random-accessed. This means that `nth()` iterates through your String from the beginning until it reaches the desired position, each time you call `nth()`. Consider using the `zip()` method on `Iterator`s for things like this, e.g. for (cha, chb) in s.chars().zip(s2.chars()) { if cha != chb { diff += 1; } else { buffer.push(cha); } if diff &gt; 1 { break; } } This way, you're only iterating over each String once.
Oh thanks for the free code review. I hated the “nth” code as well. Very happy to hear there’s a more idiomatic way. I’m barely past Hello World in Rust, so I expect to be fairly ugly until I get deeper. AoC is forcing me to make some progress. And you make me believe the Rust community is really friendly!
Thanks for answering my stupid questions. I think I'll stick with nightly here. Having a `#[doc(hidden)]` enum variant named `_PatternMatchingOnThisMakesSanguiniusSad` is kind of amusing, but for some reason I don't think it's a good idea.
The `Cargo.toml.orig` is in fact the `Cargo.toml` which got published, and the one containing the `AUTOMATICALLY GENERATED BY CARGO` is a normalized version of the `Cargo.toml` such as it will works with older versions of Cargo, and path dependencies are renamed to the crates.io ones
Intuitively I would think that the chances of a successful collision attack are increased. In a normal hash function your output bytes are dependent on all N input bytes. In this scheme you would only need to find a collision for a leaf block. Any thoughts on this? 
Oh thanks for the free code review. I hated the “nth” code as well. Very happy to hear there’s a more idiomatic way. I’m barely past Hello World in Rust, so I expect to be fairly ugly until I get deeper. AoC is forcing me to make some progress. And you make me believe the Rust community is really friendly!
forgive me if this is a dumb question, but how does the pigeonhole principle apply to hash functions?
Thanks for the information! I didn't know that, as it is the first time I inspected a crate's source directly from crates.io; normally I'd inspect the VCS (git) repository.
Except what they *do* is called "key stretching". It's a mess lol.
&gt; Generate a random number without 3rd party library Should it be a part of the standard library though? If you grep the crates for rand crate dependency, you will find that most (almost all) of them only use rand as a dev-dependency for test. Being a separate crate though, rand is more functional and generic than e.g. Python's `random` module, or D's `std.random` (e.g. try generating a normal random variable in D). &gt; Cannot calculate permutations without 3rd party library It exists in nightly, but hasn't been stabilized as it's not considered universally useful enough. (so you'd have to use an external crate) &gt; map/reduce in parallel Doesn't sound like this should be a part of the standard library since it can be implemented in many different ways... There's very well-maintained crates like [rayon](https://github.com/rayon-rs/rayon) though that make this quite trivial. &gt; can't compute SHA1 or 2 hashes ... What about 20 other types of hashes then? Would you include that into the standard library as well? There's a well-maintained `crypto` crate that provides all of that if you need it. &gt; As I mentioned in another thread, if need be, I'd be willing to get my hands dirty and implement graphs myself in D, or in C or C++. But with Rust? Probably not. Graphs in Rust are a bit tricky if you've never done it before, but doable. If you can convince BC you're not doing anything stupid it's all good. E.g., you can use a [typed arena](https://docs.rs/typed-arena/1.4.1/typed_arena/) which simplifies things greatly, and you can easily have circular references etc.
Could you please point to some good example functions for password comparisons?
Thanks for the feedback! This is pretty much the first thing I've written in rust, and you've brought up some good points
If you have n bits that generate m spaces you can simply have m inputs. On the m+1 input you will have a collision because every m space is occupied. Is that clear enough? 
I get the reason to reply with this but unfortunately thats a circular answer
Right then, [I've filed a bug](https://github.com/newsboat/newsboat/issues/378). Thanks!
Well now you have to try HashSet with fnv. :)
I think you need to put `use self::cell` at the top of lib.rs
Never mind guys, solved it myself. Basically what I did was I imported (well, technically declared) cell top-level - I added "mod cell" as the first line of lib.rs. Then, within the tests mod, I put "use super::cell" as the first line. Worked perfectly. I also forgot to put an &amp; before the String::from("AABC") thing, and had a type mismatch between the from_string (which returned a Result) and the Grid type.... I fixed that using a match. Now it works.
Module hierarchy is expected to be reflected in the file system. That is, if you want a module `crate::waka::internal`, the internal module needs to be located at `@/src/waka/internal.rs` or `@/src/waka/internal/mod.rs`. The reason `mod internal` in `@/src/waka.rs` complains that it can't find the module is because you haven't provided it at one of these locations. The current version of Rust may also require that modules with children be introduced by a `module/mod.rs` file rather than a `module.rs` file. This restriction is intended to be lifted in the near (or current, did not test) future. To be more specific, the file structure you want for this is: src \ lib.rs \ main.rs \ waka \ mod.rs \ internal.rs The reason for this is to help you find files when you want to find them. If I see a path `your_crate::ooo::eee::ooo::ah::ah::ting::tang::walla::walla::bing::bang`, I don't want to have to open up 12 files to find where the final module is, instead I can just go directly to `@/src/ooo/eee/ooo/ah/ah/ting/tang/walla/walla/bing/bang.rs` since I don't have to check each file to see from where it imports the module. That said, if you want to break this default, #[path = "path/to/mod.rs"] mod foo;
What about [r2d2_sqlite](https://docs.rs/r2d2_sqlite), which integrates rusqlite and r2d2 together?
Ten minutes for 15 generations? This might use some optimizations...
Crazy idea, ((not even close to production ready)) You could generate code for a dynamic Rust library, compile it on-the-fly with rustc (or maybe mrustc?), then load it into your program with [libloading](https://docs.rs/libloading). Then use the functions exported from there, I guess? But it looks like for your needs (types) you really can't do that.
[scrypt](https://en.wikipedia.org/wiki/Scrypt) and [bcrypt](https://en.wikipedia.org/wiki/Bcrypt)
A 256-bit hash function can output one of 2^256 different hash values. If you feed in 2^256+1 different values, you necessarily get one of the outputs twice.
Here're mine: https://github.com/aldanor/advent-of-code I'm trying to make the solutions as fast as possible -- this means, in particular, not using hashsets and hashmaps (e.g. in day1/day2 problems) which makes it quite difficult. But it also means solving problems in a complete different way, which is fun on its own :) 
&gt;when i type mod waka or mod internal in lib.rs there is no problem, but when i try to use mod internal in waka.rs then it complains that the file isn't there. You need two things: the `mod internal` in `lib.rs` and a `use internal` in `waka.rs`. `mod` declares a module and `use` imports it. if you use `mod internal` in anything other than `lib.rs` it expects an `internal` module in a *subfolder* of `src`.
it's cool to see [other people](https://github.com/paholg/typenum/) doing [stuff](https://github.com/rodrimati1992/type_level) on the type level. Is there any particular reason that you do this?: Result: If&lt;Alive, Dead&gt; + Number, ... type Out = &lt;Result as If&lt;Alive, Dead&gt;&gt;::Out; ìnstead of this: Result: If&lt;Alive, Dead,Out=Out&gt; + Number, ... type Out=Out; Maybe it is performance,or differences in style?
The type level division operation I implemented might be a big bottleneck because it is not purely primitive recursive. However, I think type calculations like these are supposed to be slow, for instance this [c++ implementation of Game of Life](https://blog.mattbierner.com/stupid-template-tricks-the-life-comonadic/) has no realistic compilation time after 4 generations on a 11x11 array.
The UDP itself does not enforce any sort of connectivity, but the sender still may receive ICMP messages that inform client of “closed” port. It is possible that some other operation on the socket is emitting this error.
The reason not to run the compilation inside alpine was that AFAIK rustup is not currently supported there, so getting the latest stable and nightly version of rust running is non-trivial. But that is being worked on. Running 'apk update &amp;&amp; apk info rust' inside alpine:latest gives rust 1.26.2.
&gt; The bottom line is Apple created Metal specifically for their own financial benefit, not because it's somehow better than something like Vulkan in some technically important way. Exactly. Blender isn't a "big important application" to Apple because it doesn't make Apple money. So, there's no reason Apple should care about making a decision to support Blender. Ditching OpenGL, sooner or later, is entirely a move of short-term self-interest.
It's possible to do it even faster, without tracking seen items at all. Mine runs in 1ms :) https://github.com/aldanor/advent-of-code/blob/master/src/day01.rs#L10 
Damnit, it was something simple, as always. So, the send operation obviously causes the error, but it was not emitted until a subsequent call to read_from(). Thank you!
&gt;But you know, with great power comes... great SIGSEGVs! Thank you; you've encouraged my respect for `unsafe`. :D
Oh, duh. Sorry.
What you are mentioning is a really important concept when you write Traits with associated types. The first Method for binding Output type parameters has more drawbacks than the second. The big problem with the first method is that it becomes [unreadable](https://github.com/gtestault/primitive-recursive-functions/blob/a6699715e65f249fde596b98950ce8d3a017497b/src/main.rs#L250) very fast and you still need to write where clauses anyways. The compiler will also require a trait bound for every associated type projection and trait to be solved: [it results in a big mess in your where clause](https://github.com/gtestault/primitive-recursive-functions/blob/a6699715e65f249fde596b98950ce8d3a017497b/src/main.rs#L229). I stopped writing traits like the first one you mentioned after my division function. The second method is really clean but requires more [generic type parameters](https://github.com/gtestault/primitive-recursive-functions/blob/a6699715e65f249fde596b98950ce8d3a017497b/src/main.rs#L730) if you want to store results. For a big type level project I recommend only using the 2nd method for your own sanity.
Ah okay. Yeah, OpenCL on nVidia is pretty much useless...
I'm thinking about writing a proc macro to do something, but I wanna know if anybody's already implemented something like it. The idea is to make method forwarding less cumbersome by allowing you to annotate which fields in a struct should have their methods forwarded. Consider the following code: ```rust struct Lmao; impl Lmao { pub fn say_lmao(&amp;self) { println!("lmao"); } } struct Ayy { #[forward] lmao: Lmao } ``` The idea is that by adding a `#[forward]` attribute on a field, all of its *public* methods get forwarded by the parent struct. So in this example, the following code would be generated: ```rust impl Ayy { pub fn lmao(&amp;self) { self.lmao.say_lmao() } } ``` So does anybody know of a proc macro that already provides this kind of functionality?
Thanks for the answer. Rc&lt;RefCell&lt;_&gt;&gt; is something i tried, but i still had problems making it work like i want it. i will give the Vec&lt;Obj&gt; a try.
Thanks for the insight! I will try to implement it with a vec, since this looks like the easiest solution(i only need the tree for a short time and can then drop it immeaditaly)
Thanks, i already know about that one, thats also how i started out with linked lists in rust. altough this guide doesnt really touch my problem with shared mutability
Learned a lot by reading the different implementations. Surprised how many different takes on the same problem :) Posting mine as well: [https://github.com/cfsamson/advent-of-code-2018](https://github.com/cfsamson/advent-of-code-2018)
Is there anything in the Rust standard library like this? fn f&lt;T, F: FnOnce(&amp;mut T) -&gt; ()&gt;(value: T, change: F) -&gt; T { let mut copy = value; change(&amp;mut copy); copy } The goal is to be able to write something like let x = f(3, |x| { *x += 1 }); instead of let mut x = 3; x += 1; &amp;#x200B;
In all seriousness, do the same thing gentoo does (although bizarrely the .ebuild for newsboat doesn't mention Rust; is it a new dependency in the latest point release or maybe optional?): set $DESTDIR to some path to which you have write access, while also setting $prefix to the final install location. (Note that by "set" I mean "pass to every invocation of `make`".) Then run both `make` and `make install` without needing sudo since it will install under $DESTDIR/$prefix (e.g. $DESTDIR/usr/local/). Finally with appropriate `sudo`ed commands you can merge `$DESTDIR/*` to `/*` - of course, since you're not on gentoo you'll have to do that bit manually or find a tool to do it.
You seem to be lost. /r/politics/ &lt;--- is that way
xxHash is know quite widely and gets on a Core i5-3340M @2.7GHz over 13 GB/s. This is without multiple cores or fancy instructions. 
I suppose I could set the install location to `/home/me/.local/` and modify my `$PATH`, $LD_LIBRARY_PATH`, etc. (Or copy the resulting tree into `/`.) However, the build instructions say `make; sudo make install`, and I was getting errors about my Rust install, and I've never used Rust before, so I came here. Newsboat only recently acquired Rust code. As of [this summer](https://github.com/newsboat/newsboat/issues/89), it is [being re-written](https://github.com/newsboat/newsboat/issues/286).
I think that's true in a sense, and the paper I link to discusses how tree hashes based on random oracles aren't themselves random oracles. However in practice, a collision between two leaves would be a collision in BLAKE2, and if that's possible then we need a new hash function anyway.
I wrestled with writing "fastest cryptographic hash function" and then left it out cause it sounded too repetitive. You're right that it doesn't make much sense to compare them.
I'm creating a web application using Actix, and am to the point where I have an endpoint that successfully validates usernames and passwords. I now need to create a session for the user, but with so much (sometimes conflicting) information about there about JWTs, cookies, etc, I'm not sure what the most secure route to go is. Actix makes it super easy to do cookie session management via a CookieIdentity middleware - see this example: [https://github.com/actix/examples/blob/master/cookie-auth/src/main.rs](https://github.com/actix/examples/blob/master/cookie-auth/src/main.rs). But my question is, how secure is this? Is it secure enough to actually use in production?
If I'm interpreting it correctly, I think Blake2s is still faster in terms of CPU time. So in applications/systems where you can hash multiple things in parallel, the performance benefit of Bao kinda melts away. I wonder how Bao performs with smaller files. Somehow I imagine that spinning up 96 threads to hash a 100k file will not be optimal. Does it have some intelligence to limit its parallelism? Still, Bao probably has its uses somewhere and at least it certainly is neat demo of how to use Rust to make fast things. And those slices and encoding things are still interesting even if you do not care about the raw perf.
One of the core concepts used within TDD Is mocking and stubbing. Also known as test doubles. Mocking objects values functions and methods for the code your are not testing. There are several libraries for rust to checkout. Such as https://github.com/CodeSandwich/Mocktopus/blob/master/README.md The idea is that you mock the parts of code you are not testing to provide hard coded return values to test specific paths through your code under test. Hope this helps.
Damn. I even tried to look for a method that does what iterator::cycle does and couldn't find it! I resorted to putting my for loop inside a `loop {}`
[a comment I wrote some time ago, should be relevant](https://www.reddit.com/r/rust/comments/9em3gk/hey_rustaceans_got_an_easy_question_ask_here/e5ry1i3/)
Agreed, the font choice makes it all mush together a bit
&gt; Is this the right way of using arc and mutexes or am i over-killing something? If you mean using both `Arc` and `Mutex`, yes. You typically use them together. `Arc` specifies the strategy for allowing more than one owner and `Mutex` specifies the strategy for allowing more than one writer. (eg. Sometimes you want `Mutex` and sometimes you want `RwLock`... or some other synchronization primitive. Sometimes you want `Arc` and sometimes you want `Rc` (or some other shared-ownership primitive).) The alternative would be to have a type for every possible combination... and that'd be a mess. &gt; and also here the headers the vector is not mutable but im clearly mutating it in the function by pushing into it how is this possible? The term to look up is "interior mutability". Basically, `Arc&lt;Mutex&lt;T&gt;&gt;` lets you satisfy the borrow checker by handing out multiple non-mut references but then convert them to `&amp;mut`by using runtime checks to ensure that only one can be `&amp;mut` at once.
Stupid question which is probably not relevant for AOC but makes it a little more rustic. Can generators return iterators? That would save one vec on this simple example.
so there's a runtime reflection cost to this approach correct? Is there any way to avoid this since this is very common i don think every time to check things on runtime is performant
`MyStruct::from(...)`
Or not. 
I believe that this is necessary if using the function you are using, because it imposes the `'static` bound on the closure, which means it cannot borrow stack data. However, the docs (https://docs.rs/curl/0.5.0/curl/easy/struct.Easy.html#method.header_function) recommend using the `transfer` API which does not have this restriction. The following code which uses that API (which is pretty similar to the one you are using!) works: let mut crl = curl::easy::Easy::new(); let mut headers: Vec&lt;String&gt; = Vec::with_capacity(10); { crl.url("http://example.org").unwrap(); let mut transfer = crl.transfer(); transfer.header_function(|h| { headers.push(String::from_utf8_lossy(h).into_owned()); true }).unwrap(); transfer.perform().unwrap(); } println!("{:?}", headers); However, unless you have a special requirement to use `curl`, you should consider using the `reqwest` library which is based on the rust-native http implementation `hyper`. Using reqwest, your code becomes as simple as: let response = reqwest::get("http://example.org").unwrap(); println!("{:?}", response.headers());
The performance comparison is a bit subtle. Bao is comparable to BLAKE2bp and BLAKE2sp on a single thread. Those are more efficient than BLAKE2b/BLAKE2s, because having multiple inputs lets them skip a lot of shuffles. However, BLAKE2bp and BLAKE2sp have fixed parallelism degrees. So while they're able to take full advantage of AVX2 (by design), they won't be able to take advantage of AVX-512. When that becomes available, Bao will pull ahead of them. Bao uses Rayon for all of it's thread management. So if you have a long lived process, you'll only pay the cost of initializing the thread pool once. But if you're spinning up a process to hash the 100k file, that's definitely going to be a lot of extra overhead.
It would be fairly trivial to wrap a generator in an iterator, even though the concepts aren't identical. Rust uses stateful iterators, and I don't believe it makes any guarantees iterators support multiple passes except for certain types (like Vec), so wrapping a generator as an iterator would be trivial. 
`vec![0; n]` should be a call to `calloc` on a platform with "alloc zeroed memory" as an operation. If using `vec![0; n]` and reading past the end of the vector (UB! According to LLVM!) are different that's (probably) a bug, or LLVM misoptimizing and just happening to still give you the correct result.
Yes, there is a runtime overhead because, because `Mutex` needs to use a lock to keep track of whether some thread is using the data, and it will block until the data becomes available. This is good. If you don't have locks of some sort, you risk data races and other subtle concurrency errors. Rust chooses to have good defaults in order to protect you from that. If you really want a decreased runtime cost, there are a few approaches: - If you only need to access the data from one thread and aren't interested in concurrency, you can use `RefCell` instead of `Mutex`. - `Mutex` has only one type of borrowing, and that is non-shared mutable. There is an alternative concurrency primitive called [`RwLock`](https://doc.rust-lang.org/std/sync/struct.RwLock.html) that can be borrowed in two ways (you can have multiple read locks, or a single write lock). This introduces some additional overhead, but it means that you don't need to block if multiple threads are reading the data and none are writing. - The crate [`parking_lot`](https://github.com/Amanieu/parking_lot) provides faster implementations of many synchronization primitives (such as `Mutex` and `RwLock`) than those in the standard library. - You can bypass Rust's borrowing rules using unsafe raw pointers, but it's easy to cause ownership errors and/or data races, both of which are undefined behavior.
thats amazing. I was searching the http clients out there and i couldnt see the reqwest anywhere. also hyper seemed over complicated. I just want a simple blocking request. I have one question though, how can reqwest block return the data since hyper is asynchronous 
also i dont understand how the same function can be used with transfer without locking. Its still the same function. In the docs there is only one `header_function` and as far as i know you cannot overload functions in rust can you ? 
&gt;Running 'apk update &amp;&amp; apk info rust' inside alpine:latest gives rust 1.26.2. In fact rust version is tagged by alpine version... You can just use the '[edge](https://pkgs.alpinelinux.org/package/edge/community/x86_64/rust)' version to get rust 1.30.
&gt; I'm not, however, up to date enough to say which is "best". While it doesn't provide simple clear answer to "best", I think smhasher is pretty solid reference on current non-crypto hash functions: https://github.com/rurban/smhasher From there "t1ha" seems particularly well performing at the moment. There is also this article from few years back that highlights how difficult it is to give single good answer to "best hash function", as the performance is dependent on the data size and your platform(s) of choice: https://aras-p.info/blog/2016/08/09/More-Hash-Function-Tests/
Hyper returns a `Future`, that when continually polled (by calling the `poll` method on the future) will set off an HTTP request, and eventually (when the response is ready) return a response. The `poll` method returns the following [`Poll` enum](https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.10/futures/task/enum.Poll.html): pub enum Poll&lt;T&gt; { Ready(T), Pending, } It returns `Pending` until the data is ready, then it returns `Ready(T)` where T is a type like `hyper::Response` (the future trait is generic so that lot's of different libraries can use it). If you want to use this Future in an async way then you can pass this to a library like `tokio`, which will spawn a number of worker thread which essentially loop through all of the futures currently registered with it, calling poll on each and if it receives `Pending`, moving onto another future in the list to call poll on next. To make it synchronous, Request is doing something much simpler: just calling `poll` in a loop on the current thread until it gets a `Ready` response then breaking out of the loop and returning the data.
The blog's main text or the presentation's text?
You can't overload function in Rust, but it is a different function. In your original code you are calling the [`header_function`](https://docs.rs/curl/0.5.0/curl/easy/struct.Easy.html#method.header_function) method on the [`Easy`](https://docs.rs/curl/0.5.0/curl/easy/struct.Easy.html) struct: In my example, I am calling the ['transfer'](https://docs.rs/curl/0.5.0/curl/easy/struct.Easy.html#method.transfer) method on the [`Easy`](https://docs.rs/curl/0.5.0/curl/easy/struct.Easy.html) struct to obtain an instance of the [`Transfer`](https://docs.rs/curl/0.5.0/curl/easy/struct.Transfer.html) struct, and then calling the [`header_function`](https://docs.rs/curl/0.5.0/curl/easy/struct.Transfer.html#method.header_function) method on the [`Transfer`](https://docs.rs/curl/0.5.0/curl/easy/struct.Transfer.html) struct. 
Great progress! Just curious, what are your plans for nalgebra when const generics/type-level integers is complete?
Ok, got it. pub fn test() -&gt; Result&lt;Connection, Error&gt;{ let conn = Connection::connect("scott", "tiger", "//localhost/XE", &amp;[])?; return conn; }
I’m writing a wasm-bingen powered library and I’d like to write some unit tests in JavaScript / Node to verify everything is working as expected. Are there any crates out there that already do this that I can crib from? 
This repo has the code I'm using to solve the 2018 Advent of Code problems. I have tried to extensively comment them to be understandable by people who don't know much Rust (aka my IRL friends). I have also tried to make them as idiomatic as possible and optimize them as best as I can while not making them unclear. I figured some of you folks may like looking through how I've solved these problems and comparing them to your own approaches if you are doing AoC this year.
It looks like parking lot RwLock supports it with [read_recursive](https://docs.rs/lock_api/0.1.5/lock_api/struct.RwLock.html#impl-4) with the trade off that fairness is degraded (writers can starve).
Damn this is still an issue on macOS Mojava. 
Are you pewdiepie? No? Sorry I can't help then :) #\#JusticeForPeeDiePie
Isn't there a plan to integrated SPIR-V backend into llvm?
LOL that was actually really good ahaha
Ah yup, I'm aware of that! I'm hoping to find strategies to prevent the compiler from saying "this impl is not allowed because of coherence". Should I implement `Into&lt;MyStruct&gt; for &amp;T where T: Into&lt;MyStruct&gt;`? `Into MyStruct&lt;Option&lt;T&gt;&gt; where T: Into&lt;MyStruct&gt;`? Those all seem like good blanket impls, but maybe they will come back and bite me.
That's a pretty nice idea and I'm happy that you put so much work into documenting it so well. But at the same time I'm scared that people will use such hacks unattended in production: if you can't get someone to give you a stable REST API, how can you expect them to keep their HTML stable? 
Adding "scraping" somewhere could be useful for SEO.
Nowadays I think procedural macro derive is stable enough, and the only unstable feature this repo relying on is nll which is unrelated with API design. So I am sorry I cannot understand what is a stable REST API... Could you explain it more detailedly please?
I think you may be looking for [`spin`(https://github.com/mvdnes/spin-rs)]?
Gentle reminder ping :)
I'm on mobile, so I can't check. But i think this will work just fine without the *. The * is unwrapping the inner value from the Rc, defeating the purpose of using it im the first place.
Use `for d in &amp;*_d`. See http://xion.io/post/code/rust-for-loop.html.
without that the inner value is not being revealed so i cannot run the for loop on the vector 
That's a good idea, thx
so many little tricks. For about 3 days im just trying to fetch data from a api unmarshall it and show it in a loop this really shouldnt be this complicated. 
what you shared works for the small example above but in actual code i have vec of structs which has option fields and they cannot be even printed 
This is the sort of thing people do in business pretty frequently. The party providing the information has a legal obligation to provide it, but they don't have a legal obligation to make it easy to consume. You, a business person, need to consume that data automatically as soon as possible, so you write a scraper bot, that pings their site every five minutes to get the latest value. If it breaks, it breaks, and you fix it ASAP. Cost of doing business.
https://en.wikipedia.org/wiki/Representational_state_transfer "Stable" just means ensuring that a URL like `/v1/stories/5/1` will always produce content in the same format and any changes will be exposed by adding a `/v2/...` namespace.
Nice! I looked at miniserde recently and was hoping to see more experimentation around this area. You spend some time talking about object-safety, what does having it enable sval to do that serde cannot?
Wouldn't the latter need to panic or only hold if MyStruct is Default?
Well, that's a separate issue. I think you have to implement the Display or Debug traits to make your values printable.
they are implemented just when i try to unwrap it says cannot move out and the only way is to clone everything on the way which is a huge waste of memory. It seems rust really wastes tons of memory even the pointer types of rust like Cell ends up duplicating/cloning things
That sounds like the same type of problem. If you're getting errors about moving things, it probably means you should be using references (i.e. inserting `&amp;`s).
That's a good question! In general, using trait objects instead of generics means you can reduce your library's compile times and footprint on disk, at the cost of not having access to certain optimizations. &amp;#x200B; For structured logging, using trait objects for values is nice because there isn't necessarily a common structure between any two log statements, so being able to capture those values as anonymous trait objects can simplify the API around handling them.
the problem is the `unwrap` function it moves things 
Ah, you're right. Maybe try `.as_ref().unwrap()`?
that seems to be doing the trick but again another small trick. I just cant imagine how people are writing prod code with rust while everything seems so unclear and tricky
I think that's because you're still in the stage of fighting the borrow checker. I highly recommend reading [the rust book](https://doc.rust-lang.org/book/second-edition/index.html), particularly the sections on ownership and borrowing.
&gt; that seems to be doing the trick but again another small trick. I'm no Rust expert; I've only written about 30 lines of Rust code. I have read a lot of Rust blog posts, though... I think it will become a lot more intuitive once you gain an understanding of Rust's core ideas (here, move by default). Also, you should eagerly [consult the docs](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref). They're pretty good, and there's probably a method that makes whatever you need happen. &gt;I just cant imagine how people are writing prod code with rust while everything seems so unclear and tricky But all that trickiness happens at compile-time; it won't make your production deployment have problems (assuming you can get it to compile).
i have already finished the rust book and i think i understand the ownership in general but this does not explain why i cant simply read the data im not mutating in a single threaded context, and also i see a lot of people are commenting on my posts using words i havent even heard in the rust book.
I need blocking locks, while that crate only offers spinlocks
This subreddit is for the rust programming language.
Oh, ha, I'm pleased it's important to ping me. &amp;#x200B; It looks like I just added \`keycode 65 = space underscore space\` to \`\~/.Xmodmaprc\`, and I also added the line \`xmodmap \~/.Xmodmaprc\` to my \`\~/.xinitrc\`. I'm using Arch Linux, so if you have a different way you're handling startup scripts you might want to put it somewhere else. As long as xmodmap has been run at least once in your current session the setting should persist. &amp;#x200B;
I'd simplify it further and do "for d in dt.iter()"
I find that I often want to write the same method multiple times: once for a value type and once for a reference type. An example is something like this... ``` #[derive(Debug)] struct Point { pub x: f32, pub y: f32, pub z: f32, } impl Add&lt;Point&gt; for Point { type Output = Point; fn add(self, other: Point) -&gt; Point { Point { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z, } } } ``` The above code will let me write code like this... ``` let x = Point { x: 1.0, y: 0.0, z: 0.0 }; let y = Point { x: 0.0, y: 1.0, z: 0.0 }; // This works fine println!("x + y = {:?}", x + y); ``` But this will not compile... ``` let x_ref = &amp;x; let y_ref = &amp;y; println!("x_ref + y_ref = {:?}", x_ref + y_ref); ``` I think I need to separately implement `Add` for LHS `&amp;Point` and RHS `&amp;Point`. And then separately for LHS `Point` and RHS `&amp;Point`. And then again for `&amp;Point` and `Point`? You get the idea... 1. Is there an easy way to define a generic function that will do what I want? 2. If not, is there an easier high level way to structure my `Point` to make implementing it less repetitive?
You *can* read the data, you just can't move it. The deref operator (`*`) in your code is trying to *move* the data out of the Rc. What you're wanting is to iterate over the data. There are three basic kinds of for loops. - If you have a `Vec` of data, and you say `for x in my_vec`, the default is to move each element out of the `Vec` and into `x`.. which means you can't use `my_vec` anymore. - If you say `for x in &amp;my_vec`, it will take a temporary reference to each element in the `Vec`, so you can still use the `Vec` afterwords. - If you wanted to mutate each element of the `Vec`, you could do `for x in &amp;mut my_vec` to grab a temporary mutable reference to each element. Since you seem to have something like an `Rc&lt;Vec&lt;T&gt;&gt;`, you can't move values out of it. `for x in my_rc_vec` is not allowed because `my_rc_vec` is an `Rc&lt;_&gt;`, and Rust doesn't do many magical things for you. So we need to deref it to get to that inner `Vec`, which we do with `*`. But, that would move it out, so we need to let Rust know that we just want a reference to the inner content, so `&amp;*`. A less confusing way to handle this would be to say `for x in my_rc_vec.iter()`, since Rust will handle the derefer and reborrowing for you with method calls on an object.
I mainly write go code. In go as long as you make sure every pointer is not nil and you use channels or mutexes to communicate data you are good to go. And it is not really that hard to check those. This simple api call and unmarshalling that took over 3 days would be done in 10 minutes in go. So rust doesnt really make things easier the memory safety is a thing but it isnt that difficult to be carefull about that. I am still trying to understand is there a real value to invest time in rust and everytime i try to write rust i end up being frustrated. even nodejs isnt this tiresome. 
&gt; (P.S.: EPUB format is actually quite capable of presenting good typography, because books published by O'Reilly themselves look good on Safari Books Online.) ePub is a restricted subset of HTML, plus any supporting files, packed up inside a Zip file. Any font with a suitable license can be bundled up inside it, just like with PDF.
&gt; even nodejs isnt this tiresome Of course it's not, it's not nearly as strict as Rust is. The Rust compiler is doing a _lot_ of checks at compile time that other languages wouldn't check at all, or check at runtime. It's an enormous benefit to writing stable, safe, and fast code, but the tradeoff is a higher upfront cognitive cost. Rust code is slower to write compared to most languages, that's just how it is. But it's possible to internalize the concepts with practice, get good at Rust, and start cranking out programs as fast as you would in other languages.
I think I understand what are you talking about. I never take stability of HTML into consideration because I use this crate only for scraper. HTML cannot be a normal serialization form in API. I parse HTML just because I don't have a normal API to do my job.
Thanks! The plan will be to replace typenum and `GenericArray` by type-level integers and arrays.
Presumably because it wants the location as "4-byte index" rather than a pointer. Keep in mind that `Float32Array` comes from JavaScript, which doesn't *have* pointers, but *does* have arrays.
I am not sure in this specific case but a f32 has 4 bytes. Maybe the pointer points to bytes. So to make it a pointer to something that has 32 bit it needs to be divided by 4.
You're looking for /r/playrust, about the game. This subreddit is about the programming language Rust, which runs just fine on a MacBook Pro.
There are even operating systems that are based on browser primitives (e.g. IBOS), rather than vice versa.
I’m new to reddit and I didn’t even realise, thankyou so much 
Looks like a bad conversion to epub. Epub should easily be able to properly display monospaced code blocks.
Thanks! I'm still very new to Rust, I didn't realise at first I was moving ownership of `value`. I'm not sure I want `Copy` here though because I'd like to use it for vectors as well, so maybe the `Clone` trait is more suitable? That seems to behave the way I want it to, although it will make an unnecessary clone if I don't use that value elsewhere, so I could keep both versions around. Would that be a sensible thing to do? I don't really understand how your `tap` function works – how can it mutate `self` if you don't declare a mutable user anywhere?
/u/Fateschoice /u/kodemizer /u/poluserthrowaway I got really motivated, and managed to get some stuff working. It should be a great starting point to try it all out, and get more familiar with the project: https://github.com/dpc/crev/issues/37
Awesome! I needed a crate just like this a few days ago but couldn't find anything I liked. Great job.
That's possible, but here it would have to be a generic `impl IntoUrl for T: AsRef&lt;str&gt;`, and if there are other generic impls you'd get a conflict. Not sure if it's the case...
Would this be able to be a replacement for pup? Seems like it. I've been looking for a rusty version of that utility. Just needs a CLI interface. 
Congrats on your crate! But also check out text_io to see how advanced Rust solves this problem. 
I'd say the point of `Rc` is that you can allow something to have *no* owners: you can take references to a value despite that value not being owned in any specific location. Instead, the value is stored on the heap, and once there are no more `Rc` objects pointing to it, the value is dropped and deallocated. Meanwhile, the `Rc` provides read access via shared references (Rust will automatically convert an `&amp;Rc&lt;T&gt;` to an `&amp;T` in many contexts because `Rc` implements the magic trait `Deref&lt;Target=T&gt;`). Thus, `Rc` is useful when you don't *know* statically what the final owner of the data will be. As a general rule, the dereference operator `*` can't be used to turn an `&amp;T` into a 
&gt;The pattern of wrapping a dyn Trait in a concrete struct is one I've found myself reaching for a lot while working with trait objects recently. That’s Non Virtual Interface pattern from C++! I’ve been meaning to write a blog post about it in Rust for about a year =/
Well, it easily has enough unique values to index every binary file every created - but that doesn't mean there won't be collisions. It just means that there are enough values that it is theoretically possible to avoid collisions. And if the hash function is 'good' then the probability of a collision is extremely low. One thing that interests me a bit though is that we've come to really rely on our hash functions. The hash functions are assumed to be so reliable that we use them for data de-duplication. (ie. if two files have the same hash, we assume they're the same file and so we only store the data once). This means that if we are unlucky enough for a collision to occur, there could be some pretty ugly side effects. ... Meanwhile, it is very difficult to prove that the hash functions really are as reliable as we need them to be. (ie. although there are plenty of different possible hash values, it's difficult to prove that there won't be some nasty correlations for the data we're feeding in.)
Neat! It probably exists under other names in other languages too. I'll read that post :)
I'd say the point of `Rc` is that you can allow something to have *no* owners: you can take references to a value despite that value not being owned in any specific location. Instead, the value is stored on the heap, and once there are no more `Rc` objects pointing to it, the value is dropped and deallocated. Meanwhile, the `Rc` provides read access via shared references (Rust will automatically convert an `&amp;Rc&lt;T&gt;` to an `&amp;T` in many contexts because `Rc` implements the magic trait `Deref&lt;Target=T&gt;` - this is called "deref coercion"). Thus, `Rc` is useful when you don't *know* statically what the final owner of the data will be. As a general rule, the dereference operator `*` can't be used to turn an `&amp;T` into a `T`. After all, an `&amp;T` is a *shared* reference. If you could simply dereference this and then mutate it, you would be violating Rust's shared-NAND-mutable rule. In theory, Rust could track where every dereferenced value comes from and error if you try to mutate one that came from a shared reference, but this would require non-local reasoning about ownership, something which the language tries to avoid. In general, Rust won't allow you to use the `*` operator unless the following is true: - `T` implements the magical trait `Copy`, which signals that the type can be safely shallow-copied on the stack. The most important types that aren't `Copy` are mutable pointers such as `Box&lt;T&gt;` and `&amp;mut T` - again, copying would allow them to be shared, violating shared-NAND-mutable. - You dirrectly reborrow the result (e.g. `&amp;*_dt`). Normally, this wouldn't be useful, but in this case it is as the use of `*` triggers the deref coercion that I mentioned above. - The result is implicitly reborrowed anyway (e.g. if you invoke a method on the result or `match` on it). If you really need to convert a `&amp;T` to a `T` for `T: !Copy`, it might be because you want to deep copy the value. If this is the case, you can use `.clone()` perform a deep copy as long as `T` implements the trait `Clone`. Rust won't do this automatically because deep copying is potentially expensive and Rust tries not to conceal expensive operations. In this case, however, you shouldn't deep copy. Instead, just do `_d.iter()`. Calling a method also triggers deref coercion, which means that converting the `Rc` to a reference is done automatically. Notice that `iter()` takes the vector by reference, meaning you don't need to dereference to apply it. Keep in mind that if you do this, the elements you're iterating over will be references as well - you'll be dealing with `&amp;&amp;str`. I know this all seems complicated at first glance. But as you continue learning Rust, you'll get a better understanding for the underlying logic of these decisions and how the pieces fit together. I wish you luck on your journey, and I hope this helps!
You could do that with macros - define `impl&lt;'a, 'b&gt; Add&lt;&amp;'a Point&gt; for &amp;'b Point { ... }`, and generate other impls with a macro that would forward to the handwritten one. [Here's an example.](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=c40455b729d92950cc3b74650cef78ca)
Rust newbie here and this comment is sort of tangential, but why is no-std a thing I see around? Is there something wrong with using the standard library?
Not at all! The standard library is great, but it currently makes some assumptions about the target platform, like that it supports dynamic memory allocation, can spawn threads and things like that. That's not true of every platform Rust can target, so libraries that don't need the standard library can avoid depending on it, and can then be used on platforms that just can't. Even in 'no-std' libraries you usually depend on a much slimmer standard library called 'core' that still has a lot of useful things in it.
You forgot "cloud computing" and "machine learning"
Rust is harder to get started with. Which is a good thing. Going from Java and C to C++, I was quickly able to write shitty code. The tooling sucks though. Similarly, when starting with Node, it is easy to write wrong asynchronous code without knowing what you are doing. With rust, I would guide anyone to type in, letter for letter, the code examples from the Rust book until they can grok it. Than you can be quite certain that no memory related bugs occur.
Why do you need \`Point + Point\`? There's no need for you to take ownership here, and as a caller you could just as well write \`&amp;Point + &amp;Point\` if you're owning the points anyways. &amp;#x200B;
I'm pretty sure the "generators" in cargo-aoc aren't actually generators, but are just called that. The attribute is only used to point the tool at what function is supposed to parse the input, so "parser" or something would be a more apt name. I haven't looked through the source code though, so maybe I'm completely off the mark here.
&gt;use such hacks unattended in production I read a really dumb medium post a while back saying you should store data in hidden HTML files, download it using AJAX, scrape the data using javascript DOM, and present the data&amp;mdash;presumably in a different manner from the original HTML&amp;mdash;onto the page. Wat.
&gt; Would it be possible to export advanced concepts (Strings, Traits, lifetimes etc.) by defining a binary layout that only gets applied when the developer actively enables it? The problem is that you can't have a `String` with a fixed ABI layout, and then another string that keeps evolving. What happens when you use those in the same program and try to interoperate between them?
I'm at work atm, so I can't check the error; I'll do once I get home. There seems to be a bit of confusion on what `?` does. Given a `foo: Result&lt;A, B&gt;`, the type of `foo?` is not `Result` anymore, it's simply `A` (if `foo` is `Ok`, otherwise the whole enclosing function returns). So the type of `conn` is just `Connection`, so you either need to drop the `?` (so it remains a `Result`), or wrap it in `Ok` when you return it.
I'm so glad I bought this book before they stopped doing direct ebook sales. It really bums me out because I don't want a subscription service and I don't want paper books (gimme PDF) and O'Reilly just doesn't give me what I want anymore. But at least I got this book before that transition happened.
Haven't pushed anything yet, but here's where I will put my solutions: https://github.com/CornedBee/AdventOfCode2018
More concretely some of Rusts big target areas of usage have no\_std environments: WebAssembly and embedded devices.
Thanks. I'm saving this in peace now. 
Thanks, I'm going to give this a try when I'm back to using rust again... 
This could really use some explanation.
Do you think a Turing complete bitcoin interesting to you. Or you think even bitcoin make no sense to you?
I remembered `cycle` and `insert -&gt; bool`, but I'm not fond of putting any kind of side effect into `find` predicates. Can't link my code, haven't pushed to GitHub yet.
So excited that this is supported now! Especially because it gives the opportunity for writing lambdas with minimal startup overhead and strong typing (I suppose go was an option before but I never really liked go)
&gt; perhaps If its written in rust then you don't have to use perhaps. Just ask alacritty ;)
Because webassembly doesn't have 8bit values. in the same way that your computer doesn't have 4bit addressable values https://github.com/WebAssembly/design/blob/master/Semantics.md The smallest addressable value is 4 bytes (32 bits) in the same way the smallest addressable value for x86 is 1byte (8 bits). i.e. if you would use "normal" pointers. the last two bits would always be 00.
Basically, `split` is an iterator that can only move in one direction - forward. To reverse an arbitrary iterator, `rev` requires that iterator can move in both directions, so it can move it to the end and then start stepping back. If you want to do something like this, you can `collect()` it to a vector (or some other data structure) and then reverse that like [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=741c8c4c82db25800a6aed73b2781cf5).
Blog text
If you want to do that, what you need is [str::rsplit](https://doc.rust-lang.org/std/primitive.str.html#method.rsplit)
Hmmm sure. The main idea is this: Denote the number of elements by n, array of cumulative sums by s[i] and the scalar sum of all elements by S (=s[n]). It’s not hard to see that if you looped back to the first element k times and then progressed i steps further, the current value of the sum will be = s[i] + S * k. In order for the problem clause to be true, there has to exist m and j such that s[i] + S * k = s[j] + S * m. Equivalently, (s[i] - s[j]) mod S = 0. We can go through all pairs and (i, j) and check this. Finally, out of all pairs for which this holds true we want to find the relevant k and m and this the number of steps needed to encounter this number: n * k + i and n * m + j. What’s left is choosing the pair that will be encountered first. No hashsets.
To add, more and more stuff is being move from std to core, so working without std isn't working without a standard library, just a much smaller one called core. 
&gt; The smallest addressable value is 4 bytes (32 bits) in the same way the smallest addressable value for x86 is 1byte (8 bits). I'm getting started with the beta of the webassembly rust book, and they have us write a 2d array in the linear memory. They multiply by 4 the position in the array to access the i32 value in a cell. So isn't it adressed with 1 byte? What do I misunderstand?
You can answer this from the documentation. [`split&lt;'a, P&gt;`](https://doc.rust-lang.org/std/primitive.str.html#method.split) returns a [`Split&lt;'a, P&gt;`](https://doc.rust-lang.org/std/str/struct.Split.html). `P` must implement [`Pattern`](https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html). There are implementations for `char`, `&amp;str`, and other types. In this case, `"-"` is a `&amp;str`, so that's the relevant implementation of `Pattern`. You're trying to call [`Iterator::rev`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rev). [`Split` implements `Iterator`](https://doc.rust-lang.org/std/str/struct.Split.html#impl-Iterator) so long as `P: Pattern`. This is already a requirement of calling `split`, so in practice this is always true. `rev` also requires [`DoubleEndedIterator`](https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html), which is described by the documentation: &gt; An iterator able to yield elements from both ends. `Split` [implements `DoubleEndedIterator`](https://doc.rust-lang.org/std/str/struct.Split.html#impl-DoubleEndedIterator) where `P`'s implementation of `Pattern` has an associated `Searcher` type that implements [`DoubleEndedSearcher`](https://doc.rust-lang.org/std/str/pattern/trait.DoubleEndedSearcher.html). Again, this is described by the documentation: &gt; A marker trait to express that a `ReverseSearcher` can be used for a `DoubleEndedIterator` implementation. Whilst `Seacher` is described by the `Pattern` documentation: &gt; The \[`Pattern`\] trait itself acts as a builder for an associated `Searcher` type, which does the actual work of finding occurrences of the pattern in a string. We're interested in the `Pattern` implementation for `&amp;str`, which has a `Searcher` type of [`StrSearcher`](https://doc.rust-lang.org/std/str/pattern/struct.StrSearcher.html). `StrSearcher` does not implement `DoubleEndedSearcher`. Thus, you can't call `rev`. As for why it doesn't, this is *explicitly noted* in the documentation of `DoubleEndedSearcher`: &gt; `(&amp;str)::Searcher` is not a `DoubleEndedSearcher` because the pattern `"aa"` in the haystack `"aaa"` matches as either `"[aa]a"` or `"a[aa]"`, depending from which side it is searched.
I have to read this when I'm more awake, but thank you for writing it up.
&gt; few Not too few: Roslyn, TypeScript and Kotlin are examples which do both command-line and IDE compilation using a single code base. Dart is kind-of interesting in this respect, because they have two front ends developed by the same team, but their IDE front-end is awesome :) Note that this is also not about incremental compilation per se (rustc is incremental, but batch compiler), but more about on-demand compilation throughout the compiler's stack (rustc is on-demand internally, but this is not exposed to RLS).
[removed]
[removed]
If, on the vague offchance, this is for a solution to day01 of advent of code, note that `.parse()` is happy with `+` and `-` prefixes to numbers (I didn't know this until I tried it!), so you can just do something like: let numbers: Vec&lt;i64&gt; = input_string.lines().map(|l| l.parse().unwrap()) To get a list of positive and negative numbers from the input, and go from there :)
&gt; The hash functions are assumed to be so reliable that we use them for data de-duplication I thought most filesystems just use this as a pointer to winnow the # of permutations necessary? ie: all equal files have the same hash (but crucially, maybe different filenames and other metadata), but not all different files have different hashes.
At least in my browser (not phone) the blog body text leading is really large and irregular, to the point where I suspect something is broken with the font.
Absolutely! I tried re-writing several workloads which I had previously implemented in .NET Core (C#) and JavaScript (Node) in Rust and the result was that both start-up time and overall memory usage was significantly lower than the originals. This translates directly into lower overall cost for the solution which alone was enough to consider porting existing lambdas to Rust.
Excellent explanation. Let's take it one step further: It seems that `DoubleEndedSearcher` _is_ implemented for `char`, which does not cause the mentioned ambiguity. In this case, we can replace the pattern with a `char`: `"aa-bb".split('-').rev()` ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=c6cba1082276eb92d9739ba36fae6b5b))
Thanks! Are there currently builds of nightly rust as well available for alpine?
Having a technical library in digital format is great in terms of Ctrl+F goodness and the such, but I do worry how folk ensure their monitors are the correct height. My library has been offering adjustable monitor height for decades.
Ok, I'll give that a shot tomorrow.
My first shot at a code walkthrough type of post. I'd love feedback, and am looking forward to writing more 😄
I'm rooting for bitcoin et all to be made illegal on the western world &amp; japan and china. Not only it's a vehicle for illegal stuff, bitcoin mining is a menace for the world. Yes, less than CO2 from cars, but i don't care, the idea is terrible by itself, as proven by bitcoin farms.
You still are able to buy O’Reilly DRM free books in other stores (e.g. https://play.google.com/store/books/details/Programming_Rust_Fast_Safe_Systems_Development)
How stable is it with regards to badly formatted HTML? 
Thanks! I didn't expect it to get the type from the struct. 
It is and thanks! :D
Possibly dumb question but why no deserialization, and why doesn’t that make this kind of a non-starter? 
It relies on crate scraper which bases on servo/cssparser, servo/html5ever and servo selectors. I think its stability depends on stability of servo.
Is it converting from a raw pointer to an array index?
Yeah, awsome explanation. Very helful. Thank you so much.
Thanks, I almost tried it, I thought it will split by the last occurrence.
Thanks, thats exactly what I am doing, a vec.
Having now looked at it for a while, i've also become confused. I think its perfectly reasonable to make an issue requesting the file to be updated with a link to some explanation. 
Very informative, thank you so much!
Okay , i found an answer. The wasm_bindgen::memory + buffer returns a pointer to this wasm instance. The instance includes a lot. Also the 'static' vertices value. The Float32Array::new(&amp;memory_buffer) interprets the whole instance as f32's. vertices.as_ptr() returns the start of the array as if the whole instance is a ByteArray. i.e. its 4 times higher then the equivalent index in the Float32Array. 
And it should all be "for the Internet of Things"
Maybe some "artificial intelligence" for good measure
Any reason why you went directly with structs instead of using enums for most of your code? Just curious
It's for when you're targeting toasters, light bulbs, ... I feel silly writing this but I've seen smart toasters and smart light bulbs.
This blog post highlights how ridiculously easy it is to write a lambda function in rust. I'm looking forward to a streamlined way incorporate API gateway -- something like SAM or serverless framework.
Except for “extern crate test” IIRC.
If only I could have this 1 year ago... Nice work :)
I'm curious about the shortcomings you mention about serde and `no_std`. AFAICT, serde does work with no_std -- it's just some serializers that don't, and that's usually solvable (currently working on [fixing this for cbor](https://github.com/pyfisch/cbor/issues/79)).
Do you mean empty enums? (like \`enum Void{}\` )
No more like `enum CellStatus{ dead, alive}`
Thanks, but I have just found out that the thing I wanna invent can't be easily added via this enum it seems.
Even sillier is that some of those actually can run the std library just fine because they are embedded linux...
Because enum variants aren't types,you can't implement traits for them,one example is `impl Number for Dead`.
Yeah but all that is is a repr function which u could use a match on for dead =&gt; 0, Alive=&gt; 1 Like I said - was just curious 😊 good job
What about the webview bindings and yaw. With does two you can make desktop GUI just using Rust and wasm and maybe some CSS to make it look pretty :)
toast : user access denied. 
Yeah but all that is is a repr function which u could use a match on for dead =&gt; 0, Alive=&gt; 1 Like I said - was just curious 😊 
You know the human race is screwed when the first the thing they use safe language + open CPU for is yet another cryptocurrency.
\`repr\` doesn't take any parameters,there is nothing to match on.
Yeah I just want to know why type-level /what benefits to it
You want /r/playrust
So it should be as robust as Firefox is. The Rust ecosystem is so wonderful 😀
Maybe? [If I'm understanding the docs correctly](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Float32Array.html#method.subarray), isn't `.subarray()` reading this slice and copying it into the Float32Array? If it needs to read a slice of memory, wouldn't it want the original address to the slice?
my understanding is they are lower quality than the ones that were in the O'Reilly store, but maybe that changed at some point?
You can make a single function called scan which is generic on return type (instead of next_i32, nect_f64). Kind of like: https://docs.rs/input-stream/0.3.0/src/input_stream/lib.rs.html#206-232 (where you would return the type directly instead of a result). Should remove a per of the boilerplate. That crate i Just linked is made by me for the exact reasons you made your Scan strruct, so you might find other useful things in the code as well.
https://github.com/TeXitoi/structopt/blob/master/examples/enum_in_args.rs
&gt; If it needs to read a slice of memory, wouldn't it want the original address to the slice? If it wanted the address, it could just ask for it. That it *works* when you pass the address divided by four pretty strongly suggests that it's based on indices, not addresses. Again, this is for JS. JS doesn't *have* a unified, global address space. It's probably just treating wasm memory as a big array of "stuff", and you're indexing into *that*.
My company is looking to book a Rust training for our developers, but I'm having trouble getting recommendations for a specific training. So this thread is of interest to me! I'm looking for an existing training (not paying to develop one, sorry!). The target audience is experienced C++ developers with no rust exposure. We're looking for a trainer that can handle 10-20 students and can travel to NYC to provide the training (we can handle all the logistics).
`RefCell` allows inner mutability for single-thread environment, `Rc` allows shared references, so together they allow for shared mutability. `Arc&lt;Mutex&lt;T&gt;&gt;` in case of multi-thread environments (or `RwLock`) Just be careful that memory can be leaked with `Rc` cycles in safe code (https://doc.rust-lang.org/nomicon/leaking.html#rc)
It sounds like C:\temp is just a directory the video author uses for all his, well, "temporary" stuff. It's fine if you just create it and proceed with the tutorial. Note: I haven't watched the whole video, just the few seconds at the timestamp you mentioned. If that directory was used earlier in the video, e.g. to download stuff into, and you believe that this directory *should* exist, check that you are in the correct path. Maybe you accidentally created it not on the C:\ root, but somewhere in your user directory.
On ereaders, at least on my Kobo, pdf are difficult to navigate and they don't scale well. Epub files work really on it, I can also switch font (using [OpenDyslexic](https://www.opendyslexic.org/blogs/tag/kobo/) for example). Unfortunately graphic don't work as well. Given that, I download all my ebooks in epub, which I read both on my ereader and on my desktop.
In Rust, an itera*ble* implements `IntoIterator` which is consuming (the `into` prefix usually indicates that) meaning your structure is moved to create the iterator. Here that would move the vector out of the pointer, which is obviously not allowable (you can only borrow from an Rc unless you swap the old value and a new one). So you need to create a borrowing (non-moving) iterator, which can be done either explicitly (by invoking [the `iter()` method](https://doc.rust-lang.org/std/primitive.slice.html#method.iter)) or more implicitly (by getting a reference to a Vec, `IntoIterator` is implemented separately for `&amp;Vec`, `&amp;mut Vec` and `Vec` creating respectively a borrowing, a mutation and a moving iterator).
I got that, my confusion was thinking the data was being copied into the array. During my drive to work I realized that the data is actually already in there. Am I understanding this correctly?
Makes sense, so the data is actually already in the Float32Array because it's our program's memory, correct? We're just indexing where it is.
I *think* so, but I don't have any direct experience with this.
I... like the current one better actually. I mean, purely visually your design *looks* better than the current design. But functionally, the current design ([here's how it looks to me on Windows](https://i.snag.gy/GZpqKX.jpg)) is a lot better. It's to the point, displays only the information I need to get Rust installed. In case it doesn't work, it points to IRC's #rust-beginners, and (in small text) in case the OS detection is incorrect it links to the instructions for other OSs. In your design, there's a ton of extra, frankly useless information: The rustup version number, links to the book, to IRC (just a vague "IRC" link, not the "if you need help go to #rust-beginners"). Your design also displays the information of how to install it on all operating sytems rather than only the detected one, and for the detected one it shows the information *twice*. Don't get me wrong, your design isn't bad. But in comparison to the current one it's worse, because the current one is very good (props to whoever made it). The goal of rustup is to be a site where you spend as little time as possible on. It doesn't have to look good. Black text on a white background is just fine. In your design, the "run the following command:" text is *tiny*, and it's the entire point of the site!
I skimmed through your code, it looks pretty cool! One suggestion is to start using [Clippy](https://github.com/rust-lang/rust-clippy). It will warn you about a bunch of common things like unneeded return statements. You can use it from the cli or integrate it with whatever editor you are using so it will highlight offending lines. I found it super helpful when learning Rust idioms, and still helpful now. Another thing it will point out is when you have a really long function. Some of your tests are very long, but broken into sections by comments. I would suggest splitting these into multiple tests with the names of the comments splitting them. Also, I would suggest naming your tests more simply, like instead of `stv_wikipedia_test` something like `wikipedia`, since when you run your tests it will say `test stv::tests::stv_wikipedia_test` which is just repetitive.
That already exists for three years...
Thanks! I got it up and running perfectly at [https://github.com/daxhuiberts/advent-of-code-2018](https://github.com/daxhuiberts/advent-of-code-2018)
Yes. This is in the context of a proc macro, so if it panics, it will be at compile time, which is ok
It looks like it was written to make it easy to save things into logs. When writing to logs, you only need to serialize to the log, you don't need to bring the logs back into Rust-land.
This comment is more helpful than any professor or tutor I have seen. Well done. 
`md \temp`
Fuck you both guys. Respect the subreddit
WOW! Seriously beautiful progress bars! Looking forward to using this in my next CLI app.
Didn't know about this. This seems to be the best option.
Thanks. Seems to work fine. Is it normal though that I need to define clap as a dependency too even though structopt pulls it in automatically? I get an error about the crate not being found when only listing structopt.
Thanks for the review! This is still very much a "work in progress" where I'm still emitting a TON of warnings. I think I need a kick-in-the-butt to finish up all the "in-progress" code instead of working on new features! Thanks for the advice about organizing tests. I'll switch them around and separate them out into their own functions. Once I actually get the code into a "reviewable" state (no warnings and clippyfied), would you be willing to review a second time? 
&gt; the tests succeed most of the time and fail every now and then &gt; For fun, I tried running the unit tests but limiting the number of threads used to 1 (so that tests are guaranteed to run in series) and in this case the tests also seem to always work. This usually means there is some sort of global state that is depended on in tests. This global state should be synchronized somehow or simply not used in a concurrent manner.
Absolutely! I can give a more thorough review then. Feel free to PM me if you any questions too.
Thank you! I appreciate it. 
I've got a rather large lot of $life problems to keep me busy this week. Nonetheless I'll try to do TWiR, some clippy work and perhaps even a Rust PR.
Do you have sample code? Consider reporting a bug on the issue tracker.
You shouldn't have to. Can you post the exact error? 
https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=1d9c270e8eab7b801852fb4c8c59df4c
Just starting out in Rust, because it looks promising and pretty cewl. Thinking of making a very simple game with basic principles implemented, just to get a hold of the syntax.
you're not implementing it for a built-in. You're implementing it for a type that you literally just defined.
``` Can't find crate for clap ``` On mobile but the highlighted line is number 4 in your example which matches line 4 in my code. My Cargo.toml has structopt = "0.2.13" under [dependencies]
If I have time I'll be working on adding diffing to my LIS crate, suitable for virtual DOMs.
Oh yeah, you do need clap for the enum macro, and you need to explicitly list it as a dependency if you want to access it in your crate. 
For desktop apps, using a DOM tree and running a WASM compiler while streaming data over localhost seems a bit wasteful in terms of resources to me. I'm quite opposed to the Electron trend, though to be fair webview seems quite a bit better than Electron.
I feel like this could be really cool if you made it act like parse or collect where you write. let x: i32 = input... And it just worked.
People in this thread might enjoy learning about \[homotopy type theory\]([https://en.wikipedia.org/wiki/Homotopy\_type\_theory](https://en.wikipedia.org/wiki/Homotopy_type_theory)).
I think that with a modern compiler, you can `use structopt::clap::arg_enum` and remove the direct clap dependency in your Cargo.toml.
Aren't you going to parse the logs? Otherwise why do structured logging?
Playing with integrating [imgui-rs](https://github.com/Gekkio/imgui-rs) into my game which uses my game framework, [midgar](https://github.com/mystal/midgar-engine). I was able to do a really quick pass by using the `imgui-glium-renderer` and [imgui-sdl2](https://github.com/michaelfairley/rust-imgui-sdl2) crates! Now to actually make some useful debug panels :)
Not sure I agree, with NVI the C++ class can still have virtual functions, they're just private. The main difference means that with NVI the C++ class can still have direct access to its fields, whereas here the fields are hidden by the trait and only accessible through getters.
To expand further, I think this has something to do with multi-dispatch. Here's one of [Niko's blogs](http://smallcultfollowing.com/babysteps/blog/2014/09/30/multi-and-conditional-dispatch-in-traits/) discussing the issue.
I figured the log parsing would probably be in not-rust. It's a simple enough task for Python or any scripting language.
Thank you again. This works fine now.
I'm working on a todo list for the command line, mostly as a way to get back into rust: https://github.com/abhijat/ya2d2 It is quite usable now for me and I've been using it myself daily, although there's a lot more I want to add such as categories, better tab complete etc. As an aside I feel like this time my experience developing rust is much more pleasant mainly because the intellij plugin is a lot richer in features and performance. 
Type level programming is about programming logic into the type system of a language. This allows you to execute code during compile-time instead of executing it at runtime. In my code all the `repr` functions are executed at runtime but they simply transform the end result of all the type level operations that have been executed at compile-time. A Game of Life Implementation on the type system is completely useless, it's just a gimmick. Something usefull you can do at the type level is providing formal proofs in Types. [This Red Black Tree implementation](https://fstaals.net/RedBlackTree.html) for instance proves that every value that is annotated with the ```RedBlackTree``` type is a balanced Red Black Tree where every operation takes ```O(log n)``` time. 
&gt; This means that if we are unlucky enough for a collision to occur, there could be some pretty ugly side effects. I'm not saying this will never happen...but if it does happen it will make national news and you might be able to get an honorary doctorate out of it :) More realistically, I do think we need to plan for this scenario: Someday in the future another well-funded team at Google with a million GPUs manages to break SHA-2 or similar. Hopefully they publish enough preliminary results that everyone has time to migrate to something more secure. However, 1) it could be that the break happens fast, and 2) even with time to migrate, _some_ users will still be on the old system. At that point you have to contend with deliberate collisions, and it's possible that attackers could cause trouble on old versions of a filesystem that are using the broken hash function. That said, in a scenario like that, collisions on your filesystem are probably a small worry compared to stuff like collisions in TLS certificates and other types of signatures. Signature schemes _have_ to assume the uniqueness of hashes, and we rely on them for security critical stuff like SSH all the time. People using unpatched systems in these scenarios are going to be in hot water, whether or not their filesystems are perfectly robust.
There are multiple ways to fetch an item from from vector. You could fetch using one is the several `get()` methods, or you could use the square brackets `[]`. Using the square brackets way does no bound checking, meaning a panic could occur if the index is invalid. Why does the language allow this? What are some of its use-cases?
Currently writing my first parser for my crate ics to read iCalendar files which creates an ICalendar object that can be soon edited and written to the file again. So far it is able to create actual tokens but I have not taken a look at error handling yet.
Starting out in Rust with trying to create safe bindings to a DDS (Data Distributed Service) library! It’s an interesting learning experience so far. Already managed to get it working in a dirty way but now trying to make it pretty so others can use it (:
Working on an issue called [Implement RealisticCamera](https://github.com/wahn/rs_pbrt/issues/70), which reads lens designs from a file (see [book chapter](http://www.pbr-book.org/3ed-2018/Camera_Models/Realistic_Cameras.html) about it).
This is beautiful. I'm trying to imagine how the fine bar is implemented. I assume this is built out of some Unicode characters that get replaced as it grows, but I cant think of what characters would give that effect.
Awesome, I love seeing basic parsers written in Rust to support application development. Do you have an application in mind for this library or is it just an interesting project?
Hm, compiling your code verbatim gives me fairly benign ``` error[E0308]: mismatched types --&gt; src/main.rs:10:12 | 10 | return conn; | ^^^^ expected enum `std::result::Result`, found struct `oracle::connection::Connection` | = note: expected type `std::result::Result&lt;oracle::connection::Connection, oracle::error::Error&gt;` found type `oracle::connection::Connection` ``` I don't really know what causes the error you mentioned. `lld` is the LLVM linker, but it shouldn't even be invoked because the code doesn't typecheck, there's nothing to link! Moreover, on my system it _does_ compile and link successfully if I fix the type error (`::connect` call, of course, fails due to the Oracle client not being installed). The only thing I can suggest is asking someone with more knowledge and experience of how C bindings crates work in Rust. I'm sad to say that I'm way out my depth here.
Woah!! This is super cool. Good luck! Let us know
&gt; Using the square brackets way does no bound checking, meaning a panic could occur if the index is invalid. This isn't quite correct. Using `[]` does bounds checking and throws a panic if an access is out of bounds. For real unsafe access there are `get_unchecked` methods. Generally, if you're in a situation where an out of bounds error is possible and you have a meaningful way of handling it, the `get` methods let you do that. In many other situations though, an out of bounds access is just a programmer error, and the only sensible thing to do anyway is panic. access by bracket is much more succinct in that case.
Great me too. Just started this week. Coming from C and Python (college level, i.e recent grad.) Rust is a pretty cool language!
I assume these ones: 2589 ▉ LEFT SEVEN EIGHTHS BLOCK 258A ▊ LEFT THREE QUARTERS BLOCK 258B ▋ LEFT FIVE EIGHTHS BLOCK 258C ▌ LEFT HALF BLOCK 258D ▍ LEFT THREE EIGHTHS BLOCK 258E ▎ LEFT ONE QUARTER BLOCK 258F ▏ LEFT ONE EIGHTH BLOCK https://www.unicode.org/charts/PDF/U2580.pdf Amusingly, on my computer, the half-block in this comment is less wide than the three-eighths-block. :P
This isn't [confusingly](https://github.com/ccMSC/ckb) [named](https://github.com/ckb-next/ckb-next) at all.
My actual goal was a calendar app for my smartphone (even in this age and time basic stuff seems to be average only) as data format which would be portable too. However, my programming skills are not good enough despite it looking like a simple task. I want to do it all in rust and support iOS and Android. Most importantly I try to apply the knowledge from an online book (http://www.craftinginterpreters.com) about parsers for an actual implementation.
Thanks!
This scam was already posted last week or so.
I think for the hell of it I'm gonna try to reimplement your project using rust enums (ADTs)
IIRC, there are a couple partial width rectangles that are often used for this effect.
Most definitely. My problem is that I have a hard time reproducing this outside of the unit tests, which I am trying to do to further investigate the issue. &amp;#x200B; CUDA definitely holds state, but as far as I can tell my functions respect all necessary conventions involved in concurrent invocations of CUDA kernels. 
&gt; Only the panic=abort configuration (i.e. a Rust panic terminates the program instead of unwinding the stack) is supported and the code presented here is only correct if that option is used. The code presented here does not try to prevent Rust panics from unwinding across the FFI, and letting a panic unwind across the FFI is Undefined Behavior. I'm curious to hear more about that limitation. Is there a performance penalty to catching panics at the API boundary? Or is it more that it's tedious to annotate a big API with catches everywhere?
The panic is a result of the bounds checking. A panic might seem to be a drastic result for a "safe" language, but the greater issue at stake is that any out of bound access could cause undefined behaviour. Preventing undefined behaviour is at the core of Rusts safety guarantee.
`&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;` that's a lot of nested types :)
Well I guess, you search for a function that acts on a fresh value (`3` in your original post) by modifying it before returning/giving it back. The important thing to notice here is that you don't care about the original value (`3`) after you modified it (`*x += 1`). This is exactly the use case of the `tap` function/method described in my linked comment. You actually **transfer the ownership** of the initial value and call a function on it. So neither `Clone`, `Copy` nor exclusive reference is necessary here, just move semantics. First, you move a value (`3`) to `tap` (in this case it copies though because it's `i32`), modify it via a closure and lastly, give back the ownership of the modified value (`4`) to the caller. Your code:`let mut x = 3; x += 1;`. Expressed with `tap`: `let x = 3.tap(|x| *x += 1);`. `tap` can crete an exclusive reference `&amp;mut` to `3` because it has ownership of it — it can do whatever it wants with it. I have personally never used `tap`, I prefer code blocks: `let x = { let mut x = 3; x += 1; x };` (which of course, makes more sense with complexer code).
Golang?
Yeah, that is Type Specialization. The std can *never* define the type specialization you just gave. Therefore, that impl is valid. 
What are some possible use cases for this?
I think, C/C++ has kinda the same "setting" as Rust
You're looking for r/playrust This is the subreddit for the Rust programming language.
Is there a way to achieve immutable string cloning without copying underlying buffer? What I mean is that I want to create a \`String\` from another \`String\` in \`O(1)\` by just copying underlying \`&amp;str\` pointer, without performing copying of data it points to.
Guys, why are you suggesting programming lenguages?
Is this a meme or something?
This is /r/rust, the subreddit for the programming language Rust. As /u/icsharppeople mentioned, you are looking for /r/playrust, the subreddit for the game Rust.
Thank you for that clear explanation. Somehow, I had made the fatal assumption that access via square brackets was done without bound checks. Though, I still wonder why one would want to use the `get_unchecked` method. 
I was thinking that you may not always want to transfer ownership of the initial value, but I didn't realise that you could just do `x.clone().tap` in those situations. So you're right that move semantics are all we need here.
This would break the contract of `String`, because the owned slice would no longer be uniquely owned. However, you can use a `Cow&lt;'_, str&gt;` to unify owned and borrowed strings, implementing clone on write.
exactly :)
Working on putting together a presentation/talk I'll be giving at Rust ATX meetup on Dec 11. The talk will be an intro to SIMD Intrinsics, with some live coding that you can follow along with if you like. https://www.meetup.com/rust-atx/
sheesh. nice.
In my experience, this usually happens quickly if you're using `nightly` compilers and updating frequently, since build artifacts for one version of the compiler are not used by a different version of the compiler, and one version of the compiler isn't going to cleanup for another one. &gt; takes precious time I mean.... if you plan ahead just a little, I'm sure there's *some* period of time that isn't so "precious" where your computer could work on it while you do other things. It is annoying though, just like how `docker` will slowly consume all of your disk space unless you manually prune your docker installation.
Sounds like you want to have two `String`s that share the same underlying buffer, which is something that the `String` API is specifically designed to prevent. This is because once one of those `String`s is dropped, the heap buffer it manages will be dropped and then the other `String` would be pointing to uninitialized memory. What you *can* do is turn a `String` into an `Rc&lt;str&gt;`, which I believe has the characteristics that you're looking for: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=8a7ab26b21a616fbd674bc64e011ff31
Well so far this week I fixed a issue in [tarpaulin](https://github.com/xd009642/tarpaulin) I found when upgrading to the newest nightly and released an update. Hoping to do further refinements and more work on my new developer [wiki](https://github.com/xd009642/tarpaulin/wiki/Developers)
Working on a UI library wrapping GGEZ for my long time game project. Also looking to release a new version of cargo sweep after I have investigated a hard bug a bit more :)
One thing I noticed about ownership is that if you write a loop where you take ownership, you may get in trouble for repeatedly taking ownership. This led me to try to avoid writing loops until the end, and focus on the contents of loops. However, I ran into an issue with code similar to this: fn some_factory() -&gt; SomeCollection { let mut collection = SomeCollection::new(); let value = collection.get_mut(0); *value = 5; collection } The error occurs on line 5, saying that there was a borrow on line 3. I understand that the borrow checker doesn't like this, but what boggles my mind is that the checker is fine with the same code as long as you create a loop or even simply a new scope: fn some_factory(a_number: i32) -&gt; SomeCollection { let mut collection = SomeCollection::new(); { let value = collection.get_mut(i); *value = 5; } collection } I think it's pretty obvious from these examples that the borrow checker could (and unless I'm missing something, it also *should*) allow the first sample of code to work - the checker could simply imagine that the borrow happens within another, smaller scope. My question is, why doesn't it do that already? Is this something that's already been identified and is being worked on? Is there anything I can do to improve the compiler for this?
I typically use [pbr](https://crates.io/crates/pbr), which seems to be the more popular of the two progress reporting libraries. indicatif looks quite nice, but does anyone know of any major differences between the two?
Well, looks like existing problems give no chance to create translation with the same functionality like on other languages. So I postpone this task till situation become better. I found another site - [exercism.io](https://exercism.io) with list of 88 tasks for Rust users and I must to say I was impressed by quality of these tasks and test for them. So I've now where to train my skills.
This will actually become legal syntax once non-lexical lifetimes land in the 2018 edition of Rust, which IIRC happens this Thursday. So it sounds like you won't have to wait much longer! Here's an example of it working in the playground on the current beta: https://play.rust-lang.org/?version=beta&amp;mode=debug&amp;edition=2018&amp;gist=13a9add9958147971aa94eb1717ee86b
I'm confused about the ambiguity, what is it and why is it a problem and how is char immune? Given `"aa"`, would the pattern `'a'` not match either `"[a]a"` or `"a[a]"` depending on which side you start from?
What do you need a division for in a game of life?
Bound checks at runtime mean slower access to data, and if you've already checked once, you may not need to check again. For example, if you're writing a simple application with only one thread, and you have a for loop that ensures you always have an index in the correct bounds, and you know that neither your index nor your vector will be changed inside your loop, you can use `get_unchecked` for marginally better performance
Ahhhh now I understand what NLL means! Thanks for the info!
&gt; Is there a way perhaps to keep it more or less sanitized for example by doing gc-like operations (removing old artifacts and binaries) automatically? Looks like you might like something like [`cargo-sweep`](https://github.com/holmgr/cargo-sweep)!
You see, the problem is that rust is an all-in-one package. You can built a rust-like experience yourself with the right mods based on other platforms but it won't be the same. I've heard Haskell has some tweak that you can build (search for tweag/linear-types on github -- note how they write tweak with a g so it's harder to find!) to unlock some of the hardcore levels. and you can try to make isocpp work with CMake and the CCG to get a similar kind of interactive experience (though not as polished).
Abort-on-panic is much easier to implement. Every C API boundary function would have to be enclosed in `std::catch_unwind` in order to implement error propagation safely. Looks like a job for a crate that can automatically generate C API boundaries...
Basically, I store the two dimensional array of Game of Life in a one dimensional array. To detect borders in a one dimensional array I do \`\`\`Index mod 11\`\`\` and check the result. My mod function is defined as \`\`\`a mod b =a - (a/b)\*b where a/b is integer division\`\`\`
Hello, I published \[my-pretty-failure\]([https://github.com/AlbanMinassian/my-pretty-failure](https://github.com/AlbanMinassian/my-pretty-failure)) which display \[failure\]([https://github.com/rust-lang-nursery/failure](https://github.com/rust-lang-nursery/failure)) in an elegant way. Line\[102\]([https://github.com/AlbanMinassian/my-pretty-failure/blob/fc7c8977564b4b8bfafecdd6a27e1a2e9e012c35/src/lib.rs#L102](https://github.com/AlbanMinassian/my-pretty-failure/blob/fc7c8977564b4b8bfafecdd6a27e1a2e9e012c35/src/lib.rs#L102)) i would like display the name of struct or enum, but i didn't understand how to do it. If anyone could help me or suggest a PR for display context struct/enum name then I would quickly add the correction to the next version. I made available an \[examples/helpme.rs\]([https://github.com/AlbanMinassian/my-pretty-failure/tree/master/examples](https://github.com/AlbanMinassian/my-pretty-failure/tree/master/examples)) with errors (with struct and enum) that you can run with \`\`cargo run --example helpme\`\` &amp;#x200B; &amp;#x200B; &amp;#x200B;
Tetris
I'm working on [prisma](https://github.com/tylerreisinger/prisma) a swiss army knife of color conversion, representation and manipulation for basic and complex needs that aims to be easy, fast and feature rich. Hoping for a 0.1.0 release in the next week or two after some refactoring and fleshing out the docs.
Looks great, I often find myself wanting some sort of colour conversion :)
I'm learning Rust by doing the [AdventofCode](https://adventofcode.com/) challenges and am having a ton of fun! &amp;#x200B; The current problem requires a 2D array and I'm wondering if I should try and use the native Rust data structures or find a package for it like numpy/pandas in Python. 
It would actually match “[a][a]”. There is no ambiguity since ‘a’ is a single character.
The logs are probably not parsed on a non-std/embedded system.
Correct! Those are the ones from the "fine bar" example. For the others, I used some more characters from the 'Block Elements' Unicode block: https://github.com/mitsuhiko/indicatif/blob/master/examples/finebars.rs
panics over FFI will abort by default once this lands instead of being UB: https://github.com/rust-lang/rust/pull/55982
I would ask someone to please leave a top-level comment explaining this submission's relevance to Rust, to satisfy our on-topic rule. It's possible that people may not be familiar with how undefined behavior relates to Rust.
Plus it runs on old hardware like PDP11.
That's great, I think it's exactly what I am looking for.
I'm guessing it's to figure out whether your program is at risk of overflowing the (probably very limited) size of the stack.
Yeh, the problem isn't that serde formats don't work in no-std, it's the combination of no-std and object-safe. The `Serialize` trait isn't object-safe, and `erased-serde`, which provides an object-safe wrapper, requires boxing to make that possible.
Nice!
That's right, it doesn't do deserialization because with structured logging, chances are you're sending your logs to some kind of log server which handles parsing for you. Even if you do find yourself dealing with files containing structured log data directly you can probably use `serde` or a specific parser to process them.
Sorry, dude(tte), we're just having some fun. Rust (the game) players post here about once a week, and we do get a little tired of it occasionally.
I remember there being issues with some Lua binding crates with this. How were those resolved?
&gt; Is there a performance penalty to catching panics at the API boundary? In theory it is possible to handle the panics at the boundary at zero cost, at least with Linux's exception handling ABI. I have no idea how Rust currently does it though. I'd assume the new abort-on-panic behavior will work in such a way.
More like once a day. Yes, it's possible I check _new_ too frequently...
Hi, https://ferrous-systems.com can handle that. See https://ferrous-systems.com/rust-training/ for our offers. We train Mozilla and other companies.
There is one thing I'd really like to see made more prominent on the front page. I often jump to the site for links to the Book and/or the API docs. I think it would be great, like the \`Why Rust?\` and \`Build It in Rust\` sections, I'd love to see a \`Documentation\` section, with links to \`The Book\`, \`stdlib API\`, and maybe \`docs.rs\`. &amp;#x200B; I'd use that myself and it would reduce clicks. It's especially handy when I want to get to a link quickly to show others.
Just started: [https://github.com/LukeMathWalker/advent-of-code](https://github.com/LukeMathWalker/advent-of-code)