Fixed all compiler errors. Not sure if it actually works though... https://play.rust-lang.org/?gist=a781dad31ea36b97b6bb2c2e9a289ae3&amp;version=stable
Interesting, thanks!
I learned something a while back reading this code https://github.com/Keats/validator 
Could you share more about your experience with teaching your gf? My wife is interested in learning programming (and recently also web dev) too and we've tried couple of times with little success. I'd much appreciate any advice on this topic.
[Currently learning some HTTP](https://github.com/legolord208/minttp)
This is an interesting point of view. What I'd fear is that beginners searching for mistakes that show themselves at runtime might be frustrated.
Not to discourage you, Rust is an awesome language and I want it to succeed, but maybe it'd be beneficial for you to try a little bit of C first to understand why you need to write some weird things in Rust.
&gt; but what use is a computer science degree if you can't write software? As a former member of academia, I can tell you that it's quite full of people that are strong in computer science but extremely weak in engineering. I'm not trying to be prescriptive or insulting here, it makes sense that things are like that because of the incentive structure. But my point is that you can actually have a fulfilling career as an expert in computer science with little to no engineering experience.
Sounds like this could be encoded in clippy...
I'd be interested if anyone can shorten Rust version or the C equivalent.
I already created a stackoverflow question [here](https://stackoverflow.com/questions/45326178/borrowing-error-using-macros), however I'd like to know some suggestions about how to create a function based on these macros: [get_body_as and get_body](https://github.com/DavidBM/rust-webserver-example-with-iron-diesel-r2d2-serde/blob/master/src/controllers/utils.rs#L69), which I think it's better to read, thanks. Edit: I've manage to improve the stackoverflow question, I guess it's something I don't understand about using macros.
&gt; What about assignment? &gt; I think making assignment an expression was a mistake, it should be a statement. As such, I left it out from the operator precedence. In most C-style languages assignment is an expression which yields the RHS (thus copying or aliasing the value in the process). In Rust assignment is an expression, but it yields `()`. Obviously we couldn’t have it yielding the RHS for non-`Copy` values, but sometimes I wish assignment yielded the *old value* of the variable (naturally you couldn’t use that value if it was potentially undefined). There’s something elegant about assignment being a replacement, and that dropping the value simply occurs because you *let* it drop. Swapping values could then be `x = y = x`. Wouldn’t that be cool? It matches what we do with things like `HashMap.remove` which, instead of returning nothing or a boolean like most languages do, returns the value (if any) that is removed. Fortunately, sanity returns to me in a matter of hours and I reflect that at least we have `std::mem::replace` to do this. Ignoring `std::mem::swap` for a moment (and the fact that `replace` is expressed in terms of `swap`), my `x = y = x` can be written `x = mem::replace(&amp;mut y, x)`.
I [wrote a post](https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/) about the techniques I use when debugging (and testing) custom derive code.
There’s not much *left* to shorten in the Rust version. I can’t imagine anything that would make it shorter *(I forgot about the trailing zero in float literals being optional)* without introducing third-party crates, at which point you just slap the function in another crate and write `extern crate p;use p::f;` (which is under a third as long, at only 12⁄37 of the length).
You can leave off the zeros after the decimals to get two more characters: `fold((0.,1.),`
How much of this would become unnecessary with generic associated types (ATCs)? Or will GATs all be object unsafe? I ask because I have seen some comments justifying GATs by saying that they already exist in the language in the form of generic methods.
Didn't know about this. Thanks!
Yep, I don't want to introduce third party crates.
You can have forks of all deps with your own paths to them...
Could you elaborate how? Maybe I'm dense... I put the folder "error-chain-master" in the same directory as my project, then added the following to my Cargo.toml: [dependencies] error-chain = { path = "../error-chain-master" } But when I run `cargo build` on my project, cargo still tries to contact crates.io, which fails.
`.split(char::is_whitespace)` produces empty strings when there are multiple contiguous whitespaces, while `.split_whitespace()` does not. For the following string: " Madoka\na \ncute!!" `.split(char::is_whitespace)` collects into this: ["", "Madoka", "a", "", "", "cute!!"] While `.split_whitespace()` produces this: ["Madoka", "a", "cute!!"] 
The thing I don't see anywhere is that if I try to use a registry source, how do I get the index, what's the format? Seems to me I need to use a directory source, but then I need the unpacked *.crate files, which I'm not sure how to get, and some sort of "metadata file" with the checksum of the files which I don't know the format of either. I'll download cargo-local-registry and try to use that, thanks for all those links :)
&gt; I’m going to use C++ as an example throughout this post, but this applies to any programming languages with conventional operators. That's not going to end well... &gt; If your language massively deviates from common idioms, you have a problem. Just imagine a language where `a + b * c` is `(a + b) * c`! That's what happens in Smalltalk, not because it has "unintuitive operator precedence" but because Smalltalk **has no precedence for binary operators**, they're evaluated strictly from left to right. It has only 3 precedences: unary messages (`foo aMessage`), binary (`foo &lt;operator&gt; bar`), keyword (`foo aMessage: aParam`). There's also cascading (`;`) but technically it's a syntactic element not a keyword. Beware what you wish for, that can also be very confusing. &gt; What does `a == b == c` do, for example. It doesn’t check whether all three are equal. It does in Python. &gt; And what does `0 &lt; a &lt; 5` do? In Python, check that `a` is between 0 and 5. In Rust, probably generate a compilation error. &gt; You don’t actually want what those expressions do as they don’t do what you think. See that's why the first quote is problematic, many issues in the essay are a combination of language-specific semantics and type-system issues, this other quote confirms it: &gt; I think making assignment an expression was a mistake, it should be a statement. Assignment is `()`-valued in Rust so most uses will be compiler-time errors, and it's a statement in Python so parse error. &gt; Note that we did have to make a few additional assumptions beyond the few I considered to be intuitive. In particular, `a &amp; b == c` does not do what C does. As far as I can tell, that is already fixed in both Rust and Python, so once again assuming every language "with conventional operators" does what C(++) does is problematic.
The index is https://github.com/rust-lang/crates.io-index
&gt; What I can do is download things manually via the browser Funny idea, rebuild cargo with `target=wasm32-unknown-emscripten` and run it inside of your web-browser. 
This is one of the many reasons, lisp(s-expr) syntax always feels "right" to me. There are no operators, these are just functions, you call them like any other. &gt; What does a == b == c do, for example. In lisp you just write : (eq? a b c) 
oooooo thanks!
Wow, I did not expect such a vast variety of responses. What a great community, really excited to eventually be a part of it. I will try to reply to all of you through a post here, hope everyone sees it and dont think Im ignoring all great inputs. To answer some of you, the main reason I want to learn rust is because I want to be a part of the MaidSafe project and the Safe network community. Could be anything from innovative decentralized applications to help out with core development. With this said, the more I read about Rust the more fascinated I get so it started with the ambition to be a part of SAFE network but now I just really want to learn it because I think it is a good option among other languages. I tried to take in all of your inputs and find a good approach for me, i am fairly positive that the best approach for me would be to start with 2 languages. There are available classes around me for C, C#, C++, Java, Python so I could start taking one of those classes and learn Rust on my spare time at home. So here goes my second question: What language is best in combination with rust and for someone who really would like to understand the basics, no matter how tedious it could be. Many people recommend Python and I dont mind starting with that, but will it really give me a good understanding of how it works "under the hood" so to say? The most basic/binary functions. Please also feel free to give me advice on books I should read to understand programming and the fundamentals better. Again, all of you, thank you for taking your time! It is highly appreciated even if I dont reply to every post. Amazing community :) 
Your `add_text` function in the `State` trait takes ownership of the state, which it can't do because the current function doesn't own it. Changing it to this will fix that issue: fn add_text(&amp;self, post: &amp;mut Post, text: &amp;str) {} However, you'll run into another issue, in that you'll have a mutable borrow and an immutable borrow happening at the same time. In this line: self.state.as_ref().unwrap().add_text(self, text); The `self.state` is an immutable borrow of part of `self`, while the `self` argument is a mutable borrow. Reading further on in that book, I see that it goes over the approach I would have gone for.
That was fast!
Thank you! I will look into it, had never looked into Go before. Yes Im fairly familiar with Git. Edit: Is Go the one created by Google?
I'd be interested in a performance comparison of that...
Iterating in reverse allows to get rid of the tuple, saving quite a few characters: fn f(x:f64,p:&amp;[f64])-&gt;f64{p.iter().rev().fold(0.,|v,c|c+v*x)} vs. fn f(x:f64,p:&amp;[f64])-&gt;f64{p.iter().fold((0.0,1.0),|(r,m),c|(r+c*m,m*x)).0} 
&gt; The precedence of the binary bitwise operators (&amp;, |, …) is lower than that of the comparison operators (== or ‘&lt;`). &gt; I don’t know why and I hate the decision. For the same reason as all the other oddities in C and C++ (and, in fairness, just about every other programming language ever): [because they were added later, and the language designers didn't want to break existing code](http://www.perlmonks.org/?node_id=1159769).
Yep, it's one of the languages Google created.
As a follow-up quick fix, the function `add_text` in `Post` can be written to work around the borrowing restrictions: pub fn add_text(&amp;mut self, text: &amp;str) { let state = self.state.take().unwrap(); // take out state state.add_text(self, text); self.state = Some(state); // put state back }
Also you should really use a lambda let f=|x,p:&amp;[_]|p.iter().rev().fold(0.,|v,c|c+v*x); and don't name it if you don't have to
There are now de-sugared examples in the documentation. Care to take a look?
I have added `for_match` and `for_match_all` if you care to take a look. Also, what do you mean by once match statements are stabilized. Are they not?
/u/bickbackbock thanks to linking to my three days course - please note it's "just" the backing slides for a workshop I give and it assumes previous knowledge of programming. That said, I'd be very happy about feedback :).
&gt; I think the biggest issue learning rust first is that there are far fewer resources than for a language like C/C++/Python, which have existed for 10x the time. There's a silver lining around this: especially with C and C++, there's so much stuff, and so much old stuff around that it is hard to get through all the cruft when you are a beginner. Which doesn't invalidate the point and especially Python has _so many people_ working on making the language approachable.
In [Pyret](http://www.pyret.org/), we sidestep most of the pain of operator precedence by [requiring that uses of multiple, different operators be explicitly grouped with parentheses](http://www.pyret.org/docs/latest/op-precedence.html). For instance, this is fine: 1 + 2 + 3 + 4 But this is not: 1 + 2 + 3 + 4 - 5 and parentheses must be used to make the precedence unambiguous: (1 + 2 + 3 + 4) - 5
Oh, math... :D Very nice and clever!
&gt; I suspect that Rust may not be great as a first language, because unless you know a little bit about how things work under the hood, a lot of things in Rust - especially the hard part of Rust, lifetimes - will probably be confusing. Rust does a lot of work to help solve hard problems that aren't obvious to a beginning programmer at all. Lifetimes are hard to use, but their usefulness and what they describe are _not_ hard to explain. The problem with lifetimes is that they are descriptive: no change in lifetime modeling changes anything in your programs execution, just in its safety model. That's very unusual for programmers that are 10 years in, to beginners, it's still hard, but they come with no assumption how programming concepts work in general. That being said, they can be avoided for a _very long time_. &gt; Bartlett's book is showing its age, but I think that if Rust should be taught early, it should be taught in conjunction with low level concepts like that book aims at. I have a concept for a similar thing, but no time :(.
That's kinda different, since it can't be used in global scope, but nice idea anyway!
Isn't binding it just naming it in scope? Can't the closure just be in-lined instead?
http://doc.crates.io/faq.html#how-can-cargo-work-offline
No, they aren't stabilized. The current behavior is subject to change, pending discussions.
`cargo-local-registry` worked for me until it broke. I solved the thing by copying stuff to appropriate directories. I found it somewhere in docs.
What I like about Rust is that many things you need to learn as concepts in C (especially ownership and sizedness) are language features in Rust.
This is actually a worse problem in rust, in my opinion. Because rust is so young a ton of information is literally just wrong - it's about a pre 1.0 language. And because it's only been 1.0 for a few years now, it's very, very easy to stumble upon that incorrect info.
right but when code golfing you want as much as possible in the main anyways because of lambdas and their sweet sweet type inference
Sure it can all it takes is a pair of parentheses. Maybe he needs to call it more than once who knows.
The bitwise operators' precedence is actually just a bug in the design of C, which has multiplied into more language, since just about everyone copied the table from C. Not even K&amp;R got everything right... 😁
There is actually an entire book dedicated to Rust macros: https://danielkeep.github.io/tlborm/book/
Fixed both issues.
Ok, It may be out dated and custom derives are not covered there, but still can be quite useful. 
Pony has the assignment expression yielding the old value, giving you the `x = y = x` syntax, which really is pretty nice, and works well with their reference capability system when you have an owned (`iso`) reference. OTOH, part of me thinks it should use an operator other than `=` to avoid confusion.
How did it do that? As far as I can see it can only download stuff from crates.io and make it fit for offline usage, but if I can't contact crates.io in the first place...
I don't normally praise Python for its design decisions, but I think Python got comparison operators right. Case in point, this statement: &gt; Just imagine a language where `a + b * c` is `(a + b) * c`! Having a language that disobeys the mathematical tradition of `*` and `+` is somehow not only unhelpful, but *unimaginable*. Yet, we accept, without question, that `a == b == c` must break with mathematics because... C did it that way? 
Not much utility here I'm afraid. It's just an interesting sequence of numbers that I decided to make into an iterator.
The amount of problems that could have been avoided if only people were not too lazy to write a few extra parentheses....
Thank you both. I've updated the gist
Try and remember when you started programming: did you not struggle with the type system or pointers or recursion? I certainly did! And although I can now write Rust with relative ease, when I started learning it, I felt exactly like I did 15 years ago when I learned to program for the first time: the stupid compiler would refuse to compile my code and I would feel frustrated and angry about it. But with perseverance and practice, I managed to form a mental model of how Rust works and little by little the difficulties subsided. I hope you keep at it; I don't think that I am a very good programmer which is why I especially like Rust. When I wrote Python code, I very often forgot to check for `None` or that an exception could be raised and as a result I put broken code in production more often that I would care to admit. If more of my mistakes can be prevented by Rust's compiler (e.g., `Option&lt;T&gt;` is not the same as `T`, so I can't misuse `None`), I can deliver software that is more robust. The price for that is (a) the time it takes to learn Rust's way, (b) accepting to feel like a newbie programmer for a little while.
I would be actually in favour of rust accepting `a == b == c` and other chained equality operators. Just have each pair be split off into its own item and `&amp;&amp;`-ed together while intermediately storing all non-constants (ie function return values) for optimization
Is there an rfc for that, I would like to take a look
Thanks for the in-depth answer.
Rust Belt Rust CFP link is broken, points to RustFest.eu
This function takes a number and returns another function that adds another number to the first number. fn higer_order_fn_return&lt;'a&gt;(step_value:&amp; 'a i32) -&gt; Box&lt;Fn(i32) -&gt; i32 + 'a &gt; { Box::new(move |x:i32| x+step_value) } This is so different from every other language, including C with blocks! Can someone please explain what is going on here and what are all the Rust-isms. 
It's generally great but it can be somewhat odd when chaining different operators or with chains of more than 3 elements e.g. `a &lt; b &gt; c` or `a &lt; b &lt; c &lt; d &lt; e`.
&gt; Having a language that disobeys the mathematical tradition of * and + is somehow not only unhelpful, but unimaginable. It's not though, as noted there have been language doing exactly that (ignoring languages without infix operators which don't have that concern to start with). Smalltalk has strict LTR evaluation of binary operators, APL also has no precedence but uses RTL instead.
I'm guessing that it's doing this because `error-chain` also has dependencies, specifically, backtrace.
nice, i didn't know about that. I've always been after this idea, for partial trait implementation (sometimes to avoid getting a cats-cradle of traits to micromanage, it might be easier to over-estimate the grouping of functions, and get a compile-time error for some cases if you made a mistake... middle ground)
https://github.com/redox-os/ion/issues/358
&gt; The bitwise operators' precedence is actually just a bug in the design of C, which has multiplied into more language, since just about everyone copied the table from C. Only languages which very directly inherit from C or those which are a bit… touched: C#, Java, Javascript, PHP, Perl, Visual Basic. Rust fixed it, so did Python, Ruby, Swift, Go, …
that... is a really good idea :o
FWIW, for the C version you can use recursion like this: typedef double d;d g(d x,d*p,size_t l){return l?x*g(x,p+1,l-1)+*p:0;} which handles the l==0 case and is a good deal shorter than the original (69 vs. 87) typedef double d;d o(d x,d*p,size_t l){d r=*p,m=1;while(--l)r+=*(++p)*(m*=x);return r;} 
heh. &gt; "And what does 0 &lt; a &lt; 5 do?" come to think of it, what does ```a&lt;b&gt;c``` or ```a&lt;b,c&gt;d``` do...
i like the idea, but I always miss "." for field access and more
Comparison operators in opposite direction may look odd and be forbided, but I believe you can generalize any sequence of comparison operation : `expression1 #op1# expression2 #op2# expresion3 ...` to `(expression1 #op1# expression2) &amp;&amp; (expression2 #op2# expression3) &amp;&amp; ...`
Sorry if I was not clear but there is a simple rules to translate. 1. `a &lt; b &gt; c` === `a &lt; b &amp;&amp; b &gt; c` 2. `a &lt; b &lt; c &lt; d &lt; e` === `a &lt; b &amp;&amp; b &lt; c &amp;&amp; c &lt; d &amp;&amp; d &lt; e` I can see that there would be two problems here: 1. In recognition that the second form does not necessarily call functions, ie. `a &lt; b &gt; some_fn()` should not call `some_fn()` if a &gt;= b because it wouldn't in `a &lt; b &amp;&amp; b &gt; c`. Thus there isn't a clean code transition and can only be truly matched to the following (as far as I know in assembly the difference is not much but in actual code it looks a lot worse) if a &lt; b &gt; c { ... } if a &lt; b { if b &gt; c { ... } } In the second case more checks are not needed because `&lt;` is commutative, meaning `a &gt; b AND b &gt; c =&gt; a &gt; c`
I recently watched some lecture about a language that used whitespace to hint the precendence and more , e.g. ```a + b*c``` ```vs a+b * c``` (I think it was more on about more advanced notation than common arithmetic) maybe it's not such a bad idea since you would use spacing to clarify visually. ...but I'd want to keep established precendee for + * . the "dot accessor" is amazingly useful and probably the reason I haven't adapted to using a lisp (despite liking the idea)
Thanks for testing Stylo and DevTools! Can you clarify "expanded into" here? Maybe a screenshot would help. In my testing, I see the same `all: unset` behavior in both Gecko and Stylo modes.
In Haskell, the way I handle this is with constraint synonyms. Then I can change it in one place. Can you make a synonym/alias for trait bounds in Rust?
Ah, so not in rust but in the redox command line, I see
why? it would be desugared to `(a &lt; b) &amp;&amp; (b &gt; c)` and `(a &lt; b) &amp;&amp; (b &lt; c) &amp;&amp; (c &lt; d) &amp;&amp; (d &lt; e)`
Step-by-step explanation [here](https://gist.github.com/anonymous/2319d61326854719e92842d4ca1e4c80). I've omitted the lifetime annotations (e.g. `'a`) as they are not necessary for the purpose of this function. In short, they indicate the span in which a reference is allowed to live, and can be treated like a generic type parameter.
Very much true, thanks! I just now realize how many dependencies there are over a "common" application, so I'm just starting to think again I might be able to pull of that "download stuff somewhere else and transfer via USB stick" thingie ^^
\**cough*\*[debugit](https://crates.io/crates/debugit)\**cough*\*
I don't see what's odd about `a &lt; b &lt; c &lt; d &lt; e`. It's long, but totally sensible. `a &lt; b &gt; c` is terrible and could reasonably be banned, by requiring your operators to all point in the same direction with only strictness varying. Something like `low &lt;= val == x_val &lt; high` would be fine.
Perfect, that crate is exactly what I am looking for! :) Wish I knew about this trick as a beginner, rather than a year after using Rust. Not sure whether documentation or language/library ergonomics is lacking here, but something is...
Well, I definitely agree with you that the API could be a little more...ergonomic :) but the underlying concepts are sound, though.
you can if you include the correct domain in the allowed image sources
AFAIR, specialisation isn't even stable yet. There's not much point documenting a "trick" that may or may not work tomorrow.
&gt; My interest in Rust is all the syntactic tweaks It really seems like D is what you want instead (or jai, as you say). Ultimately, the language you describe is probably not one Rust can become, safety is a core value. &gt; rust seems hostile to raw pointer code beyond that I would actually disagree, in general I've found that it's harder to write "actual" unsafe code in C++ than in Rust (e.g. when you're doing truly weird things and need to step around safety guarantees of move constructors and stuff). However, it is probably true that for the raw pointer stuff _you've_ needed in games Rust might be harder. &gt; Prototyping in rust with @T would have been perfect "Rust with GC" is totally doable, GC crates exist for Rust, they're just not in the stdlib. &gt; with 'unsafe' float assumptions Rust doesn't consider NaNs in floats to be unsafe.
&gt; If your language massively deviates from common idioms, you have a problem. Just imagine a language where a + b * c is (a + b) * c!' I'll do you two better. APL-like languages have right to left evaluation of operators. a * b + c evaluates as a * (b + c). Forth style languages would evaluate a + b * c as a function which requires another argument and would assume that a is a function name. Both are perfectly easy to use if you spend about a couple days getting the hang of them.
The lint already exists and is turned on by default. https://github.com/rust-lang-nursery/rust-clippy/wiki#precedence
That is actually exactly how operator precedence groups work in Swift. Binary operators belong to a precedence groups, and groups can define relation to other groups. If two adjacent operators with different groups don't have defined relations, you are required to use parentheses. 
"yes" trait OrdDebug: Ord + Debug {} impl&lt;T: Ord + Debug&gt; OrdDebug for T {} At that point, I think the bounds `Ord + Debug` and `OrdDebug` are roughly equivalent. I wouldn't call them aliases, but I think it would work fine for the OP's purposes. One issue I'd consider for this is that it would be bad if `OrdDebug` leaked into the public API of your library unless you specifically wanted it for some reason.
By the way, having `derive(Debug)` failing when you have fields that don't implement `Debug` is on my top 10 of most annoying things in Rust.
That's the problem though, type and constraint synonyms in Haskell are erased and are structurally identical to their definitions. A type or constraint synonym in a public API in Haskell is not a big deal at all. This seems more equivalent to making an entirely new typeclass that requires the constraints.
The RFC for trait aliases was approved a while ago, but they haven't been implemented yet. Tracking issue is [here](https://github.com/rust-lang/rust/issues/41517).
The Agda people made a very nice observation in their paper about mixfix parsing: Precedence shouldn't be a total order, as it makes no bloody sense to ever need to decide whether &amp;&amp; or + bind tighter... at least assuming somewhat strict types. 
&gt; It really seems like D is what you want instead. D started out GC based - the 'move semantics' of Rust is the correct default , rust handles that really well, as it was built around it; I also vastly prefer rusts syntax, "everything is an expression", 'immutable by default'; tuples, (sounds simple but I absolutely love these, being able to group values/do multiple returns effortlessly without naming and an extra word like 'pair' appearing') I like how Rust straddles the feel of a functional and imperative language. Compared to all that I don't find D interesting. I also DO actually like declaring globals to be unsafe - I agree wth that restriction r.e. threadsafety. what is so frustrating is that Rust has everything I want under the hood/in the underlying engine, then disables/prevents a few things.. it really is just an extra option that I want. What is even more frustrating is the moments where features that I liked got removed. (like a 'bait-and-switch' moment). I could probably take the safety verbosity or the 'make-sure-future library clashes never ever happen', but combined it they drive me insane. Ironically the spell of dealing with *traits* ('before you overload, you *must* place something in an entity..) has got me to make peace with classes a little, and I began to appreciates c++'s class methods merely as a shortcut for 'self./this-&gt;' more. I'm sort of burned by the whole experience of trying a new language in the first place, so I probably wont try D; it's like I should have listened to the critics who said "it's impossible to replace C++" .. better the devil you know can you not see the inefficiency here: "Here's 99% of what you want. We don't want this extra 1%, it shouldn't exist , so bugger off and find something else"(.. then you get jonathan blow spending x amount of his time building something else, .. and I know it will have the same uphill struggle with tooling, .. it's taken years to get to a point where we have 'dot-autocomplete' for Rust and it's still WIP). wouldn't it be much better for the world to just address these concerns in a spin off which still has a huge common subset - it can even be syntactically distinct as in a #[unsafe]/#[gaming_mode] or whatever that means you'll never accidentally pollute one world with the other. wouldn't that give us more synergy .. after all there will still be safe subsets of what *we* do. All the 'tools code' can still be bounds-checked just like regular rust. they say they 'don't want to fragment the community', but isn't driving people away a bigger form of 'fragmentation' &gt; Rust doesn't consider NaNs in floats to be unsafe. it's not the fact NaN's exist, but rather that Rust has to assume *they could be there*; What we really needed was a completely different type that is *guaranteed not to be NaN*; then 'division', 'reciprocal sqrt' on that need to become "unsafe operations" which *could* break that assumption. (but it would be seriously un-ergonimic if we couldn't re-use the same operators, i.e. we might need a way to say the safety of an operator depends on the type) Not sure what to call it .. perhaps some unambiguously descriptive namespace, "numeric_types::never_nan::{f32,f64}" 'true-general-purpose-complete-f32' doesn't support 'ord', but the type I'm describing does. (it's like 'f32'/'float' is really 'Either&lt;fractional_value,error_code&gt;', and we want another type that is *just* the fractional_value (or UB)) Correctly designed code doesn't check for them: they never appear, by design (e.g. before you 'calculate triangle normal', you know it's not a degenerate triangle because you filtered them all out; etc etc etc), or you normalise with a bias toward a default (so the operation isn't strictly normal, just a stable approx); there might be other 'saturation arithmetic' going on as a fallback to prevent overflows / simulations blowing up. there's no way I know of expressing everything fully in the type system , so we drop back to empirical testing (or it might be more accurate to say "everything that could happen is just too long winded to express, so it's more *practical* to drop back to testing..") ; It's easy enough to pervasively drop in a replacement 'debug version of the float, or vector' (we even had a use case for replacing 'bool' for some detail about how you got bools back from comparisons on types in the vector pipeline) this is why I think the '--unsafe' option would be best all round .. you'd have a sliding scale. 
APL I think works, Forth does not use "conventional operators" (Lisps likewise)
&gt; What we really needed was a completely different type that is guaranteed not to be NaN You can define such a thing. And you can enforce the boundary between checked and unchecked floats using the type system. You can similarly define unchecked indexing ops on custom collections wrapping around arrays and stuff. 
It's not the semantics which are problematic (those are fairly logical) it's the reading comprehension which can be troublesome, especially with less trivial operands than one-letter variables.
Would that language be Fortress? :D the project is shut down but you can still find the language spec and some presentations on it. Some top PL people worked on it and there are some really cool ideas in it. Warnings about whitespace that doesn't agree with operator precedence is one. Another is no precedence between different "domains" (groups of operators) by default, so you are required to use parentheses. IIUC another comment in the thread here mentions that Swift does this. 
&gt; Sorry if I was not clear but there is a simple rules to translate. I understand perfectly well what those expressions translate to, the issue is not their semantics it's their readability for human beings when operands are nontrivial. &gt; In recognition that the second form does not necessarily call functions, ie. a &lt; b &gt; some_fn() should not call some_fn() It absolutely should call `some_fn()`, and should further perform all comparisons in all cases. Comparison operators are not lazy.
I wouldn't mind at all if Cargo ran basic lints such as "Do all public symbols implement `Debug`?" before accepting a crates.io upload. The number of times I had to file an issue/PR about trivial stuff like this (`Debug`, `Hash`, `PartialEq` on `Error`s, etc.) is really disappointing.
that might be it.. they were going on about 'scientific/mathematical notation', 'we'll compile what you write on the blackboard'
I really don't get how ya folks manage to so thoroughly misinterpret my objection. I'm the same person who quoted the behaviour of this exact thing in Python two comments above, I'm not talking about the semantics of the comparison which are relatively straightforward. And which you got wrong incidentally, the operands should not be evaluated twice.
I'm not sure what you mean -- it seems to work here: https://play.rust-lang.org/?gist=ecd889fe337294416793f2583da81dd9&amp;version=stable
I think they are available in many common Forths?
No comparison operators are not lazy but boolean operators are (I believe). I only proposed this should also be lazy so as to have a similar outcome to the corresponding expression using boolean operators. Comparison operators cannot be lazy since they need to know both sides to compare, however, in `a &lt; b &lt; c` the first comparison is `a &lt; b` and if that is false then I think that it should lazily return false
&gt; You can similarly define unchecked indexing ops on custom collections it's not so bad making an accessor but its still slightly compromised in that we can't use the natural [] for it . its like we'll pay twice, writing the 'unsafe{} block', then be **using more verbose syntax inside it.** ( and thats what I mean about the unsafe pointer stuff aswell, *mut / *const and the double casts ; it would have been nicer to go the other way and get the auto-coercion to void* that C libraries assume. you have things like passing buffer offsets as a pointer.. the pointer never exists or is formed by taking ```((void*)&amp;(((DummyVertex*)nullptr)-&gt;component))``` .. thats the sort of thing that rust makes more painful .. rusts philosophy is "this suff shouldn't exist", not "lets help you write it".. )
Unless you can overload operators!
Infix operators?
I'm sure that was a joke, but you would have to rewrite it to use browser APIs instead of OS apis.
&gt; I only proposed this should also be lazy so as to have a similar outcome to the corresponding expression using boolean operators. Eh. That's debatable, the "corresponding expression using boolean operators" would also evaluate operand *expressions* twice unless manually memoized. Could go either way.
No, operator symbols. The operators are still there, but the evaluation order is based on RPN. This is the example from Wikipedia (I am not a Forth expert in any way): &gt; 25 10 * 50 + CR . &gt; &gt; 300 ok I guess I got the order wrong in my example? (c is the function)
Can someone clarify what this article has to do with Rust? I'm especially surprised considering that nobody has yet mentioned that, regarding this: &gt; The C programming language - and thus many derived languages - has a great example of “bad precedence” that annoys me anytime I use it. The precedence of the binary bitwise operators (&amp;, |, …) is lower than that of the comparison operators (== or ‘&lt;`). ...Rust deliberately fixes this, by making the precedence of the bitwise operators higher than the comparison operators.
I will look into it again, when I tried (what I remember was exactly that) I got the error: `unexpected value 3`
For all intents and purposes, `OrdDebug` is structurally identical to `Ord + Debug`. The places where they differ are in trait objects (i.e., existentials). You can have a `Box&lt;TraitA&gt;` but not a `Box&lt;TraitA + TraitB&gt;`. There may be other corners I'm forgetting. But I wouldn't like a "true" alias either if that appears in the public API unless it was a widespread convention.
I would prefer to just return that "Debug not implemented for {}" string as the result of the default debug, instead of panicking. But this is pretty rad!
They are necessary to get it to compile though; elision doesn't work here.
&gt; but its still slightly compromised in that we can't use the natural [] for it Sure you can. Implement the index trait. 
oh I see what you mean: so basically have unsafe::Vec and rely on clearly marking that (maybe it's constructors etc could be unsafe{}, defined in its module, then via 'priv' stuff, that would do it cleanly?). maybe that could work. anyway thats one of several issues.. all of which add up. I have ideas on many fronts, e.g. traits annoy me in making operator overload more verbose, but if referencing the trait allowed you to elide the types in the impl (like haskell instances) , they'd be a lot more welcoming. I miss the nested classes which let you share type-parameters (e.g. you can make a parameterised 'Mesh' taking a &lt;VERTEX&gt; etc, and have nested classes that inherit those params). I had another suggestion about 'module-wide type-params' to recover that. The type params are made more verbose by constraints, *and traits/lack of nesting means you have to reference them far more often*, thats why writing rust feels far more like drowning in angle bracket hell than C++. (there's a really nice proposal to make 'auto args' a shortcut for type-adams, aswell as using the concept-names as args which again would instantiate a type-param for you). rusts syntax could go further down that route because you don't need to write 'auto'.. etc etc I like the underlying 'engine' and look of rust, and with some tweaks/small additions it could be perfect. you could call what I want 'rust-+' or whatever but there would remain huge overlap. Think of how Clang handles C, C99, C11, C++, Objective-C, and even "Objective-C++". It would be silly to have to build *entirely* separate ecosystems for each facet.
Great post! I like the idea of having an executable checker so we don't end up as a community of language lawyers where nobody agrees about what is UB. And (eventually) running (parts of) the compiler test suite through it, yes please. One thing I don't understand is the stack frame counter thing: &gt; When a lock is acquired, we record which stack frame is the owner of this lock (starting at 0 for main, and counting up). Now, on every read access, we check whether there is a write lock of this location held by another function. This doesn't seem to deal with recursion or multithreading. I guess for recursion, you'd increment the frame count, so when `factorial(5)` calls `factorial(4)` they are treated as separate functions, which seems right. But for multithreading, it seems like you could end up with duplicate frame counts, right? Actually, concurrency seems like it could be a huge headache in general for this checker.
There is a compile-time way which can be used for non-Cloneable objects, in some circumstances =&gt; requiring a proof of work. The idea is that if you have a state machine with 4 states A, B, C, D where C and D are "final", then you can introduce a `ProofOfWork` type, not Cloneable, and implement: fn end(_: C) -&gt; ProofOfWork { ProofOfWork } fn end(_: D) -&gt; ProofOfWork { ProofOfWork } Then require that the function which manipulates the state machine returns `ProofOfWork` at the end of its execution. Since it *must* consume a state to produce another, and *must* consume a final state to produce the proof of work, and *cannot* return without a proof of work, then upon return it *must* have gone through all the work... or used unsafe at some point.
It's poor wording on my part, but what I did was getting rid of references altogether since `i32` is `Copy` anyway, so as to avoid complicating the function further. But yeah, lifetime elison indeed doesn't work here.
&gt; I'm sure that was a joke, but you would have to rewrite it to use browser APIs instead of OS apis. Hm, why this difference can not be hidden inside stdlib?
&gt; No, operator symbols. Lisp also has that but I assumed the essay meant "conventional operators" as in infix operators separate from other forms. In Forth or Lisp `+` is no different than `append` or whatever.
The recursive rust version is also cute: fn h(x:f64,p:&amp;[f64])-&gt;f64{p.split_first().map_or(0.,|(f,r)|x*h(x,r)+f)} two chars longer than the recursive C version but still shorter than the original 
Ah I see. That seems to do the trick, thank you!
Oh! [ATCs](https://github.com/rust-lang/rfcs/pull/1598) are entering FCP with a disposition to merge :D
This has been a thought in the back of my mind for a while. Operator precedence is clear for some and confusing for others...just like type resolution in inferred languages! Sometimes annotation is the answer, but sometimes it just adds noise. So why haven't we attacked this problem with IDEs the same way we have with type resolution? Hover over any potentially ambiguous-looking operator expression, and display in a popup the parenthesized version! It seems obvious to me, but I've never found any plugins that do so, so maybe it is a novel thought. 
Similarly, type parameters must implement Debug even if they aren't used in the struct directly. 
Yup, I don't know what I was doing wrong so now all three macros are using `match` internally, no longer relying on loops
welcome to /r/dontyouknowwhoiam 
**Here's a sneak peek of /r/dontyouknowwhoiam using the [top posts](https://np.reddit.com/r/dontyouknowwhoiam/top/?sort=top&amp;t=all) of all time!** \#1: [Woman cutting off Tony Hawk](http://i.imgur.com/OQpuPc4.jpg) | [226 comments](https://np.reddit.com/r/dontyouknowwhoiam/comments/65swpl/woman_cutting_off_tony_hawk/) \#2: [What's Tony Hawk up to these days?](https://imgur.com/gallery/JQeLA) | [194 comments](https://np.reddit.com/r/dontyouknowwhoiam/comments/60uyvu/whats_tony_hawk_up_to_these_days/) \#3: [Stupid Hipster Chick](http://i.imgur.com/JBuGSnI.jpg) | [154 comments](https://np.reddit.com/r/dontyouknowwhoiam/comments/4utpx1/stupid_hipster_chick/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Maybe `&lt;-`? `x &lt;- y &lt;- z` looks like the values are "flowing" to the left. It may even be possible to get this in rust with the placement operator for stuff like Box.
I'm working on a video game engine in it. I've also made a discord chat bot for automatic server maintenance.
Yeah, that's Fortress: https://youtu.be/EZD3Scuv02g?t=6m35s
would `a - b - c` require parentheses since it is non-associative? 
RFC that for Rust, now.
&gt; I couldn’t find a language that actually does this Perl and JavaScript have stuff sorta like this. In Perl, `2 == 3 == 4` is a syntax error. It only does that for comparison operators unfortunately however, probably to allow adding chaining syntax in the future. In JavaScript, `-2 ** 3` is a syntax error, because language designers couldn't decide on whether it should mean `-(2 ** 3)` or `(-2) ** 3`, so they made it a syntax error instead.
I see this as a continuing trend in language design. Restrict the space of allowable programs, usually through some constraint that the programmer would be unlikely to want anyway, and this also reduces the phase space of unacceptable programs. Rust is a great example of this, this lint just adds to it by taking human failings further into consideration.
[Unit-safe computations](https://github.com/coder543/metric), viewing the [nearby stars in 3D space](https://github.com/coder543/localsim), some [LDAP authentication](https://github.com/coder543/rust-cldap), maybe one day for [scientific plotting](https://github.com/coder543/dataplotlib). Just FYI, there *is* [a weekly thread](https://www.reddit.com/r/rust/comments/6p699l/whats_everyone_working_on_this_week_302017/) dedicated to this exact topic, and I am pretty sure it will get more responses than this one. You can also [look up the previous ones](https://www.reddit.com/r/rust/search?q=what%27s+everyone+working+on+this+week&amp;restrict_sr=on&amp;sort=new&amp;t=all) and read about what people were doing then.
Anything that I would have used C before. Either because of portability, performance or the need to use a C/C++ lib.
I recently wrote a debugging tool in it: https://team-worm.github.io/spice/ I am currently working on a reimplementation of classic Game Maker: https://github.com/rpjohnst/dejavu I would also like to write some IRC stuff- bots, a bouncer with a nice mobile UI, etc. Haven't done much beyond experiments, here.
I understand your frustration, but Rust tries to be a flexible solution in environments where Debug impls may be useless and only cost compile time, or worse, program size. There's the `missing-debug-implementations` lint which is `Allow` by default.
Try Clojure? `(.method_name object)` for methods, `(.-field_name object)` for fields. `(.toUpperCase "fred")` `-&gt; "FRED"` `(.getName String)` `-&gt; "java.lang.String"` `(.-x (java.awt.Point. 1 2))` `-&gt; 1`
Debug should pretty much be derived by default, except optimized away when completely unused :P
This sounds like a terrible idea why is this better than just a fixed list? 
I'd replace the default implementation of the trait to just return `format!("&lt;instance of {}&gt;", unsafe { std::intrinsics::type_name::&lt;T&gt;() });` In that case, you get mostly meaningless prints vs a panic.
This is fixed now. Thanks!
This would be equivalent to always using parentheses for mixed operators.
I just assumed it meant symbols. I dunno. Whatever. This whole argument is a bit muddy to me.
&gt; my x = y = x can be written x = mem::replace(&amp;mut y, x). I think just using `swap` is a lot more readable.
This is very similar to what Lisp does.
I wish crates.io required repository links. 
&gt; Rust deliberately fixes this Rust does not fix everything though, see [this Clippy lint](https://github.com/rust-lang-nursery/rust-clippy/wiki#precedence).
The essay is about precedence. Prefix (lisp) and stack-based languages don't have precedence.
Not really. Lisp is prefix, each operation is clearly bounded, and some operations (e.g. sum) have variable-arity. Associativity and precedence are not concerns at all in that context.
Haskell has customizable precedence. Does that mean it does or doesn't have operators? That's part of where I'm getting very confused.
How do you do "just a fixed list" with user-defined operators? (note: not overloading, actual user-defined operators as in Haskell)
It doesn't mean it's an appropriate decision. Judy makes reading coffee more difficult, because the mathematical precedence is just so intoned in most people's minds.
inb4 http://example.com/nah.git
It has operators which is why it needs customisable precedence. Forth and Lisp don't and don't, it's just that their identifiers are not limited to letters. There's no semantics difference between `(add 3 5)` and `(+ 3 5)`.
I mean if we had variadics and `==` were just a function we could just write `==(a, b, c)` :D
You would get something extremely similar when forcing operators to use parentheses when they are mixed. E.g. `(a + b + c) - (d * e)` vs. `(- (+ a b c) (* d e))`.
Thanks for your reply! I am aware of the auto dereferencing that takes place but your link was very informative; it's nice to see the full algorithm. I think what I was wondering was more; why does the same auto dereferencing not apply when using operators as well? There may be a good reason not to, but it feels like if the auto dereferencing stuff benefits method calls, it would benefit their operator versions as well (certainly my usage would have just worked without needing the further thought) 
I know it's not the same, but you can at least see the source [here](https://docs.rs/debugit/0.1.0/src/debugit/lib.rs.html)
Thus far, mostly small tools and utilities I would have otherwise used Python (and maybe Go) for in the past.
I didn't even know JS had a power operator … I always used `Math.pow` when I needed it.
It's a very recent addition, it requires [Firefox/Chrome 52](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Browser_compatibility) as it was added in 2016 standard.
This is what it is. The other thing is that we go from our first language to a bunch of other very similar languages - C to C++ to Java to Python etc. Often that's what a school will cover, or what you'll run into in the field. So when you run into something different it feels insanely hard, but only because it's different, and everything's just been super similar up until this point.
Perhaps to some extent it could be, but they are different execution environments with very different capabilities and APIs. For example, consider the fact that JS code doesn't even have a real filesystem. You could create a fake in memory filesystem, or write one backed by IndexedDB or whatever, but the whole point is that you'd have to write it, and there are a lot of options and it wouldn't work quite like the real filesystems that desktop developers expect. And then of course there's the question of how the user can interact with it. There are APIs that let the user select files to upload to the browser, but you would have to handle that specially. And then you might think about stuff like cloud integration. And the situation with networking is even worse. Just like with filesystems, you could write something (websockets, etc.) but you're on your own.
I'm building servers, though I plan on making a game once the ecosystem and I (as a game dev) mature a bit. I've been playing with `rocket` for a project, and I've built a prototype product with `diesel` and `iron`.
FYI, there's a `missing_debug_implementations` lint you can turn on to ensure all public data structures have `Debug` implementations. I turned this on for libstd a little while back: https://github.com/rust-lang/rust/pull/38006
I thought I had seen one, but I can't remember the name...
I'm not sure what you mean, can you explain? I don't think Discourse has any way to permit images from being used outside of its servers. Its CSP seems to be set to permit images only on the origin domain and their `cdn-business` subdomain.
I think user defined operators are unforgivable bad to start with. If you can't look at code and figure out what happens without consulting a table you are probably doing it wrong.
- [Ion: a next-gen system shell](https://github.com/redox-os/ion/) - [Re-implementation of GNU Parallel in Rust](https://github.com/mmstick/parallel/) - [Redox: next-gen OS](https://github.com/redox-os/redox) - Complete web server from scratch: [my WIP website](https://mmstick.tk/) - [Some simple](https://github.com/mmstick/systemd-manager) GUI [utilities](https://github.com/mmstick/tv-renamer). - And miscellaneous crates that resulted thereof
I'm glad you like it. :) Indeed, as you observed, you need both the thread ID and the stack frame number when handling concurrent accesses. Concurrency is pretty much always a huge headache. ;) However, thanks to Rust, this shouldn't be as bad here. The only locations on which Rust permits race conditions are shared `UnsafeCell`, for which no locks are acquired. So, all this memory locking business will "just" be UB when there are threads racing for anything. Of course, implementing this in a checker will be "fun" to say the least.
I used Clojure for several years; this syntax still feels relatively heavyweight to me (even though it's only a few extra characters and they have methods for chained access).
That's fair, I always find it interesting what feels heavy to different people 'cause it can differ so much. 
According to my model, it is not. (Well, ignoring signalling NaNs for a second here.) Whether pointers can alias is based solely on whether they are &amp;mut or &amp;, not on the target type.
`#![deny(missing_debug_implementations)]` edit: I see you mean that you wish that crates.io would disallow uploading packages, not just how to do it yourself. I could imagine this lint going to `warn` and eventually `deny` by default... Although I bet a lot of people disagree.
Interesting. This is UB in C, and _may_ be UB in LLVM if TBAA is being run.
There are (annoyingly) some builtin types that aren't `Debug`. The most recent one I've had to deal with was function pointers.
taking care of a few new issues with the notify-rs library, and digging into the Inotify man pages and source code to figure out how it does or doesn't work
C++ doesn't have customizable precedence, which I thought was the whole thing this article was about?
It would be nice if they had something like Serde's [attributes](https://serde.rs/attributes.html) that tell `derive(Debug)` to skip a field. Something like #[derive(Debug)] struct Foo&lt;T&gt; { bar: i32, #[debug(skip)] baz: SomeNoneDebugType, } would be super helpful.
 fn load_program(&amp;mut self, path: &amp;str) -&gt; Result&lt;i32, &amp;str&gt; { let file = File::open(path); match file { Ok(f) =&gt; { let mut byte_count = 0; for byte in f.bytes() { if byte_count &gt;= MEM_SIZE { return Err("progfile too large"); } self.memory[byte_count] = byte.unwrap(); byte_count += 1; } return Ok(byte_count as i32); }, Err(e) =&gt; { return Err(e.description()); }, }; } getting: &gt; `e` does not live long enough Wouldn't `e` get killed at the end of the match arm scope? Why can't I call a function on it to get a value and take that value with me? *edit*: weirdly, I just fixed this by returning a String in the result rather than a string slice. I'm...not at all clear on why that works. *edit2*: is it because the string slice is on the stack, thus I can't take it with me?
I did try clojure a while back.. and I did enjoy it more than other lisps; (i remember reading the opinions of 'traditional lispers' who hated it.. but i thought their use of [] {} was still close enough to the original spirit.. I also remember lispers telling me not to write a "(pipe ..)" macro, conversely clojure had that out of the box (-&gt; ..)/(-&gt;&gt; ). I write a bit of e-lisp to customise emacs.. I really wish elisp was more like clojure. maybe I should try it again sometime, but haskell seems more interesting to me now
The value is a `&amp;str`, which references the data stored in `e`. That's why you can't take it with you (without cloning it into an owned `String`).
Github is able to show the images, somehow. Anyway they are huge and break formatting. I filed a PR to replace them with emoji.
ah, makes sense.
Requiring the Debug trait can provide some safety restrictions. For example, a circular data structure may trigger an infinite print loop, while its Debug method provides a selective print of just the unique elements.
I'm porting our Speedrun Timer from C# where it was tightly coupled to the Windows API, to Rust where it is now automatically cross compiled to 38 of Rust's Targets via Travis CI and AppVeyor. The goal is to write the majority of it as a UI independent library, that exposes a C API where a little generator I wrote automatically generates High Level Bindings (i.e. with garbage collector integration, classes, ...) for about 10 additional programming languages atm. The actual main UI is written in TypeScript + React at the moment, but this may change once Riot Games' release their webrender based UI library at the end of the year. Click here to check it out (right click to access the menu): https://cryze.github.io/LiveSplitOne/#/splits-io/1dwk This is running entirely in your browser without any server side code. It's about 1.5k lines of TypeScript and 16k lines of Rust compiled to asm.js. Interestingly since the binding generator also generates Node-FFI bindings, the exact same code can be run locally via Electron, where the Rust code is running as native code.
It was my understanding that TBAA is done by the clang frontend and just results in a whole bunch of noalias annotations, which is then sued as basis for optimizations on the LLVM IR?
To clarify: That's what [Emscripten](http://kripken.github.io/emscripten-site/) already did. It provides a complete environment, including filesystem and network socket abstractions that actually work from the Rust side as well.
LISP and stack programming languages of course resolve all precedence questions, but generally speaking the precedence is not a burden on the programmer. It's about the level of cognitive load of deciding whether to add or multiply first in a mathematical expression, and the rules are fairly well understood by practitioners.
Are you looking for something like [this](https://play.rust-lang.org/?gist=74b333cb69c53204c397aca665b72876&amp;version=stable)? fn main() { let mut arr = [0; 16]; let slice: &amp;mut [i32] = &amp;mut arr; let slice_len = slice.len(); for i in 2..slice_len { for j in (i * 2)..slice_len { println!("i: {:?}, j: {:?}", i, j); // &lt;your mutation here&gt; } } }
Operator precedence was established for multiplication and addition in the 16th century, [allegedly](http://jeff560.tripod.com/operation.html). Modern precedence rules were established in C and used in most commonly used subsequent languages. Changing them, even to a "better" scheme is like changing the QWERTY keyboard - it isn't going to happen. 
Ah, perfect. Not our problem then :)
My understanding was that the stdlib emulation in Emscripten is limited, but maybe that has changed since I last checked.
It would be nice if the stdlib formatters accepted something like `{:?!}` which is basically "give me debug output whether you have it or not"!
According to itself, the language is about precedence in general, the only restriction it makes is "languages with conventional operators" which I assume to mean infix binary which is what the essay goes on to discuss: &gt; I’m going to use C++ as an example throughout this post, but this applies to any programming languages with conventional operators. Languages with custom operators (and thus usually customisable precedence) seem to be in scope of the discussion. Languages without "conventional operators" like Lisps or stack-based languages, however, would not be.
We applied to a new microkernel category with a few submissions, they accepted, and given slots over the other microkernel submissions. Redox somehow stole the thunder from other long-running microkernels in development that also applied for the new category.
JAI kinda seems like the Star Citizen of programming languages.
&gt; Modern precedence rules were established in C and used in most commonly used subsequent languages. Changing them, even to a "better" scheme is like changing the QWERTY keyboard - it isn't going to happen. Erm… many languages (Rust included) have fixed C's inane bitwise precedence, there are languages which eschew precedence between binary operators (Smalltalk or APL for instance), and there are languages which don't have a total precedence table (Swift has precedence groups which don't have to be ordered with respect to any let alone all other precedence groups).
Oh damn. I just came across linked-hash-map looking for an insertion ordered set. It would be nice if there was an easy way for crates to reach out to their downstream users when they are swamped/need maintainers.
I said commonly used :-). No precedence at all is a different thing. Forth (which is used more often than you think...) avoids it by using RPN. 1 2 3 * + 
They're displaying on Github because they seem to be different images in the preview. I think Github just downloads them and then replaces the URLs on the fly. E.g. [this one](https://camo.githubusercontent.com/d77897f66c101932f81c57b00f6ec8d6ee7dc844/68747470733a2f2f63646e2e646973636f757273652e6f72672f627573696e6573732f696d616765732f656d6f6a692f656d6f6a695f6f6e652f62616c6c6f6f6e2e706e673f763d30).
[removed]
Nice idea! But your implementation is pretty inefficient. With the recursive call, you compute the same numbers over and over, which leads to an exponential blow-up (to compute the 100th Kola number, you recompute all of them up to the `self.run`th one, and for each of those you also recompute them all up to their `self.run`ths, etc.). On my computer, `cargo` benchmarks the computation of the first 100 numbers with your algorithm at ~ 7ms. In the same time, with a more efficient algorithm, I can compute the first million numbers :P I could show you my code, but I thought that you might prefer to find it by yourself. If you want a hint, it is not a bad idea to store all the previous numbers in the iterator. P.S. Have you heard of `cargo fmt`? ;)
The first question is always "How do you keep this from breaking existing code", so any finalized solution should wait until [RFC: Evolving Rust through Epochs](https://github.com/rust-lang/rfcs/pull/2052) is finalized. Otherwise, you'd overly constraining what's possible, just to satisfy non-breakage restrictions that'll probably go away anyway.
I wonder if this would make sense to build into cargo. Perhaps a "deprecated" or some other flag that gets included as a build warning and is posted on crates.io. I always hate it when a dependency gets unmaintained and I end up finding out months later when I come across a bug, want to file a feature request or even submit code. This leads me to replace the library in question when a little maintenance on my part could have kept the project from failing.
The CSP is set by the server serving the html not by `cdn.discourse.org`. If you change the response header coming from `this-week-in-rust.org` to allow `cdn.discourse.org` everything should be fine. the problem is from their side, not from discourse.
I had to make a trade-off between recursion and storing large amounts of previous numbers. To store enough numbers to compute up to `usize::Max`, I needed the struct to have a `[u8; usize::Max / 2]` (or close to). This is obviously not acceptable. I chose recursion because it's cap is soft (any storage of numbers would make a hard cap). Don't worry about me for uploading your code, it's always good to see how other do the same things you do! I don't like `cargo fmt`'s style. putting open braces on the same line is gross.
I'm making a little toy that will eventually let me simulate basic evolution and group dynamics. I want to give it a couple creatures that interact with basic behaviors, then let it run for a while and see what pops out. It started as a generic celluar automata engine, but it doesn't really follow the normal cellular automata rules about processing the next state. I was originally building it as a [web app](http://picklenerd.com/mylittlehab/) but I was running into performance issues and didn't want to put all of my effort into optimization, so I decided to remake it in Rust. It's tricky but I'm having fun and it's been a great way to learn the language!
/r/rustjerk
i see my memes are unwelcome here
Or have non-Debug fields always skipped. The only case where you don't want to skip them is when implementing Debug by hand, but then you're not using derive.
I had some weird bugs with jsfiddle where the cursor wouldn't line up with what I clicked on. I'm not sure where the bug lies, but it seems to go away when I refresh. This is on Linux with a pretty recent nightly. I'll see if I can reproduce it so I can submit a bug.
I don't know if this would be possible. I say this because procedural macros (aka custom derives) are only aware of the current type it's generating `impl`s for; it has no type information of anything else. On the other hand, it's possible there may be some ~~black magic~~ behind-the-scenes code in play, because a) the compiler is able to specifically tell you which members are not `Debug` b) the pretty-print debug format just pretty-prints automagically, unless you implement `Debug` manually. I haven't been able to find a way to override the pretty-printing, which means it's probably being done under the hood. Of course, if I knew where to look in the compiler source, I'd go there and try to figure it out myself. ¯\\\_(ツ)\_/¯
Just have an implicit default implementation for Debug that does nothing (Or just says `field: [...]`.) Sort of like how `Drop` works.
i think "last update time" would be nice
Does it go away if you turn off stylo? That sounds like a regular nightly bug, not stylo related (but ICBW)
I find `replace` more commonly useful than `swap`; where you’re simply wishing to get at the old value of a variable in order to immediately use it elsewhere, `replace` is what you need. Despite `swap` being the actual primitive operation on which `replace` is built, `replace` is by far the more useful of the two, because most places where you want to use one of them, you’d need a temporary variable to use `swap` because `replace` has the semantics you want.
It is a bit redundant to defend the *status quo* merely on the virtue of it being the *status quo*.
I wonder why nobody has come up with the idea of user-defined-yet-unnameable objects yet? Maybe the folks involved at [Malbolge](https://en.wikipedia.org/wiki/Malbolge) could get on board with it, if the Rust people don't buy in for some reason. In all seriousness, there's no reason to not give your macro a name. People could use it to disambiguate and communicate, and they're going to call it *something* even if it has no name.
u have hackatons at work ?? :(
any plans to stabilize api?
no you are not. but i think we should use it with caution
Ok, but I find that you have rather strange ways to make trade-offs… Computing the 250th number with your algorithm takes already 45 seconds on my computer, and if I am correct on the `exp(sqrt(2n))` function calls that you need to compute the `n`th number, you can expect a few thousand years to compute the 1000th number. I'll let you make the estimate for the `usize::Max`th… My code: pub struct Kola { l: Vec&lt;u8&gt;, i: usize, r: usize, } impl Kola { fn new() -&gt; Self { Kola { l: vec![1, 2, 2], i: 0, r: 2, } } } impl Iterator for Kola { type Item = u8; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { if self.i &gt;= self.l.len() { let p = 3 - self.l[self.l.len()-1]; for _ in 0..self.l[self.r] { self.l.push(p); } self.r += 1; } self.i += 1; Some(self.l[self.i-1]) } }
There currently _is_ no (up-to-date) grammar for Rust. [RFC 1331](https://github.com/rust-lang/rfcs/blob/master/text/1331-grammar-is-canonical.md) proposed changing that, and making the grammar canonical, but has not yet been fully implemented. I'd suggest following the [tracking issue](https://github.com/rust-lang/rust/issues/30942) for it.
Professionally: A Windows executable that manages the java environment used by the client application we ship. Basically the initial stages of application bootstrap.
GUI with Rust isn't fun right now, in my opinion. GTK or Conrod are your best bets. There aren't a lot of mature options right now. We need better GUI libraries, plain and simple. [Relm](http://relm.ml/relm-intro) is under development.
I was actually just trying out Relm right now. It's model backed and uses GTK (which should be able to give me XWindow handles to draw on). Wish I could get [this example](https://github.com/antoyo/relm/blob/master/examples/include.rs) to run, since it look like what I'm looking for. Unfortunately, I get "custom attribute panicked" on the #[widget], even with nightly at latest git versions of relm. Trying to figure out if it's just my setup.
&gt; [...] wherein I was contractually barred from even responding to comments on our issue trackers (the Apache license has interesting provisions about official communications). I had to look at [the License](https://www.apache.org/licenses/LICENSE-2.0) again to see the following definition: &gt; "Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to **communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work**, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution." (Emphasis mine.) Therefore any comment to the issue tracker and mailing list would count as a "contribution", and a company that strongly prohibits any form of contribution has some official extents to do so for projects using the Apache license. *That's* interesting.
They are welcome, just not (always) in this sub :)
Console-based utilities on Windows that were either previously written in python but needed to be fast or previously written in C but needed to be readable.
(relm's author here) I can compile this example with latest nightly and latest git version of relm. Can you give me the complete error message, please? Usually, there's something more that will tell me what's wrong. Also, are you able to compile a simpler example, like `buttons-attribute`? (By the way, do you compile the example by running the command `cargo run --example buttons-attribute` from the git repository?)
Bug report: when I have a bunch of pages with web fonts loaded and I load another page of my own crafting which has a restrictive Content-Security-Policy, the web fonts from all these other tabs (MDN web docs, Bugzilla, *&amp;c.*) produce CSP errors. The error is resilient to page reloads. Turn off `layout.css.servo.enabled` and the spurious CSP errors go away.
*Please* comment in the internals thread, so that we can keep discussion all in one place!
Well, I'll consider your ideas, especially because it should be a completely non-breaking change.
I think it did, but I'll confirm tonight or tomorrow. It seems unlikely to be a Stylo bug from what I understand of the browser stack, but I'm not sure.
Huh, that makes me want to remove the Apache licensing on my own crate, Rudy.
When I was in high school and had a few years of programming experience, I spent way too much of my time inventing strange binary formats to store custom files. I didn't know what JSON was and I didn't like XML. I probably would have made it much further along in the hobby games I tried to make if I hadn't obsessed over that. &gt; There are libraries to do this sort of thing in C/C++ but I've never used them, perhaps because importing a foreign library and managing that dependency is a significant amount of work in C/C++ This is one of the key features of Rust for me, you can get speeds close or equal to C++ but with the ease of library integration of a scripting language.
Perhaps [ordermap](https://crates.io/crates/ordermap) would fit the bill?
It's not totally clear to me that these crates _need_ maintainers&amp;mdash;they could just be "done". Especially for smaller amounts of code, it's totally possible for software to be done. As long as it does what it claims and there's someone around to apply security fixes if needed (which it sounds like there is), you don't need your software to be undergoing active feature development to use it.
So, how do you version your struct? Load old data files?
Yep, that's the clause! Very curious, but honestly I think it makes sense if it does what I think it does: removing serious procedural ambiguities. Like if someone says "oh you can fix this with `&lt;code snippet&gt;`", there's no question on if that code's actually been given to you to use in the codebase. Although idk how that works in a dual-license environment.
Rust's grammar is context sensitive by the way. Only in one spot, most of it requires less power, but still.
Rust is generally doing quite well for developer ergonomics, and is constantly improving which is great.
This will help once it's implemented --&gt; https://github.com/serde-rs/serde/issues/745
I can think of at least one way: If you think you're going to readjust your file structure lots then add a version number as one of the properties and use an enum match at the top level in serde
Yes, I too believe this definition is due to a good cause. Probably you can avoid this by marking every comment with a remark that it is not a contribution, but if a company really wants to forbid the act of contribution, well, it won't like such a try anyway.
Are you one of the LiveSpilt devs? If so, thanks. It's great software.
What spot is that?
Raw string literals.
Working on an async version of discord-rs. I've got it connecting and receiving events, just need to restore all the functionality I removed getting it working now...
Although it can seem annoying, I feel like it's working as advertised. 
Hmm, recursive versions are nice, but have downside of requiring more memory, potentially overflowing the stack.
https://github.com/rust-lang/rust/tree/master/src/grammar
I think those are recognizable by mildly-context-sensitive formalisms (such as Range Concatenation Grammars), so it's not even all the way to CSG. EDIT: Yeah, an RCG could definitely do it: RawString(`r` x `"` y `"` z) :- Pounds(x, z), RawContents(y). Pounds(`#` x, `#` y) :- Pounds(x, y). Pounds(``, ``) :- ε. RawContents(x) :- ε. RCGs are super cool, since they're basically "Parsing with Datalog" (and exactly characterize the PTIME-recognizable languages, while being closed under just about everything)
You can write a custom deserializer that handles this. It's not hard. One could conceivably have a crate that helps with this.
Yeah, I ended up editing it a couple times - it should be correct now.
Thanks, sounds like https://bugzilla.mozilla.org/show_bug.cgi?id=1384741 / https://bugzilla.mozilla.org/show_bug.cgi?id=1384275. I'll look into these font-related problems soon.
Then how you're able to write this comment?
*finger hovers over "wrong subreddit" button* … you may stay. ;-)
Just follow the book? I mean rust has an official "book" website. We need feedback to make it better. Instead of hunting down blog posts, we should focus on getting the official book to be good for new programmers assuming no prior knowledge as well. 
I'm thinking of there's something we can't explain then we don't understand it well enough. Helping write/edit a book for new programmers will help strengthen our own understanding. 
&gt; I wonder why nobody has come up with the idea of user-defined-yet-unnameable objects yet? .. like operator overloading ? The point is the square brackets are 'premium syntax' , and I consider their current use to be a waste. If I want 'a few T's alongside each other in memory' , I can use a tuple. The use wouldn't leak, unlike in C++, because there's no header files. I don't see the problem here. there's many potential superior uses (like the list-comprehensions).. generating sequences. I associate the [..] more with a variable size object due to JSON, and we already have the precedent of (..) being a fixed size object (e.g. in haskell) 
&gt; "How do you keep this from breaking existing code", ... by making the default ```array![]``` , and constraining the use by the module system. if for some reason you're happy with [1,2,3] doing something almost exactly the same as (1,2,3) .. great, keep doing it, I wont stop you.
well sure the epochs will make it easier.
For most languages, my go-to solution for this is Protocol Buffers, which supports serializing to its binary and text formats as well as JSON. Though, the Rust bindings for Protocol Buffers are still not as mature.
Writing a book for new developers is going to be a very different project from what the current book is.
It would be nice to be able to update the same book as the language and the "ecosystem" evolves though. 
For those coming here for the comments and not willing to dig up the link, here it is: https://internals.rust-lang.org/t/revisiting-rusts-modules/5628
This. It's a good compromise, simple to implement and effective (not only for this use case,) and it's coherent with other derive implementations (Serde.) Somebody should open an issue or something. I think automagically avoid non `Debug` fields would require too much work on the compiler.
Ah, I see. Now I understand. Sorry, I just assumed it was supposed to be set on the origin domain.
Uhm... this reddit post contains exactly that link ;-) 
I feel stupid now LOL Found the link on aturon's blog, came here for the comments and didn't click on the actual link! Thanks for pointing it out :P
Is it still under development? Commit frequency dropped to almost nothing after early May. Or it did reach production ready status?
Good question! ...of which I do not know the answer to. My guess would be that it would lead to some ambiguous or otherwise surprising situations, I am failing to come up with an example though. Maybe /u/steveklabnik1 knows more about this?
A simple [JWT issuing authentication server](https://github.com/lawliet89/rowdy) for microservices based on Rocket, and for that, I've written the following libraries - [A JWT library](https://github.com/lawliet89/biscuit) - [A CORS library for Rocket](https://github.com/lawliet89/rocket_cors) Previously, I build this tool to [build PRs from Bitbucket on TeamCity](https://github.com/lawliet89/pr_demon), and from that, I built [another tool that creates `/refs/pulls/xxx/merge`](https://github.com/lawliet89/fusionner) like commits on Github.
I dunno, I kind of like the way it is now. I wouldn't mind if it was changed, but I also wouldn't mind if it wasn't. Nothing in this proposal seemed like a must-have to me. Proper first-class modules though, that'd be something.
I agree the learning curve is higher than it needs to be (issues like the relative/global flip), and other module systems look more intuitive; but I don't know how to fix it. i think i would be happiest to see new features that mean the extra complexity of the module can be leveraged in other ways (e.g module-wide type-params)
A commentor on the article page is pointing out an important thing to consider: The moment you need to do something outside of the scope of the library you're out of luck. Trying to add that feature to the library often is a viable solution, but some requirements are so specific that others would be unlikely to benefit from them being incorporated in the library. Now, Im not saying theres anything wrong with serde, its an amazing library. However, saying that it is the solution to every serialization-problem is probably not a healthy attitude.
Mine is SQLite because every other option I've tried has required that I reinvent something SQLite gives me for free in order to maintain the mixture of performance characteristics and safe failure modes that I need. That said, I also have a lot of legacy data that's going to need to be converted over.
I want to stream programming, but my PC slows down with software encoding :/ and I've been unable to do hardware encoding with OBS Studio.
&gt; I probably would have made it much further along in the hobby games I tried to make if I hadn't obsessed over that. Don't underestimate what you've learned by doing it yourself in the wrong way. ;) 
never used it, but I think the mockito crate is what you're looking for
Are there streams for any other programming language? I've never heard of programming on twitch.
That's a weak argument, considering it's very possible to write difficult-to-read code using existing operators (e.g. a chain of `&amp;&amp;` and `||` with no clear structure). If anything, it might be clearer to allow expressions like `a + b + c` and `x &lt; y &lt;= z`, but disallow expressions like `a + b * c` and `f &amp;&amp; g || h`.
&gt; That's a weak argument, considering it's very possible to write difficult-to-read code using existing operators "It's already possible to write garbage" doesn't even rise to the level of "weak argument". &gt; If anything, it might be clearer to allow expressions like `a + b + c` and `x &lt; y &lt;= z`, but disallow expressions like `a + b * c` and `f &amp;&amp; g || h`. That can still give rise to inconvenient expressions, at least in Python e.g. `a in b in c`.
There's a [game developer](https://www.twitch.tv/jessicamak) I follow on Twitch and sometimes watch her streams when I have the time, but she programs in C++ not in Rust.
Yeah, there's some interesting streams actually. Check the [programming](https://www.twitch.tv/communities/programming) community
The handmade hero stream is pretty awesome 
i strugled with modules, i really didnt haave problems with c# namespaces, but i dont know how would it be implemented in russt. im ok with current system but could be better
So you're suggesting that a major and common part of the language can change syntax and semantics *entirely* depending on which module I'm using it in? If you want sequences with decent syntax... write a `seq![]` macro. People can look it up in documentation, figure out what it does, and be guaranteed that they can use it in another module without breaking all their existing code in that module which assumes `[]` does something different. If I wanted a language which essentially changes the entire language on a per-module basis, I'd be writing in something like Racket. Changing the language on a per-module basis is going to confuse anyone reading my code. There's also the fact that you can't import a macro for a specific module - macro imports can only travel "upwards", and then are available for all submodules. So if I wanted to use a definition of `[]` from another crate, my entire crate would have to use that definition. Finally, a tuple is not logically an array, and can be packed differently, be rearranged in memory, etc etc. There is absolutely no guarantee that `(T, T)` is the same thing in-memory as `[T; 2]` or the thing `Vec&lt;T&gt;` points to.
Yeah I'd suggest ordermap as well, it's an excellent general-purpose hashmap *and* naturally ordered, with much better iteration behaviour than a linked hashmap as you're just iterating a dense vector instead of chasing pointers.
I strongly dislike the idea of moving too much of the knowledge about modules to the file system. I have never liked working in languages which do this because I feel it makes code harder to read, especially when one is new to a project, due to people splitting code into way too many small files. I also like when files mostly are standalone without having to always look at the directory structure to understand what this code does.
&gt; .. like operator overloading ? Why not literal overloading or initializer list construction?
Sqlite is a much better option. This is what it was built for.
You forgot the pony :-)
Just dropping this here. Meta parsing https://github.com/pistondevelopers/meta
[rust-derivative](https://github.com/mcarton/rust-derivative) has a Debug derive that knows how to do this
&gt; I feel stupid now LOL Please don't. Thanks for trying to help others being more lazy \^_^
In racket: field access are enabled by macros: separated by "-".
I really want something like protocol buffers that supports ADTs! Using Protocol Buffers forces you to model all of your data in a really unsatisfying way.
c++ initializer lists are good point of reference for why I think the behaviour of [ ... ] could be user defineable I suggest a macro (the opportunity for custom syntax in list comps etc seems good) but maybe it could even be turned into some sort of n-ary operator
You probably want this method: https://docs.rs/rayon/0.8.2/rayon/iter/trait.IndexedParallelIterator.html#method.collect_into However, if you just want to copy raw memory from one place to another, parallelization probably won't help at all. This task is not CPU-bound but memory-bound. The speed of RAM in a typical consumer machine is around 10 GB per second - and that is your speed going to be regardless of parallelization. The story might be different with NUMA architectures, though....
&gt; So you're suggesting that a major and common part of the language can change syntax and semantics sure . macros can do all sort of crazy things already, I'm basically suggesting [] becomes a shortcut for 'a crate wide favourite macro'; as another point of reference see what they've done with 'std::initializer list' in c++. and phase in the alternative of array![] for plain old arrays; this comes in conjunction with a suggestion to bring back (T;N) 'tuple repeats' .. i.e. beef up tuples to handle the fixed array case and maybe even purge [T;N]. [T;N] wont be needed so much when the language eventually gets 'pi-types'. this has precedent. other languages have better uses of the square brackets: swift has literal vector/map syntax, python has listcomprehensions, haskell can redefine their use for pattern matching on other types. I think what would happen is a common widespread use would emerge. (if i had to guess, the list-comp shortcut sounds like it could be the most useful), but with the ability to distinguish something visually obvious like [ =&gt; , =&gt; , =&gt; ] I can see it handling multiple constructors in one. I'm not saying that we don't need literal arrays , I'm just saying that *alongside tuples* (which do handle similar use cases to 'very small arrays') the premium syntax will be more efficiently used elsewhere
&gt; "There is absolutely no guarantee that (T, T) is the same thing in-memory as [T; 2]" I can understand that if the types are different, but if thee types are the same .. most of the time that I actually might want to consruct such a small array, (n=2,3,4), the tuples seem just as good. it's probably something so small you're expecting iterations to inline. anyway I'm not proposing eliminating [T;N] (just yet ..there's another post about that), I'd choose to use array![...] as a dedicated constructor for those, to keep the option.
This is weird advice. It does not consider the readability of the text format (which is crucial, because if you don't care about readability, you might just use a binary format). For example tables of numbers are terrible in JSON. 
I don't get it
I'd suggest something along the lines ofThrift, Protobuf or CapnProto. All these allow you to define fairly complex structures, auto-generate serializers and deserializers and allow for forwards and backwards compatibility (as long as you follow some simple rules while designing your schema).
The new development is in the [`feature/futures-glib` branch](https://github.com/antoyo/relm/tree/feature/futures-glib) since it is based on the new design that does not require 2 threads. Currently, this branch does not allow to work with network-related tokio crate, hence why it is not merged in master. I was waiting for this [PR](https://github.com/tokio-rs/tokio-proto/pull/172) to be merged and released (before merging this branch to master) and it was merged yesterday. Now I wait for its release and [its integration into hyper](https://github.com/hyperium/hyper/issues/1274) so that I can use hyper in the http example. So, yes, relm is still under heavy development.
Generic modules and first class modules would be really nice.
Glad to hear that. :)
there are dozens of us! dozens!
I think it's less "just use JSON" and more "just use Serde." For tables of a numbers, you can use CSV with has serde support. :-)
There's a Programming Community and a Game Dev community which are usually pretty small Links: https://www.twitch.tv/communities/gamedevelopment https://www.twitch.tv/communities/programming
i am of mixed opinion, the directory structure exists: it makes sense to leverage it. on the other hand , do rust projects just end up ```use ..::*```-ing a lot to flatten things out a bit (I *always* do 'use super::*')
I'm very skeptical that anything the linked blog post talks about is really a problem, but this quote stands out in particular: &gt; it was impossible to predict anything about the public API surface just by looking at the file system organization; you have to trace re-exports. That's great! That's perfectly intended! It means the implementation can be reorganized as the authors see fit while still maintaining perfect backwards compatibility! I also don't understand why the filesystem structure of the code base even _should_ be reflected in its public interface. If you want to browse the latter, the correct place to go is the rustdoc. The code tree is only there if you need to understand the implementation (which, like I mentioned earlier, may need to be massively different than what the API would suggest).
Thanks for the tip! I've tried it and it's really nice. And now I'm finally learning to use a plugin manager for neovim. I have to say it's already pretty cool, although I still have to get used to it, and read through all the plugin docs \^\^
&gt; I also don't understand why the filesystem structure of the code base even should be reflected in its public interface. then does that point to the existing relationship between modules and files being sub-optimal. I keep pointing out that we often see things like ```vec::Vec```, ```hash_map::HashMap```, ```option::Option``` ; its like the c++/java idea of the class being the primary entity trying to resurface (is the thing you're interested in ```mod vec```, or ```struct Vec``` ... a class has aspects of both). one suggestion i have is for a file to be able to declare a primary entity which is exported at the same level as the file, instead of the reference to the file then having to re-exporrt that entity (e.g. 'vec.rs: ```struct super::Vec{}```'? or ```struct self{}``` .. turns 'vec' into a struct with a namespace associated.. ). if the names were related/constrained, this would be collision-free. 
I don't actually know!
Couldn't we just turn mod vec; pub use self::vec::{Vec, Other, Stuff, some_fn}; into inline mod vec; which would have most of the benefits introduced in the solution of the post, but without all the magic (Alternatively any other (contextual) keyword, like `reexport` or `flatten`)
my idea was ```use mod vec```, fusing the existing use / mod keywords in behaviour and intent.
Actually yeah, I like that even more :D
[cedar](https://github.com/jtomschroeder/cedar) is another option. (I'm the author - it's still in an alpha phase)
I think the unsatisfying answer from me to you is that I don't *really* consider it a problem. Error handling is easy to gloss over to the detriment of your users. For example, I had a [request](https://github.com/BurntSushi/ripgrep/issues/444) to give better error messages, and because I glossed over the details, I ended up having to thread [more information through my errors](https://github.com/BurntSushi/ripgrep/commit/c50b8b4125dc7f1181944dd92d0aca97c2450421). But I was happy to have Rust when I did this, because everything is nice and explicit. Another thing you might consider is that instead of writing out the strings for your error messages when you generate the error, that you instead return *structured* errors. Structured errors are probably shorter to type than the full error message. What I mean by structured error is to define your own `Error` enum with variants for each error message. I've been known to go [hog](https://docs.rs/snap/0.2.2/snap/enum.Error.html) [wild](https://docs.rs/regex-syntax/0.4.1/regex_syntax/enum.ErrorKind.html) with this approach, but I like it.
You can reduce all the bloat using just `?` and the `error_chain` crate. let a = b()?; You won't get a good error message this way, though. If you want a custom error message, you have no choice but to use the last approach. But to be honest, most of that line is the error message, which you can't avoid in any case. 
You're asking for more code, with no cost and a smiley so I figured you knew you were asking for something that's not really feasible. (More code will have a cost. Non-machine code is also code, even if it's stored in the metadata of a crate.) Wishing for a pony appears to be the idiom for slightly impossible wishes: https://blog.codinghorror.com/and-a-pony/
&gt; except optimized away when completely unused I think that makes it no-cost if you don't use it...
I ninja edited my comment, to say the part in (). Adding #[derive(Debug)] to every type in a crate will increase its compilation time.
Hmmm... True. Thanks for the clarification. That's something to consider.
I'm following along with it in Rust though... I program enough C in my day job :P
Check out [cauterize](https://github.com/cauterize-tools/cauterize) + [caut-rust-ref](https://github.com/JayKickliter/caut-rust-ref). The documentation is almost nonexistent (sorry), but it's used in production from the cloud down to bare-metal systems.
I'm not sure I really see the point of overloading `[]` when anybody (not just the core language team) can write a macro that accomplishes all of your use cases: - literal vector: `vec![]` (in `std`) - literal map: `hashmap!{ "a" =&gt; 1, "b" =&gt; 2 };` (in [maplit](https://crates.io/crates/maplit)) - list comprehensions: `let even_squares = c![x*x, for x in 0..10, if x % 2 == 0];` (in [cute](https://crates.io/crates/cute)) - etc
Well from a browser. I can access the internet through a proxy, which browsers are set up to work with, but I have not been successfull in using anything else (I did try with pip &amp; curl to no avail).
That's how you do it, just use the name of your own crate (as listed in Cargo.toml). It doesn't have to be published. I'd guess you are either using the wrong name, or don't really have a library (you should have src/lib.rs, not src/main.rs).
I'll leave it to you to define the semantics of `a in b in c`.
I my opinion error handling is part of the "actual logic". Dealing with failures of any kind is a part of programming and shouldn't be ignored or pushed away. Especially in networked programming dealing with errors is a part of your logic, because failures are to be expected. You wouldn't want you browser to crash just because a page couldn't be loaded would you? Forthermore any error handling shouldn't make the code hard to grasp, even on first sight. If the code is hard to grasp with error handling it could be a sign that the code could use some cleanup (or of the course the subject is just hard to grasp).
I'd say that Rust-with-error_chain is pretty much as good as it gets in terms of error handling (though not quite perfect, you never know if someone has slipped a `panic!()` somewhere...). You get explicit error messages, you can have module-specific errors and easy wrapping/matching on inner errors... It's really terrific.
I find that having `pub(self)`, `pub(use)` and `pub(crate)` is confusing. The approach I prefer is to infer the `extern crate` and `mod` statements from the `Cargo.toml` and file system respectively.
Once again the semantics are straightforward (it checks that `a in b` and `b in c`), the issue is in the wetware.
That sure makes it sound like they're adding something like rust's ownership model to .NET for semi-manual memory management.
You never know if you might need to import your stuff into another language. JSON is easy to import for any platform.
Just to counter all the posts in this thread, I also find Rust's module system very confusing. One way to say it is that it has a lot of complexity in terms of conceptual surface for not a proportionate amount of utility. In my own app I also accidentally invented the facade pattern after running into similar issues as described in the blog post.
Anyone else think it's a little weird there are no references to previous serious and much-discussed proposals around this topic? Like [this one](https://withoutboats.github.io/blog/rust/2017/01/04/the-rust-module-system-is-too-confusing.html)? Or any reference at all to how other languages work?
That's not what I'm reading: &gt; To allow safe concurrent sharing of manual objects we introduce the notion of shields. Accessing a manual object requires getting a reference from a shield, which creates state in thread local storage that prevents deallocation while the object is being used. Shields can only be created from the unique owning reference, thus when the reference is destroyed no more shields can be created and memory can be safely reclaimed once all previously active shields have been disposed. My interpretation is that these manually allocated values have a single owner and when the owner drops the value, the allocation is marked as "dropped" so no more references can be created and the actual memory is only deallocated once all references are dropped. You get a runtime exception if you try to use a reference whose value has been dropped. They also describe all sorts of techniques to make this more performant (lock-free access management, no stop-the-world synchronization when deallocating). Disclaimer: I only read the first chapter and have no background of the subject matter.
How about [Cap'n Proto](https://capnproto.org/language.html)?
You can hack it today with `include!("vec.rs");`
I was trying to copy the code into a test project, so I suspect it's a configuration issue on my end. Will try running via --example tonight.
Cedar looks interesting and heavily inspired by Elm. It looks like it shares a lot of style with Relm, though more "web-inspired" with all the function chaining. What are the differences in the approach that led you to develop Cedar vs. working on top of Relm? Not diminishing the effort at all, just curious :)
Yes, I should've linked back to withoutboats's earlier post; we've been working together closely on this topic since before that post. I'll fix the post. **Edit**: fixed. As to referencing other languages: I think that's definitely worth writing up in detail at some point (and I've certainly been thinking about other languages!), but as I said in the post, my main goal here was to lay out what I see as the problems and *one* plausible approach. Was there any language you think is particularly relevant?
I strongly agree, I find the `pub(use)`, `pub(crate)` as forms of implicit scoping which by far are anti-patterns. Before, I would know that any exposed parts of a crate would be in `lib.rs`. But with `pub(crate)`, this would mean that there could be an exposed definition deeply embedded within the module tree.
If you can get webrender to put the state back to how it found it you could use [Context::exec_in_context](https://docs.rs/glium/0.17.0/glium/backend/struct.Context.html#method.exec_in_context) to issue the webrender draw command then restore the state. I think you'd be better off implementing a glium backend for webrender though.
It's more like *Crossbeam for C#*. Project Snowflake allows you to completely sidestep the GC. Then you can allocate objects on the heap, share them among multiple threads, and finally safely destroy them. This already sounds like a GC, but it's a very special one - the imporant characteristic is that it does not trace the object graph nor update reference counts. Long story short: the underpinning ideas are very similar to Crossbeam's. They use a combination of epoch-based memory reclamation and hazard pointers, with several tricks peppered on top of all that, all packaged behind a nice API that encourages correct use by leveraging the type system. If you're interested, I've written a slightly [more detailed overview](https://github.com/crossbeam-rs/crossbeam-epoch/pull/3#issuecomment-318382073) of the paper in Crossbeam's issue tracker.
(relm's author here) The code generator only calls `show()` and not `show_all()`. To be able to see the menu, please add this call `menu_bar.show_all();` at the end of `MyMenuBar::view()`. Also, thanks for telling my that menus do not work with the `#[widget]` attribute. I opened an issue to fix that.
awesome, thanks. It's working now. Also was able to shorten the struct down to: struct MyMenuBar { bar: MenuBar, } and it works fine.
HDF5 is what you should have used. It’s an actual shame that people don’t know about it.
&gt; I also don't understand why the filesystem structure of the code base even should be reflected in its public interface. Uncle Bob Martin usually rants about how software design is lacking architecture [design]. He usually remarks that if he looks at a floorplan of a building he can see what kind of building it is, how big it is, how traffic will move through it, etc. And how hard that is when we look at a software source code repository. How files are everywhere, blablabla. Of course, that's not even an analogy, that's just yeah, virtual apples in cyberspace and a pair of toothbrushes in your nose, completely different things, making you look silly, but if you do it long enough people will think about it for a bit. There's a point, but I don't know what. So, with modules, there's some inconvenience, some error prone aspect of code organization, but it's not simple to even articulate the problem.
`cedar` contains a *virtual DOM*-like implementation for diff-ing and patching the internal view based on the declarative `view` defined by the user (in terms of the model). This allows for a declarative (i.e. simpler/cleaner) composition of views. `cedar` also isn't coupled to a particular GUI kit (e.g. `gtk`) which allows for a simpler API and flexibility down the road. `cedar` could be used on top of `conrod`or a real DOM in the browser (in addition to `cocoa` and `gtk` as it is now).
AFAIK there isn't a great way to do this. You could define your own newtype struct and make some kind of `to_tuple` method, but without numeric generics you pretty much have to know what size tuple you are gonna need, beforehand. Something like this: https://play.rust-lang.org/?gist=b8d69ccdbed6d9cb8af905c132e0a7b6&amp;version=stable
meta comment. I am disappointed when the first post in the comments of a discussion is either "meh" or "I don't like this, lets stay the same". While a totally valid response. It shuts down the rest of the conversation; the first post gets lots of default upvotes and is often hard to unseat. It doesn't foster a discussion because it doesn't ask for feedback, it just states ones opinion. 
Is it possible to turn off comments for specific posts? It might make it easier to funnel people over to the other thread. In the future ...
This is excellent. People have long been using off-heap collections in Java and either having allocation owned by the collection or doing memory management themselves with all the dangers that entails. This sounds like this builds in affordances to running those off-heap, manually managed memory regions. There is nothing stopping other languages from encoding manual memory allocation in their high level GCd runtimes.
Btw, do you know if CEF supports the Web Component standard? I want to make a remote controllable fullscreen video player application (that will run on a Raspberry Pi), would you recommend using CEF in a Qt window to render the videos (as html `&lt;video&gt;` elements with JS and Websockets to control playback) or using FFMPEG on a glium window? The FFMPEG approach seems a lot more work, what would be the advantage?
I have streamed (primarily) Haskell and (I'd like to do more) Rust recently on [Twitch](https://twitch.tv/bitemyapp), with [video uploads on Youtube](https://www.youtube.com/channel/UCMNqLf5GI6mkAUo-LGS07ig?view_as=subscriber).
Interesting! That solution is actually better than the similar ones I saw on Stack, thanks!
I was wondering about having older struct around with impl just for loading and converting with returning a new version. Although you would still have to have a way of detecting version. I haven't worked with serde at all yet, so not sure how it is setup.
What you're proposing is making it so that I have absolutely no idea what `[]` does in a given module. I have to re-learn it for every module I touch - it's no longer something I can learn to use once and understand everywhere. That's not making that piece of syntax more valuable - it's making it *worthless*, and encouraging people not to use it for anything. If you want to propose doing something useful with `[]`, add it to the language. Otherwise, I might as well be programming lisp and not having any indicator of what my code does at all.
Nightly has "slice patterns", which let you destructure slices; they're not stable yet though.
&gt;&gt; it's no longer something I can learn to use once and understand everywhere. I think a common preferred use would emerge (we could throw our potential definitions online and see what gets most traction), and it would eventually end up becoming absorbed the new standard library default; the smart sequence constructor is the obvious use case. Some people might want to use it to emulate 'obj-C method calls' , but given that in apple-land they've moved to something that looks more like traditional function calls, that's probably a silly idea. println!("{:?}", seq![x; x*2 ;for 0..10]); println!("{:?}", seq![x; x*2 ;for 0..10 ;if 0!=x&amp;1]); // list-comp println!("{:?}", seq![1,2,3]); println!("{:?}", seq![1,2,3]); // straightforward comma separated values-&gt; array println!("{:?}", seq![1=&gt;10,2=&gt;3,3=&gt;5]); // read the '=&gt;' to imply maps, : might work aswell as in JSON/swift the thing about the above is inventing fancy syntax *inside* the macro is redundant, because we've got the named prefix already. I might as well say "list_comprehension!{..}", "map![..]" etc. and I lose the 'infixy-ness', hence *" I might as well be programming lisp"* as you put it..```(hashmap (1 10)(2 3)(3 5))``` the use I propose would be semantically a superset of what it does today, and [a,b,c] would probably still make an array. (one variation I tried was [1,2,3] makes [T;N], [1,2,3,] makes a vec, but i know we'd want a more obvious distinction. [1,2,3,..] had parsing ambiguity on another note, I think i'd be a lot happier with using named macros more often if they could be given a ```$self``` for method-like invocation, because then they could use used in a more 'infixy' way that doesn't stand out like a sore thumb from the rest of the language constructs. e.g. they say *'we don't need variadic args because we have macros'* , but you can't make something that looks like a method call with variadic args. we can do ```file.write(a,b,b,c,d)``` in c++ (which sits nicely alongside 'file' having other methods), whereas in rust we have to go back to prefix form and maybe invent some other syntax if we want to nicely seperate the 'file' and the other params.) some people say nice literals aren't needed in a systems language, but they're really handy in tests etc.. it's great for discovery when you can look for functions by giving input/output pairs and they more closely correspond to what you can do 'inline' precedents:- * swift https://developer.apple.com/documentation/swift/dictionary [] makes dictionaries or arrays, * python http://www.secnetix.de/olli/Python/list_comprehensions.hawk list comp (awesome) * haskell https://wiki.haskell.org/List_comprehension I'm not sure which 'blend' would be best (we do need to obviously visually distinguish between them) , but I'm sure we can do better than what we have at the moment. the &lt;- symbol is appearing for other use in rust I think, but we've already got for / in keywords
Is there any way to pass a parents model to a function from a child item? I'm calling a filedialog from the menu, and want it to update a label in the root window: #![feature(proc_macro)] extern crate gtk; #[macro_use] extern crate relm; extern crate relm_attributes; #[macro_use] extern crate relm_derive; use gtk::{ ButtonExt, FileChooserDialog, FileChooserExt, DialogExt, Inhibit, Menu, MenuBar, MenuItem, MenuItemExt, MenuShellExt, OrientableExt, WidgetExt, }; use gtk::Orientation::Vertical; use relm::Widget; use relm_attributes::widget; use relm::RemoteRelm; use self::Msg::*; // Define the structure of the model. #[derive(Clone)] pub struct Model { text: String, } // The messages that can be sent to the update function. #[derive(Msg)] pub enum Msg { Open, Quit, } #[derive(Clone)] struct MyMenuBar { bar: MenuBar, } impl Widget for MyMenuBar { type Model = Model; type ModelParam = (); type Msg = Msg; type Root = MenuBar; fn model(_: ()) -&gt; Model { Model { text: "".to_string(), } } fn root(&amp;self) -&gt; &amp;Self::Root { &amp;self.bar } fn update(&amp;mut self, event: Msg, model: &amp;mut Self::Model) { match event { Quit =&gt; gtk::main_quit(), Open =&gt; file_dialog(model), } } fn view(relm: &amp;RemoteRelm&lt;Self&gt;, _model: &amp;Self::Model) -&gt; Self { let menu = Menu::new(); let menu_bar = MenuBar::new(); let file = MenuItem::new_with_label("File"); let about = MenuItem::new_with_label("About"); let quit = MenuItem::new_with_label("Quit"); let file_item = MenuItem::new_with_label("Import LocationHistory"); connect!(relm, quit, connect_activate(_), Quit); connect!(relm, file_item, connect_activate(_), Open); menu.append(&amp;file_item); menu.append(&amp;about); menu.append(&amp;quit); file.set_submenu(Some(&amp;menu)); menu_bar.append(&amp;file); menu_bar.show_all(); MyMenuBar { bar: menu_bar, } } } fn file_dialog(model: &amp;mut Model) { let dialog = FileChooserDialog::new::&lt;FileChooserDialog&gt;(Some("Import File"), None, gtk::FileChooserAction::Open); let filter = gtk::FileFilter::new(); filter.set_name("json"); filter.add_pattern("*.json"); dialog.add_filter(&amp;filter); dialog.add_button("Ok", gtk::ResponseType::Ok.into()); dialog.add_button("Cancel", gtk::ResponseType::Cancel.into()); if dialog.run() == gtk::ResponseType::Ok.into() { if let Some(path_buf) = dialog.get_filename() { model.text = path_buf.to_string_lossy().into_owned(); } } dialog.destroy(); } #[widget] impl Widget for Win { // The initial model. fn model() -&gt; Model { Model { text: "".to_string(), } } // Update the model according to the message received. fn update(&amp;mut self, event: Msg, model: &amp;mut Model) { match event { Quit =&gt; gtk::main_quit(), _ =&gt; (), } } view! { gtk::Window { gtk::Box { // Set the orientation property of the Box. orientation: Vertical, // Create a Button inside the Box. MyMenuBar, gtk::Label { // Bind the text property of the label to the counter attribute of the model. text: &amp;model.text, }, }, delete_event(_, _) =&gt; (Quit, Inhibit(false)), } } } fn main() { Win::run(()).unwrap(); } The way it's written now it's just passing the menu's model, which doesn't do anything. Thanks again for the help. I've been having fun learning how relm works.
You can have an enum of structs of all the versions, define a custom deserializer that lets it pick the enum variant and fill into it, and then have conversion methods to upgrade. You can even do this after-the-fact, i.e. build in versioning _after_ you've already released software that relies on an unversioned scheme. It's more work though.
One of the downsides of plain only-type-driven random generation (as in, the functions in the `gen` module, and the current `Rand` trait) is that it's not that useful, e.g. for integers one often wants between a range (which is moderately nontrivial to do truly uniformly: `%` isn't correct) rather than the full space, and a completely uniform `char` is... basically useless, as, chances are, it won't even be assigned (only a quarter of the ~1.1 million codepoints are currently assigned) let alone printable or appropriate for the programmer's usecase; even something like "alphabetic ascii" requires two ranges (if one was to try to implement it that way) and alphanumeric requires 3 of different lengths (so a simple three-way switch to decide uppercase, lowercase or numeric won't be uniform).
If there's to be a "new library default" that literally everybody uses and nobody deviates from, then the more reasonable mechanism for getting to that point is the RFC process and adding it to the language. Writing an RFC isn't difficult and you don't have to be a member of some secret cabal to do it - if you want to write an RFC for whatever you want to do with `[]`, *go for it*. We already have mechanisms for evolving the language without building extension points that are only ever going to make code harder to understand.
That sounds OK until you hit version 50 or so.
If you control all the data your best bet is to make a converter at each version break and upgrade all the data in one shot. If you don't control all the data you need to use something that's not direct serialization of a struct, because while supporting all versions of data that way is possible it definitely does not scale.
Maintaining 50 backwards-incompatible versions - and forcing your users to keep up with you - sounds painful in the first place... surely the "correct" thing to do is just to add new attributes with default values whenever possible. How do you manage compatibility breaks with your ad-hoc format without writing additional code to handle the old format?
Uncle Bob thinks [it's programmer job to manage nulls, not language](http://blog.cleancoder.com/uncle-bob/2017/01/11/TheDarkPath.html) and generally, would consider Rust to be a "way too much churn" language anyway. Hardly a person to bring here as an authority, IMO. :P And, what is important: Rust software architecture is composed of crates, threads, ownership tracking, channels, etc. Not directories and files! I would rather have explore automatically generated graphs out of the source code, as a "floor-plans" of the software. Looking at directory structure, is like trying to understand how building is going to work, by looking how are bricks aligned in the wall. Completely wrong level of detail. I can get a good idea how the program behaves, by analyzing how are object passed, where and threads created, etc . I can see how crate operates, by reading it's documentation on docs.rs And so on. 
I have an example...well, example for you from the library I've been developing recently (called Adhesion): https://github.com/ErichDonGubler/adhesion-rs/blob/13b0736d56bf14cae4b9ef5bb6531e556118c6e3/examples/date.rs See how the example uses the crate to test like any other? #[macro_use] extern crate adhesion; #[macro_use] extern crate galvanic_assert; // ... You should just be able to do this, and it Just Work™ when you do `cargo run --example date`.
Nice, I'll have to download it and try it out. Do you know where/if Rust keeps track of implementation progress?
You're running the examples via `cargo run --example x`, right?
https://doc.rust-lang.org/stable/unstable-book/language-features/slice-patterns.html https://doc.rust-lang.org/stable/unstable-book/language-features/advanced-slice-patterns.html both have links to the tracking issues
Interesting, this is the first I've heard of it. I bet if you added support for it in serde more people would become familiar with it.
It's a pain if you don't plan for it. I just looked at one file from our project that's been live for two years and it's at version 62... though I don't know how much variance between versions there is, nor how often we can afford to force upgrades to latest version. As much as creating an ad-hoc text format to do something you can do with a library is a bad idea, tying versioning directly to code-level data structures isn't a super great idea as far as I can tell.
Cargo script is one of the handiest tools I have for learning Rust. Writing one-off scripts to manage files / network requests / etc. has shown me a wider diversity of libraries and exposed me to more codebases. I definitely recommend you give it a try.
But CSV does not align the columns, right? I'd prefer something like this for a table of numbers: col1 col2 1.7 7.1 2.9 10.0 13.4 27.8
perhaps it starts out being inspired by something more complex without yet giving the extra features that would allow (I keep hearing about 'ML modules' being able to do fancy things). if we eventually get module-wide type parameters or whatever , the extra complexity might be worth it in the end
I do not have good memories of using the HDF5 C/C++ bindings, but maybe I just did not understand their API. The Python bindings are fine though.
Oh, I see. Maybe using transparent proxy would hep with applications that can't use proxy themselves?
I'm not in control of the proxy or the net or even my own workstation. I don't think setting up a transparent proxy on my user account at my workstation can help with anything, can it? Maybe I'm misunderstanding though.
Thank you! :)
I guess, not. I think I've seen some library somewhere which you can `LD_PRELOAD` and it proxies all connections, but I don't remember exactly how/if it worked.
The way relm works is to send messages between the widgets. What you want to do is to add a message to your child widget and emit it when you want to update the label. Then, in the parent widget, you'll listen to this message to update the widget accordingly. Please look at the [communication](https://github.com/antoyo/relm/blob/master/examples/communication.rs#L236) example ([here's the version with the attribute](https://github.com/antoyo/relm/blob/master/examples/communication-attribute.rs#L173)).
I don't see the problem. This is *art*.
Relavent PR: https://github.com/rust-lang/rust/pull/43488
Just add default values for new fields. Removing fields could be a bit nastier, but depending on what you're doing, it's probably still pretty easy.
I want [flatbuffers](https://google.github.io/flatbuffers/), which is essentially Google's second stab at Protocol Buffers.
SQLite is a lot more complicated, as now you have to fill out schemas and whatnot. If you're just storing a config file or test data during testing, why bother with SQLite? If you *are* going to use SQLite, Diesel is fantastic, so the argument still holds that you should use a tool do to such things rather than manually doing it.
Maybe tsv (tab separated values) would be more appropriate for viewing in a plain text editor, or using a CSV viewer that can align columns and maybe even provide more functionality (spreadsheets for instance, or xsv and other command line tools). 
 extern crate csv; fn main() { let mut wtr = WriterBuilder::new() .delimiter(b'\t') .from_writer(vec![]); } Works until col_width &gt;= tab_width. The one reason to use 8-width tabs ;) Probably wouldn't be too hard to get it to output even columns for wider data, though I'd probably just use csv and view it with `xsv table` or somesuch.
Yes, agreed, I was just trying to show how people try to grasp programs conceptually, how to mentally grok something so abstract (the program), yet concrete and too verbose and low-level (the source code). I think UML and [4GL](https://en.wikipedia.org/wiki/Fourth-generation_programming_language) ([CASE](https://en.wikipedia.org/wiki/Computer-aided_software_engineering)) was on to something, but of course we need better compilers, that help [explore the design space](https://www.youtube.com/watch?v=TS1lpKBMkgg#t=41m33s) (language servers with/for incremental compilaton are getting us there) and help [visualize](https://divan.github.io/posts/go_concurrency_visualize/) as you said, not just shiny tools to generate a lot of dumb code in a language, that's not even fully supported by the super-IDE. 
Careful with that Hyper and Serde bifurcation. Don't cross the ~~streams~~ structs, or you'll end up with "expected `Client` but found `Client`".
Still a ways off but I am thinking about it. I'll probably make a 0.1 release after the move to webrender and some more refactoring is done. The things most likely to change after that point will at least be documented
Some of them broadcast under "Creative" too. I'm currently watching [Ferris Streams Stuff](https://www.twitch.tv/ferrisstreamsstuff) (who writes a lot in Rust, mainly emulators and demoscene stuff) and [Jonathan Blow](https://www.twitch.tv/naysayer88) (who writes the compiler for his JAI language in C++ and his game in JAI).
At least he didn't try to allocate grenades on the stack.
I would always recommend avoiding a full browser unless you need it. So no, if you are working well with ffmpeg, don't use CEF or anything. My project is for building a browser, so I need it.
I'm having a really hard time with lifetimes and closure references. What I want is to have an object Foo that owns several Bars. Foo should own a closure, which each Bar needs a reference to. [Gist](https://gist.github.com/anonymous/e6e6b8ca6bbbf79748c3666e6f38e284) / [Playground](https://play.rust-lang.org/?gist=e6e6b8ca6bbbf79748c3666e6f38e284&amp;version=stable) for a simplified example that gives the same error. The code is: struct Bar&lt;'a&gt; { cb_ref: &amp;'a Box&lt;Fn(i32)&gt;, } impl &lt;'a&gt; Bar&lt;'a&gt; { fn new(cb: &amp;'a Box&lt;Fn(i32)&gt;) -&gt; Self { Bar { cb_ref: cb } } } struct Foo&lt;'a&gt; { cb: Box&lt;Fn(i32)&gt;, bars: Vec&lt;Bar&lt;'a&gt;&gt;, } impl &lt;'a&gt; Foo&lt;'a&gt; { fn new(cb: Box&lt;Fn(i32)&gt;) -&gt; Self { let bars = Vec::new(); let mut foo = Foo { cb, bars }; foo.bars.push(Bar::new(&amp;foo.cb)); foo } } fn main() { let foo = Foo::new(Box::new(|x| {})); } What I really want out of the code is for each Bar to simply have a reference to the closure (a trait object), and NOT a reference to a Box, which seems silly to me. However, I get this error: error[E0597]: `foo.cb` does not live long enough --&gt; src/main.rs:20:33 | 20 | foo.bars.push(Bar::new(&amp;foo.cb)); | ^^^^^^ does not live long enough 21 | foo 22 | } | - borrowed value only lives until here | note: borrowed value must be valid for the lifetime 'a as defined on the impl at 16:1... --&gt; src/main.rs:16:1 | 16 | / impl &lt;'a&gt; Foo&lt;'a&gt; { 17 | | fn new(cb: Box&lt;Fn(i32)&gt;) -&gt; Self { 18 | | let bars = Vec::new(); 19 | | let mut foo = Foo { cb, bars }; ... | 22 | | } 23 | | } | |_^ Which I think is just plain wrong - the lifetime should be `'a` since that's the lifetime of `foo`. I've thought about embedding the closure directly into the Foo struct, but then it's impossible to store Foo in any other struct (because impl trait still hasn't hit stable). Edit: I tried embedding the closure directly into Foo (so now Foo's type is Foo&lt;'a, F: 'a&gt;). I get the same issue though. I think rustc simply doesn't understand that since the lifetime of `foo` is `'a`, then the lifetime of `&amp;foo.cb` must also be `'a`. Instead, it's assuming the lifetime of `&amp;foo.cb` is some anonymous lifetime that ends when the function returns, which is clearly incorrect here. Is there a way I can tell the compiler to ignore this with an unsafe block? Edit 2: I threw in the towel and made Foo::new take `cb` as a reference (with lifetime `'a`). It kinda sucks that I can't make Foo own the callback and I need to force the caller to deal with it, but I've spent hours on this without making any progress.
I'm curious to know, can you provide some examples of your use cases for needing a serialization format that supports ADTs?
How was this generated?
&gt; This is definitely commonly-needed functionality. Some protocols (notably TLS) also need the ability to read a 24-bit encoding into a u32. Indeed. For symmetry I added 24 bit and 48 bit integers. Unsigned, signed, big and little endian. It was trickier than I thought so there might be some ways to improve it. I also have plans to look how to get 128 bit integers going with nightly. With that I could have reader for 96 bit integers (STUN/TURN has such beast). &gt; I think your read_bytes() is equivalent to r.skip_and_get_input(n).map(|b| Vec::from(b.as_slice_less_safe())). I think an implementation like this might be more efficient than the current read_bytes() implementation. Thanks, I'll look into skip_and_get_input(). For current implementation I went the easiest way and relied only on read_byte(). Right now I wasn't too concerned about allocations or efficiency, but to get a proof-of-concept out and get some feedback (which I got, thanks!).
&gt; So I might move to untrusted, wish some reliance on untrustended for the various endianness stuff. Cool! Let us know how it goes. I'm open to any feedback. &gt; Something that makes me sad though, is that there's no Write equivalent to untrusted. That'd be really nice. I guess I could hack one together. byteorder works really well for writing stuff. Do you have some issues with it?
Error handling requires code. 1) has no code. It's just failing to handle the error. 2) and 3) both have code to handle errors so it of course means more code. Here is the part to be considered. If you handle the error in line, then it messes up the code for the algorithm you are trying to handle since it (no surprise) means you have code for error handling inside the code for the algorithm. But this allows greater context to handling the error.... on the other hand if you work to move the error handling code somewhere else, then you lose the context of the error handling, but clean up the algorithm code to only focus on the algorithm. It really depends on what you need to focus on. Either way, make the error handling code as formulaic and standardised as possible. The reason for this is that it allows those who care about the algorithm to 'skim' over the error handling....while also allowing special case error handling which really and truly is different to stand out.
man, that was rough to figure out. Got it now though. Thanks
How does this deal with partially applied updates? I think a library can be robust regarding this if it writes on a temp file then mv the contents to the executable.
What to you mean by "partially applied updates"? This will do a whole-sale update: download the latest binary to a temp dir, copy the current exe to a temp file, try to delete the current exe and replace it with the latest release. If something goes wrong, it will try copying the current exe back into place from the temp-copy.
Oh, you shouldn't first delete the exe, since if the program crashes between this and moving the file, the user won't be able to run it. That's what I mean by partially updating: stopping the update in the middle. You could probably just move the temp file into the exe, that way it's either at the old or the new version (except perhaps in case of power loss, for some filesystems; but it would be no worse than first removing then moving the file).
Copying is not atomic. File rename is on linux and many other OSes since its just flipping some inode links around. This is atomic on Linux barring a crash right in the middle of the rename. But then you either have the old file, the new file, or neither (dangling link) https://unix.stackexchange.com/questions/24395/rewrite-existing-file-so-that-it-gets-replaced-by-new-version-atomically-only-o For btrfs overwrite by rename is still atomic https://btrfs.wiki.kernel.org/index.php?title=FAQ&amp;oldid=11521#What_are_the_crash_guarantees_of_overwrite-by-rename.3F You basically need to do something like this bash script echo "oldcontent" &gt; file # make sure oldcontent is on disk sync echo "newcontent" &gt; file.tmp mv -f file.tmp file http://man7.org/linux/man-pages/man2/rename.2.html rename ("/usr/bin/executable","/tmp/executable-backup"); rename ("/tmp/updated-executable","/usr/bin/executable"); If it fails, rename the old one back Rust has a libc library, but there may also be a higher level option 
This is not the right way to replace executables or libraries on a Posix system. I'm not sure it's right for Windows either. There's no need to copy things. As I've seen it done, create a hard-link to a temporary backup file. Copy the new executable into a new temporary file in the same directory as the target. Call rename() to move the new file over the old name. This guarantees that there is never a point in time that the file is missing. Windows has rather annoying file locking that prevents deletion of in-use EXE or DLL files. So you have to create a temp copy of the new file, rename the existing file out of the way, rename the temp copy to the real name, and hope no one tried to use it during that millisecond. I believe some updaters use fancy NTFS Transaction tricks, but since transactions are deprecated now that wouldn't be a good plan. But anyway, a copy into the actual name is never a good idea because someone could try to execute the file while it is only half there.
Hm, that makes sense. I was actually doing that originally, but I ran into a case where running the example with `cargo run --example github` would only work if the existing file was first deleted!
Thanks, I'm not familiar with windows specifics! I'll rework this later tonight. edit: updated now
Probably with [cargo-graph](https://github.com/kbknapp/cargo-graph)
Thanks! I'll fix this later tonight to replace all `copy`s and `remove`s with `rename`s edit: updated now
Really like the look of your component system so far! I've been working on something sort of similar where each Widget has a set of EventHandlers, each of which receives a different event type, and can modify the widget state in response to events. Right now it's based on a global event queue, rather than immediately calling callbacks, but the architectural reasons for that no longer apply so I'm doing some redesign and thinking about looking into tokio/futures, although I don't have a clear idea of how that would work. I'm really interested to see how your component design will look using futures. I'm wondering, have you considered having your callbacks operate on types rather than values? It seems necessary for handling events that contain data, eg. mouse positions, unless you have another mechanism for that? That is, instead of: .on(Event::Pressed, Box::new(|state| { println!("pressed"); MyAppState { counter: state.counter + 1 } })) .on(Event::Released, Box::new(|state| { println!("released"); MyAppState { counter: state.counter + 2 } })) having something like: .on(Box::new(|event: Event, state| { match event { Event::Pressed =&gt; println!("pressed"); Event::Released =&gt; println!("released"); } MyAppState { counter: state.counter + 1 } })) 
Discord? Not Mattermost?
[Dramatization](http://emojis.slackmojis.com/emojis/images/1466103216/526/headdesk.gif?1466103216) of encountering this.
You are speaking directly to my Computer Engineering major with that;)
Related to what the other commenter said, you might find [this section of the book](https://doc.rust-lang.org/1.6.0/book/loops.html) useful. Note the bit on for loops where they contrast the "C-style" for-loop like what you wrote with Rust's version
&gt; https://github.com/rpjohnst/dejavu Game Maker, as in what eventually became https://www.yoyogames.com/gamemaker ? I would love there to be an open source version of that. Outside of Flash, it is easily the best "beginner development" environment that I've ever seen (and something I spent countless hours using as a kid). Unlike most tools of it's ilk, you really could create complex original games just using the WYSIWYG tools, and as you outgrew that you could slip into code.
Where does it say anything about passwords or salting?
Mods can lock the post to prevent comments.
Yep, exactly that one! I really like how discoverable everything was, even compared to Flash. The newer versions have lost a lot of that, without really improving on the parts of the UI that slowed you down. I'm hoping to help preserve a lot of the old games people made, and also clean up the UI to make it scale better.
The same issue I have with reading from a Cursor-backed `byteorder` : `std::io::Result` has a proliferation of error values that can never get triggered, and actually figuring out if I should handle them is a pain. I had to actually look at the source of byteorder and Cursor to find that the only error than can happen is in Cursor : https://github.com/rust-lang/rust/blob/1.19.0/src/libstd/io/cursor.rs#L258 : ``` Error::new(ErrorKind::InvalidInput, "cursor position exceeds maximum possible vector length") ``` Maybe this could be fixed by more documentation on the Cursor trait. (Also, that error could have been avoided by making `position` an `usize`, so I'm a bit surprised that this error can occur at all).
Thanks for the feedback! You're absolutely right about the event callback. In order to access the contents of the event (like mouse position) you either need to match inside the handler or I somehow need to destructure the event's enum fields before passing them into the callback. I have no idea how to do the latter right now. Your proposal seems like the way to go. As for futures, I am thinking about having something like "on_async" where instead of returning the new state you return a vec of future states. In an upcoming futures-rs I believe support will be added to turn that vec into a ordered stream and then it's just a matter of spawning that onto the Tokio event loop. In combination with tokio-timer this allows you to do something like first return a "show spinner/loading" state and then have the next state be a future that resolves only after some IO has completed which will return a "hide spinner/show results" state. Do you have a link to your component system, by the way?
Not gonna lie, the module system is a bit weird, especially if you are coming from Go or D. They have very simple systems.
Haven't looked at the details, but one thing to note is that on Unix'y systems rename only works if both source and destination are on the same filesystem. 
The key here is that a Path/PathBuf is just a tiny wrapper around an OsStr/OsString. So first you need to get your hands on one of those: https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes. Then you can convert to a path type with AsRef/Into. Note that that from_bytes function doesn't exist on Windows, instead you'll need https://ollie27.github.io/rust_doc_test/std/os/windows/ffi/trait.OsStringExt.html
Have you taken a look over at [kakoune](http://kakoune.org/)? It's a vim-like editor which operates on multiple selections.
This is the self-referencing struct issue where you want one field of a struct to reference another, and it is indeed impossible to do in today's safe Rust. Nobody has figured out how to do this safely in a generic manner (yet), though there are some crates like `owning_ref` and `rental` which can alleviate the pain in some cases.
Best part is how he only has 2 deps Lots of duplication: 2 versions of hyper, 2 different base64 libs, 2 versions of serde libs, 2 versions of openssl-sys. Bit of a pre-tokio vs post-tokio thing happening between the two
I've streamed a couple times now. Mostly Rust. I'll probably stream some Ruby one of these days. https://www.twitch.tv/seantheprogrammer Aaaand the videos are all expired. VODs are here. https://www.youtube.com/channel/UC-zdf8iX8Etq1mzXRVMqZQg
Things are shuffled to and from a temp dir made with the `tempdir` crate which looks like it wraps `std::env::temp_dir`. I suppose there could be some situations where the current executable lives on a separate filesystem... I'm not sure?
Yeah, like NFS or network filesystems. Its a possibility. 
That would also fit better with the epochs RFC, where understanding what they do would be as simple as checking which breaking features are enabled for a given crate.
True, I could swap out `tempdir` for something custom that puts temp files right next to the executable. edit: looks like `tempdir` supports this
It would be nice if there was a --force-shared-dependencies option where dependencies get auto upgrade the "greatest common denominator" as long as its not a major version ID change. Would greatly reduce binary bloat. This problem is only going to get worse as we go forward. In the security world we often depend on dynamic-linking in order to fix vulnerabilities. OpenSSL and the like often will get vulnerabilities and you need to upgrade the version that all libraries link against. If we had a similar Rust-only world then we're going to get heavy use of static linking that is going to cause a lot of security problems.
Macros that do those things already exist. So I don't see the problem that you're supposedly *solving* here.
That's already what happens, except in cases where a dependency has deliberately restricted the set of versions it's compatible with. And if a package has done that, there's probably a reason for it. The split in this case is looks to be because reqwest and discord depend on incompatible versions of hyper. No amount of forcing anything is going to help there.
But Cargo already caches build artefacts within a package. Incremental compilation won't change that.
Sounds like some sort of notion that would be more useful than the `Rand` trait would be some sort of type `Random&lt;A&gt;` that represents a *composable first class strategy* to generate a value of type `A` at random, with a random generator supplied externally to the strategy. The `Rand` trait already approximates this but with one nasty flaw that you point out: using a trait instead of actual first-class values means that there's a one-to-one relationship between types and such strategies. (I'll stop here before I go into a monads rant. Or actually, an applicatives rant, more likely...)
as the other guy says ironically trying to make the reverse suggestion: "might as well be programming in lisp" - macros revert to a prefix form. This is intended to free up the square brackets in a way that is combined with *infix* information to determine what the 'form' does. e.g. ```[ =&gt; , =&gt; ]``` is hash maps, ```[ ..for.. if..]``` is list-comp, etc. if it's determined up-front, the internal syntax becomes more extraneous. I think other languages demonstrate these brackets can be given better default use than we see in rust (e.g. swift lets them initialise both arrays or hash maps without needing any 'prefix'.). of course macros have other uses. making them 'redefineable' is about experimentation I guess. (allow community experimentation, then absorb the most popular option as the default) I did experiment myself making a single macro that could generate hash maps, list-comprehension or vector literals, but the point is if it's a macro, its seems wasteful utilising *both* prefix and infix information. Might aswell just say 'hashmap!', 'listcomp!' etc up-front, and there's no need for the fancy internal syntax.
So the problem you're solving is only that you don't want to type the name of the macro? I still don't know how that's a problem. `[` is still a prefix. And I don't see what's being wasted here. You're saying the syntax is 'wasted', but as far as I can tell, you have just as functional macro syntax to do what you want, and square brackets have a perfectly good use.
&gt; I don't know if this would be possible. I say this because procedural macros (aka custom derives) are only aware of the current type it's generating impls for; it has no type information of anything else. Except Debug isn't custom derive - it's built-in derive, and it already checks for Debug impls of fields for error reporting purposes.
Cool, yeah the stream approach is interesting, I really need to take a closer look into tokio/reactive streams, the spinner example is compelling, I can see it being especially useful for timers/animations. You can take a look at [here](https://github.com/christolliday/limn/tree/148f27773705f9f31e74b25febb9844178d930da/examples) for some examples. The internals of my project are a bit ugly at the moment, currently going through major refactoring and a lot of comments are probably out of date, but you might be interested in the event dispatching. The important bits of it are `add_handler*` in `WidgetBuilderCore` [here](https://github.com/christolliday/limn/blob/148f27773705f9f31e74b25febb9844178d930da/src/widget/mod.rs), to register stateful or stateless handlers, `Queue::push` [here](https://github.com/christolliday/limn/blob/148f27773705f9f31e74b25febb9844178d930da/src/event.rs), to add an event to the queue, and `App::handle_events` [here](https://github.com/christolliday/limn/blob/148f27773705f9f31e74b25febb9844178d930da/src/app.rs), to dispatch and process events in the queue.
&gt;&gt; you don't want to type the name of the macro? I want the behaviour to be determined mostly by infix information &gt;&gt; [ is still a prefix. but one which 'melts away'. Something psychological about symbols/punctuation vs words and entering/exiting nesting levels. Symbols/punctuation are background, your mind focusses on the words. It's so much nicer when the punctuations handles trivialities leaving vocabulary to be specific to the task at hand. I have the same issue with the loss of the sigils (this tortures me every day I use rust). Rust with the sigils was amazing. If you think i'm insane, jonathan blow makes exactly the same point criticising modern c++ in his first talk). (.. it wasn't just 'the extra typing of Box vs ~ ..it was all the other combinations - they all read logically once your brain associated '~' with owned-allocated.. Box::new(Foo{...}) is way more annoying than ~Foo{..}. trait objects worked much better. ~[T] eradicates the annoyance I've always had with the repurposing of the word 'vector&lt;T&gt;' that C++ does. 'vector of VECTOR' in graphics.. yuk. ) writing ```list_comp!{....}``` you might as well simplify the interior, and you've basically ended up with probably inferior to writing 0..10.iter().map(|x|..).collect:: you might as well just make a helper function for the latter. I'm sure we can get more syntactic mileage out of the square brackets (in both expression and type contexts.)
Well, I have the opposite problem: when I see sigils I see a screen that has rabbit turds scattered all over it. Symbols are not background, they are distracting noise. So clearly it's a matter of style. Which doesn't warrant any change, as it would be for the sake of nothing but personal preference. EDIT: But I don't think this is about that, really. I don't think your idea is bad, I just don't think it adds anything to Rust.
It would be nice if it had a global cache, and not just a project cache. Though I can see the issue of how to handle a crate with configurable compilation.
&gt;&gt; when I see sigils I see a screen that has rabbit turds scattered all over it heh. most people are very used to the arithmetic operators; then through years of OOP, the 'dot' has become instinctive too from years of C &amp; C++ , I add the * &amp; -&gt; to that list. I found the sigil ~ slotted in very naturally ; r.e. adaptation, a syntax highlighter that would colour code 'pointer-like sigils' the same might have helped, i.e. * &amp; ~ @ all being the same hue. I was surprised to read about people 'complaining about many pointer types' (..and then thinking writing longer names for them was somehow a solution..) I find that words are more 'ambiguous' (strange as it might sound) - more to argue about, whereas sigils/operators are more composable, more 'mathematical-looking', so I welcome a language giving more more of those. Words are more to argue over: I've explained the problem I have with 'vector' vs 'array' / dynamic array / even 'list' or some shortening ; then we see 'Box' in rust when i might be thinking historically about 'bounding boxes' etc. repurposing the word "::new()" for *initialisation* bugs me. And so on.. conversely one of the things I like a lot about rust is 'immutable by default', i.e. you write fewer 'muts' than you write 'consts' in c++ .. on that front Rust is getting the 'annoying word count' down :) similarly 'match {..=&gt; ,=&gt; ,}' looks a lot better than 'switch { case ..break case..break}' ..and of course it's way more powerful. I'm a big fan of the 'last expression = return-value' (significant semicolon) tangentially something else that might help macros is if they allowed two brackets items .. for!(){} because we're so used to seeing that combination from function declarations. If you want to write a macro with '2 major parts' , you often have to add another nesting level inside. (for!{(){... }}. imagine in the 'list_comp!' example putting the function and range in either half
&gt; slightly impossible So you're saying there's a chance :p
Yeah. `cargo-script` cheats to get this by telling Cargo to just use a single target directory for everything. It... *kind of* works. I've just never really trusted it to do the right thing.
It works fine on Linux Mint. I must have something setup wrong in my custom app.
Should also require `--force-subtle-bugs`
There's always solutions.
There's a project called sccache: https://users.rust-lang.org/t/sccache-for-caching-rust-compilation/10960
To be a bit more direct than Quxxy was: this is not true, we do not recompile the entire dependency graph every build. Only the current crate is rebuilt.
In 1994 I developed some Rexx and early SQL to analyze a single RPG/400 program's call structure. RPG was a shitty language that had global variables only and organized in columns like COBOL. It's only redeeming feature had a tight integration with DB2. Pics would come out like that shown (but I only managed straight lines). The last stage was to write Postscript, and it would only print on a single sheet. It had to reduce font sizes and line widths as needed to fit on a sheet and still have boxes and lines not smush into each other. If the program was big (say over 6000 lines), the reduction of font size made the resulting diagram unreadable. It would become simple [Moire patterns](https://www.google.com/search?q=moire+patterns&amp;source=lnms&amp;tbm=isch) for many of the larger programs (I'm talking about you, UN995 and UN016). Postscript was hell to work with from an "I know nothing" point of view. I had to work out Postscript by reading the source of simple print jobs and building knowledge through experiment. I generated the postscript for this tech, of course, from a template system in Rexx. The only testing there was to send it to the printer. Either a page came out or one did not. You used old fashioned debugging of course - printing debug info on the page as that was as close to 'std out' as you could get. 
Found https://crates.io/crates/haxonite, but what I worried is it's last updated time :) mockito also looks good, will try. Thanks guys
In your stackoverflow post, you mention trying to turn the macros into functions to understand them, but ... the compiler doesn't turn macros into functions; it *expands* them, replacing fragment identifiers with the macro parameters and passing through everything else. Here is a [Playground link](https://play.rust-lang.org/?gist=b72d2ea8672455564d2e5ecc33d24081&amp;version=stable) that shows what the final code would look like after expansion; all the normal borrowing rules apply (despite the code being generated by a macro), so the problem is that the outermost `let body = ...` is being assigned a value that contains a reference to the value created by the innermost `let body = ...`, which goes away at the end of its enclosing block.
This depends entirely on the use case.
I keep planning on streaming my work on clap...but alas I haven't had that much time as of late to do much of anything because of my paid job. 
This wasn't the first post in the comments?
Protobuf has oneof; when you say ADTs do you mean something other than sum types?
How would you extend that to handle negative numbers? Right now, since your code splits on (and effectively removes) `-`, all numbers parse as positive (`"4 - 5"` becomes `Ok([4, 5])` and `"-4 + 5"` returns a `ParseIntError`). 
Note that `OsStr` and `OsString` *are more or less UTF-8*, even on Windows. This is quite poorly explained in the documentation. That `std::os::unix::ffi::OsStrExt` is unix-only is *really, really annoying*. Because sometimes, even on Windows, you *do* want to take something that’s UTF-8-like and make an `OsStr` of it. Basically all it does is transmute, anyway. `std::os::windows::ffi::OsStringExt` entails parsing UCS-2 to WTF-8. When parsing a file to get a list of paths, you still need to know what format the paths are in and what delimiter is in use. Will it be essentially WTF-8 on Windows? If so, then… you’re going to need to copy what `OsStrExt` does. Just a bit of mostly harmless transmutation.
This is just the distributions, which are already supported. TBH `rand`'s great flaw was not using distributions for everything; the `Rand` trait should just be `impl IndependentSample&lt;T&gt; for DefaultDist`s, with appropriate renaming.
If you need help, please post the complete error message (the panic). Also, seeing some code would help me… to help you.
If it is simply UTF-8, you can parse it as a `&amp;str` and then turn that into a `Path`. If it you're reading arbitrary bytes that are probably UTF-8, that's not WTF-8. Unlike `OsStr` on unix, `OsStr` on Windows *cannot* contain arbitrary bytes. If you try to transmute an arbitrary byte string to `OsStr` without verifying that it is valid WTF-8, you *will* encounter undefined behavior. If you have something which is definitely WTF-8 and not arbitrary bytes and not just UTF-8, where are you even getting that file from?
&gt; SQLite is a lot more complicated Because the problem is more complicated then people in this thread let on. SQLite solves the problem of querying, platform independence, schema migration, transactionally writing changes, reading/writing from multiple languages, etc. You may not have any of these problems now, but things change and requirements grow. &gt; as now you have to fill out schemas and whatnot. You always have schemas one way or another. 
I think the wtf-8 standard even specifies that you're never supposed to put it over the wire or on the disk :p
RPG was the first language that I ever used professionally (realize that I graduated from college in 2010...); it was so unbelievably baroque that I found myself researching up-and-coming languages to balance out the flavor, which is how I stumbled across Rust in 2011. :P
Huh, good catch. But it looks then like `Sample` and `IndependentSample` might be underpowered—no `map` or `flat_map`.
I guess reddit had decided that it was 'best'; it was at the top of the page when I loaded it.
Continuing to work on my window manager, [Ruwm](https://github.com/InsidiousMind/Ruwm). Just added some custom error types for the PEG Configuration Parser and the WM itself :-). Learning alot about Rust+X+Some Theory all at once, so it's been a wild ride so far. Hoping to finish up some critical parts of the Config Parser and start on working with the XKB library and implementing Key Bindings this week.
Oh awesome! I've been streaming to liveedu, but those streams seem to cut off alot, and they recently re-branded so the audience has been different. Might just do the switch since Twitch is larger and they actually have a rustlang category My streams are a bit nooby though, so don't expect much if i do switch over, heh.
If your example is written in separate file (and referenced in Cargo.toml via `[[example]]`), just use your crate as usual, via `extern crate`. If your example in separate crate (and has its own Cargo.toml), reference your parent crate via path like `parent = { path = "../parent" }`. After testing, replace path reference and publish crate. Also you can use github url there.
It doesn't check, it just emits calls like `fmt::Debug::fmt(&amp;self.field, f)?;` - which will fail type checking if that field doesn't implement Debug
I stand corrected. Though I swear I saw custom error messages for derives at one point in time...
I won't be satisfied until Rust replaces both C/C++ and Python. :&gt;
Sorry, still waking up this morning. What did you want `map` and `flat_map` for?
Welcome to Reddit. You should check what a subreddit is about *before* posting to it. If you don't, you run the risk of posting unrelated things and making a fool of yourself. You probably want /r/playrust.
Interesting! My road (parsing a language I'm writing) went from nom to chomp to pest. I found chomp much nicer than nom for the purpose, and then pest cut the loc almost in half (though it does introduce more potential error cases which I am not completely happy about..) 
I *think* on linux now rename() is always atomic.
Why should it not compile? It's just a for-loop followed by an if-statement. The fact that you didn't separate them by a newline does not change the semantics. Like C++ and countless other languages, Rust is a free-form language where whitespace does not matter.
your code made of two statements and is the same as: fn main() { for i in 1 .. 10 { println!("{}", i); } if true { println!("wooo"); } }
I guess I'm stupid or something but the processing section of pest was indecipherable to me. Nothing I tried worked. With nom at least you are constantly making steady progress while working and it is way more straight forward what is going on. 
Is there a tutorial anywhere that shows how to create examples for your library the Cargo-way? If not...
I've been writing a virtual stack machine based command prompt interpreter defining the language as I go. It's based on a course project from a Languages and Paradigms course at my uni. This is meant to just be a fun exercise in language design and virtual machines.
Newlines are not generally significant in Rust, your code could also be written for i in 1 .. 10 { println!("{}", i); } if true { println!("wooo"); } or for i in 1 .. 10 {println!("{}", i);} if true {println!("wooo");}
&gt; WTF-8 ??? --&gt; googling --&gt; https://simonsapin.github.io/wtf-8/ --&gt; *ROFL* 
So Cargo can cope with multiple versions of a crate, but tries to unify them if it can?
Replacing python with Rust sounds like a very bad idea. They so much try to do different things. Having said that Python is terrible at what it tries to do and—like Go—mostly succeeds on the userbase being seemingly unaware of better stuff and how much the language is based on outdated practices. What Python has going for it though is a ridiculous amount of stuff already written in it so a lot of problems in Python basically become `import FixMyProblem ; FixMyProblem.fix_my_problem()`
 &gt;Having said that Python is terrible at what it tries to do and—like Go—mostly succeeds on the userbase being seemingly unaware of better stuff and how much the language is based on outdated practices. What alternative to python would you suggest? I have never really learned python but it always seemed to be lots of people's preferred choice for general purpose scripting. 
Should be noted that it's hardly that convenient because the pattern must be irrefutable; so say you _know_ guaranteed that a vecctor is 3 elements you can indeed do: match &amp;vec { &amp;[first, second, third] =&gt; /*some code*/, _ =&gt; unreachable!(), } But the part with unreachable must be included so you can't use a refutable pattern as in: let &amp;[first, second, third] = &amp;vec; As there are no compile time guarantees on the length of `vec`.
Cargo only uses more than one version of a depended-on crate if the depending crates require incompatible versions. It's that, or just flat-out refuse to compile at all.
You can use `b'\n'` instead of `10u8`.
If all you want to do is that, you can drop the new type and just impl your own trait for Vec&lt;T&gt; [https://play.rust-lang.org/?gist=10fdd954488630d61aa0ecfc035d8edf&amp;version=stable](https://play.rust-lang.org/?gist=10fdd954488630d61aa0ecfc035d8edf&amp;version=stable)
It's not uncommon that the temporary directory is an in-memory filesystem or similar.
Ruby is slower but much nicer to use IMHO. Still lots of packages available for it, but not quite as much, especially on the scientific end. If you really want a scripting language, Ruby is a good bet though, it's incredibly flexible. It's much more similar to Smalltalk than Python is as far as the object model goes and that lets you do all sorts of neat hacks that make things more convenient. Calling out to shell is incredibly easy and it even supports backticks like in shell scripts. This is valid ruby: ruby_files = `find . -name "*.rb"`.lines.to_a
&gt; Just a bit of mostly harmless transmutation. Please don’t do that. WTF-8 is an internal implementation detail of the standard library. It’s deliberate that there is no API to convert to `OsStr` from `[u8]`, WTF-8 should not be used in a file format. On top of that, as retep998 pointed out it’s not harmless since arbitrary bytes are not necessarily valid WTF-8. When reading from a file you’ve got to decide what is the format and encoding of that file. Since paths are fundamentally different on Windows vs Unix it may make sense to have different code paths. * Files contains arbitrary bytes, as do Unix paths. So it makes sense to map them one to one with `std::os::unix::ffi::OsStrExt::from_bytes` then `Path::from`. * On Windows there is no such obvious mapping, so you have to pick an encoding. Your options to support all of Unicode are: * UTF-16BE or UTF-16LE. You can decide (or not) to allow unpaired surrogate code units, since they can also occur in Windows paths. (That encoding would really be potentially-malformed-UTF-16*E, which I’d call WTF-16LE / WTF-16BE.) Either way, convert to `[u16]` then use `std::os::windows::ffi::OsStringExt::from_wide` then `PathBuf::from`. * UTF-8. Get a `String` or `str` (such as from `read_line`), then use `PathBuf::from` or `Path::from`. This means only supporting paths that are valid Unicode. Trying to cram unpaired surrogates (in order to support all possible Windows paths) into sort-of-but-not-quite-UTF-8 is the path that leads to WTF-8. It’s a hack that I wish did not need to exist. Please consider your trade-offs, and don’t propagate it lightly. ---- Alternatively, to keep thing simple you could only support the “common denominator” of Unicode paths (in UTF-8 on Unix), going through `String` or `str` on all platforms.
Depends on what is your goal: - text processing - Ruby/Perl, awk, sed - web dev - Elixir - science - Octave/MATLAB, R, Mathematica, Julia - scripting/extensions language - Lua, Scheme - sysops - sh, awk, sed
&gt; Python is terrible at what it tries to do [..] succeeds on the userbase being seemingly unaware of better stuff Python's beauty is in that it does really many things "well enough". Personally I prefer keeping to 2-3 languages in day-to-day dev. I use Python for simple desktop apps like software launchers and updaters, deployment infrastructure, game scripting, studying prototypes like simple neural network implementations, automating command line tasks, etc. For each of those tasks taken separately, perhaps you can relatively easily find a language more suitable for it, but personally I am not entirely convinced if the overhead in learning and switching between so many languages really beats any disadvantage Python has in the particular tasks I use it for.
&gt; Comparison operators are not lazy. Except in `a &lt; b &lt; c()` if I can prove this statement is false because `b &gt; a` I can optimize out `c()` since I already know that the whole thing evaluates to `false` anyway. Same way that `a &lt; b &amp;&amp; b &lt; c()` would work
Just a heads up: I've tried loading the rendered spec and the tab crashed. This happened twice. My browser is chromium on ubuntu. May be due to a problem on my side though. Also, and pardon the possibly stupid question, is svgbob limited to being exclusively implemented with SVG, or is it intended to be a general representation for any two-dimensional display system that is able to render it? I ask this question because `px` is not always defined (or defined differently) depending on the display system. Did you consider defining dimensions in terms of `em`? (which is usually defined or derivable on system that handle text)
&gt; Just a heads up: I've tried loading the rendered spec and the tab crashed. This happened twice. My browser is chromium on ubuntu. May be due to a problem on my side though. Not only you, I have the same issue. So far, this is happens on chrome for Ubuntu and Opera for Ubuntu. Chome on my macbook works well. For the time being, you can use firefox on ubuntu. So I'm guessing this could be wasm(Web Assembly) issue for webkit base browser on ubuntu. &gt; Also, and pardon the possibly stupid question, is svgbob limited to being exclusively implemented with SVG, or is it intended to be a general representation for any two-dimensional display system that is able to render it? I'd been wanting to deliver a truly native app, but I'm thinking SVG is the shortest route to take to deliver a working implementation. &gt; I ask this question because px is not always defined (or defined differently) depending on the display system. Did you consider defining dimensions in terms of em? (which is usually defined or derivable on system that handle text) Currenly I'm using px, and I believe that is the default unit to the SVG element, since I've tried removing and putting `px` back and see no difference. Adding `use_em` option to the generated SVG would be not hard to implement. Now, that you've mentioned it, I'll add it to the code. Though, I'm not sure if using `em` as the default unit would be much better. Thanks for the feedback and heads up. Edit: I think I've fixed up the chrome crashes now.
I don't think it's worth it. the opportunity would be for a single language that is better at dropping super low level and going high level; look at the way Swift would go if they manage to integrate move-semantics; also look at jonathan blows JAI language which is aimed at performance code *and* rapid iteration. rust IMO occupies a certain middle ground but is worse than C for 'low level' bit bashing/raw pointers, and worse than application languages for 'high level'. (in your multi-language project, think of C as the 'giant unsafe block', but syntax-optimised for the parts that *need* unsafe) It is nowhere near the 'silver bullet' that it's strongest advocates seem to think it is (although many admit what it's limits are, and specialised target is) If you're willing to pay the cost of language interfacing (*"with python's help.."*), I would argue you can do better by continuing with C (which is better than rust for truly low level work.. it's syntax is optimised for the unsafe cases - raw pointer manipulation) and pairing it with an 'application language' (which is more productive). As long as there's multiple ideas, we need a simple language for FFI. Rust (and of course C++) are too complex to be the 'universal FFI'. C serves an important use in being just enough to save us needing to write way more assembler, and I think C critics (even C++ people) forget that sometimes. As soon as you go a level up you're introducing many design issues to argue over like *'how should modules work'*, *'how should polymorphism work'*, which can go so many different ways - and however interesting Rust is, it's a bit premature to imagine that one set of choices in all that can become an all-singing all dancing standard.
The [atomicwrites](https://github.com/untitaker/rust-atomicwrites) crate is probably a better fit for your use case.
&gt;&gt; "I won't be satisfied until Rust replaces both C/C++" Rust isn't committed to replacing C++; There's domains where improvements could be made, but which Rust ignores by philosophy, leaving room for others. There's places where we put up with C++ for historical reasons, but the ways in which we want to move on aren't targeted by rust. excellent talk: https://www.youtube.com/watch?v=TH9VCN6UkyQ&amp;list=PLmV5I2fxaiCKfxMBrNsU1kgKJXD3PkyxO **so basically C will always live on as the universal FFI** which all contenders continue to interface with; and as long as C exists, C++ will continue as being 'a higher level language with embedded C'
Thanks, that looks way better !
Merci !
The whole point of splitting operators into groups is to *avoid* the kind of confusion you're talking about, by requiring parentheses where the precedence isn't obvious.
You inadvertently highlight one of Python's strengths here. Learn 5+ different languages for all these domains, or learn just one language which handles each domain 'well enough'. Having said that, I have spent the last 2 years working exclusively in Python and I hope to never use it again for anything bigger than a 100 line script.
GDB works as is out of the box for Rust programs if you need a debugger. As for your main question I have no idea.
FWIW, this is how I implemented self-update for a IoT client running on a Raspberry Pi at work. It uses the unix exec call so it doesn't work on Windows. The client downloads the update from the server as a zip file, which may contain a file `update.json` which can contain a list of files to delete as part of the update (others can be overwritten). I'd appreciate any feedback on this :) use std::io; use error; pub fn read_string&lt;T: io::Read&gt;(r: &amp;mut T) -&gt; Result&lt;String, io::Error&gt; { let mut s = String::new(); r.read_to_string(&amp;mut s).map(|_| s) } #[cfg(unix)] pub fn run_update(data: &amp;[u8]) -&gt; error::Result&lt;()&gt; { info!("updating client v{}", client::VERSION); debug!("exe: {:?}", *EXE_PATH); use std::fs; #[derive(Deserialize)] struct UpdateMetadata { to_delete: Vec&lt;String&gt;, } let mut update_metadata: Option&lt;UpdateMetadata&gt; = None; let mut zip = zip::ZipArchive::new(std::io::Cursor::new(data))?; for i in 0..zip.len() { let mut file = zip.by_index(i).unwrap(); trace!("filename: {}", file.name()); if file.name() == "update.json" { update_metadata = Some(serde_json::from_str(&amp;read_string(&amp;mut file)?)?); } else { use std::fs::Permissions; use std::os::unix::fs::PermissionsExt; let (file_name, permissions) = if file.name() == &amp;*EXE_FILENAME { (EXE_TMP_FILENAME.to_string(), Permissions::from_mode(0o755)) // rwxr-xr-x } else { (file.name().to_string(), Permissions::from_mode(0o644)) // rw-r--r-- }; let file_path = EXE_DIR.join(file_name); fs::create_dir_all(file_path.parent().unwrap())?; let mut f = fs::OpenOptions::new().write(true).create(true) .open(&amp;file_path)?; f.write_all(&amp;read_vec(&amp;mut file)?)?; f.flush()?; f.set_permissions(permissions)?; } } if let Some(update_metadata) = update_metadata { for rel_path in update_metadata.to_delete { let path = EXE_DIR.join(rel_path); if path.is_file() { let _ = fs::remove_file(path); } else if path.is_dir() { let _ = fs::remove_dir_all(path); } } } use std::os::unix::fs::PermissionsExt; let metadata = fs::metadata(&amp;*EXE_TMP_PATH)?; let mut permissions = metadata.permissions(); permissions.set_mode(0o755); // owner: rwx, group &amp; world: rx fs::rename(&amp;*EXE_TMP_PATH, &amp;*EXE_PATH)?; info!("finished updating"); use std::process::Command; use std::os::unix::process::CommandExt; Err(ClientError::Io(Command::new(&amp;*EXE_PATH).exec())) } #[cfg(not(unix))] pub fn run_update(_: &amp;[u8]) -&gt; error::Result&lt;()&gt; { error!("updating only supported on unix"); Ok(()) } I wonder if I should also send a SHA1 checksum to check the integrity of the zip file or can I assume that if it decompresses successfully, it's uncorrupted? And as for Windows, one would &gt;have to create a temp copy of the new file, rename the existing file out of the way, rename the temp copy to the real name, and hope no one tried to use it during that millisecond ?
while theoretically good enough, in practice, in production code, application is never just one executable, it can often contain multiple executable's, libraries, config files, images, sound files ... in other words auto-update is better done on application directory level in practice i think something similar to Google Chrome update system is better: - application directory is instead of "c:\program files\Great Rust Application\" something like "c:\program files\Great Rust Application\v.1.21.5\" - application link (hard-link or if not possible soft-link) is located in "c:\program files\Great Rust Application\app.exe" and it links to "current" version "c:\program files\Great Rust Application\v.1.21.5\app.exe" - when application is started it immediately starts but schedules background thread that will after lets say 5 minutes check if there is new version on update server (not immediately because application will look unresponsive to user if it takes more than approx 200ms-500ms to display start screen) (method of downloading update itself should be separate library because i can see multiple implementations like http, ftp, bittorrent, with or without password/licence, completly custom solution with possible encryption ... (default implementation can be "github" one, that downloads for example zip file and unpacks it to new folder but user of library should be able to override/implement his/her own download method for app directory)) - after application finishes downloading new version to new directory "c:\program files\Great Rust Application\v.1.21.6\" it switches hard-link or soft-link to point to this new folder instead so next time application is started new version is executed instead - optionally after link is switched application asks user does he/she want to restart application so changes can take effect or continue working in old version during current session - next time after new version of application is started in that same update thread that runs 5 minutes later it will notice "old directory" "c:\program files\Great Rust Application\v.1.21.5\" in its folder and ask user does he want to cleanup old application version (or maybe just delete it without asking, if developer made that decision)
also often not all application files are updated between versions so a delta update of some kind would be useful to reduce downloads, but not mandatory, something automatic like some hash/fingerprint or bittorrent would be perfect but simple manual way would be for new version to have list of files it contains and for each file last application version it is updated in than downloader can make new folder, and before downlaoding each file for new version check if user already has that file or not, - if user current application version has wrong file version than new file is downloaded in new folder using http - if file was not changed between versions and new file is same as old file than auto-update code just makes hardlink in new directory to file in old directory (or copy, softlink will not work) hardlink is better since user will need free space for only one version of file not both, plus there will be less disk IOPS for update process for example instead of downloading again unchanged file updater will make hardlink "c:\program files\Great Rust Application\v.1.21.6\unchanged_file.jpeg" pointing to old version "c:\program files\Great Rust Application\v.1.21.5\unchanged_file.jpeg"
Actually calling a shell is likely to cause random quoting problems in real code. The python equivalent is `subprocess.check_output(['find', '.', '-name', '*'])`.
This was originally intended just for simple updates or cli programs, but the updating of arbitrary files is certainly useful. The `update.json` list mentioned by /u/boscop sounds like something I'd like to add in. &gt; &gt; method of downloading update itself should be separate library because i can see multiple implementations like http, ftp, bittorrent ... I agree! I've tried to limit the functionality to only downloading and replacement of files. Everything else, like you mentioned, should be handled by the application itself. That would include choosing to install new releases in an A/B fashion.
I won't be satisfied until pure functional programming will be mainstream. 
Thanks for the input! I'd definitely like to add something like your `update.json` and doing an integrity check may be a useful option in some cases.
Thanks, looks like what I want. I'll give it a test
Be prepared for a life of disappointment.
&gt; I've tried to limit the functionality to only downloading and replacement of files if you read my whole post you will notice "replacement" is not the best option in my opinion (stolen from google chrome team) better make new separate folder for new version and download all files there (or if unchanged between version hardlink/copy from old folder) and when done just switch application link to point to folder of new version no file ever gets replaced, only copied, and when all is done you have two separate copies of application, and switch is just modifying application link to point to new version instead also remove of old version is done by new version AFTER it successfully starts so that there is less opportunity for "broken installation" 
Well there's some nostalgia for you. I learned to program using Game Maker, back in 2004. Did a bit of digging, and I *still* have the first pure-GML thing I made: [Pong](https://gist.github.com/Measter/7b2b95207541986c7078a5228e4ff2c8)!
Those are all specialized, though. If you want to do something quickly without learning a new languages, or if you want to combine different things in a single application, Python can be the best choice. 
C is easy to read, if you've learned to read it. If a Rust person didn't know C, then the 'syntax-optimized' nature of C is not obvious. The slightly klunky unsafe equivalent in Rust would make more sense and be more readable. Personally I think some C literacy is good, the world is still built on it, but it is not essential to know it.
Python and Ruby will be quite good in most cases. You will almost never do all these things in one application as: - mixing science and web in one application will kill your CPU in seconds, also when you do web then most of science needed you can do in your DB - scripting + web is at least quite unreasonable to allow run users any code in your web application - sysops + science, just why? - sysops + scripting = sh/bash - text processing + science = csv or SQL and all these languages have built in support for that - text processing + web = Light Markup Language and you will use existing libraries for that So you almost never need to do such things in one app, and by extension - one language.
Curious to hear what type of work you have done in Python in the past two years and why you say you wouldn't want to work in anything larger than a 100 line script?
I think 100 lines might be a bit of an exaggeration, but yeah, Python - like any language really - needs a much more structured and ridig approach when dealing with large codebases. I find that with Python 3.5 and 3.6, using type annotations a lot is very helpful. It's also beneficial to be strict about declaring variables early in to class definitions and so forth. Together, all that lowers the "magic" feel of the language, while retaining most of the advantages. That said, nowadays I'd be a bit hesitant to start anything very large in Python. Has a tendency to spaghettify as we humans are bound to slip from good practices when we're not forced into them.
Ah, understood. That is a pretty smart design.
&gt;If you're willing to pay the cost of language interfacing ("with python's help.."), I would argue you can do better by continuing with C (which is better than rust for truly low level work.. it's syntax is optimised for the unsafe cases - raw pointer manipulation) and pairing it with an 'application language' (which is more productive). I feel like this is kind of missing the point. The article doesn't talk about needing pointer manipulation -- it just acknowledges that Python (and the like) is slow but easy to write, and people get around that *now* by writing C that Python calls into. You don't need lots of bit bashing or raw pointer manipulation to be faster than Python, and I think Rust sits at a good place to to be the language you can call into when your scripts are too slow.
Don't like it personally; I kind of wish you could make refutable `let` bindings but when you ask for it explicitly. Like say there was `let* &amp;[first, second, third] = ...;` with the `*` indicating that you are aware that this pattern is refutable but you vouch for it and accept a panic when it's not.
I don't believe that's easily done at the moment. Calling `Debug::fmt` requires a `fmt::Formatter`, which you can only get (directly or indirectly) via `fmt::write`, which requires a `fmt::Arguments`, which you can only get (for safety reasons) via the compiler-builtin `format_args!` macro. You could instead construct one directly with the psuedo-private [`Arguments::new_v1`](https://doc.rust-lang.org/src/core/fmt/mod.rs.html#318), or since you're in a debugger, just filling it out manually. That could be wrapped up in a debugger script to make it usable. In the long run, though, we probably want macro support in debuggers, and because `format_args!` is currently only defined as a compiler built-in, that probably just means compiler integration. Macro expansion is probably something RLS already has to handle, so maybe it would be worth starting there.
Definitely a lot easier to grok. Thank you
This is the year of Lisp!
Maybe I'm misunderstanding, but the title seems pretty sensationalist and it's not really related strongly to the content. It's really suggesting that it's easy to replace libraries for Python that are written in C with libraries in Python that are written in Rust. This is a good idea, but I don't really think it's an incremental step in Rust taking over the world in any other domain. ----- Ranty aside goes here. Pretty much unrelated but I felt like writing it. If we really, really want Rust to truly replace C in meaningful ways (as opposed to be being an alternative in the vain of Java, in that it's another option to consider when writing some general program (yes I know they have very different properties; I'm talking about developer mindshare)), I think the only *major* way to get there is to support Redox heavily. I really think C is the default language because you're (almost) always writing software to run on top of OSes that were written in C. That reasoning behind choosing the language may not be logical, but I think it's the case. Writing an OS that can be used both as general purpose and as a server in Rust would mean that anything written to target that OS would probably consider Rust *first*. That's just my opinion, though, which is worth essentially nothing.
Well, it's dynamically typed, which saves few keystrokes when writing short script, but it's terrible "feature" for developing a little more complex programs. But I admit I'm biased.
Directly in the opening paragraph. &gt; Any WTF-8 data must be converted to a Unicode encoding at the system’s boundary before being emitted. UTF-8 is recommended. WTF-8 must not be used to represent text in a file format or for transmission over the Internet.
This is one of the many changes to Rust's import and module system suggested by aturon's [recent blog post](https://www.reddit.com/r/rust/comments/6pstlx/revisiting_rusts_modules_language_design/) put into RFC form. Its very self-contained, that's probably why it got its own RFC. I've posted this to reddit to give it a wider audience. What do you think? My personal opinion is against the change; see my comment on the RFC thread for why. There seem to be also positive voices about it.
That's a non-english page, not sure if its allowed on this subreddit. In any case, I've found a whitepaper that is in english: https://github.com/cryptape/cita-whitepaper/blob/master/en/technical-whitepaper.md Also a link to a Rust codebase: https://github.com/cryptape/cita
Not fully Rust, but the more usable option with less non rust-code: [imgui-rs](https://github.com/Gekkio/imgui-rs) is not declarative, but is very close by using immediate mode instead retained mode. You should definitely take a look at it.
Sorry, I understood what you meant. I have an issue open for allowing installs without requiring them to replace something first. At the time of writing, I was thinking you could just specify an install path that wasn't the current exe, which is something exposed in the builder, but actually doing so will cause an error as it's currently implemented.
A `message` is a product type and a `oneof` a sum type, not enough? Protobufs are far from perfect, but in my mind they come closest to good enough (esp due to relatively good language support compared to other binary serialization formats).
Might there be a point in The World of Tomorrow where C as FFI exposes too much as unsafe, and some safer, non-C derivation takes over?
&gt; You always have schemas one way or another. But with JSON or something else supported by Serde, it's in the code as a struct. Also, with SQLite, you add an installation dependency whereas with Serde you just compile it in (not sure if you can statically compile in SQLite support) and you need to deal with database initialization and upgrades (not too difficult with diesel, but it's yet another thing to worry about). SQLite is also much more difficult than JSON for editing by a user (e.g. a config file), so there are a lot of negatives here. JSON is much simpler and is sufficient most of the time, so that's where I typically start if I don't think I'll need anything more complex. It's usually pretty easy to tell at the outset if the data you're using is in the "JSON is enough" category or if SQLite will be needed in the future, and in that case, I'll probably just use PostgreSQL most of the time.
IIRC the itertools crate has a method for that
My first intuitive reaction to this is a very big _No_. Having implicit imports adds unnecessary complexity and paves to anti-patterns. ~~This very much feels like catering to high-level programmers.~~ EDIT: ~~To rephrase, I see `extern` as providing a trade-off on asking more boilerplate from the _writer_, but greatly reduces the cognitive load for the _reader_.~~ EDIT_2: I believe skade's [argument](https://github.com/rust-lang/rfcs/pull/2088#issuecomment-318753150) is much more clear. 
Looks like it does, thanks! Is there nothing in the standard library? This seems surprising. I'll use this in the meanwhile.
But doesn't it also cater to low-level programmers who prefer explicit imports? I don't see a problem with catering to high-level programmers without harming a low-level programmers ability (for some definition of high/low level programming). Edit: In particular as reflected in this statement of the RFC &gt; We will continue to support the current extern crate syntax, both for backwards compatibility and to enable users who want to use manual extern crate in order to have more fine grained control-- say, if they wanted to import an external crate only inside an inner module. No automatic import will occur if an extern crate declaration for the same external dependency appears anywhere within the crate.
&gt; Having implicit imports adds unnecessary complexity To me, it's the exact opposite: I always want `extern crate` in the crate root. Adding it in is just boilerplate.
It also has type hints, which you could've used. PyCharm actually uses them to warn about potential typing errors.
[Here's the changelog](https://github.com/racer-rust/racer/blob/master/CHANGELOG.md) There aren't any huge changes, but you should find that it completes in more cases, that the completions are no longer duplicated, and that closure parsing is much more accurate.
I am a scientist working in Python. The scenario of Python + Rust is highly relevant for me. Neither me nor most of my colleagues that I train know C to begin with. We know Python. We want to drop down a level to compiled fast code, but we're not going to become C experts. The promise of going down to a lower level safely (while bringing in existing scientific C libraries as well) is important for us. Ownership and borrowing are not weird if you've never allocated memory, and are not really aware of the difference between a reference and an object. Or the stack and the heap. And I have lost weeks to other peoples C code having subtle memory errors that I couldn't debug without expert help, and that would have been prevented by Rust. Correctness is a big issue here, and besides speed one of the biggest reasons for me to continually evaluate alternatives to Python.
[Named tuple](https://docs.python.org/3.6/library/collections.html#collections.namedtuple) will get you a very long way. Immutable, with no magic offsets. Lighter weight syntactically and mentally than a class, and [MyPy](http://mypy-lang.org/) offers their own [typed named tuple](http://mypy.readthedocs.io/en/stable/kinds_of_types.html#named-tuples). I've been programming in Python since 1999 and my biggest complaint is the lack of standardization in the language, that the batteries are welded to the implementation and packaging still continues to be a complete mess. On the whole, it isn't a bad system. Ruby and Lua are better designed but still don't have what Python has.
Most Rust fn signatures are just as easy, if not easier to read than C. The vast majority of programmers don't know or read C. I would like if Rust IDE plugins would hide much of the not germane metadata from Rust code, so much metadata packed into the syntax!
Is there ever a time where you'd add something to your cargo toml file and not have the accompanying extern crate statement?
It terms of "real" probability distributions, it allows one to do transformations like `Normal::new(...).map(f64::exp)` to get a log-normal distribution, and `Gamma::new(...).flat_map(|mu| Poisson::new(mu))` to get a negative binomial, and then manipulate the resulting objects as distributions themselves, similar to iterator adapters. That said, I'm not entirely sold on it: one loses the ability to easily calculate properties like mean and variance.
Not that I'm aware of.
I do it all the time. But it's because I forget to remove it from Cargo.toml after deleting the `extern crate`.
The standard library lets you use `collect` for this purpose, but there’s no way to have a delimiter (all the strings just get squashed together back-to-back).
because in the first example `contents` can't be reassigned for the lifetime of the borrow. can you give an example of illegal behavior you're concerned `let mut` would permit?
I love type hints, but they are still not enforced. I don't know, I just like really, really strong typing.
how is this implicit? wouldn't you still need to `use` whatever modules you want out of the crate?
&gt; (not sure if you can statically compile in SQLite support) SQLite is statically compiled in the app just like serde. &gt; and you need to deal with database initialization I have no idea what you mean by this. You call open on an sqlite file... &gt; and upgrades You mean schema migration? You have to do the exact same thing with json, just by hand instead of SQL. &gt; SQLite is also much more difficult than JSON for editing by a user Mac/linux have sqlite console installed, for windows you can ship sqlite console with your app. When editing, SQLite will tell you any syntax errors, with JSON it will just likely cause your app to crash. &gt; It's usually pretty easy to tell at the outset if the data you're using is in the "JSON is enough" category or if SQLite will be needed in the future, and in that case, I'll probably just use PostgreSQL most of the time. There is a giant chasm between JSON and shipping PostgreSQL with your app.
I can see why it may look like boilerplate, but to me `extern` is less about _writing_ code, but when _reading_ code. In fact `extern` is less about telling what _is_ imported and more about what _is *not*_ used. When looking at a module, the less cognitive load I have the better, and the _absence_ of imports provides a straightforward way to explicitly define the surface area of a module. Explicit `extern` is a trade off like `borrowk`, in this case, sacrificing upfront on writing time for easier reading time in the future. I believe that's a fair trade-off, after-all we read code much more than we write it.
First, even if you are not running everything in one process, you might want too share support code between parts of your application to avoid having to writing things twice. &gt; sysops + scripting = sh/bash Sure. Unless you want to deal with any non-trivially-structured data. &gt; text processing + science Doing data mangling in MatLab is a PITA.
It seems to me that what one would want is a 2 steps process: 1. Ask for a random index between 0 and a customisable upper-bound, 2. Map index to a given value. For example, for a boolean, the index would be in `0..=1`, whereas for a 32 bits integer it would be in `0..=u32::MAX`. So, taking your examples: - for an alphabetic ASCII character, the index is in `0..=52`, - for an alphanumeric ASCII character, the index is in `0..=62`, - and for `char`... well, I don't know how many states there are because of the gaps ;) This 2-steps process separates: - the act of generating a random value, so that you can check a random engine's quality regardless of types (and all types sharing the same number of states have the same quality), - from the act of mapping a random index to a specific value. By separating the two, it's even possible to generate well-distributed odd numbers in the range 109..1191 if such is your requirement. And I think that both steps can be driven by a single trait: only two methods a required after all one to give the number of possible states and one to map this state index to the desired state.
I'm not thrilled by the prospect either, though I can see advantages in some situations (conditional compilation, notably).
&gt; &gt; database initialization &gt; &gt; open on an sqlite file... I mean creating and managing tables. You can do this in Rust or use something like diesel to handle it for you, but it's not automatic. Working with JSON is automatic if you include default values for new fields. Depending on the scope of your application, this could be no big deal or completely overkill. &gt; Mac/linux have sqlite console installed And many users aren't familiar with SQL, so whether this is an issue depends on who will use your application. JSON is significantly easier since it's just a text file, and there are other formats (e.g. TOML) that are a little easier for users unaccustomed with the format. Requiring your users to learn SQL to configure your application seems unnecessary in all but the most fringe cases. &gt; Giant chasm between JSON and Postgres Yes there is, as well as using SQL vs a text file. My point is that in many cases, if I think I want SQL, I'll likely want something more complete like Postgres. If I'm not sure, I likely want something simple like JSON.
Looks very interesting! I've [refactored my code](https://github.com/RoyJacobs/weld-model/blob/master/tests/component.rs) a little bit to allow the .on callback to be fully generic. You can now invoke any object that implements the Event trait and you will get the correct type back in the callback, like this: enum MyAppEvent { Pressed(u32), Other } impl Event for MyAppEvent {} ... parent(self) .on(Box::new(|event, state| { match *event { MyAppEvent::Pressed(amount) =&gt; { println!("pressed: {}", amount); }, _ =&gt; {} } I didn't realize Rust could do such deep type inference, but there you go :)
&gt; see my comment on the RFC thread Could you link to it? You have several comments in the thread.
&gt;&gt; Ownership and borrowing are not weird if you've never allocated memory, sure, and C++ can do them too, whilst interfacing more closely with C I get the impression there might be other languages that are directly aimed at your domain? (julia?)
I don't know why you are talking about configuration files when this thread is about state files.
I was able to get `join` to work in the playground with no additional imports, on a vector created with extend (where you would give your iterator). https://play.rust-lang.org/?gist=c51b2e54189f7a5640de9b56f4932759&amp;version=nightly Here is the code for reference: fn main() { let iterable: Vec&lt;String&gt; = vec!["one".to_string(), "two".to_string()]; let mut extended = Vec::new(); extended.extend(iterable); let joined = extended.join(","); println!("{}", joined); }
`extern crate rand` is like having a `use rand` in your crate in that in imports the name `rand` in the module namespace. So things like `rand::random()` would be valid without any `use` or `external crate`.
IMO I think there will always be a layering situation going on the thing about 'provably safe' is it's an over-estimate, because we can't actually prove everything that *IS* safe to be safe (as far as I know). Rust relies on 'bounds-checked arrays', which states there's other potential correctness hazards you haven't yet eliminated; if you can test to the extent you're confident the code will never panic (and it gets through other forms of verification), I think you'd statistically accept it to be 'safe' aswell.. science is all about probabilities really ("99.99% certain.. because the number of alternative explanations has become narrowed down to unlikelyhoods") I can't see one approximation becoming standard. conversely whatever systems are built could also yield better analysers for C. (e.g. imagine converting C programs to some theoretical form with HKT where the raw-pointers become inferred smart pointers, doing error checking.)
Inheritance. Just because your `contents` variable isn't "rebinded", doesn't mean the fields of the `String` struct isn't. Having something in Rust be immutable is this amazing promise that the variable cannot be changed. Except when using interior mutability (like `Cell` and similar).
Seems like the solution might be to warn of unused Cargo.toml dependencies, like we currently warn of unused `extern crate`s. In fact, an implementation of this proposal might just give us that for free.
&gt; C is easy to read, if you've learned to read it. like any other language, it's been optimised for a driving use-case: which is unsafe pointer manipulation &amp; bit bashing. Rust is objectively less efficient for this because it's syntax space is taken up on safe use cases; specifically it requires more vocabulary to do the same work. (and conversely, C is objectively less efficient for safe code because it's syntax space is taken up in the unsafe case) &gt;&gt; " but it is not essential to know it." certainly, I agree most people using computers do not need to know it. but it is the right tool for the lowest level IMO. When extended with intrinsics (e.g. if you're working with the machines ISA) it is also interesting, e.g. reasoning about a SIMD program. if your code is stepping through memory in an efficient way.. not needing all sorts of pointer chasing abstrracitons - C will give you a big boost over raw asm, but still show you how well your algorithm maps to hardware.
Sorry I don't have examples at hand, but I see `Cargo.toml` is part of the build system, not part of the source code. The actual source should define it's namespace, not cargo. Perhaps i'm wrong about this, I probably shouldn't have commented.
So as someone who is not a fan of most of this module reform stuff in general, I think this in particular is a great idea. Cargo already follows a convention-over-configuration approach. It automatically selects or infers good defaults for things that would otherwise just be pure duplication, while still providing the configuration for special cases. Dependencies and `extern crate` are definitely one of those situations where the default is just pure duplication. I always check a new crate's `Cargo.toml` to find its dependencies anyway, rather than the main file. Further, this particular implementation, as opposed to the alternative of inferring from the source, still works with direct, Cargo-less usage of `rustc`, which still needs to specify dependencies.
But it is explicit in the `Cargo.toml`? So it is just explicit somewhere else?
Cool. I thought racer was in maintenance mode and waiting to be replaced with rls. What's the longer term plan here? 
I highly recommend contributing to Servo even if you haven't written much Rust. Some of the first Rust I wrote when I didn't know hardly anything was for Servo's `Worker#terminate` implementation. You'll immediately be exposed to a lot of core Rust concepts, and the feedback you get during review is absolutely invaluable for helping learn the lanaguage--it certainly was for me, anyway. Plus, it's pretty cool to be able to say you've contributed to a web browser written in Rust!
I would love for us to move on from C as the universal FFI. And since C isn't really an FFI, or even an ABI for that matter, what I mean by that is I would love for platform ABIs to move on from the minimal set of primitives provided by C. Windows has already done that with COM, for example- C just plain isn't universal there. Even better, though, would be for platform ABIs to start standardizing simpler things like slices and pointer ownership information, maybe even lifetimes. At a minimum I would love it if we quit distributing canonical API definitions as C header files full of macros. There's nothing inherently universal about C. It's just that we've restricted many of our platform ABIs to it, to their detriment.
https://github.com/rust-lang/rfcs/pull/2088#issuecomment-318640032
A Long Time Ago, I found it useful to look for `extern crate` lines to easily see what was an external crate and what was an internal (built-in) crate. Today, it's a bit less important because there are so few built-in crates (about 5 I think) so most people have that list memorized. Perhaps this type of thing might still be valuable to a new rust user? I'm not sure.
&gt; I would love for us to move on from C as the universal FFI. but what would get standardized? rust is there but apple have swift (which when it gets move/borrow could do the same jobs) &gt; There's nothing inherently universal about C. It's just that we've restricted many of our platform ABIs to it, to their detriment. it's the fact that it's *simple*. Rust existed *before* apple chose swift. why didn't they go with it? One answer: they had specific requirements regarding polymorphism (their object system around which their platform APIs are built). my point is as soon as you go 'one level up'.. there's far too many options for anything to become standard &gt; It's just that we've restricted many of our platform ABIs to it, to their detriment. We could come up with name-mangling conventions that imply 'move'/'borrow' , 'which pointer/index parameters pair up to become slices'. Then we'd have something still representable in C. we've got C++ able to represent very similar ideas, and it compiles out to C compatible calls wth name mangling.. Would Rust's specifics become the standard.. why when swift is also trying it. I note in the apple c headers these days they have some markup to make things more binding friendly (nullable prefixes or something) Given my experiences with rust: I would like to keep C / C++ alive. I don't want any one option to have a monopoly. I need C and C++ as a fallback to stop anyone like the rust team getting their way everywhere.
Why is the crate root different for you than other modules in this sense? I've disliked `extern crate` because it requires me to put something in the crate root even though it might be an implementation detail to some other module (for example, some `Store` implementation uses a postgres dependency). So while I actually like the fact that `extern crate` is going away, I would rather like it if a `use` statement was required in the crate root, as it is in other modules. Since that makes the crate root more similar to other modules, I would argue that also makes the module system more consistent and thus easier to learn/understand.
You can write a `[replace]` section (would link to docs but am on mobile)
&gt; but what would get standardized? It doesn't have to be any one particular language. This is why I mentioned slices and ownership- those apply to *any* language, C included (it wouldn't be able to enforce their correct usage, but it could certainly consume them). &gt; my point is as soon as you go 'one level up'.. there's far too many options for anything to become standard Yes, C is simple. But there are plenty more simple things we can add to our ABIs before we have to start picking an object model like Windows and macOS do. It could even be as simple as namespaces!
The original post was about storing a small amount of data in a file. This could be state, configuration or data, I just picked on configuration as a simple example. In my projects, I typically use JSON for small amounts of data (up to 15 fields or so), at which point I reevaluate what I'm actually trying to do and decide the best format going forward. Sometimes this is SQL (at which point I choose between something simple like SQLite and something more complex like Postgres), sometimes I stay the course with JSON. It really depends on the use case. SQLite by default is a bit like using a hammer to push push in a thumb tack (and Postgres is like using a nail gun), though there are certainly a lot of cases where SQLite is the better option.
Are they ever significant?
&gt; Why is the crate root different for you than other modules in this sense? It's not, which is why I also support the other proposal. It's more complex than this is though, which is trivially backwards compatible, and involves a lot less change and a lot fewer details.
As other comments have mentioned, that code is just two statements, in serial, oddly formatted. If you use a rust code formatter (e.g. cargo format), it fixes that right up for clarity.
I can't think of any such case, but not being certain I preferred hedging.
http://doc.crates.io/source-replacement.html
Here's my dependency graph: http://i.imgur.com/mJxFEBE.png
&gt; It could even be as simple as namespaces! I did wonder if we could establish a simple convention for the ```Foo_doSomething(Foo*, ...)``` style naming that maps onto method calls, so many C apis are setup like this , (OOP lite) could you get the Rust and C++ communities to agree on an 'extern "..."' that sets up names in this format. Maybe even directly 'extern C' extended to give a simplified mangle for method calls.
C is a marvellous notation, but not universal. It is the ground state of programming because our operating systems are C machines. My point is simply that you do not need this particular notation to achieve raw performance - a knowledgeable Rust person can do this without knowing C. And they can write more functional style code knowing that the language will do its damnedness to optimise it.
Exactly. One little line needs to be added by one person, and many people can understand the code better. Cargo yes, but rustc is not Cargo and has an independent existence. So I can't understand the need for implicit magic either. 
Since we're talking about hypothetical future platform ABIs, I would much rather just encode namespace paths directly in object files, rather than trying to find some mangling that all languages can agree on. For that matter, going back to the header files I mentioned earlier, I'd rather replace *those* with metadata using the same format, so any language can benefit without pulling in a C parser (or, heaven forbid, a C++ parser). Windows has even started doing this with .winmd files, which just reuse the CLR metadata format to describe WinRT COM interfaces.
Yep! That's the goal. I should have been more explicit about that in the RFC-- I'll add a commit which explains that.
Really nice project I didn't know yet, so thanks for posting. Now, if only cargo compile times were about a fifth of what they are... One suggestions: According to the docs, you still need to specify `// cargo-deps: time="*"` above extern crate declerations. It would be nice if the newest available version would be used automatically if you just specify extern crate without a comment. 
This is an interesting idea, but it's a breaking change from the current behavior of `extern crate` and `std`. I responded with more details in the RFC thread [here](https://github.com/rust-lang/rfcs/pull/2088#issuecomment-318726961).
Thanks for that. Personally, I disagree, but whatever is suited to your style and use-case the best. :) 
I'm not sure my alternative proposal is all that much more complex. It would just boil down to "extern crate foo;" becomes "use foo;" instead, which in terms of backwards compatibility has the same sort of impact, right?
I really feel that `Cargo.toml` should stay as part of the build system and not be required to understand the source code. I also agree with others in this thread that `extern crate` helps me understand what is being used at a glance much easier. I really dislike the idea of having to check another location just to find which crates are being used. Going further I feel like this makes sharing code examples much harder. Anyone who asks a question and shows their `main.rs` file now also has to provide a `Cargo.toml` file (remembering to anonymize it if they desire that).
Sorry! I meant https://www.reddit.com/r/rust/comments/6pstlx/revisiting_rusts_modules_language_design/ when I said "other proposal"
It would be unusual to prototype in C, despite the compiler being so fast these days. The libraries are so clunky or low level, and the safety is always off. C++ is not much better, although the level of abstraction is more comfortable. People are more likely to do their first sketch in something more forgiving and ergonomic like Python or Lua (my favourite ). For Rust, maybe we haven't forged an informal style yet. I remain hopeful. 
I've found trying to use type annotations broke a bunch of my integrated helpers, like Travis CI, etc. 
It's not about illegal behavior, I'm just trying to understand what these declarations actually entail and why they were defined this way. &gt; because in the first example contents can't be reassigned for the lifetime of the borrow Doesn't the same hold for the second example?
How can it be both the year of Lisp AND Linux. ;)
http://doc.crates.io/manifest.html#the-replace-section
&gt; Going further I feel like this makes sharing code examples much harder. Anyone who asks a question and shows their main.rs file now also has to provide a Cargo.toml file I think this is already an issue-- without `Cargo.toml`or similar, you don't know what version of a crate is being used. IMO this is something we need to work on as a community, and it's something I'd like to see reflected in the Rust playground.
I'd argue that most crates don't change that much over versions. Like for example byteorder, what has changed about its API? So that's why I prefer extern `crate foo = "5.0"` over your RFC.
C++ can kinda do them. But its still very manual and hardly compiler enforced.
I agree with this, but there is always going to be a `use thing::...` statement soon after the `extern crate thing`, right? The only exception to this is `#[macro_use]`, but soon macros will be `use`d just like everything else.
I see. I guess that only matters in the main.rs or lib.rs file, so I haven't really noticed it... but I think I would prefer requiring a `use` statement anywhere the crate's modules are used (but please get rid of `extern crate`!)
If those get added, `Sample` should definitely be renamed `Distribution`. Frankly, I haven't seen much advantage to having a trait implemented by every distribution. One could get much the same effect by wrapping a distribution in a closure, I imagine (`|rng| f64::exp(Normal::new(...).sample(rng)))`).
I would be a big +1 for `use foo` replacing `extern crate foo`, is that in an RFC too?
&gt; I'd argue that most crates don't change that much over versions. Maybe an extreme example, but basically every crate using HTTP has changed significantly in order to support async/Tokio. &gt; I prefer `extern crate foo = "5.0"` I'd like to understand why you want this. To me, it seems like there is lots of information about dependencies provided by `Cargo.toml` that can't be inferred from Rust source. You'd still need a `Cargo.toml` file, and that `Cargo.toml` file would be in charge of describing most of your build information. What is the purpose of moving _just_ dependency declarations out of the build file and into Rust source?
Its the same kind of argument that was made when ? was introduced: "everyone who doesn't like ? can just use try!". Now I'm hearing talks already that people want to deprecate or remove the try! macro in a future epoch, and it has also been replaced in all official examples and documentation. So it doesn't help us at all. Also, if you now want to have your codebase have a full list of explicit `extern crate` definitions, you need to write a linter tool to prevent any PR to be made that adds a dependency but doesn't add an `extern crate`.
That pretty much already is the case. The problem with `char` is: most people don't want random chars, and if *you* do, then you probably mean some specific subset of `char`, not just *any* `char`. Thus there's little point trying to provide a method generating a random one.
extern crate certainly help me (not a beginner) to find out whether something is a module or included by a glob import, or similar. Because when I see the extern crate, I know I can stop searching. 
&gt; doesn't mean the fields of the String struct isn't. They can being changed internally (in case of `.push()` for example), but the same notion of mutability can be expressed by using `&amp;mut String::new()`, correct? I guess my question could be phrased as: is there an advantage that `let mut s = String::new()` provides over `let s = &amp;mut String::new()` in case I don't care about rebinding `s`?
It's not -- I'm discussing it with /u/cramert in the OP PR comments.
I find this to be a personal preference thing. I love prototyping in Rust. I don't find it particularly slow. I think it's easier to have a discussion on concrete things -- for example, you mentioned method overloading -- because each particular feature that may be a boon for prototyping will have its own specific set of pros and cons that can't be generalized to other "prototyping" features.
(Oh no, how did it reply to the wrong comment D: ) &gt; Having something in Rust be immutable is this amazing promise that the variable cannot be changed. Except when using interior mutability (like Cell and similar). That's not really true: fn main() { let x = &amp;mut 5; *x = 4; println!("{}", x); } [Playground](https://play.rust-lang.org/?gist=b26f407de610d137782b8f7b38c01e8b&amp;version=stable) No Cell type, but it still mutates it just fine. Replying to your comment now: There is no advantage, and it's actually kind of weird that it doesn't give a warning. So I opened an issue about this earlier.
RLS uses racer along with its own stuff, because racer is faster than the compiler for basic info like completion
I agree; though at the same time the type-driven approach may generally work well (for user-defined types) so it's nice if supported.
~~or `#[deny(unused_imports)]`~~? I agree, though I feel that this would be an easy lint to add in the RFC. AFAIK, this lint is free with this RFC. But just to be clear, I'm not a fan of using anything inside a module that has no indication from where it came. If I will be using the namespace inside main/lib.rs, then I will be using `extern crate`. If I will only be using it inside a module, then I will have a `use rand;` inside my module as I normally would. All in all, it seems like a win to me.
&gt; You'd still need a Cargo.toml file Yeah I know its kind of a goal of you (and the lang team) to eliminate `lib.rs`/`mod.rs` entirely but I clearly hope that this won't happen... I especially don't think that eliminating a certain class of file should be such an important goal that you are ready pay with complication at another spot. &gt; that Cargo.toml file would be in charge of describing most of your build information This is IMO what Cargo.toml should focus on: describing build information. The format is complicated, and you can have a `[dependencies.foo]` section as well as `foo = "0.4"` inside the `[dependencies]` section. I've overlooked the `[dependencies.foo]` section many times already. The Cargo.toml format is not really convenient to read at all. So here's where `extern crate` is so useful. I most times don't need to know that some specific thing about a crate is being used, I just need to know that it *is* used. So it plays an important role in my eyes. &gt; What is the purpose of moving just dependency declarations out of the build file and into Rust source? I want to open as few files as possible in my editor. Opening Cargo.toml means I have to open an additional file. The file ending toml and the location outside of src means that I need to explicitly mention it. When working on smaller crates, I usually just open `src/*.rs`, with this change I'll be forced more often to open Cargo.toml as well, so I need to type `src/*.rs Cargo.toml`. This means that for me, there is an overhead.
&gt; I really dislike the idea of having to check another location just to find which crates are being used. Using `extern crate` doesn't fix this much. I personally don't spend much time in `lib.rs` because my code is broken into modules. And if I don't break up my code, it's easier for me to open `Cargo.toml` in another tab than to scroll up 800 lines to the top of `lib.rs`. `Cargo.toml` also gives *more information* (e.g. which versions, features are used), so I see `extern crate` statements as being completely redundant, unless you're doing something like adding a `#[macro_use]` statement.
I don't know enough about your problem to know exactly what you need, but one fairly simple thing you could do is to wrap your struct in a `Rc::new()`, which you can clone to get three copies, and then you could stash each of these in three `HashMap&lt;usize, Rc&lt;YourStruct&gt;&gt;` you index by each of the respective fields. This is an example of an index (three, really) that just has references. However, Rust manages the references for you. If you want to mutate the referent you'll want something more complicated (probably `Rc&lt;RefCell&lt;_&gt;&gt;` at first), but you'll need to be in charge of maintaining consistency of the indices. If you want a large volume of these things you may not want to have each of them be boxed allocations. If they are small and you don't need to change them you could just have three copies of each. Generally, Rust is pretty good at letting you write what you'd like, but determining what you'd like is now up to you. :)
Title aside this introduced me to some great things I was not aware of as a Python and rust dev. Shame to be so lost on the title....
How big is your set of objects ? Unless you have billions of objets, you can reasonably expect the Uuid to not collide. Then I would simply use a Hashmap with Uuid -&gt; references to your objects and do a lookup in that
I've been putting `extern crate` in submodules in my current project without further issues, so im confused my your first point.
&gt; There is no advantage, Is there a reason the documentation then defaults to the first case? E.g. [here](https://doc.rust-lang.org/book/second-edition/ch02-00-guessing-game-tutorial.html): let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect("Failed to read line"); could be written as let guess = &amp;mut String::new(); io::stdin().read_line(guess).expect(...) or [here](https://doc.rust-lang.org/rand/rand/index.html#monty-hall-problem) let mut rng = rand::thread_rng(); could be written as: let rng = &amp;mut rand::thread_rng(); Edit: This seems to make a difference: use rand::Rng; use rand::distributions::{IndependentSample, Range}; fn generate_random_number(rng: &amp;mut Rng, low: i32, high: i32) -&gt; i32 { let between = Range::new(low, high); between.ind_sample(rng) } results in: error[E0277]: the trait bound `rand::Rng: std::marker::Sized` is not satisfied between.ind_sample(rng) ^^^^^^^^^^ `rand::Rng` does not have a constant size known at compile-time However this works: fn generate_random_number(mut rng: &amp;mut Rng, low: i32, high: i32) -&gt; i32 { let between = Range::new(low, high); between.ind_sample(&amp;mut rng) } What gives?
I'd argue it's more about removing duplication than making things less explicit. It is still explicit; it's defined in the Cargo.toml (or other build system).
GDB has `set print pretty` which gives a similar output to the derived `"{:#x}"`, but that won't run `Debug::fmt` on the type. So if you have some custom debug printing function it won't use it. The problem is that the compiler will often not even generate machine code for the format function. It does this if the function isn't used anywhere in your code to save space. So when you try to call the format function, there's simply no code there to call. If we could ensure that the format function was compiled, we could write a wrapper function like: fn print_any&lt;'a&gt;(object: &amp;'a ::std::fmt::Debug) { println!("{:#?}", object); } Calling it from our debugger will still be hard because (GDB at least) doesn't yet understand trait objects. You'd need to make a function for each type that you wanted to print.
Oh no, that's because you x is a reference to a mutable variable. x itself isn't mutable and can't be changed to reference something else or whatever.
I think anything that references something that isn't a variable (such as `&amp;mut String::new()`) creates a new temporary variable. So yeah, it should have the advantage of one less variable.
suppose we had something like this: // case 1: let mut file = std::fs::File::open("filename"); let mut contents = String::new(); file.read_to_string(&amp;mut contents); let other = &amp;mut contents; contents = String::new(); // case 2: let mut file = std::fs::File::open("filename"); let contents = &amp;mut String::new(); file.read_to_string(contents); let other = contents; contents = String::new(); both of these blocks will have compilation errors, but for different reasons. the assignment in the first one fails because `other`'s borrow is still in scope, but the second fails because `contents` isn't declared `let mut`, so it can't be reassigned at all. since the type of `contents` in the first example is `String`, we can always get a mutable reference to it, but e.g. we can't call `into` on the second, because we don't have `self`, we only have `&amp;mut self`. i don't think that was necessarily helpful to you, but i wanted to make sure we were on the same page. could you tell me what you meant in your post by this? &gt; the first case is only possible if the declaration is rebindable (via mut) what specifically about the first case are you referring to being 'possible'? the `&amp;mut` borrow? and re: the second part of your post: &gt; I'm trying to understand how having a rebindable declaration implies that it is possible to take a unique reference to the object to which it references could you clarify your concern here? is the worry that because a variable declared `let mut` can be reassigned, its rvalue might not be unique? let me know if this clarifies things at all: in the first case, `contents` is of type `String`. that means that it already uniquely holds the rvalue&amp;mdash;we're guaranteed that nothing else does (except as a borrow). If we had `let mut contents = String::new(); let x = contents;`, then `contents` can no longer be used to access the string because it has been *moved* to `x`. does that help?
In my case everything is happening inside an `Arc&lt;Mutex&lt;T&gt;&gt;` so would be `Arc`, but this seems like a good approach. Do you know whether it's a good idea to store only a `Weak` in every "index" except the first one? Then I can just remove from one and every so often clean out the others? Maybe that's overthinking it. 
In the first program `contents` is a mutable variable of type `String`, while in the second `contents` is an immutable variable of type `&amp;mut String` (that points to an unnamed, mutable variable of type `String`). Because the second `contents` is immutable you cannot make it point to a different location, only mutate the `String` at the current one.^* The first `contents` however, can later be assigned a different `String` with `contents = new String()`. Rebinding or redeclaring is different from mutating: Rebinding is declaring a new variable with the same name of an existing variable. The old variable still exists, but is "shadowed": let foo = 1; if true { let foo = 2; // `let` (re)declares } print!("{}", foo); prints 1, while let mut foo = 1; if true { foo = 2; // no `let` (re)assigns } print!("{}", foo); prints 2. The new variable can even be of a different type: let foo = 1; let foo = false; ^* You can replace the `String` it points to with `std::mem::replace()` or `std::mem::swap()`, but that doesn't mutate the reference. 
If C was restricted to 'low level' bit bashing/raw pointers it might be ok, but people take low-level principles into high level programs and it causes all kinds of problems. The amount of "truly low-level" work that needs to be done in the scope of the entire industry is tiny, but the amount of C is ridiculously large. Rust can and should flourish in that space where people's use of C is just making things harder for themselves and everyone else, but only if its value proposition gets stronger rather than weaker over time, which I suspect is a coin flip at this point. Also I don't think C is "syntax-optimized" for anything... the syntax is really just arbitrary and not really even good at what it does do.
Hi steve, I realized my arguments are pretty flaky. I believe [skad's argument](https://github.com/rust-lang/rfcs/pull/2088#issuecomment-318753150) is much clearer.
It's kind of unsightly, but you can do let v = vec![ 1, 2, 3 ]; let (a,b,c) = (v[0], v[1], v[2]);
&gt; Yeah I know its kind of a goal of you (and the lang team) to eliminate lib.rs/mod.rs entirely but I clearly hope that this won't happen... Just a note on this piece: it's really unhelpful to characterize things this way, because it sets up a toxic us-versus-them mentality. Please, please don't perpetuate this framing. The various subteams are made up of individuals with their own perspectives and goals, and we take the RFC process *very* seriously (more on that at https://request-for-explanation.github.io/podcast/ep3-aarons-favorite-topic/index.html). Ideas floated by team members in blog posts, forums, and even RFCs **are not guaranteed to actually land**. There are plenty of examples where RFCs by subteam members have either failed outright, or been greatly improved thanks to broad feedback. This isn't an adversarial process. It's a collaborative process, and one in which subteam members try very hard to actively seek feedback and listen to it and make improvements. But it seems like folks often feel they have to push back with maximum force, lest something they don't want come to fruition. When you multiply that out by hundreds of comments, it becomes very draining. I would like to see the Rust community as a whole place more value on the importance of *listening well*: trying to understand the motivations, concerns, and constraints of others, and incorporate (or at least respond) to those in design discussions. Asking questions more often than making strong statements. (Ideas are often dismissed by saying "I see no value in this" rather a more interrogative mode of "Can you expand on the motivation here on this concrete example?") I'm not saying the subteams are perfect at this by any stretch, but I think discussions are more fun -- and lead to better outcomes -- when we all put in the effort to empathize with the perspective of others.
Replace worked great! Thanks!
I've read most of "the book" so now I'm trying to make a calculator which I'd like to eventually turn into a small CAS. The infamous dragon book is proving very helpful for this task. 
Indeed. I've personally already have formed a habit to check Cargo.toml before looking at source code. Since I'm almost never looking at the root crate and from within a module I already can't tell if `use rand;` is a module or external crate.
&gt; e.g. we can't call into on the second, because we don't have self, we only have &amp;mut self. &gt; &gt; &gt; &gt; i don't think that was necessarily helpful to you, but i wanted to make sure we were on the same page. This is more or less what I was looking for. So it is *not* possible to write code that calls `into()` in the second case since `into()` only takes `self`. And it doesn't seem possible to get around that (I tried `let v: Vec&lt;u8&gt; = (*contents).into();` and that fails to compile as well, though for another reason (**cannot move out of borrowed content**), which I'm not sure why that is). In the case where I simply want to read the contents of a file to a `String`: let mut contents = String::new(); file.read_to_string(&amp;mut contents); it seems it would be more or less a style difference whether I write the above, or write `let contents = &amp;mut String::new()`, correct? &gt; If we had let mut contents = String::new(); let x = contents;, then contents can no longer be used to access the string because it has been moved to x. does that help? The same apples if `contents` was not mut (i.e. `let contents = String::new()`), or in case it was declared as `let contents = &amp;mut String::new()`. In both cases `let x = contents` would result in a move, meaning that semantically, both syntaxes are equivalent. I may have found another difference in a post I made in this thread [here](https://www.reddit.com/r/rust/comments/6q4xq9/let_mut_x_vs_let_x_mut/dkuw0zg/). Though it could be intersecting with another Rust feature. Edit: I found yet another difference: This compiles (edited from your first example): let mut file = std::fs::File::open("filename").unwrap(); let mut contents = String::new(); file.read_to_string(&amp;mut contents); { let other = &amp;mut contents; } contents = String::new(); But this does not: let mut file = std::fs::File::open("filename").unwrap(); let contents = &amp;mut String::new(); file.read_to_string(contents); { let other = contents; } println!("{}", contents); The scope doesn't seem to have an effect in the second case. Desired behavior or bug? 
Hello aturon, I just wanted to say thank you for work so far. I apologize If I came off as adversarial. On my side of things it took time for me to realize what stemmed my real concerns, that was a lack of foresight on my behalf.
When you get these `*mut Foo` and `*mut Bar` pointers via FFI, are you the *owner* of those pointed-to values? As in, are you responsible for `free`ing the pointers or otherwise running some kind of destructor on them? If so then you shouldn't be converting them to references since your `FooWrapper` and `BarWrapper` types logically own the contained values rather than borrowing them. I know that doesn't really answer the question yet but it's important to know the answer to that before going further
Although I somewhat agree, I think you are under estimating the portability of C.
No worries, and I'm not trying to call out anybody in particular! I know that we're all passionate about Rust and want it to be the best it can be. I just think the key to doing that is listening, and working toward a world in which the merits of an argument, not the forcefulness of its tone, is what matters.
&gt; it seems it would be more or less a style difference whether I write the above, or write `let contents = &amp;mut String::new()`, correct? in this particular example? sure. but the type of `contents` isn't the same in both cases, so if you need a `String`, you have to use `let mut contents = String::new()`. if all you need is `&amp;mut String`, then yes, you can use either.
Makes sense! I amended my previous post with a small modification to your example. Do you know why adding an explicit scope makes the first example compile, but not the second? 
In the second example, you are moving the borrow, and then dropping it at the end of the inner scope. In the first, you're simply creating a new borrow for the length of the scope, but as soon as it ends, you can use the original binding again. I think you might be able to do the same thing with a mutable reference (ex. 2) by using `let other = &amp;mut *contents;` instead – reborrowing instead of moving the borrow.
As someone who obsesses over API design, I rather like exploring how to express invariants in a strong, rich and sound type system like Rust. Although that probably is not what you meant (you probably meant UI prototyping).
In the first example, the borrow only lasts as long as that inner scope does. So `contents` isn't borrowed anymore at the time of the reassignment. In the second example, the lvalue `contents` is immutable&amp;mdash;it can't be reassigned at all. The string it points to *can* be mutated in place, but `contents` can't ever point to a different instance of `&amp;mut String`. ______ You also have an edit: &gt;And it doesn't seem possible to get around that (I tried `let v: Vec&lt;u8&gt; = (*contents).into()`; and that fails to compile as well, though for another reason (cannot move out of borrowed content), which I'm not sure why that is). You can't dereference `contents` because then e.g. it would be possible to get `self` from `&amp;self` (which would allow you to re-borrow as `&amp;mut` or consume `self`). This would be a different story if `String` implemented `Copy`&amp;mdash;you could do a deref because you wouldn't have to move the value, it would just be copied. A good way to think about this is with numeric types (which are some of the few types that by default implement `Copy`). You can always do `let x = 5; let y = x; println!("{}", x)` and the compiler's not going to complain, because implicitly what's happening is that `y` is copying the value of `x`, rather than trying to take ownership of it.
True, I was just showing a quick demo. In Ruby you can use popen if you've got untrusted input. name = "*.rb" ruby_files = IO.popen(['find', '.', '-name', name]) { |io| io.read }.lines.to_a Or system if you don't care about the output: system "ls", "-l" We're talking about scripting languages here though, so if you're just writing something quick and dirty for your own automation purposes you do what you want.
Will look into it. Running `cargo run --example test_window` reports `thread 'main' panicked at 'not yet implemented', examples/support/mod.rs:40:37`, though hello_gfx does work. What about it do you say makes it more usable? It doesn't seem like it has a huge amount of documentation (at least for the rust bindings)? Since it's immediate mode, is this something that Condor would eventually be aiming to displace?
Yeah, you are entirely right, it was unhepful to have said that. I regret having it said.
&gt; I did wonder if we could establish a simple convention for the Foo_doSomething(Foo*, ...) style naming that maps onto method calls, so many C apis are setup like this , (OOP lite) &gt; &gt; could you get the Rust and C++ communities to agree on an 'extern "..."' that sets up names in this format. Maybe even directly 'extern C' extended to give a simplified mangle for method calls. Template instantiations (i.e. monomorphizations of parametric polymorphism) also need some ability to define a custom mangling that's `extern "C"`-compatible. Even C11 has added a simplified version of this with its `_Generic` declarations in header files.
&gt; Windows has already done that with COM, for example- C just plain isn't universal there. COM isn't for library linking, though - the modern equivalent to COM in the Linux world is `dbus`.
&lt;3
COM is the only way to access many platform APIs, as well as third party components. It can be used for IPC too, but it's definitely a library linking thing.
That's what I went with in the end, yea. 
I would absolutely love something like this. I've been wondering about using macros to build something like JSX, which just boils down to `createElement` calls for something like emscripten. I'm sure there would be a ridiculous amount of hurdles, but avoiding writing JS would be a very happy day for me.
I have a decent amount of experience in both Python and Matlab. I would **never** choose Matlab over Python.
That's fair, but it's not really an intrinsic property of C... it just exists because time and tooling have had since the 70s to develop around it.
I am responsible for calling a function letting the other library know that I am done with them, however I am not the owner. There is a reference count on the other side that is, but I am responsible for decrementing this count once. That's where the custom Drop logic I mentioned comes in.
Nice! yeah I really like how you can expose a type safe interface over dynamic types with a little help from `Any` and `TypeId`. I originally got the idea from [anymap](https://github.com/chris-morgan/anymap)
&gt; I think you might be able to do the same thing with a mutable reference (ex. 2) by using let other = &amp;mut *contents; instead – reborrowing instead of moving the borrow. Yep, that works :-)
Makes sense! Thanks for taking the time to reply, that was very helpful.
Anterofit author here. Glad to see it's getting some use in the wild! Minor nitpick/trivia, `GET()` isn't a macro (it isn't invoked with `!`); the `service!{}` macro just looks for a function-like invocation in the first line of the method body, parses the name as an HTTP verb and passes the arguments to `format!()`.
Well I'd argue it IS an intrinsic property of C. It maps easily to assembly and is relatively easy to write a k&amp;r compiler in most assembly languages. It (relatively) doesn't have much abstractions and is quite simple. Why isn't basic as portable? Or LISP? these came around or before and they are less portable. C was designed for rewriting Unix (written in asm). It was a portable assembler.
&gt; &gt; sysops + scripting = sh/bash &gt; &gt; Sure. Unless you want to deal with any non-trivially-structured data. When you Sysadmin you do not want to deal with such data. And when you need to deal with something that AWK cannot parse then in 99% of cases you need `jq`. MATLAB isn't for data processing but rather for marices and vectors computations (linear algebra) and this is the place where it excels, in other cases it is madman dream. 
It runs fine now. I think I had a weird cargo.toml. Cleaned it up and even copying examples into my own project is working. Thanks!
I was aware of that but the old README of racer seemed to imply that it won't be needed in the future. RLS should be able to provide very fast completions on it's own as soon as it has an AST after initial "indexing", I reckon?
I believe it's a temporary solution while the necessary compiler work is being done.
I don't know, you seem to know more than me. :P I think incremental compilation is something they're waiting on though
If it's a consuming iterator of `String`s, you can do: string_iter.collect::&lt;Vec&lt;String&gt;&gt;().join(", ") Which I [benchmarked](https://gist.github.com/green-s/fbd0d374b290781ac9b3f8ff03e3245d) against `itertools::join` and got these results: test consume_collect_join ... bench: 63,260 ns/iter (+/- 18,295) test consume_itertools_join ... bench: 82,640 ns/iter (+/- 30,842) When you have a borrowing iterator of `String`s you can do: string_ref_iter .map(|s| &amp;**s) .collect::&lt;Vec&lt;&amp;str&gt;&gt;() .join(", ") Again that seems faster than the itertools equivalent: test borrow_collect_join ... bench: 24,071 ns/iter (+/- 11,873) test borrow_itertools_join ... bench: 41,002 ns/iter (+/- 6,126)
&gt; When you Sysadmin you do not want to deal with such data. And when you need to deal with something that AWK cannot parse then in 99% of cases you need `jq`. `jq` helps, but with bash you can quickly get to the point where your code is doing a simple data transformation in some highly obscure way. That's when you want to switch to Python.
If you specify a version that is semver-compatible as a dependency of A then cargo should use that version as a constraint. So if `D = 0.1.2` is broken, but `D = 0.1.1` is okay you should be able to do: [dependencies] D = "= 0.1.1" and C will use the same version that A does. This doesn't work if you _need_ a semver-incompatible version in A than C does.
This is kind of misleading-- `x` here _is_ actually immutable. `x` is an immutably-bound reference to a mutable value, `5`. This becomes clearer if we write it out like this: let mut hidden = 5; let x = &amp;mut hidden; *x = 4; println!("{}", x); As you can see, we never mutate `x`-- what's actually being changed is the value of `hidden`.
you can have a library and a binary in your cargo toml, and you may wish to separate out your dependencies that way when possible. business logic in lib.rs, clap-rs in main.rs, say. [it could be better supported though](https://github.com/rust-lang/cargo/issues/1982)
Since a Bar cannot exist without the Foo that created it, why not get rid of BarWrapper altogether? Store the *mut Bar instance inside the Foo instance. Foo::get_bar() creates the Bar if it doesn't exist, and returns a &amp;Bar (or &amp;mut Bar, if needed). The user can manipulate the Bar via this method. When Foo is dropped, it decs the Bar ref count first, then the Foo ref count. 
Because there's multiple different types of Bars and the user may only want one or two of them. There's a large amount of overhead to getting the ones you don't need.
Okay, so you logically have shared ownership of the contained value, which is still different from borrowing the value. So it sounds like you want your `FooWrapper` to just be struct FooWrapper { pointer: *mut Foo } Then you impl a `FooWrapper::new()` function that acquires the pointer and increments the refcount, and then make a `Drop` impl that decrements the refcount. Notice how there's no lifetime annotations involved here because the liveness of the pointer is determined on the other side of the FFI boundary. All you're responsible for is helping maintain the reference count. `BarWrapper` and `FooWrapper2` would be designed similarly, except for the part where you want `BarWrapper` to always outlive `FooWrapper2`. Anyway, does the state flow in a well-behaved use of this library always go from `FooWrapper` -&gt; `BarWrapper` -&gt; `FooWrapper2`? If so, it sounds like you could have `foo_wrapper.get_bar()` consume `self` without decrementing the refcount, and then `BarWrapper` would take and hide the `*mut Foo` inside of itself. After that, you call something like `bar_wrapper.foo_step2()`, which would *not* consume `self`, but it would return an instance of `FooWrapper2` with the smuggled `*mut Foo` now passed into it. That way you can only ever create a `FooWrapper2` if you already have a `BarWrapper`. EDIT: You could then use `PhantomData` to enforce `BarWrapper` always outliving `FooWrapper2`. I think it would be something like struct FooWrapper2&lt;'a&gt; { pointer: *mut Foo _phantom: PhantomData&lt;&amp;'a BarWrapper&gt; } If that relationship is too rigid though, you could probably do some other cheeky things with the reference counts to keep `Foo`'s count from ever going to zero before `Bar`'s does too. 
Probably true. However, since there isn't a timetable for when RLS would be ready to take on that role, having racer stay up-to-date gives the community the best editing experience possible.
I think these have all emphasized emscripten so far, but should be a starting point: [webplatform](https://github.com/rust-webplatform/rust-webplatform) [stdweb](https://github.com/koute/stdweb) [domafic](https://github.com/cramertj/domafic-rs) (react/elm inspired) [quasar](https://github.com/anowell/quasar) (my own musings that has an in-progress overhaul that keeps getting distracted by other shiny things)
That won't work. The package name and crate name don't have to have anything to do with each other. Knowing one doesn't tell you the other. Also, you really shouldn't be using `*` as a version spec; it dramatically improves the chances of your code not working in the future.
How about skipping partial version? Like `//cargo-deps: blah="1.2.x"`
What do you mean? `cargo-script` uses the same version specs as Cargo itself.
~~This is only a quick hack, but could your Foo be part of an enum that consumes and goes to the next state when it is done (eg an enum of `FooWrapper` and `FooWrapper2`? You could have the bar be sure to only survive as long as the enum, solving the lifetime issue (I think?).~~ Nevermind that wouldn't work. I think you might need to consider a restructuring. Can Bar perhaps live inside of the FooWrapper, meaning you need to access it with an explicit method call? That would still mean Bar can't live while Foo changes though, which might be a problem for you. Otherwise you might need to look into `Rc` and it's associated `Weak` (e.g, when `FooWrapper` is dropped, you only have `Weak` references to `Bar` outside of it.)
I think there's an rfc about this: https://github.com/rust-lang/rfcs/issues/1936
I rarely find myself needing or wanting debuggers in rust development compared to other languages due to the Result based error handling. That being said, when I do need a debugger I really would like this feature. Especially for standard library types like Vec and HashMap, the default lldb visualisations come down to "yup there's a pointer there" which doesn't help all too much. If this was a feature though, what's supposed to happen if the format function panics (or worse)?
Look also into [coaster](https://github.com/spearow/coaster) - yet another fork with a bit more recent activity and a gitter channel.
This seems like something I'd rather just have IDEs provide for me. In Java I just do auto import with intellij and problem solved. but when someone else is reading the code everything is explicit and documented right there at the top. Just solve this at the IDE level.
Are there any asynchronous database ORMs/query builders? Ones that don't block on query requests basically. I am aware of Diesel, but it doesn't seem to use Futures in any way, so I'm assuming it blocks and am concerned about it potentially being a major bottleneck when building a web application. Background: I'm primarily a node.js developer. I understand that Rust typically leaves the work of running an event loop and Promises up to external crates, but I'm having difficulty wrapping my head around how I'd build a simple non-blocking CRUD REST server with Rust, given the available community crates.
Agreed. Servo starter problems are a great way to get some exposure once you've done a few toy projects. 
Hoping to add a feature to a tool I made for the day job, [release-party](https://github.com/matthewkmayer/release-party-BR). Specifically, adding which PRs are included in the PRs it creates on Github.
&gt; Neither me nor most of my colleagues that I train know C to begin with. We know Python. We want to drop down a level to compiled fast code, but we're not going to become C experts. The promise of going down to a lower level safely (while bringing in existing scientific C libraries as well) is important for us. Hi. I authored the cookiecutter project that was included in the article. You're describing exactly who I had in mind for the project. Programmers who work with languages like Python, don't know C, but need to start going fast. They probably can't start from scratch in a new language, but they're a bit weary of learning C. IMO that type of programmer will prefer Rust over C as long as the tooling exists to support the two side-by-side. You can check out the thread I wrote about it in r/python a few days ago. https://www.reddit.com/r/Python/comments/6masn0/build_and_release_python_binary_wheels_with_rust/ 
Despite to visual similarities, `mut` and `&amp;mut` are not related. `&amp;mut` isn't even about mutability at all, it's about exclusive access. `mut` is about reassigning to a variable and only really means anything if you're trying to pretend that rust is a functional language. While `&amp;` and `&amp;mut` have clear differences in how they can be used, making all `let` bindings `mut` just adds warnings and changes nothing about the semantics of your program. When you own your value, nobody cares if you reassign it.
If you're talking about prototyping a feature or a program, I have to agree that rust gets frustrating fairly quick. When trying to do things that you never did before you'll be hitting many compiler errors, sure that some of these would become runtime errors, but when you are just trying to discover a way to turn what you want into a program, most of these compile time guarantees would never become runtime errors (unless you are specifically going for things like concurrency, memory management, ...). To me, rust seems like the language I would use after the prototype is done and validated. It's almost like rust does too much of a good job catching possible mistakes, when, sometimes, "quick and dirty" does the trick just fine. I can see myself and my college friends failing a class that uses rust by not being able to deliver the semester project on time (which is a shame, because a rust project would probably get a 10 - no bugs, score).
But I think his goal (and certainly my goal) is to update a running executable without the user having to restart it. In my case it's IoT clients. If you only change the exe link, it will continue running the old exe until reboot.
While the unsafeties in C make things awkward for things like arrays and strings, variadic functions in C are pure BS. I don't know of any language other than C or C++ that blindly pushes arguments onto the stack and prays the the callee uses them all while the callee prays that the caller pushed enough arguments. From what I can tell, implementing a variadic function in C requires the use of macros to insert assembly that retrieves the stack pointer. Please, for the love of programmers everywhere, don't write a language that depends on printf or any other variadic C function. Do you want to be completely independent in the future? Because there's no way you're re-implementing printf in a good language that's ABI compatible. I apologize for the rant. Trying to use debug print calls in a Nim kernel uses sprintf for printing out floats and pointers. Things like memcpy are really easy because it's actually a good procedure unlike sprintf.
It's probably worth noting that on Unix OsStr(ing) is not nessarily utf-8 either. iso8859 is still an option for $LANG on Linux. Unix filenames can arbitrary bytesequences (except 0, except for Linux' special UDS namespace that starts with '\0' but you probably don't want to use a Path(Buf) there). Most programs should probably just use UTF8, (except maybe utitlies like mv, rm, etc, otherwise you can't get rid of files with non-utf8 names)
Agree, I wish there was a lib to interact with the DOM, so that one could define Custom Elements (Web Components) in Rust.
Which version would be more idiomatic? I always used to write it like the first version, even though I never reassigned `contents` afterwards. Wouldn't it be more idiomatic then to write it like the 2nd version?
The fact that C/C++ are such verbose and clunky languages gave rise to the trend of 'prototyping' before a 'serious' implementation. In my experience, in Rust you don't need that, you can just go seamlessly from a small MVP application to a larger one without switching languages/infrastructure. Because it's performant from the start, unlike when prototyping in e.g. Python, and also type-safe from the start. So you just extend your small project more and more over time. Sure you might have to refactor some things, but you don't have to prototype in a different language. I find myself writing even one-time-use scripts in Rust where I would have used Python before (using cargo-script). When you're new to Rust and still fighting the borrow checker and looking up a lot of stuff in the std doc, just keep at it, soon you'll be much faster and run into fewer compile-time errors.
Unless your struct has a `Drop` implementation that frees memory, using Weak `Arc`s won't result in any savings. The weak pointers won't stop the `Drop` from happening and freeing memory, but they will keep the pointed to data alive consuming space. You also won't recover the space in the map. I would suggest implementing a remove method on the data structure holding the maps that remove the entries under all the uuids at the same time. Also consider combining the maps into a single `HashMap&lt;Uuid, _&gt;`. Because they are uuids, you shouldn't need to worry about collisions, and a single map will be easier to program against.
Thanks! I guess the first thing to try is to get shadow Dom going with diffing and sync the changes to the real Dom and benchmark it vs React to see if there even is a performance increase using this approach.
I've mostly wanted to avoid virtual DOM stuff right now since you have to go through Javascript FFI to access any web/DOM APIs, so maybe you can make the diff faster, but accessing the DOM will still be the same, and I presume you'll end up with a lot of extra allocations moving across the FFI boundary. You might want to keep tabs on the [WASM GC work](https://github.com/WebAssembly/design/issues/1079) which is when I'd expect rust wasm DOM stuff to become much more interesting.
Great that someone put in the time and effort in any case!
It's been a while since my last blog post! Today I'm presenting the next version of the RTFM framework which I have been iterating on for several weeks. I'm pretty happy with the outcome: simpler, faster and now with full support for Cortex-M0(+) and MSP430 microcontrollers. Wondering if there's any interest in me writing about the implementation of the procedural macro used in this new version? It was my first time writing a procedural macro but error-chain, syn and cargo-expand made the process relatively painless. I'm particularly happy with how the error messages of the proc macro turned out. For instance, this app! { device: blue_pill::stm32f103xx, resources: { static ON: bool = false; }, tasks: { SYS_TICK: { path: toggle, resources: { ON }, // &lt;- wrong delimiter! }, }, } produces this error message error: proc macro panicked --&gt; examples/blinky.rs:15:1 | 15 | / app! { 16 | | device: blue_pill::stm32f103xx, 17 | | 18 | | resources: { ... | 27 | | }, 28 | | } | |_^ | = help: message: Error: parsing Caused by: parsing `tasks` Caused by: parsing task `SYS_TICK` Caused by: parsing `resources` Caused by: expected Bracket, found Brace which is certainly an improvement, IMO, over the errors you get from `macro_rules!` macros. 
Glad you like it :)
&gt; Despite to visual similarities, mut and &amp;mut are not related. &amp;mut isn't even about mutability at all, it's about exclusive access. Which is exactly the point of my question in the first place :-) But they are related due to the fact that you are only allowed to take a `&amp;mut` reference to a value/variable that is itself declared to be `mut`. One poster here mentions that it is due to "inheritance".
&gt; Wouldn't it be more idiomatic then to write it like the 2nd version? It seems as per the docs and most open source projects I've seen that people tend to go with the first version. That's one of the reasons I asked this question since it seems more specific to write the 2nd version.
Am I the only person who saw the RTFM acronym and thought of "read the f**king manual"?
Awesome, looks like some good improvements. I was waiting on the gpio hal trait to be done to get back to working on things, but I think I'll port my zen garden over to v2 now anyway.
&gt; Implementing a bot for Slack in Rust, Rocket and Anterofit - Part 1 The original title was correct. Why'd you have to go and put the word "hacking" in there?
Go to symbol finally works in VS.code. Thank you!
Anterofit is a great library! I used to work with Retrofit on Android, and I think it is simply the best way to consume REST APIs (no matter on which platform / language). Thanks for pointing out that `GET` is not a macro, will update the blog post!
I'd like to give a suggestion: I love the acronym, but I'd prefer if the project would be advertised using the full name instead of acronym. RTFM is kind of impenetrable and hard to promote, while the full name is very much on point! In fact, every time I see "RTFM", I'm like "what was that again?", until I click through and I remember.
Hacking in this context means "building something very fast", but I agree that changing the name was not the best decision.
I am very impressed at how much you manage to leverage the language to push both memory safety and performance forward at the same time.
Sure, there's a good reason. With `let mut s = String::new()` the variable `s` has ownership of the string and can pass it on (which is very common to do!) With `let t = &amp;mut String::new()`, the ownership of the string is anonymous, it's a temporary value. But we have a unique borrow of it, so we can use it for a lot of the same purposes. But `t` doesn't own the string, and can't pass it on! In that particular case, the owner is "anonymous" since it's a temporary, so there's no way short of using `swap` to pass on the ownership of the string.
Instead of transforming FooWrapper to FooWrapper2 you could use "keys So, you want a Bar not to outlive a Foo/Foo2 and also allow a Foo to be converted to a Foo2 while a Bar exists? Perhaps you could split the ownership of Foo and it's functionality (FooStep1) into two types like this: pub struct Foo { owned: *mut CppFoo, } pub struct FooStep1&lt;'a&gt; { borrowed: *mut CppFoo, pd: PhantomData&lt;&amp;'a Foo&gt;, } pub struct FooStep2&lt;'a&gt; { borrowed: *mut CppFoo, pd: PhantomData&lt;&amp;'a Foo&gt;, } pub struct Bar&lt;'a&gt; { owned: *mut CppBar, pd: PhantomData&lt;&amp;'a Foo&gt;, } impl Drop for Foo {...} impl&lt;'a&gt; Drop for Bar&lt;'a&gt; {...} impl Foo { fn new() -&gt; Foo {...} fn step1(&amp;self) -&gt; FooStep1 {...} } impl&lt;'a&gt; FooStep1&lt;'a&gt; { fn get_bar(&amp;self) -&gt; Bar&lt;'a&gt; {...} fn step2(self) -&gt; FooStep2&lt;'a&gt; {...} } But this would make Foo non-movable/consumable as long as FooStep1/FooStep2/Bar exists. Regardless of how you implement it, make sure that the types are only Send or Sync if it's OK for them to be Send/Sync. BTW: What C++ library are you trying to bind?
I'd love to see a comparision between the current module system and ES6 imports. They always felt very similar to me, but I lack the in depth knowledge about both to actually show it. Especially with ES6 being one of the most popular dialects of one of the most popular programming languages, I think it would be an interesting point of reference.
Domafic looks pretty interesting, although I am struggling with even starting. Is there a decent tutorial anywhere on using rust with js? I can't even get it to return a string at the moment (although numbers worked). Update: Domafic works right out of the box, it was the simple function I didn't know how to make to return string.
I hadn't heard about this until today, but Anterofit seems awesome. Nice work.
You can prove certain subsets of Rust are safe. Once all of safe Rust has been proven memory safe, and the unsafe parts of libraries have been proven safe, then safe Rust using those libraries will be by extension also safe.
bash is just poorly designed, I'd rather be using Python and I'm not even a fan of Python
&gt; Well I'd argue it IS an intrinsic property of C. It maps easily to assembly and is relatively easy to write a k&amp;r compiler in most assembly languages HA-HA! Writing a C compiler is FAR from simple: https://people.eecs.berkeley.edu/~necula/cil/cil016.html
I made a post in the original topic explaining how `&amp;mut` should be called an exclusive reference. That post also says that `let mut` is deceptive, it allows for two unrelated things: 1. rebind a variable 2. take an exclusive reference to a variable These are completely unrelated and like the term "mutable reference" just spread the misconception that it is about mutation—it isn't. Both could have a different keyword, an actual `let mut` and a `let uniq` or you could just take exclusive references without the `let mut` keyword or `let mut` could be abolished and `let` would just be `let mut`, if `let mut` was deprecated tomorrow and `let` would just be defined as identical to `let mut` now all code would continue to run. `let` serves as a lint—nothing more. So yes, it is purely just awkward historical design and in my opinion a flaw.
 extern crate cortex_m_rtfm as rtfm; // &lt;- this rename is required Why is rename required?
Definitely interested in whatever articles you can find time to write that cover the design and implementation. I've recently started doing some work with STM32 micros and this work is very exciting.
first part is change exe link, second part is restart app, even if you replace exe inplace you still need to restart app, that will not change ever :) 
Nope, I clicked the link expecting a manual. Wasn't disappointed though!
u/japaric/ if this is because your proc-macro internally requires the `::rtfm` namespace to work, have a look at the discussion [here](https://github.com/quodlibetor/diesel-newtype/pull/1#issuecomment-315559009) for a weird yet useful trick that serde uses!
This looks cool. Do you already plan to support the web by any chance?
Any idea why the borrow checker is yelling at me here? What is the recommended fix here? https://play.rust-lang.org/?gist=390cee8216ed968fcffc61539ea15aa2&amp;version=stable pub trait Compile { fn compile(self) -&gt; String; } enum Column&lt;'a&gt; { Alias(&amp;'a Column&lt;'a&gt;, &amp;'a str), Name(&amp;'a str), } impl&lt;'a&gt; Compile for Column&lt;'a&gt; { fn compile(self) -&gt; String { match self { Column::Alias(c_ptr, label) =&gt; { // ERROR! cannot move out of borrowed content format!("{} AS \"{}\"", (*c_ptr).compile(), label) } Column::Name(s) =&gt; format!("\"{}\"", s), } } } fn main() { println!("Hello, world"); }
&gt;Fun fact: The URL parsing can only fail if the port isn't a number. Everything else will use defaults. Well that's fantastic.
That depends on what level you're prototyping at. For example, if you're rapidly trying out various ideas for a multi-stage text-manipulating heuristic algorithm to find the one that gives the best score against a test corpus, doing it with APIs not designed around the assumption that garbage collection will take care of the minutiae is inherently going to be a bit of a drag on the experimental process. That's why, in that case, I use rust-cpython to write the building blocks in Rust while I do high-level prototyping in Python and then push things into Rust as they stabilize.
imgui is really very well made and complete, Conrod tries to get there, but its just not happening anytime soon, the project is very, very, very much slow. So, no hope to be really usable. Dear Imgui on other hand, has been stable for years and there are so much interesting addons (if you're willing to bind to them to rust anyway). But the barebone imgui is highly usable with everything you would need or expect for GTK or Qt, for example. Also, it is easy to customize its ugly default theme/colors and have something better looking than native UI. About the imgui-rs panicking, I found it is due to a recent update to glutin (this commit: f33567a1), so you can checkout to c17157b6 and it will work, but that example is just calling the sample from c++ side to show all supported features, the imgui-rs version which demonstrates everything supported in the bindings is in test_window_impl. Opened an issue here: https://github.com/Gekkio/imgui-rs/issues/68
&gt; In the second example, you are moving the borrow This has me wondering: How come we're not moving the borrow already in this call: file.read_to_string(contents); What exactly is passed to `read_to_string`? 
Rust automatically reborrows function arguments. You can move a reference into a function explicitly like this: file.read_to_string({contents}); Here's the excellent article that I learned the reborrowing semantics from: https://bluss.github.io/rust/fun/2015/10/11/stuff-the-identity-function-does/
I just watched a defcon talk on SSRF and it was basically all about not using RFC compliant url parsers lol
Shouldn't that violate the "only one mutable reference at a time" rule?
Is `slice.as_ptr().offset(slice.len() as isize)` UB if the slice spans more than half of addressable memory? Because the docs for pointer.offset() says that it's UB to overflow, but does that include overflowing downwards, ie via zero to max?
`Column` doesn't implement `Copy`, and `compile()` consumes `self`. You can fix this by inserting `#[derive(Clone,Copy)]` above the definition of `Column`.
Keyword I think you missed: relatively. Also I didn't say it was simple.
Even thought the week is almost over... I am not completly new to Rust, but i havent yet come to produce something useful. So I started to work on a small command line tool to remove comments from config files. Find it here https://crates.io/crates/comment-strip. This is my first ever contribution to the Rust Community btw. So yay ;D
Pretty sure he meant to say something like "Rust automatically *reborrows* `&amp;mut`s passed into functions". It essentially does `file.read_to_string(&amp;mut *contents)`, but it's "borrowing the borrow", so it can't outlive the original. There's a section in the [nomicon](https://doc.rust-lang.org/nomicon/references.html#liveness) about it.
&gt; Pretty sure he meant to say something like "Rust automatically reborrows &amp;muts passed into functions". Yup. Fixed.
Unlike C++ I don't try to have one file per class for example but rather think about what kind of logic/types belong together and keep them inside a module. (maybe split the modules into submodules if it makes sense)
So this means there is in fact a second mutable reference which is strictly-speaking illegal, but the compiler enforces that the callee can't do shenanigans with it such as storing it into another object or passing it into a thread. This means that the only place where those references can be used are the callees themselves, which are finished by the time that "my" code starts running again and using the original reference. Amirite?
Yes. The only difference between a mutable and immutable `let` binding is a `let mut` bindings lets you do 2 more things: * reassign to the variable * get a unique alias to the variable `&amp;mut` is more complicated and there are some things that `&amp;mut` doesn't let you do that `&amp;` does. Even worse is any `let` binding can be turned into a `let mut` binding by just declaring a variable with the same name. One way to deal with this is make all `let` bindings `let mut` and then when you're done, remove the `mut`s that give compilation warnings.
Julia is squarely aimed at us, and it _might_ end up being a good replacement once it's stable and the python interop becomes solid. Even then, there are some reasons to stay with Python+Rust rather than Python+Julia. Whether Julia will displace Python+XXX in science is over the horizon. Too much of the scientific software is in Python, and numpy+scipy are too often fast enough. I think you missed an important point though. The question is not, what can or can't the language do. The question is, how many foot guns does it have. Can I hand this to a student who doesn't know C/C++/Rust and get the student to write code that wont require weeks of debugging unless we happen to have an expert coder around (and in Julia I might end up with performance bugs that throw me back to near Python levels that novices can't detect). This is not hypothetical. We wasted weeks trying to find a bug in something someone had written. The program would work correctly 99% of the time. Good enough in some situations, but not in ours. The author was no longer available, having left academia. We abandoned the code, and only got the problem fixed when we happened to have a colleague who's a C wiz over. The tooling is another thing. Our people use the command line, but they have never written a make file. Setting up people with a single command that doesn't require them to learn what a linker is or does is huge. So yeah, this is totally niche. But I think we can absolutely benefit from a no foot gun language where idiomatic code is performant and that interacts well with Python.
Hey, I hadn't seen [your FFI guide](https://michael-f-bryan.github.io/rust-ffi-guide/) before! Looks really useful!
I think it has something to do with enforcing "correctness" and some fear of "mutation". Really, the distinction between `let` and `let mut` is just for people who want to pretend that Rust is a functional language when it's an imperative one.
I like my company's hackathon. I realize it's increasingly unpopular to have "stay up all night coding" events but lots of people choose not to participate, and for the rest of us it's a really fun excuse to hang out and program in a totally different context.
Awesome, I was travelling and didn't see that, I only learned about this from this article. I'll definitely try that once I have time for the next round of experiments with this! Thank you for keeping our niche in mind :D
Yeah I got that idea too honestly. I mean `const` already exists.
I'm surprised we have come this far actually. I originally thought that automatic derivation of ceilings, which v2 now has, required global program analysis which no Rust feature can do (well, lints can but run too late so they can't generate code) and that we would have to write a custom Rust compiler (or a custom rustc pass) to achieve the ergonomics / API we really wanted. Turns out the global program analysis requirement could be removed by concentrating the program specification in a single place (this sounds bad for modularity but that can be recovered with generic code). I first reached out for `macro_rules!` to do the ceiling computation but I found it to be too limiting (or maybe I'm not wizard enough because people implemented smart stuff like `quote!` using `macro_rules!`). Then I tried procedural macros and, wow, it was a game changer: it let write some clever stuff that improved the API in ways I didn't anticipate. I think the next challenge is going to be LLVM. There's at least one case [1] where LLVM optimizes the current API rather badly. To achieve great performance, the *expected* performance actually, the API heavily relies on LLVM being able to optimize away whole branches of code in the implementation of the API; to do this LLVM has to track the exact value of the `Threshold` token, which is just a newtype over `u8`, through the whole function call graph. It seems that when the function call graph gets too complex LLVM just gives up and generates code to check of the value of `Threshold` at runtime and this *destroys* performance -- we are talking about increases in code size of 50-100% or more compared to the size of a properly optimized program. [1] this single case is with the MSP430 port so it could actually be a problem with the MSP430 LLVM backend. I think there's only one way to stop relying on LLVM to get the expected performance *without losing ergonomics* and that is *type level integers*. Unfortunately, they are not implemented (I know there's a recent RFC) and the API requires a type level version of the `cmp::max(A, B)` operation which very likely is not going to be available in the first implementation of the feature. I could use typenum but the ergonomics around generic programming would suffer because generic code would then require a bunch of bounds (at worst something like `nchoosek(N, 2)` bounds where N is the number of resources used in a generic function). Even knowing the ergonomics downside I tried to port the current API to typenum but I seem to be hitting a rustc bug because I'm getting a compiler error about a trait not being implemented for a type in generic context even though the demanded trait bound is right there in a where clause (I should report that).
Interesting! I'll give it a try.
This is probably my main complaint about Rust. I don't like the idea that modules are defined by file (or even within a file) vs by directory. In Go, I'd do precisely what you mentioned because packages are defined on a directory basis, and I personally prefer that most of the time. That being said, I don't have any large projects (yet) in Rust, but I tend to follow the same organization as Go with a directory per "module", lots of "pub use" in lib.rs/mod.rs. I start with everything in lib.rs/mod.rs and typically break it up around 1000 LOC and I aim for ~1000 LOC per file going forward. [Here's a stack overflow question about how to do just that](https://stackoverflow.com/questions/22596920/split-a-module-across-several-files). Other projects keep with the "file is a module" idea, so you can definitely do that as well. It's mostly personal preference, though I wish it was more standardized. As for larger projects, I tend to look at a few projects I like to get an idea of best practices, such as: * servo * ripgrep * clippy * the rust compiler and standard library * rustfmt * piston * rocket Each project is a bit different, so I just peruse a few to get a feel for how other, more established projects handle it.
When maintaining and developing Rust projects, you really shouldn't have any large files. If you have a file that's around 500+ lines of code, then it's highly likely that you're overdue for a refactor. Functionality should be grouped into relatively small, manageable units. Here's an example of how I structure my projects: src | |--- gui | | | |--- GTK | | | |--- Qt | |--- cli | |--- web | |--- sys | | | |--- unix | | | |--- redox | |--- backend | | | |--- parser | | | | | |--- expander | | | | | | | |--- permutator | | | | | | | |--- ranges | | | | | |--- tokenizer | | | |--- core | | | |--- function1 | | | |--- function2 | | | |--- function3 | |--- traits It can also be important to ensure that each module is documented, maybe even providing a README.md for each module to explain what the module does and how it's used in the rest of the project. In addition to documenting all the functions and types.
&gt; avoiding writing JS would be a very happy day for me I guess I don't get this sentiment. I'd much rather write in JS than debug a nasty compile tool chain that takes forever to build and has limited library support. Then again, I write a ton of JS for my day job, so I guess it's not that big of a deal for me, especially with all of the new JS features that eliminate entire classes of problems. I think these projects are cool, but I don't think I'll use them for anything serious until they're matured quite a bit.
I like IDEs but I'm very wary of designing something with the assumption that most people use IDEs. That is not true for Rust now and I don't expect it to be in the future. IDEs should be an enhancement, not a core assumption.
Python is really good at quick prototyping and rapid development. If I'm writing a quick script or a small project where performance doesn't matter, it absolutely is the best tool for the task.
Then those using text editors with plugins can have their plugins support it as well. This just doesn't feel like a language level problem.
Especially when numpy provides much of the functionality of Matlab.
I consider "text editor with plugins" to be the same thing as an IDE for the purpose of this discussion. The fact of the matter is plenty of folks program with only basic syntax highlighting. Certain ecosystems like Java and C# are not like that but most programming languages have a nontrivial, even majority section of the community that don't use IDEs. We should have a good experience for them, _and_ build upon that for IDE users. This matters especially for language learners, if someone is trying out the language they may not go all the way to set up an IDE or editor plugins. 
I run into this a lot. From a design perspective, when should I implement copy/clone and when should I pass by reference? It seems like there are many correct ways of solving this problem, but I get the feeling that implementing Copy/Clone to solve these problems is frowned upon.
I'm glad to see someone taking the initiative to improve `rand`. I think it needs a lot of work. I think the pull request as submitted will be a bit of a pain to merge, just because the submitter didn't really explain much they're just letting the commits speak for themselves. If I were the maintainer of `rand`, it would greatly help me to have an explanation of why things were changed and what the goal was. Some more high level explanation to tie things together.
[Internals thread](https://internals.rust-lang.org/t/crate-evaluation-for-2017-07-25-rand/5505) with ongoing `rand` discussion.
And that is one of my bigger complaints of Go. I hate that a package import could mean a type came from any of those files. It feels like having glob imports on by default.
High level optimizations like constant propagation and dead code code elimination, are backend independent. So I'm afraid this can also happen on Cortex-M, we just don't have an example that triggers it yet.
That makes a lot of sense! Thanks.
Hey, loving the improvements you've made and the example projects on the blue-pill are great for DMA and other fiddly bits that I've been struggling with on my stm32f7 project using rtfm. As far as I can see, you haven't used the external oscillator + pll to achieve the maximum frequency of the blue-pill. This was one of the first things I had to do with my f7 to go from 16 to 208MHz. Am I missing something or is this just not something you've needed to implement?
So indeed they are two somewhat unrelated concepts, now I understand; but I found this post [here](https://www.reddit.com/r/rust/comments/6q4xq9/let_mut_x_vs_let_x_mut/dkvqtl2/) explains it well. Perhaps it would have been more consistent to replace today's `let` with `const`, and `let mut` with `let` as you're suggesting - but then where would "internal mutability" with the likes of `Cell` and `RefCell` fit into this syntax? (e.g. `const c = Cell::new(1)`).
Got a link?
The talk only just happened, so it isn't up yet.
And if it's 65536. Will it fail?
That's precisely what it does. It is indeed redundant in that particular example. It's more useful when you want to nest patterns but still want to grab a reference to one of the intermediate nodes.
It captures the entire value of the pattern in that particular match arm. See the Rust language reference on match expressions: &gt; Subpatterns can also be bound to variables by the use of the syntax variable @ subpattern. https://doc.rust-lang.org/reference/expressions.html#match-expressions It's useful when you don't already have a name for the expression that you're matching on. For instance: match foo() { Bar(k) =&gt; Baz(k+1), k @ _ =&gt; k, } Try out: https://play.rust-lang.org/?gist=9ebee8cc0934589abde4fae971364dd3&amp;version=stable EDIT: further example
Writing a plugin system in Rust is somewhat possible (https://users.rust-lang.org/t/rusty-plugin-system-for-my-project/11490) but much, much harder than it would be in a dynamic language like Ruby. So the answer to your question is not at the moment and probably not for a very long time. ^^
The videos are usually only available after a few months. :/
This is quite limited: e.g. using it to generate a (uniformly) random float works, but is weird, but it *won't* work for generating a normal distributed random float (one cannot tell how much randomness is required up front: one may need to request more).
What you're suggesting sounds a bit like the `extern crate` statement feeding compilation options (i.e. actual options to the compiler) down to the base crate, which would entangle cargo and rustc and also create a weird circular dependency/phasing (if `A` depends on `B`, then first one has to check the `extern crate B` statement in `A`, and then compiler `B` with any options it needs, and then compile `A`), *and* I believe macros can introduce `extern crate` statements, so this would need to iterate "parse to find `extern crate` in parent, build dependency crates, expand macros in parent, repeat". In summary, I think that brings a whole other set of hoops to jump through. On the other hand, if you're just suggesting that there's a version of Cargo's `features` that is designed to create variants with the information in the `Cargo.toml` then that seems more reasonable.
&gt; The connection between conditional probabilities and sub-type constrainted is explained on the second page here about probabilistic existential paths Ah, sorry, however the definition of the "probability" of an `if` statement is still wrong: it needs to be using some form of conditional probability, linking the condition to the then/else expressions. Happening to mention it a page later isn't enough.
Each invocation `extern crate foo features(logging, AVX, NOP_Blaster)` would be a effectively a different crate and shouldn't b shared across projects or even in the same project unless they have the same feature specification. Or maybe something similar that only controls how the `lazy_static` block executes for that crate instantiation? Screw it, lets just use functions for everything.
As a side note, it's the same as in Haskell pattern matching. -- [1](https://stackoverflow.com/questions/30326249/what-does-mean-in-haskell) [2](https://stackoverflow.com/questions/1153465/what-does-the-symbol-mean-in-reference-to-lists-in-haskell)
SSRF is all about services using IP addresses as implicit authentication. The proper way to fix confused deputy problems like SSRF is to use explicit authentication/capabilities.
release with debug assertions enabled
No, that's just one problem. The talk covers multiple other issues starting with non compliant url parsers - things like: www.google.com/@evil.com to trick the server into performing a request for evil.com.
There are a ton of languages that are more simple to implement. C in particular is very difficult, because of how confusing the standard is. If how easy it is to write a compiler was the issue, Forth would win. Forth compilers are easier to write and Forth is very close to metal. The reasons you gave are not convincing. I think it might have more to do with popularity than anything.
Well, in that case you can just do k =&gt; k, but yeah.
I assumed that it was an updated version of the interactive Rust manual thing. ("Rust by example".)
Forth is actually a good point. I didnt think about that but you are right about it. C probably did win because of popularity. But it is closer to forth in terms of bare metal &amp; ability to write a compiler than most other languages.
Huh, I had no idea you could do this. [Anonymous enums](https://www.reddit.com/r/rust/comments/6m4vjg/why_does_the_either_crate_have_so_many_downloads/djyya2t/) now seem a little more plausible: fn sum(inputs: (Vec&lt;f32&gt; | f32)) -&gt; u32 { match inputs { v @ Vec&lt;f32&gt; =&gt; v.iter().sum(), f @ f32 =&gt; f, } } 
I agree. My initial thought upon seeing this was that it is incredibly disrespectful of the maintainer's time. Not only is it far too large for anybody to review in a reasonable amount of time, basically none of the commits have reasonable commit messages, and the author calls it a "break whatever I feel like" change. It's unfortunate to see this sort of thing happening.
Rubocop and rustfmt have slightly different scope. While Rubocop also have code formatter it is mainly just a linter. And for lints in Rust there is Clippy, which also is example of how to write custom Rust lints. However all of them are rustc plugins which aren't available on stable (yet). 
It's the garbage collected smart pointe... wait no, that's what it used to be
So where do you actually need to use it where it's absolutely necessary?
On mobile so I'm too lazy to test, but maybe `foo @ EnumA(_), EnumB(_) =&gt; foo`? I don't know if this will actually compile. 
I've rarely used it. More complex patterns, or nested patterns I suppose. match foo { Some(a @ Some(bar)) =&gt; } Something along those lines.
I'm writing my own Vector type (mathsy-"x-y-z" vectors, not vectors like vec!). I wanted to define the addition operator for these vectors, and was reading the docs and wanted to double check that I understand this snippet (specifically, the ownership semantics). I've left out some of the code to keep this comment a bit shorter. #[derive(Debug)] struct Point { x: i32, y: i32, } fn add(self, other: Point) -&gt; Point { Point { x: self.x + other.x, y: self.y + other.y, } } Let's also assume 'add' is called in this context: let a = Point {x: 5, y: 2}; let b = Point {x: 3, y: 4}; let c = a + b; (This is from the [docs page](https://doc.rust-lang.org/std/ops/trait.Add.html) for the Add trait.) My question is: are the following statements correct? 1. Point does not implement the Copy trait. 2. Therefore, when 'add' is called, ownership of the Points that 'a' and 'b' refer to is passed to the parameters of 'add'; 'self' and 'other'. 3. Therefore, when 'add' exits, 'a' and 'b' will be invalid, since the Points that 'self' and 'other' referred to will be dropped when 'self' and 'other' go out of scope. I am prompted to ask this question because (to me at least), it seems odd that 'add' should consume its arguments (in this case); which lead me to doubt my understanding of the ownership/borrowing system.
Im not sure if this is the place to ask (if not, please tell me where this would be better), but I have been going through the rust book and a challenge at the end of the Hash Maps section was this: &gt; Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in the company. For example, “Add Sally to Engineering” or “Add Amir to Sales”. Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically. After doing the challenge I figured this would be a good time to get some of my code reviewed: [Github repo with code](https://github.com/bamartindev/company-roster-ex/blob/master/src/main.rs) I am looking for any pointers to make sure my code is idiomatic, that I am not doing anything horribly wrong, and that I am not fighting against the idea of borrowing. For example, in lines 43-49: let mut dept_names: Vec&lt;String&gt; = Vec::new(); for dept_name in dept_rosters.keys() { dept_names.push(dept_name.to_string()); } dept_names.sort(); Is there a better way to sort the keys of a Hash map? Thanks in advance! edit: update to github repo link
You can replace the first four lines with let mut dept_names: Vec&lt;_&gt; = dept_roster.keys().collect(); If you need ownership then let mut dept_names: Vec&lt;_&gt; = dept_roster.keys().cloned().collect();
Yeah, I haven't run into the need for increasing the clock frequency from the default 8 MHz just yet. My [most demanding](https://github.com/japaric/ws2812b/tree/master/firmware#performance) application only uses 15% CPU and uses a 200 KHz PWM signal and DMA to drive LEDs at a 160 Hz refresh rate. Increasing clock frequency doesn't make much sense for the app because the refresh rate is already high enough to not cause (perceptible) flickering.
Yes, all those points are correct. It's designed this way to allow for heavy types which may want to somehow reuse each others' memory when implementing the operations. A lot of the primitive types have `Add` implemented for references in order to get around this.
Why not use `:` instead of `@`?
Just started following along with intermezzOS. I usually program in higher level languages like Java and Python so it'll be quite a journey
Awesome, thanks for the reply!
Because (as I learned in this thread), `@` is existing syntax for naming part of a pattern, while `:` (as I used in the thread I linked to) might not even be compatible with the existing pattern syntax (I don't know, I've never tried to figure it out). `:` looks more like variable declaration/type ascription, and would therefore likely be easier to learn, but surely if it were that easy Rust would never have resorted to `@` in the first place.
The [caveat](https://github.com/facebookexperimental/mononoke#caveat-emptor) does seem relevant, but there's been a few mentions of this in some mailing lists and it's apparently all/mostly open source now. Lacking a `Cargo.toml`, I'm guessing that it's being built internally via [Buck's Rust support](https://buckbuild.com/rule/rust_binary.html). Haven't seen anything to suggest it's running in production though.
Thanks! That helped clear things up for me.
It's useful if you're doing deep pattern-matching on a structure but you want to bind to something a little less deep: fn get_thing_under_specific_conditions() -&gt; Option&lt;Foo&gt; { match something_producing_result() { Ok(result @ Some(Foo::Bar(3 ... 5))) =&gt; result, Ok(_) =&gt; None, Err(_) =&gt; None, } }
When `@` is used, both the left side and the right side are values that are equal to each other. When `:` is used, the left side is a value but the right side is the type of that value. In this case, `:` is more appropriate. If you really want to use`@`, it probably has to look like this: fn sum(inputs: (Vec&lt;f32&gt; | f32)) -&gt; u32 { match inputs { v @ (_ : Vec&lt;f32&gt;) =&gt; v.iter().sum(), f @ (_ : f32) =&gt; f, } } 
The best tip I can offer from past experience is to keep c-integration squarely in mind when designing and implementing your library. Many Rust concepts won't translate well to C and will require some sort of translation, heap allocations (and freeing functions), or both. You have to make sure that data can be cheaply converted from/to C. If you're going to target C codebases as first-class consumers of your library alongside Rust, it might make sense to store all your data in a C-native format. Also, non-JS version: https://webcache.googleusercontent.com/search?q=cache:https%3A%2F%2Fusers.rust-lang.org%2Ft%2Ftips-and-experiences-integrating-rust-into-other-projects%2F12091
There are, as far as I'm aware, no real guidelines concerning this, so people do whatever works best for them. Like others say, the c++/java idea of one class per file is not really applied. In my current project my `main.rs` is close to 3000 lines, because some of the functions require a lot of individual statements. Trying to split up those functions into smaller pieces would just obfuscate them, so I end up with large files. That being said, when I have a struct for which there are many `impl` blocks (e.g. because im implementing different conversion traits) I tend to stick it in its own file, to make searching for specific functions while editing easier.
My rather naive intuition is telling me that people use C because it is sufficiently lightweight - syntactically, conceptually, and performance-wise. The first two make people comfortable programming with it, but the third is the real buy in. Any language can be modified to do C ffi and call into the OS. I really don't think that's the main reason people use C. Though Rust needs to be good at interfacing with C (as a necessity), but even if it did that perfectly, by itself, that only makes it *as good as* C. I think what gets people excited about Rust are things like Tokio and BurntSushi's Regex library or ripgrep."You couldn't have done it better in C (or C++)" is the story I think people want to hear. The promise of lightweight, blazing-fast, safe software. People will throw out the third and kill their own children for the first two. If Rust can do all three, then it will sell itself. And there are a lot of people waiting in the wings thinking "Where are the fast SIMD ops? Where are my AoS/SoA transforms? Where are the advanced data packing options? (Why is Option&lt;Option&lt;Option&lt;T&gt;&gt;&gt; so big?)"
&gt; fn sum(inputs: (Vec&lt;f32&gt; | f32)) -&gt; u32 { match inputs { v @ (_ : Vec&lt;f32&gt;) =&gt; v.iter().sum(), f @ (_ : f32) =&gt; f, } } Unless I'm missing something `(T1 | T2)` isn't a valid type in rust.
We're talking about a hypothetical feature. (See the "Anonymous enums" link)
Hmm I don't remember which datatype I used. Maybe ¯\\\_(ツ)_/¯ EDIT: `(1 &lt;&lt; 16) - 1` = `65535`. Yes. yes it will. To be fair this entire library is really unstable. EDIT 2: I just googled. The max port can apparently only be 65535 (u16). So yes it will fail because it should. I'm lucky!
Is this sarcasm? 🤔
That's super cool, actually.
If you need the higher clock speed you should be able to modify this https://github.com/etrombly/bluepill/blob/master/src/frequency.rs . I wrote it for the bluepill and v1 of rtfm, but it shouldn't be too hard to switch over. 
my first thought before i opened the thread was "what old rust article are you reading that used managed boxes?" 
My preference is somewhere in the middle. I like being able to separate my package by file, but I also like specifying exactly which pieces in importing. I feel like the Rust way promotes either large files (entire module in one file) or lots of small files (each type in a separate module) and the best (IMO) solution is somewhere in the middle. However, Rust also gives you the tools up build your optimal module layout, so I'm not entirely unhappy, though supporting everything is less than ideal as well for consistency.
[Domafic](https://github.com/cramertj/domafic-rs) might be what you're looking for. There are also [Maud](https://github.com/lfairy/maud) (written by yours truly) and [Horrorshow](https://github.com/Stebalien/horrorshow-rs), which use macros to build an HTML string.
The GIF parser's link is broken.
You want r/playrust.
I think you may be looking for https://www.reddit.com/r/playrust/ This sub reddit is for the rust programming language. 
No because the point of rustfmt is to have one well-defined formatting style for Rust programs. If you could write a plugin that modifies its behavior, it would no longer be opinionated. (As far as I know.)
All `use` does is take the thing you name, and make an alias to it in the current scope. So `use std::io` takes the `std::io` module and creates an alias to it in the current scope called `io`. If you're familiar with *nix filesystems, it's like `ln -s PATH`. For your second example, I don't understand what you're saying. `Rng` has nothing to do with the `thread_rng` function. For your last, assuming `myFunction` is defined inside `firstPart::secondPart`, you use `secondPart::myFunction` or `firstPart::secondPart::myFunction`.
Can you please post the definition of `Document`?
I've looked at the [callbacks page](https://michael-f-bryan.github.io/rust-ffi-guide/callbacks/index.html) of the FFI guide and saw that it says nothing about panics and unwinding. Unwinding from Rust into C is, I believe, undefined behaviour. What I do is wrap the callback in a macro that aborts on panic. macro_rules! c_callback { { $(fn $func:ident($($param:tt)*) -&gt; $ret:ty $body:block)* } =&gt; { $( unsafe extern "C" fn $func($($param)*) -&gt; $ret { panic::catch_unwind(AssertUnwindSafe(|| $body)) .unwrap_or_else(|_| process::abort()) } )* } } c_callback! { fn check_progress(intermediate_result: c_int) -&gt; c_int { println!("Intermediate result: {}", intermediate_result); if intermediate_result &gt; 100 { println!("{} number is too big!!!", intermediate_result); 0 } else { 1 } } } 
I thought their monorepo was git?
No: https://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/ They used to use SVN and Git, but found Git is to be bad for their usecase.
I am not sure i would be willing to pull dependency of nom just to parse a tiny header.
I have to say, without trolling or anything, that as someone new at learning the language, this issue is kind of concerning to me. It's exactly the kind of chaos I was trying to avoid in other languages. It also seems like a pretty important basic thing...
Yeah, I was confused because in the official [tutorial](https://doc.rust-lang.org/book/second-edition/ch02-00-guessing-game-tutorial.html) the alias is using the firstPart use rand::Rng; let secret_number = rand::thread_rng().gen_range(1, 101); which is confusing because it is essentially use firstPart::secondPart; firstPart::myFunction() 
Sure. pub struct Document&lt;'a&gt; { // term frequency (or weigh) terms: HashMap&lt;&amp;'a str, f32&gt; } 
Understood. I played around a bit, but I don't think it can be done the way you would prefer. step2() causes FooWrapper to be dropped, and there's no way to tell the compiler that its lifetime has been 'transferred' to FooWrapper2. Best way I can think of is to move the *mut Foo to a new type (FooHolder?) that does nothing but hold the pointer, and release it when dropped. Then FooWrapper, FooWrapper2, and BarWrapper can all share an Rc to that FooHolder. This ensures that the *Foo won't be released until after the *Bar has been. 
Have you tried `pub type SearchRes&lt;'a&gt; = (f32, &amp;'a Document&lt;'a&gt;);`?
Thank you!
Some more precautions are needed. An implementation is in https://crates.io/crates/take_mut but as you can see, the precautions have some dire effects.
Thanks for the info, they look promising :-)
Depends on the crate. I'm running tests of ndarray both in debug and release mode since the time when there was a bug that only showed up with optimizations. (Sometimes it's your own unsafe code, it happens, and sometimes it's bugs in the compiler.) If the crate is high risk for bugs that only manifest during optimization, then I'd recommend running tests in both debug and release.
Those do seem like some pretty bad effects, and are probably not acceptable. This might be a bit of an XY problem, so here is the Github issue I originally created: https://github.com/rust-lang/rust/issues/43548 In my case, it's really an `OccupiedEntry` rather than mutable reference, so in case of a panic it could just become a vacant entry instead. Maybe I should reopen the issue.
When `f` panics, `dest` will point to uninitalized data, resulting in UB when some other code uses it assuming it contains initialized data (e.g. when its owner tries to drop it).
&gt; Couldn't be simply: &gt; &gt; `Kelvin(k) =&gt; self,` instead `k @ Kelvin(_) =&gt; k,` like: Only if `Temperature` implements `Copy`. Otherwise you can't use `self` inside of the match because it has been moved.
Not sure why people are downvoting you for that. I think there is some value in having a "default" way of parsing stuff, and nom is a good candidate for that. So even if the author could have written their own parser in less time, the experience gained in using nom is still nice, and may come in handy if/when they write a bigger and more complex parser in the future. In addition I think there is a lot of value in having parsers for various file formats available in Rust (although it looks like the author did not create a separate crate for their parser).
Funny, that MS does the same, but with git: https://blogs.msdn.microsoft.com/bharry/2017/02/03/scaling-git-and-some-back-story/ may be for them `C` is more friendly then dynamic typing Python
Rustfmt currently has extensive configuration options.
Plus nom is mostly macro based so the only extra cost is at compile time, which would be similar to if they wrote it by hand anyway. 
Couldn't this be Rust feature? Woludn't this imporove error handling? I mean.. When you have function which returns two or more error types. * You need to wrap them with your custom error type and implement `From` trait to use or * use error-chain (https://github.com/rust-lang-nursery/error-chain)? Could Niko Matsakis comment it? :) 
I think it's pretty rare that you need to consume `self`. Is `compile` really meant to consume `self`? Otherwise you could do this: pub trait Compile { fn compile(&amp;self) -&gt; String; } enum Column&lt;'a&gt; { Alias(&amp;'a Column&lt;'a&gt;, &amp;'a str), Name(&amp;'a str), } impl&lt;'a&gt; Compile for Column&lt;'a&gt; { fn compile(&amp;self) -&gt; String { match *self { Column::Alias(c_ptr, label) =&gt; { format!("{} AS {}", (*c_ptr).compile(), format!("\"{}\"", label)) } Column::Name(s) =&gt; format!("\"{}\"", s), } } } fn main() { println!("Hello, world"); } 
I usually go with 1 file, 1 module. So if there are submodukes, those get broken out into files, with possibly the important exported traits in the top level mod.rs of that module. I don't worry too much about the lines in a file, just the logical consistency and decoupling.
You can look at [this crate](https://crates.io/crates/map_in_place) for examples of how to do this safely.
Any XML parsing library for Rust with support for DTD and user-defined XML entities? As an alternative, any XML-parsing library for Rust that would correctly ignore the DTD and the entities it doesn't understand? (the ones I tried so far fail on the DTD that's fully included in the document, and if I remove that, fail on the first custom entity)
I didn't realize you could use it inside a pattern as well. I had been conceptualizing it as a something that only worked on whole patterns. Great example.
No, that's calling the function `rand::thread_rng()`, then calling `Rng::gen_range` on the result; `gen_range` comes from the trait `Rng`, and traits have to be use'd into scope to be usable.
Yeah, I can see how that would be problematic. However, since what I am really using this on is an entry, then I could just remove the entry in case of a panic. This makes it a lot more complicated, but I think it might be safe: use std::collections::hash_map::OccupiedEntry; fn map_in_place&lt;K,V,F&gt;(mut entry: OccupiedEntry&lt;K,V&gt;, f: F) where F: FnOnce(V) -&gt; V { use std::mem::{forget, uninitialized}; use std::panic::{catch_unwind, AssertUnwindSafe, resume_unwind}; unsafe { let old = entry.insert(uninitialized()); let result = catch_unwind(AssertUnwindSafe(|| f(old))); match result { Ok(new) =&gt; forget(entry.insert(new)), Err(err) =&gt; { forget(entry.remove()); resume_unwind(err); } } } }
Mattermost? Not Matrix?
And this is why `OsStr` and `OsString` are so problematic: their *raison d’être* is treating strings as more or less UTF-8 so that they can be turned into `str` and `String`. They’re dangerously misleading types in this way that work in most cases, but can easily be *utterly* broken and thus worse than useless in certain unusual contexts, because they give a false impression of sanity.
That was what I was obliquely getting at. `OsStr` and `OsString` are mostly broken by design. I don’t find them a useful cross-platform abstraction. They’re commonly fairly convenient on Linux, but as soon as you try to *do* things with them… well, it’s not nice for cross-platformness at least. Thank you for providing lots more useful information. I was hoping someone would step in with more details.
[removed]
Very impressive work. Does that mean I can take whatever STM32 I can find and start using CANBUS etc. ? And how about tokio ?
I'm not sure about the accuracy of that. Can anyone else confirm? I didn't think ctfe existed yet.
You're probably looking for /r/playrust . This is about the programming language rust.
/r/playrust/ is the subreddit you’re looking for.
I more meant that the only overhead of using nom versus handwriting it is the crate compilation and the macro expansion. The code noms macros generate is very simple. It has nearly no more runtime cost than the equivalent handwritten code. 
You can play with Rust on a large variety of computers, from small embedded boards to large clusters. Your CPU and RAM are definitely suitable, however I advise a SSD to reduce latency on seeks (it doesn't need to be big, 256MB/512MB is largely sufficient). Which video card to go for really depend on how you plan to play, for my own needs embedded cards are sufficient; test first and see whether it fits, upgrade as needed. --- *Or maybe you want /r/playrust?*
Added more features to [surge](https://github.com/sevagh/surge), my libmpv and YouTube-backed command-line music player.
I found out later it's a bit redundant for the article and I can get rid of it but I'm glad others answered your question :)
I don't want to consume `self`, but I don't have a good reason to pass a reference either (I don't particularly care that the data the function receives lives at a particular address, nor have I profiled and found passing by reference to be dramatically faster). I guess I wasn't expecting the compiler to reject such a straightforward program. I'll change to pass by reference.
Fixed now. Thanks!
I use this emulator to test out all sorts of wacky ideas. I've experimented with SIMD to speed up the graphics emulation and even written a JIT compiler to run the CPU faster. If it was intended to be a production-quality emulator, though, I'd probably agree with you.
Same for Google, which is backing mercurial as well. Only Microsoft is trying to scale git for huge monorepos these days. Facebook and Google first got their hands on git (due to its market dominance and being favored among their engineers) but couldn't get too far due to, IIRC, the lack of modularity of the git codebase and the lack of a single API (i.e. if you implement something unusual for git, you need to implement it for libgit, jgit, dulwich, msysgit,..., Which is endless, .. or it becomes a fork and you loose community support which will be lagging behind). OTOH, it seems that mercurial and its modular approach to doing things in extensions allowed them iterate quickly, and the extensions that Google and Facebook ended up developing can be taken off the shelf and enabled on any repository, as needed.
Facebook has done an enormous amount of work on the Mercurial client too: https://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/
I am planning web support for 'eventually sometime in the future'. I've experimented with it a bit, but I'm waiting until support is more solid (for both rust-wasm and 'libservo' a la Electron).
Hi! This subreddit is for the Rust programming language. You seem like you may be looking for /r/playrust instead. Best of luck to you!
I am surprised that you went with a boolean attribute for reliability, I would have expected some kind of confidence percentage or similar. Isn't there any issue with threshold effect of a boolean?
Thanks! I wasn't aware of that. 
I see, so if I do use firstPart::secondPart; I can do firstPart::myTrait() or secondPart::myFunction() ?
I would love to see more data. I'm skeptical of Microsoft's work with git. Not that I'm accusing them of embrace and extend but it is one company that is guilty until proven innocent. 
Hmm, so many people get this wrong. There was an RFC for replace_with function, which was postponed. I think it was a mistake...
You're right. I'm working on it https://github.com/advancedresearch/path_semantics/pull/162
I 100% agree. I feel like we should maybe collect a list of all the situations people have been trying to use something like this.
https://github.com/Microsoft/GVFS
God, I feel so dumb. thanks!!
coming from .net here: when comparing strings there are a bunch of possibilities - invariant - invariant case insensitive - ordinal - ordinal case insensitive the difference being that ordinal wont do unicode normalization, so it's faster. the invariant uses an english like culture. when not specified, the current culture is used for string comparissons. is there a way to PartialEq str with some control of, for example, case? thanks!!
Yes, assuming `myFunction` is in `secondPart` and `myTrait` is in `firstPart`.
I just spent the last 45 minutes reading through this project and have to say that this is one of the coolest projects I've seen. I spent a while trying to find the scheduler before coming to the realization that there is none. The hardware is the scheduler! I cannot wait to take this for a spin on my EFM32LG.
When you're using the external crate `rand`, you can use `rand::thread_rng()` regardless of what you `use`. See this playground example: &lt;https://play.rust-lang.org/?gist=73664dc93773fb149c7dc5630a905fc7&amp;version=stable&gt; Similarly for `std::io`, you could always use `std::io::stdin()`. Use `use` to bring something into scope. With `use std::io`, you bring `std::io` into scope with the name `io`, so after the `use` statement, you can simplify the name of `std::io::stdin` to `io::stdin`. What Quxxy was getting at above was that traits need to be in scope in order to be used. If we try to call `gen_range` on `rand::thread_rng()` without any `use`, we get an error: &lt;https://play.rust-lang.org/?gist=6d7024ea81d755333c51129ed57c7aa6&amp;version=stable&gt; This is because `gen_range` is a function in the `rand::Rng`-trait, so the compiler must be given some additional information to understand that you want to use this trait. It is technically possible to call `Rng::gen_range` on the `thread_rng`-object without any `use` by using the [universal function call syntax](https://doc.rust-lang.org/book/first-edition/ufcs.html): &lt;https://play.rust-lang.org/?gist=c91699931e2f8fd8055161f6dc9afe47&amp;version=stable&gt; It is, however, idiomatic to instead use `use` to bring the relevant trait into scope: &lt;https://play.rust-lang.org/?gist=0d6f20a427b362a024aaacaede67a133&amp;version=stable&gt; So, you see, the two cases of `use` you have found have different effects, even though they work with the same mechanism. `use std::io` brings a namespace into scope, `use rand::Rng` brings a trait into scope.
Some context: "OpenGL Shading Language (abbreviated: GLSL or GLslang), is a high-level shading language with a syntax based on the C programming language." (wikipedia) 
Is there a recommended way to install it? Currently, I do cargo install --force racer Which means I need to see update announcements or just try it every once in a while. It would be nice if something like 'rustup update' would notice I'm on 2.0.9 and update me.
**About IO** * std is Rust’s Standard Library/ crate. It has been divided into multiple modules. ex. std::io, std::env, std::thread, std::prelude * to use a crate from another crate, we have to import it first and then use it. ex extern crate test_crate_hello_world; fn main() { println!("{}", test_crate_hello_world::hello()); } * But we don't need import std crate manually because Rust inserts `extern crate std;` into the crate root of every crate. * `use` keyword is used to bind a full path to a new name. So instead of using the full path each time, we can use the shorter name/ alias. // 01. full path std::io::stdin().read_line(&amp;mut guess) .expect("Failed to read line"); // 02. import and use use std::io; // same to `use std::io as io`, so next time you can start from io io::stdin().read_line(&amp;mut guess) .expect("Failed to read line"); * Also by default Rust doesn’t load each and every thing on std crate on every rust program. Instead, it loads only the [smallest list of things which needed for almost every single Rust program](https://gist.github.com/dumindu/02f9a4a371f363e22efa1090005c303f). Those are called as preludes. Rust inserts `use prelude::v1::*;` into every module. **About Rng** * rand is an external crate so we have to use `extern crate rand;` * The rand::thread_rng function will give us the particular random number generator that you’re going to use. But rand::thread_rng.gen_range() is defined by the Rng trait which we have not import to local scope so far. So to add it to local scope we have to use `use rand::Rng;` PS. :: is used to navigate through modules, module-structs, enums or traits, static functions and etc. . is used for functions. If you are still confusing these things or you haven't heard about stucts, traits stuff ,just skip this Guessing Game section. It's more about to show Rust's way to experienced systems programmers but not for beginners (it can be, but not for everyone, including me) 
&gt; Same for Google, which is backing mercurial as well. &gt; Only Microsoft is trying to scale git for huge monorepos these days. Jonathan Tan from Google is [working](https://public-inbox.org/git/BC1048A63B034E46A11A01758BC04855@PhilipOakley/T/#mc717ecdd4cc6090409909a4dd8d04d81ed4ec82b) on adding partial clone features to git. So not sure how accurate that is.
I think that you'd need something a little simpler than type level numbers, since you just need an ordering and a max function, not arithmetic, right? Also, why would you need so many bounds? Can you sketch out what you were thinking?
Right! Sorry, completely missed that.
I use the excellent [`cargo-update`](https://crates.io/crates/cargo-update)
In case anyone else ends up using an f7, the clock config code I ended up with is here https://gist.github.com/cs2dsb/a5c8d60dc20c4a5fd5dc4745c906d011
Neither did I! Very cool. 
Crates.io is interested in moving towards using [The Update Framework](https://theupdateframework.github.io/). There's discussion/progress updates [here](https://github.com/rust-lang/crates.io/issues/75). The Rust compiler was bootstrapped from OCaml, but repeating the process is currently tricky because it requires you to compile ancient versions of Rust and then slowly advance forward by rebuilding on every breaking chnage.
Also another thing to take into consideration is using proxies such as Tor to fetch crates with, I'm not positive if there is any guarantee that only TLS will be used, I mean if fetches occur using Tor then malicious exit nodes could backdoor downloads. I think oftentimes github is used so perhaps there is TLS from them provided. Lack of TLS on operating system package manager's update &amp;&amp; upgrade systems has been critiqued in the security community, and this critique would be just as applicable here though it may already be mitigated I'm not certain. 
The trickiest question is how exactly this percentage of confidence/reliability should be calculated? I agree with you, it would be better for an end user to have a deal with some kind of confidence in range from 0 to 1. Now I have some idea how to do it, gonna give it a try. Thank you!
Why does TUF need to rebootstrap rust from OCaml?
Is that on google's hours? For a quick glimpse on hg's: https://www.mercurial-scm.org/repo/hg/log?revcount=500&amp;rev=author%28google.com%29 This includes works on porting to python3, [manifest sharding](https://www.mercurial-scm.org/wiki/TreeManifestPlan), rebase optimizations, work on the UX, … &gt; Jonathan Tan from Google is working on adding partial clone features to git. So not sure how accurate that is. Same thing is being worked on: https://bitbucket.org/Google/narrowhg 
Have you tried enabling the verbose-errors feature in nom? That tends to give more useful errors, and you could even handle the produced error trace and make a more meaningful error out of it. I don't remember if it slows down parsing in any way, but that should be negligible (and you could make it optional too). 
&gt; Is that on google's hours? No idea... Quick glimpse on git: https://github.com/git/git/search?p=1&amp;q=google.com&amp;type=Commits&amp;utf8=%E2%9C%93 &gt; Same thing is being worked on Maybe they are right now still undecided and want to make a comparison between hg and git before they switch? [This also seems to confirm](https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext#body-6) that they are still analyzing.
I've updated the lib, so no it provides confidence in the range from 0 to 1.
Your algorithm is very close to a naive Bayes filter. Maybe you could use the posterior probability to belong to a specific class as this probability.
Thanks for the tip. Sadly, 'cargo install cargo-update' fails. I first see error: failed to run custom build command for openssl-sys after a sudo apt install libssl-dev, I see a similar error for libssh2-sys. After installing libssh2-1-dev, I get another similar error for libgit2-sys. And after installing libgit2-glib-1.0-dev, I get the same libgit2-sys error. Stuck there. Had to back it all out and give up. 
Looks awesome!
I would guess to prove that the chain of `rustc` compilations is unbroken?
Last I looked at it it slowed parsing a bit, but for what I was using it for it was not very noticeable. Can't say for his case.
And why is that needed? Do they have some primitives down there that they trust? (Like all of ocaml, make, bash, etc?) Still curious.
Started writing a Gameboy emulator over the weekend. I've loaded up a Tetris ROM and I am just implementing each opcode as the `Cpu` gets to it and crashes because it doesn't know what the opcode is. Once I implement it I add a unit test for it then move on. I'm at the point where its starting to write into GPU memory so I'm hoping I can get something graphical happening by end of this week. I'm still neck-deep in the documentation for it and don't really understand the rendering pipeline at all but I'll get there. I currently support 16 opcodes (of which `NOP` is one... so technically 15 I guess? heh), but there are some useful ones in there. I've just implemented `CP n` and I also have `JR NZ, (n)` so quite a bit of the Tetris initialization code is able to run all the way down to `0x2CF` as of last night - so progress is being made anyway!
Usually, on stock Ubuntu I only have to do `sudo apt install libssl-dev pkg-config git cmake` (assuming none of those are already installed) which knocks out nearly everything I need for the things I `cargo install`.
`std::io` is a module within the `std` crate. When you type `use std::io;`, it is as if a `mod io { ... }` has been written in that spot, so all code below it can use `io`'s public elements via the `io::Item` syntax. When you type `use rand::Rng;`, it *only* brings the `Rng` item from the `rand` crate, so that you can use `Rng` without any qualifiers but no other symbols from `rand` are imported. Equivalently, you can `use std::io::stdin;` and now have access to the `stdin()` function with no qualifiers. Rust paths are a bit weird; `use` statements are always of the basic form `use &lt;crate&gt;::(&lt;module&gt;::)+;`, where the, to quote you, `firstPart` is the name of the crate from which to load items and `secondPart` is one or modules. Most crates are shallow, but you can technically go as deep as you want here. Finally, there's a "`thirdPart`" that can be: `Item`, `self`, or a `{ thingOne, thingTwo, ... }` of items and `self`. The `self` bit just brings the module: `use crate::module;` and `use crate::module::self;` are equivalent. The braces list lets you select a few specific items to bring in: as an example: `use std::io::{self, Read, Write,};` lets you bring in the two named traits, and also use `io::stdin()`.
I love the new MS, but we need to keep their feet to fire. But from all reports, the transformation is deeper than we think. Thank God for Balmer's departure. 
If the type is something that you commonly have references to, then you probably should default to passing by reference. In this case, `Column::Alias` contains a reference to a `Column`, so that suggests that passing by reference is better.
&gt; Each invocation extern crate foo features(logging, AVX, NOP_Blaster) would be a effectively a different crate and shouldn't b shared across projects or even in the same project unless they have the same feature specification. Yes, I understood that, but that's not the problem: having it part of the `extern crate` syntax (rather than a higher-level concern, outside the compiler, i.e. part of cargo instead) means resolving those features creates a circular dependency for compiling anything; first process the parent crate to find the features needed for the dependent crates, and then compiler the dependent crates, and then compile the parent properly now that the dependent crates exist (with additional complexity and loops to handle any macros).
How's this compare to https://github.com/DanielKeep/cargo-script ?
Have you read Ken Thompson's *[Reflections on Trusting Trust](https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf)*? I presume, knowing very little about the situation, that the OCaml compiler can be either trusted or verified (i.e. with Distributed Cross Compiling) as a basis for proving successive `rustc`s. The reason this would be desirable to someone is that *technically* compilers have a special self-perpetuating attack surface that other programs don't. I don't think it's necessary, but I'm also not a security auditor.
I've been waiting for something to happen like this for eight years :) Google's former Perforce, now Piper, special factor is the expanding/contracting nature to the monorepo - https://paulhammant.com/2014/01/06/googlers-subset-their-trunk/ and https://trunkbaseddevelopment.com/expanding-contracting-monorepos/. While Git has sparse-clone which can adequately be used for such things, it can't ordinarily handle the history that Piper can. Xooglers at Facebook knew exactly what they had to rebuild, and how long it would take. Exciting times.
Cool game for a game jam. When I won the game, I got the "We're saved" message, but when I built more solar farms, I got the message "build 18446744073709" (uint64_max).
I wanted to give it a go, but after compiling on Ubuntu (16.04 everything is updated etc... and a GTX-10xx series card) gfx_window_glutin freaks out.
It doesn't, I'm just answering OP's second question. 
Congrats! Any chance you could share a picture or video of the gameplay for those not on windows?
The reason you can do `rand::thread_rng` is, I believe, because you also have an `extern crate rand;` statement in the same file. This brings `rand` into scope, just like `use std::io` brought `io` into scope.
Why is GET all caps ? Shouldn't rust idents have only the first letter capitalized ?
&gt; I'd much rather write in JS than debug a nasty compile tool chain that takes forever to build Oh, you mean, like, [Babel](https://babeljs.io/)? (:
I will continue to try and figure out what the problem is with [this](https://github.com/mitsuhiko/redis-rs/pull/129) PR after a week long holiday. It needs some polish and benchmarks but I am still hopeful that it can be merged.
Regarding alerts for vulnerabilities in published crates, this is the goal of the RustSec project: https://github.com/rustsec. I agree with you about using public key crypto to sign and verify crates in addition to just relying on TLS.
/r/playrust
If a trait is implemented in a crate no one uses, does it really exist?
In my experience, handwriting even the smallest parser often ends badly. A lot of engineering mistakes come from yet another "heh, I could just not follow the procedure for this task, it's fine" :)
Do you have a pointer to some code?
As a non network-person: what is this exactly? Is this a program that you run in your network and it listens to all of the traffic and alerts you if it detects traffic that is known to be caused by malware? 
Indeed. Especially since the header format is fixed, there's not much benefit to using a parser combinator library. IMO you don't need a parser for this at all - a pointer cast into a `#[repr(C)]` struct with appropriately sized fields, while unsafe, is so much simpler and more clear.
The two different implementations can be found here: https://github.com/sscdotopen/incremental-cooccurrences/blob/master/src/main/scala/io/ssc/incrementalcooccurrences/IncrementalCooccurrenceAnalysis.scala https://github.com/sscdotopen/puppies/blob/master/src/main.rs In order to run the scala version, execute the following file: https://github.com/sscdotopen/incremental-cooccurrences/blob/master/src/main/scala/io/ssc/incrementalcooccurrences/experiments/Movielens1M.scala For the rust version, just download https://github.com/sscdotopen/incremental-cooccurrences/raw/master/src/main/resources/ml1m-shuffled.csv and change the correspoding path in main.rs.
what is the advantage over writing a mock rocket server? i think it is easier to mock with rocket because its less error prone than .toml config file .
Working on my new project: turn-based strategy game [Zemeroth](https://github.com/ozkriff/zemeroth/). In the last two weeks I: - [Implemented turns system, moves/attacks and basic AI] (https://github.com/ozkriff/zemeroth/pull/45) - [Updated to glutin 0.9](https://github.com/ozkriff/zemeroth/pull/48) - [Setup circle-ci to check android builds](https://github.com/ozkriff/zemeroth/issues/50) ([thanks, tomaka!](https://github.com/tomaka/glutin/pull/919)) - [Forced landscape orientation on android](https://github.com/ozkriff/zemeroth/pull/47) ([thanks again, tomaka :)](https://github.com/tomaka/android-rs-glue/issues/145)) - [Made lots of smaller changes](https://github.com/ozkriff/zemeroth/commits?author=ozkriff&amp;since=2017-07-13T21:00:00Z&amp;until=2017-07-29T21:00:00Z). Current state: https://www.youtube.com/watch?v=KGmjYH6RpFI vscode, cargo-apk, android: http://i.imgur.com/T9EgPR1.png [Right now I'm working on reaction attacks](https://github.com/ozkriff/zemeroth/projects/1). ------ [@ozkriff on twitter](https://twitter.com/ozkriff), [imgur devlog](http://imgur.com/a/SMVqO) ------ Btw, we've created a [gitter rust-gamedev room](https://gitter.im/rust-gamedev/Lobby) (for folks who prefer gitter to irc). Do I have to ask for someone's permission if I want to setup a bridge with rust-gamedev chat on IRC?
&gt; I'm not overly familiar with the systems as they are implemented, but I don't believe for example that there is any option to require a crate to be signed with a specific private signature key cargo creates a file called Cargo.lock which contains the sha 256 sum of every crate used for a project. This is better than a signature because its a) quantum resistant and b) doesn't allow people who have obtained the signing key (or who can coerce the author to sign their stuff) to give you a "special" version of the crate. The Cargo.lock file is attached to each project, so if you obtain the source code for it, you automatically get cryptographic hashes of all the dependencies. Obtaining the hashes in the first place, e.g. when updating a dependency or adding a new one to an existing project, is not very strongly secured: they are simply stored in a public git repo that is updated via the https protocol. &gt; Also, there isn't really a system whereby you can automatically become aware that a crate being used is considered insecure There is, its [cargo-audit](https://github.com/RustSec/cargo-audit). &gt; Also how secured is the actual Rust binary just in terms of would anything added to it be audited first by numerous individuals, how hard would it be to get backdoors into it The Rust compiler is written in Rust itself. There is no overly big amount of security connected to building the compiler: The compilation happens on travis and appveyor, both public cloud infrastructure. However, every change in the git repo goes through intensive review, and travis and appveyor only build what the git repo contains. So its better than the "person X compiled it on their desktop machine" but not as good as "compiled on an airgapped computer". The fortunate thing about the binary is that it doesn't need any centralized security model; hopefully one day the rust build is reproducible and then compilation will be replayable by anyone, which requires the attacker to attack everyone who does such a compilation replay. Of course, this still allows for trusting trust attacks, but for those [there is a solution in the works](http://github.com/thepowersgang/mrustc) to get a non rustc based trust basis.