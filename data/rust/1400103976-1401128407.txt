Oh well, im sure the macro could be copied for use with `Option`s a la... macro_rules! optry( ($e:expr) =&gt; (match $e { Some(e) =&gt; e, None =&gt; fail!("unwrapped None value {}", e) }) ) edit: I am horribly forgetful, this macro doesnt exist because stupidity.
&gt; Ideally a system that doesn't suffer from the holes of the current system. The current `mut` marker is the only way to make any of the types using inherited mutability (most types) mutable. A simple lint is enough to forbid the ugly types with internal mutability, since the compiler already has to be aware of them. &gt; If the current system has holes when it comes to guaranteeing correctness, lets get rid of it and design something better. It doesn't have holes. If it's removed, Rust will be losing a solid way of enforcing immutability via ownership. It's very unlikely that it will ever gain another mutability system because it already has a proven one and people want to remove it. It's not *possible* to have "deep immutability" so there's no point asking for it. Accessing read-only memory can trigger a page fault, causing the kernel to perform I/O. A more common example is unwinding or directly performing I/O. You can fake a lot of it if you have an effects system, but Rust does not and there is no 100% pure way of doing it anyway. Internal mutability is simply a reflection of the fact that immutability is a compile-time concept used to catch errors rather than a true runtime one. Most types use inherited mutability, but a few explicitly opt-out of the system (Cell) or do "deep" mutation behind the scenes (files).
It almost sounds like the questions were reversed, as if "Should there be a video" comes before "What's the content"? If there is something someone wants to put out there that is better presented as a video, go ahead!
It's not a lie, but it leads people to assume something that isn't. It's misleading. When I can declare x to be `mut` I assume that by default it's not `mut` that is immutable. And I assume that all it's contents are fully immutable too. That is I wouldn't instinctively expect that a `Cell`-like could have it's contents changed.
I feel like many of these issues would be clearer if Rust took the approach that academics take when designing languages. You design a bare bones core calculus, and on top of that you build a full language as syntactic sugar. For instance, such a core calculus would not have closures but only structs. This way you are forced to design a set of simple and general constructs without immediately having to worry about usability. At least for me Rust just seems so complicated that it's often hard to see the forest for the trees.
I see only correlation here, not causation. The languages that are in most use by the industry have been designed by...people/companies from the industry, and that is a large reason why they are popular. Languages designed by people/companies from the industry do not use that method of designing languages. Most of the popular languages would have been better had they been designed with such a methodology. The main reason for using a core calculus is that language design is hard. Designing a full blown language from the start is like trying to juggle 10 balls at the same time. Designing a core calculus is only juggling 5 balls. You can always sacrifice purity and simplicity when going from core calculus to real language. At least you'll be doing it on solid ground, rather than unexplored ground.
There's more than one species of mutability, ok. But I'm going to assume, in the absence of a specific qualifier, that "mut" refers to the genus, and means "this is mutable". Given that, when it's absent, I'll assume *that* means "this isn't mutable". In fact, "mut" means "this is mutable in this specific way", so its absence doesn't mean that something isn't mutable, only that it's not mutable that way/for that reason. This strikes me as a PR and pedagogical nightmare. It doesn't bother me that multiple kinds of mutability will still exist with this proposal, because the confusing implicature will be gone.
This would be wonderful.
In the context of a variable, "this is mutable" means "this variable is mutable". It allows you to assign new values to the variable. You can never assign new values to an immutable variable. Most types inherit mutability from the owner, with a few exceptions using internal mutability. There's no language with "true" mutability because it's not possible in a real programming language on real hardware. It's a fiction existing for the duration of type-checking, just like how the compiler pretends `i64` and `u64` are different things to make it nicer for humans to deal with.
I think the `unwrap` method for `Option`s takes care of this already; returns the value if it exists, fails on None values otherwise. http://static.rust-lang.org/doc/master/core/option/type.Option.html#method.unwrap If you want to provide a more specific failure message, you can use `unwrap_or_else(|| fail!("Your message here!"));`. I think the default message for failure when calling `unwrap` on a None value is something like: task '&lt;main&gt;' failed at 'called `Option::unwrap()` on a `None` value' edit: You should not use `unwrap_or_else(fail!("Your message here!"));` like I posted earlier! It should be `unwrap_or_else(|| fail!("Your message here!"));` dbaupp's post further down explains
So long as it doesn't overwhelm you and lead to burn out. We love TWiR! :)
If unboxed closures solve the current issue with closures and the borrow checker and they are going to be in the language then why go through with this change?
Thanks, I edited my post.
You might have a point there, but I think we agree that making vars mutable by default would be a bad idea and that Niko's use-cases can be addressed in other ways. That's the gist of what I was saying. 
Well... they don't really solve the issue. The problem still remains: you either have to choose between having to put `mut` in weird places even with unboxed closures, or you have `&amp;uniq`.
Personally, I very much dislike videos (and slideshows) for presenting technical information that I may want to reference at some point. Even with seeking, videos are inherently linear, and are generally pretty inefficient at telling me about things that I'm probably going to read more about anyway. Demos and interviews and things might be neat, though. It seems like you could just add an "interviews and demos" section or something, and produce or link to videos in TWiR, rather than there necessarily being a new video each week.
Well color me stupid! That just completely left my mind as I was thinking about macros...
&gt; It's not possible to have true deep immutability in a language. There is no language out there with this feature, because it's simply impossible. I'm sorry, but that's just not true. [D has `immutable`](http://dlang.org/const3.html) and any data marked as such is truly "carved in stone." It's a deep, transitive immutability. While the compiler will let you cast an `immutable` type to a pointer and derefing that pointer is fine (so that you can interact with C libs), mutating the data through that pointer results in undefined behavior. And again, the whole "can cast to pointer" business is there only for interacting with non-D code. And before you say "well then `immutable` must not be used much", it's used a ton in idiomatic D, including the standard library.
I may have gone offtopic here. I wrote up the RFC to rename `&amp;mut` to `&amp;only` since my issue is exactly what you describe - I feel that `&amp;mut` implies that `&amp;` is immutable, which I don't think it is, at least not in any useful way when it comes to reading someone elses code which is using generic types. This is why I'm supportive of making that change. My original proposal was to do that renaming, and then allow borrowing of a local variable declared without `mut` to an `&amp;only`, assuming its not otherwise aliased. That would allow for keeping simple types like `uint` immutable by default (unless you explicitly reborrowed them to an &amp;only), while more or less discarding the default immutability for more complex types, which I think they already effectively lack, at least for generic types. I eventually dropped the 2nd part of the proposal since I just wanted to focus on a single topic. I was also a little uncomfortable with the idea or borrowing a `&amp;only` from a non-`mut` local. I like the proposal actually under discussion here since it does away with that weirdness by proposing a significantly more drastic change.
Please spend a moment to read the subreddit rules. If you did, you would realize that this is subreddit is not for the videogame rust, but for the [programming language](http://www.rust-lang.org). And judging by your post history you seem to do this a lot. Please remember to read the subs rules before you post. Actually upon further inspection, you seem to be blog spamming.
I’m certainly not fond of the whole `get(&amp;mut self)` thing. But bear in mind that this is for the higher level, not for the lowest level; efficiency is a desirable property but should not compromise the API too much. `Cell` is completely out of the question as it admits only `Copy` data; `RefCell` would be the only option there. It exposes mutable references, which is enough to then use `std::mem::replace` for your exchange scheme. I had assessed the possibility of using `RefCell` and then taking `&amp;self`, but as you say, that would necessarily still forbid the returning of any references, lest it should lead to runtime errors in various cases that *look* harmless. `Clone` is going to be the only sensible way to deal with things in most cases, though swapping can potentially be of value—in most cases, though, people that are dealing with the typed interface aren’t going to be caring about the last two nanoseconds of performance terribly much; if they want ideal performance, they will probably be using the lower layers directly. I don’t think people would use swapping (or popping, were that implemented) frequently at all. If people aren’t going to use such things, then returning references will be faster. In the end, I think that for now taking `&amp;mut self` is the best way. It can be reassessed at a later date if it is turning out to be too painful or unnatural. Your visitor technique adds only a little bit of efficiency, removing a `header_name()` call and a hashed key lookup. I would prefer to leave such micro-optimisations out for now, and observe usage, to see whether such a feature is desirable. Adding things for the sake of it is not a desirable thing.
If you (or a library you're using) make a mistake with an internal `unsafe`, the fn isn't safe despite advertising itself as such, and you can segfault or worse. The primary difference is that memory unsafety is a bug and internal mutability is generally intentional; I'm sure the first person who has their system owned via a nominally safe Rust fn will appreciate knowing that because it was a bug it somehow doesn't count. The point isn't that we should force a more rigid definition of safe, or give up on safety altogether. The point is that a useful system does not cease being useful just because it has some holes. Learn where the holes are and how the system works, and take what it gives you.
Surely you can still *change* it?
D doesn't solve this either. It makes no attempt to keep `immutable` and `const` transitive for low-level bits like file descriptors. Rust's mutability only applies to owned data, so it's not as broad, but both languages break the rules in their standard libraries to get real work done. Purity and immutability is always a half truth, because it's simply not how an operating system works. A read of some memory can trigger a page fault, causing a read from a drive, and potentially depleting the remaining memory - triggering the death of some process. Is that really pure? It's useful for compiler optimizations and reasoning about the code, but it's not a perfect system.
&gt; Okay, now I see we have a different definition of "immutable". Your definition of it is "shallow" (as it is in C++), and my definition is "transitive" (as it is in D). No, the Rust definition (my definition) is not shallow. It does not work the same way as it does in C++, and it also doesn't have an equivalent to what `const` does on references / pointers in C++ or D. It's *inherited* mutability, **not** shallow mutability. The inheritance of mutability is as deep as `clone` will go, which is further than the shallow copies you get from regular assigning, passing and returning. &gt; I guess you don't know the D programming language because this concept of "transitive immutability" seems completely lost on you. Thanks for the condescending tone. I know what transitive immutability is, and I know D well enough to understand that it breaks the rules in the implementation of the standard library too. There are plenty of cases where an object has pointers, file descriptors or OS object handles for data mutated externally but the object is allowed to be immutable.
Use [`expect`](http://static.rust-lang.org/doc/master/std/option/trait.Expect.html#tymethod.expect): $opt.unwrap_or_else(fail!($msg)) =&gt; $opt.expect($msg)
Good suggestion! I've noticed when trying `expect` that the error message outputs the line number for its definition in rust's source code rather than the line number for where it's called. For me it looks like: task '&lt;main&gt;' failed at 'Custom Error Message!', /home/rustbuild/src/rust-buildbot/slave/nightly-linux/build/src/libstd/option.rs:164 Whereas what I would prefer to see (and what `unwrap_or_else(fail!("Custom Error Message!"))` outputs) is: task '&lt;main&gt;' failed at 'Custom Error Message!', src/main.rs:219 I'm not sure if this problem just happens for me (maybe I'm doing something wrong), but it would be nice for `expect` to output the file and line where it was called, it is certainly a lot nicer to use! edit: `unwrap_or_else(|| fail!("Custom Error Message!"));` should be used instead of `unwrap_or_else(fail!("Custom Error Message!"));`, this outputs the line number in from where it was called
&gt; D doesn't solve this either. It makes no attempt to keep immutable and const transitive for low-level bits like file descriptors. You're moving the goalposts. D's `immutable` makes no pretense that it offers immutability that spans outside your program, only immutability of memory in your process's address space controlled by D code. But if your `immutable` data refers to an OS construct like a file descriptor that refers into a kernel array, well then good luck with that. That memory isn't within the control of your program. Same with a handle to a database running on a different machine. Let's not make up unreasonable "limitations." That's not what we were talking about; I can mark a data structure I've built in a D program at runtime as `immutable` and _know_ that that memory _will not be changed by other parts of my program_, come hell or high water. I can't do that in Rust and I'd like to. &gt; Purity and immutability is always a half truth. I haven't said a word about purity, but I mostly agree that _useful_ function purity is hard to implement in a programming language.
&gt; You're moving the goalposts. D's `immutable` makes no pretense that it offers immutability that spans your program, only immutability of memory in your program's address space. But if your `immutable` data refers to an OS construct like a file descriptor that refers into a kernel array, well then good luck with that. That memory isn't within the control of your program. Same with a handle to a database running on a different machine. Let's not make up unreasonable "limitations." That's not how `immutable` in D works. It usually isn't respected at FFI boundaries even when there's mutation of the same address space. It's not any sort of hard guarantee about the process address space. &gt; I can't do that in Rust and I'd like to. Yes you can. That's what lack of `mut` does for what used to be called `Freeze` types. Unless the code is generic, you still have the guarantee. The `Freeze` trait is no longer exposed because it wasn't viewed as useful in the old form (it became `Share`) but could be added back along with a lint for non-`Freeze` types.
The whole point of a theme is moving that responsibility to someone else who is supposed to know what they're doing :P.
&gt; That's not how immutable in D works. It usually isn't respected at FFI boundaries even when there's mutation of the same address space. It's not any sort of hard guarantee about the process address space. I wasn't specific enough when I originally posted so I edited my post to clarify (ugh, poorly). Yes, you can call a C function that will write zeros throughout your address space, mutating `immutable` memory. Unsurprisingly, non-D code doesn't respect D language contracts. This doesn't make `immutable` a single shred less useful. The point is that other parts of your D codebase can't change `immutable` memory. If they've somehow managed to pull this off, they've resorted to undefined behavior or reached outside the language. &gt; That's what lack of mut does for what used to be called Freeze types. ... and we don't have `Freeze` anymore. "Could be added back" isn't something I can write code with.
Calling `upwrap_or_else(fail!(...))` like that is not doing what you expect. It's exactly like writing: let closure = fail!(...); option.unwrap_or_else(closure); I.e. the `fail!`ure happens unconditionally, without examining the `option` at all. You should write `option.unwrap_or_else(|| fail!(...))` to have the failure triggered by *calling* the closure, not by *creating* it.
&gt; "Could be added back" isn't something I can write code with. It's a proposal for something that can be adopted if necessary or useful, e.g. DST isn't something you can write code with... **yet**.
&gt; ... and we don't have `Freeze` anymore. "Could be added back" isn't something I can write code with. The compiler is still aware of which types use internal mutability. The lack of a lint for types with internal mutability is all that's missing if you want `mut` to be the only way to have mutability. It doesn't require any changes to semantics. Do you consider reference counting and garbage collection mutating memory to count as mutation though? At the moment it's not going to allow using `Rc&lt;T&gt;`, although it is going to allow using various forms of input/output or other functions with effects where memory in the address space for the process *does* get mutated. It's only relevant to generic code and I'm not sure that actually exposing this as a trait is useful. It was removed *because* no one spoke against taking it out or provided a reason to keep it. If the existing inherited mutability support is removed, that's the end of mutability support in Rust. Immutable by default is not ever going to be added back because it would be an enormous breaking change.
&gt; Do you consider reference counting and garbage collection mutating memory to count as mutation though? I'm far more concerned with logical immutability than direct memory immutability. I write C++ all day long and like that I can bail out of a `const` restriction on a member function when I need to lock a mutex since the mutex member object is marked with `mutable`. I was just trying to make a point that transitive memory immutability really is both useful and implementable, even though logical immutability is more often what the user wants. &gt; If the existing inherited mutability support is removed, that's the end of mutability support in Rust. Immutable by default is not ever going to be added back because it would be an enormous breaking change. Yep, let's keep what we have. It's useful enough for my needs.
&gt; writing code in it you can execute is hard You can't write code you can execute in a Rust-without-`mut`, so why are you complaining? /s (Talking about hypothetical features/non-features is perfectly reasonable.) --- In any case, `Freeze` is actually already modeled in the compiler (it knows about [the `Unsafe` type](http://static.rust-lang.org/doc/master/core/ty/struct.Unsafe.html), which is the only way to be non-`Freeze` and avoid undefined behaviour). Exposing it for libraries to use would be trivial; it's not a wild "amazing fluffy" feature. And, due to violations being specified as undefined behaviour, it is perfectly reasonable for the compiler to optimise based on its internal model of `Freeze` now. (E.g. if `T` contains no `Unsafe`, transitively, then all `&amp;T` pointers have no memory dependencies aka don't "alias", i.e. there is nothing you can do to one `&amp;T` that can be observed by any other `&amp;T`.)
Please forgive my newbie rambling, but would something like the following work? The keyword mut is only used to introduce new variables, whereas &amp;my denotes aliasiablity (but not mutability). struct Env { errors: &amp;my int } // Compiler deduces that env must be mutable fn mut_helper(env: &amp;my Env) { *env.errors +=1} // No mutability constraints om arguments fn helper(env: &amp;my Env) { println!("Errors{}", *env.errors} let errors = 0; let mut mut_errors = 0; let env = Env { errors: &amp;my errors }; let mut shallow_env = Env { errors: &amp;my errors }; // Allowed because errors is deeply immutable let mut mut_env = Env { errors: &amp;my mut_errors }; // let mut mut_env2 = Env { errors: &amp;my mut_errors }; // Error: my_errors is already borrowed // mut_helper(&amp;my env); // Error argument of mut_helper must be deeply immutable // mut_helper(&amp;my shallow_env); // Error argument of mut_helper must be deeply immutable mut_helper(&amp;my mut_env); helper(&amp;my env); helper(&amp;my mut_env); helper(&amp;my shallow_env); 
Vimscript _is_ horrible! But never fear, there's an alternative: /u/valloric's shiny [YouCompleteMe](https://github.com/Valloric/YouCompleteMe) completion framework! Write a plugin in C++ (or Python?) instead of a whole completion app in vimscript.
This is why you shouldn't read too much into what the benchmarks game says about Rust the language: most of the problems are just that our benchmarks aren't optimized, not that the compiler isn't optimized.
From a quick scan of that list, we're not currently using either `once` or `virtual` as well.
We use `virtual` for virtual structs, though they are (deliberately) a not very well advertised part of the language.
Both are being used: - [`once` (parser)](https://github.com/mozilla/rust/blob/73a68cdba0d6e5ee28c9ef1ae80ec473f16cd9e9/src/libsyntax/parse/parser.rs#L1032) for the old form of `once` functions. - [`virtual` (parser)](https://github.com/mozilla/rust/blob/73a68cdba0d6e5ee28c9ef1ae80ec473f16cd9e9/src/libsyntax/parse/parser.rs#L4638), for struct inheritance. (Feature gates are required to actually do anything with them.) #![feature(once_fns, struct_inherit)] virtual struct Base { x: int } struct Foo: Base { y: f64 } fn main() { let _foo = Foo { x: 1, y: 2.0 }; let f: once || = || {}; f(); // f(); // invalid: 'use of moved value' } 
I try not to, but people tend to. I'd prefer benchmarks of idomatic code, not code in diffferent programming languages directly calling SIMD, CUDA, GMP etc. I think it's only a meaningful indicator if you fail to achieve performance this way.
That puts the binary-trees benchmark in a weird spot. Is it cheating to use Apache's memory pool implementation in C/C++/Ada/Fortran? How about arenas in Rust, which are essentially the same thing?
I am personally not a fan of podcaste because i need the same concentration when listening to or watching something. Also, my experience is that code related stuff you can talk about without showing code, is not interesting to me. Same cost: my time/concentration, less benefit: only the audio, wihtout the visual information.
People would go there for computer games all the time, anyway.
`static mut NAME: Type = initialiser;` declares a mutable global, however, modifying such a thing is memory-unsafe in general, and so requires `unsafe` for all accesses. And, yes, Rust does provide [atomic types](http://static.rust-lang.org/doc/master/core/atomics/index.html) (the canonical import path is `std::sync::atomics`). You can see some examples [in that module](http://static.rust-lang.org/doc/master/std/sync/atomics/index.html), including using a global variable. (The operations are all methods on the `Atomic...` types.) In future, a global mutable static that stores a type like the atomics will actually be able to be used without `unsafe`, because the atomic types satisfy [the `Share` kind](http://static.rust-lang.org/doc/master/core/kinds/trait.Share.html).
&gt; Is it possible to declare a mutable global variable? You can (search for "static mut"s), but it is strongly discouraged. A main reason is that such global mutable variable could be shared among multiple tasks and thus is unsafe in many regards. You can safely use a thread-local storage (search for `local_data_key!`) if your use case is simple and does not involve multiple tasks. &gt; Does an atomic compare and swap exist in the rust library. Yes. Look at [`std::sync::atomics`](http://static.rust-lang.org/doc/master/std/sync/atomics/index.html).
Is this something people with spare time but little or no Servo experience could help with?
Doh! That was silly, thanks for correcting me.
I read TWiR primarily to keep up with the Rust community (as well as all those breaking changes), and to get more familiar with the language in general. Videos won't help the former, but they would certainly help for the latter. Go for it, as long as it doesn't cause too much load. Possibly make it an occasional treat, instead of a regular feature :)
I should have quoted what I was responded to: &gt; just to remove a single, simple keyword from the language seems like a terrible tradeoff. It *is* much more complicated that *just a keyword*: it has semantics that are checked by the compiler, etc... &gt; Thus when the Rust developers says mut is complicated, let's trust them on this. I never said anything about Mozilla here, Rust developers include (as far as I can see) all people who have contributed to Rust, and thus yourself among others. It's not an appeal to authority, but an appeal to experience. Not having opened the compiler innards myself I can only trust those who did when they say that the borrow checker is complicated. If you know about it, please do speak up.
I am not *exactly* opposing it, actually. Or rather, I am playing both sides of the arguments trying to distinguish what matters and what does not. As a C++ developer, I certainly appreciate what `const` implies and I would rather see `mut` live on... As for captures by values and captures by references, it seems difficult to know in advance which a user would favor. The capture list of lambdas in C++ may be bulky, but the versatility it brings is interesting (especially in C++14).
I agree. I always take the Haskell example for this because fully optimized Haskell (with unboxing and eager evaluation and layout hints...) looks more like Perl than Haskell sometimes :x I had tried looking at the Haskell benchmark code in my nth attempt to learn the language but it was so alien (compared to regular Haskell) that I had to back off. On the other hand, it's important to understand that should you need to optimize a particular tight spot you can do so right in the language without invoking the FFI. Thus, I tend to look at the benchmark as some kind of upper-bound in efficiency. Regular code will never perform as well, but if you need to you can approach it.
No, they're semantically identical (the few cases I just tested just now didn't compile to exactly the same thing, but the differences with optimisations were just the ordering of instructions). As such, the only difference is syntactic. I personally think the only use-case for "tuple structs" (`struct Foo(bar)`) is when you're constructing them a lot and only deconstructing in a handful of places, and so the `Foo(expr)` syntax is nicer than `Foo { bar: expr }`. In most other cases, the much nicer field access syntax of the "normal" structs outweighs the construction syntax for me. (Also, field names are nice and self documenting.) NB. `struct Foo(Bar)` is sometimes called a "newtype" struct, but it differs from Haskell where `newtype` is different to the "normal" way to declare data types: Haskell's `newtype` doesn't add a layer of boxing around their contained type, and so is faster. Nothing is Rust is automatically boxed, so there is no such difference.
&gt; The capture list of lambdas in C++ may be bulky, but the versatility it brings is interesting (especially in C++14). FWIW, unlike C++, Rust doesn't actually need capture clauses, since references are first-class values, and so we could just capture everything by value; under this scheme "capturing by reference" is just "capturing a reference by value".
I used to be a fan of newtype structs until I tried to wrap my head around derefing a nested pointer to a newtype struct (when `*` still unwrapped them).
&gt; Thus, I tend to look at the benchmark as some kind of upper-bound in efficiency. Exactly.
Almost certainly yes. There's often a lot of elbow grease required, but not much domain experience.
That’s what I expected. I suggest asking for volunteers to help with it—I think it likely you’ll get some.
`&amp;uni`
Since dereferencing of tuple structs was removed, I would tend to say that tuple structs are *less* convenient, because you need to use a pattern match to get the value out, e.g. `fn baz(&amp;self) { let Foo(ref bar) = *self; }`. The convenience of instantiation can be achieved with a function of the same name as the type: `fn Foo(bar: Bar) -&gt; Foo { Foo { bar: bar } }`. I sometimes wonder if we would be better removing them altogether—hang the symmetry between structs and enum variants, both of which can be of form unit, struct or tuple.
&gt; I sometimes wonder if we would be better removing them altogether—hang the symmetry between structs and enum variants, both of which can be of form unit, struct or tuple. Yup, I'm fine with this. I mentioned it in passing on IRC or some such a while ago, and there wasn't widespread support, but maybe that's changed?
Yeah, that's better.
May be `&amp;uq` like `fn` for function?
Please comment on SIMD RFC then. Thanks. https://github.com/rust-lang/rfcs/pull/15
Want to make an RFC for that?
Situations like this occur due to bad naming. And if there's really the need for an inner scope, why not introduce a function for that purpose with a descriptive name and rely on inlining to remove it again?
 Syntax |Readable?|Writeable?|Can others| |Can stay |C++ equiv | | |change it?| | in a register? | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &amp;T |yes | no |no | | yes | const &amp;T restrict &amp;mut T |yes | yes |no | | yes | &amp;T restrict &amp;share T |yes | yes |yes | | no | &amp;T /&amp;muts T /&amp;shared_mut T /&amp;cell T /&amp;volatile T /&amp;vlt T &amp;overwrite |no | yes |no | | no,must escape | n/a via mem. would that work and cover everything ? anything else to consider like deep/shallow mut/immut? I think these are sorted by frequency of use. I would also be interested in adding the 4th “write only” type, thats another issue. -hints allowing use of allocate-zero cache-control instructions on some platforms -eg ppc dcbz; -building GPU command lists in shared memory, a CPU might use uncached pages, reading there is not optimal. -Further clarifies intent/makes dependancy clearer , r.e. writable variables that are *not inputs* - i’d accept a long name for this being a rare type. &amp;write_only, &amp;write_mut, &amp;overwrite, whatever -you might even want to go further and say '&amp;overwrite', i.e this code *must* write this value, the value may be invalid before and put into a valid state. EDIT: would operator 'box' for placement new really take an 'overwrite' parameter .. ? EDIT2: remove column 'aliasiable', as thats whats' 'can others change it' is saying, really. (note of course c++ has TBAA to do avoid needing restrict sometimes.. and it probably this table doesn't really show a difference between multiple writable references and concurrent writes)
&gt; I feel like many of these issues would be clearer if Rust took the approach that academics take when designing languages. You design a **bare bones core calculus,** What does this mean practically? Do you have some examples that took this approach and how they went about building on top of it?
I must admit I could care less :) I just followed in the steps of my predecessors. I suppose that once the semantics are decided, we can bikeshed the names to our heart content \^^
Actually, [there is no float type anymore](https://github.com/mozilla/rust/pull/9519) in Rust. Edit: Sorry I should have worded it better. I mean, the hardware dependant `float` type is gone, there is only `f32` and `f64` now.
I believe, after pouring over this, that you mean `&amp;mut` in the current behavior (ie, `&amp;only` in my proposal), since under my proposal `&amp;mut` becomes the `&amp;shared` you are proposing. The one thing about `&amp;write_only` is that I find it quite difficult to really only *write*. For example, `+= 1` is write only in that you do not care about the previous value (or the new one); however its implementation implies reading the previous value to deduce the new one.
Rust's actual float type is just named f32 correct? It looks like that link is about taking out support for the hardware precision limit float ( 90 bit on Intel? ). This seems silly to me, I would think it would make sense to expose it, although having used high precision floats in D, they ended up being incredibly slow (although I don't know exactly why). 
Probably the best known example is ML. ML is a full blown language but the type system at its core is Hindley Milner which can be described [in a couple of lines of math](http://upload.wikimedia.org/math/4/0/7/4079c494a0a69f1688d782889c29e332.png). Compare this with the type system of Rust. It is essentially defined by implementation with tons and tons of cases. Even if you were to describe it in math notation instead of in code, it would still be hugely complex. Unlike the ML type system, there is no way to extract its essence into a couple of lines of math.
Would you allow to mark a field of a struct as SafelyMutable without marking the entire struct as SafelyMutable? struct A { x: int, y: Cell&lt;int&gt; } let my_a = A {x: 1, y=Cell::new(2)} let ref_a = &amp;mut my_a; ref_a.y.set(3)?
`&amp;the`
It is about removing a type `float`, not `f32` or `f64`. The type `float` was akin to `int` or `uint` (as a default type of that kind), but unlike `int` and `uint` which is useful as a length of any vector or slice `float` had no such merit, henceforth removed.
What do you mean by parallelism ? In the example I gave: enum Broken { Integer(int), String(~str) } fn foo(broken: &amp;Broken) { match broken { &amp;Integer(a) =&gt; (), &amp;String(s) =&gt; broken = Integer(3); println!("Broken was {}", s), // there is an `int` in the memory cell where `s` would expect a pointer to be... BOOM } } there is no multi-threading, and yet it's memory unsafe.
Use a "normal" struct if the field name is meaningful. If you’re tempted to name the only field the same as the type or something like "data", the name is useless so a tuple-like struct like this may be preferable.
I was talking about the 'races' part of the original quote, not about memory safety. Sorry, should've made this clearer.
Probably binarytrees. You're forbidden from writing your *own* arena, but you can use an arena from a library. Yes, it's completely arbitrary, given that binarytrees was supposed to be a *garbage collection* benchmark anyway.
Yeah, it's totally arbitrary. What's worse, binarytrees was supposed to be a *garbage collection* benchmark—it's meaningless to use it in any setting other than GC.
In short: no. If you use those, your code won't be portable at all. Remember that rust wants to target from micro-controllers and embedded devices (which might have SIMD units) to supercomputers (some of which already have 512 byte-wide AVX2 SIMD). Boost.SIMD has shown that there is a better solution to this problem. Any take on SIMD should allow you to write portable, efficient, generic, and correct code, easily (let's aim for the sky). In C++ pseudocode: __restrict double* pointer; __restrict double* pointer2; // given two non-aliasing pointers int no_elements; // in a range form auto simd_kernel = [&amp;](auto i) { // declare simd kernel in a lambda (parametric index type) auto v0 = make_simd_vector_at(pointer, i); // create vector of best size automatically auto v1 = make_simd_vector_at(pointer2, i); v0 = 2 * v0 + v1; // use an EDSL for linear algebra to select SIMD instructions }; // Iterate over all elements in the range that map to a multiple of the simd vector size chosen. // The kernel knows that it can be SIMDzed since the index type tells it so: for (auto i : simd_irange(0, no_elements)) { simd_kernel(i); } // If the number of elements is not a multiple of the SIMD vector size chosen, // we need to do something different on the remainder. By returning a different index // type, the kernel knows that it shouldn't use SIMD instructions for these elements: for (auto i : simd_remainder_irange(0, no_elements)) { simd_kernel(i); } // it would be awesome if this last step could be omitted but I don't see how. IMO, whatever approach is chosen should: - allow implementing portable algorithms independently of the SIMD vector size of the given architecture, - allow to choose the best vector size automatically at compile-time depending on target platform of the compiler (e.g. if mtune=native/march=native are used) - allow to choose the best vector size automatically at run-time - provide run-time and compile-time checks for the best SIMD instruction set available such that the users can write custom kernels This requires: - to completely abstract SIMD vector sizes, - to completely abstract SIMD instructions (and to provide slower ones when the architecture doesn't support the ones chosen) - allow to easily transform linear loops into SIMD loops, and handle remainders/corner cases in a generic and correct way. - provide a small DSL for linear algebra since this is a very popular field for SIMD. - provide standard SIMD algorithms like e.g. shuffle. - provide a standard way to check for alignment and to align things
Well, `Cell` would be `SafelyMutable` here, so the question is whether `A` should be or not. It is an interesting question given that composition will obviously occur, but I somehow managed... not to think about it :) I could see multiple ways to resolve this issue: 1. Only allowed for public fields (like yours): too restrictive (on how one can use `Cell`) 2. `A` must become `SafelyMutable`: too restrictive (on the methods `A` can implement) 3. Allow `&amp;mut A`, and more importantly `&amp;mut self` on a `A` instance, without making `A` a `SafelyMutable` The latter seems like the only interesting choice, and could be met by altering the rules of `SafelyMutable` I think: - You must explicitly declare `SafelyMutable`: like `#![deriving(SafelyMutable)]` - You can thus use `&amp;mut self` methods without being `SafelyMutable`, although of course you are restricted in what you can do then (since ultimately only `SafelyMutable` items will be able to change) So it would seem to work out quite well. What do you think ? *Note: you cannot derive a `&amp;only self` from a `&amp;mut self`, which is what restricts the available mutability.* *Note: I'll think over this and, depending on reactions, may edit it in later in the post at the top to concentrate everything in one place.*
Can you post code that compiles and is not memory safe? I can't. 
The names &amp;my and &amp;our sound nice :-) Edit: That is: Use &amp;my instead of &amp;only and use &amp;our instead of &amp;mut. 
If your goal is to provide full coverage of every use-case, then I think you are missing a row with "can I change it =&gt; no; can others change it =&gt; yes". (I believe this corresponds to const-references/ptrs in C++: inside of a function that takes an argument via a const ptr, I am not allowed to modify it, but I should *also* not assume that other code might modify it.) ((edit: that should have said "I should not assume that other code _won't_ modify it." As in, it might be modified.)) Being able to express this would be a way to allow code to lend out `&amp;const` references to locally mutable data (and still reason on the basis of there existing at most one writer of that data). (Also, there is already vestigal support for such references still lying dormant in rustc.)
Ah okay; well actually there was another paragraph in Niko's article: &gt; A note on terminology: I think we should refer to aliasing as sharing. In the past, we’ve avoided this because of its multithreaded connotations. However, if/when we implement the data parallelism plans I have proposed, then this connotation is not at all inappropriate. *In fact, given the close relationship between memory safety and data races, I actually want to promote this connotation.* This underlines the fact that should you manage to solve the memory safety issue whether by removing aliasing or removing mutability, the race issue is basically solved as a fallout: - immutable object can be shared freely across multiple threads of execution - mutable objects can be used without synchronization provided you guarantee that only a single thread of execution has a reference to them Of course in my proposal I am adding a nuance between immutable and non-aliased, which cannot be shared between threads safely without extra work. `Mutex` is an example of a type in which extra work was done.
I would note that under the proposal I posted here, `&amp;T` where `T` is `SafelyMutable` does not guarantee that the pointed to data is constant any more than today's `&amp;T` guarantees it when `T` is inherently mutable (like `Cell`).
&gt; shouldn't read too much into what the benchmarks game says Except when it says [And please don't jump to conclusions!](http://benchmarksgame.alioth.debian.org/dont-jump-to-conclusions.php) ;-) &gt; our benchmarks aren't optimized **Program authors** should contribute their optimized or idiomatic Rust programs directly to the benchmarks game by following these instructions -- http://benchmarksgame.alioth.debian.org/play.php#contribute -- to give implicit permission that their program source code can be published on the benchmarks game website.
This looks nicer than both the current system and Niko's proposal. If it's implementable and doesn't have any unpleasant corner cases, I'm all for it. It's easy to understand, has immutability _and_ unique references. Even if this proposal fails, I think we'll learn something from it. Thank you for posting this!
Cross-language "benchmarks" **are** a wierd spot :-) "The difficulty is that programming languages (and programming language implementations) are [more different than apples and oranges](http://benchmarksgame.alioth.debian.org/dont-jump-to-conclusions.php#comparison), but the question is still asked - Will my program be faster if I write it in language X? - and there's still a wish for a simpler answer than - It depends how you write it!"
&gt;&gt;. For example, += 1 is write only in that you do not care about the previous value (or the new one);however its implementation implies reading the previous value to deduce the new one. hence += would be disallowed by &amp;write_only - the value is also an input; &gt;&gt;I believe, after pouring over this, that you mean &amp;mut in the current behavior (ie, &amp;only in my proposal), since under my proposal &amp;mut becomes the &amp;shared you are proposing. perhaps everyone is just biased to the code they write, but for me the current idea of &amp;mut is clear, and a useful default; I'm on the side of keeping it; - shared mutability is harder to reason about and has performance hazards so i'd argue thats the case that wants to be clearly marked, unique-mutability should be the commonly used default for efficient code thats easier to reason about
&gt; If it's implementable and doesn't have any unpleasant corner cases, I'm all for it. That's actually what I am afraid about, coming up with a proposal is easy but proving its soundness is way beyond my reach. I am waiting for someone to come and shout it down :) 
The fact that Cell is needed means the type system is not expressive enough in the first place. I like this or something like this because it makes more sense to me. Cell is no longer a special hack using Unsafe.
I proposed this independently (in IRC), and it really is the best solution I can personally see. (I might say use "ex" instead of "only", because it's a bit easier to type and sounds better in terminology and error messages: "Cannot access foo because it is exclusively borrowed at line 42, etc etc etc".) "You don't have a mutable reference- you cannot mutate this. I do not want you to mutate this, I want it to be the same as it was before I let you borrow it. This is because I don't think you need to mutate this, so by the principle of least privilege I will not let you." "You don't have an exclusive reference- you cannot mutate this if it is not safely mutable. For example, if it is a Vec you cannot mutate it as this could change its length, and I might be iterating through it and Rust doesn't have iterator invalidation. Of course, if it's a Cell or whatever, you can feel free to mutate it all you want, but you might die at runtime so beware. It is not a matter of manners, it is a manner of safety." Manners are good to enforce, but their semantics clash with safety. The two concepts should be entirely divorced. The best illustration is RefCell- .borrow_mut would turn a &amp;mut RefCell&lt;T&gt; into an &amp;mut only T (through a Ref, of course.) **The exclusivity is given and confirmed at runtime!**
ah yes good point. &amp;const volatile perhaps? or, 'shared' is writable+volatile, and just plain volatile is 'volatile' , with Rusts' current 'I don't write it' by default. I don't have a good idea what to call all of these, unfortunately; but I do like the default current &amp;/&amp;mut over specifying noisy const/(restrict) in C++.
So contribute "idiomatic" Rust programs, for whatever definition of "idiomatic" you prefer.
I still find it hard to find a use case for `&amp;write_only`, did you have something specific in mind ? I know that in C or C++ there are so-called output arguments, however since you can return a tuple easily in Rust output arguments seem less valuable: fn fib_impl(n: int, r1: int, r0: int) -&gt; (int, int) { if n == 0 { (r1 + r0, r1) } else { fib_impl(n-1, r1 + r0, r1) } } fn fibonacci(n: int) -&gt; int { let (acc, _) = fib_impl(n, 0, 1); acc }
and there's more to do with safety, QNANs. Some people have suggested a 'r32' (real 32) for what C/C++ programmers are used to as plain float. f32 doesn't support 'TotalOrd' or something. SIMD will definitely need the performance oriented assumptions. The issue is rust assumes every operation must handle all potential inputs safely, whereas in practice high performance code relies on assumptions flowing through from data generated or validated some specific way to avoid divide by zero, overflows etc. Similarly array indexing..
Thank you for taking the time to write up a different perspective. As someone who loves (but is not necessarily skilled in) the art of tradeoffs in programming language design, I really enjoy this. I'm probably the least qualified person in the room to have an opinion on this matter, but I'll share my mortal thoughts knowing full well that they'll be effortlessly dismissed like a speck of dander. Imagine that the `&amp;only` proposal from Niko is implemented for handling the more interesting case of deep immutability. If you want to mutate a field of a struct, you need a unique reference to it. Since `only` is a property of the reference, you can modify the fields of a struct passed to a function as an argument. Fine. Now imagine that something like `mut` is reintroduced, but given a more shallow interpretation. In particular, `mut` would not be a property of the reference, but a property of a let binding. Since it's a property of a let binding, it's not even relevant to think about it being applied to function arguments. The names of function arguments can never be rebound. The caveat here is that I wouldn't want to reintroduce the keyword `mut` itself, since that would be confusing. But something like Scala's dual let keywords `val` and `var` would work perfectly, because it would be obvious that they were shallow, speaking only of whether or not the binding can change. In short, separate the notions of immutability and rebinding: `&amp;only` handles the former, the let keywords handle the latter. 
&gt; Thus when I say I want to keep mut, you can trust me on this ;) He said it's an appeal to experience. Are you experienced in judging whether 'mut is complicated' as it impacts users and tools? Personally I find the proposed simplification would make the language easier to learn. Speaking as someone who played with Rust a while ago and gave up, partly confused by compiler warnings.
`&amp;mut only self` would only be used rarely if I understand it right, only for types such as Cell. `&amp;only self` would be used for methods that mutate self. 
&gt;&gt;did you have something specific in mind ? yes: there are use cases I've personally encountered:- [1] DCBZ optimisation on powerPC, and similar elsewhere ( we needed this on game consoles, and there are still DSP processors that have DMA going on with precise control over local-store memory; sony CELL was like this, you had to manually read data so you really need to know if its read/write/read+write. CELL is on the way out, it was too hard to program, because languages lacked conceptual support .... aren't we trying to fix that here :) .. a low level language with improved semantics for concurrency ) [2] producing command lists or dynamic vertex data for GPUs in shared memory. The memory is allocated as "uncached", so reading it is dog slow and must be avoided, but it can be written efficiently sequentially (write-combine..). This is done so data is immediately available to the GPU, and the CPU cache isn't polluted. Graphics API's provide usage hints when you create buffer objects, for precisely this reason (e.g. managing where the data goes, optimised for cpu or gpu access.. dynamic or static etc..). [3] double-buffering , which can be used in many concurrent situations - avoids allocation , producing output values whilst another process is consuming an input. wait for a sync point and flip. So, for example for a game update, you could have object states that are double buffered.. one is being read from by a rendering thread, and read by an update thread; the output is being produced write-only in the 'other' buffer. Conceptually, this update+render is pure-functional, not 'mutative' .. next_state = update(previous_state,inputs). image=render(previous_state) ... Parallelizable. Then when the frame is complete, you flip. Pure functional but thanks to doublebuffering, it doesn't need allocation or GC. [4] It could also be used after an allocation? - you know the actual area returned by an allocation is garbage, you shouldn't be able to read the values ... would 'box' for 'placement-new' take a write-only parameter? 
Ah, so our terminology doesn't match- this proposal would allow "&amp;only" to imply mutability. That'll teach me to read posts carefully. That's probably better, although not as neat as mine (conceptually, I wanted to separate mutability and exclusivity), because it saves typing, and I doubt anyone wants to say "Oh, here, you have the only reference to this but you can't mutate it, that's just absurd." or "Oh, here, this isn't SafelyMutable but I don't mind if you mutate it but then you can't mutate it because it's not &amp;only".
Actually, I don't even see the need for `&amp;mut only T` because I don't see how one could use `&amp;only T` if it meant non-aliased and non-mutable ? From the compiler point of view, non-aliasing can bring some performance benefits; but from the user, it's only a tool for memory safety, and `&amp;T` can be safely aliased. Thus I would argue that `&amp;only T` is always mutable, and thus can be "downgraded" to `&amp;mut T` which itself can be "downgraded" to `&amp;T`.
Actually, I had thought that `&amp;only T` would imply mutability, in a strict hierarchy: `&amp;only T` can become `&amp;mut T` can become `&amp;T`. I don't see any value in having a `&amp;only T` that does not allow mutation for the user: you cannot do more with than with `&amp;T`. Or can you ?
~~See my reply to the other reply to my comment. Yeah, you're probably right.~~ (EDIT: he is not right because of closure-related stuff, but this is now resolved)
&gt; I'm probably the least qualified person in the room to have an opinion on this matter We may be contending for this title :/ &gt; In short, separate the notions of immutability and rebinding: &amp;only handles the former, the let expression handles the latter. I am not exactly sure I understand what you mean by rebinding: - are you talking about re-binding the name to an existing instance of an object ? (Rust allows shadowing as in `fn foo() -&gt; int { let x = 5; let x = 4; x }`) - or are you talking about re-binding a reference to another instance ?
Indeed, even if `&amp;only T` does not bring anything, we could still keep `&amp;mut only T` so that the concepts of mutability and aliasing are cleanly separate. As for `&amp;only T` then ? Well, I guess a simple lint pass could warn about its use and suggest `&amp;T` instead. I don't care either way (at the moment), I haven't grown accustomed to Rust yet so my mind is flexible :)
&gt; so that the concepts of mutability and aliasing are cleanly separate. Yeah, the sort of slogan I have in mind is "Divorce manners from safety"- mutability is manners, almost a sort of lint. Aliasing is safety.
Thanks for the use-cases! I wonder if `volatile` reads/writes could also be considered here. Interestingly, your latest point (uninitialized memory) is perhaps the example that appeals to me the most. I have seen uninitialized reads so often in C and C++... It seems though like it could be built as purely an extension of any proposed system, so for now I will concentrate on this because I am not too good at thinking over several things at the same time; I tend to mix them up :x
This is a comment to clarify my own thinking by writing about it. Perhaps it can be useful or entertaining for others. This issue at its heart seems to be about the conflict between mutability and pointers to the insides of data. Mutating an enum type while having a live pointer to the inside of one of its options leads to problems. The situation with iterators is more or less the same. When you have a live iterator inside some data structure, then mutating the data structure can lead to problems. However, it does not always lead to problems. If you have a pointer r to the value of a Cell, then while mutating the Cell changes the value that dereferencing r will produce, it will not lead to memory unsafety. Similarly, if you have an iterator of an array, it's okay to mutate an element in the array. However, if you have a tree data structure like a comparison based map, then it is not okay to mutate the tree while you have an iterator over the tree. Trees are in the end built on top of enums, so are enums the only source of problems? The answer is no: unique pointers are another source of problems. Suppose you have some piece of data x, and inside x there is some unique pointer to y. If you start at x and traverse the pointer to y to obtain some pointer to y or the inside of y, then you also can't mutate x. If you were to mutate x then that could cause deallocation of y, and then your pointer will point to unallocated memory. Are pointers and enums the only source of problems then? The answer is again no: variable length vectors are another source of problems. Suppose you have some piece of data x, and inside x there is a variable length vector. If you have some pointer to the inside of the variable length vector, you cannot mutate x. If you would mutate x to have some variable length vector that is shorter than the original, then the pointer to the inside of the vector could now point to outside of it. Are pointers and enums and vectors the only source of problems then? The answer is yet again no: closures are another source of problems. Suppose you have some piece of data x, and inside x there is a closure. If you have some pointer to the environment data associated with the closure, you can no longer mutate x. If you would mutate x to have some different closure with a different environment type, then the pointer to inside the closure would now point to data of different type. It appears that enums, pointers, variable length vectors and closures have exactly the same properties with respect to mutation. If you unpack an enum (i.e. pattern match on it), you can no longer mutate the value that contains the enum to a different enum. If you unpack a pointer (i.e. create a pointer to its contents), then you can no longer mutate value that contains the pointer to a different pointer. If you unpack a vector (i.e. create a pointer to one of its elements), then you can no longer mutate the value that contains the vector. If you unpack a closure (i.e. create a pointer to its environment, e.g. by calling it), then you can no longer mutate the value that contains the closure. What do enums, pointers, variable length vectors and closures have in common? They are all dependent pairs! A dependent pair is a pair (a,b) where the type of b depends on the *value* of a. * An enum is a pair (tag,payload) where the type of payload depends on the value of the tag. For the example given by the OP `enum Broken { Integer(int), String(~str) }` the tag is `Integer` or `String`, and the payload is `int` if the tag is `Integer` and `~str` if the tag is `String`. * A variable length vector is a pair (length,payload) where length is an integer and payload is a fixed size vector of size `length`. * A closure is a pair (lambdaID, environment) where lambdaID is some identifier of a lambda expression, and the environment contains the values of the free variables. For example if you have the lambdas `{|x| x+n}` and `{|x| k*x - m}` and the first has lambdaID=234 and the second has lambdaID=235, then environment for lambdaID=234 is just an int n, and the environment for lambdaID=235 is a pair of two ints (k,m). * A unique pointer is conceptually a pair (region, ptr) where region is the lifetime hidden inside the unique pointer, and ptr is the actual (borrowed) pointer. Here region is conceptually a linear type (can't be copied, can't be implicitly destructed). Every time we read ptr we must present `region` as a proof that the pointer is still alive, and when we want to deallocate it the deallocation consumes `region` to make sure that we can never read ptr again. Note that Rust currently does not actually work that way, because these concepts are built-in and in some cases less expressive than what you would be able to if they were represented as dependent pairs, however I think at least it's a productive way to think about it. What exactly makes dependent pairs problematic? If we have some pair (a,b) where the type of b depends on the value of a, then if we have some pointer inside of b, and we mutate the pair, then the type of b may change and the pointer becomes invalid. That is the essence of the problem. Another random thought: the terminology 'pointers', 'unique pointers', 'borrowed pointers', 'references' etc. is very confusing for me. I'll introduce my own terminology to straighten this out in my mind. First, we have a Handle&lt;T&gt;. A Handle is something that manages memory. For instance it may manage a piece of memory located on the heap. A handle can be deallocated. A unique pointer is a handle. An open file is a handle. Etc. Second, we have a Reference&lt;T&gt;. A reference refers to memory. It does not manage memory. A reference may be dereferenced, to obtain a T. Some kinds of references may have methods to obtain new references. For instance, a Reference&lt;Pair&lt;A,B&gt;&gt; may have a method `second` to obtain a reference to the second component (so a Reference&lt;B&gt;). The `second` method does not actually read memory, it just creates a new Reference (which is probably represented by a machine pointer). Iterators are a kind of references. They can be dereferenced to obtain the current value, and they may have `next` and `previous` methods to create new iterators that point to the next respectively previous elements. Another kind of reference could be with arrays of structs. Instead of an array of structs, you can represent that data as a struct of arrays (i.e. column wise storage). A reference to an element inside that array of structs could be dereferenced to obtain one of the structs, which would need to be reassembled by picking each element of the struct from one of the arrays. From a Handle, we may create a Reference which references the memory behind that handle. In Rust terminology e.g. creating a borrowed pointer from a unique pointer. In order to read such a reference, we will have to present it a capability (proof) that the handle is still alive. Third, we have MutableReference&lt;T&gt;. Aside from the ability to dereference it, it also gives us the ability to mutate the memory it references. Similar to read only references, it may have methods to obtain derived references. For instance if we have a mutable reference to a pair, we may obtain a mutable reference to its second component. So, what about dependent pairs. Suppose we have a mutable reference to a dependent pair. It allows us to replace the pair as a whole with a new pair. It also allow us to obtain a derived reference, which points to the second component. But this is *exactly* what causes problems. If we have a reference to the second component, while we have a mutable reference to the pair as a whole, we could mutate the pair which would invalidate the reference to the second component because its type could change. Therefore *while we have a reference to the second component, we need to give up the ability to mutate the pair*. This could be ensured in multiple different ways. One way is like in an ad hoc "borrow checker". Another way is to use capabilities in the type system. One way would be to make MutableReferences have linear lifetimes (so they can't be copied), and in order to obtain a reference to its second component, we need to give up the mutable reference in order to obtain a reference to the second component. Then later when we are done with the reference to the second component, we can give that one up to get back the original mutable reference. That way we can never have the mutable reference and the reference to the second component alive at the same moment in time. That's where the connection between uniqueness and mutability comes in: if want want to have references to the insides of dependent pairs, then mutable references to dependent pairs, or mutable references to *anything that contains a dependent pair* need to not be mutated while that reference is live. The easy way to ensure that something isn't mutated is to ensure that we have a unique reference to the thing, and *we* aren't mutating it. However, that's just an approximation to "isn't being mutated". The connection between uniqueness and mutability is not exact in another way: it's perfectly fine to have non unique mutable references to data that does not contain a dependent pair. The other side of the coin is that it's fine to have non unique mutable references even to data that does contain dependent pairs, as long as we can't obtain any references to the inside of that dependent pair. So given these differences, it is really a good idea to say mutability === uniqueness? I don't know, it may be a practical trade-off, or it may not be. My first thought is that this whole situation is not very nice. When some situation is not very nice it sometimes means that we are approaching it the wrong way, since math has its way of making things work out nice most of the time. Whether or not we can obtain multiple mutable references depends on what's hidden deep inside of data. That's not compositional. Is there some way around this to make everything nice? I don't know. Hopefully this rambling makes some amount of sense.
Yes, it probably should, one way or another. I was wondering about whether it would be best merged with dagenix's proposal or if Niko was going to make a proposal of its own. It might not be too noticeable but actually the Step 1 in this proposal is Niko's proposal minus the `mut` obsolescence so it's very much compatible, and could potentially just be built on top... And if I actually need to write a RFC, I'll need to check what others look like to make it smoother. I've got some time on my hands for the coming days though, so if this looks right and nobody makes a move I should be able to submit one.
I am confused here. Can `Share` data (i.e. data with no `Cell`s) still be mutated through `&amp;only`?
Normally yes: `&amp;only` guarantees that the reference we hold is the only one so mutation is safe. I edited the proposal to make it clearer that `&amp;only` here is exactly the same as in Niko's proposal (or at least, I aimed to have it be the same...).
&gt; I was wondering about whether it would be best merged with dagenix's proposal or if Niko was going to make a proposal of its own. It might not be too noticeable but actually the Step 1 in this proposal is Niko's proposal minus the mut obsolescence so it's very much compatible, and could potentially just be built on top. IMO just take what you've posted here, format it as an RFC and send it in. Don't wait for other RFC's, what you have here is good enough to start a discussion and presents the main points of your idea. 
Actually... don't you need &amp;only T to be immutable?! It's crucial for the closure-related issues as seen in the original SmallBabySteps post.
Okay, so essentially `val` is `let` and `var` is `let mut` right ? This does not solve, I think, the Inherent Mutability issue. Types like `Cell` which you can change even when declared with `val` because they use unsafe code underneath the covers, which is pretty surprising. I was attempting to bring such types back into the fold.
Ah, you are speaking about the `&amp;env` issue right ? (and the necessity to borrow `env` using `&amp;mut` right now to be able to access `env.error` as a mutable reference) Since Niko had completely removed mutability, indeed it escaped my notice that in this precise case `&amp;only T` gave you semantics: a *shallow* immutability, but guaranteed uniqueness, restoring the illusion that `env` exposes a local frame. In this case, indeed, it would seem that the orthogonality of concepts you preached would (at the cost of some verbosity) restore the necessary elements, and you would thus have 4 qualifications for references, using all combinations of `mut` and `only` where: - `only` is guaranteed to be the only reference to that object - `mut` guarantees that the object is mutable and thus the variations: `&amp;T`, `&amp;mut T`, `&amp;only T` and `&amp;mut only T`. And, in the case you have a `&amp;Env` or `&amp;mut Env` you cannot mutate its `&amp;mut T` field, unless `T` is `SafelyMutable`, because others might be holding aliases on this object's internals. I need to review the proposal then, thanks :)
Actually, as /u/XMPPwocky [remarked here](http://www.reddit.com/r/rust/comments/25ma77/an_alternative_take_on_memory_safety/chiu9fk) I had forgotten that we might need the uniqueness and (shallow) immutability for closures, that Niko presented in his blog post. Thus it seems that `mut` and `only` should really be treated as orthogonal concepts and 4 variations of references would exist `&amp;T`, `&amp;mut T`, `&amp;only T` and `&amp;only mut T`. In this case, the latter `&amp;only mut T` would be required to mutate most objects, while `SafelyMutable` objects like `Cell` (or `int`) could be mutated through `&amp;mut` or `&amp;only mut T` indifferently.
You're right. Looking at one of the other comments regarding the Apache Memory Pool reminded me of that.
True. This has been educational for me. Thank you for tossing it around.
I think that keeping these concepts separate makes them easier to explain/grasp anyway. Having a case (`&amp;only`) that implicitly governs both mutability and aliasing seems like a possible stumbling block.
It's been educational for me too, so thank you for taking the time to read and comment.
/r/playrust
I just realized that now haha.
I think this is entirely pointless, and the reasoning based on unboxed closures doesn't make sense. Real unboxed closures capture by-value and can be returned from functions. I don't understand why a huge breaking change would be done to avoid the smaller breaking change of changing closure capture semantics, especially when they'll still be crippled compared to proper closures like C++11 lambdas without any changes.
I'm confused by some parts of this. - Is it legal to go from `&amp;` to `&amp;mut`? - What does an `Rc` borrow to? To `&amp;`, or to `&amp;mut`? - If it's only to `&amp;`, how do you get shared mutability? I don't personally find this simpler than the current scheme... Also, I'm not quite sure how something like the following can work: basically, how do you modify the `Cell`? enum StoresCell { A(Cell&lt;uint&gt;), B } fn foo(x: Rc&lt;StoresCell&gt;, y: Rc&lt;StoresCell&gt;) { let inner: &amp;mut StoresCell = x.borrow_mut(); match *inner { B =&gt; {} A(ref mut cell) =&gt; { *y.borrow_mut() = B; // whoops, `cell` is dangling. cell.set(2); } } fn kaboom() { let rc = Rc::new(A(Cell::new(0))); foo(rc.clone(), rc); } (i.e. I need to take a `&amp;mut` to the internals of some other data structure to be able to modify the Cell, but allowing this would allow for creating a dangling reference. Presumably this needs the appropriate number of `#[deriving(SafelyMutable)]`, but I don't see how it can work with them anyway.) Lastly, you make no mention of `RefCell`, which explicitly gives a reference to its interior.
Select is only for channels/ports, so it's still not great.
&gt; The point is that a useful system does not cease being useful just because it has some holes. Learn where the holes are and how the system works, and take what it gives you. I would agree with this statement if Rust 1.0 had been released. I don't see any reason to settle pre-Rust 1.0, though.
If the in-tree versions were explicitly marked as being under the same revised BSD license used by the benchmarks game, would that be enough to publish the source?
The `f32` and `f64` types work exactly the same way as floating point in C or C++. I'm not sure what you're getting it. The partial ordering is the one used by C and C++ implementations. &gt; The issue is rust assumes every operation must handle all potential inputs safely, whereas in practice high performance code relies on assumptions flowing through from data generated or validated some specific way to avoid divide by zero, overflows etc. Similarly array indexing.. Rust does also provide `unsafe` versions without overhead whenever it's important. Bounds checking on indexing is already entirely optional in Rust. Division is so slow that eliminating the specific check there hasn't received much attention, but it would be *trivial* enough to expose it as an intrinsic and it would be accepted.
Not that I've noticed.
The compiler is already aware of which types have internal mutability. It's already marked in `Cell`, `RefCell`, `Rc`, etc. The current `mut` keyword means *inherited mutability* and it's enough 95% of the time. The need for another form of mutability is *not* a hack and does *not* indicate a problem with inherited mutability. Rust is a language accepting that it makes sense to use the best tool for the job. It doesn't try to force everything under one roof when it doesn't make sense.
I don't understand how making the type system significantly more complicated from both a user and compiler point of view *without getting anything back* makes it easier to grasp. The `mut` keyword simply means inherited mutability right now, and there are no holes in the system. There's also no need to change *anything* to have a solid unboxed closure implementation. A sane implementation of unboxed closures is simply sugar over structs and trait objects without any new concepts. It would eliminate all of the soundness bugs we keep finding in closures by reusing the existing language's safety.
The current `mut` keyword is already a property of the local variable. It simply allows assignment to the local variable. Since most types make use of inherited mutability, they inherit the mutability (or immutability) from the owner. This is already a simple, solid system without holes. The proposals to change it have failed to demonstrate any benefit for the extra complexity being added to the type system or compiler. The unboxed closure claims are simply not true, because real unboxed closures do not need any changes to the current type system. A version that's incredibly crippled compared to the lambdas in C++11 might need changes, but I can't see why Rust would accept an inferior implementation.
The compiler knows that those types mutate things internally? How does it know this?
What benefits does all of this extra complexity provide over the current system based on inherited mutability? It's going to be significantly harder to implement soundly, and significantly harder to grasp for new users. Everyone making these proposals is failing to understand that people only use `&amp;mut` to *provide inherited mutability*. The restrictions needed to make it safe are no different than the restrictions placed on local variables when they are borrowed from. The borrow checker is a means to an end, and yet the restrictions it places are being treated as the end goal. These restrictions can and will be relaxed in the future as the borrow checker is improved, so encoding a *subset* of the restrictions we have today into the type system is a mistake.
The current system is fine too, and doesn't need to be changed to support unboxed closures. It could be augmented to lints, but I see no advantage to adding extra complexity to the type system as these proposals want to do.
If nobody understands inherited mutability, maybe it is hard to understand?
The proposal to add `&amp;uniq` offers nothing but extra complexity. It's not useful to add another reference type... it's not at all required by a sane unboxed closure implementation.
No one has proposed removing inherited mutability. It's still part of the type system used by these proposals. They propose adding needless complexity to the type system via new reference types without any use case. There is no need to change the type system for non-crippled unboxed closures with the same expressiveness as C++11 lambdas, so there's no use case being presented.
The `min` and `max` methods are already provided via `Float` and perform the operations as documented by IEEE754 via `fmin` / `fmax`. The generic implementation would not return a correct or consistent result. LLVM may even add intrinsics for these to implement the IEEE754 semantics in hardware. A version of floating point numbers implementing the IEEE754 total ordering would have significantly slower comparisons since it's not implemented in hardware. I don't think you really want what you're asking for. You really want the efficient partial ordering operations to be exposed (`clamp` and `fcmp`). 
&gt; I think this is entirely pointless, at least I hope they could keep '&amp;/&amp;mut' being as it is now and introduce a new 'shared_mut' type or whatever (i'm sure some complimentary name is possible) to handle the range of cases better. then its just adding some refinement instead of breaking existing code and peoples knowledge 
the subreddit you're looking for is /r/playrustservers
I don't think we need anything new. An unboxed closure implementation can fit in well with what we have today, and by implementing it as pure sugar over the existing semantics we will eliminate any closure soundness issues. Here's an example: let x = 5; |a, b| a + b + x This would essentially expand to the following: struct UniqueClosure_$uniqueid { x: int } impl |int, int| -&gt; int for UniqueClosure_$uniqueid { fn call(&amp;mut self, a: int, b: int) -&gt; int { a + b + self.x } } impl ~|int, int| -&gt; int for UniqueClosure_$uniqueid { fn call_once(~self, a: int, b: int) -&gt; int { a + b + self.x } } If you wanted to capture by-reference, you could capture it as a value. If we wanted sugar, we could reuse `ref`: let x = 5; |a, b| a + b + *(ref x) This would be sugar for the following: let x = 5; { let x = &amp;x; |a, b| a + b + *x } If you capture the same variable more than once, it would just add a new field for each method of capture. A capture of a mutable reference forcing the variable to be mutable would be perfectly sensible. The intent of the `mut` feature is to make code more readable, and it would succeed - the reader would know to watch for mutation of the variable, and they'd see the explicit capture by-mutable-reference. The current closures have proved themselves to be a huge liability in terms of soundness, because they're a whole separate set of rules for enforcement of safety. That's why adding a new type like `&amp;uniq` to a now proven system is a bad idea. It *will* have unforeseen consequences, and I don't see it as adding anything beneficial.
&gt;&gt; Double extended, also called "extended precision" format. This is a binary format that occupies at least 79 bits (80 if the hidden/implicit bit rule is not used) and its significand has a precision of at least 64 bits (about 19 decimal digits). A format satisfying the minimal requirements (64-bit precision, 15-bit exponent, thus fitting on 80 bits) is provided by the x86 architecture. In general on such processors, this format can be used with "long double" in the C language family (the C99 and C11 standards "IEC 60559 floating-point arithmetic extension- Annex F" recommend the 80-bit extended format to be provided as "long double" when available). On other processors, "long double" may be a synonym for "double" if any form of extended precision is not available, or may stand for a larger format, such as quadruple precision. Here is the entry from Wikipedia, which I think is what D was trying to expose as part of the language. I had thought that in theory there wouldn't be a big speed hit since that was what the processor was doing anyway, although in my trivial test there was a huge speed hit (on an intel cpu of course). In any event it isn't what Rust was trying so the whole thing is moot.
Oh, that sort of extended precision float? Yes, the 80 bit stuff is from the historical x87 "coprocessor". Modern CPUs have the SSE instructions, which are essentially uniformly faster (and doubly so, because they are SIMD, and x87 is not).
I am thoroughly confused. How is this better than either what we have today or Niko's proposal? Perhaps I don't understand what you're actually proposing, but this is what I've taken away: * You want to expand our two reference types to 4 reference types. Despite the fact that we've been trying to actually shrink the number of pointer types we have, and despite the fact that, if we're going to add new reference types, then the simplest way to fix our type system is to just make `&amp;uniq` a legal type to use instead of something that only closures can create. * `&amp;mut` still exists, and still denotes mutability, but can only ever be used on some types? I can have a fully-mutable value but cannot take a `&amp;mut` reference to it? Except I can if the value is some particular type? That's extremely confusing. Among other things, one of the goals of DST was to unify all reference handling so `&amp;T` and `&amp;mut T` acted the same regardless of what `T` is (whereas today, it acts differently if `T` is `[U]`, `str`, or a trait). This proposal serves to change how it works so we have a special reference type with special behavior that is only valid for some subset of types. That seems like a huge step backwards. * `SafelyMutable` seems like a real mess. It has to be derived explicitly, and it has a rule that the compiler cannot enforce, but the rule itself also seems wrong. Specifically, it says the type cannot leak its internals. So if I have a `pub struct foo { x: Cell&lt;T&gt; }` I'm allowed to `#[derive(SafelyMutable)]` as the `Cell` is hidden, but if I have `pub struct foo { pub x: Cell&lt;T&gt; }` then I *can't* be `SafelyMutable`, as the internals (i.e. the `Cell`) are now public? Besides being confusing, there's also no way at all to enforce this, so I'd just go ahead and mark it as `SafelyMutable` anyway. * The next paragraph suggests that my non-`SafelyMutable` type can take a `&amp;mut self` method anyway, and mutate the `SafelyMutable` sub-component. Except I can't take `&amp;mut` reference to my type because it's not `SafelyMutable`. So this is a contradiction. * If my type takes `&amp;self` (because it's not `SafelyMutable`), how do I mutate any `SafelyMutable` sub-components? Am I allowed to take a `&amp;mut` reference to them, despite accessing the field through `&amp;self`? This isn't stated. * What makes `SafelyMutable` safe? I could declare my type is `SafelyMutable` even if it has no possible valid reason to be, without requiring `unsafe`. You stated that I can mutate `T` through `&amp;mut T`, which suggests I can then go ahead and do horribly unsafe mutations of `self` via `&amp;mut self`, without anything stopping me. Again, no `unsafe` required to do any of this. * Your example of how to define `Cell` doesn't mention `SafelyMutable`. Is that somehow deduced from the use of the `&amp;mut self`, or did you just forget to derive it? And again, what actually makes this *safe*? There's no `unsafe` required to enable this mutation of an aliased value. * If I can construct a `&amp;mut` reference to a `SafelyMutable` field of my type, from within a method that takes `&amp;self`, then your claim about mutability being explicit is completely false. If I *cannot* construct a `&amp;mut` reference to a `SafelyMutable` field of my type from within a method that takes `&amp;self`, then it becomes impossible to use mutability as an implementation detail that is not exposed via the public API of your type. Which is to say, if the former is true, then your proposal has solved nothing, and if the latter is true, then your proposal outlaws an entire class of entirely valid, entirely safe constructs. In the end, it seems your proposal only serves to horribly complicate the current situation without actually fixing anything, and depending on the answers to the above questions, it may also outlaw otherwise-legal, *safe*, correct programs.
The OP is proposing adding vector types vec2f, vec3f, vec4f... This is the wrong solution to the wrong problem. In 5 years you will need vec8f, and in 10 years vec16. You can add types ad infinitum, and never solve the real problem. The real problem is that you want your algorithms to make use of the SIMD vector units and after 20 years it starts to be clear that perfect autovectorizing compilers will never exist. So what you need is a "constrained" EDSL that you can use to express your algorithms such that they can easily make full use of all the available SIMD vector units (independently of their size/operations supported). Adding these types to the language doesn't achieve this, so why bother? My point above is that neither you nor your algorithms care how big your vector registers are. You have to deal with the remainders. The problem is that you might never know which architecture you are targeting till run-time, so why constrain yourself at compile-time with vec4 if vec8 is better? What happens if your architecture supports only vec2? The best thing is to just abstract this away. If the compiler knows the exact architecture, it can remove the unused code. Otherwise, it can generate code for all architectures it knows, and select the best function at run-time. It's a code-size tradeoff, but it is better than using suboptimal code, and if you specify a vector length, sooner or later your algorithm will be suboptimal unless you rewrite it for every new architecture... forever...
&gt; and there are no holes in the system I tend to agree with nmatsakis' post. Having `mut` representing aliasing information rather than mutability itself is occasionally misleading and is in general a leaky abstraction. Having aliasing information communicated separately from mutability seems like a win in general. &gt; without getting anything back This proposal seems to offer the semantic cleanup that nmatsakis is advocating while also preserving the immutability-by-default that the broader Rust community values so much. I'm just a casual user; I don't have your depth of understanding regarding the type system. From where I'm sitting though, these seem like positives. Knowing that I'm by no means an expert in this field, could you elaborate on your concerns?
&gt; Having aliasing information communicated separately from mutability seems like a win in general. Note that Niko's post isn't actually communicating mutability separately. It's just communicating non-aliasability, which happens to imply mutability. i.e. it's just renaming `mut` to `uniq` and removing `let mut`, not something fundamentally semantic.
Right, thanks. I was referring to what matthieum seems to be proposing, which would have `mut` be a separate concept from `only`. In the SmallBabySteps post comments, people responded negatively to losing the ability to state that they didn't intend to modify a given variable. It seemed like this would address it nicely, allowing `only` (or `uniq`) to represent aliasing while preserving `mut` to communicate intent. Or have I misunderstood?
&gt; I tend to agree with nmatsakis' post. Having `mut` representing aliasing information rather than mutability itself is occasionally misleading and is in general a leaky abstraction. Having aliasing information communicated separately from mutability seems like a win in general. I think that's an inaccurate portrayal of the current type system. The `mut` marker means inherited mutability and nothing else. The only reason someone would use `&amp;mut T` is because they want inherited mutability. The restrictions placed on `&amp;T` and `&amp;mut T` are there as a means to an end rather than the end goal. The user wants inherited mutability, not uniqueness. That's just the current method used to enforce safety. I think the borrow checker will continue to involve, and the restrictions we have today will be relaxed. It would be wrong to assume that the current restrictions are the end goal. &gt; This proposal seems to offer the semantic cleanup that nmatsakis is advocating while also preserving the immutability-by-default that the broader Rust community values so much. That's not true. It adds a whole bunch of complexity to the type system while failing to fix a single issue. Or can you point out something it fixes about the type system? The compiler is *fully aware* of internal mutability and can already put it in the documentation or refuse to allow it, it's incorrect to say otherwise. &gt; I'm just a casual user; I don't have your depth of understanding regarding the type system. From where I'm sitting though, these seem like positives. Knowing that I'm by no means an expert in this field, could you elaborate on your concerns? A claim that's it's an improvement over the current system has not been backed up with evidence. All I see here is an introduction of both compiler and user-facing complexity via new types, and vague assertions that it's clearer or easier to learn. The `&amp;uniq` type is a solution looking for a problem to solve. It's a proposal to make an enormous breaking change to the fundamental properties of the language, and it introduces a lot of complexity compared to the simple inherited mutability system. A language trying to reach 1.0 by the end of the year is not a language making massive *semantic* changes like this. It took a long time to come close to the current type system being sound, and a massive change is certainly going to push back the 1.0 release.
This is basically C++11 closures for Rust. That's good, since they work well in C++. I'm honestly surprised they don't work this way already. I like this proposal, but I don't think we should drop the focus on simplifying how mutability operates in Rust; the current rules on inherited mutability and how `&amp;mut` _actually_ works are confusing and surprising. If we can implement some ideas from the [other proposal on mutability](http://www.reddit.com/r/rust/comments/25ma77/an_alternative_take_on_memory_safety/), IMO we'd make the language easier to grasp.
&gt; I don't believe that the current type system is somehow unsound, only that `mut` doesn't actually represent mutability, as I understood nmatsakis to say. The possibility of swapping `mut` for `&amp;only` caused a lot of people (myself included) to express that they love immutable-by-default. I liked the idea of having `mut` available as a separate keyword for users to convey intent. It represents inherited mutability, nothing less and nothing more. There are no exceptions. There's no reason to have `&amp;only` with different semantics than `&amp;mut` has today, and it doesn't make sense to rename it. It's used when inherited mutability is desired, *not* when lack of aliasing is desired. It works exactly the same way as `mut` on local variables. The lack of aliasing is a consequence of the various borrow checking rules and isn't actually true with today's borrow checker. It's not what people want, but rather what they have to give up in order to get what they want (inherited mutability). &gt; Are you referring here to nmatsakis' original proposal or the approach matthieum described in this thread? It applies to both of them, but more so to this one than the original proposal.
See [my response to that proposal](http://www.reddit.com/r/rust/comments/25ma77/an_alternative_take_on_memory_safety/chj3p57). Basically, it's a horribly confusing, broken mess, that actually makes the situation much *more* complicated instead of making it simpler. The way mutability operates in Rust right now is actually rather simple. It's just not documented properly and there's a fair amount of misinformation. The solution isn't to make it even more complicated and confusing, the solution is to fix the documentation so people actually understand how it really works.
Nobody on the core team disputes that unboxed closures are a good thing. Neither you nor strcat needs to convince anybody of this. The problem is that this is pretty much totally orthogonal. Sometimes you need (mutable) by-reference captures of upvars. Then all the problems Niko was referring to come back into play. Having sugar for by-mutable-reference capture of upvars in closures doesn't change the fact that either you will have to put `mut` in weird places (which may not be so bad, but again, that's an orthogonal issue) or we will need to have `&amp;uniq`. No, I don't know how commonly you need by-ref captures of upvars. I was telling Alex today that I would like to instrument the compiler to gather some statistics about upvars used in practice (how often are they mutated/how often are they implicitly copyable/how often are they used after being moved into the closure/etc) so we can make more informed decisions here. In short: Yes. Let's do what you suggest. But it doesn't fix the issue.
(that's probably a silly question, but the answer is not at all obvious to me). If I change the closure on your example to a `proc()`, it compiles (and executes) successfully: fn adder(x: int) -&gt; proc(int) -&gt; int { proc(y) { x + y } } fn main() { println!("{}", adder(3)(5)); } If your proposal is accepted, what would be the difference between a closure and a proc?
&gt; Basically, it's a horribly confusing, broken mess, that actually makes the situation much more complicated instead of making it simpler. Please try to keep your language polite and constructive. Your subjective opinion (whether it is right or wrong) on someone else's hard work would be better expressed with some humility and manners.
`proc` is heap-allocated and execute-once. Try calling let x = adder(3); println!("{}", x(5)); println!("{}", x(7)); This should work, and it will work with the proposed by-value closures, but it doesn't work with `proc`.
There's a quote from Don Norman, author of _The Design of Everyday Things_ that goes: "If you have to write a manual, you've already failed [at good design]." That's a bit too strong, but the point is that if you're relying on your docs to explain things, your design can probably be improved. We shouldn't require that the user reads the docs to form a correct mental model of how mutability works. Does it have `mut`? No? Then it's not mutable. It has it? Then it is mutable. You don't need docs to explain that; that's how it should work. `&amp;mut` and "inherited mutability" are unintuitive, surprising and confusing as hell.
&gt; Sometimes you need (mutable) by-reference captures of upvars. Then all the problems Niko was referring to come back into play. That's not true. You capture a `&amp;mut` reference by-value. The variable containing the `&amp;mut` reference does not need to be marked `mut` (because its contained `&amp;mut` value is moved into the closure, rather than referenced). We need `&amp;uniq` today in order to capture this variable by-reference without requiring the variable itself to be mutable, but the proposal completely eliminates that scenario. &gt; Yes. Let's do what you suggest. But it doesn't fix the issue. Let's stop discussing changes to mutability for the time being, and implement the closure changes. We can then see what happens. Once we have proper by-value closures (with by-value environments, so the closure isn't necessarily tied to the stack), then we have the proper information to decide if there's still a mutability problem. At that point we can resume the discussion if people still think it's worth having.
I see, that makes sense! &gt; proc is heap-allocated So, in this example, the `x` (in the `adder` function) is copied to the heap?
&gt; That's not true. You capture a &amp;mut reference by-value. The variable containing the &amp;mut reference does not need to be marked mut (because its contained &amp;mut value is moved into the closure, rather than referenced). We need &amp;uniq today in order to capture this variable by-reference without requiring the variable itself to be mutable, but the proposal completely eliminates that scenario. Oh, well, that's true. I believe this would break some code, although I'm having a hard time thinking off the top of my head the specific scenarios that would break. &gt; Let's stop discussing changes to mutability for the time being, and implement the closure changes. We can then see what happens. Sure, but I'd say let's gather some data first. I'm curious what the makeup of closure upvars are in practice.
&gt; if you're relying on your docs to explain things, your design can probably be improved. I don't believe that applies in the slightest to programming languages. I can see how that can apply to "everyday things", i.e. physical objects you can investigate. I can see how it can apply to user interfaces in GUI software. But it can't apply to programming languages. The documentation is the only tool that someone has to learn the semantics of the language. It defines the language, defines the syntax, defines the semantics, etc. Merely reading code written in that language is not sufficient to actually learn anything but the simplest of concepts (and that assumes there even exists sufficient code to read). &gt; We shouldn't require that the user reads the docs to form a correct mental model of how mutability works. How is the user supposed to know about mutability without reading the docs? Heck, since every proposal seems to include some form of trying to encode aliasability in the language, how is the user supposed to understand that without reading the docs either? Renaming `&amp;mut` to `&amp;only` does not tell the user what the heck that actually *does*. &gt; You don't need docs to explain that; that's how it should work. Why is that how it should work? The token `mut` is not some kind of intuitive thing that all programmers expect in their languages. In fact, most programmers haven't even experienced an immutable-by-default language before, so their intuitive idea about mutability is that everything is mutable. Rust imposes constraints in the name of memory safety. We can't possibly expect the user to understand these constraints without documentation.
Are unboxed closures a 1.0 feature? It seems hard to imagine introducing them without massive breakage.
You seem to be going out of your way to misunderstand my point. :) I never said programming languages shouldn't require any documentation. On the continuum of "intuitive, simple and easy to understand" to "confusing and requires frequent documentation lookups" you'd rather Rust be on the confusing end? Programming languages should be as intuitive and easy to understand as possible. Of course they're going to need docs, but the less of it is necessary for a working mental model the better.
Why is it not ok to tell someone that their proposal is broken? How would you prefer me to have worded it? And going into great detail about what I consider to be confusing and/or broken certainly seems like it meets the definition of "constructive". I will not sit by silently and watch as people put forth proposals that I feel will cripple Rust. This is far too important to stay silent. I use forceful language because this is too important not to. But I am not breaking the code of conduct. I am not being mean or rude, insulting, demeaning or harassing anyone, trolling, baiting, or otherwise acting inappropriately, and my critique is concrete and specific. I can't see any way to interpret your statement except as an attempt to silence criticism. But criticism is not something that should be silenced. It is important, doubly-so when discussing such a fundamental change to the language.
If not, we are not going to prevent introducing them backwards compatibly.
&gt; I believe this would break some code The proposal will naturally cause existing code to break. I take it you're saying you believe there will be existing code that cannot be easily rewritten to work with the new closures? My expectation is any existing code can be made to work with this system. Existing `&amp;mut` references that are captured in closures should able to be re-borrowed into new bindings that are then captured by the closure. This should have the same effect that the current `&amp;uniq` capturing does.
In the `proc` example, yes. All captured values in the `proc` are copied to the heap. The proc is effectively a `~T` object, and calling the proc is effectively calling a method that takes `~self`. Which is to say, it's heap-owned, unique, and calling the proc consumes it (so it can only be called once).
I believe that would indeed remove the need for `&amp;uniq`, but it introduces a different inconsistency into the language. I'd rather make no changes at all and have borrowck still use `&amp;uniq` internally than make some locals implicitly mutable. Besides, I think we need to make this change to closures regardless of what happens to mutability. It's important in order to make closures more generally usable. As it stands today, C++11 lambads are vastly more powerful than Rust closures, and there's no reason why that should be so.
&gt; On the continuum of "intuitive, simple and easy to understand" to "confusing and requires frequent documentation lookups" you'd rather Rust be on the confusing end? No. I don't think the way Rust handles mutability and aliasing require frequent documentation lookups. I think it just requires us to teach the concepts properly to begin with, which is something we're not doing well today. &gt; Programming languages should be as intuitive and easy to understand as possible. I agree. But the definition of "intuitive" in this context largely means "familiar to the programmer", because programming languages themselves aren't actually particularly intuitive to someone who's never programmed before. We all had to learn how to program at some point, and as a result, when it comes to languages, "intuitive" generally means "not surprising given my previous experience with languages". Rust is introducing a new concept here, which is tying aliasing and mutability together. It's something nobody will have experience with before, and it requires documentation. We're just not doing a good job of it, to the extent that new Rust programmers don't understand that mutability and aliasing are even connected (or even know the word "aliasing"). They basically only know that they can't have a `&amp;` and a `&amp;mut` pointing to the same thing at the same time, and they have to take it on faith that this is a reasonable restriction. In fact, my recollection is that this is generally explained as making it so code can assume that their `&amp;`-referenced value doesn't change while they're working with it, and that they don't even know that this is actually about memory safety. Similarly, interior mutability is not explained well (or really, at all). For example, the tutorial right now only makes a very brief reference to what it calls "dynamic mutability" (and for that matter, it still talks about `Freeze`, which no longer even exists). And I'm not sure if the manual even talks about this idea at all. This means that when programmers actually encounter `Cell` they're confused, as it violates the mental model they built about how mutability works in Rust. Which is to say, our current documentation builds the wrong mental model about mutability, and we need documentation that builds the right mental model. Once programmers learn the foundational concepts about how mutability works, everything else will end up being intuitive.
It is OK to do that as long as you do it politely and respectfully. For example, "I don't like that proposal, I think it makes the situation more complicated instead of making it simpler". Even better would be to say _why_ you think it makes things more complicated. Saying something is wrong or broken is not constructive. Saying why something is wrong and how it could be improved is constructive. I think that you are indeed breaking the code of conduct. Your language is not friendly and welcoming and could be construed as mean and rude. Please remember it is difficult to convey subtleties of expression on the internet and to err on the side of being nice rather than confrontational - it will make everyone happier. Your criticism is valuable. It is more likely to be considered if it is worded politely - you are more likely to persuade people that way. If you are rude, people will take it as ranting and ignore it.
I was actually thinking of combining this with Niko's solution #3, that is, not allow to do anything with non-mut locals that can't be done with non-mut references. In that case, having non-mut &amp;mut wouldn't make sense, so automatically making it mut may be more natural. I'd also argue that having another reference type is much more complicated than a shallow transformation of the source code (x: &amp;mut -&gt; mut x: &amp;mut), which seems like syntactic sugar to me.
Thank you, that clarifies it! And sorta explains why `proc`s are usually only seen on the context of tasks - heap allocation is expensive.
You could drop the emotive descriptions or replace them with the technical terms. No particular need to say "horribly"; say "unsafe" instead of "broken", assuming that's what you mean by broken. This will stop people feeling so attacked and generally result in a better discussion: it helps avoid people getting overly defensive. That said, I agree that that proposal seems to make things more confusing, and [there are certainly some unanswered safety questions](http://www.reddit.com/r/rust/comments/25ma77/an_alternative_take_on_memory_safety/chizg6p).
I think so, even GHC can't remove them always. General explanation/recommendation links: - http://stackoverflow.com/a/5889784 - http://stackoverflow.com/a/2650051 - http://www.haskell.org/haskellwiki/Performance/Data_types#Newtypes - http://www.haskell.org/haskellwiki/Newtype That said, there are [some instances](http://stackoverflow.com/q/12866291) where newtypes end up being slower.
Isn't the main motivation for &amp;uniq is that &amp;T is a lie and not really immutable?
Rust has novel ideas like linear types and lifetimes. We already need good documentation to explain how mutability interacts with these ideas. That is, in current Rust and in future Rust, mutability will never be intuitive in the way you describe.
The TLDR version - in my oppinion, closure improvements and mutability issues are seperate. Improving closures may fix the maine issue that Niko mentioned, but he also said: &gt; Moreover, we have to bend over backwards to maintain the fiction that mut means mutable and not unique So, if closures are improved, maybe Rust no longer needs to bend over backwards, but that doesn't mean that the current semantics aren't still a fiction.
The problem, in my mind, is that if you see a variable thats marked as `mut`, I don't think any ammount of documentation will ever prevent the next thought being - "I guess if I don't see `mut`, then it must be immutable". But, thats not the case, since it could contain a `Cell` and be mutable.
FWIW, I opened [#14241](https://github.com/mozilla/rust/pull/14241) which adds a lint that can warn about passing internally-mutable types into function calls (i.e. when you can possible have something modify itself). This allows a programmer to explicitly see all the places where possibly-surprising mutation occurs.
Interesting. I will comment on the issue.
&gt; say "unsafe" instead of "broken", assuming that's what you mean by broken No I mean broken. Did you read the comment I linked to? Aside from not solving the problems it claims to solve, it also directly contradicts itself in at least one aspect. I understand what you're saying regarding putting people on the defensive. I'm not interested in trying to debate the proposal with the author, though. I don't think it can be salvaged; I think the goal of the proposal is fundamentally flawed. My aim was to both document the various problems I had with it, and to try to express my feelings about the subject (hence the emotive language). That said, I do understand what you're saying. Part of the issue here is that I feel like I'm on the defensive; I feel like the language that I love is in danger of being crippled and I'm afraid of that happening. That's why I'm speaking out so loudly.
That's the goal, but people are still people, i.e. it's very hard to actually achieve complete egolessness. As such, discourse will be more productive if things are worded as non-aggressively as is reasonable. (Of course, people can argue about what is reasonable and what is not until kingdom come.)
What would be a use case for `&amp;only` (without `mut` )? AFAICS `&amp;` and `&amp;only` both ensure that the field is locked and that it cannot be mutated (even safely). Why would a programmer want to ensure that the reference is also unique. That is not fully clear to me. EDIT: Is the point that `&amp;only` can create speedups by avoiding unaliasing?.
I find these most useful when I have been away from a language for awhile and want a quick refresher on the language syntax. 
er, the pull request.
I am saying that even as part of wider, more constructive feedback, "horribly confusing, broken mess" and so forth is not acceptable.
"should', yes. But in real life, you are dealing with other real human beings with feelings and egos. Kindness costs nothing, it is quite possible to be critical and kind and there is no reason not to be. Having empathy and showing kindness is also part of being a good engineer.
A variable or reference without `mut` *is* immutable and a new value can not be assigned. This is how immutability works in languages like Scala without ownership. A type usually inherits the mutability or immutability and the compiler has knowledge about 100% of the cases where types have internal mutability, but doesn't yet expose it in a useful way.
I consider it accurate. I also fail to see the difference between me describing my subjective opinion that the proposal is a "horribly confusing, broken mess", and you describing your subjective opinion that my commentary is not acceptable. Both are judgements that reflect the opinion of the speaker, but are focused on the content and not the author. Except I actually backed up my opinion with a long list of concrete critiques, whereas you just have your personal opinion. In any case, I don't think this is productive to keep arguing. If you were to say that my commentary is likely to put the author of the proposal on the defensive, that's fine and probably true. But that's not what you're doing. Instead you're just trying to cast judgement on my words while ignoring my argument, and that's not something we can really debate.
The word immutable means "deeply immutable" to me, so the idea of immutable Cells was somewhat confusing at first. This could be fixed by distinguishing between `immutable` and `mut` and `shallow` let shallow x = Cell::new(2) That could add a heavy syntax toll to the language, but perhaps some of the trouble could be avoided by combining with Nicos alternative 1 let shallow x = Cell::new(0); // Shallow immutability is explicit let px = &amp;x; // You don't have to write &amp;shallow px.set(2); let mut y = 0; // Mutability is explicit let py = &amp;uniq y; // You don't have to write &amp;uniq mut *py = 2; This approach would be easy to explain, but still, I don't know if it is really worth it. EDIT: Many fixes 
&gt; current semantics aren't still a fiction. The current semantics aren't a fiction, and pretending they are is misleading rhetoric. You can keep repeating this but it's you who's lying, not the compiler. The variable without `mut` is always immutable and can not be assigned to. The same applies to `&amp;T`, as it's never possible to do `*x = 5` with an *immutable* reference. That's all an immutable variable does in plenty of other languages like Scala. The type contained in the variable will inherit mutability since mutability is inherited from the owner. There *are* types with internal mutability but the compiler is fully aware of them as each one has to be marked by containing `Unsafe&lt;T&gt;`. It's not a hole in the system, just something you don't seem to like.
I am asking you to moderate your language not to change your opinion. I don't mind the content of your comments, just the delivery. I don't want to argue about the content of your argument because I broadly agree with you. I think you are correct that the proposal you referred to does not add much to this debate. I would prefer it if you could voice that in a more friendly manner.
I'm totally for your proposal - I think it's great! I just think that there's value in a way to remove a current complexity even before unboxed closures are implemented. I think that my suggestion is worthwhile even if it just makes `let mut` and `mut` more consistent.
I don't think it's actually weird. There's no problem with forbidding moving a non-mut value -- if you need to move it, just declare it `mut`. Also, I think that there's nothing weird with running destructors on non-mut locals. Running a destructor is not really a mutation, or doing something with an object -- it's just what you need to do to get rid of the object. Of course, if you got it by reference it's not your responsibility to do so and if it's local it is your responsibility, but I see nothing weird about it.
Why don't use the same idea of the C++11 lambdas, having a capture list where you can specify how you want to actually capture the variables? (maybe with copy by default)
That's the sugar I referenced near the end. Such sugar wouldn't actually create a by-reference capture like we have today, instead it would act like you did the borrow outside the closure and then captured that borrow by-value.
The major benefit I see is consistency: you can do exactly the same things with non-mut `&amp;` and with non-mut `let`. (As I said, I don't consider destructing an object "doing something with it". In a garbage-collected language it would have been the job of the GC, not of the function) I don't think that the break is that severe - I don't know how many places it will break, but the fix is to just add `mut`. (I'll be happy to do that replacement in the PR, if it would help). Regarding compiler complexity - I don't know, because I'm not familiar with the compiler, but I'm not certain that it would be more complex. Actually, it might even make it simpler: in Niko's first example, the compiler has to figure out that it's ok to mutate errors because it's actually local and so has no aliases. In alternative #3, it can just say that it can't be mutated because it's behind a non-mut reference. But again, I'm complete stranger to the compiler. The logic just seems to me, as a human, more simple.
I don't think it makes it simpler. It adds more complexity to the simple existing rules via a special case. It's sensible that having an `&amp;mut` view does not imply the ability to assign a view of something else to the variable unless it's a mutable variable. The current rules are that `mut` means you can assign to the variable or reference. There is inherited mutability, so a value *owned* by a variable inherits the mutability. The concept of observable (`&amp;mut`) and internal (`Cell`) mutability is not covered by the system, and adding a special case like that will not fit in with the existing rules.
&gt; but it's you who's lying, not the compiler. Lets not let this stuff get personal. /r/rust is generally speaking a place welcoming of different people and different opinions, lets keep it that way. 
I'm not the one repeating the words lie and fiction over and over because I don't agree with something. It becomes personal when you say the other side is supporting a "lie" or "fiction" as if it's not a subjective issue.
I dont care even remotely. Stay civil; that's the right thing for *everyone* to do. 
Ah, so it's okay when it's in favour of your point of view or when [you do it](http://www.reddit.com/r/rust/comments/23gfp3/the_birth_death_of_javascript_a_history_from_1995/cgx079k?context=3) but everyone else needs to carefully watch their wording and avoid sarcasm. I'll keep that in mind.
I agree that automatically adding `mut` for `&amp;mut` is adding another rule and another special case. I agree that it's sensible that having a `&amp;mut` view doesn't imply the ability to assign the variable a view of something else (and thank you for phrasing it so clearly!) However, the extra freedom automatically given by the compiler doesn't seem that bad to me - Niko's suggestion was to give that freedom to every variable. I agree that if your proposal, for switching to unboxed closures, is accepted, there's no point in my suggestion as a way to remove `&amp;uniq`. However, there's still value in my suggestion if: (1) it is decided to leave the current closures around, or (2) if you wish to make `mut` and `&amp;mut` more consistent, or (3) as a base for the second part of the proposal I [posted](http://www.reddit.com/r/rust/comments/25p2rf/yet_another_mutability_suggestion_based_on/), to make non-mut variables and references entirely immutable.
&gt; If you see someone behaving in a manner contrary to these rules, direct them to this post. If the behavior persists, report it to the mods so that we can take action (i.e. lay down some fucking bans). If you can't abide by these rules, GTFO. That is all. http://www.reddit.com/r/rust/comments/1nvsdh/a_note_on_conduct_please_read/
&gt; I interpreted this as you saying I was violating the code of conduct, which I don't think I was. This inferred accusation of a rules violation is why I was being so defensive. If you haven't stepped over the line already, I think that you're not far off violating: &gt; - Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer. Several people commented on the other thread saying they thought it was simpler. Maybe they saw something you didn't... but, then again, maybe you saw something they didn't. (In this case, I think the latter is true.)
It says right there: &gt; Respect that people have differences of opinion and that every design or implementation choice, in any programming language, carries a trade-off and numerous costs. There is seldom a right answer. That's why you don't represent the other valid side of the debate as a "fiction" or "lie". I think it's perfectly reasonable to respond to someone saying your view is a "fiction" or "lie" by reusing their wording to refer to how they're ignoring the responses to their arguments and continuing to misrepresent the other position.
You can use `Inches::new(int)`. I actually wonder if it would make sense to (sometime in the future) automatically translate `Inches(int)` into `Inches::new(int)`.
&gt; I feel like the language that I love is in danger of being crippled and I'm afraid of that happening. That's why I'm speaking out so loudly. Speaking loud is fine, as long as it's not overly aggressive. And with emotions running high, it's easy to get caught in the moment &amp; write something that's unnecessarily harsh. (I have certainly done this myself recently, as you know.)
See https://github.com/rust-lang/rfcs/pull/15.
After thinking about it a bit more, I think that my suggestion would make the compiler implementation much simpler! `let mut` is easiest for the compiler, since it has to impose no restrictions. I understand that currently, imposing the restrictions of non-mut `let` is non-trivial. In my suggestion, the way to implement the non-mut restrictions is simple: If you have non-mut `let x`, just replace every occurrence of `x` with `(*&amp;x)`. As simple as that!
It would still prevent something useful that's possible today. If you're going to strip away mutability there, are you going to do it for any type containing `&amp;mut`? That's an extra thing to worry about for the type contents code.
Not at all. It's just that: if you have `let x`, for each `x` that refers to that local, replace it with `(*&amp;x)`. I think it does exactly what you'd want.
I find koans much better for that i.e. https://github.com/liammclennan/JavaScript-Koans https://github.com/mrdavidlaing/javascript-koans also interview questions http://programmerinterview.com/index.php/javascript/javascript-introduction and some test http://smarterer.com/tests/javascript/
Wow, that's a lot of questions :) I hope I can give a satisfactory answer to everything. Regarding the `Cell` example: you are write, it was written before I took up /u/XMPPwocky's comments into account and lacked the `#![deriving(SafelyMutable)]` bound; I have added it. Regarding the complexity: you are right, it is strictly more complicated than Niko's example by virtue of having 4 variations instead of 2; on the other hand it hopefully results in less unsafe code. It is something that will have to be weighted in; certainly. I should hope that the treatment of `&amp;T` and `&amp;mut T` need not depend on the `T`: the only restriction should be that `&amp;mut T` can only be re-assigned if `T` is `SafelyMutable`. Regarding the safety: if the proposal ever leads to unsafe/unverifiable code, it should be rejected outright. At the moment, I do not think it does. --- Now, regarding what is `SafelyMutable` and what is not, I certainly hope the compiler will be able to enforce the rules; otherwise there is no point in `mut` being part of the type system and we might as well use `unsafe` code when necessary. *Not leaking references to internals* is one way of being `SafelyMutable`, and it is something the compiler should be able to enforce (based on the borrow-checker). It does not have to do a perfect job, and can be stricter than necessary, as long as it does not allow leaks. Another way is to only leak references to `SafelyMutable` types, because those can be mutated through aliases without issues. In short: yes, it's complicated. Especially since I don't know where to draw the line. Memory safety can be implemented with extremely precise rules (hardly enforceable without dependent typing, I would think) or with really coarse rules. At some point, we have to draw the line and say: it's precise enough. I hope to expand on this today. --- Finally, regarding the transitions rules: - `&amp;only mut T` may yield either `&amp;only T` or `&amp;mut T`, and either may yield `&amp;T` (with some borrows); it's a diamond and there is no going backward, or sideways. - the one and only exception: within a `&amp;mut self` method of a `SafelyMutable` type, the immediate non-`SafelyMutable` members are considered `&amp;only mut T` since no reference to them can be leaked outside --- I hope this answers all your questions, if not please let me know.
to me it is a read only variable - a function input; it says nothing about the underlying object, which might change between calls. Both communication and optimization is about distinguishing input/output. The deafult should be that you can assume it wont change while you see it. (read-only,but volatile, would be another case) - Deep immutability is what i've usually wanted, its just not been available in C++; - Referential transparency is a seperate concept, from FP. For me, rusts' default immutability is more like C++ const++(and a more useful default), it doesn't need to be the same as FP's statelesness. Deep vs Shallow: my preference would be that deep is the default, and if shallow is available, its marked with another keyword - you can catch-all by using 'deep mutable' until a shallow keyword isadded. For me the most useful default is the equivalent of C++ "const resttrict" beefed up to be deep - a function input that can be cached in registers.. but without the extra-unsafety that restrict gives you in C++ I have another suggestion to extend the range of expressibility with pointers, which is the concept of write-only. Its possibly a rarer/niche case (so can have a longer name), but it would correctly represent what you do with a pointer to a new allocation, and refers to optimizations on some platforms (dcbz, or uncached memory for communicating with GPU). It also tells you when a pointer is simply recycling memory (avoiding allocs), eg for *double-buffering* which is useful in some concurrent situations. (the flip buffer is mutated, but it is *NOT* a function input.) mutable is also input.. write-only is not. frequency syntax readable writeable Can others deep closest C++ (IMO) (IMO) change it while i see it 1st &amp; yes no no yes const &amp;T restrict 2nd &amp;mut yes yes no yes &amp;T restrict 3rd &amp;share yes yes yes yes &amp;T 4th &amp;volatile yes no yes yes &amp;T / volatile? 5th &amp;overwrite no yes no yes n/a more control of deep v shallow would take yet more keywords; current situation covers all bases through extremes 
No, I am not considering speed-up here, though of course it can be so leveraged. I had two use cases in mind. The first one came from Niko's post, but I realize now it is a misunderstanding on my part. There is no way that `&amp;only Env` containing a `&amp;mut int` can yield a `&amp;only mut int` because the `int` could be aliased elsewhere. The other is not presented here. Basically it is about `mutable` members (as in C++) used for lazy-evaluation and caching. In the case of a `struct Thing { lazy: mut Type }` then you could modify `lazy` in a `&amp;only self` method of `Thing`. I had originally planned about exposing this `mutable` members thing in the same proposal; but it was already big and flying way above my head so I retracted it to focus the debate. It can always be tacked on later if the need arise.
First of all, yes it raises the complexity tax. On the other hand, controlled mutability is at the heart of memory-safety, whether the control comes through exclusivity or specifically vetted mutability. Whilst exclusivity is sufficient for a number of cases, some types such as `Cell` require unsafe code today; the idea here is to formulate a type system expressive enough to bring those types into the fold (and remove the unsafe code). Depending on the resulting rules, it might well be decided that it's not worth it and we should keep "surprising" types that act out of the regular rules. However, to be objective in the choice we first have to formulate the rules and estimate their costs &amp; benefits.
Indeed, it will prevent that. It would never pose a real problem though, because you could always add `mut`and do whatever you like. I agree it seems like a strange rule though, but I wander if it may not be that strange in actual situations. Do you have an example of a case where you'd want to pass a non-mut variable with destructor by value? If I think of a file, you can't do a lot with a non-mut reference anyway, so it makes sense that you'd have to declare it with `let mut`.
A `Rc&lt;StoresCell&gt;` might deref to either a `&amp;StoresCell` or a `&amp;mut StoresCell`, it does not matter. We can actually rewrite the function without `Rc`: fn foo(x: &amp;mut StoresCell, y: &amp;mut StoresCell) { match *x { B =&gt; {} A(ref mut cell) =&gt; { *y = B; // error: StoresCell is not `SafelyMutable` thus // `&amp;only mut StoresCell` is necessary to mutate it cell.set(2); // OK: `Cell&lt;T&gt;::set` is `(&amp;mut self, T) -&gt; ()` } } } Thus the scheme is safe because `StoresCell` is not `SafelyMutable`; I was "coerced" into writing a RFC and I plan to spend more time digging into what is safe memory-wise (getting to the bottom of things) which should help setting the lines to determine exactly the rules a type should respect to be `SafelyMutable`. Regarding `RefCell`, it is not `SafelyMutable` itself. Rewritten, it would have 4 borrow methods (or 8 if you count the `try_` overloads): - one returning `&amp;T`, increments the counter of `Ref` being borrowed - one returning `&amp;mut T`, increments the counter of `Ref` being borrowed - one returning `&amp;only T`, requires that there is no other pending borrow and prevents borrowing - one returning `&amp;only mut T`, requires that there is no other pending borrow and prevents borrowing Thus, `mut` is essentially orthogonal with the borrowing rules themselves; it could be used however to safely increment the counter (`borrow` member) because a `uint` is `SafelyMutable` itself, that is: pub fn try_borrow&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;Ref&lt;'a, T&gt;&gt; { match self.borrow { WRITING =&gt; None, _ =&gt; { self.borrow += 1; // used to be `unsafe { self.as_mut().borrow += 1; }` Some(Ref { parent: self }) } } } I had another proposal for `mutable` members that could however be better suited here. Essentially, declaring `borrow: mut uint` and be allowed to mutate it even in `&amp;self` and `&amp;only self` methods; then only methods returning a `&amp;[only ]mut T` would need to be `&amp;mut self` which seems better suited to the semantics of the type. However it is premature to think about it, I believe.
I'd say that the main motivation is that, while references have deep-immutability-by-default with optional mutability, locals have *shallow*-immutability-by-default with optional mutability. This inconsistency means that you can't explicitly capture a non-mutable local by reference and retain the same semantics without adding a shallowly immutable reference type, which is referred to as `&amp;uniq` here and is comparable to `const *` in C/C++ in its mutability behaviour (but not in aliasing behaviour, since it can't have aliases). The fact that some types have internal mutability regardless of how they're referenced isn't really relevant, since those use unsafe to get around the mutability rules.
in some ways, passing pointers to systems with const correctness basically *is* an effects system. (when you avoid globals). mutable globals are unsafe so rust is has already taken that idea further than c++
&gt; Basically, it's a horribly confusing, broken mess, that actually makes the situation much more complicated instead of making it simpler. Ah! :D I've attempted to answer your questions over there. It took sometimes because... I suspect we are in a different timezone and I only saw it this morning. It may also be that the proposal is confusing, I am afraid my English is not exactly on par with my French yet and that I have never been a champion of "personal expression" to begin with. I can assure you that memory-safety and thread-safety are very high on my priority list: if not for them I would see no point in switching from C++ to Rust. I cannot, however, assure you that the proposal is not broken; it might well be! And of course, the two revisions I did might have introduced further issues (I tried to re-read it and tweak the necessary parts, but may have missed some). Thus, I humbly request some understanding and patience on your part. And if anything is unclear, please do say so and I'll try and improve it.
&gt; while references have deep-immutability-by-default with optional mutability, locals have shallow-immutability-by-default with optional mutability Hm? I don't quite understand what you're saying. `let x: Ty = ...;` and a value of type `&amp;Ty` have the same mutability/immutability behaviour, in particular, they're equally "deep".
I didn't spend any time thinking about a good name when writing the post.
Well, basically, you're trying to create mutability rules to explain types which deliberately break mutability rules using unsafe operations. I think that trying to fit these types into the language's mutability story is the wrong approach; the mutability story should only apply to direct mutation of a data structure without the use of unsafe operations, not to potential mutation of the data structure by a function which might use unsafe operations internally. I'd say that Rust's current approach of using built-in traits to specify how these types can safely be used is the correct approach.
Ok, yes, other than `Ty = &amp;mut` what I said was true. I was confused by what you said because the internals of `let x: Cell&lt;...&gt; = ...` and `&amp;Cell&lt;...&gt;` are both mutable, i.e. the `&amp;` isn't imposing true deep immutability (yes, I know this is the optional mutability you mentioned). And conversely (more significantly) the `uint` in `let x: Box&lt;uint&gt; = ...;` is not mutable even though it is not shallowly contained in `x` (this differs to `const` in C/C++). (i.e. it was the unconventional use of "shallow" that was confusing.) Let me rephrase what to see if I understand you: &gt; A reference `&amp;` forces any contained `&amp;mut`s to be treated as `&amp;`, i.e. "deeply" freezes `&amp;mut` references, but putting a similar type in a local doesn't forbid mutation through it. --- In any case, I don't think the mutability story is broken. Particularly, it falls simply out of thinking about aliasability (`&amp;&amp;mut` is aliasable, `&amp;mut` in a local is not). I guess this could be evidence for renaming `&amp;mut` to `&amp;only` as per Niko's original RFC, but I personally think the simplest way to answer (the common question) "I need a mutable reference" is with `&amp;mut`, rather than with "and therefore it needs to be unaliased, hence `&amp;only`". (However, I'm probably too experienced to say much about how simple things are to learn.)
I was actually ignoring types which use unsafe operations to break mutability rules for the sake of discussion. Trying to have rules that apply even when they're being broken is a needless complication. Rust already deals with the exceptions to the mutability rules by using built-in traits to reason about how these types can be used. But I accept your clarification that by deep immutability I meant deep freezing of reachable `&amp;mut`s, making them behave like `&amp;`s. By optional mutability, I meant you could get a mutable reference or local by adding a `mut` qualifier. One thing I've noticed a lot in these discussions is that a lot of people think non-mut locals and non-mut references have the same properties, which is one of the issues with the current system. Yes, it makes sense from an aliasability perspective, but if you're teaching people that `mut` means mutable, they expect its presence *and its absence* to have the same meaning across the contexts where the keyword is used, and at the moment, it doesn't.
obviously it should be *eigenmutability*
How do you envision the compiler exposing this in a useful way in the future?
"Shallow immutability" is what I think of. When I think an object is immutable, it will: - Never mutate it's own state. That state is any object or struct that it owns directly - If it has a pointer to another object, the pointer can never change (because this is part of above-mentioned state). But it is capable of modifying the contents of the pointer, unless the contents of that pointer are immutable as well. - Output of functions can change, since it has access to potentially mutable objects via pointers, IO, etc But I'm not a functional programmer *at all*, so this is probably a horribly biased world view :) And to be clear, I have no problem changing my world view because of memory safety, etc. But that's how I view immutability today 
I'm sorry if I worded my comments poorly. If I say that `mut` is a "lie" or a "fiction", my intent is to say that in my opinion the language definition appears to be providing one thing, but isn't actually doing it. I do not claim that you are lying and I'm sorry if my comments came off that way. In this particular case, I was just quoting a sentence directly from Niko's RFC. I don't argue with anything that you have to say on a technical level. I know of no reason that the current rules don't do a great job of ensuring memory safety. What I don't agree that they are useful for reasoning reasoning about programmer intent. A `mut` on a local binding has nothing to do with memory safety (reference: Niko's RFC), so I argue they are all about programmer intent. A `mut` binding conveys different things about programmer intent depending on the type. The compiler generally knows if the type contains an `Unsafe` (except if the `Unsafe` is behind a Trait object), but the reader doesn't unless they read the implementation of the type. So, what the `mut` is saying about programmer intent I think is fairly difficult to describe. So, I'm arguing to do what Niko proposed (making everything a `mut` binding) and I'm also arguing that improving the closure situation, while great, doesn't mean that shouldn't be done. If we want Rust to have a system to reason about programmer intent regarding mutability (and I'm not convinced that we need one), I think the language would be better served by a system designed specifically to do that and only that, for example, maybe an effects system. Unless I become convinced that I am wrong, I will continue to argue that point, and I don't believe that I am. 
I took it to mean [an owned Trait object](http://static.rust-lang.org/doc/master/rust.html#object-types) (though I think the correct syntax for it now would be `Box&lt;T&gt;` :p)
So slightly unrelated, does racer work with geany?
Some background behind my thought process. At first I was shocked by the proposal to make local variables mutable, and eventually I started thinking about alternative approaches. I thought that annotating "immutable" types that contain `Unsafe&lt;T&gt;` with a special keyword would be a good alternative (as in `let dyn cell = Cell::new(10);` to emphasize that cell isn't truly immutable). However, this could easily lead to having to annotate large portions of a program because a single `Cell` somewhere would require annotating the parent struct, and then parent of the parent, and so on. That is even assuming references stay exactly as they are now. Clearly, this is not a good alternative. Something less intrusive was needed. The proposed effects system could be exactly what is needed. The compiler would mark the relevant things behind the scenes, and the user simply decides when and on what level interior mutability should be forbidden. It would be an optional layer of extra control and clarity.
Why did you wait until I moved to Houston to propose a meetup? *sniff*
An effects system would be a generalization of hard-wiring lints into the compiler. At the moment it's certainly possible to [special case this](https://github.com/mozilla/rust/pull/14241) although it requires some thought.
My instincts say it's better to require the programmer to go through more hoops to disable safety rather than the other way around. 
What do you mean by disabling safety? Cell and RefCell are safe to use right now and I'm not proposing to change anything about that. The concept of interior mutability is just unintuitive to the uninitiated. I can declare a supposedly immutable Cell, and change its contents regardless. The idea is to give the user a way to avoid or recognize interior mutability if desired (which probably won't be often).
Edit ---- After further thought and discussion, while when considering only borrowed pointers, `&amp;uniq` seems like `const *` without aliasing and related concerns, this analogy breaks down somewhat when you consider `Box` and other data structures, which make slot immutability seem not strictly shallow. Also, uniqueness can be used to explain `&amp;uniq` if you consider the effect of immutability-by-default. The immutability is explained by immutability being the default, and the apparent shallowness with respect to indirection via `&amp;mut` can be explained as resulting from the ability of `&amp;mut` to override immutability provided that the data it references cannot be aliased. Thus, `&amp;uniq` can be seen as the natural consequence of having a unique pointer that isn't explicitly mutable. This reasoning applies to immutable slots as well because they are also unique, and cannot be aliased unless they are immutably borrowed. ___ Original Comment ---- If this route is chosen, I'd suggest changing `uniq` to `const`. The key feature of an `&amp;uniq` isn't its uniqueness, but instead its strange form of shallow immutability reminiscent of `const *` in C/C++ (excluding aliasing and related concerns). Its 'constness' cannot be explained in terms of its uniqueness, while its uniqueness *can* be explained in terms of its constness in the same way that the uniqueness of `&amp;mut` can be explained in terms of its mutability. Since constness is the feature that distinguishes it from both other forms of borrowed references, and because `&amp;mut` is itself defined in terms of its mutability and shares the uniqueness property (and is in fact more purely related to uniqueness), it makes sense to me to do the same for `&amp;uniq` and call it `&amp;const`.
Shallow immutability is what I expect (which doesn't mean it's the best alternative). I was actually quite surprised by the deep inherited mutability of (most types in) Rust. The current `x: &amp;mut T` and `mut y: &amp;T` happen to map quite well to ruby's constants and `freeze()`, respectively: CONSTANT = something frozen = something_else.freeze CONSTANT.some_accessor = something_else # fine CONSTANT = something_else # error frozen.some_accessor = something_else # error frozen = something_else # fine which, unless I'm overlooking something, maps to: struct Foo { field: uint } fn main() { let constant: &amp;mut Foo = &amp;mut Foo { field: 1 }; let mut frozen: &amp;Foo = &amp;Foo { field: 2 }; constant.field = 2; // Fine constant = &amp;mut Foo { field: 2 }; // Error frozen.field = 2; // Error frozen = &amp;Foo { field: 2 }; // Fine } (I'm aware that this also errors out with "borrowed value does not live long enough", but I didn't want to extend the example too much, and I think that this is enough to demonstrate my point) I think a similar correspondence also happens with Javascript's [const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const) and [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze).
iirc `gcbench` "was supposed to be" a way to test different GC techniques for JVM. Presumably you'd insist that "it's meaningless to use [`gcbench`] in any setting other than" GC for JVM -- such as GC for Mono.
This is a silly argument and I don't really want to debate it.
&gt; completely arbitrary Are you expected / allowed to write your own garbage collector for that task; or are you required to use the GC provided by the language implementation or a library? 
I'd be down to go to this; I don't follow the mailing list though.
That would be dbaupp, and it's been there since approximately January. :P Accidental /r/playrust submissions have been falling off recently, though I think it's unlikely that anyone who can't bother reading the sidebar (or the page header, or the tab title, or the big friggin' text that's six pixels below the submission link) will suddenly see the light once they've plowed through to the submissions page. Rather, I think it's more likely that people looking for the game have simply learned which subreddit is the one they want and which subreddit is the one full of weirdos arguing about boxes and mutability.
jemalloc and tcmalloc already provide a thread-local cache of allocations, so there's not much advantage to building your own storage on top in most cases. Using a better general purpose allocator reduces the external memory fragmentation caused by building your own arenas. The timings here are 76.3ns per allocation before and 28.6ns per allocation with the pools. The CPU described appears to be a relatively new quad core i7, and I expect the gains from jemalloc or tcmalloc would be quite similar.
I mostly posted this as a "oh look, this is kinda related."
It seems both subreddits [have hackers](http://www.reddit.com/r/playrust/comments/25m95f/rust_gets_spooky_when_i_interview_hackers/) though :P
I'm down too!
The title is "Haskell is useless," but that's too troll-y to post here. There's a great summary over on [lobste.rs](https://lobste.rs/s/mjqmoz/simon_peyton_jones_-_haskell_is_useless/comments/5rdg5s) which explains why I think this might be relevant to Rustaceans: &gt; Haskell has traditionally been safe but also useless, meaning that it’s free of side-effects (and what’s the point of a computer program that has no side effects?). He contrasts this with C, Java, C# which are unsafe but useful and points out that all languages are developing in the direction of safe and useful. For C/Java/C# this means going from unsafe to safe, and for Haskell it means going from useless to useful. To do this for Haskell, they’ve figured out how to keep side effects separate from pure code, and this concept has been slowly leaking back into C#.
That is what I was wondering to: it's unclear what other avenues were investigated, but I suspect none were.
Aw, I was sure lobste.rs was going to be a Rust-specific site. So disappointed.
[The game Rust has boxes too, and they're even mutable!](https://www.youtube.com/watch?v=-YhCvGVop1Q#t=11)
I could listen to SPJ all day. The Haskell community is so fortunate to have someone so affable and articulate. It's hard to watch him and not think of Michael Palin.
Hehe, yeah, that would have been awesome.
Really nice this useful|useless/safe|unsafe analogy, makes sense.
Looks like oxidize.rs is available. 
If you cannot get a `&amp;mut` out of a `&amp;`, then that's a big problem. That actually *requires* leaking internal implementation details of `SafelyMutable` types, if by no other reason then that the wrapping type needs to be `SafelyMutable` and use `&amp;mut` methods. But that is a big issue. Trivial example: Somewhere deep in my program, I have a type that contains a significant amount of immutable data. It gets cloned often. I realize that I'm wasting a lot of memory keeping around clones of this immutable data, so I decide to use `Rc` (or `Arc`, if the type is `Share`) to contain the data instead. This way it's not copied during the clone but instead shared. This change is a significant improvement to the memory usage of my program, without leaking the use of this `Rc` outside of my type. Except, with `&amp;mut`, now my type needs to explicitly leak this by deriving `SafelyMutable` and taking `&amp;mut` everywhere it used to take `&amp;`. Which requires `mut` to be sprinkled all across my program. Basically, this completely eliminates the ability to encapsulate things like `Rc` as internal implementation details. It forces them to leak these details. Which seems like a violation of `SafelyMutable` FWIW. --- Also, did you say you can assign directly to a `&amp;mut`? I suppose you must, because of how you implemented `Cell`. But that's a *huge* safety violation. `&amp;mut` explicitly is allowed to be aliased. I'm not sure what borrow rules you're proposing here, but I'm assuming I can take simultaneous `&amp;` and `&amp;mut` borrows of the same `mut` type (otherwise, how is `&amp;mut` aliased?). This allows me to say // not sure if SafelyMutable is allowed on enums, so here's a wrapper struct #[deriving(SafelyMutable)] struct Value { value: Enum } enum Enum { Integer(int), String(StrBuf) } let mut v = Value { value: String("test".to_strbuf()) }; // take a &amp;mut borrow of v let vref = &amp;mut v; // and simultaneously take a &amp; borrow of the string. // This is legal because they're both aliasing borrows let s = match v.value { String(ref s) =&gt; s.as_slice(), _ =&gt; unreachable!() }; // But now with the &amp;mut borrow I can mutate the value vref.value = Integer(42); // and now my &amp; borrow is pointing to deallocated memory println!("{}", s); // Accesses deallocated memory 
It's always seemed to me that the goal of rust is to move main stream programming languages in the direction of haskell, while at the same time it seems like haskell is moving itself in the direction of "useful". Maybe someday they'll meet in Nirvana?
&gt; And conversely (more significantly) the uint in let x: Box&lt;uint&gt; = ...; is not mutable even though it is not shallowly contained in x (this differs to const in C/C++). That's even worse. Now you have the determination of whether or not the immutability of a slot is inherited along a given path dependent on whether the first indirection encountered along that path is a `Box` or an `&amp;mut`. And even worse, if `&amp;uniq` is implemented, you're inserting that behaviour into the middle of a data structure. edit: turns out this isn't currently the case—see below ---- By the way, currently, `let b: Box&lt;&amp;mut int&gt; = ...` doesn't cause the `&amp;mut int` to be immutable, though if the `Box` is a *field* of `b`, then it does. This is most likely a bug. If it weren't, it would basically make implementing `Box` in the library contingent on having `&amp;uniq` as a reference to an immutable slot. edit: turns out my test case was broken—see below
His definition of "safe" was fairly specific: controlled effects. While you could plot a similar-looking graph that put Rust closer to some "Nirvana" (you may not agree that "useful, with controlled effects" is a desirable goal!), I think on SPJ's graph, Rust is mainly in the same camp as C -- useful, and unlimited effects.
The rust compiler enforcing safe memory management is a controlled effect. 
&gt; That's even worse. Now you have the determination of whether or not the immutability of a slot is inherited along a given path dependent on whether the first indirection encountered along that path is a Box or an &amp;mut. And even worse, if &amp;uniq is implemented, you're inserting that behaviour into the middle of a data structure. Not really? `Box` isn't particularly special, was just an example of an pointer that's not `&amp;mut`. I.e. something that made the value we're interested in not stored shallowly in the local variable. Anything else like `Vec`, `HashMap`, `TreeMap` (even `&amp;`) all have this property: their contents is not mutable when stored in a non `mut` variable. &gt; By the way, currently, let b: Box&lt;&amp;mut int&gt; = ... doesn't cause the &amp;mut int to be immutable, though if the Boxis a field of b, then it does Huh? The following compiles struct Foo&lt;'a&gt; { x: Box&lt;&amp;'a mut int&gt; } fn main() { let y: Foo = Foo { x: box () (&amp;mut 1) }; **y.x = 2; } 
Weird. For some reason my test case failed on me, but now it doesn't. I must've had a typo somewhere and misread the error. Anyways, the current behaviour contradicts what you were saying, which was: &gt; And conversely (more significantly) the uint in let x: Box&lt;uint&gt; = ...; is not mutable even though it is not shallowly contained in x (this differs to const in C/C++). While I thought this was true with `~`, at least at one point, it doesn't currently appear to be true right now with `Box`. This helps to show that `&amp;uniq` essentially is like `const *`. Even `Box` currently behaves as if non-`mut` `let` bindings have only shallow immutability. This demonstrates that in order to implement `Box` and similar smart pointers in the library, something like `&amp;uniq` will be needed to handle the edge conditions surrounding immutable slots. edit: I'm wrong about `Box` again; it transmits this (not so) shallow immutability to its referand, so they behave sort of like the immutability isn't shallow until you encounter an `&amp;mut`, and then all of a sudden the immutability doesn't get inherited like it would if it came from a non-mut `&amp;` reference. Now, your point about `Vec`, `HashMap`, `TreeMap`, etc... is interesting, however, the internal (im)mutability of those data structures is part of their own implementations rather than being part of the nature of the language. The elements of a `Vec`, for example, aren't actually reachable from a user's perspective. They can only be accessed via methods, which means all bets are off as far as inherited mutability is concerned, similar to `Cell`. Also, similarly with `Box`, simulating inherited mutability properly in a library in relation to non-`mut` slots requires something like `&amp;uniq` in order to make it feasible. Once overloaded indexing is implemented, if `&amp;uniq` is implemented, and if `let` bindings continue to work as they do, I wouldn't be surprised if Vec did implement this edge case, allowing it to simulate shallow immutability for when it's directly in an immutable slot.
For the sake of safety, I think mutability requires uniqueness.
The language is littered with uncontrolled side affects, the obvious example is `println!`. However something like [Algebraic Effects [RFC]](https://github.com/rust-lang/rfcs/pull/73) might fix this.
This proposal does make mutability require uniqueness, just not uniqueness mutability. `&amp;uniq mut` is stated as possible possible, `&amp; mut` (note the space) is not. I'm personally of the opinion that it is a mistake to make mutability and uniqueness synonyms. The programmer is almost always looking for safe mutability, they don't actually care about uniqueness. Uniqueness is a requirement for safe mutability under the current system, but there is nothing saying that we won't find a more general solution in the future. It makes no sense to tie the language down so that implementing a better algorithm would mean breaking everything. I should disclaim that I am rather new to rust.
Aliasing simply isn't orthogonal to mutability, because aliasing refers to a memory dependency. It's easy to show it's unrelated to address equality, because Rust allows you to create any number of raw pointers equal to an `&amp;mut` pointer *in safe code*. Two pointers are aliases if one can observe writes made through the other. If neither can be used to mutate, then they're non-aliasing by definition. This is how aliasing is defined by both C and LLVM. &gt; `&amp;uniq` (Unique, no inherited mutability, the same as the current internal `&amp;uniq`) I don't see the use case for this since [unboxed closures are cleaner and more useful if they're not special cases](https://github.com/rust-lang/rfcs/pull/77). A reference to a type without internal mutability is already non-aliasing. Since the Rust compiler is aware of every type with internal mutability, it can accurately inform LLVM that every immutable reference to a type without internal mutability is a non-aliasing pointer. &gt; `&amp;mut` (Shared, no inherited mutability (for safety), looks the same as `&amp;` to most code) If it doesn't have inherited mutability, it seems that it's identical to `&amp;T`. It will never be safe to assign to it if it's allowing to alias with `&amp;T` or other `&amp;mut`.
How about "eigenmutabilität" (hint: "eigen" is German)?
That's not true. See: Smalltalk. After you learn about special rules like binary functions (start with a special symbol) and a few more symbols like ^ (return) you're done. That's it. Look at the code of your distribution to learn more (as in just click on the function and you can inspect the internals of it to see what it does). The language IS that simple.
&gt; I don't see the use case for this since unboxed closures are cleaner and more useful if they're not special cases. A reference to a type without internal mutability is already non-aliasing. Since the Rust compiler is aware of every type with internal mutability, it can accurately inform LLVM that every immutable reference to a type without internal mutability is a non-aliasing pointer. dbaupp has pointed out that `&amp;uniq` would allow a few more locals to be left immutable even with by-value unboxed closures, because it could allow mutation through inner mutable references. However, to argue from this standpoint you need to prefer inherited mutability over transitive mutability, and be willing to pay the complexity cost of an extra reference type in order for a rare few local variables to be left immutable. I haven't seen anyone arguing from that point of view.
Yes, but a more emotional response is more convincing. Because we're people, not perfectly rational beings. I was more convinced by the strong words than by the arguments.
You just described a small amount of syntax. You haven't told me anything at all about the semantics of the language. For example, I would have no idea that Smalltalk uses message passing given what you just told me, and reading Smalltalk code isn't going to clarify that.
&gt; So Box indirection behaves as though the referand is held directly in the Box's slot. Yes, this is unique ownership at work. With `&amp;uniq` the same functionality can be provided for anything that semantically owns its contents (`Vec` `HashMap` etc.). &gt; If they did so, they would be simulating shallow immutability in some sense The key being "in some sense", the sense is the mutability is inherited not transitive, i.e. you can mutate through a `&amp;mut` even if it's not in a `mut` slot, as long as it guaranteed to be unaliased; at the moment the compiler only understands this for `Box` and local variables, but adding `&amp;uniq` would allow it in general. (However, in this context, all adding `&amp;uniq` would do is allow a few more locals to be non-`mut`.) (FWIW, I would recommend you find a different word than shallow, given the mutability system is fundamentally not shallow (truly 'shallow' would be like `const` in C/C++.))
One thing I haven't seen discussed yet is the choice of defaults in adding this new `uniq` keyword. The reason for having `mut` and having the default (or absence of `mut`) be immutable is that it is generally safer to have immutable variables, so we require the programmer to opt in for mutability. I believe this forces the programmer to be more careful about mutability. Should we not be doing the same thing with uniqueness/aliasing/sharing? The safest choice is to have unique, immutable references be the default, and therefore require no keywords. The less safe option is to have a (possibly) shared reference, which we might denote `&amp;share` or `&amp;shared` or `&amp;shr` (or perhaps even just `@`, though I realize many dislike sigils now, I think this would be a nice usage) One concern is that people use `&amp;` by itself almost all the time in code today, but as far as I can tell (which is not that far, mind you), all of these use cases could be using unique references instead.
But are they aliasable?
The fact that it's hard to talk about this in distinct terms is somewhat indicative of its complexity. Slot immutability is an odd beast which is less penetrative than alias immutability but more penetrative than C/C++ const. Maybe weak vs strong immutability, though the stronger form still isn't the strongest form of immutability that is conceptually possible due to the ability to circumvent it within the language. While traversing a weakly immutable data structure, you could say that the immutability *solidifies* when you encounter an `&amp;` reference or any type which, when weakly immutable, can only grant strongly immutable access to its encapsulated data, and you could say that the weak immutability *breaks* when you encounter an `&amp;mut` or any type which, when weakly immutable, allows mutable access to its encapsulated data.
I think there are 3 views on this issue: * inherited mutability is enough, the type system should stay as-is (my view) * mutability isn't important, remove the parts not required for safety (Niko's view) * transitive mutability is purest solution and should be offered (the other proposals) I don't like the current proposals for the third option, because they attempt to build on `&amp;uniq`. The `&amp;uniq` type is not useful in a system without non-transitive inherited mutability, and is identical to `&amp;mut` in a system with no local variable mutability. There is no aliasing without mutability, as a useful definition of aliasing is not about address equality but rather about memory dependencies. The `&amp;uniq` type is really *borrowing ownership*, not enforcing non-aliasing since a truly immutable reference already does that. It can't express anything new beyond avoiding a few mutability markers (very few, with by-value capture for unboxed closures), and it *only* avoids these when the immutable variable is being used for external mutation through inner `&amp;mut`. I do think there's value in the *idea* behind the third option, so I decided to write up my view of what it would look like if implemented in the simplest possible way. I'm not sure that it would have any value in practice, but it does provide what many people are asking for.
interesting. maybe they could start with an alias keyword and redeploy @ for whatever is the greatest demand; imagine as sugar for prefixable un-nested generics. e.g. foo@T = foo&lt;T&gt; foo@bar@baz T = foo&lt;bar&lt;baz&lt;T&gt;&gt;&gt;. emacs pretty mode can visually nreplace sequential characters, so foo@ could be replaced with a unicode sigil. (i personally liked the idea of using enclosed alphanumerics for chain able prefixes for things like owned-ptr, option..
That is a nice idea. Personally I would probably prefer rust to introduce some kind of default arguments, because they would allow me to write factory methods that create immutable objects without the use of builder classes. https://github.com/mozilla/rust/issues/6973
+1. I'd love to see Scala-style default arguments.
I guess that you are right. The name `&amp;mut`somehow rubs me the wrong way, because it could potentially mean "Immutable address of mutable slot" or "mutable address of immutable slot" or a "mutable address of mutable slot" . If one of the names `&amp;uniq`og `&amp;only` or `&amp;my` (my favorite) is consistent with the inner workings of rust, then it might be good idea to rename. (But hopefully the future direction of the language is not determined solely through reddit-democracy :-)
I think they are anti aliased
Not yet, I believe. The proposal for unboxed closures (https://github.com/rust-lang/rfcs/pull/77/) should improve our capabilities here in the long term, though I think sendable closures are beyond its scope for now.
For the following fn do_task_closure(task: ||:'static+Send+Share) { for _ in range(0, 2) { spawn(proc() { task(); }); } } I get do_task_closure.rs:3:19: 5:14 error: capture of moved value: `task` do_task_closure.rs:3 spawn(proc() { do_task_closure.rs:4 task(); do_task_closure.rs:5 }); do_task_closure.rs:3:19: 5:14 note: `task` moved here because it has type `proc():Send`, which is non-copyable (perhaps you meant to use clone()?) do_task_closure.rs:3 spawn(proc() { do_task_closure.rs:4 task(); do_task_closure.rs:5 }); error: aborting due to previous error The problem is the closure looks a bit like `&amp;mut Trait`, and so it has to be moved into the `proc` on the first run through the loop, meaning it's not valid to reuse it on the second (because ownership has been transferred from the `task` local variable into the environment of the `proc`).
There's a difference between the semantics being simple, and not needing to document the semantics at all. You're claiming the latter, but you have no evidence for your claim. And in fact, since you just had to describe semantics to me, that seems to be evidence *against* your claim. Also, I think you're completely wrong. `three.greaterThan(four)` in Rust syntax is a static-dispatch method call. Message passing in Smalltalk is not just syntax that corresponds to the same thing. It is in fact dynamic dispatch. Not only is it dynamic dispatch, but it's also dynamically typed and totally reflective (both structurally and computationally reflective). Which is to say, the description you just gave about message sends is about as a far as possible from the truth as you could get. And of course Smalltalk is object-oriented, which again is a key piece of the language that I would not know about based on what little you've said.
&gt; The current method seems to be fine to me. The current method is safe, and provides a useful form of user-facing immutability based on ownership concepts every Rust programmer already has to learn. &gt; It just seems that the confusion is based around shallow vs deep immutability. In that case, simply switching the syntax to `&amp;uniq` or `&amp;only` would solve the issue. The existing form of user-controllable mutability is not shallow *or* deep. It's inherited mutability, based on ownership. &gt; What seems to have happened is that because of the debate on what to use, everybody has decided to come up with their own way of handling borrowed pointers and mutability. There was a sensible initial proposal to remove opt-in inherited mutability for local variables because it has no safety implications. I think this feature is useful and has little to no complexity cost, so I disagree with that proposal. However, it's completely sound and doesn't change the logic used to enforce safety in the language. I think most of the responses misunderstood the proposal, and were based on a lot of confusion about why Rust has the aliasing rules. The aliasing rules exist to provide memory safe mutability, not as an orthogonal concept. It's not possible to have aliasing without mutability because it's tied to memory dependencies; integer-based equality of addresses isn't important. For example, the `&amp;uniq` type was put forwards by Niko as a way to allow **more** cases of non-transitive mutability by permitting modifications through `&amp;mut` stored in an *immutable local variable* by borrowing the **unique** ownership to an immutable reference. I wrote [an explanation](http://www.reddit.com/r/rust/comments/25ri67/simple_transitive_mutability/) explaining some of this a bit, and demonstrating that transitive (deep) immutability already exists as a compiler feature, but not as a user-facing feature. Exposing it doesn't require any modifications to the existing type system or even any backwards incompatible changes.
&gt; transitive (deep) immutability already exists as a compiler feature, but not as a user-facing feature. Exposing it doesn't require any modifications to the existing type system or even any backwards incompatible changes. I don't necessarily think we *should* expose this, but if you want transitive mutability in Rust you should be arguing for exposing the existing concept rather than fundamentally changing the type system. Rust's type system already provides an awesome system where strong type-based alias analysis, memory safety, data parallelism and user-facing control over mutability is all possible with quite minimal complexity. Either removing the existing control of variable mutability or extending it to transitive mutability is possible without any fundamental changes. A language releasing a 1.0 version at the end of the year is not going to drop all the existing work on aliasing and inherited mutability and attempt something else, when the current system works so well.
Okay. Thanks for clearing that up.
Yes, this is what I meant.
It's not all that dynamic, it's only dynamic based on the type of `3` so it's single dispatch you have to use reflection to dispatch (read: call a different method) based on type of `4` so it's the same situation as Javascript the fact that it's object-oriented is in how I described what things meant I said that `3` was an object, because the literal `3` is syntax for an `Integer` object
It may or may not be pointless. My impetus for doing it was to have a concrete implementation upon which to experiment (i.e. to find potential uses of `&amp;uniq` in tandem with `&amp;` and `&amp;mut` in our current code base). The closure side of this debate is not my primary interest (*). I *am* interested in the first example Niko gave, which did not involve closures. And I am also interested in identifying other cases where we are currently using `&amp;mut` in APIs where `&amp;uniq` would suffice. If I cannot find sufficient justification for introducing `&amp;uniq` via direct analysis, then I suspect I will simply join what I believe to be your (that is, strncat)'s side of the argument, in that our current system with `let mut` and `&amp;mut` is perfectly fine, and it just needs to be explained properly. ---- In any case, I find your dismissive manner of discussion pretty brusque and difficult to respond to without getting egos involved. But as far as I can tell, there's little chance of my feedback changing that aspect of your behavior. (*) I do find interesting the fact that our current closure system internally uses `&amp;uniq` and thus made this prototype super easy to hack up, but that's more of an implementation artifact rather than a basis for arguing for or against the language addition.
As far as I'm aware the *only* value of having a unique reference to something is that you can mutate its contents safely. If you don't want to mutate something there is no value in having `&amp;only x`, you can always take `&amp;x`. `&amp;mut x` is named after after its purpose, `&amp;only` is named after what it actually is (but not really, in the case of `&amp;&amp;only x`), but does not hint at its purpose. Neither is entirely self-documenting, but I think focussing on the 'what' is easier to understand and remember than focussing on the 'how'.
Baking non-unique but mutable pointers into the language defeats the entire system. We already have volatile in the library so I don't see the value of `&amp;volatile`. I think people are focussing way too much on `Cell` and a few similar types. Their use is (or should be) exceptional. Why complicate the current system for the sake of a few types that most of the time you shouldn't be using anyway? And the compiler is already aware of aliasable mutable types and all types that contain such types, so the current system works just fine.
And how many types contain Cell/RefCell parts, relative to all other types?
'&amp;volatile' is probably the wrong word for it, but does the libary let you express that something can't be cached ? doesn't that require unsafe code / *ptr at the minute? &amp;alias / &amp;alias mut are better i think.(restrict, const is default, so 2 complimentary keywords for unrestrict, unconst ...) Anything but changing &amp;mut, for me. if that means new keywords to appease the people demanding changes to accomodate cell , that would be better IMO. I dont like the idea of &amp;only or &amp;uniq at all, because I both want to type and see that its an output; hence these suggestions
It's not the same as changing `&amp;` to `&amp;mut` because it wouldn't be changing mutability, only uniqueness of reference. What you gain by using a unique reference, I think, is the ability to temporarily loan that unique reference out to a closure, or more generally if you need by-reference captures of upvars. You are correct: the only reason we would absolutely need a unique reference is if we were going to perform mutation, but providing the mut opt-in notation allows the programmer to signify intent, which is desirable. So it's not necessary, but it's desired. Plus, I would imagine having an implicit `restrict` modifier all over the place generally allows for some optimizations.
The a in the @ stands for alias...beautiful.
Thanks for taking the time to explicit your questions. I just pushed a much trimmed down version of the proposal to github which you can consult [here](https://github.com/rust-lang/rfcs/pull/78#) if you wish to keep up-date. First of all, the goal is to promote a check of *visible mutability*, I would argue that `Rc`'s references count is an implementation detail and need not be exposed to the user. This is contrary to `Cell` where the mutability of the inner value is the *raison d'etre* of the type. Regarding the second example (assignment to `&amp;mut`): - in the first iteration of the proposal, this should have been rejected because it leaked references (somehow...) - however since checking those leaks is incredibly difficult, the second iteration is much simpler: `Enum` is not `SafelyMutable` (and cannot be, only C-`enum` can be) and therefore attempting to declare `Value` as `SafelyMutable` does not compile (the short version: only PODs can be `SafelyMutable`)
&gt; Why complicate the current system for the sake of a few types that most of the time you shouldn't be using anyway? I agree with this, actually (despite proposing to enrich the system). However I would argue that in order to perform a costs/benefits analysis we first need to agree on what we are measuring. Thus, proposals of new systems help us crystallize the arguments, and evaluate the costs and benefits.
&gt; In particular, you know that no one else can mutate it [...] I have been thinking about this for a while (too much, I am afraid), and actually there seem to be plenty of cases in which this perceived immutability is *shallow*. For example: struct SomeType&lt;'b&gt; { ref: &amp;'b Cell&lt;int&gt;, } fn get(st: &amp;SomeType&lt;'b&gt;) -&gt; int { *st.ref } fn set(st: &amp;SomeType&lt;'b&gt;, i: int) { st.ref.set(i); } fn doit(left: &amp;only SomeType&lt;'b&gt;, right: &amp;only SomeType&lt;'c&gt;) { let a = get(&amp;left); set(&amp;right, 5); let b = get(&amp;left); assert!(a == b); } Does the `assert` fire or not ? Of course, this depends on using a `Cell` underneath; but as a library user I have no wish to delve into the implementation and see whether such wizardry is used. Especially since it could vary from one version to another. And therefore, even if provided with a `&amp;only` reference I am wary about trusting its "immutability" because it could potentially refer to aliased parts of the system. I suppose this maps to the memory dependencies that /u/Uniq&lt;strncat&gt; keeps repeating.
While this is an interesting solution, there are other uses for `&amp;uniq` in the language, which might in fact make this proposal orthogonal to the mutability issue. More specifically, in order for a library type to be able to propagate inherited mutability accurately, the way `Box` does, it needs something like `&amp;uniq`. If values of the type uniquely own encapsulated `&amp;mut` references, then as long as the value is uniquely rooted—i.e. there are no intervening aliasable references between it and its root slot—the data referenced by those `&amp;mut`s should be mutable, even if the value is immutably rooted. `Box`, for example, presently implements this behaviour. Without `&amp;uniq`, this behaviour is impossible to implement in a library, which is particularly a problem if `Box` is ever going to be made a library type. Values that are immutable, even if also uniquely rooted, can presently only be borrowed using aliasable references, which means that the type cannot correctly grant mutable access to the data referenced by its encapsulated `&amp;mut`s without introducing dynamic uniqueness similar to what Cell does. I think this would be unfortunate. The solution to this is one of the ones Niko suggested. As long as `&amp;mut` can override unique immutability, and slots can introduce unique immutability, there will be a need for an immutable unique reference type like `&amp;uniq`. If this need is to be addressed, then one of Niko's suggestions will have to be adopted, since those amount to (1) making it so slots don't introduce immutability, (2) adding an immutable unique reference type, and (3) making it so slots aren't considered "unique"/making it so `&amp;mut` can't override unique immutability. The proposed change to closures might alleviate one of the major pressure points, but it doesn't completely resolve the issue, and introduces complexity of its own which would have to balanced against not-completely-solving one of its target problems and the potential existence of other unboxed closure solutions which make different trade offs based on not trying to address the mutability issue.
I ran into the same issue and tried to get around it using `Arc`: fn do_task_closure(task: ||:'static+Share+Send) { let shared_task = Arc::new(task); for _ in range(0, 2) { let local_task = shared_task.clone(); spawn(proc() { (*local_task)(); }); } } giving send_function.rs:21:13: 21:26 error: closure invocation in a `&amp;` reference send_function.rs:21 (*local_task)(); ^~~~~~~~~~~~~ error: aborting due to previous error
Yes, I think this is a coherent workable form of the earlier proposal. However, I'm increasingly becoming perfectly fine with the system we have today and don't need a great need to change it, beyond removing `&amp;uniq` from the borrow checker (since the data I've gathered seems to indicate that fewer than 10% of closures would benefit from it). I do not speak for the rest of the core team.
Indeed, but I think it's the expected thing. The important part is what can happen to the *value* of a non-mut local, and in my suggestion that's exactly what can happen to a value referenced by non-mut `&amp;`. (Of course, if you move it into a mut slot then it could again mutate, but then it's not in the original slot. Whenever it's in the original non-mut slot, it could not mutate beyond what's allowed by a non-mut `&amp;`)
Do I understand correctly, that build is not triggered, when nightly snapshot is updated? That was a cool feature of rust-ci.
A concern I have about leaving well enough alone and getting rid of `&amp;uniq` vs making `&amp;uniq` first class or changing the system to make it irrelevant—aside from the rough edge in closures where captured locals cannot fully retain their mutability characteristics, which you've shown is likely of low importance—is that, as things stand, library types cannot fully replicate the inherited mutability of `Box`, in particular its transparency to the external mutability of its contents, which is a problem particularly if `Box` is intended to be moved into the library as a (slightly blessed) smart pointer at some point.
While that syntax if very nice and succinct, I think it would make people use aliasing more often. It isn't usually needed, so ought to have a longer and clearer keyword like `alias`. Similar to discouraging the abuse of heap allocation caused by the `~` sigil by adding the `box` keyword.
&gt; I would argue that Rc's references count is an implementation detail and need not be exposed to the user. The problem is that the only way to implement that is to use `unsafe` to convert a `&amp;self` into a `&amp;mutable self`. And if that's ok for `Rc` to do, then you can't prevent other types from doing it too.
I think this is basically the second part of my [proposal](http://www.reddit.com/r/rust/comments/25p2rf/yet_another_mutability_suggestion_based_on/). I just think that when you don't use a keyword you should get the most restrictive variant (transitive mutability). One reason is that otherwise most people won't bother to write `imm`, because everything would work fine without the restriction, hence the added keyword won't actually do anything to improve code readability. The other reason is that if someone *does* use `imm`, when reading the code the extra keyword asks for special attention ("look at me, I'm special") while actually it signifies the place from which the least surprises may come. So I think that a keyword for inherited-but-not-transitive mutability should be added (I suggested "sharedmut"), and then, when migrating the existing code base, usages of non-transitive mutability will have to be marked with that keyword, thus highlighting the places where things may mutate unexpectedly, gaining an immediate readability improvement.
What do you see as not implementable in the library?
 let x: Box&lt;int&gt; = box 1; let y: Box&lt;&amp;mut int&gt; = box &amp;mut 1; *x = 2; // illegal **y = 2; // legal `*x` is immutable since `x` is immutable, and `Box` inherits (im)mutability. However, `**y` is mutable, since it's the result of dereferencing a unique `&amp;mut`. This is what I meant when I said that `Box` is transparent to the external mutability of its contents. You can't implement this behaviour in a library because in order to dereference a smart pointer you first have to borrow it. You can't borrow `y` as mutable using an `&amp;mut` since it's in an immutable slot. However, if you borrow `y` as immutable using an `&amp;`, then you've made it aliasable, which means that `**y` is also aliasable and therefore must be immutable despite being in an `&amp;mut`. If you were able to borrow it as `&amp;uniq`, then `**y` could remain uniquely referenced and therefore mutable.
I don't like this one very much, it doesn't fit into the series so well and it highlights some of Rust's scruffy edges. The next one will be here sooner and be more fun.
A few nits… &gt; To pass a ref-counted pointer you need to use the `clone` method. This kinda sucks, and hopefully we'll fix that, but that is not for sure (sadly). Touché :) I'm not convinced at the moment (due to an intense aversion to copy constructors). &gt; You can take a (borrowed) reference to the pointed at value, so hopefully you don't need to clone too often. You can also take a borrowed reference to the Rc *itself*, which is also a common idiom in C++ to avoid reference count traffic. &gt; For now, you should know that if you want a mutable, ref counted object you need a Cell or RefCell wrapped in an Rc. As a first approximation, you probably want Cell for primitive data and RefCell for objects with move semantics. So, for a mutable, ref-counted int you would use `Rc&lt;Cell&lt;int&gt;&gt;`. I'd prefer not to encourage people to write `Rc&lt;RefCell&lt;MyHugeStruct&gt;&gt;`. Instead, it's better form to put cells and ref cells on individual fields of the struct. &gt; Currently Gc is a prototype implementation and is actually implemented using reference counting (so if you have cycles, you are screwed). You should probably just use Rc pointers for now. Indeed, `Gc` is marked `#[experimental]` for this very reason. You might want to add that…
&gt; Currently Gc is a prototype implementation and is actually implemented using reference counting (so if you have cycles, you are screwed). The one benefit of `Gc` over `Rc` (at the moment) is you're not completely screwed, `Gc` cycles get collected at task death, while `Rc` requires explicit breaking of cycles via `Weak`. &gt; You also don't need to use `clone()` to copy Gc pointers like you do with Rc pointers, again, I hope this inconsistency gets addressed You *can* use `clone` to copy a `Gc`, i.e. `Gc`s are strictly more flexible than `Rc` at the moment. Making `Gc` more restricted by forcing the use of `clone` seems like a strange thing to want "fixed"? (Also, there's `*mut T` in addition to `*T`.)
I didn't realise there was that difference between Rc and Gc. I thought task death would lead to all memory getting destroyed - how do Rc cycles persist beyond that? I meant that the inconsistency should be fixed, I don't care which way it is fixed. Making Rc not need the explicit clone makes more sense to me too. I'll add a little something about *mut T
I'm going to cover Cell/RefCell in a bit more depth in the next post. I'll add your comment there. I'll add the other things to the current one. Thanks!
&gt; I didn't realise there was that difference between Rc and Gc. I thought task death would lead to all memory getting destroyed - how do Rc cycles persist beyond that? `Rc`s aren't connected with the task at all, they're basically just `*T` pointers with a fancy destructor, i.e. the task object doesn't even know they exist, let alone try to collect them. `Gc` pointers are placed into a big linked list stored in the task object when they are created, and removed when collected, meaning the task can just run through the list and dealloc all the left-overs (which are those in cycle) when it is closing down. &gt; I meant that the inconsistency should be fixed, I don't care which way it is fixed. Making Rc not need the explicit clone makes more sense to me too. Oh, ok... FWIW, I'm not so keen on removing explicit `clone`s. Using move semantics means Rust automatically has "lazy" reference counting: i.e. you only need to increment when it is actually required. You could also link to the [pointers section of the "unsafe" guide](http://static.rust-lang.org/doc/master/guide-unsafe.html#pointers) for a more detailed treatment.
Huh, I always assumed tasks were like processes and all the memory they allocated would be destroyed when they die. Now I am a little more scared of Rcs.
&gt; It's an edge case, perhaps, but it's a designed edge case that resulted from a certain amount of discussion and consensus building In what way did this specific behaviour of `Box` come from discussion and consensus building? In any case, `&amp;uniq` (as a known-to-be unaliased version of `&amp;`) can almost certainly be added backwards compatibly in future, if the behaviour of `Box` is required to remain. (I'll file a bug about this, though.)
 else { -1 // Not a recommended error handling strategy. } I presume a follow up post will discuss `Option&lt;T&gt;`? :)
Yes, the next one, in fact.
I seem to remember an explicit decision to make `~T` behave the same as `T` when it comes to this sort of thing, but I could be misremembering. Regardless, it's the kind of thing that might escape notice until it suddenly becomes a backwards compatibility issue, so I think it's a good idea to defang it one way or another sooner rather than latter, so good idea filing a bug.
You can also leak memory with reference cycles via types using `Arc&lt;T&gt;` internally or simply *similar* to `Arc&lt;T&gt;`, such as Rust's channels. It's not considered unsafe, and the only data tied to task lifetimes is task-local storage and the old managed pointer implementation (see `cleanup.rs`).
The proposal isn't ridiculous, the situation is.
I've rephrased that section.
I haven't played with Rust much yet, so try not to hate on me too much, but don't these Options annoy anyone else? More often than not you just just unwrap them immediately, which goes against the rest of Rust's extreme brevity. Is there anything better we can do? (sorry, I know this has almost nothing to do with OPs post. I do like these weekly updates) Edit: I'm a bit misinformed. Take the above with a grain of salt.
You have three choices: - exceptions (java, c#, python, etc) - error codes (c, go) - types (ml, haskell, rust, etc) Error codes are really undesirable for lots of reasons and exceptions have a performance and understandability cost associated with them. That leaves types. A robust program is going to be handling errors and propagating None's upwards.
If you unwrap Err or None, your program fail!s and crashes. Though, unfortunately, it doesn't specify where *in your code*. fn main() { let a : Option&lt;int&gt; = None; let num = a.unwrap(); } task '&lt;main&gt;' failed at 'called `Option::unwrap()` on a `None` value', /Users/serenity/Programming/rust_src/rust-fork/src/libcore/option.rs:248 
&gt; I'd prefer not to encourage people to write Rc&lt;RefCell&lt;MyHugeStruct&gt;&gt;. Instead, it's better form to put cells and ref cells on individual fields of the struct. Why is using multiple (ref)cells a better way?
This makes me really sad. Can't there be a way to compile the program with extra debug information? (Seriously. Who is downvoting me for asking questions? I don't care how negative this goes, but I'm really just trying to understand the logic here. Is it bad etiquette to ask rust questions in the rust subreddit?)
Sure, `-g` and gdb. You can also set `RUST_BACKTRACE=1` to get a backtrace on task failure.
Not quite. With types, you *are* forced to handle them up-front, by either actually handling the error or using unwrap/unwrap_err (for result). I dislike exceptions because you can never see where you *don't* handle an exception, only where you do. With types, you at least see every spot where you could be doing error handling but aren't.
/r/playrust
http://www.reddit.com/r/playrust Have a look at this subreddit's title and sidebar :-)
Hmm, shouldn't it be the default to show backtraces? Especially considering that without them, you can't be sure where the error is (in your code)? BTW, would it be possible to map the crash location (stored EIP?) to the source file/line number, automatically? 0x1081b1d8a and main::h46f791218cb7c42cgaa::v0.0 may be helpful information when using gdb, objdump or such, but to the naked eye, so to speak, you only see the function name.
I didn't realize that it would crash immediately if you tried unwrapping a None. I guess you don't have a choice then. &gt; I dislike exceptions because you can never see where you don't handle an exception Might be hard to see visually, but at least you'll find out the first time you trigger it :-) But that kind of sucks if it makes it to production. &gt; With types, you at least see every spot where you could be doing error handling but aren't. That's a pretty good pro.
Please give further thought about my [proposal](http://www.reddit.com/r/rust/comments/25p2rf/yet_another_mutability_suggestion_based_on/). I really think that it: - simplifies the language semantics (can you explain today's non-mut slot rules in one sentence?) - makes the language more consistent, and - gives the programmer more sound guarantees. It also makes `mut` mean just what it implies - mutability. I think that immutability, besides giving the programmer sound guarantees to rely on, is an easier concept to understand compared to uniqueness (*When* must a reference be unique? *When* can it be shared?). Indeed, the compiler cares only about uniqueness and not about mutability. So the time will come when a newcomer to rust finds out that he needs a mutable *and* shared reference, and then he'll learn about Cell and friends, and use a shared-but-not-immutable reference. But that would come later on the learning curve, after using a concept which is intuitive to the coder and good enough (more restrictive than required for memory safety) for the compiler. I'm pretty certain that deep immutability is the norm. Why not make it a strong guarantee, so programmers would have to worry about less surprises, and add a keyword for the cases when you need the less common, less restrictive guarantee? 
Oh. That sounds good. If that's anything like .NET's backtraces or even PHP's, then I'm quite content.
Thanks :-) And thank you for answering my questions.
For example, Option: enum Option&lt;T&gt; { Some(T), None | And we want a function, unwrap: fn unwrap&lt;T&gt;(opt: Option&lt;T&gt;) -&gt; T; How could you implement this? Well, the only type-safe way to return a T in the case of None would be to return nothing at all -- that is, fail. fn unwrap&lt;T&gt;(opt: Option&lt;T&gt;) -&gt; T { match opt { Some(val) =&gt; val None =&gt; fail!("called `Option::unwrap()` on a `None` value") } }
Yeah... I was expecting to get back a `None`, but I guess Rust doesn't work like other languages where that's allowed. Not like .NET's `Nullable&lt;T&gt;`. But that's a good thing. I look forward to not having to check for nulls everywhere.
Well, unlike .NET or Java and more like C or C++, values in Rust are unboxed. That is, when you have a struct, you just have a bunch of bytes for the fields, not a pointer to some Object or another. So `None` or nul isn't even a possibility!
Very nice, I use natural sorting everywhere in the UI of my programs.
&gt; I haven't played with Rust much yet, so try not to hate on me too much, but don't these Options annoy anyone else? No. Compared to exceptions or error codes they are a godsend. 
Immutability is like a seatbelt, it does not prevent crashing, but it saves your life when it does: "I have a bug, now these 100 000+ lines are 100% pure safe Rust and those 1000 lines use unsafe code. Guess where the bug is." I write Rust code every day now and I really appreciate the language the way it works now. Yet, it is not perfect: Still waiting for 'impl&lt;T: Foo&gt; Bar for T' to work properly. I need it for reduce redundant code in Rust-Graphics and to port generic persistent data structures from C#. Otherwise it is the best language I have worked with.
How do `Option` and `std:optional` differ?
Sorry, I had a brainfart there. I'm looking in too many languages and had confused things.
Mutable data is not dangerous, data which is mutable _and_ aliasiable is dangerous. In that case it can be changed without you knowing. If it is mutable and unique, then you can change it, but no-one else can (without you knowing), which requires a different kind of reasoning from immutable data, but it is just as easy to reason about. Functional programming languages endeavour to remove mutability and thus avoid mutable, aliasable data. Rust gives you the choice of mutable or aliasable, but not both. Thus we offer safety with more flexibility. If you are concentrating too much on mutability, you are missing the real benefit which Rust has to offer.
I disagree with your first statement. Mutable and non-aliasable data is still dangerous: a programmer is able to mutate it even if they do not intend to, when they use the wrong variable in an expression.
&gt; Still waiting for 'impl&lt;T: Foo&gt; Bar for T' to work properly. Is this something that's in the pipeline? Although that would be excellent, I've got the impression from somewhere that this feature would cause some kind of intractable problem related to method resolution.
Mutable data can cause bugs, and mutable and aliasable data can cause *nastier* bugs. Currently, if I have a `mut` slot, or even a non-`mut` slot which isn't `Freeze`, and I give a reference to it to a function, I can't be certain that the function isn't going to mutate it without carefully examining the function and all the functions that it calls. Certainly if I assume that something isn't going to change and it changes, I'll get bugs. Those bugs can be eliminated by proper immutability guarantee in Rust. Indeed, the restriction of something being aliasable is what's needed for memory safety and concurrency, and is very useful. However, the stricter restriction of immutability can eliminate other bugs, which aliasability alone doesn't eliminate. There are times when you need the less strict guarantee of aliasability and not the stricter guarantee of immutability. In those cases I claim that a special word should be used (`sharedmut`, for example), so that the coder can note that he has here aliasability without immutability. I don't see how providing a stronger guarantee by default makes me miss the benefits Rust has to offer. Most of the time I can get the entire memory safety guarantee with deep immutability, while I get the added benefit of not having to worry about whether a function I call mutates my local. When this is a too strong restriction, I can always use the less strict guarantee of aliasability and get the same benefits I get today.
Currently when you think something in rust is immutable (doesn't have `mut` annotation), there's a chance that it's not really immutable, just aliasable. Would you like to get the guarantee that non-`mut` locals are always immutable, at the price of having to use a special word in the (probably rare) cases where you need something aliasable but not immutable? edit: fixed according to long_void's comment
&gt; RefCell would be a protected where synchronization is baked in at the calling convention level You don't mean multithreaded synchronization, do you? (Because `RefCell` is explicitly not threadsafe: in fact, it's actually the [sequential version of `RWLock`](http://static.rust-lang.org/doc/master/sync/struct.RWLock.html).) &gt; plain old structs wouldn't need to go out of their way to lie about their ownership semantics What do you mean by lying about ownership semantics?
Still, that's a much smaller danger than having it mutated from a non-local code location. Non-aliasable data will necessarily be accessed with very limited locality.
You could create a bug report requesting it, yeah. I don't know how likely others are to like it.
**rust-natord** Information: Author: lifthrasiir Description: Natural string ordering for Rust Main Language: Rust Number of Forks: 0 Number of Watchers: 2 Number of Stars: 2 
Just discovered the allocator proposal, and I was wondering how: &gt; unsafe fn realloc(&amp;self, ptr: *mut u8, size: uint, align: u32, old_size: uint) -&gt; *mut u8; works with types that have a more elaborate copy constructor than bitwise copy. For example, types that implement `Clone`. It's actually one of the short-coming of C++ `std::allocator` that you cannot `realloc` cleanly because, unfortunately, moving and copying are not necessarily bitwise copies.
Rust doesn't have any constructors (including no copy constructors), and a move (which is what a `realloc` is doing semantically) is always a byte copy, i.e. `realloc` is fine. (`Clone` is just a library trait.)
It would be worthwhile to link to [the difference between Rust and Mezzo, as provided by the very co-author of Mezzo](https://news.ycombinator.com/item?id=7702872).
[An issue](https://github.com/mozilla/rust/issues/6679) was created for this about a year ago. :-)
It usually is a smaller danger, but if you can eliminate it, why shouldn't you?
It’s dangerous on the programmer’s side but doesn’t cause segfaults or crashes (well, generally).
Because if you have a struct like: struct Foo { x: Vec&lt;int&gt;, y: Vec&lt;int&gt;, } And you're iterating over `Foo::x`, then you should be able to mutate `Foo::y` through another pointer without causing a failure. But if you use one `RefCell` you can't do this.
&gt;I have experience with both exceptions and error codes, and definitely prefer exceptions because you can't ignore them. I think the opposite : the problem with exceptions is you can too easily ignore them in most languages. Java can force checking some exception, but not all of them and the new API use only unchecked exceptions. &gt;With exceptions, when I'm prototyping, I often just leave exceptions unhandled. I'll quickly find out if I messed something up, and I'll know exactly where it happened. I don't need to do anything extra to get that functionality. The problem with error code or exception is that you only notice you have an exception case if you don't hit it at runtime. The goal of Rust is to be able to handle as much as possible things at compile time. Adding .unwarp() is not a really huge extra compared to a try{} catch{} block. I think handling things at compile time worth the extra verbosity. 
Segfaults and crashes are the easiest error to spot. Using the wrong variable (happened to me just two days ago) are much harder, because all you have is the wrong result (and in my case in only made a difference some of the times, which made finding the root of the problem even harder).
Not aware of problems related to this, but has been told it is going to change.
I believe you meant to write "... need something aliasable but *not* immutable?" In 100% safe Rust (no unsafe blocks, no Cell) I believe the lack of 'mut' means both aliasable and immutable, is that correct? For my use cases, that is good enough.
I'm pretty sure what you accomplished was making it possible to write `Cell` without `unsafe`, but still requiring it for all the other types that need internal mutation (barring the ones that just use `Cell` internally, like `Rc`). Which is to say, anyone who needs internal mutation without using `unsafe` can just use `Cell` and they'll have accomplished that goal today.
This language is made at INRIA Rocquencourt, France &amp;ndash; by the same research group which created OCaml, the language that the Rust bootstrap compiler was written in.
`Mutex` and `AtomicInt` also behave this way. I can't think of another language that has a type like `Cell`, however, most languages have a `Mutex` type.
&gt; By knowing that an object is unique, you know that there are no other references to it. That is a powerful tool for reasoning in its own right. In particular, you know that no one else can mutate it I think this is a very important point. I feel that many people (including me when I first started learning Rust) looked at `&amp;` and concluded that that was the type that guaranteed that no-one else could mutate the object it pointed to. However, the guarantees that rust provides with `&amp;` and mutation are complicated. However, `&amp;mut`/`&amp;only`/`&amp;uniq` provides a very strong guarntee that no-one else can mutate the object which I think is a far simpler and more useful guarantee, but one that is obscured by the current system that tries to put an effects system (`let mut`) ontop of an aliasability system (`&amp;` / `&amp;mut`). So, I'm strongly in the 2nd camp. Mutability is exceptionally important, but it feels to me that aliasability is the right way to reason about it in Rust.
I agree its not a hole in the memory safety guarantees and I still don't like it. In Scala, the immutability of a type is only dependant on the type itself. The immutability of the reference to an instance of that type is a fully orthogonal concept. The Rust inherited mutability system is significantly more nuanced since it depends both on the type AND the reference / slot. My oppinion is that we're not getting much for this added complexity, so I'd rather just make everything `let mut` and focus purely on aliasing.
Not yet. There's barely an http library (https://github.com/chris-morgan/rust-http) and the author is restarting after having experience building the first one. Once a solid http library is somewhat stable/working state, you can expect a lot more infrastructure around web development (routers, MVC, etc...)
&gt; I think it's useless to be discussing the mutability of these values when I don't even know what SomeType is. Why would I care whether SomeType is mutable or not when I have no idea what I'm doing with it? If the current system doesn't provide good guarantees regarding mutability of a type that you aren't fully familiar with then in my oppinion its not doing a better job in communicating programmer intent better than `let x = 0; // mut` would. &gt; &gt; I think Cell is non-exceptional for Rust &gt; &gt; Do you have any evidence to back up your claim? How often is Cell actually used in Rust code? I don't think it's very often (at least, outside of the compiler; the compiler is not idiomatic Rust code and should not be taken as representative). In my oppinion, it doesn't matter if its used all over the place or just once. Its a valid type in the core libraries with a completely safe interface. &gt; &gt; I'd also argue that it would be very much non-idomatic to see a C++ implementation of Cell where the set() function is marked as const &gt; &gt; As you already pointed out, Cell is the equivalent to C++'s mutable, so it doesn't make sense to even implement Cell in C++ (as it provides no benefit over just marking the field mutable). That said, if you did implement Cell for whatever reason, the set() function would indeed have to be marked const or else you could not use it without the Cell itself being stored in a mutable field (which of course makes the Cell redundant). This is a poorly worded example on my part. What I'm getting at is that in C++ its always possible to take a program and remove all of the `const` from everywhere (and all used libraries) and still have it work. So, in C++, `const` is about communicating programmer intent and as a coding aid. So, I'm arguing that in C++ it would be highly non-idiomatic to have a type that allowed you to directly mutate its primary content via a `const` reference. For example, the methods to mutate a (C++ `atomic`)[http://en.cppreference.com/w/cpp/atomic/atomic] instance are not `const`. However, in Rust, the methods to mutate an (`AtomicInt`)[http://static.rust-lang.org/doc/master/core/atomics/struct.AtomicInt.html] all take a `&amp;self`. So, thats my arguement that `&amp;` != `const`. &gt; &gt; The current mut/non-mut semantics are very useful for memory safety purposes, but it seems to me that they already lack useful guarnatees regarding mutability and I think thats a good enough reason to get rid of them. &gt; &gt; The proposals don't do anything to fix this situation. The only one that comes even vaguely close is the idea of removing immutable-by-default, but every proposal still leaves the behavior of &amp;T alone. And the behavior of &amp;T is precisely what requires types like Cell to exist. Which is to say, every proposed change to mutability would leave Cell intact. The only proposal that actually changes Cell itself is the one about &amp;/&amp;mut/&amp;only/&amp;only mut, which renames &amp;mut to &amp;only mut and requires Cell to be accessed through a brand new &amp;mut, but as I documented elsewhere, the proposal does not indicate whether you can get a &amp;mut out of a &amp;. If you can, then it still hasn't actually changed anything, and if you can't, then it's outlawing programs that are legal and safe today. I'm fully in the camp of removing immutable-by-default along with a renaming of `&amp;mut`. I don't see a need to change anything else. &gt; In any case, I think you're focusing too closely on Cell, which as I said above, I don't think is actually used very often. I don't agree that just because its used less frequently than other types that its somehow less important that it fit into the model. &gt; Which is to say, it's mainly just Cell that violates your beliefs about mutability. The other types with interior mutability use it to track the extra data that makes the type safe. And the ones that provide you with a &amp;mut handle on the contained value still require explicit mut markings at some point (e.g. for Mutex you need to say let mut val = mutex.lock() in order to mutate the value through the val handle). You seem to think that I'm argueing that there is something unsound about the current system. I'm not. All I'm argueing is that the current system is more complex than necessary and that it should be simplified by making all locals mutable and making aliasability the primary concern of the language. The benefits of having immutable slots by default don't seem to justify that complexity. &gt; In the end, there's always going to be an escape hatch for mutability, and that hatch is encapsulated in Cell. But most types don't use Cell, and most of the ones that do, use it as an implementation detail that doesn't leak (e.g. Rc uses it to hold the reference counts). I don't like thinking about `Cell` as "an escape hatch for mutability". I think thats confusing. Thats why i'm argueing what I'm argueing because it feels like an escape hatch given the present of immutable slots. If those are removed and the focused is placed soley on aliasing, then I argue it no longer feels like an escape hatch but rather a regular type in the system. `Cell` is only one such type, there are many others.
Oh? That's cool. I didn't know that. All the more reason to isolate things in tasks. Very cool.
Fair enough. I didn't consider my alternatives when I wrote that. I just saw all this code riddled with `unwraps` everywhere.
Smaller danger each time it happens, but *much* more frequent risk.
&gt; So, I'm arguing that in C++ it would be highly non-idiomatic to have a type that allowed you to directly mutate its primary content via a `const` reference. That's correct. But that's because C++ has `mutable`. There's no need to have a type be intrinsically mutable when you can just store it in a `mutable` field (or just don't mark it `const`, i.e. in a static). But that doesn't work for Rust. We don't have `mutable`, because that's not safe. Instead the handful of types themselves are inherently mutable, because that's the only way to make them safe. `Cell` only allows POD types because that's all it can guarantee safety about. `Mutex` guarantees it's locked before it allows you access to its value, etc. But you can't store a `Mutex` in a `Cell`, so you can't just use `Cell` as a stand-in for `mutable`, instead `Mutex` itself needs to contain the mutability. And I don't see it as a bad thing that Rust needs different mutability than C++. C++ isn't memory-safe. Rust is. &gt; All I'm argueing is that the current system is more complex than necessary and that it should be simplified by making all locals mutable and making aliasability the primary concern of the language. Making everything mutable-by-default doesn't actually reduce the complexity at all. The only thing it does is remove the need for `&amp;uniq` for closures, but we're already aiming to get rid of that by overhauling how closures work. Notably, we still have the exact same inherited mutability concept we do today. Locals will be mutable, but `&amp;` and `&amp;mut` (regardless of what you rename it to) will still behave the same. So you still need to teach the same concepts as before. I recognize that you think immutable-by-default has no value. But I hope you recognize that a lot of other people think it has a *lot* of value. In any case, I think /u/strncat is doing a decent job of explaining our current mutability system and why none of these various proposals are simplifying it over in the [comments on RFC #78](https://github.com/rust-lang/rfcs/pull/78).
Indeed. Thanks! The problem with the current situation is that even if you have no `unsafe` blocks, you may be using some struct from some library, and you have no way to know whether it contains one of those aliasable-but-not-immutable structs. So there's currently no way for you to be certain that something is really immutable beside checking all members and sub-members of the struct, including private ones. 
I see. A `Refcell` is really like a single-threaded lock then - it seems like the same tradeoffs of coarse vs fine-grained locking apply
Because mutability is useful
 let x = foo.frob(); x = bar.frob(); // wait, why did this work? Your proposal would make the above work. Sometimes. Depending on the type of `foo.frob()`. If it returns a `&amp;mut T` then that magically makes `x` mutable, but if it returns anything else then `x` remains immutable. I shouldn't have to know the type of a variable to know whether it's legal to reassign to that variable.
The extended suggestions 3, 4, 5 basically mean that every non-gimmick^[1] trait needs to take `&amp;mutshared self` instead of `&amp;self`, because it doesn't know if it will be implemented on a type that has internal mutability. And since every trait will be taking `&amp;mutshared self`, that means any variable that will ever need to call a trait method will need to be `mut`. Which is to say, at this point you may as well just go whole-hog and remove immutable-by-default from the language. Except even that's not enough. Because now you can't call trait methods on `&amp;T` references. Which pretty much removes the utility of `&amp;T` references. Trivial example: `Clone` will need to take `&amp;mutshared self` in its `clone()` method, because `Rc` needs to mutate its retain count when cloning. This means you can't `clone()` *any* type without it being non-`Freeze`. Ultimately, `Freeze` was removed from the language because it turned out that everyone who used it actually just wanted thread-safety. So it was replaced with `Shared`, which guarantees thread-safety rather than deep immutability. I don't see how re-adding `Freeze` does anything useful. If what you really want is just some way to satisfy to yourself that you don't have accidental internal mutability, you should probably be pushing for something like the [internal mutability lint](https://github.com/mozilla/rust/pull/14241) that /u/dbaupp wrote. Although that particular lint was discarded because it turns out that the compiler has to assume `Unsafe` is more prevalent than it actually is (e.g. it assumes trait objects, closures, and generics are all `Unsafe`). But you could perhaps come up with a more focused lint that cares only about concrete types. ^([1] Every trait that is intended to be implemented by multiple types, as opposed to traits that exist purely to add types to built-in or libcore types)
Of course it is useful! No one is arguing to totally eliminate mutability. It is unintended mutability that is concerning and a potential source of bugs. I find this argument similar to that put by language writers of languages that contain null pointers. They say they're useful, and that the underlying machine has null pointers. Of course they are, but unintended null pointers are a huge problem, that's why `Option`s are a great feature.
&gt; Might be hard to see visually, but at least you'll find out the first time you trigger it :-) But that kind of sucks if it makes it to production. Exactly. That's a big reason I find `Option` appealing, and superior to exceptions, particularly *unchecked* exceptions (incidentally, Java gets a lot of hate for implementing *checked* exceptions, but I prefer explicit to implicit error handling and propagation). You never know which code throws until it does, and by then it might be too late. With `Option`, `Result`, `IoResult`, etc. you know exactly what's going on. Several methods on these types make it easier to deal with them (e.g. `map`, `unwrap_or`, `chain`, and so on). Macros also help (like `try!`). Once HKT is implemented, things would get even easier, you'd be able to do something like: let x: Option&lt;int&gt; = read_int(); let y: Option&lt;int&gt; = read_int(); let sum: Option&lt;int&gt; = do { a &lt;- x b &lt;- y } { a + b } Now, `sum` is `Some&lt;int&gt;` if and only if both `x` and `y` are not `None`, otherwise it is `None`. Note: a variant of the above can already be implemented as a macro, but it is not until HKTs are implemented until it can be generalized.
I didn't mean that `let x = something` would become `let mut x = something` if `something` is a `&amp;mut`. I meant that if the `let` contains an explicit type which is written as `&amp;mut something`, you won't have to type `let mut`, because `let mut x: &amp;mut` is too verbose and a non-mut slot of type `&amp;mut` doesn't make sense. If you don't see `&amp;mut` typed in the source code right after the colon, no automatic `mut` would be added, and you'll have to write it by yourself.
&gt; Nobody today needs to care that Rc&lt;T&gt; has an Unsafe interior, but they will need to care if any proposal (besides Niko's) is adopted. What about /u/strncat's proposal? So far, his seems to make the most sense -- keep things the way they are (even Niko mentioned that in his post), and add some lints if people want to use them. This is far better than making everything mutable.
You could, but it you'd have to write a lot of code first. The low level building blocks are starting to fall into place and once the language and basic frameworks stabilize you'll start to see higher-level web frameworks and libraries. **HTTP** The [rust-http](https://github.com/chris-morgan/rust-http) project is the only serious HTTP library right now. The author is currently working on rewriting it in the form of the [teepee](https://github.com/teepee/teepee) library, which is still very much a work in progress. **URL Routing** URL routing relies on HTTP so there isn't much here. There have been [a couple experiments](https://github.com/search?l=Rust&amp;q=router&amp;type=Repositories) and some of the frameworks people have built include routing but this won't stabilize until there's a fully fledged HTTP server ready. **Persistence** There are client libraries for most of the popular open source databases and caches but I haven't seen any higher-level "ORM" libraries on top of them yet. Higher level libraries will come when the language is more stable. **Templating/Views** There's good selection of different template libraries for Rust already. [ers](https://github.com/franckverrot/ers) is in the style of ERB from Ruby, [rust-mustache](https://github.com/erickt/rust-mustache) renders mustache templates and [rust-haml](https://github.com/jeremyletang/rust-haml) renders HAML. **Frameworks** There are a couple attempts at frameworks but they're still in active development and aren't prebuilt solutions like Rails or Django (yet). If you feel like getting your hands dirty with Rust and web development improving one of them as the language and core libraries evolves would be a great way to learn. * https://github.com/jroweboy/oxidize * https://github.com/Ogeon/rustful * https://github.com/daftcorp/feral
I really like RFC #77, and it's great that it will get rid of `&amp;uniq`. Point (1) forbids the first example in Niko's post: ` let mut errors = 0; let env = Env { errors: &amp;mut errors }; ` It will remove the inconsistency in that example, by forcing you to write `let mut env =` whether you're using another function for incrementing env.errors or doing it in the same function. So in general, there *are* things you can do with `mut` slots and can't do with `&amp;mut` references, and I propose to make them consistent, by allowing to do the exact same things with both. I hope I better explained what I meant by point (2) in the other answer. Rule (2) is just meant as a sugar so you won't have to write `mut x: &amp;mut` every time an argument is a `&amp;mut`, which is quite common. I have no problem with requiring explicit `let mut x = box &amp;mut a` in your example. 
`let x: T = foo()` and `let x = foo()` are semantically identical today if `foo()` has an unambiguous return type `T`. If you're suggesting that `let x: &amp;mut int = foo()` and `let x = foo()` behave differently, despite `x` in both cases being typed as `&amp;mut int`, then that's a problem. Besides the usability concerns, that also means you are not, in fact, removing the need for `&amp;uniq`.
I once wrote a piece of code that's supposed to take every row in a DB with that userID and copy some of the values and set the userID to null. But I made a typo in userID, so it was something like userId instead and it never got set to null upon being copied. Every time the user saved information, it would create 10 new rows. Then those 10 rows would then be copied 10 times the next time, and it would create 100 rows. So on and so forth. Next day I had over one million rows in that table and the website was unresponsive because the server was running out of RAM. This is because I modified the wrong variable. Now the convention that `userId = null` actually makes a new variable made that possible, but you can still accidentally modify a variable that exists.
&gt; And since every trait will be taking `&amp;mutshared` self, that means any variable that will ever need to call a trait method will need to be `mut` I don't think it's true - there should be no problem of taking a `&amp;mutshared` reference of a (deeply immutable) `&amp;` reference. `&amp;T` would just make sure that `T` is `Freeze`, while `&amp;mutshared T` won't. `&amp;mutshared` actually means "may be shared and may be mutable", which includes all those that "may be shared and may not be mutable". Therefore I think the cascade of making everything `&amp;mutshared` won't happen. Can you elaborate on what this lint does? I don't see a problem with using internally mutable structs, I just think that using them should be clearly marked. I also think that there should be a way to mark a struct as `Freeze` even though it contains mutable slots if the public interface of it doesn't expose this mutability.
I think that there should be a way to mark a struct as `Freeze` even though it contains mutable slots for that reason: if the public interface doesn't expose mutability, it shouldn't be considered mutable.
Why does point (1) forbid that? You haven't actually done anything with `env` yet. And even if you consider initialization to be "doing something", it's perfectly valid to say `let env = &amp;Env { errors: &amp;mut errors };`. The distinction is that `*env.errors` is considered immutable in the latter case, but not the former. Your proposal would say it needs to be considered immutable in the former as well. Except your point (2) seems to be designed to make `env` be considered mutable. Although as I pointed out, where do you draw the line? Because only considering it mutable if it contains `&amp;mut T` means you're not handling cases like this `Env` struct. &gt; So in general, there are things you can do with `mut` slots and can't do with `&amp;mut` references, and I propose to make them consistent, by allowing to do the exact same things with both. I don't think this is consistent. I think it's needlessly restrictive, and confusing because you're implicitly making some variables `mut` and not others. It certainly doesn't solve the `&amp;&amp;mut T` case, which is the only real wart, because you can still get a `&amp;&amp;mut T` rather trivially. `mut` variables and `&amp;mut` references actually are already consistent today. They both are indicators that the value observes *inherited mutability*. Which is to say, in both cases, the contained value is mutable if the container is mutable. The stack^[1] is considered to be mutable, so a `mut` variable is also mutable. Similarly, temporaries are mutable, as they are owned by the stack. I think this actually makes more sense if you flip it around. Since `mut` really just means "obey inherited mutability", it's not special. What is special is `&amp;` and non-`mut` variables. Both act as a barrier, saying "do not inherit mutability past this point". So any value contained within a `&amp;` does not have inherited mutability (even if that value is a `&amp;mut T`). Similarly, a variable that is not `mut` does not have inherited mutability, so neither the variable's value, nor the variable itself, can be mutated. The simplest way of putting this is "values are mutable by default, they only lose mutability when embedded in a `&amp;` or a non-`mut` variable". Given this, it would actually make more sense if we renamed `&amp;mut` to `&amp;inheritmutability`, but that's rather impractical. ^([1] and registers, but I'll just say "the stack" for simplicity)
Right. In fact, I've been wondering if we should maybe introduce it as something like "a single-threaded lock", since that's what it is.
Indeed, I suggest that `let x: &amp;mut int = foo() and `let x = foo()` behave differently. In the first case it's obvious that you want `x` to be mutable, and in the second case it's not, so it should be immutable. You can always write `let mut x = foo()` if you happen to want to mutate `x`. I see the inconsistency, but it doesn't feel so bad to me. Perhaps point (2) should be constrained to function arguments, where you always have to specify the type. I understand that the need for `&amp;uniq` comes from not wanting to write `mut` before some references. Point (2) removes the need to write `mut` before some (most?) of those references, but I don't see a problem with still having to add `mut` to some slots compared to today.
Nope. From what I understood, he wanted to keep things the way they are mutability-wise since the compiler already knows about types like `Rc` and `Cell`, and just have a lint to expose such internally mutable types to the user if it is enabled.
The cascade has to happen, because the implementation of a trait method can't know if the `&amp;mutshared` was borrowed from a deeply-immutable `&amp;T` or not. Which means `&amp;T` can't actually enforce immutability, because calling any method on it would be allowed to mutate. The only way for `&amp;T` to enforce deep immutability is to disallow taking a `&amp;mutshared T` from a `&amp;T`. But because traits won't know if their implementors need to be mutable, this does cause the cascade and ends up with all trait methods taking `&amp;mutshared`. Which means you can't actually use `&amp;T` in practice. &gt; Can you elaborate on what this lint does? Basically, the idea is to let you say "this block of code should not be using internally-mutable types, so I'll mark it as `deny`". Unfortunately, as is documented in the linked PR, because generics/trait objects/closures all have to be assumed to be `Unsafe`, the lint ends up not being useful. That's why I'm suggesting that if you're interested in being able to make this guarantee you should investigate a more focused lint that perhaps catches fewer things but is more practical (i.e. explicitly ignores trait objects/generics/closures, or only checks the creation of concretely-typed values). &gt; I don't see a problem with using internally mutable structs, I just think that using them should be clearly marked. Even when the internal mutation is not intended to be externally visible? Such as in the case of `Rc` or `Arc`? These have to be able to mutate themselves from within `Clone`, which means mutation from a `&amp;T` pointer has to be legal. Perhaps you'd be more comfortable with a lint that merely checks that every `let`-binding to a concrete type requires `mut` if the type is `Unsafe`. Again, you'll have to restrict yourself to concrete types because generics/trait objects/closures are assumed to be `Unsafe`. You could also investigate checking temporaries that are captured by closures, coerced to trait objects, or passed as an argument to a function that takes a generic type for that argument (which is to say, try to identify the points where a temporary can become "wrapped" in one of these types that you had to ignore earlier). I don't know if you can actually practically create such a lint, but it seems to be the only approach that really does what you want, which is to require `mut` whenever working with a type with interior mutability. &gt; I also think that there should be a way to mark a struct as `Freeze` even though it contains mutable slots if the public interface of it doesn't expose this mutability. We don't have `Freeze` anymore. It was removed in favor of `Shared`, which is the kind that indicates that a reference to this type (i.e. `&amp;T`) is considered thread-safe.
As I wrote in another comment, I think that there should be a way to annotate structs as `Freeze` for cases where they contain mutability that is not externally visible. So indeed, those implementation details shouldn't leak, just like as you said the `Unsafe` doesn't make using it unsafe. I suppose `clone()` should take a `&amp;mutshared T` (which is just today's `&amp;T`) so as not to be overly restrictive. But even if it took a `&amp;T`, since I think it *should* be possible to hide internal mutability, there would be no problem. Basically it's just `Rc` saying to the compiler that it implements `Freeze` even though the compiler may have thought otherwise.
There's a difference between saying I want `x` to be mutable, and I want `*x` to be mutable. You're conflating the two, and saying you think it should be impossible to have `*x` to be mutable without having `x` be mutable.
&gt; he wanted to keep things the way they are mutability-wise Ok, so not a proposal to change mutability. &gt; just have a lint to expose such internally mutable types to the user if it is enabled I'm only talking about proposals that actually change how references, mutability, or aliasing work. Adding a lint is rather orthogonal. I personally don't think you can implement a lint that catches enough stuff without having too many false positives, but I also don't begrudge anyone who wants to try (as long as it's default-`allow`).
Your proposal, by definition, prevents `Clone` from taking `&amp;self` and still allowing for internal mutation. Also, as I responded in another comment, `Freeze` no longer exists. It was determined that nobody actually cared about deep immutability, they only cared about thread-safety, so it was replaced with `Shared` which is a more practically usable kind.
I still don't think the cascade has to happen. `&amp;T` in my proposal would mean `&amp;T:Freeze`, where `Freeze` should indicate that a shared reference to `T` is considered deeply immutable. Therefore you could coerce `&amp;` into `&amp;mutshared`, just like you could coerce `&amp;T:Freeze` into `&amp;T`; for the borrow checker there would be no difference between `&amp;T` and `&amp;mutshared T` - `&amp;T` just adds another check, that `T` is `Freeze`. `T` would continue to be `Freeze` even after being coerced to `&amp;mutshared T`.
&gt; In C++, if you have a object that needs to be visibly mutable and aliasabile, you can just avoid using `const`. Well yeah, because C++ doesn't enforce safe mutation. That's kind of the whole point of Rust's rules. If Rust behaved like C++, we wouldn't have memory safety.
&gt; Therefore you could coerce `&amp;` into `&amp;mutshared` How does that follow? If I can coerce `&amp;` into `&amp;mutshared` then `&amp;mutshared` *isn't doing anything*. Also, since `Rc` can't be `Freeze`, then I can't take a `&amp;` pointer to `Rc` in the first place.
If I understood it correctly, /u/strncat's proposal is to have a lint that indicates whether a type is internally mutable, meaning that you would have not been bitten by this issue. Plus, how would having everything be mutable prevented you from being bitten by it?
It seems to have more powerful features than Rust. It can do a tail-recursive map definition and not only can Rust not do that, AFAIK it doesn't even have TCO.
:D I smile whenever someone links my webframework. One of the goals of oxidize (which is still in active development, check out the incoming branch) is to provide a full stack like django or more aptly, revel. I've been a django user for the past three years and now at my new job I'm having to get my hands dirty with frameworkless PHP code and I'm learning why Django does things the way it does. I want to emulate that consistentcy that you get from django, but also I'm trying to add in a little bit more flexibility. As /u/zvms pointed out, it is very new, so expect somethings to be just flat out missing. It "should" be able to support middleware, but it does nothing with the middleware yet. It does have routing (provided by rustful's router now!) and it does have context (so you can have a persistent database connection and so on!). Soon I'm going to add in variable binding in the routes, and then I'm going to try to write a full featured website as an example and along the way I hope to find several shortcomings. Watch this subreddit soon since I'm _really_ close to making a post about it. Just planning on cleaning up some code, adding full documentation, and test code/travis support. I look forward to hearing feedback from the community soon!
&gt; Once HKT is implemented Wait, I thought the Rust team decided against those? That's exciting!
This was just an observation rather than an argument in favour of any particular proposal. I would like to know if something that is 'immutable' is really immutable or if it is kinda immutable. If that can be done with a lint, then that is great. I'm not saying everything being mutable would help, I was just pointing out why you might care about internal mutability. (In this particular case however, I wouldn't have spent so long debugging because I wouldn't have assumed an object was immutable when it wasn't. Of course you could argue that I shouldn't make such an assumption in the first place, and you would be right :-) )
thanks, this is pretty helpful. I hope there will remain a choice between integrated stacks and separable libraries. Re HTTP, what's the status here? Is teepee going to be proprietary? Is the sensible thing to do to say "we'll use rust-http and hopefully swap that out when something better comes along"? Is it likely that mongrel2/ scgi -style alternatives will mature? With an HTTP library, I must surely be able to do my own rudimentary URL routing if I want to, it's just a map from a string pattern to a lambda returning a string, right?
Agreed. I'm just saying that in my oppinion `Cell` isn't the same thing as `mutable`. I agree that a number of its usages are the same thing, but are places where it makes sense to use a `Cell` in Rust that wouldn't make sense in C++, so they aren't equivalent.
The Django devs speak highly of Flask as a very well-designed framework. In their words, if Flask had been around back then they wouldn't even have bothered starting Django (and I say this as a Django user). So look into that as well; Flask is much more decoupled than Django but the general feel is very good and amenable for large web apps.
Concerning Teepee, [the post in which I introduced it](http://chrismorgan.info/blog/introducing-teepee.html) is valuable reading. &gt; Is it likely that mongrel2/ scgi -style alternatives will mature? I do not believe that the future lies in such architectures. They are adding an additional layer of abstraction for no real improvements—they exist far more for the benefit of slow, dynamically-typed languages than for languages like Rust. It remains to be seen just how well those things will fit in with Teepee, but I personally am not going to expend much effort on them. If compatibility is convenient, it will probably happen at some point; if it is not, I do not intend to go out of my way to make it happen. &gt; With an HTTP library, I must surely be able to do my own rudimentary URL routing if I want to, it's just a map from a string pattern to a lambda returning a string, right? These things—or rather, these things done *well*—are considerably more complex than you think.
I had read your post about Teepee. It was because the post was silent on licensing that I asked the question. I would agree with you re SCGI/WSGI/etc, but not on Mongrel2, which I think is a valid alternative approach. I am perfectly aware that URL routing is complex; that's why I went back and put "rudimentary" in the sentence you quote
+1 For mentioning flask here as well. I've always wanted to learn flask but I haven't really gotten a chance to make anything in it yet. But having read lots about flask, that was one of the goals I had in mind was to make it highly decoupled (so if you hate the sum of the parts, you can take the parts and make your own framework off oxidize) I actually have a copy of bottle sitting in my local repository for when I want to see how bottle does some feature. On another occasion, I tried to make the framework look like Martini (just to see if I liked it), but rust closurses aren't ready for that kind of action yet. If it isn't apparent, development on oxidize has been pretty much, lets see what it looks like if I try this, and then I realize I don't like X about it, or having Y prevents me from having Z, so I'll redo it often. Its a small codebase so it isn't hard to handle. I have learned about soo many different web frameworks because of this though and so sometimes I forget where I get which idea from anymore :p
Makes sense to me!
Would you agree then that if we were able to have some way to inform the programmer about internal mutability (via a lint perhaps), then sticking to the status quo would be better than removing immutability altogether as per Niko's proposal?
It was silent on licensing because it hadn’t occurred to me as a topic that needed mentioning—just like Rust, rust-http is MIT+ASL2, and Teepee is MIT+ASL2.
http://protz.github.io/mezzo/tutorial/tutorial.html.pp.html#type-checking-the-improved-map-function it switches between a Cell and a Cons type (it's mutable when it's a list in progress and becomes immutable after it's done) thinking about it, you might be able to do the same thing with the Rust borrowck, but you still won't have TCO so it's pointless
Well, you and I appear to possess rather different sets of unspoken assumptions. Then again, I'm from Adelaide :) The blog post said "want to get paid for Teepee" and "donations"; this could have meant several different things, including proprietary licensing. Thanks for clearing it up
&gt; My oppinion is that we're not getting much for this added complexity, so I'd rather just make everything let mut and focus purely on aliasing. Inherited mutability will exist whether or not variables have opt-in mutability. The *only* reason for the aliasing rules in the compiler is to implement inherited mutability safely. There's little to no reduction in complexity from removing opt-in inherited mutability for variables.
There are multiple ways to implement them. Perhaps a major difference between such algorithms is a treatment of leading zeroes; rust-natord assumes consecutive digits to be left-aligned in that case (so that `3.014` &lt; `3.12`). This does not work always (one may want to compare `A315` and `A000315` to be equivalent) but is basically a good heuristic.
Yes, if you allocate your own memory and have an unsafe pointer to it, then you must free it. You can have an unsafe pointer to memory that is allocated by someone else and then they have the responsibility to free it (and that 'they' might be the compiler or the standard library). You just have to make sure you don't keep the pointer around once it is freed. There is no performance penalty for using an unsafe block - it is purely a compile time thing - it disappears completely after type checking.
Another alternative is exposing [transitive mutability](https://github.com/rust-lang/rfcs/pull/78#issuecomment-43394726) since the compiler is aware of what's necessary to provide it.
Why is being distinctive in itself a goal worth pursuing? IMO, Niko's proposal won't significantly simplify the language in a way that is worth to forgo local immutability. The focus should be on overall correctness and good software engineering practices, instead of one thing vs another (e.g. aliasing vs. local immutability) -- it should not be presented as a dichotomy, both are great ideas, and it would be awesome if Rust supported both, as it currently does.
Ah, assumptions… don’t we all love ’em. Of course, West of the Border you *would* have different assumptions! 😉
There's no `Freeze` trait exposed in the language anymore. At the moment, `Unsafe&lt;T&gt;` and the internal mutability concept in the compiler is solely there to permit optimizations in the future. It's not possible to lie about this, because it would result in undefined behaviour.
 &gt; (Related, sometimes you also want immutability so the compiler can make optimisations, that is only safe in the case of true immutability, not logical immutability). Compiler optimizations care about memory dependencies (often called aliasing, but address equality isn't relevant for most optimizations) above everything else. &gt; logically immutable It's not logically immutable if it's not *actually* immutable, because it prevents high-level reasoning about it. You can extend the lifetime of an `Rc` by calling `clone`, so there are externally visible effects. A cache is almost always going to be the same way.
&gt; There is a benefit in having aliasing information totally independent of mutability. There is no aliasing without mutability, because two pointers don't alias if there cannot be a memory dependency between them. Rust certainly doesn't use the address equality definition of aliasing, because you can create aliasing raw pointers anywhere you want in safe code. &gt; That is a powerful reasoning tool and does not require any mutability information or enforcement. It doesn't *require* mutability information, but it's a useless guarantee without mutability as truly immutable references (no internal mutability) cannot have memory dependencies. Rust has aliasing mutability via `Cell` / `RefCell` so non-aliasing references don't give you a reasoning tool.
Rust doesn't provide a non-aliasing pointer: fn main() { let mut x = 5; let y = &amp;mut x; *y = 10; let z = x; println!("{} {}", z, *y); } Thanks to `Cell`, there are aliasing writes whether or not this issue is fixed. I'm not what what the sort-of-non-aliasing guarantee actually allows you to reason about other than mutability. It only to implement safe inherited mutability for `&amp;mut T`.
There are types such as Cell and RefCell that can safely allow an object to be mutated through an non-unique reference by enforcing safety at runtime rather than compile time. The idea is that a `&amp; mut` would allow mutating through such types. Compile-time checked mutation (e.g., assignment) would require a `&amp;uniq mut` pointer to preserve safety.
There is no non-aliasing guarantee for `&amp;mut T` yet: fn main() { let mut x = 5; let y = &amp;mut x; *y = 10; let z = x; println!("{} {}", z, *y); } Rust only enforces non-aliasing up to the point that's it's required for safe inherited mutability, because that's the only reason it has ever existed and will ever exist. There is no such thing as aliasing with truly immutable references *because these are not orthogonal concepts*.
Consistency is extremely important. "Immutable local variables are immutable, except sometimes, when they are mutable" isn't an exceptionally consistent statement. Turning that into "Memory is only mutable through a unique reference" is, I think, much simpler and much more consistent since its true all the time and for all types.
&gt; In particular, you know that no one else can mutate it, which is more useful to know than that you can or can't mutate it. (Contrast that with mutability, where if an object is not mutable, you only know that the non-Cell/RefCell parts can't be mutated (by you or someone else)). Rust has the necessary building blocks for exposing true transitive immutability. It's misleading to characterize mutability by the current `mut` keyword, which is used to control inherited mutability, not mutability in general. There are also internal and external mutability in Rust.
&gt; I can't speak for Niko, but I fall into the second camp. My understanding of the position is that it is not that I(/we) think mutability is not important, but that we think that it is the combination of mutability and uniqueness which prevents errors and so they are equally important. That's only true of memory safety issues. Mutability guarantees separate from aliasing are still useful to aid the programmer in reasoning and preventing errors along with aiding compiler optimizations. &gt; Furthermore, it is the treatment of aliasing which is more specific to Rust, more fundamental, and easier to communicate, and so aliasing (not mutability) should be indicated by the syntax and mutability should be implied, as opposed to the current situation where mutability is indicated by the syntax and uniqueness is implied. If it was fundamental, `&amp;mut T` would actually be a non-aliasing reference rather than just everyone **pretending** that it's a non-aliasing reference: fn main() { let mut x = 5; let y = &amp;mut x; *y = 10; let z = x; println!("{} {}", z, *y); } This is not a bug, it was designed to allow for safe inherited mutability and that's *all* it does. Whether or not it will be changed to disallow this in the future, it's not accurate to state that Rust has a non-aliasing reference in the present.
I'm not sure what you mean by memory dependency. As a programmer, for reasoning about a program, aliasing means address equality and doesn't require anything else. Now, talking about how Rust can support that kind of reasoning means thinking about safe vs unsafe code. Since you can only dereference raw pointers in unsafe code and once you are using unsafe code, all bets are off, they can be ignored as far as reasoning using uniqueness as supported by the compiler goes. To put it another way, if you took all the mutability info/enforcement out of Rust (but left in the rule about not deref-ing raw pointers in safe code), you (a programmer, not the compiler) could still use the aliasability info to usefully reason about your program).
&gt; &gt;To pass a ref-counted pointer you need to use the clone method. This kinda sucks, and hopefully we'll fix that, but that is not for sure (sadly). &gt; &gt; Touché :) I'm not convinced at the moment (due to an intense aversion to copy constructors). I agree here, and with dbaupp below. Being explicit is valuable here.
I agree that distinctiveness should be a low priority thing, but I do think it is a worthwhile goal, to some extent. Hypothetically, if we were a great language but indistinguishable from another one, why should anyone use Rust rather than the other hypothetical language? I also agree that we should support both, indeed it is the combined treatment of mutability and aliasability which makes Rust really special. I think we differ on which should be primary, i.e., which is reflected in the syntax, etc. And here I think we can retain the various benefits of good software engineering, correctness, etc. _and_ differentiate ourselves from other languages by making uniqueness primary.
It has observable effects because optimizations based on the immutability (whether by the programmer via user-defined rewrite rules or the compiler) will be incorrect in all but edge cases.
I think we are talking at cross-purposes because we are using different definitions for 'aliasing'. You are taking a compiler implementers POV, whilst I am talking about a programmer's. The ability to dereference is important. If you can't dereference it, then it is no different from an int which happens to have the same value as the address. That is, when reasoning about a value, it is irrelevant if someone else has an alias for it if that alias can't be dereferenced - it means they can't observe any of your effects, and can't cause any effects for you to observe.
I think a focus on aliasing would make us _more_ distinctive. For the newcomer question, I think this is an important point - they are going to think about mutating whether or not it is in the language. But perhaps they won't think about its aliasing properties unless it is in their face. I think that is a reason to make the more subtle aspect more prominent.
&gt; I think we are talking at cross-purposes because we are using different definitions for 'aliasing'. You are taking a compiler implementers POV, whilst I am talking about a programmer's. The programmer doesn't care about address equality, they want to reason about memory dependencies and mutability. Rust doesn't satisfy anyone who wants to worry about address equality because it doesn't enforce any of it. This is *especially* true in a language with zero-size types since their addresses are completely meaningless garbage values. Here's are two *equal* `&amp;mut T` references: // compile with rustc -O foo.rs fn main() { let mut x: () = (); let mut y: () = (); println!("{} {}", &amp;mut x as *mut (), &amp;mut y as *mut ()); } Either Rust is broken in terms of what it claims about aliasing, or aliasing is about memory dependencies and not about address equality. &gt; The ability to dereference is important. If you can't dereference it, then it is no different from an int which happens to have the same value as the address. That is, when reasoning about a value, it is irrelevant if someone else has an alias for it if that alias can't be dereferenced - it means they can't observe any of your effects, and can't cause any effects for you to observe. You're describing memory dependencies, not address equality.
An example, if I have an object which abstracts an expensive computation and caches recent computations, but guarantees that its the result of computation is independent of whether we hit the cache or not (since it depends only on the input), then there are no programmer-observable effects. That is the whole basis for allowing mutable fields in C++. Sure the compiler has to know that const doesn't mean deeply immutable and if you are going to hand optimise the output, you need to care. But as far as reasoning about the program is concerned, logical immutability can be a useful abstraction.
You can call it memory dependencies or aliasing or whatever, and I admit that I am talking a bit hypothetically here (since you are right with your example that &amp;mut != unique reference, although I think we should fix that). But, my point is that uniqueness/aliasing/memory dependency as a concept (perhaps not quite as implemented in Rust right now) is useful as a reasoning tool, independent of mutability. So, to say that it is only a "means to an end" is not true, in general.
C++ doesn't provide transitive mutability without `mutable` fields either.
&gt; since you are right with your example that &amp;mut != unique reference, although I think we should fix that By removing zero-size types? I don't think you can guarantee anything about address equality in Rust.
How would Niko's proposal change this though? Wouldn't `Cell` types still get passed by `&amp;`, and they would be mutable?
I do not expect rust to support guaranteed tco
No, I meant the &amp;mut example - we should take the stricter borrow checking rules Niko proposed a while back.
This would all be the same - the whole point of Cell is that it is mutable through a `&amp;`. It would get rid of the inconsistence with let x = 0; let y = Cell::new(0); Where `&amp;x` is immutable, but `&amp;y` is not, even though they are both in immutable slots.
&gt; Hypothetically, if we were a great language but indistinguishable from another one, why should anyone use Rust rather than the other hypothetical language? That's the thing, Rust is already shaping up to be a great language, and it already has distinguishing features from the language it is trying to replace (C++). It is really great that Rust managed to attract C++ programmers, as well as OS, games, and embedded programmers. This is a sign that it already did manage to distinguish itself. I would be happy if local immutability were supported regardless of whether it were a primary or secondary feature. Perhaps adding an `imm` or `const` keyword? The thing is, the vast majority of Rust's local variables are immutable anyway, as well as captured closure variables from what /u/pcwalton posted on the RFC submitted by /u/strncat.
But languages like C#, Java, Scala etc already do this via the `const`/`final`/`val` quantifiers. Even `const int*` vs `int * const` in C++ have different semantics: one is a pointer to a const slot, the other is a fixed pointer to a non-const slot. E.g. `final int x = 0` does not allow you to modify `x`, whereas `final Stack&lt;T&gt; s` allows you to call `s.pop()`, a mutating method. In Rust, this type of internal mutation is only limited to `Cell` and gang. If we have a lint that exposes this internal mutation to the user, then we wouldn't have any surprises, correct? Perhaps forcing `Cell` and gang to always be bound to `mut` slots works? So the above code would need to be declared as `let mut y = Cell::new(0)`, otherwise it is a syntax error.
LLVM now supports guaranteed, portable tail call elimination via `musttail`. It may not be part of the stable language in the near future, but there's nothing stopping Rust from exposing a feature-gated guaranteed TCO operator. The requirements needed for `musttail` as a high level in Rust are the following: * it must return right away (`become foo(2, 3)` would be equivalent to `return foo(2, 3)`) * no variables with a destructor in-scope (to guarantee the previous requirement) * type signature of the caller/callee must match (to make the ABI match) * no passing references to local variables (can be enforced via region checking - just only allow references with a lifetime longer than the function scope)
Rust has tail call elimination. It's done by an LLVM pass called `tailcallelim`. It's now possible for us to expose this as a guarantee in the language thanks to LLVM improvements.
&gt; I don't think you're lying, I think you're carefully picking only the facts supporting your point of view and making misleading statements. That you have pronounced me to be wrong does not mean that simply argueing my point of view is akin to "making misleading statements".
&gt; If we have a lint that exposes this internal mutation to the user, then we wouldn't have any surprises, correct? I think getting a lint to do this without overwhelming users with invalid warnings would be very hard. I could be wrong, of course. There has already been one attempt to do this that hasn't panned out. &gt; Perhaps forcing Cell and gang to always be bound to mut slots works? So the above code would need to be declared as let mut y = Cell::new(0), otherwise it is a syntax error. I'd prefer to just get rid of mutable bindings since I think its simpler and still preserves memory safety. However, I do think this idea has merit and I think its significantly better than the current situation. The difficulty is in determining what types would need to be declared this way. `Cell` is a trivial example. A type that contains generic types or a trait object is more complicated since it won't be possible to know until runtime if it contains a `Cell`. So, I believe it would be necessary to reintroduced something like the `Freeze` kind which would then require that everything be correctly annotated as being `Freeze` or not `Freeze`. 
I don't believe that any of the evidence that I'm argueing is wrong. That you are arguing that the evidence is wrong does not mean that it is; it just means that you think it is. Using evidence that you don't agree with does not mean that I'm making misleading statements. I don't agree with all of the evidence that you are using. Does that mean that I should accuse you of cherry picking convenient facts and making misleading statements?
You updated your comment after I responded (or maybe before I refreshed). So, I replied to your update in a new comment. I hadn't specified exactly what I meant by "aliased" and "non-aliased" which I'll admit probably made some of my arguments a bit difficult to respond to accurately. Anyway, I'll try to use the more technical defintion of "NoAlias" that you posted from now on.
Protip: use default_or map_or etc. 
Oh nice, I want the compiler to actually check that I get tail calls when I need them.
Or mongrel2 with https://github.com/erickt/rust-zmq
The Rust team has nothing against them, but they're not a priority for 1.0.
I have a Java version lying around somewhere (that should be transposable to rust quite easily) that sorts by the numeric value, then by length of each number (so that a1 &lt; a01 &lt; a2 &lt; a10). It's even quite safe - the version Dave Koelle had at the time crapped out on some examples.
Being powerful for the sake of power is emphatically not a goal for Rust. Language features that would betray the principle of "pay only for what you use" won't make the cut. EDIT: And hilariously, this cropped up a half hour after my comment: http://www.reddit.com/r/rust/comments/25xae1/rfc_81_support_for_guaranteed_tailcall_elimination/ . Hooray!
We've long pointed to https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html as our rationale for not supporting guaranteed TCE in Rust, so what's suddenly happend to change our tune? 1. LLVM has grown better support for TCE (due out in the forthcoming 3.5 release, I believe). 2. The vision of TCE proposed here has been pared down to have very strict restrictions. In future versions of Rust we may be able to loosen these a bit.
No, it's RFC 81, it's just not *accepted* RFC 81. :P The way I see it, by the time it reaches the accepted directory, it's no longer open to comments and therefore not even an "RFC" at all!
&gt; more powerful features than Rust It's not clear-cut, it has a GC so deallocation is non-deterministic. In that sense, even Haskell has more powerful features. 
Fair enough. I've gotten by without them thus far, but as I've started to read about them, they sound really cool and useful.
This is a great addition to the language, between this an by value closures the functional programmer in me is very excited.
Yes, it is only triggered when you update your code (and then it downloads the latest nightly build). It is not a perfect solution, but at least the Travis build is always using the most recent build.
Rust is rather big on not trusting the programmer. `Option` forces you to explicitly mention that you're okay with a value being nullable, and again when you expect a nullable value to be non null. For example, you could get a runtime error in the following C code: int n; int a[n]; // whoops cin&gt;&gt;n; In C++, you can use nullable datatypes in places where they're supposed to be non-null, without the compiler batting an eyelid. In Rust, if you want a nullable, you have to use `Option` -- a conscious decision. Whenever you are 100% sure that the value will be non-null, you use `.unwrap()`. Again, a conscious decision. (There also is the non-failing `.unwrap_or()`, which is sometimes useful). I look at `Result` as somewhat similar to `throws` in Java. If a method is returning an error, then you have to handle it somehow, or bubble it out -- the compiler won't let you continue without this. The added benefit is that you can use Rust's amazing pattern matching against `Result`s, instead of a long chain of `catch` blocks. Also you don't have to complicate the language with added support for exceptions when the type system in conjunction with `fail!` can handle it. 
The backtraces are rather basic, they just mention line numbers, but they go down pretty deep (both in `gdb` and with `RUST_BACKTRACE`). Debugging in `gdb` is done by setting a breakpoint at `rust_fail`
 let args: Vec&lt;StrBuf&gt; = std::os::args().move_iter().map(|x| x.to_strbuf()).collect(); It might even be possible to give the type hint as `Vec&lt;_&gt;`, but there are some issues with the type of inference required for many `.collect` calls, unfortunately. 
I didn’t like the “RFC” name for that reason—but there’s precedent for it in IETF’s RFCs. It is what it is: not an RFC yet. If accepted, it will get an RFC number, and that will be likely to be considerably lower than 81. For myself I prefer a name (and, for that matter, a process) in the fashion of PEP.
It's worth noting that last example is [likely to become illegal](https://github.com/mozilla/rust/issues/12624).
A yes, thank you! With the `::&lt;Vec&lt;StrBuf&gt;&gt;` at the end, my old method seems to work now aswell. Did not consider the type-inference system failing.
I feel like the current RFC process is fine for the moment. It's fast and loose and we'll probably outgrow it someday, but for now it's exactly what we need in that middle ground between the prior Wild West and the inevitable Design By Committee.
I meant the repository that can be used in travis builds. I don't think those can be.
`Clone` could take `&amp;self` and allow internal mutation, as long as it's not publicly visible, since a type with no public mutability when being behind a shared reference should be manually annotated as `Freeze`. I suspect `Freeze` wasn't used because without requiring it as a default, writing code that uses it would require adding `:Freeze` to every non-mut declaration with no immediate benefit. That is, code like that may be less bug-prone in the long term, but it looks ugly and doesn't let you do anything you couldn't do without it. Additionally, if types like `Rc` were not `Freeze`, adding `:Freeze` to declarations would impose unnecessary and annoying restrictions. On the other hand, I think that a `Freeze` which is required by default and denotes all non-externally-mutable-when-shared types, could be very useful in making Rust safer, in the sense of helping write programs with less bugs.
If you introduce a new trait (I call it `Freeze`, but it doesn't have to relate to the old `Freeze` in any way), it could be defined in which way you like. It should have nothing to do with other traits which are there to permit optimizations in the future. It's a new trait, which denotes types that when accessed through a shared reference expose no mutability.
&gt; Overall, I am in the functional camp. I greatly prefer to leave my variables immutable. But I also accept that some types need internal mutability in order to function. I think we actually both want the same thing: to be free from caring about mutability when possible. We both think that internal mutability is sometimes needed, and shouldn't be prevented as what is important is the public interface and whether it can expose mutations, not the implementation details. It makes me uneasy that I need to consult the API to verify that a type that I use doesn't expose external mutability when behind a shared reference. And I think that there is a relatively simple way to achieve the goal that the compiler would make this check for me, so I won't have to bother about it. Our discussion helps us find out if there really is such a way. But would you agree that *if* it turns out that it's possible for the compiler to guarantee that all non-mut values are actually externally immutable, *without* requiring too much effort from the language developers and *without* adding significant complication to the language, it would be a good thing? I hope that there is such a way. Let's see if I'm right or wrong!
They can be used just fine: [sample .travis.yml](https://github.com/SiegeLord/RustGnuplot/blob/master/.travis.yml#L8-L12).
I think that this comparison is only partial. Let's quote it here for the reference: &gt; Rust and Mezzo are in essence trying to achieve the same thing, except that Mezzo is in the context of ML. &gt; Being a high-level language gives us more flexibility: &gt; &gt; - we can afford _not_ to think about what's stack-allocated or heap-allocated; &gt; - our adoption/abandon mechanism, which somehow keeps the complexity of the system within reasonable bounds, is implemented using run-time tests; &gt; - de-allocation is not predictable because we use a GC (so no destructors). &gt; &gt; So I would say that we don't have to deal with all the high-performance constraints that Rust is tackling, which makes our life easier :-). &gt; Also, the implementation and the design is a two-man project. I think the Rust team is a tiny bit bigger now! One thing that protz did *not* highlight is that Mezzo's type system is has a clean, well-defined semantics (that's a thing I wanted to highlight with the "proved-correct" in the title), which is right now not the case of Rust. It is of course easy to understand why this is the case: maintaining a formal specification of such a rich type system is very hard (it's a research problem), even harder for a language that is as ambitious and evolves as fast as Rust. (I'm not talking about a Coq proof here, but only a honest LaTeX inference rule system with pen-and-paper proofs.) Fortunately, I heard that things are somewhat changing and that people are working on a soundness proof for a subset of Rust. Niko himself did a good first step in that direction with a [PLT Redex model of Rust](https://github.com/nikomatsakis/rust-redex). I think that Rust and Mezzo are quite complementary (per coincidence): Rust provides a very good justification to the Mezzo people that their research concerns are not purely theoretical, and that tight ownership control is actually of interest. Conversely, I think the Mezzo work (which I'm sure the Rust designers have on their radar) could also inform dicussions in the Rust community. I posted this link as a reaction to Niko's post on focusing on unique ownership instead of mutability: look, this is what is done in Mezzo -- and it works rather well.
That's why I propose a trait that would signify that a type has no *externally visible* mutability when behind a shared reference. I referred to it as `Freeze`, but I gather it's not what the origianl `Freeze` was. Let's call it `NewFreeze` for now. It should be manually added to types that contain internal mutability as a guarantee that it's actually internal, and can be automatically inferred by the compiler when a type is composed from only `NewFreeze` types. I think that it's important that `NewFreeze` would be required by default, since I think that the vast majority of types are actually `NewFreeze`. If it would be left optional, nearly no one would bother annotating all his variables with `:NewFreeze`. If it is required by default for non-mut slots and references, the compiler would force you to note when you are using one of those needed types that *do* expose mutability behind a shared reference, and you'd have to pay attention. (and indeed, I'm not interested in immutability as an optimization-enabler, but on immutability as a bug-reducer)
Ok, that works for Travis, but travis creates a new instance every time, how will fork on Ubuntu? What worries me is this. I have `Rust 0.11-pre`, but how do I upgrade tar installation to `Rust 0.12-pre`? 
I absolutely agree that having a PPA is much more preferrable to using the ad-hoc method used by the official binaries, so I'm advocating the official binaries as a stopgap measure only. That said, the official binary installer script has an uninstall command that you could run to remove the old version. I personally don't bother, and just install the new versions on top of the old versions.
I think it is just another way of writing: let my_x = point.x; let my_y = point.y;
I just thought I would throw in that this can be useful for returning multiple values from functions: fn f() -&gt; (int, int) { return (1, 2); } fn main() { let (x, y) = f(); println!("x: {}, y: {}", x, y); }
Yes, but not quite, if x and y were not implicitly copyable. It destructures point. 
Can't you do this? let my_x, my_y = point.x, point.y
Oh, yes. Tuples are actually a very nice and simple example. Thanks for reminding me!
This looks similar to Python's tuple unpacking.
`be` kind of matched `ret`, but at this point I'd probably rather read `return tailcall foo(x, y, z)`
I just did a quick check, and it seems that this syntax is obsolete. So it was supported at one point, but isn't anymore. You could do what /u/Iron-Oxide mentioned elsewhere in the thread and pack/unpack a tuple via `let (my_x, my_y) = (point.x, point.y)`. But I don't know if the tuple construction/destruction is optimized out, so from my ignorant perspective I'd expect the direct destructuring version to be more consistently performant. I might be wrong on that part though.
I'm not really a python programmer, but I'm pretty sure that what rust has is actually just a more general form of python's tuple and list unpacking. 
It will be optimised out—it’s a very obvious optimisation to make.
Excellent. I had expected so, but was unsure if there was something involved making it harder than it seems.
No, well at least not on master, that syntax is considered obsolete and results in a compile error, you could do something like let (my_x, my_y) = (point.x, point.y); But what I'm doing here is taking a structure, extracting the fields and putting them into a new structure, and then destructing that new structure. Better would be: let my_x = point.x; let my_y = point.y; This isn't really bad style in my opinion, but it can't be used nicely everywhere that destructing can, consider: struct Point { x: int, y: int } fn f() -&gt; Point { return Point{ x: 1, y: 2 }; } fn main() { let Point{x: my_x, y: my_y} = f(); println!("x: {}, y: {}", my_x, my_y); } To do this without destructing you would need to use: let point = f(); let my_x = point.x; let my_y = point.y;
Another use-case is the other way around and using destructuring in function arguments: struct Point { x: int, y: int }; fn point_sum(Point { x: my_x, y: my_y }: Point) -&gt; int { my_x + my_y }; let s = point_sum(Point { x: 23, y: 42 }); Especially in cases with simple function bodies, this can really help separate the data extraction from the actual computation.
For reference, I believe this is the relevant commit to LLVM that added 'musttail' suppport: http://reviews.llvm.org/rL207143
So we have the possibility of: Normal safe allocation-&gt;used/stored in unsafe block -&gt; released in safe block -&gt; try to use in unsafe block again? Actually this pleases me, I have all the power to shoot myself in the foot as in C, but it just seems to be harder! (I'm not being sarcastic, I like having power) So supposing I implement some datastructure unsafely like a double linked list or whatnot assuming I allocate it in unsafe and pass it out as a unique pointer or whatever, when it gets freed I can still have a deconstructor called to scrap the nodes right?
You can still use something similar though: fn main() { let point = f(); let ref my_x = point.x; let ref my_y = point.y; println!("x: {}, y: {}", my_x, my_y); } This makes my_x and my_y `&amp;~int` (shouldn't that have been changed to `&amp; box int`?), and while pedantic in this example could be useful if the structure contains more than just x and y.
I disagree, tailcalls change the semantics of return (stack growth, possibly calling destructors in the future), and they change what is allowed in the rest of the function. They should be clearly marked as different from `return` for people who don't know what a tailcall is. I also just find `become` more pleasing to read then `return tailcall`.
This doesn't mention that `Rc` implements the `Deref` trait (which apparently `Gc` doesn't). If you use the `*` operator to manually dereference, does it call `deref` behind the scenes? Are there any differences between the two?
Unfortunately, I wished to make `Cell` possible without `unsafe` but I failed. I cannot, at the moment, come up with a simple set of rules that would ensure that a data-member is not possibly aliased. `Cell` manages it because it has an extremely restricted interface; but that's about it.
If we're bike-shedding, I'd prefer `recur`
&gt; But would you agree that if it turns out that it's possible for the compiler to guarantee that all non-mut values are actually externally immutable, without requiring too much effort from the language developers and without adding significant complication to the language, it would be a good thing? I don't believe that's possible. I think every proposal that attempts to accomplish this ends up complicating the language without actually providing any extra safety.
Another question: is it possible to destructure a struct directly into fields of another struct? I tried this: let Point { x: point2.x, y: point2.y } = point1; But got: error: expected `,` but found `.` let Point { x: point2.x, y: point2.y } = point1;
OK, I think I understand. I was just confused by the use of `let` in a different manner.
True, the destructuring pattern can get pretty ugly if there're many fields, or if the fields have long names.
The Alef language has a `become` keyword and was cited by Graydon as one of the major influences. That's why the `be` keyword has been reserved for quite some time. &gt; These are surprising words for this purpose. It's a clear way of describing one function *becoming* another, since it's a combination of the action of calling with returning. I can't think of a better term for the semantics.
The `recur` keyword doesn't communicate that it's a combination of calling with returning.
Yes, in [Alef](http://doc.cat-v.org/plan_9/2nd_edition/papers/alef/ref), possibly elsewhere as well, I just found that by searching for it.
I can't imagine recursion without calling functions or returning. But /u/IronOxide mentioned this allows for arbitrary tail calls... how does that work? Tail call to a different function?
The `become` keyword would allow tail call elimination for *any* tail call meeting the requirements in the RFC, not just self-recursive functions. Recursion is certainly possible without returning *immediately* after the call, so `recur` is a misleading term for this for more than one reason.
There is sugar for binding to variables with the same names as the fields: let Point { x, y } = foo();
The rust-lang.org page gives a really good summary of Rust's features: * algebraic data types * pattern matching * closures * type inference * zero-cost abstractions * guaranteed memory safety * optional garbage collection * concurrency without data races * minimal runtime * efficient C bindings
To me rust is "C but sane". You get practically all the benefits of C, but much less of those crazy sharp edges that can make you bleed (in the heart).
Memory safety without garbage collection.
&gt; What kind of problem that Rust can solve, while the others can't or hardly solve? Less bugs (while still being efficient), a programming language that prevent all bugs is obviously impossible (unless it only allows you to make one program, and then it's just not turing complete), but Rust does a good job at catching many of the common ones, including the equivalents of Apple's goto fail, and Openssl's Heartbleed. &gt; Why do you use and choose Rust instead of the other language? - Memory safety - Strong typing, - Immutability by default - the struct/impl system (what do you call this?) - pattern matching In a low level language. &gt; What do you hope for the future of Rust? - Better functional programming: [tail call optimization](https://github.com/rust-lang/rfcs/pull/81), [proper closures](https://github.com/rust-lang/rfcs/pull/77), and a strictly opt in [Algebraic Effects](https://github.com/rust-lang/rfcs/pull/73) system - Polishing the language a lot before releasing 1.0 - Popularity (Not just because I like programming in the language, but because I think it would make the tech world more secure)
1. The main benefit over C/C++ is safety. The main benefit over Go/Java is again safety, but mostly for concurrency and a better type system. The main benefit over something like Python is speed and type safety. The main benefit over Haskell is no GC/consistent performance. 2. You can have safety without sacrificing performance. So zero-cost abstractions and less bugs. C/C++ fail at this, as evidenced by Heartbleed and my Firefox crashing from time to time. 3. I hope it completely replaces C and C++ in the future. But at the same time, it's expressive enough to write performant web scripts. Wouldn't it be exciting if both PHP and C die at the same time? 4. World domination. Everyone writes Rust except for language theorists.
Right now the standard libraries are in flux regarding `~[T]` -&gt; `Vec&lt;T&gt;` and `~str` -&gt; `StrBuf`. In the near future you can expect `os::args()` to return a `Vec&lt;StrBuf&gt;`. For the time being, the existing answers by /u/lifthrasiir and /u/dbaupp should work.
&gt; optional garbage collection It's a bit strange to have listed there when Rust doesn't have it.
In some cases improvements to bindgen can remove the need for that but it'll never be perfect. For some things you'll have to manually specify the mapping due to the complexity/style of the C library. Being able to automatically generate the common case as a part of the compilation process is still useful.
&gt; I have a distaste for golang. There's massive hype for it, tried several times to love it, but it just doesn't feel like a useful language to me What do you think is missing or wrong? (Please don't say generics)
&gt; The main benefit over Go/Java is again safety, but mostly for concurrency Could you explain this to a Go programmer (ie myself)?
Go does not have any safety guarantees for concurrent code. There is a race detector, but it doesn't catch everything and has to instrument your running program, empiricism. Rust finds data races at compile time, proof.
Go does not protect against race conditions. It does come with a race-detector; however, it cannot achieve 100% coverage. Rust resolves these issues at compile time, using its type system. Furthermore, Go also suffers from aliasability issues, again which are prevented by Rust's borrow checker. Non-existence of null pointers in Rust is also an advantage over Go and Java.
Gophers are going to be fighting the generics fight, just as we're gonna have to be fighting comparisons to Go. :) I understand the arguments for not having generics in Go, but I don't buy them. Oh, and missing or wrong: nil. No generics. A weak type system. Mandatory GC. Lack of safe concurrency. I'm happy others like Go. I just don't.
&gt;&gt; What do you think is missing or wrong? (Please don't say generics) immutability :)
I read http://static.rust-lang.org/doc/master/intro.html but it seems that you still require a mutex to sit around shared memory. Would Rust not permit compilation without the mutex?
&gt; I understand the arguments for not having generics in Go, but I don't buy them. I appreciate that, but it's hardly an argument to be made when it's explicitly not supported &gt; nil Could you expound on this point?
If it stays ;P (I hope it does)
Hmm, agreed. /u/nick29581's "Memory safety without garbage collection." is probably a better way of phrasing it.
Other questions: can you use macros at the toplevel(to expand to enum/impl declaration)? I've added a from_int to be used instead of the initializer syntax so RI(500) will be invalid but this still allows you to construct invalid RangedIntegers, is there a way to prevent this(while still allowing pattern matching)?
Back when every other person wanted to bring up the comparison to Go, it seemed like the consensus was that it was a bad comparison. Obviously, both are general purpose programing languages, and thus can do all the same things, but not in the same way, since Go is not a "systems language" in the same sense that Rust is. Hence, it might be totally reasonable to use both for different applications. I also think it's important not to use the deficiencies of other languages as the main benefit of Rust. This is more about delivery than the actual content though. Don't define Rust as what other languages are not, but let it stand on its own because Rust has a lot going for it without having to put other languages down.
Having types that are nullable by default can cause lots of bugs. In Rust you have to be explicit when you want a value to be nullable (using the `Option&lt;T&gt;` type), and you have to handle that null case whenever you access that value.
Yes, they're not supported, but they could be. It's valid to criticize a language based on the features it lacks, ESPECIALLY the ones that were considered and rejected. As for null, it's that it exists at all. I'm on mobile, but google 'my billion dollar mistake' for the creator of null references discussing why he shouldn't have.
It's more that Rust does not allow you to send aliasable memory across a concurrency boundary. You can use unsafe to build abstractions that, for example, enforce all changes go through a mutex if you NEED shard mutable memory. 
You would run a standalone bindgen tool or make them by hand.
Well, it is intended to have garbage collection via Gc&lt;&gt;, it's just not implemented yet.
For me, it's error handling. When 2/3 lines of my code are about "what happens when this function fails", it's really hard to figure out what's actually going on. Rust seems to have less of that simply due to its stronger type system; it's easier to build functions for which they simply won't compile given invalid input. When errors can happen, Rust provides for a better experience managing them, IMHO.
...and this is a comment on a link to add a bindgen! macro to rust-bindgen.
My use case: real-time control systems for robotics. I am looking for a language that is: * fairly fast -- If it's 10x slower than C++, I'm not interested. A few times slower is fine. * deterministic -- Avoidable GC, no unavoidable memory allocations, etc... * Higher level than assembly So far, the only popular languages satisfying all criteria above are C and C++. C doesn't support many modern programming paradigms, such as OOP, generic, and functional programming. C++ supports them, but maintains a fair amount of cruft from C (I believe header files are purely code duplication). Rust promises to have performance comparable to C++, optional garbage collection (and I can avoid GC in the realtime thread while using it in other threads), and is a modern high-level programming language, which makes it a viable replacement. Here are the reasons I believe Rust will replace C++ as my language of choice once it stabilizes: * Better build system -- I really like Rust's build system. C++ makes you maintain the build system in parallel with your code; Rust integrates it into the language itself * Safety -- This is obviously beneficial to most types of software development. In robotics, software crashes can cause "real" crashes * Syntax/Semantics -- I much prefer Rust's syntax (and language semantics) to those of C++ I believe that C++ is a very well designed language, but its design is somewhat outdated and it carries around some amount of cruft. Rust promises to provide capabilities I find necessary in a more modern language.
I think you can do something similar with macros, but it's not nearly as elegant, in my opinion. I've wanted to be able to use primitive types in type parameters for so long.
&gt;I would suggest foo(a,b) resolves the same as a.foo(b) I would propose that too. So naked impls can be used to overload an identifier without a trait? Didn't think of that. That's certainly a tangible benefit.
(I think you need a blank line before/after a list for it to be rendered correctly, e.g. I am looking for a language that is: * fairly fast ... * deterministic ... etc.)
&gt; Would Rust not permit compilation without the mutex? Correct. Rust doesn't permit compilation without the mutex.
The reason I was attracted to Rust was that it seemed like a replacement for C, with a modern syntax/semantics but applicability for very-low-level work. IOW, a C replacement with static typing, immutability, more sugar and safety without GC that presumably could do both systems and embedded work. I really like match statements and the algebraic type notation. Rust manages to avoid Java's verbosity and Haskell's terseness. That said all my real-world work is with high-level stuff processing documents and the like so it'd be nice to see regex, XPath, SQL, PDF libraries and the like. Also 1.x so I wouldn't need to review the changes to the language all the time. It'd also be nice to see some stronger functional stuff, like TCO, list comprehensions/LINQ, etc., although I realize that's already been considered and bikeshedded. And I'm kind of stupid--I'd like to see some more in-depth tutorials showing "intermediate" use.
You can have data races in Go, but Rust is made with safe concurrency in mind. Just the existence of a tool that detects data races in Go means it's inherently unsafe.
I doubt you can do generics over values in rust, thats why I thought BoundedInt syntax might need to be added, unless macros can be used to create types. Also like I said I'm not quite sure about the point of bounded types but I think the point is that the bounds stay the same as you compose them(since certain values are invalid) for certain things this would make adding from 2 different types rare.
I am mostly lurking around the fringes of Rust for now, trying to learn some of the core concepts like pointers and the functional programming constructs from other, more stable languages while waiting for 1.0. But what makes me *really* excited about Rust is the possibility that it could outperform C and C++ by communicating aliasing information to the compiler automatically. dobkeratops already touched on this with "the noise of 'const restrict' ", but it's actually more than just an issue of noise, because C/C++ compilers cannot generally use the type system to check the correctness of `restrict` qualifiers. In my ideal world, Rust will apply and check these optimizations by default, and make mutable and especially aliasable types the opt-ins with special qualifiers. So where others have made the comparison to C/C++, I like to think of this as a kind of FORTRAN with modern syntax and programming paradigms.
To back up my point a little, here's a bit from Frances Allen's ACM Turing Lecture where she laments C's aliasable-by-default model. "Beyond a doubt, that was a huge setback for languages and compilers, and the ability to deliver performance easily to the user." https://www.youtube.com/watch?v=NjoU-MjCws4#t=41m03s
I'd probably rather read : `#[tailcall] return foo(x, y, z)`. Annotations seem the natural way to do this to me. 
&gt;I disagree, tailcalls change the semantics of return (stack growth, possibly calling destructors in the future) I'm not sure this argument is valid since tailcall optimisation can already be performed with the return keyword, even if it is not guaranteed yet. So the semantic of return is already changing when compiler performs the optimisation.
I've updated it https://gist.github.com/rtaycher/138f188ba9444e59f621 Now it uses a macro https://gist.github.com/rtaycher/138f188ba9444e59f621 to create ranged types make_range_int_type!(RangedIntNFiveToFive RINFiveToFive OutOfRangeNFiveToFive -5 5) 
&gt; the struct/impl system (what do you call this?) Nominal records and type classes?
I thought `Vec&lt;T&gt;` and `StrBuf` are supposed to be the dynamic growable versions of `~[T]` and `~str`, but now it seems that every `~[T]` and `~str` gets replaced. Wouldn't it be appropriate to keep most `~str` in function parameters since they never change its contents? Actually I can't imagine why one would want to use `Vec&lt;T&gt;` or `StrBuf` as a parameter (except for mutable references maybe). Did I misunderstand the purpose of this conversion?
It looks like on the mailing list you're thinking 7-9pm? Although I don't have any active rust projects, I hope to make it!
The main idea here is that creating a owned vector/string usually starts with a `Vec` or `StrBuf`, and that converting it to a `~[T]` or `~str` afterwards is worse than just returning them directly. The reason its worse is because you lose any potential additional capacity, and due to the way allocators work it has to call `shrink_to_fit` on the allocation, which is a `O(n)` reallocating operation in the worst case. So, because of that and to make the common case not more confusing by having two different types, we just standardize on `Vec` and `StrBuf`.
Can the annotation go on the function declaration? Is that more idiomatic? Curious!!!
Could you point to the place in the docs this is described?
So, if I understand correctly, a type that has Cell embedded in it can only be shared through a Mutex? (In safe code.)
No algebraic (safe union/enum) types.
It's not described anywhere, it's just that we have fixed-length arrays that can be used to work around the lack of generics over values.
The repositories are now moved to an open source organization called "PistonDevelopers". This makes it easier to add new collaborators and prevent commits directly to master. Piston now supports both GLFW and SDL2. The progress last week has been awesome. We are planning to release a 0.1 version as soon as we got something usable. Thanks for all the contributions!
Looks cool! I like the example on the front page. The words `impl Game for App` just sound _right_ somehow ;)
Congratulation, I was thinking of write and/or contributing to a project like that.
This is a known issue, and will probably be fixed at some point. But there are a few different way to implement it, a few uncertainties about how powerful it would/should become, and it's not really a 1.0 blocker, so its not currently in focus. Possible solutions: - values in the type system: `fn foo&lt;static N: uint&gt;(a: [T, ..N])` - associated constants: `fn foo&lt;N: StaticValue&lt;uint&gt;&gt;(a: [T, ..N::VALUE])` - special case array arity: `fn foo(a: [T, ..*])`
Yes.
what version of LLVM do you have? I remember on debian sid trying to install the normal llvm package gives weird errors but if I installed a specific version aka apt get install llvm vs apt get install llvm3.5 perhaps try a different version
The last thing you want is rusty pistons ;-)
Isn't that what ~[T] and &amp;[T] are for? To be able to operate on an array of an unknown size?
Different use case: Those have dynamic sizes, and have to life behind a pointer. `[T, ..N]` is unboxed with a fixed size.
You mean: `BoundedInt&lt;[Negative,..128],[Positive,127]&gt;` ? This sounds like a neat hack, however can you specialize the structure with some rules to get the smallest possible integral type (among `i8`, `u8`, `i16`, ...) that can contain the number ?
*low level language* sounds bad, it makes people think about C. I wonder if we could turn it around ? Like "low-level accesses in a high level language" ?
That error message makes it look like your system doesn't have any C++ compiler, which is necessary to build LLVM. You say that you have all the dependencies, how did you verify this? If you type `g++` into the console, what does it say? Note that if you don't care about modifying the compiler's source code, then you can install a precompiled version of the compiler from here: http://www.rust-lang.org/install.html
I had a crack at installing it on windows 7 (I've duelbooted) and I've got it working now. If I find the time and patience I'll have another go at getting it working on Linux, That LLVM seems like the problem since all the dependencies are definitely installed. Thanks for the help anyway :-)
I'll be there!
IIRC there is a RFC to allow attributes on expressions.
Nice! Very similar to the ES6 flavor
What I do as a temporary work-around is to use the `as_slice()` function. Maybe it can be useful for you as well.
&gt; not flexible enough, but I can't remember why exactly It almost certainly works for implementing traits like `Show` and `Eq` etc, which would be really nice and much better than the situation we have now. (Probably not enough for `Clone` though.)
Well, we want them to think about C. ;) We've been saying "high-level bare metal programming" a bit, and it sounds kinda okay.
&gt; I expected the same for Rust but I understood that will not be the case unfortunately. For now. There will be a much better one once the language is actually finished.
The None from your List1 enum is overriding the None from the Option type.
Thanks. I understand that, but how do I prevent that from happening?
Can't the compiler provide a warning in that case? If the.compiler can, then why not make that warning an error?
A little bit sad that we're postponing tail-call elimination for now, but realistically it's not like LLVM will even be ready to support musttail on all of our supported platforms for a while yet. I think LLVM aims for twice-a-year releases, which would mean that 3.5 would be released in a month or so. If support for no other platforms beside x86 land in that period, then it would be another half-year before any more platforms support musttail in a stable LLVM release. And then consider that rustc tends to lag behind in LLVM releases anyway...
You can either rename the `None` variant of `List1`, or you can stick `List1` in a module of its own and then refer to the variant as `foo::None`.
&gt; Wouldn't it be exciting if both PHP and C die at the same time? Add Java to that list and I'll join your army.
Oh god, yes. Axe list: * Java * C/C++ * C# * PHP I'd add more, but they're not popular enough.
You, sir, win for most unpronounceable username.
I think it's probably best to avoid calling it None altogether, given that None is defined by the Option enum and is in the default namespace. The tute uses Nil, probably partly for this reason. This also makes me prefer the struct version.
Is it common/encouraged in Rust to do wildcard style imports? While this is allowed in Python it is heavily discouraged which is something I've found super useful, especially when using libraries for learning. In the frontpage example I don't know where Game, Gl, and Context come from so I have to check both modules. Obviously not a huge deal in this example but in larger code bases I feel like it increases the overhead to learning.
Glob inports are discouraged and are currently behind a feature gate. This is because they can cause problems such as circular and ambiguous imports. In addition, as you say, it is hard to work out where things are imported from.
Thought you may find this interesting - an implementation in D: http://wiki.dlang.org/Creating_a_subtype_using_struct_template 
I had the same problem on an old Ubuntu machine. The solution was to install the nightly build instead. Not what you want but it might fix a few annoyances.
On a side note, boy is that `Box` syntax ugly. // old ~ syntax struct List2&lt;T&gt; { data:T, next:Option&lt;~List2&lt;T&gt;&gt; } 
If there would be *Trait-bounded return types*, can the Iterator trait be updated so that all its adaptors return just some Iterator? That would make it possible to meaningfully override them.
Cons and Nil are like *foo* and *bar* or Alice and Bob, they are a well-known duo. Cons and None just doesn't rhyme, so it has to go no matter what ;-) On a more serious note, Option is a very useful algebraic type, and by embedding it you often don't need to create any algebraic types of your own.
No, it probably can't work for trait methods without some unification. This isn't like a trait object, it has to be the same type (at most generic over the type parameters of the function returning it).
I am wary of this. Whilst C and C++ developers would be intrigued by the claim, and soon realize undefined behavior got kicked out of the window, I am afraid developers from higher-level languages risk identifying Rust as "another low-level language" and shrug it off because they build web-application not OSes or device drivers. Rust is *so much more* than C!
In the limit for power -&gt; infinity this generalizes to full dependent types.
Using [Wikipedia's Dependent type](http://en.wikipedia.org/wiki/Dependent_type) definition, I would say *no*. C++ has non-type template parameters without supporting dependent types.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Dependent type**](https://en.wikipedia.org/wiki/Dependent%20type): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science) and [logic](https://en.wikipedia.org/wiki/Logic), a __dependent type__ is a type that depends on a value. It is an overlapping of feature of math-encoding [type theory](https://en.wikipedia.org/wiki/Type_theory) and bug-stopping [type systems](https://en.wikipedia.org/wiki/Type_system). In [intuitionistic type theory](https://en.wikipedia.org/wiki/Intuitionistic_type_theory), dependent types are used to encode logic's [quantifiers](https://en.wikipedia.org/wiki/Generalized_quantifier) like "for all" and "there exists". In [functional programming languages](https://en.wikipedia.org/wiki/Functional_programming_languages) like [ATS](https://en.wikipedia.org/wiki/ATS_(programming_language\)), [Agda](https://en.wikipedia.org/wiki/Agda_(theorem_prover\)), [Idris](https://en.wikipedia.org/wiki/Idris_(programming_language\)) and [Epigram](https://en.wikipedia.org/wiki/Epigram_(programming_language\)), dependent types prevent bugs by allowing very expressive types. &gt;Two common examples of dependent types are dependent functions and dependent pairs. A dependent function's return type may depend on the *value* (not just type) of an argument. A function that takes a positive integer "n" may return an array of length "n". (Note that this is different from [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science\)) where the type is an argument.) A dependent pair may have a second value that depends on the first. It can be used to encode a pair of integers where the second one is greater than the first. &gt;Dependent types add complexity to a type system. Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence [type checking](https://en.wikipedia.org/wiki/Type_checking) may become [undecidable](https://en.wikipedia.org/wiki/Undecidable_problem). &gt; --- ^Interesting: [^Epigram ^\(programming ^language)](https://en.wikipedia.org/wiki/Epigram_\(programming_language\)) ^| [^Type ^theory](https://en.wikipedia.org/wiki/Type_theory) ^| [^Type ^system](https://en.wikipedia.org/wiki/Type_system) ^| [^Intuitionistic ^type ^theory](https://en.wikipedia.org/wiki/Intuitionistic_type_theory) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chneq1u) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chneq1u)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Yes, something like that (that's basically how the `.len()` method works on arrays now).
Dependent types are like templates where the arguments can depend on *run time* data as well as compile time data. That's why I said "In the limit for power -&gt; infinity this **generalizes** to full dependent types."
The reason I am using global import for Piston is that I want to have a minimal example that does not break ;-) For Rust-Graphics, this is a bit different. Rust-Graphics uses a lot of types which are in flux right now and these types are rarely used explicitly. I guess for Rust-Graphics it is ok to use it, since it is an API with exceptionally many types and unpredictable use. We don't use global imports internally in Rust-Graphics, because by the general rule it is a bad thing. I will check the Piston source for unnecessary use of global imports and make a note for this for later when me make tutorials. Thanks for the feedback!
I've updated the example. Removed the global import for Piston. Thanks for noticing!
Hah, it still need text to display score.
I don't think there needs to be any complexities there beyond "reject any tail-calling functions whose locals attempt to run destructors at the end of the function". A subset of current semantics is much easier to understand than a whole-new alternate semantics (such as implicitly running destructors early). As mentioned in the RFC, people are free to wrap variables that need destruction in an explicit block as a workaround. As for unforeseen issues, the best way to determine what those are is to implement it and find out ourselves. :)
If you think that's bad, I have an `Rc&lt;RefCell&lt;DList&lt;Arc&lt;Box&lt;Player:Send+Share&gt;&gt;&gt;&gt;&gt;` in one of my programs, and as far as I can tell every one of those types is necessary in order to declare a task-local reference-counted pointer to a mutable linked list of immutable global trait object references.
As far as I know it was scrapped in order to make the rules simpler by always inheriting mutability.
See also http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/
Isn't this what typedefs are for? type TaskLocMutListRef&lt;T&gt; = Rc&lt;RefCell&lt;DList&lt;Arc&lt;T&gt;&gt;&gt;&gt;; type Players = TaskLocMutListRef&lt;Box&lt;Player:Send+Share&gt;&gt;;
INHTWAMA! I thought I'd never utter that butchered acronym again. It seemed like such a fine solution at the time, but in the end it was really still just attempting to paper over the problems with `@` rather than admitting that it really didn't jive with Rust's developing philosophy.
I've been meaning to typedef it, but just haven't gotten around to it.
What does this add over what you can do today with generics? trait MakeLi { fn make_li(&amp;self) -&gt; Li; } impl MakeLi for Box&lt;Node&gt; { fn make_li(&amp;self) -&gt; Li { /*...*/ } } impl MakeLi for &amp;'static str { fn make_li(&amp;self) -&gt; Li { /*...*/ } } fn li&lt;T: MakeLi&gt;(content: T) -&gt; Li { content.make_li() } let item1 = li("not a link"); let item2 = li(box a("link", "http://www.rust-lang.org/")); From what I can tell, the people clamoring for function overloading actually care about what to do when you have *multiple* arguments, which, using the above method, would force you to implement `MakeLi` on a tuple, and then force users of your API to call your functions with a single tuple as an argument. I feel like an approach that somehow allows implicit tuple unpacking would be the least magical way of accomodating this.
Ah, I had interpreted *this generalizes to full dependent types* as *this change gives full dependent types to Rust* :/
In retrospect, I'm amused at how more than half of the questions on there have been obviated by features being added or removed. I think that's a good sign, it means that the language is apparently becoming more self-explanatory. :)
There's the double-dispatch pattern aswell for multiple arguments, closer to real overloading but (a) its quite boiler-plate heavy, (b) as far as I can tell its a closed set of methods/types (you need to include the types in one dispatcher) can syntax extentions help? i thought about trying to make a macro to setup double-dispatch. Rust is usually a step forward vs C++, but my perfect langauge would have generalized overloading and UFCS instead of any sort of special receiver (symetry between all arguments) 
There are a few other uses for this feature besides arrays, so the first option seems best.
I proposed that a special reference would be needed to refer to these types, and so using the regular reference would be an error. Without it, referring to them is legal just as referring to regular types.
"Event will be delayed due to technical issues" Any details?
The A/V system in the room is malfunctioning. We'll try to do it another time.
i'm pretty sure you could make a static analyser for C++ to do the same job, its just most existing C++ programs would have huge 'unsafe footprint' , and it might need some hack for annotating lifetimes? (some people speculate lifetimes might eventually be inferable?)
We did attempt to record the talk. If it comes out well we'll post it later.
There is a typo in `He focuses on safe support for parallelism in prorgramming languages` (prorgramming). I am waiting to see the video!
Nice code. The approach seems like a bit of a hack (in a good way), but I'm happy that it's possible to make the nice syntax work for the caller, at least in the simple case. Unfortunately, that approach quickly gets unwieldy for double-dispatch, or if you're writing a method where `self` can't be co-opted. Here's another possible use case.. my approach: enum Timeout { Finite(int), // or some kind of TimeDelta type Infinite, } struct ItemKey; struct DataStore; impl DataStore { fn get(&amp;self, key: ItemKey, timeout: Timeout) { /*...*/ } } Current Rust: trait Timeout { fn data_store_get(&amp;self, data_store: &amp;DataStore, key: ItemKey); } impl Timeout for int { // or some kind of TimeDelta type fn data_store_get(&amp;self, data_store: &amp;DataStore, key: ItemKey) { data_store.get_finite(key, self) } } struct Infinite; impl Timeout for Infinite { fn data_store_get(&amp;self, data_store: &amp;DataStore, key: ItemKey) { data_store.get_infinite(key) } } struct ItemKey; struct DataStore; impl DataStore { fn get(&amp;self, key: ItemKey, timeout: Timeout) { timeout.data_store_get(self, key) } fn get_finite(&amp;self, key: ItemKey, seconds: int) { /*...*/ } fn get_infinite(&amp;self, key: ItemKey) { /*...*/ } } It's subjective, but I'm not a fan of how, in both the original example and in this one, you have to bend and contort your code around the varying argument. Then again, as long as you're not writing a DSL, the extra `enum` construction probably won't kill you.
Not to mention that generics allows for collections libraries that don't leak internal abstractions like c++
I don't consider generics rusts strongest part, but sure even in their current state they help significantly.
The LLVM issue doesn't really matter because feature gates exist for that reason. The `struct` inheritance feature was added to Rust behind a feature gate despite it being very controversial and involving more complexity than this.
INHTWAMA seems like exactly the current scheme we have (with `@mut`/`Mut` replaced by `Rc&lt;RefCell&gt;`)... `&amp;mut` is non-aliasable, and borrows are dynamically checked.
Even when you're writing DSLs, I think I'd prefer the explicit enum construction. `ds.get(key, Finite(10))` is self-documenting in a way that `ds.get(key, 10)` is not: it suggests to the reader that the second argument is more elaborate than a mere int, and from the naming alone I could easily guess at the existence of a variant named `Infinite`, rather than having to rifle through the docs. Though in this specific case I think I prefer the second API, `get_finite` and `get_infinite`. Combinatorial explosion is one thing, but an enum for just two cases is overkill here when multiple functions will suffice. This is a touchy subject because it's actually one of the reasons I'm reluctant to have function overloading in Rust, as useful as it is: IME it tends to encourage crummy and opaque APIs. But now we're both getting knee-deep into subjectivity. :P
Yes, as I mentioned above there are echoes of the old problems present in the current discussion over mutability. The reason that I *don't* think they're exactly equivalent to what we have today is because 1) library types are less visible and less implicitly-encouraged than language built-ins, 2) the exceptions that `Cell` makes in the type system are explained via existing mechanisms (`unsafe`) rather than bespoke ones, and 3) `Cell` and `RefCell` seem far less ubiquitous than `@mut` ever was (though it's entirely possible that I'm just out of touch here).
Personally, I prefer struct List&lt;T&gt;(T, Option&lt;Box&lt;List&lt;T&gt;&gt;&gt;);
What use case do you have in mind?
watching the recorded stream. nice water bottles!
The video is up now.
Tuple structs are a horrible way to define a struct for accessing data: they require pattern matches for everything, rather than allowing `foo.data` or `foo.next`.
Note the requirement for `Box` is just a bug, specifically, the DST bug: in future `Arc&lt;Player:Send+Share&gt;` should work.
Yes, there's some syntactic differences and some implementation differences, but the overall semantics are nearly identical. I still think it appears a lot in modern Rust. In particular, INHTWAMA gave us the `&amp;mut` we know today, and `&amp;mut` is really what makes Rust the language it is. Basically, in my mind, saying that INHTWAMA was just papering over problems with `@` is implying that Rust is still just papering over problems with `@` because I don't see any fundamental difference between the language INHTWAMA describes and the Rust we have now. (To be truly precise, the "surface" problem it was addressing is one with how the old `@mut` worked; an immutable `@` is fine, we will have that forever as `Rc` and maybe `Gc`, as are dynamically checked borrows, which we will also have forever, in the form of `RefCell`.)
I think we're kinda talking past each other (partially because I'm not explaining very well), I'm addressing your original point that "it seemed like a fine solution at the time" as if it's *not* something we have now, but in distilled form, INHTWAMA is "`&amp;mut` are non-aliased pointers". I.e. exactly what we have now. (The stuff about `@mut` in the original proposal is just a consequence of `&amp;mut` being non-aliased.)
Crap, I'm on mobile, accidentally submitted and can't edit posts there. The other point should be: * default function/init arguments
I get no video on ffox os. Should put it on youtube.(!)
It needs to stop changing And it needs a clear statement saying what's integrated with the toolset provided by the Rust team, particularly as regards distribution of libraries In Python and OCaml, for instance, there are third party tools that are basically essential, but since they're not bundled with the language, the language maintainers might not want to endorse a particular tool. This means the community de facto standardises on something which can't be mandated, and it's all a mess
I downvoted you, because if you don't change language before 1.0 ships, when will you fix the biggest mistakes? 
IMO the Rust probably needs following things: * Proof that type system works, sorting out any bugs in implementation * Libraries for time/formatting and others from the wishlist * A rust version of `go fix` * A solid package manager EDIT: * Hopefully adding the proposed inheritance of structs and dealing with any problem that might arise early on * Purging `@` and friends from the Rust compiler 
Oh no! You lost a meaningless point in a fabricated system of determining consensus on an internet forum, oh the huge manatee. &gt; And become serial killers People need excuses for their hobbies :P 
Good points. I would add: * formal proofs for all unsafe code in the standard library * formally defined semantics Of course while the language still changes there is little point in starting to address these points... A `rust fix` doesn't seem that useful to me. 
What would you define as a reasonable size?
Metaprogramming which is as powerful as C++'s, albeit with a nicer syntax. 
[3. profit](http://youtu.be/tO5sxLapAts)
That was a great talk! I also noticed the difference from earlier talks that aliasing and mutability are now more in focus than dangling pointers. This is a good thing because people who have not programmed with pointers might not understand why they should bother learning Rust. Aliasing and mutability are two concepts you have to learn in order to understand Rust at a deep level. It affects how you design data structures and helps to reason about the code. This is one of my favorite things with Rust, because one can use the rules to guide the thinking process. Usually the data structure that fit the safe rules also avoids other subtle costs that are hard to see. It makes it easier to see the tradeoffs because the context which the types are used are much narrower. Learning these concepts can help you become a better programmer and help you spot patterns that you never would see otherwise!
Some commenters at HN did mentioned they want a way to prevent style bike-shedding by having a `rust fix` tool. It's a good enough reason in my opinion. &gt; Of course while the language still changes there is little point in starting to address these points That's why I kinda wanted proof of type system. Because hopefully a good enough proof might shed light what correct path is.
Doesn't it have macros? I'm not intimate with metaprogramming in C++ but in Rust, you can actually plug stuff into the compiler.
Personally, for rust code, &lt;200 lines.
There was already [an RFC](https://github.com/rust-lang/rfcs/pull/47) about friend modules which was rejected because the current tools are sufficient. While it is true that they are, it is incredibly disruptive, messy and non-DRY it is to actually do it that way. Friend modules would be a far more natural solution to this and I hope it gets revisited (perhaps better reasoning might help... the original proposal doesn't go into how the current tools are utterly unsatisfactory).
I'd like a tutorial/book that teaches Rust as a first programming language. Surely it can do better than C in this regard?
&gt; Proof that type system works Let's not forget about a proof that the grammar is LL(N) for a reasonable value of N. I think cmr is working on that right now.
I think the missing point is *non-type parameters* for parametric types/functions. For example, I can write a `unit&lt;int, int, int, int, int, int, int&gt;` based off the 7 elementary units, and then: - `using distance = unit&lt;1, 0, 0, 0, 0, 0, 0&gt;;` - `using duration = unit&lt;0, 1, 0, 0, 0, 0, 0&gt;;` and have the compiler type check that `dist / (dur * dur)` has type `unit&lt;1, -2, 0, 0, 0, 0, 0&gt;` which is an acceleration. Of course, it's possible today with Rust if you define types yourself (`Zero`, `One = Succ&lt;Zero&gt;` and `MinusOne = Negative&lt;Succ&lt;Zero&gt;&gt;`, ...) but honestly that's painful... and the errors messages get grating :x And yes, I do realize it requires a lot of work; after all, C++ templates are Turing Complete...
That doesn't bother me. 
https://github.com/rust-lang/rfcs/pull/48 solves #1
Python style default arguments in functions, or some form of method overloading is my only gripe (just started playing with Rust, most things are awesome so far).
Exposing ownership and aliasing might make it hard for a complete beginner to get anywhere. (But I'm not really sure: I've never tried teaching someone Rust as a first language.)
I wonder if it would be possible to have a more restricted kind of template metaprogramming, like a total functional language with guaranteed termination. But yes, some features of C++ like overloading and templates that are convenient and introduce no run time overhead, would be nice.
Hopefully without the surprising persistence which occurs with mutable default arguments in python!
what about newtypes and operator overloading?
Thanks for a really elaborate answer! +1
&gt; Some commenters at HN did mentioned they want a way to prevent style bike-shedding by having a rust fix tool. It's a good enough reason in my opinion. That's `rustfmt`, not `rustfix` :) I started hacking on a `rustfmt` ([source]) using the `clang-format` algorithm, but I've only sunk a few hours into it. I do agree that it will be important, especially for Servo. [source]: https://github.com/pcwalton/rustfmt
* A better macro syntax, and less reliance on macros to express what is difficult to express otherwise. * static generic parameters. [RFC 56](https://github.com/rust-lang/rfcs/pull/56) * Option methods for calling a (possibly mutating) function on the wrapped value, without returning it. It's a small thing, but I would use it all the time, whereas I rarely use the current alternatives .mutate() and mut_ref() for other purposes. 
&gt; That's `rustfmt`, not `rustfix` :) I thought it was `--pretty-format` :P Actually idea was to have a tool that works as `go fix`, that both fixes the incorrect indentation (I might be wrong about this), pretties the format and can automatically transfer old Rust code into new. That would be really awesome for Servo. 
Who teaches C as a first language? Torturers? I self-taught C++ as my first language about ten years ago; that and straight assembler are the only first languages I can think of which are worse than C. Don't get me wrong, I'm a fan of meeting in the middle with programming education: learning e.g. Python and C to understand the bigger picture. And maybe a smart adult could handle starting with straight C. For the most part though, I think people do much better starting with a high-level language so they can focus on abstraction and design without being distracted by the complexities of low-level implementation and performance.
As someone who is currently writing a master's thesis on Metropolis light transport and who finds Rust's concepts rather fascinating, this looks really interesting. I've been thinking about writing a simple path tracer in Rust myself in order to learn it. It is definitely something that I'll check out once I have some time at my disposal, thanks for sharing. 
There's an effort in LLVM land to make GC with LLVM better. Doesn't make much sense to do anything before that happens. 
Well, C++ has dependent types in the sense that types can depend on terms, it’s just that those terms are restricted to the compile time language of templates—which is to say types and integers. So you might say it lacks *full* dependent typing.
I do like iterators written as fns. General coroutines would be even better, with a wrapper to turn them into iterators. Even more generally would be delimited continuations. I'd love to see Rust's take on that. Simple dependent types for integer ranges and array sizes would be amazing. This is essentially a generalization of C++'s values-in-template-arguments. Higher-kinded types would also be nice. Better procedural macro syntax, more like how Lisp macros work. There's no divide there between "regular" macros and procedural ones- you just put unquoted code in the macro definition and bam.
Normal for(int i =0; i &lt; 100;i++) (why not rename iterated for to foreach?) and of course ++,-- open gl tutorial?
You can read the request as a need for 1.0, instead of as a need for stability before 1.0. Is 1.0 still planned for 2014?
Cool!
IMO learning C before C++ is a good idea, modern C++ style is supposed to hide pointers and allocations but I think you'll have a better idea of what should be possible if you've dealt with them manually. I realise many say the exact opposite :) See the whole business of ~ vs Box&lt;T&gt; in rust, they wanted you to type more to avoid getting the wrong idea about allocations ... if you learned a language where you must allocate manually, that would also be a good education. bear in mind there are niches where even dynamic memory allocation isn't suitable :)
I think engineers often learn C first, and switching to Rust (or indeed anything appropriate which encourages safety and proper design discipline) would improve the quality of embedded software engineering ...
kind of a shame both the words 'for' and 'loop' are taken. I suspect they'd say emulating a C loop is a job for a macro. can always call it 'for_loop!' i guess. you've always got 'for i in range()', and .enumerate and so on.. so i think they're right to use 'for' this way I miss the do/for sugar, i'd have preferred that over the current dedicated for. (apparently not being able to return from inside was a problem, but i'm sure that could have been dealt with another way) 
why? i think they got rid of it because it’s basically another way to write while loops, with less obvious rules. you can do everything in the three cells in for loops and those expressions get evaluated in strange ways (at the beginning, before each loop as test, after each loop) that, and assignments in expressions (like ++) are silly.
That sounds very cool! This is actually what I wrote for my 3rd year project and I'm hoping to be doing something similar to you next year.
To be clear, in the future, is an official http package (for example) will be included in an extra library, which is more or less officialy maintened and shipped with Rust?
Hi all, I'm studing Rust for my little programs and for my fun. I have noticed that Niko in the slides' code uses the index operator for Vec&lt;T&gt;. Is there an intention to implement this in the near future? Thank you. R.
Oh, awesome! I've been reading the book (Physically Based Rendering, for anyone interested) on and off for the last couple of weeks, it's really good. Would you mind sharing your progress?
'inherit use' might make dividing modules up less painful (personally i'd like that to be default ,cancelled with 'priv use'
IMO Rust is very bad as a first language IMO, worse than C in this regard. Reasons: - All the complex memory concepts, ownership and all that stuff, you need to understand them when learning Rust, newbies can't. - Rust's type system is not straightforward like C, there are so many little bits you need to grasp, again, complex for newbies. Rust is good for experienced system programmer, but too hard for newbies IMO.
OK, maybe not as first language, but as a first system language. Like, for someone who never wrote in C.
hmm. perhaps rust and C++ are already on a par - C++ powerful templates, limited macros - Rust - adequate generics, powerful macros .. its just us C++ programmers have 'macro' burned into our heads as "evil"
could associated constants be computed and propagated - e.g. to implement a fixed point type where the shift value is calculated and returned; would they be as convenient to instantiate; is there anything on github discussing this alternative, i'd be curious to see. would associated constants be easier to implement?
sometimes embedded software doesn't want any form of dynamic allocation. you could argue rust is too high level
One thing I've been wanting was non blocking methods for accessing data from futures. (and by extension reading files, web requests etc) Now what the best way of doing that is a whole nother thing but off the top of my head, (from bad to least bad) you could do events, callbacks, promises, an async keyword or something else. 
It's a nice book. What I did back then was to port the whole thing to C#, just for the fun of it, and now to rust. Due to my masters thesis I'm lacking the time to keep up lately, but here you go https://github.com/Kintaro/rbrt
Just like with C, you can start with the basic stuff, no? Variables, loops, functions... Then move to the more advanced things...
interestingly i do think classic C for loops are easier to write, compared to searching through documentation to find the right named entities that do what you want. (you just learn a few pieces of syntax, then compose them to do anything you want). I wish there were tools to help with discoverability, the answer is probably in things like hoogle , i've also seen something for clojure where you supply an input &amp; output literal , and it tries all the functions to find if anything does what you asked..
I just finished my 3rd year of college and we essentially started with C. First semester of first year we done basic HTML, second semester was Processing. The from the start of second year to the end of third year it was only C. I'm doing Electronic and Computer engineering so C was the logical place to start. No-one in my year (~40 people) has had too many problems learning C. Next year we'll be doing higher level programming (Java/C++).
We'll get there...
It's **actually** `--pretty`. ;) &gt; that both fixes the incorrect indentation (I might be wrong about this), pretties the format This is `gofmt`. &gt; can automatically transfer old Rust code into new. This is `gofix`. At least to my understanding. Maybe `gofix` happens to call `gofmt` first.
&gt; Proof that type system works Niko and someone else are working on this. &gt; A rust version of `go fix` I actually don't think this will be a big deal, since we're committing hard to SemVer. &gt; A solid package manager In progress: http://github.com/carlhuda/cargo &gt; Purging @ and friends from the Rust compiler https://github.com/mozilla/rust/pull/14250
Yes. There is also `SCREAMING_SNAKE_CASE`, which is my favorite name ever.
Yes.
Awesome! The book is great! I too have been working on a renderer heavily based off of pbrt. Its nice to see graphics tech in languages other than c++.
It's surprising inflexible. For example, in the course of resolving an equation, you might get a `unit&lt;1, -3, 0...&gt;` (acceleration / duration). This does not have a name, really. And coming up with a name for all potential combinations of the 7 elementary units is a scary prospect.
Oh, I know. Moving target, and all that jazz. It's hard to learn anything about such a fast moving target, though.
i only knew those as names_with_underscores and CAPS_WITH_UNDERSCORES. SCREAMING_SNAKE_CASE is a huge improvement here. PS: i also like the name kebab-case! and did you know there are languages with real multi word identifiers? (SQL, PGF, Inform)
 pub fn lerp&lt; T : Add&lt; T, T &gt; + Mul&lt; f64, T &gt; &gt;( u : &amp;T, v : &amp;T, t : f64 ) -&gt; T { return *u * ( 1.0 - t ) + *v * t; } I'm curious about those expressions in the type parameter, but I can't find anymore info about that feature. Does anyone know where I can find out more?
I advise you to visit the #rust IRC (the link is in the sidebar). I just started playing with rust a few days ago, and I've yet to wait more than 30 secs for an answer in the IRC. Rust has an extremely helpful community!
That is very cool. Did you have any major problem making it in Rust? Right now I'm coding an OpenCL ray-tracer in C++ just because I want to make sure everything works, but rust looks awesome... One thing I'm not sure Rust supports is data alignment? Kinda essential for me right now in order to properly share memory between devices.
http://static.rust-lang.org/doc/master/core/ops/
 fn f&lt; T : Trait1 + Trait2 + ... &gt;( &amp;x : T ) { ... } says f is a function of 1 argument where that argument implements Trait1 and Trait2 and ...
:-/ with this approach to ranged integers it seems unlikely that the compiler would ever end up optimizing out the checks when it could have proven they aren't violated, nor does it seem like it would be easy to swap a ranged type into a production codebase for exploration/diagnostic purposes. I hope rust someday grows first class ranged types.
The 0.9 -&gt; master -&gt; 0.10 transition was a bit of a hassle and lifetime syntax can be a headache. If you search the #rust logs for hhhhhhhhhh you can probably find the 500 million questions I asked. OpenCL or OpenGL? I started with CUDA but having to Google for hours every time I wanted to sit down and do anything was no fun at all. [#[packed]](https://github.com/huonw/rust/commit/b5ceba1fc5fe068ede7fe6d0fc88b80904cef6b2)?
It would also help to find documentation area's that people can contribute to.
 &gt; iterators written as fn that yields values, just like Python's yield statement. There's a ticket open for a `yield` construct: https://github.com/mozilla/rust/issues/7746 &gt; default function/init arguments Likewise, though this one was closed after going off the rails and getting nowhere: https://github.com/mozilla/rust/issues/6973
Yeah, I see what you mean. But I guess I'm the kinda of programmer that would accept it in order to code in a cool language :P I'm actually using both, OpenCL and OpenGL. I'm creating a shared context between the two so my OpenCL Kernels can write direct to texture memory of the OpenGL context. When I looked into Rust I found SDL2 and OpenCL bindings, so I think its not a problem. What I could not find was support for the "_ _attribute_ _ ((aligned (64)))". I'm not sure if "packed" would work for me, but I can't be sure. I think it could work if I create "padding" variables inside my structure. *Thank you for the link, I'll take a look :)
Last year we had a proof that our grammar was LL(2), and could be made LL(1) with enough gymnastics in the proof language. I believe this is it: https://github.com/jbclements/rust-antlr Obviously our syntax has changed since then, but I don't believe we've added any constructs that would change us away from LL(N) for finite N.
Not quite the same, but we do already have an on-by-default lint for non-camel-cased types: sn.rs:1:1: 1:16 warning: type `foo_bar` should have a camel case identifier, #[warn(non_camel_case_types)] on by default sn.rs:1 struct foo_bar; ^~~~~~~~~~~~~~~
Thinking about it, multi-word identifiers are actually possible (if not *allowed*) in a whole lot of languages. Many languages don't allow you to just arbitrarily put identifiers side-by-side, which is the only case where multi-word identifiers become ambiguous. Languages where such ambiguities would arise include the following: 1. Any language that declares variables directly adjacent to their types (C, C++, Java) 2. Any language that allows you to elide the parentheses around argument lists (Haskell, CoffeeScript) 3. Any language that allows you to introduce fake keywords via metaprogramming (Ruby, Nimrod) As for Rust, which doesn't do any of these, multi-word identifiers seem like they would be possible. But, I'm not saying they would actually be a good idea. :)
Tons of people seem perfectly happy to tear out the standard library and use Rust without allocation. The recent effort to reorganize the stdlib should make it even easier to use allocation-free Rust while only losing select portions of the stdlib, rather than all of it.
&gt; Better procedural macro syntax, more like how Lisp macros work. There's no divide there between "regular" macros and procedural ones- you just put unquoted code in the macro definition and bam. I think this may only be possible in Lisp because of s-expressions. Procedural macros need to modify the AST, and in Lisp you're always just coding the AST directly.
No mean-spirited sarcasm, please.
Yes, though our current implementation of the Index trait (if it hasn't been ripped out already) is known to be inadequate. I think https://github.com/mozilla/rust/issues/6515 is the relevant issue.
Note: usage looks like `impl Add&lt;Rhs, Result&gt; from Lhs`, so here it's about implementing the glue to get `T + T -&gt; T` and `T * f64 -&gt; T`.
Any idea about the etymology of "snake case"? Are the underscores supposed to be where the snake was run over by a car?
with syntax highlighting, it would work, especially in languages which mostly have keywords at the beginning (e.g. no `qux = foo if bar else baz`, only `if foo {` or at least `with baz as boo:`) it would work best in languages that minimize keywords (e.g. APL) or in defined subexpressions (e.g. LaTeX option lists like `\framebox[some option=some value, another option=another value]{ content }`)
my favourites are python’s new `yield from` coroutines and C♯’s `await` and `defer`
If I were to hazard a guess, perhaps the underscores and characters create an "undulating" pattern that vaguely [resembles snake locomotion](https://www.youtube.com/watch?v=zEto1-ZTbd4).
Add&lt;T, T&gt; + Mul&lt;f64, T&gt; is a trait for a type for which the addition of two elements of this type produces another element of this type AND the multiplication of a float and a element of this type produces another element. This is exactly vector addition, (+): (T x T) -&gt; T, and scalar multiplication, (*): (f64 x T) -&gt; T, the two fundamental operations on a vector space.
&gt; Typical C++ compilers have a switch to control the evaluation depth, with a "sane" default. Which is by the way implicitly recommend by the standard, that only requires a certain instantiation-depth to be possible.
The term possibly predates Python, but pythons are snakes. :)
I'm in Enschede so you're not alone. :-)
7-9 it is! Remedy Teas! 
Yes! Hope to see you there. 
I'm a noob too! 
I'd love to do something like this eventually, but Rust is still changing so much that having an archive of answers might as well do us more harm than good. We would need some ability to update outdated information, such as that a wiki provides.
Right, but at the same time you're getting extensive formal post-secondary education about programming and computation in general. You're self-selected to already be passionate about programming, since you picked that program. You're also pre-selected, by virtue of being accepted into that program, for being a bright student. /u/erkelep was talking about a tutorial or book, for which the audience is *much* broader than just college-aged engineering students. As such, the criteria for what makes a good teaching language is much different.
That I would definitely agree with!
An extension to that... Documentation that isn't organized by pulling from the source tree. It leads to oddities like the documentation of the Iterator trait being buried in std::iter::Iterator or methods on str being scattered throughout the std tree.
Because there are solutions that emphasize uniqueness over mutability that don't involve changing all `let` bindings to be mutable. For example, changing `&amp;mut` to `&amp;my`.
I think you may want to link to https://github.com/PistonDevelopers/rust-graphics/issues/1, I'm getting a 404 on your link.
This means that users should never see `~str` (aka `Box&lt;str&gt;`) at all. The only string types used in libraries are the slice `&amp;str` and the dynamic `StrBuf` (likely to be [renamed to `String` soon](https://github.com/mozilla/rust/issues/14312)).
Well, about 5 minutes away from the border, so I could attend meetups easily as long as they're somewhere in the southeast corner of the Netherlands.
I've just [updated my Project Euler solutions](https://github.com/riccieri/rust-project_euler/commit/47f340487927a274d992035e3e651f454a434fda). Was actually more painless than I thought. The diff might be of use as reference for other people updating their code
Good point. At first I had the same view as the grandparent. It is easy to overlook this
Hat's off to /u/pcwalton's incredible tenacity at getting this merged. It looks like it bounced 14 times before getting through bors.
&gt; 1. Any language that declares variables directly adjacent to their types (C, C++, Java) Rust *does* actually allow types next to expressions in some cases — `|x| -&gt; int x` is a valid expression. Here you have a type (`int`) adjacent to an identifier (`x`), so it’s ambiguous.
Well, this code is really well done and understandable. Way to go, I enjoyed reading that, and using this as an example may well get me able to use OpenGL in Rust finally. Just updating my rustc now so I can compile this. Thanks for sharing.
I tried posting this in the blog comments, but the submission was failing with a nginx error, so it's going here instead. --- Firstly, it's awesome to see people experimenting with (binding to) GUI libraries in Rust! Are you compiling with optimisations (the` -O` flag or `--opt-level=&lt;number&gt;`)? That should cause dead functions to be eliminated and so reduce the binary size. Also, the problems with closures are known, and it's being progressively improved (e.g. https://github.com/rust-lang/rfcs/pull/77 ). By the way, your work-around has a very high risk of invoking undefined behaviour. The reason the compiler doesn't let you call a closure through `&amp;` is because all mutations of aliased data *need* to go via the [`Unsafe` type](http://doc.rust-lang.org/master/core/ty/struct.Unsafe.html) (or one of the wrappers, like [the types in `std::cell`](http://doc.rust-lang.org/master/core/cell/)). Mutating via `&amp;` without using `Unsafe` is undefined behaviour (in the sense of C/C++) and the compiler may "break" your program. A closure can mutate its environment, hence calling one via `&amp;` risks invoking undefined behaviour. However, it should be safe if you enforce that there are no captures (by giving the closure the `'static` lifetime, e.g. `|...|:'static -&gt; ...`). It's worth mentioning that this does mean that implementing &gt; Things are getting even more complex if “mut” state for slots is allowed - up to the point I had to always use only non-mut and use RefCell&lt;&gt; for any mutable state that is accessed in slots. requires special care. &gt; The state is limited to only one variable. Multiple variables would complicate things even further by requiring to select the appropriate Callable struct implementation. Rust has tuples (e.g. `(int, f64)`) so you can have a state being multiple variables by capturing a tuple. &gt; Surprisingly, the answer is “no”! Rust doesn’t even have member functions pointers! This means there’s no way to implement generic “callable” trait that would forward calls to the member function of your choice. A bare function pointer is written `fn(...) -&gt; ...`. E.g. struct Foo { f: fn(int) -&gt; int } fn increment(x: int) -&gt; int { x + 1 } fn main() { let foo = Foo { f: increment }; println!("{}", (foo.f)(2)); } There is some subtlety there, in that writing `foo.f(2)` is always interpreted as a method call, so the parentheses are required to disambiguate. &gt; I didn’t manage to find the way to use lifetimes properly in “::new” functions. That is, in the examples above I have to construct the struct in two steps: calling “new” first and then “init” from the code that actually instantiates “DigitalClock” or “ImageViewer” structs, see lines 67 and 333 respectively. At a guess, this is probably due to the `&amp;'a self` annotation on `init`. This forces the `'a` lifetime of the `ImageViewer` to be the stack frame of `new`, since that's where the `ImageViewer` struct is placed when you call `init` (and hence the maximum time that the `&amp;self` reference passed to `init` can last). Theoretically the correct fix would be removing the `'a` lifetime on the `self` reference, but I imagine that this would cause the captures of each slot to not last long enough. Another possible fix would be using a shared pointer equivalent (`Rc`) so that the captures do not need to have lifetimes like they have there... A third possible fix would be having some sort of action dispatcher on the `ImageViewer` type, which then passed a reference to itself into the action handler automatically (rather than "manually" capturing `self`for each one). However, I imagine this last one is very hard when using a library that's not been designed for it.
He's trolling, of course, but there is one tangential issue here: the community should stop indicating the language is ready to be adopted because the upcoming changes are relatively small. They are not, they're pretty disruptive if you're serious about coding in Rust. This is far more common on Reddit than on the other community channels. I understand it would be cool to build a larger, more varied community before the language is finalized, to give different perspectives before the language decisions are set in stone, but it's bound to produce responses like the OP's.
A Rust meetup in Germany could find some interest too, since some contributors seem to be originated there.
Hm I think that's only because you know that you need to get len() or sizeof() or whatever API you need to create the upper bound on the loop. I don't, and I don't mind that the syntax is .iter() or .iterator() or whatever loops will accept in the future instead of .length(). It also prevents me from doing lots of beginner mistakes, like off-by-one, unnecessary calls to .length() on every loop iteration, etc. I've only done some Rust coding for some pet projects, and then only a couple hundred lines, but I would not mind if loops would take anything that can be converted to an iterator instead of the iterator itself. It would prevent the iterator from being reused... 
Also, &gt; This is not translatable directly to Rust enums, so I had to combine all enums with the same value into single item &gt; &gt; This is definitely not convenient and misses the whole purpose of this enum, but I see no other way of fixing it - modulo abandoning enums altogether and translating things to constants + int types, which crates its own share of problems like type safety. Yeah, Rust's enums are explicitly different to an enum in C/C++: Rust uses them as tagged unions, not just a "random" collection of integer values like C/C++. Maybe [the `bitflags!` macro](http://static.rust-lang.org/doc/master/std/bitflags/index.html) could be used?
A school where I was required C as a programming language of business majors. I'm pretty sure it was their first. I thought it was crazy too. A lot of cheating went on. 
&gt; the community should stop indicating the language is ready to be adopted because the upcoming changes are relatively small Are people actually saying that the language is ready for serious "stable" use?
Personally I'd like to see the removal of the libgcc/MinGW dependency that Rust has. Makes Windows development not quite favorable yet.
Note that there's an official `core` crate as part of the standard libraries now. The `std` crate is becoming a shim over lower-level crates. It will end up providing the runtime features like the dynamic selection of M:N or 1:1 for task scheduling and failure with almost everything (even native I/O) available at a lower level.
Ah, you're right! Thus dies the dream of multi-word identifiers, I suppose. :)
Updated! Thanks!
I would have assumed there would be a few in Amsterdam. Probably asking on twitter #rustlang and/or the IRC channel would be a better way to judge interest.
I'm pretty sure the C++ enum is just used to define a series of compile-time constants, so there's no real point in translating it to anything fancy.
Thanks for the tip. I am also going to do that!
See also https://mail.mozilla.org/pipermail/rust-dev/2014-May/009887.html
Actually, the Standard does not even require a given instantiation-depth, it merely gives a recommendation.
Yes, the problem really is maintaining it. Maybe it should be integrated in a Travis CI to make sure it does not rot?
/u/cmrx64 is doing a proper grammar as part of his internship and is incorporating it into the testsuite.
&gt; No catchable exceptions If I may add my two cents: people often think about *catching* but rarely think about *recovering*. Ensuring recovery, in a typical language like Java or C++, is impossible. The program is left in an unstable status because the bodies of `try` and `catch` may have accessed and mutated variables from outer scopes, and there is no guarantee in the language that those variables were straightened up afterward (if necessary). Rust, on the other hand, make any access to outer state explicit: - either from the arguments pulled in, *if* they are `Share` - or from the use of channels this limitation of what a possibly-failing operation might alter makes it much easier to reason about the program state in case of failures.
Interesting, I would prefer an ordering of arguments to deduce the correct overload: C++ rules for overload deduction are pretty arcane and it's actually hard to predict what will get called, and I think that the symmetry (for free-functions) is part of the issue.
Oh, amusing. I had missed that thread and just proposed a similar solution [on the QT5 bindings article]. I am not that put-off by actually *naming* the overload, it makes it so much easier on the caller part to immediately and unambiguously identify which overload is actually going to run (which computers are good at but humans not necessarily).
I really like this presentation. The chosen examples are straight to the point, and follow on from each other in a very logical way to illustrate your points. At 36', the way `proc` is presented is a bit confusing. It's not obvious that `proc` is actually a keyword, and that the right part of your slide is the detailed view of the content of the proc. Instead, one can think that `proc` is a simple function defined on the right, and invoked on the left. Also, it was not immediately clear to me why I'd need an `Arc` to share a read-only struct. From the previous slides, I would have said that a simple reference (&amp;) would be sufficient (aliasing without mutation). After thinking about it, I now realize that references cannot work across threads, because lifetimes make sense only inside a given stack. And yes, those are really nice water bottles!
Oh, and by the way is there a reason to inject the names of an `enum` variant into the enclosing scope. It's incredibly painful: enum List { Nil, Cons(...), } enum Map { Nil, Tree(...), } leads to a complaint about a *duplicate definition*. I find it slightly startling, given that it's been considered a mistake for C and C++ `enum` for years and the introduction of scoped enums (`enum class`) in C++11 was very much acclaimed. Now, I do understand that having to write `Map::Nil` or `List::Nil` everywhere would be annoying, however I could perfectly imagine a scheme where: - the names are injected by default, - but pulled out in case of ambiguity, - in which case the user is invited to `use List::Nil;` to import the one she values the most It seems such a basic point that I cannot help but think it's been discussed already.
Why yes, I am too.
I guess an example of using #[packed] would be [this](https://github.com/jeaye/q3/blob/master/src/shared/obj/bsp/lump.rs). Looks like he doesn't add any padding to his structs though. Yeah in theory CUDA kernels can write directly to textures/FBOs but for me the images it produced ranged from http://i.imgur.com/YucE8Fs.png to whatever I was last looking at in firefox but upside down. Glad that you are having more success than I did.
My changes [look quite similar](https://github.com/exscape/Rust/commit/875cf906087a5e7fdb7549f26151a47a8fb70470). Is there a better way than to use .as_slice() everywhere? Or will there be, when all this change is finished? strbuf.as_slice().slice_to(10) looks very ugly IMO, and strbuf.as_slice()[i] is possibly even uglier.
What about a trait?
With DST, `StrBuf` will likely implement `Deref&lt;str&gt;`, allowing to call `&amp;str` methods directly, and allowing to explicitly create a slice with `&amp;*strbuf`
Ah! I parsed it as `member (function pointer)` not `(member function) pointer`... I don't know how one would write something similar to that in Rust.
There's now some [extended docs about avoiding `std`/using `core`](http://doc.rust-lang.org/master/guide-unsafe.html#avoiding-the-standard-library).
Something like this has been proposed before - https://github.com/mozilla/rust/issues/10090
&gt; A person's name Names do change a lot more than you'd think. Making a person's name immutable leads to horrible hacks later.
Right; if it were possible to pass member functions as arguments to functions expecting a function that takes an equivalent self type, that sounds like it would Just Work.
StrBuf gets renamed to String, not Str, because Str identifier is reserved for trait, right? So type Strings will implement trait Str, and word "Str" is short for "String". That's odd.
I've got an ~2000 SLOC codebase that uses dynamically allocated strings quite heavily. (It's a server that exposes itself through a JSON API over websockets with mongrel2.) Took me about 40 minutes to `de-~str` the entire thing. This also helped me identify some areas where I was making duplicate allocations or needless allocations, which was nice. I'm not exactly shooting for high-performance, I just enjoy writing rust. I'm still happy to see the stdlib guiding me towards writing better code.
For now you can just use a plain function with a `this` parameter that delegates to the real method. It's a little uglier but it should work fine. Could even be macro'd, most likely.
You could use newtype structs as well if you want type safety.
To expand on this, here are the meeting notes where the devs rejected the idea: https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-10#enum-mod It might still be plausible to get such a thing in before 1.0, thanks to the new RFC process. *However*, I would warn against proposing the RFC at this specific point in time. There are so many breaking changes in the pipe (`@`-removal, `~`-removal, DST, by-value closures) that people will rightly be wary of accepting more changes for 1.0 until we can prove that we can clear out what's already on our plate.
Hm... part of me does really like the idea of injecting the names by default, such that you can use both `Nil` and `List::Nil` interchangeably without any boilerplate, and only forcing disambiguation where necessary. I think a future RFC to this effect would be well-served by this feature. The downside is that this behavior is unprecedented in the language as it stands, and might be too surprising. Need to think about it. Surely enum constructors are *already* a tad unprecedented in their own right...
will big features be added afterwards? i would think that coroutines (living only as [proto-RFC](https://github.com/rust-lang/rfcs/pull/53)) won’t make it, but won’t be backwards-incompatible either.
The `Str` trait is such a minor detail that its name wasn't a factor in the recent renaming discussion. It will be used very rarely (especially compared to the `String` and `&amp;str` types), and it only provides a single method: `as_slice`. We could trivially rename it to something like `StrAsSlice` if we needed to.
Anything that's backwards compatible could be added, just nothing incompatible can. We'll be following SemVer.
i hope you’ll get default arguments nailed down before 1.0, because i fear that the perfect design might be baclwards-incompatible
yep, same situation.
Thanks for the detailed answer! &gt; Are you compiling with optimisations I wasn't, but it doesn't seem to make any difference in this case - after compiling with "-O" the size is still the same. Changes to "debuginfo" parameter don't help as well. Interestingly enough, "strip" does reduce the size of the binary significantly - but not due to debug info (as "strip -g" makes very little difference, it's only full "strip" that does), suggesting that due to some reason there are a lot of unnecessary symbols included in the binary. Here's the comparison table for the Digital Clock example: Default parameters: 70,296,792 -O: 70,276,728 -O --debuginfo=2: 70,296,048 -O --debuginfo=1: 70,277,808 -O --debuginfo=0: 70,276,728 strip -g: 68,587,165 strip: 37,041,672 However, even 37M is still too much for this kind of example. At some point I might try to analyse in more details which of the symbols are included in the resulting binary and compare those to the ones which are not included - and try to derive a pattern. &gt; Also, the problems with closures are known, and it's being progressively improved Yes, I've seen that RFC and I really hope something like this is eventually implemented. &gt; A closure can mutate its environment, hence calling one via &amp; risks invoking undefined behaviour. Given that in current work-around I capture and pass the state explicitly, I think environment mutation should not be a problem. I'll think about using explicit "'static" annotation though, thanks for the suggestion! &gt; It's worth mentioning that this does mean that implementing ... requires special care. I don't think it's a problem as in this case mutation happens in explicitly captured &amp; passed state, not in the environment. &gt; Rust has tuples (e.g. (int, f64)) so you can have a state being multiple variables by capturing a tuple. Yes, this is already possible with current work-around as it's parametrized by Param type, which can be tuple as well. Other approach would be to pass a struct that groups all relevant state in single object. It's not so much about the possibility of doing it but more about convenience &amp; extra efforts required by programmer to use it. &gt; A bare function pointer is written fn(...) -&gt; ... &gt; ... Yes, I'm definitely aware that it's possible to take the address of non-member function, I'm using that extensively inside the bindings implementation to call from C++ to Rust and then invoke slots. Unfortunately, this doesn't help with signals / slots implementation: 1. It would require spreading the logic from the struct implementation to multiple global / static functions. 2. To pass the state that is necessary for this function to do its job while avoiding hard-coding exact state type in signals implementation, one would have to use smth like "core::any::Any". Both of these are "no go" in my book for any non-trivial project. In fact, another possibility for (2) is to implement "Callable" traits &amp; structs similarly to what I've done for "closures without captures" in my work-around, so that exact state type can be captured &amp; isolated from the signals implementation - but then again we're not better than with current work-around, plus added problem of (1). The reason I was mentioning "member functions pointers" (and dreugeworst was right, I really meant "a pointer to a member function", sorry for confusion!) is that it's another way to implement "Callable" approach, which was successfully used in C++ to implement callable objects (e.g. boost::bind / boost::function) even before lambdas were available. However, after discovering that "closures without captures" don't require stack frame, I believe they're an adequate substitute for pointers to member functions (albeit with more awkward syntax to pass the object to call the function on). &gt; Theoretically the correct fix would be removing the 'a lifetime on the self reference, but I imagine that this would cause the captures of each slot to not last long enough. Yes, that's exactly the problem - the reason I had to add that 'a lifetime annotation in "init()" was that otherwise 'self' cannot be captured into the explicit state by reference. Using Rc would be an option indeed, but it felt quite intrusive to require slots receiver to always use Rc&lt;&gt; for the whole struct just because it happens to have one function that needs to be the slot. &gt; Maybe the bitflags! macro could be used? Yes, this could be very useful, thanks for the suggestion! I'll have to see whether "bitflags!" or "newtype" (suggested below by Patrick) works better for enums, but where "bitflags!" should shine is in replacing Qt's QFlags&lt;&gt; - current wrapped syntax is ugly and verbose as hell, "bitflags!" should be much more elegant.
Ah, as I had mentioned in my parent comment (C-4 now!) I thought I had read about him working on it in the Meeting-weekly minutes. This is definitely a great idea; any idea how he's planning to manage the check between the formal grammar and the compiler's lexer / parser ?
Yes, looks like it can work perfectly to wrap C++ enums (at least those that are not used as "flags" - for them "bitflags!" might be more appropriate?), thanks for the suggestion!
How many arguments should the trait method take ?
Yes, it's "just" a paper cut, and there are clearly more important changes. On the other hand, I don't type well with protection gloves :(
Apparently, something similar was already [proposed and rejected](https://github.com/mozilla/rust/issues/10090). I would understand it is not a priority for 1.0 as you can work around it; it's just annoying.
Well, if the disambiguation is the issue, then I would just vote for always requiring scoping and separately aliasing the constructors that you really want. This would be much simpler to implement, I guess, although the fallout in terms of reworking the code would be *massive*.
In that case better name for String would be Str, because rust already uses short identifiers for common types, and I think that's great, for example like * int instead of integer * bool instead of boolean * char instead of character * Num instead of Number * Eq instead of Equal * Vec instead of Vector (Sorry for bikeshedding)
The disambiguation isn't the issue, it's that such behavior is fairly "magical", which is a property that we have steadfastly resisted in the past. That said, automatic enum constructor injection is magical too, in its own way. We're just blind to the magic because we're so used to it.
We discussed the name extensively here: https://github.com/rust-lang/rfcs/pull/60 At the end of the day, `String` was the least-objectionable proposal. Note that we *also* have the type `&amp;str` for string slices, just like how the type `&amp;[T]` is for array slices.
Are you aware of the #rust-gamedev IRC channel? This may not answer your immediate question, but it could perhaps help you get more timely help in the future. See the link in the sidebar if you're interested.
OK, I see, all arguments were spoken, all possible options were considered.
The issue here, as you correctly point out, is in the name selection for these "One", "Two" and "Three". For small libraries I can imagine this can be done manually, but for large ones (like Qt5) it's just too much work to be practical.
Oh, OpenCL and OpenGL gave me lots of headaches too. I'm using the AMD's OpenCL implementation and the only texture I could use was GL_RGBA. If I try anything else it just doesn't work even though the OpenCL specification says it should. Anyway, I don't know CUDA, but if you ever use OpenCL then this code may help you: [OpenCL/GL sharing](https://github.com/AranHase/basic_openclgl_sharing) Only downside with this solution is that if OpenGL creates a context using just one GPU, then your OpenCL context will have just one GPU. If you try to use two GPUs (or GPU+APU) in OpenCL it will just fail.
If you might be interested in [Piston](http://pistondevelopers.github.io/).
From my experience, you can stick pretty closely to gl tutorials (I used http://www.opengl-tutorial.org/). What little differences there are, you can look at the gl-rs source (which is tiny) and figure out the changes. The most barebones way to run through that tutorial would be to use glfw-rs alongside gl-rs as a way to get a window handle as well as process input and events. I used cgmath-rs in conjunction with that, but you could probably use nalgebra just as easily. All of the repos I mentioned are on github, so they should be easy to clone and play around with.
What if the RFC proposer is willing to do the implementation work? That would not increase the burden on the core team (modulo the normal burden of trying to land sweeping changes at the same time other changes are going in, but that's a fact of life).
You can use [hgl-rs](https://github.com/cmr/hgl-rs/) to do 3D. There are also existing vector and physics libraries. * https://github.com/bjz/cgmath-rs * https://github.com/sebcrozet/nphysics Our goal with Piston is to be compatible with these libraries in addition to 2D. Contributing to the existing projects might be a good way to learn Rust! I also recommend https://github.com/bvssvni/rust-empty to set up your directories. This will make it easier to emigrate your project to the Cargo package manager later.
Promises to do work don't really provide any solace. In order for this strategy to be effective, you have to either be a proven compiler contributor or have the work finished *before* submitting the RFC. And even then it's not guaranteed, such as with burntsushi's regex and quickcheck crates (the former accepted, the latter rejected). Also, the disruption that such a widespread change would have on in-progress patches is not a factor that should be discounted. This is another reason why you ought to wait until things settle down slightly before proposing this (just be sure not to wait too long).
Thanks, I'll consider those other libraries, but I still bet I'll end up writing my own. (although much simpler) I'd totally be willing to contribute to physics projects but I must admit my knowledge of tensors is close to 0, Happilly next semester is upper level mechanics..... Still the temptation to not have to write a 3d collision detector is huge, but I sort of want to do it to understand the physics more. 
Well all your examples take 2 arguments, so 2. You could also just take one argument and implement the trait on tuples.
`bitflags!` wraps things in a struct internally for exactly that reason.
where's part 1 through 6?
oops sorry
http://featherweightmusings.blogspot.co.nz/search/label/rust-for-c
Thank you for explaining RefCell.
On the paragraph about tuples: &gt; Enum values are initialised in the same way as enum types are declared, but with values instead of types for the components, e.g., `(4, 5)`. I think you meant 'tuple' instead of 'enum'
When you say ‘"ghost" types’, that is the concept normally called *phantom types*. File I/O does not use phantom types, though there was just a demonstration at the time typestate was removed of how such an API would work.
Sorry. I wasn't too sure about that name. Thanks for the correction.
I do admit I found it magical. I also found it slightly surprising that `List::Nil` was not accepted by the parser. Of course, I might be biased because C++ allows a qualified name and routinely nests constants and types within `struct`/`class`.
Yes; although from the mail discussion I think a better approach (for Qt5) would be to attempt a reduction step. For `fillRect` for example once eliminate the overloads that pass arguments to build the object instead the function you realize there are only **2** different overloads, from the original *12*, and the difference is because one works with integral coordinates and the other with floating point coordinates... which I guess is pretty pervasive in Qt.
Can someone point me a discussion on ~ vs Box syntax somewhere? Perhaps mailing list or some blog. I think that if ~pointers are common, making them more verbose may actually hinder clarity (see: Java verbosity). But then, I suppose that enough people was confused by the ~ syntax to warrant a change. Or perhaps ~ pointers shouldn't be used that much; I'm reading some docs where it's recommended only for circular data structures and references to traits (and little else).
Change the signature of `incr_ret_ref` as follows: fn incr_ret_ref&lt;'a&gt;(par: &amp;'a mut int) -&gt; &amp;'a mut int `par` and the return type should have the same lifetime, and as the function signature is not inferred (by the design) you need to let the compiler aware of this.
BTW, what version of rustc are you using? I only ask because new-ish versions will actually tell you the required lifetimes for some invalid code like this, e.g. for this one, it says (among other things): ref_ret.rs:5:5: 9:6 note: consider using an explicit lifetime parameter as shown: fn incr_ret_ref&lt;'a&gt;(par: &amp;'a mut int) -&gt; &amp;'a mut int which is exactly the solution that /u/lifthrasiir gives. --- The [lifetimes](http://static.rust-lang.org/doc/master/guide-lifetimes.html) are annotations to allow the compiler to guarantee that the references point to valid data, and, relatedly, for how long this data will be valid. In this case, it's just saying that the returned reference is valid for at least as long as the input reference (which is quite sensible, since you're returning the exactly the reference you received). [Niko's recent talk](https://air.mozilla.org/guaranteeing-memory-safety-in-rust/) gives some motivation and an intuitive explanation for how Rust's borrowing/references/lifetimes work.
Thank you. Unfortunately, I have no idea (yet) what lifetimes are. :-) Can you explain why it is necessary in this case? 
Yeah, I got that error exactly. Need to read about lifetimes...
A reference depends on a value somewhere else. That value must live at least as long as the reference, or the reference could become invalid. Lifetimes are a way to formalize this relationship. The function signature makes it clear that the output reference depends on the same value as the input reference. The compiler could probably infer it, but in a more complex scenario with multiple references, without explicit information we would have to inspect the code or try to compile to understand which reference is returned.
I'll take a stab at it, since I just ran into this issue the other day and learned it myself. Lifetimes are basically the length of time (or scope) that an object is considered still "in use". After a variable's lifetime has elapsed, no one owns the memory any more and it can be freed. For example, take this function: fn do_things() { let my_foo = 1; ... ... } `my_foo` is a local variable instantiated inside of `do_things()`. It is scoped to the function and shares the same lifetime...when do_things() exits, `my_foo` is destroyed. The *lifetime* of `my_foo` is scoped to duration that `do_things()` is executing. That's pretty simple, since everyone expects locally declared variables to behave that way. It get's trickier when you are returning references. fn incr_ret_ref(par: &amp; mut int) -&gt; &amp;mut int { In this function declaration, `par` is a mutable reference...the function owns the `par` variable and is capable of modifying it's contents. The lifetime of this ownership is for the duration of the function. Once the function exits, ownership goes back to the original owner (the caller). However, you are returning then returning a mutable reference to `par` from the function. Because `par` is scoped to the duration of the function, this returned mutable reference is "dangling" and exceeds it's declared lifetime (the duration function). Of course, we know it doesn't based on your code, but the compiler cannot reason about this. You need to specifically annotate the lifetime by saying "the lifetime of the returned value is the same as the `par` variable". This means that when `par` is freed in the caller, the reference returned by the function is also free. This allows the lifetime to "escape" from the function, since it is tied to the `par` variable. Pheww! Hope that made sense...still processing these things myself :) 
It makes some sense, thanks. :-)
I do not understand what the problem is. Can you explain it further?
What happens if I make a circular structure with Box? Will the type checker reject it magically, or will the structure live forever (memory leak), or something more bizarre? Anyway my impression is that `~` was removed just because beginners kept misusing/overusing it. That is, I don't buy that expensive operations (in this case, heap allocation) must be translated to lengthier, heavier syntax, especially for a concept as important as recursive data structures. Tons of real world C++ code actually use pointers for this purpose, and would benefit from a lighter syntax. There's also the point that `box` now enables custom allocators. Would custom allocators create variables of a different type than `Box&lt;&gt;`, but still with the same semantics? How/why doesn't `~` support custom allocators? (I can't really find this) Anyway. I think that part of the problem is that Rust settled on the C++ syntax of `A&lt;B&gt;` instead of the Haskell's syntax `A B`. `Box T` really isn't very heavy. My trouble is types can get really lost in &lt;&gt; noise (which is something that C++ does a good job showcasing).
&gt; Given that in current work-around I capture and pass the state explicitly, I think environment mutation should not be a problem The problem is the scheme without `'static` doesn't *enforce* that there's no environment mutation, i.e. it's theoretically possible to accidentally pass in a closure that does mutate its environment. (But, fortunately, using `'static` fixes this.) &gt; I don't think it's a problem as in this case mutation happens in explicitly captured &amp; passed state, not in the environment. Yes, but it will have to be captured by `&amp;mut`, and `call` will need to take `&amp;mut self`. &gt; The reason I was mentioning "member functions pointers" (and dreugeworst was right, I really meant "a pointer to a member function", sorry for confusion!) is that it's another way to implement "Callable" approach, which was successfully used in C++ to implement callable objects (e.g. boost::bind / boost::function) even before lambdas were available. Yeah, I misinterpreted (sorry!), so my mention of `fn(...) -&gt; ...` was completely irrelevant. As /u/erickt [said](http://www.reddit.com/r/rust/comments/269t6i/cxx2rust_the_pains_of_wrapping_c_in_rust_on_the/chp9oqk?context=3), [the "UFCS" proposal](https://github.com/rust-lang/rfcs/pull/4) will likely fix this. &gt; "bitflags!" or "newtype" (suggested below by Patrick) (BTW, `bitflags!` is actually just a macro for creating a some newtype structs.)
Talking about `'a` as lifetime is vague because it doesn't actually refer to how long an object lives. Talking about object A and reference B having the same lifetime is misleading because the reference can have any lifetime as long as it doesn't exceed that of A. There is a general vagueness in much of the language used to describe these concepts, and I think it's because the term "lifetime" is just not adequate. I think we should try to come up with a better name and use it throughout the documentation. PS: the problem is that there are actually two different but related concepts for which the same term is used, which is confusing. The documentation uses "lifetime" to refer to the actual lifetime of an object, but also uses it for `'a` which is clearly not the same thing. PPS: in C, &amp; is both a reference and an operator to get the memory address of an object. Two different but related things. I think it's universally agreed that this is confusing at first. Rust is making a similar mistake at the human language level by not differentiating between lifetimes and lifetime limits/depencies/whatever.
I'm still not sure I see how a better name would help. The concept of lifetimes is a difficult one; it seems to me that someone who is not familiar with the concept is not going to be much more enlightened by a two-word name than a one-word name. Its more complicated than any two standard English words can fully encapsulate. That's why there is now a full [guide](http://static.rust-lang.org/doc/master/guide-lifetimes.html) to lifetimes. Now, maybe having one highlighted sentence in that tutorial defining lifetime would be good. Currently, embedded in there is this sentence: &gt; A lifetime is a static approximation of the span of execution during which the pointer is valid: it always corresponds to some expression or block within the program. That's a pretty good definition, as far as I'm concerned. Maybe it should be highlighted better?
&gt; What happens if I make a circular structure with Box? Will the type checker reject it magically, or will the structure live forever (memory leak), or something more bizarre? Rejected. Most values in Rust move by default (that is, a by-value use will prohibit the source from being used), including`Box`, and so any attempt to put a `Box` to create a circular structure of `Box`s would be moving out of a variable which still needs to be used (to assign to the interior). &gt; Anyway my impression is that ~ was removed just because beginners kept misusing/overusing it It wasn't the only reason. The [RFC text](https://github.com/rust-lang/rfcs/blob/master/active/0014-remove-tilde.md#motivation) lists 4 reasons (and you even mention the custom allocators one yourself). &gt;That is, I don't buy that expensive operations (in this case, heap allocation) must be translated to lengthier, heavier syntax, especially for a concept as important as recursive data structures. Tons of real world C++ code actually use pointers for this purpose, and would benefit from a lighter syntax. This has been discussed at length elsewhere. Basically: how often are you *defining* recursive types? The longer `Box` type doesn't really affect the use: creating values is still nice `box foo`, and, anyway, values should very rarely be passed around inside a `Box&lt;T&gt;` is almost always unnecessarily restrictive and not more efficient. The decision was made that the benefits of the `~` syntax are outweighed by the disadvantages. &gt; Would custom allocators create variables of a different type than Box&lt;&gt;, but still with the same semantics? How/why doesn't ~ support custom allocators? (I can't really find this) An allocator would be something like `Box&lt;T, MyCustomAllocator&gt;` using a default type parameter (meaning that `Box&lt;T&gt;` just uses the default allocator). There's no syntax for specifying the allocator parameter with `~`. &gt; Anyway. I think that part of the problem is that Rust settled on the C++ syntax of A&lt;B&gt; instead of the Haskell's syntax A B. I don't disagree, I like Haskell's syntax too.
The annotations would need to interact with the two `&amp;mut` and `&amp;` references somehow. I.e. `mut` isn't just a lint in Rust, it's also fundamental to memory safety. Of course renaming `&amp;mut` to `&amp;my`, `&amp;only` or `&amp;uniq` would "fix" the use of the `mut` keyword... In any case, mutability is a concept Rust really cares about (and always will), because it is a big memory safety risk.
&gt; It wasn't the only reason. The RFC text lists 4 reasons Oops, just skipped the RFC itself... this &gt; `~` can encourage people to blindly add sigils attempting to get their code to compile instead of consulting the library documentation. I think is a valid pedagogic concern, rich type systems sometimes make people throw things at it to see what sticks. And, as far as syntax goes, `~` could be made to work in two forms: `~X` for the default allocator, and `~&lt;X, MyCustomAllocator&gt;`. Perhaps it makes the grammar too ugly.
&gt; The concept of lifetimes is a difficult one; it seems to me that someone who is not familiar with the concept is not going to be much more enlightened by a two-word name than a one-word name. Its more complicated than any two standard English words can fully encapsulate. It doesn't help though that lifetime is an established term: http://en.wikipedia.org/wiki/Object_lifetime At least a two word name makes it clear that we're not talking about object lifetime but something more complex.
A lifetime is just a monoid in the category of endofunctors, what's the problem? ^(Seriously though: maybe "lifetime scope" or "lifetime frame" [to mirror "stack frame", since some aspects of lifetimes are very similar to the actual execution stack].)
Full ack.
You have surely not read rule number 7 (as of 5/24): "Lifetimes are like burritos".
Your definition is spot on. I think possibly the main issue is that lifetimes are compile time hints only. They're useful for static typing in many situations, but because they don't 100% accurately reflect exactly where destructors will be invoked, many kinds of code goes through hoops to 'make the compiler happy' even if that results in unsafe code (eg transmute, unsafe); the lifetime checker can get out of sync. The term 'lifetime' *does* give the impression that they *do* accurately map to when objects are dropped, and the tutorials dont do a good job of explaining the difference I think.
Lifetimes is [actually](http://www.reddit.com/r/rust/comments/26dd52/trying_to_write_a_function_that_returns_a/chpywk9) a good name. If someone doesn't get them, just tell him to ask [Nihy](http://www.reddit.com/user/Nihy) :P
Rest assured that he will be *severely penalized*.
Hm, I think lifetimes might actually be monoids (though not AFAIK in the category of endofunctors). The operation being intersection (which is associative, and which lifetimes are closed under) and the unit being 'static.
"lifetime" is the best name for this concept. The more formal name is "region", but that's even less descriptive to most people. The `'a` in `&amp;'a T` does **not** refer to the lifetime of the referenced object. It is actually the lifetime *of the reference*. The borrow checker will ensure that the lifetime of a reference is not greater than the lifetime of the referent (and thus no dangling pointers can occur). "lifetime intersection" is exactly what it sounds like: the intersection of lifetimes. That is, the intersection lifetime `'c` of two lifetimes `'a` and `'b` is the largest lifetime that is contained within both `'a` and `'b`. Typically, this just ends up meaning "pick the shortest of `'a` and `'b`". `fn foo&lt;'r&gt;(ref: &amp;'r int) -&gt; &amp;'r int` means "a function that takes a reference to an integer and returns a reference that is valid for just as long as the argument reference". `fn foo&lt;'r&gt;(x: &amp;'r int, y: &amp;'r uint) -&gt; &amp;'r int` means "a function of a reference to an integer and a reference to an unsigned integer, both of which are valid for at least lifetime `'r`, and returns a reference to an integer that is valid for at least that same amount of time". Here `'r` is the intersection of the lifetimes of the arguments.
One way I can refer to Rust's named lifetimes is "relative temporal typing". They fit in HM completely AFAIK, though they can also be viewed as values in a dependent type system. Coming back to the "relative" naming, you could use "anchor", "time point" or something similar to indicate that they are a point in time at which the object is known to be alive. ^^&lt;/rant&gt;
Awesome! :)
Will you... shorten his lifetime?
I've been working on this for a while. There's a lot there, but it's nowhere near usable. I figure it wouldn't hurt to share.
Really awesome! I'm currently writing a query language that's a Lisp dialect and Rust is truly awesome at writing these kinda things. /nitpick: One thing I noticed while browsing the code is the tab usage and the super long lines (over 110 characters in length). (I don't usually like mentioning these nitpicks, but hey)
I think that lifetime is the appropriate name, but it does need to be explained differently. To me, it basically means the scope of a variable. And the only time you need explicit lifetimes is if you want to extend the scope beyond what can be inferred by the compiler.
Thanks! Re: nitpick; I don't want to get into the entire tabs-spaces debate, but with tab-size: 4 it is better. I'm more concerned with vertical size (long files) atm. But yeah, there are some serious formatting issues. (*cough* virtual_machine.rs *cough*)
"it's better to Burn out, than it is to Rust"? my my, hey hey
having done most of my programming in large monitors with great IDEs, I'm always a bit surprised people find having lots of line breaks better than lines that are a bit longer (say &lt; 120 instead of &lt;80 columns) But most of my work was in Java, Scala, etc where methods are long-named.
I think I understand why you're uncomfortable about the situation, but I don't see how using a different term will help. `Lifetime` is already fairly descriptive: It refers to the period of time that an object is allocated and thus can be interacted with. This is directly analogous to our own lifetimes, which are the period in which other people can interact with us. Perhaps the difficulty is in clarifying the fact that a reference to an object is itself an object, and thus has a lifetime of its own that is not independent of the thing it refers to. It comes into being after the object it refers to, but cannot last longer than the object it refers to, because then it would be an invalid reference. There's no direct analogy for this in our own life experience, though, at least that I can think of. Anyway, my point is that any object will have the property of a lifetime, and it makes sense to continue to refer to that property by its current name, because the lifetime of most objects are not directly related to one another. It's just the relative lifetimes of objects and reference objects that point to them that's confusing, and I don't think naming is the issue that's causing confusion. It's hard to capture in the name of one thing a property that is due to a relationship between that thing and another.
Scopes and Lifetimes (or extents) are different things in general, though. The scope of a variable refers to the places in the program text where a name refers to the same allocation of memory or value. The extent or lifetime of an allocation refers to a dynamic property; that of the temporal period of validity for references to that allocation, which is a property that emerges while a program runs rather than being strictly a property of its text. Static scoping is fairly easy to deal with and doesn't feel very limiting because it's static verification of a static property. Rust's static verification of lifetime feels more confusing and like more of a constraint on the programmer because it is reasoning statically about a dynamic property of the program, and this is necessarily going to prevent some programs that would be valid without the static checking along with the ones that wouldn't be valid. In other words, static scoping is straightforward enough that even most dynamically-typed languages follow its discipline (with tcl and emacs lisp being notable exceptions), but static lifetime analysis is more similar to static typing systems in the trade-off of expressiveness for correctness guarantees that it makes.
I understand they're different things, but the concept is similar, and so helps explain lifetimes better.
Nice article, and I like the direction of this series! Some future requests: - How to actually layout a medium-sized project. Crates, modules, foo.rs vs foo/mod.rs, etc. - Guidance on code structure: structs with implementations vs functions, mod-level functions vs static methods on an implementation, etc. - Practical testing in Rust. I'm coming from a dynamic language world, where you mold your program to fit testing requirements (IoC, mocking, etc). I get the feeling that this isn't the case in Rust (or C/C++) since these kinds of practices have non-negligible performance impacts. I'm curious how people approach testing in less dynamic languages. Mostly black-box integration testing? Instead of mocking, just instantiate the struct in each test with whatever params you want? etc etc
Interesting, thanks for the correction and the (excellent) description!
Thank you! I think this is wonderful. Having a Rust lib to play with JS and it's AST will start sprouting really cool tools. I'm currently working on parallelizing the process of compressing JS. It's a very simple implementation that runs UglifyJS in separate processes and joins the outputs afterwards. The stage of the experiment is really premature but I'm interested in decreasing the time it takes to compress Javascript assets. In the future, I think I will use your library to gain even more speed in the process. That is, I'll port uglifyjs into rust.
Many of us keep two panels with code on the same screen, side by side. Scrolling less does help with that a bit. It's not a big deal, though.
(I don't know if the author will see this on reddit, you may wish to contact them via Twitter or email.)
I don't agree that it helps to explain lifetimes better, because the concepts aren't actually similar. They are both properties of variables, and sometimes they are related (i.e., the lifetime of some variables begins and ends as dynamic execution passes through the scope boundaries of the program), but I think saying "it basically means the scope of a variable" is an instance of the kind of vague language that makes lifetime harder to understand. However, if you're saying that they should be presented to learners at the same time so that their interactions can be explained, I definitely agree with you there. Unfamiliar things just take some time and experience to really grasp, even if they're not terribly complex. Over-simplifying doesn't actually help, even if it might get people nodding their heads.
This is nice, but I have one request: tell us which version of Rust that you're using! I'm perpetually terrified of people trying to learn the language post-1.0 who cannot differentiate between current and outdated articles. It's nice that you have a date on there, but I really do insist that all articles on Rust include a version number as well, for the sake of our future users.
Cool! Does it also transpile to Rust?
Awesome. Performance is going to be suboptimal unless a JIT and good GC are also written in Rust, but there are surely a lot of applications where security or reliability are far more important (e.g. Tor Browser), and Servo could use this in those cases. 
What do you say we whip up a reddit link flair for articles that forget to mention a version, and thereby abuse our positions to coerce the authors into fulfilling our desires?
No, I'm implementing it as a VM. It's got some dynamic features (fibers, throwing, ...) that don't translate to Rust. There might be some other languages that are more suitable as a target, but that's really not the plan. The cool thing about the Rust implementation is that the moving/borrowing semantics make it really easy to provide a safe API for extensions. Besides being useful on its own I hope that one day, burn can serve as a plugin language for Rust applications.
Great idea. I was going to do that, but there wasn't much code in there. I'll add it back and to every subsequent article. Edit: I've updated the current article with the output of `rustc -v`
It must have been fun to use Rust's awesome pattern matching to generate and analyze the AST :D
`#[unstable="needs Rust version"]`
Syntax highlighting with a broken syntax highlighter (`#![…]`) is bad form. If the upstream syntax highlighter is not fixed, we need to fix it. If it is, could you update? If it is not, can you substitute manually-fixed HTML for now?
I can just change the css for the errors not to appear in red like that.
Thanks for the ideas! I'll definitely cover those subjects now.
That’s something, but it’s still inconsistent with `#[…]` attributes.
I would also like to see an article about the module structure of a non-trivial project. PS: and one article about using traits and enums for non-trivial purposes, written for people coming from OOP languages.
Some context: [Aheui](http://esolangs.org/wiki/Aheui) is an esoteric programming language designed for the Korean alphabet, Hangeul. It was the first language of this kind (designed in 2005) and still remains a dominant example. It is a stack-oriented non-self-modifying two-dimensional language, with each component of Hangeul syllable indicates the primary operation ("push", "pop", "go-backward-if" etc.), the direction and the argument. Thanks to its non-self-modifying nature, it can be reasonably easily implemented with a conventional compiler framework like LLVM (unlike other multi-dimensional languages such as [Befunge](http://esolangs.org/wiki/Befunge)). There is also an interpreter version of the same language, also written in Rust: [rsaheui](https://github.com/aheui/rsaheui). Implementations in other languages are available in [aheui](https://github.com/aheui/) GitHub account (disclaimer: I've written pyaheui and some very large snippets long ago).
Maybe a pre-recorded video presentation then?
I'm playing with integrating libjit in a fork right now.
So far I've considered the following JIT libraries: + LLVM - Easy to include because it is embedded in librustc but can be sluggish and a bit overwhelming. [GC](http://llvm.org/docs/GarbageCollection.html) is available. + LibJIT - Easy to include because it's so small and is portable but is slow on updates. There is no GC included. + DynASM - Portable and fast, but there is no GC included. But with all of these you have to be very careful to avoid potential exploits in the code you generate - I'm planning on adding JIT once it is standard-compliant.
Nice article! However, *please* don't encourage people to write their own makefiles for library they want to share! [Rust-Empty](https://github.com/bvssvni/rust-empty) does all this with `make lib` and `make git-ignore`. However, that's just the start. The real advantage of using Rust-Empty is avoiding all the annoying things people go through to use other people's library: * Easier emigration to Cargo package manager * Targeted compilation * Generate docs (lint for missing doc comments) * Compiling with '-O' flag * Debugging * Symlink dependency information (since Cargo is not ready yet) * Building examples * Cargo, Cargo-Lite and Travis CI configuration files * Running the executable with current directory set to 'bin/'
Be careful though because everything is subject to change until the first milestone. I think the Javascript lexer included in this project is well-written and really fast. The parser not so much, but I'm working on simplifying it. I'm glad to see this library will be used! At some point I'm going to make the parser and lexer compile seperately from the interpreter so libraries that want to access the AST can do so.
LLVM might be having its JIT overhauled, given that Apple are now using it in JSC and getting overall positive results. I do wonder what LLVM can do with "asm.js"-style code that was produced by emscripten from LLVM IR. If it can reproduce the original IR... then what's stopping it from achieving native performance?
Good point! But there will still be performance lost in compilation, unfortunately. I'll add 'asm.js implementation' as an issue on Github for the first milestone, because it'll really set this apart from the crowd if it's implemented in asm.js.
Well, Emscripten already can take LLVM IR from rustc and turn it into "asm.js" code, so you'd be competing with that. On the other hand, you have higher level abstractions that allow for easier interaction with existing JS code.
/r/playrust
The type system is interesting! As a Boolean algebra enthusiast, I have a couple questions: 1. What made you choose '+' for logical AND and '|' for logical OR? Why not '|' for logical OR and '&amp;' for logical AND? Alternative: '*' for AND and '+' for OR. This is a less commonly used notion but makes it easier to see the similarity with numeric algebra. These rules behaves nicer with the operator precedence of Boolean algebra. 2. Are there any restrictions to the type system? Can you do `(B | C) + D`? Can you build any arbitrary expression? 3. Is it possible to construct two types that are equivalent logically, but treated as different types in the type system? This is a side effect from using Boolean algebra, where one logical expression has more than one representation. You can flatten all expressions and order the terms do unique comparisons. 4. Have you considered restricting the type system to "finite" Boolean algebra? An algebra restricted by OR and AND NOT (exclude) as the only operations can only give finite results if all the variables are finite. In a Venn diagram, it never can return a result that fills the space outside the circles. For example, "this customer wants a not Cake" does not make sense, but "this customer wants some Groceries, but not Cake" makes sense. This could be written as "Groceries - Cake" or "Groceries and not Cake".
Wow, I must say I'm impressed with the work done here and how far you came. Especially the automatic conversion from C++ to Rust. What suprised me is that you are using value-type structs for QObjects instead of pointer-types like the actual QObjects. Don't you run into problems with pointer invalidation (e.g. for the signals) when the objects get moved? I also agree that using signals or any other kind of callbacks ist currently somewhere between next-to-impossible and very hacky. The approach that I had taken was to add a static function to the struct for each callback. That static function takes an unsafe pointer to an instance and the additional parameters. Inside the static function you can cast the unsafe pointer into a reference and invoke the member associated member function. You can store the callback by storing a pointer to the static function and a pointer to the unsafe instance. So it was similar to what you would probably do in C. But cluttered with a huge amount of unsafe statements and ugly casts. I don't think that lifetimes are helpful for the signals &amp; slots. They an help you on some situations, where the relation between sender and receiver is 100% determined at compile time and doesn't change. But that isn't guaranteed in QT. You can move your objects around as you want to. And if you have queued signals it get's even more complicated - in C++ QT you will receive them even if the sender was already deleted. I can only imagine that the situation improves when DST lands. I would then probably make all objects that want to receive callbacks `Rc`/`Gc` only types, make a trait for each signal type and then store `Rc&lt;Trait&gt;` as the destination for the callback. Guess that would similar to Java's `ClickEventListener` &amp; Co. Hmm, but as you can implement a Trait only once that still doesn't solve the problem with having multiple slots with different behavior for a signal. 
Because soft wraps break things in awkward places &amp; doesn't align them, e.g. some_long_function_name(this_argument.a_method(), another_argument.method(a, b, c, d)); versus some_long_function_name(this_argument.a_method(), another_arugment.method(a, b, c, d));
Glad you like it. I think it's a pretty original approach with obvious advantages, though not without its drawbacks. I love compile-time checking but I decided to go dynamic all the way. * `+` and `|` are personal/intuitive choices and not set in stone. I just happen to like the look of: `String+Empty` or `Odd|Even`. `&amp;` for logical AND is a good suggestion, I think it would look just as nice, and it reduces overloading on `+`. Haven't yet decided how to do type negation at this point. `!` would work well alongside `|` and `&amp;`. * Types are arbitrary expressions. Being a type is a type of itself. E.g. `List.of(Integer)`, `HasMethod("json:serialize")`, ... Functions of the form `function( Anything $val ) -&gt; Boolean` are also `Type`s. You could write: `function( function( $v ) -&gt; Boolean { return $v % 2 == 0; } $even ) -&gt; (Integer|Float)+Not(Zero) { ... }` Though I hope people won't take it that far :) * Yes, you can construct logically equivalent types. `Anything` is equivalent to `function( $v ) { return true }` which is equivalent to `Number+!Number`. Comparisons between actual types will not be supported (i.e. `$Type1 == $Type2` causes a TypeError). Flattening and comparisons are just impossible with this level of dynamic typing. Types need not even be strictly logical: `function( $v ) { $program.system.random_bool() }` would be a useless but valid type.
This is the best explanation of Rust memory safety I've seen so far. So many things fell into place after watching this. Thank you! This should really be transcribed into a tutorial and replace the existing pointer tutorial, this presentation was much easier to follow.
Why not? Nothing wrong with writing a simple makefile for a simple task. We should be encouraging people away from make and towards a cross platform build tool (cargo I suppose) in the long run. I dont really see the benefit of championing rust empty in the short term...
That's a really interesting notion, of extending the same ownership semantics of memory to non-memory resources. I had never thought about that. The only issue that I see with it is that memory usage require no initialization or cleanup for its use. Everything else in this article does: threads, file handles, GPU cores, etc. I'm trying to think of how this would work. I guess you'd have a specific trait that object could implement where the destructor was defined in a certain way? Another thing is this seems a very minor distinction from memory being cleaned up automatically. Generally system resources are represented by objects in memory, so cleaning up one of those objects should trigger the resource being free. Is that not already possible with GC in Rust? Wouldn't it call a destructor and, for example, the file handle would be released as the file object is destroyed? edit: grammar/spelling
The issue with that is now the makefile becomes magic for newcomers. Having a simple ~20 LOC Makefile is super simple to understand, which is the whole point. People need to understand how Rust compiles things and such before they use some sort of already-done makefile. Right now, git submodules is the easiest way to manage dependencies, and if you introduce a new dependency, you'll probably have to specify it in a makefile. It's much easier if you understand the makefile and wrote it yourself. I wouldn't even worry about transitioning to Cargo atm. Because that's quite a while aways, and everything will be different when working in a Cargo environment (managing dependencies, building projects, etc....). I don't really see how Rust-Empty could make a migration easier. With that said, it's an option for people to use, which is great. I personally don't use it, but offer it up as a resource for people who want to.
Bit optimistic about the flexibility of our references imo
&gt; You're right, it doesn't. Which is why it's confusing that you seem to insist on thinking of it this way. It isn't the lifetime of the object, so the fact that it doesn't accurately reflect the lifetime of the object isn't misleading. Your interpretation of the meaning of the term is what is misleading. Lifetime means object lifetime in other contexts and languages. The Rust documentation uses it both to refer to object lifetime as well as `'a`. It's not me that is confused. I understand the concept. It's the documentation and the language around the concept that are confusing. 
It doesn't mean "object lifetime" anywhere. If someone says "lifetime of x", and x is an object, then they are talking about the lifetime of an object because of how the term is being used. The term itself doesn't mean "lifetime of an object". The word "lifetime" applies to different things when it is applied to different things. This is how language works on a basic level and shouldn't be surprising. It's even tautological.
I wouldn't necessarily put "reference counting" and "automatic reference counting" in separate categories—they're really the same thing. I believe that Dan Gohman told me that LLVM has some optimizations to strip out reference counts from `shared_ptr` as well; since they're atomic, this is a big win.
Out of curiosity, what is the use case for the following coercion? impl&lt;T&gt; Coercible&lt;T&gt; for [T, ..1] { }
Thanks for answering my questions! I think it is interesting to have a type system like this. Are you familiar with dependent types? I did some playing with Idris for a few days, trying to get a grasp of the idea. Your Burn language got me started thinking about developing something for games. We are building a game engine called [Piston](https://github.com/pistondevelopers/piston) which I hope could bring on some interesting research. This might be a good way to test a language! Specially if one can use a REPL and make stuff happen directly. Rust is nice for games, but it becomes a little tedious to restart every time you make changes. Idris is based on C, which makes it hard to use with Rust. Since Burn is using Rust, this could make it more suitable. It is room for new language ideas in this area. I am interested in a type system with full Boolean algebra, because I have played around with it and seen how powerful it can be. Anyway, great work!
For those who want to follow along at home (or make pull requests!) I've published my preliminary results in [my fork](https://github.com/jdm/js.rs/tree/jit).
We are using Rust-Empty for the [Piston](https://github.com/pistondevelopers/piston) and we are eager to use Cargo as well, but we are not sure if it will replace all the needs in a fast moving project. It might take some time. Rust-Empty is pretty agressive at integrating with other tools and we can do the upgrading without fearing large changes and breaking the tool chain. Make is good for easy tasks, but it is hard to make it scale properly. It takes quite a bit of time to get it right. Whatever project you do, you end up reinventing parts of Rust-Empty anyway. One month down the road and you figure you could just copy that makefile from Rust-Empty to less frustration for people who want to use your library in their tool chain.
I imagine it'll be fairly easy to expose some Piston items to Burn and create a repl gui. Take a look at [errors.rs](https://github.com/rainbow-alex/burn/blob/master/src/libburn/builtin/burn/errors.rs) which exposes some builtin error objects and their types. That's not too bad, and hopefully with macros boilerplate can be reduced even further. There is already a simple cli repl in the burn binary; the underlying code could just as easily be tied to a gui. It's really nice to get feedback and see some interest! I'll keep at it :)
aww was hoping to run rust in a browser but this is fine too ;)
It reminds me of the glGen* functions that take a pointer and length and then fill in that array with the generated resources' IDs. Those often get called with the address of a scalar variable and a length of one, which is precisely this pattern.
There's a function for that already too: [`core::slice::ref_slice`](http://doc.rust-lang.org/core/slice/fn.ref_slice.html)
Note that the `~T` type is now `Box&lt;T&gt;`, and also that *all* values undergo deterministic destruction by default, you do not need to be storing a `T` in a `~T` for the destructor to run when it goes out of scope.
I've seen `pkg.rs`. I haven't seen `bin.rs` before.
In Objective-C they have the significant difference in whether the programmer must manually provide all of the retain &amp; release calls. I don't do C++, is the reference counting described by the author more automatic?
C++ doesn't need explicit reference counting calls to be written by the programmer: incrementing and decrementing can be performed by the copy constructor and destructor respectively.
Yes, it's automatic via copy constructors and destructors.
&gt; Be careful though because everything is subject to change until the first milestone. Anything different would surprise Rust users: ;)
Watchout for https://github.com/mozilla/rust/issues/2235
I have multiple git clones of various Rust projects and I have a lot of lib.rs, a good number of main.rs, but no bin.rs at all.
(Just to be clear: unique pointers aren't special in Rust, they act like any other owned data type with a destructor, in terms of linearity/affine-ity.)
`pkg.rs` is different - it was used as a build script by the old `rustpkg` command, which would compile and then execute it. `pkg.rs` would then call the compiler to build the package correctly.
I think your example would be more like having a type HashMap that implemented the trait Map which would let you use a HashMap as a Map. This seems more like a safe version of reinterpret_cast from C++ where you cast between two types that have the same layout in memory.
I'm tackling [mozilla/rust#6812](https://github.com/mozilla/rust/issues/6812). Although is still a WIP, I have reach a point where other people can start testing it and I'll love to get feedback!
Could some Lazy-struct + lifetimes help me enforce the following restrictions at compile time? Say I'm walking through a stream, resulting in an iterator, where each step is very expensive, but only if evaluated. I want to skip some steps that I don't care about. I could do this with a Lazy-construct in e.g. C#. However, I can only access the variable in the current step of the for-loop, after that the state of my iterator changes so that I cannot evaluate the lazy value anymore. E.g. imagine allocating the string below would be very expensive: let mut i = 1; for s in "hello|cruel|world".split("|") { if i &gt;= 2 { println!("Accessed #{}: {}", i, *s); // expensive, but necessary } else { println!("Skipped #{}.", i); // okay, cheap, *s is never evaluated } i++; //return s; // whoops, not allowed! s is invalid outside this scope } 
Go for it!
See: https://github.com/mozilla/rust/issues/12642 Would that solve the relevant use cases? I think that would be the nicest way to handle these things in the language, if it's expressive enough.
a.foo(b) *is* superior to foo(a, b). This has nothing to do with OOP religion. The main advantage is that in a.foo(b), name foo is local, but in foo(a, b), name foo is global. That is, the main difference is name resolution. Haskell is considering to adopt this name resolution behavior, and the proposal explains advantages and also explains why it has nothing to do with OOP. https://ghc.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
IMO, in C++ foo(a,b) is just as local as a.foo(b), because of how it's overloading works; Isn't there some special rule for namespacing in C++ that allows you to put foo(a,b) in a namespace aswell, if you want, and it still can find it from the types given? http://en.wikipedia.org/wiki/Argument-dependent_name_lookup IMO this is superior, because its a generalised graph - you haven't had to make a decision that one type is more important than the other, imposing an artificial tree structure, when a function has many arguments of different types. EDIT: I've just skimmed through your link , looks like thats similar - they're considering adding something along the lines of C++'s ADL to haskell? IMO the real benefits of a.foo(b) over foo(a,b) in C++ are dot-completion (write one argument, then the IDE gives you a list of applicable functions) - and less nesting when chaining; it would be great if these benefits were universally available independently of anything to do with scope/modules; hence UFCS in D, and i think "|&gt;" in F# does something similar? (but i've never used it)
Wow, Haskell is considering adopting the silly thing I made up—that's great news :)
Try: `let mut array2 = [0, ..100];`
Could it be that is uses `unsafe` code behind the scenes ? :)
I remember doing that when benchmarking too, unless you want to actually benchmark a cold start the first run is always iffy. I had only really thought about caches though, not CPU temperature.
Of course, this initializes it to zeroes. Most of the time, that's what you want. However, if you *really* want to have it be uninitialized until you put the values in, you can use: use std::mem; let mut array2: [int, ..100] = unsafe { mem::uninitialized() }; (This comes with all the ~~fun~~ insecure ~~benefits~~ downsides of having an uninitialized value on the stack, like leaking whatever was there before. The only time you'd want to use this is in some sort of inner loop that needs to be *really* fast.) Edit: you can also use `Vec::from_fn` if you want, but if you're interested in it being fast you probably don't want an allocation anyway.
Great stuff! I'm excited to see more Haskell stuff being ported to Rust. As a general comment, I think in general we can learn a great deal from how Haskellers use their type system, from projects like [quickcheck](https://github.com/BurntSushi/quickcheck) for example. Many of us (myself included) have yet to really begin to leverage the power that our type system affords. Of course we must remember that when we write libraries we are user interface designers, and hence must craft abstractions that are comprehensible to our users. It's a balancing act.
Still not working: error: expected type, found token LIT_INT_UNSUFFIXED(0i64) let mut array2: [0,..100]; ^
Can you initialize to something more interesting than a constant?
You may also be interested in Jane Street's take on Criterion for Ocaml, which uses a different approach: https://blogs.janestreet.com/core_bench-micro-benchmarking-for-ocaml/
Did you try giving the literal a suffix? Perhaps `0i` is what you want. You also seem to be mixing up the type form with `:` and the `=` assignment form.
Well, you could write `let mut array2: [int, 100] = [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];`. `mem::uninitialized()` isn't a constant, though -- it's literally just uninitialized memory, as if you were writing `int array2[100];` on the stack in C.