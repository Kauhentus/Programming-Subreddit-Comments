I wonder how it would be if Rust had some kind of ASCII (easy to type for most using Western keyboards) as one way of typing it and some kind of arguably more readable Unicode symbol as an alternative syntax... *ducks*
Sorry, I got that all backwards, I meant "concurrent", not just "custom". I think the fact that built-ins are faster just indicates that code reuse is really important: someone could implement a single optimised concurrent hashmap that the benchmark could use, as it stands it's left either implementing one by hand (hard work, so it's left with something slower than necessary) or using the built-ins, even though there are other more appropriate data structures for the task at hand.
We could use vim's conceal feature so e.g. `&lt;&gt;` displays as `〈〉`.
I keep thinking that we really need programming specific symbols to disambiguate syntax for humans and the compiler. That `&lt;&gt;` is used for both comparison and type parameter lists results in needing :: to disambiguate `foo::&lt;uint&gt;()`. And `[]` for type parameter lists would conflict with indexing. There's just no good solution. We need more symbols, ideally designed to express certain programming concepts.
NB. this argument works both ways, that is, if we currently had `[]` for generics and were considering moving to `&lt;&gt;`, then people could create some code that could be considered to be more difficult to read with `&lt;&gt;`. (I personally don't think the `[]` version is so different to the `&lt;&gt;` of the example you give.)
In a monospace font, they are all the same width.
Clashing is not the only way in which something can be difficult to read; if it was, we probably wouldn't have this RFC (or no-one would support it).
It's worth noting that this would fundamentally break parametric polymorphism, since you would not be able to tell how a generic parameter will be used by looking at the signature. `fn foo&lt;T&gt;(x: T)` currently can do literally nothing with `x` except move it around in memory. With a "trait switch" all bets are off, e.g. `foo` could coerce `x` to `Writer` and write to it. Parametric polymorphism allows users to have guarantees about exactly what a function will do, helpful for reasoning about side effects (or lack thereof), etc.
&gt; a single optimised concurrent hashmap that the benchmark could use, [Not optimized, but concurrent](http://play.golang.org/p/8pJ7gTuuJR). I spent ~30min to write those 3 naive implementations. I'll later see whether those improve the benchmark or not.
There actually was a bug in Go's standard library I saw a while back (can't find the link for it now) caused by exactly that. One of the networking methods that took a `Reader` automatically checked to see if it also implemented `Closer`, and if so, closed the stream on EOF. While not strictly a bug, it was undocumented, and caused a fair amount of confusion because the method took a `Reader` and not a `ReadCloser`. Nonetheless, I do think that trait switching would be useful to have for Rust's `Any` if nowhere else, since it already throws a lot of typing rules out the window, and it would make it more flexible to use.
The language is getting close to 1.0, we're just getting started.
Thank you! You have just changed my life! Rust looks great with Hasklig, especially arrow-heavy parts.
I'm more used to `&lt;&gt;` just because I come from a Java background
For me this simplified version does work: http://is.gd/SgK31Q A possible alternative is to use `iter`. Take a look at this example: http://is.gd/GQxFtC EDIT: I looked to your code and it looks like a compiler bug... The last pattern should be reachable! If you delete it, the compiler will complain that the patterns are not exhaustive.
Not at all. Here is a shortened link to Piston docs feed: http://is.gd/wP4O4C Was generated by [rust-docset](https://github.com/vhbit/rust-docset) with providing a simple file: [docset] name = "Piston" bundle_id = "piston" version = "0.0.1" type = "docset.rust" doc_dir = "../doc" out_dir = "doc_out" [feed] base_url = "http://s3-us-west-2.amazonaws.com/net.vhbit.rust-doc" upload_cmd = "./upload.sh" 
basically the problem is humans don't have enough fingers, that in turn restricts the design of keyboards
No, the *spacing* is the same in a monospace font, but any given glyph may be lighter or darker on the page based on the number of strokes, their thickness, etc. Monospace fonts do generally tweak the glyphs to get a consistent [color](http://en.wikipedia.org/wiki/Type_color) (for example, the long tail of `t` and `l` and the wide serifs on `i` and `1`), but it's not the case that all characters are equally dark.
[Some `f32`/`f64` values do not compare well against other values](http://doc.rust-lang.org/std/cmp/trait.PartialOrd.html). If you want to disregard such values, you can use [`.sort_by()`](http://doc.rust-lang.org/master/collections/vec/struct.Vec.html#method.sort_by) method: floats.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Equal));
I did find this but I am not sure if I understood all of it, it sounds like what you were talking about. https://github.com/rust-lang/rust/issues/10320 I didn't realize that languages had to decide how to handle this.
A solid 2 on Wadler's scale.
`[a]` works, but then `[a, ..rest]` is erroneously reckoned as unreachable. (This is a bug—I have no time now, but you should see if it’s been filed, and if it hasn’t, file it.) However, you can work around this by requiring at least two elements with the pattern `[a, _, ..]`. [Demonstration](http://play.rust-lang.org/?code=fn%20main%28%29%20{%0A%20%20%20%20let%20vects%3D%20[%26[1u%2C%202%2C%203]%2C%20%26[1]%2C%20%26[]]%3B%0A%20%20%20%20%0A%20%20%20%20for%20%26vec%20in%20vects.iter%28%29%20{%0A%20%20%20%20%20%20%20%20let%20msg%3D%20match%20vec%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20[]%20%3D%3E%20format!%28%22empty%22%29%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20[a]%20%3D%3E%20format!%28%22only%20one%20element%3A%20{}%22%2Ca%29%20%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20[a%2C%20_%2C%20..]%20%3D%3E%20format!%28%22many%20elements%2C%20first%20is%20{}%22%2Ca%29%0A%20%20%20%20%20%20%20%20}%3B%0A%20%20%20%20%20%20%20%20println!%28%22{}%22%2C%20msg%29%3B%0A%20%20%20%20}%0A})
Screenshot?
No, QWERTY was designed to prevent typewriters from jamming, and to allow salesmen to type the word "typewriter" using only the top row.
I stand corrected.
[Small example](http://imgur.com/TbzxSgl).
Filed a [bug](https://github.com/rust-lang/rust/issues/15307) for it.
I'm on `rustc 0.11.0-pre-nightly (90ab2f8b616634cff8e02f12c529504c088d52e8 2014-07-01 01:01:36 +0000)` in x86-64 Linux. It is a very recent change and the nightly might be yet to catch up (I think win32 nightly didn't have that change when I've last checked).
No one is saying, including the author, that writing programs in Go is a bad idea. He's just saying there's no compelling motivation to do so. It's not dismissive, it's reality. That being said, Go is a very young language. We wouldn't judge Java on 1.0 now, for example. EDIT: after thinking on it for a moment, this is something I like about Go -- it's a tiny language like C, you can literally learn it in an afternoon -- so +1 to you for that somewhat unclear reference
For your information, it was written `[\ \]` in the plain text.
[] is hardly astonishing, it is just different. Once you've seen one example, you'll get it. Astonishing is when things don't behave as you expect.
Thanks for your help, you guys are awesome. Just downloaded the 2014-07-01 nightly and its there, I didn't realize the change was so recent. Just had to change floats to mutable and it worked. Thanks again.
Their use is as easy or easier in Erlang, Rust, and Nodejs. The later is a stretch because there is only one thread. Haskell, Ruby, and others have them but they are a bit more primitive. The only really bold choice they made was to not have implementation inheritance, which I think was a great decision. Also the tooling they provide is excellent: go and gocode are like an instant IDE wrapped up in two command line apps. That being said, I think the one thing people overlook about Go is that it's a very small language making it very easy to pick up. This may be what makes it succeed long term.
I agree it reads better (and I come from C++), however the issues of `&lt;&gt;` are well known; I'd like to be able to say the same about using `[]`: what of conflation with indexing ? If we are to change toward braces, what of `()` or `{}` ? fn parse&lt;'a, T: Encodable&lt;Encoder&lt;'a&gt;, IoError&gt;&gt;(value: T) fn parse['a, T: Encodable[Encoder['a], IoError]](value: T) fn parse('a, T: Encodable(Encoder('a), IoError))(value: T) fn parse{'a, T: Encodable{Encoder{'a}, IoError}}(value: T) *Note: even though strange, I would think that `{}` might be the less likely to lead to grammar ambiguities; not only are those always paired, but they are also only used to delimit blocks... unless recognizing a code-block from a parameters-block would prove ambiguous of course.*
Clay does this as well, I find it more pleasing than &lt;&gt;. OTOH it's not worth the churn at this stage of rust's development anymore.
About a centimeter per row versus having to remember arcane numeric values. I'm not really seeing the downside to be honest. Hell, Give me a numeric keypad sized or slightly bigger symbology pad off to the left for programming. I know a lot of people who would use it.
The comparison to c/c++ is false. Fortran (shudders of the thought of that arcane language) is still better designed and more efficient than c/c++. Regarding "rust pointers are c pointers" - in fact due to ownership they are Fortran pointers and thus Rust can beat c/c++ in performance, at least once rustc utilizes all its knowledge about the code. One main difference is that in c/c++ pointers can overlap which blocks many optimizations. 'restrict' in C is an attempt to improve this somewhat but IDK if that actually helps that much in reality. 
I agree. Haskell has an excellent theoretical base but it is a horribly complex and incomprehensible from an engineering point of view. A "regular" programmer that wants to get things done should not need to have a math PhD or go read advanced type-category math books just to understand how to print "hello world" to the screen. Kinda reminds me the time when I tried to install Debian from 6 floppy disks some 12 years ago and the primitive installer they had started asking me questions such as the physical layout of the hard-disk. 
/u/long_void ?
While I agree with most points, I don't agree with the one-language-fits-all myth... As it is now, Rust is appealing for C/C++-like languages developers: it is just too low-level for many tasks with no options to make it higher level if the developers are willing to pay for it. It's just not there. Of course the language is appealing, but I wouldn't trade Python for it to do my job, just as I would never use Python for some other jobs. And I don't find Rust that expressive. Compared to C, well, yes. But even compared with C++, I'm not really sure... (Just to be clear, I'm not bashing Rust which is already a fine C-like language. I'm not bashing the article either: the zero cost abstractions are there with improved expressiveness. I just don't agree with the conclusion)
No, because the brackets have empty space around them, while &lt; take up most of the monospace width. So while yes, the character space is the same, but not the actual pixel width.
Maybe I read this too carelessly, but I came away with the impression that the author is using the "zero cost abstraction" goal of Rust to differentiate Rust from C++. Isn't this, instead, something that Rust *shares* with C++? I haven't spent any time programming in the latter, but I'm pretty sure that Bjarne is well known for aiming at the same target.
I still think the former is better. Just because some collections use generics doesn't get rid of the advantage for those that don't.
You may want to check atom.io, which is similar to Sublime and has a plugin for racer integration
D uses the third form. While code is easier to scan than with `&lt;&gt;` I find it more confusing that parentheses can occur twice in a function call.
I don't think this principle is very applicable in this case. 1. Rust is already a mix of ML, C, [...] -syntax, so anyone who is coming from a C/++ background will already be wary of any potential differences when they come to the point of having to read this kind of code. There is not much precedent for assuming that the syntax of this feature is going to be a certain way. 2. Rust is a tool to be invested in, more than it is a tool that is sporadically used. Take for example web pages; a lot of them will have to serve people who are only going to be needing them once, maybe for as little as on the order of minutes or seconds. Then you probably want to be as unsurprising as possible, since any annoyance ("This does not match my expectations") is going to be a real nuisance, relatively speaking. Rust, on the other hand, is more of a tool to invest in. And for long term investment, minor upfront 'surprises' are not such a big deal in the long term. Though this *could* be a problem if someone switches between languages a lot. 3. If the only contention under question is whether to use (&lt;,&gt;) or ([,]), then the language might be unsurprising (not astonishing) at least up to this concrete syntax; generics are bracketed, as opposed to for example being "curried" (Haskell whitespace significance). This seems internally consistent, and consistent with languages like C++. Does the concrete bracket-y symbols make it 'astonishing'? 4. As argued in the last point, the concrete syntax doesn't add any complexity or subtleness, assuming that you accept and can think of both these pairs of symbols as bracketing symbols (and C++ programmers should be able to identify both in that way). In this light, I imagine that this kind of reaction: &gt; Oh, they have a different bracketing symbol for this thing. This syntax sucks! is more likely than a reaction like this: &gt; Oh, there is some kind of sigil or character in this type. I don't understand! Or, at least if they've been following a tutorial or something, and not encountered it 'in the wild'. If this is true, then this seems more like a *marketing* (appealing to a demographic) problem rather than a *useability* problem. 
Say what you want about Haskell, but I think its syntax is incredibly well-suited for its... well, semantics (currying and whitespace as function application, for example). (That is what the topic is, right? "code that *looks* almost like Haskell.") Whether that syntax would suit Rust is a totally different matter, but I find it hard to imagine a better syntax for a programming language like Haskell. 
&gt; primarily robust pointer and type systems that offer safety and expressiveness with as close to zero performance penalty as possible the point is zero cost abstraction of things C++ does not do
Yay! 
I used to think there's a 0% chance Rust would ever gain dependent types, but these days I think there's a 1% chance.
Cool, I have a few questions. 1. So the idea of the "proofs" is to actively force the caller to do argument verification, rather than having functions verify their own arguments? 2. Are the proofs intended to be performed at runtime or compile time? 3. So the author objects to the Maybe monad (Option&lt;T&gt; in Rust) because he insists the compiler shouldn't permit the function call unless it can prove b != 0. But what about functions whose return value depends on external input? For example, a function that connects to an HTTP server and returns a GIF, unless there is some error along the way (no network/timeout/404/etc). 
 1. It's about callers being able to, and required to, prove that preconditions are met, and callees being able to make use of the proof (to, e.g., derive further proofs, satisfy preconditions of other functions, etc.). 2. Depends on the language and probably implementation. Probably some of both. As far as I'm aware type erasure for dependently typed languages is an open research question. 3. The idea is basically that static proofs would replace those cases where in Rust you might otherwise have to resort to `fail!()`, i.e. the caller failed to satisfy preconditions, i.e. a runtime bug. If instead of enforcing the precondition in this case you propagate it to the output as an `Option`, then the *caller* will end up having to call `fail!()` if they get `None`, because there's no other reasonable thing to do. (Haskell also uses `error` in this case, which aborts the program with a message, not `Maybe`.) If dividing by zero doesn't signify a bug in the program but a legitimate runtime condition, e.g. you are writing a calculator application, then the `Option` approach is appropriate.
http://twdkz.wordpress.com/2014/06/26/teenage-haskell/
I can understand that the Go designers may not want to extend the language to the point of adding algebraic data types in order to implement something like Option instead of pointers which can be null. But why can't they just make some kind of special type or syntax for non-nullable and nullable pointers? Something that is lightweight enough that it only makes the language a little bit more complex, but gives you the crucial benefit of guaranteeing that you can't get null pointer exceptions (or "panics" or whatever the correct terminology is in this case)? 
So for Rust, with hypothetical proof notation, the first case would fail dependent typing, while the second would succeed? fn quotient(f1: f64, f2: f64) proof(f2 != 0) -&gt; f64{ f1 / f2 } fn fails() -&gt; f64 { let f1: f64 = some_float(); let f2: f64 = other_float(); let quot = quotient(f1, f2); uses_quotient(quot) } fn succeeds() -&gt; f64 { let f1: f64 = some_float(); let f2: f64 = other_float(); let quot = if (f2 != 0) {quotient(f1, f2)} else {0} uses_quotient(quot) } (edit formatting)
"Rust’s entire pointer system which guarantees memory safety without a garbage collector, compiles to code that looks like the equivalent C. All pointers are C pointers, there is no tagging, no runtime checks, and generally just no runtime overhead for the safety the borrow checker gets you." Isn't that only the case with Owning pointers? I mean the ref counted ones have some overhead I would think? 
The basic idea is right, but I'm not sure if it (hypothetically) could/would work like that for plain `if` expressions. What would definitely work is having a function like fn test_eq&lt;T&gt;(a: &amp;T, b: &amp;T) -&gt; Either&lt;proof(*a == *b), proof(*a != *b)&gt; (heck, maybe in Dependent Rust the `Eq` trait would return this instead of `bool`) and then let quot = match test_eq(&amp;f2, &amp;0) { Left(proof_eq) =&gt; fail!("divide by zero"), Right(proof_neq) =&gt; quotient(f1, f2, proof_neq) } Proofs are just values like any other, so `quotient` would be more like fn quotient(f1: f64, f2: f64, proof_nonzero: proof(f2 != 0)) -&gt; f64 (but maybe the compiler could automate some of this and pass some proofs implicitly, like with type classes (traits), I dunno) A basic principle in dependently typed programming is that functions shouldn't merely return statements of things, e.g. whether two things are equal, a listed is sorted, etc., but proofs which the caller can make use of.
This RFC has since been closed. There's no point in further discussing it.
Yes and no. Reference counted pointers (and by now owning ones too), are purely a library feature. They are not part of the language as such, therefore it's a fair claim to make I guess. If you refer to any kind of "pointer" available in Rust, some of them certainly have an overhead though. Personally I found myself disagreeing with this, because as soon as Dynamically Sized Types land there will be fat pointers, which are not ordinary C pointers. So, this claim certainly won't hold true for long.
Note that this actually happened on 7/1, not 6/30.
Ah crap...
I don't think we got to any, in fact.
Mozilla does not have time machines. The meeting was today, not yesterday.
Idris is a bunch of fun. Bit hard to get installed though, I found. But I've always been hopeless when it comes to Cabal.
Arc&lt;Exclusive Vec Box Buffer T&gt; 
My experience has been that making contracts part of the type makes for very fragile type signatures that are very annoying to work with. Surely something more like [Spec#](http://research.microsoft.com/en-us/projects/specsharp/) or [Dafny](http://research.microsoft.com/en-us/projects/dafny/) is the way forward? The same team that made those is making a dependently typed F# called [F*](http://research.microsoft.com/en-us/projects/fstar/), so maybe some interesting things will come out there.
I think there are two major directions on improving the type system. One is to make it specialized to solve a particular set of problems (e.g. Rust). Another is to make it generalized enough to solve many problems if you want (e.g. dependently typed languages). I expect both will coexist for long time, as there are considerable pros and cons for each directions. That said, Rust wouldn't likely be dependently typed but it will never diminish the value of either Rust or dependently typed languages.
That's exactly what I said... I did not say that C has bad performance, I said that Fortran can still beat it which is why HPC still uses Fortran to this day for the low level performance critical calculations.
Wherever fortran beats C in some benchmarks, it should probably be seen as the C compiler's failure.
Sweeeeeet
`restrict` has problems: e.g., it makes it easy to invoke undefined behaviour by accidentally passing aliasing pointers to `restrict` arguments.
Is rust-graphics designed to be a 2D graphics library along the lines of Cairo (http://cairographics.org/)? Firefox uses Cairo to render page content and UI. Could Servo use rust-graphics for the same purpose?
Agreed. So it is certainly easier to write high-performance fortran than high-performance C.
I find it silly that people have such a hard-on for dependent types, but completely disregard linear dependent types. I want a type theory with subtyping, resource consumption and correctness reasoning built-in, is that too much to ask for?!
Is there any real chance of getting the D syntax, `foo!(bar)`, where bar is the template parameter? It could use a different character than `!` to avoid the ambiguity with unary prefix `!`, maybe `$` or `|`, or one of the newly-freed-up sigils. I do realize this would be a pretty big change with uncertain gain, but hey, I can dream (or speculate, rather).
I would use C++'s though. Not because it's anything great, but if Rust is specifically targeting C++ programmers, it should do anything it can to make transition easier, especially with something as minor as this. Also, there's no point in changing it now anyways, there's no real benefit. If someone feels really strongly about Rust's syntax, they can always make their version of coffeescript.
I see it from a somewhat different perspective. The goal of a type system is to allow as many good programs as possible to be expressed and as many bad ones as possible to be rejected. And that duality basically defines what I see as the two major directions. I think Rust should bow down to no one, including Haskell, when it comes to improving expressiveness. On the other path lies GADTs and other features useful for theorem-proving, culminating in dependent types, which is a direction Haskell is increasingly moving in. I think Rust is and should be less interested in that direction.
The objection I've seen to linearity + dependent types is that it's not clear how values of linear types should behave at the type level. I mean just as a completely meaningless but illustrative example: fn string_eq(a: String, b: String) -&gt; Option&lt;proof(a = b)&gt; { /* oops, `a` and `b` have been moved into the return *type*, can't refer to them here */ } which is of course totally absurd. One solution might be to have both linear types and non-linear ones and only allow the latter to occur in types. This is what Rust is doing, even if it doesn't realize it yet. If/when we gain general support for [`static` values in generics][1], I think `Copy` is the clear boundary for the types it could-should-would work for. And once you say that the types of values which are allowed at the type level are the ones which are `Copy` (or in other words POD), that also resolves the linearity + dependent types puzzle. This observation corresponds to the 1% chance I see for Rust ever gaining dependent types. [1]: https://github.com/rust-lang/rfcs/pull/56
Well, they can anyway, if a language contains a concept of “callables” or first order functions: class Clbl: __call__(self): pass Clbl()() Or: def foo(): def bar(): pass return bar foo()()
Expanding on your last example, one thing that may trip people up is stuff like `s[i] as char == '\x80'`, `s[i] = '\x80' as u8` (the same as `b'\x80'`), or, worse, either of those examples with a larger char, like `'\u1234'`. (The thought process I can visualise is someone trying `s[i] == '\u1234'`, getting an type error about `u8` and `char`, and just casting either side.) In any case, [the removal](https://github.com/rust-lang/rust/pull/15085) has now landed.
https://github.com/rust-lang/rfcs/pull/150/files#diff-25c9ac05b1979f1f274531a315ccfae9 Seems unlikely Rust would go in this direction, but here's an idea that attempts to combine the graph-like import of other module-systems with the hierarchical module-tree of Rust.
It's a very cool font, ~~indeed~~ really. It's a shame that the editor/terminal support is so limited EDIT: remove forbidden word ;)
&gt; It's a shame that the editor/terminal support is so limited Indeed!
Yes, it is meant to be used for similar purposes, but it is not finished yet.
That's precisely the reason I find it confusing. Your example is my default interpretation.
For vim and haskell I am using this: http://www.vim.org/scripts/script.php?script_id=3200 It seem to try to do the same thing, but in a different way. Don't know how it compares. I also think it would require minor tweaking to make to the plugin active on .rs files.
I would like to use Vim conceal to replace `&lt;&gt;` with `〈〉` which I find easier to read. However, in gvim, gnome-terminal, and xterm `〈〉` display as double-width while they display as half-width in Leafpad using the same font (bitstream vera sans mono), my web browser using the same font, or in the gnome-terminal font selector. Anyone have any ideas? I'm also taking suggestions for alternatives to `'` for lifetime annotations. `〈’a〉` vs `&lt;'a&gt;`?
[Indeed!](https://www.youtube.com/watch?v=VyQ2i98wl9w)
Works perfectly with [Kate](http://www.kde.org/applications/utilities/kate/)
A few days ago a change in Rust broke a certain kind of abstraction used in Rust-Graphics, resulting in the trait system having more restrictions on lifetimes. Rust-Graphics is now working again with slightly different assumptions.
imagine if all the bracket types [] () {} &lt;&gt; had slightly larger/smaller versions substituted for nesting levels
See also [this comment][1] by Edwin Brady in the /r/haskell discussion with a solution in Idris along the lines I described. [1]: http://www.reddit.com/r/haskell/comments/29kv2y/why_dependently_typed_programming_will_one_day/cimhyt0
Nice article! I actually think we are fine with `Option` and `Result` types... Won't having to make proofs before calling a function be a huge source of boilerplate? I would love to see real world code examples of how this would work! EDIT: here I found some code http://www.reddit.com/r/haskell/comments/29kv2y/why_dependently_typed_programming_will_one_day/cimhyt0
I'm intrigued by the mentions of () for indexing arrays rather than [] (used in Scala). Conceptually, it makes sense: indexing an array is kind of like a function that takes an integer and returns an element of that array (if valid index). This solution seems more uniform than to use brackets for indexing. 
I recently saw https://github.com/conduit-rust and am perplexed how similar the repository descriptions on this one and https://github.com/iron look! What's going on there? Two similar projects started at the same time? Any plans to work together? (I saw a pull request on conduit by the author of iron.)
That's me! Iron's a bit older than conduit and has more middleware built around it. Conduit is a bit more ground up. We are planning on collaborating and making both of our frameworks better. Conduit's major advantage is that it is implemented more of the tech stack - Conduit is by the same team that did the port of Civets to Rust, so they have the freedom of using another http library. Iron is a bit further along in its development, though. We only discovered each other about a week ago! It was pretty funny that we'd missed each others development for the whole time until then.
Don’t give the rules away! It’s supposed to be a secret thing only for the observant!
I wonder if, now that we have byte string literals where `b'\x80'` and `'\x80'` are different, we should change the `\xXX` escape sequence to define a byte in general, to make them consistent again.
For the 5% observant, it might be beneficial to include a rule stating this is not the Rust game. After all, 5% of 10000 rust-game-server-announcements is still 500 less pages I have to open! Think of the power we would save, indeed!
This font seems like it'd work well with just about any ML inspired language. Now if only it worked in Visual Studio, because reasons.
Vim conceal is not usable for me. Lines look different when you put the cursor on them, so basically they look nice (concealed) when you aren't looking.
Looks a lot like [Futures](http://doc.rust-lang.org/std/sync/struct.Future.html).
This was proposed in [issue #2800](https://github.com/rust-lang/rust/issues/2800). As discussed there, I am against this. I’d be ok with restricting it to the ASCII range in (Unicode) str and char literals, as proposed [in the discussion of issue #12769](https://github.com/rust-lang/rust/issues/12769#issuecomment-43574856), but that’s also inconsistent. (`\xXX` is actually the only way to get non-ASCII in byte and byte string literals.)
KDevelop FTW :) But for simple tests I just use Kate + Konsole
Also https://github.com/floor-org/floor , https://github.com/jroweboy/oxidize and https://github.com/Ogeon/rustful
Indeed, not even I can fully fathom the profound wisdom of rule number 6.
&gt; I find it more confusing that parentheses can occur twice in a function call Well, D prepends a bang before compile time arguments, which is how it avoid ambiguity. Example: void foo!(A)(A someTemplatedType) if(isOutputRange!A) { /* */ } Where the parens after the bang is optional if only one parameter is supplied. 
With negative bounds: trait MaybeShow {fn has_show(&amp;self) -&gt; bool;} impl&lt;T: Show&gt; MaybeShow {fn has_show(&amp;self) -&gt; bool {true}} impl&lt;T: !Show&gt; MaybeShow {fn has_show(&amp;self) -&gt; bool {false}} But that's not certainly on the radar (maybe `where` would support it?). For runtime erasure of the set of traits that a type implements, see [Many](https://gist.github.com/eddyb/f828f8ce819a5f00d42d) - that has the drawback of requiring explicit listing of all the traits a type implements (which isn't an issue in its original usage scenario, which is an extensible kernel device tree).
I mainly use kdevelop for its file sets - you can easily switch between the files you have open for specific branches in a larger project (think rustc PRs :P).
Maybe it's on nix? If it is it should be a breeze to get working. 
that hello world benchmark you mentioned in readme, that is just writing a static string? Did you compare it to go?
Is there any idea how many more point releases there will be before 1.0?
1.0 is 'by the end of the year', (not a hard deadline but pretending it is) and point releases are every three months, so.... one or two?
n = number of months until release so its around ceil(n/3) - 1 releases in between
You can use the script: $ curl -s http://www.rust-lang.org/rustup.sh | sudo sh Standard warnings about `curl | sudo sh` apply. But you can run this whenever you want and it will give you the latest nightly.
Using Homebrew I think you can just "brew reinstall --HEAD rust"
&gt; brew reinstall --HEAD rust Seems homebrew is pulling a lot of source code back to local and started compiling. I don't think it is a good way since the compilation time is unnecessary (we have the binary already)
I tried to benchmark, it starts fine (about 2 seconds) and then just a bunch of errors: &gt; ERROR:http::server: finishing response failed: broken pipe (Broken pipe) Another problem is cargo does not compile with optimizations enabled ATM.
I'm glad you're having so much fun with this! I've been (silently) waiting for Sublime to support ligatures just so I could use Hasklig more often.
Unfortunately it doesn't compare favorably to Go or many other more mature languages. This is due to a combination of things, some of them our fault and some of them just caused by an immature ecosystem for basic http.
I sometimes get that error when trying to hit the server with many, many concurrent requests.
Cool, any inspiration from Go? The request and response paramater pattern looks familiar.
Yeah, I was using wrk. Now I noticed that it does not display the messages until the benchmark is done (probably wrk closing TCP connections and server trying to flush)
I get 9k for iron vs 35k for go. The question is what is the boost when compiling with optimizations. edit: and that was only using 1 core for go
That is a common pattern, Java Servlets use the same thing.
I know, sad that sublime doesn't have them :(
I use: #!/bin/sh if [ "`uname`" = "Darwin" ]; then target=x86_64-apple-darwin else target=x86_64-unknown-linux-gnu fi mkdir /tmp/rust-update cd /tmp/rust-update curl -O http://static.rust-lang.org/dist/rust-nightly-$target.tar.gz tar xf rust-nightly-$target.tar.gz cd rust-nightly-$target ./install.sh # --prefix=$HOME/code/rust cd $HOME rm -rf /tmp/rust-update and for cargo: #!/bin/sh cd /tmp/ git clone --recursive https://github.com/rust-lang/cargo cd cargo make make install cd $HOME rm -rf /tmp/cargo https://gist.github.com/bjz/e3ca7c0f925eae6d3f23
I'm not sure what you mean. But as far I understand it self does not have any "method namespace" if could fall back to. It's just a bare pointer to something neither the compiler nor the runtime can figure out in the most general case. Can you maybe give an example? 
This is the wrong subreddit, you want /r/playrust
Didn't happen in a while…
Teal'c would like a word with you.
the methods added with a traitless impl e.g. `impl Foo { fn foo(&amp;self){...}}` // foo is in the namespace of type Foo:: vs `impl Bar for Foo { fn bar(&amp;self)}` //i'm told bar is actually in Bar::, not Foo::. EDIT: the 'fallback' is taken when looking for the implementation of a trait for a known type, not in the definition of generic code(which would only see trait methods there)
Generally I don't like building packages locally since it is slow, costly and error-prone. Sorry I didn't get what strcat/thestringer is, is it some binary build system like open build system I use in openSUSE?
`use std::collections::{DList,Deque};` works fine for importing Deque and DList. Edit: I looked at the docs and when it says &gt; DList implements the trait Deque. It should be imported with use collections::Deque. it means that you have to import Deque in addition to DList.
DList is a concrete implementation, Deque is a trait, you have to import both of them.
I figured that out not long after posting this. It seems a bit clunky.
Hello, maintainer of rust on MacPorts here, I expect rust will be up tomorrow.
Yes, eventually, cargo will support this. It's currently a pre-alpha. It _just barely_ does enough to be useful. Give it time.
I've been managing well with `su` and `git pull &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install`.
Would like to hear constructive feedback.
&gt; The &amp; literal has a different meaning from in C. (Confused programmers) &gt; &gt; The &amp; literal does not naturally translate to the concept of 'a reference' or 'an address'. (Confused new programmers) In what way? `&amp;x` is "take a reference to `x`" (aka "take the address of `x`"), i.e. basically identical to the C use of `&amp;`.
You can theoretically use nested patterns [here](https://github.com/arjantop/tftp-rs/blob/a32fdadbf97d06bd438fca27f45483b75a6da5da/src/tftp/netascii.rs#L29-L32): Some('\r') =&gt; { match chars.next() { Some('\n') =&gt; ... You can probably be slightly more efficient by preallocating `String` via `String::with_capacity` if you have an estimate on how long they will be, e.g. [here](https://github.com/arjantop/tftp-rs/blob/a32fdadbf97d06bd438fca27f45483b75a6da5da/src/tftp/netascii.rs#L24) and [here](https://github.com/arjantop/tftp-rs/blob/a32fdadbf97d06bd438fca27f45483b75a6da5da/src/tftp/netascii.rs#L53). If you want to be careful to not overallocate, the first could be `s.len() / 2` (since the text could consist entirely of `\r\0`, meaning two input bytes for every output byte) and the second `s.len()`. If you're fine with overestimating slightly, the first could be `s.len()` and the second `2 * s.len()` (although you may regard a string of entirely `\0`s (causing the length to double) are fairly unlikely, so preallocating only `s.len()` or a smaller overestimate, like `s.len() * 5 / 4`, may make sense). Also, if the string decoding is a hot section of code, it seems the only escaping you need to do is on ASCII characters, so it would actually be possible to operate solely on bytes rather than `char`s, which saves the UTF-8 decoding step (the file name certainly suggests that using bytes, or even [`Ascii`](http://doc.rust-lang.org/master/std/ascii/struct.Ascii.html), would be appropriate). (On that note, is TFTP guaranteed to be valid UTF-8? Or, at least, restricted to 7-bit ASCII, i.e. no possibility of isolated bytes like `0x80` or `0xFF`. If not, then `Vec&lt;u8&gt;` and `&amp;[u8]` are the appropriate types, not `String` or `&amp;str`.) Theoretically a library should be [avoiding `fail!`](https://github.com/arjantop/tftp-rs/blob/a32fdadbf97d06bd438fca27f45483b75a6da5da/src/tftp/client.rs#L79) for non-fatal conditions; either returning an `IoError`, or making `get` return a `Result&lt;(), ...&gt;` with a custom error type (e.g. `enum ClientError { Io(IoError), InvalidPacket }`). On that note, I think [this `match`](https://github.com/arjantop/tftp-rs/blob/a32fdadbf97d06bd438fca27f45483b75a6da5da/src/tftp/client.rs#L48) should be avoiding the `fail!` in the `Err`, maybe `let (n, from) = try!(self.socket.recvfrom(buf.as_mut_slice()));` rather than the manual match? (Tiny nitpick, the `println!`s there should either be removed or replaced with [calls to `log` macros](http://doc.rust-lang.org/master/log).) Naming wise [`into_string`](https://github.com/arjantop/tftp-rs/blob/a32fdadbf97d06bd438fca27f45483b75a6da5da/src/tftp/packet.rs#L66) neither yields consumes its argument ([implied by `into`](https://github.com/rust-lang/rust/wiki/Doc-detailed-release-notes#cast-naming-conventions)), nor yields a `String`. Maybe `as_str` would be better? Also, the `from_string` function suffers the same naming issue, and would be better done via [the `FromStr` trait](http://doc.rust-lang.org/master/std/from_str/trait.FromStr.html) (conveniently callable as `from_str(x)`, since there's a `from_str` function in the prelude). Lastly, Quickcheck now has [a syntax extension](https://github.com/BurntSushi/quickcheck#the-quickcheck-attribute), so [this test](https://github.com/arjantop/tftp-rs/blob/a32fdadbf97d06bd438fca27f45483b75a6da5da/src/tftp/packet.rs#L549-L555) can be written as #[quickcheck] fn encoding_and_decoding_packet_data_octet_is_identity(packet: DataPacketOctet&lt;'static&gt;) -&gt; bool { Some(packet.clone()) == packet.encode().decode() } (Unfortunately the macro crate isn't installable via Cargo just yet, although I believe Cargo has recently gained the required functionality.)
`&amp;` is the "address of" operator for C/C++ and other languages. It does essentially the same thing in Rust. The difference is that Rust makes guarantees about aliasing and the lifetimes of pointers. In the type syntax, `&amp;T` is a reference to a `T`, which is somewhat similar to C++ and gives the idea that you're passing a temporary reference to something. The difference is of course that references in Rust aren't aliases like they are in C++; you have to dereference them to access the referent. As for whether 'at "hello"' makes more sense as an addressing operator than 'and "hello"', I think it would actually be misleading. 'at' implies *de*referencing to me. When you say "at x", "x" is a location, while "at x" is definitely not the location of "x". Besides, `&amp;` has a decent history of being "address of" in other languages, so there's precedent for it.
Oh, unless you're referring specifically to the string syntax, where `"foo"` and `&amp;"foo"` used to be 100% identical? Now, `"foo"` is a `&amp;str` (as it was), but `&amp;"foo"` is the same as `&amp;("foo")`, that is, `&amp; &amp;str`: reference to a `&amp;str`/address of a `&amp;str`, matching the C behaviour.
That is an interesting point. What is your opinion on Rust's balance between appealing to existing conventions in programming VS 'what would this look like if I had to implement a programming language today'?
(Sorry for length/train-of-thought-ness.) The code looks pretty good!
According to the discussion, you can still do it, but stating explicitly that you're accessing the string as bytes. Making it the easiest way would have caused so many bugs with novices ("My code worked fine until I used an accented letter!"). People need to be steered towards other ways of working with strings.
&gt; On that note, is TFTP guaranteed to be valid UTF-8? From the [spec](https://tools.ietf.org/html/rfc1350#page-2) it looks like strings are encoded as "netascii" which refers to the 8-bit ascii variant, terminated with a zero byte
&gt; doesn't compare favorably to Go I would be surprised if it did. Highly concurrent socket servers are precisely Go's strongest area. From what I've read here and on rust-dev, it's task model (green threads with segmented stacks) is simply better suited for this than Rust's (native threads with contiguous stacks) EDIT: You should try with libgreen though. Maybe the overhead will be smaller
Reminds me a bit of node's [request](https://npmjs.org/package/request). Really convenient API
Have I ever told you how much of a hero you are for doing these code reviews? I learn things from them as well!
Ah, looks like the `u8` containers may be appropriate than strings.
It is indeed a pain point and there was an [RFC](https://github.com/rust-lang/rfcs/pull/37) for solving that. However there were some uncertainty about the possible solutions (and it has a side effect that harms the backward compatibility of libraries when we are not careful) and it was decided that *for now* we don't seek to find the solution. I guess it will be eventually revisited in the future.
Because structs can implement two traits that both define a method with the same name, say `foo`, and there needs to be a way for callers to disambiguate them. (There are other proposed solutions for this, but we're being conservative for now.)
Yeah, I also did an ab benchmark to iron and found it much slower than go
I understand. Inevitably any modern language has to decide that balance with respect to convention.
Yeah, that is how I see it too. [Rust's green tasks](http://doc.rust-lang.org/green/index.html) have a smaller creation cost than the default native ones, but are still heavier than goroutines, because the stack still needs to be allocated all at once. I'm still working my way through these concepts though, so do take what I say with a grain of salt!
Coincidentally someone asked about this exact situation on [the issue tracker](https://github.com/rust-lang/rust/issues/15358) today. [My suggested solution](https://github.com/rust-lang/rust/issues/15358#issuecomment-47861867) (for now) is manually implementing the trait by taking the expanded `deriving` impl (compile a file containing just the struct with a `#[deriving]` attribute, passing `--pretty expanded` to `rustc`) and adjust the `"type_"` strings to `"type"`.
3000 requests per second? So it's taking a million CPU cycles per request? Is that a joke? A Rust http server needs to be at least as fast as nginx, which means in the magnitude of 100K requests per second on common hardware
An allocator that caches stack segments intelligently. Another possible design is to allocate tiny (4kB/8kB) stacks and unmap several guard pages in front of them, paging in stack space as necessary. This should be fine on 64 bit because there's tons of address space, though the cost of the `mprotect()` calls may hurt.
I srsly don’t know why Travis borked. It does indeed work properly even if Travis errors out and doesn’t let me restart the build.
Excellent!! This is precisely what I needed :)
Looking forward to addition of a C-style `for` loop.
Definitions of `is_space` seem to scream out for a standard C-API header of [`ctype.h`](http://en.wikipedia.org/wiki/C_character_classification)...
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**C character classification**](https://en.wikipedia.org/wiki/C%20character%20classification): [](#sfw) --- &gt; &gt;__C character classification__ is an operation provided by a group of functions in the [ANSI C Standard Library](https://en.wikipedia.org/wiki/C_standard_library) for the [C programming language](https://en.wikipedia.org/wiki/C_(programming_language\)). These functions are used to test characters for membership in a particular class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide characters are supported. &gt; --- ^Interesting: [^Chinese ^character ^classification](https://en.wikipedia.org/wiki/Chinese_character_classification) ^| [^Virtue](https://en.wikipedia.org/wiki/Virtue) ^| [^Kanji](https://en.wikipedia.org/wiki/Kanji) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cine06e) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cine06e)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Theoretically, this could probably be solved by an attribute on a field. Eg: struct Foo { #[decodable_name="type"] type_: ... } But wether or not that actually works I'm not sure about, and someone would have to actually implement that. ;) 
is_space checks a different set of characters than C's isspace function or std::char::is_whitespace.
I'm not sure why you have the impression that it's going to be added.
I've been having a play with different characters. The second line doesn't display correctly in my terminal and the third (a mathematical left/right angle racket) is difficult to distinguish from parentheses: fn parse&lt;'a, T: Encodable&lt;Encoder&lt;'a&gt;, IoError&gt;&gt;(value: T) fn parse〈'a, T: Encodable〈Encoder〈'a〉, IoError〉〉(value: T) fn parse⟨'a, T: Encodable⟨Encoder⟨'a⟩, IoError⟩⟩(value: T) fn parse❬'a, T: Encodable❬Encoder❬'a❭, IoError❭❭(value: T) fn parse❮'a, T: Encodable❮Encoder❮'a❯, IoError❯❯(value: T) fn parse❰'a, T: Encodable❰Encoder❰'a❱, IoError❱❱(value: T) 
That’s a function of `'concealcursor'`.
I'm actually not following the spec with this and allowing more, it still is backward compatible.
I think Rust does very well in balancing "familiar yet fresh" for C++ programmers. When the C++ mind sees let a= &amp;something - you know &amp; is taking an address being unary - so if that actually works you figure it must be filling in some blanks somewhere to make that do what you wanted; There's not too much else it could mean sensibly
I'm sure, its 0x20-0x7F + some control characters I ment as_str, as_string does not even make much sense
That is essentially how Go's interfaces work, yes.
Ok, awesome. :)
Nonsense. The only thing I installed by piping something was homebrew itself, and that wasn't even with `sudo`. Installing with `--HEAD` in homebrew has the *specific purpose* of downloading the latest source from git and building it. Many normal *release* packages on homebrew have 'bottles', which are binary packages.
You can't do that for `unwrap` and `unwrap_or` since `unwrap` takes 0 parameters
(Nitpick: `unwrap` takes 1, `self`.)
`self` is implicit, so to the caller sees `blah.unwrap()` and that looks like it doesn't take any arguments
Ack! They did some nasty stuff with the build tools... I'll probably do it over the weekend.
True, syntactically a method call like that appears to have no arguments; although under the hood it has 1, and with [UFCS](https://github.com/rust-lang/rfcs/pull/132) `Option::unwrap(&amp;blah)` will work.
One crazy thing I always liked about &amp; is that it looks like the 'B' in borrow.
This is slightly off topic, but someone might know. Was it ever discussed to use type inference for default parameters? So using your example: pub trait ToStrRadix { fn to_str(&amp;self, radix: 10u) -&gt; String; } And radix would infer the type uint. The &lt;variable_name&gt;: &lt;variable_type&gt; = &lt;default_value&gt; syntax seems a little unnatural. Was there ever an RFC for this?
You are going to need to build a modern version of GCC in your home directory. Rustc and/or its prerequisites did not build with the g++ 4.4.7 on my system when I tried. (I think it might have been Boost that it failed on)
totally agree
While technically possible, it doesn't jive with Rust's current philosophy. You'd be more likely to get support with a more explicit syntax: fn to_str(&amp;self, radix: uint = 10u) ...which is mercifully free of bikeshedding, since that's exactly what our typical explicit variable declaration looks like anyway.
I don't see why that would make any difference. I can't imagine a system that would require functions to take at least one argument before allowing them to have optional parameters.
it doesn't make any difference, I'm just pointing out that optional parameters are more powerful than default parameters
I honestly do not understand why this is something anyone wants. It seems to me that the iterator protocol being used is generally safer, just as performant (if not more so), and more readable than the C-style loop. Is there any use case where any of those things is not true?
&gt; Tree of data, accessible by single task only, with the only possible long-term reference to the root of the tree, and okay to scan repeatedly from the root =&gt; use box. Memory costs: zero. Time costs: scanning from root each time. Runtime dangers: none I don't think using `Option&lt;Box&lt;T&gt;&gt;` for mutable trees can be considered zero cost. Rust's `TreeMap` is built on `Option&lt;Box&lt;T&gt;&gt;` and yet it's 3x slower at inserts and removals than raw pointers and `unsafe` code due to unnecessary swaps / moves despite having the same memory layout and search performance as C. The same issues are going to occur with any other mutable tree data structure. The same issue comes up against in `PriorityQueue`. In safe code, there's a 30-40% performance penalty due to unnecessary swaps (3 copies) where a single copy is necessary. It's not even possible to solve this with `unsafe` code, because the comparison function could unwind and all the slots in the underlying vector need to remain valid. It currently has a hack where it gets away with a memcpy + memset instead of a swap, but that's going to break when drop flags are gone. `RingBuf` also needs to be written with `unsafe` code in order to avoid being up to 2x larger and 30-40% slower than a proper ring buffer with an uninitialized gap rather than `Option&lt;T&gt;`. Even Rust's `HashMap` is now based on a bunch of `unsafe` code rather than just building on `Vec&lt;T&gt;`. I think the only answer to the issue of writing efficient data structures is to bite the bullet and use lots of `unsafe` code. The widespread usage of intrusive data structures in kernels and games isn't something that maps to safe code without reference counting either. That's why the LRU cache in the standard library is implemented with a bunch of `unsafe` code too.
A bit late to the party, but wanted to add that the @ symbol is used in Pascal as the address of operator. So it's not entirely precedence. Still it's likely that more C++ programmers will look at Rust than Pascal programmers.
From what I hear, nginx does lots of arcane things in order to achieve the speed that it does. There's no reason that Rust couldn't do those same arcane things and achieve the same speeds, but it will take optimization work to get there (and there's no guarantee that the contortions that nginx goes through can be factored out into a useful general-purpose library while maintaining the same raw speed).
I don't grasp the distinction that you're looking to make here. All optional parameters have a default value, even if that default is some implicit analogue of null. What do you mean exactly by "optional parameters" and "default parameters"?
I personally would MUCH prefer to have auto-currying instead of optional or default parameters.
I certainly agree with the reasoning that optional/default parameters should be considered carefully before 1.0 as it could have a big effect on the naming of methods in the stdlib.
been there done that :) didn't like it as much as i thought i would - conflicts with the rest of the syntax highlighting, although I guess you could use greyscale to weight the brackets. Making the brackets slightly taller/smaller is what you tend to do on paper . i suppose it would be quite hard for syntax highlighters to guess when &lt;..&gt; should be matched. (&lt;..&gt; not separated by other unbalanced parens or ";" ?.. would that do it?)
Note that Niko has a plan to, post 1.0, allow slots to be temporarily deinitialized as long as the compiler knows there is no way to unwind while any slots are deinitialized. This may help in some cases.
I've been sitting on a question about program architecture which seems like it might belong here. I'm using Rust to write a single-threaded program which requires significant global state. I'm currently achieving this by passing a mutable reference to a "runtime" object into practically every function and method in my program (since the runtime is required for, among other things, error-reporting, memory allocation, and "decompression" of various tiny ubiquitous data structures). I very strongly suspect that I will never need to generalize my program so that it can, say, execute multiple runtimes concurrently. As such, the status quo leaves something to be desired, especially because I'm having to break Rust's aliasing rules in a couple of places to handle all of the runtime's ownership issues without seriously overcomplicating my program. My ideal fix would be to have one global instance of the runtime which can be accessed everywhere (using wrapper functions to ensure that Rust's aliasing requirements are met). My working plan is to have a `static mut` variable holding the necessary global state, then a `mod rt` containing safe functions for accessing and mutating that state. My questions are: (1) How experimental is `static mut`? Will this pattern remain supported up to 1.0? (2) Some sources tell me that static mut variables can't own memory (or perhaps can't contain any non-Pod data at all). Is this true? If so, is there a fix, other than relying on raw pointers and manual memory management?
in OCaml they have both, but with optional parameters coming BEFORE mandatory ones so that the mandatory parameter actually forces the function to be applied and... that would be material for a third RFC (probably requiring keyword arguments ?)
I meant that default parameters can't save you when you're missing a parameter completely and want to do without it (and never reference it)
The compiler could learn to allow the `TreeMap` use cases with the caveat of needing to avoid `Option` methods since it won't know if they can unwind. The `PriorityQueue` case seems like it will always require `unsafe` code, and even then it won't be fixed without of an effects system (`nounwind`) integrated into generics / traits.
&gt; especially because I'm having to break Rust's aliasing rules in a couple of places to handle all of the runtime's ownership issues without seriously overcomplicating my program If you break the aliasing rules, your program has undefined behaviour. The compiler can and will optimize based the aliasing guarantees. You need to use raw pointers and custom types built on those raw pointers to avoid the aliasing rules.
Alternately we could allow it even if unwinding might happen, and just do a program abort if it does.
&gt; This is interesting. Won't some of these low-level copying overheads be possible to optimise away automatically at some stage? If moves had stricter semantics, a lot of zeroing could be avoided. However, that improvement is also going to mean the `PriorityQueue` inner loop needs 3 copies instead of a copy and a zero operation per comparison. In a world without unwinding, it would be a single copy with no zeroing. The compiler could also learn to be much more permissive with moves by allowing temporary moves out of fields. This is going to be greatly restricted by unwinding, in that you won't be able to have a function call until everything is back in place. Destructors and move semantics don't mix well with exceptions. Rust would compile significantly faster and could have far more relaxed move checking if it didn't support them.
Interesting. That's evil but I like it. :) Presumably you'd be able to lint that off, since some people may want to write 100% exception-safe code—but that's easy to detect and lint about.
I hope they could coexist since some functions would be used more in situations where currying makes sense (e.g. - binary operators), whilst others would benefit more from defaults (e.g. GUI api). I want everything but have been convinced other language features are more important (HKT, multiparam traits, associated types). I hope Rust does get ALL these sugars eventually but they're not showstoppers. 
Hm. When I wrote that sentence, I was under the impression that migrating to a static mut runtime would make it easier to write custom types which gave the runtime internal mutability, but having given it some thought, I'm pretty sure that's not actually the case. Sorry for the confusion. In any case, I understand the risks, I'm transmuting lifetimes with the utmost care, and I plan to fix this problem whether or not I migrate to a static mut runtime; you're not going to see me whining about 'compiler bugs' in the near future, I promise :P
&gt; Destructors and move semantics don't mix well with exceptions. Rust would compile significantly faster and could have far more relaxed move checking if it didn't support them. /u/glaebhoerl's abort proposal would mitigate this. I know you want to get rid of exceptions, but I don't see any way to get the improved UI of fine-grained task failure in Servo without them, and I suspect that Servo is not the only program that would benefit in this way. (In fact, I know it's not: this is important for Yehuda's Skylight use case, in which the Rust code must not fail and must translate exceptions into Ruby errors.) I am sympathetic to the performance argument, but I would like to see if there is a way we can have our cake and eat it too.
Using the redhat devtoolset is much nicer than building your own, there are packages up on people.centos.org Edit: http://people.centos.org/tru/devtools-2/ Install the .repo file in /etc/yum.repos.d Install devtoolset-2-gcc and devtoolset-2-binutils from yum Source /opt/rh/devtoolset-2/enable in a terminal to activate the updated toolchain in that terminal. Enjoy up to date tooling without messing with your main system.
See http://www.reddit.com/r/rust/comments/29qdfp/unable_to_install_rustc_on_centos65/cinnc5q
No, it's not possible to have auto-currying and optional parameters unless the optional parameters come before the mandatory ones. Example: fn slice(&amp;self, begin: uint, end: uint) -&gt; &amp;'a str when curried, you do: foo.slice() this returns you a `fn(begin: uint) -&gt; fn(end: uint) -&gt; &amp;'a str` now try making that auto-curry with the `end` parameter being optional how would it work? It doesn't know whether to execute upon being given a `begin` or to return an `fn` that takes an `end` The solution to auto-currying would be to use keyword args/overloading fn slice(&amp;self, begin: uint, end: uint) -&gt; &amp;'a str fn slice(&amp;self, from: uint) -&gt; &amp;'a str fn slice(&amp;self, to: uint) -&gt; &amp;'a str I think it's fairly clear how to use this `slice` method now, for methods, you could actually put self at the end and optional parameters would work with auto-currying, but not for regular functions since you still need to have a positional argument at the end
What if an optional parameter is missing? Do you execute the function with the default value or do you just partially apply? You need a positional argument at the end to actually apply everything. Alternatively, you need keyword arguments and make non-conflicting function definitions.
I guess if we did have arity-overload, it would be easy to write a macro to generate currying if you wanted it. &gt;&gt;unless the optional parameters come before the mandatory ones. how about, simply, the act of adding defaults removes the currying option. My hope is some functions suit auto-curry - e.g. binary operators - and they won't have defaults. So basically the library writer takes the decision, which is more useful. Add defaults or auto-curry. The hazard comes if people leave off defaults and start to use with currying, at that point the library writer is constrained by users to not add defaults. and you can always recover something similar to currying with closures... the closure syntax in rust is nice enough |x|foo_bar(a,x) just 4 characters saved by currying really 
I haven't seen this proposal. Can you link it?
That's exactly why I prefer one over the other. If I want something like optional parameters, I can emulate that with Option&lt;T&gt;.
It's downstream in the thread.
I wish there were a less evil way (but I don't think there is). &gt; Presumably you'd be able to lint that off, since some people may want to write 100% exception-safe code—but that's easy to detect and lint about. Is it? Wouldn't the lint need access to borrow checker information? (Does it *have* access?) In any case, you'd presumably want to enable the lint for `Drop` impls as well, because the same situation holds.
Thanks. I'd be happy with a limited amount of well-encapsulated well-understood well-tested unsafe code in a project, something that the local genius can create and everyone else knows to leave well alone. (Apart from personal interest, probably like many here, I'd like to find a better language to recommend for use at work, where Rust's safety would be a great advantage.)
Scala has traits, correct? How does scala handle this?
I like the idea that it's analogous with let's syntax. Allow both: pub trait ToStrRadix { fn to_str(&amp;self, radix = 10u) -&gt; String; } as in: let radix = 10u; and pub trait ToStrRadix { fn to_str(&amp;self, radix: uint = 10u) -&gt; String; } as in: let radix: uint = 10u; Obviously it's better if we have less special cases in the language. 
What mechanism would you use to opt into this behavior? Would an attribute suffice?
Or the method on ASCII, which mirrors ctype exactly.
I'd rather have it opt-out. If this were the only circumstance where unwinding could result in program abort, then I would feel opt-in is more justified, but there's also unwinding-while-unwinding in destructors.
Can you file an RFC, so that we can consider this in full?
Is there even a reasonable argument against supporting default parameters (only allowing statics for the time being and to avoid surprises).
Well according to /u/pcwalton it's /u/nikomatsakis who's planning to introduce this, my comment was just a suggestion. But for the record, [RFC PR 98][98] is essentially the same functionality reified as a reference type. I have some comments there. [98]: https://github.com/rust-lang/rfcs/pull/98
&gt; It's true, the semantics aren't entirely the same Could you explain exactly how &amp; differs in C++ and Rust? I'm just trying to learn a bit of Rust so it would be nice - I thought they were pretty much identical but I appear to be wrong.
Would it be workable to simply disallow that: In the case where 2 traits are required for the same struct, require community consensus on complimentary/consistent method names... roll an adapter in the worst case clashes. (e.g. trait MyFoo ...{ fn my_foo(&amp;self) { self.to_my().foo()}...} EDIT: oh,ok. I've just been trying to make a trait To&lt;T&gt; { fn to(&amp;self)-&gt;T }, it currently fails to impl multiple T's for a self; would it need to count as different traits with the same method name 'to'.. 
The salient differences between Rust references and C++ references is that Rust references can be treated like values, and even storing them in data structures is 100% safe. Rust references also don't permit mutation through them (that's what `&amp;mut` is for), and the machinery around lifetimes will sometimes require you to be explicit to convince the compiler that what you're doing is safe. Here's a guide tailored to C++ developers: https://github.com/rust-lang/rust/wiki/Rust-for-CXX-programmers
&gt; RingBuf also needs to be written with unsafe code in order to avoid being up to 2x larger and 30-40% slower than a proper ring buffer with an uninitialized gap rather than Option&lt;T&gt;. Even Rust's HashMap is now based on a bunch of unsafe code rather than just building on Vec&lt;T&gt;. (BTW, [#15326](https://github.com/rust-lang/rust/pull/15326).)
The benchmarks are actually uncertain. wrk gives something closer to 17k req/s, but I'm unsure of the numbers in general. There's a issue on github about it.
Vim conceal is now usable for me! Neat. It's got its weird edges like a lot of vim stuff, but I might actually continue to use it now.
Vim or emacs, as suggested by the main repository ;-)
Vim + vim-rust + racer is working pretty well for me. I have a bunch of other non-Rust related plugins as well though.
Tooling is something that Rust really needs IMO, and I wish that Mozilla would step up to help that, however it is a complicated task and people are very opinionated, so it will probably be up to the community to get it done. Right now what we have for auto completion is racer, as mentioned, I just use sublime text with the rust package at the moment.
Tooling is very important, but Mozilla is focusing on getting the language itself to a backwards compatible state. Once the language has a guarantee of stability, writing tooling will make more sense.
&gt; #[decodable_name="type"] &gt; I'd love this for my RethinkDB driver, where the over-the-wire representation of a query uses one-character field names to save space. It's annoying to have to map these to readable names in my library's structs by hand.
Thanks for the advice on sublime, I thought it was just a text editor with syntax highlighting and didn't realize it has commands for building and running. While it doesn't have code completion, it'll do for now.
From my understanding, the *library* won't actually have any backwards compatible guarantees when the *language* hits 1.0. So there would still be time to consider such a change to the language. Besides, you could keep and deprecate the pre-optional/default/overloaded arguments function names and still maintain backwards compatibility.
I agree, just wanted to know if it's planned
So ~ and @ are no longer behind a feature gate; they are completely removed from the language. Is my understanding correct?
The compiler doesn't use Gc everywhere, that's really just the AST.
 use std::slice::Items; use std::iter::Map; #[deriving(Show)] enum Foo { Bar, Baz, Zoo } impl Foo { fn variants() -&gt; Map&lt;'static,&amp;'static Foo,Foo,Items&lt;'static,Foo&gt;&gt; { static VARIANTS: &amp;'static [Foo] = &amp;[Bar, Baz, Zoo]; VARIANTS.iter().map(|x| *x) } } fn main() { for v in Foo::variants() { println!("{}", v) } } http://is.gd/RVcvYd It would be possible to write a macro for this, something like macro_rules! static_iter { ($name: ident =&gt; $($thing: expr),*) =&gt; { impl $name { fn variants() -&gt; Map&lt;'static,&amp;'static $name,$name,Items&lt;'static,$name&gt;&gt; { static THINGS: &amp;'static [$name] = [$($thing),*]; THINGS.iter().map(|&amp;x| x) } } } } static_iter! { Foo =&gt; Bar, Baz, Zoo } 
Very cool. Thanks!
Rust style is very similar to [Python's PEP8](http://legacy.python.org/dev/peps/pep-0008/) (although I believe it came from OCaml originally); it's just the way it is. There is some discussion about moving all style lints into a single lint that you can disable in a single go, if you wish to deviate from the recommended style. However, Rust is setting a global style (similar to Go with `go fmt`) to avoid pointless bikeshedding over tabs vs. spaces, `fooBar` vs. `foo_bar`, etc, and people will likely look at your Rust code strangely if it differs. ([`rustfmt`](https://github.com/pcwalton/rustfmt) will be part of that story.)
I think this can be handled better with Rust’s type system. Something like this, which structurally prevents the mingling of controls with values for a different control: #![feature(macro_rules)] trait Ctl { fn ctl(&amp;self) -&gt; int; } macro_rules! impl_ctl { ($($name:ident = $ctl:expr,)*) =&gt; { impl Ctl for $name { #[inline] fn ctl(&amp;self) -&gt; int { $ctl } } } } #[repr(C)] enum MouseMode { // Could do them as MouseModeClick et al., up to you. Click, Drag, Move, } #[repr(C)] enum CursorShape { Block, Under, LeftBar, } impl_ctl! { MouseMode = 0, CursorShape = 1, } impl Term { fn setctl_init&lt;C: Ctl&gt;(&amp;mut self, ctl_value: C) { tickit_term_setctl_init(self as *mut _, ctl_value.ctl(), ctl_value as int); } fn example(&amp;mut self) { self.setctl_init(Click); self.setctl_init(Block); } } This is probably not perfect, but I think the general idea of using Rust’s type system to your advantage is sound. Don’t try to work around the type system—you’ll regret it!
It's the way it is. Keep consistent with it and you will have a much easier time attracting new users and contributors. That said, I usually turn off the lints as needed in `ffi` modules and keep the naming consistent with whatever C library I'm binding to.
iFindSnakeCaseMoreReadable forMoreExpressiveIdentifiers.
I'm also using ST3 and custom build commands in the project configuration. So i have a build command for "cargo build; ./target/app" and for running tests etc.
It's just another visual distinction between classes/traits and functions/methods. You'll immediatly know "this string with () at the end is a function". Microsoft probably isn't the best example of code style, see https://en.wikipedia.org/wiki/Hungarian_notation 
We already have customisable linting. To stop the compiler complaining about camel case use `#[allow(non_snake_case_functions)]` (or run `rustc` with `-A non-snake-case-functions`). The `unconventional_style` umbrella lint I mentioned will just allow you to use `#[allow(unconventional_style)]` and go wild with style-guide-flaunting i.e. violate any style rule with that single `allow`, rather than having to manually override each one (as it is today).
FWIW, within C++ there's Qt which also uses camelCase for functions. I seem to recall that Cocoa does too. (I'm *not* suggesting we should do the same, just pointing out some examples.)
no_i_disagree_snake_case_is_beautiful()
There_was_a_study_and_the_study_found_that_snake_case_reads_faster. It_just_looks_like_spaces_we're_already_used_to. CamelCaseReadsMuchWorseBecauseWe'reNotUsedToReadingTextWrittenInCamelCase.
Lisp actually has the best convention, which is dash-separated, case-insensitive (in practice) identifier names. The only reason it's not popular is collision with binary minus operator, but you should probably always flank those with spaces anyway.
Wasn't this partly because many lisps were case-insensitive? Common Lisp still is, as far as I'm aware. For me, using lisp-case in a non-lisp language would look a little odd.
I have a better idea and if everything goes well I hope in a ?week there will be even better solution for Dash integration (spoiler: all credits to Dash and rust-ci authors)
The source of link.rs says the following: .targ_cfg.os == abi::OsWin32 { // Make sure that we link to the dynamic libgcc, otherwise cross-module // DWARF stack unwinding will not work. // This behavior may be overridden by --link-args "-static-libgcc" cmd.arg("-shared-libgcc"); As far as I can tell, the actual rust libraries will be statically linked, but libgcc is special for whatever reason, seemingly related to unwinding.
I think it would be important to get an error if you add a new enum variant but forget to update the VARIANTS list. Maybe there is some macro which can define both the enum{} and the impl{} blocks at the same time, maintaining the relationship?
In the [GCC Link Options][1] it says: &gt; There are several situations in which an application should use the shared `libgcc` instead of the static version. The most common of these is when the application wishes to throw and catch exceptions across different shared libraries. In that case, each of the libraries as well as the application itself should use the shared `libgcc`. So that explains what it has to do with stack unwinding. Unfortunately, `--link-args` is not a recognized flag, and while passing `-C link-args=-static-libgcc` does append it to the linker arguments, it doesn't seem to override the behavior. However, the documentation makes it sound like this is specifically for `libgcc` so that exceptions work correctly, so that might be the only DLL I have to give to him. It'd be nice if this behavior was more visibly documented, but I guess that's the risk you take working with a WIP language. Just a note somewhere would be great: &gt; If you plan to distribute Windows executables built with `rustc`, make sure to include `libgcc_s_dw2-1.dll` from `%RUST_PATH%\bin`. [1]: https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html
I think that's exactly what /u/rustcvswci is demonstrating... (i.e. you misread the camel cased text.)
All lisps are case-sensitive, but the reader converts symbol names to upcase. So 'foo internally becomes 'FOO, but it is possible to escape so it stays lowercase (|foo| or \\f\\o\\o). Hence why it's technically incorrect to say that it's case-insensitive. In any case, preferred Rust style for functions is all-lowercase so it's not much different.
Can you give an explicit example of how you think it should work? I don't understand the original post.
Ah, thanks for the explanation, I didn't realise that it was possible to escape the case like that.
So would it also be possible to write a macro so that enum Foo { Bar, Baz, Zoo } fn main() { for v in Foo::variants!() { println!("{}", v) } } works as expected? Or maybe `variants!(Foo)` instead? Of course that macro would somehow need to keep track of the enums that have already been blessed with an iterator to omit duplicate definitions, plus it would need to somehow put the iterator in `Foo`s namespace.
 struct Foo { i:int } impl Foo { fn bar(&amp;self,i:int);} trait Baz { fn bar(&amp;self,i:int); } trait Quux { fn bar(&amp;self,i:int); fn quux(&amp;self);} // "Foo" now satisfies Baz, even there is no explicit impl, // as it has a suitable 'bar' impl Quux for Foo { fn baz(&amp;self) { ... } // fn 'Quux::bar(&amp;self,int)' is missing // so it falls back to Foo::bar(&amp;self,int) // Quux now works } // Saved making a 'trait Bar', and telling 'Quux' about it, // although you'd still need one if a generic // function was to use 'bar' in isolation // 
KDevelop is very good for C++ projects, but sadly since I need it for many languages it's not flexible enough for me. I'm considering switching to [Atom](http://github.com/atom/atom) due to its tweakability (that's what I love of KDE) but since it's written with web languages the performance is awful. I like the concept though, it would be awesome to have a whole DE written like this, maybe running on Servo for speed, and Rust instead of C++ as the backbone :D
&gt; `Map&lt;'static, &amp;'static Foo, Foo, Items&lt;'static, Foo&gt;&gt;` Can I do it backwards? * It takes a source iterator of type `Items&lt;'static,Foo&gt;` (this is the Slice/Vec iterator) * Each element is mapped to type `Foo` from source type `&amp;'static Foo` * The closure passed to Map to do the transformation has lifetime `'static` Edit: Basically three of the parameters are for the closure used in Map: `|B|:'a -&gt; C`
That's definitivt not true for me. With snake_case, I briefly stop at each underscore, almost as if it's a short period, resulting in an extremely choppy reading experience. On the other hand, I read camelCase as fast as if it was a single word, even faster than if the words had spaces between them. For me, that works beautifully as long as the names don't get ridiculously long.
I like it. One step closer to [Ken Arnold's plan](http://www.artima.com/weblogs/viewpost.jsp?thread=74230), which I've always thought was a thoroughly sensible idea. In a blue-sky vein, consistent style might also help the compiler to produce better error messages if it can tell what a problematic identifier was *supposed* to be.
Unwinding is truly an evil thing :P.
I'm personally planning forking `rustfmt` to add the functionality of choosing tabs vs spaces/brace style etc if it doesn't come with it by default. Additionally, since the compiler lints are planned to be pluggable I expect custom lints that enforce alternate styles to pop up as well. I'm not sure how flexible the lint system is planned to be, but it'd be nice if there could be a parametric lint (e.g. `#![style(FunctionCamelCase)]`).
yes thank you I did that Now i have gcc version 4.8.1 20130715 (Red Hat 4.8.1-4) (GCC) I still got the below error libstdc++.so.6 version glibcxx_3.4.15' not found centos 6.5 so I did added a symlink to the opt dir sudo ln -s /opt/rh/devtoolset-2/root/usr/lib/gcc/x86_64-redhat-linux/4.8.1/libstdc++.so /usr/lib64/libstdc++.so.6 Now I get /home/leo/rust/rust-0.11.0-x86_64-unknown-linux-gnu//bin/rustc: error while loading shared libraries: /usr/lib64/libstdc++.so.6: invalid ELF header install: error: can't execute rustc binary on this platfor 
With(Overloading(),You(),Dont(NeedTo( concatenate_so_much_into_long_function_names()))) :) 
Hungarian notation is absolutely brilliant, in my opinion, it just so happens that everyone (including Microsoft) does it wrong. I mean, with properly implemented Hungarian you could have a lint warning that says things like &gt; function set_width() expects a 'int width pixels', you entered a 'int width millimetres'. This would be flagged despite the fact that both types are 'int' to the type checker. How cool wouldn't that be? Microsoft had lint checkers like that already in the 90s when they developed the Office suite. 
maybe adding more 'ask the compiler' error messages could help, meet in the middle. autocomplete could over-estimate, error messages could refine the guess .. e.g. tell you what traits you needed, the paths you'd need to use, 'see definition of..' etc
I'm very glad it's on. Because it stops people from making their APIs look inconsistent just because they like it more. Naming is subjective. Pick one.
Hmm, linking stuff out of the devtoolset may cause problems if you ever compile with the system GCC. you might want to undo that. Try installing devtoolset-2-gcc-c++ and compiling from a shell with the devtoolset enabled. I have the entire thing installed in my machine so I'm not 100% sure on the exact packages required.
keywords.with(you.get(best_of=&gt;worlds.both()))
Yes, you could write a procedural macro used like #[make_variant_iterator] enum Foo { A, B, C } that acts like `#[deriving]`. Unfortunately, it isn't possible to do this in-source, and you have to write an external dynamically loaded plugin.
No, macros can't be namespaced like `Foo::variants!()`; and the `variants!(Foo)` form doesn't have enough information to construct the iterator: macros act only on the syntax tree with no type information available, so there's no way a call like that can get the list of variants of the enum (unfortunately).
&gt; Additionally, since the compiler lints are planned to be pluggable They are actually now pluggable.
Ok, but a macro that constructs the Foo enum and its iterator would be possible? Like iterable_enum! { Foo =&gt; Bar, Baz, Zoo }
`rustc` is always right! You *must* follow its recommendation. ^^^:P
I think it's a really nice interface! (at least before closure reform) Small sugestion: Use `as` for pointer→`uint`→pointer casts instead of unsafe transmutes. Also, `raw_chunk` seems to be unnecessary. By the way, I wonder why Rust doesn't allow to send raw pointers. They are unsafe to deref anyway. Edit: I think that following: let mut chunk_size = data.len() / parallelism; if chunk_size*parallelism &lt; data.len() || chunk_size == 0 { chunk_size += 1 } could be shortened to: let chunk_size = (data.len() + parallelism - 1) / parallelism;
the camel case groups the single entities IMO, which is why it might not be as disastrous as the comparison to text/spaces idea suggests. When overloading is working right - it's because you say things with types... you've described more to the compiler. Bjarne says "templates are powerful because they can gather information from many sources" ... the synergy between templates and overloading; .. when you just described something with a naming convention, the compiler can't leverage it (unless you start using macros to concatenate symbols). (A large part of C++ atrocities are how headers complicate all that..) I would like to see everything.. overloading, arty, defaults, keyword args. They all have complimentary uses. 
Can you explain this to me? I've seen it said a few times, but I've never seen it explained, and it's not obvious why it's hard to deal with.
Preferences are arbitrary and personal, but if you work in a group you have to give up your personal preferences for group consistency. Having one reasonably-sane standard is way better than everyone trying to impose their personal style on a project. You know, perhaps one guy is real precious about having no space before the '=' operator, and the other guy wants spaces before and after each parenthesis because the font he uses doesn't show them so well, and so on and so on. In the end all the code just looks terrible. There is Java code I have to look at that has mixed Eclipse and GNU-style indentation -- what a mess: nothing lines up, the structure becomes unreadable, and to avoid getting 'git blamed' for stuff I didn't write, I have to work around it without reformatting it. I guess the bit that the engineer was looking at when he wrote it looked fine to him in whatever editor/IDE he was using. Any reasonably-sane standard is better than this kind of mess, and the 'go fmt' or 'rustfmt' on check-in approach sounds ideal.
It's not going to be possible to compile 0.11.0 with 0.10. Rust needs to be compiled with the revision specified in `src/snapshots.txt`.
Using semaphores is faster. https://gist.github.com/arjantop/2d341b9649167f03a394
Found the default implementation of `fmt::String`: https://github.com/rust-lang/rust/blob/master/src/libcore/fmt/mod.rs#L531 This cannot be overridden, right?
What you could do is have rustc emit the unlinked object code, and then link it yourself.
Heh yeah I wrote this in the middle of the night instead of sleeping, so it has some issues ;)
This is the third one I've seen now, but its the first to make it to distribution so i hope it goes somewhere.
It just seems easier to give my friend the `libgcc` DLL.
Yeah, it will be easier. It would be an alternative if you ever do need to make a completely standalone executable though, especially since you've already looked at what the linker flags are and could just modify them a bit.
As /u/indorri notes, Hungarian notation, as it was originally intended, is a good idea, but it's a coping mechanism for inadequate type systems (or for inadequately taking advantage of type systems, I dunno).
The comments in link.rs suggest that `-static-libgcc` should override the default behavior but it's clear that isn't happening. But I understand why `libgcc` is dynamically linked so I don't know if it should. I guess it's okay for programs that don't expect to fail. In my program, I don't use operations that might call `fail!()` unless I check for the failing condition first, i.e. if input.is_ok() { // input is Result //input.unwrap() - use value here } But I don't know how pervasive it is in the standard library. I guess I should put in an issue for it since it seems like the flag should work.
what you want is /r/playrust
x-posting this to /r/IntelliJIDEA if you don't mind.
Unwinding is vital for some use cases, but for others it imposes implementation complications, code bloat, missed optimizations, and inflated binary size. It's only natural that those who don't need unwinding will raise a fuss about it. C++ compilers offer a flag, `-fno-unwinding`, which allows users to disable the behavior. Rust doesn't have any similar solution thus far (and a compiler flag is less than ideal for various reasons).
You can't override it, but you can make a new wrapper type (using a tuple struct perhaps) and implement `fmt::String` on it.
Neat. I'll try them out. I'm basically using tasks as semaphores so it isn't a huge surprise there.
You mean `-fno-exceptions`. Rust needs support for unwinding; we aren't going to just process abort in failure. That's too limiting for many use cases. We can allow it to be disabled better though. Note that on Windows unwinding isn't really optional anyhow. Edit: We're having interesting discussions about alternatives. I wouldn't say that will definitely have unwinding in the future. I think we have some room to experiment post 1.0.
**Rust** *if* you're interested in reaching low-level, implementing a graphics library, game, operating system or perhaps just a high-performance, efficient GUI desktop application e.g. the type of Photoshop or perhaps a driver to power a mission-critical facility. **Go** *if* you're interested in developing backend for web apps, command line utilities, data synchronization utilities across a network etc. - basically all sorts of networking applications.
Yes, yes, and more "yes". When this matures I promise to start using it instead of emacs.
But because its implemented on `T` you can't. At least not without the new trait matching stuff.
Imma toss a couple more yesses onto this stack.
Well, Servo doesn't render enough things correctly yet for this to really be feasible.
It sounds to me like you have a lot of misconceptions about what desktop environment is and how the parts work together. First of all desktop environment is the whole package: compositor (the thing which shows things on screen and talks to the applications), shell (the thing which optionally shows some bar, puts windows at places on screen and has any other “built-in” functionality), session manager (the thing you see when you log in) et cetera. Your questions indicate you care mostly about compositor and a bit about shell and not at all about any other part of desktop environment. What **compositors** basically do is having some well defined communication channel for applications to connect to, giving a drawing canvas(es) to the applications that connect at that channel and showing those canvases on the screen when the app announces it has drawn things on its canvases. This should answer your second and third question. * Given you teach GTK, Qt et al. how to draw on your canvases (usually this won’t be necessary unless you want to give them non-OpenGL(ES) canvases) and how to connect to your connection channel, you should be fine. Wayland project is very helpful here as it is a compositor standardisation effort (i.e. basically Wayland is just a set of specifications on how a compatible compositor should communicate over its socket and a library abstracting the communication protocol) and not a compositor writing effort. * You give the applications canvases to draw into. This means each application will have at least one OpenGL context for its own needs. **Shells** are the same boring applications which connect to compositors with some special hints (i.e. draw me as a fullscreen shell, not as a window). They draw their bars and that’s about it. I don’t see why a shell couldn’t be implemented in Rust and Servo couldn’t be used for drawing whatever you want your shell to draw. Nor I see why Servo couldn’t be used as a regular application which draws your webapp into a canvas given by compositor. Finally to answer your last question: These are called client-side decorations. Basically the apps draw the decorations themselves into a canvas they are given and ask compositor or window manager or shell to not decorate them. Very relevantly Gnome Shell is written in javascript.
&gt; Counterpoint just on the tab issue: every tool has a different default size for tabs. The point of tabs is precisely that you can configure your editor to whatever size works best for you without reformatting the code.
Yes, I didn't know anything about DEs - nice explaination, thanks. So: * Could a custom UI toolkit be written in HTML, CSS, JS and Rust, in a way that it uses OpenGL for acceleration, and then used in applications and in a shell? (I'll call RusTK by now on for convenience) * Could a full DE be made with: * A Wayland-compatible compositor? * LightDM as login manager? * Custom Rust apps based on RusTK - file manager, etc.? * A custom shell based on RusTK? So, if I have KDE-plasma as workspace, KDE applications, and KWin as compositor but I use LightDM instead of KDM as a login manager and I have XOrg as display server, I'm not using KDE as a whole DE, but only parts of it, right?
Perl6 has adopted that too. &gt; 47.is-prime True
This is in reply to /u/!kibwen and /u/DroidLogician as well. I still don't understand why unwinding is hard/bad for optimization, or why it is vital. You say it is, I believe you, but I'm curious about why. It does raise the question though of what is limiting about process abort though, I would be curious about that too. Or at least why you need to unwind the whole stack and not just call some specially marked destructors...
Oh. I see.
&gt; Could a custom UI toolkit be written in HTML, CSS, JS and Rust, in a way that it uses OpenGL for acceleration, and then used in applications and in a shell? (I'll call RusTK by now on for convenience) Toolkits are an abstraction over low-level drawing primitives, therefore HTML+CSS could itself be called a toolkit. Usually rendering engines already use GPU rendering for certain parts of pages too. Yes, you could easily use your toolkit to draw both applications and the shell, given your toolkit itself is flexible enough for your use cases. &gt; A Wayland-compatible compositor? &gt; A custom shell based on RusTK? Yes. However general direction Wayland compositors are going to is having a shell and compositor in a single (possibly strongly coupled) piece of software for flexibility and development purposes (i.e. not having to invent a protocol for shell to speak with compositor as Wayland specs don’t cover that (yet?)). &gt; LightDM as login manager? Yes. Traditional session managers let you enter a password and then quit after executing your specified shell/script/executable. &gt; Custom Rust apps based on RusTK - file manager, etc.? Sure. &gt; So, if I have KDE-plasma as workspace, KDE applications, and KWin as compositor but I use LightDM instead of KDM as a login manager and I have XOrg as display server, I'm not using KDE as a whole DE, but only parts of it, right? That’s right. And that’s the best part about being part of this ecosystem as you can freely mix and match parts of various DEs to make something that suits you the best.
I think I understand now, ty. BTW I meant a toolkit since a set of standard HTML + CSS based widgets for convenience would probabily be needed.
There are some optimization passes, such as LICM, that aren't as aggressive with unwinding. I agree that the cost isn't very high.
I don't like web languages, either. But they are simple to use, and there are a lot of web designers out there. Since the UIs should not become this, I think that designers are more appropriate than developers to create UIs. It would be awesome to use other languages (joining the theming and the UI scripting would be very nice in my opinion), but what scripting languages should be used? They should be widely known / easy enough to learn, or I doubt designers would ever create the UIs for this theoretical toolkit...
Maybe the right solution would be to step back even further and parameterize `Functor` over the function type (which should presumably be a `Category`, but maybe a `Profunctor` or `Arrow` -- not going to think this through right now). This idea comes from Haskell land as well, but it's less pressing when you have a single clear function type for everyone to use.
Yeah, that might work, although it will presumably result in the ergonomics and composability decreasing... the cost of low-level control!
You do know that the Firefox browser is written in JS/HTML too, right? :) &gt; Could a user interface toolkit (like GTK or Qt) be made, based on HTML widgets and Rust/Servo backend and libraries (I'll call it RustTK for convenience from now on)? Something like what XUL does in Firefox? Probably. Will it be made? Probably not ;) Unless we ever decide to patch Servo into Firefox, in which case we'll need libxul and XPCOM and the rest. &gt; Could RusTK be capable of running on different platforms, as long as the Servo rendering backend is changed, to be used in standalone applications? Yes. Well, assuming Servo gets Windows support. I would expect the first Rust library for this to be C bindings, or something, however. Servo's still a long way from accomplishing this.
True, this doesn’t handle getters. How about this approach, then: trait&lt;V: ToPrimitive + FromPrimitive&gt; Ctl&lt;V&gt; { fn ctl(&amp;self) -&gt; int; } macro_rules! impl_ctl { ($($name:ty / $v:ty = $ctl:expr,)*) =&gt; { impl Ctl&lt;$v&gt; for $name { #[inline] fn ctl(&amp;self) -&gt; int { $ctl } } } } struct MOUSE_MODE; #[deriving(ToPrimitive, FromPrimitive)] enum MouseModes { Click, Drag, Move, } struct ALT_SCREEN; impl_ctl! { MOUSE_MODE/MouseModes = 0, ALT_SCREEN/bool = 2, } impl Term { fn setctl&lt;V: ToPrimitive + FromPrimitive, C: Ctl&lt;V&gt;&gt;(&amp;mut self, ctl: C, value: V) { tickit_term_setctl_int(self.tt, ctl.ctl(), value.to_int()) } fn getctl&lt;V: ToPrimitive + FromPrimitive, C: Ctl&lt;V&gt;&gt;(&amp;self, ctl: C) -&gt; V { tickit_term_getctl_int(self.tt, ctl.ctl()).from_int().unwrap() } fn example(&amp;mut self) { self.setctl(MOUSE_MODE, Click); self.setctl(ALT_SCREEN, true); self.getctl(MOUSE_MODE); // Click self.getctl(ALT_SCREEN); // true } } This provides both pleasant ergonomics and type safety.
This is [using](https://github.com/huonw/spellck/blob/48693f74fc21fffdab297fff40b3630dbfc75e7e/src/spellck/lib.rs#L15-L18) the compiler's new experimental [plugin API](http://doc.rust-lang.org/master/rustc/plugin/) for loading [a lint](http://doc.rust-lang.org/master/rustc/lint/), to make the spell checking happen during compilation.
Part of the problem with unwinding is the secondary effects where you have to write code to be exception safe, e.g. the standard library's `sort` function and data structures like `TreeMap` have to be very careful with how they handle their data when calling the user supplied comparators, because they could cause unwinding, and the destructors need to run exactly once (you can't miss any, and you can't let one run twice).
That has a run-time cost. Overloading is compile-time.
It can be optimized. 
That can be addressed by aborting the process if the comparison function fails. This was /u/glaebhoerl's rather ingenious proposal.
Something like having `std::task::no_failure(|| { ... })` that locally replaces unwinding with `abort`? (Or implemented via RAII, whatever.)
I've been meaning to add autocomplete support for a while, but intellij already has quite good tooling for tokenization ast manipulation. 
We have a whole heap of stuff not yet released including some experemental run+compile commands. Auto complete is still in the works but the grammar / syntax checking fully supported. 
Cargo integration? &lt;3
Certainly on the list of things to do. You could always add an issue to get updated when the feature is implemented.
You begin by not being so rude. (You've been [warned before](http://www.reddit.com/r/rust/comments/29sumo/warning_function_foobarshould_have_a_snake_case/cio8kx9?context=1), this is the final one.)
If we want good tools for rust, we should have something like C#'s Roslyn, instead of reinventing the wheel.
Yes, they are gone.
Even Jetbrains don't use Roslyn for their C# editor Resharper. http://blog.jetbrains.com/dotnet/2014/04/10/resharper-and-roslyn-qa/ When you have a code base capable of doing inspections, autocompletion, refactoring, tokenization and parsing in 20+ languages you have a huge amount of tooling written in a generic way. The question is not whether to reinvent a wheel, its how to get the wheel that fits with the least amount of effort. In this case I think its to use Intellij's existing tooling and great documentation. There are also many open source language plugins to pull examples from. 
&gt; But they are simple to use QtCreator/QtDesigner are far simpler to use, and you aren't haunted by the horrors of CSS.
Would be interesting to figure out, whether this is because of being accustomed to one variant or if different people inherently read differently. This could have implications, since the second case would unintentionally shy away certain people from using a given language. btw, I also find snake_case way more readable, even though I have worked with lots of Java and CamelCase C++ in the past.
I thought it used GTK+... Did the new UI change that?
Firefox? I think it does. The UI is written in XUL (XML) and is rendered by Gecko, but of course the final appearance of the widgets has to come from somewhere. Possibly GTK (doubt they would roll their own) The parallel was more of creating desktop UI components that work in a browser (which XUL does).
Heh, nice! Didn't even think of this use case for compiler plugins. ... But then again I haven't thought of any use case apart from syntax extensions yet, so... :P
Yes, but I didn't mean to describe the widget layout in e.g. XML to have it loaded in GTK or Qt later. I meant to have the widgets rendered like they were a webpage, directly.
That's what happens. The browser is nothing but a big webpage. XML is used instead of HTML, that's all. Again, it's rendered by Gecko. The widget styling and other things might come from GTK, but at least at one level Gecko does the rendering.
Oh, that would be sooo good! Does this work with the IntelliJ Community Edition? 
I appreciate many may not like this idea (to be honest, I'm not sure I do). I hope people do appreciate that this is a really *good* RFC though. It includes solid, detailed motivation which clearly explains why the idea is worthy of consideration.
This can be done in XUL, too, IIRC. For example the download progress bar (remember working on that in the past) is just a nested div (or equivalent) with a background. You can look at XUL as extended HTML. It supports JS/CSS/and enough elements to do the same stuff you do in HTML, just that it has a bunch of useful UI elements like vbox and all the widgets. It's not like the usual XML used in Qt/etc. Each XUL element is implemented in Gecko just like a normal HTML element. Again, the browser is a big webpage.
That seems a good compromise between presets and flexibility.
Nice! Have you thought about augmenting it with a Damereau-Levenshtein distance algorithm to propose suggestions ? It would be most helpful to non-native speakers (such as myself).
- `tsm_screen_get_cursor_x` returns `unsigned int`, so it's a bit weird to [cast to `int`](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/lib.rs#L63-L64). `u32` is probably better (you use `u32` [above](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/lib.rs#L49) too). - [Woah woah woah](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/lib.rs#L39), are you trying to crash the program? Dereferencing null is bad. (And [again](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/lib.rs#L79).) - [This](https://github.com/skade/rust-terminal/blob/master/src/c_bits/mod.rs#L44) and [this](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/c_bits/mod.rs#L35) can lead to undefined behaviour: for either type, `from_uint(10)` will be creating a value that's outside the range of the enum, which is [supposed to be impossible](http://doc.rust-lang.org/master/rust.html#behavior-considered-unsafe). You can get an autogenerated safe conversion via [`#[deriving(ToPrimitive)]`](http://doc.rust-lang.org/master/std/num/trait.FromPrimitive.html), although the [`bitflags!`](http://doc.rust-lang.org/master/std/bitflags/) macro may be appropriate too (or maybe not). - [The binding](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/c_bits/mod.rs#L100) of the [`tsm_log_t` type](https://github.com/clkao/libtsm/blob/f4165895ae0b09d5c11e961a84b42457600cbac7/src/tsm_screen.h#L46-L67) is horribly wrong, it needs to be like the `tsm_write_cb` or `tsm_screen_draw_cb` you have below. - Nullable function pointers should be represented by `Option&lt;fn_type&gt;` (e.g. `Option&lt;tsm_log_t&gt;`). Yes, these are a single pointer, with `None` being NULL. - You need to be more careful about `*mut` vs `*const`. The [C API](https://github.com/clkao/libtsm/tree/master/src) has a lot of `T*` which you bind as `*const T`; it *should* be `*mut T` in Rust. e.g. [this invocation of `tsm_screen_new`](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/lib.rs#L38-L39) should be let mut screen = ptr::mut_null(); tsm_screen_new(&amp;mut screen, None, ptr::mut_null()); - [This `vec!`](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/c_bits/mod.rs#L80) is unnecessary since it's known at compile time: it would even work as a `static`: `static RGB_LEVELS: &amp;'static [u8] = &amp;[0x00, ...];` - [This one is too](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/main.rs#L139), but it's not a compile-time constant, so it still has to be a local variable: `let fields_to_emit = [...];` - [This `as u64`](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/lib.rs#L100) should be `as libc::size_t`. As it stands, the code will only compile on 64-bit platforms. &gt; String handling leads to a lot of to_slice and unwrap. Is there a remedy for that? Preferably you avoid `.unwrap`: for a robust application, it should be regarded as an assertion "this should never happen", rather than as a valid error handling technique. Preferably code is rewritten to avoid it. - [This](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/main.rs#L66-L69) could be let line = match stdin.read_line() { Ok(l) =&gt; l, Err(_) =&gt; return }; - [This](https://github.com/skade/rust-terminal/blob/6a564e2200c38f9499717b4abd31152ef32f13b2/src/main.rs#L72-L78) should be match stdin.read_line() { Ok(next_line) =&gt; { let n = from_str(next_line.as_slice().trim()); ... } Err(_) =&gt; return } (Or the same sort of early return + outer name binding as the previous one.) One sensible technique is to declare a function `fn core() -&gt; IoResult&lt;()&gt;` that does all the work, and have `main` like: fn main() { match core() { Ok(_) =&gt; {/* everything worked */} Err(e) =&gt; { writeln!(&amp;mut std::io::stderr(), "An error occured: {}", e); std::os::set_exit_status(1); } } } This allows one to use the [`try!`](http://doc.rust-lang.org/master/std/result/index.html#the-try!-macro) macro for your main code: i.e. the two things I pulled out above would become just `let line = try!(stdin.read_line());` and `let next_line = try!(stdin.read_line());` If there's more that can occur (i.e. not just `IoError`s) then define an `enum` with all the possibilities and have `core` return `Result&lt;(), ErrorEnum&gt;` and `main` handle the various possibilities. You can then define a macro like `try!` that makes short circuiting nice. [See this post for an example](http://huonw.github.io/2014/06/10/knn-rust.html). You should be able remove essentially all the `unwrap`s. However, I don't think this addresses your core issue, which is the verbosity of the `unwrap`s... Rust tries to put the errors into types, essentially forcing them to be handled in some way: you can't just paper over them. &gt; I don't like the long encoder implementation in main.rs. Does someone have a good idea there? let options = [("fg", &amp;self.fg), ("bg", &amp;self.bg)]; let bools = [("bold", self.bold), ("underline", self.underline), ("inverse", self.inverse), ("blink", self.blink)]; let num_fields = options.iter().filter(&amp;(_, opt) opt.is_some()).count() + bools.iter().filter(&amp;(_, b) b).count(); e.emit_map(num_fields, |e| { let mut key_pos = 0; for &amp;(name, opt) in options.iter() { match *opt { None =&gt; {} Some(v) { try!(e.emit_map_elt_key(key_pos, |e| name.encode(e))); try!(e.emit_map_elt_val(key_pos, |e| v.encode(e))); key_pos += 1 } } } for &amp;(name, b) in bools.iter() { if b { try!(e.emit_map_elt_key(key_pos, |e| name.encode(e))); try!(e.emit_map_elt_val(key_pos, |e| b.encode(e))); key_pos += 1 } } }); (Untested.)
You're not forced to use QML with Qt, you still have the good old plain C++ widgets toolkit.
I believe you are looking for /r/playrust. This subreddit is about Rust, the programming language ;)
&gt; maybe as a tweak the `*_` could infer the const-ness I think it's this sort of little tweaks that over time create a messy language, so it's best avoided.
In Scala, you don't have to import them. If you have two method implementations inherited from two different traits, the last one wins.
My google searching skills are clearly not up to par! That's a perfect thing to use the name on, though. 
But they aren't as flexible as HTML
Hi /u/dbaupp, Thanks a lot for the thorough review! It got a lot of things cleared up, especially as how to handle the pointer fiddling around creating the screen. I didn't know about ToPrimitive, this certainly helped a lot! I integrated most of the smaller changes (they don't need much of a debate) and rewrote the run loop currently. Well, there is one thing: I am fine with the unwraps() failing, as this program should crash on any invalid input. Still, reordering using your fashion helped a lot for clarity. Thanks a lot for assisting again, I'll integrate your encoder refactoring later. I've got one additional question: how do I handle `va_list` correctly? Best, Florian 
Being able to put `return` and `break` into closures would be nice. Then one could write let conn = PostgresConnection::connect("postgres://localhost:5432/postgres", &amp;NoSsl) .unwrap_or_else(|e| return Err(format!("{}",e))) But there's probably a good reason why this isn't already possible. So macros it is. &gt; It still goes in front, so it still obscures the intent of the author. But "everybody" knows what the try! macro is for. It's in the std.
My opinion is try!, if anything adds more context (this might fail etc.). More general try! would be great (like haskell do, for any monadic type, not currently possible) but things are good enough. Then you have a lot of functions (both Option and Result) for this use case like map, map_err, and_then, or_else etc. For me this is completely readable (even more with nice syntax highlighting): let conn = try!(PostgresConnection::connect("postgres://localhost:5432/postgres", &amp;NoSsl)) let stmt = try!(conn.prepare("SELECT ir FROM x")); let mut res = try!(stmt.query([])); And in the end you can do: result.map_err(|e| format!("{}", e)) An this: let val: i32 = row[0u]; is just a library design, adding try would not affect readability: let val: i32 = try!(row[0u]);
&gt; But "everybody" knows what the try! macro is for. It's in the std. By "obscures" I mean that the intent of the author is to establish a postgres connection and go on with their work. Error handling is a detail, but "try!" goes in front. To me, it just seems backwards. That's why I'm suggesting an infix "match", or perhaps an infix "try" would be good, too. I don't have a problem with the semantics and I'm trying to avoid any radical suggestions. I just don't find it very readable when the error handling is first and the primary goal is stuck within the perenthesis. EDIT: that's what's good about your first suggestion: the error handling is last. Perhaps what we need are infix/postfix macros?
Because `*T` does not mean "nobody will mutate it" like `*` normally means in Rust, it means something more like C++ `const` ("*I* won't mutate it"). To avoid confusion, the syntax was changed.
&gt; My opinion is try! if anything adds more context (this might fail etc.). Why add the context at the beginning? Regardless try *only works* if the result error types match, so it is just not viable in many cases. Extending/generalizing "try" might work, but that would probably kill readability.
if they don't match you convert them so they do
Well, with my suggestion you could implement a generic `unwrap_or_return` function, and `map_err` could convert one error type to another so the return types match.
I don't like enforced case, people get to do what they want. I am a fan of turn offable lints. I guess Haskell works well, but I remain unconvinced.
Some perfectly terrible names I thought of are "rutht" for a lisp interpreter, and "Ferrous Oxide" for...really anything. 
I'd recommend using the newest version of Rust. You'll get better performance than the version you're on, because `Vec` performs better than `~[T]`. :)
Something all those languages have in common is that none of them have algebraic datatypes and pattern matching.
&gt; Regardless try only works if the result error types match, so it is just not viable in many cases. That's why methods like `map_err` exist. It lets you convert one error type, to another. This is typically needed when dealing with a custom error type and calling a bunch of io functions where it returns `IoResult` and `IoError`. I wrote about it on my blog: http://hydrocodedesign.com/2014/05/28/practicality-with-rust-error-handling/
 'main loop { let x = maybe_int().unwrap_or_else(|| break 'main); } fn do_stuff() -&gt; Option&lt;int&gt; { let x = maybe_int().unwrap_or_else(|| return 'do_stuff None); let y = maybe_int().unwrap_or_else(|| return 'do_stuff None); let z = maybe_int().unwrap_or_else(|| return 'do_stuff None); Some(x,y,z) }
Yeah. Cargo wrote [their own `try!` macro](https://github.com/rust-lang/cargo/blob/d3e28cfe5dada42235c6af5db670da51792fa8f6/src/cargo/lib.rs#L50-L59) to go along with a trait `FromError` and helper function for doing just this: converting from a set of known error types to CargoError. I expect that this pattern will crop up pretty often.
1. you can probably use an iterator for iterating over text 2. return type can be a reference from text input. --- fn kmp_search&lt;'a&gt;(text: &amp;'a str, word: &amp;str) -&gt; &amp;'a str {
justplain "oxide" would be snappier
I haven't seen that before, where can I read more?
Oops, yeah, I somehow pasted the version with the off-by-one error even though I had already fixed it. Pressed 'u' one too many times in vim. :)
If you find yourself using `Result&lt;_, String&gt;` often, why not write a macro that hides this boilerplate? (example [here](http://is.gd/Z6UDWV)) macro_rules! try_str { ($e:expr) =&gt; { match $e { Ok(x) =&gt; x, Err(e) =&gt; { return Err(format!("{}", e)); } } } } Or in that particular example, assuming all three of those method calls return the same error type, you can do something like: fn run_query() -&gt; Result&lt;PgResultSetOrWhatever, String&gt; { PostgresConnection::connect("postgres://localhost:5432/postgres", &amp;NoSsl) .and_then(|conn| conn.prepare("SELECT ir FROM x")) .and_then(|stmt| stmt.query([])) .map_err(|e| format!("{}", e)) }
I just made it up.
Yes, but Ferrous Oxide, in particular, isn't actually rust. Rust is ferric oxide something-hydrate (on my phone). A nice way to piss off chemistry buffs. But in all seriousness, "Oxide" on its own is probably a better name.
Something all those languages have in common is that all of them are in the Top #10 programming languages in most studies (I'll just take TIOBE and RedMonks as example, but I'm currently too tired to google them). Which has nothing to do with the argument why Rust needs enforced case. Or why this RFC gets a lot of criticism. The FFI argument against the RFC is the most convincing for me. Requiring mental gymnastics to find out the correct Rust-y name for users of external libraries, thus making it harder for them to rely on the original documentation is something that will need a lot of benefits on the other side to tip the scale in its favor. Also it's ostensibly about error-free codes, but I fail to see why a lint wouldn't work just as well in that regard.
["amulet: a rusty object intended to save you from curses"](https://github.com/eevee/amulet)
I believe you should write `range(2u, 10u)`, note the `u` suffix, which indicates it's a range over unsigned integers.
And you only need to have the `u` suffix on one of them because of type inference!
This works for me: let mut fib = vec![1u, 1]; for i in range(2, 10) { let val = *fib.get(i - 1) + *fib.get(i - 2); fib.push(val); } I added the `u` to the first number for the `vec![]` to let Rust know what the type of the numbers is. You need the `*` before the `get` calls since they return references and you want a copy of the value. I also separated the value calculation from the `push` call (otherwise there would be a conflict for borrowing the vector once mutable and twice immutable) Edit: Changed explicit `fib` var type to `u` on the first number, thanks to /u/aarjan for the hint.
you can do: let mut fib = vec![1u, 2]; 
True, thanks and fixed.
Performance will be much better if you avoid copying the characters into a vector, and either use iterators or store `skip`, `i` and `m` as byte indices (or a combination of the two).
Slides are in English though. Just about dismissed this.
Too many common examples, plus it will cause issues with multiple libraries by different authors.
They have a set of interfaces for classes generics and lambdas but actual implementation is pretty manual still. Is there a programmatic way to interface with racer? I dont know how well java can interface with rust code directly so I think there would need to be some socket / pipe based communication. Will it work on all platforms (windows and centos are my main concerns, centos has a very old glibc...). 
BTW, I'm going to talk about Rust in Kiev 26th of July. Everyone is welcome to attend.
Oh, sorry, I typoed: I mean `FromPrimitive`, not `ToPrimitive`. Rust has variadic FFI support (`extern { fn printf(fmt: *const i8, ...); }`), but I don't know the best way to bind to `va_list`.
In the default link path that gcc would use. You cannot specify full or relative paths, but you can augment the search path with the `-L` flag to rustc
I was going to write an arimaa AI and call it bot_oxidize
&gt; But there's probably a good reason why this isn't already possible I think it is because Rust closures are a type of function. It's the same thing in javascript: [1, 2, 3].forEach(function(i) { console.log(i); if(i &gt; 1) return; }); Will log three times. Ruby's blocks are different however: def foo 1.upto(3) do |i| puts i return if i &gt; 1 end end This will only log 1 and 2, because the `return` returns from the enclosing ~~function~~ method, not the block. I don't know if Ruby-like semantics are implementable (or even desirable) in Rust.
Thanks to all of your suggestions I have made some improvements and ended up with a new version: https://gist.github.com/anonymous/66939ed9675d4f6b10dc Rust is fun!
I looked over your [revised copy](https://github.com/skade/rust-terminal/commit/7e53dca60c4342f432237ca59e89a1697f524547): - normally one uses [`*mut` rather than `&amp;mut` in FFI bindings](https://github.com/skade/rust-terminal/commit/7e53dca60c4342f432237ca59e89a1697f524547#diff-034186d42afba55034e4f5236a48ec58R138): `*mut` corresponds to the C type more closely (`&amp;mut` has additional semantics), and `&amp;mut` coerces to `*mut` automatically. - You are still [dereferencing NULL pointers](https://github.com/skade/rust-terminal/commit/7e53dca60c4342f432237ca59e89a1697f524547#diff-b4aea3e418ccdb71239b96952d9cddb6R79). Doing that is really [bad](http://en.wikipedia.org/wiki/Pointer_%28computer_programming%29#Null_pointer)! If you compiler without any optimisations your code will almost certainly crash, and if you compile with them... well, it could do anything: [Rust defines dereferencing null](http://doc.rust-lang.org/master/rust.html#behavior-considered-unsafe) as [undefined behaviour](http://en.wikipedia.org/wiki/Undefined_behavior), just like C. If you want to pass NULL... just pass `ptr::mut_null()`, *not* `*ptr::mut_null()`. - FWIW, [this pattern](https://github.com/skade/rust-terminal/commit/7e53dca60c4342f432237ca59e89a1697f524547#diff-034186d42afba55034e4f5236a48ec58R38) can be written as `FromPrimitive::from_uint(v).expect("Decoding of uint into ScreenFlags failed!")`.
I'd argue that they're actually far more flexible. CSS in particular has a number of annoying limitations and the lack of components in web development is a real annoyance.
I came up with "tetanus" a while back but was unsure of a fitting project.
The interface is very basic at the moment: you run the racer binary passing the source filename and coordinates as command line args and it prints out matches. Current editor plugins save a temporary file and pass the filename and coords to that, then delete it afterwards. It 'should' work on windows, but I haven't tested it because I don't have a windows machine. I'll try to fix windows bugs if people find them though 
Reddit has a nice JSON API (much easier to use than email), and asking here seems fine.
[This study](http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf) seems to agree with you.
I wouldn't. In web development, components are simple, common parts grouped together. For instance the same CSS class that applied a gradient to the background of a button can be used as a checkbox background, or listbox background. You organize them in a library of standard components and use them via CSS classes and such. Qt widgets rely on inheritance to be extended; you need to create a new class for each component, and often you need to override the painting method of the custom component.
Great! There is a simple implementation of Levenshtein in LLVM [here](http://llvm.org/viewvc/llvm-project/llvm/trunk/include/llvm/ADT/edit_distance.h?view=markup). I added it to the issue for whoever wishes to look into it.
I don't believe you can do that using macro_rules!, you would probably have to use the plugin api: http://doc.rust-lang.org/master/rustc/plugin/ No that you can initialize arrays with "default" values like: let x = [0, ..10];
No problem, I found it from there ;). Well, I'll pass on the `va_list` problem, as the function is never used and I have no need for it at all.
If once you are constructing a vector, why would you go doing more work turning it back into a fixed-size array? ---- Still, here’s a demonstration of a more efficient technique that works with just the array; although it contains unsafe code, the abstraction is safe: #![feature(macro_rules)] use std::mem; use std::ptr; #[deriving(Show)] struct MyStruct { number: uint, } macro_rules! make_array { ($n:expr, $constructor:expr) =&gt; {{ let mut items: [_, ..$n] = unsafe { mem::uninitialized() }; for i in range(0u, $n) { let val = $constructor(i); unsafe { ptr::copy_nonoverlapping_memory(&amp;mut items[i], &amp;val, 1); mem::forget(val); } } items }} } fn main() { let items = make_array!(5, |i| MyStruct { number: i }); println!("{}", items.as_slice()); } (You could replace the `ptr::copy_nonoverlapping_memory` with the less-scary `mem::replace`; this form is just that little bit more efficient.)
Actually, you can use CSS to theme native Qt widgets ; see [here](http://qt-project.org/doc/qt-5/stylesheet-reference.html) for reference.
and maybe someday: make_array&lt;5&gt;(|i| MyStruct { number: i})
I'm by no means a rust expert, but here are my 0,02€. Methods are a way to define a data type's interfaces, as well as the interface of all derived types. This means that using methods opens the door to polymorphic code, which functions don't. Moreover, requiring methods pushes developers to associate the definition of a particular function to the definition of the data type itself.
I think the contents of the macro would be better written as: let mut items: [_, .. $n] = mem::uninitialized(); for (i, place) in items.mut_iter().enumerate() { ptr::write(place, $constructor(i)); } It must be *guaranteed* that `$constructor` never fails, if the type in the array has a destructor (or contains types with a destructor), or else dtors will run on uninitialised memory: undefined behaviour! (Which is why I didn't put any `unsafe { ... }` above: uses of the macro will require a `unsafe`, reminding the user that they're playing with fire...). BTW, [`ptr::write`](http://doc.rust-lang.org/master/std/ptr/fn.write.html) is `copy_nonoverlapping_memory` + `mem::forget` all in one. &gt; the less-scary mem::replace; It's still very scary, `mem::replace` will return the old value (i.e. uninitialised memory), so you still need to remember to call `forget` on it.
Shouldn't the functions be in reverse order?
I am also no Rust expert but Rust has no inheritance and it uses a trait system which is similar to Haskell's type classes. Did you read my example? It shows a polymorphic function. 
In ML you could write this like something |&gt; foo |&gt; bar |&gt; baz or in Haskell baz . bar . foo $ something But I am not sure if we can have custom infix operators in Rust. But it probably doesn't exist and that's why Rust uses methods.
&gt; I am also no Rust expert but Rust has no inheritance and it uses a trait system which is similar to Haskell's type classes. Rust might not have inheritance, but it does have trait inheritance. [Rust docs: trait inheritance](http://doc.rust-lang.org/tutorial.html#trait-inheritance) From the docs: &gt; Notice that methods of Circle can call methods on Shape, as our radius implementation calls the area method. &gt; &gt;(...) &gt; &gt;In type-parameterized functions, methods of the supertrait may be called on values of subtrait-bound type parameters.
Any chance of getting D's version of UFCS? It's basically the reverse of what you said: function called with `foo(zoo, bar)` can be called `zoo.foo(bar)`.
While I like the general idea of this, my main use case for using this would be passing the function into a hof. Prefixing with the trait/struct type is probably going to be more characters than creating a one line closure calling the method explicitly, which is a bit unfortunate.
This is identical to: class (Shape a) =&gt; Circle a where
IIRC, the main motivation for that change was to clean up the `num` module leaving it cleaner so that it can be made nice in future without having to work around the freestanding functions... like with the rest of Rust, it's not at all final, and the current state now doesn't (necessarily) represent the desired future state. (I certainly find postfix mathematics peculiar to read too.) The libraries have been somewhat neglected until recently (they haven't had a focused all-encompassing effort), due to the core language implementation work being more important, however Mozilla hired Aaron Turon a few months ago, he is now working on libraries and API design.
You probably can't talk about it, but is there a chance of Yandex' official interest in Rust?
~~Why is this a macro and not a normal function?~~ EDIT: I see, it is to be able to have a fixed-size slice... EDIT2: Why do you use `copy_nonoverlapping_memory` and `forget`? Does that perform better than just doing the following? let mut items: [_, ..$n] = unsafe { mem::uninitialized() }; for i in range(0u, $n) { items[i] = $constructor(i); } items
Thanks!
Re. EDIT2: that would run the a destructor, if there is one, on uninitialized memory. If you have a boxed value, for example, this will probably cause a crash.
I think you meant "type safe" instead of "time safe" ;) Maybe I am missing the point of the discussion, but you could write your function without casting. See below: fn add_to_color(c: Color, r: u8, g: u8, b: u8) -&gt; Option&lt;Color&gt; { let sum = (c.r.checked_add(&amp;r), c.g.checked_add(&amp;g), c.b.checked_add(&amp;b)); match sum { (Some(new_r), Some(new_g), Some(new_b)) =&gt; { Some(Color { r: new_r, g: new_g, b: new_b }) } _ =&gt; None } }
Maybe you could open a thread to get your code reviewed by other people... You can use https://gist.github.com/ to upload your code.
Thank you, will post it as soon as I finish the code(could take a few days more tho).
I really hate having to take care of what is a pointer, what is a value, etc. In most system languages, you want to have a clear differentiation between what is a non-owned pointer, what is a local value, etc. **because you need to manage their lifetime manually**, and having a clear difference between a pointer and a value helps doing so. But Rust automatically manages the lifetime of everything and tells you when you do something wrong. So why would I care whether I manipulate pointers or values? Why do they have two different syntaxes? Here is an example: fn foo1() -&gt; SomeIterator&lt;int&gt;; fn foo2() -&gt; SomeIterator&lt;&amp;int&gt;; fn main() { for elem in foo1() { do_something(&amp;elem); blablabla(elem); } } If I ever want to change `foo1()` to `foo2()`, I need to entirely rethink the body of my `main` function. When I write complex code in Rust, I spend almost half of my time solving compilation errors because some functions expect a `&amp;foo` and I supplied a `foo`. One of the main reasons why I like C++ is because you can turn a `void foo(string)` into a `void foo(const string&amp;)` without having to change the code of the `foo` function at all. Rust provides some many high-level abstractions and yet for me fails at one of the most simple ones. 
No problem! People is patient in this subreddit... they have been waiting for Rust 1.0 for years!
&gt;&gt;This means that using methods opens the door to polymorphic code, which functions don't. Its' just that Rust has chosen to unify the organisation for static and dynamic dispatch, i think?(traits as vtables and generic bounds); It is perfectly possible to do polymorphism with function parameters aswell (and IMO it suits maths code very well e.g. matrix * vector, matrix*matrix etc),... but not efficiently for runtime with multiple parameters.. hence rusts use of the special receiver which can dispatch through a vtable
Well, I'm not sure what do you call "official interest", could you please send me an e-mail to nga@yandex-team.ru?
I would wish for more syntactic sugar and everytime something gets removed from the language, i just hope that the reasoning everything is done to have the possibility to do that in the langauge is true. I would wish for more syntactic sugar in the language, akin to say python, where i can do array[2:] or array[::-1] or whatever. Also, currently my rust code uses a log "as_slice" and "to_string", which looks noisy..
This is my biggest issue with Rust as well. I submitted [an RFC for auto-derefing pointers](https://github.com/rust-lang/rfcs/pull/102) which would help a lot. People liked it in the thread, IRC and in [the Reddit discussion](http://www.reddit.com/r/rust/comments/272i7p/rfc_autodereferencing_nonraw_pointers/) but alas, it was ultimately rejected. What's makes this especially annoying is that the syntactical distinction between the two exists entirely because older languages have it, not because it's necessary in Rust. C and C++ need it because derefing a pointer is possibly dangerous, but not in Rust. So the whole "use * here and &amp; there" is just pointless ceremony.
This is because of rust's philosophy of explicitness and visible costs. The different in cost between passing a pointer and passing a value is part of this. Also, there's a huge difference between rust and C++ here: structures with destructor are moved instead of copied if they're not passed by reference, so they're not equivalent for many types. I personally like this (though full auto-deref would be good, needing to throw in random `*` just seems arbitrary).
Or maybe some kind of test-case generator that tries to break your unit tests?
The biggest issue I have with Rust is that I for one am having a hard time trying to implement what should be rudimentary data structures and algorithms that would need unsafe pointers. I just can't really wrap my head around a lot of 'simple' things, like, e.g., how I would implement a graph structure or even a simple ring buffer, without either lots of `unsafe` blocks or lots and lots of `Option&lt;Option&lt;Option&lt;Node&gt;&gt;&gt;`. I mostly work with high-level stuff so it could just be my ability is lacking. The other complaint I have is that there isn't quite the stdlib or even third-party lib ecosystem that I end up needing on the job for high-level, real-world crap--i.e., database access, csv, yaml, xpath, regex, http. You know, the boring, yak-shaving crap that ends up being most of the work. It's questionable if I'd even use Rust for that since those are high-level tasks, but inevitably you need to parse some 2GB html file into a CSV over a socket, and languages ostensibly suited for that, like Python can easily choke on minor inefficiencies with things like that... The language isn't a 1.x yet though, so I can look past that.
Yes, the philosophy is good, but more auto-deref would be nice. Also I have the suspicion that the std is too reference heavy. Primitives should either be passed by value or by mutable reference.
This is a great example for us to really flesh out our quasiquoting support. Something like this shouldn't need unsafety at all, the problem is that we can't really control loops inside macros. Sure we could add a repeating construct, but life would be so much better if we could use unquoting as in: #![feature(macro_rules)] macro_rules! make_array { ($n:expr, $constructor:expr) =&gt; { { [ $unquote_iter( range(0, $n).map(|_| { $constructor }) ) ] } } } #[deriving(Show)] struct MyStruct { x: String, } fn main() { let dst = make_array!(5, MyStruct { x: "a".to_string()); println!("{}", dst.as_slice()); } Of course, that might introduce a circular loop between libsyntax and librustc, which doesn't seem great. I suppose we could always write a small Scheme interpreter for this situation :) edit: ack! it does support unquoting, just the docs are using the term `antiquote` so it wasn't tripping my grep. I'm going to have to play with it to see if I can get this to work...
Great stuff! What really puzzles me is how Rust got to Minsk faster than to Toronto... (I migrated from Minsk).
[I have also submitted one](https://github.com/rust-lang/rfcs/pull/137), unfortunately [this post](https://mail.mozilla.org/pipermail/rust-dev/2014-July/010689.html) "recommends close" because of mixed feedback.
Rust also doesn't have nice currying like ML/F#/Haskell, which would make this kind of thing rather difficult.
I'm not happy with generics in general. What we have works, but isn't good enough. Real generic arrays are impossible also. Yes I know there are improvements planned. Option/Results are good but HKT would be nice.
Not in as far-reaching a way as D's, no.
Note that, despite it's prevalence, #[link(name = "")] should never be used directly except for a shim library that you compile as part of your build process. The correct solution is to use pkg-config, either to generate a #[link] attribute, or in -C link-args. Cargo will be working on integrating pkg-config soon, including support for platforms where it's not ubiquitous yet. Example of one correct approach: https://github.com/o11c/termkey-rs/blob/master/Makefile
I've been experiencing some similar troubles as you describe in your first paragraph. After some discussion on the IRC, it seems to me that ```unsafe``` isn't quite as "avoid at all costs" bad as I had initially believed. If it's underneath an otherwise safe API, and the unsafe blocks are small and simple, it's not all that awful. I think the [std libs implementation of DList](http://doc.rust-lang.org/src/collections/home/rustbuild/src/rust-buildbot/slave/nightly-linux/build/src/libcollections/dlist.rs.html#36-40) is the perfect example. They rely on a raw pointer for the back references, but the term "unsafe" appears in all of three places, and two of them are one-liners.
There's a few things I miss from Java, which is my day job bread and butter. Obviously much of this stuff can't be easily integrated without cost, so I can see why it isn't there. * Comparatively weak runtime reflection. You don't need it most of the time, but it can be really useful. * Having to import traits that other traits import. * It's a niggle, but not being able to upcast a trait has irritated me once or twice. * Exceptions. I know this is heresy, but when working on code with a lot of extremely unlikely error paths (I/O code, for example), the number of Options and Results multiplies ridiculously and makes my code quite noisy. I don't want exceptions for *most* situations, but IMO they can make some code much cleaner. * And the biggest one - not having toString and hashCode guaranteed to be on every type. It's SO nice when I go back to Java and can easily just print out any value when I want to know what it is.
Higher kind types
Sorry, i meant: are there people who are personally interested in Rust who just happen to be associated with Yandex or is Yandex interested in Rust?
Some of the aspects of the trait system can be very frustrating. You can be severely restricted by a declaration somewhere else in the system (like in the standard library). The first is a generic trait implementation in terms of another trait. This means you can't implement your own independent versions. While for some traits this would make sense, like implementing PartialOrd in terms of Ord so you can't make them inconsistent, in other cases it's more arbitrary like the implementation of Hash in terms of toBytes (I can't remember the exact details here, but it may have changed since I ran into this issue). There needs to be a good way to provide a default implementation for a trait in terms of another trait without excluding independent implementations of both traits. The second issue is traits like Ord which can be usefully implemented with different meanings in different contexts for the same struct, like ordering by different keys. Using newtypes for this feels especially heavyweight and awkward, and classes like PriorityQueue don't provide any other means to provide the ordering.
Yeah, there is nothing wrong with `unsafe` in of itself. The key is to use them as little as possible and wrap them in a safe API. Callers don't need to know that pointer shenanigans are happening inside the data structure. And if something goes wrong, you have a smaller footprint to audit. For example, I'm working on a LMAX-Disruptor clone, which is basically a SPMC, lock-free ring buffer. I have two unsafe functions and five unsafe one-liners in the couple hundred lines of code. The actual unsafe usage is rather mundane too, they are only unsafe because I need to store a mutable Vec&lt;T&gt; in an immutable slot, so it requires an Unsafe&lt;Vec&lt;T&gt;&gt;. All the one liners are just retrieving slices, etc.
It is mostly people personally.
This seems like it could be simplified some...
[Higher kinded types](http://hydrocodedesign.com/2014/04/02/higher-kinded-types/)
&gt; Inability to do anything like an Abstract class. Say you have an Abstract class that implements 95% of the functionality, but you want your end-user to implement the last 5% and then supply the class to your library. In Rust, the end-user has to implement a wrapper around the "abstract" struct. It exposes a lot of ugly API to end-users. There are workarounds (using closures, etc) but the resulting API is ugly either way. Actually that seems pretty doable with a trait, like: trait AbstractClass { fn abstract_method(&amp;self); fn use_abstract(&amp;self) { // other things self.abstract_method(); } } Then when your struct implements the trait, it just needs to implement the abstract_method and it gets the use_abstract method for free. Your library then could just have some functions like: fn use_an_abstract&lt;T: AbstractClass&gt;(thing: T) { ... } No ugly api! The downside of this is that you can't supply members to the struct through a trait, but if you need access to getting or setting one you can make them "abstract" methods of the trait. &gt; And in the case of "constructors", you get to set it on the returned struct too, with a gross double-colon that I always forget (MyStruct::&lt;T&gt;) Agreed about all the boilerplate with generics :/ Although in your example, you shouldn't need the ::&lt;T&gt; for the constructor, right? Type inference should take care of that if you write just: pub fn new(v: T) -&gt; MyStruct&lt;T&gt; { MyStruct { field: v } }
It might be, but I don't know Scala, so I went with what I know :) But why do you say that? Is it because both are multi-paradigm? Or some technical reason I'm overlooking?
I'm relatively new-ish, so feel free to correct me. The problem I ran into is if the abstract class needs it's own state variables. For example: trait AbstractClass { fn abstract_method(&amp;self); fn use_abstract(&amp;self) { self.transmogrify(); self.abstract_method(); } fn transmogrify(&amp;self) { self.internal_state = 1; //Oops! Traits can't have variables } } So now you're in a position where the user implementing the trait also has to declare the state variables that the library needs internally, which is *really* gross. It was at this point that I decided I could either split the state out into a separate component, or just pass a closure since it's basically the same thing. Would love to know if there is a better way to do it! &gt; Type inference should take care of that if you write just: Good call on the ::&lt;T&gt;, not sure why I thought it was required. Hooray for reduced boilerplate! :)
&gt; Modules/crate system. Maddeningly complex, although I think I'm (finally) figuring out how it works What would you like instead? A lot of people complain about this, but I haven't seen any coherent proposal for something else to do. &gt; Why do I need to define the &lt;T&gt; on the struct, the impl and the impl name? Because there are different options in each case. For example, you could add bounds to any one of them.
&gt; The second issue is traits like Ord which can be usefully implemented with different meanings in different contexts for the same struct, like ordering by different keys. Using newtypes for this feels especially heavyweight and awkward, and classes like PriorityQueue don't provide any other means to provide the ordering. You want this. Languages that don't enforce this (like Scala, or old Rust) end up in bad situations whereby hash tables can get silently corrupted because the `.insert()` method was called with different hash implementations for the same key.
Yeah, I understand the importance of coherence, but there needs to be a good answer to the practical requirement to sort the same type differently in different datastructures.
I don't really have any issues w/ the language itself at this point; my concerns are mostly structure/build-related. Personally, I think there are too many crates included in the standard distribution. I hope that at some point the less essential crates get siphoned off into their own repos. I also dislike how Windows support has essentially been consistently abysmal since the beginning and there seems to be very little progress made on this front. I would think that somebody involved w/ the project would want to take initiative to make this cross-platform language actually, you know, cross-platform.
&gt; What would you like instead? A lot of people complain about this, but I haven't seen any coherent proposal for something else to do. I don't know :( I've also seen this complaint discussed *ad nauseum*. I understand *why* it is the way it is, and I don't have a better solution, but I still find it miserable to use. Not helpful at all, I know. Sorry :( I think my biggest hurdle was understanding the order that things need to come in, which seems arbitrary. E.g `use` before `mod`. use ringbuffer::{RingBuffer, Slot}; mod ringbuffer; Coming from more dynamic languages, I see `mod` as the equivalent to `import` or `require`. So then my brain get's all confused how I'm supposed to `use` a namespace before it has even been imported. And then my brain just breaks whenever I try to deal with hierarchies of dependencies. If I need a crate in a "child" source file, do I `extern crate` in `lib.rs` or in the child? When do I use self:: or super:: ? etc etc I freely admit that I'm terrible at programming, and take full responsibility for not understanding the crate/module system...but it does constantly trip me up :( &gt; Because there are different options in each case. For example, you could add bounds to any one of them. How? If I try and add a trait bound on the struct &lt;T&gt;, I get this: src/lib.rs:66:1: 77:2 error: trait bounds are not allowed in structure definitions src/lib.rs:66 pub struct MyStruct&lt;T: MyTrait&gt; { And if I try to add a trait bounds to the impl name, I get: src/lib.rs:79:18: 79:19 error: expected `,` but found `:` src/lib.rs:79 impl&lt;T&gt; MyStruct&lt;T: MyTrait&gt; {
I've recently been irritated by the restrictiveness of `&amp;` and `&amp;mut`. I'm writing a single-threaded program; therefore, Rust's pointer-aliasing rules are acting as nothing more than (1) a way to force me to give my program's architecture (unnecessarily) strict ownership rules, and (2) a way to enable tiny optimizations equivalent to C99's `restrict` pointers. There's simply no way for me to write a mutable object with shared ownership (say, the set of registers in a console emulator) without either using `RefCell` (and risking difficult-to-track failures at runtime), or filling my codebase with `unsafe` blocks. I know this is an unrealistic complaint ("safe and concurrent" is two-thirds of Rust's motto), but I figure this thread is more for venting than it is for actual feature requests ;)
My problem is that there is a lot of boilerplate required to do something that should be as easy as `"Hello".to_uppercase()`. The reason being that "the points in a character might not have an uppercase" which is valid, but sometimes ease is better than validity. Another thing is that it is really hard to find a list of methods that a Type implements. I can't just go on the docs page, I need to go searching through the structs used to find the correct thing. Once again, it is correct, but it is not usable. 
&gt; How? If I try and add a trait bound on the struct &lt;T&gt;, I get this: This will be supported in the future. &gt; And if I try to add a trait bounds to the impl name, I get: Yeah, I didn't quite speak accurately here. For that case, it's because you can write: impl&lt;T&gt; MyStruct&lt;T,int&gt; { ... } Which is different from: impl&lt;T,U&gt; MyStruct&lt;T,U&gt; { ... } Which is different from: impl&lt;T:Show&gt; MyStruct&lt;T,int&gt; { ... } So as you see you can need all three.
Ух ты! Круто, спасибо :) .
+1 on lots of imports. It is weird importing things that don't even appear in your code.
Ah, ok :) Would you mind explaining what the `&lt;T, int&gt;` varieties do? I have no idea what that is supposed to represent.
If you're code isn't too huge, you can use play.rust-lang.com to share it too!
There are approaches that allow for coherence in the face of local instances.
a package manager ... it infects your clean code with evil outside code &gt;:}
What's lacking in generics and what you mean by real generic arrays?
Compiling rustc really makes you regret trying to contribute :-(
Could you expand a bit more on your use case? Rust allows you to have almost any directory or module hierarchy that you want.
Implement methods that are available if the second type parameter is `int`.
I think you misunderstand `mod`, this is not good. **You should use** `**use**`, this is the way to "import" or "require" something. `mod` defines the module hierarchy. Defining modules is different from using them.
https://github.com/rust-lang/rfcs/pull/102#issuecomment-47285329 an awful reason. It's not magic. It's strategic. There's more reason to use mongodb (read none) than to enforce distinction between pointers, references, and values. 
Tuples only containing types defined in a crate, are treated as being defined in another crate (the standard library?), so you can't implement traits defined in other crates on them. No tail call optimization, making functional programming more or less impossible.
Sorry, I might not have been clear. `mod ringbuffer;` in my example is referencing an external file/module (`ringbuffer.rs`), which is being defined as a child of the current module. The confusion comes from the fact that you need to first `use` a namespace before it is even defined in the current module. 
Could you give an example please? This is something I've been thinking about a bit.
&gt; impl&lt;T&gt; MyStruct&lt;T,int&gt; { ... } But there is no second type parameter here? Edit: Maybe I'm just horribly confused. Consulting the documentation now... 
My proposal for a simpler ui over the same system is an import with relative path, analogous to #include header based code with #pragma once. `'use mod &lt;relative-path&gt;' //brings it into the project if not already, and bring the module into scope` super:: = ../ foo::bar == foo/bar.rs relative to here etc. (would assume that its' a file, not a submodule within a file, and further symbols could be used). with this every module could describe its own context, relatively, and it would be easier to refactor back and forth between many crates or 1 crate feedback i got in the rfc s that it adds complexity, but my suggestion is a shortcut that should work with the existing scheme rather than against it. however i'm also told rust used to have relative use's and it was found to be more problematic?
It now only allows `mod` statements at the top-level module in a directory.
Dang, good point. It's irritating to learn the costs which we absolutely have to pay for memory safety, but at the same time, it kind of highlights all of the impossible things you need to reason about to guarantee the safety of code written in C++. The pattern "take a reference to a global variable which contains a vector -&gt; call a function which takes a non-const reference to that global variable" doesn't exactly scream "dangling pointer", right?
Similarly to other people, I don't like the large amount of matching/nesting you need to do when dealing with many Option types. In Haskell we can just write a different version of the function that matches in its parameters for None, and I really miss that. I find Rust extremely tedious lately, and I am hoping that goes away as I get more familiar with the language. I think unwrap_or() is fine and useful, I don't feel there should be a plain failing unwrap() at all, this will be the first thing noobies do when dealing with an Option, and I bet they will be pretty disillusioned that they just made their Rust program "crash" when Rust is all about not crashing, as it says right on the website. I do like Swift's sugar for Optional types, I feel like maybe there should be more sugar in general, be it by macros or sigils or whatever, I did like the ~ sigil very much and would like to see that put back in as some sort of sugar even if it means there are two ways to do the same thing. I have recently attempted to do something 'low level' that I would do in C/C++ which is read a file into some memory on the heap and then overlay a struct on that memory, and found myself a bit confused, how do I just create X bytes of memory, how do I zero this memory, how can I do a memcopy, can I just use transmute at this point to overlay the struct? I eventually figured all this out. I find the standard library a bit disorganized, but it is getting better lately. No github project with a library or demo project I have tried to use has ever worked for me in the past 10 months, I can never figure out what build of Rust goes with which library or project. I would very much like to try Rust with OpenGL or PortAudio, but I have not been able to. (And if you look on my github I am guilty of not putting my rust version too) If I did build a library I wouldn't know where to put it, in my project? In the /usr/lib/rustlib directory? I can't wait until there is a package manager. The Port Audio library for Rust does not implement the audio callback (it is unusable for real-time audio without it), and as many times as I've asked why it is not implemented or if it is for some reason impossible at this point, I never get any answer other than that of course it can because Rust can do everything C++ can do. I don't like how the Rust community compares the ideal version of future 1.0-and-beyond Rust with finished languages that exist today such as C++ or Go saying it can do everything those can do, when it is currently untrue due to the language not being finished. After looking into wrapping libraries with the FFI many times, I am still confused on how to wrap functions taking pointers to pointers used as in/out params which is all over the place in C, I am very confused still about how to deal with opaque handles that many C libraries use although I've read the docs on this many times. I have managed to create a simple max/msp plugin with Rust, however. Rust takes forever to compile because of the need to rebuild llvm every time (do I really need to do this?) In some ways the Rust I started out learning has changed to be something I am becoming uninterested in due to the huge amount of tedium involved, and difference of opinions about sigils and sugar. And at this point I am just waiting for 1.0 so I can again check and see if this is a valid language for me to do DSP audio work in, because for me, doing audio programming in something other than C/C++ is the entire reason for my interest in this language. A few of these complaints are because of my unfamiliarity with Rust, and I hope they will go away as I progress. Overall I feel like what started out seeming like a straighforward language that was easy to understand quickly became very complicated, much more so than C++ even, when I tried to do anything non-trivial. I'm not going to write off the language, I feel it has so much potential, I am basically in waiting for 1.0 now. Edit: Added another thing. 
It would be possible to have a more relaxed reference type like `&amp;share` forbidden from aliasing with `&amp;mut` and `&amp;` but allowed to alias with other `&amp;share` references. It wouldn't be possible to take a `&amp;share` reference to the interior of an enum or a container. However, this would cause an enormous amount of additional complexity in libraries, since many places would need a `&amp;share` version in addition to `&amp;` and &amp;mut`.
I've been struggling with the same issue, but I've since decided that more stable releases at this point would make it more difficult for them to make breaking changes. We still need quite a lot of space for breaking changes.
I owe you a beer or coffee or tea for saying HKT! :-) (Also easy to redeem because we're both in NYC!) There's some math/array codes I'd love to try to port to rust, but I can't afford the time it'll take to port sans HKT (hkt in BOTH senses mind you :-)). Would have to manage a painful amount of duplication otherwise. 
&gt; Tuples only containing types defined in a crate, are treated as being defined in another crate (the standard library?), so you can't implement traits defined in other crates on them. afaik niko matsakis intends to fix this.
I'll qualify this comment with the following statement: I am not a systems programmer. I have in the strictest sense "written" C/C++, but I generally favor GC'd languages for simplicity/safety reasons, and have never written a substantial production-quality C/C++ application. I am currently trying to understand the ideas behind Rust, and am evaluating it from the perspective of implementing data structures and algorithms. I am hoping Rust will provide a platform for writing efficient and simple data structures, while preventing me from making the kind of mistakes I would in C++. I do not believe that I currently have a "solid" understanding of Rust, so I may be incorrect about some things. I always appreciate being told that I'm wrong, especially when there's a better/easier way to do something. I've personally had a lot of trouble groking how to use Rc (and consequently Cell/RefCell) correctly in Rust. I get the impression they're second-class citizens, or some kind of shim, as any examples I find in docs (if they're mentioned at all) strike me as toyish. Box gets nice syntax-level support to easily wrap/unwrap values, while Rc/Cell doesn't. I see Rc frequently touted as a way to implement trees with parent pointers, but everyone I've asked (notably, after they suggest using Rc for trees) has been unable to direct me to an actual *example* of someone doing this. Especially using Rc in a context when the number of Strong references is literally always supposed to be 1 strikes me as a bit odd. So far, just using boxes and raw pointers wrapped in a couple of unsafes seems simpler and saner for Rust data structuring. This is how DList does it, and it comes off pretty elegant. TreeMap and BTree meanwhile, are implemented to avoid the issue of parent pointers altogether, which is an interesting and clever design tradeoff.
Historically `"Hello".to_uppercase()` did not exist, because there was no `.to_uppercase()` method on the `char` type. This has changed, though the `.to_uppercase()` method does have some limitations noted in its documentation. I don't think providing a method with the same limitations, but for strings would be unreasonable (i.e. I'd expect such a pull request to be accepted).
Yeah, I understand that there's exceptions at an implementation level. I'm more talking about the user affordance of not having to try!/unwrap/map/whatever every single value you get back from an SQL query because the type might not be what you specified. Arguably the library could set it up so it does the failing for you if a type doesn't match, but then you're into libraries causing task failure which i understand is typically discouraged.
Only for bare `mod name;` statements though.
Just FYI, the [Rc documentation](http://doc.rust-lang.org/std/rc/index.html) has been updated recently. If the examples there are confusing/bad/whatever, say and I'll try to improve them.
~~Rust has decent automatic string conversion - it just isn't the default because if it did this for every single type it wouldn't be very lightweight:~~ #[deriving(Show)] struct Thing; ... println!("{}", thing) ~~And hashing too - just not the default for the same reasons as above:~~ use std::hash::sip::hash; #[deriving(Hash)] struct Thing; ... println!("{}", hash(&amp;thing)) a) Rust is low-level so it has to cut some corners. It's easy to add in this functionality though. b) Hopefully your toString() issue will be solved by Primitive or Num depending on a Show implementation.
(example in game development here, since that's my main programming area) Say I have an `Entity` type. Entities have a position, perhaps a velocity, and functions to `update` and `render` each frame. Then you have another type, say a `Human`. A `Human` is a subtype of `Entity`, and it could have a variable for health, and maybe a weapon. It will also need to define behaviour in the entity's `update` and `render` functions. Then maybe we get more specific and have a `Warrior`. A `Warrior` is a subtype of `Human`, and it keep the same `render` function, but perhaps the `update` function needs to change. (There are a few more things that would be neccessary, but those are the main problems with the current system) The problem is that the trait and struct system doesn't support this (easily). At the moment, I have to define traits for each supertype, and then have a whole load of structs and impls with nearly exactly the same behaviour and variables. Sure, the macro system helps make this easier, but I'm still writing an awful lot of code for no additional functionality. I think your [RFC on virtual structs](https://github.com/rust-lang/rfcs/pull/5) is the most convenient way of allowing this, but it may even be possible to put something together using little more than a bit of sugar. At the moment, by abusing `Deref` you can fake inheritance through composition (I wrote an example here: http://is.gd/QaBG2z). However, mixing this approach with traits and casting down into subtypes does not work. However, you're a lot more familiar with the workings of Rust than me, so you may be able to find a way to turn that into something that allows better polymorphism.
This code sample: extern crate debug; struct Foo { a: int } let foo = Foo{ a: 1 }; println!("foo = {:?}", foo); Will print: foo = Foo{a: 1} I still see no value in having a default hash implementation that is not correct 99.9% of the time
Yes, I was definitely pleased to see it updated with some examples. I would personally prefer that the statement: &gt; For example, a tree with parent pointers can be represented by putting the nodes behind strong Rc pointers, and then storing the parent pointers as Weak pointers. be given an *actual* accompanying example, or removed. A splay tree is probably the simplest structure I can think of that desperately needs parent pointers (their height can be O(n), so maintaining an explicit or recursive stack of your search path is a terrible idea). I don't think you even need a full structure. Just simple Tree/Node structs, and then an example of, say, DFS (that uses O(1) memory), and performing a rotation.
Because type-based dispatch is useful. It allows you to attach methods to types and callers can automatically call them without the caller having to import the methods specifically. For example, in OCaml you have to write `Hashtbl.insert m k v`, whereas in Rust you can just write `m.insert(k, v)`. You could `open Hashtbl` or `let insert = Hashtbl.insert in ...`, but then that prevents you from calling other unrelated methods called `insert`.
Haskell gets along fine without it. I think in most cases newtypes or methods that take closures (e.g. `.sort_by()`) are good enough.
Its deriving(Show) for quite some time now. And he is trying to debug print things that do not have Show instances.
&gt; I did like the ~ sigil very much and would like to see that put back in as some sort of sugar even if it means there are two ways to do the same thing. &gt; In some ways the Rust I started out learning has changed to be something I am becoming uninterested in due to the huge amount of tedium involved, and difference of opinions about sigils and sugar. Rust is not going to get sigils back before 1.0. Sorry.
Agreed. The amount of `as_slice` and `to_string` calls in my codebase is absurd. We really need some auto-coercion here or well _anything_ other than the silly mess we have.
Thanks, I've fixed my reply now
This proposal wouldn't make the `match` example warn, because it doesn't make any code unreachable. Only immediately silly things like "x = continue" would warn.
Primitives are normally only passed by reference into traits, where it is very reasonable to use other (nonprimitive) types.
&gt; Another thing is that it is really hard to find a list of methods that a Type implements. I can't just go on the docs page, I need to go searching through the structs used to find the correct thing. Once again, it is correct, but it is not usable. The struct? Do you mean traits? Also, have you looked at the docs recently? Nonbuiltin types have always had a page with a summary of all methods and traits (e.g. [`Vec`](http://doc.rust-lang.org/master/std/vec/struct.Vec.html)), and now all builtin ones ([except raw pointers](https://github.com/rust-lang/rust/issues/15318), for now) have such a page too (e.g. [`u64`](http://doc.rust-lang.org/master/std/u64/primitive.u64.html)).
We have [binary installers](http://www.rust-lang.org/install.html).
&gt; My worry is that there's not enough time before 1.0 for that to play itself out in some areas. Such as? :)
&gt; I'd rather have types explicitly derive things like Copy instead of it being inferred by the contents, since I think it is a crucial part of the API. I know there was talk about changing this, but I'm unsure how that turned out. [Yes](https://github.com/rust-lang/rfcs/blob/master/active/0003-opt-in-builtin-traits.md), with [a follow-up proposal](https://github.com/rust-lang/rfcs/pull/127).
3 times I tried to play with Floor, and in all three I couldn't because rust-http had some compile error under the then-current Rust master :(
Look at the [str docs]( http://doc.rust-lang.org/std/str/) it has a list of functions, which is nice, and then it lists all of the traits, and not the methods that a str object implements. When I go to the std::str (as an example) docs page I want to know everything I can do with str objects, I don't care about the trait names (that's a lie, I'll have to use them) I just need to know they exist. Think java api docs. It's so simple and understandable.
The mentioned ones. A couple of the RFCs I've already submitted. Some of the ones I'm going to. ([For example.][example]) [example]: https://github.com/rust-lang/rfcs/pull/135#issuecomment-47713550
&gt; No github project with a library or demo project I have tried to use has ever worked for me in the past 10 months, I can never figure out what build of Rust goes with which library or project. I would very much like to try Rust with OpenGL or PortAudio, but I have not been able to. (And if you look on my github I am guilty of not putting my rust version too) If I did build a library I wouldn't know where to put it, in my project? In the /usr/bin/rust directory? I can't wait until there is a package manager. We have one now: [Cargo](https://github.com/rust-lang/cargo/). ([Basic docs](http://crates.io/).) If you're having building problems: upgrade to the latest nightly and then, if it's still not working, consider updating it and submitting a pull request. (Normally the updating process is quick, especially if the library has been tracking master reasonably closely.) &gt; The Port Audio library for Rust does not implement the audio callback (it is unusable for real-time audio without it), and as many times as I've asked why it is not implemented or if it is for some reason impossible at this point, I never get any answer other than that of course it can because Rust can do everything C++ can do. That's sounds more like a "problem" with the developer of that library, not really a problem with the Rust language... well, maybe "being young so the library ecosystem is still developing". Also, assuming you're using [the rust-portaudio bindings](https://github.com/JeremyLetang/rust-portaudio), the [`PaStream` type](http://jeremyletang.github.io/rust-portaudio/doc/portaudio/pa/struct.PaStream.html) does have a `callback_function` field? (Lastly, you could [file a bug](https://github.com/JeremyLetang/rust-portaudio/issues).) &gt; I don't like how the Rust community compares the ideal version of future 1.0-and-beyond Rust with finished languages that exist today such as C++ or Go saying it can do everything those can do, when it is currently untrue due to the language not being finished. People are often saying that the *language* can do everything, but the libraries are still missing. (I.e. they are saying that it is possible to write such libraries in Rust, even if they haven't been written yet.) &gt; After looking into wrapping libraries with the FFI many times, I am still confused on how to wrap functions taking pointers to pointers used as in/out params which is all over the place in C, I am very confused still about how to deal with opaque handles that many C libraries use although I've read the docs on this many times. I have managed to create a simple max/msp plugin with Rust, however. `const T*` should be bound as `*const T` in Rust. `T*` should be bound as `*mut T`. Opaque types can be defined as `enum Type {}` or `struct Type;` and just stored as `*mut Type` everywhere, e.g. a C function like int some_library_init(opaque_t** out, const int32_t* values, size_t length); would be bound as #[allow(non_camel_case_types)] enum opaque_t {} extern { fn some_library_init(out: *mut *mut opaque_t, values: *const i32, length: libc::size_t) -&gt; libc::c_int; } The [FFI guide](http://doc.rust-lang.org/master/guide-ffi.html) does include examples of all this, but it's not explained very well.
&gt; That methods are "special" I don't see how making them not special would work without resorting to overloading and/or multiple dispatch (for the sake of symmetry). Methods are special since the kind of function you actually call depends only on what kind of object you have left of the dot (and the kind of compile-time parameters that are specified or inferred for a generic function). If you don't want that special call syntax but provide "self" as first parameter, I would be very unhappy about the asymmetry: the first argument is somehow special in that it affects what function is actually called. If you want to restore symmetry here, you need overload resolution and/or multiple dispatch (I'm thinking of Julia)
&gt; there seems to be very little progress made on this front This is very unfair to Vadim Chugunov, klutzy and Alex Crichton who have put a lot of hard work into improving our windows support! If you look through [the closed windows issues](https://github.com/rust-lang/rust/issues?labels=A-windows) it's normally one of those 3 who diagnosed the problem. :) (AIUI, Vadim recently removed the last major blocker for [running Rust on 64-bit windows](https://github.com/rust-lang/rust/issues/1237) by adding the relevant exception handling support to LLVM upstream!) That said, our support is definitely a work-in-progress (please [file bugs](https://github.com/rust-lang/rust/issues/new) if you happen to meet any).
There is a special page for the actual [`str`](http://doc.rust-lang.org/master/std/str/primitive.str.html) type; the interface isn't perfect (and will be improved) but it is there... FWIW it's [even linked from the `std::str` page](http://doc.rust-lang.org/master/std/str/index.html#primitives).
I think you have to write a procedural syntax extension to be able to use unquoting?
I do like your proposal there.
Well, for example (I apologize if I use the wrong terms but I haven't gotten really deep into rust due to the rapidly changing syntax): httpcrate + http |- header.rs |- request.rs |- response.rs Where header.rs contains `struct Header` as well as `Header`'s `impl`, with the same going for `struct Request` and `struct Response`. I'd like to be able to `use http::Request` without needing to do `use http::request::Request` and the like. I know it's possible to re-export it in mod.rs but that's a really big hassle that I feel could be automated somehow. Possibly some way to say in mod.rs that all the other files in the same directory are part of the same module and not distinct additional modules. As an analog to C#, it's typical to put each class (and maybe some other closely related types) in its own file and each part of the namespace would have its own directory. I've recently started messing around with D and found that the system is very similar to the way rust does it and Go tends to do the same thing. It's a bit annoying to me that all these new(ish) languages I like that are coming out tend to lean toward having massive files that are hard to find anything in.
I don't know anything about the particular things you complained about, but I have the same feeling. Instead of logical consistency, there's just solving each problem one at a time. If a slice of a String is &amp;str, then a slice of a Vector is ___
Ah, I don't imagine rustc itself will move off makefiles in the near future, but theoretically one should rarely meet that by [using the binary installers](http://www.rust-lang.org/install.html) (unless of course you'd like to hack on the compiler/standard libraries... in which case, yeah, support is lacking :( ). `cargo` should mean almost all second-party Rust libraries don't need Makefiles at all (certainly pure-Rust ones shouldn't). I don't have any knowledge about the plan for the MinGW dependency, but I *can* dump links to relevant issues: - [#1768](https://github.com/rust-lang/rust/issues/1768) - [#9367](https://github.com/rust-lang/rust/issues/9367) - [#11782](https://github.com/rust-lang/rust/issues/11782)
/r/playrust
Version number too low.
I kinda hate all the str/String business. The API feels bad and incomplete.
 fn main() { let x = 1; println!("{}", x); } print.rs:3:20: 3:54 error: cannot determine the type of this integer; add a suffix to specify the type explicitly print.rs:3 println!("{}", x); ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ note: in expansion of format_args! &lt;std macros&gt;:2:23: 2:77 note: expansion site &lt;std macros&gt;:1:1: 3:2 note: in expansion of println! print.rs:3:5: 3:56 note: expansion site error: aborting due to previous error This is ridiculous. Rust can't print 1 without complaining.
`{:u}` doesn't imply `uint`
I changed the example, "{}" doesn't work on 1.
Hm, the followup doesn't seem to talk about opt-in `Copy` anymore, has that been dropped? That's one I'd actually prefer to have as an explicit part of the API.
 Prelude&gt; let x = 1 Prelude&gt; putStrLn (show x) 1 How come Haskell can make this work? What do I care about the size?
[Yes, seems so](https://github.com/rust-lang/rfcs/pull/127/files#diff-6a9ae0315fbe5d8fd4ff8be8d1f485ddR125).
I know you want to remove methods from the language, but it's not going to happen. Rust needs methods to be palatable to users of other languages.
What Gabor wants is for the caller to have to import every method explicitly before it can be called. That's a non-starter as far as I'm concerned.
Haskell defaults to the unbounded `Integer` type, i.e. it's pretty hard to use it wrong. Rust previously defaulted to the `int` type which was bounded *and* changed sizes on different platforms.
`&amp;[T]`, obviously. I disagree with the characterization of Rust's design as scenario solving. Rust is one of the most orthogonally designed industry PLs I know.
That's too bad. Is `rustdoc` able to infer if a type is `Copy`?
Yes, I believe that knowledge is available to it.
We can mitigate the runtime cost by aborting on failure during tight swap chains. It's not inherent.
Would it be a good idea to open an issue for having that included in the generated documentation? I'm a bit unsure for what to search to make sure there isn't already one.
&gt; I know it's possible to re-export it in mod.rs but that's a really big hassle that I feel could be automated somehow. Ah, I see. FWIW, I disagree. :-) I love that you have to explicitly re-export things. In fact, I do exactly this when writing Python. I use my `__init__.py` to collect all my imports from sub-modules and then "re-export" them one-by-one using `__all__`. It's explicit and it *clearly* defines your public API in your source code. The nice thing about Rust is that it *doesn't* force you to have everything in one file. You can literally split up your code in whatever manner you like. Whether it's lots of little files or just a couple big ones. &gt; As an analog to C#, it's typical to put each class (and maybe some other closely related types) in its own file and each part of the namespace would have its own directory. This is pretty close to how I use Rust now. Check out the [libregex](https://github.com/rust-lang/rust/tree/master/src/libregex) crate that I wrote. The entire module is cleanly divided into separate pieces (parsing, compiling and searching) across multiple files, but it is exposed as a single unified module.
That sounds like a really good decision. Even if you don't, it's a constant. There's literally no way to get this wrong. I understand how to fix it, but as a user of dynamic languages this is what people talk about when they say *"see? static types make you type lots of inane information you don't care about"* I would like to say *"No, you don't have to put types, they can be inferred most of the time"* and then this happens. I'd just say give tagged union of unbounded ints + 31 bit ints as the default.
Rust does not have an unbounded integer type in the language (not yet anyway). Furthermore the actual type matters, even for constants, since trait implementations (etc.) differ, e.g. trait Foo { fn bar(&amp;self); } impl Foo for uint { fn bar(&amp;self) { fail!() } } impl Foo for int { fn bar(&amp;self) {} } 1.bar(); // what happens? &gt; I'd just say give tagged union of unbounded ints + 31 bit ints as the default. You are conflating implementation details with semantics i.e. one might implement an unbounded integer type using a tagged union like that for efficiency. 
How is that obvious? In C++ it's obvious, `array_view` and `string_view` I'm not even saying I like those names, but at least they're consistent.
If there's less than three, we have to post more!
Thanks for the example! Yeah, I think this kind of thing (which fits very well into the classical OO paradigm) is difficult to encode in Rust. Specifically, where there is inheritance of data as well as behaviour. I'm not sure if adding a new feature or adjusting the ones we have is the way forward. Probably the former, seeing as there are performance motivations for that too. I'm wrestling a bit with exactly what kind of subtyping or coercions are necessary for it to work well, but I hope we can work that out a little bit as we go along.
Can you say why? Developement there is ongoing, so specific feedback would be useful.
It just seems so inelegant compared to other codes sometimes... I equivocate about it all the time.
What is HKT? I don't think it means Hong Kong Time, which is all Google is getting me.
[Higher kinded types](http://hydrocodedesign.com/2014/04/02/higher-kinded-types/) ([#8922](https://github.com/rust-lang/rust/issues/8922)).
Why not make all integer literals be, say, always i32? Or always i64? Why the need for a generic integer?
I see what you mean but I just feel so... *wrong* doing stuff like `pub use http::request::Request` =/
I might not have found this trick if Rust didn't break the lifetime on traits, because then I would not have rewritten Rust-Graphics which lead to TyOverby's idea which lead to this idea. A lucky coincidence.
&gt; That methods are "special" and can only be added by the owning module. That's not a wart. It's to avoid name collisions. &gt; The nondeterministic name resolution in some places It's not nondeterministic. Maybe it's too complex, but it's not *nondeterministic*—there are specific rules. &gt; as well as the statics/enum variants vs. bindings issue in patterns. There is no problem here in practice, and the cures (significant case—which doesn't work with statics anyway—or sigils) are worse than the disease IMO.
It'll be perfectly orthogonal in Rust when we have DST. Then `&amp;[T]` will be nothing more than an existential (i.e. with the number erased) version of `&amp;[T, ..N]` where `[T, ..N]` is the fixed-length array syntax. `&amp;[T]` and its interaction with DST is actually one of the most simply and orthogonally designed parts of the language.
I was just asking about that on IRC. I would like more functionality in Rust. Being able to use `Option` or `Result` as functors or monads would be a lot cleaner than nested `match` blocks or matching on tuples.
You can use concrete `Option` and `Result` as functors and monads: the `map` method on each corresponds to `Functor`s `fmap` (in Haskell), and `and_then` corresponds to `Monad`s `&gt;&gt;=` (aka "bind"), with `Some` and `Ok` (respectively) corresponding to `return`. The thing HKT allows is *generic* monad handling.
Higher kinded traits, though good support for higher kinded types would be good too! :-) Basically wants needed to implement even a simple Join :: m (m a)-&gt; m a That works genericly with both option and result types and a few bajillion other things 
This is a whitespace argument, but not the typical Python one... One of my favourite parts of Rust is that it takes on responsibilities that were previously given to humans (e.g. concurrency) so the Rust language designers acknowledge that humans are fallible much more so than the designers of other languages. In other languages they think that a super-human programmer will avoid all the traps and they blame programmers when they fail (and history has taught us that they always do, hence Rust), but Rust acknowledges human realities much more than other languages. So, along that line of thinking, I don't understand why Rust allows weird whitespace when it could just treat it as an error and refuse to compile. Like most bracey languages Rust has two levels of syntax: 1) brackets that compilers read, and 2) whitespace that humans will see as grouping in addition to brackets. This means that these can potentially be misaligned and cause programming errors. I'm not suggesting getting rid of braces but I think that whitespace which doesn't align with the braces shouldn't be allowed. E.g. the following code shouldn't compile, fn main() { let n = 5i; if n &lt; 0 { print!("{} is negative", n); if n == 0 { print!("example");} } else { print!("{} is zero", n); //this is actually attached to the above if } } I'm sure any one of us could come up with a better example than that, but you get my point. Whitespace is meaningful to programmers and Rust should take responsibility for it. Ignoring problems like this is the ethos of C.
Well, first, I'm not trying to start an argument...just explaining my confusion. Second, your comment isn't really true. In PHP for example, you can define multiple namespaces in a single file, or across multiple files. One-file-per-class is merely a convention settled on by the community. You can also alias namespaces any which way you want. The only hard rule is that you must first `require` or `include` the source first, which is basically equivalent to *physically adding it to the source* at that location. And you must do that before you can `use` the namespace. Hence my comments. In any case, I don't want Rust to be like Python, PHP, Ruby, etc. Just explaining my confusion since it seems like a common problem amongst new people :)
I was wanting something like `(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c` to combine two `Option`s into one if both are `Some`. It's pretty straightforward to match that with a tuple: match (maybeA, maybeB) { (Some(someA), Some(someB)) =&gt; Some(combine(someA, someB)), _ =&gt; None } But it would be so much cleaner if it was maybeA.with(maybeB, combine) //Option::with is just a suggestion Wouldn't be too hard to write a macro for it, I guess.
&gt; This is problematic because Rc enforces memory safety by only giving out shared references to the object it wraps, and these don't allow direct mutation. `Rc` also has the `make_unique` method which is kind of clunky in that it will give you a mutable reference if there is only one strong reference, and give you a clone otherwise. For that reason it also requires the generic type to be implement the `Clone` trait
That still doesn't require HKT, HKTs are only required to write a generic function that handles it (i.e. HKT are required to write `liftA2`, which is what your function is). E.g. it could be added as a method on `Option` now: fn with&lt;B, C&gt;(self, other: Option&lt;B&gt;, f: |A, B| -&gt; C) -&gt; Option&lt;C&gt; { self.and_then(|a| other.map(|b| f(a,b))) } (You'll note that my implementation there can also be used directly, and that source can even be copy-pasted to be used with `Result` even if it's not truly generic.)
&gt; For that reason it also requires the generic type to be implement the Clone trait To be clear, `Clone` is only required when calling `make_unique`; `Rc` can still be used for types without `Clone` (but calling `make_unique` will be illegal).
Yes that's what I was trying to convey
I thought about opening an RFC to suggest that but when I asked about it on IRC I was told "just use `match`". It doesn't seem like much to add and it seems really convenient.
Well... the `and_then` + `map` version works too. (And naturally extends to more arguments: `x.and_then(|a| y.and_then(|b| z.map(|c| f(a, b, c))))`... not as nice as Haskell's `f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z` but nicer than the match, maybe?)
I'm on smartphone so typing is a pain. My main complaint are following: 1. `String`/`&amp;str` conversion to and from seems needless. I think either they need some kind of auto cast or their API needs to be almost eqivalent where possible. I generally oppose magic but this one place might be needed. 2. Randomly accessing strings should be supported. If you need as special structure for this so be it. I imagine it woul work same as ASCII trait `("String".to_rastring())[3]` because of the expense of initializing such structure. 3. Also `ASCII` trait needs a rename and/or fix. Various other non-ASCII encoings have need for uppercase. 4. ` r""`, `b""`, regex string need documentation and examples. 
&gt; I think unsafe blocks are poorly named. Agreed. Let's call them dragons ;) because if I found a function prefixed dragon I would be like wtf need to check this s in docs. &gt; I'm unsure about manually annotating integer literals. Can't you say let x : [int32] = [1, 2, 3]?
i'm strongly in favour of that. bouncing between foo(a,b) and a.foo(b) is a huge frustration in C++(and it could be fixed with either ufcs or extention methods) you still have a bit of this in rust .. some std lib functions have moved. its better though because it does have extention methods.
You're presenting a false dichotomy. No one is claiming that the there should be a single type. Both `T` and `&amp;T` must obviously exist, it's just that _using_ `&amp;T` shouldn't require special syntax. Auto-deref (and auto-ref if we decided to use that as well) would make using `&amp;T` pretty much the same with using `T` even though they are two different types.
It may seem that way, but when you actually try to do so you find that nothing you come up with satisfies all of the usecases properly...
Task unwinding. I want to have a function like this: replace_with&lt;T, U&gt;(&amp;mut T, U, |T, U| -&gt; T) Which would replace the contents of the first parameter with the result of the closure. That would allow a good number of safe and efficient operations to be done all over the place (including in data structures that implement the MutableHash trait). But since the closure may fail, this function is inherently unsafe. In my honest opinion, there are only two kinds of failure: recoverable (already well addressed by Result&lt;T, E&gt;) and unrecoverable. The latter should finish the whole process, because that's a lot better than leaving the program in an undesirable state. Task failure is a weird in-between with the disadvantages of both approaches. I'm not sure why it was included, I hope it was for a good reason. But I think recoverable task failure would be better implemented by simply using Result&lt;T, E&gt;. Besides, affine types work well only in linear control flow. Task unwinding apparently breaks the control flow. 
From the post I was replying to: &gt; In most system languages, you want to have a clear differentiation between what is a non-owned pointer, what is a local value, etc. because you need to manage their lifetime manually, and having a clear difference between a pointer and a value helps doing so. &gt; &gt; But Rust automatically manages the lifetime of everything and tells you when you do something wrong. So why would I care whether I manipulate pointers or values? Why do they have two different syntaxes? AFAICT the complaint wasn't about auto-deref: Rust still needs a clear difference between pointer and values to help you help the compiler *check* lifetimes correctly (the compiler doesn't actually do any runtime management of them, just statically verifying they work). Maybe I misinterpreted and the original post was only talking about syntax for pointers in expressions (i.e. where auto-deref kicks in).
&gt; Man, type coercion has bitten me in the ass more times than I care to admit No one is saying "implement it like JavaScript" :)
some platforms go out of their way to make cross platform harder...
rustfmt will take care of this issue.
You should compare/contrast with hammer.rs if you haven't already.
&gt; From the post I was replying to I think the text you are quoting can be understood as complaining about the need for different syntax when using `&amp;T`. At least that's how I see it. &gt; Rust still needs a clear difference between pointer and values to help you help the compiler check lifetimes correctly No disagreement with that. &gt; Maybe I misinterpreted and the original post was only talking about syntax for pointers in expressions (i.e. where auto-deref kicks in). That's how I see it. And if it isn't, OP's complaints can still be resolved with auto-ref/auto-deref without losing the distinction between `T` and `&amp;T`.
What you're asking isn't subtyping, it's inheritance. Those are different concepts, and Rust has subtyping, but not inheritance. 
&gt;Anyway, it is supported, via .char_at (using byte indices, the only way to get efficient random access with UTF-8), or by collecting into a Vec&lt;char&gt;. That's not good enough. I remember someone talking about a data structure that could memorize byte indices of characters and allow O(1) access to chars at given position. So no byte indices. Just char position. Also, I'm quite aware there is more than one way to represent char in Unicode. &gt;It seems relatively rare to want a byte literal with UTF-8 encoded multibyte characters, fwiw. (Do you have an example?) Checking that \u2028 char is counted as newline in xml parser. I used str as input.
Just today I was looking for a nice command-line parsing lib that's better than `getopts` (which is a _very_ low bar) in the std lib. Docopt looks amazing! Thank you!
So you're using phantom types (and default type parameters to remove some typing) to ensure your graph typechecks? Very nice.
Not really technical, but the target audiences seem closer, the syntax is closer overall, and lambdas correspond to lambdas better than to blocks :)
and `&amp;[T, ..N]` is analogous to what other syntax?
Aha, interesting - and good to know. So the freestanding functions will be reinstated after the cleanup? I certainly hope so! Great that someone is actively looking at the API design. It's *such* a hard problem, and would be great to have a consistent set of thinking behind it.
I do it all the time, there is an option to disable libc++ and use libstdc++. I do not know it by heart, but it's probably something along the lines of --disable-libcpp. If you `./configure --help` you will find it :)
&gt; but when working on code with a lot of extremely unlikely error paths (I/O code, for example), the number of Options and Results multiplies ridiculously and makes my code quite noisy HKT (and `do` syntax) will fix it much better than exeptions.
I am not at all fond of what the current syntax does to immediate representation of recursive datatypes. The change from `~`-as-boxing to `box` made it cross over into outright obnoxious territory for me - `Cons(1, box Cons(2, box Cons(3, box Nil)))` might be an accurate representation of what is actually being specified, but it is a drudgery to type in the long run and clutters up the code to an extent that really obscures the intention behind it. The usage of a bare keyword to denote boxing also feels very much out of place in an otherwise fairly C-like syntax; while C++ does a similar thing with its operator `new`, the counterpart of the above is not a relevant use case because C++, unlike Rust, makes no pretense of supporting functional idiom. (Don't get me started on the planned `box(GC)` etc.) Even though it would introduces a somewhat illogical and intransparent aspect into the language, this itches enough that I would probably find it better if (un)boxing was done implicitly where it would preclude a type error (so that writing `Cons(1, Nil)` in the above example would be equivalent to writing `Cons(1, box Nil)`).
They aren't phantom types; with the default type parameters, the `shape` and `color` members have the unit type `()`, but they are still members.
My name is not actually Chris Morgan. I go under an assumed name.
&gt; In any case, random access to codepoints isn't particularly useful. Useful no, but will new people ask for it? Yes. I believe the happiest solution might be to just make "string"[2] a sugar or shortcut for "string".iter().take(n). &gt; As in, just for writing a test? Yeah. My tests broke because apparently iterating over a "...".as_bytes() and b"..." isn't the same. Note: I put said bytes in BufferedReader and iterate over the chars. Anyway twiddling with bytes in string is easier than twiddling with files. I used to do that kind of things earlier to simulate BOM. 
I get the `&amp;` sigil, I'm asking where `[T, .. N]` comes from since Java has `T[N]` like `String[10]` not `[String, .. 10]`
I think you need an extra newline in there for formatting
I created a Java project and then added a new file, naming it Foo.rs It seems to recognize the file extension. I compiled via command line for now.
What's wrong with makefiles on windows? Windows is the platform I develop on for work and I've not come accross a windows C/C++ dev box that hasn't had cygwin or msys on it in years. Note, we don't use GCC for anything, just the shell environment and related tools. They are a god send for working around window's automation shortcomings.
 let foo = 42: let mut foo = foo; Redefining mutability in the middle of the life time of a variable doesn't seem to be very coherent with the idea of declaring mutability, and I think this is not adding any special expressiveness to the language. You could achieve the same in the other way: let mut foo = 42; let const_foo = &amp;foo; Furthermore, this way you know since the beginning if there is any chance of foo being modified or not.
It helps a lot, but it only takes a single expression. If I'm doing (say) an SQL query that retrieves 7 columns, I might have Results/Options on creating the connection, creating the statement, running the query, retrieving each of the 7 column values in a loop. All that error handling makes the code feel noisy to me - it would be nice to have a try! that worked for blocks rather than just expressions.
&gt; I should not need to care whether it's a Foo or a &amp;Foo when I write code that uses foo. But does actually matter: if `Foo` is not `Copy`, then `let x: &amp;Foo = ...; let y: Foo = x;` is invalid. Of course, the compiler will tell you when this happens, but it's not possible to completely disguise the difference between `&amp;Foo` and `Foo`. Furthermore, `let mut x: &amp;Foo` and `let mut x: Foo` are very different. &gt; When you code in Rust, you don't really care where and in which order your local variables will be destroyed, but the compiler knows. When you use enums you don't care about their layout in memory, but the compiler knows. When you write functions, you don't care about how their parameter will be passed or returned (using a registry or on the stack), but the compiler knows. No. People do care about all of these (with very legitimate reasons). As an example: a compiler bug recently caused rustc to double in memory usage because it was placing destructors in the wrong place... and it's entirely possible to simulate that effect by holding onto local variables for longer than necessary. Furthermore, low-level memory layout has a big influence over speed. E.g. people do care that `Option&lt;&amp;int&gt;` is a nullable pointer, people do care that `Option&lt;u8&gt;` is only 2 bytes. In many instances, these aren't the foremost concern, but Rust is designed for applications where time and memory performance matters (e.g. web browsers), and people do think about these things.
Ah, I had missed that. That's clever. However, I can imagine it doesn't scale too well when you want to do that for more fields, you could easily end up with many parameters.
The fact that [T, ..n] is a special case in the type system. I cannot do this: struct Foo&lt;n&gt; { foo: int, bar: [int, ..n] } or this: fn foo&lt;n&gt;(t: [int, ..n]) -&gt; Vec&lt;int&gt; { ... } and I really wish I could do this too: fn foo&lt;n, m&gt;(a: [int, ..n], b: [int, ..m]) -&gt; [int, ..(2*n+m+1)] { ... }
If you want to not care about the size of your values, you should not be using Rust, or any systems language. A great deal of the complexity in the type systems is so that you can have values with known size. If you can afford not to care, then you should use a language which is somewhere else on the abstraction spectrum.
&gt; No. People do care about all of these (with very legitimate reasons). As an example: a compiler bug recently caused rustc to double in memory usage because it was placing destructors in the wrong place... and it's entirely possible to simulate that effect by holding onto local variables for longer than necessary. &gt; Furthermore, low-level memory layout has a big influence over speed. E.g. people do care that Option&lt;&amp;int&gt; is a nullable pointer, people do care that Option&lt;u8&gt; is only 2 bytes. You care about these **when you write very low-level code**. You care about this when you write a hash map implementation or a mutex implementation. If the Rust language is successful, low-level code will represent a minor percentage of its codebase. When you write high-level code (for example an app with GUI, a website or a video game), there are too many things to think about. That's why people use languages such as C# or Java, because their compiler does the work they don't want to do. Rust allows you to do the same: manage the lifetime of your objects for you if you don't want to, and manage the layout of your objects for you if you don't want to. Except that it has this nasty thing where you need to differentiate between a pointer and a value even if you don't care. Building a software is done in layers: low-level code being used by high-level code. But you should not make writing high-level code more difficult just because of low-level code. You should **have the possibility not to care** or you will never attract C# and Java programmers. 
{:?} will be enormously helpful, thank you. I retract my objection! I do see your point regarding the hash implementation - the thing is, it's very rarely an issue for me in the real world. Typically, I can rely on any type that might feasibly be put in a hash table having a real hashCode implementation. If I want to (say) put a bit of duplicate elimination code into a method that takes List&lt;$some_interface&gt;, I might feel reasonably confident using a HashSet to eliminate the dups. Of course, it's not exactly in Rust's culture to rely upon convention, and that's also something I like about the language. I think part of it's just about getting used to the language: my instinct is to want to pass things around by their trait, but if I do that and decide later I want to put them into a hash table, I have to go back and make everything that in the call tree that produces $trait for this function into &lt;$trait + Hash&gt;, which is potentially a lot of interface changes. I wouldn't be surprised if over time I changed to see this as a good thing, though :-)
I think implied is that they would like to be able to use Warrior anywhere a Human can be used, etc. That polymorphism doesn't have to be by subtyping, but close enough. So what is being asked for is inheritance and subtyping. And Rust has both already, just not the kind requested (inheritance between traits, subtyping given contravariantly by lifetime inclusion).
Thanks for the reply - it looks like {:?} pretty much solves my issue. I do understand that not all of my wishlist can possibly be accommodated and allow rust to be the language it wants to be - I was just listing things that I miss when I use the language :-)
&gt; You care about these when you write low-level code. You care about this when you write a hash map implementation or a mutex implementation. You care about it when you're writing a high performance HTML parser, you care about it when you're writing a game (every millisecond is a few more frames per second), you care about it when writing most mobile applications (minimising battery usage is important, and they have more constrained memory restrictions), you care about it when writing a production compiler (everyone likes a fast compiler, e.g. Go vs. the complaints about C++ and `rustc`'s speed). &gt; But when you write high-level code (for example an app with GUI), there are too many things to think about. That's why people use languages such as C# or Java, because their compiler manages lifetimes for you. Yes? Isn't that just proving that maybe Java/C# are better languages to use for that sort of code? Rust isn't *required* to be perfect for every usecase, it is highly unlikely that Rust will ever be as easy to use as a managed language: language design is all about tradeoffs and achieving high-performance memory safety with zero overhead isn't free. &gt; manage the lifetime of your objects for you if you don't want to No, the compiler is doing no active management. Lifetime annotations are just static declarations that allow the compiler to *check* that the programmer is doing the right thing. It is not magically making things work: the compiler will complain at you, even if there's an obvious/trivial fix (the compiler can and does work out the fixes and suggest them in many cases). &gt; You should I've given several reasons why it's not entirely obvious that we *should* have auto-deref and auto-ref (both here and now on your RFC). It might be very nice to have, but there are definitely tradeoffs. &gt; you will never attract C# and Java programmers. Never attract them for doing GUI development, maybe. But Rust can attract them for doing the sort of stuff they'd do in C/C++ (if they're not doing things where those languages are appropriate, then Rust isn't necessarily the best fit either).
If you are the owner you can do pretty much anything with it.
When would you want a main function not called main() for instance? Most languages are quite happy with having a main function called main().
It would be really useful to have something - I know rust as a whole looks to discourage inheritance (and it's fair to say that it's a much abused concept!), but sometimes you do hit a classical OO problem, and rust then feels unnecessarily clunky.
You have 1000 independent tasks running. 1 fails. Are 999 tasks in an undesirable state?
Basically what /u/Valloric wrote. I want to generalize them, not remove them. Anyway, this is not the right time and place to discuss it in depth.
If I understand your concern correctly, there's no requirement that `f(a, b)` and `a.f(b)` work exactly the same way. The latter can use type-based lookup etc. even if the former doesn't.
It would be nice to see a clear chain of what is calling what under various circumstances, from the lowest-level entry point that anything in rust has control over, through to the `main` function I actually define (or don't define, depending on which attributes are being used), along with what each layer is meant, or is expected, to do.
(I agree, just to be clear. But that's not what the question was about in this case.)
In that case failure can't be expected to work, since librarie will be making backwards incompatible changes turning it into an `abort`.
I'm pretty certain we're going to have this, just probably not before 1.0.
&gt; Even if you don't, it's a constant. There's literally no way to get this wrong. It can overflow while using it. Choosing the right integer size requires careful thought, because it needs to be large enough that it will never overflow. Haskell defaults to a big integer type and Rust can't do that.
Choosing the right integer size requires careful thought, because it needs to be large enough that it will never overflow. The only sane default would be a big integer and Rust can't get away with that. Since the literals without suffixes are generic, most literals don't need suffixes regardless of the size being used. There is no preferred / default integer type, all sizes are treated equally.
&gt; r"" b"" regex string need documentation and examples. Raw string literals are documented at http://doc.rust-lang.org/rust.html#character-and-string-literals
Weird. It feels completely natural to me. Try it for a bit, maybe it will grow on you. :-)
&gt; What's wrong with makefiles on windows? They're aggravating, theoretically unnecessary speed-bumps. I'm *really* not fond of them. . `&lt;hysterical-ranting bias='heavy' seriousness='80%'&gt;` I don't like Makefiles on general principle, but I like them even less on Windows. My experience over the years has been that pretending a Windows box is a UNIX box just causes more problems than it solves. I remember trying to compile Cairo from scratch years ago and just giving up after three days of screaming madness, installing and configuring I don't know how many different pieces of software, in some cases multiple times, all to no avail in the end. Now, every time I see a library depending on a Makefile or shell script, I die a little inside. It invariably means I have to fork the repository and screw with it to try and trick it into working. Sometimes just re-writing the build environment in something else is easier! As far as I'm concerned, requiring cygwin or msys isn't a solution, it's a *symptom*. Personally, I avoid the issue by just writing all my build scripts in Python and teach it to acquire dependencies directly. Takes a little longer, but they *actually* work cross-platform! Instead of build instructions for Windows being "just type `make`! ... after you download and configure the following three environments, ensuring they're all installed to specific hard-coded locations, then install these fifteen libraries, half of which don't build cleanly anyway and have to be manually installed, and don't forget that library A requires the mingw version of library X, but library Y requires the MSVC version, and must be installed under different names to what X's build scripts produce, then drop to a command line, start msys and navigate to the repository", it's "download Python, double-click installer, double-click `build.py`." *panting* `&lt;/hysterical-ranting&gt;`
which cargo commit is needed for this to work?
Well, the biggest difference is Docopt itself. If you like the idea of say, writing `Usage: cp [-a] &lt;src&gt; &lt;dest&gt;` and getting a parser out of that, then maybe `docopt.rs` is for you. Getting into the weeds, `docopt.rs` will write a struct definition for you from a Docopt usage string. It will let you override types. For example, if you have a program that adds two numbers, then it'd be nice to declare those arguments as integers: docopt!(Args, "Usage: add &lt;x&gt; &lt;y&gt;", arg_x: int, arg_y: int) And since `int` satisfies `serialize::Decodable`, your `arg_x` and `arg_y` fields will have type `int` and the conversion is done for you. This just about preserves a *single point of truth*. In `hammer.rs`, I believe you have to declare the struct yourself and then use what looks like a mini-DSL to specify the usage patterns. Of course, the cost of this is that writing a struct definition is pretty magical. That's the part I'm seeking feedback on. :-)
I'm entirely willing to accept the possibility that my seething hatred for cygwin/msys is borne out of a few bad experiences that wouldn't happen these days if I was starting from scratch. ... I still prefer to believe they're an unnecessary blight that can be replaced with a few simple Python scripts, though. :) &gt; With the microsoft toolchain nothing ever works first time. Yeah, that annoys me, too. Almost as much. I think ported-over UNIX tools bother me more because they tend to depend on a lot more of their native environment, which means more ways they can break when trying to use them on Windows. I had a Rust library fail to build because it used a shell script. It didn't work, even from msys, because git (being built for windows) can't preserve the execute permission on the script, so it couldn't be run directly. I had to excise the script and tell Cargo to depend on a local fork of the repository. *grinds teeth* My goal is to make sure that builds are all reproducible from just running the build command, without having to mess around with specific install locations, environment variables, etc. *Any* tool that gets in the way makes me angry. In one of my projects, I resorted to checking the entire compiler toolchain, build tools, and libraries into the repository when a compiler update broke the source code one time. Then I modified the build script to nuke the user's environment variables and re-build them all so *nothing* could mess it up. Maybe a bit extreme, but I haven't had any build issues with it since. :D
Have you considered writing a tool that generates the docopts structs into a file in your source tree? This has all the advantages of the third method and you get to see the source code of the structs. Though having to use another tool is a downside in and of itself.
The examples and explanations are good, but teaching a safer approach than this let gadget = gadget_opt.upgrade().unwrap(); println!("Gadget {} owned by {}", gadget.id, gadget.owner.name); would be even better gadget_opt.upgrade().map(|gadget| { println!("Gadget {} owned by {}", gadget.id, gadget.owner.name); }); I also didn't know `drop(foo);` was a thing.
&gt; It didn't work, even from msys, because git (being built for windows) can't preserve the execute permission on the script Ahh yeh, that kind of thing is really irritating when it happens, I've had a few bad experiences trying to use scripts with git dependencies on windows naively. Git is probably one of the worst offenders as far as having behaviour that differs between posix and non-posix platforms goes. The situation is improving as more of the shell and perl scripts get ported to native applications, but it's really unfortunate that its easy to make it depend so heavily on the posix specific shell functionality. For the record, I'm wholely against having an msys dependency on cargo. I really like the git architecture of having lots of small programs that interact over stdin/out, and I'm happy to run make from the windows command line, just as long as there isn't an actual sh/bash dependency.
The only answer to his question in the end is &gt; using tabs, not spaces, for indentation Everything else is secondary. Sure, I like snake case, but it's not in any way necessary.
I believe anything is just this, right? Or is there any other thing you can do when you have a immutable ownership, that you can not when you just have a immutable ref.
Ok, they need *extensive* documentation, examples, corner cases explanation, etc.
&gt; So? I'm quite happy guiding people to better solutions, we don't have to privilege the worst one with nice syntax just because beginners ask for it. Well, ok, just keep in mind newbies will probably come to Rust with previous programming experience. If trivial tasks like fetching `n-th` char aren't user friendly enough it might just give them a reason to not bother at all. Also as I said, the solution for `str` right now isn't even correct. For example, what if I want to turn following string "чек" ("Чек") into upper case? What are my solutions? Writing my own uppercase function? &gt; Seems strange, although maybe you hit the only difference between them that will compile Quite possible, here is the problematic part: use std::io::BufReader; fn main() { let input= b"a\r\x85t"; //let input = "a\r\x85t".as_bytes() // which works let mut reader= BufReader::new(input); for ch in reader.chars() { println!("{}", ch); } } Char `\x85` which is [next line unicode point](http://www.fileformat.info/info/unicode/char/85/index.htm) returns `Err(invalid input)`.
it should be metapackages right? All I get is "No package named quickcheck_macros found"
FWIW, you can view the result of macro invocations by running rustc with `--pretty expanded`.
You are right, my Lua is a bit rusted. D: But I hope that concept was clear. 
You do can it recursively and use traits to propagate the methods.
&gt; If trivial tasks like fetching n-th char aren't user friendly enough it might just give them a reason to not bother at all. It might be trivial, but it doesn't make it a sane thing to do. We can try to encourage good unicode hygiene. It might turn out in future that this high moral ground is untenable, but for now, IMO, we should be encouraging the good behaviour. It's easy to add things, but hard/impossible to remove them once a library is stable. &gt; Also as I said, the solution for str right now isn't even correct. For example, what if I want to turn following string "чек" ("Чек") into upper case? What are my solutions? Writing my own uppercase function? Yeah, like the rest of the libraries, (major) parts of the string APIs aren't complete and haven't been planned. It is possible now using the codepoint iterator foo.chars().map(|c| c.to_uppercase()).collect::&lt;String&gt;() but it's not great. &gt; Char \x85 which is next line unicode poin returns Err(invalid input)! Yep, that is the difference: println!("b {} as_bytes {}", b"\x85", "\x85".as_bytes()) // =&gt; b [133] as_bytes [194, 133] (The error is because an isolated `\x85` byte is invalid UTF-8, while the UTF-8 encoded U+0085 code point is fine.)
Your first example is a subtle trick: it's not redefining mutability of `foo`, it's defining a whole new variable `foo` which has it's own mutability. That is, it's like writing let foo_1 = 42; let mut foo_2 = foo_1; and using `foo_2` after the second `let`.
it properly rebuilt after this resulting in some strange linker errors. Decided to clean target/ and .cargo and now build is fine but test fails with: error: can't find crate for `quickcheck_macros` #[phase(plugin)] extern crate quickcheck_macros; ls target/deps/ libquickcheck_macros.so libquickcheck.rlib
Btw, I'm pushing for a chain of RFCS that would lift the ordering restrictions between `use`, `extern crate` and declarations: https://github.com/rust-lang/rfcs/pull/116
Now it says that both libs are conflicting: src/tftp/packet.rs:480:5: 480:29 error: multiple matching crates for `quickcheck` src/tftp/packet.rs:480 extern crate quickcheck; ^~~~~~~~~~~~~~~~~~~~~~~~ note: candidates: note: path: /home/arjan/code/tftp-rs/target/deps/libquickcheck_macros.so note: crate name: quickcheck note: path: /home/arjan/code/tftp-rs/target/deps/libquickcheck.rlib note: crate name: quickcheck src/tftp/packet.rs:480:5: 480:29 error: can't find crate for `quickcheck` src/tftp/packet.rs:480 extern crate quickcheck;
thanks for clarifying.
Was the error unrecoverable? If so, then yes. My function is a good example of that. Imagine that I use it to change shared state, but the closure fails. Since it acts by moving the values into the closure, now the shared resource is a dangling pointer. If I want the error to be recovered, I should make that explicit in the type system. In this case, the function would never fail, because the type system wouldn't allow it. If it calls a computation with a recoverable error, it must address that. If it does fail unrecoverably, then it makes no sense to go on. 
Aha, makes sense; thanks. (Just putting your first sentence there into the docs would make it all clear. :) )
Ok. But, again, why not model that with Result&lt;T, E&gt; always? 
Rust doesn't manage lifetimes -- it's only keeping track of them in an open accounting system that helps you manage the objects and design the program.
A block is an expression though, so can you clarify?
How? Tasks are isolated and you can't recover from task failure. And what are you moving into closure? T? You only have &amp;mut reference so you can't move?
Propagating all the error to the root of the application just to fail? I love explicit error handling but that is not a solution.
You don't need `Copy`, you can either wait for that code to be valid with moves, or you can use destructuring.
But that's my point. The function in question is useful because it allows the value to be used in the computation that replaces it. That should always happen, there shouldn't be a situation where the value is moved and isn't replaced. What makes the operation unsafe is only the fact that Rust assumes an unrecoverable failure doesn't affect all tasks. Don't get me wrong, I can totally live with it. I could make a function like this instead: replace_with&lt;T, U&gt;(&amp;mut T, U, |&amp;mut T, U|) And it would probably work, too (though having the ownership is probably useful for some computations). I just think that the kind of failure that task unwinding covers would be better covered by making the failures explicit in the type system. For instance, I could have replace_with&lt;T, U, Out&gt;(&amp;mut T, U, |T, U| -&gt; (T, Out)) -&gt; Out So Out could be a Result indicating a failure that would propagate upwards until it aborts the task with an error that can be catch in other tasks. Even the proc that spawns a task would return such a Result. 
The function would be a safe abstraction, of course. 
Why not? 
I'll do that. Thanks for taking the time for the review!
I think we'll have to just consider that part of the library API. There are plenty of places where we have to be careful about stabilizing an API that has subpar perf; this is just one of them. We can also get a fair bit of mileage with a blanket statement that the comparison functions inside `Eq`/`Ord`/`PartialOrd`/`PartialEq` must not fail, lest the app abort (same with the `sort_by` comparator). IMHO, we should start making notes of all the places where swap chains are hurting performance and take that into account during library stabilization.
We didn't want to use `T[N]` because it interacts badly with `&amp;` going before the type: is `&amp;T[N]` a reference to `T[N]` or is it N copies of `&amp;T`? We could have used `[10]String` like Go, but everyone felt that looked weird since it follows neither initialization nor use. For example, you can initialize an `[int, ..10]` with `[1i, ..10]`.
When you are debugging something, commenting lines and such, it's really annoying to go and put the correct indentation if you are just going to modify that code right away. Whitespace problems are infrequent, I don't think this is an issue at all.
I didn't, but I will! I made a PR to rust-http to solve the particular problem I was having, and I'll try floor again later today. Thanks for the reply!
I don't understand what you meant when you talked about "shaping the input space", or what you meant about using the type system as a graph. Do I need to watch the Idris video to understand what you are talking about?
After watching the video it did make more sense. Some parts of it went way over my head though
Cool. I'm not sure what the differences are, but Cargo is built on top of hammer; might be a nice way to get some feedback, use this instead and see what the diff is?
Not completely related, but there is a Rust Tip4Commit page in http://tip4commit.com/projects/149
http://steve.klabnik.usesthis.com/ I'm now on Ubuntu and XMonad instead of #! and OpenBox, though. Everything else is the same.
Plug-in is very intresting. For me, is not elegant to initalize the array with defualu value that is a struct type. R.
I build first the vector only for obtain later an array of fixed length, that is a very natural type for the function return type (the answer of my problem). Thanks for the code with low level memory access. Rust can be truly low-level. R.
&gt; I also didn't know drop(foo); was a thing. It's just manually calling the destructor, since `Drop` is a trait, it adds a method, `drop`. Currently, however, manually calling `drop` does not release any borrows.
gofmt is used with enough vigour that all Go code is formatted like that. This is a practical enough solution.
Do such financial incentives actually work? I imagine once you involve money people will compare contributing with their day-jobs and conclude that it isn't worth it, while they might have contributed for other reasons (e.g. fun, sense of achievement, etc) had money not been involved.
Any chance of switching Response::send to use the BytesContainer trait? That would allow the use of encodings that aren't utf8, as well as String.
I like dragons. Really gets the point across. `dragons { crazy_things(); }` 
Awesome! Thanks for this, learned a few new tricks (`self.implementation`, and that you can define your own `type`). Will be using this in my project!
sounds reasonable. Care to send a PR?
Arch Linux, gvim, tmux, Gnome
I don't see how money affects that specially. You could easily reverse the argument. If your neighbor asked you to mow his lawn for him, would you be more inclined to do it out of the kindness of your heart, or for $20? Your day job pays much better so you could just pass on the offer altogether, but his lawn hasn't been mown in ages and is getting to be quite an eyesore. I only see it as another reason to contribute, in addition to the ones that you listed. Edit: words are hard because fatigue
I'm pretty new to rust but I use emacs with evil - I find rust support to be good between rust-mode, flycheck, and racer. I use xubuntu 14.04.
I've had nothing but positive experiences with Cygwin and MinGW over the past 2 years of daily use, especially in the year or so since the release of a 64-bit version. Complaints are louder than praise, and all that... I also put in a bunch of time earlier this year porting a different LLVM-based language to build using the Microsoft compiler (for fun and the challenge of it). Reward vs effort is really not there on an open-source cross-platform project though - a Linux or OSX dev will at least recognize the process (if not the peculiarities, which are much less frequent these days than they used to be) of using Cygwin and MinGW, and it'll be the same process as cross-compiling.
I found VMWare Player's Unity mode gives me the best of both worlds. Hosting Xubuntu in Windows 8.1 and loving it.
I believe there are some plans to make many uses of both `as_slice` and `to_string` unnecessary once DST lands, though sadly I'm not familiar with the specifics. I agree that this is painful.
I used to use virtual machines but the startup time added unnecessary overhead to getting my work started. My day job is primarily web dev and some data entry so I don't need a full separate dev environment.
Yeah, I made a commit and got $0.00001 in bitcoins; I had a great laugh about that!
`here_be_dragons { ... }`
The fact that `#[hide_documentation]` exists is proof that there are grievous visibility issues in the module system.
Yep.
Self-hosted too early, hard to bootstrap. Relying on downloaded binaries to build makes packaging by distributions harder, and impossible to get started on a platform that binaries aren't available for or don't work on. While it technically might be a better choice for writing some types of libraries that I work with, there are too many alternatives that are much easier to use and have a head start in prerequisite tooling for my application area. Rust feels like a good-parts-of combination of C++ and Haskell, what I wanted was a good-parts-of combination of Python and Fortran. Not Rust's target, but optimistic folks asking "Why not Rust for everything" don't always seem to realize this is one of the answers.
at home: win7 + notepad++ for rust things (i'm so sorry) to actually do useful stuff: mosh to a DigitalOcean server, tmux, then vim with an ancient version of vim-rust that I need to update
Are you close to the datacenter? I've seen reports from a few people that work that way, but the latency is just toxic to my workflow. It's probably a bit different when you aren't an hemisphere away from the server though :p
I don't see how that's better than the current `impl`/`trait` system. Furthermore, automatically bringing all names in a module into scope has all the problems of globs writ large.
What would you like instead?
I don't suppose you consider C++'s Argument Dependent Lookup a good idea ? That is, when consider a function call, check for a match in the same module as *any* of its arguments (not special-casing the first one).
Either Crate level visibility or folder-level visibility. Or you could have a visibility level where all modules on the same height in the crate module tree can see it. A | \ B C | D If B has a function with "sibiling" visibility, then C could see it, but D cant. In order to get around visibility concerns, I've had to `cat` source files together because they were getting too large and unrelated, but needed to share private methods.
I think I actually have $0.01 from that.
Really? Wow, I hadn't even thought of that given that your website, Github and Twitter all use Chris Morgan. Wow.....
Interesting. What kind of overhead would be introduced to ensure that subtypes are enforced? Would it be something like bounds checks applied to the subtype value whenever it is potentially modified? 
What you really want is to lift the whole value level to the type level so that any value can be passed at compile time, but that is an even bigger change! Most languages don't support integers passed in generics, so I don't think it's *that* big of a deal. You can always pass them as value arguments.
Some kind of delimited continuations could be used to implement this in a more general way (it would also allow for full coroutines and other fun things). That notation might work pretty well as a way for closures to auto-capture them, although it seems kind of magical at first in that context.
FWIW, I've started working on the default view in the [grid-view branch](https://github.com/ogham/exa/tree/grid-view). It now copies the behaviour from ls.
Arch, ViM &amp; Atom
In case anyone was interested, seems like [this works](http://is.gd/dGpSwC).
So how much money are we talking? Because if my neighbour offers $2 instead I will tell him to go fuck himself :-P Research shows that you can discourage behavior by rewarding it. 
I suggest that we start calling it something like UMCS instead of UFCS, in order to better convey that our system is dissimilar to D's (which is to say, the exact opposite).
That's just a black hole for donations. It chops them up into tiny little pieces that are unlikely to ever be withdrawn.
In this case you can use `.unwrap()` directly (without `.ok()`), which will preserve the error message on failure.
As I understand it Ada uses both dynamic and static predicates, corresponding to runtime and compile time checks, where appropriate. Something like a sub-range of an enum could probably be statically checked, while a sub range of an integer, or a special string format, etc would be runtime checks.
The internet is such a small place sometimes. :) I was always a big fan of yours, and I can't wait to see what you create with Rust if you end up sticking around.
The problem is that you are trying to collect into a `IoResult`: let stuff: IoResult&lt;String&gt; = reader.chars().map(|x| x.unwrap()).collect(); You should collect the characters directly into a `String`: let stuff: String = reader.chars().map(|x| x.unwrap()).collect();
I have been able to reduce it to this (Playpen: http://is.gd/ZWDFFW), but still have no idea on why this happens: trait Aspect { fn one() -&gt; bool { true } } fn main() { let aspect = Aspect::one(); }
Not sure about 'inherent', but the syntax for multiple trait bounds is irritating: impl&lt;K:Hash+Eq,V&gt; HashMap&lt;K, V&gt;{ ... } ^~~~~~~ 1. Hash+Eq is not itself a trait: I cannot declare a variable of type Hash+Eq. 2. The symbol '+' usually denotes 'sum' and not 'intersection'. (Of course, that is not how it is supposed to be read, but it would be the way it is supposed to be read in usual type theoretical notation. IMHO '+' is a poor choice of symbol here.)
Task failure does exactly the same thing. Consider the semantics of task unwinding in the presence of failures. The only difference is that, with `Result&lt;T, E&gt;`, only functions that deal with possible errors need to guard against them, while, with task unwinding, everyone has to pay a price. I can see a legitimate concern regarding the syntactic overhead of explicitly passing `Result&lt;T, E&gt;`s all over the place, but this can be adequately addressed by providing support for a `Result&lt;_0, E&gt;`monad. (Where `_0` is a type-level de Bruijn index.)
The missing type here is the that `Aspect` is being implemented for. That is, it doesn't know which implementation you want. (And you don't have any.) The canonical workaround here: trait Aspect { fn one&lt;T: 'static&gt;(Option&lt;Self&gt;) -&gt; ... { ... } } ... Aspect::one::&lt;Transform&gt;(None::&lt;TypeThatImplementsAspect&gt;) 
Yeah, I've wanted crate-level visibility too. I believe there are a couple of good proposals for it…
I have around 30ms ping, so it's fine. Also, note that I use mosh instead of ssh, which does an excellent job of predicting.
&gt; I also dislike how Windows support has essentially been consistently abysmal since the beginning and there seems to be very little progress made on this front. One of the things that I especially like about Rust is that it's actively developed for `*nix` with `*nix` culture in mind, not Windows. The thing that I disliked most about D was it's Windows-ness. You could feel it everywhere: cold touch of propriaty software, zip-bombs, crude tools, etc. It started to get better though at some point (around the time when D moved to github, I believe). But I'm an open Windows hater, and this is my subjective opinion obviously. 
I love this thread, I love open criticism (feels like a fresh air for ideas). Rust devs, you're awesome and Rust is awesome - I hope you won't mind a little bit of negative feedback. :)
Archlinux, vim, [my homegrown hybrid floating/tiling WM](https://github.com/BurntSushi/wingo) and three monitors.
My Setup: http://i.imgur.com/1TepF5N.jpg Editing environment: Tmux + Vim + lots of vim plugins. 
[Done](https://github.com/BurntSushi/docopt.rs#viewing-the-generated-struct)!
Ok thanks m8.
&amp; would be more accurate than +, I think.
I think I fixed this for now. I had to add `crate_type = ["dylib"]` to docopt's `Cargo.toml`. You shouldn't have to change anything on your end. I'm not totally up on Cargo yet, but I had to delete the cache in `~/.cargo` to get Cargo to pull in the latest changes from upstream. (At some point I need to split `docopt.rs` into two separate packages so that you aren't forced into using a shared lib.)
This is working for me: [andrew@Liger cartest] tree -n . ├── Cargo.toml ├── src │ └── cartest.rs └── target ├── cartest ├── deps │ └── libdocopt.so └── tests 4 directories, 4 files [andrew@Liger cartest] cat src/cartest.rs #![feature(phase)] extern crate serialize; #[phase(plugin, link)] extern crate docopt; docopt!(Args, "Usage: cartest &lt;x&gt; &lt;y&gt;") fn main() { let args = Args::parse(); println!("{}", args); } [andrew@Liger cartest] cat Cargo.toml [package] name = "cartest" version = "0.1.0" authors = ["jamslam@gmail.com"] [[bin]] name = "cartest" [dependencies.docopt] git = "https://github.com/BurntSushi/docopt.rs" 
The way that everything is abbreviated. I can understand abbreviating pointer types, but there is no excuse for shortening "string" to "str", "vector" to "vec", etc... I understand that it's tiresome to write those things while there is no IDE support, but this is incredibly short sighted. New code should be easy to read, and this sets a low standard for 3rd party libraries.
It's not a language issue, but the biggest bugbear for me is I/O. 1) A task can't select between channel communication and I/O. The advice is to only select between channels or multiplex I/O objects, not both. 2) But... there's no way for a task to multiplex I/O objects! 3) The I/O abstractions do not expose the platform's I/O handles / file descriptors, so you can't write your own I/O multiplexing API 4) There is a fixed number of I/O abstractions that cannot be extended by the user (which would be a problem if there was a standard API for multiplexing I/O, but there's not so currently not too much of a problem). 5) Signals are not supported at all in the native runtime but you don't get a compile or link error if you try to use them -- the program crashes at runtime! 6) The try! macro and methods on the Result type are rather awkward. I'd love something like Haskell's do notation. 7) You cannot use try! in main, so I/O in small programs is awkward. I end up either calling unwrap() on every I/O action, which I don't think reads very clearly, or moving the bulk of my code into an extra function that returns an IoResult&lt;()&gt;. I'd like a try_or_fail! macro for simple programs.
Ubuntu (planning to switch to something, temporary), Terminator, ssh+screen+irssi, mocp for music, Sublime or vim depending on my mood. I sometimes pop over to my department and take residence in the computer room, in which case I have INFINITE MONITORS. Okay, two, or if I can borrow a splitter, three. 
Arch Linux, i3, atom, terminator, firefox for viewing rustdocs. Laptop + 1080p external monitor. No photos, but a screenshot: http://i.imgur.com/6hXPGGQ.png
I used to, but then it stopped working because something was out of date and I haven't bothered trying again since.
(I contribute to Servo, not so much Rust, but the same principle applies) I don't know, I personally would probably start thinking "I can earn money for this, why am I doing it for free?". And if it's not paying "enough" for the task, that might make me not try for the bounty either. It's a whole mix of emotions that I'd rather not associate with open source. There was one time when a particular online subcommunity approached me and offered to pay for something I usually have done for free within that community. I accepted it, partially because I didn't have the time to do it for free (also I would have procrastinated). But I wasn't really happy doing that (even though I made a bundle). That being said, I believe it could be used for large "week long project" type bugs that you want fixed but have higher priorities for employee time. (Technically I'm being paid for my work on Servo (GSoC), but that's different since it's a one-time thing.)
&gt; But that's my point I think you misinterpreted. There's no way for a safe shared resource to be deallocable by one thread. You can't move out of an `Arc&lt;T&gt;` directly, as concurrent accesses would then be left accessing moved-out data i.e. its invalid. Similarly, you can't get a `&amp;mut T` pointing directly to the interior of an `Arc&lt;T&gt;` because, e.g., multiple threads would be able to do this at the same time, creating aliasing `&amp;mut` pointers. Hence, the only way to move out or get a mutable reference to the interior of a shared resource is via a wrapper type like `Mutex` that guarantees unique access. The *only* interaction with failure is the wrapper type has to poison itself when the task fails, so that no other tasks can get access to it. tl;dr: the basic shared resource type `Arc` doesn't need to handle failure. &gt; replace_with&lt;T, U&gt;(&amp;mut T, U, |&amp;mut T, U|) This entirely pointless: `replace_with(x, y, |a, b| ...) is just `{ let a = x; let b = y; ... }` without the function call. The whole reason to have a function like `replace_with` is to get ownership.
&gt; I'm not totally up on Cargo yet, but I had to delete the cache in ~/.cargo to get Cargo to pull in the latest changes from upstream. I believe `cargo build -u` will update the dependencies. (Theoretically it should be done by incrementing version numbers, I guess.)
Hm. Yes, I'm aware of RWLock and RWMutex, I just thought that was implicit in the discussion. You did bring a point that `Arc&lt;RWMutex&lt;T&gt;&gt;` will give me the ownership because it is a shared ownership already. I'll think about that. And no, it's not pointless. `replace&lt;T&gt;(&amp;mut T, T) -&gt; T` exists. `replace_with` would exist for a similar reason, but it would be more powerful than `replace` in some contexts. E.g., having an efficient function that allows you to replace the contents of a value in a `MutableMap&lt;K, V&gt;`. Right now, if you want to get the ownership for the value, you must `pop(K) -&gt; V` it and then you `insert(K, V)` it again. That's not efficient.
What's a non-pointless implementation of `replace_with&lt;T, U&gt;(&amp;mut T, U, |&amp;mut T, U|)`? (Note which `replace_with` I am talking about.)
You **can't** use a procedural macro via a static lib. A procedural macro has a runtime dependency on `libsyntax` and `librustc` (I think). The benefit from splitting the library up is that you could use the non-macro portion in a static lib.
Btw, your `Show` implementation can be replaced by using `#[deriving]`: #[deriving(Show)] enum FuzzyBool { False, True, Both, Neither } Also, your nested matches could become a match on a tuple: fn bitand(&amp;self, rhs: &amp;FuzzyBool) -&gt; FuzzyBool { match (*self, *rhs) { (True, y) =&gt; y, (Both, True) | (Both, Both) =&gt; Both, (Neither, True) | (Neither, Neither) =&gt; Neither, _ =&gt; False } }
&gt; So the freestanding functions will be reinstated after the cleanup Probably/hopefully.
Nice. Thanks! I forgot about tuple matching and `#[deriving ]` definitely cleans things up a bit [Updated source](http://is.gd/UJHZel)
(You may wish to fix your link... you can post an `is.gd` link from the `Share` button, but it will require moderator attention, unfortunately.)
Check this out: http://learnyouahaskell.com/a-fistful-of-monads It gets to Maybe, Haskell's version of Option. This is what would be possible if we had higher kinded types, and the reason people really want them.
I know haskell and haskell has exceptions. And I am interested in explicit error handling examples that are more complicated that these toy programs.
It's worth noting that `drop` is nothing special for calling the destructor, it's literally defined as `fn drop&lt;T&gt;(_dummy: T) {}`, that is, it takes something by-value and immediately lets it go out of scope (calling the destructor).
This is my understanding now, and my fault before. unsafe { } does not mean developer is doing something wrong. It is to make places which need to bend the rules more distinct.
What problems are you referring to? Note that D's system does not introduce conflicts with names in other modules or the local module. If ambiguity exists, the compiler complains. Further, it appears that you are very casually dismissing how D handles name imports without a complete understanding of how it works. D's language designers (Walter Bright and Andrei Alexandrescu) aren't fools, and neither is the D language community filled with people who can't grasp pros and cons of language features. AFAIK this feature has been used in production code without issues or complaints for longer than Rust has existed. If you find yourself in a situation where respected language designers of different languages choose an approach that strikes you as greatly flawed, I suggest it might be a good idea to explore how their approach truly works before discarding the ideas out of hand. You (and I and everyone else) are unlikely to know everything, and what initially strikes you as wrong might just end up being a good idea upon closer inspection. To reiterate, you are discarding ideas that have been: 1. Working like clockwork in other languages. 2. Designed by smart, respected people. 3. Evaluated and banged upon by many. 4. Used by thousands for literally years. and doing all of it with a knee-jerk "oh that can't possibly work well" attitude. Honestly, it comes across as conceited; I doubt that was your intent. Patrick, you're better than that.
I thought no one would ever ask… It’s Christopher! 😆 (OK, OK, so I do commonly go by the name Chris in real life.)
&gt; You (and I and everyone else) are unlikely to know everything, and what initially strikes you as wrong might just end up being a good idea upon closer inspection. I still think that importing all names in a module by default is an idea with more drawbacks than advantages. I'm not insulting anybody. I know a lot of people happily use D, and I think Walter Bright and Andrei are super smart. I have tons of respect for Brendan Eich, for example, and there are plenty of ideas I don't like in JavaScript. I have respect for Guido van Rossum, and I think local-variables-by-default are a flawed idea, despite the fact that everyone in Python loves them. It goes both ways too; I'm not offended by Walter casually dismissing AST macros, or Ken Thompson casually dismissing not having null pointers as "should we ban the number zero too?". Ultimately languages just have to be opinionated sometimes, and I like the fact that Rust comes down on the side of not having glob import.
There's plenty of back and forth research about whether incentives are helpful or harmful; the interesting one I've heard of is about how once incentives exist, the quality of the output is compromised in exchange for productivity. It's easy to understand; When you earn $ for fixing a bug, do you fix one bug completely for $ or 50 bugs mostly for $$$$. Once you place a monetary (or magical karma/internet points) value on a task, you allow the 'gain' for completely the task to be quantified, which results in numerical optimization for most-points-for-time-spent (where points is karma, money, etc) by people. I think that's a quite tangible downside to associating any kind of numerical gain to tasks/bugs/goals, in general; with the caveat, obviously, that it *does* improve productivity if that's all you're looking for. (see http://knowledge.wharton.upenn.edu/article/the-problem-with-financial-incentives-and-what-to-do-about-it/ for some reading on this) Personally I think the gittip / patreon model of crowd sponsoring productive community members to work on whatever they want is much more plausible and sustainable. 
Sorry, wrong subreddit. You want /r/playrust 
This is a direct response to Rust's pre-commit testing, which we use to great effect, but not without difficulty.
You make some good points there. I appreciate the citation as well. Patreon and gittip are both attractive models, but I would like to see something more like the cryptocoin tip bots here on reddit, where the tipper is tipping for a specific comment, and not just donating to the user. It's a subjective reward, like gilding, where the emphasis is placed on the contribution instead of simply the completion of the task. It'd be cool if gittip/GitHub supported tipping for a specific commit so people could show their appreciation for the contribution directly. 
Speculative merging can be improved upon with human wisdom guiding it; I filed https://github.com/graydon/bors/issues/23 for my idea of how that can be reasonably achieved.
Vim on a Linux Mint VM.
Can you tell me more about Haskell's exceptions? I wasn't aware of this.
I'm on mobile, and will check more out later, but four spaces, not tabs. I like how the match arms in the RPN make a little wave. I'd probably even them up, and it would look way less cool.
We'll agree to disagree on the imports, but I must say I like the rest of your response a lot.
&gt; I like how the match arms in the RPN make a little wave. ~~Matching the operators? You mean on the right side? Yeah, I sorted them so that they're near relevant operators to make it easier to sift through.~~ I get it. Yeah, that doesn't bother me too much but I can see how it might. That's more of a specific code style thing, though. It would look better if they were lined up but it almost seems like the waviness helps to organize them a little bit. Updating the Gist doesn't seem to set the new indent mode. I'm using the official Vim plugin so the indent should be right on the original files.
It's barely worth a PR. Just add a generic parameter for S: BytesContainer, change &amp;str to S, and change the as_bytes() call in the body of send to as_bytes_container(). I could always do a PR if you want, though.
I've tried both systems and can vouch that you *always* want to do the no-rocket-science method whenever you can get away with it. Speculative merging sounds interesting but assumes a healthy portion (maybe 90%) of pull requests are sound for it to pay off. It probably relies on developers running at least the fast test suites locally before they submit, which admittedly isn't a bad idea. EDIT: Actually I'm an idiot. Of course what you do is you parallelise the individual pull requests by throwing hardware at it, then you speculatively merge N pull requests at a time. Since they are already tested individually you now only have to deal with the possibility of silent merge failures (merge conflicts would be caught as you're building the speculative merge), so N can potentially be very large. This would work well at scale too, since (presumably) larger code base will have less chance of the pull requests interacting.
Additionally, we use travis-ci as the first line of defense against failing PRs. If it doesn't pass travis, it doesn't get an r+ (assuming that travis isn't broken, which happens)
- Two macbook pro retina. One topped out 15", and another baseline 13". - A samsung 27" 1080p monitor - Magic mouse - Giant speakers - Apple keyboard - tmux, vim, chrome, iterm2 (At work I have another giant apple monitor and stuff) http://imgur.com/nt1SDbJ
`"i".to_uppercase()` - should this return I or İ? It depends on which language you're writing in. In Turkish, it would be the second one.
Then there is a reason why `libsyntax` and `librustc` can't be linked statically too?
A `--release` command line option [has just been added to cargo](https://github.com/rust-lang/cargo/pull/140). However it may not be available in the nightly build yet.
There is MaybeOwnedVector in graphviz crate (But the plan is to move it to std baased on commit comments)
Stylistically, where you have `|a, b|{a + b}` you should write `|a, b| a + b`. No need for the braces.
I did not know that was possible. I would prefer it that way. Single expression, right?
Does this allow me to GET an URL similar to ../../../../../../etc/passwd?
The plugin is loaded dynamically into the rustc process. AIUI, this only works for dynamic libraries.
I tried following it but the examples are full of obsolete code. I just went with the official tutorial in the end.
Ah yes, I've seen that before but didn't twig that this was the same situation. Thanks.
my motivation for suggesting relative modules was that you'd be able to build any individual file as the root - regardless of if it was the crate root or not, any file would have the information to bring in its' own dependancies. Would that allow parallelizing tests at a finer grain ? .. and reduce the set of what needs to be rebuilt to verify a change?
I don't know the details, but I think it has to do with the implementation pulling in code dynamically. You'd be better off asking one of the core devs.
Yes, don't set it in stone yet. A lot of the above complaints are valid and should be addressed.
Scala has algebraic datatypes and pattern matching, and it doesn’t enforce case either.
It is not currently possible to parameterise types by mutability. For example, I'm currently working on some networking stuff, where I want to be able to represent both mutable and immutable packets. For mutable packets it should be possible to set fields, and otherwise just retrieve them. pub struct EthernetHeader&lt;'p&gt; { packet: &amp;'p [u8], offset: uint } pub struct MutableEthernetHeader&lt;'p&gt; { packet: &amp;'p mut [u8], offset: uint } To avoid writing the get methods twice I then make a trait with all getters implemented, which each struct then implements. It would be great to instead write something like: pub struct EthernetHeader&lt;'p, "m&gt; { packet: &amp;'p "m [u8], offset: uint } Then when implementing, &amp;mut self methods are only available when "m is mutable, but &amp;self methods are always available.
this almost looks like a workaround for default params/keyword args, but i realise you can do more by accumulating part of a state and reusing it with variations.. thats neat is there any scope to package up this pattern in macros
&gt; "wart" "nondeterministic" We're assuming different meanings for the words. You're disputing things I didn't mean to imply. By "nondeterministic" I mean that the name resolver "branches": it checks if a thing exists, and if it does then the program means one thing, and if it doesn't then the program means a different thing. Whereas under deterministic name resolution, either the thing exists and the program means a thing, or it doesn't and the program is ill-formed. Deterministic/nondeterministic are the best words I could think of to capture this difference, but if you know of better ones... (incoherent? nonconfluent?). &gt; There is no problem here in practice This is exactly the kind of thing I was thinking of which bothers me. It works in practice, so there's no interest in figuring out how to guarantee correctness. We only seem to get the point of "huh, maybe we should do it the more principled way" after we've been bitten by the drawbacks of the less principled approach in practice. Whereas that's what I would start with. Let me copy something I wrote [on GitHub][1]: &gt; I really, really don't like saying to people, "We've left some landmines in the language... but don't worry! You can reduce your risk of stepping on them if you use *this lint* and *that convention*.", when we have it within our power to not plant any landmines. The point is that guarantees are valuable. It means not having to do due diligence, or ever think about "well, what if...". To the question, "What are the chances of that ever happening?", I want to be able to answer, "0%". ----- &gt; and the cures (significant case [...]) are worse than the disease IMO. Why? &gt; significant case—which doesn't work with statics anyway I haven't heard of this - how come? [1]: https://github.com/rust-lang/rfcs/pull/154#issuecomment-48129967
The RPN calculator is using a `DList` as a stack, but a `Vec` with `push` and `pop` would be more efficient (better memory locality, fewer allocations). The `let input = stdin().read_line(); if input.is_ok() { ... ` would be better written as match stdin().read_line() { Ok(input) =&gt; ... Err(e) =&gt; { /* handle error */ } } and that whole `loop` can actually be written as for raw_input in stdin().lines() { match raw_input { Ok(input) =&gt; { /* ... */ } Err(e) =&gt; { /* ... */ } } } Tiny nit: the `&amp;` shouldn't be necessary in `println!("{}", &amp;stack);`, since the `println!` macro does the borrowing internally. For the prime calculator, I would recommend using a normal struct: `struct Primes { primes: BitvSet }` to avoid the repeated `let &amp;Primes(ref primes) = self;`: just use `self.primes` directly instead. `collect_factors`, `test_prime` and `gen_primes` are all iterating over far more than they need to: they have to check each and every element of the Bitv, even if the comparison with `test` is going to fail for all remaining elements. Using [`take_while`](http://doc.rust-lang.org/master/std/iter/trait.Iterator.html#tymethod.take_while) will give you a shorter iterator that cuts out as soon as the condition fails (and since the numbers are increasing, checking `a &lt; test` is perfect). Furthermore, as soon as you see a single failure of the `%` condition in `test_prime` you know that it is not prime, and can stop iterating. The `all` method shortcircuits in this manner. Combining the two ideas: self.primes.iter().take_while(|a| a &lt; test).all(|a| test % a != 0) As a general point, it would be convenient if `collect_factors` was to return an `Iterator` itself, but doing this in a nice way requires closures with by-value captures and "abstract" return types, that is, it might look something like the following in future: fn factors(&amp;self, test: uint) -&gt; impl Iterator&lt;uint&gt; { self.iter().take_while(|a| a &lt;= test).filter(|a| test % a == 0) } (You can do this now by creating a whole new struct and implement `Iterator` on it manually too.) &gt; I had trouble getting an intermediate limit (like test.sqrt()) to work on small numbers. You might need to take the [ceiling](http://doc.rust-lang.org/master/std/num/trait.Float.html#tymethod.ceil): `test.sqrt().ceil() as uint`. &gt; One thing that stands out to me is my pervasive use of mut. I know functional languages prefer immutable state but it does tend to add complexity in a lot of use cases. I do use immutable locals whenever possible. Rust isn't trying to be a functional language: sometimes mutable variables are just the right thing to use.
That’s still not a *general* solution to the problem of maybe-owned types.
I'm not a fan of docopt's design as it does not go far enough. It also does not allow you to easily programmatically extend on it and does not work at all with localization. I do however like the idea of going through a syntax extension.
What are the problems of glob imports? That discussion was before my time, and since then I've seen several references to "the problems of globs", but not an explanation of them.
A UTF-8 sequence doesn't have a fixed length.
The problem is that there's no such thing semantically as a "mutability modifier". `&amp;` and `&amp;mut` are two different types which behave quite differently.
That was just a suggestion based on your Token implementation not for a general implementation.
- [`random_table`](https://github.com/jayanderson/turing/blob/d49b29302d97b580c300f83637cb29b568aaff14/src/turing.rs#L75-L80) could be slightly more efficient by precomputing a [`Range`](http://doc.rust-lang.org/master/std/rand/distributions/struct.Range.html) value, rather than calling `.gen_range` repeatedly (each of which computes a `Range` internally). `Range` is designed to give perfectly uniform random numbers and so the initialisation isn't trivial: it does a `%` etc. internally. - there's no reason to [take a `&amp;Vec&lt;T&gt;`](https://github.com/jayanderson/turing/blob/d49b29302d97b580c300f83637cb29b568aaff14/src/turing.rs#L117): taking `&amp;[T]` is strictly more flexible (that is, it can do all the same functionality, but a larger variety of types can be passed to it). - [the printing loop](https://github.com/jayanderson/turing/blob/d49b29302d97b580c300f83637cb29b568aaff14/src/turing.rs#L150) could use more iterators, e.g. zipping with [`count(0, 3)`](http://doc.rust-lang.org/master/std/iter/fn.count.html) instead of the manual `i += 3`, or even zipping with [`self.image.mut_chunks(3)`](http://doc.rust-lang.org/master/std/slice/trait.MutableVector.html#tymethod.mut_chunks) (I'd guess the latter may actually be slower anyway). - The [colours can be extracted](https://github.com/jayanderson/turing/blob/d49b29302d97b580c300f83637cb29b568aaff14/src/turing.rs#L145) in one go with `let [r, g, b] = *pallete.get(val as uint);` (IIRC) - [this `vec!`](https://github.com/jayanderson/turing/blob/d49b29302d97b580c300f83637cb29b568aaff14/src/turing.rs#L175-L186) is entirely static, i.e. it could be written like static PALETTE: &amp;'static [Color] = [BLACK, RED, ...]; and returned from `load_palette` as `-&gt; &amp;'static [Color]`. &gt; Is the syntax for setting elements of a mutable Vec being cleaned up?: *self.image.get_mut(i+2u) = color[0];. Or is there a better way to do this? There isn't a better way yet, but yes, it will be cleaned up: a large part of the fix landed just in the last day in [#15394](https://github.com/rust-lang/rust/pull/15394) (improving our overloaded `[]` operators).
this was the suggestion - https://github.com/rust-lang/rfcs/pull/150 - allow projects to be described entirely by relative imports; Then any subtree could be treated as a crate.. or you could compile the whole thing as one unit.. or you could test any file in isolation. But it might get a bit crazy with a lot of `use mod super::super::super::foo::bar::baz` for common project wide stuff.
 if { let &amp;Primes(ref primes) = self; primes.contains(&amp;test) } { return true } This made me stop and stare for a moment out of confusion. I think its intent is more clear like this: let &amp;Primes(ref primes) = self; if primes.contains(&amp;test) { return true; } The problem to me is using a block for the condition expression followed immediately by a (required) consequent block. 
I _just_ deployed 0.11 last night. I got a few bug reports, though. Fixing them today. Editing your own work is hard :(
ubuntu trusty + gnome 3.12 on a 2011 13" MBP Emacs 24 from git, evil-mode, rust-mode from elpa, etc http://i.imgur.com/qTEAUI6.png
I just fixed all the ones I knew about. If you end up glancing at it again, please let me know: https://github.com/steveklabnik/rust_for_rubyists/issues/new
I agree 100%. That's why I'm pro-HKT. But it's not likely that Rust will get them before 1.0, because they're backwards compatible.
I wouldn't have thought that so many people here are using i3wm! :) Debian testing + i3wm + Sublime Text here
Ever write a partial differential equation solver that takes a day to run on a thousand hybrid MPI-OpenMP nodes? Fortran's damn good at that, nothing else is. Python needs a better type system and package management that actually works reliably, but it has the advantage of being dead simple to use. Rust may eventually be great for systems programming, maybe web or games even further down the line, but trying to use it for numerically intensive tasks is more trouble than it's worth.
In a really abstract sense what you wrote kind of makes sense, I think, but you would need a *vastly* more powerful type system than Rust's to actually be able to represent it that way.
Would something like `[5, 2, 3, 10, 11, 18] as &amp;[u32]` work? I've never tried it, just theorizing.
Nope. :/
I'm curious why you chose the name `UnregisteredMethod` rather than `ExtensionMethod`?
&gt; I'm guessing then [T, ..N] is only valid for any T of a fixed length, then? Yes. &gt; So [[T], ..N] is not a valid way to represent an array of different length arrays. Yep. &gt; Yet &amp;str is basically &amp;[[u8]] even if the type system can't represent that. The thing with types like `&amp;[u8]` is that the type system is employing existential quantification: it's moving the above `N` from compile time to runtime, storing it alongside the pointer to the array. But it's still there. With `&amp;[[u8]]`, where do you put them? Given a sufficiently powerful type system you could probably encode the fact that the length of a particular sequence depends in such-and-such ways on the previous sequences and the prefix of the particular one (essentially, teach the type system about UTF-8), but Rust's type system is not.
Does it support forwarding tokens that are not proper HTTP ? (I hate to be that guy but...)
I spent a little time figuring out what the types were for each step in the process: use std::io::{BufReader, IoError, Chars}; use std::iter::Map; fn main() { let meow = b"meow meow meow"; let mut reader: BufReader = BufReader::new(meow); let chars: Chars&lt;BufReader&gt; = reader.chars(); let mut map: Map&lt;Result&lt;char, IoError&gt;, char, Chars&lt;BufReader&gt;&gt; = chars.map(|x| x.unwrap()); let result: String = map.collect(); println!("{}", result); }
FWIW, there is value in a design that keeps its requirements simple and plainly states that something more complex is not its job. Using Docopt is *very* simple. (Its implementation is anything but.)
Also, I see that there are "safe" and "idempotent" fields in UnregisteredMethod, but obviously the parser has no way of knowing whether unregistered methods are safe or idempotent, so these should be Option&lt;bool&gt;, set as None by the parser, and as Some(v) by a client that knows what the method he is using does. 
Will borrowing that immutable ref affect the calls below that conditional? That was my reasoning for that, but I think I changed things around where before I was borrowing `primes` as mutable and mutating it below. I was explicitly scoping the borrow. I thought it was smart.
&gt; FWIW, there is value in a design that keeps its requirements simple and plainly states that something more complex is not its job. I do not believe in APIs that are blackboxes. I much rather have a low level interface I can fall down to if the high level fancy pancy API stops working. Docopt's design is that you cannot access the internals and even if you could, there is too much hardcoded magic. I don't like that at all. :)
Some great insights. I thought `DList` might be better because `Vec` would have to resize a lot; wouldn't that pertain a lot of copying? A minor complaint with `Vec` is that pushing and popping affects the right side vector instead of the left, which mostly just affects printing. I was concerned that `take_while` would miss primes because the iterator might not be sorted, but now that I think about it, a `BitPositions` would be sorted, so that's a good optimization. I did not know `all` short-circuited. I was negating the result of `any` before. Not sure why I went this way instead. I will definitely add that in. I would appreciate a `sqrt()` method on `uint` because converting to float and back made that whole thing very messy. Will converting a `uint` to `f32` or `f64` ever result in an error, if a `uint` is always guaranteed to be representable? Or can the conversion error be safely ignored? I was using `uint::to_f64` and `f64::to_uint` because I thought casting it might introduce errors. On that note, is being lazy and using machine-width integers `int` and `uint` discouraged? Is it preferable to use specific-width integers? I presume `int` and `uint` will be the size of a machine word, e.g. 32-bit on 32-bit, 64-bit on 64-bit. &gt; Rust isn't trying to be a functional language: sometimes mutable variables are just the right thing to use. So, I'm not overusing `mut`?
No REPL. I don't like the edit/compile/run cycle when I'm figuring things out with an unfamiliar API or piece of syntax. Since this was removed from the language (i.e. rusti existed at one point), I'm hopeful a new REPL is feasible in a way that a C REPL isn't really.
I think match and guard arms in Haskell need to be lined up or the compiler will complain. I guess it looks better but I don't think it should be enforced in syntax.
I'm not saying it should be either.
arch, xmonad, zsh, tmux and vim
Well, technically, `if cond {};` would be a statement. ;) But you're correct. I should be more exact. https://github.com/steveklabnik/rust_for_rubyists/commit/8d0bd8199a00dd0f88b0fb8daaf3c05c646f93c5
Interesting. I didn't realize why I found "grokking" Rust difficult, even though *technically* almost all types and methods in the Rust standard library are documented. Without examples, I find myself looking at the standard library source code more often than I would like, in the hope of finding examples of proper usages. Sometimes there is an instructive test case, but more often than not, I end up more confused because of all the internals that I am not supposed to access. As an example, providing a custom implementation of the Show trait, a 5-minute job, resulted in an hour long hunt for the "right" way to accomplish this. (Solution: use the write! macro on the &amp;mut Formatter passed to the fmt method)
Contract-based programming makes a lot of sense to my mind. If you consider abstract data types, their types don't always reflect or make obvious all of their useful invariants. If you have a stack, for example, this should always hold: `pop(push(stack, elem)) == stack` This can be expressed with a quickcheck-like tool. Now you are already a step ahead of your typical unit testing since you have an expression from which you can generate a lot of test cases, instead of having to "hard code" the same expression with a lot of different stacks. Arguably the next step is to somehow connect these invariants with the interface/trait/type class/signature which defines the abstract data types. That is, to make the connection explicit. Now all implementations of these interfaces can be directly vetted against the invariants. Maybe the run time can also leverage the invariants, which means that the invariants aren't just confined to the batch processess of generating test cases with the quickcheck-like tool, but can be tested on actual running programs. Perhaps you can also use them in new interfaces which build on your previous interfaces, to (interactively with the compiler) reason about these invariants and how they relate to other data structures and their invariants. These invariants, or *axioms*, are the missing components from interfaces/signatures in most mainstream languages. One might balk at the idea of a lot of runtime checks. What seems crucial is the ability to turn off these checks, if necessary, and if it doesn't violate any presumed correctness garuantees. Then you might have something like a debug build, and a production build with less dynamic checks. Maybe you even have a lot of dynamic checks for the production build, if the program is relatively immature. The next step w.r.t. correctness is *static checks* of correctness, which might be realised via proofs using things like dependent types. However, if you can't find time for proving stuff about code, or you can't manage to find a compiler that is 'smart' enough to generate a lot of proofs for you, then this contract-based programming with dynamic checking seems like a pretty great bang-for-your-buck approach. An ideal approach seems to be to combine dynamic and static checks, which seems to be what Spark/Ada is about. 
You're writing a synthesizer in rust? That sounds fantastic.
Thanks!
I agree with you about the sigils. The 0.5 (maybe 0.3?) syntax was what attracted me to Rust in the first place.
Does this work for you? http://is.gd/6UWmTl The other option is to do the lookup as a secondary step. http://is.gd/74uSML which is not as safe.
Hey dude, you in /r/rust, which is for the rust **programming language**. You are looking for /r/playrust. Hope your server does well!
If you just match on `Some(c)`, `c` is of the type `&amp;'a i32` - a reference to some integer that lives inside the cache. What you need to do is match on `Some(&amp;c)` so that it clones the integer into `c`. This will make the borrow expire after pattern matching but right before the associated branch. You'll also need to change the second branch so that it returns the generated `i32` by value. The resulting code would look like [this](http://is.gd/7er3bQ). From the docs: fn get&lt;'a&gt;(&amp;'a mut self, k: &amp;K) -&gt; Option&lt;&amp;'a V&gt; The lifetime of the reference is tied to the lifetime of `self`. As long as you're holding the reference `get` returns, you can't modify the cache.
What do you mean? If a method is not syntactically `token`, it *must* be rejected. No doubts about that.
The terminology “extension method” is obsolete—RFC 7230/7231 does not have such a distinction as RFC 2616 had. This is merely a convenience, an implementation detail, not a part of the standards. I think it is more correct.
Ahh, thanks! This should help direct my reading ;) I just started looking into rust this week, and so far I'm really liking it, even in the current state.
All/any comment containing an is.gd link gets killed by Reddits spam filter, if you do comment here with a link like that (or anywhere else), feel free to reply to this comment or directly message the mods to attract attention.
nope :)
I can certainly do it myself but I love PRs, especially since I love contributors :) I won't insist though.
I have seen the approach of the Joyent HTTP parser (“I’m not a general purpose server, really I’m not! I don’t need to be compliant, I don’t need to support methods outside this small set of horribly-done and buggy hardcoded methods!”) and hated it. It leads to people discovering that supporting things like the LINK method, which should be trivial, is actually blocked on joyent’s http-parser as used in nginx, node, &amp;c. They are breaking the web because of their own poorly designed software. For these reasons and others, I declare that both the low- and high-level APIs in Teepee *will* support all HTTP methods. Given that, this enum doesn’t produce any benefits at all (`method == Get` is considerably more awesome than `method == Http(Get)`) and imposes certain ergonomic costs. If you wish to convince me to use such an approach, you’ll have to work quite a bit harder! [New lifetime elision rules](https://github.com/rust-lang/rfcs/pull/141), which I expect to land, will improve things with `Method&lt;'a&gt;` also. ---- There is no *benefit* in storing the contents of a token as `str` instead of `[u8]` or even `[Ascii]`. It’s internal implementation detail, and if I ever did want to expose it as any of those other types I could do so in an unchecked fashion. As it is, I think that exposing it as bytes is probably all that’s ever going to be needed, but an `as_str` is something that could be added later on at no cost. ---- An HTTP request-line with an invalid method *must* be rejected. There is no value in logging it or passing it through to proxies; it should be flatly rejected (terminate the connection or send back 400 Bad Request, at one’s discretion). Keeping invalid tokens around is not necessary.
Can you expand on what benefits this would yield? I can’t picture how it would work.
Sure, but you could limit the borrow here without containing it to the conditional expression. E.g. let contained = { ... }; if contained { return true; }
Have the mutable version call the immutable version? Won't inlining make them basically equivlaent?
Doesn't that require some kind of transmute (as I show in my hack)?
Unfortunately it doesn't work as a `[]()` link because it contains unescaped `)`'s.
Yeah, markdown is terrible like that... links should use `&lt;&gt;` as separators [per the URL RFC](http://tools.ietf.org/html/rfc3986) (Appendix C).
Yeah, not much we can do about that ATM though. Although, for reference, it does work using the long form of Markdown links. E.g. [hello world][hw] [hw]: http://play.rust-lang.org/?code=fn%20main%28%29%20{%0A%20%20%20%20println!%28%22Hello%2C%20world!%22%29%0A} src: [hello world][hw] [hw]: http://play.rust-lang.org/?code=fn%20main%28%29%20{%0A%20%20%20%20println!%28%22Hello%2C%20world!%22%29%0A}
What about the immutable version calling the mutable one? Edit: wait no that's the same problem, just transmuting a different thing. Yeah, I dunno how to do this hack-free. I kinda think we need some sort of mutability-generic.
I know you deleted the following comment, but here's a toy example with some of the approaches: http://is.gd/6rbtrj
What's even more terrible is some markdown engines handle the `()` in the URL and some don't.
Reddit, what are you even doing?
I never really considered that DRYness is impacted by the dichotomy between mutable/immutable reference-returning code. I wonder if there's a way to address this problem in a general fashion at the language level.
Yeah, I don't think this actually meets your requirements. I was thinking of a variant of your design one, but instead of storing the `Token` directly in the `Method` statics, you'd store something like an offset or key or whatever for a shared lookup table, making `Method`s `Copy` again.
How? The immutable one doesn't have a mutable reference to the object...
The difference is that at the end you have to *return* a mutable reference to the inside of the structure. You can't get that from a function that takes in an immutable structure.
Considering that rust requires different binaries for different systems... Why?
[Spam filtering](http://www.reddit.com/r/rust/comments/2a54sy/lrucacheget_and_borrowing_in_general/cis25xr).
Oh yeah, I was thinking of a case of my own, where the immutable getter actually *does* of necessity take `&amp;mut self` (Teepee’s header collection).
That’s just the trouble—it works *just* well enough and is dependency-free and so on, and so people use it. I just wish it didn’t work.
Ehh it's probably a good change overall.
Ohhhhhhhh.
You could have a static variable containing the path, conditionally compiled. I hope you are using this for defaults instead of hardcoding the path - multi-instance minecraft by definition requires different .minecraft locations
Totally parsed that as `LLVM on (Windows Update)`. Was confused.
I would be convinced Microsoft had gone batshit insane (in a good way?) if that were true.
I'm sure you wouldn't have been a fan of mine if you had ever seen some of the actual *code* that powered it. Who needs a level description markup when you can have 7-tuply nested array literals? ...15-year-old me was an idiot. I probably won't accomplish much interesting with Rust for now, since there are a lot of language quirks and bugs that are really preventing me from writing the kinds of things I'd want to. Mostly I'd just write data structures and algorithms if I could, though. I must admit, I'm finding the community intoxicating, regardless. Really getting in the way of me getting *actual* work done. :)
I suppose I could subject myself to the horrors of editing code. One PR, coming right up! The interface might not be perfect the first time, though.
Sounds like a lot of work was put in to the LLVM IR to better support Windows ABIs, albeit C++ ABI on 32-bit platforms, but as a Windows user I would hope this could help rust on Windows. It does sound like LLVM can be compiled on Windows without MinGW, which could really be useful in helping rust drop it as a dependency on Windows.
`input.split(',').flat_map(|s| from_str(s.trim()).move_iter()).fold(0, |a, b| a * b)` Very dense. Uses the [wonderful iterator support](http://doc.rust-lang.org/guide-container.html#iterators) EDIT: `flat_map` is much like a normal `map`, but rather than mapping to a single element, it maps to an iterator. It then iterates over all of these sub-iterators, yielding each element from every iterator in turn. An iterator over an `Option` is something that yields one or zero elements. `move_iter` creates an Iterator that yields the contained element by value, and consumes the option.
You'll probably get a more thorough reply than this, but basically what you want to do is use iterator chaining instead of that for loop. map: http://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html#tymethod.map Check out all of the methods implemented by the Iterator trait, you'll find everything you're looking for in there. Using a match expression instead of the if x != None {} block would be more idiomatic. Edit: here's an idiomatic solution fn main() { print!("Enter some numbers: "); let input = std::io::stdin().read_line().unwrap(); let result = input.as_slice().split(',').filter_map(|i| from_str::&lt;int&gt;(i.trim()) ).fold(1i, |tot, val: int| tot * val); println!("Multiplied, they are: {}", result); }
How would swapping mingw dependency for Visual Studio dependency improve anything? 
[`filter_map`](http://doc.rust-lang.org/master/std/iter/trait.Iterator.html#tymethod.filter_map) is a special case of `flat_map` for `Option.move_iter`, i.e. `input.split(',').filter_map(|s| from_str(s.trim())).fold(...)` should work.
Instead of the `fold`, you can use `product`, you'll need to import the `std::iter::MultiplicativeIterator` trait. input.as_slice().split(',').filter_map(|s| from_str::&lt;uint&gt;(s.trim())).product()
It does support it by having multiple Cargo.toml files in a repository, e.g. [quickcheck](https://github.com/BurntSushi/quickcheck) has two ([main crate](https://github.com/BurntSushi/quickcheck/blob/master/Cargo.toml) and [macro crate](https://github.com/BurntSushi/quickcheck/blob/master/quickcheck_macros/Cargo.toml)), dependent packages just need to [depend on both packages](https://github.com/BurntSushi/quickcheck#installation) and Cargo will search and find them.
It uses the builtin arena type on what was originally a garbage collection benchmark, so be cautious not to read too much into it.
I guess, but it's really not my favorite benchmark.
Should initialize the fold with 1 for a product, I believe
I wouldn't say that cargo is a driver for cars, but the tone of the guide feels good. It's supposed to be a guide and it feels like a good book that I would love to read. It reminds me of the Pragmatic Programmer or something.
 x.map(|y| result *= y); FTFY
It does, thanks for the tip.
Cool, I'll check it out.
The obvious solution here is to recognize that mutable/immutable is really a tri-state: * immutable - I need this to be the same thing at all times * don't care - I won't change it, but don't mind if someone else does (not concurrently, of course) * mutable - I need to change it Currently we have `X` vs. `mut X` - so we need to have a moniker for the "don't care" mutability state. How about `var` as in X is variable (but not mutable inside this function)? `X` vs. `var X` vs. `mut X` - looks good to me.
Thanks, these are the sort of idiomatic tips I was looking for :)
Thanks a lot, that's great!
I find side-effect only functions strange to use with `map`, especially since `Option.map` differs semantically to `Iterator.map`, making the code somewhat harder to read.
Though there isn't really much precedence for this in canonical rust code, I find it useful to visually rearrange the chained iterators, something like this: let result = { input.as_slice() .split(',') .filter_map(|i| from_str::&lt;int&gt;(i.trim()) ) .fold(1i, |tot, val: int| tot * val) }; There's been some discussion about the possibility of syntactic sugar for iterator chaining.
I have now implemented this; feel free to review it if you desire. https://github.com/teepee/teepee/commit/50cf00bd45e73f448cf2b51e55b6ea7db62647df
On unixy systems you could use uname, and windows most likely has some equivalent. So you need to write some sort of wrapper and have conditional compilation for windows.
I think this is a little different to `const`. At least, the actual solution is different to `const`, it's like a combination of `const` and `uniq` (or just `&amp;` and `&amp;mut`, really). Inside a function declared like fn foo(x: &amp;'a var T) -&gt; &amp;'a var U the compiler treats `x` as a `&amp;mut` with respect to aliasing, but as a `&amp;` with respect to mutability (i.e. intersection of the restrictions of `&amp;` and `&amp;mut`). Meaning you can call `foo(&amp;mut bar)` and get a `&amp;mut U` out, and `foo(&amp;bar)` to get a `&amp;U`.
This is the first idea that always comes to mind but how would it, could it, actually work? You can no more abstract out the `mut` in `&amp;mut` than you can abstract out the `Mut` in `RefMut`. It's just part of the name, but it's a completely separate type with different semantics. What I could imagine is, once we have HKT, abstracting over the *reference type* (`&amp;` or `&amp;mut`) directly, rather than its mutability. But I'm not really sure how that could be used to solve this particular case either.
Does this mean that it won't be long before Rust programs on Windows don't require the `libgcc` DLL anymore?
This *is* some form of parametric polymorphism then: fn foo&lt;'a, mutability var&gt;(x: &amp;'a var T) -&gt; &amp;'a var U unless you want to be able to pass in an `&amp;` and get an `&amp;mut` out.
Yes, I agree that it's parametric polymorphism.
At that point I'm not sure if it bears much resemblance to /u/llogiq's original suggestion, but OK :) (And I'd still like to see the idea fleshed out, but based on your comment I at least have an inkling that *maybe* it could work.)
As dbaupp said, it's not exactly &amp;const. And yes, it is a form of parametric type, namely a wildcard over mutability. I am not exactly sure how mutable pointers are implemented in rust, but in theory, apart from the code to own/de-own a mutable / immutable object the method should stay the same. Shouldn't that be a no-op anyway, as the compiler catches concurrent access at compile time? If so, the code generation could treat the (const, volatile, var, dontcare) as mutable and the borrow checker would need a special provision to check depending on whether the method was called with a mutable or immutable object. The resulting assembly would have no duplication at all.
I agree, much more readable.
I agree, line breaks and aligning to the `.` is nice (e.g. [this blog post of mine](http://huonw.github.io/2014/06/10/knn-rust.html)). I think there is precedence for it, it's just quiet, since iterator chains that long aren't particularly common (or, at least, people haven't really talked about/highlighted it much).
So I ran into an issue with handling empty input: Enter some numbers: task '&lt;main&gt;' failed at 'called `Result::unwrap()` on an `Err` value: end of file', /home/rustbuild/src/rust-buildbot/slave/nightly-linux/build/src/libcore/result.rs:545 So for completeness here's my solution using `match`: fn main() { print!("Enter some numbers: "); let result = std::io::stdin().read_line(); match result { Ok(value) =&gt; println!("Multiplied, they are: {}", value.as_slice() .split(',') .filter_map(|i| from_str::&lt;int&gt;(i.trim())) .fold(1, |x,y| x*y)), Err(_) =&gt; println!("") }; } 
I'm reminded of Steve Krug's excellent writing rule. Omit ~~needless~~ words. It was made in context of writing text for e-stores but holds water in this case as well. My take would be this: &gt; Think about relationship between cargo and rustc like this: rustc is a car that can be driven either by you or by an automated system like cargo. 
Mine neither, but its results are the most impressive: http://benchmarksgame.alioth.debian.org/u64q/rust.php
No, this sort of analogy is just superfluous. Cargo is a tool to build your program, while also taking care of downloading and building dependencies. That's more helpful than any analogy. Perhaps clarify what dependency means exactly and everything should be clear even for a beginner.
Analogies rarely work. The only people who understand them are those who already understand the concepts on *both* sides of the analogy. You can rarely, if ever, transfer knowledge of one side of the analogy to the other.
Can't you have function return an enum with mutable\immutable variants?
I really don't want to discourage steveklabkin from writing the docs, but his style **is** a bit too fluffy.
The rust docs have to serve very different people that are at different stages of their skill development. While I agree the quoted paragraph is useless, there does need to be some form of softer introductory material for people like the thousands of RoR devs out there that have never seriously used a statically typed language, let alone a language with manual memory management. But yes, a guide that follows in the tradition of [Scala for the Impatient](http://www.horstmann.com/scala/index.html) would be lovely. 
&gt; .fold(0, |a, b| a * b) ...
Interesting, and ultimately a good thing that Rust is getting visibility to people who make decisions on technology without ever actually using it. I think the description of Rust leaves something to be desired. I know Mozilla is not very likely to advertise Rust's speed until there is an actual focus on performance optimization, but the fact of the matter is that Rust is already blazing fast. Part of the reason why Rust exists is because safe manual memory management is a nightmare to write, maintain, debug, etc...but the message that gets lost is that manual memory management still exists because it is fast and has very low resource consumption overhead. Rust gives you that speed without giving you the warts that traditionally came with it. 
This is the weirdest arbitrary selection of languages I've seen in a long time. And why do languages get split into parts - 'Scala, the good parts' - wtf? I was more impressed with IEEE's recent [publication](http://spectrum.ieee.org/static/interactive-the-top-programming-languages), despite its obvious flaws and the omission of Rust (or is that an obvious flaw too? ;) ).
&gt; And why do languages get split into parts - 'Scala, the good parts' I'm sure they have had Scala on there before, and this is a revision to signal they are rethinking things in regards to the language. This is their 6-monthly review - more languages have been reviewed in the past. Personally I am more interested in the fact that a company like ThoughtWorks has enough interest in Rust to have given it a preliminary review.
As long as it doesn't turn into why's poignant guide to Ruby...
Aargh, yes, I was aware of that initially, but it is a bit hard to test such issues and I've managed to forget it. The new code should have no such problem.
... better not look into my past, then. Rust is my first programming language! :P
This kind of rule often leads to text that is very, very boring.
I could imagine that many have only driven automatic, and many others have only driven manual. In that sense, it might not be very relatable.
&gt; This ~~kind of~~ rule ~~often leads~~makes ~~to~~ text that is ~~~very,~~~ ~~very~~~ boring. &gt; This rule makes text that is boring. See what I mean?
I actually just wrote this up as an example in the guide, so there will be precedence soon.
LLVM and Clang can be compiled using Visual Studio for a long time. clang_cl can also be used to compile a lot of C++ code that do not use exceptions. Of course it is not production ready for now but still very usable. 
Or maybe [decapitated caterpillars](http://learnyouahaskell.com/starting-out#an-intro-to-lists)?
I'm a little late to the party, and currently just an interested spectator rather than a practitioner of Rust. With that said, I don't like the [naming conventions](https://github.com/rust-lang/rust/wiki/Note-style-guide). Mixing `PascalCase` and `words_with_underscores` is awkward, in my opinion. Those styles originate from separate communities, and seeing them together evokes something akin to cognitive dissonance in my brain. Also, the abbreviations make things a bit harder to read. In today's world of wide screens and code completion, it seems a bit anachronistic. Some things like `Vec` are obvious, but others like `Shr` are not. Is that SHift Right? SHoRt? SHaRed? StandardHttpRequest?
An emoji ?
No, but probably because the original, longer sentence was boring anyway. There is a good phrase 'too cute by half' which tries to get across the point that some things are just as acceptable with half the cuteness. That this discussion has popped up makes me think you're bumping up against those things.
I still think it's a cop-out and a way to protect oneself unfairly against deserved criticism. If we're going to split up languages by referring to 'the good parts' and 'the bad parts', many languages deserve to be at the core. It's intellectually dishonest. I'm not very surprised at Rust's inclusion. I've been keeping an eye on Rust since the very first time I read about it, but in the past month I started seeing some signals of hype: we now have [pro-Rust trolls](/u/bet_on_rust), [anti-Rust trolls](/u/hello_fruit), people complaining on \/r\/programming that it is now being [compared against](http://www.reddit.com/r/programming/comments/29fp6w/why_go_is_not_good_will_yager/cikq7m1), that that sub [has the hots for it](http://www.reddit.com/r/programming/comments/29t8wm/the_march_towards_go/ciohuo1?context=3) (read entire linked thread), and some expect it to displace Java **and** C++ [already](http://www.reddit.com/r/programming/comments/29t8wm/the_march_towards_go/ciowe0i?context=7). Oh, and then there's the jokes (I think) about the [Node-&gt;Go-&gt;Scala-&gt;Rust train](http://www.reddit.com/r/programming/comments/29syhg/farewell_nodejs/cip5d92?context=5). All that is bound to result in some (possibly premature) network effects. Even though I was expecting that, I didn't expect it to start happening already. I'm not complaining, but I can't believe the pace at which word is spreading now.
&gt; serve very different people that are at different stages I think that this is really the issue. It's extremely hard, maybe even impossible, to strike a balance when targeting such disparate readers. For the most part, Steve is going to have a specific type of reader in mind and write for them. Those outside of this type are going to find certain things annoying. Personally, I hate fluff. Lucky for me, Rust by Example exists and is awesome. I'm not sure of its status, but I would be overjoyed if it got first-class status besides the new guide.
Yup, that's exactly what having an editor is like.
I understand that, but it misses my point. It's linked as "External documentation" behind the "All docs" link. The guide is going to get prime placement on the front page, overtaking the 'Tutorial' link, no? That is what I meant by first-class status. My point is that the new guide is (currently) 1527 words to Hello World. Rust by Example is 219 words to Hello World. They serve massively different purposes, and I think both are important. Some people are going to be much better served clicking on Rust by Example first, not the guide.
Absolutely. I don't disagree with anything that you've said, I was just trying to point out that it _does_ have more blessing than many other things.
Some 'vacation!'
I don't have any data to back this up, but from watching the sidebar of this subreddit (where it says "~48 users here now") but I swear there was a sharp up-tick in interest following Apple's announcement of Swift and Chris Lattner's subsequent citing of Rust as an influence.
Could you elaborate on that? What changes do I need to make?
Dependent types are powerful because it narrows down the possible combinations that gives a working program when you have programmed it partially. You can have the computer search for valid inputs and fill in the gaps for you. This is what Idris does. What I meant by using the type system as graph, is thinking of data as nodes and traits as connections between the nodes. You don't need to define all the nodes, only the symmetries between the edges. The graph exists as a mathematical object implicitly defined by the type rules. When you write a program like this, jumping from one node to another, you navigate the graph.
I don't think the data concurs: http://redditmetrics.com/r/rust Seems like a pretty smooth curve, though the last two weeks have been a little stronger than expected.
[Here's](https://github.com/rust-lang/rfcs/commit/704f0060176418659698eb63642e2071b109e029?short_path=6b90c47#diff-6b90c47efb814adb642039adecdde442) a markdown rendered view. Syntax highlighting and not all highlighted in green.
Im not sure I agree. I thought Niko's analogy of Rust's ownership system to physical objects was helpful (owning a book, borrowing a book, etc).
I'm not familiar with the no-allocation part. Why does using `collect` do more allocating?
I have to admit I keep reading "Lifetime Ellison RFC," and I wonder how Larry Ellison got into an RFC. On a more serious note, I think this RFC is going to be a big win for making Rust a cleaner-looking language.
&gt; Moreover, lifetimes cannot be elided in impl headers. This quote comes from the section "Today's lifetime elision rules", which describes the status quo. It's more obvious in the [rendered view](https://github.com/rust-lang/rfcs/blob/704f0060176418659698eb63642e2071b109e029/active/0000-lifetime-elision.md).
Also considering having a nightly version to run, instead of being pegged at 0.11 and occasionally manually updating.
"programmers love car analogies" I don't. Aren't I a programmer? Introduce a car analogy if you like, but please don't tell me what I love, or imply that I'm not a programmer since I don't.
&gt; By codifying this pattern into simple rules for filling in elided lifetimes, we &gt; can avoid writing any lifetimes in ~87% of the cases where they are currently &gt; required. &gt; &gt; Doing so is a clear ergonomic win. Looks like it is a win for writer, but a lose for reader, and a big lose for newcomer trying to understand how lifetimes work. I hope it's for the best.
The first rule in this RFC is the elision rule we have today. Can you expand on the downsides you see here?
It takes a function from an element to an iterable, and chains all of those results together.
&gt; The first rule in this RFC is the elision rule we have today. And I like that rule. When I see &amp;-parameter without lifetime, I rapidly understand, that this is in-parameter. It does not escape. And vice versa when my eye catches &lt;'a&gt; I quickly understand that function returns a reference to input parameter. (Sidenote: for the same reason I'm against removing apostrophe from lifetime token) Code like this looks like data is copied into a buffer. To understand it properly, I have to know the signature of BufReader type. fn new(buf: &amp;[u8]) -&gt; BufReader { ... } With explicit lifetime parameters: fn new&lt;'a&gt;(buf: &amp;'a [u8]) -&gt; BufReader&lt;'a&gt; { ... } I can bet, that BufReader references buf, even if I know nothing about BufReader. That were arguments from code reader point of view. Now arguments from teacher/learner point of view. I do tell about Rust a lot (mostly to my colleagues). And I have big trouble explaining, how lifetimes work. It takes significant amount of time to explain, how lifetimes are propagated through functions. Basically, I explain it like this: * Lifetime is a function static parameter, like type parameter * Type inference does not cross function border * Look at the function signature: see, there's lifetime marker near parameter, and the same lifetime marker near return type. That's because their lifetime is the same. It takes me about 15 minutes to explain, how lifetimes work (that's a lot). At that point I can tell my colleagues: look at the Rust standard library, for instance, option.rs, it is very nice and easy to read piece of code. With new elision rules applied, I would have to immediately explain new elision rules, and I think percentage of people willing to continue learning Rust would be somewhat smaller.
I've never been driven by a robot.
No, something that basic should be pretty safe.
I don't think it is such a problem - assuming you have `&amp;''mx T` (to use an absolutely awful straw man syntax) you just have to ensure that the method type checks with all possible values of `mx` which is `mut` and not `mut`. That should just come down to checking with a third kind of reference - one which is unique and immutable. Any function which doesn't type check that way, will need separate implementations for mut and non-mut. HKT probably gives you a cleaner way to do it. But probably at the expense of more complex signatures.
Really? Seems just don't have to mention explicitly named lifetimes at all any more now. If you want to pitch Rust you can now do it with just a few points: - Ownership; explain the compiler automatically free's objects when they go out of scope, or the parent object is free'd. No GC. No manual free; the runtime manages it all. - Borrowing; you can only uniquely borrow mutable references, which 'locks' that data for the duration of the borrow. ie. Thread safety. - Immediate direct fast ffi for interacting with c libraries, a wrapper that automatically generates bindings from c headers (bindgen). - All the good things about concurrency, traits, etc. you expect from a language. That's it. No explicit lifetimes; lifetimes are pretty much comprehensively covered by ownership and borrowing. Why do you actually have to explain explicit lifetimes? The only reason imo is in the rare cases you need explicit lifetimes, and those only exist because the lifetime checker can't infer things purely from the type definitions in some cases. It's burden, not a feature for new users. Certainly I've never had any kind of positive reaction to trying to explain explicit lifetimes to people. They generally speaking dislike the verbosity and complexity. I think this is a great change~ 
Thanks for typing this out. I don't have time to read it right now, but I'm sure it's much more helpful. I'm giving quite a bit of thought to this, as lifetimes need extra amazing docs. EDIT: I think /u/shadowmint and nick said everything I'd say, but still a conversation worth having.
Explicit lifetimes are not pleasant but they are sometimes necessary. Think of them like medicine. You will still need to understand lifetimes and lifetime parameters to be an intermediate to expert Rust programmer. Because, by the stats we have at the moment, you _could_ elide lifetimes 87% of the time in rustc. That means explicit lifetimes are necessary in 13%. In my experience, the lifetimes will not be necessary but a function will 'need' them in order to be debugged or just for clarity in some more cases. Also, rustc has relatively simple lifetimes compared to Servo and maybe other projects. So we should probably regard 13% as a best case for real software, 20-25% might be more realistic (total guess). All of which is to say, that this lifetime elision work will make Rust much simpler and will be full of win, but it will not, realistically, stop you having to think about or write lifetimes in all cases. It will probably push back having to do it a little bit further along the learning curve and make a lot of common cases easier though.
Would you like a tutorial about what the various primitives are, or just how one actually uses calls the Rust versions of them? For [`Semaphore`s](http://doc.rust-lang.org/master/std/sync/struct.Semaphore.html), I believe the expected usage is to put a semaphore into an [`Arc`](http://doc.rust-lang.org/master/std/sync/struct.Arc.html) (atomically reference counted pointer) and then clone that among the tasks that need access to it.
More of a tutorial or example of how call and work with them in rust's context. I'm still trying to wrap my head around Rust's syntax. And just raw doc isn't cutting it. I've been spoiled by java docs very simple "this is you constructor, these are your methods, have fun." I know typically how is use semaphores, queues, etc for IPC and resource management. Just not in rust's syntax. 
That's something I've ran into. When you head off the beaten path you find things not exactly commonly documented, it's annoying but I guess part of this being a fairly new language. 
Yes, it is definitely something that needs improving (and is). (Patches are definitely welcome (even just adding an example), if you or anyone else wishes to help document things.)
It's probably something of a more edge case here, but I'm primarily interested in it for its potential as a more productive language to replace C for the 'heavy lifting' that light weight dynamic languages can bind to, that can itself easily interact with easily C libraries. eg. interact directly with rust crates (shared libraries) from python, js, etc. I'm sure the 'pure rust' ecosystem will develop over time, but this definitely hits the sweet spot of 'immediately useful' in day to day work.
I'm following Rust: * Because programmers should be protected against themselves wherever this can be done affordably. * Because performance is almost paramount. * Because problems that needn't exist, shouldn't exist. * Because the world never stops, nor should it. * Because, in my humble opinion, tradeoffs in execution speed should generally only be made when necessary for security. * Because static typing gives clarity. I used to occasionally read about programming languages via [this Wikipedia page](http://en.wikipedia.org/wiki/Comparison_of_programming_languages). I suppose I still do, but I think Rust is the first language that felt like it was designed with the right goals in mind. I already find myself thinking about what a Rust++ would be like decades from now (comprehensive dependent typing? automatic concurrency?). If I knew what would be a perfect programming language to me, I might be stupid enough to go for a TMasterlang and have it fail, but for now Rust seems to be everything that it should be.
Would HKT still be possible with this type inference scheme replacing the current one?
I'm interested in Rust because I haven't found another language like it that has a better (or even close) chance of widespread success. I'm starting to use it everywhere I used to use C/++
Yup! I will EVENTUALLY get around to writing these, but it's at the end of my list. Contributions very welcome.
&gt; I'm starting to use it everywhere I used to use C/++ Interesting! For you, where is that?
&gt; It's probably something of a more edge case here I'm think it's not an edge case at all! If I ever make professional use of Rust, I think that it will be through an FFI (unless I move away from the web at some point). I've also thought about writing plugins/extensions for software that expects a C-like ABI, such as VST effects for guitar programs - making metal with Rust, eh? ;)
Of course that's when I'm not working on Rust itself!
I believe in the concept of having a safe and more functional C++ without performance loss.
I'm interested in Rust as a way to do high-performance, low-level programming with fewer errors and less verbose repetitive crap.
"I don't always work on Rust, but when i don't, i work on Rust"
I was interested in D as a C++ replacement, but it never got the community support that I wanted. I played with it a bit, but there were just too many missing pieces. I then moved to Go and found it white productive. I've used it since just before 1.0 was released and have liked the direction of development. I had since run and into my fair share of nil pointer panics and weird GC bugs that's really can't see myself using it for anything realtime (e.g. game dev). And here I am, playing with Rust. Where Go feels rushed, Runs feels well designed. Many of the features I wished Go had are presented in Rust: * destructors * functional style (I love the conditional syntax for assignment) * traits are explicit, as opposed to interfaces in Go * optional GC * generics (don't miss them too much, but they come in handy some times) * static functions namespaced to a struct (I like the ::new () idiom) * cargo (the go tool is cute, but...) I plan on using Rust for gamedev once 1.0 hits. It just feels like a better fit in almost every way to every other language I've used for that application, and since Mozilla is looking to use it in FF, C++ bindings will likely be well supported so I should be able to use the wonderful C++ libs out there (unlike Go and D).
&gt; C++ bindings will likely be well supported I would like to see this as well! There are many cool libraries out there that are in C++ (Qt being the first to come to mind). That said, what I've read on past issues isn't too encouraging. It seems like C++ bindings are really hard to get right.
It's not hard, it's impossible. Unless you are C++, you can't really use C++ libraries like Qt which make heavy use of templates and most other C++ features.
I think it might be possible to piggyback on lifetime parameters rather than introducing an entirely new class of parameters. Basically introduce a third mutability option (I'll call it `&amp;mut?` for want of a better name). A parameter with this kind of mutability binds the mutability of its argument to its lifetime. Then, any `&amp;mut?` references returned by the function that have the same lifetime inherit that mutability. I haven't really thought through the implications of storing `&amp;mut?` references inside a struct, though. Also, I can't say for sure whether or not there's a compelling use case for accepting two `&amp;mut?`s with the same lifetime and then returning a reference whose mutability depends on only one of the parameters and not the other. It seems like you wouldn't need them to have the same lifetime in that case, but I'm not certain of this.
hehe. I've been getting pretty deep into networking in Rust in the last few months, and yeah, it's pretty painful. This is definitely an area I'll be trying to improve as I move along within it.
Modern language features for low level programming (micro controllers). Awesome ~~syntax extension~~ plugin infrastructure.
I'm currently using Java (along with a bit of fortran, python and R, but our main focus is Java, because most colleagues know it) for statistical data analysis and processing tasks in my job. Since I am the technical lead of my company, I feel obliged to check out technologies for improving our code. Our programs usually run a number of hours (sometimes a few days) and are (depending on their age and frequency of use) heavily optimized. Still, they run longer than they'd need, as we pay for GC (though we don't use it too much), lack of value objects (as of yet, my hope is for Java 9), lack of optimization for number crunching like C or fortran. So I look for a suitable, safe replacement for Java for massive, a bit parallel number crunching tasks with a mix of serial and random memory access patterns (so moving stuff to the GPU doesn't work so well) and some modest precision requirements. So far, I have a few contenders: * Fortran: Is already used and scores very high in the performance department, but the language style is quite baroque, also the only colleague besides me who still knows it has started retirement last year * C/C++: [...] C is playing with knives, and programming in C++ is juggling chainsaws. -- (unknown, taken from a CS textbook); as only my boss and I know C/C++ well, I don't feel comfortable to make that move. I'll still consider it, if none of the other contenders are ready for prime time next year * Julia: Nice, should outperform Java by some small amount. A strong contender, modern and available * Rust: It currently lacks a bit in the number crunching territory, but the strong type system, traits, concurrency and safety features and the macros are a big win; with GMP bindings it could conceivably beat Julias ass in the performance department So far Julia or Rust seem the strongest, most modern contenders of the bunch, and as we won't make the switch this year (because of project requirements), I can wait for rust to mature a bit before deciding whether to use it.