I do in fact implement that trait, which was, in fact, the issue. Thanks for reminding me of that, and it'd be really nice if Rust could either figure out those conflicts, or at least warn you of them -_- That was NOT readily apparent :c
The thing is, I'm under the impression that it *should* have picked this up. I know I've hit ambiguous lookup problems before. If anything, I'd have expected Rust to give the inherent method priority.
Please submit a PR and I'll publish.
There's also precedence for `|` showing up in types, since (if my memory isn't betraying me) there was a time when `||` was a valid closure type.
You know, I forgot about that. Given that `|x: i32| x` is valid, I'd say `|` should probably *be* allowed.
I tried to do that but it doesn't work, I get a lot of undefined names, Im probably doing something wrong in the file im trying to export to.
In the first case you can call load_bin with any type that implements AsRef&lt;Path&gt; and load_bin converts it into a Path ref. In the second version the caller has to do the conversion. I think the first one is more ergonomic for the user of the API.
I can imagine this works great if there are easier issues... Unfortunately libpnet is currently in a position where all the issues are either "add this big feature" or "fix this bug which requires quite a lot of domain-specific knowledge". I'm always (really!) happy to help mentor people, but I have a feeling those kinds of issues are particularly scary from a newbie perspective. Perhaps a way around this would be to try and break them into bite-sized chunks which can be tackled separately?
That would make sense. At least getting a warning that you have repeated function names would've been nice.
It's not for me asking for a friend who wanted to try to learn it- I'll pass irc suggestion on. Thanks :)
"Neutrality" is a political statement. It is saying that the status quo is OK; that those who are hurt by the present circumstances are not worth worrying about. If you think that you should make decisions based on technical merit alone and not politics, then the politics of your source code hosting site should not matter; if it works technically, then there should be no reason to care about their politics. If you want to move away from a source code hosting site due to political issues, that itself is a politically charged decision. And yes, this is all pretty overblown. That Business Insider article was more flamebait than informative.
/u/Quxxy's explanation is correct. However this particular oversight is [fixed](https://github.com/rust-lang/rust/pull/30694) on beta and nightly. There are [some more](https://github.com/rust-lang/rfcs/issues/1463#issuecomment-179568381) that need to be added though.
This is still not ready for use. It needs integration with emscripten's LLVM fork, and there are still a big chunk of tests that fail, but it's coming along. The remaining commits are in [my branch](https://github.com/brson/rust/tree/emscripten). They correspond to the emscripten `sdk-incoming-64bit` SDK. I expect that once the tests pass reliably, the Rust and Emscripten teams will attempt to synchronize our LLVM upgrades, effectively making Rust use the emscripten LLVM fork. We'll see how much maintenance that requires. I'd like to have demos ready for GDC to hopefully show off wasm support, maybe even with multithreading.
Do you have a timeline for OpenType Layout? Because I have an OpenType Layout library in development (with the same codename :S) but it's probably not going to be useful before late June (since I don't have that much time I can dedicate to Rust).
I did some testing with this and the problem does not seem to be the actual implementation of `std::ops::Neg` but rather that `std::ops::Neg` is in scope. Try toggling the comment in this playpen: http://is.gd/7Epy3X
Ah, I though we were talking about using `||` syntax in types. Closure construction of course still works :)
The documentation for that crate.
By OpenType Layout, are you talking about full-on HarfBuzz-style all-the-bells-and-whistles layout? That's a big undertaking. If your main focus is layout then my project and yours don't have to step on each other's toes (sorry about the name clash though). Mine is mainly focussed on the rendering side. If both libraries can find a common shared base for parsing fonts, then a user can load a font, lay it out with your library then render it with mine, a bit like how it works between FreeType and HarfBuzz. The immediate problem then is coordinating code for parsing fonts. At the moment this is not at the top of my priority list. My immediate goal is GPU caching of glyphs, followed by using it in my GUI library project. So, I suppose the TL;DR is "Not soon. Can't say much other than that though."
Do we have some sort of presence lined up at GDC? I'd looove wasm support regardless, of course. I also think combining our LLVM efforts with those of the Emscripten team is a great idea.
After reading this thread, I've decided to start learning a bit of Rust. Cheers.
*Interesting side story* I thought it worth sharing the genesis of rust-lzma, because it's based on a surprising result. I was working on a different Rust project and at some point needed to save/load some structured data to a file. Normally I like using plain-text formats (i.e. JSON), for the usual reasons, but file size was a concern. In particular I had to store lots of binary blobs, which I'd want hex-encode if I was using plain-text. So I looked around for some dual binary/text formats. The landscape was wretched, with only Google Protocol Buffers being somewhat sensible. There were rust bindings, but they weren't pretty. I could just create a custom binary format, but binary formats have the usual pitfalls. So then I got a crazy idea. What if I **did** use JSON, but ran it through a compressor. Just how good is XZ at compressing? Would it be possible, by some miracle, to compress JSON into something within spitting distance of a binary encoding? No way, right? But a good engineer profiles, so profile I did. I whipped up a program to generate test data, and then dump it as either binary or JSON. Then I ran JSON through `xz -9` and compared. Imagine my surprise when json+xz ended up being smaller! The smaller part confused me at first. Lots of fields in the data are `u64`, but they rarely use all that range; typically 16-bits or so. My guess was that xz was able to take advantage of that, whereas raw binary was just dumping them as 8 bytes each. So I modified the test case to fill up more of the bits. json+xz was only 6% bigger than bin. Okay, slightly more sane, but still weird that json+xz is doing so well. How about comparing json+xz to bin+xz. That's the most fair and apples to apples comparison. json+xz was only 8% bigger than bin+xz... So color me impressed. xz is able to go toe to toe with a custom binary format. I'm totally willing to pay 8% for the benefits of JSON. And hence, the birth of rust-lzma. I can slap an `LZMAWriter` on to a `File` to write compressed JSON out, and then `LZMAReader` on a `File` to read it back in. And the resulting files can be opened with `xz` or other archive managers for debugging/editing. Easy and wonderful.
In my opinion, Rust is 100% not a beginners language, and should not be taught to beginner's. Python, java, and perhaps JavaScript are much better alternatives. Why do you think Rust is a good option for absolute beginners?
Continuing to work on Vulkan stuff based on whatever information is available (the talks, the various articles, the SPIR-V specs, the Mantle specs, DX12, etc.). I'm trying to design an API that matches Vulkan concepts (especially descriptor sets and memory management, which we know a lot about), except with template parameters for compile-time checks. And in parallel I write an example code where I try to use that API and see if it's not too bloated. Technically you can do metaprogramming with Rust types, with things like `DescriptorSet&lt;((Image&lt;2D, R8, Multisample&gt;, Buffer&lt;[f32]&gt;), Image&lt;1DArray, R8G8B8, NotMultisample&gt;)&gt;` for example. However it's not necessarily a good idea, as it must not be too hard or too confusing to use. 
Let me take the `Into` trait as an example, though I'm fully aware there are other practical alternatives to do the same with the following toy examples, such as the `From` trait. I want to define a `String` variable `s` from a literal with a help from the `Into` trait. Repeat, I want to define a `String` variable `s` with the `Into` trait. This is a bit lengthy: let s = &lt;_ as Into&lt;String&gt;&gt;::into("abc"); This is fine, let s: String = "abc".into(); but I like the resulting type to be at the right hand side of the `let` definition. This looks OK to eyes of a C++ programmer, but not really correct: let s = "abc".into::&lt;String&gt;(); because the `into()` method is not parametric under a given trait implementation and takes zero type parameters. Are there any nice (UFCS?) ways to do so?
Thanks for a suggestion, but I'm aware of the `From` trait as I already wrote in my original post. I'm interested in how to fix a type parameter of the return type of a "static" trait function.
A lot of Python is straightforward, and has good error messages. Java also has the same reputation. I do not believe that C++ is a beginners language, but I mean if you think that it could work, go for it, but I'm pretty sure you (the person you are teaching) will be the guinea pig in this experiment. 
That pretty much answers my question, thank you. (`match` is natural for what I'm writing but its current state makes it unusable. If no one has a vague idea of when MIR is landing, then it's not any time soon so I'm better-off pretending `match` doesn't exist.)
I am trying to figure out [PhantomData](https://doc.rust-lang.org/std/marker/struct.PhantomData.html), it sounds so **mysterious**.
This doesn't change anything about the `Error` trait. It's syntax sugar for where you would have used `try!` before. Here's some info about `Error`: https://doc.rust-lang.org/book/error-handling.html#the-error-trait and https://doc.rust-lang.org/book/error-handling.html#advice-for-library-writers
Github has actively removed content for political reasons in the past
The really basic concepts like conditions, loops, functions, variables, etc are more or less the same in all languages including Rust so once you grasp that, you get to the stuff that sets Rust appart from other languages. Also wether you switch from a GC'd language to Rust or start from nothing you will need to learn stack, heap, pointers, etc anyway. So yea I think it's possible and maybe not even a bad idea to learn Rust as a first language, you will need to understand more concepts in comparison to simpler languages but it's certainly possible imo.
Your only goal should not be to learn Rust, your goal should be to learn how to program, and I believe that learning to program, using Rust as a teaching language, it would be very difficult. If you want to learn to program, start at a good teaching language, like Python or Java (in my opinion). 
No, the neutrality I mean is more of a big statement/guarantee : &gt;No project will ever be removed from this site due to political/social reasons. (of course porn/illegal files don't belong in code hosting; and threats are illegal) The political stance of your hosting plays into the technical merits insofar that you might end up losing your code if folks don't like your politics. What if during the Eich incident git-hub would have decided to hold any MOZ code there hostage? Or what if they decide something is too privileged and micro aggressive and delete it? Source hosting must be reliable and those risks cast shadows on reliability imho. Now I'm not saying they will start pulling code based on political things, but I think it might be wise to have a plan B. Maybe this sort of similar situation will shed light on what I mean. http://wonko.com/post/jsmin-isnt-welcome-on-google-code Looking past the obvious part that this person had to find new hosting because google didn't like the license; we see what uncertainties a simple "do no evil" non-neutral statement causes to the end user WRT to being in compliance. Of course if Github had some promise to not remove code based on disagreeing with political/social views that would ease my slight worry somewhat.
This video is hilarious, because it's just everyone stomping on Go, as politely as possible. I guess that's why you don't bring garbage collection to a native programming fight.
Do you have a sense of performance? I.e.: How does compile speed compare to other Scheme implementations? How does it compare in terms of macro expansion speed? Do you also intend to go all the way, compiling byte-code into executable code?
Or start with great learning language with even greater book and use Scheme. 
It's a shame we can't get the person who wrote TRPL to help with this. :troll:
For details: http://blog.rust-lang.org/2014/10/30/Stability.html TL;DR: If you download the stable version of the compiler, upgrading should be basically painless. We reserve the right to break things for soundness fixes, but we take compatibility very seriously.
So generally I should go with option B? Could you give me some examples for what would qualify as cheap? Would it just be structs with &lt; # of fields?
When I mean performance I mean more the quality of the algorithm - in terms of efficiency / runtime, it's quite good. Given the same parameters it runs &gt; 10x as fast as the Python code. But the Python code arrives at a higher quality path, given the same number of iterations as my code. &gt; The constants you define at the start should be const, not static (does not make much of a difference, but more idiomatic unless you need to mutate them) Good to know! I've moved them all into a per-population builder actually, so it's a moot point. &gt; I'm pretty sure calculate_distance could just return distance_squared, which will give some performance improvements Sorry, what do you mean?
&gt; Sorry, what do you mean? Calculating the square root is a very expensive operation (as you probably know). Since in your algorithm, you are not really interested in the actual distances between the points, but only use them to compare them to other distances, you can get rid of the call to `.sqrt()` and only return the squared distance. Right now, your function looks like this: fn calculate_distance(&amp;self, p: &amp;Point) -&gt; i64 { let x_dist = (self.0 - p.0).abs() as f64; let y_dist = (self.1 - p.1).abs() as f64; let t: f64 = (x_dist * x_dist) + (y_dist * y_dist); t.sqrt().floor() as i64 } While you could implement it like this: fn calculate_distance_squared(&amp;self, p: &amp;Point) -&gt; i64 { let x_dist = (self.0 - p.0).abs() as f64; let y_dist = (self.1 - p.1).abs() as f64; ((x_dist * x_dist) + (y_dist * y_dist)).floor() as i64 } Since `calculate_distance` is called pretty often, I believe this could gain some performance. Edit: Again, this is just about runtime performance, not computational performance. I can't really dive deeper into your algorithm right now.
Oh, yes. I had it that way earlier on but I decided to do it this way just to make things easier to compare to the methods in dailyprogramming topic. The as f64's can also be dropped in that case.
/r/playrust
My bad, thank you
You asked for comments on the whole idea, so below is some big-picture thinking on how to maximize this page's "matchmaking" potential. Here are a few things that, were I looking for a new project to contribute to, would influence my decision, and therefore would be information I would want to know when choosing which project to contribute to. **Most important: How active is the project (for its scope)** Let's imagine a spectrum that begins at: * Contributing to a project where you know you can just stop, and your contributions will continue to benefit others for months to years. You have very little creative control in how larger problems are solved, but you can also choose to work on just the available tasks of the project that interest you. to: * forking a project, or being handed ownership of it or a giant section of it by an owner who no longer has time to work on it. You have essentially total creative control, but also have to do many tasks which don't interest you as much for your work to be useful, and without a lot of active, continued development and maintenance from you, the chances of your work ever being used drop greatly. The scope of the project is also helpful to have here. A project with five developers is likely to look a lot like scenario one if it is a simple device driver, and likely to feel a lot more like scenario two if it is a 3D modeling suite. **What kind of development would I be doing?** I think we can neatly divide this into four categories, from how much a new coder with lots of free time would like it, to how much a busy but experienced professional in the same field as the project might like it. 1. new development on a codebase with an easy/variety of difficulty levels 2. maintenance on a project like that 3. new development on a codebase with a relatively specialized, high skill/knowledge bar. (e.g. mathematics, statistics) 4. maintenance on a project like that. When I say "High skill bar" projects, I'm including those that can find tasks for those without specialized knowledge on the periphery. Some prefer that periphery ecosystem work like writing user guides or developing the project website, and in a high-skillbar project that kind of work is appreciated most. Others are more interested in implementation and would like a project where they know they will be able to get started doing that within a couple days. **How big is the project's userbase?** For some projects this is something people will care about, for others they will not (just one example, if it is the only project of its kind for a particular niche purpose) Popularity could be measured in terms of cargo downloads, github stars, google trends, whatever. **what license is the project?** Many people today do not care about this, but there are still many who do. Specifically, there are some people who are not interested in contributing to GPL-like licensed projects, and others who are only interested in contributing to GPL-like licensed projects. Some are not interested in licenses where forking the project can be encumbered by software patent liability.
Kinda sucks that you have to allocate to use this. Pity there's no `&amp;str` &amp;rightarrow; `Result&lt;Cow&lt;CStr&gt;, _&gt;` in the std lib... **Edit**: Also, you should probably use `Result&lt;(), _&gt;` as the return type from `pledge` so people are less likely to forget to check it.
You can use the `Drop` trait to create a scope guard and implement "finally" as a library. There used to be a `finally` module in `std` that did just that, but it was deprecated and turned into the [`finally` crate on crates.io](https://crates.io/crates/finally). It seems to me that one could do [a simpler version](http://is.gd/WVmBE6), but perhaps there are issues with it that I'm not thinking of? Besides that it's ugly to have to put the "finally" _before_ the code that it runs _after_ I mean...
Good points. Maybe a simple web crawler could be written that goes through list, github, crates.io and calculate some of mentioned metrics.
&gt; sevens.sort(); let (mut count, mut prev, mut counts) = (0, 0, vec![0u16; sevens.len()]); if !sevens.is_empty() { prev = sevens[0]; counts[0] = 3 } for i in 1..sevens.len() { if prev != sevens[i] { count += 1; prev = sevens[i]; sevens[count] = prev; } counts[count] += 3; } I was wondering what the performance characteristics of something like [this] would be, in relation to bounds check elision. Assuming, of course, that it's a safe abstraction and I haven't missed anything. [this]: https://play.rust-lang.org/?gist=0d0f4232cb929a184801&amp;version=stable
moving does a shallow copy of the data, same as what happens when you copy a `Copy` type.
I decided to throw caution to the wind and upload the GBA emulator-in-progress I mentioned in the last what's-everyone-working-on thread to [Github](https://github.com/Ketsuban/rustboyadvance). Happy now, /u/yupferris? :P
I don't quite follow what you're saying, plus the formatting error. If you wouldn't mind cloning the pastebin link?
I wouldn't learn Rust as first language. My journey was C# -&gt; Java -&gt; C/C++ -&gt; Various other languages including Rust. I would advise you to start in language like C#/Jva/Python that provide certain guarantees and allow you to focus on basic concepts instead of throwing all that complexity on you immidiately. Then learning C to better understand what hardware is doing Or jumping into Rust will build upon your experience with basic concepts and further your understanding why/how certain things are done. My 0.02$
Back from holidays, back into business! I'm advancing again on wayland. Just fixed [a nasty macro issue](https://github.com/vberger/dlib/issues/3) and [integrated the support of wayland protocol extensions](https://github.com/vberger/wayland-client-rs#wayland-protocols) (behind cargo features). Next step is the server part of the API! Apart from this, I'm starting to fiddle around [Matrix.org](http://matrix.org/)-related rust projects, like [pto](https://github.com/tdfischer/pto) and [Ruma](https://github.com/ruma)
Yeah; you can go at this both ways: Do almost all of a big feature yourself, and leave some peripherals as a easy bug. Or, do all the heavy lifting for a big feature, writing some utility APIs and designing it in full, explain the design to the new user, and it _becomes_ an easy bug.
http://m.imgur.com/a/CMRVq Whether or not you agree with gamergate, that repository was literally just listing public email addresses for advertisers of the games media they are against, nothing else. They also have removed a WebM converter library for having the word retard in its description
That's good to hear! I really should take a bit of time out to watch the actual talk. I've only read [the followup blog post](http://blog.paralleluniverse.co/2015/08/07/scoped-continuations/) and it made quite an impression on me.
Depends on the situation. In this case, it should though. 
``` impl Drop for Bass { } ```
Well, but not being able to commit or publish is different from not being able to install things. Github is an unreliable static file host, especially once you start doing many requests and the rate limit hits.
&gt; Of course if Github had some promise to not remove code based on disagreeing with political/social views that would ease my slight worry somewhat. This is getting meta, but the discussion of what qualifies as political/social is a political/social discussion.
Actually (feature-gated) [type ascription](https://github.com/rust-lang/rust/pull/30184) allows us to write let s = "abc".into() : String; This is awesome.
A little bit off-topic: The design of the `sidebar-nav` and the `slide-menu` which shows up when clicking the home burger button is nice. But a scroll bar appears between the two. This scroll bar breaks the continuity of the background colors of the two elements which is not nice. I possible workaround is to switch the scroll bar position to the left by creating an extra div inside `slide-menu` and switching the direction property twice: .slide-menu { direction: rtl; } .slide-menu &gt; div { direction: ltr; } Edit: I noticed that by doing so, the code that hides/shows the `slide-menu` will break. It should be changed accordingly.
aha, gotcha.
Nom looks neat. Since it has macros, it tends to replace a grammar description language. Thanks!
Exactly.
Now that [RustType](https://github.com/dylanede/rusttype) is in a limited-but-useful state, I'm working on implementing a GPU glyph cache. I initially said this was going to be a separate library, but I think it would make sense to keep it in a module in RustType (at least for the time being), with separate crates for graphics backends (e.g. gfx &amp; glium). I am of course still tweaking RustType based on the feedback from the initial release.
&gt; But yes, that allocation for the promises string probably doesn't hurt too much? I'm guessing rust cleans up once it goes out of scope, at least I couldn't find any proper way to do that manually. It's not a question of having to clean up afterwards; it's having to make a heap allocation for a literal string under all circumstances. It's not a deal-breaker, it's just unfortunate.
LLVM can do all kinds of things, including "SROA" = taking the hammer to the struct and splitting it into its component fields, tracking which fields update instead of the struct as a whole.
Good call. Linus Torvalds and how he runs the Linux kernel is the [infamous example](http://arstechnica.com/information-technology/2013/07/linus-torvalds-defends-his-right-to-shame-linux-kernel-developers/) of someone who prefers a lower sensitivity. Other than that, I doubt you're going to see many good examples of it. If you're such a person, you'd probably not going to start contributing to a project if it has a CoC that you know you're going to have a problem with. I e, I think the effect might be there without you noticing it, but this is more of a gut feeling than actual evidence, so take it with a grain of salt.
If github's role in rust is "too big to fail" that's reason itself to work on a backup plan. It should be push-button ready *before* any real action needs to be taken.
* You can remove a redundant collect / allocation and do [this](https://github.com/justinas/gettext/blob/8df37852db8a8e08fd1889d58c45325676b26bc6/src/parser.rs#L132-L139) in one step by using `.collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()`. * I usually joke that we pass down the knowledge of the collect-result trick by oral tradition. Which is kind of true, even if you could discover it from the docs too. * You can look up into the hashmap using a `&amp;str` directly, you should not need .to_owned() [here](https://github.com/justinas/gettext/blob/76db7a23e1c9af3ec5cd85ec23a8d198b6bc13bd/src/lib.rs#L124) (same in both gettext and ngettext). 
&gt; Also, you should probably use `Result&lt;(), _&gt;` as the return type from pledge so people are less likely to forget to check it. I haven't figured out this part yet. I'm new with rust.
Thanks for putting this together! I'm at a point now where I could really do with some more different viewpoints on my project - I'm sure this will help with that greatly!
&gt; Which is kind of true, even if you could discover it from the docs too. I put it as the last example in `collect`'s docs! http://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect
Thanks! All this time I thought the borrowing happened on the lookup key. :)
I'd like thank you for your explanations, and appreciate your explanations from you and others here. This community has really detailed answers, and this is one of the most knowledgable forums I've seen, while still being extremely friendly to those learning.
QUOTE replaces '. BACKQUOTE replaces `. UNQUOTE replaces ,. Also hello over from /r/lisp!
You can use [rust-phf](https://github.com/sfackler/rust-phf) to build your hash table at compile time, with no heap allocations. Requires either a compiler plugin (nightly only) or code generation using a build.rs script.
Why not have a README.md for commit history?
[rust-phf](https://github.com/sfackler/rust-phf) is brilliant, thank you!
That has just changed https://github.com/rust-lang/rust/pull/31333
You would need to implement PartialOrd and Ord manually, instead of deriving them
Yeah, thanks a bunch, nasa42! In fact I enjoy reading TWiR so much that I help out where I can.
The derived comparison code is based on the order of the variants. You can make your assertion pass if you swap their order: #[derive(Eq, Ord, PartialEq, PartialOrd)] enum Either { Numeric(u64), Alpha(String), } [Playground link](http://is.gd/HcmDZd)
Can't you just make the stack grow so much it blows past the guard page and still get a segfault?
This worked perfectly, thanks! Do you know if there is something in the rust docs that explains why this works?
This means that **ANY** `Numeric` will be smaller than **ANY** `Alpha` though. Is this what you want?
It can still segfault in some cases, it seems. fn main() { let huge = [0u8; 25_000_000]; } That program causes `Segmentation fault (core dumped)` with `rustc 1.8.0-nightly (75271d8f1 2016-02-09)`. I don't know if it's even possible to avoid segfaulting in this case without introducing undesirable runtime checks, but it's still a segfault nonetheless.
Yes, this is what your sibling has pointed out as well.
At least for now it's a publicly editable wiki only.
Props for actually writing the code, though.
Rust is extremely well suited for crypto-tech space, combining performance with reliability. No wonder we got Bitcoin support early: https://github.com/apoelstra/rust-bitcoin/, then Maidsafe started using it https://github.com/maidsafe/crust, now Ethereum. 
Ok, then /u/mbrubeck's solution will do fine. &gt; Do you know if there is something in the rust docs that explains why this works? I don't know if there is, but it's basically this: If you `derive` `Ord` on an enum, the Rust compiler just takes the order of the possible variations and uses that internally. This is similar to how it works in C, where by default enum values correspond to 0, 1, 2...
This looks really cool. Are there any plans to break `ethcore_util` into separate crates? Most of the modules in there look like generally useful things that could be published separately on crates.io. Hopefully under a more permissive license, but either way they seem like great additions to the crate ecosystem.
&gt; Fair warning: the code is a complete mess in most places, and an unmitigated disaster in others When I look back at my code from a couple months/years ago, it's usually my impression. And yet I was so proud when I wrote it ;)
I finally got my [query language for TOML working](https://github.com/matthiasbeyer/imag/pull/149). The idea is: you query something from a toml value by a DSLish string: `"foo.bar.15"` queries in the first set the key "foo", the value should be another set were we access "bar" and then we expect an array and access index 15. If something fails in between because the types are not appropriate or because there is no value there, my implementation returns `Err()`. If everything works, I return `Ok(Some(&amp;mut value))` internally and I expose some interfaces to access this value in mutable and non-mutable ways. [Of course I submitted a (WIP) PR upstream](https://github.com/alexcrichton/toml-rs/pull/86)! All this was introduced for my project ["imag"](https://github.com/matthiasbeyer/imag) - a Personal Information Management suite for the terminal, which seperated into lib (features) and bin (cli) crates, so it is both extensible and reusable (LGPLv2.1). I plan to integrate a lot of PIM tools and I want to be as permissive as possible when it comes to external tools, so I do not want to replace your {newsreader, email client, editor, music organizer, foo bar baz } if possible. --- Besides that I'm in my exams phase at university and I really should learn for my exams, though Rust is just too cool and really distracts me. Shame on you language developers! 
Also Pony -- GC'd but per-actor, so very lightweight if you spread the load over many actors. Seems like a good compromise between "OMG now we have to invest man-years in an industrial-strength GC" and Rust's approach. Also good considering a NUMA-style future.
I plan on changing the API for [rustyard](https://github.com/simon-whitehead/rust-yard) significantly. Firstly, I will return nicer errors (not just strings), but also remove the need for an instance per calculation. Instead, the `calculate` method will accept an expression, allowing a single `ShuntingYard` instance to calculate a result as many times as it wants.
I want to know more about this, if you are keeping a tally!
Hah, I now see that work was cited in the blog post, so you're already well aware :)
Microsoft has spent more on experimental OS research than any other commercial entity I know. I'd call that the opposite of being worried about quick bucks.
Yeah, I at least tried rustfmt without the fancy real-time editor integrations, and it didn't play too nicely with the enormous stream-friendly font size I have to have haha. But I didn't try very hard to configure it etc. Hard to justify spending time on that tbh :)
Which in turn is allegedly equiexpressive to algebraic effects... and then there's the allegation that the continuation monad is "the mother of all monads". Seems like all of these might be saying the same thing. Aware, but as yet unenlightened. Understanding the concepts, differences, and relationships between the control-flow zoo of coroutines, continuations, delimited continuations, monads, yield, generators, algebraic effects, exceptions, setjmp/longjmp, async/await, threads, fibers, actors (and also Futures, IVars, Events, and Behaviors) is somewhere up there on my to-do list. But delimited continuations feel like the key. One of those maddening concepts I regularly encounter but still haven't gotten around to grokking. But earlier today, I opened 12 tabs. Thanks for the 13th. =)
Would it be doable to use [guile](https://gnu.org/software/guile/) for that kind of extension ? Guile is a dialect of scheme lisp, it is "the extension language of the gnu project" and it has bindings for C, C++ and Lua. Or rather: was it really easier to write Ketos than it would be to write a binding for Guile ?
Rust is sort of the polar opposite of smalltalk: instead of "extreme late binding of all things", we try to bind extremely early. You can still do dynamic dispatch, but you cannot do message passing in the Smalltalk/Ruby sense. I mean, in a certain sense, you could implement your own object system in Rust, and then use it in your Rust program... but that's a far cry from the language directly supporting it.
&gt; As much as possible of our software, including our Parity product line, will be made fully open under the popular Free software licence GNU GPL, exactly the same as the Linux kernel on which we expect Parity to run[...] It's not exactly the same, the Linux kernel is under GPL v2 and you're under GPL v3. I was going to prefix this by saying I was nit-picking, but since you used the word "exactly", I feel that your statement is wrong. (I don't have a preference for what license your project is under. I'm just pointing out an inconsistency.) Edit: I originally claimed you misspelled license, but then I googled to double check myself, and apparently that is a valid spelling in some contexts. I only noticed because my browser complained about it anyway.
What he is asking is this: http://ruby-doc.org/core-2.3.0/Object.html#method-i-send and objc_msgSend from Obj-C. Which is not supported. 
Rust doesn't even know about types in run-time because of type erasure.
I see now, thanks.
Yes, Microsoft is probably the exception here, but I am not so sure about cancelling the Xerox PARC projects after the failure to go commercial, closing the DEC research lab and similar activities. Hence why I generalized my complaint.
Just as a heads-up, sometimes `cargo run` doesn't exactly work as intended due to the way in which it runs the binary [as a subprocess](https://github.com/BurntSushi/chan-signal/issues/5). In my rustendo64 fork I added a handler to drop into the interactive debugger REPL on Ctrl-C, and that doesn't work with `cargo run` since it closes stdin and the REPL can't read lines anymore.
Isn't that because of the missing stack probes? Because if the stack probes were working right, it would SEGV on the guard page itself before trying to fill in the zeros and accessing past it.
I don't know enough about Pony to comment on the particular example, but if you survey the literature, most of the interest in capabilities and permissions is for functional correctness rather than memory safety or performance.
This is painful to watch. The Go developer and the C++ developer both questioning their choice and it feels like both of them actually want to be Rust developers &gt;.&lt;
I checked it out, but it requires mutexes, which aren't available in a `no_std` context. Good point, though. I'll try to see if I can create a version that doesn't use mutexes.
Nice! Rust really is perfect for this kind of thing. Now that this is available I might look into it for enforcing some types of contracts at work. Thanks! 
Ethereum spam is coming! Secure your inboxes! Jokes aside, it's nice to see big projects being rewritten in Rust. Last week was a blockchain parser, today Ethereum.
&gt; I looked into making it a `static UnsafeCell&lt;Option&lt;T&gt;&gt;`... And then what? Every time I want to use the inner value, i have to `forget` it so that the destructors don't run? You don't need to take ownership of the value when you access the global. `UnsafeCell::get` returns a `*mut T`, which you can dereference to access the `T` without moving it into the local scope where its destructor would be run.
(Edit: Bad Idea) Idea: Clone `lazy_static` locally and add a `#![no_std]` to `lib.rs`. It still compiles fine so I assume it works.
I don't know how ready Rust would be for UI-heavy applications. I've never seen a GUI app written in Rust. I think Rust is mature enough for a Docker clone, but unfortunately that's not an application that really plays to its strengths. Users of Docker don't necessarily expect low latency, or higher performance than what's achievable in idiomatic Go. I think Rust might be mature enough for a limited debugger, but gdb is completely insane. I think it runs on a dozen different architectures... Which is something that Rust doesn't do right now.
Rust does support rudimentary reflection with the Any trait, but you'll have to build a lot of that yourself.
yeah but you can allocate more than the guard page
Wow, if you need some exciting buzzwords for your next press release, you can borrow some from them: &gt; Founder Dr believe believe believe empowerment help faster better cheaper best technology best blockchains new venture first global over $200m Dr Co-designer Inventor Dr Co-founder, Provenance Dr Head CEO trail-blazing startups global industry leaders help unleash immense potential key verticals energy Exciting New Release trailblazing proud flagship fully compliant from the ground up open standards cutting-edge technologies best practices unsurpassed in-house expertise low-footprint high-performance ultra-reliable developer-friendly secure modular usher in optimizations more relevant aggressive position Free software open standards fully open Free software GNU GPL everyone to benefit success vision
Yes, to clarify, I'm asking about _implementing_ a debugger. In general, I'm wondering which apps commonly implemented in C or C++ would Rust be a homerun for. Not merely suitable ... I know Rust is suitable for low level programming. But what areas align well with Rust's strengths such that implementing them in Rust would be a significant advantage?
Is there any way to have a struct encode into name/value string pairs? So, I'm dealing with a JSON API that looks like the following: { "parameter": [{"name":"id", "value":"123"}, {"name":"verbosity", "value":"high"}]} (it's jenkins, sadly, by the way) So to get this to encode I have something like: #[derive(RustcEncodable)] struct Parameter { name: String, value: String } #[derive(RustcEncodable)] struct JenkinsBuild { parameter: Vec&lt;Parameter&gt; } Which works, though it kinda sucks. Is there any way I could set this up so that instead, I had something like: #[derive(RustcEncodable)] struct JobParameters { id: String, verbosity: String } And that would encode into {"name":"id","value":&lt;id&gt;}, etc?
The GTK bindings in rust aren't worse than doing it in C. AFAIK binding Rust to Qt has problems because of C++ iter-op. I'm not sure however why there are not more GUI programs out for rust. Maybe I should put up a few examples in GTK... 
If you know it's not going to be accessed concurrently, you can eschew any kind of synchronization and just use `UnsafeCell&lt;Option&lt;Console&gt;&gt;`. If you're going to be using threading at all then atomics are better than data races. I wouldn't worry about the speed of atomics, though. They're pretty damn fast, especially with low contention. Where's the documentation for the static variable? You might be able to just interpret it as a `#[repr(C)]` struct and access it directly.
There's `const fn` in nightly Rusts. But yes, definite pain point.
Ah that makes perfect sense - thanks!
Small capitalization typo: "we as a community" should be "We as a community".
Actually, Hash is already implemented for references to all types that implement Hash! However, if you're trying to hash by address, you'll need to create a wrapper struct and implement Hash yourself on that.
Please see rules 1, 2, 4, and 5. (hey, y'all are so nice I rarely get to use the "distinguish" button on reddit; better use it here)
Yes the hash has to be by address as a `State` is a node in the graph and can only be identified by its address. Thanks for the wrapper solution. I am surprised that rust doesn't have a simpler way to do this simple task though.
Fixed, thanks.
Interesting read, thank you. As ever, question involving humans are much more tricky than programming problems. Maybe Rust should be developed by a robot army? =P
[It is](http://edunham.github.io/rust-org-stats/) See also: https://www.youtube.com/watch?v=dIageYT0Vgg
In general, the answer is the same for many different kinds of projects - the language is great and the libraries are getting there.
You're a hero, Graydon
[lithos](https://github.com/tailhook/lithos) is not a docker clone, but uses the same underlying technology (cgroups &amp; namespaces). Low-level support for building a debugger (ptrace syscall) is also there, but I haven't seen anything related to disassembly in native rust. It would be possible to use [capstone](https://crates.io/crates/capstone).
That's also in boolinator: `bool::as_option()`. It could get compiled to the same code if LLVM optimizes away the additional step.
&gt; My problem when it comes (hypothetically speaking) to that is when someone starts blaming the person instead of blaming the mood. Can you speak in concrete examples? I see a lot of people speaking hypothetically about that, but rarely in concretes. &gt; There is no way to prove that anyone agreed with the CoC (because its written down) so there is no way to prove that the CoC is entirely correct and agreed upon at all times. So there is simply no way to take a CoC seriously, even if everyone took the CoC seriously. You don't need to agree to the CoC. This subreddit, all rust-lang properties and many meetups have a moderation team running the show. They are the caretakers. They are the people providing _you_ with a service. They made the effort of writing their rules down for you and they can (and will) enforce them whether you agree or not. It's actually a Reddit feature and used as intended. You also don't agree to "don't insult the owner and other guests" before entering a restaurant. They will nevertheless kick you out if you do.
Refusing to read the code of conduct is an odd stance to take. I'm not sure what your point was there. Anyway, it's very short and quite reasonable; I'd suggest reading it, at least if you're going to discuss it.
Type erasure is generally used as opposed to type reification for generics, and Rust uses type reification. A more commonly understood way to say it is that Rust doesn't have implicit RunTime Type Information (RTTI).
*"mildly"?!*
What's up with the PU rule? &gt; 8. Quadruple Parallel Universes?
First of all, do not follow my advice if you installed multirust with some package manager. Here is a list of files, that multirust has on my system: /usr/bin/cargo /usr/bin/multirust /usr/bin/multirustproxy /usr/bin/rust-gdb /usr/bin/rustc /usr/bin/rustdoc /usr/bin/rustup.sh /usr/lib/rustlib/components /usr/lib/rustlib/install.log /usr/lib/rustlib/manifest-multirust /usr/lib/rustlib/rust-installer-version /usr/lib/rustlib/uninstall.sh If you installed it locally into you home directory, these files might be in `~/.local/{bin,lib}`. Delete all of them. Additionally, remove `~/.multirust`. You might want to backup `~/.multirust/overrides` first and restore it later. That should remove all traces of multirust on your system. 
IIRC Dropbox is also using Rust for an internal project. EDIT: https://www.reddit.com/r/programming/comments/374mre/we_just_switched_from_rust_to_nim_for_a_very/crk48jw
Disdainful betrayal! For it was you who made me a mod! :-D Full disclosure: Yes, I am a mod of the subreddit (and others) – to allow me to sticky the weekly "what's everyone doing" posts. I am unsure if that actually makes me part of the mod team, though.
&gt; "DO NOT specify a workload in the config in-combination with the following on the command line: &gt; • method • rate • bytes" Seems to me like that should be fixed, and not documented...
Thank you for your thoughtful reply. * Re: "be excellent to each other": You are right. I'll change the wording. * Re: Chilling effects: Of course this goes both ways (as does the "grow up" argument, which I included). Still this is the part of the argument against a CoC that I find relatively most convincing – who's to say that the mod team won't turn inquisition in the future? All it takes are a few sociopaths. Having met my share of them during my career, I can understand the reaction of those arguing from that angle. That doesn't make them right, but it also doesn't make them bad. * Re: Social Justice: While outside of Rust-land there are instances of the "speech control" you mention (like that brotli thing a few months ago) that seem strange from a distance, I find it hard to get riled up about. I for one fully agree with the Rust CoC and ask everyone at our meetups to uphold it. IMHO, trying to see those who fail to see its value (yet) as humans instead of [insert random insult here] is just part of it. Understanding where they come from and what shapes their thoughts may enable us to help them see the value after all.
...speaking of which, does Highfive exist "as a service", similar to Homu?
That's really no better than TFA's regular conditional: if bool { Some(T) } else { None }
Most likely a reference to this excellent piece of computer programming theory: https://www.youtube.com/watch?v=kpk2tdsPh0A&amp;feature=youtu.be
[Nothing, the mods just like to have fun with their CSS powers once in a while.](https://www.reddit.com/r/rust/comments/2xl9fa/meta_definitely_offtopic_what_does_the_bee_rule/cp13dgz)
Hi. This subreddit is for the Rust programming language. You want /r/playrust It's generally a good idea to see what an online community is about *before* posting. Blind posting doesn't tend to work well.
Using referential identity in Rust is, in my experience, a bit of a code smell. Lifetimes get tricky and objects get frozen in place (i.e. become unmoveable) as does any container of which they are part. Furthermore any kind of mutation is verboten in a graph structure like this. The reason this is problematic in Rust is the same reason doing this in C++ correctly is problematic: guaranteeing that `State*` is not dangling is (a) non-trivial and (b) brittle in the face of changes. The preferable solution in both langauges, in my opinion, is to use indices into an array. In Rust this would be: struct State { transitions: HashMap&lt;char, usize&gt;, } // Somewhere: states: Vec&lt;State&gt; Here's is a great article about this [in Rust](http://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/) and here is a great resource with the same advice [for C++](http://bitsquid.blogspot.co.uk/2011/09/managing-decoupling-part-4-id-lookup.html).
Yeah Rust's coc is pretty reasonable at the moment.
I just googled the broti thing...... That is moronic. It actually makes me want to give my projects harmless names like that so double fail.
I've seen this part in the videos and wondering if this is nicely doable in rust. hadn't much time to reason about since then. but i don't know how well this come out to prealloc all you memory and write your own allocator. never really did this in a serious project only for fun in toy projects in C – to scared to fuck things up :D ... What i do like about this, is saving expensive OS allocs. Is there something like a memorypool und custom allocators in rust, to save some OS allocs? EDIT:// totally missed that https://doc.rust-lang.org/book/custom-allocators.html https://github.com/koute/memory-pool to sad i've no time for that in the following weeks :(
Using a `const fn` on a static does not yield a static, as intuitive as that would be. 
&gt; Still this is the part of the argument against a CoC that I find relatively most convincing – who's to say that the mod team won't turn inquisition in the future? All it takes are a few sociopaths. Having met my share of them during my career, I can understand the reaction of those arguing from that angle. That doesn't make them right, but it also doesn't make them bad. The problem I see here is, this slippery slope assumes a level of malice of the moderators. If that would be the case, I can't see how not having a CoC would make the moderators behave better in that scenario. If one exists, the community can at least appeal to it. 
I would highly recommend installing multirust w/o using `sudo`. It can be installed in a user directory using git clone https://github.com/brson/multirust.git cd multirust mkdir ~/rustbase ./build.sh ./install.sh --prefix=~/rustbase see https://gist.github.com/seanjensengrey/07bb8ae5397a81d39321 for more instructions. The alternative if you are on a Mac is to use homebrew via: `brew install multirust`
I'm not sure. Sounds reasonable to me!
Every post about the game is (probably) by a new user... I think we should add a text "The Rust Programming Language" to the bottom of the logo in order for people to take notice before posting...
The mod team is as follows: https://www.rust-lang.org/team.html#Moderation But most aspects of the Rust community have additional local moderators. 
&gt; Maybe I should bias the strong to breed more? Yes, choosing which parent to breed is a important part part of genetic algorithm. Without that, GA is become nothing more than a fancy random search. There is a different method to select the parents. The most common is roulette wheel selection, I suggest you look at Tournament selection. The python code seem to use Truncation selection, which is, in general, a bad method. &gt; I couldn't really understand the python code crossover method to be honest. From what I understand, the python code to some sort of local optimisation while doing the crossover (that the "greedy" part of the algorithm). This make it converge to a local optimum fast. This lead to good result in a few iteration. When using a genetic algorithm (and most global black box optimization method), there is a trade-off between searching the solution space and optimizing what you have found. 
I managed to figure this out independently just now: let identifiers = "abc.123".split(".").map(|v| Identifier::from(v)).collect::&lt;Vec&lt;Identifier&gt;&gt;(); Is your version and mine two ways of doing the same thing, or is my version not accounting for something?
Possibly silly idea: you redirect stdout into a file descriptor that you also read and that reader code will rewrite everything using that special C function. Dunno if it would actually work with the Rust standard library.
You mean, if they haven't noticed the GIANT LOGO, the "The Rust Programming Language" box, the *content* of the subreddit or the following **on the submission page itself**: &gt; The Rust programming language. For the Rust video game, see /r/playrust &amp;nbsp; You can lead a horse to water, but you can't make it drink. Even *if* you shove its head into the water while screaming "drink you miserable bastard" over and over again, as you sob uncontrollably in frustration.
`from` only works for things with infallible conversions, while `parse` works for things that can fail. Your struct cannot fail, since any `str` can be put into the `Alpha` variant, so `from` is fine.
So you can foretell who the moderators will be a few years hence? Also my experience with sociopaths has been that they thrive on rules, the more the better. Please bear in mind that the argument, though often brought forth in rational tone, is an emotional one.
We used to have restrictions, but slowly removed all of them so that things can come in whatever order.
Yeah this looks good to me.
The CoC still asks you to dismiss the argument, not the person.
Interesting. Does not look like it requires a lot of safety, so it's nice too see, that someone also likes the other features. By looking at the code it seems that someone really loves match.
Why not a macro? macro_rules! some_if{ ($condition:expr,$some:expr) ==&gt; {{ match $condition{ true =&gt; Some($some), _ =&gt; None, } }} } #[test] fn test_it_works(){ let maybe= some_if!(true,"aha"); match maybe{ Ok(s)=&gt; assert!(s.eq("aha")), _ =&gt; assert!(false,"uuh") } } gist: https://gist.github.com/palad1/7a57408af2681db3cf82
Feel free to use mod powers on this subreddit for actual moderation :)
Because a malicious mod can then use a CoC as justification for "wrongful" punitive action. Without a CoC the mod has nothing to justify with, and should s/he perform such punitive action anyways they would probably be ousted as a mod either by official team or the community. With a CoC neither group can do anything about the "wrongful" action, because the mod is "clearly just following the CoC."
These are the only mandatory rules as far as I know: * [Shebang line](https://en.wikipedia.org/wiki/Shebang_%28Unix%29). If present, must be the first line of the crate. * Inner [attributes](http://doc.rust-lang.org/reference.html#attributes) (`#![...]`). Must come before any items in a module. This includes inner doc comments (`//!` or `/*!`) for the crate or mod. * `macro_rules` definitions and `#[macro_use]` imports. Must come before any code that uses the macros they define.
No thanks. I am very ambivalent about redditing in the first place, and about the disproportionate influence my words can have due to earlier activities in the project. No need to make matters there worse.
&gt; The Rust CoC has been in place since day one. [...] I wrote it before releasing any code, before even agreeing to work on such a project for Mozilla. Thanks. 
&gt; Maybe rustfmt will let us switch back to multiple lists. C++ clang-format can sort includes alphabetically into different categories (e.g. first std includes, then includes of 3rd party libs, then includes of the project, then local includes). Probably rust-fmt can be "taught" to automatically organize modules in a particular way.
Who is saying that the mod is "clearly just following the CoC"? If the official team members or the community have the power to remove moderators that abuse their power without a CoC, can't the same entities recognize the abuse and act appropriately when a CoC is there? It also presumes agreement that a punitive action was actually wrong. If there are no outlined processes, there is nothing to appeal to. Every action, wrong or right, could just lead to long discussions that don't change anything. What if the action wasn't wrong, but others want to get rid of the moderator that did right? It's not that I can't see the situation you outlined happening, I just doubt the helpfulness of not having a CoC if it does happens. And I think the value of the document outweighs the dangers. I'd like to think of it as this: When the leadership of a project (as a person or group) first proposes a CoC, that's them communicating "this is how we would act". If they wouldn't communicate that, they would probably use the same processes, just less transparent, without giving the community a chance to critique and help in shaping them, and probably much less consistent. Edit: Not sure why you're being downvoted. It was a clear outlining of a scenario involving a CoC. Disagreements about how effective it would be as a tool don't seem like a good reason.
I would find it amusing, personally, if his flair was "Graydon" ;)
I just wished that Rust had some facility for writing constant-time code (or even better, code whose runtime doesn't depend on secret data).
That's what I thought, yes (and you could probably insert runtime checks just to functions that call `alloca()` anyway, if you wanted to add support for it).
Devil's advocate: With 47 commits out of 48 by "brayniac" (a certain Brian Martin), it's difficult to conclude that Twitter is interested; it might very well be a single employee getting leave to use whatever he wants to create the tool. I do agree with your comment in general though, and for multiple reasons: - it validates the claim that a high-performance systems programming language (rivaling with C or C++) is needed - it bodes well for the future of the language, as Open Source projects thrive on contributors
Thank you for your advise! I hadn't thought of that, that's really useful. Adding a CONTRIBUTING file is next on my TODO list, and proper documentation is on my 1.0 roadmap... Unfortunately (as I've mentioned), I don't have a lot of time available to me to get everything done correctly. Do you happen to know of a checklist somewhere, of all the things that need to be done to make a great community? It would be great if I could add a tracking issue with things I can check off so I don't forget anything important (I imagine it would be really useful for other people's projects too).
Actually, I don't believe this is purely cosmetic. If you overflow your stack past a guard page and into another thread's stack or any other VM allocation, then you have memory unsafety. I don't see anything preventing this from happening in Rust.
You'll need to implement the [Encodable](https://doc.rust-lang.org/rustc-serialize/rustc_serialize/trait.Encodable.html) trait yourself. Something like this (not tested): impl Encodable for JobParameters { fn encode&lt;E: Encoder&gt;(&amp;mut self, e: &amp;mut E) -&gt; Result&lt;(), E::Error&gt; { e.emit_seq(2, |e| { e.emit_seq_elt(0, |e| e.emit_map(2, |e| { e.emit_map_elt_key(0, |e| "name".encode(e)); e.emit_map_elt_value(0, |e| "id".encode(e)); e.emit_map_elt_key(1, |e| "value".encode(e)); e.emit_map_elt_value(1, |e| self.id.encode(e)); })); e.emit_seq_elt(1, |e| e.emit_map(2, |e| { e.emit_map_elt_key(0, |e| "name".encode(e)); e.emit_map_elt_value(0, |e| "verbosity".encode(e)); e.emit_map_elt_key(1, |e| "value".encode(e)); e.emit_map_elt_value(1, |e| self.verbosity.encode(e)); })); }); } } 
Affine types aren't strong enough to encode state machines, because every state is treated as an accepting state. The work on session types uses unsound static analysis to find cases where linearity is violated, but the real solution is linear types.
Everyone can teach us something. Sometimes what they teach us is what not to do by example. Some provide actual innovations even while shooting themselves in the foot, after all; a unique foot shooting is still unique. Some projects provide the same!
&gt; because every state is treated as an accepting state That's a limitation, certainly; I hope for linear types (someday). Still, at the moment, one can helpfully: - use `#[must_use]`, though it does not guarantee consumption of course - implement `Drop` and call `abort` in it It's not as good as linear types, obviously, but it gets much closer than the other mainstream languages.
do you have a link to HH rust?
The change described only changes the error reported as far as I can tell (which is cosmetic). As pnkfelix mentioned to guard around "overshooting" the guard page a change in the "poking" algorithm is required to poke multiple times for large stack frames (at intervals fixed by the guard page size); this would solve unsafety.
To be clear, I'm not arguing against a CoC. I was simply stating one scenario in which a CoC could be wrongly used, in order to answer your question about the power of mod not being influenced with the presence of a CoC. Generally I agree with you, although I do believe it to more of a best case scenario which unfortunately isn't always the realistic world we live in. Yes, we'd like to think a mod wrongfully using a CoC would be outed just as if there wasn't one. But as can be seen from the many, many CoC debates around the Internet those who would seek to call out someone "abusing" the CoC (such as censorship, etc) are attacked as opposing the CoC outright. Like the OP, I like to think I straddle the line. I agree CoC is good in 99% of the circumstances, but I also like to think a community can be adult about certain situations which just aren't black and white obvious.
I already do ;-)
&gt; To be clear, I'm not arguing against a CoC. I was simply stating one scenario in which a CoC could be wrongly used, in order to answer your question. I get that, no worries. I just regard this subreddit as a little civil island where it's possible to discuss these things without it all getting too heated up. I usually stay out when these topics come up, so I got a bit more wordy. I agree that we're in general agreement :) I guess it's a question of probabilities of things developing a certain way. We might just have different experiences there, since I'm not worried at all about that part. It's not that I'm not worried about anything, just not that particular scenario. I won't comment on the other CoC debates. While I do read some of the discussions, as I said I try to stay out of them. There's often too much ugliness all around in those disagreements.
https://github.com/pcwalton/rust-media/ is a nice start here.
Well, I want to caution you against the "citation needed" form of derailing; you may not know you're doing it, but telling someone to do your homework for you is a characteristic tactic used in conversations that are "superficially reasonable" but actually aim to grind down the person being spoken to. It's a form of tar-pitting, using up a conversational opponent's resources while not actually listening. So I'm hesitant to spend a lot of time on this, and only going to respond once here, and only concerning gender since it's had the most press. You can follow the links / figure out how to use google better if you want to study further; I'm afraid given the context I'm not willing to have a lengthy discussion. Too likely it's in bad faith. That said, maybe try these: [FLOSSPOLS study](http://flosspols.org/deliverables/FLOSSPOLS-D17-Gender_Policy_Recommendations.pdf), [Assessing the Attack Threat due to IRC Channels](https://www.researchgate.net/publication/4243412_Assessing_the_Attack_Threat_due_to_IRC_Channels), [GeekFeminism - FLOSS](http://geekfeminism.wikia.com/wiki/FLOSS), [The rhetorical dynamics of gender harassment online](http://www.indiana.edu/~tisj/readers/full-text/15-3%20herring.pdf), [](http://ella.slis.indiana.edu/~herring/gender.power.pdf), [Free as in Sexist? Free culture and the gender gap](http://firstmonday.org/article/view/4291/3381) The latter First Monday essay, and the GeekFeminism page, have many outbound links to primary and secondary sources as well.
Note that you don't need the lambda, `.map(Identifier::from)` should work just fine. And I think you can collect to `Vec&lt;_&gt;` since the type of the internal object is known, but don't quote me on that. Also FWIW `.split('.')` might be more efficient than `.split(".")`: the former splits on a `char` so it just has to check if the current character is equal to `self`. The latter splits on a subsequence so it probably has slightly more work to do.
Check this out: https://doc.rust-lang.org/std/io/fn.stdin.html I always ask on /r/rust
Anything you'd like to see personally?
[removed]
&gt; the former splits on a char so it just has to check if the current character is equal to self. The latter splits on a subsequence so it probably has slightly more work to do. char vs string
Wow. What a wall of text ;-) Unfortunately, it's getting late here and I have to catch some sleep, so I will be brief: &gt; Sociopathic behaviour hardly needs a Code of Conduct through which to articulate itself. True. Still, the sociopaths I learned to know were *attracted* by organizations with rules. &gt;I ask, again, that you pause to reflect on and be more careful about terminology and assumptions. Ok, will do. I surely have worded that too strongly. Having been part of an organization where a few people ruined it for the rest by misusing the rules has probably made me sour on such endeavors. &gt; ou can write all the mocking cranky racist and sexist blogs you want on your own [...] I have no intention to do that. I just tried to summarize the arguments I found. &gt; ... before they turn their backs. Which they, like you, have every right to do. Full ack. Doing my part here. Thanks again for taking the time to explain your position so thoroughly.
it's used a *lot* in computer graphics and games. When your only concern is ordering and a transformation doesn't modify that....do you really need that transform?
There's a hidden, unstable function in `std::io` called [`set_print()`](http://doc.rust-lang.org/nightly/src/std/io/stdio.rs.html#585), which is used by ~~Cargo~~ the compiler-generated testing harness to redirect stdout for tests. It only changes the thread-local stdout handle, so you have to call it again in each thread you spawn that will be doing printing. You should consider this an implementation detail and subject to change without notice. Redirecting stdio streams is not an uncommon use-case so it'll probably get a more sane public API in the future.
It's totally possible to generate such stack probes. On Windows, rust already uses that feature. But unfortunately llvm doesn't support it for Linux right now... See https://github.com/rust-lang/rust/issues/16012
Also there is license issue. Guile is GPL licensed so it is impossible to use any kind of more permissive license, that is kind of issue for some of my work. 
Why have you included general purpose hashing functions (which are unsuitable for passwords hashing) but none of Password Hashing Competition competitors? Also I would return struct with overrided `Eq` and `PartialEq&lt;T: AsRef&lt;str&gt;&gt;`. That would make everything less error prone. 
Somehow I don't see the point. Your example does no sense to me and using it with iterator would be like `iter.map(File::open).filter(Result::ok)`. 
This explains some of the issues I've bumped into. Thanks!
Link to documentation gives me a 404. https://crates.fyi/crates/shared-mutex/0.2.0 This link does work: https://crates.fyi/crates/shared-mutex/0.1.0/ Version issue?
It should be fixed now, `crates.fyi` just takes a little bit to pick up new releases.
I believe the value returned by `.lock()` in both cases is a temporary (because it's not bound to any variable), so it will be dropped at the end of the current statement. In the first case, “the current statement” is the entire `if…else` expression. In the second case it is only the `let` statement.
I do the std/external/internal split as well, and I've always done this in other languages too. But now that I think about it, I don't really have a reason for it. Sure, it's easy to see which of those three categories an import is from, but why does it actually matter? I'm curious what your reasons were before you stopped doing it.
A code of conduct is not the word of law. If a moderator language-lawyers the CoC maliciously, it is something that would be obvious and oversight would catch it. Nor are moderators robots who will follow the CoC to the letter without recognizing exceptional cases. A CoC is not a carte-blanche to the moderators to do whatever they please provided it can be shown as fitting within the CoC.
&gt; If somebody is explicitly withdrawing from a conversation due to assumptions which you know to be incorrect, I'm not sure that's a sensible heuristic to apply. There are very few contexts in which someone is obliged to carry on a conversation, and this is certainly not one of them. Please respect that you do not have a right to other peoples' time and attention, even if you dislike the reason they give for not engaging with you. This is not a 'heuristic.'
I follow the same convention. Additionally, I adopted the Python one that separates the module's "prologue" (imports etc.) and the rest with two empty lines. This allows me to further subdivide the imports with one empty line in between.
Here's the thing. In heavily skewed communities (e.g. open source; which is gender-skewed amongst other things), the fact that you're "different" can be a real demotivator. Being constantly reminded of that is not helpful. That's why "dude" and "guys" are problematic; it reinforces the notion that "if you're not male you don't belong here". You may not _mean_ that when you say it; however for people who have had to fight prejudices to get where they are it will resonate with their experiences and make them feel that way. That's why it's best avoided. It's not being overly sensitive or self-centered here. Besides, saying "dude" is not something the code of conduct or the moderators deal with. You were not "called out", you were reminded. Referring to mixed-gender groups or unknown-gender individuals as male is a mistake many of us make, and a friendly reminder can help get rid of that habit. If you refuse to try and avoid this habit; it's your prerogative, though I wish that wouldn't be the case. 
Apologies for the verbosity. I type too much when I care about a topic and am in a hurry.
The only benefit I can think of is that it helps to know where to find the definitions of names that are being imported. In the local category, you know you can look from the root of the current crate. If they're mixed together, you have to compare against the list of extern crates first.
Actually, that's a strong signal that further conversation is unlikely to be productive, especially if you have to bug the other party to get it to happen.
Then, taking into account my earlier posts, you won't be surprised if I briefly respond: Of course it's fine for somebody to bring a conversation to an end. "Sorry, but I really don't want to talk about this any more, so I'm going to bail" is fine and polite. Even just not responding is a trivial (if slightly rude) way to achieve the same thing. The problem is when people abuse that power to silence people they disagree with and get the last word, which is an uncommonly dirty debate tactic. "I find your attitude disgusting. Obviously oranges are better than lemons. Are you wasting my time deliberately...? Either way, I'm not even going to talk to you any more, this conversation is over." You can scroll up in this comment thread to see /u/graydon2 attempting this tactic twice, which is partly what started this whole mess.
Fair point
&gt; `assert!(false,"should not reach this point");` Don't forget about `unreachable!()`
&gt; Re: Chilling effects: Of course this goes both ways (as does the "grow up" argument, which I included). Still this is the part of the argument against a CoC that I find relatively most convincing – who's to say that the mod team won't turn inquisition in the future? All it takes are a few sociopaths. Small pedantic aside here: you [probably meant psychopath](https://www.psychologytoday.com/blog/wicked-deeds/201401/how-tell-sociopath-psychopath), sociopaths are not manipulative, they are generally very impulsive and have very little self-restraint. Psychopaths are more like what you want. Most people don't note, but it confused me initially. So I agree that this is a danger, but I would ask: why would this not happen if there isn't a CoC? The thing is that I do see the weakness, what I do not see is the *causality*. If there wasn't an explicit CoC a small group of pyschopath could easily take over and do a lot of chaos. There isn't a single social system that can prevent this so it happens at every level, even national (ej. North Korea, ISIS). So we could add systems to moderate moderators, have a way for users to create a case against one moderator abusing their power. Then the other moderators could review the case and decide. This means that the better solution is to extend the CoC, not reduce it. Of course it could be the case that all moderators are corrupted. At that point though the system is completely collapsed. Open source gives you a simple solution: you can always fork. Notice though, that in order for sociopaths to gain control they'd have to slowly erode the system and replace the moderators, a drastic action would clearly and undoubtedly violate the CoC making it clear what is going on to everyone. Notice that even without a CoC, if the people regulating the community are corrupted in something that goes against the interests of the project, you're in the same situation CoC or not. A psychopath will always move things to his/her benefit. If there are no rules they'll promote chaos and infighting, many times for personal fun (trolling) other times to allow them to focus things against someone. Since there's no rules they can always change the argument against someone, and leave things implicit. A CoC helps *prevent* this by making things more specific and clear, creating an objective way to make an argument that someone is being detrimental to the community and explaining how it should best be solved. Can the CoC be misused? Of course, since you can't know the context and situation of every interaction there'll always be scenarios were the whole thing can get abused. But having no CoC is, in many ways, even worse as it lets anyone to manipulate people and make everything relative. Without any concrete reference point to make objective observations of at all, things could only be worse.
Ooh, sweet! Still, you need a server and stuff (easy for a large project, less useful for a small one), so having a "highfive service" that you can just hook up to github would be pretty awesome.
"free DO droplet" heh, I've had bad experiences with that DO droplets are harder to get when you're not in the US and don't have a credit card (debit won't work). Friends of mine (students, in India) have had a lot of trouble getting droplets, both free and paid for :) It's possible to get something from Amazon or whatever, but the free server credit runs out pretty quickly. Though this was a few years ago, I'm not sure how far you can get for free now.
Nobody is asking you to use or know about "xer" or anything else (there are accepted/well-established English substitutions for all common gendered statements). When someone is asking you not to use "guys", they are not assuming you should know something about that; they're just trying to ask yourself to try and change that habit, at least in that venue.
Yes.
I think a lot of the annoyance of manually doing this stuff would be to teach `rustfmt` how to sort these imports, so we can write however we want, and it will be fixed for us.
This seems really useful. Is there any plans to include it in the standard library in the future?
Awesome man! One critique though, you have your links mixed up :p.
Hi, OP here. Thanks everyone for the comments. The question I'm really grappling with is this -- what kind of problem domain really lines up extremely well with the current state of Rust right now? If you imagine a hypothetical developer who knows C, C++ and Rust equally well (say even 95th percentile as a programmer in all of those), what problems do you think Rust would be so well suited for (right now) that choosing Rust would be a big win?
&gt;However, on unix systems, this reader-writer lock (which is used in std::sync::RwLock) cannot be associated with a condition variable, which are limited to the native mutex (which is used in std::sync::Mutex). Meanwhile on Windows we have [`SleepConditionVariableSRW`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686304\(v=vs.85\).aspx), which oddly enough is what we already use for `Mutex` in the standard library because both `Mutex` and `RwLock` are implemented using SRWLocks on Windows.
You prompted me to actually read CoC in entirety so congrats. CoC seems fine. In my experience being an arse is only fun if you're the mouthy one. For everyone else it's just a barfy reminder of immaturity some circles have in this field. So adapt. My view is that it shouldn't be necessary to spell out the rules (because it implies that you have a problem to fix, when problems aren't part of you the moment they become problems), but apparently some people need to know the rules. 
Can you explain the joke to someone who's never used VB?
&gt; we have yet to ever do this I love Rust community, it's so much unlike the rest of Reddit. Quick tangent, I used to play Payday (the first one) - for a shooter game in which you rob banks the community was unstereotypically nice, unlike most other fps games. Even when you did poorly everyone was super nice and supportive. Rust reminds in how polite everyone was to each other even when they were being "noobs". It's super neat. :3
&gt; The change described only changes the error reported as far as I can tell (which is cosmetic). Forgive me as I'm not very knowledgeable in this area. SIGSEGV was raised by cpu and then was reraised by handler code, but now it just aborts. If in the stack overflowing code you accessed a valid page beyond the guard page wouldn't that constitute an unsafe access because the cpu wouldn't raise the exception?
Is there any way to run a Command such that the command thinks it's hooked directly up to a terminal (TTY) but without printing any output? I'm trying to run a command, capture its output, then later display that output to a terminal. The problem is that some commands automatically disable color printing when they're not connected to a terminal, but since I will be eventually displaying their output, I still want the color information.
&gt; Whoa, so there IS a difference between single and double quoted strings? Rust strings are double-quoted, single-quoted is a single char.
&gt; if they are feeling like that person is somehow harassing them The thing is that what causes people to "not fit in" is actually very rarely anything that the average person would call "harassment". What causes this tends to be indirect statements and assumptions that are non-inclusive of that person. Basically - as, I assume, a dude, you tend to be pretty welcome most places you'd want to be. Want to become a core contributor to that project over there? It's very likely nobody cares, and in the case that you don't say and you have a roughly genderless nickname, you'll be assumed to be a cis white straight guy, and use language and treat you accordingly. Outside of certain spaces, nobody's going to ask you which pronouns to use and use "they" otherwise. (Note that most projects do have informal chatter between people as a thing that you're expected to do sometimes, so it's not just a case of "don't refer to any of these things in the issue tracker".) But what if you're not a cis white straight guy? Well, you're suggesting that when people refer to you as such, it's not ok to politely correct them. If somebody said "your girlfriend", and you in fact had a boyfriend, would you be required to keep silent about that? I think you'd agree that that sucks and shouldn't be the case. But when it's about gender, shouldn't that be treated similarly? What if you feel that something is unintentionally slighting your race or the historical struggles that led to who you are in society, a la the master/slave database debate? And as a result, if people use language which assumes that everyone is of a certain type or has certain experiences - which is, for the record, *different* from actually assuming such - it can feel alienating. If everyone kept referring to the group as "girls", and what's more, this happened in every other group you joined, you'd eventually see an issue, and you'd very likely attempt to ensure that any spaces which do explicitly recognise your existence continue to do so. Pretending that oneself doesn't exist is exhausting. IME, the people who "get it worst" when politely corrected are the people who try to argue rather than say "oops, sorry, won't do that again", which is explicitly seeking further response.
I've been using DigitalOcean for a while now. I live in Europe, and I was able to deposit $5 via PayPal and get a $10 credit on sign-up.
Interesting! Thanks for the info, I'll bear that in mind when I get around to implementing a debugging interface.
To a large extent it is just "listen to people when they suggest you might be making people feel unwelcome". The CoC lists some ways in which you might make people feel unwelcome, and states that nobody owes you interaction.
i think for rustfmt a rustfmt.toml with follow content should be enough max_width = 80 ideal_width = 60 and for emacs i use [racer](https://github.com/phildawes/racer), [flycheck](https://github.com/flycheck/flycheck) and [company] (https://company-mode.github.io/). Flycheck runs everytime you save. Also i compile in emacs 'M-x compile' then you can just click on the warnig/error to jump to that line in code. and here a [screenshot](https://imgur.com/TxjHxGq).
As I understood, this is exactly what they have done. They used `Result` syntax (quite similar to rust) and tried both implementations: exceptions and return codes. And concluded that the first one is better.
I saw both of those recently too. I think I'd like to go with a more mainstream language, though. I don't expect many people to end up using this editor, but if by chance someone does, I think it would be nice if they didn't have to learn a new language to be able to customise it. This is why I was leaning towards Lua / Python as both are pretty widely used. Good idea about using both! I'll need to play around with it more I think, see how it fits together. I wonder, do you know of any existing RPC implementations in Rust? Need a nice example to look at so I can learn more about how it might work.
Well, for stuff that needs runtime initialization there are really just two alternatives: - Initialize it at program startup directly. - Initialize it lazily at first access. Both seem to be most easily accomplished by having a `static` of type `UnsafeCell&lt;Option&lt;T&gt;&gt;`. In either way, you can accessing the inner T without having to move it out, and with a bit more unsafe code can even avoid the pointless `None` checks that might involve.
Well, like I said, if you went for a bare bones TCP socket and let the plugins worry about how to encode their communication, you don't have to worry about RPC yourself. Having said that, if you want things to be easier for plugin authors you may want a higher level interface. Off the top of my head https://github.com/dwrensha/capnp-rpc-rust might be worth looking at, or maybe your script engine could provide a TCP interface plus an interface to a JSON library to help plugins encode their data.
Neither of the char split or str split implementations are optimized for this simple ASCII byte split. They could both be improved in fact.
Haha that's pretty far from my day-job of programming (soft) real-time industrial control systems but sounds like a fun change of pace :)
I like to think that I have curated my subscriptions well. :-) Also I see this "yay-wild-west-internet free-speech mindset" as an U.S. centric phenomenon – here in Germany we do things in a much more orderly manner.
PayPal is ... problematic in India, due to some various government rules. I'm not saying it isn't doable, just that there are hurdles.
I've been working with text processing a lot, and stemming is an example that frequently uses sizeable sets and maps for storing exceptions.
In general (assuming a proper hash function) I would imagine that if your hash map is large enough that it is unlikely that any given lookup hits the cache, and has enough entries that collisions are becoming a nuisance, you can simply increase the capacity of the hash map to bring the chance of collisions arbitrarily close to 0 without affecting performance much, so I doubt perfect hashing would make much of a difference in that case. In the case of a DNS server, I doubt the difference between perfect hashing and 'normal' hashing is significant compared to how expensive network IO is.
I'll be waiting and hoping :) I may eventually put one up for my own purposes, after all, but I don't have the resources to make anything large scale.
Doing what you suggesting without perfect hashing requires O(n^2) space. Perfect hashing gets away with O(n) space for practically the same effect. Edit: This is wrong, O(n^2) is if you want the chance of *any* collisions to be sufficiently rare, not just if you want the chance of a particular element coliding to be rare. I think it's linear either way, but don't have time to check it. The O(n^2) number can be found all over, see any proof that perfect hashing works really since it's needed in that proof.
Sounds very interesting... I was only thinking of the speed gains of perfect hashing, but as you say the memory savings are very interesting as well.
What's the preferred way to `use` types from your own crate? src/lib.rs: mod foo; pub use foo::Foo; src/bar.rs: * `use Foo; // depends on the root module using Foo but is concise` * `use foo::Foo; // always finds the right Foo but breaks if Foo moves to another module` * `use super::foo::Foo; // maybe helps with deeply nested modules`
Yeah, yeah, but your scientists were so preoccupied with whether or not they could that they didn't stop to think if they should.
You're right, I read over that too quickly too early in the morning and thought it was equivalent to something it wasn't. I've explained more in an edit. Sorry about that.
I am glad that bcrypt was included (and used in the example code) since it's probably the most commonly used cryptographically secure hash. However, I agree with /u/Hauleth that general-purpose hashing functions shouldn't be included in this crate--or if they are, don't label it specifically as a *password* hashing library. It gives users the wrong idea, that those hashes are safe to use for passwords. (To be fair, the general purpose hashes do appear to be salted at least--but there's no reason to use e.g. salted SHA256 over bcrypt, which is specifically designed for password hashing.)
If you need something like that, you could always make a hashmap of closures.
they are skyrocketing btw - nice timing :)
The CoC as a text is fine, and if there's been any problem with enforcement, I at least haven't heard of it. Codes of Conduct can and do go awry, so there's reason to be wary, but Rust's has text that explicitly cuts against these problems. To wit: &gt;avoid flirting with offensive or sensitive issues, particularly if they're off-topic If at any time you are ever "attempting to work against some verbal reinforcements of systemic oppression in the wider world" through your involvement in the Rust community, you are going against this provision of the code. It's sensitive and off-topic. I'm not just trying to beat you over the head with the letter of the code here. As a matter of principle, whether one is trying to make the community more or less inclusive, whoever is the first mover in making demographics an issue is in the wrong. That includes efforts at social engineering no less than it includes inconsiderate speech. Whether the community is 90% this or that is not inherently indicative of a problem. No one should feel their contributions are devalued because of their identity.
No need to even require read-only use. Look at [Ctries](https://en.wikipedia.org/wiki/Ctrie) :) (Warning: the memory management story associated with Ctries will make you want to rip your hair out)
I don't think so, but I don't know for certain. I use the name since it is used in hwloc as well, it is probably just another term for "layout".
Indeed. Selling price has doubled already since I bought them.
Nice post! It was really helpful! I think I've found two typos: 1. Section "Borrows", "However, with this borrow b we can only read the variable a. We can not modify a, nor can we borrow something else with b." -&gt; I think it should be variable "i" instead of "a", as there is no previous mention of the "a" variable. 2. Section "String Objects", "Because this is a move, s can now no longer be accessed:" -&gt; I think it should be "p" instead of "s". 
Explicitly failing to include half the population is, in fact, discriminatory language, even if it's not intended. If it's not intended as such, the correct response is "oh, sorry, didn't mean that". &gt; You should be happy we live in a time where you have straight cis people who want to fight for our equal rights as much as you do. We have a large number of cis people who want to fight for equal rights so long as it doesn't inconvenience them too much.
Very loosely. Hardware topology is more related to topography than topology. (in fact, I think the two terms were convoluted. I would argue it should be hardware topography, not topology). Topology makes more sense when talking about networking things but less sense when talking about physical CPU arrangement.
&gt; If in the stack overflowing code you accessed a valid page beyond the guard page wouldn't that constitute an unsafe access because the cpu wouldn't raise the exception? It would (and does still), the PR just changed the signal raised, it did not change the validation logic.
This is cool! It's also interesting to point out that this is apparently developed by Google.
&gt; general-purpose hashing functions shouldn't be included in this crate--or if they are, don't label it specifically as a password hashing library. It gives users the wrong idea, that those hashes are safe to use for passwords. I must have somehow not made it sufficiently clear: those *are* specifically password hashing algorithms, which just use the familiar hash functions to implement them. E.g., for SHA-256/512 based hashes, see [the spec](https://www.akkadia.org/drepper/SHA-crypt.txt).
&gt; I have carefully reviewed the code for safety in addition to using automated tests, but as with all concurrent and unsafe code, more eyes and brains would be better. Which makes me think... Clang/LLVM has ASan, MemSan, TSan and UBSan and recently Chandler Carruth (from Google) claimed that if your tests pass the sanitizers, and then crashed, then it was either a bug in sanitizers (missed UB) or in the compiler (mis-optimization). I am wondering about the effort it would take to re-use the libraries developed for those sanitizers in `rustc`... to help detecting issues in `unsafe` code it seems it could be quite worthwhile.
I think I've finally gone insane. Anyone want to write a NES game with this? ;)
This is cool! I'm currently learning Rust by writing a NES emulator. Maybe once I get my CPU working I will write some test programs with this :) 
Yeah, we've been talking about this on our #rust-lang Slack channel internally @ Dropbox. Pretty slick!
Yeah, it may be a little strong. OTOH `.clone()` often *is* the easy cheat to postpone learning about lifetimes and ownership.
Well, if you prefer, you can put the channel inside an `Rc` and clone that instead. That should not be as expensive as cloning the entire channel, I think.
You're right about tuples!
I'm not cloning the entire channel, just one of the Sender or the Receiver. i'm still binding names in that case. hmm, i'll look into it. Thanks for the direction to look into.
&gt; If I wanted to add something like this to the standard library, what would be the process for doing so? The library team decides if a change is "major" or "minor". Major changes need an RFC, minor ones don't. I would imagine that a new iterator method is fairly minor. The process for minor features is "open a pull request".
cloning senders is cheap, so that's okay. The backing buffer is owned by the receiver (which is not cloneable; if you wish to clone a receiver use something mpmc instead)
Just FYI, put brackets around your superscript so you don't superscript your bracket. I.e. `O(n^(2))` gives O(n^(2)).
I'm a bit embarrassed, actually, I should have waited until it was more done before posting it :(. I'm glad you all are talking about it though.
makes sense. I basically want two channels. one to send messages to the API from the UI to process, and one to send messages (with data) to the UI from the API in order to present it to the users. This is basically how every UI I've every built professionally works. It's kept so many issues at bay and allowed me so much flexibility that it's something I would like to continue, this seems to work, it just looks ugly to me creating a new name binding just so the borrow checked won't freak out. Though the point of the borrow checker *is* to reduce the scope of programs to those which can be checked and confirmed correct, so it makes sense. I'm guessing this is just something I need to live with, aesthetics vs practicality type thing.
Note that if you use Rust Clippy, it will tell you when you don't follow the convention for method prefixes: https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention
&gt; While other languages regard shadowing as something evil *Some* languages. Not all languages are so hostile.
be sure to train on half the data and then test on the second half, otherwise you run the risk of overfitting and not knowing it.
&gt; People have to be treated as individuals, not as avatars of their race Nobody is suggesting treating people as "avatars of their race". I said, and believe, that if someone's experience of life includes a marginalized identity, they should be able to express that if they wish. Further, that claiming that the mere discussion of marginalized identities is itself unacceptable ("because it's sensitive") is a false equivalence, a mis-application of a CoC, and one I reject. &gt; If on the other hand someone is constantly haranguing others about ephemeral offenses like "privilege" apropos of no particular behavior, that's just disruptive This is exactly the false equivalence I was talking about. Being "harangued" (i.e. having to hear about) someone else's experience of oppression is absolutely not equivalent, in any way, to oppression against your own self; a CoC does not exist to silence the topic. Making that equivalence is unacceptable. &gt; reflect on your readiness to take the challenges faced or not faced on average by entire races to judge the standing of unique individuals I have no such readiness; you either misread me or are constructing a straw man. I don't even know what you mean by "the standing of unique individuals". Individuals do not exist in a vacuum, but neither are they simply statistical averages of circumstances. &gt; when in a Rust-related venue it's reasonable to ask how these things are pertinent to Rust Rust is a technical artifact as well as a social entity: the people working on and with it. The degree to which that social entity pushes people away vs. draws them in, and the social function within it, is very pertinent to its present and future. You can claim this isn't so, but that doesn't make it not-so. It makes it "willfully ignorant".
But you have to admit that it can sometimes make code harder to read. So the hostility is not quite unfounded.
Well, the Error says it's a RelativeUrlWithoutBase, so I'd assume you need to specify the protocol: "https://www.reddit.com/r/F04cb41f154db2f05a4a/search.json?restrict_sr=on&amp;t=all"
The wilful ignorance I speak of is the demand to not be made to think about factors that have disproportionate influence on your society and its members. Not wanting to think about something is the definition of wilful ignorance. I browsed the IRC logs and it looks like someone makes a comment about the matter every month or two. If you feel that a polite reminder around gender-exclusive language every month or two represents nagging, I don't know what to say. How do you feel about common problems that arise in code review? If I were more present on IRC, I would probably say the same thing as whoever you're feeling nagged by, so I doubt you actually want to see more of me there.
&gt; harass and bully individuals into changing their nomenclature Again: unacceptable false equivalence. It's not harassment to ask people to use gender-neutral language. Stop trying to make that equivalence and I'll stop asking. Keep it up and I'll keep asking. Simple as that. &gt; You do not have the authority to tell Ilogic that "be excellent to eachother" isn't good enough I didn't say it's not good enough, nor did I claim any authority. I did ask them not to use it because it is _routinely used to mean the opposite_ of how they were using it in their post. If they meant to use it the opposite of how I thought they used it, then maybe my request was a mistake. &gt; Your opinion and thoughts are as worthless as mine are. I don't think your opinions or thoughts are worthless. I'm sorry the community has rubbed you the wrong way. But we do have norms and they're really not challenging to follow. &gt; which you would know if you were around TBQH I feel increasingly alienated from it, moreso every time I have to revisit this topic because someone wants to argue that having a CoC at all is equivalent to harassment. &gt; I think it's curious you think I have a problem with you. I don't know, maybe it comes from the part where you just called my thoughts worthless, or the bit earlier on where you were saying "fuck you" to the moderators.
It's here: http://servo.github.io/rust-url/url/enum.ParseError.html but there's not really a lot of documentation to it.
Well darn :s This makes things difficult
Oh shit that's what you meant by protocol! For some reason that didn't compute... Yeah that fixed it. Thanks a lot &lt;3
There's also a standalone crate for that! https://crates.io/crates/bcrypt/
&gt; disagrees with your method to achieve it Ok, what method do you think we should use? &gt; why is it so difficult to believe me when I say I hold co-existence and tolerance above all else? Because your conversation reads as [completely conventional concern-trolling](http://geekfeminism.wikia.com/wiki/Concern_troll) and [tone policing](http://geekfeminism.wikia.com/wiki/Tone_argument), even if unaware. Please take a moment to reflect on your own behaviour and decide whether it's actually helpful to those people you seem to want to co-exist with and tolerate (but not listen to, or take actions that would acknowledge or respect). &gt; Especially when there is no malice intended. Assuming that systemic oppression is only ever articulated via malicious intent is a mistake. A common one, but a mistake nonetheless. Not-intending to reinforce a power imbalance does not actually prevent the power imbalance from being reinforced. Benign intent doesn't matter. I do not imagine you or anyone who, as you put it, "says 'guys' on IRC" has any malicious intent; nor, I expect, do the moderators. And none of the short, direct requests to change that behaviour have a punitive tone either. Mistake, corrective. It doesn't require a 116-message argument thread. Only if you "disdain", dig in and treat it like an "instigation". 
How is `Send` relevant here? All signal handlers are invoked on the UI thread.
Use exhaustive `match` instead of if-chains. The compiler will catch you if you forget a special case. Avoid boolean blindness - use methods that return an enum/option rather than testing and then using a panicking method.
Howdy folks, I'm locking this thread because this has devolved into nothing more than a small number of people arguing heatedly over broader issues that are almost entirely off-topic, for which this subreddit is emphatically not the proper venue.
My game crashes on launch. It says I have Crash Report folder 2016-02-11_205154 if that means anything
You want /r/playrust, this subreddit is for the programming language Rust.
Open issue for `rustfmt`. I think it would be great addition. 
It gets around 91% accuracy after getting through just 1/3 of the training set, so I there is only minor overfitting. But you're right, need to test it on the validation set too...
This video is way to quiet, i cannot hear anything. Compare how loud your audio is to popular music videos to see if you have it loud enough. It seems to be 70%-90% quieter then most music videos. Should be able to use video editors to calculate and change the loudness side by side.
As a newb, I feel like these would be more helpful with some detailed examples.
[removed]
/r/playrust 
[Inner attributes can’t follow items.](http://is.gd/4yRaqw) [Inner doc comments can’t follow items.](http://is.gd/9WBkN1)
I've changed the post. Thank you.
As of... like an hour ago (shhh)... I start my job at Apple. Everything I produce related to computers/programming now needs to feed through Apple's legal department to see the outside world. So this isn't particularly well edited or reviewed. It's just something I wanted to write down, and figured other people might find useful. Had to knock it out before The Apple Blackhole kicked in. This is actually basically a massive self-nerd-snipe. Sometime earlier this week I decided to write an RFC issue (not even an RFC!) to the effect of "support generativity as a first class notion". I started to write out why generativity was useful, which led me to start to write a brief comparison of why generics/assoc-items/hrtbs exist, which then led me to backfill and forward fill context, until I awoke several days later to a 9000 word abomination. Along the way I pinged Niko and Aaron like a billion times to argue what was or wasn't expressible and "what even is a higher kinded type even". I also found a bug in the compiler, because that's what happens when you abuse the type-system.
Rust 1.7 isn't stable yet!
The README for the project explains all. Emphasis mine. &gt; This is the **next iteration** of “The Rust Programming Language”, which is currently located in the main Rust repository. If you want to read the book, you should check it out there or on the web.
The second version is way more detailed but is not finished yet.
Congratulations! Now more Swift and less Rust, or is Apple going to do Rust related stuff? Assuming you can answer about it, that is.
Ok, I didn't know that (never encountered that problem, as I always use hashbangs on top). But it isn't true about module/crate comments for sure. Why it should matter? Isn't docs comments just fancier way to write `#![doc="…"]` attribute?
First, THANKS! Second: &gt; I should probably explain the orphan rules properly. Are they explained somewhere in the book? &gt; Syntax extensions look like macros or annotations, but they cause the compiler to execute custom code to (ideally) modify the AST. build.rs files are a file that Cargo will compile and execute whenever a crate is built. And these?
Here's a cool code reuse pattern that we put into libcore to be able to support two cases in the string searcher: 1) Fastest scan to next match and 2) Next reject or match result. It uses a type parameter and a strategy trait to use the same code for the two strategies. [Usage site.](https://github.com/rust-lang/rust/blob/4b2c7030fd3c8773fc9d567ae240e896d5616be7/src/libcore/str/pattern.rs#L911-L914) [Strategy definition.](https://github.com/rust-lang/rust/blob/4b2c7030fd3c8773fc9d567ae240e896d5616be7/src/libcore/str/pattern.rs#L1166-L1201)
Syntax extensions: For ex. [here](https://doc.rust-lang.org/book/compiler-plugins.html) and [here](https://www.gulshansingh.com/posts/how-to-write-a-rust-syntax-extension/). `build.rs` is described [here](http://doc.crates.io/build-script.html). 
I found a typo! for&lt;'a&gt; F: Fn(&amp;I::Item) -&gt; bool You probably mean: for&lt;'a&gt; F: Fn(&amp;'a I::Item) -&gt; bool 
// Inserting a `u8` into the `x` solidifies its type to `Vec&lt;T&gt;` I bet you meant to say: solidifies its type to `Vec&lt;u8&gt;`? Also: congrats on your new job! But does that mean that you can't properly participate in the Rust community anymore?
Yeah, sorry about that. I was using a very cheap mic and I didn't feel how bad the audio was. Anyway, I have added subtitles now to compensate the lack of audio. Thanks for the feedback =)
&gt; you should probably make the font bigger It was pretty stupid of me to keep using the small font. Lesson learnt! &gt; few more seconds to explain "why" ownership is useful I would have loved to do that. Alas, there was no time =(. If I do get the chance to do this again in the future, I might do a video explaining it. Thanks for the feedback!
Hey thanks! The gameboy series is still a good idea - clearly I support the format, hehe! Yeah I'm looking forward to the rasterizer etc as well. Should be super fun!
hey thanks, I'll give that rustfmt config a shot! I did get your email btw explaining the tools you use - if I get some time to sit down with it I'll have to give that stuff a shot as well, looks really nice!
Some bikeshedding: If I came across `#![recursion_limit = "128"]` in code without an explanation in a comment or context I would have no idea what this exactly does (set the recursion limit of macros).
Are you suggesting counting the number of segfaults, and then feeding the same inputs to an equivalent parser in a memory unsafe language such as C/C++ and comparing the results? That would indeed be an interesting experiment. Of course there are several known cases where memory unsafety can occur (e.g. many/all issues on [this](https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-unsound) list), but I doubt most of those will get triggered in the average parser, and they will be fixed in the future.
 trait RefIterator { type Item; fn next(&amp;mut self) -&gt; &amp;mut T // `T` should be `Self::Item` } Those Apple reviewers are no good!
Even so, having experimental data to back up the claims is a good thing™.
Naturally, I mention the unsoundness issues merely to point out that it is already known that Rust does not guarantee 100% memory safety at this time. Fuzzing would still be very valuable: in addition to (hopefully) increasing confidence in the memory safety of Rust compared to other languages it might expose new soundness/compiler bugs, and perhaps find incorrect `unsafe` blocks in the code that is being fuzzed.
Yeah, it sure is very valuable. Gotta find the time to setup afl-rs and fuzz clippy... One of those days...
&gt;As of... like an hour ago (shhh)... I start my job at Apple. Everything I produce related to computers/programming now needs to feed through Apple's legal department to see the outside world. So this isn't particularly well edited or reviewed. It's just something I wanted to write down, and figured other people might find useful. Had to knock it out before The Apple Blackhole kicked in. Congrats, but I would recommend being under an NDA that you have "vicarious control" over before signing the Apple NDA. That way you can decide what qualifies for Apple's NDA without their interference.
The best alternative is probably a thread local. lazy_static is not very efficient so thread locals are often the better approach there anyway. You can also replicate it with a spinlock or atomic boolean.
It kind of looks like you have just been adding lifetime annotations because the compiler tells you to. Sometimes this actually helps to solve the issues, but at other times (and it seems like this is one of those times) you end up digging a deeper and deeper hole for yourself. Anyway, I have a local commit that fixes all the lifetimes and passes all tests, but no gitlab account, so I can't send you a PR. The summary: using `Rc&lt;RefCell&lt;Template&gt;&gt;` instead of `&amp;'a Rc&lt;RefCell&lt;&amp;'a mut Template&gt;&gt;` simplifies things a lot.
This is great! One note: Inserting a `u8` into the `x` solidifies its type to `Vec&lt;T&gt;` Should read: Inserting a `u8` into the `x` solidifies its type to `Vec&lt;u8&gt;`
Thank you very much. Could you send me the commit as a gist then? You can sign into gitlab using your github account if that makes it easier for you?
I sent a PR.
Some people can spend years talking about this. 45 Minutes would be much more welcome. 
This guy is doing C++ template metaprogramming in Rust. Stop him! Stop him before it's too late!
No... what you'd really do is just multiply it by some arbitrary factor and change it just to make sure your version wasn't "gimped". 128?! Pshaw! My machine can handle 2048! /that_instant_smug_weenie_feel
&gt; But it isn't true about module/crate comments for sure. What isn’t true? Can you show an example where it isn’t true? &gt; Isn't docs comments just fancier way to write #![doc="…"] attribute? Yes, and both inner attributes *and* inner doc comments *must* come before items, as demonstrated in my previous comment. I don't know why this restriction exists, but it does.
I never really payed attention to the issues. It works fine for me. I read that one letter to github and there was basically nothing that I would care about. Seems to work fine with rust. The bots they use are cool. Rfc structure seems fine, and familiar. Idk.
Thank you very much, I don't think I could have gotten this done myself!
\+1, :thumbsup:, me too
This is the major thing that I want from GitHub. People complain about issues a lot, but it works ok enough, and I value the simplicity. I like GitHub issues more than Bugzilla: even though Bugzilla has a few very nice features, it also has dozens and dozens that are just noise. So complicated. 
That's probably our *single biggest request* for github.
Yes, this is one of the 'small things' that would be quite useful. In Rails, we made a dedicated team for this, with a "don't actually use that commit bit" mandate. Worked out fine. I only accidentally merged something once ;) In reality, we don't want _anyone_ but bors to be able to merge stuff, so it'd be nice outside of that as well. Talking to GitHub employees about this in the past, they were concerned about UI and implementation complexity.
`&amp;T` and `str` are also built-in types, yet I see no problem with a function taking `&amp;str`. But I agree that you should use `&amp;str` instead of `&amp;String` etc.
Monomorphism and monomorphisation are slightly different. The former affects when things are generic, while the latter is a strategy for compiling/generating code for generic code.
That "bugfix" would belong to Apple now.
I was in the triage team for @padrinorb and really liked the job. Highly recommend having something like this. Good triage people should also be trusted enough that you are sure they don't use their commit rights even if they could.
&gt; Good triage people should also be trusted enough that you are sure they don't use their commit rights even if they could. Yes, this is exactly it.
Highfive actually has some of this already.
Yeah I mean maybe I'm just more heavy-handed with things than most: if they're getting in the way, just delete them. That's what I do.
well this awkward
Github-bashing has become the new thing. I suspect there's a lot of "I don't like Github because centralization" and "I don't like Github because SJWs" going on. Most github projects are small and are better of with a simple bug tool. Others can use external tools. Don't really see the big deal.
Moving a resource is not a side-effect, it is a type restriction.
People like to be subscribed to events on their repo such that they receive email whenever someone does anything, which includes leaving a comment on an issue. I suspect a lot of people regard "+1" comments as noise, and the reason we don't consider it to be much of a problem is likely because the activity on the Rust repo is already overwhelming, and also because we shunt a lot of the bikesheddy stuff over to the RFCs repo.
Have you tried to the `move` keyword to make the closure capture its contents by-value?
You probably want to ask /r/playrust
I mean `{` curly braces `}` are restrictions to and have various side effects. But saying it that way doesn't really tell the story of what they are. They're design decisions. I mean why can't i just do: line 1`{ let x = 1; }`, line 2`{ let y = x + 1; }`? That's a damn restriction! Rusts ownership system is the same has `{ scopes }` in that it allows encapsulation of ownership. 
Whoever wrote that `is_origin()` function should have thought about whether he wants to take his argument by value or by reference in the first place. And yes, a certain familiarity with a language is necessary to write code in it. But I have to say, the second part of the article gave a really nice example of a "fight with the borrow checker", and I really liked his final solution (I didn't know it was possible to have multiple(?) impl blocks for the same type). Cool blog post!
Is there a reason why your project has suddenly disappeared?
Here's the link to the PR adding the preliminary support for this build system, which landed just yesterday: https://github.com/rust-lang/rust/pull/31123
&gt; (I didn't know it was possible to have multiple(?) impl blocks for the same type) This is possible only within the crate which defined the type (otherwise you need to define a trait), but they can be in different modules. They need to be in the same crate for coherence reasons - otherwise two crates could define a method with the same name. You can also do [things like this](https://play.rust-lang.org/?gist=0d3d99622f18df9cd7d9&amp;version=stable) with parameterized types.
Most of the stuff in that list isn't really a problem for us. Servo would like to be able to allow people without commit access to be assigned to issues (and give them the ability to triage). We work around the former with a "C-assigned" label. It's also a bit hard on issue categorization and planning; we sometimes feel pains with that which would be solved with bugzilla (but bugzilla isn't too newbie-friendly). But overall, it's great!
Methods default to module-level visibility. See https://github.com/rust-lang/rfcs/pull/1422 for possible extensions to this
I wish Rust was "borrow-by-default". It makes more sense to me - 90% of the time I'm passing borrows around, not values.
Ah, but then the syntax would be inconsistent. Or we'd need to invent a new sigil for 'move'.
there also is codeanywhere.com
Doesn't work if you have a `Complexf32`/`Complexf64` type (that obviously implements `Copy`) and you want to provide both a borrowing and an owning implementation of `Add` (or almost any operator for that matter).
I don't recall. It was when we had argument modes. Probably 0.1?
and it's closed source too. :/
(author here) I mean...not gonna lie, Cargo really seems to have gotten just a *hell* of a lot right. Any language could do a lot worse than to emulate it. Well done. The single thing I'm most curious about, partly because of what it means for Go, but also because of what it means for escaping the [repo-as-unit DVCS thoughttrap](https://bitquabit.com/post/unorthodocs-abandon-your-dvcs-and-return-to-sanity/), is how path dependencies work out as a practical matter. Since I'm at most a Rust tinkerer thus far, I haven't used them at all myself, let alone actually published something I need to maintain. Now we just need Go to start versioning its compiled objects, and then it could be better than Carg...OH WAIT NOPE y'all already did that too
Not sure if you're aware of the Rustonomicon, but it's required reading for anyone expecting to veer off into unsafe territory: http://doc.rust-lang.org/nightly/nomicon/
I think you might be looking for /r/playrust. This subreddit is for the programming language with the same name.
Good idea in that case would be to wrap the struct in the separate module and expose only functions that are 100% safe regardless of the usage. Even when doing it just for yourself. By the way, the lifetime parameter in `Foo&lt;'a&gt;` is really confusing and is actually more unsafe than making the lifetimes `'static`', so I would get rid of that. It would be really nice to safely store owner and references in the same struct. There's a library implementation for that: [owning_ref](https://github.com/Kimundi/owning-ref-rs), but that allows only for a single reference, not eg. a `Vec` of them, due to language limitations. But after I've seen [that part](http://cglab.ca/~abeinges/blah/rust-reuse-and-recycle/#higher-kinded-types) of recent /u/Gankro post, I believe that it might be possible to generic version of that library!
&gt; they're harder to use. Instead of typing self.method() you need to type function_name(&amp;self.field) Slightly more verbose to use, maybe, but typing isn't particularly hard. It also makes the function easier to reason about, as you know it only takes `self.field`, whereas if `self` is passed in then it could access and modify any of `self`'s state.
Are you talking about the fact that the book considers arrays, tuples, slices and functions to be also primitive types whereas the reference does not?
Indeed, this kind of thing tends to be buried in a struct implementation that doesn't expose internals readily. Ah there was something posted about that regardling lying lifetimes vs static... I can't remember that now. Perhaps there was a lint on this with clippy which is escaping my memory. owning_ref is very handy for the case where you don't need multiple references to the data. I'll be very curious to see if it is extended further!
You could group fields together that you need for a method into a common struct, and then impl the method on that struct instead. The borrow checker likes you, and you've designed your code to be more modular. 
Some programming languages have `x.f()` be syntactic sugar for `f(x)`. The idea is that dot notation is very appealing so people tend to overuse methods when regular functions would work just fine.
It would be ideal if the shorthand syntax could transparently accommodate a simultaneous borrow and mutable borrow of different fields (e.g. possibly just adding the `mut` keyword to those field identifiers).
I think it would be an overreaction to start favoring free functions due to the linked blog post, because that post doesn't actually need them. To recap, here's a compilable example of the code from the blog post that demonstrates the borrow error that arises when modifying `Parser::next` to return a `Lexeme&lt;'a&gt;`: struct Lexer { x: String, } struct Lexeme&lt;'a&gt; { y: &amp;'a str, } enum State { Closed, } struct Parser { lexer: Lexer, state: State, } impl Lexer { fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Lexeme&lt;'a&gt; { Lexeme { y: &amp;self.x } } } impl Parser { fn consume_lexeme&lt;'a&gt;(&amp;'a mut self) -&gt; Lexeme&lt;'a&gt; { self.lexer.next() } pub fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Lexeme&lt;'a&gt; { let lexeme = self.consume_lexeme(); if lexeme.y == "" { self.state = State::Closed; // error from the borrow two lines up } lexeme } } fn main() {} (Note that you don't actually need any of the lifetime declarations on these functions, they're just here for instruction.) The blog post solves this by having `consume_lexeme` become a free function that just takes a `Lexer`. But this is a bit strange, because it is a tacit acknowledgement that the `consume_lexeme` function shouldn't be defined on `Parser` at all... it should be defined on `Lexer`! And indeed if you do this, the code works just fine using methods. Compile it for yourself here: http://is.gd/JzkdsT
That sounds like a great idea. It makes the reasoning about the code easier for the compiler and for the reader.
&gt;defend a license that limits competition You don't really understand open source do you? 
&gt; I'm just learning :) 
We're not using it yet, it's part of the wasm experiments. The parsell goal is to build streaming parsers that only do memory allocation or dynamic dispatch at packet boundaries (when you have to save/restore parser state). Compared to Nom, it's more limited in the languages it accepts (just LL(1)) but gives tighter memory guarantees.
Sorry about that! The coding works in a lot of cases, but it's probably not infallible, for the same reason that you can express a lot of higher type classes without HKT, but not everything. For example, you can express that a type has a map method, you just can't express that it returns an instance of the same type function. I'm not sure this matters so much for iterators, where you care about the type of the items, not the type of the iterator.
Anyone having been cursed without C++ `auto_ptr` has already felt the sting of such invalidation :(
Right, but when you ask for hardware topology, you aren't asking for any of that. You aren't trying to figure out what the graph is of the interconnections between CPU, Cache, and Memory. Rather, your are looking for a physical layout. "I have x cores here, y cache here, and z amount of memory". That is the main difference. You aren't saying "CPU X connects through CPU Y through node Z which also connect CPU Q and W and Node V". That is more the difference. There is topology work that goes on with system design. But that isn't on the same level as what you talk about when you talk about network routing, for example.
&gt; Rather, your are looking for a physical layout. "I have x cores here, y cache here, and z amount of memory". If you don't care about NUMA then you are right, that is the only thing you are possibly looking for. &gt; You aren't trying to figure out what the graph is of the interconnections between CPU, Cache, and Memory. Of course you are. The moment you do care about NUMA you need to know: how many NUMA nodes does this CPU has, how many cores per NUMA node, what are the closest core to this core, how many cores do I have to jump to get to that core (Cell...), which memory channels can I access from this NUMA node, which other CPU can I access, what is the "distance", ... If you have a modern Intel/AMD CPU with &lt;=4 cores NUMA doesn't matter that much. With an Intel Xeon Haswell with 16 cores and 4 NUMA nodes with 1 memory channel each accessing a different RAM module, you ask the wrong memory from the wrong core and your latencies skyrocket. If you are implementing something like an OpenMP run-time system or Rust rayon and need to steal a task from one core, you better steal it from the queues of the closest cores within the same NUMA node. If you have pinned threads to physical cores you do this by querying for the distance between a core and another. Topology is literally the right word. You steal a task from the wrong core and you might end up synchronizing caches within two different CPUs.
Thanks, done :) https://github.com/rust-lang/rust/issues/31628
&gt; Caring only about basic "topology information" like "how many cores do I have" doesn't make it "less topology". What I'm getting at is that the term is misused. I'm not trying to say the information isn't useful. Topography is everything you have just described in the post. How many, where, how it accesses. Topology is more about things like Set theory and Knot theory. Topology doesn't really talk about things like "I have 8 things that need to talk on one bus". It cares more about things like "I have an island surrounded by land connected with 8 bridges, can I cross each bridge only once?". That comes in handy in networking mainly because you have to answer questions like "have we created a cycle" or "What is the minimal number of jumps to get to a location" (and even then, that is more graph theory than topology theory). I'm not trying to dispute the usefulness of the data. I'm just trying to be pedantic about the usage of the term. The original question was "is hardware topology related to mathematical topology" the answer is not really, the term is misused.
Ah I see. But then I don't understand how it is less misused for "network topology". It sounds to me like it is also far away from what topology in mathematics mean.
Yeah, "network topology" isn't necessarily right in my opinion. It may be right if you are talking about navigating a network graph but not so right if you are talking about the actual layout of a system. (it also may be right if you are talking about knots... :))
&gt; In computer science, primitive data type is either of the following: ^^[citation ^^needed] &gt; &gt; * a basic type is a data type provided by a programming language as a basic building block. &gt; * a built-in type is a data type for which the programming language provides built-in support. &gt; &gt; ... &gt; &gt; More sophisticated types which can be built-in include: &gt; &gt; * **Tuple** in ML, Python &gt; * List in Lisp [**arrays** and **slices** are rust's builtin lists] &gt; * Complex number in Fortran, C (C99), Lisp, Python, Perl 6, D &gt; * Rational number in Lisp, Perl 6 &gt; * Associative array in various guises, in Lisp, Perl, Python, Lua, D &gt; * First-class function, closure, continuation in languages that support functional programming such as Lisp, ML, Perl 6, D and C# 3.0 
Yep, this is exactly what I've encountered as well. Posted about it in the "Ask a question" thread a while back, got similar confirmation from other folks: https://www.reddit.com/r/rust/comments/42gh9h/hey_new_rust_users_got_an_easy_question_ask_it/czdwip0 I've noticed myself breaking impl methods into one "main entry" method that calls out to impl-private plain old functions. That let's me scope the functions to just the impl, but side-step a lot of the borrowing issues. The major downside is that it clutters up a lot of the function signatures, since you have to start passing around a lot of the state from the struct itself. But maybe that's a good thing, pointing out functions/structs that are doing too much and should be refactored?
the first function is generic over both `'a` and `'b`, and the second requires that Someclass uses the lifetime `'a` for both contained lifetimes.
I feel uneasy about allowing partial ownership and borrow, TBQH.
Change line 4 to let team_size_in_text; You always assign to it, so there's no reason to assign it `""` initially. And since you only assign to it once, you don't need it to be mutable, either. After this, you can also do let team_size_in_text = if team_size &lt; 5 { "Small" } else if team_size &lt; 10 { "Medium" } else { "Large" }; Which is much nicer.
But why does it make a difference when I am just calling `stuff(x);` in either case? Shouldn't `'b` equal `'a` in this case?
And that's a very minor point, but there's no need to take a reference for `println!`'s parameter, `team_size_in_text` is already perfectly suitable for printing.
The terminology always gets me. `Vec&lt;T&gt;` owns a heap-allocated dynamically sized slice of instances of `T`. But what should we call types that "contain", in the sense that they own and encapsulate, a dynamically sized type?
&gt; There's no benefit to splitting up code into multiple compilation units in Go. (Rust does it for compile time improvements, and so that plugins/etc can work) Yes, there is. A hypothetical GoServo that put everything in one package would have really bad compilation times. The Go compiler has been getting slower from version to version (the rewrite in Go being a large regression, and I predict the SSA backend will bring more regressions) so the situation isn't as different in Go-land. Furthermore, there's no namespacing beyond the package level in Go, so if you want to avoid mashing everything together in one namespace you have to use multiple packages. This is not a problem Rust has, since it has a module/crate distinction. (In fact, if not for the lack of incremental compilation, I think there wouldn't really be much of a need to use lots of crates in a Rust project. Makes me wonder whether we could have introduced some sort of "DAG module" that enforces DAG ordering to allow some degree of manual incremental compilation within a crate. Of course, there's very likely no point in that now, with incremental compilation so close.)
Use rust to support LLVM, then use [this](https://github.com/avr-llvm/llvm) backend?
So download, run tests fix broken tests? Is that something a newb-ish contributor can do or am I missing something? Also dumb question will emscripten allow me to make webpages without working with that terrible type unsafety from js? Or is it more like a way to make RIA-s? Hmmm..... If I can talk back to the server and there is a gui framework to use this could be very nice in RIA land..... EDIT: I had been looking at dartlang but I'd prefer rust's static typing if they scratch roughly the same itches....
That very much depends on `SomeClass`. For example within rustc there is a `Context&lt;'v, 't&gt; where 't: 'v` (IIRC). In that case asking for `'t` and `'v` to be equal would unduly restrict the implementation. Try it and borrowck will likely stop you.
You'd need to present some concrete examples before we could determine such a thing. :) Specifically, I suspect that the notion of free functions vs. methods is orthogonal here, which is to say that any data that gives you a hard time while refactoring would give you just as hard of a time were you using exclusively free functions.
I'm pretty sure that `#[derive(Clone)]` will clone each field of the struct. I'm not sure how copy works although I think it may be translated to a `memcopy` in llvm. If copying does copy the padding you could derive `Copy` and then implement `Clone` yourself as just `*self`. If copying does not copy the padding then you should probably not implement `Copy`. In this case you should be able to implement Clone as `unsafe { ptr::read(self) }` (or probably even as `unsafe { *(self as *const _) }`). However you might still be relying on undocumented behaviour, because I don't know if moving a struct in rust in guaranteed to move the padding as well.
&gt; that would need the compiler to understand aliasing in context of indexes – it would special case the Vec. The big issue is that there's nothing in the `Index` trait that guarantees that `a != b` implies `&amp;v[a] != &amp;v[b]`. So if the borrow checker always assumed that `v[0]` and `v[1]` were disjoint, you could violate aliasing rules with a container that didn't follow that pattern. So yes, it would need to special-case `Vec` to be able to do that analysis.
&gt; Whether one allows to move fields like c out might be discussed though, but with local inference it might be allowed as long as it is "replaced" within the same method. That can't be allowed because the method might panic before the field is redefined.
'Primitive' is a sort of fuzzy word, but the reference is definitely wrong in separating `char` from the other scalars.
I think that GitHub's issues work fine. They're not perfect; but no issue tracker I have ever worked with could be characterized as "perfect." It's always about a balance; you can keep things simple, to reduce the barrier to filing issues, at the cost of somewhat more noise in the form of issues without enough information to act upon. Or you can add lots of extra features and text, which might lead to a little bit more information on some issues, but will also discourage some casual filers, and will add noise for everyone interacting with the system in the form of irrelevant fields (as most fields don't apply properly to every issue) and extra redundant or irrelevant information in the ticket (as people complying with a template may include information that just isn't actually helpful). I actually appreciate that GitHub doesn't offer extra fields and templates; that allows the person filing the issue to include just the relevant information, and the team to request more information in comments if necessary. Adding a "+1" or "star" button to discourage content-free "+1" or "me too" comments might be nice; I don't think lack of it is worth leaving GitHub over, but I can see the appeal. Contribution guidelines not being prominent enough; eh. Not all that big a deal, I don't think. Just reply to a PR with a link to the contribution guidelines if someone hasn't followed them. Almost all of these problems could be solved with just a little bit of elbow grease doing issue triage and followup. I think the bigger part of the problem is social; contributing code is seen as being more valuable than doing issue triage, responding to issues with requests for more information, helping out confused newcomers, and the like. So any amount of noise in the issue tracker or in PRs is seen as time taken away from valuable coding, rather than an opportunity for some people to contribute in valuable ways that don't involve coding.
I love these posts :D
It would be really cool to have a document which describes all of the ideas that rust tried out and discarded, along with reasons why. I realise it'd probably be a huge amount of effort to write, but it would be very useful for people proposing new language features, people designing new languages, and even just people using the language.
&gt; The license is mainly to prevent someone setting up a directly competing service. Assuming this is the case, these classifications hold true: * Source is available: Yes * Open Source: [No](https://opensource.org/faq#restrict) * Free Software: [No](http://www.gnu.org/philosophy/free-sw.en.html)
Now I want a fiber library called `hemp`.
Just for clarity, let me point out that I wasn't framing the argument. I was merely pointing out that "dot notation is objectively better" is a false statement, and providing an example of a long-held opinion (that pre-dates Rust) as evidence. This whole discussion starting with my grandparent post is really an aside from the main original post. I agree with your point about the nature of decomposing data structures in Rust. 
&gt;&gt; This is the same as destructuring self in a method to end a borrowck squabble Would that work? (I'm a year+ away from Rust, so I don't know). If I used destructuring in the signature of the method, and only took some subportions of self as a param, would the borrow checker only consider those subportions as borrowed? EDIT -- on second reading, I think maybe you're saying to let the method take self, and have it delegate to a free function that only takes the subportions. Right?
Unless there's another trait that, if implemented, tells the borrow checker that `a != b` implies `&amp;v[a] != &amp;v[b]`. Then `Vec` could implement it, but also other types.
I don't like that sort of special casing, though, since it tends to make things fragile. Like if you have the code: let i = 3; for j in 0..v.len() { if i == j { continue; } borrow(&amp;mut v[i], &amp;mut v[j]); // Allowed? } I wouldn't really expect the borrow checker to be sophisticated enough to pick up on that, but it's an odd inconsistency.
Apparently there is now working underway to mainline the avr-llvm work. Once that happens, avr-rust can make headway. You can follow along the upstream merge process [here](http://reviews.llvm.org/p/dylanmckay/feed/), though phabricator appears to be börkd for now.
I've been struggling with these things too. Using unsafe is not a good idea, the big question is *what to do instead*, which might fall into one of these categories: * Using indices. I e, instead of storing `&amp;str`s, you're storing a `(offset, length)` tuple. When you want to access the data, you look it up in the `String`. * Using `Rc` (and sometimes, `Cell` or `RefCell`). Might not be the best solution for your exact problem, but for many other ones. * Self-borrowing, which is an interesting two-step trick: Like this: impl Foo&lt;'a&gt; { fn new(s: String) -&gt; Foo&lt;'a&gt; { /* just sets up s */ } fn calculate(&amp;'a self) { /* calculates v and h */ } } ...after calling `calculate`, the borrow checker guarantees that Foo is not changed or moved (except for inside `RefCell`s). You need to put `v` and `h` into refcells for this to work. (I haven't used this much, so I'm a bit out on deep water here.)
Note that arrays in Rust are quite limited, but they are fixed length and contain their elements directly, whether they are on stack or heap. On the other hand, `Vec`s are variable length and store the contained elements on the heap. Slices (as in `[T]`) are usually just seen as reference (`&amp;[T]`) because there is no way to instantiate them directly. Note that those are 'fat pointers' – they store both start and length of the slice. There are other things that sort of straddle the line like smallvecs which store data inline for small sizes, or generic-arrays which are array-like types generic over the length of the array (using a typenum-based hack).
Those fields of the struct suddenly become half public this way. In the end we may need to have abstract such fields i.e. simple borrow groups, to preserve encapsulation
Wow... using padding bits to actually carry data? That's one nasty hack :(
Yeah, I just get triggered when I see C++ with backwards includes. It comes from too many times where I've had to reverse engineer which files are needed when I want to include a file from a new module.
On the other hand, Clojure (and I think Haskell but I know it less), though it doesn't have dot notation, has some threading macro that allows to end up with a pretty similar result: (-&gt; x (f a b) (g c d) (h e f)) which is more similar to: x.f(a, b) .g(c,d) .h(e,f) than to: h(g(f(x, a,b), c, d), e, f) So maybe saying "dot notation is objectively better" is a bit excessive, but at least it seems to me that "some mechanism that allows to take the result of previous computation and pass it implicitly as first parameter of the next call" is a common pattern that is pretty useful in chaining computations ^^
The right way to think about it is this: * Do I need to change the value? If not, using `&amp;T` will suffice (and often be more flexible and faster unless `T` is `Copy`) * Does my caller need the value after I'm finished with it? If so, using `&amp;mut T` will allow our caller to keep ownership. Otherwise you may as well take `T` (but keep in mind that it's usually hard to know what a caller does)
I don't know what clang-format defaults are but with a mixture of regexes and some magic you can specify in .clang-format whatever order you want and then apply that to your whole project automatically :)
I don't think so, but I can't quite remember.
Not a new user by a long shot (here since 0.12), but is there a way to automatically print a stack trace on panic, via env variable or so? As it is, I often have to reach for gdb just to print the stack trace.
I'd try prepending `RUST_BACKTRACE=1` on the command line.
It's been more than three weeks since I annoyed you fine folks to get nominations and votes for TWIR's crate of the week. So here goes. :-) Feel free to comment and vote here or on the rust-users thread.
like "mbed", "Arduino" is an API for embedded devices. Specific platform support would require LLVM backend ports to AVR, varying ARM platforms, and TI devices. The difficulty are the backends. At this point we can look at making rust's own embedded API since arduino and mbed are complete ass.
This: http://stackoverflow.com/a/29980945/4373209; [std::thread::Builder docs](https://doc.rust-lang.org/std/thread/struct.Builder.html); [rustc RUST_MIN_STACK flag](https://www.mankier.com/1/rustc#Environment); is the best i could find about it, it looks like spawning a thread is the only way. 
I've left you a pull request that should significantly reduce the number of boxes: https://github.com/m-decoster/RsGenetic/pull/15 Also, you should consider running rustfmt over your code. It takes care of most style problems.
Cargo defaults to \^, not =. If you want exactly that version, use =. I should also say that serde _does_ follow SemVer. The issue here is that nightly breaks internals, not externals.
Thanks! I'll take a look. EDIT: What does the `?` do in front of `Sized`? The documentation says "The special syntax `?Sized` can be used to remove this bound if it is not appropriate.", but I'm not sure what this entails. &gt; you should consider running rustfmt I actually run it after each commit. What's on the master branch has had rustfmt run on it. Except the examples.
&gt; I actually run it after each commit. What's on the master branch has had rustfmt run on it. Except the examples. Sorry, I thought rustfmt had some different rules. Nevermind.
To add to this, what I did is kind of a hack. `Builder` doesn't make any sense when its type argument is unsized because you can't return an unsized object. However, `Simulation::B` needs to be defined even if `Self` is unsized so I needed to allow `Builder` to accept unsized type parameters. The other solution is to bound the `Simulation` trait with `Sized` but this would mean one wouldn't be able to use `Box&lt;Simulation&lt;T&gt;&gt;` or `&amp;Simulation&lt;T&gt;` (trait objects). If rust allowed where clauses on associated types (currently, it only allows them on associated methods), one would write: pub trait Simulation&lt;T: Phenotype&gt; { type B: Builder&lt;Self&gt; where Self: Sized; // not allowed. fn builder() -&gt; Self::B where Self: Sized; // allowed. fn run(&amp;mut self) -&gt; RunResult; // ... } And `Builder&lt;T&gt;` would only have to be defined for `T: Sized`.
&gt; They say things like "It's better to have 1,000 functions that operate on 10 data structures, than to have 100 functions spread across 100 data structures." Plenty of programmers prefer no association between functions and the data those functions operate on. This does not make sense to me. Methods as they exist in Rust are primarily a syntactic difference (they are also easier to import than functions, as pcwalton pointed out). This syntactic difference has no bearing on whether or not there are 1,000 functions operating on 10 data structures or 100 operating on 100 - those functions could be written as methods or as free functions either way Additionally, in a statically typed language there is necessarily an association between functions and the data they operate on, because the type of that data is a part of the type of the function.
Instead of `.ok().unwrap()`, you can just write `.unwrap()`. Also, if possible, avoid unwrapping. For example, in `src/sim/seq.rs`, you have: if parents_tmp.is_err() { self.error = Some(parents_tmp.err().unwrap()); return StepResult::Failure; } let parents = parents_tmp.unwrap(); You could have written this as: let parents = match parents_tmp { Err(e) =&gt; { self.error = Some(e); return StepResult::Failure; }, Ok(parents) =&gt; parents, };
Yes, thanks. I'm on mobile so I got lazy.
We have not had a new RFC for these types yet. So there's that. I'm not sure if LLVM changes, which I think were the issue last time, have made it simple enough to not require one these days.
Please comment on any issues, safety or documentation-wise. I'm also wondering if the name is good. I saw someone with a similar (but unsafe) function `ref_mut_map`, and calling it something related to `map` does make some sense. I'm also wondering about usefulness, I sort of imagined that this could help reduce usage of the "Option dance", but I'm not sure how much.
[removed]
You're looking for /r/playrust. Check the sidebar for more information on this subreddit. ;)
Only an extremley rough and rushed implementation [but here you go](https://github.com/panicbit/depot-rs). # Quick setup 1. Clone the repo and run the `cargo run` it (nightly required). 2. Add `index = "http://localhost:8080/index/"` to the `[registry]` section of your `~/.cargo/config` (or to a project-local cargo config) 3. ??? 4. Try building a clean project 
You can simplify `ExitOnSuddenDrop`by removing the bool and instead using `mem::forget` to avoid running the destructor if the function ran successfully.
There is [RFC](https://github.com/rust-lang/rfcs/issues/521) to add `u128` and `i128`.
I think it would be nice if the library would print a short message before exiting, otherwise there would be pretty much no indication of what is going on if a panic occurs (I think). Also, maybe you should advise against using `take_mut` in a library crate because I think it is very bad taste for a library to just exit the complete process unless explicitly documented. Otherwise this look like a great crate!
I'm not sure where and if this is documented, but it seems as if `use` always uses the global context (i hope you know what i mean), so you have to use use b::c::Z; even if you are already within the `b` module [playpen link](http://is.gd/jSthLx)
Interesting, thanks
The right hand examples could confuse someone because `*a.b` is not `(*a).b` and you do need to say `&amp;*a` at times, though for other reasons.
Nit: &gt; let team_size = TeamSize::from(0); println!("Current team size : {}", team_size) &gt; Current team size : Large
No, there is not an RFC to add those types, there is only an issue on the RFCs issue tracker. An RFC is a whole document that needs to be created and maintained.
Good idea, thank you.
Good point; that was sloppy of me. However, when does one need to say `&amp;*a` (other than to help type inference or is that what you're talking about)?
I do seem to get the original panic message, at least. I'm concerned about printing, what if `println!()` itself panics? Is the behavior of panic in destructors stable? And if so, I might as well double-panic to abort instead of exiting. Hmm. I want this to be usable in libraries, and I think a user of the function might be able to tell how likely a panic is? Possibly a cautionary note somewhere, not sure where.
Not to start some sort of insane tangent, but the sentence you wrote " I have a sense of what needs to be done on my project, but — because I know that waterfall doesn’t work — I have to assume my understanding is incomplete." Is actually weaker by including the point about waterfall. It makes no sense, why didn't you just say straight up that you have to assume your understanding is incomplete?
If you want path from current module you do `self::c::Z;` if you want the parent you can do `super::b::c::Z;`. [use docs](https://doc.rust-lang.org/reference.html#use-declarations)
If a panic happens while already panicking, I believe it just aborts.
Your way is the obvious way to avoid rightward drift. stebalien's way is less obvious, but more "idiomatic". (I prefer to handle the "happy path" branch first, though) 
I guess my concern is, is this documented behavior that's not likely to change?
Thanks for the tip on defaulting to '^' - and having to use '=0.6.12'. Apparently I've been misusing this for many months. I'm able to build again. Great! Wonderful! However, I submit to the Rust community that this is not the documented behavior - nor is it the expected behavior. Evidence: - The cargo docs state that Cargo follows this defined behavior. Documents: - http://doc.crates.io/crates-io.html#using-cratesio-based-crates - https://docs.npmjs.com/misc/semver - https://github.com/steveklabnik/semver#requirements - Relevant snippets from the docs: - A leading "=" or "v" character is stripped off and ignored. - = Equal. If no operator is specified, then equality is assumed, so this operator is optional, but MAY be included. *maybe* Cargo/Rust docs should state it uses a 'Version Range Requirement' (instead of 'Version Requirement'). You can call the 'pedantic police' on me, but maybe if it is stated this way it would save someone from continuous build breakage. 
One case I know of is you have a pointer and you want a reference, the idiomatic way to convert is this: let ptr: *const u8 = ...; let ref = unsafe { &amp;*ptr };
Neat! I'll be needing some genetic algorithms in the near future...I'll give this a spin. :)
I've been writing my own iterators and it's been quite nice, but one thing eludes me. I've found IntoIterator trait but it consumes its input which I don't want. I know I can call .iter() to get a non-consuming version but for the life of me I cannot find the trait this belongs to. So far I've just been adding fn iter() methods to my type impls but I'm pretty sure I should impl a trait instead. Does anyone know which trait provides .iter()?
Yeah when passing an argument to a generic function, it won't know whether you want `&amp;Box&lt;T&gt;` or `&amp;T`, and will conservatively stick to the former (even if that fails to compile).
I love that game, but this is the wrong subreddit my friend. You are looking for [this](https://www.reddit.com/r/playrust)
I read `?` as "perhaps".
This is for Rust the programming language. You are looking for /r/playrust.
I can't figure out how to handle the borrow checker here (where data is a large object and expensive to clone, instead of an int): fn test(data: &amp;i32) -&gt; Box&lt;Fn(i32) -&gt; bool&gt; { return Box::new( |x| x == *data ) } Obviously the Box needs a lifetime assosciated with it somehow, but I'm not sure how to represent that.
`.iter()` is just a method, no trait. See [HashMap](http://doc.rust-lang.org/src/std/collections/hash/map.rs.html#892)'s implementation as an example.
I don't feel like my question is being taken seriously here. This is a common theme. I have a question or concern, and the answer is something along the lines of, "No, you're wrong, Rust is doing it the right way." I don't get that sense very much from other communities. For example, Go and Python are from the "one good way to do things" philosophy of language design, but when I ask a question about error handling in Go or about problems with duck typing in Python I get much more measured, thoughtful responses. Or when I ask questions about mutability or existential qualifiers in Haskell, people will talk honestly about problems with type system soundness or with poor mutator interaction with the GC. But that's not how I feel in the Rust community. I ask a simple question. "What would Rust be like if move wasn't default?" I'm not even attacking Rust. I'm not saying Rust is doing things wrong. But the answer I get is something like, "We already tried that, it was horrible." "Why was it horrible?" "Because move by default is not surprising because it is default." What kind of circular logic is that? I got some pretty dismissive responses when I've asked questions about other things involving Rust as well: * When I asked about why ad-hoc polymorphism was so painful when used with multiple dispatch, I felt like my concerns were dismissed with the "we don't want to be like C++" without really listening to what my concerns were. It's not like multiple dispatch can't be used with ad-hoc polymorphism, but you have to jump through a ton of hoops in Rust just to get your code working. * When I asked about Rust and HKT, people told me that "Oh, you can't have HKT because you would need to pass around implementation dictionaries." (not true) and people told me that "we don't want to be like Haskell" but I'm not really satisfied with that explanation. I'm not here to evangelize HKT, but it seems like we can't even really talk about it. * And now, when I ask about what Rust would look like with non-default move, I basically feel like I am being treated like a child. I don't know. The Rust community reminds me a lot of `comp.lang.lisp` back in the 90s, which has me worried about its future. CLL was full of smart people, and Lisp is dead. We don't want that to be Rust's future.
Does this produce any demonstrable performance benefit? (And does it seem funny that Any without any dynamic calls is called Dynamic?)
Actually, I was annoyed with that one and rewrote it several times, but for some reason got stuck on the idea that "arrogant douchcanoes will not believe that they don't completely understand things," and so felt like the appeal to a widely-held maxim (waterfall doesn't work) would benefit. However, when you point it back out to me here, I realize that no magic wording would convince those people anyway, and such justifications are out of character with the rest of the section anyway. What do you think of: "I have a sense of what needs to be done on my project, but I have to assume my understanding at best incomplete, and at worse dangerously incorrect."
Great work! If that helps, I wrote a pure ocaml decoder for CFF (the non-truetype part of opentype) and ligatures tables a few years ago, see http://patoline.org/darcs/patoline/src/patfonts/ If you can read Ocaml, reading this would probably be easier than reading the docs for these weird formats, and testing on the collection of printers we tried over the years ;-)
Ok thanks!
Good point, I didn't realize the language reference clearly stated that it was mandatory to use `self::` to import a path relative to the current module: &gt; Also note that the paths contained in `use` items are relative to the crate root. So, in the previous example, the use refers to `quux::foo::{bar, baz}`, and not simply to `foo::{bar, baz}`. But then, I wish to know if there was any rationale behind the design decision, especially when relative lookup just works without `self::` in `type`, as I showed in the above example. Incidentally, `type U = b::c::Z;` doesn't compile but `type U = ::b::c::Z;` does. [`3.6 Paths`](https://doc.rust-lang.org/reference.html#paths) states &gt; Paths can be denoted with various leading qualifiers to change the meaning of how it is resolved but it is not clear about paths without those special qualifiers.
To add to this, it is customary to `impl IntoIterator for &amp;T` that calls `T`'s `iter()`.
I can feel the pain of that Haskell developer, as long compile times are also one of *my* biggest gripes with Rust as well. I hope that in addition to incremental builds, there will be significant improvements to the general performance to the compiler. I work on multiple projects, and I update to the latest Rust nightly often, causing me to have to rebuild *every single* project I'm working on, with all of their dependencies, so every little improvement to the compiler performance would help. Not to mention faster compile times would also make rustc itself bootstrap faster, boosting the productivity of rustc developers. One of the reasons why I don't contribute to rustc is because I don't have a beefy enough machine to reach compile times that I have patience waiting for.
I saw a [comment](https://www.reddit.com/r/rust/comments/44rnqh/hey_new_rust_users_got_an_easy_question_ask_here/d00eyey) from /u/zzyzzyxx on someone else's question that made me try changing the signature of `Arr::box_iter` to `fn box_iter&lt;'a&gt;(&amp;'a self) -&gt; Box&lt;Iterator&lt;Item=&amp;'a i32&gt; + 'a&gt;` and everything suddenly works. I guess I read this is as saying the Iterator also has lifetime `'a`, which I guess sorta makes sense? But I don't understand how to connect this solution to the error messages I was getting. Is the `T + 'a` syntax documented in the Rust book somewhere? I don't see it in the obvious places, and it's a hard thing for a noob to google. Also: what's the logic behind the syntax? It seems incongruous. There's `&amp;'a T`, but not `'a T`. It's instead `T + 'a`? Maybe I'm still misunderstanding. (And, speaking perhaps over-harshly from frustration: this seems important. I feel like I'm steered toward using Iterators for everything, but I can't return them unboxed because there isn't consensus on an "impl Trait" solution, and I'm *also* not told how to box them so I can at least get it working some other way. I'm not sure how I'm supposed to approach this, and I don't understand why every newcomer isn't constantly tripping over this. I mean, aren't boxing and iterators the core-est of the core abstractions? Probably this is my fault for diving right in and jumping around The Book instead of reading straight through, but I still feel like this oughta be more discoverable somehow.)
 &gt; I'm also wondering if the name is good. I think something with "replace" would be a good name, since this is much like `std::mem::replace` but with a closure. So I'd go for "replace" or "replace_with". &gt; I'm also wondering about usefulness, I sort of imagined that this could help reduce usage of the "Option dance", but I'm not sure how much. It could perhaps also be useful if `Foo` has builder methods like ` fn bar(self) -&gt; Self` but all you have is a `&amp;mut Foo`. 
My opinion is that 1. dev rebuilds of large projects should be fast when very little is changed (i.e. "crate as a whole" build method may not be the best) 2. release builds can be slow 3. some compromise, dev-with-some-optimisations is needed, as some projects can be so slow in dev builds that testing is difficult
Turn codegen units on, it makes things much faster (slightly less efficient though).
It's a major focus, yes. Nick Cameron has an automated benchmarker set up [here](http://www.ncameron.org/perf-rustc/). It had stopped working last month (which is when a major perf regression sneaked in through llvm), but it's back. This does not gate anything. We may eventually set up something like [Talos](https://wiki.mozilla.org/Buildbot/Talos) for Servo, and perhaps Rust can use that too.
it's relatively easy to fix, but the error messages are misleading: whenever you write out the type of a trait object, the trait object needs to have an appropriate lifetime. Only types that have at least that lifetime can be casted to this trait object. Because most of the time we use and need `'static`, whenever you write the type of a trait object and don't attach a lifetime via `+ 'lifetime`, it is implicitely assumed to be `'static`. So where you wrote `Box&lt;Iterator&lt;Item=&amp;'a i32&gt;&gt;`, it gets treated as `Box&lt;Iterator&lt;Item=&amp;'a i32&gt; + 'static&gt;`. Now your `slice::Iter` object only lifes `'a`, so it can't be casted to that. The trick is simply to use `Box&lt;Iterator&lt;Item=&amp;'a i32&gt; + 'a&gt;` instead. [working playpen](http://is.gd/kZy88L)
Yep... `impl Trait` return types will be very much welcome once they land.
&gt; It seems a good idea to put an iterate() back in the std lib, because it's handy. Most iterator adapters are handy at some point, to someone :) The problem is just that there are so many of them, and `std` cannot have them all. If it's not in `itertools` yet, I'd start adding it there.
[You don't have to be able to compile the compiler to contribute.](https://github.com/rust-lang/rust/pull/31535) Improving docs is absolutely a contribution. :)
I specifically meant contributing to **rustc**, which is the compiler.
&gt; with incremental compilation so close. what's the timelime or status on this? I lost track of it when the MIR discussion took over.
This is a part of the borrow checker that needs improvement. Should get fixed post MIR I guess? https://github.com/rust-lang/rfcs/issues/811
Might be a good opportunity to show off Rust (providing it performs well...)
not an expert, but I think without green threads, this sort of toy benchmarks (with 1M actors doing nearly nothing) would be a particular bad scenario for Rust
Works perfectly, thanks! I guess the logic is that I can't take a reference to the reference and expect it to live past the end of the function, only the data the reference references, hence I need to take a copy of (move) the reference.
&gt; Well, six is still a bigger number than one so it's not completely nonconcurrent… That's true, but 5 out of these 6 are just waiting for the next one to finish :)
So, basically all the hard stuff still needs to be done. Right now `jupyter-rs` spins up a few threads, initializes a zmq context, and opens all the ports necessary to connect to a jupyter frontend.
Hey, I don't want to argue. I'm sorry if you are feeling dismissed. Part of the problem here is that this particular question happened a long time ago, so it's hard to recall the exact details, and you asked me over a busy weekend. I didn't want to ignore you, but I also didn't really have time to write out a big thing, so I tried to give to-the-point answers.
It seems like this benchmark does not actually use multicore but just tests channels and lightweight-tasks of the languages in question, though it is not 100% clear from the documentation and when I compare with local benchmarks it does not match the results if I actually specify any number of cores for the programs (or set to 1). Most likely it is left to the runtime of each to automatically decide the number of threads to use. Go is much faster if `GOMAXPROCS` is set when running the program (it defaults to single-core in most versions of Go), Haskell is compiled without support for threading but benefits greatly if compiled with `-threaded -rtsopts` and run with `+RTS -N8` (and I get a very slow execution compared to eg. Go if I compile and run it as the readme specifies, it does not match the ratios of the specified numbers at all). Node.js is also singlethreaded, which makes it an unfair comparison if multiple cores are allowed to be used (or threadsafe channels are to be used in a singlethreaded context) and the intention is to test the efficiency of channels and lightweight-tasks. To make a fair comparison Rust should probably be run in a single thread with a job-queue using non-threadsafe channels. Results on my laptop (MacBook Pro (Retina, 15-inch, Late 2013)): * Go `GOMAXPROCS=1`: 1.19 s * Go `GOMAXPROCS=8`: 0.35 s * Haskell (7.10.3, without `-threaded`): 47 s * Haskell (`-threaded -rtsopts` and `+RTS -N8`): 7.93 s * Node.js (v 5.6.0): 0.22 s * Erlang (7.2.1, non-HIPE): 1.30 s
Yeah, I saw that after looking into it a bit. And if I interpret it correctly it always has to be a REPL in the backend? That would mean the only current path would be integrating [rusti](https://github.com/murarth/rusti), which works (and AFAIK always will work) on nightly? :/ (also found [this rusti issue for a Jupyter integration](https://github.com/murarth/rusti/issues/43))
There's so much misinformation around this silly little test that it boggles my mind... Scala has no coroutines or green threads. Scala Futures are just scheduled in a plain old Java stdlib thread pool. To make a similar Rust version, create a thread pool with n CPU threads and use Rust Futures to run inside that thread pool. Don't spawn a POSIX thread every time. That's just silly. 
How would I represent an AST in Rust? Working on a little LISP based on o-expressions (http://breuleux.net/blog/oexprs.html) (not sure yet whether I'll finish ;-) )
It should already be on by default for debug builds.
IIRC package signing on crates.io came up on this subreddit before (though I can’t find links at the moment). This article is about Python / PyPI, but it applies equally well to Rust / crates.io. As usual, crypto can only reduce a problem to key management, and knowing which keys to trust is not easy.
I've spent some time with my [D-Bus bindings](https://crates.io/crates/dbus), implementing a slimmer / less allocating way of getting message arguments in and out of a message. The previous way was [a big enum](http://diwic.github.io/dbus-rs-docs/dbus/enum.MessageItem.html) of all possible argument types. [The new way](http://diwic.github.io/dbus-rs-docs/dbus/arg/index.html) is highly generic/monomorph and took a few attempts to get right, but now we can, e g, return strings as `&amp;str` instead of converting them to `String`. As a bonus, we can now generate D-Bus signatures from types (e g, call `Dict&lt;&amp;str, Variant&lt;_&gt;, _&gt;::signature()` for a D-Bus String =&gt; Variant dictionary) so now you don't have to know the syntax of D-Bus signatures to make server methods. What was annoying at some points was the lack of being able to turn traits with static methods into trait objects; I could have supported more use cases if that was possible. I don't see a problem with just adding the methods to the vtable, even though they don't take a `&amp;self` parameter? 
I gave it a quick go: https://github.com/rphmeier/skynet-jobsteal. Seems to perform about as well or better than the other implementations. See the numbers yourself to compare. I wasn't sure whether to include the time used to create the pool, so I did just be to as fair as possible. Edit: Some people may be wondering why I haven't submitted this as an entry to the main skynet repository. I have a few reasons for this: - I doubt that my own little parallelism crate represents the Rust community at large. - As a third-party solution, it doesn't necessarily portray Rust's intrinsic capabilities correctly.
&gt; The problem is just that there are so many of them, and std cannot have them all. I agree, you can't have them all. But after writing similar kind of code for years, I've seen that there is a reasonably small group of higher order functions that are enough for most cases, that I think are worth having in a standard library. If you write a script-like Rust program you probably don't want to use an extern itertools.
Thank you. I am using this code: const SIZE: usize = 3_000; type T = u64; type TM = [[T; SIZE]; SIZE]; fn sub() { let mut tot = 0; let m: TM = [[1; SIZE]; SIZE]; for r in 0 .. SIZE { for c in 0 .. SIZE { tot += m[r][c]; } } println!("{}", tot); } fn main() { use std::thread::Builder; use std::mem::size_of; Builder::new() .stack_size(size_of::&lt;TM&gt;() + 1_000_000) .spawn(sub) .unwrap() .join() .unwrap(); } But a compilation switch to change the size of the main thread seems a nice enhancement for Rustc.
Shit! Sorry, corrected.
0.07 seconds on my machine, compare to numbers in https://www.reddit.com/r/rust/comments/45w9ll/anyone_want_to_try_a_rust_version_of_this/d00omoe But this is still slightly unfair in that it does not use any channels to propagate the data to the parent task. I made a fork of your code which uses channels here: https://github.com/m4rw3r/skynet-jobsteal/tree/channels The performance using channels is still very good, running at around 0.1 second.
Does the RLS have a repo yet?
I tried to run the go version on my laptop, but I didn't have golang installed. Using the golang package in Ubuntu 14.04, I just followed the directions and did a `go run skynet.go`. This immediately led to my laptop becoming unresponsive for about a minute or so until my mashing of Control-C got through. After this, my laptop was sluggish until I restarted. No idea what could have caused that.
Thanks for the response. Although I understand intuitively why an Iterator cannot outlive its container, I'm still trying to understand how I'd know that just looking at function signatures for cases that aren't as obvious as this one. For example, looking at the primitive slice iter() method, its signature is `fn iter(&amp;self) -&gt; Iter&lt;T&gt;`. I read that as "let me borrow self, and I'll return to you an Iter that you own". Since I own it, why can it not live as long as I want? (I think the answer here is that `slice::Iter&lt;T&gt;` is actually `slice::Iter&lt;'a, T&gt;` with the lifetime elided. And technically, it's not even the `'a` lifetime parameter that's determining the lifetime, but rather the fact that it contains references that have that lifetime, but I'm less sure about that one. Anyway, if there were no elided lifetime parameter on the return value, would that be enough to assure me that the return value could live as long as it wants? Separate aside: for some reason lifetime elision of `&amp;'a self -&gt; &amp;'a Data` is intuitive to me, but `&amp;'a self -&gt; Data&lt;'a&gt;` is not.)
[Here is a version](https://gist.github.com/birkenfeld/b497cb538720c943d5d6) using channels. It's about 50% slower than yours.
Work continues on my [nascent GBA emulator](https://github.com/Ketsuban/rustboyadvance)—I've done some big refactors to add support for the saved program status registers, but the resulting API is still a little sloppy so I'm open to suggestions on making it neater.
i read a very insightful comment here. can’t find it but i’ll paraphrase it: &gt; a CoC is always an act of balance between being too despotic for some and being to permissive towards abusers for others. language is hard and it’s easy to both use rules and their absence to “legally” terrorize decent people. i won’t cite rust’s CoC, but e.g. github’s: &gt; Harassment includes […] &gt; * […] simulated physical contact (eg, textual descriptions like “hug” […]) &gt; * Publication of non-harassing private communication so it’s OK to publish private conversation once someone wrote “hug” to someone else once. obviously it’s just as easy to find a way of harassment that isn’t listed. --- nonetheless i really like rust’s CoC!
I also believe that the answer is what you think, but I haven't done a whole lot of detailed work in this area, so I'm not quite sure, to be honest. I have to be in a certain mindset to dig into complicated cases like this one, and I'm not there at the moment :)
oh, forgot to check the https-less link
I was going to experiment and see if there were ways other than `rusti` to make this work. I was going to experiment with alternatives, because I don't think jupyter notebooks have to be restricted to _just_ the "repl" model on the backend. But, yes, it is possible that all my experiments would fail and I would end up having to just stick `rusti` on the backend and call it good.
Search for cargo-edit :)
Is this a drop-in replacement for Any? IOW, should we consider deprecating Any and replacing it with this?
Rust Language Server: https://github.com/rust-lang/rfcs/pull/1317
Impressive! Thanks!
It seems like highfive could be trivially extended to do this. It already responds to change-labels commands from core team members.
It probably would be a part of rustc itself given the level of integration it needs.
(and rustc is built in opt mode by default IIRC)
true FP16 ALU support is coming in GPUs (driven by AI workloads) - see nvidia pascal; http://wccftech.com/nvidia-pascal-gpu-gtc-2015/ (keyword 'mixed precision'/'half precision') Explicitely, it's a tradeoff to allow more low-precision operations inflight in parallel, not just to save memory (which was the traditional use of FP16 as an 'in-memory' type). Seems we've come full circle (past GPUs used to have lower precision pixel operations in separate pixel pipelines before the days of unified shaders) It's true that support is not widespread *yet*, but the type exists for good reason; I haven't seen the need for F128 myself but imagine it has similar niches where it's a game changer. I'd expect more processors to support it in coming years, given the potential of machine learning/machine-vision generally. There are new classes of chip coming out targeted at this space (e.g. Movidius, Eyries,epiphany) - and various attempts to bring CPU and GPU capabilities closer (HSA, intel knights-landing ), and with spir-V it would be great to drive a GPU with lambdas in your main program.. Rust could get ahead of the curve by having native support, if you choose to add this
Yup, I think so too.
The closure is supposed to return a new value for the `&amp;mut T` to point at before the real owner of the `T` notices that anything has happened. Critically, the closure takes an argument of type `T`, so it thinks it owns the `T` even though in truth there is another owner somewhere. If the closure panicked, it apparently couldn't come up with anything for `T`, as you say. As the panic unwound out of the closure, `T::drop` was already run. This is a big problem because the actual owner is planning to run `T::drop` at a later time. So the only (?) way to prevent memory unsafety (double drop, or two `&amp;mut` references to the same place) is to prevent the program from doing anything else at all, i.e. kill it immediately.
Since two people have now responded to change the code to channels, I will probably do likewise (feel free to submit a PR since it looks like you already have a fork). The next question is whether it should record the start time before or after creating the pool/channel. Go and Crystal record the start time after the channel is created, and the pool creation is implicitly before main.
I sincerely doubt Rust will ever have built-in lightweight threading support. We tried that with libgreen back in the day, but we wanted to have a minimal runtime, so that had to go. And it's not a big deal, either, since user-created libraries can perform similar functionality. In the past few months, we've seen an abundance of thread pools and parallelism libraries, most of which work seamlessly with Rust's borrow checker to provide simple parallelism.
&gt; &gt; &gt; On one hand, I figure that most of the languages using channels do so either because it is largely unsafe to use pointers in this way or they are the only method available. On the other hand, Rust's borrow checker is exactly what makes using pointers like this provably safe, so it feels wrong not to take advantage of that. I agree. I just wanted to try how much slower channels would be, and share the result. Using channels may be a bit more flexible once you go beyond simple integers to add, but the pointer-based version is showing off one of Rust's strengths, so I wouldn't discard it.
The interesting thing is that you can still use pointers for arbitrary types, even if they aren't Copy/Clone through the power of Option! See the implementation of [Spawner::join](https://github.com/rphmeier/jobsteal/blob/master/src/lib.rs#L351) for a fully generic example.
It's time that I start working on the network stack for [Uni.rs](https://github.com/uni-rs/uni.rs) again. Arp response and ping are currently working and should land in the repo this week. Next step is to make UDP work.
I've submitted a (pretty naive) implementation using coroutines-rs, as a PR to the original repo: https://github.com/atemerev/skynet/pull/45. Please feel free to comment and improve.
No, it's not a complete replacement. Unlike `Any`, `Dynamic` is not actually a trait, it simply stores a trait object of a private trait `trait Dyn {}` which is implemented for all types (and a `TypeId`). This means there is no `Dynamic + Send`, etc.; while it would be possible to enable similar behavior it would come at a steep complexity cost. (see the implementation of similar generic behavior in https://github.com/reem/rust-typemap to allow maps with bounds)
&gt; the Rust ecosystem provides a little gem called Timely dataflow. I thought I was reading a Ruby post for a minute, until I remembered that "gem" was a concept in normal English and not just the word for "library in Ruby" ;)
&gt; &gt; Somebody needs to make BigData tools in Rust &gt; &gt; Too true. Do yinz have examples of Big Data tools that would be nice to have in Rust?
Yeah, you could use this in the implementation of an `AnyMap`/`TypeMap` but there actually won't be any performance benefit since you can already do unchecked downcasting in those structures. These structures have to be type-directed, since you can't just compare two `Dynamic` values; even if you know that they are the same type, you don't know what type that is.
Ah, good. Because `HashSet&lt;Box&lt;Any&gt;&gt;` and `HashMap&lt;Box&lt;Any&gt;&gt;` don't work right now due to the `Hash` bound, which implies an `Eq` bound, which isn't object safe :/
In theory, it's not permanent. It's more a result of effort being directed toward `Regex::new`. I think the main driving factor here is that making `regex!` produce fast code for some *subsets* of regexes is probably not a terribly difficult thing to do, but in order to support everything (sub-captures, mainly, I think), I suspect it too might need multiple matching engines like `Regex::new` has. It's pretty yucky, but possible. If we dropped the `static` requirement, then maybe it would be easier (because it could perhaps reuse existing matching engines defined for `Regex::new`).
I really don't know how to handle the name bikeshedding, and whether I'd have to somehow rename the library itself. I don't know how I'd actually get started on stdlib inclusion. An RFC?
I might have already said this elsewhere but: _Read this code!_ /u/BurntSushi has the gift of turning complex CS papers into well commented, pragmatic code.
It's not quite in the spirit of things, but [rayon](https://github.com/nikomatsakis/rayon) shows off quite well. I've uploaded it [here](https://gist.github.com/anonymous/87b6cfb48f19ad7c2aa1), which also includes /u/rphmeier, /u/birkenfeld, and /u/m4rw3r's versions: test bench_jobsteal ... bench: 55,431,834 ns/iter (+/- 12,840,995) test bench_jobsteal_channel ... bench: 110,501,708 ns/iter (+/- 21,324,486) test bench_jobsteal_channel2 ... bench: 110,170,646 ns/iter (+/- 15,499,356) test bench_linear ... bench: 5,658,440 ns/iter (+/- 1,357,386) test bench_rayon ... bench: 4,450,592 ns/iter (+/- 1,075,631)
For perspective, Go has been famous for tiny compile times but has grown through 1.5 and 1.6. The dev team now plan to focus on reclaiming compile time, saying that little attempt was made to optimise new features, and they expect to recoup much or all of it. A policy preventing compile time increases would be obstructive to the kind of deep surgery I gather was necessary to reduce GC pause times in Go, so I think it would be a problem for big projects in the language's development.
&gt; Don't use the regex! macro. How fast/slow is `Regex::new` itself? I mean regex parsing and compilation, not matching with the result of `Regex::new`. One advantage of the macro is that it does this work at compile time. There is not always a convenient place to call `Regex::new` and keep the result around for matching many times. What do you think of a new macro based on `lazy_static!` and `Regex::new`?
Compilation can be as fast as a few micro-seconds and as slow as a few milliseconds (e.g., `\pL{100}` takes around 20ms if micro benchmarks are to be believed). &gt; What do you think of a new macro based on lazy_static! and Regex::new? I guess an interesting thing there is that the macro could be just a regular macro and not a compiler plugin. Although, that would prevent compile time checking of regex syntax (but maybe clippy will do that now). We could check syntax, but it feels like maintaining an entire compiler plugin just for that is a bit overkill. I did add some docs about using `lazy_static!` to conveniently compile a regex only once: https://github.com/rust-lang-nursery/regex#usage-avoid-compiling-the-same-regex-in-a-loop (I honestly don't feel very strongly here because I mostly live in Rust stable land. I don't really mind maintaining `regex!` in whatever form it's in, it's just that since it exists, people will use it, and right now, it's probably not a good idea because of perf. I also don't want to spend my cycles right now improving `regex!` and would instead like to improve `Regex::new` and reach 1.0.)
It's not deprecated in cargo but in crates.io. You can specify "*", do `cargo update` and then copy the version from `Cargo.lock`. But the approach with `cargo-edit` is easier, of course.
I took a look and removed unnecessary allocations. Sent you a [pr](https://github.com/ereichert/elp/pull/15) :-)
You can mark static methods with `Self: Sized` to allow the trait to still be used as a traitobject. This also works for any functions which refer to `Self`. trait Test { fn test() where Self: Sized; } 
Worth noting this won't build on MSVC Windows as the dependency context (https://github.com/zonyitoo/context-rs) uses "AT&amp;T Style" assembler. What are your thoughts on https://github.com/rphmeier/skynet-jobsteal?
Ah, I wasn't thinking about the details of the unwinding process. I think I was assuming a panicked thread just got cut off at the roots the way exit does to a process.
Could you silently turn the regex! macro into a wrapper around Regex::new() and add a lint? That way it won't break anything. edit: Just remembered it's nightly only, so no one should be relying on it - just remove it for now, in my opinion.
That's basically what others have suggested (using the same technique as `lazy_static!` so that it continues to work as a static).
They accepted a Node version and Node doesn't support concurrency afaik so it's just a silly round about way to make delayed computations which are consumed later. So in that vein, I wrote this pile of garbage (which gets the correct answer very quickly (25+x faster than node on my machine)): #![feature(fnbox)] extern crate time; use time::PreciseTime; use std::boxed::FnBox; enum Promise&lt;T&gt; { Val(T), Future(Box&lt;FnBox()-&gt; T&gt;) } impl&lt;T&gt; Promise&lt;T&gt; { #[inline] fn force(self) -&gt; T { match self { Promise::Val(x) =&gt; x, Promise::Future(f) =&gt; f() } } } fn skynet(num: u64, size: u64, partition_size: u64) -&gt; Promise&lt;u64&gt; { if size == 1 { return Promise::Val(num) } let tasks = (0..partition_size) .map(|i|skynet(num + i * size, size/partition_size, partition_size)) .collect::&lt;Vec&lt;_&gt;&gt;(); Promise::Future(Box::new(|| { tasks.into_iter() .map(|t| t.force()) .fold(0, std::ops::Add::add) })) } fn main() { let t1 = PreciseTime::now(); let val = skynet(0, 1000000, 10).force(); let t2 = PreciseTime::now(); println!("{}", val); println!("Skynet time: {}", t1.to(t2)); } This was pretty fun to write and helped me get to grips with returning closures from functions. So while I think the actual benchmark results for skynet are rubbish, it was a nice excuse to do some code kata. Thanks to durka42 on IRC for some of the help in working with `FnOnce` and learning about `FnBox`. Edit: Removed `Display` since I only had that for some diagnostic stuff.
Why is [this](http://is.gd/IWnlJV) not compiling? There doesn't seem to be anything different about the bad line. Also, rearrange them, and it's always the first line with a `to_string`.
Is there any code publicly available for these posts? Would be very interedted to see it.
Just for the sake of making sure I got the lazy DFA algorithm right: * The lazy DFA algorithm uses the [powerset construction](https://en.wikipedia.org/wiki/Powerset_construction) (aka the good ol' NFA to DFA algorithm), but instead of computing the entire DFA, it only computes one DFA state per char read, that is the next state to transition into. * The purpose of the DFA state cache is to avoid the potentially exponential blowup of the algorithm. Is that right? Or have I reached some wrong conclusion/skipped something important/etc?
Because you are pattern matching and non of those patterns make sense (you are trying to do call functions from the pattern match, while no code in the pattern is *ran*, its just *matched*), but even if it would you don't want to do that but [this](http://is.gd/ozhK9M), `.as_ref()` creates a `&amp;str` string slice. 
Pretty much, yup! To clarify, the state cache is used so that previously computed states are reused. The *bound* on it is what prevents worst case regexes from being exorbitant memory hogs. Once the cache fills, it is wiped and any state that had been previously been computed will need to be recomputed if it is visited again. In the worst case, a new state is created for every byte of input, which effectively makes the cache useless. It would be more memory efficient in those cases to just not use a cache and recompute every state on the fly. Of courses, that's effectively what the NFA algorithm is! (It would be nice to fallback to the NFA algorithm in those worst cases, since it is indeed a little fast than the DFA in those cases.)
Oh, and with regard to powerset construction... That is also basically right, with a twist: each DFA state is an *ordered* set of NFA states. This is necessary to preserve the "leftmost first" matching semantics of most popular regex engines (like Perl). In particular, it is needed for implementing greedy/ungreedy quantification, among other things.
I have no earthly clue about how it's actually implemented (and it's likely you've already checked), but I recall that D can statically compile regular expressions. Perhaps take a look at how they do it?
Any talks about integrating this world class regex engine in the standard library? :)
I doubt it. My focus is on getting it to 1.0 and into the rust-lang org. Technically, that's one step closer to std, but I suspect it will remain an external crate if only for its size and complexity.
This is probably a bit off-topic, but how is stuff like greedy/non-greedy quantification, grouping etc implemented in terms of a DFA? My understanding is that for an NFA you probably only need to tag the relevant states with metadata, but I have no idea at all how you'd do such a thing with a DFA.
Wrong Rust sub. You're looking for /r/playrust
Practically probably as you say below, by giving it multiple matching engines. (From memory, it's possible to get DFAs to return subcapture locations by duplicating states, though obviously then you end up with further state increase.) [Edit: http://laurikari.net/ville/spire2000-tnfa.ps is what I'm thinking of.]
To-the-point answers are great. If you can't recall the details, that's fine too. But if you don't have time to answer a question, then don't. Just don't.
Neat crate! I suspect it makes more sense to not call `process::exit`, since that's a more well-behaved exit than what should be being conveyed here. Something like `libc::abort()` might be better, since, e.g., debuggers should catch that automatically.
How about just changing `regex!()` for the time being to simply statically verify that the regex is valid, and then still call `Regex::new` at runtime? Sure, you lose the benefit of having the regex be pre-compiled, but the static verification of a valid regex is still really useful. Edit: Oops, that runs afoul of the `static` requirement.
Delete the post? 
I think that bugzilla would be a bad idea -- the user interface is ugly. Trac works well (I find GHC's Trac easy to use) and I think that Redmine *looks* great -- but I have never used Redmine so I can't say.
As far as Google can tell, FOF ATP has something to do with tennis. Can you expand that acronym? :)
re: [Code of Heat Conductivity](https://llogiq.github.io/2016/02/10/code.html) I see [this has been posted before](https://www.reddit.com/r/rust/comments/450zy7/blog_code_of_heat_conductivity/), and I missed the discussion. Oh well. As someone who's generally not very happy about CoCs, I'd like to elucidate why. The most preeminent codes of conducts are more than just rulesets; they're also an implicit pledge of allegiance to one side or the other of the current culture war. The most salient example of this is Coraline Ehmke's [Contributor Covenant](http://contributor-covenant.org/), but there are others. Codes of conduct are ostensibly about inclusiveness, and I think inclusiveness is really something worth working towards. But, and this is a bit ironic, I find myself avoiding projects marked with the Contributor Covenant like the plague. Not because I'm principled, not because I think I'm making a brave stand or anything like that, but because [*I don't want people having that kind of power over me*](http://squid314.livejournal.com/329171.html). Quoting feminist academic [Fredrik DeBoer](http://fredrikdeboer.com/2016/02/08/if-youre-not-careful-whos-in-and-whos-out-becomes-the-only-question/): &gt;The problem with associative politics writ large is that they work only on those who are already predisposed to care about the approval of the given in-group. Conversely, you can avoid [all kinds of interpersonal catastrophes](http://www.amazon.ca/So-Youve-Been-Publicly-Shamed/dp/1594487138) by making sure you have absolutely zero need for that in-group's approval. ________________________ This isn't about me trying to preserve my right to be a racist or anything like that. I'm the son of two feminists, I was a militant feminist up until about 2014. I haven't suddenly become a monster. I still make extra sure I'm giving underprivileged people the credit they are due; I find myself semi-regularly providing physical protection to random women on nights out. I wholeheartedly welcome being told when I accidentally act in a racist/sexist/etc. manner, so long as it is done respectfully (and ideally in private). So be sure that, whatever it is that makes me keep my distance with feminism, it's not just a dumb desire to be sexist/racist with full impunity. [I just want to be out of the firing line.](http://slatestarcodex.com/2014/06/14/living-by-the-sword/) And that involves not letting social justice types hold social power over me. /u/graydon is one such person I find immensely threatening; if there were three or four of him on this subreddit, you can be damn sure I would have found another language to write my OS in. ________________________ **What does this all have to do with Codes of Conduct?** I think CoCs are a good idea in the abstract, and I think well-designed CoCs can be a serious asset for a project. But a CoC *must not* be a barely-disguised pledge of allegiance to the social justice movement. Contrast the Contributor Covenant above with the [Recurse Center's amazing CoC](https://www.recurse.com/manual#sec-environment). The Recurse Center is a feminist hacker school, yet their CoC artfully manages not to imply that you will be tarred and feathered if a minority member of the community asks for it. IMHO, a good software code of conduct should avoid: * Laundry lists of protected classes. The Contributor Covenant lists *twelve* such classes. They're one of the most obvious shibboleths of the social justice movement. Besides, by trying to exhaustively list traits that shouldn't serve as bases for discrimination, you infallibly miss a few. * References to oppression, privilege, and other concepts from intersectional theory. Those are are *good* concepts, they're an excellent language for discussing social ills, and they *absolutely do not belong* in a code of conduct. * "Minimum sentence" type stuff. "Project maintainers have the right **and responsibility** to..." Hell no. Trust the human, damn it. * E: defining away discrimination against privileged classes as "reverse racism/sexism" etc and thus not a problem. ____________________________ **TL;DR**: damn social justice, you scary.
Not sure where to ask this, but is there any chance we're going to eventually get an extensible interface for implementing `std`? I'd like to eventually port it to my OS, but right now that involves maintaining a fork of the compiler. No bueno.
I never really understood why tools like Hadoop or Spark should use JVM. And writing a distributed filesystem in Java is also a strange idea. Anything like that would benefit a lot from better performing languages.
Have you looked into how http://speed.pypy.org/ is generating their "How has PyPy performance evolved over time?" chart?
First Order Formula Automated Theorem Proving.
Didn't consider that you wanted to call it as well. That isn't a problem though. ~~Just add a method with a default implementation which takes `&amp;self` and calls your static method.~~ Adding a default method wont work but you can add a method which takes `&amp;self` and implement it using your static function. trait Test { fn test() where Self: Sized; fn self_test(&amp;self); } EDIT: It might be a bit easier to use two traits. A base trait which has your static function and a super trait which has the `&amp;self` version and then you have a default implementation for the super trait. `Any`in the standard library does something like this [Link](http://doc.rust-lang.org/src/core/any.rs.html#92-98)
[maybe this is relevant?](https://internals.rust-lang.org/t/libsystem-or-the-great-libstd-refactor/2765/1)
Except the missing semicolon. You can't expand macros from inside structs: macro_rules! m { () =&gt; {x: i32}; } struct Name { m!(), } 
I updated my portfolio website recently and used a similar method, where some of the information was baked into the binary and some were left as files (I may embed even more as I figure out a good workflow). I'm using [phf](https://crates.io/crates/phf) with [phf_codegen](https://crates.io/crates/phf_codegen) to map project handles/slugs/urls to various project data, and it's built from a directory structure. What I imagine you could do is to combine phf with `include_bytes!` to map paths to binary data and create something similar to `go-bindata`, ~~but beware not to overly bloat the executable with huge files. They will all live in RAM all the time, as far as I know, and you want some of that for other stuff.~~ Edit: But what do I know? :)
That's a really cool lint! I'm sure it's quite small, but that sort of check is awesome to have.
Yeah, I suspect the author hasn't seen TUF - it solves a lot of problems in this space.
&gt; by omitting the noalias attribute on &amp;mut function arguments. nooooooooo, the llvm bug is reported [here](https://llvm.org/bugs/show_bug.cgi?id=25422). Is somebody working on fixing that LLVM issue? It seems like there hasn't been any activity since november 2015.
&gt; I think the graphs more or less speak for themselves The y axis are not labelled. I guess you are plotting the performance index, but I cannot find how this is computed (it is just the time it took to run the benchmark?). Without this information I cannot make anything out of the graphs. I tried to see if some spikes/drops would appear in multiple packages, since that would mean that a given commit had an influence on performance. But couldn't do that since the x-axes are not the same for all plots. Checking this would be nice, that is, if there is a performance drop due to a single commit along multiple packages then that would be a serious regression.
/u/dbaupp and I used to have a benchmarking + reporting setup, which you can see the (old) results of here: http://huonw.github.io/isrustfastyet/. at the time, though, memory and time usage of the compiler was far more interesting to me than performance of compiled code (huon plotted that information from the benchmarks that ran on the buildbots, but the data were always somewhat noisy). I used to have a copy of rustc built from every merged PR since sometime between 0.5 and 0.6 (a few TB!). Chosing good benchmarks to measure the quality of compiled code is really hard, and I'm not sure runtime is the most useful metric, although it's the easiest to measure. for actually tuning the compiler, more interesting would be things like code size, number of basic blocks and their sizes, branch mispredicts, cache misses, or instructions executed, and maybe where the most time is spent. Runtime alone obscures all of these variables, which are really important for determining the cause of a slowdown! Pinning the LLVM version could also be useful, but that's harder to do over reasonable amounts of time.
You might be interested in Python's `for`/`else` construct: the `else` clause is entered if execution drops off the end of the `for` loop, rather than `break`ing out. It tends to be kind of obscure, and if you don't already know about it it's not very clear under what circumstances the `else` would be executed.
Sadly, this syntax's meaning has already been poisoned by Python, which uses it for [something both completely different and *obviously insane*](https://docs.python.org/2/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops). I actually never use this in Python because every time I do, I get the semantics wrong. I believe people have already suggested this in the past, but with *Python's* meaning. No matter which way you go, you're going to leave people confused.
Ah I see. So the `else` executes the first time that the loop condition fails? **EDIT**: Apparently not. The actual python implementation is insane. To me, my suggested syntax is intuitive. But if other existing languages implement the same thing differently then I guess it could be misleading.
Hmmm, yes, I have stumbled across the tagged DFA/NFA stuff but hadn't explored it too deeply. It certainly looks promising! (At a glance, it looks like the tagged NFA is a formalization of the Pike VM, but I'm not sure.) Thanks for the pointer!
Yes, please. It should also be trivial to plot multiple graphs in one figure to verify.
I would be so much happier if these graphs started at 0 on the y-axis. The graphs make it look like there is an enormous fluctuation, when in most of the cases there isn't. It also needs to be clearer what the unit of measurement is. You imply that it's in ns, but you never explicitly say so.
Hmm, has there been any work on a Rust 'view engine'? That is, composing HTML from several files (with some kind of markup to indicate where data goes) into the Body of an HTTP response? 
[This chart](http://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/) may help clear some things up.
Well, 13K of those is The New Adventures of Sherlock Holmes for benchmarking. For the most part, it was just more convenient this way, plus I'm the maintainer. If someone else did it, I probably would have made them split it up so that I could digest the changes.
not sure if you saw my reply, http://wccftech.com/nvidia-pascal-gpu-gtc-2015/ (what did you mean by 'last generation'?) True FP16 is coming in the next generation of GPUs as a true performance/precision tradeoff, driven by AI workloads(especially machine-vision). Given the scope of this, I expect this will become more popular and widespread in time. If you wanted to drive GPUs with SPIR-V from rust directly, it would be nice to have F16 - and its' possible other CPUs will gain it
I'm not sure if it's possible at the moment, but has anyone considered or tried writing a compiler plugin for typesafe JSX expressions? Something like: struct Button { title: String } impl JsxComponent for Button {...} jsx!(&lt;Button title="Click me!"/&gt;);
Just to put the timeline in perspective, the (RFC) design work for compiler plugins is (probably) going to need a stable Application Binary Interface (ABI) first. Also a means of handling panics from plugins...
I see. I know little to nothing about those things :)
The y axis is the geometric mean of the runtimes of all benchmark functions for a crate, in nanoseconds. You're right that it should be labelled. Thanks for pointing that out! The x axes should be more or less the same for multiple crates, but you're right that it'd be nice to have them explicitly unified. EDIT: The y axis is now a normalized geometric mean of the runtimes. Each day is normalized against the first one in the series (usually the results from 9/1/15), so a 1.0 means "roughly the same as the first day we were measuring."
Noted, my medium-term plan involves a nicer page where I can update the data regularly and have all of the benchmarks on a single large chart. Thanks!
Awesome work – and incidentally the first time I see someone actually using my [optional](https://github.com/llogiq/optional) crate – even if just for benchmarking. :-)
Good that they took measures preventing it from getting out-of-date again :)
Agreed -- thanks for the feedback.
Thanks! I'll be uploading the raw JSON at some point in the next day or two. That's correct -- it's a single commit from each repo, with different rustc versions. Here's the manifest file I used to run the benches: https://github.com/dikaiosune/rust-runtime-benchmarks/blob/master/bench.toml The commits were in most cases the last time the version was bumped (i.e. what's likely to be available via crates.io). EDIT: The raw JSON and the ipython notebook are now also in the repo I linked above.
Nice, I must admit that I charged ahead without looking at what is typical for this kind of analysis. Perhaps a survey of other performance tracking sites is in order. EDIT: So the paper that PyPy links to suggests either the geometric mean of normalized numbers or the sum of benchmark results. I see a couple of issues with this. 1. The sum will ignore fluctuations that occur only in the smaller benchmarks. For example, if there are three benchmarks in a crate, and one takes 1000ns, and two take 50ns, we should still care about fluctuations that only occur in the 50ns iterations, as those might actually be called more frequently in practice. 2. Re: normalizing the numbers before a geometric mean, I guess they could be normalized against the first date in the series, but I'm not sure that would provide any greater accuracy or sensitivity than the naive geometric mean I'm using. I am of course open to being persuaded otherwise, just thinking out loud. EDIT 2: I decided to try out normalizing against the first point in each series, which provided some good consistency.
I agree that runtime alone isn't a particularly useful metric, but I honestly have no idea how to collect the other metrics you mention :). I do think that there's something attractive about benchmarking from the end-user perspective: nightly builds as opposed to custom builds (although the latter is an intended goal for secondstring), public crates instead of bespoke benchmarks, etc. But maybe I think that because I'm an end user of the compiler interested in how my programs will perform, not a designer of the compiler interested in fixing the root causes. Either way, I hope that something like this is a start towards uncovering the regressions, but I do think you're right that it has a ways to go before it'd be useful to the rustc team for tracking performance regressions.
Nothing can actually be the Holy Grail except for said cup. Package Signing is definitely necessary, but not sufficient. It doesn't mean we shouldn't start to put some machinery in place to enable signed packages. The original post is a bit of a strawman, it was directed at some nebulously defined noob who is taking a naive position. And in the lengthy of explanation that amounts to "shit is hard and complex" it diffuses the real need for verifiable packages on some level. Even after having written this, pypi still doesn't have a package authentication mechanism other than "it was downloaded over https". Only in the last couple years did they remove remote downloading of packages. Crates.io has two good properties: * All crates must refer only to crates that exist on crates.io * Deprecating of wildcard versions There are **many** attack vectors against a package repo and an ecosystem. Just like other things Rust, we should err on the side of safety and correctness. Is there enough publicly verifiable metadata to even regenerate crates.io should it get compromised?
[This](https://github.com/rust-lang/rfcs/issues/961) is the relevant RFC issue, for the record.
My first borrowck issue I'm stuck on; I'm trying to take a reference to a global const which I thought would be valid forever but the borrowck isn't having it: fn main() { let s = get_struct(); println!("{}", s.field.bar); } struct Holder { bar: i32, } const CONSTANT: Holder = Holder { bar: -88, }; struct Struct&lt;'a&gt; { field: &amp;'a Holder, } fn get_struct&lt;'a&gt;() -&gt; Struct&lt;'a&gt; { Struct { field: &amp;CONSTANT } } http://is.gd/LZXSqw Note that it's important that it doesn't only accept global const, that's just a placeholder to avoid Option&lt;&gt; and associated unwrap()s
https://github.com/Nercury/twig-rs
Seems like the # has the wrong title.
&gt; everyone would have a different idea about how for + additional clause works. So just make loops return an `Option` instead. That is unambiguous - though different from my suggestion. let a = for i in 0..100 { if i == 10 { break i; // Aside: syntax collision with: break 'label } }.or_else( 0 ); 
Note that I forgot to set the y axes to a sensible value -- I'm currently working on rectifying that, and it should look a little less scary when I've updated the graphs. EDIT: I normalized the results against the first point in each series, and graphed on a fixed interval. Hopefully less scary, although there's still some interesting variation.
It was just released! https://www.khronos.org/vulkan/
I uploaded the file to https://github.com/dikaiosune/rust-runtime-benchmarks (along with the toml manifest and the ipython notebook). I also took your advice about normalizing the values to the first point in each series, and then taking the geometric mean of that. Combined with a more sensible y-axis centered around 1.0 (since results are normalized), the graphs are less scary.
`finally` has the inverse problem as `else`: its connotation (from `try`..`finally`) is that it *always* runs. People will be surprised if, after a `break`, it *isn't* run. Fundamentally the issue is that there are two potentially relevant questions: whether the loop was ever entered, and whether it was exited with `break` (or whether it exited normally). In other words: whether the loop condition ever evaluated true, and whether it ever evaluated false. For an `if` these are mutually exclusive and so consistent, for a `while` they are not. Some people will implicitly think in terms of one and other people, the other. Any syntax that attempts to draw this kind of analogy will leave one group confused.
[Detailed information about the relaunch](http://www.arewewebyet.org/news/2016/02/16/we-are-back-baby/)
I started trying to translate cube.c to my own bindgen bindings a few days ago - but I haven't made much progress, and it is a very confusing and very long (2700 line) file. Have you gotten a demo application to run yet? Or do you know of clearer examples? The docs were hard to navigate before release.
https://github.com/SaschaWillems/Vulkan These demos end up being ~800 lines (+ base class &amp; common code).
I was first shocked by how long the file was, but looking closer I realized that a lot of this is boilerplate like redundant `struct Struct_xxx {…} type xxx = Struct_xxx;` and its accompanying `Clone` and `Default` impls. Also, why does an antipattern like hard-wrapping the lines still exist today? People have different screen-sizes and some (like me) prefer proportional fonts for coding (for anything really), so the lines should be soft-wrapped by the editor/IDE of the user's choice, if the user so prefers. Anyway, because all the function type definitions begin with `::std::option::Option&lt;unsafe extern "C"`, hard-wrapping means that not only do function definitions take multiple lines, but many parameters are spread over multiple lines. The actual content is ~150 functions and a few types. In other matters, I made a [post](https://www.reddit.com/r/rust_gamedev/comments/4638e9/anyone_working_on_a_vulkan_binding_already/) on /r/rust_gamedev asking about idiomatic bindings in development. Should I crosspost?
&gt; Also, why does an antipattern like hard-wrapping the lines still exist today? People have different screen-sizes and some (like me) prefer proportional fonts for coding (for anything really), so the lines should be soft-wrapped by the editor/IDE of the user's choice, if the user so prefers. I can't cite a language without style guidelines, whether official or unofficial, that recommend hard-wrapping the code to keep it under a predefined line length (usually 80, 100 or 120 characters). I'd be happy to learn about those that don't have such guidelines. I personally find it it _way_ better to read code with newlines inserted at specific, semantically sound locations rather than relying on my terminal or editor's word-wrapping engine. What if I `cat` a source file? IMO, hard-wrapping makes it easier to navigate the code and understand its structure, because lines map pretty well to semantic units such as statements, function parameters, etc. 
Open CoC is so much worse than the Contributor Covenant. I should have used that example instead.
The only problem is that bindgen's wrapping and indentation is absolutely garbage. This is my idea of good quality wrapping and indentation for FFI functions: https://github.com/retep998/winapi-rs/blob/master/lib/kernel32/src/lib.rs
That's more like what I find acceptable. I'm not sure about those multi-line multiple-parameters-per-line parameter lists, though.
Yes, I suppose that potentially the optimizer (either in rustc or LLVM) could then make use of the exposed information about the regex DFA to optimize further... but I am afraid this is likely to be very dependent on the surrounding code (based on whether the regex match/search functions are inlined at the call site or not). I would not, in general, count on it. Also, I feel the need to point out that the CTFE in discussion is about initializing `const` variables, so probably the lazy-DFA engine would not work there.
&gt; glibc reserves 2048 bytes in the stack through `alloca()` for the DNS answer at `_nss_dns_gethostbyname4_r()` for hosting responses to a DNS query. In my (not-so-performance-sensitive) application code whenever I see a stack-buffer I switch it out for a `vector` (C++) on the motive that the slight penalty of allocating memory is worth it in terms of simplicity (obviously can accommodate large sizes) and ease of debug (a corrupted stack is painful). Is `alloca` really faster? Is there no safer solution (thread-local, cached, memory buffer)?
I am SO glad that Rust decided to have fixed-length integral types (and cry a little whenever I go back to `short`, `int`, `long` and the magnificent `unsigned long long`).
Have you worked with ASTs in any language? Rust has the same building blocks that I'd use, specifically `enum`s. You might be interest in the [OCaml parsetree implementation] (https://github.com/lucasaiu/ocaml/blob/master/parsing/parsetree.mli) - it's basically entirely made up of mutually recursive `enum`s. A simple calculator AST might look like enum AST { Atom(i32), // literal number Add(Box&lt;AST&gt;, Box&lt;AST&gt;), // x + y Mult(Box&lt;AST&gt;, Box&lt;AST&gt;), // x * y Negate(Box&lt;AST&gt;), // -x Reciprocate(Box&lt;AST&gt;), // 1/x }
The index is all on GitHub, so that's publicly mirrored. I can't imagine we're not doing a regular backup of the S3 bucket, but that's not my department. It's also worth putting this post in proper context: this is from 2013, by one of the authors of Python's PyPi, and came at a moment where everyone _was_ saying "why not just sign all the things"
[Why not both?](https://s-media-cache-ak0.pinimg.com/564x/bc/f0/11/bcf011d75f2f39acf22ebe0bfb9b21f7.jpg)
If you take all of the mutability out of `self` in `iter_find`, then it compiles and runs. Are you trying to do this for a function that does require mutability? pub fn iter_find&lt;P: FnMut(&amp;T) -&gt; bool&gt;(&amp;self, mut p: P) -&gt; Option&lt;&amp;T&gt; { let mut cur = self; loop { match cur { &amp;List::Empty =&gt; return None, &amp;List::Cons(ref x, ref rest) =&gt; { if p(x) { return Some(x) } else { cur = rest; } }, } } }
As /u/steveklabnik1 points out, anything from before 2015 is probably going to be fairly out of date. Even early 2015 stuff is a bit out of date; there were a couple of really big overhauls of parts of the standard library during alpha. What I would recommend is checking the dates on your sources, and trying to stick with newer material if you're just learning. Here are some good sources of up-to-date material: * [The Book](http://doc.rust-lang.org/stable/book/) should probably be anyone's starting point * [Rust by Example](http://rustbyexample.com/) can work well if you really want to see how everything fits together in working examples * [The Standard Library](http://doc.rust-lang.org/std/) documentation can be good to search for things. For instance, if you're looking for `Sender`, try typing that in the search box and it will take you to [`std::sync::mpsc::Sender`](http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html), from which you can find that channels have moved to [`std::sync::mpsc`](http://doc.rust-lang.org/std/sync/mpsc/index.html) (stands for "multi-producer single-consumer", to describe the specific type of channel). * There are a couple of classes being taught in Rust this semester, which have material available online: ** [CS 198: Rust Programming at UPenn](http://cis198-2016s.github.io/) ** [EECS 395: Concurrent Programming in Rust at Northwestern](http://users.eecs.northwestern.edu/~jesse/course/eecs395/) However, if you do want to translate from older sources to what the modern replacement is, the best sources are probably the [release notes](https://github.com/rust-lang/rust/blob/stable/RELEASES.md). Sadly, the release notes don't seem to be specific enough in the era that you are looking at to include the specific changes that have thwarted you. There is also [bitrust](http://killercup.github.io/bitrust/) (or [plain text](http://bitrust.octarineparrot.com/) if you prefer) which extracts all changes marked with `[breaking-change]` to make them easier to find, but that only goes back to July 2015 as it's limited to 100 changes; you could [grab the code](https://github.com/killercup/bitrust) (or the [plain text version](https://github.com/mrmonday/bitrust)) to increase the limit and be able to search all of the breaking changes back to when the convention was introduced (which is sometime mid-2014 I believe, so still won't cover all breaking changes). Finally, you can just [clone the Rust repo itself](https://github.com/rust-lang/rust/) and use `git log -S RWArc` or `git log -S std::comm` to find the commit that deleted those strings, which should tell you where they moved to. For instance, for those I find: commit 64a52de8236e6405a50150c910370e161b854927 Author: Alex Crichton &lt;alex@alexcrichton.com&gt; Date: Sat Mar 22 00:53:58 2014 -0700 sync: Update the arc module This removes the now-outdated MutexArc and RWArc types. These are superseded by Arc&lt;Mutex&lt;T&gt;&gt; and Arc&lt;RWLock&lt;T&gt;&gt;. The only remaining arc is the one true Arc. Additionally, the arc now has weak pointers implemented for it to assist in breaking cycles. This commit brings the arc api up to parity with the sibling Rc api, making them nearly interchangeable for inter and intra task communication. and: commit bc83a009f655dd3896be4a7cd33cac8032a605f2 Author: Alex Crichton &lt;alex@alexcrichton.com&gt; Date: Tue Dec 23 11:53:35 2014 -0800 std: Second pass stabilization for `comm` This commit is a second pass stabilization for the `std::comm` module, performing the following actions: * The entire `std::comm` module was moved under `std::sync::mpsc`. This movement reflects that channels are just yet another synchronization primitive, and they don't necessarily deserve a special place outside of the other concurrency primitives that the standard library offers. * The `send` and `recv` methods have all been removed. * The `send_opt` and `recv_opt` methods have been renamed to `send` and `recv`. This means that all send/receive operations return a `Result` now indicating whether the operation was successful or not. * The error type of `send` is now a `SendError` to implement a custom error message and allow for `unwrap()`. The error type contains an `into_inner` method to extract the value. * The error type of `recv` is now `RecvError` for the same reasons as `send`. * The `TryRecvError` and `TrySendError` types have had public reexports removed of their variants and the variant names have been tweaked with enum namespacing rules. * The `Messages` iterator is renamed to `Iter` This functionality is now all `#[stable]`: * `Sender` * `SyncSender` * `Receiver` * `std::sync::mpsc` * `channel` * `sync_channel` * `Iter` * `Sender::send` * `Sender::clone` * `SyncSender::send` * `SyncSender::try_send` * `SyncSender::clone` * `Receiver::recv` * `Receiver::try_recv` * `Receiver::iter` * `SendError` * `RecvError` * `TrySendError::{mod, Full, Disconnected}` * `TryRecvError::{mod, Empty, Disconnected}` * `SendError::into_inner` * `TrySendError::into_inner` This is a breaking change due to the modification of where this module is located, as well as the changing of the semantics of `send` and `recv`. Most programs just need to rename imports of `std::comm` to `std::sync::mpsc` and add calls to `unwrap` after a send or a receive operation. [breaking-change]
You'll have to put a bunch of boxes in there.
Macros can only expand to a limited number of things and as /u/SimonWoodburyForget said, a struct field is not one of them. So you either have to combine the macros together, so one macro expands to an entire struct, or you can write a recursive macro which repeatedly calls itself building up parts of the struct declaration in the macro arguments, and then outputs the whole thing in one go at the end. The second approach is necessary if you have to make decisions on each field, as it seems you do here.
`alloca` is ridiculously faster. Allocating memory on the heap requires searching through free-lists and updating the allocator's data-structures to record the new allocation, while `alloca` just bumps the stack-pointer, which is usually a register and doesn't even have to go to L1 cache let alone RAM.
They were implemented in Java because someone using Java wanted to write them. Scratch and itch and keep scratching.
One thing that could be more feasible (at least for libraries) would be developing some drop-in replacements for critical C-libraries that could be used on systems where rust was well-supported.
&gt; someone using Java wanted to write them. It was one of the examples where tools actually matter and the choice was poor. That's all I'm saying.
I vaguely remember some kind of issue report suggesting improving the borrow checker's support for cases like this, but I can't find it. I'm pretty sure you can't do it currently without the dynamically checked or unsafe suggestions in other comments.
This subreddit is for the [Rust programming language](https://www.rust-lang.org/). You are looking for /r/playrust .
Yep, it's better.
One other thing that just came into my brain &gt; That said, when you look at the regex or permutohedron benchmarks, it's clear that something changed. Are you testing a single version of the library across all these versions of rustc? I know regex just made some changes which add more speed...
&gt; *No memes*. &gt; Leave the image macros at home. This applies to comments, as well as top level posts. 
&gt; You're missing the point: there are multiple possible interpretations of what that code should do. Python uses an interpretation that to many people is unnatural and bizarre. In my experience, if there are multiple possible interpretations, many people will find whichever one you choose unnatural and bizarre. The only way to win this specific game is to refuse to play.
Yeah, I'm specifically asking how to deal with this in the mutable cases, like getting a mutable pointer to some subtree (e.g. for insertion into a binary heap).
Oh man, yeah - that's what I did. I thought I was being leaner by only `use`ing the types I referenced, but changing that to `use iron::prelude::*` fixed it. Thank you so much. You are awesome!
&gt; P.S. It seems like this would be simply solved by having a type of thread which was required to "join" at the end of its scope, thereby bounding its lifetime. In that case, the lifetime of my BWT would be more than long enough to encompass that of the thread. Is this possible? There was a function like that, but it turns out there's no way to guarantee that the thread is joined at the end of the scope. Instead, there's a library called [crossbeam](https://crates.io/crates/crossbeam) that lets you spawn scoped threads by taking a closure and running it in a separate thread.
Cool, I _figured_ you probably did, but just checking :)
did you see TermKit? https://github.com/unconed/TermKit#termkit
Yes, for the HDFS part of things, it's stupid that it's in Java and wasting resources. A good project would be to reimplement HDFS in Rust in the manner that Scylla reimplements Cassandra in C++.
The chicken and egg problem can be nicely broken up when you have some killer features and I'm cautiously optimistic that Rust has enough of them already. In my eyes those would be safety, great tools for concurrency and awesome developer tooling. Heck, I'd have chosen Rust over C++ for cargo alone. I'm glad if I'll never have to even learn how to manually deal with dependencies.
Got to tell you, this is one hell of an update! Glad to see you guys slicing through like this :)
It was on PHP5. Just regular function calls added up to milliseconds. I had to spend development time PROFILING MY WEB APP. There is no win in development time if you have to waste time optimizing it later. That said, I'd rather use Rust than OCaml for web dev because I know Rust better. Also, Rust should be faster than OCaml and Node (easier to optimize performance, keeping more things on the stack, etc.)
If you're interested in all of the gory details, see the discussion on [issue #24292 std::thread::JoinGuard (and scoped) are unsound because of reference cycles](https://github.com/rust-lang/rust/issues/24292)
I'll be sitting back at watching what the Rust Community does with this. I'm at the ArcadeRS tutorial level at the moment. (My day job is a full-stack .NET Developer.)
My [~~sed/awk clone~~ scripting language](https://github.com/Xion/ap) can now handle objects (string-&gt;value hashmaps) and functions as first-class values. Unless I really wanna go for full control structures (which is rather tempting...), I should probably stop piling on features and start working on polish: tests, bugs, TODOs, and documentation. In other words, that last 20% of work which, as the saying goes, is gonna take another 80% of the time :) Considering that I've only picked Rust two months ago, it would seem the initial learning curve isn't as steep as some people say it is.
How about [something like this?](http://is.gd/8EG1md) 
Yeah, the conventional pattern is to use lots of mutually recursive types for the various classes of things you want to have. Something like: struct Expression { operator: Operator, arguments: Arguments, } enum Operator { ... } type Arguments = Vec&lt;Expression&gt;; enum ASTNode { Integer(i32), Operator(Operator), Expression(Expression), Arguments(Arguments), } Depending on your code, you might not need `ASTNode`, or you might have fewer fields.
So at the moment this is just some helpful utility functions to work with rust-sfml ?
The problem with this is that because the guards are never used, there's nothing to guarantee the compiler won't just destroy them immediately upon creation.
Isn't that what giving the variable a name that isn't just `_` does? I've seen a lot of code that relies on this behavior. Especially when you're trying to work with a `Mutex&lt;()&gt;`.
Pretty sure the presence of a Drop implementation prevents the compiler from removing it.
Can you shed some light (or provide links) on what exactly that does? Why does that scope affect the borrow/move?
FYI http://chat.redox-os.org/ does not seem to redirect to https://chat.redox-os.org (and I think it probably should). Also "Redox : Back in the cinemas" -- that's pretty perplexing. What's it supposed to mean?
I don't know enough about formal proofs but I would assume that it would be possible to formally prove at least a subset of Redox, running in virtualization. Without the ability to control the design of hardware, though, it is not possible to formally prove a physical system.
 * panic handling (e g `std::panic::recover` (or catch_panic) and `std::panic::set_handler`) is not stable yet, so there is no way AFAIK to stop a panic from causing UB (Undefined Behavior) on stable Rust. To me, this is a blocker. * Rust ABI is not stable yet, and there seems to be no sign of the core team wanting to stabilise it any time soon. So even if you have two independent Rust libraries, they're going to have to talk C to each other. This is perhaps not a blocker, but a major speedbump. * Rust code might be larger. If you have several libraries, each of them is likely to include their fair bit of std and often other dependencies as well. Compared to C libraries which dynamically links to glibc and other dependencies; so glibc is only in RAM in one place, whereas different Rust libraries will all include their version of the std crate. Whether this is a problem or not depends on how small your target device is. 
Still hoping for a review on [#30884](https://github.com/rust-lang/rust/pull/30884). "Because nobody has implemented it" is no longer a valid answer to why we don't have inclusive range syntax yet! Also nerd-sniping myself with various macros. This week's is a 216-line implementation of the hypothetical ["early exit from any block"](https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md#early-exit-from-any-block) feature from the `catch`/`?` RFC. I might publish it as a crate. It uses macro recursion to walk the AST and transform `break` statements, plus a trick I learned from sdleffler to branch on a comparison during macro expansion. I really need to start a macrology blog.
Nothing except historical precedent that this doesn't happen, so changing behavior to drop things before they go out of scope would be a massive breaking change! Things like mutex guards and [TempDir](http://doc.rust-lang.org/tempdir/tempdir/struct.TempDir.html) rely on this.
No, it's an obfuscated `id(_)` function. Read https://bluss.github.io/rust/fun/2015/10/11/stuff-the-identity-function-does/ for more information.
I tried looking this up, is filling_drop something that's likely to stick around? It vaguely gave me the impression that it wasn't really intended to be used.
FWIW this seems to be how the compiler's internal owned pointer type works: https://github.com/rust-lang/rust/blob/82f30d2a361cd8e5621f4906c61e16bbe61ebad6/src/libsyntax/ptr.rs#L73-L83
It is completely plausible to create a formal proof of the correctness of the kernel.
These do also run on Linux: - [sodium](https://github.com/redox-os/sodium) - an editor written in pure Rust. - [coreutils](https://github.com/redox-os/coreutils) - a collection of core utilities in pure Rust. - [binutils](https://github.com/redox-os/binutils) - a collection of utilities for for processing binary files. Written in pure Rust.
Thanks for the heads up on that. Will fix it. &gt; Also "Redox : Back in the cinemas" -- that's pretty perplexing. What's it supposed to mean? It's just a bad joke, since we were using Slack before, and then switched to Mattermost.
It is by no means Rust's sweet spot. Rust is actually, at this time, extremely efficient and flexible for web development.
[handlebars-iron](https://github.com/sunng87/handlebars-iron) has great support for your requirements. 
&gt; Heck, I'd have chosen Rust over C++ for cargo alone. This cannot possibly be overstated. Cargo is such a wonderful tool, I find myself missing it any time I step outside of rust.
What's up with the https://crates.io/crates/logger crate ? On the top right it says "Last Updated 2 months ago" but further down on the site it says "0.0.3 Jul 5, 2015". Is this an issue on my side or is something wrong with crates.io ?
keep it mind golang only has defer because it lacks destructors, another reason why it's a terrible language.
Pretty much that. No one knows anything for sure, though.
I think your solution is quite a bit convoluted. It's not clear why the `parameters` of `get_fitness` should be put into the `parameters` of `Wing`. Why can't the `parameters` of `Wing` be set outside of `get_fitness`? Then you could just have something like: pub trait FitnessFunction { fn get_fitness(&amp;self) -&gt; f64; } impl FitnessFunction for Wing { fn get_fitness(&amp;self) -&gt; f64 { ... } } And if you need a fitness function for `[f64]` you could still have: impl FitnessFunction for [f64] { fn get_fitness(&amp;self) -&gt; f64 { ... } } 
It was more of a Rust exercise for me, than the actual performance squeeze attempt. I'll try to improve, though. Maybe using the true OS threads on the first level of spread and Coroutines on all the subsequent ones will help?
Here's a related post: /r/rust/comments/3clurs/
A `&amp;mut T` is a moving type, so passing it by value somewhere would usually move it, which would be quite annoying if you work with functions that want to mutate data: let x = &amp;mut y; foo(x); // This would move bar(x); // Which would make this an compile error So in order to combat this, Rust instead tries to reborrow, which basically means creating a new `&amp;mut` with a shorter lifetime by temporary borrowing the original `&amp;mut`. If you where to write that explicitly in code, it would look like this: let x = &amp;mut y; foo(&amp;mut *x); // Create a new &amp;mut that borrows x bar(&amp;mut *x); // Create a new &amp;mut that borrows x Usually that's the right thing to do, but since it changes "moving away from a location" to "creating a borrow to that location" its an issue here, since the match body would be considered to borrow the `cur` variable, while what you actually want is "move the reference away from cur, create a new reference with the same lifetime for the tail, reinitialize cur with that reference". The trailing expression in a block is a location where a `&amp;mut` will always be moved, since a reborrow would just go out of scope directly and give you a lifetime error. And that's why `{cur}` causes `cur` to be moved instead of being reborrowed. 
Why not use [uutiles/coreutils](https://github.com/uutils/coreutils)?
Yeah, a lot of unsafes have been removed.
See also: http://burntsushi.net/rustdoc/fst/trait.Streamer.html (In short, yes, you're right. This just demonstrates that something is possible, but it is *extremely* limited. e.g., most or all adapter methods are impossible to define and use AFAIK.)
[removed]
There are totally syscalls on Windows. They're just not public, so you have to use the Win32 API, which wraps the NT syscalls with a pretty thick layer of abstraction. From what I've heard, NT isn't really all that similar to Win32 at all, and most of the Win32 logic is in the C lib and the Windows personality host process.
Does Streamer trait work with a for loop?
Nope. For loops only work with the `IntoIterator` trait.
Feel free to rewrite it in a more Rust-y way and do your own PR. I'm just curious to see how Rust perform.
Of course, there are, but all of them are totally undocumented, thus, not really recommended to depend on.
Right, I was talking more about the use case of having Rust depend on libc-rs.
I have attempted idiomatic Rust bindings several times, and I have the benefit of experience working with what the compiler has built on top of LLVM. It's hard. LLVM is a massive API surface to cover, and the key parts like Types and Values are tricky to create good abstractions for. 
How can I get the following code to compile? (It seems correct to me and I don't know what is missing) (relevant playpen: http://is.gd/LQkBMW) #[derive(Debug)] enum Either { Boring(i32), Exciting(Vec&lt;Either&gt;), } impl Either { fn eval(self) -&gt; i32 { match self { Either::Boring(i) =&gt; i, Either::Exciting(vector) =&gt; vector.iter().fold(0, |acc, &amp;x| acc + x.eval()), } } } fn main () { let a = vec![Either::Boring(1), Either::Exciting(vec![Either::Boring(2)]), Either::Boring(3)]; a.iter().fold(0, |acc, &amp;x| acc + x); println!("{:?}", a); } 
Thanks for the answer - I was thinking that since there are already alternative implementations, such as musl and Bionic, it is clearly technically feasible to re-write libc. If it were possible to do so in Rust (i guess using Rust core??) then that would be potentially significant. Incidentally, does rust build on non-glibc libc versions?
Keep in mind that Rust does not guarantee that drop is called, another reason to not flame other languages.
Fixed, http://is.gd/FWPjtT : Changes: Removed pattern matching on 'x' in the fold, I'm not sure if you actually get an rvalue or lvalue if you pattern match out of a reference. (uh sorry for probably garbled terminology...) Added .eval() in the fold() inside main(). This was the first error in your example. Made eval() take self by reference and made the match on Vec capture by reference too.
It is kinda witchcraft actually.
Thanks so much! what does the `ref vector` do, though? Have not seen that keword o.O well, TIL ;-)
see https://www.reddit.com/r/rust/comments/45w9ll/anyone_want_to_try_a_rust_version_of_this/ . Already has some implementation proposals in rust 
* Because Cargo isn't the compiler. * Because the compiler isn't Cargo. The only way these would work is if Cargo and the compiler were one and the same. Getting the set of extern crates would involve *at minimum* expanding all macros, which only the compiler can do. Having the information external to source files also makes it a lot easier to do things like compute all transitive dependencies, which lets Cargo resolve what versions of everything to use, so it knows what to download, so it knows what to build. It's just easier and more useful in almost every respect... aside from the fact that it requires violating DRY a little.
 That's much closer than anything I came up with. I was hoping it would be possible to hide knowledge of underlying c implementation from the user with some generic wrapper around the `firfilt_*` structs like I did in Julia: type FIRFilter{Th,Tx} q::Ptr{Th} tx::Type{Tx} end I wasn't expecting anybody to put that much effort into answering my question, thanks!.
Yes, rustc can also target musl
Yeah, that was added fairly recently though; I'm not sure it's there for older crates.
As well as bionic on Android, libsystem on OS X, MSVC's CRT, and the various BSD libcs. glibc is only present on GNU/Linux ~~and mingw~~, and Rust can target a lot of platforms besides. But yes, even on Linux there are currently three libc's supported, glibc, musl, and bionic.
I'm just curious, since I didn't see anything about it in the update, what's the filesystem status? The last I read, Redox could mount ZFS images in readonly.
&gt; Getting the set of extern crates would involve at minimum expanding all macros, which only the compiler can do. That is quite the problem indeed. External crates can define their own macros leading to horrible recursive situations where it tries to compile the code a bit, realizes it needs a macro from some dependency, has to fetch the dependency, try compiling a bit more only to see that macro created an extern crate, so it has to go back and fetch and build another dependency, and if _those_ dependencies also have recursive macro extern crate hell, well that's just awful.
You might want to pin to a particular version.
I'm going to answer each of these questions in separate replies, because that's easier for follow-ups.
&gt; Why an explicit lifetime would be applied to a struct, instead of to an instance of the struct. Because lifetimes are _generics_, and hence, part of the type. Lifetimes attached to the instance of a struct would be a runtime thing; lifetimes are a compile-time thing. Does that make sense?
&gt; why the decision was made to leak that lifetime to every fn which touches an instance of said struct. Well, as part of the type, you have to declare the lifetimes like any other type. Consider this, related type: struct Foo&lt;T&gt; { x: T, } impl&lt;T&gt; Foo&lt;T&gt; { fn x(&amp;self) -&gt; &amp;T { self.x } } It's the same thing, but with a generic type instead of a generic lifetime. Does that help any?
I'm surprised to see the "easier" argument about a language that does type inference etc... One of the thing that attracts me in Rust is the fact that it makes the computer do (almost) everything that it can so I don't have to. Given that Go lang avoid the dependencies repetition, and that it make sense to avoid it, I really expected Rust to do the same, and certainly didn't expect that it wasn't done because it's hard.
Hm, I would have thought `cwd` would have been the project root as well.
can you provide an example of what you mean?
I may or may not have heard some rumblings that you may get your wish in a bit.
i would like to have higher-kinded shenenigans :D
&gt; they're going to have to talk C to each other. Or, you can compile them with the exact same version of the compiler.
When are we getting a pluggable interface to `libstd`? Those of us writing OSes or working on obscures platforms would love to have a way to port it to their platforms.
I find this confusing, but I'm not sure how to describe my confusion. What is the advantage to assigning more than one lifetime to Foo? What is the benefit of x &amp; y having different lifetimes within the lifetime of Foo? Can you illustrate this?
&gt; &gt; struct Foo&lt;T&gt; { &gt; x: T, &gt; } &gt; &gt; impl&lt;T&gt; Foo&lt;T&gt; { &gt; fn x(&amp;self) -&gt; &amp;T { self.x } &gt; } Thanks. With the understanding that the lifetime is a component of the _type_, this helps some.
The book made the same point, but I don't understand how &lt;'a&gt; communicates anything to the reader about the lifetime of a given type. Primarily, it doesn't appear to tell me when the thing begins and ends. This is still a source of confusion for #3.
Windows has syscalls, kind of, just that they are in form of public API not Assembly instructions. Also it isn't the only OS doing that. Having written a compiler with zero dependencies to C, the decision to depend on libc boils down to how much work one whats to save. Also I personally find it brings some confusion to those not versed in compilers, the usual "my compiler compiles yours" kind of joke.
So you depend in kernel32 and similar, what's the problem? 
When LLVM knows that mutable pointers don't alias it allows for really neat optimizations, in particular the ability to reorder reads and writes or even elide them entirely. If mutable pointers are allowed to alias, then LLVM can no longer perform those optimizations. If two pointers can possibly alias then LLVM has to ensure the order of reads/writes to those pointers is unchanged and they cannot be elided otherwise the code would behave incorrectly.
Porting the underlying libraries won't ever get me to a point where I can compile arbitrary `std`-dependent crates for my OS. I'd love to "just port `std` to my platform", but because said platform is ~~kind of~~ **extremely** obscure, support for it won't be accepted into the compiler. I'd need to maintain a fork of the Rust toolchain. No bueno. The Redox folks are hitting a similar hurdle. They have their `libredox`, which is essentially a from-scratch, incompatible re-implementation of the standard library. That kind of artificial ecosystem fragmentation probably isn't a good thing. What I'm asking for is a way of porting `std` to a new platform that doesn't involve modifying the compiler. Maybe using `lang_item` and such.
Rust used to do that long time ago, but this feature was removed. It was decided that managing dependencies and versions was a package manager business.
Go takes a fundamentally different position on dependencies than we do, so it's not _that_ surprising that our solutions are different. I don't think "it's hard" is the primary justification, it's just an example of why two tools is better than a single tool.
&gt; My understanding is that the reason you cannot make multiple mutable references to the same structure in Rust is that it would cause race conditions in multithreaded settings. It's not just that. http://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/
I can. I've done it in the [sliding_windows](https://github.com/flo-l/rust-sliding_windows/) crate. See my comments on [this stackoverflow question](http://stackoverflow.com/questions/35123824/how-can-i-correct-cannot-infer-an-appropriate-lifetime-without-editing-functio), I go into a bit more detail there.
I am always bad with coming up with a succinct example of this; maybe someone else has some ideas?
`&amp;mut` isn't `noalias` right now because of an LLVM bug :( https://github.com/rust-lang/rust/pull/31545
Yes, but that's a bug, not expected behavior.
Fair enough! I think it's good to mention too. My inner doc person is just always nagging at me, "documented semantics are not the same as a current implementation which may have bugs!" After seeing too many people say "well Rust does X" and assume it's the correct semantic. I hope this can get resolved in a reasonable timeframe.
I'm still not sure how to deal with the Dropocalypse stuff. How are we supposed to work with Drop if it's "optional"?
Good point, I totally see where you're coming from! These days I feel like it's a pretty small list of things where semantics differ from implementation, right?
Can you point to some docs? I'm only aware of lack of drop ordering in structs, and the fact that one can create stuff like Rc loops.
I think the Rayon version is the most idiomatic, most performant, and therefore the clear winner. (top comment in the post linked to by /u/andallthat)
I'm currently working on an idiomatic api that utilizes Rusts type system. Work is slow, however, and as /u/Aatch said, it's a massive api surface to cover...
 1. Do not depend on Drop for safety (example: Gankro implemented the vector drain iterator by zeroing the length of the vector on construction and restoring it on destruction =&gt; at worst it leaks) 2. For any other effect: punt. The user is in charge of making sure things are dropped; if she leaks, it's on her head.
https://github.com/rust-lang/rfcs/pull/1502
It makes me happy that someone was able to use my 2 favorite languages in a way that easily complements the other. Due to the similarities between them (functional in some aspects, immutability, monadic error handling etc.) I'm surprised I haven't seen more of these kinds of projects. I'm glad the author's experience was relatively painless. I'll probably implement this combo for my machine learning class' next assignment to try it out.
arcnmx is bae
Go's default way to manage dependencies -- which isn't really management at all -- is rife with so many problems (e.g. lack of version pinning) that I wouldn't really cite it as a good solution.
&gt; Can I replace my Rails/Django/Flask already? It's not really Rails/etc. that I'd like to replace Rust with, it's API servers that are often written in Java, Go, or node.js, and only talked to from Flask/Django/Rails/etc. frontend.
The more I think about it, the more I think it'd make sense. The issue of pinning a dependency version exists right in the code really, since method signatures etc... might change from one version to the next. Do you remember roughly what where the pros and cons around that discussion? 
I am happy that you finally made the decision (I understand why this stuff can be sleepy!). And thanks for the enormous effort you have put into this. If you are fine with it, I will take over the development of ZFS. Again: thanks for the time you have put into this!
The maintainer of llvm-rs hasn't been very active in some time. [I wrote a few fixes a while back](https://github.com/TomBebbington/llvm-rs/pull/7) but they haven't been merged and could very well have broken again since then.
You have to define what "character" is. Do you mean byte, codepoint, or grapheme cluster? You _probably_ mean one of the last two. `chars()` gives you Unicode Scalar Values, which are a subset of codepoints. Strings are hard. That said, your solution is fine. &gt; I did not yet grasp the difference between iter() and into_iter() `iter()` produces references, `&amp;T`. `into_iter()` produces owned values, `T`. You don't want to collect a list of pointers to characters, you want the list of characters, so you need `into_iter()`.
&gt; I did not yet grasp the difference between iter() and into_iter() and usually if one fails to compile I just try the other one. In the above example, iter did not compile but I'm not sure why. The difference is that `iter()` takes its receiver by reference and `into_iter()` takes it receiver by value. That is, `iter()` borrows the receiver and `into_iter()` moves ownership of the receiver. In the case of `iter()`, since it's borrowing the receiver, it will generally yield elements of type `&amp;T`, where as `into_iter()` will just yield `T`. In your case, since you're collecting into a `String`, you need a `T` since it has a `FromIterator` impl for `char` but not for `&amp;char`, which is what you would get if you used `iter()`.
They just merged the PR with coroutines, I think it should be useful to also have one without
Calling the Python implementation "insane" just because it's not what you came up with is clearly a case of bias. Whatever is insane or not depends on each person (in the absense of a clear body of data.) Personally, the Python interpretation sounds like something I'd have a use for pretty often (I didn't know about it until now), and your suggestion just sounds weird. So it goes both ways. :)
Interestingly, today I found another weird usecase for this trick: I wanted to create a new `&amp;mut [u8]` in a test that points to some ascii data on the stack, and ended up with this: let slice = &amp;mut {*b"foo"}[..]; Why? Well, Rust's byte string literals `b"foo"` have the type `&amp;[u8; N]`, so `&amp;mut *b"foo"[..]` would be a "can not borrow immutable data as mutable" error. But because `{}` forces a copy/move, `{*b"foo"}` can be used as a `[u8; N]` literal.
It sounds like you are referring to something similar to [RefCell](https://doc.rust-lang.org/std/cell/index.html). This is a wrapper around an &amp;mut, that can be cloned as much as you want. Then when you want to access the inner &amp;mut value, you call a function that does runtime borrow checking.
Shameless plug /r/IntellijIDEA
The `get_fitness` method is repeatedly called from the optimization algorithm, which sets the parameters to many different values. If the user sets the parameters outside of `get_fitness`, it will get overridden with generated values by the algorithm before anything bad happens. Also, I have checks to make sure the `get_fitness` method doesn't return NaN or infinite to prevent crashes. Not only that, but if the user doesn't implement the `get_fitness` method correctly, the algorithm will still minimize it, so the solution returned will simply be bad for a real task, but good for the fake fitness function.
You would run into issues with areas of the C standard library which rely on macros and compiler support (`errno` and `va_list` spring to mind, and you would need to be careful around functions which get built-in to C compilers like memcpy). But for the functionality which can be exposed as linker symbols, yes it's in principle possible but would be a lot of work.
It's not done yet, there are features needed to get this beyond POC status, but I figured you'd be looking for something *right now*, so I uploaded it sooner than I usually would. Please don't rely too much on the non-existant API, if you end up using this. :)
Looking at the Game of Life code, I don't see anything particularly optimizable, at least in the Rust-specific sense. There are some things you could do algorithm-wise (starting simple, have you considered incrementally updating `alive_nb`?), but those aren't what you've asked for so much. FWIW, Rust doesn't really have a ton of pragmas. Nothing you've missed AFAICT. You have some non-idiomatic code at first glance. Why is `GRID_WDH` `static` rather than `const`? This is simpler: lazy_static! { static ref GRID: Mutex&lt;Vec&lt;u8&gt;&gt; = Mutex::new(vec![0; GRID_WDH * GRID_WDH]); }; } `grid` being a static rather than a parameter seems weird, but I'm not too fussed. Note that `new_grid.set_len(grid_size);` is only (probably) safe because `u8` has no destructor. if x &lt; 0 { GRID_WDH - 1 } else { if x &gt; GRID_WDH - 1 { 0 } else { x } }; is just if x &lt; 0 { GRID_WDH - 1 } else if x &gt; GRID_WDH - 1 { 0 } else { x }; is just match x { -1 =&gt; GRID_WDH - 1, GRID_WDH =&gt; 0, _ =&gt; x } given `x` can never be off by more than 1. I would put `grid_ptr.offset(X as isize)` in a local closure. It'd look much prettier. This might have a frequently mispredicted branch: if alive_nb == 3 || (alive == 1 &amp;&amp; alive_nb == 2) { 1 } else { 0 } I'd try ((alive_nb == 3) | ((alive == 1) &amp; (alive_nb == 2))) as u8 instead, though it might instead make it slower. But I think this does the same thing much faster: ((alive_nb | alive) == 3) as u8 Bit hacks are best hacks. If you stored these in bits you'd have a much smaller memory requirement. Doing this cleverly is an algorithm question, and I said I'd avoid those, but there should be some clever hacks (of the best kind) to make it extremely efficient. I'm going to stop myself here before I get too carried away.
I would personally write something like fn take_last_n(str: &amp;str, n: usize) -&gt; Option&lt;&amp;str&gt; { if str.len() &gt;= n { Some(&amp;str[str.len()-n..]) } else { None } } for any type of slice fn take_last_n&lt;T&gt;(slice: &amp;[T], n: usize) -&gt; Option&lt;&amp;[T]&gt; { * Edit: I'll keep this up as an example of what not to do if you want to handle strings correctly!
`take(&amp;Foo)` and `borrow(&amp;&amp;Foo)`, respectively. And it doesn't matter if you use the reference or a copy thereof (they both point to the same thing after all), rustc will insert the right number of copy operations (and elide unnecessary ones).
**Redox has a mostly Rust stack, including a Rust libc replacement** Here is how a File::open is handled in Redox: * [The Rust libstd calls a system crate, which provides libc-like functions](https://github.com/redox-os/redox/blob/master/libstd/src/fs.rs#L25) * [Here is the open function in the system crate](https://github.com/redox-os/redox/blob/master/crates/system/syscall/unix.rs#L131) * [Interrupt 0x80 is called directly from Rust](https://github.com/redox-os/redox/blob/master/crates/system/syscall/x86.rs#L33) * [They are handled in a small assembly function](https://github.com/redox-os/redox/blob/master/kernel/asm/interrupts-i386.asm#L23) [(needed until #[naked] is approved)](https://github.com/rust-lang/rfcs/pull/1201) * [They are sent to the kernel's Rust interrupt handler](https://github.com/redox-os/redox/blob/master/kernel/main.rs#L322) * [Interrupt 0x80 is then sent to the syscall handler](https://github.com/redox-os/redox/blob/master/kernel/syscall/mod.rs#L19) * [Which finally makes its way to the kernel implementation](https://github.com/redox-os/redox/blob/master/kernel/syscall/file.rs#L114) Hope you enjoyed that trip down the rabbit hole.
I'm all for shenanigans. Especially higher-kinded ones.
**Redox has a mostly Rust stack, including a Rust libc replacement.** Here is how a File::open is handled in Redox: * [The Rust libstd calls a system crate, which provides libc-like functions](https://github.com/redox-os/redox/blob/master/libstd/src/fs.rs#L25) * [Here is the open function in the system crate](https://github.com/redox-os/redox/blob/master/crates/system/syscall/unix.rs#L131) * [Interrupt 0x80 is called directly from Rust](https://github.com/redox-os/redox/blob/master/crates/system/syscall/x86.rs#L33) * [They are handled in a small assembly function](https://github.com/redox-os/redox/blob/master/kernel/asm/interrupts-i386.asm#L23) [(needed until #[naked] is approved)](https://github.com/rust-lang/rfcs/pull/1201) * [They are sent to the kernel's Rust interrupt handler](https://github.com/redox-os/redox/blob/master/kernel/main.rs#L322) * [Interrupt 0x80 is then sent to the syscall handler](https://github.com/redox-os/redox/blob/master/kernel/syscall/mod.rs#L19) * [Which finally makes its way to the kernel implementation](https://github.com/redox-os/redox/blob/master/kernel/syscall/file.rs#L114) Hope you enjoyed that trip down the rabbit hole.
LOL how much fucking code do you write? How do you code so much? I'm blown away. Edit: This is mainly aimed at jackpot51, he's got inhuman work ethic.
That makes sense, thanks! In order to avoid a fat pointer, I'd have to have types explicit everywhere. It would be quite easy to miss something like this in a language like Java (although there are lots of different types of overheads for such a language anyway)
Zipf's law suggest that that's the large majority.
Your code only supports ascii, strings in rust are utf-8 so you can't just slice the last n bytes.
It is part of project euler puzzle, characters are ascii. I was curious if it can be done without an allocation in the middle. 
&gt; If the user sets the parameters outside of get_fitness, it will get &gt; overridden with generated values by the algorithm before anything bad &gt; happens. Ok, you don't seem to be able to see a problem here. If parts of a data structure - `parameters` of `Wing` here - shouldn't be used by the user, then they shouldn't be accessible or visible for the user. Everything else just complicates things and isn't quite intuitive. Now you will say that's no problem, you will just tell the user, fine, but good and safe design doesn't has to tell, it just doesn't allows it. 
Currently it hardcodes TCP, but making it transport agnostic is ~~on a shortlist of planned improvements~~ something we're thinking about.
Which transport do you wish was used/supported?
You are correct, I found it. Stupid error... I was calling LoadLibraryEx to map the binary file like this: let module = unsafe { ffi::LoadLibraryExA(path.as_ptr(), 0, ffi::LOAD_LIBRARY_AS_IMAGE_RESOURCE) }; Notice the path.as_ptr() since I was struggling so very very hard with passing C-strings to FFI functions... But path.as_ptr() isn't guaranteed to be null terminated... I'll put that as a new top level question.
How do I call Win API functions that accept 'const wchar_t*' as an argument? Example: mod ffi { pub type HANDLE = usize; pub type LPCWSTR = *const u16; pub type LPCSTR = *const u8; pub type DWORD = u32; pub type HMODULE = usize; pub type BOOL = i32; pub const LOAD_LIBRARY_AS_IMAGE_RESOURCE: DWORD = 0x20; #[link(name = "KERNEL32")] extern "stdcall" { pub fn LoadLibraryExW(lpLibFileName: LPCWSTR, hFile: HANDLE, dwFlags: DWORD) -&gt; HMODULE; pub fn LoadLibraryExA(lpLibFileName: LPCSTR, hFile: HANDLE, dwFlags: DWORD) -&gt; HMODULE; pub fn FreeLibrary(hLibModule: HMODULE) -&gt; BOOL; pub fn GetLastError() -&gt; DWORD; } } How do I call `ffi::LoadLibraryExW(path, 0, ffi::LOAD_LIBRARY_AS_IMAGE_RESOURCE)` where I have a `let path = "Path/to/file.dll"`? I've looked at OsString but I just cannot figure this out... How do I convert a &amp;str to a null terminated, UTF16 encoded path I can pass to LoadLibraryExW? rustc 1.6.0 (c30b771ad 2016-01-19)
FWIW, I think that dependencies declared in cargo should, by default, show up as if you had been writing "extern crate xxx;" in crate root. This should be able to turn off in the unusual case someone wants to import the crate somewhere else. It should be fairly straight-forward to implement a compiler switch to rustc, like this: --crates FOO, where FOO is a comma separated list which expands like $X:ident=$Y:ident =&gt; "extern crate $X as $Y" $X:ident =&gt; "extern crate $X" ...and cargo could use that. (Hmm. Backwards compatibility might be a problem though - I suppose this would be a breaking change to all cargo.toml:s...)
Unrelated but representing None as MAX seems ripe for misuse. Is there a really a use where you need it exactly the same size?
Type wise, both `(self: &amp;'a Foo)` and `(self: Self)` are correct - the issue seems to be some weird compiler bug. If you switch playpen to the nightly version, all three compile. Generally, the `self: Foo` syntax (with the keyword `self`) is not yet fully specified and I honestly expected there to be a stability error for using it. :P
All value bindings introduced by pattern matching are normal variables that got initialized with a rvalue - either with an attempted copy/move for by-value bindings, or with a freshly created reference in a by-ref binding. So `&amp;foo` would match the reference away, and then try to copy or move what it points at into the variable, while `ref foo` would access the matched value as a lvalue to create a new &amp; and store it in foo.
Hey /u/steveklabnik1/ . I was looking at the new book which is very much in progress. I love it, and find that I understand some things a little more using it than the older(current) book. Good work on both! My question hope it's not improper - when will it be completed.
&gt; * Whether or not the struct implements Send - does it never (e g if there is an Rc inside), or does it always do that (if T is just some phantomdata type), or only if T: Send (if there is a T inside) &gt; * Likewise, but for Sync &gt; * Similar, but for Drop (I think, not 100% sure) Aren't the answers to these questions to be found in the "trait implementations" (and "derived implementations") section below methods documentation?
&gt; Aren't the answers to these questions to be found in the "trait implementations" (and "derived implementations") section below methods documentation? I don't think so, at least not in a way I can find/understand? Just as an example, I'm looking at [std::result::Iter](http://doc.rust-lang.org/std/result/struct.Iter.html) and it doesn't say anything about Send, Sync, Drop or variance.
Because there's no `FromIterator` impl for `&amp;char`. I guess it could be added since `char` is `Copy`. If you use `iter()` with an `&amp;T` and `T: Clone`, then you can call `iter().cloned()` to get an iterator of `T`.
`UnsafeCell` will affect transitive implementations of [`std::panic::RefRecoverSafe`](http://doc.rust-lang.org/nightly/std/panic/trait.RefRecoverSafe.html) as the compiler cannot guarantee that user code will not witness broken invariants after a panic through an &amp;-reference to a type containing it. This extends to `Cell` and `RefCell`, but not `Mutex`, as it's got panic-safety built-in with its poisoning semantics.
I agree to 100%. A smarter rustdoc that can summarize these properties would be great. Since you mention Rc/Arc, their property that changed was not just variance, but also an ownership/drop implication (`Rc&lt;T&gt;` got the annotation that it owns and may drop a `T`). You can test send/sync-ness for example like this: #[test] fn test_is_send_sync() { fn _is_send_sync&lt;T: Send + Sync&gt;() { } fn _test&lt;'id&gt;() { _is_send_sync::&lt;Id&lt;'id&gt;&gt;(); _is_send_sync::&lt;Index&lt;'id&gt;&gt;(); _is_send_sync::&lt;Range&lt;'id&gt;&gt;(); } } 
I recently found myself looking for a crate to perform a specific task, but the search on crates.io is not that helpful. There might be a lot of very good crates that are not used because it is hard to determine which crate is best. In the end I discarded all crates that didn’t have a documentation link, and then read trough the API reference to see which one looked more appropriate. Perhaps something like a small example on the crate page could help to make a decision. (Hackage for instance, shows an overview of the modules and gives you direct links to their API reference on the package page.)
Ok I see, thanks for the answer! Are y'all going to go for a BSD like utils clone? I only ask because even the BSD utils have quite a bit more functionality. So from the messaging I'm not sure if "the current state is considered BSD like" or "BSD like is the goal." ---- Like /u/daAccordo I'm also curious if there's a list of "known good" crates one can depend on to target Redox, or perhaps a more useful "known bad."
It's hard to discover because it doesn't show up in the online docs, as those are generated on a Linux machine for the Linux Rust distribution. Instead, navigate to your local Rust installation, then go to `share\doc\std\index.html` or something like that, and bookmark it or make it a desktop shortcut. That's the generated documentation for Windows. If you go to the docs for `std::os` you should see a `windows` module instead of `linux` and `unix`. What you're looking for is `std::os::windows::ffi::OsStrExt`, which is an extension trait for `OsStr` which adds an `encode_wide()` method. This returns an iterator over `u16` values which is the UTF-16 that Windows is expecting. `.collect()` it to a `Vec`, push a `0u16` on the end (that's your nul-terminator), optionally check to make sure there's no premature 0 values in the string (as that will make the string be recognized as shorter than it is), and then pass it to your FFI with `.as_ptr()` and cast it to the expected pointer type. It probably goes without saying that you should make sure that the `Vec` sticks around as long as it's needed so it doesn't get freed prematurely and leave you with a dangling pointer. And if you'd rather not reinvent the wheel, this string handling has already been implemented for you [at least once](https://crates.io/crates/wcstr/). Also, I highly recommend [winapi](https://crates.io/crates/winapi). There's loads of type definitions and function bindings to various Windows libs that have already been done for you. If there's something missing that you need, you can bug WindowsBunny on the #winapi channel of the Mozilla IRC or open an issue on the repo.
AFAIK, there's a github repo with the whole dataset somewhere.
I took MIN and MAX respectively exactly *because* they are unusual values in many (not all!) applications.
Thanks for the in depth explanation! I've seen the winapi crate, but I'm not duplicating his work. I'm writing some rust abstractions to inspect windows binaries and for testing I need to map them into memory. Eventually I'd like to do that myself but I was getting frustrated with the file read APIs so I thought for now I'd do things quick'n'dirty by calling this Win API but that didn't work out so great either... Thanks again for the amazing response!
Thank you! This makes more sense to me now. The FromIterator page you linked contains duplicate impl signatures, is that a bug? 
But surely the "extern" syntax could be modified to add "possibly using a certain source" and "possibly using a fixed version" to it. It seems to me that pinning to a version is as important to the code as it is to the package manager. Your code is what depends on a version. It would also have the advantage that if two pieces of code within the same code base depend on a different version, it'd be easy and quick to find out which ones.
&gt; seemed like a hassle/kind of hacky to me. Once syntax extensions are stable, it should be a lot easier to use. Anyway, neat project!
Couldn't a two (x?) pass compile solve this? Why is it a problem that the compiler has to do a lot of work? I'd rather the compiler do work than me, that's one of the reason I've started looking at rust (memory management dealt with via inference).
&gt; lack of version pinning But that's a syntax issue. Couldn't the "extern" syntax be modified to potentially pin to a version, the same way it is currently done in the toml file?
It is hard to grasp both the number of programmers and the higher ratio of open source development. The number of people that learn JavaScript next year is probably greater than the total sum of people who have ever programmed.
I love this! Using the colored term output may span way beyond simple image printing. One could, let's say, find a semi-random Mandelbrot set window (as a login greeting). Or, hook up to some sort of a renderer (GFX, a software rasterizer, whatever), and render a nice frame of a scene. Speaking of which, I recall glutin having a backend for the ASCII output, I wonder how it compares with this project.
&gt; duplicate impl signatures, is that a bug They aren't *exact* duplicates. One refers to items in the standard library (`std`) and the other refers to items from `libcore` and `libcollections`. It's not ideal that both are shown, so you could report it. There's probably an existing issue somewhere, so try to find it first and comment on it, but if you can't find it, go ahead and open another.
This is unrelated to macros: fn written() { println!("Written"); } mod test { // use super::*; // Doesn't work use super::written; // Works #[test] fn test() { written(); } } When asking for help in the future, it would be very useful to produce a code sample the demonstrates the problem.
What's the debugging story like with this plugin?
From the perspective of someone who prefers to read the source rather than the docs, all I'm missing is `#[derive(Sync)]` and `#[derive(Send)]` annotations.
[Image](http://imgs.xkcd.com/comics/wikipedian_protester.png) [Mobile](http://m.xkcd.com/285/) **Title:** Wikipedian Protester **Title-text:** SEMI-PROTECT THE CONSTITUTION [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/285#Explanation) **Stats:** This comic has been referenced 439 times, representing 0.4380% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d04oet6)
To add to others: the `regex` crate uses the sentinel trick in at least two places. One of them is encoding a `char` that can be none (this one is questionable and should be benchmarked more carefully) and the other is encoding special states in the DFA (quite useful, because it keeps the memory footprint of state transitions down).
Where is the in-progress version? I'd love to take a look.
I guess I'm not coming across the way I'd like to. The structure of my argument is: - A code of conduct can be a device to signal allegiance to a political movement. - There are many valid, non-bigoted reasons why someone would want to avoid participating in SJ communities. Such reasons include not wanting to be a potential target for life-ruining witch hunts and public shamings. - Therefore, a code of conduct that signals allegiance to the social justice movement can be exclusionary. I'm not arguing that the Rust code of conduct is evil and should disappear. I'm mostly documenting that there can be valid reasons for not wanting to make the Rust code of conduct *more* SJ-ish. If you'd like to understand things from my perspective, you could re-read my comment while keeping in mind that: * None of it is about the Rust code of conduct in particular, and * Everything from the fourth paragraph through "What does this all have to do with Codes of Conduct?" is **not** talking about codes of conduct.
Thanks for the test example. I also found a test for variance [in this commit](https://github.com/rust-lang/rust/pull/30998/files).
This is a _very_ common issue that everyone runs into, and might be a good candidate to put into F.A.Q. or (even better) into the error messages.
In the last link, what's `::env`? Does this resolve to a different name than `env`?
[::env is here, it is a global that stores some important kernel structures](https://github.com/redox-os/redox/blob/master/kernel/main.rs#L108)
How much? A huge amount of code How? By neglecting all other basic human responsibilities
Isn't there a `macro use`?
This is not a concretely useful example, but it is one where the different lifetimes are required: struct Foo&lt;'a, 'b&gt; { a: &amp;'a i32, b: &amp;'b i32 } fn main() { let a: i32 = 1; let c = { let b: i32 = 2; let foo = Foo { a: &amp;a, b: &amp;b}; foo.a }; } If you use only a single lifetime parameter on this struct, you will find that the code doesn't compile: in that case, the foo.a and foo.b references have to live for the same time, but we require that foo.a can go into the outer scope (lifetime 'a) while foo.b is limited to the inner scope.
Can't redox do lazy initialization of static variables? (like [this](https://github.com/rust-lang-nursery/lazy-static.rs)) In such a way that it wouldn't need to be an `Option` that is always `Some` and need to be unwrapped like this.
I see you are using the image crate. Did you know it includes color_quant for gifs? I think you can use that to better match an image's colors to a small pallet – though I don't know how to easily match that to the term colors. Also, this will be slower.
I appreciate the response, and understand the difficulty in clearly, correctly and concisely expressing oneself in online discussions. My problem is that you haven't pointed to a specific example in either your first or this, your second, post; and without concrete examples, it's hard to see how these hypotheticals add up. I also don't see any evidence to sustain the assertions in your followup: * You still haven't mentioned what is "threatening" about /u/graydon * You talk about "SJ communities", but Rust is is a programming community. Indeed the CoC expressly exhorts people to "avoid flirting with offensive or sensitive issues, particularly if they're off-topic". * You talk about codes of conduct requiring "political allegiances": but I also don't see that. Demanding that you treat the gay, black, women on your team as well as equally-qualified straight white men does not demand that you agree to the extension of _civil_ rights to gays, or to women or any other group. It just means treating your collaborators nicely. In a sense, you do have a point: a code of conduct will frustrate and deter anyone wanting to discuss politics on the programming subreddits and IRC. Personally I don't see that being a bad thing. This is /r/rust, not /r/politics It will also frustrate those who feel they should treat certain people poorly to express those opinions. I also don't have a problem with that. &gt; there can be valid reasons for not wanting to make the Rust code of conduct more SJ-ish I'm aware that there are extremes on the left-wing of politics. I'm not aware of any realistic attempt to embrace these extremes in the Rust community. I'm also quite bit puzzled to hear you say you've posted in the _Rust_ subreddit regarding something that's _not_ about Rust, and only partially about codes of conduct. 
Many crates are very easy to port (often, you don't even need to "port", all you have to is to properly link to libredox). The actual hard stuff is things, which either does or have dependencies which do depend on IO related actions. These are a lot more complex to port than application which are more centered around logic. That said, we got an extensive std replacement, which contains all the basic IO (fs, io, env, and so on). This covers 90% of all cases. The real issue becomes present when you use crates which depends on libc (other than the basic stuff, like memset, memmove, memcpy etc.). Thus, for making portable software, I would recommend to using as few dependencies as possible (check the deptree!). You'll quickly realize, how you don't need all those fancy dependencies.
is this new one? how does it compare to the other one?
You can do more advanced testing using [compiletest](https://crates.io/crates/compiletest_rs), for example doing compile-fail tests. I use it in the crate where the snippet comes from, since it enforces some rules via the type system, so I check that the failing examples really fail to compile. (see tests/ here https://github.com/bluss/indexing )
thank you for going over this, this is good to know if I finally get around to starting on an a app that works on redox. interesting stuff.
Sorry about that, example added. Is this the only way to import functions? My unit tests cover every single function defined in `super::` and I was hoping to be a little cleaner with the test code.
**FFI and C enum** Let's say I have C library with some enum like // C code enum e { a, b, c }; Now, how do I represent this enum in Rust binding?
Looks a lot better in my eyes =)
Thanks for the reply, I understand now. Partially what I was wondering was whether or not yall were looking for people to implement more of the utils or not. Thank for the details!
Shouldn't this be something you should be able to put into the source code? So if you never intend for a struct to be Send-able, you should maybe be able to say "#[noderive(Send)]" or something?
That's exactly what OP is asking for. 
What are those inner enums?
What are alternatives if you want a language without VM that is statically typed? Go? What else comes to your mind?
Thanks for the response. &gt;&gt;Why is the explicit cast necessary in the map closure? &gt;That's where the type erasure happens; you're transforming a specific thing into a more general thing. But it also happens on the function return and I don't have to explicitly cast it there. &gt;&gt;I'm sad about having to use map. &gt;Why? Because at first I thought that the indirection penalty for using `Box` over `-&gt; Trait` was going to be constant: that I could just do it at the root and not have to iterate over everything. Instead, the cost (for this case) is linear and I have to munge each element of the outer `Iterator` into its own `Box`.
Can I define it in terms of values defined by C enum? I was thinking about something like this #[link(name="lib")] extern { // enum e static a: i32; static b: i32; } enum e { c(i32) } impl e { fn a() -&gt; e { e::c(a) } fn b() -&gt; e { e::c(b) } } But that looks umm... clumsy.
That is possible today, e g: impl&lt;T: ?Sized&gt; !Send for Rc&lt;T&gt; {} ...although that is slightly longer than just "noderive(Send)".
You'll want to ask /r/playrust. The Rust **language** compiler has no loading screen as far as I know, though it would be really sweet if we could implement one.
&gt; Doesn't that mean it implements none of them? Or possibly Sync, according to Sync's documentation it is implemented by default on some types: Send and Sync are automatically implemented in most cases, and it would be extremely nice if `cargo doc` showed them. Drop, however, is not actually implemented transitively; the compiler just emits drop glue for every type that transitively contains anything that implements Drop. And having drop glue has essentially no affect on how a type can be used.
Without VM - why?
You can choose to implement the rhs multiplication by implementing it for each lhs type individually. It's not generic nor symmetric, but it works.
Just finished https://github.com/imbaczek/organize-by-mtime. Could've probably do it in shell or Python in 20% of the time this took, but it wasn't about the destination, but about the voyage :)
One thing I am wondering about when hearing about redox. The program seems good and you are probably very talented programers (far more than I am), but what are the usecases of redox. Are you planning to have someone using it in production ?
It'd be kinda cool if it could! :)
I've used llvm-sys for my [little compiler project](https://github.com/Wilfred/bfc) and I'd very much recommend it. It provides a straightforward API, so you can read the LLVM docs and it just works.
But it also affects how people write READMEs. This feature has had a big impact on the npm ecosystem, for example: people write better READMEs because they know they will see them on the page.
So... how long until there is a [Legend Of the Red Dragon](http://img.gamefaqs.net/screens/5/c/c/gfs_87987_1_1.jpg) clone in rust then? The images really hit a nostalgia button for me. Looks great!
You can use `multirust` to do this quite painlessly.
I suspect the poster is actually looking for /r/playrust, based on the terms used.
Thumbs-up for multirust-rs. It's working fine for me.
Weird, but then `Drop` is weird compared to everything else in that implementing it (or adding a field that implements it) can cause code to fail, whereas every other trait kind of works the other way around. If it had the reverse functionality (and then being called `NoDrop` or `NoDestructor` instead), then it would have made sense to make it an OIBIT, I think. 
Why not?
&gt;branches &gt;Pre-release &gt;2GB &gt;2.0 &gt;Legacy
For small, likely one-off demos I prefer gist because it doesn't create a lot of forked repos under my account that I have to go through and delete once in a while.
This would give the language a notion of the package registry, its index, and its protocol, of pulling from git, et cetera. These are not things that belong inside the language. You could probably make a much more compelling argument that `extern crate` should be removed than that `cargo`'s functionality should be rolled into `rustc`.
This is interesting and I'm not sure if the project has made any backcompat guarantees about cargo. I think the `extern crate` syntax is kind of iconic, but it does seem like cargo could pass the information it provides to rustc with flags.
It shouldn't be embarrassing, it happened to many people before.
I can't compile llvm-sys on Windows (through AppVeyor). Did you try?
I have a trait that contains a fold function and want to add a sum function to the same trait and reuse the previous fold implementation. How can I provide the correct return type for the sum function? struct Fold&lt;F&gt; { value: i32, f: F } trait Stream { fn fold&lt;F&gt;(self, value: i32, f: F) -&gt; Fold&lt;F&gt; where F: FnMut(i32, i32) -&gt; i32; fn sum&lt;F&gt;(self) -&gt; Fold&lt;F&gt; where Self: Sized, F: FnMut(i32, i32) -&gt; i32 { self.fold::&lt;F&gt;(0, |i, v| i + v) } } Playpen: http://is.gd/isQykL
&gt; This video is currently being transcoded; that will take some time. Feel free to check again on its status after a while. &gt; &gt; The transcoding should have finished 4 hours 33 minutes ago I guess it must be a more amazing video than expected!
There's the [itertools](https://crates.io/crates/itertools) crate that has the following method: https://bluss.github.io/rust-itertools/doc/itertools/trait.Itertools.html#method.chunks_lazy
I really ought to work on my own terminal image thing in Rust. I had one in C++ that worked really well on the Windows console where it had only 16 colors, no cheaty 256 color nonsense. It took advantage of dithering and did everything in linear RGB space (which makes a _huge_ difference when you're dithering between only 16 colors). It only used the default 16 colors though for the windows console, I never around to making it choose a custom 16 color palette, something I'd like to do if/when I work on a Rust version. Example screenshot: http://i.imgur.com/aC0pb2U.png
**tl;dr** Niko gives a very nice introduction to the lazy iterators used everywhere in Rust, by showing how fundamental traits like `Iterator` and `IntoIterator` as well as methods likes `iter`, `map`, and `zip` are implemented. While this post explains the basics and shows that Rust is able to express these high-level constructs and compile them down to highly efficient code, two future posts teased, which will explain parallel iteration with _rayon_.
I heard about this, and wondering how important a rust replacement for glibc would be.
Nice!
I decided to stop procrastinating... Then, I saw this.
This is the shortcoming that most broke my heart about Rust, and it's the reason I went crawling back to C++ last year... The decision to implement binary operators as trait methods on the first operand means complex number templates are hosed: Complex&lt;real_type&gt; * real_type Is fine, but: real_type * Complex&lt;real_type&gt; is not generic. This just gets worse considering that you'd like matrices to do: Complex&lt;real_type&gt; * Matrix&lt;real_type&gt; -&gt; Matrix&lt;Complex&lt;real_type&gt;&gt; and so on... Of course you can implement specifics for any given real type (f64 for example), and you can use macros to save on the amount of duplicate code, but you need to invoke your macro for each new type you come across. It won't "just work" with someone else's Rational or Decimal type, and it should. Moreover, there won't be any macros to make interop work between libraries that don't know about each other (Matrix and Complex, for example) - end users will have to marry the two. Rust just got this part wrong... 
nice, thanks for the link! I was not aware of this :)
Ah yeah that would make sense, thanks.
[Linux kernel vulnerabilities](https://www.cvedetails.com/vulnerability-list.php?vendor_id=33&amp;product_id=47&amp;version_id=&amp;page=1&amp;hasexp=0&amp;opdos=0&amp;opec=0&amp;opov=0&amp;opcsrf=0&amp;opgpriv=0&amp;opsqli=0&amp;opxss=0&amp;opdirt=0&amp;opmemc=0&amp;ophttprs=0&amp;opbyp=0&amp;opfileinc=0&amp;opginf=0&amp;cvssscoremin=7&amp;cvssscoremax=7.99&amp;year=0&amp;month=0&amp;cweid=0&amp;order=3&amp;trc=269&amp;sha=27cc1be095dd1cc4189b3d337cc787289500c13e) [Glibc vulnerabilities](https://www.cvedetails.com/vulnerability-list.php?vendor_id=72&amp;product_id=767&amp;version_id=&amp;page=1&amp;hasexp=0&amp;opdos=0&amp;opec=0&amp;opov=0&amp;opcsrf=0&amp;opgpriv=0&amp;opsqli=0&amp;opxss=0&amp;opdirt=0&amp;opmemc=0&amp;ophttprs=0&amp;opbyp=0&amp;opfileinc=0&amp;opginf=0&amp;cvssscoremin=0&amp;cvssscoremax=0&amp;year=0&amp;month=0&amp;cweid=0&amp;order=3&amp;trc=62&amp;sha=5e0c40399ffafd65f77e6b537bcc0f50474eeed3) [Bash vulnerabilities](http://www.cvedetails.com/vulnerability-list.php?vendor_id=72&amp;product_id=21050&amp;version_id=&amp;page=1&amp;hasexp=0&amp;opdos=0&amp;opec=0&amp;opov=0&amp;opcsrf=0&amp;opgpriv=0&amp;opsqli=0&amp;opxss=0&amp;opdirt=0&amp;opmemc=0&amp;ophttprs=0&amp;opbyp=0&amp;opfileinc=0&amp;opginf=0&amp;cvssscoremin=0&amp;cvssscoremax=0&amp;year=0&amp;month=0&amp;cweid=0&amp;order=3&amp;trc=10&amp;sha=b7da5775428a703fdead6c27fbca76cd40b7c596) [X vulnerabilities](https://www.cvedetails.com/vulnerability-list.php?vendor_id=8216&amp;product_id=&amp;version_id=&amp;page=1&amp;hasexp=0&amp;opdos=0&amp;opec=0&amp;opov=0&amp;opcsrf=0&amp;opgpriv=0&amp;opsqli=0&amp;opxss=0&amp;opdirt=0&amp;opmemc=0&amp;ophttprs=0&amp;opbyp=0&amp;opfileinc=0&amp;opginf=0&amp;cvssscoremin=0&amp;cvssscoremax=0&amp;year=0&amp;month=0&amp;cweid=0&amp;order=3&amp;trc=55&amp;sha=a68a1ced1b67444749733b7fa9e1438ff0c42810) **We should be using Rust everywhere** Many of these vulnerabilities rely on buffer overflows, and would not happen in idiomatic Rust code. To build a secure operating system, we should use a microkernel architecture with most programs and drivers written in Rust, and preferring safe Rust.
There seems to be a small mistake in definition of `MapIter::next` – the return type should be `Option&lt;RET&gt;` instead of `RET` (with the body adjusted accordingly). Ping /u/nikomatsakis
That's a convincing response ! I now understand the utility of a rust OS, because rust help reduce the number of vulnerabilities. But helping does not mean it will happen. Rust removing some vulnerabilities is only interesting if your code also have less of non-prevented-by-rust vulnerabilities. Are you sure you are at least as good on non-prevented-by-rust vulnerabilities ? Linux have vulnerabilities, but few compared to the massive code base of the os (only 50 !). And is redox going to be a viable replacement of something like linux or FreeBSD ? I think redox is far from having has much feature as linux. And I am sure many of those missing feature are required to have industry considering using redox. Are you expecting to push redox to a point of being usable by industry as a replacement of linux for instance ?
Looks like they forgot to update the example in the documentation after merging [this PR](https://github.com/lfairy/maud/pull/31). Try `^name` instead of `$name`. Also looking at tests such as [this one](https://github.com/lfairy/maud/blob/master/maud_macros/tests/tests.rs#L149-L155). If this works, or even if it doesn't, definitely file a github issue so they know to update the documentation.
Ah, great, that's exactly it. Thanks!
Bonus points if the parsing part is done with nom ;)
Thanks Steve.
Yep, so I'll just remove this thread then. :)
num maintainer here - as long as it's not causing trouble, I don't mind leaving it there in a dusty corner. It would have been nice to delegate to std, the way ints do, but oh well.
Serde owner here. Sorry you were having problems with it enough to write your own parser! What problems were you running into?
Dear fellow Rustaceans! Author is here, feel free to ask questions :)
Actually not a problem with Serde itself, it was Aster that wasn't compiling for some reason. Also I didn't really liked that you need to be on nightly to compile. (even tho I'm using nightly anyway...) I did test adding Serde to the dependencies right now and it did compile now, so I may give it a second chance.
&gt; Why do we need to add dependencies in Cargo.toml? Can't Cargo deduce them from the "extern crate xxxx;" statements in the source files? From seeing the source code you can't infer that this `xxxx` crate actually comes from crates.io (as opposed to coming from another directory in your filesystem, or from Github).
&gt; struct JNINativeInterface JavaNativeInterfaceNativeInterface? Sounds about right.
I have run into similar issues, although I have never thought to perform the work-around you did. One band-aid solution would be to rename the trait on your working implementation to something like `MergePrivate` and then do: trait Merge { type Out; fn merge(self: Self) -&gt; Self::Out; } impl&lt;A, B&gt; Merge for (A, B) { type Out = &lt;() as MergePrivate&lt;A, B&gt;&gt;::Out; fn merge(self: Self) -&gt; Self::Out { &lt;() as MergePrivate&gt;::merge(self.0, self.1) } } Defining Merge implementations is still ugly, but at least then you could use it with your preferred syntax.
Maybe because you drop the `Library` on line 47. The `Symbol` type in libloading is parametrized by the lifetime of the underlying library, but when you do Library::new(&amp;path).unwrap().get(b"response\0").unwrap() You create a library, get and store a symbol out of it, and then destroy the library. Hence the "invalid memory error" you get. The simplest fix to that would be to store the libraries you use a separated container, just to make sure that they are not droped. I am not sure why this is not spotted by the compiler. Maybe something related to `unsafe`. Does it compile if you write it like this: let lib = Library::new(&amp;path).unwrap(); let symbol = usafe{ lib.get(b"response\0").unwrap() }; 
Is the `T: 'iter` syntax documented somewhere in Rust?
It's a [lifetime parameter](https://doc.rust-lang.org/book/lifetimes.html#lifetimes). Normally, people just use `'a` or `'b`. 
tl;dr -- What is the easiest way to pattern match multiple attributes in a FilterIterator predicate. (i.e filter on the values of a vec of attributes inside a vec of nodes) I'm writing an app that parses a page with `html5ever` . [The definition of a node in html5ever is very succinct] (http://doc.servo.org/html5ever/rcdom/struct.Node.html), and as a consequence there aren't many 'utility' methods implemented. I'd like to fetch a particular element in the DOM, and instead of walking the whole tree looking for the node the 'matching node', I would like to provide an ancestry list of structs with three attributes, all `Option&lt;&gt;`s (e.g `div`, `.class` and `#id`). I'd like to avoid nesting bunches of match clauses and so I'd like to know before I do that if there is an idiomatic way to destructure multiple such attributes in the form of a [Servo rcdom node](http://doc.servo.org/html5ever/struct.Attribute.html) (basically a kv vec) without getting extremely verbose?
Note that the crate name used in you Rust source code doesn't necessarily match the crate name in Cargo (and creates.io), so we can write something like this extern crate abc as abc2;
Wrong sub.
Conceivably `rustc` could have a commandline argument like `--extern-crate libc --extern-crate abc=abc2` or whatever, `cargo` could have a field in dependencies like `import_as = "abc2"`, and everything extern crate declarations do could be done by cargo. I don't know what would keep this from working. But I also feel fairly indifferent about the change.
OP said that his string is actually ASCII though.
The current generation of new programming languages (Rust, Go, Swift) have at least had the courage to throw out C's type declaration syntax (contrast Java, C++), so I'm hopeful that the *next* generation of new programming languages will at last chuck out `&amp;&amp;` and `||` for logical ops (C++ is already halfway there!), as well as reclaim all those nice characters that are currently tied up doing bitwise ops. These things take time! :P
&gt; Also, why two shift operators? What documentation are you referring to? We have left shift and right shift, but unlike, say, Java we don't have both `&gt;&gt;` and `&gt;&gt;&gt;` for signed and unsigned shift.
I wonder what the other browsers will do in the near term to compete if the performance difference is indeed so drastic, even ignoring security. As excited as I am for servo and webrender, for the web's sake I hope it's not a multi-year lead where we all begin to standardize on one browser again. It's certainly not impossible to create a system like webrender in C++, given the comparison to game engines. It will likely just take longer, and have all of the safety and stability issues we're all here to avoid. If I have time I'll be eager to evaluate whether webrender is efficient enough as to make the web smooth on very low powered devices. When you're running on a 600mhz single core arm chip, the existing browsers aren't remotely fast enough.
You can also write pub fn my_method&lt;T: MyStructTrait&gt;(t: &amp;T, s: &amp;MyStruct) { t.my_method(s) }
I meant two operators for two arithmetic shifts. As I said you could achieve an arithemtic shift in any direction with one operator, and using negative to go left and positive to go right. I also said this might not be a good idea, but you get the point.
It's not that I find it arbitrary, more inconsistent. Things like dot syntax for calls and double colons are consistent. Having logical operators like &lt; &amp;&amp; &gt; etc and bitwise like &amp; &lt;&lt; &gt;&gt; isn't consistent.
well, maybe in 10 years that next generation of programming language will exist XD. Or maybe rust need support something like "ascii binary operator overloading" (not arbitary +-%&lt;&gt;= like haskell &amp; scala) so we can create our "and", "or", "shl" syntax :). 
Making a new programming language is a tightrope act between familiarity and novelty. Rust simply chose to spend its novelty budget in different places.
Great article! Thanks for sharing. One question, why `Clone` is required for `Parser`?
Okay, I changed the code into this, http://hastebin.com/atisiyufiz And it works for the first time, if you send an http request, it sends back "hi". But the second time you send a request, it segfaults again saying http://i.shibe.ml/QmddXbFZyySaNmjyRacji57qTSEUaXVJcrWk4Q2Aejs6tu.png So what do I do?
Or even impl MyStruct { fn my_method&lt;T: MyStructTrait&gt;(&amp;self, t: &amp;T) { t.my_method(s) } }
Wait, does `..Config::default()` (which I assume returns a `Config`) actually unpack into the remaining fields?
Actually, the [nomicon](https://doc.rust-lang.org/stable/nomicon/dropck.html) has a section about how implementing `Drop` can cause things to stop compiling. I think the reasoning is just: If `struct Foo&lt;'a&gt;` implements `Drop`, then 'a must strictly outlive Foo, otherwise 'a is also allowed to have the same lifetime as Foo. And that works transitively, so in the case of `struct Foo&lt;'a&gt;(Bar&lt;'a&gt;)` then compilation can start failing if either of `Foo` and `Bar` starts implementing `Drop`: struct Foo&lt;'a&gt;(Bar&lt;'a&gt;); struct Bar&lt;'a&gt;(&amp;'a str); // impl&lt;'a&gt; Drop for Foo&lt;'a&gt; will cause compilation failure // impl&lt;'a&gt; Drop for Bar&lt;'a&gt; will cause compilation failure fn main() { let (f, s); s = String::from("mooh"); f = Foo(Bar(&amp;s)); } Which means that you're probably correct in that the drop policy is per type/lifetime parameter.
Yeah -- but it's creating a complete default `Config` that it uses for setting the other fields; it's not creating only the uninitialized fields.
You need to clone a parser if it's used in more than one log paths: parser p_parser { foo_parser(); }; log { ... parser(p_parser); ... }; log { ... parser(p_parser); ... }; The second p_parser is the clone of the first one. You don't have to implement the clone() method on the C side, but then you cannot use the same parser in different log paths.
- [Release Notes](https://github.com/rust-lang/rust/blob/master/RELEASES.md) for changes that have made it to stable - [Unstable features](https://github.com/rust-lang/rust/labels/B-Unstable) for changes that are implemented but not stable yet - [Approved RFCS awaiting implementation](https://github.com/rust-lang/rust/labels/B-RFC-approved) for changes that haven't happened yet.
I feel like a lot of that has to do with familiarity. Rust's main target audience is the C/C++ crowd, and subtly breaking commonly used semantics like that will really annoy people who work both in Rust and in C-like languages. I'd be pretty happy to see "and", "or", etc. implemented as operators though. 
You can also get subtraction using addition and negation (and it still works for unsigned numbers, thanks two's complement). I think it's clearer to have right shift instead of left shift by a negative number.
When combined with a wrapper function that dispatches to the right impl so that it doesn't look backwards, I've heard this called the "double-dispatch technique". It's useful for overloading, though it is verbose. Actually, I think if we had variadic generics, then we might have all of the power of Java/C++-style overloading, without actually having overloading as a separate language feature. Kinda neat.
Are these kinds of optimizations something we basically need to rely on LLVM to do, or is it reasonable for the Rust compiler to do them? 
That sounds like a minor inconsistency. `&gt;` is not the "logical version of" `&gt;&gt;`, they're just two operators using the same symbol.
Thanks for the examples &gt; The `T` type above could even be a reference Why *wouldn't* it be a reference? When you pass ownership you're not concerned with use-after-free, no?
Luckily, a lot *hasn't* changed – stability is a great thing ;-)
Indeed, this was actually a potential "drawback" in the [original proposal](https://github.com/rust-lang/rust/issues/10124), although it was never explicitly mentioned in the issue. And since we have the `Fn` traits, they could be "fixed" to work for this *right now*, with `struct function;` and several `impl Fn&lt;(A, B, C)&gt; for function {...}`. AFAIK, all typeck has to do is query, e.g. `Fn&lt;(_, _)&gt;` for a call with 2 arguments, instead of `Fn&lt;_&gt;` (cc /u/nikomatsakis for confirmation).
That image link isn't working, can you upload somewhere else(imgur.com is popular)? It if doesn't contain a stacktrace getting one of those would be nice as well. In general with libloading you use `libloading::{Symbol, Library}` instead of `libloading::os::unix::{Symbol, Library}` but I don't think that should cause any problems.
The Atom packages I have installed right now are: * [language-rust](https://atom.io/packages/language-rust) (syntax highlight) * [linter-rust](https://atom.io/packages/linter-rust) (lints code on file save) * [racer](https://atom.io/packages/racer) (auto-complete)
i also had [build-cargo](https://atom.io/packages/build-cargo), but found that linter-rust is actually better for everything. the only thing worse with that setup is switching between “clippy” and “test”, as you have to reach for the preferences every time.
It would be actually more useful to just copy and paste text here, it's just screenshot of one line of text output.
Process didn't exit successfully: 'target/debug/proxytest' (signal: 11, SIGSEGV: invalid memory reference)
This is a question about visibility of symbols. I have a lib.rs which references some other modules: pub mod foo; pub mod bar; pub mod load; I created a directory for foo and bar, and put a mod.rs in each, with the same content: pub mod baz; Then I created a module file foo/baz.rs and bar/baz.rs with symbols in them: pub struct Struct { ignore: i32 } Now back at the top level I made a load.rs module: use foo; use bar; pub fn as_foo() -&gt; Option&lt;foo::baz::Struct&gt; { unimplemented!(); } pub fn as_bar() -&gt; Option&lt;bar::baz::Struct&gt; { unimplemented!(); } Why do I get this error? Everything is public. error: type `Struct` is inaccessible pub fn as_foo() -&gt; Option&lt;foo::baz::Struct&gt; { ^~~~~~~~~~~~~~~~ 
Most architectures don't support shifting by a negative amount. x86 takes into account the 5 or 6 least significant bits for shifting, none of which happen to be the sign bit (IIRC MIPS also does that). So if you had only one shifting operator, you'd have to bet your bottom dollar that the optimizer can figure out that your shift amount is always positive or negative, so that it doesn't have to emit a branch (or a conditional move), a negation and two shifts.
Can you run it under lldb to get a backtrace? In order type: `lldb target/debug/executable_name`, `run`, (get the segfault), `bt`
&gt; so I'm hopeful that the next generation of new programming languages will at last chuck out &amp;&amp; and || for logical ops (C++ is already halfway there!) Source? The closest thing I managed to find is [this](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r0.html), but it's only related to template metaprogramming. 
It was in std and then it was removed. https://doc.rust-lang.org/std/primitive.f64.html
I'd say a browse through this-week-in-rust from when you last looked would be the best
It's because you lend your exclusive mutable borrow to the function. The mutable borrow of the function does not outlive that function, so "ownership" of the borrow is implicitly given back to the original function. If you would return the borrow from the function, this would not work anymore as you can see here: http://is.gd/oo1Lba Try renaming the z binding to _ and it works again.
What I'm trying to understand more is, why does "lending" my mutable reference work for functions, but [not for example with blocks](http://is.gd/tmRWus): let y = &amp;mut x; { let z = y; mutate(z); } mutate(y); // error: use of moved value: `*y` Naively I would think a function call is doing the same thing, moving my mutable reference into a local binding, but the function example seems "reversible" somehow while this block example is not. Note that if we throw in a few more `mut`s, the block example [actually does work](http://is.gd/W2vMTT): let mut y = &amp;mut x; { let z = &amp;mut y; mutate(z); } mutate(y); Is this sort of `&amp;mut &amp;mut` thing happening implicitly when I pass a reference into a function?
Oh, wow! Where has this syntax theme been all my life?? *Edit:* I just noticed you're the creator. Thanks so much for this theme. It's seriously good.
As mentioned by /u/krdln [here](https://www.reddit.com/r/rust/comments/46qwjv/why_can_i_use_an_mut_reference_twice/d078ggb) this is re-borrowing. When calling a function taking a `&amp;mut T` argument with a `&amp;mut T`, instead of moving the reference the compiler inserts a re-borrow automatically: `&amp;mut *t`. This creates a temporary mutable reference which: - transfer the borrow for the span of the function call - is itself moved into the function without actually invalidating the original mutable reference it came from. It can be a bit surprising, and was motivated by ergonomic concerns (not forcing users to write this re-borrow at every call). Steve Klabnik is working on the next iteration of the Rust book and will talk about re-borrowing there.
I'd love Rust having variadic generics. It's the one feature I probably miss the most.
Like Python, C++ has `and`/`or`for logical operations, but it only gets half credit because it will also have to deal with `&amp;&amp;`/`||` for the rest of eternity.
[clippy](https://github.com/Manishearth/rust-clippy) is a bunch of lints and warnings as compiler plugin. there’s a [cargo subcommand](https://github.com/arcnmx/cargo-clippy) for it, allowing you to run it via `cargo clippy`.
reminds me of [gruvbox](https://atom.io/themes/gruvbox)
These seem to be my settings for it. I guess also make sure the linter is actually enabled (through the command palette): "rust": { "@disable": false, "args": [], "crate-root": null, "excludes": [], "use-cargo": true, "use-cargo-check": false, "use-crate-root": false }
Can someone explain how [this example](http://is.gd/SM4un3) is moving out of borrowed content? I don't want to clone the iterator because I want subsequent calls to `do_things` to pick up where they left off.
Yeah, that inline errors are pretty nice. That's the one thing I'm really missing.
for running it? that makes sense. but for developing i like the instant and inline way linter-rust works.
Automatically taking a reference to something has broader semantic and runtime consequences than re-borrowing a `&amp;mut`. In this instance Rust was heavily influenced by experience with C++, where autoreference is an oft-bemoaned feature of the language (though this can be a contentious topic).
&gt; Copying is just a bitwise copy and is always cheap. That's only because it's rare for people to make large structs. If you had struct Massive { data: [u8; 1024] } , then it would be almost as expensive to copy or move as an equivalently-sized `Vec` would be to clone.
The for loop tries to call `self.input.into_iter()` which would consume `self.input`. Just change it to `&amp;mut self.input` so that it iterates by reference.
Right, I forgot that for loops use `into_iter()`. Thanks
That is very true.
Thank you for the exhaustive testing, you were right. Due to having 2 modules that are very similar (as the example I showed) I forgot to update the other module tree and I skimped over the errors not realizing it was only giving errors for the `foo` module when `bar` was working fine... Again thank you for going to the effort to test all this.
If you don't mind me pitching another editor, I found the atom ecosystem to be buggy and slow. Instead I'm using visual-studio-code with [RustyCode](https://github.com/saviorisdead/RustyCode) which has been working pretty much flawlessly.
I think maidsafe is using it as well
I only learned this detail recently: the fact that your original example does not get reborrows automatically inserted is actually an artifact of our *type inference* system. In particular, if you add a type annotation to the `let z`, the compiler will insert a reborrow: fn mutate(_: &amp;mut i32) { } fn main() { let mut x = 10; let y = &amp;mut x; { let z: &amp;mut i32 = y; mutate(z); } mutate(y); } playpen: http://is.gd/dxk31z ---- Update: Just to clarify, in a statement like `let z = y;`, the compiler cannot insert a reborrow for the `let z = y;` because it doesn't know the type of `z` (and thus conservatively assumes that it might require a coercion at that point to fill in whatever type is filled in by the inference system).
I see. I think you might be interested in following, and possibly commenting on, [the RFC on factoring out a `std::sys` that contains all of the platform-specific code in `libstd`](https://github.com/rust-lang/rfcs/pull/1502). While this RFC alone wouldn't give you a pluggable `libstd`, I think it would dramatically reduce the burden of maintaining a port, and be a step towards a pluggable `libstd`. If you're already involved there, apologies, I just don't know everyone's mappings between GitHub and Reddit usernames.
I'm indeed already involved, but thanks anyway :)
That's fascinating. Is this considered a bug? I can imagine having cases that the inferer can't figure out, but it seems weird to have a case that it *can* figure out nonetheless behave differently when you're explicit.
Loved your WebRender talk! Sadly didn't get to see it in person.
Thanks for the advice. I agree, I also find Atom a bit slow etc but I figured it it is the easiest way to set up a Rust environment, so be it. Not even sure how much I will use it. Just interested in a modern, safe language to try out. :)
I've only been using it for side projects in rust, my main development work is (unfortunately) in Java and for that I like having an actual IDE. With that disclaimer I've had practically no issues in the month or two I've been using it. There seems to be a small amount of memory leakage as you leave the same instance running for days at a time, but that's easily fixed by reloading it occaisonally.
**Edit** I wrote a topic about this on the forum. I guess it's more coherent there. https://internals.rust-lang.org/t/zip-optimization-riddles/3189 ---- Here's an example of why .zip() is fragile and why I didn't see it autovectorize before -- using for loop directly vs .map() affects the output. https://play.rust-lang.org/?gist=4b2fed2bb83c447f61c3&amp;version=nightly The indexed version is "Best" here because only it enables `memcpy` loop idiom recognize. I also plugged in .zip() into the core of ndarray, and it autovectorizes there as well. Normally I use the indexed approach. In ndarray, .zip() benchmarks just slightly worse, because the vectorization code is slightly different -- it is not interleaving instructions from successive operations as well in the .zip() case as it does in the indexed algorithm, so again the indexed approach is just a bit better. Here is a comparison of the two loop cores for zip() vs indexed method, for a loop that basically does `x[i] += y[i]`. ASM: https://gist.github.com/bluss/06818f5c19ce13474aa1 Rust: https://play.rust-lang.org/?gist=d9f8d962139c4edfd52a&amp;version=nightly
How confident are you that the response box was the actual problem, and changing it hasn't just happened to cause the undefined behaviour to not show up? I ask because I'm dealing with what appears to be a similar bug in my code which uses libloading. It's entirely possible it's in another part of my codebase (which is also highly unsafe) but I'd like to know if I should investigate libloading more carefully first.
[OP](https://www.reddit.com/user/rumbl1000/submitted/) is a karma bot: /r/rust/comments/451j48/rpcperf_an_rpc_performance_testing_tool_from/ More info [here](https://www.reddit.com/r/BotWatchman/comments/46s2ic/overview_for_rumbl1000/)
The formatting is a little odd, but I found the (likely unofficial/incomplete) [style guide](https://github.com/rust-lang/rust/blob/master/src/doc/style/features/functions-and-methods/input.md) in the rust repository useful. In particular: &gt; Let the client decide when to copy and where to place data. &gt; &gt; If a function requires ownership of a value of unknown type T, but does not otherwise need to make copies, the function should take ownership of the argument (pass by value T) rather than using .clone(). That way, the caller can decide whether to relinquish ownership or to clone. &gt; &gt; Similarly, the Copy trait bound should only be demanded it when absolutely needed, not as a way of signaling that copies should be cheap to make. Which makes sense. Copying values seems like a choice better left to the caller, if possible.
&gt; If a function requires ownership of a value of unknown type T, but does not otherwise need to make copies, the function should take ownership of the argument (pass by value T) rather than using .clone(). That way, the caller can decide whether to relinquish ownership or to clone. That's a much needed explanation for me. I kept wondering why the standard library often decides on, "yeah, I'm going to eat this variable so the client can't ever use it again." *Because* the alternative is "yeah, I'm going to give the client no choice but to duplicate this data. Makes sense!
[YouCompleteMe](https://atom.io/packages/you-complete-me) is a must have. It provides fast, fuzzy, as-you-type code completion, GoTo, and (for some languages) real time feedback from the compiler. YCM's Rust support doesn't have the latter, but the first two are game changing. 
1. Always just copy if it is small and you don't need to share mutations (if this covers you, skip 2 &amp; 3) 2. If you pass something to a function, do it as a borrow 3. If you allocate something in a function, then return ownership to the caller The idea is simple: don't deal with shared ownership if you don't have to, but if you do, then make sure the owner is the highest possible stack frame because that's the one that will live the longest. 
I think relying on macros to implement boilerplate for operators indicates that Rust's template operator traits are inadequate. &gt; Multiplication isn't always commutative I never said it was. I don't want Rust to secretly swap the order of the operands. In fact, I would suggest that Rust's type system should be able to preserve non-commutative values (and even types) with operators. For intstance: Given types A and B, with variables a and b: If a*b gives value c with type C and b*a gives value d type D then a*Complex&lt;B&gt;(real, imag) should give Complex&lt;C&gt;(a*real, a*imag) while Complex&lt;B&gt;(real, imag)*a should give Complex&lt;D&gt;(real*a, imag*a) etc... I can do this with C++ (although the STL std::complex does not do this). &gt; Would this be fixed if structs like Ratio were traits with default CRatio No, this misses the point completely. There are dozens of useful scalar types that Rust doesn't know anything about. In addition to Ratio, you could have DoubleDouble, QuadDouble, BigDecimal, ArbitraryPrecisionDecimal, IntervalArithmetic, AutomaticDifferentiation, and many more. And in addition to Complex values over the real scalars, you could have Quarternions, Matrices, TensorArrays, and many other things. It's entirely reasonable to want a Matrix&lt;AutoDiff&lt;Complex&lt;f64&gt;&gt;&gt; and expect to be able to multiply it by an f64. Creating new traits for all of those doesn't solve the problem. The core Rust system should not need to know about any of these in order for users to mix and match third party libraries. &gt; How would you propose to make it "just work"? It seems to me that there are two obvious solutions. The first, and more preferable to my mind, is to acknowledge that binary operators are functions that operate on pairs of values and not methods on the first value. This would be a significant change to Rust, but it would be the "right" thing to do. The second, is to add right-handed versions of each binary operator trait, and have the type system resolve to the left-handed operator trait if one matches and then fallback to a right-handed trait if one exists and matches. This is kind of like what Python has with it's __rmul__ kinds of operators. However, I've never seen a core Rust developer even admit the current system has shortcomings, so I doubt this will ever be fixed. They're busy worrying about adding "higher kinded types" and "negative traits" when they can't even do real*complex with templates reasonably. I assume this is because web developers (and web-browser developers) don't particularly notice or care about complex numbers. If I sound bitter, it's because I've been watching Rust for the last few years and hoping it could save me from all the other nonsense and complexity in C++. However, this is one of several things C++ does much better, and Rust just got it wrong. 
Welcome to Reddit. Before posting, you should make sure you're posting to the right subreddit. Blind posting often leads to, *just as an example*, posting stuff about a video game to a subreddit dedicated to a programming language. When you submit a link, Reddit will tell you what the subreddit is about; make sure you check that. You want /r/playrust.
Would love to see Rust explode in China just like Go has done.
Cloning a `Rc` is very cheap. Cloning a `Vec`, maybe not. &gt; If you wanted to be really tricky, instead of returning a Vec&lt;String&gt;, you could return a Vec&lt;&amp;String&gt; I would prefer a `Vec&lt;&amp;str&gt;` (`&amp;String` ends up being a double pointer)
Thanks for the information (and presumably the report). As we in /r/rust support /r/botsrights, I don't think any action will be necessary.