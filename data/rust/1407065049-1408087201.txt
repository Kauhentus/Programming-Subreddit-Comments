Thanks for the links. Actually the second link contains an explanation which is fully convincing for me. &gt;It falls out automatically from supporting shadowing-in-general (idents in enclosing scopes) and the ability to declare new variables mid-block. Each new decl opens a new implicit scope from its point-of-decl to the end of its lexical block. An optional lint would still be useful, but for shadowing in general, and not for this particular case.
Variable shadowing has a lot of synergy with affine types (move semantics). E.g. let foo = foo.unwrap(); where you're rebinding `foo` to refer to the result of `unwrap()` at the same time as the old `foo` becomes inaccessible because of it.
I personally use this feature to avoid having to come up with arbitrarily different names for variables which are essentially a temporary copy of some other variable. let ctx = match renderer { LiveRenderer(_, ref mut ctx) =&gt; ctx, DeadRenderer =&gt; fail!() }; - let mut stream: Option&lt;Stream&gt; = open_input_stream(); //... if stream.is_some() { let stream = stream.get_mut_ref(); for n in range(0, file_len) { stream.emit_byte(bytes[n]) } } It makes code marginally more difficult to comprehend (I will occasionally become confused about a variable's type, having looked at the wrong definition), but I think that saving the programmer from having to come up with endless silly derived names, like `internal_ctx` or `stream_ref`, makes this feature a definite net good.
[Isaac Schlueter](https://news.ycombinator.com/item?id=840331): &gt; [...] The length of a variable's name should be proportional to the distance between its definition and its use, and inversely proportional to its frequency of use.
Even in haskell I *always* write top level function type declarations. Makes the code so much easier to read. 
As an IRC network operator this is a welcoming direction. Many IRC servers (and services, for what it matters) are either very stable at expense of less features or not very stable but feature-rich; an well-tested and verifiably safe server would be a good way to go.
I find this example unconvincing. Mainly because it's not idiomatic Rust. One could write the same thing with no mutability, `let` or assignment in a block, and it's shorter and more readable too. let percentage = if OVERRIDE &gt; 200f32 { OVERRIDE } else { 100f32 } .round();
If servo fails what makes you believe the language will die?
There's no project to push it forward. The code is open-source and the community will undoubtedly pick it up but the quality and level of commitment of the developers will vary significantly. The project will end up suffering a slow death. Meanwhile I'm doing a project in Rust that I wanted to do in C++ and my productivity levels have gone through the sky and I really really don't want to lose that.
I disagree. I find it very useful to make `stream_ref` type variables because then I can debug them. If `stream` refers to different variables it makes it confusing since based on where you are in the logic it's a different value and in your example is even worse since you are using the original value in it. It's the same concept as mutable state: let data = get_videos(id); ... let data = get_video_info(data); ... let data = get_publisher_video(data); ... let data = get_advertiser_video(data); ... now you want to refactor this monstrosity into something more manageable and understandable, but each method keeps appending info from the DB to your data and returning more stuff and you can't just skip the `get_video_info` call because the `get_advertiser_video` method might read the video id from that call (here `data` is a hashmap with db fields and each method call can take things out of the hash map and put more things in) so reusing the same variable is basically the same as having mutable data because it makes it difficult to debug the same symbol that's shadowed and makes the data flow more opaque and harder to understand
Yes, we plan to make Servo easily embeddable from the start.
I don't like that you test it by regexes, it's kind of hackish. It doesn't cover cases like "my program outputted Buzzfizz by accident" or whatever (depending on the implementation this could happen) I have a fizzbuzz program of my own: https://bitbucket.org/iopq/fizzbuzz-in-rust the output is different due to capitalization, but I could just change it to do "fizz" and "buzz" and capitalize the first letter every time my program has a few extra features as well, I can output any string (including empty string) and any combination of factors in any order, any REMAINDER (I can do fizzbuzz when the remainder is 1 from dividing by 3 and dividing by 5 - so fizzbuzz on 16), any default value (not just the number itself, but any function on the number) how would I test that?
In case it's unclear, the concrete reason I want to avoid having `a` know about the message type is that in the real-world case this ends up dragging in a ton of extra dependencies that the `a` crate should never need to be exposed to.
Use [this](http://code.google.com/p/chromiumembedded/) API and you'll be fine. We're doing a talk on it [at LinuxCon](http://lccona14.sched.org/event/aff393e7ce1495272da79ea0da6449ca) in a couple weeks as well.
It's a pattern syntax rather than part of the type, so it won't show up as part of the type elsewhere.
You could have b create the receiver, return it as a Box&lt;std::any::Any&gt; (or preferably a more type safe wrapper) and pass it to c which then unwraps it into a Box&lt;Receiver&lt;Whatever&gt;&gt;. Something like: use std::any::Any; use std::owned::BoxAny; fn main() { let recv: Box&lt;Any&gt; = b_crate(); c_crate(recv); } // main() does not depend on this type type MyType = int; fn b_crate() -&gt; Box&lt;Any&gt; { let (send, recv) = channel::&lt;MyType&gt;(); let recv = box recv as Box&lt;Any&gt;; send.send(10); recv } fn c_crate(recv: Box&lt;Any&gt;) { let recv = recv.downcast::&lt;Receiver&lt;MyType&gt;&gt;().unwrap(); println!("{}", recv.recv()); } I'm a bit confused by your example though as c uses structures from b and so the a crate shouldn't really be necessary. I'm assuming that in fact b and c both depend on a d crate and not each other which defines structures used by both?
Not everybody has an ä key.
IMO..whilst explicit types are useful most of the time, I can see 2 situations where full type inference would be useful:- (i) refactoring: when you have a large function that you want to break up , you suddenly find you have to figure some types out that were previously inferred. It would keep things more fluid, sometimes the function name is sufficient info. Does this create a slight draw toward bigger functions to leverage inference? (ii) it would also help with small 1 line functions (clamp,lerp..), where the implementation might be smaller than the type info/bounds a useful compromise might be full inference for local/private functions only, for case (i).. case (ii) might just as easily be macros i guess
I, for one, feel a slight patriotic tingle.
https://www.google.com/search?q=chat+rust
This is an interesting idea!
Nope, there isn't. There have been some proposals to make this a bit easier. (Also, they should be `Trait1` and `Trait2`.
&gt; The decoupling problem here is that the a crate does not (and should not) need to know anything about the values sent over the channel; Not if you want the channel to be strongly typed...
Well, I hope that those proposals are listened to. I've found myself using too specific of a type just because it's less typing with the current system. Thanks.
&gt; // Unused imports are allowed because randomness is used &gt; // for fuzz testing and not a normal compile Two better ways: 1. Put your tests inside a `test` module, and only import rand in there. This is considered good Rust style. 2. I _think_ you can also `#[cfg(test)]` on that `use`.
Yeah, but the downside there is that you're using a Mac. I found a keyboard layout called English International w/ AltGr that lets me type those letters with combinations like RightAlt + " + u = ü and RightAlt + 6 + e = ê, but that's only because I use French occasionally. Most people don't have that set up.
Je n'en parle que deux. Est-ce que je peux vivre?
`a` is the crate the controls the instantiation of the tasks from `b` and `c`. As I said, it's a reduced example.
There is a proposal to make declarations a bit easier to read (but not shorter). https://github.com/rust-lang/rfcs/pull/135 On the other hand, what would be your preferred syntax for the example case?
Félicitations. Maintenant nous pouvons parler sans les autres nous comprendre[.](https://translate.google.com/#auto/en/F%C3%A9licitations.%20Maintenant%20nous%20pouvons%20parler%20sans%20les%20autres%20nous%20comprendre%2C%20sauf%20s%27ils%20utilisent%20ce%20lien.)
The single letter variables I frequently use are: * `a`, `b` for arguments to binary operations * `c`, `d`, `g` for drawing context * `i`, `j`, `k` for indexes * `n`, `m` for length * `x`, `y`, `z`, `t` as spatial coordinates with their deltas `dx`, `dy`, `dz`, `dt` Sometimes I use `p`, `q` or `v`, `u` for more complicated math.
도와주세요! 나는 RUST 프로그램에 갇혀 있어요.
&gt; sans les autres nous comprendre sans que les autres nous comprennent. ^ ^ 
Google normally doesn't care and finds it anyway.
They come with their own sets of drawbacks. Complicated types are inherently complicated. We'll see how it ends up.
https://www.google.com/search?q=chat+rust 
Yes it is a bit generic. :/
My point is (at least under my search results), the search term "chät rust" has your library as the second result, but "chat rust" is entirely about the game.
 impl Configuration { ... fn get_settings(&amp;self) -&gt; &amp;Settings { &amp;self.settings } ... } It's somewhat shorter, but not that much.
Who said it's public? I want people to access it but not change it.
The lack of `const` alone makes it much easier to type.
Also, there are plenty of tools that haven't been tested against Unicode strings. They should be, but they aren't.
Thanks! Tests and their imports moved over to a dedicated module, I'll keep that in mind. I still got unused import errors, but dropping `#[cfg(test)]` in front of the module cleared that right up.
I'm sorry, your naming convention mislead me into believing this-&gt;settings was public. Regarding your definition, the only thing it does is put in place compile-time restrictions on how to access a member variable. If all you want to accomplish is instruct the compiler how to limit access to an object which otherwise would be freely accessible then obviously you should expect that the declaration would be bigger than the implementation. Besides this, your example appears to have a bug. The type of your definition (const Settings&amp;) doesn't match the type you're trying to return (the address of this-&gt;settings).
It was more the b c interdependency that I was curious about because if they have a common dependency (say d) you can do something like this which should enforce type safety. // Common to a, b, and c use std::any::Any; use std::owned::BoxAny; pub struct SomeTypeMarker; pub trait ReceiverBoxMarker&lt;T&gt; { } pub struct ReceiverBox&lt;T&gt; { recv: Box&lt;Any&gt;, } impl&lt;U, T: ReceiverBoxMarker&lt;U&gt;&gt; ReceiverBox&lt;T&gt; { pub fn new(recv: Receiver&lt;U&gt;) -&gt; ReceiverBox&lt;T&gt; { ReceiverBox { recv: box recv as Box&lt;Any&gt; } } pub fn unwrap(self) -&gt; Receiver&lt;U&gt; { let box recv = recv.downcast::&lt;Receiver&lt;U&gt;&gt;().unwrap(); recv } } // Common to b and c pub struct SomeType; impl ReceiverBoxMarker&lt;SomeType&gt; for SomeTypeMarker { } 
if that's your biggest complaint with C++ ... lucky you :)
Now that languages tend to be switching over to unicode-by-default instead of ascii-by-default (Python 3, Rust), that will probably become less of a problem over time.
Then this is yet another tiny motivation for people to do something about it. 
&gt; I've never thing the software community so excited about a new language like with Rust. I think I can, in recent memory; Swift. From zero to nothing over night (which is understandable, given the circumstances). As an example: /r/swift has already got more members than /r/rust. No, seeming Reddit mind share isn't necessarily indicative of anything in the grand scheme of things, but still. &gt; Even the enthusiasm for golang subsided significantly when people realised they couldn't get rid of the garbage collector and couldn't get used to the type system. Maybe it depends on the people you hang out with? It initially wanted to attract C/++ delevopers, but it has probably made more impact on Python, Ruby etc developers. 
You forgot to mention the worst part--the need to write a duplicate function prototype in a different place, the header file, often with significantly different syntax... virtual InnerStruct* GetFoo(int parameter = 0) const; Class::InnerStruct* Class::GetFoo(int parameter) const { ... } But why Rust? D is a pretty good alternative too.
Garbage collection. Plus, I'm already settled into rust, I don't want to learn D.
There's a lot of people who see mobile development as a ticket out of whatever circumstances they're in. Once that starts to die down, and it is happening... As for golang, the fact that indeed it cannot replace C/C++ is the problem. It found a new niche but the predicted explosive growth was definitely stunted.
It is indeed buggy. I wrote the post in frustration before running my unit tests.
I haven't dived too deeply into the code, but the use of `Relaxed` memory ordering everywhere is probably incorrect. I believe hazard pointer algorithms generally require `SeqCst` access.
I agree that we ought not to hide this information, but this is probably the wrong forum.
In that same module, you could write #[cfg(test)] pub fn points_to_original_function(arg1: T1, arg2: T2) -&gt; R { original_function(arg1, arg2) } This function will only exist in the `test` environment. It's a bit of a hack, but w/e.
That's what :t is for. (Interactive prompt type detection) A lot of haskell programmers write the function, let :t spit out the type and then bake it in as docs / insurance.
Yes, but you often run it once, and use :t to get the type then bake it in. I'm not a fan of the compiler adding non-optional style requirements like this. It fits much better as part of a linter or -W flag.
This might not be what you're looking for, but directly testing private methods is something you [don't generally do](http://programmers.stackexchange.com/questions/100959/how-do-you-unit-test-private-methods). Private methods get tested by testing the public methods that use them. They are an internal implementation detail of the class or module they are inside of. If you feel like there is too much logic in your private method to avoid a test, then that may be a signal that it should be pulled into its own module or class. Of course there are exceptions to everything though.
As different as Rust is from C++, D is incredibly similar to C++. Lots more things are intuitive in the sense of "this worked in C++".
Except I want to provide a single interface to a `mod` through a public method while splitting complex business logic into several smaller methods.
Or `#[test]`. But I wonder if I have to put the test method in the same `mod` as the implementation method.
Someone was doing preliminary work on Qt bindings. They were having trouble with Qt's use of C++'s overloading not working nicely with Rust's design decision not to include overloading.
I was interested in creating an IRC client in Rust. My only issue is that I'm not very familiar with the IRC protocol and I got stuck trying to parse messages. If anyone would like to team up, let me know!
Hopefully before too long `rustc` is going into package manager repositories so we don't have to jump through these hoops. Probably not until 1.0, though.
Well, this isn't going anywhere so I'll drop it. But the advice given is general design advice, not language specific, even though it's a Java question. Large amounts of private logic is a code smell no matter what the language. Everyone agrees with this whether or not they realize it, just at different levels due to personal taste. If you have a 1 million line code base with only one public method, that's clearly too much private logic and I don't think anyone would argue it. The above post is more about adjusting your refactor-o-meter to be more sensitive. For me, my trigger point when I step back and reevaluate the design is when I start feeling the need to test private methods. This is where I refactor into smaller units, whether that be Java classes, Rust modules, or multiple public methods on different Structs. I'm probably past the point of giving uneeded advice, so as I said I'll drop this and we can agree to disagree :) 
I found [a blog post](http://calebdelnay.com/blog/2010/11/parsing-the-irc-message-format-as-a-client) that explains this quite in detail. And maybe have a look at [RFC 2812](http://tools.ietf.org/html/rfc2812#section-2.3.1). 
can D do move-semantics 
It's not redundant as it returns a const reference. You may read the settings but not alter them. 
I really like your example, the result looks pathological to an outsider but you can easily write yourself into that corner when (ab)using shadowing. On the other hand you do the same sort of stuff in Haskell-land, which comes with no mutation either: let x' = foo x x'' = bar x' in baz x'' Here you don’t do `x = foo x` not because shadowing is disallowed, but because you would define a recursive (and likely useless) binding. The net result is relevant though. So, I’m on the fence. On the one-hand I’m really tired of ‘priming’ identifiers. On the other hand the primes grow about as fast as the sense of unease that you’re doing something wrong, so they serve as a built-in warning of sorts. On the gripping hand I just don’t feel that strongly against shadowing and I can’t help but think that this is throwing the baby out with the bathwater. (To be fair though Haskell does come with lots of way to combine and compose ‘successive’ computations, and I’ve very rarely seen identifiers grow beyond one prime. That in itself might be important.) In any case I’ll certainly keep this pathological case in mind as a cautionary tale one way or the other
actually, yes. But almost nobody uses it. They do like their garbage collector and their reference types.
I could be horribly wrong, however Relaxed should work. This is since I am only using atomics to ensure a consistent order exists given operations affecting a specific address. However, I'll have to look into this a bit more before I'm 100% positive. Thanks for bring it up. Edit: Will probably have to change some things in my hazard pointer algorithm as ordering is a bit more complicated than I originally assumed.
Because Rust has far more forms than just `&amp;self`. C++ has an implicit `this` because that's all it has, whereas with Rust, you need to be explicit on what kind of `self` you want to take. * `self` -&gt; self by value * `&amp;self` -&gt; self by reference * `&amp;mut self` -&gt; self by mutable reference * etc... The second piece being it also changes if the function is static or an actual method operating on an instance of a record.
To distinguish between &amp;self, &amp;mut self, and self. It could be inferred, but I like that a function signature gives me a lot of information just by looking at it. I'm not sure but I think there are plans to allow destructuring of self as well, which is really handy when self is a tuple struct or intended to be behind a pointer. 
I guess my milage varies. I've known about the existence of D for a long time. But I've never seen any material about D that convinced me to dive in. And I've browsed their hompage more than once and probably watched every presentation by Alexandrescu in which he tries to sell D lang. It's always "meh." Rust on the other hand had me at "runs blazingly fast, prevents almost all crashes, and eliminates data races" together with "zero-cost abstractions".
C++ lets you stick 'const' on the end to differentiate &amp;self/ &amp;mut self i think i prefer rusts' idea of an explicit self parameter though. I wish there was a way of destructuring self aswell
Usually, the private implementation uses algorithms or data structures that can be generalized and have a value by itself. E.g. if your private implementation internally uses a sorted array, you can implement the sorting as a private function, since it's just internal. Or you recognize that sorting an array is generally useful and factor it out. You can also do this if the resulting 'helper module' is not useful for other purposes. Other code does not have to import it and it does not hurt encapsulation. After all, you still cannot alter private data with the help of that module.
Either way, the binary snapshots will be fetched by the build system over HTTP.
And if you test your private methods you're not hiding the implementation anymore. If it changes, the tests will need to change too. And no code should have to change just because you change implementation details.
expr's `irc-message`[0] Node.js module should be a quick and easy translation to Rust. It is spec compliant. Be sure to tell him (he's in #expr on Freenode) if you do so. My `irc-socket`[1] may be of use, trading the event emitter for a channel, using an enum for the possible message types (which are helpfully enumerated in the documentation already). [0] https://github.com/expr/irc-message [1] https://github.com/Havvy/irc-socket
This actually explains it quite well. Although adding something like C++'s `this` would reduce the amount of noise.
The Index trait is relatively new, and getting it working for HashMap is probably in the works already.
Doing it via a method allows returning a bool to indicate whether the key was already present or not.
IndexAssign doesn't even exist yet.
Types in function signatures are never inferred. There are various benefits and drawbacks to this approach. What you're seeing is a drawback.
Oh :)
This is very interesting.
What? You hide implementation details from the consumers of your code. That's why you have encapsulation. Unit tests and written and consumed by the developer, not the people you hand your library to.
The binary snapshots are verified by checking their SHA1 hash, though, I think, so I don't think its an issue that these are fetched over HTTP. EDIT: nevermind - I though you meant the binary snapshots when you build Rust. The binary snapshots that rustup.sh fetches are fetched via HTTP, as you point out, and not verified. So, accessing rustup.sh over HTTPS won't accomplish to much since what it actually downloads still isn't verified.
rustup.sh fetches the nightly binary snapshots via http and doesn't have a way to verify the authenticity since they aren't signed.
But won't bar need a reference to `&amp;self`? How do I provide that?
As pointed out by other commenters, you test the public API, not the implementation details. This way you can change the underlying algorithms, just not the API, and tests still pass
And how do I know the implementation details are correct?
Strangely, the following works as expected: struct Foo { x : Vec&lt;int&gt;, y : Vec&lt;int&gt; } fn move&lt;T&gt;(x: T) -&gt; T { x } fn main () { let foo = box Foo { x : vec![1,2,3], y : vec![4,5,6]}; let box Foo { x, y } = move(foo); }
(You're welcome!) I just accidentally stumbled upon [a followup paper](http://research.microsoft.com/apps/pubs/?id=151805) which is based on Haskell rather than C#, and even achieves purity via some kind of `ST`-monad-like mechanism. (The `ST` monad in Haskell corresponds to lifetimes in Rust, so this could be interesting.) Having discovered it mere minutes ago, I haven't read it yet. Edit: oops, [two](http://research.microsoft.com/apps/pubs/default.aspx?id=150431) [more](http://research.microsoft.com/apps/pubs/default.aspx?id=145511)!
Stack Overflow is not very responsive? Vladimir, Huon and I all do plenty of answering over there. To be sure the community here is larger, but I have the impression that we’re not at all unresponsive on SO. Can you give details so that we can improve it?
You're not talking about unit testing, right?
This seems like they are talking about end-to-end or 'functional' tests IMHO.
Most package managers aren't gonna provide nightly builds :/
This could be improved by allowing box patterns on arbitrary impls of `Deref` (and I think there is a plan to do this?). I don't know if it would be possible to do the same thing for bind-by-move with a future `DerefMove` trait. The goal is to eliminate all special handling of `Box` in the language if possible, and extend all of the remaining capabilities to arbitrary smart pointers.
what does that have to do with privacy?
Wrong. See http://doc.rust-lang.org/std/str/type.MaybeOwned.html
Still, it just seems like trading one form of verbosity for another.
There's a PR for it, someone with authority just needs to review and (ideally) accept it: https://github.com/rust-lang/rust/pull/16195 libcollections is very much so an inconsistent hash of ideas right now. Nham, Treeman, and others have done a great job filling in gaps in implementations and documentation, though!
I am. I don't know of any common practice there is where a private implementation is tested. Have any examples?
Unit tests are consumers of the code, even if they are often authored by the same people.
Could this be temporarily solved using a macro? Do you have any other idea as to what might be a temporary solution?
If you have complicated internal function it makes a lot of sense to test it individually to, e.g., assist when writing it (and when editing it later).
I upvoted you back to 1, but I disagree with sentence #3.
`delete mvec` makes no sense with affine types, since the `mvec` data is moved into `ivec` and it is illegal to use the `mvec` variable after that. (Without reinitialising it with a new `Vec`, at least.)
So the goal is to avoid `a` having to have an `extern crate c` (or `extern crate b`)?
Good guy Steve Klabnik
An example of gecko being embedded https://github.com/sailfishos/sailfish-browser
I think something like this defeats the beauty of the solution. Even breaking it onto multiple lines it's fairly unpalatable. let banana = { let mut banana = Vec::new(); banana.push(1u32); banana.push(2); banana }; If you want to disallow shadowing of mutable variables, I think the proper solution is to add a way to make the intention explicit. let mut banana = Vec::new(); banana.push(1u32); banana.push(2); let const banana = banana; Feel free to argue what syntax this form would take, but I think the usability of the language requires that it stay beautiful.
I don't know of a great temporary solution. :-/
 #[test] fn test_foo_bar() { let foo = Foo::new(); foo.bar(); }
Im not in favor of this, I would be in favor of a lint that against variable shadowing, which is opt-out by default.
So far I've done all my Rust programming in a linux VM on my windows computer. I get the impression that windows isn't all that high a priority at the moment.
&gt; there \ in Program Files isn't escaped correctly This sounds like [a bug](https://github.com/rust-lang/cargo/issues/new). &gt; the majority of rust libraries assume that you're going to rely on the system C shared library, and dont work at all. Are you saying that Rust libraries don't work because they are relying on the system libc? 
Dust seems to me more like an imperative Haskell than Rust. Rust is interesting because it brings a lot of modern design ideas to a language with no inherent runtime overhead and with complete safety. Its type system, while powerful, is not its focus. It's basically just Haskell's type system plus whatever's needed for communicating lower level ideas (pointers, vectors, strings). If you're on a high-level platform like a javascript VM, everything that makes Rust interesting is no longer relevant, and you're left with Haskell's type system in an imperative language. This isn't a diss against Dust, I was initially attracted to Rust for its similarities to Haskell. I just think that the project might want to rebrand itself to be more of its own thing.
For the moment my solution is to avoid using any Rust library that depends on a C library. No glfw-rs, no rust-sdl, no curl-rs, no rust-openssl for me. gl-rs will hopefully be fixed soon. &gt; Running cargo-test blows away the test folder every time, so if you try to manually copy the DLL into it so your tests can run, it never works. Note that you can execute `cargo test` then quickly copy-paste the DLLs into `target/deps` while rustc is compiling. This is what I do when I work on my Lua bindings which require the Lua library. I didn't find any other way. 
Thanks!
Anyone who wants to achieve 100% code coverage and thus be assured that their code is modular enough to be easy to change?
&gt; Are you saying that Rust libraries don't work because they are relying on the system libc? No, rust crates typically link using: #[link(name="curl")] extern { ... } Which assumes that there's a curl.so, curl.dylib or curl.dll on the system path; which *may* be true on osx and linux (or trivally fixed), but *isn't* true, typically, on windows. (as opposed to linking using #[link(name="curl", kind="static")], which will link the symbols into the resulting binary in a way that is distribution safe; we can argue the merits and flaws of static linking on and on, but practically speaking the problem is that windows DLL's are typically *not* in the system path; they're distributed in the folder of the .exe binary; and cargo provides no obvious means for achieving that)
oh, that does actually work. Nice. (does seem pretty hacky though)
I believe the goal is to have a [pkg-config](http://en.wikipedia.org/wiki/Pkg-config) syntax extension that will compute the correct way to link against things (including names, etc.). I don't know the details.
As a newcomer to rust as a language, why do you consider shadowing the more beautiful solution in this context?
The makefiles know about the following platforms: $ sed -n 's/^CC_\([^=]*\)=.*/\1/p' mk/platform.mk x86_64-unknown-linux-gnu i686-unknown-linux-gnu arm-apple-ios i386-apple-ios x86_64-apple-darwin i686-apple-darwin arm-linux-androideabi arm-unknown-linux-gnueabihf arm-unknown-linux-gnueabi mipsel-linux mips-unknown-linux-gnu i686-pc-mingw32 i586-mingw32msvc i686-w64-mingw32 x86_64-w64-mingw32 x86_64-unknown-freebsd x86_64-unknown-dragonfly I'm not 100% sure which platforms actually work reliably, but I'd guess it's possibly just `i586-mingw32msvc` and the two `mips`s (that don't work).
Oh, nice! So it's probably not that hard to embed Gecko elsewhere. :)
I don't know about the others, but I did get rust-sdl working on Windows. If you download the mingw library and copy the SDL.lib (or .dll.a) file to the current working directory, compilation seems to go fine. 
Exactly. Let the user (or the team of users) decide whether or not they want to allow shadowing. For programming in the small, it's probably a net win (less need for new names), while for programming in the large the code without shadowing will be easier to understand because one variable will have the same identity throughout a function.
Just a basic question. Are the following two programs identical or is a variable somehow relased when shadowed? let x = foo(); let x=x; let x_ = foo(); let x=x_; 
In the second example, 'x_' is still accessible in your scope. Otherwise they do the same thing. After they've been compiled I would expect their output to be identical apart from some symbol naming.
Why does the DLL search location not contain the directory the executable is in?
Similarly for Vec. Slices can be indexed, Vec's cannot. Is that a deliberate decision, or will Vec's implement Index in the future?
[They can][pp]; although [`Index` being new](http://www.reddit.com/r/rust/comments/2cj692/any_reason_hashmap_doesnt_implement_index/cjfzs91) means it's new for `Vec` as well as `HashMap`, i.e. work-in-progress applies there too. [pp]: http://play.rust-lang.org/?code=fn%20main%28%29%20{%0A%20%20%20%20let%20v%20%3D%20vec![1i%2C%202%2C%203]%3B%0A%20%20%20%20%0A%20%20%20%20println!%28%22{}%22%2C%20v[0]%29%3B%0A}
Cool! It would be useful for those times you have to do Option arithmetic.. fn size_hint(&amp;self) -&gt; (uint, Option&lt;uint&gt;) { let (a, ah) = self.a.size_hint(); let (b, bh) = self.b.size_hint(); let (bo, boh) = self.b_orig.size_hint(); // Compute a * bo + b for both lower and upper bound let low = a.checked_mul(&amp;bo) .and_then(|x| x.checked_add(&amp;b)) .unwrap_or(::std::uint::MAX); let high = ah.and_then(|x| boh.and_then(|y| x.checked_mul(&amp;y))) .and_then(|x| bh.and_then(|y| x.checked_add(&amp;y))); (low, high) }
Untested: fn size_hint(&amp;self) -&gt; (uint, Option&lt;uint&gt;) { use mdo::option::bind; let (a, ah) = self.a.size_hint(); let (b, bh) = self.b.size_hint(); let (bo, boh) = self.b_orig.size_hint(); // Compute a * bo + b for both lower and upper bound let low = mdo! { x &lt;- a.checked_mul(&amp;bo); ret x.checked_add(&amp;b) }.unwrap_or(::std::uint::MAX); let high = mdo! { ah &lt;- ah; boh &lt;- boh; bh &lt;- bh; x &lt;- ah.checked_mul(&amp;boh); ret x.checked_add(&amp;bh) }; (low, high) } EDIT: updated to last syntax.
FWIW, when I [implemented a macro](https://mail.mozilla.org/pipermail/rust-dev/2013-May/004182.html) like this a while ago, I used `bind &lt;pattern&gt; = ...` and `let &lt;pattern&gt; = ...` for monadic and pure name bindings respectively, this allowed one to avoid the prefix symbols: let l = mdo! { bind z = range(1i, 11); bind x = range(1, z); bind y = range(x, z); let test = x * x + y * y == z * z; bind _ = guard(test); let res = (x, y, z); ret(res) }; But writing a pile of `bind`s is a little annoying and not particularly clear, maybe it could be something like bind $(&lt;pat&gt; = &lt;expr&gt;),*; e.g. bind z = range(1i, 11), x = range(1, z), y = range(x, z); ^/bikeshed
I'm up to any idea about the syntax, I'm not fond of the one I use, but it works. So, do not hesitate to propose and give your idea! And don't forget that the grammar is quite limited.
(I just did propose and give my idea. :) )
&gt; ...reminded me of several cases where bugs were introduced into my Rust programs when I accidentally put "let" in front of an assignment. I'm curious to see some examples of these bugs. You *are* talking about bugs causing weird/unexpected behaviour at runtime, right?
Same here. This isn't exactly just a rust problem either, many languages suffer from this sort of aliment. Some of the node standard library, for example, just straight up won't work on windows still. Still, it would be nice if it were fixed.
How so?
Cool. Idiom brackets (as implemented in Idris for example) would also be very useful when using lots of options etc.
Nice, but inotify based, so: &gt; Oh and it only works on Linux. Sorry, Mac and Windows folk! 
Wow. Now we just need https://github.com/rust-lang/rust/issues/15802 to be fixed in order to use `TlsClient` as a mock for `TcpStream`.
Is it immune to timing attacks?
Great work, it's exiting to see a TLS implementation written in Rust. It's somewhat hard to grasp at first, due to the huge amount of macros used, but the overall design seems sound. I wonder if it would be possible to replace some of the macro usage with generics. It seems to me this should be able to benefit from [rust-crypto](https://github.com/DaGenix/rust-crypto), and possibly vice versa.
.rust/ works perfectly well too, that's why I do in the curl-rs I linked to above. The issue is that tests don't run, and when you build a binary that depends on a library that uses DLL the final binary in target/ won't have the required DLLs next to it in target/, and won't run. I don't see how DEPS_DIR will solve either of these?
What do you mean? The DLL search location does include the directory the executable is in. The problem is that the DLLs are not put there by any build process, and particularly if the DLL is built in a dependency there's no obvious way to generate a list of DLLs to hunt down manually. The result is a binary (.exe) that expects a number of .dll files in the same folder as it, but those .dlls don't exist. So it compiles with no errors... and then binary doesn't run. Code example compiled with no errors and didn't run is about the worst experience you can have as a developer (in my opinion). (The whole point of my post is that basically, this is the experience first time windows users will have, which isn't good)
what is this
ASCII 😍
You barbarian ♥‿♥
Hi all! This is the initial release of stomp-rs. It includes most of the 1.2 spec with the exception of heartbeat, which is a work in progress. It has been tested on ActiveMQ 5.9.1 and RabbitMQ 3.3.4. Feedback is very welcome! Thanks!
I was discussing this with ChrisMorgan on IRC, and there seems to be a big issue with this: `MockResponse&lt;R&gt;` doesn't automatically implement the same traits as `R`. There are solutions for this, but they would all probably make everything more difficult to use.
You call that elegance. I call it a footgun.
...what do you mean? Actually, hmm, the way I implemented the timelock means (I think) there can be concurrent compiles happening if they take more than two seconds; that's not intended. I'll fix that up tomorrow.
How would a dependency handle this? Say I write foo, which depends on curl-rs, that creates curl4.dll When cargo build foo.exe, which depends on curl-rs, it fetches curl-rs from github; it then builds curl-rs; but how does (or can?) the curl-rs makefile know what DEPS_DIR to publish the DLL to? Thats exactly the problem, in a nutshell. Practically speaking I think cargo needs to have a way of tracking build artifacts that dependencies build that must be published when a binary depends on that crate. eg. build = "make" build_artifacts = ["build/curl4.dll"]
I would be hesitant to use the NIST recommended elliptic curves since they may contain unknown mathematical vulnerabilities. This numberphile video explains it better than I ever could. https://www.youtube.com/watch?v=ulg_AHBOIQU&amp;list=UUoxcjq-8xIDTYp3uz647V5A
Still wont fix the issue that when running 'cargo test' after rustc ( and therefore after the build step) but *before* executing the test those build artifacts need to be copied into the test folder... but I see what you mean. You could plausibly require the dependency build step to be aware of the env vars and publish to the correct folder.
I meant opt in by default, you are absolutely right!
FWIW, what is described in the video concerning Dual_EC_DRBG is a completely different problem from "insecure curves". The backdoor in Dual_EC_DRBG is knowing $n$ for $Q = nP$. This is independent of the curve itself. What people are afraid of with respect to "insecure curves" is that the NSA might know a property of the curve that makes certain operations easy for them. E.g. efficiently computing an $n$ as above for arbitrary points $P$ and $Q$.
Clearly you know more about this than I do so please correct me if I am wrong. The impression I got from the video is that curves recommended by NIST should not be trusted. Since the curve used in this implementation is recommended by NIST (http://www.nsa.gov/ia/_files/nist-routines.pdf) then shouldn't it be under suspicion too? Wouldn't it be safer to just use another curve that is not recommended? Edit: Curve and points. I realize these are separate issues from what you explained in your post.
That impression is certainly correct. There is certainly reason be suspicious about NIST curves. I'm just saying that the exact issue explained in the video is unrelated to that. It would likely be better to use other curves. However, it's unfortunately not "*just* use another curve". AFAIK all curves that are currently registered for use in TLS are considered untrustworthy by some.
You can't really use arbitrary curves in TLS. Curves need to be registered to IANA TLS Parameters EC Named Curve Registry. http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml Unfortunately, all of currently registered curves are considered unsafe according to the following evaluation. http://safecurves.cr.yp.to/ Curve25519, which passes the above evaluation, is currently proposed for addition to the registry. The proposal is from a PolarSSL developer. http://tools.ietf.org/html/draft-josefsson-tls-curve25519
Where does `Deref` stand for this?
That would even be a good fit for the matched-delimiter syntax of macro invocations.
I'm guessing macros don't let you invent new syntax like `ident &lt;- exp`, otherwise we wouldn't be having this discussion?
It seems to me that DBC, plus a fuzzing approach to testing, a la Haskell-land's QuickCheck\*, would be a very pleasant and also pretty effective solution. --- \*: For those who've not used it - it uses the readily available detailed type information (something Rust also excels at) to generate random values within the entire range of legal values for a parameter, and ensures that various conditions you state still hold. With DBC that last part could move into the program, so the fuzzer would just check that each random input wasn't violating anything you'd set out for your functions.
What are idiom brackets?
What about: you can only shadow if the new variable is immutable?
It depends. Is `x` copyable?
구글 번역기 쓰셨나요? 전 유창하지 않지만, 왠지 저 글은 좀 이상하다고 생각해요. 
I see, thank you for explaining.
&gt; I would be hesitant to use the NIST recommended elliptic curves since they may contain unknown mathematical vulnerabilities. You need them nevertheless for interop with MS crypto. They refuse to implement anything else.
I'm always up for a new tutorial to see whether it is to my liking :) But unfortunatly I find this one pretty hard to read just because of the low contrast colors and the very thin monospaced font in between. Just saying. I guess I'm not the only one with limited vision. If anybody else has problems with the colors and uses Firefox, just hit Ctrl+Shift+K, go to the colors-light.css style sheet and tweak the color hex codes to your liking. And a "font-weight: bold;" in style.css for the code parts also helps. 
Alternatively `alt` to bring up top bar, `view`, `page style`, `no style`, makes it (and pretty much any other webpage) readable, at the cost of loosing code formatting.
As macro is LL(0), it must know the branch before parsing rust code. `pat &lt;- expr` is ambiguous with `let pat = expr` and the final `expr`. We need a string to begin with. In my proposal, this is `|` for binding, `+` for `let` and `&gt;` for the final `expr`. I have a version with `bind pat = expr`, `let pat = expr`, `when expr` for `_ &lt;- guard(expr)`, and `ign expr` for `_ &lt;- expr`
Yes, you can. The problem is just the general `&lt;pat&gt; &lt;-` is trickier to handle due to patterns and expressions having different grammars (I imagine it may be possible with some effort, although maybe not with the current parser infrastructure), i.e. if you have mdo! { ... (a, b, c, ... } mdo! { ... TupleStruct(a) ... } you can't tell if that's starting a tuple/tuple-struct pattern or evaluating some expression. However, a macro has lots of control over how it parses things, and it is possible to have arbitrary look-ahead (with a procedural macro).
https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
http://www.reddit.com/r/rust/comments/2cj692/any_reason_hashmap_doesnt_implement_index/cjfztwu
Wow, what happened with Pascal in the last year?
You misunderstand. The timelock thing (as intended) is meant to say "don't compile if it's been less than N seconds since the last time", and it's really just a regulator to avoid spawning or queuing multiple compiles in milliseconds (due to how 1/ editors save files and 2/ inotify sends events). The current behaviour is *a bug*, but "works" if you don't save while it's compiling, N seconds after it's started. Really, the entire lock mechanism is something I put together by flinging approaches at the code and seeing which one stuck. If you have actual ideas on how this could be better, in a way that doesn't devolve into 100% cpu time usage forever, I'd be glad to implement them / see if they stick better :)
New syntax updated, about dbaupp's proposition with keywords when for filtering, and ign to do a monadic operation without binding the result to a pattern.
Have you tested what you just typed? `type MyType&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;T&gt;&gt;&gt;;` works just fine here. Maybe you just forgot the semicolon.
Okay so problem with using newtype: How do you instantiate a new member of that type? I tried: impl&lt;T&gt; OptRcRefCell&lt;T&gt; { fn new(data: T) -&gt; OptRcRefCell&lt;T&gt; { Some(Rc::new(RefCell::new(data))) } } But that doesn't let me implement new method for types defined in another crate. Can't implement a trait for it, because the types exist in a different crate. That makes me thing I should use a wrapper type.
This would allow a repl to be more consistent with regular Rust code. 
That's because the "new" type isn't a new type. It's just an alias for an existing type. And you can't create new methods for types defined in other modules, unless you're implementing a trait defined in the current module. Now you must think: "why do I need it to be a method? Couldn't it be a function instead?"
Yet another syntax: more Haskellish: `pat &lt;- expr` for binding, and `to expr` for the final expr. No change to `let`, `when` and `ign`. I'm not found of `to`, so if you have a better idea? (`do` is a reserved keyword, and `return` seems strange because you use the monadic return a lot in this place...)
I could make a method like fn string_it&lt;T: Show&gt;(src: OptRcRefCell&lt;T&gt;) -&gt; String and then later use println!("{}", string_it(my_var)); but it kind of feels like I'm fighting the type system. It would be nice if I could work with the type system and get a net gain of readability. I'm currently trying to figure out if a unit tuple struct might be a good way to wrap another type.
Whenever the topic of a new cryptographic library comes about, people spend more time discussing and worrying about very sophisticated attack vectors (e.g. timing attacks) than about full-frontal, own-your-machine attacks (e.g. buffer overflows). Not that timing attacks are not a concern, but could we start by making sure that a long string is not going to dump the content of memory?
It doesn't seem to say 'unsafe' anywhere so I'm somewhat confident it won't do that.
I believe the common practice for making a "newtype" rather than type alias is to make a tuple struct, or simply a wrapper struct. Something like "struct Outer(Inner);" This doesn't automatically implement traits defined for Inner on Outer, but it will allow you to implement new traits for Outer. 
Jonathan Reem (one of the Iron authors) was talking about moving away from middleware in favour of mixin traits. You would only have to `use JsonParser` to bring in a JSON parsing trait and an implementation for `Request`. This catches middleware registration errors at compile time like you desire. To take this idea to the extreme, you could remove the idea of middleware entirely and just use mixins and a single route function. Source: https://github.com/iron/urlencoded/pull/24#issuecomment-50431665
Extra (keyboard) typing is a drawback. In my experience with Rust, it's not a major drawback, and the benefits outweigh completely.
I think (hope) that by using rust you get protection from a whole lot of traditional vulnerabilities for free thanks to Rust's memory model. I was actually just thinking yesterday that there should be an effort to implement all the crypto staples in Rust to avoid a lot of the memory-based bugs that plague existing libraries
I'm messing around with unit tuple structs right now and it's very inconvenient. It doesn't implement `Trait1` by default so you can't just say `.ref0()` to get the inner contents. You have to use matches to get at the inner contents, which causes all kinds of borrowing issues. I'm thinking it might be easier to just define a one field struct wrapper.
The canonical way to do a newtype is a tuple struct. You should implement Show on that type from within same crate as the type definition.
That's what I usually do. (I agree that it is annoying) 
That's what we do in nickel.rs. That allows us to have sugar on the request such as `let person = request.json_as::&lt;‌Person&gt;().unwrap();` In this case, we don't even need a trait though as it's a core middleware but the same principle of adding sugar methods to the request works for external middleware via traits as well. 
**Introduction** Last week I was exploring Rust libraries. I realized that the experience was mediocre, since the only main places you could find libraries were [the rust wiki](https://github.com/rust-lang/rust/wiki/Community-libraries) and [rust-ci/projects](http://rust-ci.org/projects/). I wanted a tool that is dedicated to exploring Rust Libraries, so I made Rust Kit. Even though it's feature dry at the moment, I hope to grow the app into something mature. You might now be thinking about Crates, and it's plans to have a central repo. We don't know how many months or years it will be before that happens, and if it even will have search capabilities. The Rust community needs to grow now, while it's young, so I built this tool to help ease developers into using Rust. I believe the more Rust tools there are, the better the Rust community will be. **Tech Notes** This is a Sinatra ruby/angular app, with a rethinkdb as it's NoSQL database. It's currently hosted on a EC2 Micro Instance, with plans to migrate into a docker container so I can easily deploy to anything I want. I also want to eventually rewrite this in Rust, when Rust Web Frameworks mature and stabilize. Where do I get the data? I crawl Github search for Rust Libraries, and I also have a [tags.yml](https://github.com/rgawdzik/rustkit/blob/master/helpers/yml/tags.yml) for tag classifications and extra undetected repos. Do you want to add a tag or add a repo to this list? Submit a PR with your changes to [tags.yml](https://github.com/rgawdzik/rustkit/blob/master/helpers/yml/tags.yml). **Conclusion** It was a pleasure to write this app during the week, and I throughly learnt a lot about quick prototyping and iteration. I will continue to iterate on this project until I see it being stable and feature-rich. Github Repo Link: [rgawdzik/rustkit](https://github.com/rgawdzik/rustkit) 
Yeah, it's not really an issue for static linking (and to be clear, I'm 100% in favour of static linking I think it's really a much better distribution story for all platforms; Go got that one totally right). ...there are already lots of rust libraries out there that don't statically link though, unfortunately. 
Using a struct with a named field is exactly equivalent, and IMO, the better way of writing wrapper types. IMO, tuple structs are only widespread because they historically had some special autodereferencing properties that they now lack. Now, despite being rather annoying to use, we seem to call only tuple structs 'newtypes' even though (as I said) a named field is often a better strategy.
Yes, they are identical (assuming you don't (try to) use `x_` after `let x = x_;`).
I've created a tracking issue for this: https://github.com/passcod/cargo-watch/issues/1 Current options are: port Go's fsnotify, use fswatch, implement my own, bind and use libuv's facility. Please comment.
Well, Rust gets you that unless you implement your own malloc/free based on a large allocated block of memory. Hi, Heartbleed!
Neat project! I've been thinking similarly that it would be great to guide people not just to rust libraries that exist, but rust libraries that are *good*. i.e. use *this* for XML, *that* for DB access, etc. FWIW my list of cool rust stuff is http://brson.github.io/rustlinks.html
That's a really great list, nice work. You are right, guiding people to choose which libraries to use is also important. I need to figure out how to tell developers which libraries are good, such as an anonymous review system, or a Hacker News upvote system. Currently, repo stars somewhat indicate the quality of a repo. Even some sort of recommended tag would be useful as well. 
Unfortunately no, because start_c_using_receiver either takes a concrete type, in which case we get a type error trying to pass the generic one, or it takes a generic type, and we get a type error trying to store the generic parameter in a concrete field.
 &gt; Variable bindings are very flexible, you can do something like: &gt; fn main() { let y; let x = y = 12i; } **In Rust this will not do what the tutorial implies it does.** In Rust the value of the assignment **is the unit type** `()` and **not the assigned value** like in C. Thus if you write say `print!("{} - {}", x, y)` you would get `() - 12` as a result which is not what the tutorial leads us to believe.
As I understand it this is one of those non-obvious edge cases in rust. If you have: let x:Foo&lt;Bar&gt; = Foo::new() or let x = Foo::new::&lt;Bar&gt;() It'll work, but it'll *also* work, if you do this: fn RequiresFooBar(x:Foo&lt;Bar&gt;) -&gt; { .... } let x = Foo::new(); ... y.RequiresFooBar(x); In the example you posted I suspect the end of the example, where: //We must indicate the image's color type and what format to save as. let _ = image::ImageLuma8(imbuf).save(fout, image::PNG); Is coercing the type of imbuf. Personally I find this to be obscure behavior that generates obscure errors (example 1 works, example 2 does not because of code far away), but that's the way it is.
Oh I didn't notice you were sorting by stars! This is awesome.
Very useful, thanks!
&gt; let x = Foo::new::&lt;Bar&gt;() The type parameters are on the type, not the `new` method, so it has to be `Foo::&lt;Bar&gt;::new()`.
The caller of a function that returns MaybeOwned still has to call either `as_slice` or `to_string`, no? It moves the burden from the callee to the caller but doesn't eliminate or lessen it.
I like to implement `Deref` and `DerefMut` for such a tuple struct, so I can use `*` to access inner value, conveniently call methods through auto-deref and don't have to make up a name for a field. It's a little bit unpleasant to implement manually each time, so wrote a macro and now I can write: newtype!{Outer(Inner)} (unfortunately I don't have access to that code right now, and it don't work with generics anyway)
Yup, it's merged and live :)
I figured it probably existed already, but thank you for linking it since I hadn't actually gone looking yet. :)
Ah, that's true. (usually; I've seen a fair bit of this too: impl Foo&lt;()&gt; { fn new&lt;T&gt; -&gt; Foo&lt;T&gt; } 
I often use shadowing to prevent referring to another variable again. This is a habit I picked up from OCaml, where shadowing is allowed and idiomatic. For example, in `trans` I often shadow terminated block variables, since it is a bug to use them again. In this way, shadowing can be a powerful tool to *prevent* bugs.
Another couple of things to note. 1. It's a great way to assign multiple variables at once: `let (a, b, c) = (1, 2, "foobie bletch");` 2. You can destructure tuples in function arguments too: `fn foo(Point { x, y }: Point) { ... }` `[ 1u, 2, 3 ].iter().enumerate().map(|(x, y)| x * y)` This comes up most often when the function is being passed to a generic that expects one argument, but you know in your specific code that you need two things (for example, the `.enumerate()` example). Destructuring a tuple is very convenient then.
It may just be my internet connection, but I can't get any projects to load... :(
EDIT: I fixed the Safari issue below, I hope that was the issue for you. Are you on Safari? There is an active issue just recently tracked for Safari([Issue #6](https://github.com/rgawdzik/rustkit/issues/6)), because of a base64 unicode decoding issue. For now, check it out on Chrome or Firefox. 
If you need to take two borrowed mutable reference to same struct at once, you can do: fn my_func(&amp;mut self) { let &amp;Foo { a: ref mut a, b: ref mut b } = self; *a = 10; *b = 42; }
You can abbreviate it as `let Foo { ref mut a, ref mut b } = *self;`.
Well... that form of `new` is rather unidiomatic.
Does this match by name, or by order? *Edit: It matches by name http://is.gd/xjmlih
You need to add some `cursor: pointer`s in there, or make those labels `&lt;a&gt;`s.
For my information, what's the rationale here? If you're going to have statements as expressions, why not return the assigned value?
I think it has. I was wondering why special handling of self in the new lifetime elision, and not in the first parameter as a more general solution.
Great! But did you consider increasing the width of the content? It looks horribly small and is hard to read on a FullHD Screen: http://i.imgur.com/TMM7mZv.png
"I don't care if it eats someone's laundry" is a bit more than an implementation detail. Also, tests can only test what you think to test, but attackers have plenty of time to think creatively. Code quality is still important: tests are supposed to encourage well written code, not backfill bad code
It's not explicit, but the list is (at least for now) limited to GitHub-hosted libraries.
the laundry thing is a bit of a tounge and cheeck joke from rusts website &gt; * In theory. Rust is a work-in-progress and may do anything it likes up to and including eating your laundry. With your argument, no one is right. Why would he forget to test facets of his public API, while making a point to test his private API? The same exact problems exist, so your comment is fairly moot. &gt;Also, tests can only test what you think to test I agree, but how is OPs problem relevant to this? I agree, but tests for private code does not magically fix this problem. Like I said, I am not against code quality, I am against public tests for private implementation details, use some `assert`s or whatever for them.
There's also https://github.com/kud1ing/awesome-rust with a focus on stability/usefulness.
Cool! But what I find very weird is that my Firefox does not change the mouse cursor icon when I hover over something clickable. It took me a while to figure out that I can actually click the boxes to see more content including a Github-Link.
because C programmers learnt that lesson a long time ago bool valid = true; if (check = valid) { /* always true */ } if (check == valid) { /* this is what you want */ } 
Checking the drawbacks about the default parameters, I thought a syntax that could solve the issue: instead of add(1) for automatic currying, we make it explicit. Something like add(1, \_), and this also allows us to do add(\_, 1) EDIT: Originally used a underscore, but reddit takes it as an style operator. Nevermind, the symbol is the least important. EDIT2: Thanks, the underscore is back.
You can put code in backticks, then underscores will show up unchanged. For example: `add(_, 1)`
Can we guarantee in the first case that the compiler will optimize this? Normally I try not to care too much about such things but doing exactly the same pattern in another language (Scala?) has caused me pain before when it turned out the compiler was indeed constructing a temporary tuple and then unpacking it and destroying it.
While working on a similar tool (Zwobot), I came up with the following approach: https://github.com/hannobraun/zwobot/blob/master/src/runner.rs Zwobot was actually the reason I created inotify-rs. Unfortunately I don't think I'll continue working on it. Even small projects like this can be a lot of work, and as much as it pains me, at some point I had to decide how to spend my limited time.
I like this actually.
I changed the background and fonts a little. Is it better now?
Should be wider now.
It would be nice to have something similar to [unapply in scala](http://docs.scala-lang.org/tutorials/tour/extractor-objects.html), to be able to customize destructuring. I wonder if anything like that has ever been taken into consideration.
I feel it would be beneficial if Rust were to use 'typedef' over 'type', since I've run in to the reserved word and had to name attributes 'typ' or alternatives quite a few times already.
It would have been interesting to see also the memory profile :)
I like smosher's idea: http://discuss.rust-lang.org/t/alternatives-to-nested-angle-brackets/164/13 but keeping the comma: HashMap&lt;Vec&lt;String&gt;, Vec&lt;Rc&lt;Cell&lt;int&gt;&gt;&gt;&gt; // no sugar HashMap&lt;Vec.String, Vec.Rc.Cell.int&gt; // sugar HashMap!(Vec!String, Vec!Rc!Cell!int) // D equivalent Whatever the character(s?), sugar for single template arguments keeps the visual associativity that C++/Java programmers are used to, whilst removing unnecessary nesting of brackets.
Well, Rust itself is probably not bug free yet.
i think as people get "culturally accustomed" to larger displays, higher resolutions, and greater pixel densities, going fullscreen with an app window is going to be less common. i usually have a browser window (or two or three) at 33-50% width. my editors always have two panes side-by-side (oft code + tests, for example) or just two editors. that said, more flexible css to respond to wider view areas would be nice :P 
I considered that, but as the program could easily be run entirely just in registers (without using any stack or heap) it would really just be measuring VM overhead and compiler willingness to inline the whole thing.
What are you on about? I totally acknowledged that approach for dynamic linking works (though Id argue its poorly considered to require that setup) and obviously (since my example does exactly that and so does yours) statically linking works. The point I was making is that dynamically linking for windows hasnt been setup to work correctly on windows for most rust libraries, thats all. Lets not get into a static vs dynamic linking discussion; that'll be pointless. Suffice to say I think static linking is a better strategy; youre welcome to have a different oppinion. 
Exactly. Memory overhead is probably as much as important on an embedded device as CPU.
You should be able to get the same performance as C, but implementing a codec is a lot of work. Making bindings is a lot easier. Generally, Rust feels like it would be very good for DSP work. But I haven't done much, so it is mostly a feeling.
True. I'll do that next time I benchmark ARM in future.
Good suggestion, I will make it an issue.
No D lang?
As far as I'm aware it doesn't have a fully working ARM port.
Ahh. That's unfortunate. I thought they did.. .
I run it in a chroot. Android is technically a Linux, so I can run 'mount' and 'chroot' from a terminal inside Android (after installing them with Busybox). It's simply a matter of mounting the sdcard partition with Arch installed (`mount -t ext4 /dev/mmcblk1p2 /myFolder/ArchLinux`), mounting the Android /dev/ and whatnot into the Arch root, and then `chroot /myFolder/ArchLinux/ /myFolder/ArchLinux/bin/bash`.
Drivers are required for the kernel to access the hardware. The trick is to run the non-android OS in a chroot on top of the existing android kernel. In OP's case it was arch. The process is usually along the lines of "Boot android, open terminal, su, mount arch image, mount /dev et al inside the arch image, chroot into the arch image."
Apparently LDC is nearly there: http://wiki.dlang.org/LDC#ARM
I don’t know about Scala, but in Python a 3-tuple is a Python objects that contains three pointers to other Python objects. This indirection has overhead, which sounds like what you’re worried about. Rust is has no such implicit indirection. A tuple is just things next to each other in memory. For example, `(u64, i64)` is one 128 bit chunk of memory. So in `let (a, b, c) = (1, 2, "foobie bletch");` the tuple only exists at compile-time. At run-time, it’s just three variables that happen to be next to each other on the stack.
I even think it would be ok if defaults and currying were mutually exclusive (the act of adding defaults precludes currying) for some functions, currying is clearly useful, and defaults don't make sense, e.g. binary operators.. most maths functions or would it be ok to just say trailing defaults terminate the ability to curry:- fn foo(a,b,c=10,d=20) foo() === |x,y|foo(x,y,10,20) foo(3) === |x|foo(3,x,10,20) foo(3,4) === foo(3,4,10,20) foo(3,4,5) === foo(3,4,5,20) but if you can figure out a way of doing both intuitively then great. 
The colors are better. Thanks. I would make the text body even darker. But now the font sizes are pretty huge. To be hontest, I'm not sure whether you intended this as a joke or not. But maybe you have much smaller pixels than I do ;)
No it doesn't. If I'm not completely blind, this does not do any ASN.1/X.509 handling at all. Implying it doesn't check certificate validity yet.
I just want to thank the Rust community for bringing up this shadowing issue. I just noticed that it is possible to enable warnings for shadowing in clang for C++, so I enabled it in my C++ project (-Wshadow). And found few more possible bugs. They are now fixed. Looks like Rust is making code less buggy in other languages, too. =) 
/u/logicchains, I like the blog post, but should you be doing IO in the middle of your timing code?
True, so I can't use it. Any other proposition?
All I can say is when I try it, DEPS_DIR is test/native/foo-1234... which doesn't leave a dll sitting next to the binary at run time, although it does have it in the right place at link time (which is why this works for static linking). so... it doesnt work for me? your milage may vary I guess, but on my machine the test binary doesnt run because it cant find the dll at runtime. I dont really have anything more meaningful to say than that. Works for you? great. Im going to stick to static linking, that seems (so far) to be working for me.
haha... I did try, I promise. ...but: https://github.com/rust-lang/cargo/blob/master/src/cargo/ops/cargo_rustc/mod.rs#L160 They're the same value.
Tuples are not GC'd in Rust, so the overhead is minimal either way. (The worst that can happen is equivalent to a register spill.)
I've noticed a *lot* of downvotes in /r/rust this morning. Almost all the new threads had comments at `0`.
The intuitive way is to use keyword arguments. Keyword arguments allow you to specify defaults for the keywords. fn slice(from =&gt; start: uint = 0, to =&gt; end: uint = self.len(), &amp;self) 1. `foo.slice()` gives a slice of the whole length 2. `foo.slice(from =&gt; 1)` gives a slice starting from 1 to the end 3. `foo.slice(to =&gt; 5)` gives a slice from 0 to 5 4. `foo.slice(from =&gt; 1, to =&gt; 5)` gives a slice from 1 to 5 `str::StrSlice::slice()` gives a closure `str::StrSlice::slice(from =&gt; 1)` gives a closure `str::StrSlice::slice(to =&gt; 5)` gives a closure `str::StrSlice::slice(foo, from =&gt; 1)` gives a compiler error `optional arguments cannot follow positional arguments` or something of that sort `str::StrSlice::slice(foo)` is equivalent to 1. `str::StrSlice::slice(from =&gt; 1, foo)` is equivalent to 2. `str::StrSlice::slice(to =&gt; 5, foo)` is equivalent to 3. `str::StrSlice::slice(to =&gt; 5, from =&gt; 1, foo)` is equivalent to 4. 
Web frameworks are written by webdevs. Webdevs aren't the best programmers on this planet. The results shouldn't be surprising.
I'd favor having a curry! macro than implicit currying.
[You beat me to a working stomp library](https://github.com/mattyhall/stompers)! :) Your API looks pretty nice and you have decent examples - nice!
This is excellent, I didn't know about it
It seems to be working for me as of this morning - which is odd because I haven't updated; nor even restarted the editor.
Yeah, as far as I know there's still a number of soundness issues open and of course likely some more not found yet. But I would still expect that the lower-hanging fruits in this case are algorithmic errors and that sort of information leaks and not memory errors.
You should weigh in here: http://discuss.rust-lang.org/t/prioritizing-windows-issues/319
Yeah, I think automatic coercions from String to &amp;str would be pretty helpful. Though I feel like that's been discussed a lot and the closest we'll get for a while is &amp;*. Also, creating Strings in the first place still needs some syntactic help imo. I like the idea of the `FromLiteral` trait, but my impression is that it's not going to be added any time soon, as there are a lot of details still being worked out.
According to these [benchamrks] (http://togototo.wordpress.com/2014/08/05/fibonacci-numbers-on-the-galaxy-s3-arm-benchmarks-of-rust-ocaml-haskell-go-racket-lua-c-and-java/), Rust would get a performance closer to C, which is awesome. 
Fair point. But it's only really super dangerous if the language also implicitly coerces everything to bool (unlike Rust). Direct comparison with a boolean value like you're doing isn't *that* common - most people would write `if (check)` instead of `if (check == true)`.
Totally! I'm just mentioning it because one of the reasons that Rust lags on Windows is that we have a lack of expertise on Windows. Help would be super awesome.
Was inspired by this to play around with Rust's benchmarking (had to see how the rustic fizzbuzz compared against a more naive implementation). https://github.com/cciivv/rust_experimental/blob/master/fizzbuzz_bench.rs the results on my machine: ~/workspace/tut/experimental$ ./fizzbuzz_bench --bench running 8 tests test testee::cfunc ... ignored test testee::original ... ignored test testee::rustic ... ignored test testee::simplified ... ignored test testee::bench_c ... bench: 2123215 ns/iter (+/- 22587) test testee::bench_cfunc ... bench: 2234442 ns/iter (+/- 31028) test testee::bench_cs ... bench: 2054929 ns/iter (+/- 19948) test testee::bench_rustic ... bench: 1920301 ns/iter (+/- 20673) test result: ok. 0 passed; 0 failed; 4 ignored; 4 measured 
What do you mean, exactly? If you don't know how many parameters you are explicitly specifying, you don't know the type of the expression. You could use an enum or boxed function, maybe. But this is an issue if you specify arguments implicitly or explicitly, isn't it? Edit: that is, given a-&gt;b-&gt;c-&gt;d, calling with a yields a b-&gt;c-&gt;d, which is different than calling with a then b. 
Yes, that seems to have fixed the problem. Thanks. :)
&gt; I'll, once again, inadequately use the word "simple" in "it'll be pretty simple to build". I say that for everything, so I'm probably using it wrong. lol. Thanks for the writeup! What a cool project. I want to find the occasion to play with zinc.rs.
the java results confirm my experience with openjdk on the raspberry pi. Terrible performance. The oracle jvm was a great deal faster, but the code (web server in clojure) still drags and takes up way too much cpu. Didn't expect such a difference with haskell but I guess it makes sense. Hopefully there will be some speedups for haskell on arm in the future. 
Great stuff. I'm also interested in using Rust for embedded programming. I'll be following this series with interest!
For anyone else that comes across this thread, I found a great link from one of the recent Rust threads. It doesn't necessarily say too much extra from what this thread does, but sort of ties it all up in one place. http://matej-lach.me/rust-tooling/
Super excited about where clauses, UFCS and associated items. Thanks for giving us a status update!
Good point, although considering it runs for around three seconds, would the time taken to read a single int from argv be even 0.01% of the total runtime? I can't imagine it taking more than a few milliseconds.
&gt; They're also working on improving the register situation. Yes. The current implementation is just a little bit of sugar to save some typing. The "improved" solution is generating safe accessors using a DSL that maps nicely from what you would see in a datasheet or reference manual. These accessors also have doc comments, and handle the bit shifting, clear-on-write flags, and safe read-modify-write. We are also looking at using the Drop semantics for temporaries to do all this in a performant way. For example: // Setting bits for field PINMODE and PINSTATE (just made up) // Instead of reg::PINSEL1.set_value(reg::PINSEL1.value() &amp; !(0x3 &lt;&lt; 14) | (0x5 &lt;&lt; 14)); // Something like reg::PINSEL1.set_PINMODE(Alt1).set_PINSTATE(true); And having the two changes to the same 32bit register committed in one go at the end of the line (when the temporary is dropped).
What about overloading/optional or default parameters/etc?
Not sure how you'd implement this as a macro, given that macros do not have access to semantic information. Maybe you could use the `..` syntax used for structs to mean "and the rest". Put it in a function call, and it rewrites it into a closure which takes the unspecified arguments. fn blah(a: int, b: int, c: int) { println!("blah: {} {} {}", a, b, c); } // Assuming keyword arguments... blah(1, ..)(c: 3, ..)(2) // Outputs: blah 1 2 3
The `prop`/`mut_prop` is definitely a very annoying wart in Rust, IMO. It would be interesting to parametrize a method/function over mutability as well as lifetime, so you could have something like struct Foo { a: int } impl Foo { fn get_a&lt;`a&gt;(&amp;`a self) -&gt; &amp;`a int { &amp;`a self.a } } let foo = Foo { a: 5 }; { let const_a: &amp;int = foo.get_a(); let another_const_a: &amp;int = foo.get_a(); } { let mut_a: &amp;mut int = foo.get_a(); } I don't really like the backtick syntax, but the idea seems nice. Not sure how well it would actually work out, though.
They'd require disambiguation, I suppose. Something like f(a, _: int) to clarify that the free parameter is an int, to take care of the overloading issue. I probably would just call default parameters sugar on top of overloading. This might be okay as long as default parameters are always trailing. That should let us define a new function with one fewer parameter that calls the other one with the last parameter fixed. Then make sure the compiler optimizes it properly into a single function call. Then if we have f(int, int, int) and f(int, int), doing f(x, _) calls the two-argument version. There are probably some issues; I haven't really thought this all the way through. Edit: I might also be out of date on rust development. I've been AFK for a few weeks. 
[Quad opamp](http://electronicdesign.com/analog/whats-all-p-i-d-stuff-anyhow) and a [circuit](http://electronicdesign.com/site-files/electronicdesign.com/files/archive/electronicdesign.com/files/29/6131/figure_01.gif) might do it :)
[Previous discussion](http://discuss.rust-lang.org/t/parameterisation-over-mutability/235).
Aren't you just being intolerant or something? Ever heard of tiling window managers? I usually always work with as much as screen estate at use that i have. I have one workspace dedicated to webbrowsing. I hate dragging around windows. I use a keyboard 99% of the time for everything. I also don't see the sense in building websites that waste 80% or available space for nothing. I'm sorry if i don't use the computer the same way you do. 
&gt; Aren't you just being intolerant or something? Not necessarily a bad start... &gt; Ever heard of tiling window managers? I usually always work with as much as screen estate at use that i have. I have one workspace dedicated to webbrowsing. I hate dragging around windows. I use a keyboard 99% of the time for everything. I also don't see the sense in building websites that waste 80% or available space for nothing. I'm sorry if i don't use the computer the same way you do. _Cough, cough, cough_ argh just choked on my coffee. What were you saying about tolerance?
It'd be interesting to try to get Rust working on an Arduino board, just because the hardware is so ubiquitous - and affordable.
'ret', like return using the same convention as 'ign'?
https://github.com/jensnockert/dueboot
Something like [this][1]? Not sure what you're asking for. [1]: http://play.rust-lang.org/?code=fn%20main()%20%7B%0A%0Aenum%20Token%20%7BEOF%2C%20COMMENT%2C%20Other%2C%7D%0A%0Aimpl%20Token%20%7B%0A%09fn%20string(%26self)%20-%3E%20%26str%20%7B%0A%09%09match%20*self%20%7B%0A%09%09EOF%20%20%20%20%20%3D%3E%20%22EOF%22%2C%0A%09%09COMMENT%20%3D%3E%20%22COMMENT%22%2C%0A%0A%09%09_%20%3D%3E%20format!(%22token(%7B%7D)%22%2C%20*self%20as%20uint).as_slice()%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Aprintln!(%22%7B%7D%22%20%2C%20EOF.string())%3B%0Aprintln!(%22%7B%7D%22%20%2C%20Other.string())%3B%0A%0A%7D
Frankly an Arduino may be slightly simpler, but it's by no means inexpensive. ARM cores are ridiculously cheap ($2/chip for a small 50 MHz Cortex M3) and the flexibility they give you is quite handy.
This is awesome! My brother just built something similar, but using existing libraries for an arduino to drive it. I keep eyeing it as a potential project to port to Rust once I get more familiar with it, so I'm glad to see I'm not the only one. Can't wait to read further writeups since this is a direction I want to move too!
Macbook Pro (15"), iTerm2 (zsh), Emacs (with evil, rust-mode, racer, flymaker). I use sublime for everything else, but for rust related material, flymaker/racer is awesome. I also very heavily use an Arch 64 (via Antergos) dual boot with the exact same setup as in OSX (except I'm using terminator with zsh).
Thanks! Zinc actually puts statistics of the file size for every build: http://zinc.rs/stats/ Edit: Previous number was incorrect. Gonna build it again and post the correct one here, but it's around 3-4KB.
Presumably a `curried!` macro taking the place of `fn`? If that has access to the name, the parameter list, and the function body, it could be done; I did something like this in the admittedly rather different context of clojure: https://github.com/bwo/monads/blob/master/src/monads/util.clj#L8-L43
If you implement `Deref&lt;T&gt;` on `A`, you can use the traits that `T` implements with an object of type `A`. However you can't pass an `A` to functions that require a trait implemented by `T`. Do you think I should open an issue for that?
I have considered a few complicated schemes... and then the one of doing "trait bound autoderef", which you're likely thinking of. I did mention it to /u/nikomatsakis, but I didn't get a response, I don't think. Feel free to open a forum post on it - though I really need to get in the habit of visiting it :D.
I took a brief look over the URL you posted and at first glance, everything described there would be very easy to describe in Rust. Much of the bits are already part of the stdlib. Rust fully supports generics so you can make phantom types which can provide better type safety to values (e.g. Mass&lt;float&gt;(5.0) instead of just 5, so you don't actually supply a Force value into a param which requires Mass) Also Tuples are a first class citizen in Rust. 
/u/RustML: you should serve Source Sans Pro in Italic too as webfont, otherwise browsers automatically produce shitty slanted versions. Replace: &lt;link href='http://fonts.googleapis.com/css?family=Inconsolata|Source+Sans+Pro&amp;subset=latin,latin-ext' rel='stylesheet' type='text/css'&gt; With: &lt;link href='http://fonts.googleapis.com/css?family=Inconsolata|Source+Sans+Pro:400,400italic&amp;subset=latin,latin-ext' rel='stylesheet' type='text/css'&gt; Also, ampersand should be escaped in HTML: replace `&amp;` with `&amp;amp;`. Lastly I don't know why you're shipping Inconsolata if you don't use it. You might as well remove it. Or maybe you want to change the font-family for code blocks. FYI Source Sans Pro has a matching monospace, Source Code Pro.
&gt; But maybe you have much smaller pixels than I do ;) Do you mean screen size? Because actually, bigger letters display better at a given pixel density.
could they make the 'keyword=&gt;value' syntax work with straightforward defaulted-arguments ,closer to python, without needing additional names for the keywords
The UTF-8 handling code AFAICT isn't written in a way that the logic can be reused to simultaneously decode and validate the input. (In particular, there's one validation procedure, and then everything else assumes valid UTF-8.) The easiest way I can think of is to use `run_utf8_validation_iterator` in [libcore/str.rs](http://doc.rust-lang.org/src/core/home/rustbuild/src/rust-buildbot/slave/nightly-linux/build/src/libcore/str.rs.html) (it's not public, but you could copy it); it gives you the position of the first invalid UTF-8 sequence in your &amp;[u8], so you could convert everything before that to a &amp;str. This isn't lazy, though.
That's unfortunate.:( Anyway, thanks for the pointers, I'll look at that code (and probably copy parts of it) and will try to create a lazy version of this thing. If anything worthwhile comes out of it then I promise I'll share it.:)
There are three ways of doing flags: 1. If it's just for a boolean, you can use a newtype. `struct MyFlag(bool);` Granted, the newtype won't have any impls on it, but you can destructure in the function that takes it, e.g. `fn i_take_flag(MyFlag(flag): MyFlag) { println!(flag); }` 2. If you have more than two values, all of which are mutually exclusive, you can use an enum: `enum ProgrammerNames { Foo, Bar, Baz }` 3. If you have values that are not mutually exclusive, you can use the bitflags!() macro. I've not looked into the documentation for that, so I cannot give an example.
Looks good! Few thoughts(on what I assume are unintended): * You can keep adding the same tag unceasingly * When there are no results to display, it says page 1 of 0 and the next button isn't greyed out. (silly special cases :) Keep up the good work!
Many thanks for the feedback! In fact, that is the impression I got so far as well - that it could potentially be used to build such a higher-level platform, although in itself, it is of course more low level than a full blown VM such as Erlang. Interesting.
In short: you need to install it. (there are ways around that, but installing it is the easiest way.) Long version: many programs come in different "parts". They will have some code specific to the program in the actual executable file, and some "generic" code in libraries, which it may share with other programs. When you run the main program (`rustc` in this case), it needs to be able to access the libraries it needs (`libnative....so`, and others). How does it know where to look for those libraries? Well, that's more complicated than I entirely understand, but one place it looks are the "standard" locations on your computer; `/usr/lib/`, for example, on my Arch linux setup. If you don't install the nightly, those libraries won't be in the places the compiler expects them to be, and it will fail. If you install it, those libraries will be where it expects them to be, and all should be well. Also, what OS are you using?
Well, for Arch Linux, I'd highly suggest using the [AUR package](https://aur.archlinux.org/packages/rust-nightly-bin/) for the nightly install, it works well! edit: there is also one for [Cargo](https://aur.archlinux.org/packages/cargo-nightly-bin/), the Rust package manager.
You need to include /usr/local/lib in your LD_LIBRARY_PATH. Just put export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/usr/local/lib in your .bash_profile or .zprofile.
It actually worked! Thank you so much!
Ill note that fix. But i actually fixed by installing nightly version from the AUR, since im using ArchLinux.
What delimits the UTF-8 from the binary data?
I have thought about this before. My current impression is that it might be beneficial that Rust currently tends to prefer message passing style parallelism over shared memory programming. To some extend the `Send` kind should be applicable for sending data across a network. In general I think an MPI equivalent written in Rust could potentially be a lot safer and easier to use due to Rust's type system.
I've just started working on a library of purely functional data structures for Rust. If you want to help out my efforts are here: https://github.com/reem/adamantium 
Great! Glad it worked!
I'm actually working on a few components that are fundamental to distributed systems. Gossip.rs is a building block to highly-available, fault tolerant distributed systems. On the CAP spectrum, it's an AP system. So, gossip.rs is a gossip protocol based on the plumtree paper that has implementations in Cassandra and riak, to give a couple examples. Riak ended up changing some of the details to better suite their needs. The paper did tests with 10k+ nodes, so that each node could never actually be fully aware of the entire cluster. Riak, on the other hand, only have a few hundred on average of nodes per cluster, so each node can be fully connected to all other peers. I'm currently rewriting the gossip protocol after tinkering a few different ways to approach it in Rust. One example is the data encoding that needs to happen for communication between nodes, either built-in broadcasts or user defined. Json and all are not suitable for proper communication. So I built (privately right now) a fressian implementation in Rust. Transit, the successor to fressian has been released recently. So I'll be implementing the transit spec. The other thing I had implemented were tagged values. Such that when we receive some broadcast, we only receive a bunch of bytes that are encoded through the transit layer. So we can't decode it until we know what type it is. Now, with tagged values, we can add a tag to the broadcast. If we don't know the type then we simply pass it on, in the hopes that someone will know eventually and will be able to decode it. Kinda went off on a tangent, but to answer your question, yes, I think Rust is very appropriate for distributed systems but it's still early and there are many things that we'll need to experiment with to see the best way to do things.
The cheapness of an Arduino is mainly in the USB debugging board it comes on, surely? Which is of course a moot point if you have one for ARM chips already, and plenty of components to breadboard with. Or do you mean the bare chips themselves?
Is this using the visual studio compiler windows ABI?
Instead of using the AUR package, you should use strcat's repo: [thestinger] SigLevel = Optional Server = http://pkgbuild.com/~thestinger/repo/$arch Then install `rust-git`. Updates nightly.
Could you explain why it is a trap?
Sorry, but what is the difference? Why is it better?
Vadim has done some heroic work to make this happen, including *writing LLVM's 64-bit SEH implementation*.
It updates automatically, includes the editor configs, doesn't depend on rpath, and is smaller (compressed with deltas, deduplicates duplicated files, ...).
The increased popularity of R might be explained by the data analysis series on Coursera that makes lots of use of Github, i.e. each student has to use it.
If you know the first few *lines* to be UTF-8, you could go splitting on `b'\n'` and then converting to `&amp;str` line by line.
It carries little to no semantic information. More specifically, a function with a Boolean parameter often means you want two functions...
Ill try it then. Thank you a lot!
Sure, but if you're talking about just buying the chip then a chip like the AtMega used on the Arduino (or an MSP430 as another example) is still cheaper. The OP didn't just buy a $2 ARM chip, he bought a dev board which costs [in excess of US$40](http://mbed.org/handbook/Order). More of an Apples-to-Apples comparison for an [Arduino board](https://www.sparkfun.com/products/11021).
it could be done, but then you'd probably need to clean up names of the arguments in the standard library since they would be used as part of the public-facing API this is basically an implementation detail for the methods, not really important for how you call them but then, you need to still specify which parameter is optional and which parameter is mandatory let's say you have a method `split` which does different things depending on whether you give it a `count` you need a way to: 1. specify a parameter as completely optional 2. refer to the parameter when it IS specified `fn split&lt;Sep: CharEq&gt;(sep: Sep, [count: uint]?, &amp;self ) -&gt; CharSplits&lt;'a, Sep&gt;` doesn't do it, how do you check whether we got a `count`? We probably need to overload like: `fn split&lt;Sep: CharEq&gt;(sep: Sep, count: uint, &amp;self ) -&gt; CharSplits&lt;'a, Sep&gt;` `fn split&lt;Sep: CharEq&gt;(sep: Sep, &amp;self ) -&gt; CharSplits&lt;'a, Sep&gt;` so we have overloading, but it will be based on arity or the types (ew, this gets messy if suddenly we have some kind of subtyping tacked on later) with keyword-based overloading we can do something like: `foo(a =&gt; A: a)` and `foo(b =&gt; A: b)` of course, we can do this if the keyword names are also the same as the parameter names, but then it gets a little bit weird - the formal parameter names to the function change the behavior of the function. It would be strange if these were separate funcitons: `foo(a: A)` and `foo(b: A)` but not so strange if they have two different keywords: `foo(deny =&gt; a: A)` and `foo(allow =&gt; b: A)` 
Internally &amp;[u8] is { *T, uint }; transmute it to Slice to access the internals, then create a new slice and do a binary search using the len param and pass/fail based on is_uft8. The caveat is that if your binary data happens to be valid utf8 you wont find the correct boundary, but thats unavoidable no matter what you do. Edit: Oh yes, don't forget a utf code point can be multiple bytes, so you'll have to check a few bytes either side in case your break point is partially through a utf8 symbol. Here's a linear search which is probably slower than the binary seek alternative, but it gives the general idea: use std::str::is_utf8; use std::raw::Slice; use std::mem::transmute; fn main() { let mut x:Vec&lt;u8&gt; = Vec::new(); x.push_all("Hello World Adfadf oi 英字新聞のジャパンタイムズがおくる通訳・翻訳業界総合 dfs dsdsfsdf ffガイド2015年度版が登場！a adf adsf das dasf das fzc xv cvzx cxzv czvx czxv df adf adf".as_b x.push_all([255u8, 255u8, 255u8, 255u8, 0u8]); // Invalid utf8 data println!("Boundary: {}", find_utf_boundary(x.as_slice())); } fn find_utf_boundary(value:&amp;[u8]) -&gt; int { unsafe { let tmp:Slice&lt;u8&gt; = transmute(value); let mut maybe_invalid = 0i; let mut marker = 0i; for i in range(0, tmp.len) { let view:Slice&lt;u8&gt; = Slice { data:tmp.data, len: i }; let view_as_bytes:&amp;[u8] = transmute(view); if !is_utf8(view_as_bytes) { if maybe_invalid == 0 { marker = i as int; maybe_invalid = 1; } else { maybe_invalid += 1; } println!("Found {} consequetive invalid bytes", maybe_invalid); if maybe_invalid == 4 { // see http://stackoverflow.com/questions/4983196/unicode-code-point-limit return marker; } } else { println!("Found valid utf8 data; resetting counter"); maybe_invalid = 0; } } } return -1; }
&gt; 1.specify a parameter as completely optional &gt; 2.refer to the parameter when it IS specified what I've got in my head is simple: the act of supplying a default is what makes the parameter optional. Its leveraging the symbols you already had to create &gt; but then you'd probably need to clean up names of the arguments in the standard library I imagine this would be ok .. you'd have to modify these declarations to add the defaults in the first place &gt; foo(deny =&gt; a: A) and foo(allow =&gt; b: A) &gt; split.... vs split(count..) Making different keywords is more like making completely different functions, not what I'd call overloading.. more like 'mixfix function name' it seems identical to just saying `fn foo_deny(..)` &amp; `fn foo_allow(..)`.. or `fn split(..)` &amp; `fn split_by_count(..)` When I hear 'overloading' I think more of the type-based polymorphism in C++ .. being able to have ` mul(matrix,matrix)` vs `mul(matrix,vector)` etc.. really useful for maths code. Also streams.. &lt;&lt; as a binary operator specialised both for stream type and the object in question. Overloading interacts nicely with templates in C++ - gives a lot of power at the expense of complex error messages.. (which only affects code that doesn't work) I think these are all complimentary features, solving different problems. They could co-exist. The keywords as you suggest (mixfix function names?) solves the problem of readability, interspersing meaning with parameters.. `do_this_with_that(a,b)` vs .. `do_this(a, with_that=&gt;b)`. maybe rust macros already give us a lot in that direction since you can use them to wrap functions in calling sugar.
this is exactly what is done in Smalltalk, the function signature contains the keywords making it into the function name doesn't scale: add_new_control_with_coordinates_and_size_and_title(Point::new(500, 300), Dimension::new(100,100), "Hello World") but keywords are fine: add_new_control( coordinates =&gt; Point::new(500, 300), size =&gt; Dimension::new(100,100), title =&gt; "Hello World");
In the limit, `not(true)`, `xor(true, false)` etc.
What do you mean? Win64 has only one ABI.
From what I remember, we could build on windows for a while using Mingw and not link to visual studio generated dlls. There has been a lot of work in LLVM recently so I was wondering if this was the result of that.
Interesting idea, but the parser can tell where the binary data starts if it is able to parse the utf8 text. It does have a general structure and we dont have to look for the binary data by looking for non utf8 stuff. I guess my description of the problem was not detailed enough.
Nothing, the utf8 text ends and the parser has to be in state that no more text based stuff is expected.
If I do this then I need to define a max length of line to be able to give up the parsing of corrupt messages. With the lazy parsing the parser could tell that message is invalid and there would be no explicit line limit. Obviously I need a limit for the undefined utf8 content inside the utf8 string but thats already there. I also want the parser to check each utf8 character only once (for now this looks possible).
You need to describe the layout of your types to LLVM, it's not the other way around. Structure layout etc is all in the frontend. *Clang* is now interoperable with MSVC++, for the most part. We don't get much of that benefit. Indeed, since we only have C FFI, we're not really exposed to the issues Clang had with C++.
Does this mean we're getting a nice MSI installer?
Why only booleans? There is in principle no such thing as a „boolean trap“. Calling it so, is just hiding the fact that it's a general problem of API design which can already kick in if you are using more than one parameter. Named parameters (which is what fizzydish is basically talking about) or interleaving the function name with the parameters (like in SmallTalk/ObjC) can be a solution.
Yep, or whatever folder you might have unpacked the downloaded tarball into, and add "/lib". For example, I added to my ~/.bashrc: ```` export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:~/opt/rust/lib ````
syntax updated with `ret` instead of `to`. rustdoc is up. Do not hesitate to make comments, report issues or send pull requests, especially for the doc.
Oh, I didn't realize vec had a mut_slice(start -&gt; end) function that created a temporary view. Nice; yeah, that's totally a better way of doing it. You'd also not is_utf8() the whole string; even if you were linear searching you'd move the start position to the last-known-valid-utf8-end every step, so I don't think it'd be O^2 really. (although my example, as you say, is) 
Why not use ZeroMQ / nanomsg and get not only cross-node but and cross-language features? Erlang is much too closed ecosystem IMHO
Ops: Could this be added to the sidebar?
This RFC proposes a reworking of Rust's unsafe features to force the programmer to declare (and think about) safety boundaries when they write unsafe code. The goal is to reduce mistakes when working with unsafe code that could ultimately affect program stability and security. Note: this is not another RFC for a name change!
&gt; The goal is to force the programmer Rust cannot be dominated by fear or else it will turn into Java. There's probably no problem being able to declare functions explicitly as `unsafe` but is it really necessary to do a load of extra typing to define a function as `safe` if it contains `unsafe` code? Isn't there still the risk that a developer just learns to always declare functions safe without stopping and thinking about the interface anyway? What is an example situation where you think somebody might actually "accidentally" call a function containing unsafe code?
&gt; is it really necessary to do a load of extra typing to define a function as safe if it contains unsafe code? I would not call annotating a function with an attribute a "load of extra typing". Regardless, convenience comes second to correctness when writing unsafe code. &gt; Isn't there still the risk that a developer just learns to always declare functions safe without stopping and thinking about the interface anyway? If a developer is really determined to disregard the safety system, yes, but having to choose between declaring a safe interface and declaring the function unsafe forces them to actually stop and consider what is the correct action. It will prevent oversight, but not deliberate evasion. Teaching developers to treat unsafe code carefully remains as important as it is today. &gt; What is an example situation where you think somebody might actually "accidentally" call a function containing unsafe code? This question doesn't really make much sense to me. Calling functions with unsafe code isn't a problem. Writing them is. If you have unsafe code without a safe interface then you can introduce subtle holes in your program's memory safety. It's easy to contrive examples of this. It might be as simple as not bounds-checking an index parameter passed into a function that uses it as a pointer offset.
&gt; It might be as simple as not bounds-checking an index parameter passed into a function that uses it as a pointer offset. So, in your opinion, a "safe" function should always bounds-check the input? Is it my imagination or is this excessive? Unsafe code may be created explicitly for speed. The contract of a function (i.e. in the comments) may specify that the input parameters be well-formed. Thus bounds-checking may not be "necessary" in the sense that the input should be trusted.
Oh, that `initKeyEvent` example there brings up bad memories ...
I really like the idea. In this RFC, the fact that the code you write is potentially unsafe and that you provide a safe interface are both explicit, so the main concerns about the unsafe keyword are solved. 
You'll be able to call it, just not from a safe function, unless you declare (with #[safe_interface]) that you've used it in a safe manner and the calling function still has a safe interface. For example, if you have: unsafe fn foo(i: uint) {} and another function calls it with parameter 1, which is always safe: fn bar(...) { unsafe {foo(1);} } then you can annotate bar() with #[safe_interface] to declare that it can be invoked safely with any input. No bounds checking needed, just the explicit statement that you've considered the situation and deemed it safe!
The obvious alternative is to box the stream and erase its runtime type with `as Box&lt;Stream&gt;`. You should be able to turn every value of type `T` which is a `Stream` into such a box.
No, I did mean pixelsize. If you want text to have the same size (in mm), you would have to choose the number of pixels the text occupies depending on how large a pixel is (how many pixels per inch). If you want the text to occupy the same area on your retina, you would also have to factor in the distance between eyes and display. So, the text height and width in pixels should be proportional to the number of pixels per inch multiplied by the distance between eyes and display. Typical computer screens used to have 90 to 100 pixels per inch whereas a "Retina display" has about 300 pixels per inch nowadays.
AFAIK one of the benefits of using an enum is that it is easy to perform match. pub enum UintOrFloat { Uint(u32), Float(f32), } fn main() { let x = Uint(123); match x { Uint(_) =&gt; { println!("Found uint") } Float(_) =&gt; { println!("Found float") } } } 
Sorry, missed the joke on the laundry list! :) I see what you're saying, I guess it's a difference of perspective; to me, the use of asserts is *part of* test driven development, or more broadly contract-driven. I thought you were implying that no level of in/out or state enforcement should take place in the internal code, or that doing so was wasteful, but it seems that wasn't the case.
I turned [my comment implementation](http://www.reddit.com/r/rust/comments/2957fg/can_i_request_a_c_style_for_loop/cihkh5t) into a proper crate you can easily use with Cargo (with docs and everything!). No more complaining about C-style for loops please. :) (Quick question: should I rename the crate to `boom`?) ([source](https://github.com/huonw/cfor/).)
I just came across [`TraitObject`](http://doc.rust-lang.org/std/raw/struct.TraitObject.html) in the standard library. You might want to use it instead of `FatRef` at least in the Rust portion of your code.
I got rustc to build under msys2 64bit gcc by fixing a missing include (#include "stdint.h") in src/rt/valgrind/valgrind.h. This is pretty great.
Broadly speaking I like this idea; specifically the unsafe flag for structs and requiring unsafe blocks in unsafe functions. However, practically speaking I think #[safe_interface] is pointless; Introduce a #[safe_interface] attribute which permits the exclusion of the unsafe qualifier on functions in exchange for programmer assurance that a function is safe to execute for all inputs. That's what unsafe already is. Or trusted? Whatever happened to calling it trusted anyhow? Anyway; this (the extra attribute) mostly just seems to be bike shedding to me; I don't see how it'll change programmer behaviour or code in any meaningful way.
&gt; Rust cannot be dominated by fear or else it will turn into Java. The idea is to be afraid of the right things. I've always been bewildered by the "safety through verbosity" approach of languages like Java. In this instance I think there's a strong motivation for explicitly distinguishing "these operations are unsafe" from "but taken together, they are safe".
Looks very nice and clean so far. Out of curiosity, why are you starting with a BTree implementation? It is an interesting approach, from what I can tell, using Arcs to point to every subtree, which could allow easy sharing of across tasks, but wouldn't that introduce a considerable amount of overhead? 
Either works.
Case in point: checked exceptions. While it is a safe approach, the burden of extra verbosity sways the developer into unsafe-by-default practices every time they need to extend the program. That's why type inference is a net win: we want the safety of static typing without necessarily declaring the type of each variable.
A safe function should be safe for every input. One problem is that the Rust type system isn't powerful enough to disallow many common kinds of invalid input at compile time (for example: there is no type of "integers ranging from 0 to the size of this array - 1", unlike some other languages [\*]). Ideally you should be able to disallow many errors at compile time, but if you can't do so for a particular error then you must either check it at runtime or mark the function as unsafe. No exceptions. [\*]: in response to [this email](https://mail.mozilla.org/pipermail/rust-dev/2012-May/001860.html) it was said: &gt; &gt; For the moment, we are trying to avoid introducing arbitrary arithmetic into the type system. It's possible typestate could be used here in some limited cases. &gt; &gt; And I suspect LLVM can hoist out a bunch of bounds checks if we provide it with type-based alias analysis. That is/would be cool.
But that can be avoided, right? Something like ($init: stmt; $cond: expr; $step: expr $body: block) =&gt; { $init; if ($cond) { $body while { $step; $cond } $body } } (Totally untested.)
So, parse until an invalid sequence is encountered, and stop there? What's the format you're parsing?
Unfortunately, that is intended for the same '100MHz-class' ARM Cortex-M cores. It doesn't support the regular AVR Arduinos (but if there was a backend for LLVM, we could probably get it up and running in a few hours)
Why would you duplicate the body? That's ridiculously inefficient.
I wish we could implicitly call match on an algebraic type within a function declaration, like in Haskell, where you write multiple function declarations for each pattern match. This could just translate to a single function with a match inside it and an possibly exhaustive list of matches, could it not? Edit: Wouldn't this very nearly get us "overloaded" function calls, but based on a single algebraic type?
My attempt to fix this, note that it's almost certainly still slower, but now only by a constant instead of linear with the size of the for loop. // Above the macro_rules #[deriving(PartialEq)] enum ForState { Start, Break, Continue, End, } // In the macro_rules ($init: stmt; $cond: expr; $step: expr $body: block) =&gt; { { let mut _state = Start; $init; while { if _state == Break { _state = Continue; false } else { _state == Start &amp;&amp; $cond } } { _state = Break; $body _state = End; } if _state != Break { while { $step; $cond } { $body } } } };
A fairer version of the qestion would be: is Windows viable for rust programming?
Lets keep this serious?
Why are elements boxed before being added to vectors? And why store empty vectors as none? 
Is Rust-Windows more unstable than Rust-linux?
It receives less support in general, because most contributors work in some *nix environment. But it should be mostly equivalent.
What do you expect to fail?
There still isn't a 64 bits build (though it will arrive soon), there are some issues with the WinAPI (though there are some [workarounds](http://www.reddit.com/r/rust/comments/2cdk3c/winapi_with_rust_results_in_ugly_windows/)), among some other minor issues. It would be great that more Windows users would start to use and report bugs in the Windows version, though. :)
Are there any plans to maintain the windows version of rust in the long term?
Absolutely. From what has been said on /r/rust before, Windows is a first-class target platform. Rust just doesn't have as much interest from Windows people currently.
That would be a legitimate question if Windows actually had some technical reason to make Rust unsafe or not worth the effort with lifetimes or something. That is not the case.
Почему рано? Здесь 5К+ пользователей, по-моему, не мало. В рунете тоже есть люди, которые интересуются данным языком.
Yes, and if I recall correctly an empty vector does not allocate. 
Может пора изучить английский? Зачем нужны гетто?
Supposedly, Windows and Linux will be equally supported when 1.0 comes out, it's just less supported in &lt;1.0 era.
Для продвижения его в российские компании. Почему бы и нет?
Most Firefox users runs on Windows and Rust is a [Mozilla research](https://www.mozilla.org/en-US/research/projects/) project used to write Servo, a browser engine. I think it's in Mozilla best interest to support Rust on Windows.
&gt;Для продвижения его в российские компании. Если российской компании обязательно нужны русскоязычные сообщества для адаптации той или иной технологии, то зачем нужны такие компании? &gt;Почему бы и нет? Например чтобы не способствовать культурному огораживанию страны. Я особо и не возражаю, конечно, но особого смысла в этом не вижу, разве что того самого, из-за которoго гетто в городах растут по естественным причинам: "Чтоб со своими, а не с чужими". Англоязычные сообщества в любом случае будут более насыщенными и информативными, просто потому что глобальные, и технология в основном американская.
If there are easy things I can test for you guys I'd be interested to help out. I'm new to Rust and also not yet exposed to compiler internal stuff (only theory stuff in college), but maybe some low-hanging fruit: verifying bugs, testing cornercases for you etc.
Windows is absolutely considered a first-class platform. Every PR is tested against windows, and we release nightlies and such. That doesn't mean Windows support is perfect, but it's intended to be good, and we want it to be the best it can be. As mentioned above, it's just that usage is smaller right now, and we have less expertise overall. That's slowly changing!
I don't agree with the trailing defaults because of their interaction with currying ;) To me, currying seems to be the way that Haskell/ML don't really do "dependency injection" - because you can pass partially-applied functions around and pass in dependencies later. If you have structs that you initialize and pass around into other functions a lot, you get Windows APIs. http://mollyrocket.com/casey/stream_0029.html this is what passing around structs tends to degrade to
[Fixed](https://github.com/huonw/cfor/commit/50a687daf9b01405a8f26d87475e32ebe939a5a1).
It's possible to do with [a nested run-once loop](https://github.com/huonw/cfor/commit/50a687daf9b01405a8f26d87475e32ebe939a5a1) that is effectively turning `continue` and `break` into `goto`s, this allows `body` to be written once and is still really easy for the optimiser to handle (but does require being a little careful to propagate the `continue`s and `break`s).
For rust-xmpp I explicitly decided against this to avoid dynamic dispatch. It would be kind of fancy if we could `impl&lt;T: Stream&gt; DerefMut&lt;BufferedStream&lt;T&gt;&gt;` to do this. Unfortunately that doesn't work, because `T` diverges between enum variants.
You may be interested in the [`Result` type](http://doc.rust-lang.org/master/std/result/type.Result.html); specifically `Result&lt;T, Exception&gt;` where `T` is generic and `Exception` describes the failure. You can see this in action with [`IoResult`](http://doc.rust-lang.org/master/std/io/type.IoResult.html) (an alias for `Result&lt;T, IoError&gt;`), with [`IoError`](http://doc.rust-lang.org/master/std/io/struct.IoError.html) containing the "exception" information.
Thanks!
Bingo. As usual, it's useful enough to already exist. This is exactly what I was looking for. Thanks!
The buildbot list I was looking at only showed the ones bors is currently gated on (I think), which doesn't include the bsds. Sorry if I got your hopes up.
Only if someone volunteers to maintain FreeBSD. As it stands now, no one has. There are some helpful members of the FreeBSD community who have given us assistance with issues in the past, but we really need someone in the Rust community to be responsible for it.
You want /r/playrust (but check to see if they allow posting server IPs there. They might have a different subreddit for that.) This is the subreddit for the Rust programming language.
It's not possible to "extend" somethings lifetime to `'static`. Either it is, or it isn't, `'static`, and if it isn't, there is no way to make it so. `'static` means "lives forever", ie "always valid for the entire execution of the program". Your heap-allocated thing is *certainly* not eligible! Without more details of your program, it's hard to help more, but you're going to need to restructure somehow.
&gt; Either it is, or it isn't, `'static`, and if it isn't, there is no way to make it so. See, that's not covered anywhere. If I had known that, I would have refactored around it ages ago, either with explicit lifetimes everywhere or `String`. 
If someone were to fix the testsuite, the BSD bot gating could probably be reenabled; but without someone supporting it reliably, it would be quick to be redisabled if it started to spuriously block pull requests again.
The buildbot doesn't know about gating/not-gating; it's just a dumb build-server. bors has all the knowledge about what's being gated on and what's not and interprets the output of buildbot to determine if a pull request was good (I don't know if the exact list is available publically, but at the moment only BSD is ungated).
&gt; What correctness? It's just a programmer annotation, he can be wrong about a function being secure. The point of the annotation, as the title of the RFC hints at, is to force the programmer to be explicit. Currently people can drop unsafe blocks anywhere and make *no indication at all* as to how it should be treated. This makes it easy for them to make errors, or later maintainers to make errors. There is no automatic correctness, but the goal is for it to catch mistakes and improve documentation. This point is put forward multiple times in the RFC.
&gt; this mostly just seems to be bike shedding to me; I don't see how it'll change programmer behaviour or code in any meaningful way. The point is to make the declaration explicit. Currently when you put an unsafe block in a safe function the rule is "assume the function is still safe" by default. Under the proposed new rules, it becomes "error by default; have the programmer choose explicitly between safe and unsafe".
Hmm, then whats the significance of the visible bots in buildbot page I linked? Edit: just looked on my laptop and its different to what I saw earlier on my phone, now I see a lot more bots. Interesting.
You may want to read about error handling in nickel.rs because we use exactly this mechanism for error passing / handling. http://www.reddit.com/r/rust/comments/2cvuq4/error_handling_in_nickelrs/ 
currying is certainly nice sugar.. part of haskells' elegance. their argument seems to be its' just 'saving typing' because closures can achieve the same result. that's also what they say about default args. their counterargument with argument structs is they can be reused and passed between subroutines. I think rusts' Enum's would have made what they tried to do in the windows API's more elegant. (message passing stuff)
[Docs for TcpStream](http://doc.rust-lang.org/std/io/net/tcp/struct.TcpStream.html) indicate that there is a `.read_to_string` that probably does what you want. In general, when you have a `Vec&lt;u8&gt;` you can turn it into a result containing a string with `String::from_utf8( the_vec )`, so the code would look like this let raw_bytes = socket.read_to_end().unwrap(); let response = String::from_utf8( raw_bytes ).unwrap(); If you want to handle errors instead of just failing, you would match on the results, instead of just calling `.unwrap`.
Yes, but in case of specific errors, at least you already have a strong indication that you should look for the relevant `unsafe` blocks. &gt; If the programmer believes the function exposes a safe interface, then they can proclaim a #[safe_interface]. Your suggestion adds overhead, but doesn't actually guarantee anything, it relies on the programmer. It's faith-based language design: the compiler doesn't check whether a safe interface is exposed, it only checks whether a programmer added a flag. As such, there's no indication correctness will improve given that the original mistakes were likely a result of the same thought process that would lead programmers to add your attribute. If a programmer makes a mistake now by believing a function to behave safely whereas it doesn't, I see no reason why they wouldn't make that same mistake by just adding this flag erroneously. It's not like people want their function itself to expose an `unsafe` interface; it's the accidents you should look out for, but if you're already mistaken about the interface, chances are you're going to be mistaken about the flag too. &gt; There is no automatic correctness, but the goal is for it to catch mistakes and improve documentation. This point is put forward multiple times in the RFC. I'm not convinced it really catches any mistakes whatsoever.
&gt; No non-unsafe function should ever provide an unsafe interface in the first place. Exactly, except the default is to assume that every function with unsafe code in it is actually safe, whether or not a safe interface actually exists! This makes it easy to make mistakes. The whole point of the annotation is to remove "assume it's safe" as the default, and force a choice between "this has a safe interface" and "this has an unsafe interface".
&gt; Yes, but in case of specific errors, at least you already have a strong indication that you should look for the relevant unsafe blocks. It's far better to have less errors in exchange for writing a few more characters in your unsafe code. The downside is essentially nil. And what's more, the worst mistakes are the ones you *don't* notice. &gt; there's no indication correctness will improve given that the original mistakes were likely a result of the same thought process that would lead programmers to add your attribute. The main point is to remove "assume a function with unsafe code is actually safe" as the *implicit*, *assumed-by-the-compiler* default. You have to be misinformed to inappropriately tag every function with #[safe_interface], but *anybody* (no matter their experience) can forget to consider the interface when the default is to just permit `unsafe {}` anywhere.
I disagree that this removes the assumption you mention. It just makes the programmer repeat his or her mistake in creating a shoddy interface. It makes proper and improper unsafe code slower to write, all alike. I'm not in disagreement that unsafe code can have problems, I just disagree with the attempted solution. I really can't put it any better than some of the commenters on the RFC have already put it, e.g. ballard26 and rpjohnst.
If I had the time to write an error handling guide, you would have already known... sigh.
I respect your disagreement. Thanks for the input.
This is really useful. :) Are macros stable enough these days for us to be happy to depend on macros from external crates? (I know it works, I just thought it was still one of the 'still subject to significant change' topics)
The toolchain is still somewhat cumbersome to work with (specifically mingw) but broadly speaking my experience working with rust on windows has been pretty good. Go for it I say~ Watch out of existing rust libraries that are bindings of C libraries (ie. stick to pure rust) would be my only caveat. Most c bindings don't really work on windows at the moment (not because they can't but because the authors haven't bothered to support windows; although I'm sure they'd welcome pull requests to fix things).
I like how a majority of your introduction is to convince people to not use your library.
Well, I don't like the library, but I dislike the C-style-for-loops arguments on /r/rust and IRC even more. :)
Is the question just how to make a cons cell list? Here you go: enum List&lt;T&gt; { Cons(T, Box&lt;List&lt;T&gt;&gt;), Nill, } Used like this extern crate debug; enum List&lt;T&gt; { Cons(T, Box&lt;List&lt;T&gt;&gt;), Nill, } fn main() { let list1 = Nill; let list2 = Cons( 1i, box list1 ); let list3 = Cons( 2i, box list2 ); println!("{:?}", list3); }
Going with Rust's metallic theme: Thermite
As a Windows user, I welcome requests to build and test stuff. It's hard to discover stuff on my own unless I'm looking for something specific. Win 7 64-bit
And I'm looking forward to seeing other contributions, submissions, RFCs by you. I'd be lying if I said I didn't have to give this suggestion some serious thought in trying to determine the effect it would have.
https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AA-windows Knock yourself out ;)
&gt; Every PR is tested against windows, Note that not all tests are run for Windows: http://huonw.github.io/isrustfastyet/buildbot/
One of those is mine, actually. The `--static-libgcc` issue. Apparently the shared lib is necessary for proper exception handling.
Custom error handling function will go big if we need to handle multiple codes. It will be good if we have facility to add custom fn to required error codes. Something like, server.handle_error(404, IntoErrorHandler::from_fn(custom_404));
I've assumed this list shows the correct bots: http://huonw.github.io/isrustfastyet/buildbot/
Этой цели, мне кажется, лучше послужат живые доклады в духе https://tech.yandex.ru/events/cpp-party/june-minsk/talks/1978/ или посты на хабре про реальный опыт других российских компаний, использующих Rust. А русскоязычная гугл-группа, ну не знаю.
Yes. In fact, Windows' multithreaded I/O via IOCP is in some ways a better fit for Rust's task model than Unix's.
I'd let thermite be the name of something more useful tbh. Since this is a utility macro, just call it what it is. If you want to be punny, call it 'c4'.
There's another quirk from C that Rust didn't inherit (rightfully so): integer overflow is undefined. It seems there's a precedent that whenever some low level math can be done in a cleaner way, Rust is allowed to do it.
Indeed. For integers, there is already checked_div(), but it doesn't check for division by zero: http://doc.rust-lang.org/std/num/trait.CheckedDiv.html For floats, division by zero should return Inf/NaN. 
&gt; What's wrong with the tests? [Segfaults](http://buildbot.rust-lang.org/builders/auto-bsd-64-opt/builds/734/steps/test/logs/stdio). I don't know if it was ever diagnosed properly (which would be part of the reason why it wasn't fixed); researching/debugging that would be the first task of someone fixing the test suite. &gt; Also, where does the recent Dragonfly BSD port fit into this? Is it also unmaintained? It's not officially maintained, and tests are not run on it. It remains to be seen if it will be maintained by the community long term.
[Yes it does][pp]. [pp]: http://play.rust-lang.org/?run=1&amp;code=use%20std%3A%3Anum%3A%3ACheckedDiv%3B%0A%0Afn%20main%28%29%20{%0A%20%20%20%20println!%28%22{}%22%2C%202i.checked_div%28%260%29%29%3B%0A}
FWIW, integer overflow being undefined can be regarded as somewhat cleaner: the compiler is allowed to assume the signed numbers act like the full ring of integers and thus can optimise using the properties of that set (e.g. if `a &gt; 0` then `x + a &gt; x`).
That's just a subset; [the graph of everything](http://huonw.github.io/isrustfastyet/buildbot/all.html) is too noisy (that shows all the bots that have passed recently, which, ATM, happens to exactly the bots that are being gated on).
Might be ignorant of me, but what would be the implications of abs() returning an unsigned integer? There is the common expectation that abs() returns non-negative numbers.
It's ugly, but it seems like it should almost return a Result&lt;&gt;.
Well, this optimization is, how can I say, `unsafe` and should only be made when the compiler can prove that overflow/underflow doesn't happen. (That is: Rust can still do it if the compiler is clever enough) What optimizing C compilers actually do is to shift the burden of proving there is no overflow to the programmer, because they are too dumb to do it themselves. To make matters worse, you can't actually prove theorems in C so you need to use an external method (or more likely: some informal reasoning. Or: just be extra careful, hopefully testing will find the bugs that slip)
I wasn't disagreeing, just pointing out that properties like "`a &gt; 0` implies `x + a &gt; x`" are actually cleaner/more intuitive (even though violations are `unsafe`).
Then the docs are incomplete..
I think overflowing in abs is as intuitive as overflow anywhere. Sure it would be nice to have full suite of checked math funcs, but the default behavior should be consistent. 
The error handling chains too. If you return `Ok(Continue)` it calls the next error handler. The trick is handling when the 404 error causes a 500 error.
I think it would require something like multi-parameter traits to convert an arbitrary type A to an arbitrary type B, and then implement it for pairs of signed integer to unsigned integer types. (well that's how it's done [in Haskell](http://hackage.haskell.org/package/convertible-1.0.11.1))
Yes; that's all part of the excitement of using Rust. :P (In general if a behaviour seems very reasonable but isn't documented, like "`CheckedDiv`" checking for division by zero; it probably happens but was accidentally omitted from the docs... pull requests accepted.)
PR that fixes this: https://github.com/rust-lang/rust/pull/16323
I think it would require having associated types.
Why not make the return type of abs(i8) be u8? fn abs(n: i8) -&gt; u8 That seems preferable to returning an option or failing.
Regarding that Russia soon will be cut off from the international internet it's probably a good idea to start a russian user group now.
[See above](http://www.reddit.com/r/rust/comments/2cykyz/abs_for_minimum_int_values/cjkcz36).
I'm inclined to wonder if it's sane in the first place to have asymmetric (around zero) data types, but changing that to symmetric might make Rust extremely eccentric and have many unforeseen effects. Always returning a u64 could have problems as I'm guessing in the future uints could end up as 128-bit on certain platforms, and is therefore quite myopic. Assuming defaults should be sensible, I'm a mild proponent of having abs() return an Option, but doesn't ever fail. Honestly, all solutions seem to be pretty shit. Then again, I do feel that it should be in line with the other functions, so if / doesn't check for division by zero, maybe abs() shouldn't check for overflow? Ugh.
The only downside I see is that boxing a stream like this requires moving it into the heap. As for dispatching: I'm not convinced that following a vtable pointer is worse than branching on an enum's discriminant. Anyhow, I'm not saying prefer one over the other. Just pointing out what I think the OP wants to read.
Sure. And if there are many variants, I guess this will be significantly faster than testing every possibility using a `down_cast` function that may return None. Maybe there is a way of matching runtime type IDs. I don't know. But this is probably not as safe because you would need to add an additional "_" case to make it exhaustive.
My assumption is that it is not following the pointer as such, but the potential cache miss that entails. Admittedly I was not completely sure about the timings either, so I wrote a small benchmark. I'm doing 1 byte reads from a 2GiB file, xoring them to make sure the result is used. The best result I have using dynamic dispatch is about 15% slower than the worst result I have for enum match + static dispatch. I wonder why you think moving a few bytes to the heap might be a downside? BTW, I'm not saying which one to prefer either. Using trait objects for this is perfectly fine, but I'm rather convinced it entails a small performance loss.
Oh-ho! Genius!
Good points! I wasn't really thinking straight w.r.t. boxing only happening once and not regularly like reads and writes.
looking at the source, abs for ints boils down to `if *self &lt; 0 { -*self } else { *self }`. I think that is very reasonable implementation, and if more safety is wanted then the overflow check imho should be placed into the unary `-` operator instead.
&gt; pull requests accepted Very much yes. API docs are on my plate, but won't happen for a while yet.
I particularly liked the last sentence: &gt; On the other hand, even if an updated implementation was available, in 2014 I would perhaps not use Deputy for a new safe low-level project, but would give Rust a try instead, since it has a good story not only for out-of-bounds pointers but also use-after-free errors.
russtia?
Thank you!
If you want to implement `Buffer` for your `enum` then the only things you have to do is to implement the first two ("required") functions. The rest including `lines` is provided automatically ("provided functions").
[Good news!](http://www.reddit.com/r/rust/comments/2ctpbk/add_support_for_64bit_windows_builds/)
That is actually a very good point. Maybe a compiler flag should be in place, to enable/disable bounds checking for basic arithmetic functions?
Ahh. Ok, that's great. Thanks!
Either, more than likely. On Hackage you can notice a lot of *foo-fd* (for ‘functional dependency’, implying multi-param typeclasses) and *foo-tf* (for ‘type families’, typically in the form of associated types) packages which typically provide the same functionality, although in different forms. Or one being an alternative to package *foo*. That’s not to say that those two things are exactly as powerful though.
I really like articles like this! Blog posts/docs/scrawlings on a wall that step through a real-world problem really help to bring people from a beginner level to an intermediate one. I'll save reading this properly for my ten hour car journey tomorrow! 
If you need something available in your 'whole program' then your whole program gets a hard dependency on it. Whenever it changes, you can affect code anywhere, and you can't test code without this 'thing' being available too. If something needs access to this config, pass them a reference to it, rather than having them look it up directly.
All modern CPUs implement twos-complement arithmetic, so it would be a huge decrease in efficiency and would be a death blow for a systems language to move away from it.
Yeah, it all gets put into a ProgramSettings struct that gets passed around. I just figured that the strings can be `'static` since I expect the object to live for the whole duration of the program. Refactoring to `'a` wasn't difficult, though.
This is a long-standing and unfortunate limitation, [issue #7590](https://github.com/rust-lang/rust/issues/7590). If I understand correctly, the developers want to fix it but haven't yet committed to a specific plan for how to do it. There's a workaround described in [this old blog post](http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/) (search for "IntRhs" and ignore the `pure` keyword which has been removed from the language since then).
John gave a talk at the San Francsico Rust meetup a few months ago, it was wonderful.
I'm curious what your thoughts are on Error-Handlers-As-Middleware vs. Error-Handlers as their own thing. I recently added error handling to Iron as just another method on the Middleware Trait, but I'm not sure if that's 100% the way to go.
Awesome!
curl-rs, gfx-rs, gl-rs, rust-sdl, rust-sqlite, rust-openssl, ... Its easy to tell; does cargo.toml have a build step? no? The library probably assumes the presence of a system DLL that doesn't exist and wont run on windows. 
It'd have to be something like an `Abs&lt;Result&gt;` trait, similar to the other algebraic traits. Nobody complains that `Mul` requires two types, so, `Abs` accepting one is no big deal. There's a discussion on rust-dev about making `Pow` a trait, so, IMO `Abs` and others should be too.
Messaging is a very specific task. Which protocol to use (tcp/udp/dbus/etc)? Which port? Authentication? pub/sub or p2p? There are too many variables. Better to use a suitable existing library. And do not come up with a new standard.
Use `mod` for declaring the module heirarchy you want, and then `use` for bring names into scope in other places. As it stands you have a module hierarchy like mod rcqueue { mod entry { mod optrcrefcell; // A } mod optrcrefcell; // B } where `A` and `B` are actually entirely different modules (i.e. `rcqueue::entry::optrcrefcell::OptRcRefCell` and `rcqueue::optrcrefcell::OptRcRefCell` are different types). It seems you might be wanting a structure like mod rcqueue { mod entry; mod optrcrefcell; } In this case, you just have the two `mod`s inside `mod.rs` to load the files into the module tree there, and then use a `use` inside `entry.rs` to bring the `rcqueue::optrcrefcell` name into scope. (In fact, I think your code should compile fine if you just remove the `#[path = ...] mod ...;` there entirely, since you [already have the right `use`](https://github.com/forticulous/rcqueue/blob/4d6f7f8c4cd30744de13fbde1a1d40b1bc4de6fe/src/rcqueue/entry.rs#L1).)
Indeed it does appear to work when i get rid of the `path` and `mod` in `entry.rs`. So I guess the problem was I was declaring another module level under entry when I didn't have to.
Part 955: Batching DOM updates
Thanks :)
Good! When do you plan the second part? :-) Also I have a technical question: a text node is a node. And it seems from the definition you provide that any node may contain a list of children node. So does it means that a text node may contain a list of child node? Told differently: does it means that a text node may *not* be a leaf in the DOM tree?
`'static` is the zero of the lifetime system when you intersect `'static` with some other value `'a` you get `'a` the intersection of two lifetimes that's `'static` also implies that both of them were `'static` so the only way to get it is to start with it I'm wondering why main is not declared with `'static` arguments, though (a `Vec` of `'static str`s, perhaps?)
Doesn't mean that there shouldn't be an Abs trait. Whether it uses the same type or converts to unsigned can still be debated.
How would this system handle middleware that must be applied in a specific order?
I see! I must have been thinking of the work in LLVM relating to C++.
I've ran into this problem a month ago. The current implementation of the json parser tries to match the struct to the json data and has no checks for missing fields (in the json data) so an empty value gets passed for the non-matching token; which then tries to get unwraped in your code. I was looking to find time to hack on this (as well as optional json fields) but vacation and my master's thesis is getting in the way.
Thanks! I hope to have the next part ready on Monday. A text node implements the DOM Node interface which includes the childNodes attribute, but its list of children is always empty.
&gt; (a Vec of 'static strs, perhaps?) It would have to be `&amp;'static [u8]`, since command line arguments are not guaranteed to be valid UTF-8.
`std::os::args` gives a `Vec&lt;String&gt;` right now, what happens when you give it an invalid UTF-8 input?
Well, the general idea is that middleware that provide information rather than modify the request or response or change control flow, (e.g. compression middleware or a router) are not order dependent, or can be resolved lazily as they are needed. Middleware that do make those changes *must* be order dependent, but they are also much harder to submit in the incorrect order because that represents a true semantic error, which is much harder to catch on the type level. I'd be thrilled to hear about a scheme that is both practical and stops that form of error, but I haven't seen one so far.
It requires GADTs and abstract types, and Rust has neither.
This seems like it's going to be a good example of how to implement what would often be an abstract interface in C++/C#/Java. I haven't quite worked that out in Rust, I guess that pattern matching is used on the node type? I'm interested in seeing more!
It fails, but we provide [`args_as_bytes`](http://doc.rust-lang.org/master/std/os/fn.args_as_bytes.html) for bullet-proof programs. The problem with passing `&amp;str` to `main` is it requires unconditional UTF-8 validation, i.e. every Rust program ever would fail for non-UTF-8 command line arguments and there would be no way to avoid it.
Well technically it is, but not as you'd expect. During your pattern matching of the option&lt;T&gt;, the result&lt;r,e&gt; is (or should be) passed (as an option containing the value, or the error. The problem is the json parser doesn't pass anything with non-matching values and instead passes a 'None' which during the pattern matching tries to get the result value (to match against) and then fails during unwrapping of this non-value internally.
Are GADTs and abstract types any more likely to be added into the language than real higher-kinded polymorphism? If they were easier to add, it could be a shortcut to higher-kinded polymorphism for those that really want it.
&gt; During your pattern matching of the option&lt;T&gt;, Where is this pattern matching?
You said &gt; During **your** pattern matching and there doesn't appear to be any such pattern matching in /u/pzol's code. Are you actually talking about what the decoder does internally?
Some things I know are an issue at the moment: * This is part of a bigger project, so it might be a bit hard to see what the code is trying to do. I'd be happy to give any context needed. * Apologies for size—this is my first program *in Rust*, having used C++ and Ruby for the other bits of the system of which this is part, and I deliberately chose a non-trivial thing to implement so I'd get a good feel of the language. * The clunky attempt at stopping the tasks doesn't really work well at the moment. I'm a bit unsure about how to effect a clean exit when there are so many tasks and some of them are TCP/IP listeners. I'm hoping something like [this pull request](https://github.com/rust-lang/rust/pull/15704) will help if it gets merged in. * Satisfying the borrow checker still feels like dark magic to me, so I know I'm doing a lot of cloning that I don't need to do =p
For an application, you should be checking your `Cargo.lock` into version control.
This is small, but https://github.com/UniversityRadioYork/listmaster/blob/master/Cargo.toml#L4 can be in the "Name &lt;email&gt;" format, like git uses. Also, your git commits use "Matt Windsor &lt;mbw500@york.ac.uk&gt;", rather than the one you've put here, unsure if that's intentional.
https://github.com/UniversityRadioYork/listmaster/blob/master/src/responses.rs#L14 Given that you've already done https://github.com/UniversityRadioYork/listmaster/blob/master/src/responses.rs#L14 , not sure this is needed. and given that you've done https://github.com/UniversityRadioYork/listmaster/blob/master/src/main.rs#L3 , I'm not sure any of the others are.
I don't know why I just noticed this now, but https://github.com/UniversityRadioYork/listmaster/blob/master/src/reaction.rs#L41 Arguments usually have no space before the `:`, so fn send_request(&amp;self, word: &amp;str, arguments: &amp;[&amp;str]);
I only had minor nitpicky stuff to say, apparently. Good work! I like that you wrote docs too :)
I can feel with you, the borrow checker can be a bit nasty sometime, mostly because of [issue 6393](https://github.com/rust-lang/rust/issues/6393).
Meta-nitpick: Before copying/pasting Github URLs, press y to include the commit hash. This way, the links will still point to the correct files/lines of code after the author pushes new commits to the branch.
please make a readme.md :) edit: I'm a moron
There was a README.md, but it was very sparse on information, so I've added a bit more to it. Please let me know if there's anything missing that needs to be on there! =D
OK, I've tried to fix most of the points Steve raised, though the experimental tags and the issue of everything and its grandma being marked `pub` remains. I might look into these later =p WRT the spaces before `:`, that's me not really getting the Rust conventions at the moment. The code was a lot worse a few commits ago, because it used a strange mishmash of C and Haskell style (being that Rust feels like it's halfway in between the two languages, this probably makes some semblance of sense!) I think I tried using an auto-formatter (I forget the name, probably rustfmt?), but I thought the output was visually very unappealing at the time. Thanks for the feedback!
Oh yes since you linked directly to the ```src``` path, I didn't see it it. Sorry! 
If they are aware of each other and don't overlap it could be collision detections slowing things down. Try removing the awareness part and see how it performs to narrow it down. If it's that, you can start looking at strategies like partitioning the space to reduce the number of collision checks per particle by avoiding impossible checks. EDIT the 2d array of bools for occupancy in O(1), is this what you use for collision? Then I misunderstood, sorry.
Out of curiosity, is any if this work public / on GitHub yet? I'd be curious to take a peek at your cluster membership strategy, particularly in contrast with riak_core.
I haven't pushed up the rewrite I've been working on. So the current gossip.rs repo on github is quite old. riak_core definitely has done some interesting stuff in terms of the overall protocol, but I haven't read any of their source code, I've only read and watched talks about their strategies.
If you think to, drop a reply when you do push, I'm curious :-). Full disclaimer - I work for Basho, so I have some love for Riak.
I've also had to solve the issue of stopping tasks blocked on I/O, although in my case it was to gracefully stop a task doing interrupt-driven GPIO, rather than accepting TCP connections. I solved it by defining an IoSelector struct, that acts rather like a channel select! statement but for I/O objects, and then selecting between the I/O object served by the task (TCP acceptor in your case, GPIO pins in mine) and another I/O object used to signal that the task should stop gracefully and release I/O resources. On Linux, I implemented this for the native runtime, using the epoll syscall for the IoSelector and eventfd syscalls for the stop signal. On other platforms, IoSelector could be implemented with select or poll (unix) or WaitForMultipleObjects (win32) , and the stop signal with a pipe (unix) or event object (win32). Code here: http://github.com/npryce/rusty-pi 
You might be facing the limitation of Rust-Graphics API above 10 000 particles, which triangulates all the rectangles one-by-one on the fly. There are ways to work around this, but it becomes more complicated. You could try drawing the particles to a texture with rust-image and update the texture. Alternative is to use a special shader and cmr's hgl-rs with a buffer of the positions of the particles. https://github.com/cmr/hgl-rs https://github.com/pistondevelopers/rust-image Personally I don't think it is a good idea to optimize before you have a working prototype. However, knowing the limits is a good thing. You have 10 000 entities, now you need to come up with an idea for a game!
I haven't historically supported the GPL because I've often disagreed with its attitude towards proprietary software, but working on something like this and then imagining some company rehashing and selling it as their own (as unlikely as that is) definitely changed my mind. There's a time and a place for the GPL. I decided this was it.
Yeah, I know this is true, I just always forget to do it. Thanks.
Don't let anyone bully you about the GPL. You wrote the code, you should decide the license.
I'm not too worried about the time/memory complexity of the hash because the biggest bottleneck is still going to be accessing the disk and decoding the images. But if you think it'd be good to implement, please feel free to open an issue on the repo so I don't forget about it.
I used to be on the other side. Having several proprietary projects in mind, looking for libraries/tooling and only finding GPL'd stuff got pretty frustrating. Chess engines are the worst. There's only a handful out there and they're all GPL'd, except one which actually didn't have a license. But if you make something that you want to stay completely in the open, the GPL helps you keep it that way.
&gt;You might be facing the limitation of Rust-Graphics API above 10 000 particles, which triangulates all the rectangles one-by-one on the fly. There are ways to work around this, but it becomes more complicated. You could try drawing the particles to a texture with rust-image and update the texture. Alternative is to use a special shader and cmr's hgl-rs with a buffer of the positions of the particles. Can it be the iteration over a 10,000 long vector that is the bottleneck? &gt;Personally I don't think it is a good idea to optimize before you have a working prototype. However, knowing the limits is a good thing. You have 10 000 entities, now you need to come up with an idea for a game! Well, for falling sand game I need more than 10,000 entities. :-)
&gt; In order to use Rust for professional game development, we need a safe abstraction over 3D graphics API that lowers the possibility of shooting yourself in the foot. gfx-rs is a project that seeks to solve this problem. Several experienced gamedevs in the Rust community is working at this project. I disagree, to use Rust in professional game development, I want the most amount of control over the graphics context as possible, even at the cost of being able to shoot myself in the foot. I'm not sure this is really the biggest thing holding pack professional game development.
You should totally get a legitimate blog! These posts are great, and I love it when you write another, so you should get a site to post this stuff! Maybe a plain github pages site would work, its free and easy!
 4 spaces before a line of code or surround the code with `back-ticks`
Yeah. Holding back novice game development, maybe. But even then having better control is a good thing. Most professionals end up rolling their own 'niche' solutions in the end anyway.
I'm aware of that, but if I want to use the entire display as my game grid, and displays today are ~2000x1000 and more, what can I do?
It sounds like it might be easier to do what you want than how you're trying to approach this. Maybe some context might help? If you want to match on a `u8` as an 8-tuple like this, you can try writing a conversion function. fn bits_tup(byte: u8) -&gt; (u8, u8, u8, u8, u8, u8, u8, u8) { (byte &gt;&gt; 7 &amp; 1, byte &gt;&gt; 6 &amp; 1, byte &gt;&gt; 5 &amp; 1, byte &gt;&gt; 4 &amp; 1, byte &gt;&gt; 3 &amp; 1, byte &gt;&gt; 2 &amp; 1, byte &gt;&gt; 1 &amp; 1, byte &amp; 1) } By the way, the `0x` prefix means hexadecimal. I think you want `0b` if you're working with binary.
Are you compiling with optimisations? `-O` for direct `rustc` use, `--release` with `cargo build` (output to `target/release`).
When optimised, the two are equivalent.
Well, I think for iron it makes sense to just add an `on_error` method to the `Middleware` trait. It feels more symmetrical to handle it like that given the way that you treat middleware with `on_enter` and `on_exit`. For Nickel it makes more sense to have a different trait with the error as a third parameter to the handler because I want to stick closer to the design of express. I think the way iron handles middleware is quite neat, I just want something simpler for nickel. (Probably because I suck at writing Rust ;-))
I solved this issue but I'm still not 100 % satisfied with the current state. Maybe someone smarter than me want to comment on that: https://github.com/nickel-org/nickel.rs/issues/59#issuecomment-51762578
The best way to find out is to test. I doubt that if you use a clever sorting algorithm like timsort (look in python or java for good implementations, I don't know what Rust uses), the sorting will take much time, as the order won't change too much on each iteration. In general, if you want to optimize for caches, try to reduce write access first. Why? When you read something, you may induce a cache miss, which means that something else will have to be de-cached. But if that something was changed, the de-caching will have to write back to memory (oversimplified), which will synchronize all CPUs on that memory access, invalidate all other caches for this line and cause general mayhem. Otherwise (if it's unchanged), it just overwrites the cache line with new stuff in the safe knowledge that memory still holds what was there.
That's the spirit. Now a sort that will best-case (order hasn't changed) run in O(n) doesn't look so bad, does it - apart from the fact that if you run it after every moved particle, you will waste a lot of time - you'll want something else for that. Maybe you can do without sorting until all particles have moved. Notice the maximum diff between where a particle should be and where it is and search an interval of twice that width. Once you've minimized writes, you can look into compressing your data. Of course, you don't just gzip your vectors. That'd be stupid. But what if you could store your cells' positions *relative* to a) each other or b) some reference point for some given grouping of particles? E.g. with a quadtree, a good chunk of bits of their position is already encoded in the particle's position in the tree.
(Disclaimer: Rust newbie) My understanding is that since Rust isn't using split stacks anymore, there isn't any overhead beyond what a call would normally cost.
It should be no different than the cost of calling Rust from Rust or calling C/C++ from C/C++. In the past calling C/C++ from Rust had some non-negligible costs due to Rust's use of split stack, but it's now gone. By the way, you should use a proper binding for C/C++ libraries if possible. ZeroMQ has two known Rust bindings ([rust-zmq](https://github.com/erickt/rust-zmq) and [zmq.rs](https://github.com/zeromq/zmq.rs)), both seem to be actively maintained. Please do not reinvent the wheel unless you want to make a *better* binding; calling C/C++ from Rust is the last resort and should be well-wrapped with idiomatic interface.
Note that zmq.rs is not a binding but a pure-Rust implementation.
If the intent is to make sure something is completely open then the GPLv3 adds another couple of assurances (the patent and anti-tivoisation clauses). I know Linus is against the GPLv3 for the kernel, which I understand, but I feel it's been unfairly demonised by the open source bloc.
I understand that this is an ownership/memory safety issue, but doesn't "foo".to_string() feel sort of read-ably unintuitive since you have a to_string fn being called on a string?
Professional games are also based on graphics engines, which in turn abstract over platform API. As long as we are not introducing any hard compromises or performance overhead, gfx-rs could be a foundation of a professional graphics engine. Besides, it's not like we are gonna have a monster-scale game (think - GTA) right off the bat. First, the indies need to appear, and for those rapid prototyping and convenience is more important than these 5% (or less?) of performance you can get from the raw graphics API.
I don't think so. I wrote a simple bare-metal program in Rust, and the only thing I saw that would *not* have been in an equivalent C program were some instructions at the start of each function to ensure that there was enough space on the stack for the call. Even that overhead is apparently going to disappear once Rust moves to using guard pages. So... yeah, I don't think there's any Rust-specific overhead if you're binding to another language, in either direction.
This is one of the cases where I feel Rust macros are too limited. It would be lovely if one could write a macro bit_match!(x, (0, _, _, _, _, 1, 1, _)) that expands to ((x &amp; 0b10000110) == 0b00000110) I.e. create two literals, for the first one replace each digit with a `1`, each `_` with a `0`, for the second one replace each digit with itself, each `_` with a `0`.
On the topic of immediate-mode GUIs, we (PistonDevelopers) are currently working on a project called Conrod, a "graph based, immediate mode, user interface with some fancy search capabilities." https://github.com/PistonDevelopers/conrod It's still in VERY early stages and it will probably change a lot, but we have an example with some basic working widgets (button, toggle, slider) and the dev pace is starting to pick up (i'll be working on it pretty much full time for the next couple weeks). We're always on the look out for inspiration, tips and tricks so thanks for the post :) I'd also be super interested to see if there are any other Rust UI efforts going on of any kind! It'd be great to share ideas and collaborate.
wheels were made for reinvention
I don't know if this has been done already, but if not, you could port over the excellent ocaml-bitmatch library to rust (as a macro probably). I'm certain a lot of people would be interested.
a little wasteful but... let bv = bitv::from_bytes([0b110]); match bv.to_bools().as_slice() { [false, _, _, _, _, true, true, _] =&gt; {}, [true, _, _, _, _, _, _, _] =&gt; {}, _ =&gt; {} }
This could probably be done with a syntax extension. Something like: match x { bit_patt![0, _, _, _, _, 1, 1, _] =&gt; { ... } } Could certainly be possible.
I work on yt, and this would be really fun. Ping the yt list?
So if a line is malformed and contains to few elements to create a face or a vertex what would be the preferred way to handle that? Check the length of `line_data` and return `Unused` if the length doesn't match the type?
Good stuff again! Waiting for the next one. Thanks!
Rust programmers may notice that I'm using owned `String` values in places where slices could be more efficient or idiomatic. I could probably use more iterators too. But I was more concerned here with making the post accessible to non-Rusty readers, and doing it this way let me avoid clutter from lifetime parameters. Later parts in the series will use Rust references in all their glory. :)
I always wondered if you could just take a browser overlay as the UI. Probably not the fastest, but you get an awesome GUI toolkit.
The rust lifetime system is a slight twist on a "region" system. Have a look at Cyclone for one of the motivating examples. Edit: thanks steve
Projects exist that do this, e.g, librocket and berkelium. I think librocket is more of a reimplementation and berkelium is actually embedding webkit.
It's actually Cyclone, not Ceylon http://cyclone.thelanguage.org/ I make that mistake all the time too.
I have no idea how I made that mistake... I blame the article about missing java features on proggit... Thanks!
Matching like that won't specifically catch the 0 in the first position like OP wanted.
GPLv2 was one of the licenses GitHub recommended while v3 was lower in the list. I trusted that it was that way for a good reason.
yeah, see [my more complete solution below](http://www.reddit.com/r/rust/comments/2d7rrj/bit_level_pattern_matching/cjnb2zn). It is not as pretty as I'd like, those redundant `x if ...` bits seem bit tricky to eliminate.
Great series! Thanks!
How many people went to the last one hosted at this new location? The one Seattle Rust meetup that I went to had 3 or 4 people living near UW and it was implied that we would try having the meetups there. I'm not sure that I want to bus or bike all the way downtown.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 706 times, representing 2.3761% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cjng9x3)
games use non-bounds checked indices all over the place(e.g. mesh structures), and yet they work. Rust dictates that an index operation must be bounds-checked , to be 'safe'. but this has a runtime cost. If you know your program isn't going to crash (which it won't, if you designed it correctly), you don't accept a runtime cost for failure checks, except in debug builds, which you use to track down your logical mistakes. So: to achieve the same efficiency in Rust that we're used to in C++, big chunks of code will have unsafe internals (anything that uses indexing) To be 'safe', rust over-estimates by default. There's still too much that can't be reasoned about in a type system. Floats are the other hugely common example of something routinely 'unsafe'. reciprocal is strictly a potentially unsafe operation, playing 'by the book'. again, high performance code might rely on whole program assumptions that the values being inverted can't be zero. eg- in a simulation, you can't have it 'fail'. every state the user can see must be processable to produce another valid state. Reality doesn't "fail". If your game 'fails' ,its a bug(by design), you broke the sense of immersion, and it wouldn't be accepted for publishing on curated platforms. Simulations 'fail gracefully', or avoid failing (by design). Debug builds let you make program wide efficient 'micro-unsafe' assumptions (like valid indices and non-NAN floats) whilst still providing you with sane tools to track down your mistakes. And you can see the evidence of this filling the shelves for many years already. 
I think it's probably possible with a recursive `macro_rules!` macro too that consumes the "tuple", pattern matching for literal `1`, `0` and `_`.
Maybe 6-8? The UW connection didn't pan out so far. I'd like it if a UW member could help here. :) edit: I think the thing with UW is that there was concern about having random people wander into a building after-hours during summer with no one around. I personally would love to cycle through different locations available to different people, including UW.
.. and remember games get tested anyway for other reasons e.g. "is this fun", "does it contain anything against platform guidelines", "does this simulation actually work correctly", "does this effect look good". Its useful to have a build you can tweak separate to what gets distributed/consumed. 
Having spent the better part of my career optimizing graphics rendering, I very seriously doubt that a "retained mode" api will give the the ability to optimize my rendering in ways that I need, or otherwise would be able to with the special knowledge of constraints that my particular game allows. I don't think the fundamental question is if the api is "safe" or "unsafe" in a rust style manner, but when I need to use tricky ARB extensions in non-standard ways, in all likelihood the safe api is just going to get in my way. I do however have much bigger reservations about any retained mode api beyond the set of data the hardware already tracks. Extra state-tracking does nothing but cause performance problems.
FSVO "awesome". But, see [Coherent UI](http://coherent-labs.com/). It does exactly this.
Most of your arguments apply well to libraries, which I can agree with from the perspective of a proprietary software developer. However, `img-dup` is a standalone application, not a library. It is not built for linking against, and does not expose a stable API to call programmatically. I might change that last part in the future, at which point I may reconsider my choice of license as well. Or separate the user-facing interface (GUI or CLI) and the image-searching backend, with a GPL on the former and Apache/MIT on the latter. Basically, I don't *want* `img-dup` to be an option to proprietary developers. Organizations can modify it and distribute it internally without restrictions, but they can't take it and distribute it publicly as their own, which is exactly what I want. `img-dup` currently doesn't have a userbase to "steal" and I doubt it ever will. I don't have a problem with that, as I made it entirely for myself. I implemented the perceptual hashes primarily as a learning exercise in Rust and my intention was to share them and invite improvements and constructive criticism. I will continue to improve it myself as I see fit, and I want any derivations to remain in the open for the foreseeable future, which is what the GPL facilitates. It's my code, I will do with it what I will.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 707 times, representing 2.3787% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cjnjh9s)
\#2 would only apply if `img-dup` were a library or meant for reuse. It's not. \#1 will happen regardless of what license I choose. The GPL just gives me the option to pursue legal action if I want. Which I probably won't, because it's fucking expensive, but it'll give most developers pause before copy-pasting willy-nilly. \#3 just depends on me not being an asshole and grepping every related project to see if any thing looks copied. Which I won't do, because it's not worth my time. The second part is just that GPL begets GPL, which isn't my problem. You wanna use my code, it's gotta stay in the open. And it's still my code, and I'm still doing what I want with it. I'm done feeding you, troll.
"Macro" was intended to exclude syntax extensions, though you are probably right that it is the umbrella term. I had thought about pointing out that it would be possible as a syntax extension, but then again pretty much anything is possible as a syntax extension…
I just realised I didn't actually answer your question. Yes, a simple length check would be sufficient for now. In the future though it will be a little more complicated as you can receive data like f -4 -3 -2 -1 or even f 6/4/1 3/5/3 7/6/5 So at the same time as improving the parsing I'll have to add different kinds of validation checks :)
Search for '[regions](http://en.wikipedia.org/wiki/Region-based_memory_management)' and '[linear types](http://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems)'. Those are the type theory terms for 'lifetimes' and 'ownership' respectively. From what I gather from speaking with /u/pcwalton, the two concepts had 'gone out of fashion' in the academic world by the time that Rust was conceived. Regions were not extremely useful in a GC setting, and linear types found little practical use. The novel thing that Rust brings to the table is the realization that by combining the two, you can have safe, deterministic memory management without a GC. You need both in order for the added complexity to be worth it. A formal model of a subset of Rust is being worked on by [Eric Reed](https://github.com/anasazi) at the University of Washington: https://github.com/nikomatsakis/rust-redex/graphs/contributors Also this might be of interest: http://static.rust-lang.org/doc/master/rustc/middle/borrowck/doc/index.html nmatsakis and pcwalton are also good folks to contact on IRC/email, although niko is quite busy these days, so you might have to work abit to catch him. I would love to see more work formalizing Rust, or building on its ideas. There is still much to be explored in this space - Rust itself is just the beginning.
I just tried to implement that and failed in various ways. I also don't think this could generate a literal (as opposed to computing the mask at runtime/depending on the optimizer). I'm willing to offer a virtual cookie for a working implementation of this approach ;).
&gt; #[allow(non_snake_case_functions)] ...
It relies a little on the distinction between the types `str` and `String`.
 int f() { int x = 0; int *@region(`f) y = &amp;x; L:{ int a = 0; y = &amp;a; } return *y; } it literally has the keyword `region`
The code itself is okay but you're going up against a lot of Rust idioms and common practices with the file structure, capitalized file names, etc.
Ah! I am mistaken then! Thanks!
You may find some of the [ATS papers](http://www.ats-lang.org/PAPER/) useful too since that's a low level language designed to deal with pointers,etc safely. In particular [Safe programming with pointers through statefull views](http://www.ats-lang.org/PAPER/SPPSV-padl05.pdf),
I don't think you need to display anything. "all copies of The Software" intention would really be the source code, I guess. For executables putting some files explaining license of the compiled software should be enough. But I might be wrong here, so I'm interested in opinions of other people.
If you want, when you distribute your application, you could just have a credits section in the readme that credits rust and other libraries and their licenses.
I'm confused by the way you wrote your unit tests. You do [this](https://github.com/UniversityRadioYork/listmaster/blob/3a2cb2020476e00b89e7f9bb86a814cf2f46feae/src/models/playlist.rs#L418-L475). It took me close to 2 minutes to figure out that that was actual code meant to be executed, because of the way it's interspersed with test code. See the [Unit Testing Guidelines](http://aturon.github.io/testing/unit.html) for how it's normally done.
It seems the discussion has happened here: http://discuss.rust-lang.org/t/settling-some-key-naming-conventions/269
Depending on the optimiser to constant-fold a series of nested arithmetic operations seems very reasonable. #![feature(macro_rules)] macro_rules! compute_mask { (0) =&gt; { 1 }; (1) =&gt; { 1 }; (_) =&gt; { 0 }; } macro_rules! compute_equal { (0) =&gt; { 0 }; (1) =&gt; { 1 }; (_) =&gt; { 0 }; } macro_rules! bit_match { (: $x: expr, $mask: expr, $equal: expr, ()) =&gt; { ($x &amp; $mask) == $equal }; (: $x: expr, $mask: expr, $equal: expr, ($head: tt $(, $rest: tt)*)) =&gt; { bit_match!(: $x, $mask * 2 + compute_mask!($head), $equal * 2 + compute_equal!($head), ($($rest),*)) }; ($x: expr, ($($pat: tt),*)) =&gt; { bit_match!(: $x, 0, 0, ($($pat),*)) }; } fn main() { let v = [0b000u, 0b001, 0b101, 0b110]; for &amp;x in v.iter() { println!("{:03t}\n\t_01: {}\n\t1__: {}", x, bit_match!(x, (_, 0, 1)), bit_match!(x, (1, _, _))); } } Output: 000 _01: false 1__: false 001 _01: true 1__: false 101 _01: true 1__: true 110 _01: false 1__: true [playpen][pp] [pp]: http://play.rust-lang.org/?run=1&amp;code=%23![feature%28macro_rules%29]%0A%0Amacro_rules!%20compute_mask%20{%0A%20%20%20%20%280%29%20%3D%3E%20{%201%20}%3B%0A%20%20%20%20%281%29%20%3D%3E%20{%201%20}%3B%0A%20%20%20%20%28_%29%20%3D%3E%20{%200%20}%3B%0A}%0Amacro_rules!%20compute_equal%20{%0A%20%20%20%20%280%29%20%3D%3E%20{%200%20}%3B%0A%20%20%20%20%281%29%20%3D%3E%20{%201%20}%3B%0A%20%20%20%20%28_%29%20%3D%3E%20{%200%20}%3B%0A}%0A%0A%0Amacro_rules!%20bit_match%20{%0A%20%20%20%20%28%3A%20%24x%3A%20expr%2C%20%24mask%3A%20expr%2C%20%24equal%3A%20expr%2C%20%28%29%29%20%3D%3E%20{%0A%20%20%20%20%20%20%20%20%28%24x%20%26%20%24mask%29%20%3D%3D%20%24equal%0A%20%20%20%20}%3B%0A%20%20%20%20%28%3A%20%24x%3A%20expr%2C%20%24mask%3A%20expr%2C%20%24equal%3A%20expr%2C%20%28%24head%3A%20tt%20%24%28%2C%20%24rest%3A%20tt%29*%29%29%20%3D%3E%20{%0A%20%20%20%20%20%20%20%20bit_match!%28%3A%20%24x%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24mask%20*%202%20%2B%20compute_mask!%28%24head%29%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24equal%20*%202%20%2B%20compute_equal!%28%24head%29%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%28%24%28%24rest%29%2C*%29%29%0A%20%20%20%20}%3B%0A%20%20%20%20%28%24x%3A%20expr%2C%20%28%24%28%24pat%3A%20tt%29%2C*%29%29%20%3D%3E%20{%0A%20%20%20%20%20%20%20%20bit_match!%28%3A%20%24x%2C%200%2C%200%2C%20%28%24%28%24pat%29%2C*%29%29%0A%20%20%20%20}%3B%0A}%0A%0Afn%20main%28%29%20{%0A%20%20%20%20let%20v%20%3D%20[0b000u%2C%200b001%2C%200b101%2C%200b110]%3B%0A%20%20%20%20for%20%26x%20in%20v.iter%28%29%20{%0A%20%20%20%20%20%20%20%20println!%28%22{%3A03t}\n\t_01%3A%20{}\n\t1__%3A%20{}%22%2C%20x%2C%20bit_match!%28x%2C%20%28_%2C%200%2C%201%29%29%2C%20bit_match!%28x%2C%20%281%2C%20_%2C%20_%29%29%29%3B%0A%20%20%20%20}%0A}
Ugh, `iter_owned` looks so bad compared to `move_iter`. I could take `iter_move`, but `owned`? I thought that was almost extinct after the removal of `~`.
On a second note, what happened to `refs`, `mut_refs`, `vals` and `move_vals`? (Also consider `s/vals/values` and suffixes instead of prefixes)
I agree that assert is pretty confusing. In all languages I know it is used to check a condition and don't return a value. get or unwrap fit much better IMHO.
Assert sounds fine to me, since that's precisely what it is. Using the same name tells the programmer that this is a "succeed or die" function and might deter them from using it willy-nilly.
&gt; Assert sounds fine to me, since that's precisely what it is. `assert!(foo)` asserts `foo`, what does `assert()` assert?
I also find `.assert()` a bit weird, but as aturon suggested, how do you distinguish `.unwrap()` from cases when it can fail and when it can not?
&gt; I hope to see the same thing take hold in Rust. `rustfmt` will be a thing, it's just a thing to do as close to 1.0 as possible. The style guide is still being worked upon, and the language is still changing...
&gt; although it seems silly to not be able to post the short link. Blame Reddit, not /r/rust
Assert has a different meaning in other languages. Won't this be too confusing?
This was written about the low level representation of events. It might be unclear from the context. There is already some work targeting high level event programming going on in the expression branch of rust-event https://github.com/pistondevelopers/rust-event/tree/expression Here are two articles about the design: * http://www.reddit.com/r/rust_gamedev/comments/2cqo32/rustevent_breakthrough_for_expression_branch/ * http://www.reddit.com/r/rust_gamedev/comments/2cviwl/understanding_rustevent_eventcursor_duality/
You can use this to be able to rewind to a previous state, e.g. the internal [`core::str::run_utf8_validation_iterator`](https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src/libcore/str.rs#L702) function is designed to consume an iterator until the start of first sequence of bytes that's not a valid UTF-8 encoding of a code point, returning `false` and restoring the passed-in `&amp;mut` reference to the iterator to point to that position. Each run of [the loop](https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src/libcore/str.rs#L703) consumes a valid sequence, so the state [is saved](https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src/libcore/str.rs#L705), and [any error](https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src/libcore/str.rs#L708) will restore the state (i.e. make the iterator point to the start of the incorrect byte sequence).
Here is the gfx-rs repo: https://github.com/gfx-rs/gfx-rs There are discussions in the issue tracker where you can give feedback. If you want to talk to the developers, you can do it here: https://gitter.im/gfx-rs/gfx-rs 
I think it depends. When you use the method on an option, you are asserting that this value is what it is.
`foo.assert()` asserts `foo`.
I'd prefer a more explicit name. E.g. unwrap\_or\_fail() (to match the other unwrap\_or\_... methods) or get_or_fail() if it needs to be shorter.
&gt; Path:new() can fail when invalid-UTF-8 is passed [Does it?][pp] [pp]: http://play.rust-lang.org/?run=1&amp;code=fn%20main%28%29%20{%0A%20%20%20%20println!%28%22{}%22%2C%20Path%3A%3Anew%28b%22ab\xFFcd%22%29.display%28%29%29%3B%0A}
Also in C/C++ it's usually compiled out of non-debug builds. I think this will be more confusing going from rust to another language than the other way around though.
I come from a background in D, and agree that assert has a different meaning for me than this. .tryunwrap() or .tryunbox() seem like they would be better options. Both imply a possible critical failure, but are more descriptive of what actually happens.
I feel like this is changing the meaning of a traffic sign. There will be trouble.
Has anyone considered 'ensure'? Maybe it doesn't fit, but I've seen that in at least somewhat similar APIs.
I wouldn't mind that. To be clear, my position on this change is "it's kinda weird but I don't think it's a super big deal, and I do think it makes sense. I don't really care enough to argue strongly for or against it." I wonder after using it for a while if it won't seem perfectly natural.
it doesn't duplicate the start and end of the range, so if you need to change that logic, you only have to change it in one place. If the range start and end were calculated then the benefits would be more clear. 
Yes but the main goal of unwrap was getting the value of foo, asserting foo exist is a side effect. I think not naming the function regarding to the main effect at all is bad. unwarp_or_fail is longer but would describe both effects. 
The main goal of unwrap is to say "If this value is not `Some`, then screw it, let's just `fail` the task. I'm not handling errors." This feels _very_ conceptually similar to `assert` to me.
Right but you get the idea. [This one fails](http://is.gd/mIHOTV)
They don't sound very iteration-y to me. *shrug*
&gt; I'm warming up to unwrap_or_fail though because it is highly descriptive. I'm with you on that, feels symmetric to `unwrap_or_else`.
Wrong link i fixed it
Ah, well; to be precise, a null byte is valid UTF-8.
lolwhat, why was this down voted again. was I rude? the rules say don't just down vote for casual disagreement.
(You can use the markdown long-link syntax suggested in the sidebar to avoid dumping a huge link, i.e. [The code is here.][code] [code]: http://play.rust-lang.org/... ) &gt; So any help in the code is appreciated and my question is, what types/changes must i make so that the final for loop and println outputs a modified board. What do you mean by this, or is that the problem you have solved with `as_mut_slice`?
I'll get on fixing that. Please file issues when you see incorrect docs! Done: https://github.com/rust-lang/rust/pull/16443
See, this is the problem with the current name. You shouldn't be using `unwrap` to get the value, you should be using `match` to get the value. `unwrap` is a shortcut that's used when you're not planning on handling an error. There's value in a more scary name that properly communicates what it is you're trying to do.
you could put some other language feature like #[discourage_use("...some informative message..")] or something to mark functions you want to report as 'bad style' .. it could throw a warning. IMO 'assert' already has meaning, this conflicts
less nesting levels/ less mental steps; closer to what people are used to. if (auto x=something_that_might_fail_with_null_pointer()) { ... use x ... } if let Some(y)=something_that_might_fail() { // 1 'step' to get 'y' .. use y... } match something_that_might_fail() { // Some(y)=&gt;{ // this is like a second operation inside, before i can actually do something ... use y.... } } i can see the argument for minimalism 'match already does it'.. but i think this is ubiquitous enough to justify sugar I know it sounds unscientific, but it definitely 'feels more laborious' - the extra nesting level is the concrete difference i can point to. Even if you combine the expressions and close brace onto one line, the double close brace always sticks out to me like a sore thumb
I was looking at the windows:Path which seems to have a different implementation. https://github.com/rust-lang/rust/blob/master/src/libstd/path/windows.rs#L638 
Sorry, i meant https://github.com/rust-lang/rust/blob/master/src/libstd/path/windows.rs#L638
awesome! I am for If let
You might enjoy the RFC: https://github.com/rust-lang/rfcs/pull/160
&gt; I like it now, I think. What has changed you mind? I don't mind renaming it, but i consider it a big mistake to name it to `assert`, which has strong deviating precedence in nearly every other programming languages http://rosettacode.org/wiki/Assertions Also i am quite upset and disappointed that such impactful discussions are moved away from GitHub to a discussion board which was advertised as mostly Mozilla-internal in the past.
This is obviously unorthodox and a bit surprising, but I think it's totally brilliant. The absence of prior art just makes me go, "why didn't anyone else think of this?". (For what it's worth I have a slight preference for `assert_some()` over just `assert()`.) Edit: so it turns out [there *is* prior art](http://discuss.rust-lang.org/t/settling-some-key-naming-conventions/269/43?u=glaebhoerl), I had just forgotten about it.
Oh, there's a separate rust-gamedev subreddit. Another thing to follow :)
It's what i solved with as_mut_slice, i wanted the "board" variable to be modified after solving the problem, i had tried different types and it seemed most moved the value.
Not trying to point fingers, it just seemed silly.
&gt; What has changed you mind? The more I think about what an assertion means, the more that I think that `unwrap` is fundamnetally an assertion, and should be treated as such. &gt; strong deviating precedence in nearly every other programming languages As I said in another comment, I don't think that's actually true. Assert means "I say this value is something, or else crash." That's what `unwrap()` does. There is little difference between (C code): int foo(char *format ) { assert( format != NULL ); // other stuff and fn foo(format: Option&lt;String&gt;) -&gt; int { let format = format.unwrap(); With the name changed, this becomes fn foo(format: Option&lt;String&gt;) -&gt; int { let format = format.assert(); Comparing: assert( format != NULL ); let format = format.assert(); Other than that one is a function and one is the method, feels very, very close to me. &gt; moved away I have some thoughts on this but I'm not really ready to post them, but I do want to acknowledge that I've heard what you said. EDIT: /u/pcwalton said what I was thinking: https://github.com/rust-lang/rust/pull/16436#issuecomment-51911916
It is kinda silly, it'd be nice if we could turn it off for this Reddit. I bet that 99% of those links are spam, though.
Making `unwrap()` a warning would be going too far. If you warn people about every little thing, soon they just start ignoring them all. There are legitimate use-cases for `unwrap()`.
A warning that everyone is going to turn off isn't useful.
A method name being *clever* is a bad thing and makes an API confusing for newcomers. The functionality can and should be obvious from the name by calling it something like `get_or_fail`.
The `cycle` iterator is also based on using `clone` to save the iteration state. You don't need to do the second `clone` though, as you can just consume the range.
That make sense too. But I suspect the use of confusing naming conventions may hurt the language in the long run.
unwrap is fine. Killing common name convention for the sake of warning users is a bad move.
I think if you want a scary name that has to be used exceptionally, "unwarp_or_fail" fit beter. And you understand what it does at first sight.
I'm not opposed to that name.
It says included in, to me that just means the installation should put a copy of the license on the disk. Example: http://packages.ubuntu.com/search?searchon=contents&amp;keywords=LICENSE&amp;mode=exactfilename&amp;suite=trusty&amp;arch=any
So, I'll just add my 2 cents... I've not been keeping tabs on Rust for the past month or so (my rustc is 1 month and 1 day old), but that might actually be useful, to get a semi-outside perspective. For assert(), I think unwrap_or_fail() sounds best, especially considering unwrap_or_else and unwrap_or_default already exist. assert() that returns a value doesn't feel right; I think of assert as an if statement, not as a means of fetching a value. Regarding iter_owned, iter_move sounds best to me, though I must admit I've never really used those functions, so I'm not 100% sure how they work.
Some CLI tools include this sort of thing in the result of `--help`.
Yes, I agree with this philosophy. But I disagree that renaming `unwrap` to `assert` adds needless complexity. Given something like the following: fn do_something(x: Option&lt;int&gt;) -&gt; int { let val = x.assert(); val + 1 } I believe that: 1. for a user who has never read the docs, I would actually suggest that `assert` is more informative than `unwrap`. `assert` at least gives you some hints about what it might be doing. As far as I know, then term `unwrap` has no common usage in other languages. 2. Opening the documentation and reading that `"assert() will move a value out of an option type and returns it, consuming the Option"` is an obvious next step for a confused developer, and is neither a burden nor is it complex enough to make life harder on new rust developers. (I think rust has lots of little quirks that can users pause and think for a moment -- like the lack of a `return` statement in the above example. Sure, these might not be obvious at first glace, but once you learn the language, these quirks are not burdensome)
Apropos of that, I'd make return mandatory everywhere. Scanning code becomes much easier. Also, your example makes it look like the new intended usage of assert is sensible. Lets hope that in other conditions it will not become a problem, ie, when wrapped inside different types of code. Also, the use of `unwrap` is discouraged. Does the same still apply to `assert`?
&gt; Also, the use of unwrap is discouraged. Does the same still apply to assert? Yes, renaming the method doesn't change the fundamentally bad behaviour of it (it is a partial function, with task failure/unwinding), so it is still (strongly) recommended to use a `match` or the other methods like `map`, `or_else`, `unwrap_or`.
The name `.unwrap()` also looked a little weird when I saw it first time, so `assert()` is probably an improvement. The name `.or_die()` would be short and easy to understand, but cumbersome to write. I don't know if this is good or bad, but at least it would add some drama to the syntax.
I would prefer `or_fail` to `or_die` because 'die' doesn't really mean anything in Rust.
Not sure if this is a useful data point, but in the language I've been designing in my spare time, I'd named the method `assert_success` on `Result`, so using `assert` definitely seems right to me.
This is great, so first of all here is your virtual cookie, with an accompanying virtual cup of tea: 🍪🍵. The main reason I failed is apparently that I did not know about the `tt` fragment specifier, or that one would have to use it here. I shall file a documentation bug against the macro guide I guess. I'm admittedly always a bit hesitant to depend on the optimizer, because (not having read its code) I find it hard to reason about the results. E.g. what if I have 32 Bit instead of just 3. Depending on the heuristic it might not fold the expression completely, because it becomes too complex (64 operations each with a data dependency on the previous one, if I'm not mistaken). Just for fun, here is the solution I came up with. It works fine now that I'm using the `tt` specifier. It's a bit shorter, but not as cleverly recursive: macro_rules! bit_match( ($x: expr, ($($b: tt),*)) =&gt; ({ let mut mask = 0; let mut val = 0; $( mask = (mask &lt;&lt; 1) | compute_mask!($b); val = (val &lt;&lt; 1) | compute_val!($b); )* ($x &amp; mask) == val }); )
To clarify, discourse has never been promoted as Mozilla-internal (well, maybe for a few days of beta-testing, but never whilst anything important was happening). It is meant to be for *Rust*-internal discussion. I.e., a forum for discussing the language and its implementation, open to all.
How about `must_unwrap`?
&gt; It's weird that you say "Brain****" in your comments, but the project name and the README both say "Brainfuck." If you're going to build a Brainfuck interpreter, just say 'fuck.' &gt; That's because I did not write those comments, that's the ENSI standard document I just copied into my spec in order to ensure my interpreter follows it. (http://esoteric.sange.fi/ENSI/brainfuck-1.3.txt) That's also why some comments appears to be not well formatted, because of the editor I used (atom) keeps ignoring my configuration I got some files with mixed tab and spaces, I think I normalised them to use tabs since I had to convert a single file only. I think I'll convert them to 2 spaces because github uses weird tab spaces. I didn't think that my choice of not using snake case could be an issue since this is not meant to be a reusable module, also because the compiler allows it and even gives a directive to turn off the nag warning about it, but I see that for all here that's a big issue, I can understand that, unfortunately I find snake case to be difficult to read, but I understand that's my problem. Thank you for your suggestions I'll try to improve the code a bit later.
&gt; open to all If that's the case, why isn't it advertised on the main page along with the mailing list and other community gatherings? How is a new Rust user meant to discover that there is this super-important discussion area?
https://github.com/rust-lang/rust-www/pull/56 &gt; How is a new Rust user meant to discover that there is this super-important discussion area? It's not actually for Rust users, it's for developing Rust itself. Right now, there's a lot of overlap, but as Rust grows, that overlap is less and less.
Yes, this is more explicit. "Not handling the error in the current task." That said, I don't think a lot of Rust programs are currently using supervisor tasks, though hopefully the pattern gets used more in the future.
http://en.cppreference.com/w/cpp/experimental/optional/optional could get together with the people writing this and come up with a consistent name. `unwrap/unwrap_or()` vs `value()/value_or()` vs `assert()` the swift language has `!` , the telling thing being they think its important enough for an operator.. a single word like unwrap might be a nicer compromise than a lengthy name 
It's very nice, I usually use it when I work from home instead of firing intellij since it's more lightweight and my old macbook can handle it better. My only problem is that sometimes it mess with space and tabs, but most of the times works correctly, in fact is my default editor now :) 
I'm proud to have helped make a tiny contribution to this space. The paper "Better Static Memory Management: Improving Region-Based Analysis of Higher-Order Languages" contains a pretty good summary of my Masters work. http://research.microsoft.com/pubs/67471/afl-pldi95.pdf Basically, we were trying to do static analysis of an ML-style programming language to figure out how much stuff we could allocate in a stack-like manner (deallocating on scope exit), and that particular paper was mostly about figuring out what you could drop in a tail call. This particular line of research never became practical, because you still needed a GC for most things, and just being able to free some memory in that context doesn't buy you much. Rust takes these ideas _much_ farther, flipping the equation so you barely need GC at all for most things. But I think you'll find that a bunch of the ideas in there - ML style type system, regions, using constraints to statically analyze the program behavior - are recognizable.
&gt; The intend behind unwrap is to get at the value stored in the option. No, it is not. It is to declare that you know better than the compiler, and to let the task fail if you are wrong.
Cool. :)
there are cases where you know the unwrap can't fail but the compiler does not. Example: let _ = 1u.to_biguint().unwrap(); // there's no way this can fail you don't want to have to do this: let _ = match 1u.to_biguint() { Some(n) =&gt; n, None =&gt; fail!("there's no way this can fail") };
I don't want to _limit_ participation. I'm just saying that the topic of Discuss is Rust itself and its development. Most of the content on this subreddit, for example, is not appropriate. That said, _maybe_ it should be there now, and moved. I don't feel super strongly either way.
I submit that API cleverness can never be outweighed by anything.
I guess so. I just took the idea from Go's regexp package, where the function `MustCompile` lets you skip checking for errors. Looking over the discussion, I like the name `force` the best, but I'll be happy with anything other than `assert`.
If getting the value is not what the function attempts to do, then it shouldn't return the value. If it's only supposed to enforce a runtime check for the value's presence it can do that perfectly fine without returning the value.
`get_or_fail` is so much better than `get` or `unwrap`, why did I not hear of it before?
Perhaps try_get() or tryget() ?
I use the nightly PPA on a few different Ubuntu systems and I haven't noticed any issues. Here's my 64-bit 14.04 Linode: $ rustc --version rustc 0.12.0-pre $ dpkg -p rust-nightly | grep Version Version: 201408120406~9dcf895~trusty $ uname -a Linux ... 3.15.4-x86_64-linode45 #1 SMP Mon Jul 7 08:42:36 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux $ rustc - &lt;&lt;&lt;'fn main(){std::io::fs::unlink(&amp;Path::new("./rust_out")).unwrap();}' &amp;&amp; ./rust_out $ Have you tried reinstalling rust-nightly? (`sudo apt-get install --reinstall rust-nightly`) If you backup your system you might want to run `diff` on older versions of `/var/backups/dpkg.status*` to see which packages have changed or been installed recently.
The fact that it's perfectly valid (and it absolutely is!) does not imply that it should be the most ergonomic way to work with an Option. Why should blowing up be the easiest thing to reach for? 
I think `get_or_fail` is by far the best suggestion. It might be more verbose than `unwrap`, but together with pattern matching and the proposed `if let` I don't really see it as a problem. 
I don't like it. At least with unwrap you knew what the method was supposed to do in the normal case. All "assert" tells you is that the method can fail.
That would be ideal! inotify-rs always was a stopgap. If it becomes obsolete due to something better showing up, that would be excellent :)
Yes, it will. I think this thread is demonstrative of that.
I also don't see why the increased verbosity is not *desired*. I'm under the impression that the point is to *discourage* usage of `unwrap()`. While I can see `assert` achieving that, I sincerely doubt it's for the right reasons (i.e., obscurity). The most surprising element of this development to me is that `unwrap_or_fail` or one of the related suggestions, which seem to have all the desired properties for this context, was not chosen over `assert`.
It would be to make sure that you don't accidentally change the arguments in one, but forget to do it in the other.
I personally like .unwrap() and .value() (in no particular order) over .assert() just because they both make me think there is something contained within. Though, it is a fair point someone else made that assert makes more sense due to it confirming the value exists first. Would there be a way to compromise?
I have to agree, `.assert()` is not a good replacement name for `.unwrap()`. It does make me think `assert!(opt.is_some())`. Why not `.require()`? It's usually in the context of dynamic imports, but I think it fits well here. You're depending on that value being available, and you don't want processing to continue without it. Anyone familiar with PHP or Ruby or Node.js would immediately grok its meaning.
Yup!
Well it's kind of the point that new rust users are not directed there, since it is meant for discussion of the internals of the language. There are better forums for new users. Contributors should be able to find it easily - it is linked from the irc motd and GitHub. If you think it could be better advertised to contributors, then let us know how and we'll do so.
Slightly relatedly: Would it make sense to have a trait named `ToStrSlice&lt;'a&gt;` with a method named `to_slice()`? This trait could be implemented by `String` and `&amp;'a str`?This would allow you to do stuff like fn f&lt;a', S: ToStrSlice&lt;'a&gt;&gt;(text: S) EDIT; The Pre-RFC looks nice.
&gt; Assert means "I say this value is something, or else crash." No, it means "I say this condition is true, or else crash". "This value is something" is only a (common) condition. The closer C code would be assert(format); Which is perfectly legal in C, but isn't what I would like to see in Rust!
Damn right. The procedure is *not* a good one. It's *just* good enough that the developers can pretend it's not broken. I would bet hard money that one or more of them will show up in this comment thread and try to defend their discussion mechanisms that are not only architecturally flakey, but barely used in the first place. Bonus points if they call it "open" or "transparent". The fact that there is so much backlash after the change, is proof that their process is not living up to those expectations. If you can't recognize the symptoms that your discussion process sucks, of course you'll be surprised when the community turns on you. And they *will* turn on you, because you surprised *them.* So let's all stop surprising each other.
Isn't 'assert' a lot like 'expect' but without the message? EDIT: I do agree that it is surprising. +1 for unwrap_or_
That already exists: Its the `Str` trait EDIT: Oh wait, that has slightly different semantic due to the lifetime parameter... hm...
Thanks. I think that `Str` handles lifetimes better than my proposal.
You can do that in Rust today, it's just a macro: `assert!(format)`.
Will do! I really like Riak's protocol, so gossip.rs borrows some of the same tweaks to run in a few hundred node cluster (instead of the 10,000+ P2P cluster that the original plumtree paper demonstrated.)
With `format` an `Option&lt;String&gt;`, as in your example? http://doc.rust-lang.org/0.11.0/std/macros/macro.assert!.html says it requires a boolean expression, and that's what I've assumed before as well.
^(p.s.) there's a Discourse [thread about that link as well](http://discuss.rust-lang.org/t/link-to-this-forum-on-rust-lang-org/67).
Again, wonderful work. 
It's [linked on the dev wiki](https://github.com/rust-lang/rust/wiki/Notes) since July 11. Admittedly it was a bit understated. But there's also been some discussion on `[rust-dev]` about it.
Avoiding recursion is nicer. :) &gt; Depending on the heuristic it might not fold the expression completely, because it becomes too complex (64 operations each with a data dependency on the previous one, if I'm not mistaken). This is just a sequence of operations with no complicated dependencies, meaning it can be reduced iteratively starting at the top with `0` and applying each `+` and `*` operation in turn.
I can't wait for it. The last thing I need to think about it a style guide. Just use what's been agreed upon and move on.
Ah! I just ment that the assert macro exists, I wasn't thinking about the type. How would `assert(format);` work in Rust?
Your requirements here are very minimal. Unless you are distributing the Rust source with your source, then your source code doesn't need to care about reproducing the Rust license. For the binary, you do not need to display any of the Rust licenses inside the software. Finally, I believe you do technically need to distribute the license to all the software included in Rust if you are distributing a statically-linked binary. All you need to do though is take the license files in our top level directory and dump them into your distributables, making sure they are discoverable, and that it's clear they apply to upstream Rust. Rust's LICENSE file is not perfectly maintained and may not exactly reflect what's in tree. I'm not a lawyer.
Hm, that's not my experience, though I'm not used to D. See C#'s [Int32.Parse](http://msdn.microsoft.com/en-us/library/b3h1hf19.aspx) vs [Int32.TryParse](http://msdn.microsoft.com/en-us/library/f02979c7.aspx)
Very exciting stuff, IMO. I implemented most of this last week, so it should be landing in a rustc near you Pretty Soon Now. Just waiting on reviews! https://github.com/rust-lang/rust/pull/16377
Kudos to you for producing a 5000 LoC patch in a week! Very exciting indeed!
I really appreciate the idea of it, and I don't use assert enough in other languages to be "confused" by this usage. On the other hand, I don't think that ```assert``` really says what it does. I would go for ```force``` or something like that. But, in any case, I think that unwrap is the wrong name for it. It always seems akin to an unsafe block to my mind. You are stating that you know better than the compiler. 
Ah, I didn't appreciate the meaning of extern in that context, thanks. Also, it is not an issue casting between void * and a function pointer? http://stackoverflow.com/questions/12358843/why-are-function-pointers-and-data-pointers-incompatible-in-c-c I'm sure I've seen c libraries in the past that general an internal symbol table of function pointers as a global struct and have the shared library loaded read that one (data) symbol out, for cross platform compatibility. 
There's no such problem with Rust right now, and I doubt we'll make this UB. To my knowledge to relevant architectures have this concern anymore.
Source: https://github.com/cmr/VisualRust Still a lot more features to add before I'm ready to put something in the VS Gallery though!
Casting `*mut fn()` to `fn()` is also casting a data pointer to a function pointer, so the question is moot. (`fn` is the function pointer, and thus `*mut fn()` is, strictly speaking, a pointer to some normal memory location holding a function pointer, i.e. a data pointer.)
The multidispatch would be very useful. I recently implemented a `Quaternion`, and it must support scalar multiplication as well as quaternion multiplication. The way to do it (thanks guys at the IRC channel!) was to add an extra trait `MulQuaternion` with a `mul(&amp;self, lhs: &amp;Quaternion) -&gt; Quaternion` method that is implemented for types that can be multiplied with a quaternion at the right. Then implement `Add` like this: impl&lt;T: MulQuaternion&gt; Mul&lt;T, Quaternion&gt; for Quaternion { ... } Implementing `MulQuaternion` feels weird, because self is actually the right hand side. This approach works, but it is only possible to define a multiplication where the scalar is on the right. I think that for multiplication on the left, `f32` should not have implemented `Mul&lt;f32, 32&gt;` directly, but it should have followed a similar pattern, with a `MulF32` trait that could be implemented by `Quaternion`. (Please correct me if I am wrong.) Having multidispatch would make this so much cleaner. Does multidispatch allow overloading methods in general? I.e. having different traits with methods that have the same name, but different argument types, such that the trait can be inferred from the arguments?
When will parameterization over values be implemented?
It shouldn't, which is precisely what I've said: &gt;&gt;&gt; Which is perfectly legal in C, but isn't what I would like to see in Rust! 
If you’re checking for Err before unwrapping a result, you should probably just be using pattern matching directly, or perhaps using [`try!`](http://doc.rust-lang.org/std/macro.try!.html). After all, that’s exactly what `unwrap` and `is_err` are defined in terms of, anyway. If you use the pattern matching directly, it’s trivial to prove that the code will not fail; if you’ve checked `is_err` first, it takes a mite more effort, and while it should be optimised out it is immediately less obvious. `unwrap` is a code smell.
Edit: The question was about Result&lt;R, E&gt;, but this applies anyway. One problem is the risk of unwrapping the wrong variable: let x = Some(5u); let y: Option&lt;uint&gt; = None; if x.is_some() { let val = y.unwrap(); //Oops! } This can happen any time when writing new code or refactoring and the compiler will not warn you. Some alternative approaches are using map, if possible: let x = Some(5u); let y: Option&lt;uint&gt; = None; x.map(|val| { //Do stuff }); or writing a macro: macro_rules! with ( ($pattern:pat = $expression:expr do $action:expr) =&gt; ( match $expression { $pattern =&gt; $action, _ =&gt; {} } ) ) //... let x = Some(5u); let y: Option&lt;uint&gt; = None; with!(Some(val) = x do { //Do stuff }) I'm sure there are more solutions, but these are what I can think of right now.
`unwrap()`reliably causes the program (or thread) to fail fast if the value is `Err`. So in that sense `unwrap()` is not dangerous. If you want to reliably fail fast with a message, then you can write x.unwrap_or_else(|e| fail!("My message {}",e))
 fn main() { use std::io::File; let mut file = File::open(&amp;Path::new("foo.bin")); let number = file.read_le_i32().unwrap(); } See the Reader trait: http://static.rust-lang.org/doc/master/std/io/trait.Reader.html Or did you mean serializing/deserializing?
You can do the macro solution without a macro (i.e. just write a `match`); I don't think it is anywhere near as bad as the OP is implying.
Task failure (and thus `unwrap`) is not a composable error handling mechanism. A library using failure for error handling is unlikely to see much adoption, since users of the library cannot control/contain it (without starting a new task at each point that an error should be caught). Furthermore, the unwinding that task failure does causes missed optimisations and thus leads to slower code (i.e. don't use `unwrap` inside an inner loop). Manually checking for `Err` or `None` before calling `unwrap` risks mistakes and typos unnecessarily, and doesn't encapsulate the intent of the code as clearly as a `match`. &gt; Doesn't this pattern make for a much cleaner alternative to pattern matching, where we can get tangled calling match within match? Wouldn't using `is_err` + `unwrap` lead to calling `if` inside `if` in the same situations?
You are absolutely right! I, personally don't mind `match` that much, but turning it into a one-liner can be useful in some cases and I was just showing some alternatives. :)
`iter_move` and `unwrap_or_fail` sound good.
I'm weirdly still stuck with the old names, I still think in terms of `.chain` for Option, the meaning of and/or hasn't really trickled in yet.
I was talking about Java. When you `try` something it definitely could fail
Very cool -- just a bit of tension since the RFC is so big, as a programmer I don't seem to like complexity at all. Associated types should make it much easier for all the custom collections and matrix libraries already existing.
&gt; Furthermore, the unwinding that task failure does causes missed optimisations and thus leads to slower code (i.e. don't use unwrap inside an inner loop). So loops with unwrap inside will always be slower than loops with pattern matching? &gt; Wouldn't using is_err + unwrap lead to calling if inside if in the same situations? I don't know Rust as well as you do but I have the impression that code is cleaner if we do away with all the negative stuff with a single if at the head of the method.
Conrod is a project under the Piston umbrella with the goal of developing a graph based navigation UI with immediate mode widgets.
The way you've described the module system seems kind of weird to me. It's not that `main` uses `vector`, it's that `main` is the root of the module tree. Thus far, once I move beyond simple 1-2 file programs, the only things I typically put in `main.rs` or `lib.rs` are the external crates being used, the top-level module tree, and the top-level public exports. In other words, I tend to use the root file almost as a "project file" that specifies the layout of the program. Also, I think that the C# approach is a definite step backward from how Rust works: given a C# source file, you cannot tell where any given symbol is defined in the code base without needing to use an IDE or grep. With Rust, every item has to be in a module, that module has a name, and unless you're doing any weird path renaming or re-exporting shenanigans, the module's name can be used to find the file. I have a *very* strong preference for languages where names map in some fashion to files.
&gt; I don't know Rust as well as you do but I have the impression that code is cleaner if we do away with all the negative stuff with a single if at the head of the method. If it's possible to write a single `if`, it's (almost certainly) possible to write a single `match`. &gt; So loops with unwrap inside will always be slower than loops with pattern matching? Never say always, but yes, on average code using `unwrap` will be slower because the optimiser is having to do more work to get to the same place, e.g.: extern crate test; static LENGTH: uint = 100; #[bench] pub fn unwrap(b: &amp;mut test::Bencher) { let vec = Vec::from_elem(LENGTH, Ok::&lt;u32, u32&gt;(0)); b.iter(|| { for x in vec.iter() { if x.is_ok() { test::black_box(x.unwrap()); } } }) } #[bench] pub fn match_(b: &amp;mut test::Bencher) { let vec = Vec::from_elem(LENGTH, Ok::&lt;u32, u32&gt;(0)); b.iter(|| { for x in vec.iter() { match *x { Err(_) =&gt; {}, Ok(a) =&gt; test::black_box(a), } } }); } Compiling that with `--test -O` and running with `--bench` gives: running 2 tests test match_ ... bench: 88 ns/iter (+/- 11) test unwrap ... bench: 153 ns/iter (+/- 7) test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured 
In some places I think you can use [collection initializers](http://msdn.microsoft.com/en-us/library/bb384062.aspx).
I used to do that, but then I took an arro^W - ugh, that joke is getting old! But I have to agree, associated items are quite exciting :D.
This will be such a big improvement for code duplication, I've been waiting for someone (smarter and has more time than I) to do this! Thank you!
Will it have widgets that look like the default system widgets?
I don't think it's planned. However, there will probably be themes. If you are making a widget framework, you spend a lot of effort making it, so making a new design is a way to distinguish itself from the default system and get some experience in alternative design. If it fails, then at least you got some experience you can use in other projects.
Except for the list of modules there is still the `main` function, but when the port is done, `main` should only be a few lines to set up everything. With all the module declarations it starts to look like a project file indeed. I also prefer names that map to files. I usually have one file per class/struct, and sometimes multiple structs in one file when they are related. The thing that surprised me, is that to use `vector3` in `ray.rs`, I have to edit a _third_ file (`main.rs`) that in principle has nothing to do with `ray.rs`. On the other hand, if you just declare all the modules in `main.rs`, then you can reference them everywhere just fine, and `use` statements work similar to `using` in C#. Maybe the right way to look at it, is to treat `main.rs` like a kind of project file. Thanks! For C#, the convention is to use one file per type, use the type name as the filename, and have the directory structure mirror the namespace structure. If you follow these conventions, locating a symbol should not be hard. 
Excellent! It seems like these generic traits with multidispatching can significantly compensate the lack of plain function overloading. My hope is only that they will be approved and implemented before the library stabilization.
I think `Str` is not a good name as I don't expect a trait named as such to have a single method `as_slice`. I prefer `StrSliceable`, somewhat in sync with `StrAllocating`.
Or rather x.expect("My message")
A few minor things: - I have never encountered using statements inside a namespace (RustBraceMatcher.cs). They just go at the top of the file, before any namespace (RustTokenTag.cs). - It is more idiomatic to use Pascal casing for enum variants, just like classes and properties (RustTokenTypes.cs). - If an event is not used, you can declare it without the `add` and `remove` (RustTokenTag.cs, RustClassifier.cs). - Instead of producing an enumerable by enumerating an enumerable, and using `yield return`, you can also use `Select`, the C# version of `map` (RustClassifier.cs).
What should I use if I want system widgets?
In /u/Bob_goes_up's example (a) the type is `Result` (there's no `expect` for `Result`), and (b) the failure has formatting based on the data inside the `Err`.
Ruud-v-A meant C# `using`-statements (actually `using`-declarations) inside a `namespace`. There are very few cases where you'd want to put the `using` declarations inside the `namespace` scope, usually you put them at the top of the file above the `namespace` declaration.
Library stabilisation is [one of the 2 reasons](https://github.com/aturon/rfcs/blob/43160e85e29a56c507c8614ba7be0b7054cdffc6/active/0000-associated-items.md#why-now) that this RFC has been submitted and considered now.
Exciting times! Too bad we won't get rid of the asymmetry between the first and all further input params.
[And it seems associated types are on their way.](http://www.reddit.com/r/rust/comments/2deaqh/rfc_associated_items_and_multidispatch_traits/)
Isn't UFCS supposed to address this one?
I thought `using`s should go inside namespaces? At least, that's what StyleCop suggests.
I have encountered using statements inside a lot. Its a common practice. In fact, Re-sharper and style-cop even provide options for automating it that way.
I'm just wondering if it would be easier to get IDEA IDE to get working with rust. Rust and their Kotlin seem very similar in some aspects
VS is important for game dev shops. IDEA would be great though, and it's multiplatform.
I don’t know about StyleCop, but code analysis makes no such suggestion. Also, Visual Studio does not put them inside the namespace when you add a new class, and the [source](https://roslyn.codeplex.com/SourceControl/latest#Src/Compilers/CSharp/Source/Emitter/CustomModifier.cs) of the Roslyn compiler platform has them outside the namespace as well.
&gt; VS is important for dame dev shops. That's sexist :P But yea, game devs would love that
&gt; in Rust 7.0 Is this a typo? :)
I'm confused. Why does match not allow you to fail fast? Couldn't you take every version of if x.is_err() { [failure] } and replace it with let y = match x { None =&gt; { [failure] }, Some(inner) =&gt; inner } ? Isn't that the same thing? Or are you saying that that isn't clean?
I feel it's not as clean as if result.is_err() { } do_something_useful(); 
I mean input type params to parameterized traits, not method parameters. That is, that we write `impl Add&lt;RHS&gt; for LHS` instead of Haskell-style `impl Add&lt;LHS, RHS&gt;` or, like listed as an alternative design in the RFC, `impl Add for (LHS, RHS)`.
I think it's exaggeration for effect.
OK, I guess that's a matter of opinion. Although you're leaving out the `result.unwrap()` part...
This trait doesn't mean "a slice" but "a string that can be viewed as a slice", so I don't think `Slice` is fitting. (`Str` has the same issue here.) EDIT: And searching for `as_slice` in the API docs yields many `as_slice` methods. I now think that unifying them under a single generic `AsSlice` trait may be preferable. 
It's only one line, I can easily ignore it away when scanning code.
That's correct.
&gt; to use vector3 in ray.rs, I have to edit a third file (main.rs) that in principle has nothing to do with ray.rs. This is true, but you don't have to do it this way. Check it: steve@computer:~/tmp/foo$ tree . ├── Cargo.lock ├── Cargo.toml └── src ├── main.rs └── ray ├── mod.rs └── vec3.rs 2 directories, 5 files steve@computer:~/tmp/foo$ cat src/main.rs pub mod ray; fn main() { ray::vec3::foo(); } steve@computer:~/tmp/foo$ cat src/ray/mod.rs pub mod vec3; steve@computer:~/tmp/foo$ cat src/ray/vec3.rs pub fn foo() { println!("Hello!"); } steve@computer:~/tmp/foo$ cargo run Compiling foo v0.0.1 (file:///home/steve/tmp/foo) Running `target/foo` Hello! steve@computer:~/tmp/foo$ If you want to have submodules, they need to be in a mod.rs file. So when you tried to declare `use vector3` inside of `ray.rs`, it wouldn't let you, but if you'd move it to `ray/mod.rs`, it would have.
thank you for the tip 4spaces. i changed the code display style.
Yeah, your quasi-proposal in one of these long comment threads is what I was thinking of making that post. The question about what gets existentially erased is pretty interesting to me because it's basically about the semantic meaning of the `self` parameter versus other method parameters, at least in non-inherent impls.
But then `vec3` is a submodule of `ray`. How does it work when I don’t want `vec3` to be a submodule, because it does not belong in `ray` per se? Other modules need it as well, like `geometry`. └── src ├── main.rs └── geometry | ├── mod.rs | └── ??? └── ray ├── mod.rs └── vec3.rs
You can do .ok().expect("Message") though, although displaying the original message like in Bob's example is better.
Ok, agreed - but aren't we talking basically just [`std::slice::Vector`](http://doc.rust-lang.org/std/slice/trait.Vector.html), if all the requirement is that it would have a `.as_slice()` method? It only makes sense to "unify" them somehow if we account for the difference in [`std::str::Str`](http://doc.rust-lang.org/std/str/trait.Str.html) which yields a [`&amp;'a str`](http://doc.rust-lang.org/std/str/index.html) instead of a [`&amp;'a [T]`](http://doc.rust-lang.org/std/slice/primitive.slice.html).
Right. Modules form a tree, with your `main.rs` as the 'crate root.' If you want `vec3` to be used in other places, it needs to be `use`d properly in those places: $ cat src/geometry/mod.rs use ray::vec3; pub fn bar() { vec3::foo(); } steve@computer:~/tmp/foo$ cat src/main.rs pub mod ray; pub mod geometry; fn main() { geometry::bar(); } 
&gt; How does it work when I don’t want vec3 to be a submodule, because it does not belong in ray per se? Well, if you don't want it to be a submodule, then it has to be a module, and so you'll have to declare it in `main.rs`. You can't build a tree without declaring all the branches, you know? Since `main` is your crate root, that's where you put the names of the other modules that you're making.
The first argument of [MessageBoxW](http://msdn.microsoft.com/en-us/library/windows/desktop/ms645505%28v=vs.85%29.aspx) is an `HWND` (not an `HINSTANCE`) and should be a handle to the owner window if not null. You don't have an window to start with, so you should use `std::ptr::mut_null()` instead.
woopsies!
I believe the use of whitespace around \&lt; and \&gt; would be for when you want to use them as comparison operators, not for generics.
Ah ok, I see what you're saying. This seems like much more of a bad idea then I initially thought then if we're talking about operators... Do other operators in rust require this? 
There are some other traits that has their own `as_slice` methods. I don't know if they can be modified to utilize `Vector`, or if such modifications are worthwhile. Come to think of it, maybe Rust "defines" that "A `Str`/`Vector` is anything that can be viewed as a string/vector slice", thus unsliceable `Str`/`Vector` simply doesn't exist? EDIT: Grammar. 
C# you say? That's my jam! :p The entire project seems relevant to my interests. I'll have to contribute. :)
Last time I heard about it, the answer was "not mandatory for 1.0".
Okay, I was also wondering if you would eventually wanted some error handling rather than silently ignoring (if just returning `Unused` for lines that don't parse) errors in the input file. Figuring out how to best cope with these kinds of problems in Rust without using exceptions has been interesting in my experience (for now I just abort on IO errors or bad input).
No, which is why they discussed applying it to all operators or just `&lt;` and `&gt;`.
I'm worried that the whitespace-sensitive `&lt;` rule would be seen as almost as much of a wart on the language as `::&lt;` is today. I reflexively omit whitespace for expressions in some circumstances (such as when I'm passing an expression as a function argument, eg `foo(x+100)`, `bar(x&lt;42)`). I'm sure there are many other programmers out there who have similar habits. The proposed feature would require me to *totally* unlearn these habits, or else be presented with semi-frequent, frustratingly bureaucratic error messages ("you laid out your code in a way which the compiler was too picky to deal with", essentially). It reminds me of C++03's old rule that there has to be a space between consecutive close-braces for a template argument list (eg, `vector&lt;list&lt;int&gt;&gt;` had to be `vector&lt;list&lt;int&gt; &gt;`). I'm sure it simplified compilers, but good lord did it seem silly to a casual observer. There must be a better way to get rid of `::&lt;`. Can anybody explain to me why the compiler devs are so averse to having infinite lookahead in the lexer? Would it be very bad for performance?
I agree with your 3rd edit. I absolutely hate trying to read: `for(i=0;i&lt;max;++i)` in C, it's like we are paying for horizontal space. Terse code is great, but omitting white space hurts readability I think. Therefore, a simple rule that enforces the mandatory use of whitespace around binary operators (`-+/*&lt;&gt;&lt;=&gt;=!===`) would be most welcome. Even if it is not used to reduce grammar ambiguities.
Cool, thanks for creating this. I think a lot of people neglect Windows because it feels more natural to work on OSS on Linux or OSX because of their ties to it. But I feel that the way to having a more successful language with a lot of adoption is the tooling around the operating systems it supports. I like how everyone can make their own choice on which platform they want to work on and feel more comfortable doing so. 
&gt; The proposed feature would require me to totally unlearn these habits, or else be presented with semi-frequent, frustratingly bureaucratic error messages How do you feel about how `rustfmt` will likely catch and reformat these kinds of things for you?
Unless `rustfmt` becomes obligatory, I will be very unlikely to use it. My idiosyncracies exist because they make code easier for me to read (or possibly vice-versa...), and I only write Rust code for my own use. (Of course, if I were to write Rust code in a team, my answer would be different.)
a utility to reformat code is not (imo) a proper solution to users wanting to utilize the language in a specific way, or for detecting lexical errors. And the next step becomes.. if rustfmt can figure it out, why can't the compiler?
&gt; "you laid out your code in a way which the compiler was too picky to deal with", essentially I think you're being a bit uncharitable here. Computers don't have human intellegence, and so it's not that the compiler is too picky, it's that it can't understand what you're saying. Parsing is not my strongest point, but let me try and explain it a bit more. Here's an example: (a&lt;T1,T2&gt;()) This is currently ambiguous. It can be parsed in two ways: (a &lt; T1, T2 &gt; ()) "a tuple with two elements, the result of `a &lt; T1` and the result of `T2 &gt; ()`." or (a&lt;T1,T2&gt;()) "a tuple with a single element, the reuslt of a call to function `a`, paramaterized over `T1` and `T2`. Because this is currently ambiguous, we force you to write the second as a::&lt;T1, T2&gt;() If we said "`&lt;` and `&gt;` as operators must have white space around them," (a&lt;T1,T2&gt;()) becomes unambiguous: a tuple with a single element, etc. (a &lt; T1, T2 &gt; ()) is also unambiguous: a tuple with two elements, etc. &gt; There must be a better way to get rid of ::&lt; There are multiple ways of dealing with this problem. Quoting /u/pcwalton, from the notes: &gt; C++ knows during lexing when it's a type and fixes it that way. In Java, methods aren't first-class types, so a less than can never follow a type - it can only follow a method. None of this is relevant to Rust, unfortunately. So, I think pnkfelix's approach is worth considering. I think he may or may not have mentioned one or two more things Swift?. But regardless, Patrick _has_ looked at all the other ways people resolve this ambiguity, and most of them either don't work or have additional requirements that we're not happy with. Second, while there are good reasons to avoid infinite lookahead, it's also that it's not entirely clear that infinite lookahead will help here: it's possibly geniunely ambiguous. Not sure on that one yet, we're trying to figure it out. There is a loooooong discussion from last night on `#rust-internals` about all of this: https://botbot.me/mozilla/rust-internals/2014-08-12/?msg=19629635&amp;page=5 Finally, let me just say that this is a very initial discussion. No decisions have been made. This was Felix trying to raise the issue, and get some feedback on an idea, as well as learn the history of `::&lt;`, in case his idea had already been tried and discarded before. Nobody likes the situation with `::&lt;`, but you have to explore different solutions to figure out what works best. Does that make sense?
I'm not suggesting it is, I was just asking for an opinion. &gt; if rustfmt can figure it out, why can't the compiler? It can't. My intention was more broad, about the relationship between coding habits and unlearning them, in the presence of a formatter. In this case, for example, assume that we required whitespace around all operators, and you wrote `f(a+b)'`, and `rustfmt` turned that into `f(a + b)`. What do you think? Is this a 'oh man, thank you, `rustfmt`, I always get that wrong' or a 'fuck you `rustfmt` you suck I don't want spaces there'? (I'm not sure it can in all cases, this is a thought experiment, and applies more broadly than this case.)
Resharper lets you decide where you what them actually. And I believe the default is outside the namespace but I could be wrong about that.
It's more of the second one. I think it's a self-defeating road to go down. If the formatter does it, the compiler should be able to also. Is what I was trying to say. Telling users to rely on the formatter to fix syntax discrepancies seems like a poor way to handle a syntax change since it's already been implemented one way. I understand things aren't standardized yet, but I believe this is one of those areas that's nearly uniform in a programming syntax context where it would be less beneficial to disrupt the norm. So for me it's more of a I'd shake my fist at the compiler type situation and wonder why the language couldn't 'just be smarter'
I think this stems from the issue that () is a unit value, and nothing else. If you remove this out of the equation wouldn't everything just work? To me the bigger problem is allowing (). 
Adding in arguments wouldn't fix it, I don't think. (a&lt;T1,T2&gt;(foo, bar), baz) is this (a &lt; T1, T2 &gt; (foo, bar), baz) "a tuple with three elements: `a &lt; T1`, `T2 &gt; (foo, bar)`, and `baz`" or (a&lt;T1,T2&gt;(foo, bar), baz) "A tuple with two elements, the result of a function call, `a`, which is parameterized over `T1` and `T2` and has two arguments, `foo` and `bar`, as a second element, `baz`? Plus, without `()`, you cannot get an empty tuple, which, IIRC, is distinct from the type 'unit', as well. They're just unambiguous, and written the same way.
The problem is that `&lt;` and `&gt;` are used for both less than / greater than and type parameter lists.
I believe that `20 * i + 12 * j` is less readable than `20*i + 12*j`, or more generally I think that you shouldn't force usage of whitespace in such a way.
ah right, so it's still present even with arguments, well all this advanced type-paramatarization stuff jsut makes simplifying the syntax difficult! Thanks for explaining it out.
I concur with that. Some libraries also abuse (let's pretend this abuse is legitimate) the XOR operator for exponentiation, and that just looks weird spaced out: `my_matrix^2 + identity` vs `my_matrix ^ 2 + identity`.
I'm unsure how moving to `[]` is an acceptable difference from C++'s 'lexical similarity', but requiring a space around less than is not. (Even disregarding when C++ does require you to put a space before a `&gt;`, as demonstrated elsewhere in the thread.) Can you help me understand? I guess maybe it's the 'lexical' part? &gt; D did away with them, and I don't see actual D users complaining about it. D did away with them in a way that we cannot. &gt; I really fail to see the immutability of the angle brackets. When the change to `[]` was proposed, [the original author closed it](https://github.com/rust-lang/rfcs/pull/148#issuecomment-47721690). &gt; Thanks everyone for comments on both sides of the argument. However, it's clear that it's simply too late for a syntax change without any real benefits that aren't subjective. I originally proposed the RFC because I thought we could get rid of the ambiguities, but I had forgotten about indexing; thus, the only arguments that were left were indeed subjective. The 'immutability' is due to exactly this: changing to `[]` does fix this problem, but it introduces others. Nobody who participated in that massive thread was able to adequately provide a non-subjective reason that addressed all of the issues. If you think you've found one, then please open up another RFC! &gt; it's not clear to me what exactly about `::&lt;` is so despicable? Many non-Rust users complain that Rust is very noisy, and `::&lt;` is often brought up as "Rust is basically Perl, lol." Many Rust users don't like how it looks, either. I myself don't mind `::&lt;`, but I do recognize that it bothers others, and if we can find a solution, I'd rather not have `::&lt;` than have it.
No problem. Parsers and I don't exactly get along, so I may have gotten something wrong here.
I would certainly write the second, but with parenthesis. Yay subjectivity! :/
I have the same thing happening in Scala (as compared to Java). Not sure if it is good or bad for a large project.
&gt; &gt; &gt; The rest of the syntax, on the other hand, is quite different in Rust. To that end, I really fail to see the immutability of the angle brackets. D did away with them, and I don't see actual D users complaining about it. I know depressingly many Rust users that complain about &lt;&gt;'s. They already require tons of hacks (consider the handling of &gt;&gt;). How many more hacks do we need to add until it becomes not worth it? I used to be a D user and I'm really not a fan of its template syntax here. C++, Java, C#, and Swift are all in agreement: `&lt;&gt;` is the syntax for generics.
&gt; There must be a better way to get rid of ::&lt;. Can anybody explain to me why the compiler devs are so averse to having infinite lookahead in the lexer? Would it be very bad for performance? If you have a solution (other than switching to something that isn't `&lt;&gt;` for generics), I'm all ears. Infinite lookahead doesn't even seem to solve the problem, unfortunately: `(a&lt;b, c&gt;-1)` is the nastiest case I can think of, which is totally ambiguous. (Is it a tuple of two booleans or an enum variant `None&lt;b,c&gt;` minus one? Yes, the latter is legal due to overloading…)
imagine if we could write `impl LHS : Add&lt;RHS&gt;` just so it reads better.. `lhs.add(rhs)`
I have a feeling this is going to be a problem if/when we get a realtime syntax checker as the larger the file the longer it's going to take to validate etc. Otherwise, probably not much of an issue :D
As in an IDE? Try opening libxml2 with Eclipse CDT...
Wait, you can read your Scala code the next day after you wrote it?
&gt; Lastly, it's not clear to me what exactly about `::&lt;` is so despicable? Is it that `::` is not nothing? Would some other symbol there be better? On the one hand, it's subjectively noisy and ugly, but this is, as I said, subjective. The more irritating aspects of it, to me, are: * It's inconsistent and breaks use-syntax-follows-declaration-syntax. You declare a generic type as `struct Foo&lt;T&gt;`. You use it as `Foo&lt;int&gt;`. You declare a generic function as `fn foo&lt;T&gt;(...)`. You use it as `foo&lt;int&gt;()`... er, wait. (This kind of pun/mnemonic is employed all over the place, see also tuples, etc.) * The use of `::` in particular is arbitrary and inconsistent with its meaning elsewhere (and for this reason, at least in my case, initially confusing). Sure, you can rationalize it, and say that it's kind-of-similar if you squint really hard and cross your eyes, but it's really not, and you just end up hurting your eyes.
For what it's worth, I was really bothered by how awful Rust's `::&lt;&gt;` syntax for type application is... until I reflected on the fact that Haskell does not have this feature *at all*, and they mostly get along fine. (Although they will likely gain it in the next release of GHC.)
Given that you're suggesting it, I have a feeling it'll blow eclipse up given it's java memory footprint/allocation.
Please observe rule #4.
&gt; I guess maybe it's the 'lexical' part? It is. &gt; Even disregarding when C++ does require you Did. It no longer does in C++11 via hacks. &gt; D did away with them in a way that we cannot. Only because pcwalton is against it. From the point of view of the grammar, D's solution is identical to Rust's, only tokens are different (and nicer looking). &gt; non-subjective reason I don't see why the subjective dislike of `::&lt;` requires non-subjective motivation to fix it. &gt;Many non-Rust users complain that Rust is very noisy, and `::&lt;` is often brought up as "Rust is basically Perl, lol." You make it seem like once a user gets past the syntax, there are going to fall in love with Rust. What evidence do you have that the syntax turns away more people than the borrow checker errors, `&amp;*`, the module system, `.to_string()`, indentation pyramids amongst many other annoyances that are far far more common than `::&lt;`? Maybe instead of focusing on the color of the bikeshed, you should first make sure the inside doesn't smell.
I'd be content with using a different disambiguator instead of `::` and then using it consistently. I too find the inconsistent application of it kind of strange.
&gt; It is. Thanks. I guess I care more about use and feel rather than lexical purity. Both are valid positions. &gt; Did. It no longer does in C++11 via hacks. Then there's some degree of precendent to what is proposed here. So we could fix this issue the same way C++ did. &gt; I don't see why the subjective dislike of ::&lt; requires non-subjective motivation to fix it. Because, as per the discussion above, moving to `[]` doesn't just fix the problem, it creates new ones. &gt; From the point of view of the grammar, D's solution is identical to Rust's, only tokens are different (and nicer looking). I don't know if this is true, exactly. We'd have to figure out what to do with macros, for one. Is that ambigous or not? Without a concrete proposal, we can't tell. Again, if you have a concrete proposal, please draw up an RFC. Take into account all of the issues that were brought up in the previous one. &gt; You make it seem like once a user gets past the syntax, there are going to fall in love with Rust. No, I do not. See below. &gt; What evidence do you have that the syntax turns away more people I don't. But if they go away because of the syntax, they never get to all those other things. Erlang is a wonderful language and runtime, but its adoption is hindered because of public perception of its syntax. Don't disregard ergonomics and public perception. &gt; Maybe instead of focusing on the color of the bikeshed, you should first make sure the inside doesn't smell. Please let's keep this civil?
It won't. But it also won't do syntax highlight, and it's not like libxml2 is easy to read.
Will do :|
Yes, completely agreed regarding the problems with `::&lt;`. To be clear, I don't much like significant whitespace either. But I don't see a way to avoid inconsistency *somewhere*. You pick (1) inconsistency with other C-like languages, (2) inconsistency with where `::` is needed, or (3) inconsistency with whitespace rules. Every choice is a tradeoff. My reasoning behind wanting to investigate (3) is that at least it wins in aesthetics for those used to C-family languages.
Me too -- I actually used Parsec in one of my previous [projects](http://limpet.net/mbrubeck/2009/10/30/compleat.html) several years ago. Combinator libraries seem to work best in languages with Haskell-, ML-, or Forth-like syntax, though.
(Yes, my personal preference right now might be for (3) as well. But I don't have a good sense of how bad the drawback would be.)
Not to mention (at least) most US students get VS's most expensive version free of charge 
Never heard of this before - Looks incredible (in terms of graphics and in terms of ease to code and even it's simplicity), I'd love to see this in Rust (Assuming theres a good OpenGL and SDL Binding *Not sure of their status - i'm still pretty new here*)
In an ideal world, I would prefer (3) extended for all binary operators. But alas, we don't live in that world. Instead, people don't always put whitespace before and after binary operators, and making an exception for one operator is uglier than adding a disambiguating operator.
I'd argue that it's `^` being abused as XOR instead of exponentiation. Sure, XOR is slightly more common in code, but the common person reads n^2 as squaring n. Of course, we also have `**` as an option for exponentiation, which is preferred, but that still leaves `^` with XOR being weird.
Yes, you do. This is by design.
&gt; So we could fix this issue the same way C++ did. It requires mixing parsing and type-checking. It's a non-starter. &gt; it creates new ones. No, it doesn't. It just doesn't solve the fundamental ambiguity problem, and the only reason to prefer `::[` (yes, with the `::`, it's in the RFC) to `::&lt;` is purely because the former subjectively looks nicer. The RFC was closed by the author because of this, not because it somehow made things worse. &gt; Again, if you have a concrete proposal, please draw up an RFC. Take into account all of the issues that were brought up in the previous one. There is absolutely no chance any RFC that changes the syntax away from `&lt;&gt;` will get accepted. There is a core member of the team that is strongly opposed to any changes in this direction, and no RFC has ever got merged under these conditions. It's straightforward to come up with an unambiguous grammar for type parameters, but it won't look like C++'s fundamentally ambiguous choice (i.e. `let a = None&lt;T&gt;`). &gt; I don't. But if they go away because of the syntax, they never get to all those other things. So if 1% is turned away by the syntax, but then 50% drop out because of deeper issues it's still a reason to focus on the syntax? &gt; Erlang is a wonderful language and runtime, but its adoption is hindered because of public perception of its syntax. Erlang's syntax issues are pervasive, while `::&lt;` is not. There are 1088 instances (outside of tests) in the rustc distribution (out of 313K lines of code). In Servo there are 62 instances (out of 55K lines of code). In the totality of my code there are 55 instances (out of 23K lines of code). Just don't use it often in the guide you're writing, and there won't be an issue.
Note that a bunch of traits are in the [prelude](http://doc.rust-lang.org/std/prelude/), and so they are "used" by default, which is why you don't need to add your own `use` line to call their methods.
Since the blog post I've added basic error handling on parsing failures with. I haven't dealt with IO errors yet though. https://github.com/PudgePacket/Rusticle/blob/master/src/main.rs
Incidentally after reflecting on Haskell's lack of any explicit type application syntax at all (not even a bad one like `::&lt; &gt;`), I remembered why Rust uses it so often:^1 it's because we don't have type ascription yet. E.g. instead of `transmute(foo): TargetType`, we have to write `transmute::&lt;FromType, TargetType&gt;(foo)`. So once we *do* gain type ascription, that'll mean even fewer cases you need to write `::&lt;`. ^1 Often relative to Haskell, which again, doesn't even have the feature.
Is there an idiomatic reason why much of the functionality (ie arithmetic, dot product) was put directly in the impl, but more was put in a trait in the same file? It could be a personal preference of the library creator, but i'm curious if this is a common/encouraged practice.
cgmath isn't perfectly designed, but we try to keep things that *can* be generic, generic.
&gt; If you change the spec slightly to avoid all of the comparisons you can go from O(n2) to O(n). Would you mind elaborating? &gt; An easy speedup I can see is taking all your instances of Vec&lt;Vec&lt;f64&gt;&gt; and replacing them with Struct {data: Vec&lt;64&gt;, shape: Vec&lt;uint&gt;}. That's unnecessary complexity, since that 2D vector is basically guaranteed to be rectangular. I can do exactly like `ImageBuf` in `rust-image`, with a width and height and calculate the index into the packed vector. 
Looks like I misunderstood the code. It initially defines a "Vector" trait and define most operations there, then creates a macro that defines fields and methods that differ between different vector sizes, and finally defines the EuclideanVector trait to add still more functionality to the vectors. It looks like the structure here is too nuanced to ask this kind of open question about. This does lead to another question though: Why don't I need to use the Vector trait before I can use the arithmetic operators? They're defined inside the Vector trait, but I can call them without having to use Vector up above.
Ah! No worries, code with macros especially can be hard to follow. There is a module called the 'prelude', which is imported into every Rust program: http://doc.rust-lang.org/std/prelude/index.html You can actually see this happen by using the `--pretty=expanded` flag to `rustc`. Take 'hello world', and then `rustc filename.rs --pretty=expanded`. You'll get something that starts with this: #![feature(phase)] #![no_std] #![feature(globs)] #[phase(plugin, link)] extern crate std = "std"; extern crate rt = "native"; use std::prelude::*; fn main() { See that `use`? It `use`s the entire `std::prelude`. Which, if you check the link above, does a bunch of `pub use` statements. (this is what http://www.reddit.com/r/rust/comments/2dhyx3/beginners_question_do_i_always_have_to_use_a/cjpo96s was talking about)
So, if I understand correctly: I can write code with overloaded operators from Vector without having to use anything, because of the prelude, but a library writer still has to define them so that the compiler knows to use them? But it seems like they're defined more than once, they're defined in the Vector trait and then again inside the macro.
&gt; C++, Java, C#, and Swift are all in agreement: `&lt;&gt;` is the syntax for generics. Each language copied it from its predecessor; It's not like they all independently arrived at `&lt;&gt;` as the optimal syntax. (Not that there's anything inherently wrong with choosing familiarity)
&gt; I can write code with overloaded operators from Vector without having to use anything, because of the prelude, Yes. &gt; a library writer still has to define them so that the compiler knows to use them? Rust is written in Rust, so someone has to define _all_ of it. :) &gt; But it seems like they're defined more than once, they're defined in the Vector trait and then again inside the macro. You mean the bit that starts here: https://github.com/bjz/cgmath-rs/blob/master/src/vector.rs#L114-L124 vs the bit that starts here? https://github.com/bjz/cgmath-rs/blob/master/src/vector.rs#L184-L205 Well, the first part defines the trait: see how they're just the type signatures? The macro actually _implements_ the trait, see how the functions have bodies? Then the calls to the macros actually do the defining https://github.com/bjz/cgmath-rs/blob/master/src/vector.rs#L353-L355
Wait, can enums have struct variants? When did this happen?
`#![feature(struct_variants)]` :)
Thanks.
If you want to, you can produce unreadable code in any language. If you want to, you can produce readable code in any language that supports comments.
By-value closures will make these libraries a great deal easier to implement. Most of the parser combinator libraries were abandoned with the removal of `fn@` closures. (eg. https://github.com/jesse99/rparse)
Operator overloading could help here.
Awesome, thanks. I'll try to optimize this.
Eclipse CDT has a configurable file size limit, set by default to 5000 lines of code. It won't syntax highlight files over that limit for performance reasons (Since C has all this preprocessor shenanigans, syntax highlighting large files is a really tricky business). You can of course increase the limit if you're so inclined.
Scala has more readable generics...
It’s been there at least as far back as I’ve been using Rust, which is over a year.
There already is [a project to add Rust support in IDEA](https://github.com/Vektah/idea-rust). It's very basic at the moment, but there is a complete parser implementation, so syntax highlighting, setting breakpoints, formatting (buggy) and structure view (in [my branch](https://github.com/jesnor/idea-rust)) works. I'll try to get compiling and running from within IDEA to get working next, however I'm new to IDEA plugin development so I'm learning as I go. :)
I last touched Scala 3 years ago. I wasn't impressed. That is all.
`unwrap` now does that by default though, so `unwrap_or_else(fail!)` is redundant.
FWIW I think that `::&lt;` is fine as it is. I fear that meaningful whitespace will end up causing unnecessary confusion.
1. This is speculation on my part, but I would assume what's happening here is that something else (possibly in the standard library, or hard-coded into the rust compiler) is causing it to link against `User32` anyway, and removing the need to actually specify it yourself (though you probably *should* specify it yourself for people reading your code). 2. As noted by chuckguy55, `stdcall` is the calling convention used for the Windows API. What they said about setting up/tearing down stack frames is also true, however there's another important detail: the calling convention *changes the function's name*. The standard C calling convention on Windows, if I remember correctly, prepends an underscore; `GetModuleHandleW` would get stored in the library as `_GetModuleHandleW`. `stdcall`, on the other hand, *appends the size of the arguments on the stack*, which would cause it to be internally called `GetModuleHandleW@4` (or something similar). Thus, if you don't specify the calling convention correctly, even if you link against the correct library, the linker won't be able to find the function because it will look under the *wrong name*. 3. No idea. You're probably screwed. :P I assume that the `#[link...]` annotation is just a note to the linker that it needs to link against a particular library, but doesn't cause it to actually *look in that library for the annotated symbols*. I could be wrong about that, though I've never seen a language that did direct linking that way (manual dynamic linking is another matter entirely, though).
To add to this, the python style guide [PEP 8](http://legacy.python.org/dev/peps/pep-0008/) suggests you use the second style. I think it's a fairly common thing to do as well and definitely makes it easier to read
I'm not familiar with imagebuf, is that contiguous in memory? Hashmap. When you fail to insert a duplicate item you deal with your duplicates.
Fascinating article. I can't wait for the rest of the series. How far are you going to go with this? Are you planning on covering (basic) layout? Rendering? I maintain the UI module in a game engine at work, and the way it works is a lot like a (very) crappy and (extremely) limited browser. Since inheriting it, I've wondered how an actual browser would be implemented (but haven't had the time to dive into servo, and real browsers are far too large). I hope you keep up the series!
Well, I might have missed it but there is still the (unlikely for many reasons, I know) possibility of changing the operators to keywords (like `gt`/`gte`) or (`morethan`/`atleast`). But as I said, highly unlikely :)
This is cool, although [converting `query_range` to an iterator](https://github.com/reem/rust-n-tree/pull/1) gave a large speed-up, by avoiding doing multiple allocations for each layer ([here](https://github.com/reem/rust-n-tree/blob/b196771ad85e11b0869c72f3fb1df2548ddcf6e4/src/lib.rs#L113), [here](https://github.com/reem/rust-n-tree/blob/b196771ad85e11b0869c72f3fb1df2548ddcf6e4/src/lib.rs#L115) and [here](https://github.com/reem/rust-n-tree/blob/b196771ad85e11b0869c72f3fb1df2548ddcf6e4/src/lib.rs#L118), although those could be reduced (not eliminated), e.g. using [`retain`](http://doc.rust-lang.org/master/collections/vec/struct.Vec.html#method.retain) instead of `move_iter().filter().collect()`). My iterator version also does the minimum number (1) of `contains` checks per point, while the current `query_range` checks every point *p* `O(depth(p))` times.
`Result.expect` doesn't exist.
1K + downloads.. cool. Btw.. does it work with Android Studio?
C++ is famously awkward to split 'afterwards' because of the need for header files. Maybe Rust's module system is easier to deal with if you start splitting into files earlier? (the fact you don't have to maintain headers separately should make that easier?) I seem to find that rust can still be quite awkward to retroactively split , because that makes compulsory new namespaces for everything and you have to go back and use individual symbols. The circular glob-import problem seems to work against creating a lot of common context. I like the suggestion of 'inherit use..'. in C++ #pragma once/guards can let you create a graph of includes, whilst with rust you can't do something similar with glob uses'.. at some point you have to micromanage individual symbols 
I only have this problem with Haskell. It is sometimes hard to read a Haskell program that I wrote months before. My Scala code is much easier for me to read than most other languages. In fact, it's *too* readable. A part of my brain feels unused when I program in Scala and not in C++, I feel there is an addiction to complex things.
Meant `unwrap`, fixed.
Can you really match something without the match keyword or is this a typo? (Referring to parse_rule()) Quirks like this, ie returning without a return statement still throw me off sometimes but I think I am getting use to it. Edit: I really like your consume_while method and how flexible it is. I'm writing a lexer and I'm not satisfied with how I keep ending up with nested matches in terms of longterm maintainability. Do you mind if I use the same fn or something similar? Will give credit too :)
On the flip side, I find that it's very easy to split the library into many files and tests into logical files using cargo. So far just using one public module, but it contains reexports from all my private submodules (files).
Is this some kind of Haskell joke? If not, it should be.
&gt; A library using failure for error handling is unlikely to see much adoption Well then such a library can't implement `Index`. But for sure, for all the reasons listed, the library user should be able to choose to use fail-free APIs as far as possible, but there are always different cases. Even in C you don't *always* need to think about performance for every line -- doing so would often be premature.
`::&lt;` [*also*](http://www.reddit.com/r/rust/comments/2dfi4t/weeklymeetings20140812_generalizing_object_type/cjpfrfp) causes confusion. I'm not necessarily disagreeing with your value judgment on the matter, it's just not the case that meaningful whitespace would be confusing while the current situation is not confusing. We're choosing the lesser evil out of different confusions.
&gt; code is cleaner if we do away with all the negative stuff with a single if at the head of the method fn something(x: Option&lt;int&gt;) { let x = match x { Some(val) =&gt; val, None =&gt; return }; // do something with x } But yeah, there could be syntactic sugar for some common cases of matching.
Yes, I've always found the bitwise operations (`^`, `&amp;`, `|`, `~`, `&lt;&lt;` and `&gt;&gt;`) not to be worth their operators. They just occur too rarely.
http://www.piston.rs/docs/rust-image/image/struct.ImageBuf.html Internally, it uses a 1D vector to represent 2D image data, using arithmetic to index into it two-dimensionally. The problem with a Hashmap is I don't just need to find duplicates. I need to find nearest-neighbors based on the `ImageHash.dist_ratio(&amp;ImageHash)` function. I spent a couple hours last night trying to think of how to do that in less than `O(n^2)` but I haven't come up with any good solutions yet. In truth, `O(n^2)` is only the worst-case performance, where every image is unique. I'd say the average is closer to `O(n log n)`. Absolute best-case is actually constant-time, where all images are duplicates of a single image. 
Approximating isn't necessary, because we want to exhaustively find all nearest neighbors, not just the best guess for one. Accumulating into a tree would be a good start. Then we can use the nearest-neighbor search algorithm for a k-d tree. That discards half of the tree on each iteration. That would necessitate writing a custom tree implementation because the trees in the collections crate don't give us the right querying methods.
The reason why `parse_args` feels clunky is because you shouldn't use `Option` but `Result`. The result could also carry the error/usage-message as it's Err-flavor. Furthermore you should not set the return code trice and more importantly not in some helper function (you could do that at the match in main where you also return). Never write functions that have funky side-effects. The name `parse_args` suggests that it merely parses the arguments and not that it quits the program or updates some global state. I never did much Ruby, but this is probably also not very idiomatic in Ruby. I guess you would raise an exception and handle it in `main`.
As a first comment, you can find the current style guide here: http://aturon.github.io/ Eventually, there will be a tool, `rustfmt`, that will re-format your code to fit many of these guidelines, though obviously, that only does some of it.
If you make your main file `main.rs` instead of `code-generator`, these lines: https://github.com/robmiller/code-generator/blob/master/Cargo.toml#L7-L9 go away. As a bonus, you can `cargo run`! 
Package names should be identifiers, so this package and the executable (and files) should be named `code_generator`, not `code-generator`.
Use four spaces instead of tabs.
&gt; there's no way to exit in Rust There is! I... don't remember it right now. O_O. But, instead of using `parse_args`, consider using http://doc.rust-lang.org/getopts/index.html or, if you're really feeling adventurous, https://github.com/docopt/docopt.rs
A few random remarks: For generating the random letters and numbers you could use [`rng.choose`](http://doc.rust-lang.org/std/rand/trait.Rng.html#tymethod.choose). If you want to improve efficiency, you could use [`String::with_capacity`](http://doc.rust-lang.org/std/string/struct.String.html#method.with_capacity) instead of `String::new`. `parse_args` looks fine in principle, however I think you should move `os::set_exit_status(1)` and the usage prints to `main` into the match before the return. This would also reduce code duplication. You are using quite a few redundant type annotations, I'm not sure whether this is intentional. A simplified (but untested) `parse_args` could look like this: fn parse_args() -&gt; (Option&lt;uint&gt;, Option&lt;String&gt;) { let args = os::args(); if args.len() &lt; 3 { return (None, None); } let num_codes: Option&lt;uint&gt; = from_str(args[1].as_slice().trim()); let code_format = if args[2].as_slice().len() &lt; 1 { None } else { Some(args[2]) }; (num_codes, code_format) } I think this here can be simplified from let mut code: String; code = codes::generate_code(code_format.as_slice()); to let code = codes::generate_code(code_format.as_slice());
https://github.com/robmiller/code-generator/blob/master/src/codes.rs#L4-L14 You'll be happy to hear that `inject` exists in Rust, it's just called `fold`. It would look _something_ like let code = code_format.chars().fold(String::new(), {|code, character| let random_char = match character { 'B' =&gt; random_letter(), '1' =&gt; random_number(), other_char =&gt; other_char }; s.append(random_char); } I just wrote that out, didn't test it ;)
Well, there's https://github.com/kevinmehall/rust-peg at least.
The only way I know is unsafe and uses libc.
http://doc.rust-lang.org/std/os/fn.set_exit_status.html &lt;- what I was thinking of. I think these docs are old, as we don't have 'supervised' tasks anymore...
What about let code: String = code_format.chars().map(|character| match character { 'B' =&gt; random_letter(), '1' =&gt; random_number(), other_char =&gt; other_char } ).collect(); 
That works too, and is probably a bit more clear, depending. I like it.
Can I voice disagreement with your multi-comment style? It inflates the comment count by a huge margin, and its much easier for me to parse just a markdown list. I somewhat get the argument that when people reply, they reply to the specific point, but i really hate clicking on a rust thread with 14 comments and have most of them top level comments by the same person, its quite aggravating. But thank you for all the code reviews.
I've also noticed that I often want to use all the symbols from another module, but have to specify them individually. So far, in small projects it's been a very inconvenience, but I agree it would be nice to have the ability.
BTW, passing `-C relocation-model=dynamic-no-pic` option to `rustc` (as explained in that PR) helps, but it is impossible to do it with Cargo, so it is not a real workaround.
This is what the OP uses and it does not exit. I was thinking of [this](http://doc.rust-lang.org/libc/funcs/c95/stdlib/ffi.exit.html) unsafe libc function. You could also exit "task-wise" using `fail!`, but that does not necessarily exit the program.
Right. Good call.
On https://github.com/robmiller/code-generator/blob/523b1da164bebfa16746cc9cd0e3e3364ffe1766/src/code-generator.rs#L60 I was thinking you can avoid the `!existing_codes.contains(&amp;code)` check by checking the value returned from `existing_codes.insert(code.clone());`. `insert` returns true if the value was not already present in the set.
It does not alway make sense IMHO. I think a*x + b*y + c*z is a lot more readable than a * x + b * y + c * z And this is a rather harmless example. On the other hand, I can't think of an example where I would want to not have spaces around a comparison operator.
Also at https://github.com/robmiller/code-generator/blob/523b1da164bebfa16746cc9cd0e3e3364ffe1766/src/code-generator.rs#L97-L104 Looks like you want to perform some action if the value of the `Option` is `None`, so maybe [or_else](http://doc.rust-lang.org/std/option/type.Option.html#method.or_else) would be a better fit here?
`rustfmt` should be useful for de-obfuscation and code pasted from somewhere else (indentation is usually wrong after copy/pasting something). Here is an example line from a script on the gmail page: ```(function(){try{var d=this,e=function $e$(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&amp;&amp;"undefined"!=typeof a.splice&amp;&amp;"undefined"!=typeof a.propertyIsEnumerable&amp;&amp;!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&amp;&amp;"undefined"!=typeof a.propertyIsEnumerable&amp;&amp;!a.propertyIsEnumerable("call"))return"function"}else return"null";``` Finding min test cases on code like this without pretty-print is difficult. This probably won't be as common in Rust though.
I have no idea what to do about this, but I'm glad you asked... maybe somebody here can help out. Little I know; I don't even understand why PIC comes up at all in static-linking, which is exclusively how I'm using the C lib. (if you do come up with something, plz add an issue on the github page for me)
Why not use tuples? What exactly do you want to do?
If `,` is ambiguous in `(a&lt;T1,T2&gt;())`, why not make a stronger *Generics comma:* `,,` for only when the distinction is needed? So `&lt;T1, T2&gt; == &lt;T1,, T2&gt;`; but `(T1, T2) != (T1,, T2)` because `,,` is only for generics. You have all these: : =&gt; :: . =&gt; .. =&gt; ... / =&gt; // + =&gt; ++ - =&gt; -- * =&gt; ** &gt; =&gt; &gt;&gt; &lt; =&gt; &lt;&lt; &amp; =&gt; &amp;&amp; | =&gt; || = =&gt; == Note: `...` is from [range! macro](http://discuss.rust-lang.org/t/a-range-macro/377) `// and **` are from python `++/--` from C++ [EDIT] `a&lt;T1,, T2&gt;()` may be better than `a::&lt;T1, T2&gt;()`...
In that case, I'd have a math!() macro. ;)
A quick google search tells me that there are ~40 status codes. At this size, you could honestly probably get away with a slice like `[(int, Whatever), ..40]`. It can even be sorted for binary searches, if you want, although I'm unsure if it'll be worth it at that size. Otherwise TrieMap and HashMap would both work here. You'd have to test your precise workload to see what works best. TreeMap (note: different from TrieMap!) probably is wasteful for such a small set, and SmallIntMap probably isn't appropriate due to the sparsity of the codes.
What exactly do you mean by “store HTTP status codes”? You might find http://chrismorgan.info/blog/teepee-design-status-line-take-two.html and http://www.rust-ci.org/teepee/teepee/doc/httpcommon/status/type.StatusCode.html of interest.
There are 500 possible HTTP status codes. Most are never used, but that’s irrelevant. (Of course, it depends a little on what your purpose is; the ones that are not defined do not have an associated canonical reason phrase.)
It shows up consistently, everywhere, for everyone. Four was chosen because the traditional eight leads to lots of rightward drift. (I personally prefer two spaces, but some people think that's too shallow.)
This has also been an issue when compiling GLFW from source: https://github.com/bjz/glfw-rs/issues/90 hannobraum thinks the PR to blame is https://github.com/rust-lang/rust/pull/16340 It seems to be an issue related to i686 and something about security. Ask in #rust-internals (link in the sidebar ---&gt;)
It's both a false trichotomy and a subjective evaluation of which evil is lesser. You could remove your first confusion by requring `::&lt;` everywhere where type parameters are expected, and the second by picking a different symbol for `::`. It'd be the status quo (being somewhat inconsistent with other C++ descendands) without any other drawbacks.
Thanks for taking the time to make this change!
Definitely seems that [#16340](https://github.com/rust-lang/rust/pull/16340) caused the breakage, and I guess I can sort of see the point of that PR... apps that use libraries, which may somehow be vulnerable to exploits, should protect themselves. So I guess that's the new thing, require -fPIC on dependency libs? Don't know how that'll fly in the long run... safer, but I'd've got laid a lot less if I'd walked away when there wasn't a condom handy. That may or may not have been better. So does Rust now not support linking to arbitrary C libraries without a recompile? Anyway. I'm pushing a '-fPIC' mod and hopefully that'll fix it; find out as soon as I can figure why bjz's gl-rs is breaking at the moment.
Ahh, interesting. I should have tried it with an `Option` type instead of `()` in the post.
I meant "we're choosing which evil is lesser", not "we're currently choosing the evil that's lesser". &gt; It'd be the status quo (being somewhat inconsistent with other C++ descendands) without any other drawbacks. Other than being even noisier and uglier, yeah. Especially given that the feature is uncommonly used and should be even more uncommon in the future, it doesn't feel like it would be worth it. Do you have any concrete ideas for a replacement for `::`? The few I tried brainstorming seemed even more repulsive.
Let binary code with hex `0x0` be represented by `0` and `0x1` represented by `00` and so forth then a program written in this language maps directly to the binary (the number of 0s is the same number as the binary file is in hex) I don't care if you have comments, "this compiles to 105382604096378406374067340683049680348680 zeroes which is helloworld.exe" will never be understandable
[This](https://github.com/sfackler/rust-phf) fits pretty well the requirement of an immutable list of key-value pairs
This is actually an LLVM problem. Some optimization pass generates a load for the Result struct in the unwrap() code. The discriminant is then extracted using extractvalue, and LLVM apparently can't see that this value is the same as the one that's used in is_ok() (where it was fetched using getelementptr + load). Modifying the resulting IR to use getelementptr + load in both places allows LLVM to remove the failure path. The resulting IR and assembly still differs a bit between match and unwrap, but I have no idea which is faster, if any.
If I had to choose right now, I'd choose `~`, `-` or `.` in that order. I particularly enjoy `~` because it makes generics look fishy: fn test~&lt;T: Add~&lt;T, T&gt;&gt;() -&gt; Option~&lt;T&gt; { None~&lt;T&gt; }
I'm not sure what you are looking for, but here's a simple way to create a static list of things and search them using tuples: http://is.gd/uvBwcY
What I can't get over is that accepting `(Variant&lt;T, T&gt; - 1)` is considered a good outcome of this entire project. My brain parser does a double take at code that even though I personally follow that spacing style in my code and have been for many years (and I was gracious and used realistic, but worst-case scenario identifiers... `(a&lt;b, c&gt; - 1)` is completely jarring).
&gt; Edit: I mean, you could accept them, sure, but there's nothing you would ever map them to. The spec says that if you don't recognize a specific code, you treat it as a X00 code.
I've started it, but I can't finish it. Windows is not my native platform, but I wanted to see what I could whip up in a few days. I'm totally lost in this and it takes me many hours to do basically anything, which is very discouraging. I'm hoping someone who knows more than I will pick this up and carry it forward. This preview only has basic token-based syntax highlighting and "smart" indentation (but will not de-indent on closing brace...).
One reason to prefer `map(...).collect()` for Vec is that a reasonably smart compiler should be able to figure out that the resulting vector is the same size as the one your started with, then do the allocation once and fill it, avoiding even the check for resize. This doesn't work in general for string though, because a single char can be a variable number of utf-8 bytes.
&gt; The question is, do we have to compile ALL dependencies which are static libraries with PIC flag? Or maybe I don't understand something? Unless you plan on disabling ASLR, you need to build all static libraries as position independent code with `-fPIE`. You only need `-fPIC` if they're also going to be used within dynamic libraries.
That would be a problem with Cargo, not Rust. The solution is to build code with `-fPIE` so that it supports position independent executables. Disabling ASLR with `-C relocation-model=dynamic-no-pic` will work, but that's not much of a solution.
&gt; apps that use libraries, which may somehow be vulnerable to exploits, should protect themselves. Memory corruption bugs like buffer overflows are trivial to exploit without ASLR. It can be a bug in any `unsafe` block (in your code or a Rust library), a compiler bug or a bug in a C library. &gt; So does Rust now not support linking to arbitrary C libraries without a recompile? It still supports linking to arbitrary C libraries. If the static library wasn't built with support for ASLR (`-fPIE`) then it either has to be rebuilt or you need to disable ASLR with `-C relocation-model=dynamic-no-pic` (not recommended).
&gt; I don't even understand why PIC comes up at all in static-linking, which is exclusively how I'm using the C lib. ASLR requires the ability to relocate the code in the executable, and Rust is enabling it by default. You can get away with `-fPIE` rather than `-fPIC`, which avoids paying a performance cost for thread-local storage.