Honestly you should probably just post your code - the real version of it, not the explaination. 
&gt; (ie. Stuff where it's not really a code invariant but actually an assumption about the input or execution context which can unexpectedly tank my program unless I treat panics like exceptions and prepare to catch them.) OK, hmm, then this I agree with. Looks like I just misunderstood your advice then!
Does it use https://github.com/google/xi-editor as backend? If no, who is faster?
I was being stupid and pretending there are more problems than there really are. I'm just going to do what you said and put the duplicated code into a function. Thank you for your time and expertise, it really helped me out
source code under 1000 lines. that's all. one man's small editor. you can modify this editor to super fast. performance is not my main interest. 
- added read.exe binary (~4MB). (done) - my main purpose is done, writing my own editor. (done) - more adventure into editor world. (todo) 
&gt; Are you new to Rust? Quite, I only start playing with it 7 years ago. &gt; They have extensive unit testing for this type of thing. I doubt gcc doesn't have extensive unit testing, though I admit I only contributed to Clang and never checked in depth. I also have never seen anything like crater for GCC or Clang, although it is obviously limited to open-source code which may not exhibit all the "weirdness" of proprietary code. I am afraid this does not prevent bugs from slipping in, though. The fact that the 1.26.x a .1 and a .2 releases, and there is still talk about a .3 release due the issue of default match bindings, certainly highlights that no process is perfect. Testing has, after all, never proven the absence of bugs. &gt; I work in industry and am aware of the issues we're talking about. We've hit compiler bugs and linker bugs several times. I've also coded for embedded applications (realtime linux vehicle controls, c++) and an embedded system (bare metal, c) on a cubesat. Then you should know better than most that upgrading a toolchain is not *that* easy, so why offhandedly recommend to "simply" upgrade it? Or was it intended to be sarcastic?
I wonder how `#![no_std]` and `#![no_main]` crates will work in Rust 2018 edition. Will I still have to opt in into for example the alloc component? Take this snippet: ```rust #![no_std] #[macro_use] extern crate alloc; ``` How will it be translated, to be Rust 2018 compatible?
Fair enough. In the case of goblin, I consider it `panic!` abuse because I believe that unexpected input should never cause a parser to panic.
Thank you. That's been an incredibly helpful reference for me, both for finding cool stuff and for finding real projects to examine/learn from.
Not making promises right now. 
Just the no_std part. You’d “use” any macros you need from alloc.
Unstable, partial support - only supports move closures with singLe lifetime inputs.
Yeah I think this is an oversight; I wrote this up based on the RFCs, then things changed a bit. /u/aturon edited this section, maybe he missed tweaking this part?
There are 8 mutexes which are used everywhere, but the application is single threaded, so I feel like this is not the best design choice. It feels like a C code that was ported as is, without adding any abstractions. I think a slightly better way would be to group your variables in one or two structs, convert most of the functions to methods, and pass a raw pointer to a struct in your window_proc function. Also it's generally a good idea to try separate safe and unsafe code, to keep unsafe blocks small and easy to review.
I recently discovered `ethaddrgen` and while looking over the (very nice!) code I discovered a pattern I had not yet seen in rust - Lifetimes tied to a `loop`. Can someone point out to me what it does and maybe provide a link to additional information? Example: [https://github.com/Limeth/ethaddrgen/blob/master/src/main.rs](https://github.com/Limeth/ethaddrgen/blob/master/src/main.rs) thread::spawn(move || 'dance: loop { thread::sleep(Duration::from_secs(1)); { let result_guard = result.read().unwrap(); if let Some(_) = *result_guard { break 'dance; } } let mut buffer = buffer_writer.lock().unwrap().buffer(); let iterations_per_second = context.iterations_this_second.swap(0, Ordering::Relaxed); cprint!(quiet, buffer, Color::Cyan, "{}", iterations_per_second); cprintln!(quiet, buffer, Color::White, " addresses / second"); *sync_buffer.lock().unwrap() = Some(buffer); });
I personally highly dislike the change from `pub(crate)` to just `crate`. IMO it's not clear at all what "crate" is supposed to mean, the `pub(crate)` or `pub(in module)` syntax was at least consistent with the usual `pub`. I mean, if I just ask you "what does the word 'crate' mean" vs "what does the word 'pub(crate)' mean", you immediately know that the second one is a visibility restriction, while in the first it depends on the context. I feel that this is syntax sugar going in the wrong direction. Other than that, the module improvements look good.
Thank you!
I'm using it already, but it does not do the syntax highlighting.
`to_string()` is provided by the [`ToString`](https://doc.rust-lang.org/nightly/std/string/trait.ToString.html) trait, which has a generic `impl&lt;T&gt; ToString for T where T: Display + ?Sized`, and `f64` implements `Display`.
Hi Steve, Maybe I misunderstood something. By rolling you mean that if I target rust 2018 edition a client that has a older version of a compiler that has 2018 edition support, but no support for async/await might not be able to compile the code? 
I would guess that since `f64` is `[Display](https://doc.rust-lang.org/nightly/std/fmt/trait.Display.html)`, it automatically gets a `[ToString](https://doc.rust-lang.org/std/string/trait.ToString.html)` implementation, which is where you get `to_string()` from. Documentation doesn't highlight generic implementations, unfortunately.
`to_string` is implemented by the trait [`std::string::ToString`](https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string). If you look there, it says that `to_string` is impl'ed for all types `T` implementing `Display`. If you now look at the documentation for `f64` you'll see that `f64` implements `Display`. That being said: I would also love to know if there is a way to discover all traits which are indirectly implemented for a type.
I'm not sure you were downvoted. This is much, much clearer than `rust`/`edition`. Maybe `language-edition` would be better just to keep the terminology.
Sorry, I'm having trouble following: Looking through the documentation, I found a section called "Trait Implementations", which lists `Display`, `Default`, `LowerExp`, and several others. Clicking the link for Display leads me to here - https://doc.rust-lang.org/nightly/std/fmt/trait.Display.html Looking through this page, although I see Display is implemented for String, I do not see ToString is implemented for Display. How do you route to f64 to ToString? In general, is there a way to list *all* functions available, inherited or not?
I didn't understand, how do you get to `ToString` from `Display`?
&gt; I would also love to know if there is a way to discover all traits which are indirectly implemented for a type. Yes! Exactly, that's what I'm trying to do. Starting from `ToString`, you can find that it is in `Display`, but I don't see how to get to `ToString` from `Display`.
`rustdoc` does not display traits with blanket impls in the "implemented traits" list. This is tracked [here](https://github.com/rust-lang/rust/issues/33772), and [Doxidize](https://github.com/steveklabnik/doxidize), the eventual successor to `rustdoc`, does support it.
You mean through documentation? You can't. I just knew that `ToString` existed, so I looked at [its documentation](https://doc.rust-lang.org/std/string/trait.ToString.html), and found a blanket implementation for all types that implement `Display`: impl&lt;T&gt; ToString for T where T: Display + ?Sized Unfortunately, rust's documentation system isn't perfect in this regard, and you don't see this implementation (or any other blanket implementation) anywhere else. This is a shortcoming of the documentation.
Not sure if this is exactly what you wanted, but I decided to take a stab at the problem. fn main() { let obj = Obj { data: 5, call: Box::new(|x| println!("callback was given {}", x)) }; obj.msg(); } struct Obj { data: i32, call: Box&lt;Fn(i32)&gt;, } impl Obj { fn msg(self) { (self.call)(self.data); } } 
I don't blame you for not having seen this; as far as I can tell, this is *almost* totally undocumented in the second edition of the book. Good thing the [first edition explains loop labels](https://doc.rust-lang.org/book/first-edition/loops.html#loop-labels). The one mention I could find in the second edition was the following in the appendix on "operators": &gt; `:` (`'a: loop {...}`): loop label. There's no link to more information. Here's the entry in the first edition: &gt; `'ident`: named lifetime or loop label. See [Lifetimes](https://doc.rust-lang.org/book/first-edition/lifetimes.html), [Loops (Loops Labels)](https://doc.rust-lang.org/book/first-edition/loops.html#loop-labels).
Sometimes you panic where you could use error handling because it gets the job done. Error handling can be added layer. &gt; First make it work, then make it work well!
I see. In that case, it there a way to get rust to print out all of the functions available for an object?
&gt; I'd want it written something like `Regex::new(...).expect("string literal is valid regex")` &gt; That way, if it breaks, there's information on what the intended invariant was when the code was originally written, which can help to inform the decision about what corrective action to take. (eg. maybe it got switched from a local literal to a `const`and then to a loaded-from-config-file `static` over the lifetime of the program) So you are hoping that if someone will change the source of the regex they will forget to update the string in `expect`?
Set a panic hook that prompts the user to email you the panic info. Use `unwrap()` when it makes sense to you to get emailed when that code panics in production.
It sill will. Don’t forget you’d import such things now with “use crate::”, so there’s symmetry.
That’s correct.
I'm saying it should be how `cfg` works. Or a macro could interpret the syntax to lisp style. 
&gt; Note that Actor model introduce some latency as you use channels and send messages around The alternative to sending messages is using locks, which introduces contention and blocking, and therefore suffers from its own latency issues. Regardless, you are right that sending messages from one Actor to another via a channel introduces overhead. From experience, I'd expect a well-tuned MPSC queue to introduce at least 100ns overhead. Therefore, I would recommend to both use channels, and use them sparingly. The less exchanges between Actors are necessary, the better.
Kudos to the Rust team and contributors. Y’all are amazing. 
Have a look at: \* [https://github.com/dtolnay/reflect](https://github.com/dtolnay/reflect) \* [https://github.com/simonask/rust-reflect](https://github.com/simonask/rust-reflect)
I just want to go to sleep and wake up when async/await is done
This is a rustdoc bug: [https://github.com/rust-lang/rust/issues/33772](https://github.com/rust-lang/rust/issues/33772)
Nice! This was the blocker for me, so I'm ready to give it another try.
[Related question on StackOverflow](https://stackoverflow.com/questions/46084968/how-can-i-convert-a-float-to-string/46085066)
Who do I throw money at to make this a thing sooner? :)
Rust currently doesn’t support run-time reflection so getting all the functions associated with a type wouldn’t be possible. But the documentation is extensive covering the static, instance, and traits implemented on a type each with a link to the source code. [Here’s the docs for `u16`](https://doc.rust-lang.org/stable/std/primitive.u16.html) 
Nightly dist is kicked off at midnight UTC using the latest commit on master, and takes a few hours to finish. You can find the code for the cron job at [rust-central-station](https://github.com/rust-lang/rust-central-station). See `promote-release` for more rules about whether or not nightly is built. Look at the crontab for timing for other release channels.
&gt; I also have never seen anything like crater for GCC Typically during the GCC release cycle, Red Hat and SUSE will rebuild the distro with the new compiler, analyze the failures, and fix the resulting bugs. 
Nice idea, but it wouldn't be required if the documentation worked properly. 
Actually... I tried to remove it and it seems nothing gets changed. And it turns out that the whole mod containing that unsafe is unused at all, so I've submitted a PR to just remove it :)
For a top-level "script" perhaps. Over 20+ years I've been programming I have had a lot of experience both burning out from trying to be to perfectionist and getting burned by following "make it work, then make it work well" and then losing track of what I needed to come back to, so I've developed a system for avoiding that. For panics in Rust, it boils down to: 1. Whenever I can, let error-chain be my "easy thing I intend to replace later" rather than `expect`. (In the case of a library, I'm going to rewrite it anyway, it's better to change from one kind of monadic error handling to another.) 2. When I write something that can panic, like integer division, and I can't be 100% certain that it cannot panic in practice, given the amount of thought I'm willing to spend on it at the time, write a `FIXME: audit panic` comment on it. 3. If I determine that something which is technically capable of panicking cannot panic in practice, annotate it and anything responsible for enforcing that promise (eg. function's type signature) with explanatory comments. 4. **Never** publish a crate before all `FIXME: audit panic` comments have been resolved. As mentioned, I'm considering "ensure all calls to 3rd-party crates happen within a `catch_unwind`" to make up for others not being this thorough.
Do you know what cases those might be?
If someone non-malicious changes the source of the regex, they'll change it to something that they believe is a valid regex, so they won't want to change the `expect` message.
This is one of the things that the [Rust Language Server](https://github.com/rust-lang-nursery/rls) is designed to do.
Also, if the literal is defined in a `const` far from the `expect` and then it gets changed to a `static` that's loaded from a config file, then the first occurrence of failure will display a message that helps to remind that the failure-handling strategy was not updated to account for dynamic data and needs to be reworked.
I like this strategy, you can always use string errors from failure/Error-chain in the short term
I specifically always try to `expect("internal error: ...")` or `panic("internal error: ...")` in production code. That way if a consumer of my code sees the crash, they know it's not anything they did wrong. If I can't write that message in good faith, then the panic doesn't belong in a production crate.
I'm not sure how other people feel about this, but for me if you call an API entry point in my crate in a way that explicitly violates a documented precondition or input invariant, it's OK for my crate to panic. Type systems are not powerful enough to statically restrict every possible misuse of code, and returning an error in this case is probably useless anyhow, inasmuch as whoever called the function wrong is also going to have no idea what to do with the error.
[`hyper`](https://hyper.rs/) is pretty popular. 
No screenshots?
Yes, take my money too pls
They will want to change the "literal" part. The way I see it, the whole point of using `expect` here is to convey that when the code created it used a literal string, and thus it makes no sense to bubble the error up because an error is a local bug. If someone would have change it to get the pattern from a config file or from user input, the `expect` will still have the word "literal" in it which would indicate the reason for electing to panic instead of bubbling the error.
Just out of curiosity, what do you think of Teras -&gt; https://github.com/Keats/tera I'll definitely have a look at cobalt. 
Ah! This certainly qualifies as equivalent to crater given the size of the distributions. Do you know if the equivalent also exists for Clang?
Is there a way for the compiler to tell me if i have code in the same scope as a locked mutex that can panic? I imagine this would help prevent poison errors.
Reading the "Macro changes" section in the guide, it wasn't clear to me whether `std::println!("hello")` will be possible. But [it works](https://play.rust-lang.org/?gist=9668daab24deabe909a25c267f2713c3&amp;version=nightly&amp;mode=debug). Nice! Much more consistent.
I don't understand what happens if my crate contains both a `baz` function and a `baz!` macro. Is this OK? Was it ever OK? In a world where `macro_use` is supposed to be replaced by `use` how do I specify both? One or or the other?
No idea, but interesting question
Note that compile-time reflection would be sufficient here: get the functions at the compile-time, print them at run-time.
 use po8::baz; This will import both the function and the macro. I believe there is currently no way to import one but not the other.
It supports move and non-move async blocks, async fn with single lifetime inputs, move async closures, and non-move async closures without arguments. There are limitations for sure, and I'm excited to have them fixed, but practically speaking you can express anything you'd want in terms of async blocks, so this gives you full expressiveness.
&gt; Oh, and also `b!`, `static_record!` and a myriad more... this is cluttering literally all my files now This is something that `slog` would need to fix. In its definition of `info!` it will need to replace invocations of `static_record!` etc with `$crate::static_record!`. We are currently working on a way that `slog` could accomplish the same thing without dropping support for all previous compilers.
&gt; rust-fix didn't help in the slightest here! As mentioned in the announcement, rustfix is far from being ready; let's hope it gets better as the release of the edition nears! &gt; use slog::{ Drain, Logger, log, info, record, }; &gt; Oh, and also `b!`, `static_record!` and a myriad more... this is cluttering literally all my files now (yes, I like to log, blame me)! Is there any specific reason you are not using blob import, aka `use slog::*;`?
Well `pub` and `crate` are for completely different things. One is visibility control, the other one is for specifying from where to import things. Previously visibility control had one (main) keyword: `pub`. Now there's two of them, `pub` and `crate`. In `use` statements, `crate` makes sense because you want to control from where to import types. But controlling visibility has nothing to do with importing. It's a reuse of the keyword, but it's not symmetry - and all that just to save typing 5 extra characters... not a good tradeoff IMO. I sadly didn't know that this RFC had this proposal otherwise I might've voiced my concerns earlier. I guess I can live with it, but I don't really like it and I'll stick to `pub(crate)`. 
Yeah I noticed that if a macro uses other macros, you have to `use` those manually as well. Very confusing.
Has some nice features though the API is geared towards static site generators / HTML. I'm not sure what people's reasons were but I heard negative reactions to tera from some other Rust devs. I've brought up the idea of need for a de factor standard template language in Rust for things like cargo init from templates, stager, etc and I got some negative reaction based on their perception of Tera. I didn't explore to much but it seemed liquid's ability to customize what language features are available seemed to warm them up the the idea.
&gt; I'll definitely have a look at cobalt. Also, as an FYI, cobalt might look like it is stagnating. That is because I've temporarily shifted my focus over to the CLI Working Group. Trying get to 1.0 on assert_fs, assert_cmd, stager, cargo-tarball ASAP.
If your constructor returns a `Result`, what is the code that's trying to construct one of these things going to do? I think if you're writing a library you don't have the necessary context and should probably bubble up errors very often. If you're writing a complete executable, you can know if being unable to create a PRNG means you might as well just crash quickly.
For now, there's nothing – we don't even have a working panic detector in clippy (as far as I know) yet, but we could possibly write one. Hooking this up to the scope of a Mutex would be the easy part.
&gt; sweet summer child I agree with your overall point, but please try to be respectful to others. Condescending remarks like this make it harder to have productive conversations.
That's what `rustdoc` is _supposed_ to do. It's a longstanding bug that it doesn't include `to_string`.
Yeah! I've been reverse engineering the original for a while now, love that game! Trying just to get more of the python version complete, but I'm having such a blast writing bits of it in rust.
Whoa! That's valid Rust? It seems so counter-intuitive but at the same time logical. I though thought you could only ones type parameters in `impl` blocks at the places they are used in the declarations of the affected types.
&gt; Do you know if the equivalent also exists for Clang? No idea, sorry.
Great, long waited feature.
Is this based on Corrode? I feel like I would've heard of a massive effort like this while it was in progress if it were all-new work, so I'm skeptical... but it would be interesting.
This work is separate from the good work of Corrode. This project uses a different approach of using Clang to parse, pre-process, and type-check the input C code. At the beginning of the project we talked with Jamey Sharp, the author of Corrode, about the challenges and lessons learned working on Corrode.
wow, so this is really impressive then. I'm definitely interested to see how he work like this can go! for a team wanting to start refactoring C code to Rust, something like this tackling the low hanging fruit would be really helpful.
&gt; For one thing, there have been backwards-incompatible changes in rustc. Can you link to one? I am not aware of any.
I'll be looking forward to this. I've never felt the use of using await on my futures. But then again, I have no C# and JavaScript background. Coming from Scala I am used to futures though, so it will be interesting how `async/await` "feels" to me :)
I had the same idea for a panic detector, it might be my next project (But even if it is don't expect it soon).
RIIR all the things! ...but really, it would be fantastic to be able to port serious ubiquitous software like Sqlite with a tool like this.
I had the same idea for a panic detector. It might be my next project.
Once you get the hang of writing asynchronous code exactly like synchronous code, you'll go back and wonder how you ever wrote anything else. Resumable functions are infinitely easier to design, write, read, and debug, compared to equivalent code based on state machines, or callbacks, or etc.
Apologize for my ignorance but that means that `await` doesn't block like the one I am used to for the similar named method on futures from Scala? Then that sound even more intriguing :)
The joke is that in a way, c2rust is a riir of corrode
It blocks the control flow of the current function, but it doesn't block the thread (it yields such that the thread can be used for processing other futures while it waits for data). IMO the best thing about using async/await over futures is things like loops. Doing an async while loop with futures is a nightmare, but with async/await is just works. With rust I think borrowing over await points will also be a big plus.
Will futures become unnecessary when async/await is in rust?
rustup installation with terminal: $curl https://sh.rustup.rs -sSf | sh asks for manual entering a number. 1 is default installation. Can i programmaticaly execute the default installation?
I didn't follow the RFC process, but couldn't the `!` syntax be used to disambiguate macros and other kinds of items in use statements? e.g. `use {po8::baz, po8::baz!};`. Or is macro invocation also valid inside a use statement?
To be fair it sounds like it's half RII&lt;Production C++ Library via Rust FFI&gt;
The opposite, I think. Some part of Futures will move into the std lib.
Correct. The function is paused on the line where the await happened, and control is returned to the caller. The caller can then do other things. Later on, the caller can resume the function when the resource it was waiting on is ready, and inside the function, execution picks up at the await line where it left off, with all local variables etc intact.
When does LLVM get the RIIR treatment? Seriously, anyone sneakily started it?
Cretonne maybe in the long run. For now it's a backend meant primarily for wasm.
You're very welcome to try to fix the issue. Any help is very welcome. :)
This 2018 shit is bullshit
This has been my feeling for more than a year.
No, but they won't suck to work with and maintain, like they do now.
Not really worth it
This is really cool. The result obviously isn't idiomatic or safe rust, and I understand it would be nearly-if-not impossible to accomplish that. Would the result here lend itself to gradual refactoring to idiomatic code? It seems like the dependency on c types would make this difficult.
&gt; It seems like the dependency on c types would make this difficult. It happily translates from C structs to Rust structs (give it a try). The primitive types are all the same `libc::c_int` is just `i32` on non-exotic platforms, and so on, so it's easy to switch those over. Translating from "C pointer based Vec" to "Rust Vec" obviouly takes some work, but I don't see any issue with doing it one type at a time.
may be of interest, if you haven't seen it already: https://www.youtube.com/watch?v=qr9GTTST_Dk
Ah, thanks for the explanation. I’m not very familiar with C or C++, and always wanted to try my hand at rewriting something in Rust to get a better understanding of the former. I’m considering Dear IMGUI since it’s entirely self-contained. 
Ah that's nice
Unfortunately, I excluded some important details in my question, so this is not enough in my situation. I had a discussion with u/K900_ above your comment about what exactly I need. Still, it runs fine and exactly matches what I wrote in my question, so thanks for taking your time :)
Great write up and explanation.
async/await are implement on top of futures much like `?` is implemented on top of `Result`. This is the same approach taken by C# and JavaScript if you’re familiar with async/await in those languages. There will likely be a decreased need to use bare `Future`s but certain operations to e.g. compose futures will still need to operate on them directly. 
What if it was first compiled to WASM? https://github.com/CryZe/wasm-to-rust - [sqlite](https://mobile.twitter.com/CryZe107/status/975105633316896768) - [lua](https://mobile.twitter.com/CryZe107/status/974800532253626369) - [Go](https://mobile.twitter.com/CryZe107/status/979759289890942976) 
isn't there something like "CTAGS" for rust that can be supported in a repl though?
That sounds pretty cool. I'll have to read more about it!
&gt; https://github.com/rust-lang/rust/issues/33772 The last thing on this link is saying that there's a "new rustdoc" which may or may not handle this, but is the place to fix this. But there are no links to it and a quick google search doesn't find anything.
If I'm using a crate, is there a way to either find other crates that use that crate, or projects on Github that use that crate? For some crates I'm interested in finding examples of that crate being used.
Thank you for curating this collection. It's been a great resource for me while trying to learn Rust.
I have the following code: ```rust struct Lazy&lt;T, F&gt; where F: Fn() -&gt; T { calc: F, val: Option&lt;T&gt;, } impl&lt;T, F&gt; Lazy&lt;T, F&gt; where F: Fn() -&gt; T { fn new(calc: F) -&gt; Self { Lazy { calc, val: None } } fn get(&amp;mut self) -&gt; &amp;T { match self.val { Some(ref x) =&gt; x, None =&gt; { let val = (self.calc)(); self.val = Some(val); self.val.as_ref().unwrap() }, } } } fn main() { let mut thing = Lazy::new(|| { println!("called"); 3 * 5 }); println!("begin"); // does print 'called' println!("fst = {}", thing.get()); // does not print 'called' println!("snd = {}", thing.get()); } ``` Which pretty much works the way I want it to. I wonder, is there a way to avoid using `unwrap` in `get`? Though I can see it's definitely a Some (let's not think about concurrency or whatever for now), I wonder if there's a more idiomatic solution. Something like this: ```rust let val = (self.calc)(); let b = &amp;val; self.val = Some(val); b ``` doesn't work because you can't borrow and then move into a new var, and ```rust let val = (self.calc)(); self.val = Some(val); &amp;val ``` doesn't work because you can't move and then borrow from the old var. This ```rust let val = (self.calc)(); self.val = Some(val); &amp;self.val.unwrap() ``` doesn't work because you're moving out of `self.val`, then returning (also, it still uses `unwrap` anyway). And this ```rust let val = (self.calc)(); self.val = Some(val); self.get() ``` _does_ work, but it feels a bit weird to make a recursive call here. Any suggestions? Even if not, I'd be grateful if someone could confirm that my understanding of why most of the alternatives I presented don't work, or if there are other suggestions. 
On crates.io, you can see dependent crates. [Here's][1] an example. [1]: https://crates.io/crates/tokio/reverse_dependencies
I have a WASM to Rust compiler (so you can do C -&gt; WASM -&gt; Rust) and it produces 100% safe code (as WASM itself is 100%). I've successfully corroded sqlite, Lua and musl's libm with it (+ some Go, Kotlin, ...). So you can totally turn unsafe C into safe Rust.
This might work: ```bash curl https://sh.rustup.rs -sSf | sh -s -- -y ``` More [here][1]. [1]: https://github.com/rust-lang-nursery/rustup.rs/#other-installation-methods
Thanks. That's very handy!
How does one easily implement a loop structure with tokio/futures? This is what I've always struggled with when writing Tokio code. 
Sorry, rust noob here, how would you fix the code example given? How do we recreate while its values are borrowed?
You can use CTAGs with Rust.
Care to share how you went about it? I’ve recently become involved in the development of Gotham and it feels like it needs some touching up in regards to speed (but beyond that, there’s little out there about gauging performance for Rust).
It's similar to how you can import a type and a value of the same name from a single use import.
I quote https://rust-lang-nursery.github.io/edition-guide/editions/index.html : &gt; The Rust compiler can link crates of any editions together. Therefore, if you're using Rust 2015, and one of your dependencies uses Rust 2018, it all works just fine. The opposite situation works as well. It seems the definition of 'just fine' that is being used here is rather misleading, if dependencies must update so they are 'Rust 2018' ready.
They already have, in order to support this PR. (They’re in core too)
Merged! Thanks for the PR!
``` struct A { a: u64, b: u64, c: u64, } fn x(xa : A) { let p = &amp;xa as *const A; println!("addr2: {:p}", p) } fn main() { let ma = A { a: 1, b: 2, c: 3, }; let p = &amp;ma as *const A; println!("addr: {:p}", p); x(ma); } ``` Hi, C programmer question: when Rust does the move from `ma` to `xa` above, does it do a shallow copy? Does it actually copy 24bytes for that, or does it just pass a pointer? I am asking about how it is actually implemented. 
What do you mean by loop structure? If you mean like async for loop, if you're operating on a stream, there is `Stream::for_each` which is probably the easiest. But manually isn't that bad either: while let Some(item) = try_ready!(self.rx.poll()) { // Use item... }
The slog crate will continue to offer its existing API (`#[macro_use] extern crate slog`) without any code change in slog or crates depending on it. The owners of slog can elect to support a different, advantageous API (`use slog::info`) at their convenience.
My methodology was pretty straightforward -- first and foremost I wanted to identify what portion was taking longest. I noticed that the route matching was _by far_ the most intense part of the response. From there, I tried to reduce branching logic and use HashMaps as much as possible in order to match the route. Originally the route matching was implemented using a single HashMap, where Thruster would match each piece of a route and concat the results together to get the final combination of middleware. This would happen trying to match both exactly and with a wildcard route for each piece, which ended up making a lot of possible branches. What I switched to was a simple tree, where each node has a wildcard option. The wildcard option is matched if none of the children match (also referenced by HashMaps,) That change actually sped up Thruster by about 20-30%! Still looking for more performance improvements like that, I know they're out there ;)
All moves in rust are semantically shallow bit copies of the value. The optimiser can choose to use a pointer for arguments, or not move a value at all if it wants to.
Thanks. Follow up question: what is better when I want to transfer ownership into a function? Box the struct or just move as a value? Is there any penalty if I just pass structs “by value”. I. In C it would be a no-no. 
I can't answer that. The optimiser will use a pointer behind the scenes if it thinks that will be faster. Also keep in mind that forcibly boxing stuff could potentially ruin *other* optimisations. The general advice is to just pass by value if those are the semantics you want, and let the optimiser worry about it. If profiling reveals it's slow, override it at that point.
Thanks!
Just ran it through the same suite of tests from the readme and got: ``` 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 35.99ms 117.25ms 1.20s 96.99% Req/Sec 1.85k 263.08 2.67k 91.73% 631065 requests in 30.04s, 53.56MB read Socket errors: connect 0, read 413, write 0, timeout 0 Requests/sec: 21010.43 Transfer/sec: 1.78MB ``` Whereas the rust frameworks (Actix, Hyper, and of course Thruster,) were all above 50k Requests/sec. It does seem to be the fastest _python_ based framework, but doesn't really compare to a compiled language framework. That being said, I haven't really touched python in around 5 years, so I could be doing something horribly wrong as far as a "prod env" build would be concerned.
I've heard that before but, as someone with a heavy UI/UX focus, I'm very skeptical of the value of the phrase "internal error" in conveying that. My experience has been that an end user won't recognize the significance of the error being "inside some unspecified thing", so it winds up just being an incantation, not backed up by HCI research, which adds extra clutter when I'm reading the code.
Now compile that to WASM.
How would you construct it, even given a Default impl?
Unless the LLVM developers decide that’s something they want to do, then that would be a fork, and then it would need to be maintained separately.
No, compile it to brainfuck.
Had a quick play with this, good first effort! Noticed a couple of bugs: 1. After the editor starts, the first keystroke is always ignored. 2. After I dragged-n-dropped a file into the editor, I couldn't edit the dropped text. I could only append new text. And like /u/pftbest says, it best to keep your unsafe code separate - maybe a whole other module.
Wrong sub ... this is for the programming language called rust. I forgot what the rust game sub is called sorry 😩
Ideally it is impossible to express bugs like that - where, for example, forgetting to call A before B causes a runtime error. But yeah, in some cases it's not ergonomic or worthwhile - for example, sometimes you may call 'init' as the first line in your code. And if you don't, panics later. Usually this sort of bug is going to be caught immediately.
&gt; it would be fantastic to be able to port serious ubiquitous software like Sqlite with a tool like this. Honestly, of all software that would be the last program that I'd care to see in rust, as their C is actually verified (the resultant binary, btw, not the source, so it's probably _more_ correct now than it would be in rust).
This is the sub for the rust programming language. You want /r/playrust
You want /r/playrust
&gt;My friend was banned from Rusty Moose 2x accelerated server and was accused of having an alt account with multiple vac bans. Their reasoning behind this was because someone on his friends list had multiple vac bans that used a piece of his name. Now there probably isn't much that anyone can do about it here but I do want the community to be aware of this. This was not his account nor is it even linked to his account. Below are pictures of the conversation between himself and Wojak (one of the Admins). This all comes after my friends and I joked about changing our names to all be the same. With this reasoning if one of them cheated we could all end up banned. &gt; &gt;https://gyazo.com/eab9f29c150cb926cf8428efdeda98f6 &gt; &gt;https://gyazo.com/e84981f32753d84ae1a03b65d6247d57 lol sorry. Thanks though =D
Really neat! Is it possible to translate unsafe code into safe code automatically?
Created a repository of some of this suff! https://github.com/brendanzab/rust-visitors
If there is someone brave and smart enough please post a working example using async/await and async TCP socket (either listener or client).
It might not be too easy. The `Future`s in `std` have a different API from those in the `futures` crate, so `tokio` and every other crate using futures will have to be updated.
Basically I want to iterate over multiple streams, in the order that they come in. In particular, I want to wait for a `future::sync::mpsc` channel and a `TcpFramed` at the same time. 
Thanks for the link to that thread, I wasn't aware. And... yes, I suppose it might not be the perfect tool for the job, but I know Rust better than I know Erlang or Elixir, and AFAIK Rust is certainly _capable_ of performance in the same ballpark, if only with a bit of extra work to establish a similar foundation. 
Thanks for the explanation. I take it that in the non-`SyncArbiter` case, the actors will not block each other?
Tools that can help human to refactor unsafe-&gt; safe, yes. To do that automatically, I don’t think so. Because if that’s possible, we wouldn’t have Rust to begin with, since that tool could make C just as safe. 
You can do this: use std::io::{stdin, stdout, Read, Write}; fn pause() { let mut stdout = stdout(); stdout.write(b"Press Enter to continue...").unwrap(); stdout.flush().unwrap(); stdin().read(&amp;mut [0]).unwrap(); } fn main() { pause(); println!("Hello, world!"); } 
Well regular actors may act in the same way as future. I.e. you have various handlers that are executed during event loop poll, so if you keep your code short and simple(as with futures) they will not block too much. Note that current actix uses tokio's current thread event loop, if I'm not mistaken
&gt;use std::io::{stdin, stdout, Read, Write}; fn pause() { let mut stdout = stdout(); stdout.write(b"Press Enter to continue...").unwrap(); stdout.flush().unwrap(); stdin().read(&amp;mut \[0\]).unwrap(); } Perfect thank you!
This seems to be a bug if it happens in non-upgraded crates, can you file something with an example?
&gt; Well, except that I now have to re-import everything with the new syntax (rust-fix didn't help in the slightest here) Please file a bug on the rust repo with examples of things rustfix isn't helping with. This is why there's a preview, so that we can find these bugs.
/r/playrust
I wonder if this could be a easy way to pinpoint runtime memory errors in C code by checking the translation for rust compilation errors.
Wrong sub. You want /r/playrust
You've posted to /r/playrust before, you should know this is the wrong subreddit.
To elaborate a bit, Pause is a Windows command and in c when you do system("pause") it executes that command. (Same as if you would type it in a cmd window). The function written above basically re-creates that behavior but in a cross platform way. It prints the message then reads a line from the user
Also, `system('pause')` is equivalent to opening up a `cmd.exe` console and typing `pause`. It's an ugly hack and only works on Windows because the `pause` command only exists on Windows. Here's a rough C++ equivalent to that Rust code for you: #include &lt;iostream&gt; int main() { std::cout &lt;&lt; "Press Enter to continue... "; std::cout.flush(); std::cin.get(); }
Ha thanks you guys must get this a lot. 
You can set breakpoints in an editor that supports debugging. Visual Studio code should and clion has inegrated debugger. A lot easier than manually placing pause everywhere.
True but there's many things in C that are safe. For example in C code where you know pointers don't alias.
BEAM's concurrency model could only be implemented inside a VM, and for agent/message based concurrency it's unbeatable. I don't know if it's right for you, but if you want to copy Erlang you need to roll out your own VM and catch up to about 30 years of engineering and real-world use. If Rust already has decent libraries for actor-based systems(?), it should be more than adequate for most things, though, especially if you're already familiar with the language.
It seems that my results are complete garbage, but I don't understand why. Python simply cannot outperform highly optimized Rust servers... What is your OS/kernel version?
I haven't really been following the discussion around these changes, but am I misguided to think that `extern crate module;` made the codes more readable than directly using `use module::function;`. Maybe I am just being sensitive to change here.
What errors would you check for here?
I see [this is already being addressed](https://github.com/rust-lang/rust/issues/35896#issuecomment-394553992) in the tracking issue.
Shit
I don't think this is possible without unwrap. After the assignment you immediately lose the information that it is `Some`, and therefore will need unwrapping anyway. And you can't get a reference before assigning, because you will need to move the value and construct a fresh new `Option` for assignment. And regarding your comment about concurrency: because you have `&amp;mut self` you are guaranteed that no one else can modify, or even inspect `self`. At the point where you unwrap it's definitely Some, even when you think about concurrency.
Since I was referring to matching the behaviour of the Rust `unwrap`s, I'll interpret your question as "What are the `unwrap`s checking for?" In this situation, probably just "something closed the other end of stdout/stdin".
Before, `extern crate module;` helped to draw attention to when the code was reaching across crate boundaries. Now, `use` always expects an absolute path (with `use crate::...` being the new syntax for explicitly relative paths), so it's easy to see where things come from.)
That assumes the goal isn't to pause as part of normal operation. For example, a simple tool which uses `cmd.exe` as its output and doesn't want the window to close before the user has had a chance to read the output.
Yes. Also, the edition isn't something you particularly "target" as a dependency; since dependencies on older editions compile fine. You need to target the compiler version.
&gt;I sadly didn't know that this RFC had this proposal otherwise I might've voiced my concerns earlier Pretty much every concern ever was voiced there :) All of this is the decision taking all of the concerns into account.
I might be the only one here who pronounces it "amper stir" 
&gt;C2Rust: translate C into Rust code (I'm part of the C2Rust project.) The website doesn't demo this capability but one of the other tools we provide is the ability to instrument and run the C code alongside the translated Rust code. We cross check the two code bases at the function level to make sure they compute the same values by default. This can be relaxed as the Rust code is refactored. More here: [https://github.com/immunant/c2rust/blob/master/docs/cross-check-config.md](https://github.com/immunant/c2rust/blob/master/docs/cross-check-config.md)
The problem isn't that the code is wrong (it is) but that the match ergonomics are preventing the compiler from giving a more meaningful (and more helpful) error message. You're right, it is being borrowed, but the error message isn't saying that that's the problem because the type checker is running before the borrow checker and thus it's pointing at the wrong location as the source of the error.
No, it was rustdoc2 at the time. A new rustdoc based on RLS. doxidize is another version but it won't come out before a (very?) long time. If you want to try to fix it now, it'd be very awesome.
&gt;* any non-std trait is obviously absent. Locally created docs using `cargo doc` should at least help with that one, covering traits from all crates your project is using.
How is performance like? If it's only around 1.5x of C (like I've often seen quoted for WASM) that sounds like a pretty good deal for safely embedding C libraries. A shame that FFI without memcpy becomes hard, though.
Like this: fn get(&amp;mut self) -&gt; &amp;T { self.val.get_or_insert_with(&amp;self.calc) } 
Wouldn't you want to call `pause()` at the end of the program, so you can see the printed output?
That's just an example. It's up to you when you want to call it. 
`await await;`
I'm really hyped about Rust 2018! I'm especially exited about the changes to the module system. That part always felt a bit 'alien' to me. I also hope that clippy makes it into the edition. It's a great hand-hold for simplifying your code. However... I'm a bit wary about the community splitting into a Rust 2015 and Rust 2018 camp. Just like the switch from Python 2 to Python 3. I think the majority has migrated to Python 3 already, but it was devastating for the community. How will the Rust board ensure that this won't happen?
I'm on simple OSX core i7 processor, no extra optimizations :-) At the end of the day, a static compiled language without garbage collection should be more performant than a dynamic interpreted language, it's just less overhead! (Ignoring run time optimizations and such.) It's also important to remember that perf isn't everything. Although my goal for thruster is to be performant and ergonomic, it likely won't be able to achieve the ergonomics of something written in NodeJS simply because of rust's stricter syntax. Some developers will value speed, some will value ease of use, some will value that it's in a language shared with the rest of their stack.
Maybe whitelisting can also be done at the unsafe section level. You then can decide to only review modified sections. A community database would be interesting too.
I am deeply sorry about it being perceived as condescending; I thought it appropriate to introduce my reply in a gentle way, and I had not realized such a connotation.
No, I use bindgen from commandline, because I can't use it in code. When I try to use it with `extern crate bindgen;` I get the 'can't find crate bindgen' error.
Any reason not to use `print!("Press enter...")`?
Oh yes, `u16` will be present on the *trait* documentation itself. But this means that finding all methods usable from `u16` requires scanning *all* documentation, not just the `u16` page. Of course, this is not different from scanning for free functions taking `u16` as a first parameter.
Is [CS4414: Operating systems](http://rust-class.org/index.html) still a good source for learning about an OS using Rust? It seems outdated and not maintained.
Not really. I just wanted to have an stdout handle around to explicitly flush it. 
Oh right, I guess `print!` doesn't flush either.
I've tried to do this with a (few) nontrivial C project(s) in the past with Corrode, e.g. https://github.com/oxidizers/drdns Never actually completed such a swallow-a-whale conversion, but here's the basic process I was following with the Corrode output: - Refactor code into Rust modules and use the Rust module system - Remove `extern "C"` declarations and use (unsafe) Rust functions - (Along with the above) use the `libc` crate in lieu of `extern "C"` invocations of libc functions - Replace literal "zero value" struct initializations with `mem::zeroed`, or an appropriate `::new`-style constructor - Replace pointers with references/slices - Replace `malloc` and `free` calls with `Vec` and appropriate lifetimes - Replace calls to `libc` or code in the project which overlaps with `std` with calls to the appropriate `std` facilities In the process of doing all of the above, you'll start to see all sorts of places where `unsafe` can be gradually removed. It's a hell of a lot of work though, even with a small project.
Someone wrote a create pretty similar to that idea. Should work well for a CLI application: https://github.com/yoshuawuyts/human-panic/blob/master/README.md
I strongly disagree with the idea of adding options (such as Haskell's extensions) to define various "accepted" subsets of Rust. Imagine a world where each crate author defines its own accepted subset of Rust; it would be a nightmare to try and contribute to crates with vastly different subsets! Idioms and lessons in one crate would not be transferable to another, good habits would be impossible to develop, ... One such option, in isolation, would not be the end of the world, but it would start us on a very slippery slope! So, much like with style guides, I'd rather go against my own preferences and stick to a common definition; I'll argue for my preferences before the decision is made, certainly, but if the community goes against me, so be it. It may not be optimal, but consistency has advantages of its own, as Java has proven over time.
And I find that branches in a closure in processing a stream or chaining futures is difficult because you have to return a single return type when they `impl Future`, so you have to do a bit of type aliasing since all those impls are different types. But with async await you can side step that. However last time I used async blocks in nightly I got a compiler error so I hope it’s more stable now. 
Can we expect C++ support from this tool any time in the future, or is that out of the scope of this project?
I'll need to patch the message to fit with my "Never share e-mail addresses. Point people at a purpose-built contact form." policy but it looks great otherwise. Thanks. :)
I've tried the C++ code from the talk. It doesn't segfault. It just fails to print anything. Why is that? I used just a simple `g++ main.c` to compile it. #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() { std::vector&lt;std::string&gt; v; v.push_back("Hello, "); std::string &amp;x = v[0]; v.push_back(" world!"); std::cout &lt;&lt; x; } 
Try doing this and setting your vector capacity to 1 before the push back. Also, this may not always segfault.
`string &amp;x = v[0];` is the problem. He either meant `string* x = &amp;(v[0]);` or `string x = v[0];`
Good to see Rust getting some industry adoption.
If you make it a pointer the `cout` is going to print the address of the string, not the contents, and copying the string out would make the program defined (at least as far as I can tell). Note that the program is supposed to be a demonstration of undefined behaviour: It can behave in *any* way, if it happens to segfault it's just fine, if it prints nothing it's just fine, if it deletes every file on your hard drive it's just fine - at least as far as the standard is concerned.
&gt; Why is that? Because it _may or may not_ be undefined behaviour. `push_back` _may_ reallocate only if `v.capacity() == v.size()`. Depending on the implementation, `v.push_back("Hello, ")` may increase `v`'s capacity to `N`, where `N &gt; 1`. If that's the case, then `v.push_back(" world!")` won't reallocate and therefore `x` is still a valid reference. However, if `v`'s second `push_back` had to reallocate, you'll end up with an invalid reference and undefined behaviour, which may or may not lead to a segfault (most likely) or other erroneous behaviour.
Neither. He deliberately want to create a reference, not a pointer or a copy.
Right, that makes sense. I was answering why it wasn't printing, but didn't check the context of the example.
This is typical with undefined behavior. It could have any outcome. A very interesting discussion about undefined behavior in C/C++ can be found in this blog https://blog.regehr.org/archives/213 
Flushing std::cout is not necessary. It's due to the UB.
It won’t be a real thing for a long long time.
"It works on my machine..." ;)
1.21.1, I believe, immediately fixed a soundness hole in 1.21.0, which was a breaking change, as the API changed.
Was that for something that was added in 1.21.0?
Yes. There have been a bunch of other small things too, that’s just the most obvious, simplest example.
That’s interesting, because I’m pretty sure Gotham is the same (route matching is the longest). How did you measure? Valgrind?
Great talk, I think this is one of the most eloquent introductions to Rust's ownership and borrowing system I have seen.
It is undefined behavior, always. Undefined behavior is not synonymous with "crash" it just means that anything can happen. So undefined behavior might work exactly as you expect. But it's not guaranteed to. It also might order pizza.
&gt; `Regex::new(...).expect("string literal is valid regex")` Expect is really horribly named because the "polarity" of the error message is wrong. If that ever fails, it will fail with `panicked at: 'string literal is valid regex'` which is exactly what did not occur.
&gt; It also might order pizza. We should add a feature to the compilers. On the other hand, I'd probably die after a single day.
The pun was actually unintentional and only occurred to me hours later.
A nice takeaway for Rust: &gt; Personally I find it very interesting that the same technique on rustc, the Rust compiler, only found 8 bugs in a couple of weeks of fuzzing, and not a single one of them was an actual segfault. And I look forward to this follow-up: &gt; For rustc, I will write a more detailed blog post about how to set it up, as compiling rustc itself with AFL instrumentation is non-trivial and it makes more sense to detail those exact steps apart from this post.
&gt; Just like the switch from Python 2 to Python 3. The switch from Python 2 to Python 3 created a schism in the community for one simple reason: Python 2 and Python 3 libraries are incompatible, so the switch has to be atomic. Switching a codebase from Python 2 to Python 3 was a horrendous choice: - It takes effort to switch, but it's necessary to use the new features and follow the ecosystem, - Unfortunately switching means barring oneself from using Python 2 modules, and while reviewing your current dependencies is easy enough, it's unclear which *future* dependencies you will require and whether they switched. In the end, it becomes a game of chicken: you wish for the rest of the ecosystem to switch before you do, so you do not suffer from the switch, but this every wait (of many) is what is holding back the ecosystem from switching. A very uncomfortable situation for all involved, to say the least. &gt; How will the Rust board ensure that this won't happen? By avoiding incompatibility and allow gradual conversion. From the [Edition Guide: What are Editions?](https://rust-lang-nursery.github.io/edition-guide/editions/index.html): &gt; #Compatibility &gt; When a new edition becomes available in the compiler, crates must explicitly opt in to it to take full advantage. This opt in enables editions to contain incompatible changes, like adding a new keyword that might conflict with identifiers in code, or turning warnings into errors. **The Rust compiler can link crates of any editions together. Therefore, if you're using Rust 2015, and one of your dependencies uses Rust 2018, it all works just fine. The opposite situation works as well.** This compatibility is the very reason that [*raw identifiers*](https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/raw-identifiers.html) were introduced, allowing to call a `try` function (as `r#try`) even after `try` became a keyword. This means that: - if you decide to switch to Rust 2018, you don't have to wait (or hope) that your dependencies migrate first, you can use them whether they migrated or not, - if you wish to switch to Rust 2018, you do not hamper your users ability to continue using Rust 2015 for their own code. The key, of course, is that there is, ultimately, a *single* rustc compiler able to compile both Rust 2015 and Rust 2018 code.
&gt; Personally I find it very interesting that the same technique on rustc, the Rust compiler, only found 8 bugs in a couple of weeks of fuzzing, and not a single one of them was an actual segfault. Some of the bugs have testcases that are just ... wild, though. https://twitter.com/ManishEarth/status/994336519975387136 (Almost all of the bugs are places where weird consteval is happening, which always leads to funny-looking code)
Is there a way to display a methods signature? For example in the [stream::Filter](https://docs.rs/futures/0.2.1/futures/stream/struct.Filter.html) struct it says "This structure is produced by the Stream::filter method." I can not find this method in the docs at all. I mean its obvious that the method needs some kind of a predicate and a stream and yields a filter. The compiler itself just tells me that the method wants two parameters and that the first should be of the type futures::Stream (after I provided (),()) as parameters. Is there any good way to show the complete signature without needing to trick the compiler? Also now that I am typing: When I generate a stream from futures::stream::iter_ok like so ``` let mut stream = stream::iter_ok::&lt;_, ()&gt;(vec![1,2]); ``` why doesn't it count as a Stream for Stream::filter()? According to the docs iter_ok implements the Stream trait. But the compiler dismisses it completely: | 41 | let filter = Stream::filter(stream,()); | ^^^^^^ expected trait futures::Stream, found struct `futures::stream::IterOk` | = note: expected type `futures::Stream` found type `futures::stream::IterOk&lt;std::vec::IntoIter&lt;{integer}&gt;, ()&gt;` 
I've run into the same thing with messages in test assertion frameworks. To protect my sanity I always state explicitly what should be happening, which is unambiguous -- 'should' vs. is or is not. So \`\`\` Regex::new(...).expect("string literal should be a valid regex") \`\`\`\`
Well, the docs are slightly incorrect, it's produced by [`StreamExt::filter`](https://docs.rs/futures/0.2.1/futures/trait.StreamExt.html#method.filter). You can find this by entering `Filter` in the search bar and checking the "In Return Types" tab. Now you're not going to want to simply call `StreamExt::filter(...)`, you'd call it on a value of a type that implements `Stream` (all types that implement `Stream` also implement `StreamExt`): use futures::{stream, StreamExt}; let filter = stream::iter_ok::&lt;_, ()&gt;(vec![1, 2]).filter(|_| Ok(true)); 
That's from 2014, before Rust 1.0, so no it's not going to be much related to the current language. 
The biggest downside of criterion is that it pulls in a massive number of dependencies.
Point. Still, might be a good idea for someone more confident to propose changing the panic message to something like "panicked when expecting:"
That would now silently make all the existing implementations with flipped error messages wrong. I don't see a nice way of fixing this.
I've written up an explanation of what happens in one of the ICEs that vergard found: https://github.com/rust-lang/rust/commit/5724dad82ed34f4461f58b3c035b1b06747d8669 The "loop check pass" it's talking about is stored in ` src/librustc_passes/loops.rs` and is responsible for emitting errors related to break and continue. E.g. it creates the error when we've found a break outside of a loop.
The mechanism sounds similar to [EBR](https://aturon.github.io/blog/2015/08/27/epoch/#epoch-based-reclamation). Do you know what the relationship is? Also, it's very interesting how the situation is parallel to `Cell`: `swap()` is "free", and `set()` is fine because it's just dropping the old value after swapping it out, but `get()` is problematic, and (unlike the others) requires a `Copy` bound. I would suspect that, at some level of abstraction, the reason for both of these is the same.
\&gt; However, there's also an important technical difference between \`T: Trait\` and \`impl Trait\` ... \[in that you can't use turbofish with \`impl Trait\`\] This makes me sad. Are we hoping to fix this soon?
Not necessarily. It can also be read as "Panicked when expecting: X" can read as either "Panicked when X was expected" or "Panicked on an expect call with message X". That's why I chose it.
To me this looks like I am "declaring a new crate contained in struct Foo" pub mod bar { crate struct Foo; } Since that doesn't make any sense at all I suppose I can deduce that it must be related to visibility -- but I agree with you, I also prefer `pub(crate)`.
The connection to `Cell` also stood out to me. If we had field projection for `Cell` we could treat `&amp;Cell&lt;T&gt;` as a kind of middle ground between `&amp;T` and `&amp;mut T`, and `&amp;Cell&lt;Rc&lt;T&gt;&gt;` would be a rather fundamental tool in that world (usually obtained via projection to a field of type `Rc&lt;T&gt;`). So the atomic version of that sounds rather useful.
Thanks for the explanation. I wasn't aware that rustc will be able to work and mix with both Rust 2015 and Rust 2018 crates. I thought it was more black and white (like the Python fiasco): either 2015 or 2018. I guessed wrong apparently. Luckily.
Is there a problem with macros that are the same name as a function (that *is* currently legal right?) use bar::baz; fn main() { baz!(); } what if there were also a function named `baz`? Shouldn't it be `use bar::baz!`?
I really hate blob imports because when there is more than one I can't know where it came from, being explicit saves a shitton of maintanance time. Of course that with only one it's doable, so I save it for some preludes that are more necessary.
I've read that article about a year ago. In that light, my subconsciousness probably pulled some inspiration from there without me consciously knowing it. The reasons for it looking similar may be because of that, or because it tries to solve a very similar problem. Still, it was fun trying to prove as weak orders on the atomics as possible (I suspect there's still space to improve). Though there are some important differences ‒ with `ArcSwap`, each one is independent of another and it doesn't work as a GC (you know when a piece of data is dropped) ‒ I can afford to actually wait for the `load` to finish, because I know it is fast, while crossbeam needs to assume arbitrary long critical section inside an epoch.
&gt; Of course that with only one it's doable, so I save it for some preludes that are more necessary Then you may consider creating your own prelude for `slog`. Find the commonly used symbols from `slog` in your project, re-export them from a `log` module, then use a blob import on this (controlled) `log` module :)
&gt; It doesn't segfault. It just fails to print anything. It's UB, so the behaviour is *undefined*, it can do more or less anything: a program containing UB is *illegal*, so the compiler — assuming that it is fed a legal program as no other assumption makes sense — will carry on under that assumption. This can lead to the complete removal of any path which would provably lead to an UB: the program can't be legal if it contains an UB, so it can't contain an UB, so any code path which would lead to UB has no reason to exist. This can have odd effects, like [time travel](https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633). &gt; Edit: I was wondering what the exact reason was that could cause it to print nothing. Is the dangling pointer read and the memory interpreted such that it prints nothing? Does the compiler detect undefined behaviour (and if so, what) and in turn does some "optimization"? Compilers don't *detect* undefined behaviour, they just behave under the assumption that UBs can't happen.
One `use bar::baz` will import both the function and the macro.
My money would be during 2018
println! does flush tho, but not print
One exciting potential use of this would be to enable bindgen [to expose static inline functions](https://github.com/rust-lang-nursery/rust-bindgen/issues/1090). Currently static inline functions defined in header files are completely inaccessible to Rust code and the only workarounds are either to manually re-implement the functions in Rust or to modify the original C code. If bindgen could just produce equivalent Rust functions this would make things considerably simpler. 
&gt;If we had field projection for &gt; &gt;`Cell` What do you mean by that?
Implicitly due to line-buffering of stdout, I guess?
I saw your comment, you're correct. For some reason I was remembering how traits work in a very weird way, then I checked and remembered you can't even use traits as arguments if the compiler can't tell if they are Sized or not.
I'm sorry
Imagine you have something like this: struct Point { x: f32, y: f32, } Right now, if you have a `&amp;Cell&lt;Point&gt;`, you can only read and write the entire `Point` at once, not the individual `x` and `y` fields. This means that if you *do* ever want to access individual fields, you have to "infect" the `Point` type with that fact and write `x: Cell&lt;f32&gt;` instead. However, this is not actually necessary for memory safety; it is merely a limitation of what the library-based `Cell` API can provide. Field projection would let you convert a `&amp;Cell&lt;Point&gt;` to a `&amp;Cell&lt;f32&gt;` pointing at `x` or `y`, while still using the original definition of `Point`. (This is already in the works for arrays, which the library-based API *can* handle: https://github.com/rust-lang/rfcs/blob/master/text/1789-as-cell.md)
Any link to Osmium, which is mentioned near the end of the talk?
Lack of mature UI libraries will be a major one if you do any UI work. Compile time safety versus run time safety are another thing that, while better, can be frustrating at first.
Interesting. Won't it be possible to use libraries like GTK and QT if the bindings are ported, though? In the safety sentence, do you mean that you spend more time making your code pass the compiler in order to avoid problems when running? Because that is literally one of the best arguments in favour of Rust coming from Java. Having to boot up your entire Spring Boot app every time you think you've fixed all your NullPointerExceptions just to find out you were nowhere close to finished is not my idea of fun.
So there are bindings to gtk and qt, but imho they're not super pleasant because they're mixing idioms from other language designs into rust. There are some native rust libraries though but they're not very mature just yet. That said, you can totally make gtk or qml based apps right now. And yes for safety you'll spend more time at first as you're getting used to it trying to get code past the compiler. This is of course rusts biggest strength too but it takes a while to get used to coming from languages that push more of the safety to runtime. That's just for the learning period though.
You can use gtk+ just fine, but good luck getting that to work on windows. I am currently trying to do so and good god it's a big mess. My solution is just to use a webapp with a local websocket server.
Yeah, when selecting Rust over Go, I realized the learning period would be harder, but I would end up with a language with completely different features compared to Java. I'm willing to make that trade.
Http, the great escape valve of all UI apps ;)
I wrote Java before Rust. I miss virtually nothing. I wanted to say the libraries, but I don't actually miss them for the most part - I didn't rely on a lot of dependencies in my Java code. I sort of miss Spring, but not really, more like I miss aspects of Spring. Uh, I guess being able to say `List&lt;T&gt;` was cool but I also didn't care that much about that when I was a Java dev and I don't care that much now.
So long as you're only reading code that uses it.
Start thinking of the compiler as your friend/coding-partner who has volunteered to do all the tedious work involved in making sure there are no data races so that you can concentrate on the more interesting stuff.
No love for nasal demons?
Nice, congrats on the first library! :)
 fn main() { let sum: u32 = (0..).take_while(|i| i * i &lt; 123).sum(); println!("Sum: {}", sum); }
Thank you sir!
You mean because there's no trait for mutable sequences? Or that [Multi-Trait-Objects don't exist](https://github.com/rust-lang/rfcs/issues/2035)?
I don't know of any maintainec QML bindings. But if they exist, shouldn't they be ok idiom-wise? Interfacing with QML should need only a pretty minimal API.
You also need to add `bindgen` to your `Cargo.toml`: `Cargo.toml` [package] build = "build.rs" [build-dependencies] bindgen = "0.37.0" and in your `build.rs` extern crate bindgen; Hopefully this will fix your `Can't find crate bindgen` error.
I haven't really tried it too much to be honest, I found the workflow clunky. But this blog post goes into it https://www.vandenoever.info/blog/2018/06/09/to-do-a-rust-gui.html The binding they use seems actively developed
I call it a "string slice", so I use "a" (as opposed to \`String\`, which is "an owned string"). For \`&amp;Foo\`, where \`Foo\` is a struct, I'd call it "a Foo borrow".
Coming from C#, what does the Java List&lt;T&gt; class have that std::vec::Vec&lt;T&gt; doesn't have? The few missing LINQ features I found were easily replaced by Itertools.
RFCs welcome :D
One thing that may be seen by a negative for some is that even though rust is past its 1.0 release, there is still active development that could greatly change what is considered best practices - some individuals are using the 2018 edition which is part of the nightly toolchain, and will eventually be available through the stable toolchain.
Anything could happen. But the following is actually likely to happen in practice: The second `push_back` needs to allocate new storage and then `std::vector` moves all old data to the newly allocated memory, i.e., the string in `v[0]` (old) is moved to `v[0]` (new), using `std::string`s move constructor. On this move the implementation of `std::string` leaves the old version in an unspecified but valid state and one of the easiest possible solution is to set `v[0]` (old) to be an empty string. After all the moves, `std::vector` deallocates the old storage. This typically keeps the old content intact until some new memory allocation happens, so in the directly following printing operation (`std::cout &lt;&lt; x;`) the bytes of the moved-out string are still intact and the program is more than happy to print the empty string.
The thing that you are doing wrong is assuming that 2018 edition is ready for stable release. It is not, which means that you can only acquire it through nightly. 
You don't have the breadth or maturity of libraries. There are many great quality libraries but they're still lacking in features (or lacking easily integrated peers that add those features). You don't have the many millions of examples (though the examples there are are usually of better quality). The development experience within the IDE is not yet nearly as good with - thought VS Code with racer/rls and IntelliJ with the Rust plugin are catching up fast. We used reflection extensively in code and artefact generation in Java. This is less easy with Rust - the macro model filling some of this void - I'm still early in this journey to see how I can scratch the same itches. However the rust language/platform is better and gives you executables with predictable ergonomics where we're constantly struggling to make Java fit the resource constrained containerised world of todays applications. I'm not commercially productive in Rust yet but I can see a time when I will be, while Oracle (the business mostly, rather than the engineering team) does their best to make Java a harder choice in the future.
Can't we just have a `cfg(rust_edition = "2015")`, `cfg(rust_edition = "2018")`, ... ? Since those are macros, the cfgs will be expanded in the crates where they are used, so... that could fix the problem for macros. Outside of macros, these flags do not make much sense because the edition is a crate local thing.
Well, in Java everything is dynamic and polymorphic. In Rust everything is default static and non-polymorphic. You have to opt into polymorphism and dynamism. This will be starting at first until the differences and methods of dealing with those differences become apparent in the code. The first time you’ll hit this will be with Errors, I recommend using the Failure crate as it will help avoid some of the issues you run into there. Then, get to know monomorphism well, as this is the general polymorphic approach in Rust. Immutability, and single mutable references at a time will also be startling. I recommend getting familiar with the Iterator return types, combinators, and working with mutability and references through these nested calls as an approach to deal with references in a simpler manner. I could go on, but I think these are the big ones. 
I think use case around signal handlers is usually better done with something like [`chan_signal`](https://github.com/BurntSushi/chan-signal) or [`tokio_signal`](https://github.com/alexcrichton/tokio-signal), where all the signal handler does is notify a regular thread, and that thread can then handle the signal without any tricky limitations.
And I thought I was going crazy. Thanks for your explanation. Also the "Search in Return Types" tab completely went over my head so thanks for that as well :)
Rust compile times are longer. This gets improved over time, but I don't think it will ever be similar. (Java can't optimise that much, if any, because of runtime reflections) Some datastructures which are easy to implement in Java are hard to implement in Rust (Graphs, Self referential, etc.). Because in Java code there is no need to worry about cleanup/lifetimes/object sizes. I still think it is easier to find things in the generated JavaDoc than in the RustDoc. Only because the JavaDoc has a method table providing an overview. (Provided you could find the right class in the first place) Also Rust does not have anything nearly as mature as the Spring-Framework. Which is totally understandable. You only asked for negatives, so... yeah. I still would like to use Rust at work someday.
List&lt;T&gt; could be an ArrayList&lt;T&gt; or a LinkedList&lt;T&gt; or whatever. Can't do that with rust.
heh, yeah, I'm not trying to replicate BEAM. I only expect to need a few thousand actors at once, maybe ten thousand, rather than millions. 
Compile times! I'm not quite sure where Java is on that spectrum, but Rust compile times are painful.
Thanks for submitting /u/YbgOuuXkAe! Maybe the title should be changed to the official YouTube title if that's possible. Would make finding the content a little easier in the future. ;-) Anyway, I worked a lot on my pacing with this episode. Hope it's bearable. As always, you can participate at https://github.com/hello-rust/show on future episodes.
&gt;using std::strings move constructor. That's a good point, I didn't think of those. Also, thank you for trying to think of a likely cause. People are tripping over themselves telling me that "It's UB, anything could happen, yada yada yada".
You would need to start with \`&amp;mut Cell&lt;Point&gt;\` exclusive access, for \`&amp;Cell&lt;f32&gt;\` referencing the inside of the \`Point\` to be sound. The soundness of \`Cell&lt;T&gt;\` depends on no arbitrary code having access to a reference to the inside of the cell (unlike \`RefCell\`, hence the latter name), because that reference could be invalidated by a call to \`.set(…)\` on the same cell.
gotcha, interesting!
Sorry, I think I was wrong here and the RFC you linked explains why: \`set\` on the larger cell would write the same memory locations as referenced by the "projected" smaller cells. So I think this kind of projection is valid for a "flat" structures (`struct`s, tuples, arrays) but not enums or through any sort of pointer indirection.
No, that's not true for arrays (as seen in RFC 1789) or structs (which are just arrays with heterogeneous elements). A `&amp;Cell&lt;f32&gt;` would not be invalidated by calling `set` on its containing `&amp;Cell&lt;Point&gt;`, because the struct layout remains the same. There *would* need to be a few more restrictions on cell field projection than on normal field projection, though. You wouldn't be able to go from a `&amp;Cell&lt;Box&lt;T&gt;&gt;` to a `&amp;Cell&lt;T&gt;`, or a `&amp;Cell&lt;Option&lt;T&gt;&gt;` to a `&amp;Cell&lt;T&gt;`, for example, as overwriting an owning memory allocation or enum *can* invalidate pointers to its contents.
I actually was far more rudimentary -- I just used the built in bench tools in nightly :-) I then moved the bench tests around testing various parts until I found the slowest bits.
I also came to Rust from Java and one thing that I have found more difficult is how much carefully you need to think about memory and references. In Java, it is so much easier to just have references to everything without having to worry about ownership.
You can take `I: IntoIterator&lt;Item = T&gt;` which is even more flexible, but might not let you do as much as `List&lt;T&gt;` (I don't know what all `List&lt;T&gt;` gives you).
Less jobs available. By a lot.
I am using nightly, as you surely read :) And I am giving feedback, as we were asked to.
Java's `List&lt;T&gt;` is C#'s `IList&lt;T&gt;`.
No of course I was referring to your experience with serde and slog. Happy rusting!
It hasn't been fully accepted by the lang team yet but we are planning to do your second approach -- translate macros by implicitly inserting `$crate::` in the right places at compile time when used from a 2018 compiler. The implementation in the compiler is around 10 lines of code and some plumbing flags around, under 50 lines total. Providing a rust\_edition cfg and leaving it all up to libraries to do correctly would require libraries to duplicate all of their macro code (thousands of lines in many cases) and maintain a copy that uses `$crate::` and a copy that does not use `$crate::` in parallel, which is not a desirable state of affairs.
`List&lt;T&gt;` is sorta weird (like the entire Java Collections Framework). Essentially it is an ordered collection, it supports iteration, it supports getting its size, it may or may not allow adding elements (the `add` method always exists, although it sometimes can throw exceptions saying that it doesn't actually exist). There is also `Collection&lt;T&gt;` which doesn't have "ordered" requirement, and can be used for types like sets. The direct equivalent of `IntoIterator&lt;Item = T&gt;` in Java would be `Iterable&lt;T&gt;`, except the funny thing is that pretty much the entire Java standard library hates `Iterable&lt;T&gt;`, and most functions in it only accept `Collection&lt;T&gt;`, even if technically they could accept `Iterable&lt;T&gt;` instead. Like usually, code that would use `IntoIterator&lt;Item = T&gt;` in Rust uses `Collection&lt;T&gt;` or `List&lt;T&gt;` in Java. As for my advice about what types to use in Rust, if you would use `List&lt;T&gt;` in Java, then use accept `IntoIterator&lt;Item = T/&amp;T/&amp;mut T&gt;` if you simply need to iterate over elements, `&amp;[T]` if you want an ordered list, `&amp;mut [T]` if you want a mutable ordered list or `&amp;mut Vec&lt;T&gt;` if you need a mutable ordered list which can be appended to. Sure, you lose a bit of flexibility, but at the same time, I never have seen an instance of `List&lt;T&gt;` that isn't `ArrayList` or comes from `Arrays.asList`/`List.of` methods.
While Cargo is awesome, and rustc has great error messages, everything related to interactive tools (most importantly IDEs) is frustratingly bad compared to JVM and .NET languages. I haven't written much Rust in the past 2 months, but AFAIK not much has changed in that time: * Autocompletion is slow and inaccurate. It can take up to a few seconds for the autocompletion list to appear, and at least in VS Code it's usually missing some trait methods and all macros. Sometimes the IDE just gives up, and doesn't show the completion list at all. AFAIK the IntelliJ plugin can expand macros, but the official language server cannot, which is a pretty big limitation for certain projects. * The language server can be very unstable. I've had projects where it crashes about **twice a minute**. * There are very few automatic refactorings, fixes, code generators and other such things - I think rename symbol is the only one right now? You could make the argument that compared to Java and C# Rust has so little boilerplate that these things are less important, but I largely disagree. For example: I have spent quite a few frustrating minutes removing lifetime parameters from every function signature and struct field when refactoring structs. Auto-import, extract function, inline function, move to module and so on would also be really useful. * As far as I know, there are no graphical profilers, or tools for exploring code structure (like visualizing it as an interactive graph or tree). Now, I'm of course aware that these things are being worked on, but it doesn't change the fact I sometimes feel that the lack of tooling is wasting my time.
Ooh, very nice.
Thanks. I haven't gotten to concurrency yet in The Book, but your comment was helpful.
Obviously there's a big tradeoff, but garbage collection is, like, really awesome. It shouldn't be given up lightly. Let's just say Rust will make you really appreciate what a GC gives you, even as it delivers the benefits of ditching GC. With that said, I would never switch to Java just for GC. Besides reflection, most of the other downsides are transient ecosystem issues, not fundamental.
From Java, I would say compile time / quality of editor integration is the largest negative point.
Also.. in which sense would &amp;Cell&lt;T&gt; be a middle ground between &amp;T and &amp;mut T? (Rust is so cool!)
Hey, this seems cool. Does it support spying on methods of instantiated objects? Like if I have: struct Foo { val: i32 } impl Foo { fn get_val(&amp;self) -&gt; i32 { self.val } } Can I do something like the following? fn main() { let f = Foo { val: 12 }; let (spy_fn, spy) = spy!(f.get_val); // ... etc } Though maybe instead of returning a spy_fn it'd need to return a spy_obj? Not sure. I think something like that would be a useful feature, if you're taking requests. 
Just curious, why do you say tooling for Java is ‘such a nightmare’? The profiler, IDE, debugger, test coverage, instrumentation, and linting tools are all way ahead of Rust. The only clear advantages for Rust are cargo over maven or gradle, and the error messages from the compiler.
Interesting, thanks for the explanation!
It would be a reference type that lets you both share and mutate, though it would be limited to mutation that can't invalidate the other `&amp;Cell&lt;T&gt;`s that may be floating around. (See [this comment](https://www.reddit.com/r/rust/comments/8tiqdn/making_arc_more_atomic/e187q5s/).) If you then restrict your data structures to things that can be mutated through `&amp;Cell&lt;T&gt;`, what you end up with looks a lot like a typical GC-based memory safe language: lots of `Rc&lt;T&gt;` at the point where the structure's "shape" can change, but fewer restrictions on who can mutate what.
Well, it would be a good test of the transpiler, I guess? But yeah, you're probably more likely to hit a memory safety bug in the rust compiler or standard library than to hit a memory safety bug in SQLite.
For a lib like this we really need keyword arguments in the language, to not mix up arguments (that come as &amp;\[u8\]). In absence of that, perhaps you could wrap them in a struct? Also, a data argument should probably be generic to accept &amp;\[u8\] and &amp;str. Also, [here](https://docs.rs/orion/0.4.0/orion/default/fn.hkdf.html) what's info?
Awesome! 🎉🎉
No it's not always undefined behavior. It's undefined behavior if and only if when the `push_back` method is called, `v.capacity() == v.size()`. This is documented in the C++ standard with respect to iterator invalidation.
There is nothing illegal about undefined behavior. No where in the standard is undefined behavior considered illegal, ill-formed, invalid, or anything of the sort. Undefined behavior is strictly defined in S1.3.12 as behavior for which the standard imposes no requirements. Furthermore the standard states that it is perfectly valid for a conforming compiler to provide behavior characteristic of the of the environment. The standard simply does not require that a conforming compiler do so. The idea that undefined behavior is necessarily incorrect, illegal, invalid is simply false and unjustified.
You will realize what a poorly-designed language Java is, and you will never want to write in it again.
`stdin` or `stdout` being closed.
I think those checks are done automatically in C++.
&gt;In Rust everything is default static and non-polymorphic. I tend to think of it differently. In code things are effectively polymorphic, even if when compiled they're monomorphized and use static dispatching. In other words, compile-time polymorphism vs runtime polymorphism..
Will do next time as I can't edit the title. If you're looking for any video ideas a useful one could be on lifetimes, including how to work them into `impl Trait`.
That would be sweet indeed.
Thanks :)
Yes, I mentioned in that comment that monomorphism is generally the polymorphic default in Rust.
No specific plans. The project could benefit from more \`rustdoc\` and \`examples\`. At some point I will also need to write a book-like documentation, so that people can read about how tantivy works, and get a decent idea how it works. That is quite important for advanced users and for contributors. Unfortunately I'm stretched thin between my job, my baby, and tantivy :(
Hm- that may be the case! I'm not actually sure how to test this in C++, I think we'd need to close the file descriptor? Not sure how to do that in either language, actually.
For a generic solution, there's the new [`try_fold`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold) method on iterators. You make your closure return `None` when you want it to break, or `Some` if you want it to continue.
Big Rust noob here, and I'm a little bit stuck! I'm trying to write a function that takes in a value and returns the index of the closest value in an array. Something like: ```rust static VALUE_TABLE: &amp;'static[u8] = &amp;[4, 8, 14, 26, 87, 99]; fn get_index_of_closest(input_val: u8) -&gt; usize {/*...*/}; ``` My intuition tells me that I need to iterate through the array, check if the `input_val` is between the values of `i` and `i+1`, and then return the index to whichever table value is closest. But here's where I'm getting stuck. If I iterate through the VALUE_TABLE using a `for value in VALUE_TABLE`, then I seem to only have access to a single value at a time and I can't compare it to the next without consuming/moving the iterator (i think). As such, I was thinking about using *"slice::Windows"* into the array to get 2 values at a time to get around that, but then I just have the raw values I'm not sure how to easily get the index of each of those values. I'm also aware of *"iter::Enumerate"*, which I can use to also get the index of each value in my VALUE_TABLE, but *I'm not really sure how these bits and pieces can fit together to do what I want...* **How how can I create a loop that allows me to [a] compare the current iteration with the next while [b] knowing and returning the indices? Can I combine "enumerate" and "windows" while iterating over my array? Or is there a better/easier/smarter way of doing what I'm trying to do here?** 
I created a ticket ([\#327](https://github.com/tantivy-search/tantivy/issues/327)). I may not have much time to help you go through this ticket but maybe someone else (dru ? Jason?). Join the gitter channel and we can ask them. [https://gitter.im/tantivy-search/tantivy](https://gitter.im/tantivy-search/tantivy) For the fastfield part, Jason [implemented a new type recently](https://github.com/tantivy-search/tantivy/issues/267). 
Regarding profilers, all your usual C and C++ profiliers will generally work, modulo some name-demangling that you might have to write a script for (gdb has rust name-demangling built-in now I believe).
Ugh, that is so obnoxious. Yes. You're completely right.
You’re looking for r/playrust - this subreddit is about the programming language called Rust.
Do you know how many releases it has to be a warning in Rust 2015 in order for it to be denied in Rust 2018?
&gt; I’ve found none where the ArcSwap would perform worse than RwLock&lt;Arc&lt;T&gt;&gt; Are there any benchmarks where it would be faster?
You can't do this with a `for .. in` loop because it takes ownership of the iterator. However, you can do it with `while let` and `.peek()`: let mut iter = VALUE_TABLE.iter().enumerate().peekable(); while let Some((idx, val)) = iter.next() { if let Some(&amp;(nidx, nval)) = iter.peek() { // compare to `val` and `nval` } } However, if your `VALUE_TABLE` is large then a linear search might be too slow. Instead, if your list is sorted you could use `.binary_search()` which returns either the matching index or the index of the _next higher_^1 value which you can then check: match VALUE_TABLE.binary_search(val) { Ok(idx) =&gt; // `val` is equal to the value at `idx` Err(idx) =&gt; // `val` is between the values at `idx - 1` and `idx` } ^1 The documentation of `.binary_search()` defines its `Err` value as: &gt; [...] the index where a matching element could be inserted while maintaining sorted order.
Hmm, I never really felt that. Garbage collection, to me, was just one path to avoiding manual deallocation, and Rust provides another
Looks good, I have been thinking about doing something similar but with reverse ssh tunneling to servers that are behind about 5 firewalls &amp; application layer proxies. Some notes: * You have [unsafe](https://github.com/oxy-secure/oxy/search?q=unsafe&amp;unscoped_q=unsafe) in your code. While I know this can't always be avoided due to FFI, maybe comments in the source to indicate why it's safe in this context. Are there other ways that would avoid unsafe? * You have lots of [unwraps](https://github.com/oxy-secure/oxy/search?q=unwrap&amp;unscoped_q=unwrap) too. Panicking isn't a security risk, but would be a pain if you were using this, especially for remote access. Can they be converted to use `Result` to make it more robust? * Seems to be a lot of keys/PSKs that are needed for the server? knock, psk, privkey? Can this be limited to simply a privkey only? If you are using cert based auth you are sort of shielded from MITM, since no password is ever sent. Obviously you can still exploit this if you aren't verifying public keys. * Can you bypass the knock &amp; hidden service stuff if it's going to add complexity? Key exchange looks a bit convoluted too, I'm not sure whether this adds extra security on first glance of the protocol docs. 
I just wanted to make sure you knew that someone appreciated the rimshot drum audio insert for the __init__ pun ;) Great video(s) and thank you. 
There's embedded scenarios where it might be nice to have.
Also harder to hire good rust developers by a lot.
No clue.
Very enticing! eventually paving over SSH could never be a bad thing. just some feedback - plaintext user guide :( - modest comparison between SSH and oxy features. You don't support remote authentication yet, that's a big one, and I'm sure you know plenty more of these. leaving them to be discovered by the user detracts from reputability. explicitly mention every security feature /missing/ - e.g. i don't see any privsec either (and yes the absense is a big regression! rust-the-language might be perfectly security but what about its compiler on arm-middle-endian-jellyishp-56-bit? etc) - learn from SSH mistakes? e.g. BasicCommand should take an argument vector, else you open users up to security issues from use of /bin/sh - file transfer: baking this looks bad, and you're already making a fairly obvious looking mistake. mechanical disks could live with a single thread pumping one IO at a time, but SSDs are nothing like that (usually rated with queue depth=32), your protocol design should reflect the 21st century, as should the server (looks like IO is handled on the main loop!?) - file transfer: UploadRequest should take a flag indicating whether file should already exist or not, i.e. O_CREAT, otherwise parallel clients can clobber each other without notice. SSH got that wrong too - file transfer: looks like you waste 1 RTT asking permission to upload a chunk before sending the data? - file transfer: meh.. ok, generally, the reason SSH ended up with scp /and/ sftp is a good thing, and I hope from above you can already understand why: they both suck in different ways, but the modularity permitted future improvement or ignoring them entirely (e.g. rsync, tar) 
I have a strong preference for writing native-feeling apps for my KDE-based desktop and limiting web apps to situations which actually rely on their strengths (eg. things like GMail or the now-defunct Google Reader, which display richtext content being communicated over a network, or a Wiki-based PIM solution where richtext and hypermedia intersect.) ...so I came up with my own escape valve: Use rust-cpython and the Python bindings for Qt to create a QWidget/Python/Rust analogue to the official QtQuick/QML/C++ stack. So far, it's been working out quite nicely in the Python prototype I've been porting over to it.
&gt; I'd love to see a "refactoring toolbox" for this. There is [Google/rerast](https://github.com/google/rerast), [facebookincubator/fastmod](https://github.com/facebookincubator/fastmod) as well as the not-Rust-specific [Facebook/codemod](https://github.com/facebook/codemod).
I’m having trouble figuring out who created this. Am I not looking hard enough, is it acceptable for the creator of a security program to not disclose their identity, or is this concerning?
Having to think about lifetimes, while substantially better than manual deallocation, is a lot more work than just letting the GC do its magic (assuming your code isn't bottlenecked performance-wise by it).
This would normally excite me, but the web page's writing is *very* off-putting. &gt; It's like SSH, but more secure, and with cool modern features. It is not an implementation of SSH, it is a new, modern protocol. Security is not just a collection of crypto primitives or algorithms. If I'm not mistaken, most security experts consider in-the-wild experience to be a metric with more weight than modernity. I see you acknowledge the lack of maturity later in the page, but in the meantime, claiming it is "more secure," especially before anyone but you has used it or given it any scrutiny, is *highly* suspect. &gt; I work with a team of *the best* pentesters around You might not have intended for this to come off as braggy, but I couldn't help but roll my eyes at this. There's nothing wrong with taking some pride in the team you lead, but I would trust a humble person to understand how difficult it is to get security right, and be careful enough in their implementation of a security product, a thousand times before someone claiming to be the best.
Quick suggestion, I think you want your functions to take `impl ToString` as the argument type, since all you use from it is `to_string()`. That would be the most generic.
Not sure if it's negative but you will have to unlearn OOP. I'm mostly talking about structuring your data in a graph-like fashion where everything references everything else that OOP encourages. This is not going to fly in Rust. Treat your data as data - keep it in datastructures that are best suited to it, use IDs (possibly typed) instead of references, and look up what you need from vectors, maps, hashmaps etc. In Rust you will think constantly about what owns what, instead of what references what. For me it was a bit of revelation, everything clicked and I now do it in all other programming languages.
You use a simple signature + DH scheme, and I believe this is not a good AKE protocol. You can take a look at this. [The 8th BIU Winter School on Cryptography - Secure Key Exchange](https://cyber.biu.ac.il/event/8th-biu-winter-school/)
I think one of the things that has been hardest for me is that in lots of idiomatic Java, the IoC container owns everything. Even if you are diligent and think of things in terms of a dependency graph in Java, going from things magical setter injection to tracking lifetimes is huge. Now that I think about it, scanning the classpath at runtime to create object is kind of an insane paradigm. Combined with the (relatively) rampant need for casting, Java is really just a dynamic language with lots of type hints to help the JIT.
Seems solved on Ubuntu 18.04: stable-x86_64-unknown-linux-gnu unchanged - rustc 1.27.0 (3eda71b00 2018-06-19) nightly-x86_64-unknown-linux-gnu updated - rustc 1.28.0-nightly (01cc982e9 2018-06-24) 
&gt; In the jargon, load is lock-free and wait-free. The swap (and therefore store) is only lock-free, but that still allows it to be used inside a signal handler ...provided no threads receive the signal in the middle of a load, right? You'd have to `pthread_sigmask` the signal out prior to calling load (and can unmask it afterward).
That's much more pleasant, but sometimes you actually want thread-directed signals—mostly for profilers and dumping debug information while crashing.
I never noticed take_while somehow. Awesome!
That's what I meant with my first paragraph ("It may or may not…"), but now that I read it back I realize it's somewhat ambiguous.
I would actually nix the “UI” part of that statement—mature libraries across the board are lacking. Don’t get me wrong, I’ve put my chips in on Rust (got work to back a couple projects in Rust now), and libraries that fill gaps are popping up all the time (which is why I’m confident this won’t be a problem for long). We are, however, mostly a Rails shop for backends and web framework aside, I wouldn’t be able to drop-in replace a good chunk of what we need with Rust tools. OTTOMH things we’re lacking (aside from a web framework and “plugins” for it) libs for: * I18n (fluent seems to be the front runner for Rust, but our translators don’t have tooling to work with it) * GIS tools (vector support is there albeit new, but I haven’t seen any raster support available) * Unit conversion (libs exist but not any I’ve seen would work for us) * Elasticsearch support (libs exist but are not stable) * rabbitmq support (it’s there, just new) Rust is new and I love it, but there’s work to be done!
Just what I need
My bad, I was running under the assumption that modification = invalidation, which is true of some containers, but not specifically of `vector`. It was a bad assumption, and I feel like a heel for assuming that your were drawing a distinction between undefined behavior that triggers a null dereference and benign undefined behavior (which to be fair is a common misconception, but not one that you in particular are likely to have.)
&gt; Oh and "throws Exception" is NOT ERROR HANDLING! It's making ME handle your error, you idiots! And now I don't even know WHAT KIND?!??! A note on error handling in Rust: Because recoverable errors (i.e. things that don't `panic` or `assert`) are communicated by passing around values, you don't get a stack trace for the _origin_ of the error - you only get a trace for the point at which you assert that a value is valid. This usually isn't much of a problem: open a file with `fs::open`, call `.unwrap()` on the result. If the unwrap fails, the stacktrace will point to a line adjacent to `fs::open`, and so ultimately the _source_ of the error is easy to spot. But other times, maybe you'll be using Serde to deserialize a json blob into some struct, and maybe that struct has struct members. When the deserialize fails, you're not likely going to be able to tell which field failed to deserialize, just that the thing as a whole failed, because the stack trace can't include any functions called from _within_ `deserialize`. So, having stack traces that are tightly coupled to the source of the error is one of the things you may lose when switching from exceptions to Result types.
It depends on what you're trying to accomplish. For example, if your data model is well-suited to how Rust's ownership model works and memory consumption is an important concern for the project, then Rust can easily be less work than a GC. (ie. Consider whether all the time initially gained with a GC is going to be lost again, with interest, when you're trying to tune the codebase.)
[A quick look at the latest commit](https://github.com/oxy-secure/oxy/commit/6fd7e30294507d8d742171b0aa4c222c9af4aa11.patch)
Unfortunately, as far as I can tell, Rust Qt Binding Generator has been designed around the assumption that you're used to writing Qt projects in C++ and CMake and want to incorporate Rust into that paradigm.
&gt; There is nothing illegal about undefined behavior. No where in the standard is undefined behavior considered illegal, ill-formed, invalid, or anything of the sort. An UB makes the entire program meaningless: as your quote indicates, implementations can react to UBs in wildly different, divergent and incompatible manners — including reacting to the UB before the UB is dynamically hit, just because of its existence in potentia. From this it naturally follows that a syntactically valid C program containing an UB is not actually C, it will not work according to the strictures of the abstract machine and will not behave coherently across implementations. I stand by my assertion, an UB makes the program illegal, invalid and undefined: it's not C anymore.
Thank you for the feedback /u/protestor, it means a lot to me. Could you please clarify some things: &gt; to not mix up arguments (that come as &amp;[u8]). In absence of that, perhaps you could wrap them in a struct? I'm not 100% sure what you mean. Do you mean taking, for example, the `salt` parameter and making a wrapper struct for such arguments specifically? So that this struct would be used for any other place a `salt` argument is passed? &gt; Also, here the docs don't say what info is used for. This is an ["optional context and application specific information"](https://tools.ietf.org/html/rfc5869#section-2.3). Now that you mention it, I realize this usually wont be needed most of the time. Instead of documenting it, how would you feel about just removing this parameter entirely from this function?
Yeah, I don't like that. Is there an architectural reason for this?
We don't do language bashing here.
I'd guess that security oriented people usually won't just download a binary, `chmod +x` and run it. At least provide a hash of the file and/or sign the file. 
There's two things here: 1) Why don't errors have stack traces by default? Two reasons. The first one is simple: we cannot generate stack traces on all targets. The second comes from the nature of the Rust programming language as a systems programming language: you can choose you error format yourself. If you take a close look, Rust _has no error encoding_, it just has the notion of `Result&lt;T,E&gt;`, where E is whatever you want. For short-distance errors (you call a function and inspect the error immediately), you probably don't want something big, but will instead choose an Enum, taking a couple of bits. Just for comparison: `backtrace::Backtrace` from the library of the same name is _at least_ 24 bytes big. For long-distance errors (one component reporting to another or things that rarely happen), it _may_ make sense to carry a backtrace and pass around a heavyweight error object. https://crates.io/crates/failure is a library that allows you to build such an error object. 2) Why is the reporting of panics sometimes a little off? Because of the location where the panic happens. For example, if I call `.unwrap()` on an option, `.unwrap()` is no special function. It does an assertion, so the panic happens up the call-stack in `unwrap()`. There's an accepted RFC that allows to annotate such functions to report a different crash point. https://github.com/rust-lang/rfcs/pull/2091
That comes a lot, yet, RustFest always has multiple sponsors attending seeking developers...
Just rustup'd [flamer](https://github.com/llogiq/flamer). Next up: [mutagen](https://github.com/llogiq/mutagen)!
I am continue porting my experimental Software Renderer from c/c++ into Rust. Currently i have completed 96&amp;#37; of it. Currently i rewrite the complete Unit Tests about rendering all kind og geometric from point to complete Scenery with and without texturing, rotation, perspective and orthogonal projection and the most important thing....fixing bugs i found. So Happy c0ding @all :)
Would you be open to publishing such a tool? I have a few projects I wouldn't mind trying it on. 
IIRC gcc used to launch nethack for some UB a long time ago.
[Roguelike Tutorial 2018](https://github.com/Lokathor/roguelike-tutorial-2018) It's a group project from the roguelikedev subreddit. New segments begin Tuesdays, and I'm trying to have it ready to post as soon as each week starts. This week is dungeon generator stuff. A friend _was_ gonna go whole hog with specs, but full ECS is just a bad fit for a roguelike, at least that's the case with our level of ECS skill. Maybe we were doing it wrong.
It is a big pain, because of the way widgets are usually implemented. Every data member that is used from inside a callback will need to be reference counted with local increments and NLL is not expected to improve this use case. Also in what concerns Gtk-rs, something basic like [this](https://github.com/pjmlp/gwc-rs) takes about 15 minutes to compile on a dual core, 8 GB with the latest 1.27.0. Although the blame is on what pango and other Gtk+ wrappers are doing on their build.rs files.
Not everyone is Google or Facebook. If the application was developed with sensible data structures, usually fine tuning might be yak shaving if the memory and time budget are already met.
&gt; The result is the arc-swap crate and the ArcSwap type, I would call this `AtomicArc`, and ideally you would use an 128-bit wide. Also, it probably make sense to store the ref count into a single cache line (e.g. using `repr(align(64))`) to avoid false sharing when updating the ref count but accessing the pointer.
Neat, thanks
So I need to write a structure that contains elements that reference other elements, and inside of those elements there are different elements that references different elements, all of the elements live on the same struct, is there some design I should use? Indecies makes me sad and its hard to write good code when I cant borrow specific fields, so its bunch of hacks of indecies and borrowing fields directly and my code cannot be uglier.. If all of those elements lives on one struct inside a Vec shouldn't it be easier?
One `Cargo.toml` supports one library crate and an arbitrary number of binaries. Best practice would be to have one package -- unless the dependencies are a lot different, in which case you'll want to separate the manifests.
Give your inputs a fuzz and if it's all still a-buzz well maybe its time to try and give your code a fuzz!
I am continuing work on my [RTSP 2.0](https://github.com/sgodwincs/rtsp-rs/graphs/traffic) implementation. Also considering starting an RTP implementation so I can start testing media transports.
When something returns a `Result`, it's because you are meant to handle it (or refer, appropriately). If a parser (deserialize) doesn't give good error messages, it's more a limitation of the parser than of the language (good parser error messages are hard).
&gt; d Hiring? :)
&gt; For rustc, I will write a more detailed blog post about how to set it up, as compiling rustc itself with AFL instrumentation is non-trivial and it makes more sense to detail those exact steps apart from this post. Could you add those steps to the rustc compiler book ?
I followed this path and I have to admit that I enjoy writing Java a lot less now!
&gt; I would love to replace all my bash, python and awk scripts with rust but there are some areas where rust is not convenient enough. One of them is error handling. In production code, Result and other stuff is totlaly perfect solution but I don't need to be that secure in my dev scripts. Try [error-chain](https://github.com/rust-lang-nursery/error-chain). It makes it easy to use `?` to write code that feels more like an exception-based language as far as convenience goes. Also, check out the [project template](https://github.com/ssokolow/rust-cli-boilerplate) I wrote last year for writing my own CLI "scripts" to replace Python and bash. It uses error-chain. &gt; Maybe such crate could also try to simpliy some other details like str vs osstr. Not possible without risking things like corrupted filenames or "path does not exist" errors, depending on how you force things together. The fundamental problem is that filenames may contain bytes (Linux) or codepoints (Windows) which aren't valid UTF-8, but `String` and `str` require their contents to be valid UTF-8. (And then other APIs depend on that guarantee) Converting between `String` and `OsString` and their slice variants is fundamentally about telling the language how to deal with "X contains data that isn't valid input for Y". That's why Python moves *away* from whay you want when going from 2.x to 3.x. 
Um...looks like it is not open sources? Will not trust it then.
&gt; I would call this AtomicArc. "Atomic Atomically Reference Counted" seems a bit too much :)
Not everyone has a big hobby budget to burn on higher-tier VPS accounts either. To perform well, a GC inherently needs a certain amount of slack space to work in compared to something like Rust and I've heard it quoted as high as twice what you'd get out of something like Rust. (And, from the cases of people rewriting things in Rust that were formerly in Java, that seems to consistently be an understatement.)
In the C++ Concurrency TS it is called `std::atomic_shared_ptr`. It reads "atomic atomically-reference counted pointer". There is a distinction on whether the reference count is atomic, the pointer is atomic, or both.
Is that built on TCP or UDP ? [Mosh](https://mosh.org/)'s ability to keep the connection alive when roaming or putting your computer in sleep mode thanks to UDP is really a killer feature. Any SSH replacement should have this IMHO. 
&gt; If all of those elements lives on one struct inside a Vec shouldn't it be easier? This is irrelevant. Rust cannot reason about cyclic references (and having references to sibling fields counts as cyclic because it requires the containing structure to borrow itself), so it doesn't let you have them. The best thing to do is redesign your code to not need them. Yes, that often means using indices and passing borrows down into functions rather than just accessing stuff directly. If that's not an option, you can use things like `Rc&lt;RefCell&lt;_&gt;&gt;` instead, though in that case you're going to pay the cost at runtime with needing to manage ref counts, and doing the dynamic borrow checking. Other languages let you get away with this because other languages don't really care about preventing data races. Rust does. You can either accept that and adjust how you write your code, or you can be *very* miserable while writing Rust. I literally just alt+tabbed over from a project that I've ported from D. I had to replace lots of cyclic pointer graphs with indexed tables and explicitly-passed borrows passed down into functions. It's *much* more work to write. But the trade-off is that the code is *so* much easier to understand and manage. It also allowed me to start using threads for fine-grained parallelism *everywhere* because the code was now structured such that it was safe to do so. In one case, the new code runs 60x faster because it's simpler, and safe to parallelise. I'm absolutely satisfied with having to change how I structured all that code, and having to put in a bit more work up-front if that's the pay-off. If you care more about the code being easy to write then, and this is *in no way a negative judgement of you or your priorities*, maybe you should use a different language.
Thanks for sharing your thoughts. Your project template looks very interesting and I will definitely dig into it! I know error-chain and `?` (and i think that `failure` is even more up to date solutoin for error handling), but imagine that I just write fn do_some_stuff() -&gt; Result&lt;()&gt; { ::std::fs::create_dir_all("it/cannot/be/created")?; } This way I'm loosing path information and I only get underlying error message. Also, there are some uses where I totally don't care if the paths are invalid utf-8. To be honest, I have never seen such paths in last 20 years. Python is moving from one extremity to another and I would like to have a choice: be perfectly safe on production and live on the edge in fast-and-dirty scripts.
FWIW I remember https://users.rust-lang.org/t/full-tiff-parser-paid-gig/17234
Eh, it's over ssl, that already verifies the file doesn't it?
Working on Underscore. Currently compiles to x86 but function calls do not work;
Wait. Wasn't the goal to make the two compatible (using the `futures` crate version `0.3`)? I thought the idea was that `futures` `0.3` should be compatible with both code written for the `0.1` APIs (i.e all the existing stuff) and code written for `std` futures, and let them interoperate. That said, I am really out of date on this. I only looked at some of the proposals and discussions around a month or so ago. Many things probably changed since then. Let me know if this is no longer the case. 
There is a set of steps listed here, but it's a little bit hacky since it some parts of AFL from the afl crate and some parts from the afl.rs source repository: [https://github.com/vegard/prog-fuzz/commit/c80b1a750c030f0e67bf556989ffb39dc092cf9c](https://github.com/vegard/prog-fuzz/commit/c80b1a750c030f0e67bf556989ffb39dc092cf9c) There is also the rust-fuzz book (which is great, and which I think might be even more appropriate for this than the rustc book): [https://rust-fuzz.github.io/book/afl.html](https://rust-fuzz.github.io/book/afl.html) I'm not sure I'm the right person to write for any of these books, but the above should be a start if somebody else wants to do it :-)
I built rustc with your stdsimd changes. I *think* the cached value lookup is getting inlined now. See disassembly at the end of https://gist.github.com/bitshifter/2fb86002961f33869b9873d5841e33a2
I think the `futures` crate will be compatible with the `std` futures. I don't it will be compatible with the `0.1` API. For example, the `Future` trait in `std` lacks the `Error` type: https://doc.rust-lang.org/nightly/std/future/trait.Future.html and https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md#corefuture-module.
This is actually one of my favorite features of Rust. This will be a rant on exceptions and why I think they make a language worse. The last 5 years or so has mostly been C# for me and I lack the words to properly express how much I loath exceptions. There's almost no help from the type system in C# (and I guess Java?) to get exception handling correct since the handling is optional at every level. The only way to actually handle them is to catch all types of exceptions, all the time (I know this is not idiomatic), just in case some butterfingered colleague goes and changes the exceptions being thrown either knowingly and not caring or by just not knowing what the expected exceptions are, since they are not part of the function signature. Using Rust, if using the Result enum for error handling, there will be a build error when the error types and error values change. This is a game changer for robustness, in my opinion. Rant complete.
&gt; and i think that failure is even more up to date solutoin for error handling I'm aware of failure but I suggested error-chain because I'm familiar with what's involved in using it while I have yet to try failure and I've heard some people claim it's more effort to set up. &gt; This way I'm loosing path information and I only get underlying error message. Could you clarify this? I'm not sure what you mean. &gt; To be honest, I have never seen such paths in last 20 years. Consider yourself lucky. I'm still finding [mojibake](https://en.wikipedia.org/wiki/Mojibake)'d filenames I need to fix in my collection of Japanese music years after the mistake which messed up the encodings. Likewise, I actually *have* filenames which wouldn't work in a sloppy String&lt;-&gt;OsString setup. (ie. They contain bytes which aren't valid UTF-8 due to encoding translation mistakes and they caused no end of pain in scripts I wrote using Python 2.x.) &gt; Python is moving from one extremity to another and I would like to have a choice: be perfectly safe on production and live on the edge in fast-and-dirty scripts. To be perfectly honest, I don' think Rust is what you're looking for in the latter case. It's just too divergent from Rust's core goals.
Hi, I wrote down a little about the (non-)sustainability of my current (Rust) community involvement, especially through RustFest. Details (and sponsorship link ;)) in the post, happy about answering all questions here.
**Mojibake** Mojibake (文字化け; IPA: [mod͡ʑibake]) is the garbled text that is the result of text being decoded using an unintended character encoding. The result is a systematic replacement of symbols with completely unrelated ones, often from a different writing system. This display may include the generic replacement character � in places where the binary representation is considered invalid. A replacement can also involve multiple consecutive symbols, as viewed in one encoding, when the same binary code constitutes one symbol in the other encoding. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Not everyone is targeting VPS accounts as well. If the project budget is 200 MB, the application makes it 80 MB, reducing it down to 20MB is just wasting money that could be used in other project development activities. 
Why would an interrupt be a problem? Would a thread getting interrupted appear any different than the thread being de-scheduled?
Job, baby, and tantivy is a full plate. If I were to try tantivy, I want to at least know that I've indexed my documents in a tantivy-compatible format and can query it using all that tantivvy offers. How do I know whether I'm making full use of what is available? I don't want to waste effort.. 
How mature is the iOS and Android support in Rust? Are there any disadvantages or issues to be aware of when using Rust instead of C or C++ for a static library to be used in mobile apps?
&gt; Could you clarify this? I'm not sure what you mean. println!("{:?}", std::fs::create_dir_all("/no/wai")) // Err(Os { code: 13, kind: PermissionDenied, message: "Permission denied" }) Path info (`"/no/wai"`) is not included because I guess that stdlib tries to keep errors as small as possible and avoids additional allocations. This is great in general case but hurts in non-serious programs like one-time scripts or small dev tools for my own usage. I believe rust is perfect general-purpose language and with good enough crates it can be used everywhere.
I mean, even a blank page on those books with a big TODO and a link to that commit would already be much more helpful than having nothing there. Somebody can pick it up afterwards and word a proper section, but nobody is going to magically discover that commit.
Does it have the same behavior if you do `g++ -O2 main.c` instead ?
Right; I agree :-) I've posted the commit to the rust fuzzing channel on IRC when I made it nearly 3 months ago, so the rust fuzzing people should be aware of it. The idea was always to do a more thorough writeup on the rustc-specific bits \*on the blog\* later when I have the time to do it properly (and then let somebody else take it to the book, if they wish). The only reason I linked the commit now was because you asked for it specifically, which I thought would be more helpful than saying nothing.
No. 
You might be interested in [`ergo_fs`](https://docs.rs/ergo_fs/0.2.0/ergo_fs/).
It only verifies the transport. To give you a concrete example, I lost a popular domain name used to distribute binaries. It was later acquired by some obscure advertising company. Files were served over HTTPS, but it doesn't matter: the new domain owner can serve malware at the same URL as previous binaries. The only thing that will prevent this is signatures.
There are some in the git repository and it is a tiny bit faster, but as I said, I don't want to put too much trust into them.
Mosh is awesome. The most complex part of Mosh is not the protocol, but its internal terminal emulation. But a modern Mosh/SSH replacement leveraging UDP should pony on QUIC instead reinventing yet another protocol.
Use NOISE, don't invent your own. There are even implementations in Rust.
IHMO, this name is confusing. It may come from being a non-native english speaker, because Rust's "atomically reference counted" already seems weird to me. I see some sense in the ArcSwap name, but I don't find it perfect either. Thanks for these details :)
It could be. Imagine you lock a mutex, then while locked, you get a signal on the same thread and it also tries to lock the mutex, but can't as it already is locked. But it can't terminate either, because it waits on the mutex, forever… This is why mutexes are forbidden in signal handlers. With a descheduled thread, the one blocking it will get run eventually. Using two syscalls around the „fast“ load operation just won't do. So yes, it may be a problem… I'll have to think about if it can or can't get blocked :-|. I'm sure load inside a signal handler is fine, but swap might not be…
&gt; Security is not just a collection of crypto primitives or algorithms. Especially when it says "AES-GCM", which can be surprisingly difficult to use correctly. By the way, Oxy's claim "the only reason OpenSSH has non-AEAD ciphers is because they weren't invented back then" is confusing. OpenSSH supports AES-GCM since OpenSSH 6.1 released in 2012.
Hashes won't help though, they can just replace the hashes. Signatures would help, that I do agree with.
Thanks! Your answer is exact reason why I even created this post :) [ergo](https://github.com/rust-crates/ergo) is the tool that I'm looking for.
Thank you for your question. I know it's very common testing pattern in JS word however I don't think it's possible to add spying functionality to methods of already instantiated structs in current implementation. Will play around this idea and let you know about results.
I’m getting an ouroboros vibe here. With WASM this quine relay could turn into a kraken. https://github.com/mame/quine-relay
Thanks thats makes sense. So indecies is the way to go if I wanna focus on performance, are there any libraries or tips for working with indecies? Should I create wrappers around containers and let them only accept Typed Indecies? I feel we need better tools/abstractions to deal with indecies if they don't exist yet(maybe I missed it?) or atleast some pointers in the docs about good practices with indecies 
I'm 100% in favor of experimenting with new cryptographic applications and protocols, but I think there's a genuine obligation to note on the website that this project is experimental and unaudited rather than "SSH, but more secure".
Agreed that Noise would be a good basis for a project like this, (and [WireGuard](https://wireguard.com) might be a good spiritual guide if it will use UDP). I wrote the [snow](https://github.com/mcginty/snow) Noise implementation in Rust called and am around if you have any questions about it.
https://doc.rust-lang.org/1.4.0/book/benchmark-tests.html
I'm not aware of any. It depends a lot on what you're going to do with them. Are your tables dense or sparse? Can you free up indices? Can you re-use them? How many do you need? The answers to all of the above (and possibly other) questions could change what you need to do and how you need to do it. In my specific case, it means I use a lot of `BTreeMap`s, and never worry about ID reclamation.
I know that the DKFZ (German cancer research institute) is using it quite a bit. Rust is in the speed range of C and, since the last version, gives you access to explicit SIMD computation. In general, though, the language is _young_, which might mean that the libraries that you need for your specific task are not implemented yet. (some call that lacking, I call it a _contribution opportunity_) I don't have enough experience with Julia to make any good comparisons.
I agree. It was a pity java used subtyping for exceptions instead of enums with forced handling/rethrowing non-handled way back when...
[v0.19.0](https://crates.io/crates/uom) of [`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis) released last week. The release was made possible by the recent 0.2 releases of `num-bigint` and `num-rational`!
I'm not sure about those details yet, its highly experimental Thank you I will give it a try! :) 
Note this is for 1.4; and as it says, isn’t stable. OP, the built in benchmark tests are still unstable, it’s true. I believe there are some crates on crates.io that let you build some on stable.
No, that's exactly what I did :c
Your best bet is to find bindings to cpp libraries right now. We really need value generics :/
Say I want to compile a project and have trouble compiling one of the dependencies. I can download the binary for this dependency but where should I put it in order for cargo build to use it ?
Ahh. It seems I got too caught up in the proposed implementation details and didn't see a more idiomatic way to achieve the desired goals. That said, the error-chain solution for your problem is the `Error::chain_err()` method that error-chain adds, which lets you wrap up a returned error in a higher-level error with a message of your choice. Then, when you consume the error, you can do something like this example from the docs, where it walks down the chain of wrapped errors and prints them as "Caused by:" lines: // Get the full cause and backtrace: println!("{}", e.display_chain().to_string()); // Error: invalid toolchain name: 'xyzzy' // Caused by: invalid digit found in string // stack backtrace: // 0: 0x7fa9f684fc94 - backtrace::backtrace::libunwind::trace // at src/backtrace/libunwind.rs:53 // - backtrace::backtrace::trace&lt;closure&gt; // at src/backtrace/mod.rs:42 // 1: 0x7fa9f6850b0e - backtrace::capture::{{impl}}::new // at out/capture.rs:79 // [..]
&gt; have trouble compiling one of the dependencies What's the error message?
Different messages on different ubuntu versions. See [here](https://github.com/mimblewimble/grin/issues/1189)
When thinking about the name, I thought about \`Aarc\`, but that sounded more like a hex/curse than a good name for a library 😇. And I don't really like renaming a crate once it is published… there's a lot of crates with strange names. But thanks for the suggestions what to look into around the performance… I don't know when I'll have the time to look into that, but I made a note of them.
Hmm there is `cargo publish --dry-run` but it *doesn't* fail with my `Cargo.toml`.
[Criterion.rs](https://github.com/japaric/criterion.rs) supports rust 1.23 and newer. 
[Criterion](https://crates.io/crates/criterion) and [bencher](https://crates.io/crates/bencher) are the crates I've seen recommended. Criterion's quite nice in that it tracks diffs from the previous run and can produce nice graphs with gnuplot.
\&gt; Is it as fast as C Unless you plan to use AVX-512, yes. But that is coming soon.
This. Anyone know more about Osmium? You can't find anything about it.
I'll repeat what I've said elsewhere: In my opinion, choosing not to use some feature is in no way "fragmenting" the community, or "creating dialects". Everyone already only uses a subset of the language. Is everyone evil that decides to: * Not use `impl Trait` in argument position? * Not use `as`? * Only specify trait bounds in `where` clauses, and not use the `&lt;T:Clone&gt;` shorthand? * Not use `?` * Not use the new constraint syntax sugar that just went FCP-merge? * Prefers `match` over `if let`? * Decides to support an older version of Rust? All these things "fragment" the community. But those are things leadership wants, so in those cases Rust is a "there's no single way to do it" language. But it seems if you *don't* like something that leadership likes, it's "our way or the highway". The phrase "you don't have to use it" has been said a lot in the past, but that has to be made possible. With match ergonomics, it's basically impossible. I've opened a [clippy issue](https://github.com/rust-lang-nursery/rust-clippy/issues/2850) about adding an opt-in restriction lint to at last give us a chance at enforcing consistency. It would be great if people could add their use-cases, so it might have a chance. There's a lot of talk about trust going around currently. It would be nice if the Rust leadership could show some trust in the community to make their own decisions. /rant
&gt; Imagine a world where each crate author defines its own accepted subset of Rust; it would be a nightmare to try and contribute to crates with vastly different subsets! * Is the crate `no_std`? * Do they like `foo&lt;T:Clone&gt;` bounds? * Do they want to support an older Rust version (also something we're not allowed to declare) * Do they want `impl Trait` in argument position? * Do they `#![forbid(unsafe)]`? * Do they use `failure` or plain `std::error`? * and on, and on... It's the availability of the choices causing the fragmentation. Enforcement of the chosen paths is only creating clarity.
Actually, I find it quite interesting to see and hear about RLS crashes with all those slogans about language safety and everything. 
To be fair, I think every single crash was caused by an `unwrap() / expect()`call, a deliberately placed `panic!` or an out of bounds index. Nothing actually unsafe, like memory corruption.
I've been trying. I'm coming from a Python/Matlab background (not an expert at either, or Rust). It's easy where it's easy and painful everywhere else. The ndarray crate seems to be your best bet for Numpy stuff, with nalgebra also a good choice (although nalgebra seems like it's not made for doing math on very large, dynamically-allocated arrays). I can say that I'm damn impressed with Rust's speed. I had a finely-tuned function in Python using (almost) all the tricks Numpy could provide (the function was almost all Numpy with only a tiny bit of pure python). My poorly-coded, eyeballed Rust version (that could likely be optimized a lot further) was 6 times faster than the Numpy one. I also really like my function to extract the data I need from some Sqlite databases. I tried for a week to get BLAS/LAPACK to compile/install on my Windows computer (I got it just fine in Linux... but it just wouldn't compile on Windows -- went through like 4 tutorials over three times each). As there are bindings with ndarray for BLAS (and I think LAPACK?). When I got frustrated, I tried implementing the singular value decomposition algorithm (the one that I needed) myself and got lost/bogged down. I didn't feel like trying to get nalgebra to play nice with my ndarray types, but that was the next step I was going to try. I haven't taken too much of a look at Julia. Coming from Python, Julia isn't exactly what I want - I want something that's lower level, compiles to an executable, and has really good CLI support (I don't know if Julia has really good CLI support, but Rust has AMAZING CLI libraries). So, from my (noob-ish) perspective, Rust just isn't there for scientific computing, but it's close (maybe 1-2 years). Even then, you won't see something as comprehensive as SCIPY, but the underlying statistics/linear algebra stuff will be there so you can at least roll your own higher functions.
[Or rogue, or simulate the tower of Hanoi with emacs](https://feross.org/gcc-ownage/). (It's GCC 1.72, it was likely to have _the_ GNU editor installed)
Sure but it needs additional effort, e.g. create_dir_all(...).chain_err(|| format!("could not create {}", path.display()))?; If you check `ergo_fs source` mentioned by /u/burntsushi you could see that it does it for you already
&gt;Luckily. I would say Luck had nothing to do with it. This was all planned and designed carefully with lots of input from both the community and the Rust core team. It's a reflection of how well the Rust ecosystem is developing and how well the core team manages change. No luck involved.
Hi, so after my last blog post about this, I continued my journey into WASM + Azure Functions. Let me know any questions/feedback :). Cheers!
I guess my wording was a bit off. I didn't mean luck as in randomness. I was just glad that they didn't go the Python route. 
&gt;`system("pause");` Note that this would only work on systems where `pause` is a command, as it's actually invoking a program called "pause" as if you're typing it into a shell. So Windows only.
`nalgebra` is quite good for linear algebra. i don't actually know how it compares on speed, but it was totally sufficient for my use case (a realtime 3d ifs fractal viewer/editor), and the api is really nice.
Still not anywhere near as much as Java. Where I live, 90&amp;#37; of companies have Java positions open but I've yet to even see a mention of rust anywhere. 
That's exactly the impression I was under when I read the [previous article](https://www.vandenoever.info/blog/2017/09/10/time_for_rust_and_qml.html) of the same blog on this subject.
Are you sure this is the correct subreddit?
I'd extend it from \`unlearn OOP\` to \`unlearn common design patterns\`, cause the GoF ones don't expect the concept of borrowing and are extremely challenging to replicate with Rust.
It's slowly getting there. I've been working on it in my free time on a few scientific libraries. Julia has us hands down beat as far as library support is concerned. Over the next month, I plan on writing a Krylov sub-space methods library (iterative linear solvers), so we should have a few more numerical methods available by then to help close that gap :) However, I believe as the language matures you'll start to see more and more scientific libraries brought over to Rust especially now that SIMD operations are available in stable Rust. Another thing I'd like to add is that if you see a gap in libraries in an area you know well then write a crate for it or help add on to existing crates. We need a lot of help right now to build up the scientific computing community in Rust, and any help we can get to build it up has a much more noticeable impact than in some of the more mature languages out there.
I actually like the attitude/humor. The only minor point regarding saying it is still "green" is change "It's like SSH, but more secure" to "It's like SSH, but **designed to be** more secure". That **designed to be** changes a lot in the attitude and makes it clear that while it should _theoretically_ be more secure you can't actually make any claims as such (yet).
Have you tried `cargo verify-project`?
Wrong subreddit. Your looking for /r/rustporn
Of course. If something like ergo_fs exist, use it. I was just making sure you knew how to fill in any gaps, since the error-chain docs were a bit lacking back when I initially got into it.
Doesn't look like it's Send nor Sync.
You want r/playrust. This is the forum for the "[Rust Programming Language](https://www.rust-lang.org/en-US/index.html)" (like it clearly says in the side-bar).
I am interesting in [CS140e course](http://web.stanford.edu/class/cs140e/) mentioned in the talk and willing to go through it . But not every lecture is accompanied by its own material/slides. Does anyone know where to find more information about the course?
I've used Rust a bit and Julia even less, but from my experience, it's faster than Julia, but not considerably faster (maybe 2x-3x faster at most). However, Julia is certainly much easier to code it. It's nearly as easy as Python to write, while Rust is, at least in my experience, much more difficult to write (although it's still better than C and C++).
I don't know, it looks `Send` to me. Not sure about `Sync` however.
A breakdown of all the reasons why "it depends" is the correct answer to whether you should check the value of a variable before updating it or just overwrite even if the value is the same. Useful information for anyone trying to micro-optimize Rust code and not especially accustomed to thinking about the vagarities of CPU performance.
Is the [internals/compiler forum](https://internals.rust-lang.org/c/compiler) the right place to start discussing my (possibly naive) findings of optimizations Rust can benefit from?
Please elaborate.
TLS does not matter if the domain is owned. TLS provides integrity and authentication - a hash provides nothing over this. A digital signature could imply an out of band signing process, which may provide something on top of tls, but TLS seems generally sufficient.
I performed the analyses for my [most recent paper](http://cs.brown.edu/~sk/Publications/Papers/Published/wkf-who-tests-testers/) in Rust! I needed to repeatedly and quickly deserialize thousands of JSON files (containing test suite execution results) and compute summary statistics. [Serde](https://github.com/serde-rs/serde), [Itertools](https://github.com/bluss/rust-itertools), and [Rayon](https://github.com/rayon-rs/rayon) made this dead easy. (Also, shout-out to [biomake](https://github.com/evoldoers/biomake)!)
I eventually figured it out - devenv.exe doesn't provide any stdout, so trying to gather it causes a panic as there's none to gather. 
It's pretty nice for game dev, where you can just drop a whole scene's arena when you enter the loading screen, instead of free'ing each allocation one by one. Or even a per frame arena.
Criterion is the standard way right now, it is pretty easy to use and has good quick start and user guide.
Define a mutable `slice_primes_len` instead, and only use `slice_primes` as a temporary within the loop.
holy 👀
I don't understand, why can't I just resize the slice from with-inside the loop? The only reason I am using a slice, is to avoid having a length variable.
[boxxy](http://github.com/kpcyrd/boxxy-rs) does something very similar to that. The binary is not supposed to be installed though, so it's in `examples/boxxy.rs` instead of `src/main.rs`. If your crate is named `foo` you can just write `extern crate foo;` in your binary target (`src/main.rs`) to import your crate as a library. This is also common practice if you have multiple binary targets that share code. A few of my other projects are structured like this as well.
Because when you can only have one mutable path to a value at a time. As soon as you create the slice, you lock out access to the underlying array for as long as that slice exists. There's no way to "extend" the slice, because that would require going back to the array (which is locked out). You'd have to let the slice fall out of scope, because you can't terminate a borrow before end of lexical scope. Except *that* means it can't be outside your loop, it has to be inside. Which means you need to store the length of the slice outside the loop. You could work around this if you were *shrinking* the slice, but not extending.
You're running against the limitations of the current borrow checker. Your code is actually fine, but rustc isn't able to see that (yet). All that the borrow checker sees, is that you're mutably borrowing `array_primes` twice and that those borrows overlap, therefore error. What the borrow checker does not see, is that by creating the second borrow you invalidate or 'delete' the first one. This will be fixed once the MIR borrow checker (aka NLL) lands. Compiling this today on nightly with `#![feature(nll)]` makes your code compile.
whoops
Huh, you really should only be catching the exceptions you are expecting. If your program falls over because an exception occurred that you weren't expecting but should of been, then add a catch for that exception. The only time I can think a catch all is required is the case of logging and that'll usually be much further up the stack than where most exceptions are thrown.
Great work! Dates and times are tough... Thank you!
Right—in general, the signal handler can't wait for the thread it interrupts, because that thread is implicitly waiting for the signal handler, so they'd deadlock. The two threads case is easier because it doesn't have that implicit second wait. FWIW, you can build mutexes which are safe to use in a signal handler if they're guaranteed not to be held by the thread the signal handler interrupts. That's limited but still sometimes useful. (Note `pthread_mutex_lock` isn't advertised as such. I'm guessing that's not by accident. Here's one way I can imagine it going wrong even if you follow that restriction: it might allocate memory. For example, I use a mutex implementation at work that builds a profile of contention—whenever a lock is released, if there are waiters, it records how long each stack trace was waiting. I'm sure there's memory allocation involved there. Unless you guarantee the signal can't happen while the calling thread is allocating memory (seems pretty impractical), that comes down to the same problem where the interrupted thread and the signal handler need to acquire the same lock.) The bad behavior isn't always a deadlock, btw. Reacquiring the same non-recursive `pthread_mutex_t` from the same thread is undefined behavior. IIRC, in some implementations it's a no-op (and then the first unlock is the one that does something, oops). I think they record the thread identity of the holder in the mutex, and the signal handler probably has the same identity as the interrupted thread (or maybe not if you use `sigaltstack`, who knows). &gt; Using two syscalls around the „fast“ load operation just won't do It's hard to say for sure without a specific use case in mind (maybe the thread(s) doing the loads can just leave the signal masked the entire time), but it definitely limits usability, and the documentation should point that out when saying swap is async signal-safe.
&gt;learn from SSH mistakes? e.g. BasicCommand should take an argument vector, else users are opened up to issues inherited from use of /bin/sh -- and they can always request it explicitly with a vector I don't understand this point. &gt;mechanical disks could live with a single thread pumping one IO at a time, but SSDs are nothing like that (usually rated with queue depth=32), the protocol design should reflect the 21st century, as should the server Same, what do you mean by that?
I didn't know about it, but it gives me {"success":"true"} 
I am in no position to offer any kind of work, but just to be clear - are you offering free time to open-source projects, or paid commercial work? From the headline I assume the latter.
So I'm still working on rustified versions of parts of [OpenMoonstone](https://github.com/joetsoi/OpenMoonstone/) Last week I finished the binary file parser and image viewer for the fullscreen files, this week I'm going to look at writing a sprite sheet extractor.
correct, we're looking for paid work :)
Just looking at [rocket](https://rocket.rs/guide/getting-started/) it looks like it follows the npm hype style of writing glamour emoji filled terminal output. It's so boring that people write code to show fancy emoji messages rather than focusing on simplicity, frugality and cleanness code. How the heck do you want to debug messages in your journal after? You will grep by bomb emoji? By rocket emoji?. *sigh*
Thank you for that hint. It seems that this is no funding yet :-\
I'm using Rust for various compute-intense data science workloads. It feels so good to rewrite some sketchy C++ or Python code in a way that lights up all 32 cores of our server. I have found that prototyping/cleaning in R, then just shelling out to Rust for heavy lifting (with the CSVs as inputs) works quite nicely. Would love a proper dataframe abstraction though, even if it loses some type-safety. As a side note, as part of my work I made [this wrapper](https://github.com/jesskfullwood/rust-nlopt) for nlopt (a nonliner optimization library) and it works great!
&gt;I don’t want money from individual donors. I'll bite: Why?
&gt; The second point I think has the potential to be a bit controversial, so I’m happy to receive feedback on that. This seems extremely reasonable to me. You can always re-open things later!
Hmm, i guess it doesn't bother me either way. I'm guessing my terminal doesn't support those so I haven't been seeing them. As far as the grep comment, I'd imagine this has been accounted for by also outputting the word 'error' or some variation ('failure' etc.) which you could search on. Oh well, the web framework has been working for me and has been great compared to the previous two I've tried: nickel and iron.
But in another sense, yes.
Making [graphql-client](https://github.com/tomhoule/graphql-client) ready for a 0.1. release. I will be done with the last feature (interfaces) by the end of the day, and will move on to getting documentation and examples into shape.
Chicken and egg. It'll sort itself out.
&gt; At least provide a hash of the file and/or sign the file. What's the point of providing both *file* and *hash* on the same server? If someone hacks the server to switch the file, they can just replace the hash...
&gt; it looks like it follows the npm hype style of writing glamour emoji filled terminal output "npm hype style" uhhh lol what &gt; It's so boring that people write code to show fancy emoji messages rather than focusing on simplicity, frugality and cleanness code. It's... boring? That people that people *don't* focus on frugality? ???? Who says that the code is less clean or simple? &gt; How the heck do you want to debug messages in your journal after? You will grep by bomb emoji? By rocket emoji? Does Rocket put emojis in its actual debug logs? I saw that in dev mode it prints to the screen some emojis in benign parts. Anyways, if your logging pipeline can't handle unicode you have bigger problems. Complaining about something this trivial because it doesn't fit your idea of "frugality" is the worst kind of bikeshedding.
This comes off as bikeshedding and doesn't add to the discussion.
Working on pushing const generics forward. Almost every aspect has gotten far enough that we need to start thinking about lowering to MIR, so I'm going to be learning about how that might work. Other than that I need to get back to my embedded work. I'm going to be testing an SPI driver, and when that works I can work on getting a driver for XBee X2Ss working.
While I'm not the author, a few reasons why I think that is a good choice: - Individual donors would most likely be community members. It's healthier for the community if they spend their time and energy to engage in the community. It's then probably more healthy for the individual to not spend energy AND money. - Even a medium sized company can donate 10x-100x what a individual donor can while at the same time beeing much less impacted by it - Companies are usually more professional about donations. The only enter the agreement knowing pretty clearly what they expect from it, while individuals (rarely but that is still too often) may expect preferred treatment for the donations. It's probably more healthy not to enter into financial agreements with the wider audience.
&gt; I don't understand this point. SSH and ^ work by passing a single string to the shell to parse, which means users must escape stuff. Sure no problem for one layer, but try a nested SSH, or a ssh+sudo+ssh and you'll start to immediately feel the pain &gt; Same, what do you mean by that? You can't saturate a modern drive with a single pending request. On the majority of OS, the only way to reliably issue multiple requests remains to execute on multiple threads. Various OS have asynchronous IO support, but usually it places lots of restrictions on your requests (page aligned, direct to block device, cannot use fs) or fall back to synchronous in some cases (definitely true on Linux)
Pretty much all of those memcpys are optimized away by LLVM.
That's what I've been told, but unfortunately they are not: https://godbolt.org/g/x3kmFz
That's a massive array. Most real code won't run into this.
You are missing the point, which is that this will happen no matter how big or small the struct is.
Yeah I noticed that problem after writing my comment, too :/ However, it's probably useful if the file is hosted on an external server. Or if the hash is posted on a very trusted site (like GitHub). But I'm certainly not one of those "security oriented people" :P 
Made the struct smaller, and [poof](https://godbolt.org/g/WScMgy).
Except from using a reference/borrow, what's the alternative?
I thought /u/slamb was talking about single atomic operations, But I now see how an interrupted `ArcSwap.get()` will prevent updates from completing. I have implemented a similar data-structure, [`PairLock`](https://github.com/tormol/pairlock), which also has this issue! (It uses a `Mutex` to serialize updates anyway though). I'm working on a structure were both swap() and get() are wait-free, but it stores custom `Arc`s and has custom reference types too. (It stores the number of get()s of a value in the pointer's padding bits, which means there must be a limit on the number of references to the cell.)
It still does a bit-wise copy! It just doesn't use `memcpy`. 
You cannot transfer ownership when you use references
Having done a substantial amount in both (ie have clocked in north of 10 klocs in each), I would use Julia hands down for most things. There are certain circumstances where I could see Rust being really useful, but realistically Julia has much better abstractions for things like arrays and vector computations. Highlights of Julia: - Dot syntax: it's awesome, just look it up - Speed: when the JIT isn't working hard, the speed is on par with C and Rust - Libraries: Julia has either a native version or at least bindings to just about anything library you might want. DifferentialEquations.jl is incredibly feature rich, moreso than anything else I've used (been around the Python and Matlab block a few times as well) - Ease of Use: Unlike Rust, Julia is an easy language to pick up and be productive fast. If a person can use Python, they can be productive in Julia in just a few days. The same is not true for Rust. Forget teaching Rust to someone who doesn't have a strong programming background (esp low level systems programming). It's totally your call and do whatever suits your team, but Rust is a very detail oriented language and a lot of times you just want to see your graph and not worry about the lifetime of a flag to the graphing library.
You can heap allocate and pass the Box?
Is there an alternative when something is allocated on the stack? Put it into a box if you want heap allocation (and thus cheap move semantics).
* as K900_ observed, it doesn't always call `memcpy`, but it does always do a bit-wise copy. Which is pretty much the same.
Strongly agree with you!
Even if you put it in a box, you still don't avoid the bit-wise copy. `Box::new(Foo { dummy: [42u8; 5] });` will still do a bit-wise copy.
Even if you put it in a box, you still don't avoid the bit-wise copy. `Box::new(Foo { dummy: [42u8; 5] });` will still do a bit-wise copy. 
Ahh. yeah you can. For a moment this comment confused me: `@MatthieuM allocating it on the heap is very well, but in my experience, even writing Box::new(BigStruct::new()) first allocates the BigStruct in the stack (in BigStruct::new), then copies it in the heap (in Box::new). Or am I missing something? – Pierre-Antoine`
Ahh... yeah you can. For a moment this comment in SO confused me: &gt; @MatthieuM allocating it on the heap is very well, but in my experience, even writing Box::new(BigStruct::new()) first allocates the BigStruct in the stack (in BigStruct::new), then copies it in the heap (in Box::new). Or am I missing something? – Pierre-Antoine 
Nice work! I'd like to address your [comment](https://github.com/bspeice/dtparse/blob/7d565d3a78876dbebd9711c9720364fe9eba7915/src/lib.rs#L619-L629) regarding `&amp;usize`: You're right that `usize` itself is `Copy`, but references in general are not! One solution would be to dereference them - since the target type is `Copy`, it will just be copied instead of moved. [playground link](https://play.rust-lang.org/?gist=692ef19bb934fb6375b360712947f3b1&amp;version=stable&amp;mode=debug)
One somewhat unrelated comment, I love how diverse the picture at the top is. It's not ideal, but it shows that the effort the Rust community has put into making a safe environment for all types of people is paying off. That being said, we can, will and must continue to improve on this. 
That is all you get. You can checkout the subreddit dedicated to the class and it has a link to a different but similar class(os class but not in rust) with slides.
How do you do cyclical data structures like doubly linked lists? It seems like ownership would be a major obstacle here.
What is the best way to convert from `Option&lt;String&gt;` to `Option&lt;&amp;str&gt;`? I have `x.as_ref().map(String::as_str)` ([playground](https://play.rust-lang.org/?gist=91f2adeddfabc3434ae46ab0b970d46f&amp;version=stable&amp;mode=debug)), but maybe there is something else shorter.
Use `flat_map` instead of `map` https://play.rust-lang.org/?gist=e61461671e6a59ee5e5476599baec22f&amp;version=stable&amp;mode=debug
that's a rather large should -- even the smallest implementation of QUIC entails 10k LOC (picoquic), and still depends on some of the worst parts of SSL (x.509 parsing)
Maybe these links can be useful: * [Learning Rust With Entirely Too Many Linked Lists](http://cglab.ca/~abeinges/blah/too-many-lists/book/) * [Writing a doubly linked list in Rust is easy](https://www.reddit.com/r/rust/comments/7zsy72/writing_a_doubly_linked_list_in_rust_is_easy/)
`flat_map` on a `Result` just throws away `Err`, like it was an empty iterator. Here's the solution I gave on the users forum: fn compute(input: String) -&gt; Result&lt;i32, String&gt; { ingest(input)? // Ingest and abort if error. Simple enough .into_iter() .map(|i| i.normalize()) // Maps into Result&lt;Data, String&gt; .map(|i| i?.perform_operation()) // Maps into Result&lt;i32, String&gt; .try_fold(0, |current_max, value| Ok(current_max.max(value?))) // Maximize }
How about [this](https://play.rust-lang.org/?gist=f4928921f1b791e03e9177dfd3653455&amp;version=stable&amp;mode=debug)? The fold call is a tad ugly since for some reason it needs this type hint, but maybe there's a way around that I don't see. Other than that, it seems close to what you want, just that you can't map functions but have to use closures, which blows up the number of characters, but otherwise... Note though the semantics, if there's an error somewhere in `normalize` or `perform_operation`, we'll be returning the first one, while still going through the full thing.
Yeah, this is definitely the most optimal solution. Thanks.
No dice :( Is there a good forum to post this on? I'm tempted to try emailing some rust devs at mozilla, but I want to cover every base I can think of before trying that 
The biggest issue, in my mind, is a total, complete lack of documentation or examples. In my understanding, it works well, you're just on your own to figure it out.
Yes.
I think of it this way, but if saying it out loud I say something else.
Finished integrating `gfx_glyph` into the `ggez` game framework, replacing what was already there and bringing much faster and more featureful text rendering. Nice to be able to close a 10 month old feature request!
Very happy to see the recent pushes for more sustainability in Rust community regarding open-source and now also community contributions! While I was aware of the problematic before, my personal experience of launching a high profile Rust project (Leaf) and it's subsequent abandonment due to lack of sustainability made me really see how much goes into maintaining a project and what strains it can put on you. It also made me see how much of our programming ecosystems are built on the free work of hobby contributors, while the bulk of companies using it don't contribute back. I really hope that this works out for Florian, as I feel very few people in the Rust community had as big of an impact on me as he did! It's not directly mentioned in the linked post, but he also (helped?) found the Berlin Rust meetup, which is awesome! When I attended my first meetup there, with only a bit of Rust experience at the time, while him clearly being of of the more experienced people there, he was very approachable and taught me about the importance of stable over nightly Rust if Rust ever wants to get mainstream and commercial adoption. This very much embodied what I previously only experienced online in terms of a welcoming community, and was definitely a factor that made me want to be a part of this community. P.S.: The eurucamp link is broken ;) 
What's "Underscore"? Link perhaps?
How can I tell if a sys crate is being statically or dynamically linked when building a binary? I'm writing a pretty involved git hook using the git2/git2-sys library, and want to make sure that the ssl and git2 sys libraries get statically linked.
&gt; "npm hype style" uhhh lol what Like the GIF here, I assume: https://hacks.mozilla.org/2018/04/hello-wasm-pack/
Is anyone here injecting Rust via wasm into their JS-based projects? My projects right now are mostly TypeScript, so examples of this kind of stuff would be helpful to look at.
I think this is a real concern, and there isn’t a really good way to deal with it: you just need to be careful to avoid having large structs or arrays in the first place when possible, and when not possible be careful not to move them around a lot but to pass references (be they \`&amp;T\` or \`&amp;mut T\` or \`Rc&lt;T&gt;\` or whatever works in that case). Servo has unit tests that checks \`size\_of\` for a few types, so that if they grow we at least do it knowingly.
I'm working on an RSS/Atom feed to email program. You define some feed URLs, run the program and receive an email for each new feed entry. That's about it.
Same situation here. If I tap the blank space in the top left corner of the page I get the menu. The auto hiding behavior of the page title is also very weird. If I pull down on the page to go up to the top, the title disappears. If I pull up to go to the bottom of the page, the title appears. This seems to happen mostly on short pages. 
Yes, in current rustc versions it’s possible that `Box::new(something large)` will not optimize well and do one more copy than necessary. But after that moving the box around is just copying one pointer. If that one copy is a deal-breaker, unfortunately today there isn’t really a better solution than allocating memory and unsafely initializing it, pretty much re-implementing `Box` yourself.
&gt; "npm hype style" uhhh lol what Don't believe me? This is output of [yo](http://yeoman.io/): https://imgur.com/a/zMXYFU0 &gt; It's... boring? That people don't focus on frugality? ???? Yes, because you get distraction instead of focusing on clean and explicit logs. 
I would consider myself an applied mathematician before calling myself somebody that knows much about good coding, but I work full time in scientific computing writing pretty specialized linear algebra methods, and I have used Julia and C for these jobs for the last \~2 years. Other commenters are definitely right that Julia has many more features and libraries available, but I do have my eye on Rust as something to start using the next time I start a new project because it seems to be a great language for developing software that is intended to be run in within-node parallel, and it may be useful if only to write libraries that handle specifically compute- or memory-intensive bits of larger computations and then pass those results back to Julia to then more easily take advantage of a Julia library. I would warn against agonizing too much about questions of Rust being "as fast as C" and things like that, because for sufficiently serious computations the things that Rust can do slightly faster probably are just a very small drop in the bucket compared to the things that aren't really that language-sensitive, like giant dense linear algebra or something. Like, maybe C or Rust can somehow normalize a vector 0.1 seconds faster than the other, for example. But if you're then going to apply a matrix to that vector, that slight speedup of the normalization is not that meaningful. And you'll probably be calling BLAS to do that matvec anyway, so in the end I bet production-level code in all of the languages you've listed will perform pretty similarly. Granted, this example is contrived and I'm sure there are circumstances where my apathy is inappropriate. But after spending the first months of my job wasting time by micro-optimizing and caring about 0.1 seconds versus 0.01, I try to be very careful about spending too much time thinking about anything other than the really big parts of my computations.
I'm struggling to understand how a focus on frugality is *not* boring, but it's not really important. No sure I care about the `yo` thing either but I lack context. 99% of my job (forensics, IR) is logs and monitoring logs and parsing logs and acting on logs and blah blah blah blah and I don't give a shit about emojis in my logs so I wonder how anyone else can give a shit about emojis in their logs (and so far I have not seen emojis in logs, just stdout).
&gt; Ultimately though, I hope that these comprehensions can be added through macros or syntax extensions A super-simple list comprehension isn't even that difficult! (though I'm sure there is a crate that includes more robust versions of this kind of macro) ``` macro_rules! iter { ($result:expr ; $elem:ident &lt;- $list:expr) =&gt; { { $list.iter().map(|$elem| { $result }) } } } macro_rules! list { ($result:expr ; $elem:ident &lt;- $list:expr) =&gt; { { iter!($result ; $elem &lt;- $list).collect::&lt;Vec&lt;_&gt;&gt;() } } } fn main() { let v = vec![0, 1, 3]; let v = list![elem ; elem &lt;- v]; } ```
Is there any work being done on auto-generating a TypeScript `.d.ts` file for your `wasm`'d Rust? 
Cargo is awesome, but so is Maven when you get used to it. Of all the languages I've worked with, Rust and Java has the best tooling by far. Java tooling is much more mature though, naturally for such an old language. If you're coming to Rust from Java and expect radically better tooling, you're going to be disappointed.
Going to be doing the usual and working on [tarpaulin](https://github.com/xd009642/tarpaulin) issues. Also going to the London Rust groups show and tell.
`wasm-pack` already does this for you!
Amazing! Thanks for the info Steve! I guess I skipped over that part of the post or something.
It wasn't in the post :)
I've only just begun, but I'm working on a 6502 core and development tools written in Rust that targets wasm. I use wasm-pack and pack and publish the wasm file to npm, then include the node module in another JavaScript project which will eventually be the user interface for an emulator.
Yes, indeed. I've used this technique from time to time when profiling reveals some non-trivial amount of time shuffling bytes around. One common area where this comes up is if you have a big error type. Functions returning a `Result&lt;T, Error&gt;` end up becoming large as well. Internally, if you represent your error as a `Box`, this can fix things and has very little cost (unless your error cases are both common and performance critical).
Hey, I'm a beginner at Rust. I wanted to compare Go and Rust at calculating primes, to see how they'll run with different algorithms. Although Rust was faster, I found Rust to be significantly better at having a smaller memory size.
• What is the most efficient way of going from a [u8] of ASCII representation of floats and integers. Found the atoi crate, is there something similar for floats? • Can byte slices be used as HashMap keys?
I’ve used Maven since 1.0 days, I’m plenty used to it. Cargo is better because it knows what it’s for and punts on everything else. There’s an equivalent happy path for Maven use, but damned if I’ve ever been on a project that’s managed to stay on it.
I'm working on a small example project that reverses gifs. Just to explore the toolchain and rust and to get a feel for the whole rustwasm thing. But I've hit a dead end recently. I can't manage to get the wasm module working inside a WebWorker loaded via webpack/worker-loader :/ If anyone is interested/wants to take a look I can push it somewhere public.
cli disk usage utility on top of ignore:: directory walker. [https://github.com/dzhibas/ripdu](https://github.com/dzhibas/ripdu) so i don't need daisydisk anymore 
I wonder how quick this would be in Go if you alloc'd a `*big.Int`, kept doing an `Add` on a prealloc'd big.Int for 1, and did a [ProbablyPrime](https://golang.org/pkg/math/big/#Int.ProbablyPrime) check before actually checking. Probably no benefit. Also, you should use the benchmarking approach they use (essentially tests, but taking testing.B and looping). There are lots of other things to say about Go and primes for actual crypto use, but I'm in the wrong sub, heh.
OK, yeah, I was reading the cargo docs and it mentions this, but I'm not entirely clear how this actually shakes out in the organization. I may just need to read further. I see that I can have both a `lib.rs` and a `main.rs`, but I'm still not clear how it builds from there. Say I create a crate `foolang`with a `lib.rs` with a pub fn `eval()` , and then a `main.rs` with a `main()` just wraps an input loop around `eval()` ... will Cargo just automatically build this as both a library providing `foolang::eval()` and also a `foolang` binary? Or is there something I need to do here to make what I want happen? And the `bins` directory, I presume it makes executables for each file based on their name? So if I wanted to call my shell binary "foosh" I just make a `foosh.rs` with a main() inside, and Cargo will build a `foosh` executable? 
I can't seem to figure out the issue here, can anyone shed some light? russ@RussDev:~/projects/rust/test$ rustc --version rustc 1.27.0 (3eda71b00 2018-06-19) russ@RussDev:~/projects/rust/test$ rustc - -o test &lt;&lt;&lt; 'fn main() { println!("This does not work!"); }' russ@RussDev:~/projects/rust/test$ ls russ@RussDev:~/projects/rust/test$ russ@RussDev:~/projects/rust/test$ echo 'fn main() { println!("This does not work!"); }' &gt; test.rs russ@RussDev:~/projects/rust/test$ ls test.rs russ@RussDev:~/projects/rust/test$ rustc test.rs -o test russ@RussDev:~/projects/rust/test$ ls test.rs russ@RussDev:~/projects/rust/test$ 
Might be worth mentioning then :) I know for a lot of TypeScript devs, that would be a huge deal and make Rust a very attractive alternative to some of the other compile-to-wasm options.
It'd be cool to see this compared with Swift as well.
Veering a bit off topic, but Maven was the first build system for me that, given a random project, there was a very high probability that it would just build without any fuss. So far my experience with Cargo is just as good, but other than for dependency management and testing, I haven't really gotten to try it out.
RustFest gets good credit by people actually attending. It's nothing you can force, but we really enjoy working on these things. If I had more time, I'd actually like to write about some things, but yeah, we're back at the post ;).
The only thing I could find is [`rug`](https://crates.io/crates/rug) which has [`Float::parse()`](https://docs.rs/rug/1.1.1/rug/struct.Float.html#method.parse); however, that parses an arbitrary-precision float which incurs an allocation and requires a rounding conversion to fixed-precision machine floats. I would just use `str::from_utf8()` and `str::parse()` in the stdlib, both are highly optimized (the former especially for ASCII input). You can use `str::from_utf8_unchecked()` to skip validation if you're *absolutely sure* that your input is valid ASCII. As for `HashMap` keys, slices of any element type that is `Hash + Eq` can be used, and that includes `&amp;[u8]`.
Thanks :). That's really nice to hear! Also thanks for helping out with the Hack &amp; Learn from time to time! &gt; P.S.: The eurucamp link is broken ;) Ugh, it seems they are all down. I need to check on that. I pushed a change linking to media.eurucamp.org and highly recommend the Joseph Wilk videos there! (especially the music performance) You'll also recognise a RustFest Keynote speaker there ;).
I think you're giving arguments in the wrong order. For compiling from stdin, try: rustc -o test - &lt;&lt;&lt; 'fn main() { println!("Hello!"); }' Similarly, for using a file, I think rustc expects it to be the last argument: rustc -o test test.rs
I find this very confusing. What’s the point of the edition if you still have to target a specific compiler version?
Wow, that's unfortunate. I would have thought it would behave like monad bind for Either in Haskell and just return the error value...
I would have preferred something like `internal`. At least that’s more obviously a visibility modifier. 
Yeah totally!
I think you'll be more specific, because `&amp;T` is always `Copy` (and `&amp;mut T` is never `Copy`). I suspect the problem there is having a `&amp;i32` and the function expecting an `i32` to be returned, so some sort of dereferencing is required (and either `*...` or `....clone()` would work).
I dunno. It's a bit "any use case you like, as long as it involves `npm`". [Last time this came up](https://www.reddit.com/r/rust/comments/8d6kjp/hello_wasmpack_mozilla_hacks/dxl2ts0/) the alternatives were apparently [`stdweb`](https://github.com/koute/stdweb) or calling `wasm-bindgen` directly with `--no-modules`. Will the book cover these at all?
Using `AsRef::as_ref` instead of `String::as_str` is a whopping one character shorter. You can also use a closure performing deref coercion though it doesn't look as clean: `x.as_ref().map(|s| &amp;**s)`. If you're using this pattern a lot though, you could implement an extension trait to wrap it into one method call: pub trait AsOptRef&lt;T&gt; { fn as_opt_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;; } impl&lt;T, U&gt; AsOptRef&lt;U&gt; for Option&lt;T&gt; where T: AsRef&lt;U&gt;, U: ?Sized { fn as_opt_ref(&amp;self) -&gt; Option&lt;&amp;U&gt; { self.as_ref().map(AsRef::as_ref) } } Stick that trait and impl somewhere and then import it in every file use utils::AsOptRef; takes_opt_str(x.as_opt_ref())
Once nebulet becomes a bit more mature, I'd love to see a blog post on it on the rustwasm blog!
Yep, that's most of it. There's an additional thing: many companies using open source are less in the habit of giving back to contributors to the software they use, even less so the communities they are built on. It's not necessarily out of bad faith, often, they aren't quite aware there. Now, I appreciate that we found a ways to do individual donations to people creating software. I think that's great. But it sometimes leads to an unfortunate situation: individuals paying other individuals for the stuff they use at a for-profit company. I call it the "FOSS employment tax". I want to raise the awareness that the structure we build is to _the benefit of companies_. They reap the benefits. This funding drive and the amount is a good way to raise that awareness. For that reason, I also don't want money from Mozilla. We need to grow a little beyond that. This does not rule out maybe taking individual donations sometimes in the future. But for now, I would prefer if these would go to your favourite artist, creator of a truly FOSS project or just awesome hacks.
Essentially it's a new flavor of the language, with better idioms and some new features that can't exist in the old edition due to compatibility requirements. 
Your best bet here is to look at [the `-sys` crate's build-rs](https://github.com/alexcrichton/git2-rs/blob/master/libgit2-sys/build.rs). Looking through it, it appears to link `libgit2` statically, but `libgit2` links `libssl` dynamically (as it's expected to exist on the system already).
&gt; including reacting to the UB before the UB is dynamically hit, just because of its existence in potentia I think you mean "including reacting to the UB before the UB is dynamically hit, just because it *inevitably will*". I looked it up; ["in potentia" means "capable of development into actuality", while the way UB propagates is more related to what the compiler can guarantee will happen](https://www.merriam-webster.com/dictionary/potential). Consider a C program that divides by a user-supplied number: int main() { int k; scanf("%d\n", &amp;k); printf("If the user does not type a `0`, then this text must be written to the console; if the user does type a `0`, then this text might not be correctly printed out.\n"); 1 / k; } Because the user input is used as a divisor, the compiler is allowed to assume it will not be zero, even before the division actually happens. That's what it means for Undefined Behavior to time travel. If the user types something other than `0`, though, then the program must print the line out, even though the program is theoretically capable of exhibiting UB. The impact this kind of inference soup has on debugging, of course, is why I hate C.
Ok I think I get now. I think calling it “edition” may be confusing. Most other languages use “language version” or a minor variation thereof for the same concept. For example, the Visual Studio 2017 compiler can compile up to version 7.something of the C# language standard. But VS2015 can only compile up to C# 6.0. It all seems a bit complex to me. 
"has non-AEAD ciphers" != "does not have AEAD ciphers". OpenSSH has both non-AEAD \_and\_ AEAD ciphers.
Crosspost of my comment on the [Hacker News submission](https://news.ycombinator.com/item?id=17395760): &gt; Josh (fellow founder) and I have been hacking on this over the past year and working on the foundational crates for much longer! &gt; &gt; As lovers of the bullet-proof Rust vest and creative coding frameworks like OpenFrameworks and Processing we felt it was about time to merge the benefits of the two while attempting to apply some of the lessons learned by these predecessors. &gt; &gt; While the library is certainly still in its youth we have been using it with great success in our recent commercial work and feel it is finally time to share it with fellow hackers and artists who might like to have a play or perhaps even join the project! &gt; &gt; I'll be around to answer any questions for the next hour or two and then will try to make it back on tomorrow before we give the presentation at Protopixel in Barcelona. &gt; &gt; I'd like to apologise in advance for the lack of HTTPS - the site is still fresh and we are in the process of getting it working ASAP. &gt; &gt; If you would like to skip the announcement post and jump straight to the git repo see [here]( https://github.com/nannou-org/nannou). If you are more curious about the API and would like to jump to the Rust reference, see [here](https://docs.rs/nannou). &gt; &gt; Happy creating!
I'm at the gym currently but I'll give this a try when I get home, thanks!
Awesome!
[maplit](https://crates.io/crates/maplit) has macros for map and set initialization. It also supports napping over keys/values. As far as comprehensions go, you've got a few options. Personally I prefer to use iterator functions and collect.
This is the first case the team is working on. You start small, and focused, and then branch out. Those cases will happen, it'll just take some time.
That's indeed the case - I'm going to change it do a `*` deref later.
What is the difference between this and the `stdweb` project?
Unless arbitrary-precision floats are required, using `str::from_utf8()` and `str::parse()` is better than using `rug::Float::parse()`. For instance `rug::Float::parse()` has to copy (with an extra allocation) the original string itself in order to add a nul terminator to pass it to the underlying C libraries, which is probably already going to be more expensive than checked `from_utf8()` for ASCII strings.
You could change [`self._ymd.get(*i).unwrap().clone()`](https://github.com/bspeice/dtparse/blob/7d565d3a78876dbebd9711c9720364fe9eba7915/src/lib.rs#L622) to just `self._ymd[*i]`
I am toying with Rust on Azure Functions a bit, in a way to have serverless Rust, which means that I am mostly writing Node-based code. Imho wasm\_bindgen does great work in bridging the gap between JS and Rust types and once you figure out the caveats, it's quite easy to use crates that don't invoke OS functions for any server-side projects. From my benchmarks, the performance was sometimes really good, sometimes - strangely - quite bad. In summary, JS + Rust couldn't be easier to integrate imho.. Read more here: [https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-2/](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-2/)
&gt; A Slice is a reference pointer to different points in an array, that looks and feels like an array. You can keep on "expanding it" even though in memory, the array keeps being in the same place without changing. &gt; &gt; Although Go uses this concept extensively, Rust does not. Although Rust contains the syntax required to build a Slice, you cannot easily increase the size of the Slice, without running into mutibility borrowing problems. It's a bug in Rust that's being tracked here - https://github.com/rust-lang/rust/issues/43234 &gt; Since I was not able to use Slices in Rust, I had to manually keep track of reference pointers to the array. &gt; Basically, I had a variable tracking the "slice length", and kept iterating through the array up to the "slice length", and kept increasing the "slice length" every time there was a new prime number. There seems to be some confusion in there. The issue linked is the tracking issue for non-lexical lifetimes, which wouldn't really help with growing slices. That being said, the described behavior of slices in go is exactly a pre-reserved `Vec` in rust, so it wouldn't need to do anything different from the previous, `Vec`-based case.
Thanks for your efforts! I found using Rust with WASM (on Node, not browser) was really easy and once you got the hang of it, debugging also works :D Sometimes the performance of WASM vs JS was/is a bit surprising, is there a good resource on that? :)
Thanks. I tried to follow the advice in the csv crate to use `Byterecord`s for improved perf. I even used the `from_utf8_unchecked`-trickery, since I know 100% that it’s valid utf-8. That actually turned out slower than using `Stringrecord`. Hm.
Wow, looks like a ton of effort went into this! Congratulations on the release, it looks great!
That still didn't work. Very odd. I've tried uninstalling and re-installing to no avail.
&lt;3 Probably wouldn't have happened like it did without all your Rust help in the early days! (what, 4ish yrs ago now???)
Just a question, but you did build this with the `--release` flag, right?
&gt;most optimal solution This is totally off topic and I know that this shouldn't bother me as much as it does, but optimal is a superlative. Things can't be more or less optimal just like they can't be more or less "the tallest" then something else: Either something is the tallest or something is optimal or it isn't. Optimal is not relative. Please don't downvote me to oblivion. This is somewhat important for me for some inexplicable reason :(
Have you looked at the examples on using the CSV crate with Serde? If your CSV doesn't name its columns you can still deserialize rows to a tuple, or even a regular struct if you use `ReaderBuilder` and set `has_headers` to `false`.
Can someone help me compile this? why does it need move ||? why mut is not working when non-mut is? [https://play.rust-lang.org/?gist=3ca28ad624fb3ca3c01314f1fe084cae&amp;version=nightly&amp;mode=debug](https://play.rust-lang.org/?gist=3ca28ad624fb3ca3c01314f1fe084cae&amp;version=nightly&amp;mode=debug)
In [mutagen], I have some code that is very regular and thus a good fit for code generation. Unfortunately, macros aren't up to the task, so I simply write out the Rust code in my `build.rs`. However, I just got an error on `cargo publish` – it appears this is no longer allowed under the (new?) validation scheme. Is there a way to allow this or what is the preferred method of build-time code generation?
IF it isn't doing a memcpy, what is it doing to accomplish the bit-wise copy? Wouldn't memcpy be the most efficient? Or are you saying that it will only not memcpy when the value is something small enough to be moved with a single (or few) load, store, or move instructions?
I actually tried to get started with the Rust and WebAssembly book (on Arm) but I couldn't compile the Hello World program because of this error: error: linker `lld` not found | = note: No such file or directory (os error 2) I am kind of confused, because lld is supposed to be packaged with Rust.
Remember, like that quote says, using Box::new still does a memcpy on creation/initialization. There's crates that you can use to avoid that too (`boxext` I think).
&gt; it will only not memcpy when the value is something small enough to be moved with a single (or few) load, store, or move instructions? Yes. This
Well there is a comment in SO below that that says: &gt; @Pierre-Antoine: In Debug, yes, for now; this is why placement new is so sought after. In Release, the stack copy should hopefully be optimized out anyway, but this may lead to Stack Overflows in Debug that prevent you from testing your code :( So it looks like in Release they do have an optimization to avoid the extra bit-wise copy 
\+1000
Tor, Bitcoin, and truecrypt. But yeah I agree it would be better for us to have obvious disclosure. That's the reason I'm not installing this tomorrow... :-/
Would it be possible to get benchmarks?
\&gt; As a side note, golang does have higher-order functions You can make things like map/fold in rust but it is awkward and the community discourages doing it: [https://github.com/robpike/filter](https://github.com/robpike/filter)
I think for now they only package it for the major toolchains (Tier 1 I think)
Wheres your boy Fermat and his little theorem?
I work alongside bioinformaticians, and for the most part they're stuck gluing together "pipelines" from other people's code. They have jobs that can run for several days or even weeks, I suspect in part because of poor performance and lack of parallelism in the individual pipeline stages. I asked them why they can't write their own tools (in Rust, for better performance) and was told that in order to get their work published they have to use tools that other people have written papers about and published results with. I have always thought this was a silly restriction, but I'm not a scientist so maybe there are good reasons for such things. The effect is that trying to introduce anything other than Python and Bash into the environment is a complete non-starter. 
Shouldn't be too hard to get a good estimate - I'm already replicating the Python test case. More info to come soon.
I suspected it required at least one allocation for the floating point container, but I didn't consider the need to create a C-string as well. Such an inefficient paradigm.
&gt; because lld is supposed to be packaged with Rust says who? it hasn't ever been, as far as I know. it might be the default one day. lld is the LLVM linker. Rust currently uses the GNU BFD linker by default for normal projects. Have you tried installing lld on your system? `llvm-lld` might be the package name.
"Another way to say "loop until you reach the square root of the number" is "loop until your iterator ^ 2 equals the number". I use this due to computers preferring working with integers over decimals." If you do it that way, you have to calculate iterator^2 every time, whereas you could just take the square root of the number one time and then round it to an integer. Would that not be faster?
I actually don't agree. I presume that we agree that "optimal" means "best", or, in more easily reasoned-about terms, "at the maximum of a fitness function". Thus, "an optimum" is the maximum of that fitness function. I would argue that "more optimal" means "producing an output of a fit function closer to its maximum". You could also express this as "nearer the optimum", or "nearer the maximum of the fitness function", whereas "less optimal" means "further from the maximum of the fitness function". Here, my fitness function includes several factors, including whether or not the code compiles, whether or not the code operates correctly, how many errors the compiler emits based on the code, how "pretty" the code is, how efficient the code is, how much of the code can be lazily evaluated, et cetera. Several solutions were provided which came _closer_ to fulfilling all of those requirements than did my original code, but the comment by /u/CUViper came closest of all. Therefore, it is the input producing the fitness function value closest to its maximum, or, in other words, the "most optimal" solution.
This is very cool! Glad to see I'm not the only one who has wanted something like this to exist. Especially that the examples show that for a lot of the GUI code, you don't need to be thinking about ownership, as lots of it just gets folded into a more fluent pattern. Will be interested to see where you take it, and what kinds of projects build on what you'd made.
[removed]
Why would you care to optimize a benchmark?
Will it be possible to replace 100% of the javascript on a site with wasm rust? Basically: will it be possible to make a website with only html and Rust?
there's at least 3 patterns that achieve this 1. what you described, `hkdf(Salt(something), Input(something2), Info(something3), Len(32))` 2. something like `hkdf(HkdfParams { salt: something, input: something2, info: something3, len: 32 })` 3. using the builder pattern, `Hkdf::new().salt(something).input(something2).info(something3).len(32).build()` what many libraries do in practice is 3), but what I meant was 2), but it becomes less clean if there's many functions with slightly different parameters. so I think your approach looks better. but **anything** that shows you that you swapped input and info would be excellent.
For fun I would imagine. No need to bite my head off. 
Yes, it’s in the works! Check out stdweb if you are interested in running Rust in the browser with no JS. 
I've mostly felt that rust's initial marketing push as "really fast" was a mistake that undersold its utility as a productive, correct language. I worry that this is a step back in that direction, which is a direction I've had to fight against repeatedly when telling others about rust.
Wasn't it just in the latest release that Cargo forbids build scripts from writing to `src/`?
there's also an approach like \`hkdf!(salt: something, input: something2, info: something3, len: 32)\` which is like what \`println!\` uses to workaround the lack of keyword arguments in \`println!("{x} {y}", x = 1, y = 2)\`. but that's ugly because macros can do wilder things.
You should be able to create a separate file for the benchmarks so that your crate runs on stable and your benchmark suite on nightly.
[removed]
&gt; Even though we declared the array to have this much space early on, both Rust and Go did not allocate that much memory. Both of them seemed to wait and only use memory when it was necessary. Uh what. An array is an array, it can't be allocated while there are references to it. That's an OS thing, to overcommit memory.
&gt;The memory use was most surprising. A 64 bit 20,000,000 integer array should take up 156,250 KiB of memory. &gt; &gt;Even though we declared the array to have this much space early on, both Rust and Go did not allocate that much memory. Both of them seemed to wait and only use memory when it was necessary. I'd have to investigate further to be sure, but I'm pretty sure what happened with Rust is that the huge alloc was serviced with mmap, and since most of the pages were never touched physical memory was never allocated for them by the OS. But from the application's perspective that memory absolutely was allocated. The same would happen in C or C++ or whatever.
You might want to try optimizing your Cargo build for Rust, using the techniques [here](https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Rust/hyper/Cargo.toml#L26-L29). These flags are almost always set in benchmarks (that I've seen), so it might be a good idea to check with/without them and see what difference (if any) they make in your use case.
Good thing I'm not an artist, because if that's a "doodle", then what is it called when I draw something? Paleolithic? Nice Ferris!
I'm a noob having trouble with the GenericArray return values of Rust-Crypto::Sha2: fn dhash(input:&amp;[u8]) -&gt; [u8;32] { Sha256::digest(&amp;Sha256::digest(input)) } How do I copy the result into a [u8;32] or other readable byte vector or return a slice? The error of returning the GenericArray is an enormous type, requiring typenum::U32 and more, that doesn't work when used: error[E0308]: mismatched types --&gt; src/blockheader.rs:43:5 | | fn dhash(input:&amp;[u8]) -&gt; [u8] { | ---- expected `[u8]` because of return type | Sha256::digest(&amp;Sha256::digest(input)) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected slice, found struct `generic_array::GenericArray` | = note: expected type `[u8]` found type `generic_array::GenericArray&lt;u8, typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UTerm, typenum::bit::B1&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;&gt;`
This is fairly recent (see https://github.com/rust-lang/cargo/pull/5584). Maybe /u/matklad has a suggestion on how you're supposed to generate code?
Squee!
I also work with bioinformaticians (am a grad student in Chemistry here, but we work with some bio groups). Likely they need to use the packages other people wrote because it makes it much, much easier for a peer-reviewer to accept their results if they were obtained through another peer-reviewed piece of software. If you write your own tools, you need to spend a lot of effort publishing the source code, vetting it, and convincing a reviewer that your code is both functional and that you didn't add something into the code that could cause your results to be erroneously good. This is because (for good science) other scientists need to be able to reproduce your results - which they can only do if they have access to your source code. Once they have access to the code, they *can* (although they don't always) nitpick it until you just give up and submit your article somewhere else.
It's not helpful for a language comparison, but if you have a real need for primes, the `primal` crate is very fast. extern crate primal; fn main() { let primes: Vec&lt;_&gt; = primal::Sieve::new(20_000_000) .primes_from(0) .take_while(|&amp;p| p &lt; 20_000_000) .collect(); println!("Found {} primes.", primes.len()); } Takes 20-30 milliseconds here.
[removed]
Square roots are much more expensive to compute than squares are.
You could send it over a channel: https://doc.rust-lang.org/std/sync/mpsc/index.html.
Personally, I don't find "thinking about lifetimes" to be much work. I build most of my data as stack-allocated views into other data, and most things work quite well. Sometimes I get a confusing error, but for the most part, resolving them just means redesigning a bit. On the other hand, I've spent months writing programs that, in the end, simply did nothing because Java was not fast enough to make it do things in a usable time window (the next steps being reconfigure the GC and/or reimplement dependencies.) So much of my time has been wasted on poor default performance that I'd argue the effort it takes to learn to avoid a GC is always worth it. Once you know what you're doing, a GC is basically a crutch you don't want.
But you compute the square root a single time, instead of squaring the iterator on each step.
I'm out of the loop with the whole WebAssembly thing, I just skim through some article about it every now and then. If i understand correctly, Rust could be used to write libraries that FE developers (presumably JS devs) would call. People that are more into web-deb, do you think Rust has a chance of becoming a popular language for writing these sort of libraries?
Wow. All those `function interface {}` is like the holy grail of type unsafety. No wonder why a `for` loop is recommended
It seems so. Why was this done and what should be done instead?
Napping over keys and values means that I have a luxury couch completely filled with keys for expensive cars?
*sigh* sure
Hmm, I'd disagree with that since the frontend lot are fickle and if you don't solve everything straight away that's fine, whereas the backend people are usually much less flexible as they're interested in longevity and stability while also meeting their requirements, and if they have a bad experience you might not have another chance for adoption.
Using sqrt looks slower to me: https://play.rust-lang.org/?version=stable&amp;mode=release
No, LLD is packaged on Tier 1 platforms and is necessary for wasm32-unknown-unknown.
This is really great! Also cool that you use conrod! About https://docs.rs/nannou/0.7.0/nannou/ui/struct.UiCell.html Call it UiJail, RestrictedUi, maybe SharedUi (in the sense it's used in a scope where you can't mutate in certain ways because someone else also has a reference) But not UiCell please.
`interface {}`has the same type safety as `void*`.
Yeah, using brotli-wasm in our web compiler https://github.com/choojs/bankai
That doesn't seem fair. Instead you'd write let m = (n as f64).sqrt() as u64 + 1; (2..m).all(|i| n % i != 0) which is indeed mildly faster once you bump the limit. Also, that `sqrt` produces some scary-looking asm.
If you skip the conversion to floating point inside the take\_while, it is faster with sqrt. See [https://play.rust-lang.org/?gist=1e2a386ab282e201cabb78d2f835a3ab&amp;version=stable&amp;mode=release](https://play.rust-lang.org/?gist=1e2a386ab282e201cabb78d2f835a3ab&amp;version=stable&amp;mode=release) I upped the iteration count and duplicated the code to make measuring slightly more robust. FOr actually testing this kind of thing, something like criterion should be used.
Didn't know what untrusted is: * https://github.com/briansmith/untrusted * used by those crates: https://crates.io/crates/untrusted/reverse_dependencies
Very new to rust so I'm building a simple crate to get some info about a webpage (title, description, text content, opengraph etc): [https://github.com/orottier/webpage-rs](https://github.com/orottier/webpage-rs)
Congratulations! I've been following Nannou for as long as I've known about Rust. I'm only diving into learning the language now, but as someone who works with OpenFrameworks on an almost daily basis I'm very excited to see the same creative coding potential budding in this wonderful community. This is going to be such a fun tool to help me (and I hope many others) to get comfortable with Rust! I hope that someday I'll have what it takes to contribute to such a fantastic project. Also great taste in music :)
I’m working on exposing simple WebAssembly versions of ripemd160, sha256, sha512, and sha1 (the hashing functions used in bitcoin and other cryptocurrency projects) here: https://github.com/bitjson/bitcoin-ts/pull/8 Interestingly enough, benchmarks for the WebAssembly versions are significantly better than the built-in Node.js options for all input sizes. (I might write a blog post about it after the PR is merged.)
Precisely yes.
Bugfix PR in case we can learn from this: [briansmith/untrusted#20](https://github.com/briansmith/untrusted/pull/20)
Thanks! I'm pretty sure I have an ad-hoc, informally-specified, bug-ridden, slow implementation of half of this in my last two JS codebases! (I mostly ended up using promises as result type though.)
That only happens because you observe the address of the struct. In C and C++ it would not be permitted to optimize away the copy, since the two structs are guaranteed to have separate addresses. In Rust it is permitted, but LLVM doesn't know that, so it calls \`memcpy\` to emulate C behaviour. In real scenarios it's quite rare that you actively observe the address of the data, and LLVM will understand that it is allowed to do the optimization. When you remove the lines that print the address, the \`memcpy\` calls disappear from the assembly.
gotcha, but they should still be able to install lld on their system
`ignore` is really a marvelous piece of machinery, hats off to @burntsushi. I built my find-like `findr` on top of it, with Rhai to evaluate conditional expressions about paths.
We were discussing the recent unsoundness revelations around actix-web and wondered if a community initiative (like the crate blitz) could take off and do the hard but necessary job of auditing common dependencies.
so Azure actually supports Docker Functions. have you considered compiling your code to native, stuffing it in a Docker, and using that? performance should be better and more predictable than the nascent WASM interpreters, I'd imagine. https://medium.com/@mariano.d.martin/azure-functions-with-docker-f7a361f0ac75
Small clarification to the above... Hope I've got this right...still learning: \`flat\_map\` on the \_iter\_ throws away the \`Err\`, but flat\_map on a \`Result\` (i.e., \`and\_then\`) does retain the \`Err\` (like bind does).
That's abomination.
I wrote several stochastic simulations and optimization algorithms in Rust (MCMC, KMC ("Gillespie"), simulated annealing). They are much faster to write correctly, and sometimes they even run faster than my C/C++ versions. I found Julia promising and have followed it for some time, but was ultimately put off by the agonizingly slow starting time and the verbosity of the language. I think they tried to stay close to MATLAB to make the transition easier for people who came from this language, but it just "feels MATLAB" to me.
Totally; that’s what the benches directory is for.
The same static safety, but significantly better dynamic type safety.
A panic is a security advisory?
I'm trying to (Have a project that renders in WebGL and Vulkan with much repeated code between TS and Rust), but am unable to get bindgen or stdweb working due to finding no way to configure InstantiateStreaming or Instantiate.
That would be a good idea, and could be achievable with a reasonable amount of work if it's aiming at unsafe code. In this case, there is no unsafe code involved, and then it does “only” triggers a `panic!`, which is one order of magnitude less scary. But if you want to audit the whole code of all crates to find this kind of bugs, I'm afraid the task is way too big to be successful. Bound-checking are a thing in Rust for a reason, that's because you never never be 100% sure you're code doesn't contain this kind of bugs (unless you're writing [Idris](https://www.idris-lang.org/) code maybe ?)
Cool post, I have never actually seen that in action :D unfortunately though it has a lot fewer integrations (afaik) like queue triggers, db triggers, etc. and JS is a primary citizen and by extent WASM makes Rust a primary citizen :). Alternatively one could of course load native libraries using C# (just like batch files right now) 
Many people came to Node because of the performance; it’s generally pretty compelling to many of the people I talk to. Note that this is the *initial* vision; the use case that’s being focused on first.
&gt; while individuals (rarely but that is still too often) may expect preferred treatment for the donations. This definitely happens with companies as well.
I don't know, I assume it's a cultural thing. I'm not into the `npm`/`node` ecosystem, but indeed, this seems to be widespread there. Anyway, it's mostly harmless, and I don't mind it that much.
Cool! I didn't know about the reverse dependencies page. Pretty neat.
&gt; Combination of these two programming errors (one in untrusted and another by user of this crate) could lead to a panic and maybe a denial of service of affected software. The latter is the important part.
There is [cargo audit](https://crates.io/crates/cargo-audit) which could help based on the dependencies but a general overview of unsafe code will be good too.
Another idea will be to run cargo audit on uploading to crates.io but this won't fix the libraries that are already affected but haven't made a new release so far.
its a compiler written in Rust [https://github.com/Lapz/underscore/tree/x86](https://github.com/Lapz/underscore/tree/x86) 
Thanks for the clarification!
BTW you already can use crates from [RustCrypto](https://github.com/RustCrypto/hashes) for it without any problems.
fyi: https://github.com/rust-bio/rust-bio
Yep, it's a huge issue. The advantage is that with larger sums, that's easier to manage.
Is there any way to check if two packages have dependency relation from command line?
If you say it's the closest to the optimum or closest to being optimal that makes sense, just like you can say "He is closes to being the tallest". [Stackoverflow says that it's logically meaningless but so widespread, that it's idiomatic, which I think is a satisfactory answer for both of us.](https://english.stackexchange.com/questions/114272/is-more-optimal-correct-grammar#114274)
cargo-tree is nice! But then you'll have to scan visually. Maybe this is good enough: cargo-tree | grep "the-dependency" 
100% certainty is theoretically possible but practically impossible (or simply too expensive). The idea is to audit "popular" or "foundational" crates. But, it's a big job anyway! I think careful people are doing auditing anyway, so it would be useful if these audits could be pooled.
You can actually allocate value directly on heap on Nightly using "box" keyword ( feature(box\_syntax) ).
Listed in my ["Rust-enhancing crate list"](https://users.rust-lang.org/t/list-of-crates-that-improves-or-experiments-with-rust-but-may-be-hard-to-find/17806).
So cute! Like it's trying to borrow something…
I'm looking for a way to take screenshots of a specific window (preferably, but entire screen will do too) on any desktop OS. Performance is the key, I will need to take at least one screenshot per second and I wouldn't want my tool to use all the resources. I feel pretty comfortable with rust itself, just need someone to point me to the right direction. If you think other language will work better for this task, please advise me which and why.
`cache` is ok for small projects, but rust tends to consume *a lot* of space for larger ones. Our current cache is ~20Gb and cache upload/download by GitLab becomes the slowest stage of the build. I described my approach to builds on my [blog](https://not.plhk.ru/gitlab-ci-rust/) for anyone interested.
[removed]
The release said something about `src/` should be considered immutable. Some guesses as to the rationale: * changes to the contents of `src/` cause the project to be recompiled, but if it's changed by the build script then it will cause the project to always be recompiled. * `cargo clean` doesn't touch `src/` so there's no automatic way to remove generated files * generated files have to be manually added to `.gitignore` It looks like you're supposed to use the path in the `OUT_DIR` environment variable instead: https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#case-study-code-generation This makes sense as this always falls under `target/` which is already ignored by Git in the default project template, modifications don't invariably trigger recompiles, and is covered by `cargo clean`. There may be other reasons but these alone seem compelling enough.
Also there is a clippy lint that has good heuristics to warn against large structs so that you know when to start boxing them. 
looking myself in a mirror
Thanks, I'll update mutagen to use this variant, too.
You guessed wrong this time, Java has checked exception, which is a type system support to let you know what expected exceptions are. (On the other hand, the feature is very unpopular in Java and that's why it's not in C#.)
You can abstract a good deal of it away, see: https://blog.burntsushi.net/type-parametric-functions-golang/ and https://godoc.org/github.com/BurntSushi/ty and https://godoc.org/github.com/BurntSushi/ty/fun
I try avoid `SmallVec` (and prefer either `ArrayVec` or a `Vec`) because of this. `SmallVec` is the best and worst of both worlds. You can grow beyond the `ArrayVec` capacity, but you always pay the price of full memcpy on the struct even though the elements might be boxed on the heap.
The whole `box` feature set is being deprecated/removed so... I don't know if using that is something to be encouraged.
The problem here is that if `T` is small (e.g. zero sized) and `Error` is large, you will be always copying `Error`-bytes around even though that `Result` might only contain an `Ok(T)` which... is nuts... 
&gt; I'd have to investigate further to be sure, No need, this can only happen if you have overcommit enabled.
You seem to confuse optimal and ideal. (when you stay close to their initial Latin meaning and don't factor in the corrosion of the classic superlatives in American English compared to European languages, which definitely happened)
Or pinch you lovingly? As in, 'Did you really intend to do that?'
Awesome, I've been experimenting with injecting Rust via wasm into js, but I've no experience as a front end developer and am desperately looking for some guidance and best practices. 
Couldn't help but chuckle at this.. security focused! &gt; curl -O https://oxy-secure.app/oxy &gt; chmod +x oxy &gt; ./oxy --help 
There has been some discussion about this topic in the user forum: [https://users.rust-lang.org/t/numerics-math-foundation/7247](https://users.rust-lang.org/t/numerics-math-foundation/7247) As others have mentioned it's not there yet but improving over time. There is also ["Are we learning yet" ](http://www.arewelearningyet.com/)which lists crates usefull for machine learning, data processing and scientific computing.
What do you propose? Which argument would you make? How practical is your argument for people writing Rust code today?
Rust can also call into JS for front-end and in the future when the wasm DOM API is available, you'll be able to use wasm to more or less replace JS.
&gt; front-end and in the future when the wasm DOM API is available, you'll be able to use wasm to more or less Yes, but is it realistic that people used to writing JS code will want to learn Rust? All the main benefits of Rust (memory safety without GC, zero-cost abstractions...) are probably not so important for most of the web-developers? Or at least not enough to justify learning the harder parts of Rust, like borrow checker? 
Fixing the compiler bug behind it might be a better investment of time than adding workarounds for it to the whole ecosystem: https://github.com/rust-lang/rust/issues/47490 
This looks very interesting. Congratulations!
At the very least, I won't have to learn JS. And plenty of people choose to write other languages that compile into JS instead of writing JS and it's not just a win for Rust, it's a win for all languages that compile into wasm. 
 ~/go-vs-rust-primes $ time ./prime_slice_memory 1270607 real 0m7.397s user 0m7.392s sys 0m0.004s ~/go-vs-rust-primes $ time ./prime_growing_memory 1270607 real 0m7.325s user 0m7.325s sys 0m0.000s Something that is *extremely important* during performance measurements are: * Compiler version * CPU specs * Whether or not you're browsing Reddit at the moment. In a recent paper I wrote, I plotted the performance of an application in function of the string length. You can still see a dip the plot, which was caused by me opening Reddit since I was bored. ~/go-vs-rust-primes $ rustc --version rustc 1.26.0 (a77568041 2018-05-07) ~/go-vs-rust-primes $ lscpu Architecture: x86_64 CPU(s): 4 On-line CPU(s) list: 0-3 Thread(s) per core: 2 Core(s) per socket: 2 Socket(s): 1 NUMA node(s): 1 Vendor ID: GenuineIntel Model name: Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz CPU max MHz: 3100.0000 CPU min MHz: 1200.0000 BogoMIPS: 4988.33 Virtualization: VT-x L1d cache: 32K L1i cache: 32K L2 cache: 256K L3 cache: 3072K 
&gt; At the very least, I won't have to learn JS. And plenty of people choose to write other languages that compile into JS instead of writing JS and it's not just a win for Rust, it's a win for all languages that compile into wasm. Great, good luck with that, I'd like to see Rust succeed in more than one area! 
&gt; Since the only problem with this feature There are a lot of problems with the feature, in particular when it comes to uninitialized memory and what not. It wouldn't surprise me if `mem::uninitialized()` would be removed in Rust 2018 (and maybe `mem::transmute()` as well). Might happen if we get `MaybeUninit` before that.
&gt; I prefer pub(crate) over crate as a visibility specifier. I think it is much clearer and less confusing. Also, I don't remember seeing discussion about this While I like a lot of the module changes, I was originally somewhere between neutral and ok on this. After seeing it in the edition guide, I soured on it and worry we'll regret and remove it in a later edition. My biggest concern is readability for someone new to Rust. It does not look like a visibility marker imo so the intent will be confusing which will add on top of an already "noisy" first impression people have.
I had issues with the cache growing quickly when I cached `~/.cargo` and `target`, I've swapped to only caching `~/.cargo` which doesn't change much and using [sccache](https://github.com/mozilla/sccache) with [minio](https://minio.io/) as the backend for handling the rest. Ended up being a bit faster as uploading the cache was a pretty slow before.
Haha sounds like this is something you reach for regularly then! There are a couple J's specific combinators I added for promises. They generally add the word 'await' to the name. Promises work fairly well like that since they automatically flat map themselves, but type checkers can't type the catch because anything that throws on the chain can bubble into that catch. I end up using Promise&lt;Result&lt;T, E&gt;&gt; by resolving happy path and error cases, then using the catch for things that are truly unexpected like syntax errors.
Your practical argument doesn't sound very practical to me. Sitting on my thumbs waiting for a bug to be fixed that may or may not fix my slow program doesn't sound more practical than "use a box in some cases and be happy." I think I've needed to use this "workaround" two or three times in my 4 years of writing Rust. &gt; "always Box your errors if they can be large" I didn't make that argument.
&gt; in ~~rust~~ Go but ftfy
IMO the important part is the opt in by the documentation. &gt; [No part of untrusted.rs's API will ever panic or cause a crash.](https://github.com/briansmith/untrusted#untrustedrs)
&gt; Your practical argument doesn't sound very practical to me. Sitting on my thumbs waiting for a bug to be fixed that may or may not fix my slow program doesn't sound more practical than "use a box in some cases and be happy." I wasn't arguing against the exceptional case of boxing error types, I was arguing against boxing error types as a rule to overcome compiler bugs. &gt; I didn't make that argument. I didn't say you did?
Yes actually leveraging them can be very awkward due to the lack of generics, especially for functional programming styles, but fact remains that Go does have first-class functions and hofs. 
But the stdweb crate seems to be for js interop, why do i need it if i only want to work in rust?
I had Googled for it, but, looking for "rust crate underscore", led to a bunch of links regarding the use of underscores in identifiers. I probably should've searched [crates.io](https://crates.io). That being said, "underscore" seems like a name that is going to be an issue with discoverability.
&gt; if we are lucky, maybe mem::transmute is removed as well. I don't see how this would be a good idea. Sometimes you just need to perform bit-level operations on certain values, and in order to do so you need a way to cast a value into its raw bytes.
yeah I read it later and it wasn't exactly a typo but ambiguous to parse. 
I'm on a Windows computer. I managed to pull this information using `wmic cpu`: |Name|Value| |---|---| |AddressWidth|64| |Architecture|9| |Availability|3| |Caption|Intel64| |ConfigManagerErrorCode|Family| |ConfigManagerUserConfig|6| |CpuStatus|Model| |CreationClassName|94| |CurrentClockSpeed|Stepping| |CurrentVoltage|3| |DataWidth|1| |Description|Win32_Processor| |DeviceID|1980| |ErrorCleared|11| |ErrorDescription|64| |ExtClock|Intel64| |Family|Family| |InstallDate|6| |L2CacheSize|Model| |L2CacheSpeed|94| |L3CacheSize|Stepping| |L3CacheSpeed|3| |LastErrorCode|CPU0| |Level|100| |LoadPercentage|205| |Manufacturer|1024| |MaxClockSpeed|6144| |NumberOfCores|6| |NumberOfLogicalProcessors|10| |OtherFamilyDescription|GenuineIntel| |PNPDeviceID|3301| |PowerManagementCapabilities|Intel(R)| |PowerManagementSupported|Core(TM)| |ProcessorId|i5-6600| |ProcessorType|CPU| |Role|3.30GHz| |SocketDesignation|4| |Status|4| |StatusInfo|FALSE| |SystemCreationClassName|3| |UniqueId|CPU| |UpgradeMethod|U3E1| |Version|OK| |VoltageCaps|3|
&gt; It wouldn't surprise me if mem::uninitialized() would be removed in Rust 2018 - if we are lucky, maybe mem::transmute is removed as well. Taking into account my experience with using SIMD in Rust so far, I think this is a terrible idea.
&gt; if we are lucky, maybe `mem::transmute` No, please. `transmute` has legitimate use-cases and much easier to understand and read compared to the "alternative" dance around pointer casts and explicit reads. Maybe we could add lints which will recommend against pointer transmutes, and which will require explicit type parameters. &gt; I have no idea what crate improves over pub(crate) I guess the main drive is that many think that 10 symbols for signature prefix (which can be used quite often) will be too noisy.
&gt;It does not look like a visibility marker imo Very much this. `crate` looks like, intuitively, it should define or declare a crate, like in `extern crate` and like `mod` defines or declares or module. `pub(crate)` is a bit verbose but at least it's quite obvious that it's a variant of `pub`.
&gt; You will grep by bomb emoji? By rocket emoji?. Good thing `ripgrep` includes fast Unicode pattern matching 😎🤩🤠
Or just use [the G package](https://www.nivenly.com/finally-an-elegant-solutions-to-generics-in-go/)
I find talking to you about this topic to be pretty annoying, so I'm just going to stop now.
&gt; I prefer pub(crate) over crate as a visibility specifier. I think it is much clearer and less confusing. After thinking about this, I prefer `crate` over `pub(crate)` as a visibility identifier, because: 1. I don't consider crate visibility as public visibility, so `pub` there looks like a misnomer to me, kind of like saying the item is public, but not really public, only crate visible. 2. I don't see how this can be confused with declaring a crate, since you would not get `crate Foo;` but `crate struct Foo;` or `crate b: Bar;`.
&gt; I also personally dislike in-band lifetimes and lifetime elision. I like them and think they generally remove the need to write the same thing twice. Having said that, I am not sure how they interact with previously declared lifetimes if the same lifetime identifier is already used, that is I don't know how lifetime shadowing works. For example consider the following: // 2018 edition impl Foo&lt;'a&gt; { fn bar(&amp;self, other: &amp;'a Self) -&gt; &amp;'a Self { // ... } } Which of the following three using edition 2015 is equivalent? impl&lt;'a&gt; Foo&lt;'a&gt; { fn bar(&amp;self, other: &amp;'a Self) -&gt; &amp;'a Self { // ... } } impl&lt;'a&gt; Foo&lt;'a&gt; { fn bar&lt;'b&gt;(&amp;self, other: &amp;'b Self) -&gt; &amp;'a Self { // ... } } impl&lt;'a&gt; Foo&lt;'a&gt; { fn bar&lt;'b&gt;(&amp;self, other: &amp;'b Self) -&gt; &amp;'b Self { // ... } } 
Never was removed because it [doesn't coerce as one would expect](https://github.com/rust-lang/rust/issues/49593), and it seems that no one has had the time to implement a solution.
If you remove `mem::unitialized` then how you will create arrays in complex situations? For example, how would you map array? Also. `mem::uninitialized` gives you the same state as `ptr::read` leaves. So if you frightened of undef values - you have to remove `ptr::read` and `ptr::write` as well.
&gt; don’t consider crate visibility as public visibility I think of anything being visible outside of the struct public. But I can see it from your point of view too. My main problem with it, however, is that’s it’s not consistent with `pub(super)` and `pub(in some_parent_module)`. If those are also ‘public but not really’, surely we should’ve dropped the `pub` there as well?
What is about the copy right? May I use this anywhere or do you protect it? 
I love that the demo site is Rust compiled to WASM.
Good point. Currently the way I interpret `pub(x)` is "public visibility, but constrained to be inside x" whereas `crate` would be simply "crate visibility", which is simpler to think about than "public visibility, but constrained to be inside the crate". Maybe my point of view is what it is because the only visibilities I use are private (the default), public (`pub`), and crate (currently `pub(crate)`), and I think I never used the other `pub(*)` forms.
Well, it boils down to a choice between unsafe and deprecated, yes. [Tracking issue for box syntax](https://github.com/rust-lang/rust/issues/49733)
I should have mentioned that's what I'm using! It was very easy to get working, I'm just working on the making the TypeScript side a bit friendlier. (Purely-functional interface, works in Node.js without `Fetch`/`fs.readFile`.) Thanks also for [your help](https://github.com/RustCrypto/hashes/issues/55) u/newpavlov, the library is fantastic!
&gt; For example, how would you map array? `[MaybeUninit&lt;T&gt;; N]` but you should check that RFC. &gt; mem::uninitialized gives you the same state as ptr::read leaves. `ptr::read` "Reads the value from src without moving it" so it does not leave the source uninitialized. 
Sorry about that.
It also provides Web APIs so that you can interact with the underlying web-browser in Rust directly. 
Ah that's very cool.
&gt; I prefer pub(crate) over crate as a visibility specifier. I think it is much clearer and less confusing. Also, I don't remember seeing discussion about this. This is part of the most discussed RFC on your list. It's the third item on a 440 comment RFC that had two preceding RFCs with 200 more comments. https://github.com/rust-lang/rfcs/blob/master/text/2126-path-clarity.md#summary The RFC has a history section. https://github.com/rust-lang/rfcs/blob/master/text/2126-path-clarity.md#the-community-discussion-around-modules The discussion also discusses that specific change.
&gt; No, please. transmute has legitimate use-cases and much easier to understand and read compared to the "alternative" dance around pointer casts and explicit reads. I think the alternative is to use an `union` although you can of course use the read/write pointer methods. I am not well versed in the issues with transmute, but I've always disliked that a lot of code using it is not portable due to endianness.
I've rebased my rust lldb plugin to work on top of rust-llvm; next up is trying to get everything into the build so that lldb can be in rustup.
Removing `transmute` will not help with portability in any way, people will simply write `&amp; *(u8_slice.as_ptr() as *const [u32; 16])` and it will "work". 
Yeah, I did a bit of research into it after posting this, and found `and_then`. I guess having thought about it, how would the iterator's `flat_map` have the error semantics? I guess I was just naively hoping I could use `impl Trait` as a sort of generic Monad.
Aye. Thanks for the feedback. I can see how I came across as aggressive. I will try to soften up. :-)
Str is an abbreviation of string, so I'd say "a &amp;str".
\`Foo1\` is equivalent. \`other &amp;'a Self\` is not introducing a new lifetime parameter because \`'a\` is already in scope.
&gt;It wouldn't surprise me if mem::uninitialized() would be removed in Rust 2018 It can deprecated so that using it emits a warning, but not removed because crates in the same program − even if they are in different editions − need to use the same `std`. For example `String` needs to be the same type.
My thoughts exactly. I'm in favor/neutral on all the module changes minus the `pub(crate)` -&gt; `crate` change. I initially didn't think about it, but after seeing it I'm not a fan. It just doesn't look like a visibility modifer.
Very interesting! I just up a templating benchmark repo yesterday: https://github.com/djc/template-benchmarks-rs It would be nice if someone added Zapper to it.
Map and fold are part of std as iterator adapters.
&gt; It wouldn't surprise me if mem::uninitialized() would be removed in Rust 2018 In my experience it's common to need uninitialized/zeroed structs when I'm wrapping a C API, especially if one of the functions I'm wrapping is for initializing the struct. Is there a proposal for removing `uninitialized` without forcing a performance penalty on those calls?
There are a lot of JS programmers quite interested in Rust. There’s a lot of ways this manifests, but one example is that embedded development with JS is very popular. But you hit limitations... and rust is there. 
Letsencrypt (also from Mozilla) gives you free certificates in 10 minutes of work, so don't look elsewhere when you have time for it 
It might have been discussed but this also gets into why we need the new RFC proposal. I tried to follow this discussion but it dragged on too long in a single thread, making it hard to track the discussions on the individual points. Being able to have a PR or issue dedicated to a single subtopic, like `pub(crate)` I think will be a big help. As I mentioned in my other comment, there is also a difference in perspective when in the middle of a topic discussion and when you step out of it and look at it again with fresh eyes. When I read the edition guide, I was looking at that section from the perspective of someone new to Rust and that is what changed my opinion from `+0` to `-1` on this subfeature.
Awesome, thanks for this! Will forward this info onto our web dev now.
Does Ferris have a gender?
Don’t forget that you now import things from your package as use crate::foo; So, they tie together fairly nicely IMHO.
The most practical approach I think will be to fully fuzz crates with enabled debug assertions. For example in [flif](https://github.com/dgriffen/flif.rs) crate I am fairly sure it allowed me to catch all overflows and that crate will not panic for any (malicious) input. Unfortunately, it's not that easy for most of crates.
This looks so awesome! Sorry for a question which could have been answered with more research from myself, but does this bundle embedded development as well? I imagine there is a fair amount of that for a suite like this!
&gt; My main problem with it, however, is that’s it’s not consistent with pub(super) and pub(in_some_parent_module). Would `pub(super)` and `pub(in_some_parent_module)` be more clear as `crate(super)` and `crate(in_some_parent_module)`? 
Imo, no. They have nothing to do with crate boundaries, they’re talking about what can access them (hence `pub`) and from what domain, which in both cases is a module, and hence nothing to do with crates
I would love to do frontend web development but the current high-churn Javascript ecosystem makes me dizzy; this is probably a naive question but will it be possible to do web-development without integrating in the Javascript ecosystem using WebAssembly and Rust someday? 
see my edit =)
Thanks for doing this! There is definitely low hanging fruit inside of liquid that just hasn't been a priority.
Some artists go like "look at these doodles" at stuff that I'm like "omg how did you draw that"... so, idk. One-year-ago me would not have called this a mere doodle. =P
🦀
I thought about drawing him holding a `'a` or an ampersand. The one on the cover of The Book is holding what I can only assume is a deref.
If I'm understanding correctly you want to copy a `&amp;[u8]` into a `[u8;32]`. Easy way is to just use `slice::copy_from_slice()`: let a: [u8;32] = [1; 32]; let mut b: [u8; 32] = [0; 32]; b.copy_from_slice(&amp;a); Not really sure where `generic_array` is coming from.
This is _not_ what the OP says, though. The OP says, and I quote again: &gt; I don't remember seeing discussion about this. There was a truckload of discussion on this. I'm not saying there isn't an issue with truckloads of discussion, which is your point. Which I agree with and don't want to discuss. The OP _could_ have said: "I know that it was discussed, but now that I'm seeing it again, I don't like it." Fair. But currently, the argument _du jour_ is "it wasn't discussed". On the thing that was discussed _the most_. Sorry for getting a bit angry. It's lazy. &gt; Being able to have a PR or issue dedicated to a single subtopic, like pub(crate) I think will be a big help. You can always request changes to accepted RFCs. It can be done and it has been done. I agree that we need a new RFC format, but this RFC follows the old one. So let's not shift the discussion to yet another RFC discussion. I'd also like to raise the issue that opening the door to always revisiting issues that have been discussed very broadly is opening up the process to endless circles, which _also_ has huge downsides. This decision was made and needs to be implemented. There needs to be some security for implementers. 
&gt; Please require the bang for macro imports / use statements, to make a clear distinction from other language items. use some_crate::thing; should import a function or type by the name thing, not a macro. use some_crate::thing!; should import a macro, not a language item. I feel that macros are sufficiently different from other parts of the language that such a distinction is important. It makes everything much clearer. I don't agree with that. For me, the ! is not part of the macro name, and `use` is mainly about name resolution. I don't get any use from macros being special-cased here, while all other items are not.
Ferris is typically a male name, so I think it's reasonable to assume male.
Another similar phrase is "most complete", which doesn't mean that it *is* complete. I imagine this would raise your same objection, but it's a common use.
As I understand they're more or less parallel to each other. `stdweb` is a hand-written binding of the browser API for Rust, `wasm-bindgen` and related projects are tools for working with Rust and browsers together in general.
Possibly! I believe there are people working on an API to interface with the browser directly through wasm, without Javascript involved. I know nothing more than some of the webassembly people have said "yeah this would be nice someday", though.
&gt; This is &gt; not &gt; what the OP says, though. The OP says, and I quote again: Sorry, I was discussing your comment and not trying to back up / support OP. I think it is helpful to ask why the OP has the impression there wasn't much discussion. We can't fix every problem for everyone but there might be useful insight. &gt; I agree that we need a new RFC format, but this RFC follows the old one I meant this as a general "hey, here is a case study in why the new process would help" and not advocating for adopting it earlier or retroactively. I understand the priorities for why its not being worked on now. &gt; So let's not shift the discussion to yet another RFC discussion. I do think it is useful to - Take from these language feedback posts an examination of the process that went into them - Examine a proposed process to evaluate how it would help or not with someone's concerns. - Call out where the proposal would help to help people who are unsure about the proposal to see where it can benefit us &gt; I'd also like to raise the issue that opening the door to always revisiting issues that have been discussed very broadly is opening up the process to endless circles, which also has huge downsides I agree that you can't endlessly reopen past discussions. I think an interesting aspect is what caused me to change my opinion: that stepping back and looking at it from fresh eyes / seeing the forest rather than either the curse of knowledge or being stuck in the trees making it harder for me to re-examine. Is there a useful way for us to try to integrate this into the RFC process without bogging it down, discouraging people with last minute changes in direction, or other unforeseen problems?
There are many phrases that are common use, which don't make a lot of sense, if you think about it. One example - which is way worse but unfortunately the only one I can think about right now - is "I could care less". I mean I get what you are saying and a lot of people use this phrase, but it's still nonsense. The reason I'm so pendantic about this, probably is that in my mother tongue people tend to be stricter about these things.
That's weird though, in the "slice" example he uses `vec![0;20000000]`. Shouldn't that initialize all elements to 0 and therefore actually use the memory?
To add a bit to this, \`stdweb\` has some nice macros to facilitate generating JS directly from your Rust code. \`wasm-bindgen\` is currently more of a simple bridge for function calls and data types, with a focus on the future being able to support other languages (C/C++ etc) and things like host binding (ie interacting directly with the DOM from Rust).
OK, I guess it's not clear what "on" was applying to when I said "`flat_map" on a `Result`." This is a method of an iterator, but I was referring to how it works with `Result` items -- or really on `Result` values returned by mapping function. More specifically, `Iterator::flat_map` requires that mapped value to implement `IntoIterator`. The implementation of `Result::into_iter()` returns `result::IntoIter`, which is a single-item iterator for an `Ok` value, or an empty iterator for an `Err` value.
&gt; This is not what the OP says, though. The OP says, and I quote again: &gt; &gt; I don't remember seeing discussion about this. &gt; &gt; There was a truckload of discussion on this. I'm not saying there isn't an issue with truckloads of discussion, which is your point. Which I agree with and don't want to discuss. I said this because I did not know where to find discussion about this. I now see that it seems to be an issue with discoverability, not lack of discussion. I did not follow the path discussions. I presumed that those were about the new module system syntax (`use` statements and such), and I am perfectly happy with those changes. I was not aware that there was also a new visibility specifier change being discussed in the same thread. I was not aware that that was even a thing, until I read the edition guide today. I read the edition guide, saw a feature I disliked, did a quick search to try to find where it was discussed, but for some reason did not get to the path discussion. Maybe I wasn't searching properly and I should get better at searching. 
I've never met someone with that name. The only person I know of that was ever named that was the person who invented the namesake Ferris wheel, which was a last name. https://en.wikipedia.org/wiki/George_Washington_Gale_Ferris_Jr.
https://en.m.wikipedia.org/wiki/Ferris_(name)
**Ferris (name)** Ferris is both a given name and a family name. It is related to the name Fergus in Ireland, and the name Ferrers in England. In Ireland, the Ferris family of County Kerry derives its surname from the patronymic Ó Fearghusa. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Note that there's currently a lot of plumbing that has to be generating to make this work, so you may run into performance issues. Eventually libraries like this will hopefully have direct access to the DOM (via the upcoming "host bindings proposal").
The OP stated they are using bindgen and that's what is being talked about here. It's relevant to this thread.
I am not a lawyer and this is not legal advice. What you're trying to ask is "how is this licensed?". In most countries, all works are automatically copyrighted to their author at the moment of creation, and others have no rights to the work^(\*) unless they 1) bought a copy or 2) are licensed. u/Xor_Boole's work is distinct enough from the essential elements of the original Ferris artwork that they can \*probably\* claim sole ownership, rather than derivative work status for it, and have freedom to license it however they wish. Otherwise, it would have to be licensed compatibly with the original artwork, for which I was unable to find a license. Copyright is hard, and setting aside for a moment the moral validity of the whole notion of intellectual property, in an environment of global sharing and collaboration, the legal frameworks underpinning copyright are inadequate and complex interactions and restrictions of those rights between different countries' legal frameworks (not to mention jurisprudence) and actively functions to \*discourage\* creation, rather than its intent of encouraging and rewarding those who create. Exercise what influence you can in your locality to help others understand that the current state of things discourages a lot of people from creating, or puts more money into lawyers' pockets than into creators. ^(\*) With the exception of "fair use" rights, in a manner of speaking. And only in a manner of speaking because "fair use" is essentially an after-the-fact determination made by the courts.
[Bueller? Bueller?](https://en.wikipedia.org/wiki/Ferris_Bueller%27s_Day_Off)
Unfortunately JS tooling can be a bit overwhelming, and tends to change a lot. You're probably going to need to learn at least Webpack. I'd recommend starting here if you haven't already: [https://rustwasm.github.io/wasm-bindgen/](https://rustwasm.github.io/wasm-bindgen/)
Do you mean Rust the game, or Rust the programming language?
Rust already supports android. As for Ark, it hasn't really got a mobile-friendly interface; you'd probably be better off with a different archive app. Dunno what the other two are.
the game i know the programming language is on there 
Then you probably want r/playrust
It seem quite the opposite to me. `crate` keyword in `use` declarations has a pretty similar function than in `pub(crate)` but it is completely different than `crate` as a visibility modifier.
You probably were looking for r/playrust.
On quick inspection, the minimal examples look like an excellent abstraction over some of the Rust grahics/UI libraries (conrod, winit, etc). Great work! I really hope that we're able to compile projects like this directly to WebAssembly someday and have it just work.
This is going to be entirely platform-dependent, not really anything to do with rust per se. Likely each OS will have a screenshot API that you can bind to. However, some might have security policies that make it difficult. 
&gt; That only happens because you observe the address of the struct. &gt; When you remove the lines that print the address, the memcpy calls disappear from the assembly. No, it doesn't: https://godbolt.org/g/yYSqek
The result of \`ptr::read\` is considered to be the actual value, for non-Copy types the old location is effectively garbage. If it were considered to be valid you would have magically Copied a non-Copy type. If you drop the value in the pointed to location, and drop the result of the \`ptr::read\`, you would have dropped the same value twice.
# Update I ran the project through typedoc (a typescript tool to generate documentation), so now you can peruse the API here: [netlify docs](https://sad-saha-4a5616.netlify.com/)
I think the problem was that I was not aware that this visibility specifier change was part of the discussion about new module paths. I remember learning about the new module system and path syntax proposals. I was happy with those changes I saw and how things seemed to be going and never participated in or read the discussions. I had never seen `crate` as a visibility specifier mentioned anywhere until I read the edition guide today. So, I just found out about a feature proposal I disliked. I wanted to see the discussion that led to it. I thought it was a separate unrelated change and did not think to go looking at the new module paths proposal (which I am happy with). I didn't expect this to be part of the same proposal, as it felt like it had nothing to do with it. I did some quick searching and didn't find discussion for changing visibility specifiers. So I complained about it. I think it might be some combination of discoverability of these discussions, too many things being discussed at once in a single proposal/RFC, too many things being discussed in the middle of really long threads, making it hard to find and follow discussions, or me not knowing how to search properly. I guess I will work on improving my searching skills. I can't do much about any of the other things. I don't see why you are so outraged. I just posted a comment about how I felt. I felt like this was worth a thought. I didn't do it to just repeat a meme.
Yes? There are two usecases to consider: - passing a value as argument, - returning a value. When passing a value as argument, the compiler can decide instead to pass a pointer to the value instead of copying it: fn hello(name: [u8; 256]) { ... } Will be compiled to: void hello(char* name) { ... } With appropriate `Drop` call in `hello` if necessary (and none in its callers). When returning by value, the caller is already in charge of passing a pointer to the return slot, so the callee just has to use this space directly instead of allocating a variable and then copying: fn greeting() -&gt; [u8; 256] { ... } Will be compiled to: void greeting(char* __return) { } Unfortunately, even with such an ABI, there can still be extraneous copies that the compiler does not manage to optimize out. For example, when someone observes the address... either explicitly or by passing a reference to the argument to another function.
yes
Do you have a link for "host bindings proposal"? I'm curious to learn more. 
Awesome. I was just poking around this space the other day deciding on a templating system for [my personal static site generator](https://github.com/anderspitman/assg). I decided to use Mustache since it's simple and widely supported, but it's great to see native Rust projects for this stuff.
I added build instructions [here](https://github.com/coder543/zapper_web/blob/master/README.md) now!
I would definitely support adding Zapper to this. I'll try to get it done soon!
Note: there is no need to allocate a `Vec` just to count the number of elements, use [`Iterator::count`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.count) instead. Not knowing the crate, I am also wondering if the `take_while` is necessary given that the `Sieve` is already initialized with `20_000_000`.
Actually, I find it useful. It means that if you have a Go program with a maths-heavy inner loop with no allocation, you probably won't gain much (if anything) from attempting to rewrite this inner loop in another language such as Rust or C.
&gt; I had never seen crate as a visibility specifier mentioned anywhere until I read the edition guide today. So, I just found out about a feature proposal I disliked. I wanted to see the discussion that led to it. I thought it was a separate unrelated change and did not think to go looking at the new module paths proposal (which I am happy with). I didn't expect this to be part of the same proposal, as it felt like it had nothing to do with it. I did some quick searching and didn't find discussion for changing visibility specifiers. So I complained about it. &gt; I think it might be some combination of discoverability of these discussions, too many things being discussed at once in a single proposal/RFC, too many things being discussed in the middle of really long threads, making it hard to find and follow discussions, or me not knowing how to search properly. I guess I will work on improving my searching skills. I can't do much about the other things. I mean, it's literally the third point in a four-point summary of an RFC. I agree with findability being an issue, but it also isn't particularly _hard_ to find. It's fine if you miss things. I don't agree that too many things are discussed, this is a four-point RFC, the previous ones were _huge_. &gt; I don't see why you are so outraged. I just posted a comment about how I felt. I felt like this was worth a thought. I didn't do it to just repeat a meme. Most of my anger was triggered by someone dragging this into a whole different direction and reading words into your post that weren't there. Less by you personally. The initial post was mainly pointing out the mountain of things having been written about this and huge efforts taken to give context to the discussion. I'm fine with the comment, I'd recommend expressing it more like "I haven't been able to find anything, and it's probably been discussed, does someone have pointers?". We're never going to get the Rust back where we have read all discussions. Not by far.
I wanted to produce the same result as the others, but if you *only* want the count, [`Sieve::prime_pi`](https://docs.rs/primal/0.2.3/primal/struct.Sieve.html#method.prime_pi) is even better. The manual limit is because `Sieve` may round up its limit to better fit the internal wheel size. There's a note about this on [`Sieve::primes_from`](https://docs.rs/primal/0.2.3/primal/struct.Sieve.html#method.primes_from): &gt; NB. it is not guaranteed that the end is the same as the limit passed to `new`: it may be larger. Consider using `take_while` if the limit must be exact.
Yes to a lot of things. I still believe that discussion has a better place somewhere else. So it's probably a couple of good points at a bad place. I was mainly pointing out the facts about this RFC. Let's have that discussion somewhere else at some point.
&gt; Personally I prefer to use iterator functions and collect. As do I, but I read that sentence in the post and took it as a challenge, then realized that someone had to have done it better before.
Interesting. My guess is that `&lt;u8 as Display&gt;::fmt`, which takes the `u8` by reference, is somehow too "opaque" for LLVM to understand. If you switch it out for a function that takes the `u8` by value, even a completely opaque external call, it does remove the `memcpy` completely: [https://godbolt.org/g/CY916N](https://godbolt.org/g/CY916N) You clearly have a point that LLVM cannot remove all instances of `memcpy`. In my personal experience with Rust this has never been an issue though.
I don't know. I think I disagree. \`\`\`pub mod ...\`\`\` means make this module available to the public, \`\`\`pub(crate) mod ...\`\`\` means make this module available to the public of the crate (???), \`\`\`crate mod ...\`\`\` means make this module available to the crate. To me, "crate" is like "internal" in C#. So where C# has the following visibility specifiers: \* public - visible "Everywhere" \* protected - visible only within the class or sub-classes \* private - visible only in the class or module \* internal - visible everywhere within the assembly (public to the assembly) \* protected internal - visible everywhere within the assembly or in sub-classes \* private protected - visible within the class or withing sub-classes within the same assembly YIKES! Now, Rust has: \* (no specifier) - private to module, struct, etc \* pub - visible everywhere (public) \* pub(crate) or just crate - visible with the crate (basically equivalent to "internal" for C#) I actually prefer the "crate" rather than "pub(crate)" and it makes complete sense to me. I reads like: \* \`\`\`pub mod ....\`\`\` - declare a public visible module \* \`\`\`crate mod ...\`\`\` - declare a crate visible module \* \`\`\`pub(crate) mod ...\`\`\` - declare a public to the crate visible module (???strange way to say it???)
You could set up a network of virtual machines and deploy code onto them.
I agree. ! is not part of the macro name. It is an operator that means, "expand" with respect to a macro name.
Out of interest, if I buy the kindle version, how much money will go to the authors? If it is not 100%, is there another way?
A specific reason to avoid modifying `./src` is `cargo vendor`. It calculates checksums of vendored packages to make sure that vendoring can't be abused to "fork" pacakges. If a pacakge's `build.rs` writes to `./src`, then such package would be impossible to vendor due to checksum mismatch. This is not the only reason, but the general model of "`./src` is immutable" covers over edge cases as well. &gt;what should be done instead? A simple fix is to generate code to `OUT_DIR`. The "proper" solution I think is to include the generated code into the published package. That way, your dependencies won't need to compile the generator and it's dependencies (think "compiling LALRPOP-generated parser" vs "compiling LALRPOP itself"). I don't think Cargo has first-class support for this, but the following pile of hacks should help: - in your project, create a separate bin/lib with a code-generator, so that you can run generator manually as `cargo run --manifest-path ./gen/Cargo.toml` - add generated files to `.gitignore` and to `include` field in `Cargo.toml` that way, generated files won't be committed, but will be packaged. - write a test, which depends on the generator (test-depnedencies, unlike build-dependencies, are not propagated downstream), which checks that the generated code is up-to-date and optionally updates it. 
Except there is more to `pub(...)` than `crate`. See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html). This is already a hard feature to find information about and I'm concerned we've not taught it well as-is. I'm concerned that we're making a special case of it which will exacerbate people not understanding this feature.
There are other points I wish to respond to but I feel your posts are unconstructively shutting down conversation and I feel its better to step back and not engage except for this one misrepresentation &gt; Most of my anger was triggered by someone dragging this into a very different direction and reading words into your post that weren't there. Less by you personally or your post. I feel my comment is relevant to the discussion. I also feel that my post was not reading into OPs words and I have clarified this.
Thank you! This is the Digest trait that I'm experiencing, returning a GenericArray: https://docs.rs/sha2/0.7.1/sha2/trait.Digest.html and this is the current solution: fn dhash(input: &amp;[u8]) -&gt; [u8; 32] { let mut a = [0u8; 32]; a.copy_from_slice(&amp;Sha256::digest(&amp;Sha256::digest(input))); a } 
&gt; I don't see how this can be confused with declaring a crate, since you would not get &gt; crate Foo &gt; but &gt; crate struct Foo &gt; or &gt; crate b: Bar &gt; . For someone familiar with Rust, I agree, and this is why I was original a +0 to +1 on this. My concern is outsiders / new Rust programmers. I feel I would have no idea what a `crate struct` is.
Carol and I were both paid by Mozilla to do the writing, rather than collect the resulting money. All proceeds are going to be donated to Black Girls Code.
&gt; If you switch it out for a function that takes the u8 by value, even a completely opaque external call, it does remove the memcpy completely: https://godbolt.org/g/CY916N If I read it correctly, in your example the compiler is smart enough to inline the `do_stuff()` so it's not that it avoids the copy. It just avoids the function call completely: ``` call std::io::stdio::_print@PLT movzx edi, byte ptr [rbp - 65608] call do_stuff@PLT ```
Hmm, I think in the proposal I read this incorrectly as `use crate::foo` where `crate` was a placeholder for the current crate. I.e. `use clap::foo` I don't think I understood it would *literally* be `use crate::foo`. I wonder if that's where some of the confusion is coming from for others as well.
Yeah, you “use clap::foo;” if clap is not your crate, whereas you “use crate::foo;” if you’re using something from your own crate.
Is the version from nostarch going to be released today as well? I've been waiting for my epub to be available for a long time.
That’s my understanding, see https://twitter.com/billpollock/status/1011347518414675969?s=21 and the reply 
Ah ok, for some strange reason I thought it would be `use clap::foo` in *both cases*. Thanks for the clarification!
No Kindle version. You can't call it releasing without digital, paper books are like film cameras these days. Looking forward for it though, great job.
👍❤️
Large RFCs that try to do too much have the same problems as pull requests that try to do too much: 1. Reviewer fatigue 2. It complicates discussion because it's all in a shared space, which increases the barrier to participation (people with interest/expertise in only a subsection have to wade through everything in order to be caught up enough to participate) 3. Disguises failure to separate concerns 4. The cost of getting something wrong is higher
So, my approximate read is: - Ferris, the character, is CC-0, so basically anything is kosher if I had drawn this from my head... - But I used a reference (using a reference counts as making a derived work!) from the cover of print version of The Book, whose source can be found [here](https://github.com/rust-lang/book). The repo is dual MIT/Apache, so if the cover art is in there, then we're kosher... - But I can't find it and the No Starch page doesn't credit it. My ~guess~ is that Karen Tölva, the designer of Ferris, is the one responsible, but I have no way to confirm this. As far as I can guess, I can't claim copyright on this drawing, and I would be very shifty about saying "yeah use this on a shirt", modulo someone actually involved in The Book saying something.
Awesome, thank you!
Yeah, I will look into low level APIs, was thinking if there is some library, like python has.
Maybe `crate` doesn't look like visibility modifier because it is a noun in opposite to `pub` which is an adjective?
It inlined the call to `bar` in both our examples. There is no `call example::bar@PLT` anywhere. In your code, it allocated a *second* `Foo` inside `main'`s stack frame, `memcpy`:ied data into it, and then does the `println!` magicks on it. In mine, it calls `do_stuff` directly on the first `Foo`.
You are right! But again, the avoidance of the memcpy is only because of the inline. If we disable inlining the memcpy comes back: [https://godbolt.org/g/ajPo9u](https://godbolt.org/g/ajPo9u)
Some way of allowing third-party reviews to show up on the crates.io page *could* help a lot, though it would have to be thought through well. Reviews should be based on the package as published, not the repo's master branch. There would need to be some separation based on completeness of review (self-declared? up-voted, reddit style?) so that there can be both thorough reviews and more cursory ones. This is all *assuming* that potential users will sometimes review the code, but I think at least *some* review would happen. In some ways this is orthogonal to security advisories, but it could still provide some overview of code quality.
How does it compare to other templating engines in Rust like Tera?
Not a lawyer, but I'm pretty sure as long as you didn't flat out trace it's shape then it's more likely you own the copyright on this particular work with all of the shading, etc. If I create a stylized clone of a classic painting, but side by side it's obvious mine isn't the original one can hardly call it a derivative work. That being said, I've certainly been wrong before when working on websites mid-stream. I eventually just decided to do my own from scratch or buy rights to use stock images. Looking into websites design copyright stuff will probably give you a decent idea though. When in doubt track down who did the source image that inspired it, ask them if it's been licensed and go from there. 
Have you tried the criterion crate? It would be a great fit for this -- benchmarks in stable and nice graphs comparing different implementations! (I recently wrote [this](https://github.com/killercup/simd-utf8-check/blob/ac81acb0508aa58313fbb4ec9772935f72edd2a8/criterion/validate-utf8.rs) to generate [this](https://killercup.github.io/simd-utf8-check/report/index.html).)
That's also something you can, to a degree, do pretty easily with docker-compose.
I disagree because they’ve removed `extern crate`, and now `crate` is only two thing: - A visibility qualifier. - A module scope (the current crate). To me it’s actually a good thing. What are you most annoyed about `crate` vs. `pub(crate)`? And also, what the inherent problem of `crate` as visibility modifier for you? Do you think we might end up confusing it with something else / not getting its purpose? Cheers anyway buddy!
&gt;For me, the ! is not part of the macro name, and use is mainly about name resolution. In that case my question would be, do `fn foo()` and `macro_rules! foo` occupy the same name or can they both exist at the same time? If they can coexist then in my view they're different things and should be imported separately. [(see here for the answer)](https://play.rust-lang.org/?gist=11f4d9d242c1704b0b241bbffab9778e&amp;version=stable&amp;mode=debug)
 &gt; An error occurred during a connection to ipecho.net. SSL received a record that exceeded the maximum permissible length. Error code: SSL_ERROR_RX_RECORD_TOO_LONG Hmm?
How does this book compare to 'Programming Rust' by Blandy and Orendorff?
Started a rust learning blog... link later once I have more content :) Counting down days to RustConf
Lol this is more than I paid to pre-order
at least it's not curl -O https://oxy-secure.app/oxy chmod +x oxy sudo ./oxy --help
Dunno but when you ping it, it responds with this name: n1nlhg336c1336.shr.prod.ams1.secureserver.net
seems like just your public ip that's returned and some text. i guess some browser switched to https but the webserver/cert has issues. try http://ipecho.net it returns something like [this](https://i.imgur.com/5SPJuLO.png)
Thank you!
It's the rust programming language volume 2, available via `git clone` from this repo: https://github.com/rust-lang/book, but this is run through the publishing process.
The `box` keyword may or may not avoid the copy. There is no guarantee, and it doesn’t always in practice. (Though I don’t remember specifics, sorry.)
This is extremely cool from a technical perspective, but I can't get over the idea of a room containing a hundred people, all of which are 49-year-olds named Bob, and each of them is slightly more fat than the previous one.
Why not use LLVM for code gen?
There's only two crates that pertain to taking screenshots, and neither inspire much confidence. * [screenshot](https://crates.io/crates/screenshot), hasn't updated in 3 years, only supports Windows, known memory leaks/error handling issues. However, [the Github version](https://github.com/alexchandel/screenshot-rs) seems to be more up-to-date than on Crates.io, having apparently gained OS X and Linux support sometime in 2016. It still only supports getting a screenshot of the entire display though, and the Windows support may still be buggy. * [x11-screenshot](https://crates.io/crates/x11-screenshot) only worth mentioning for completeness' sake, it only supports Linux (thus, X11) and looking at the completely undocumented API, seems to only support taking screenshots of the main display.
Yes, now let me find it for you.
Could someone comment on what a concise way to get values out of a hashmap are? I'm trying to do something along these lines, but a bit stuck: fn solve(coins: &amp;Vec&lt;i64&gt;, target: i64) -&gt; Result&lt;i64, Error&gt; { let mut values = HashMap::new(); values.insert(0, 0); for x in 1..=target { values.insert(x, i64::max_values() - 1); for coin in coins { if x - coin &gt;= 0 { values.insert(*x, cmp::min(values.get(*x)?, values.get(*x - coin)? + 1,)); } } } values.get(target) } I changed the return Value to be 'Result' but I get this error : error[E0277]: the trait bound `std::error::Error + 'static: std::marker::Sized` is not satisfied Before I go down that rabbit hole, I get a gut feeling that this isn't the right way to use a hashmap get. Any help welcome! Thanks. 
*has science gone too far?!*
Interesting post. Thank you. I guess leaving out brunch and the like just avoided to copy things here and there, or am I mistaken. How much time did it take you to get up and running with Rust and Elm for web development? I am currently in the middle of Elm, and I did not touch Rust yet. What other backend concepts would you recommend with Elm? 
https://hyper.rs/
There is a huge difference between this and uninitialized memory. 
By removed I meant unusable from Rust 2018. It can be part of the `std` crate, but trying to use it can be a hard error that one can't use `allow` to suppress. That's a way higher bar than just deprecated.
Thank you. I have updated mutagen to follow the convention and will publish a new version soon.
Maybe wrap it in a `Mutex`, or try https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html.
No, `vec![0; ...]` actually doesn't do a `with_capacity` + memset, but does a `alloc_zeroed` call instead, which can call `calloc`, which means that the OS can give you "zeroed pages" as you touch them instead of giving you pages that then you touch to set to zero.
Definitely looked at it, it's on my list to do next
The cover of the book was done by Karen (we paid her for her work, I’m surprised there isn’t a credit... hmm), but isn’t included as part of the open source release of the book; it’s the only thing that’s not. That said, I’m not a lawyer, and I’m not sure that simply looking at the book’s cover is enough to say this is a derivative work. 
Pretty sure Ferris is canonically agender; that said, I can’t find a reference at the moment, which is and of itself kinda a reference, you know?
I would try docker-compose. It's the way we've been doing integration tests that need to talk to different components over the network. It's self-contained, but also simulates a network. 
The text is identical, to be clear.
Thank you! So it's not a must have for me, maybe I'll buy this later just to have it on my bookshelf :)
They compliment each other pretty well, IMHO. That book goes a little faster, assumes you know more, and has a very different writing style. I know people who hate my book and love it. I also know of people that prefer mine. I’m just glad we have so many books, and want even more. Oh, there is one other difference; that book covers 1.27, this one, 1.21.
Isn’t that usually how pre-orders go?
You could do so manually, being sure to \`poll\` until you get \`NotReady\`, or you could make use of \[\`Stream::select\`\]([https://docs.rs/futures/0.1.21/futures/stream/trait.Stream.html#method.select](https://docs.rs/futures/0.1.21/futures/stream/trait.Stream.html#method.select)) let rx = rx .map(Either::A) .map\_err(app\_error\_from); let framed = framed .map(Either::B) .map\_err(app\_error\_from); let fut = rx .select(framed) .for\_each(|either| { // handle item })
`pub` can also be a noun (i.e. the public).
&gt;Thanks! I'm pretty sure I have an ad-hoc, informally-specified, bug-ridden, slow implementation of half of this in my last two JS codebases! (I mostly ended up using promises as result type though.) oh yes, tell me about it :) [https://github.com/jsen-/shrewd/blob/1b0cd8cb919311de13e80088b2caac650d85ce1f/src/result.ts](https://github.com/jsen-/shrewd/blob/1b0cd8cb919311de13e80088b2caac650d85ce1f/src/result.ts)
Just made a donation :)
But what about users of the library? Or other developers who want to use it? They will not have the same docker configuration as I do, so even though my tests will pass for me they will not pass for other users of the library, which seems wrong to me but perhaps it is acceptable seeing as there is little other option. 
Doesn't look like that will be ready for 2018, though. 
+1 for this, just updated one of my projects to use Criterion and have not been disappointed!
Thanks! Yeah, I'm using brunch to do that and a few other things: copy files to the right location, allow me to use ES6 with babel if I do need some JS, compiling sass, and minification/obfuscation for prod builds When you say up and running, do you mean like comfortable and productive with the languages? If so, I'd say I'm more comfortable with Rust than Elm. However they're both challenges, and I think that's why I enjoy them. Elm seems so cryptic sometimes, for instance it takes me a lot of brain power to figure out how to deserialize JSON, when normally that is pretty trivial in other languages. It's interesting you don't actually interact with the json string in your parser, instead you are building a function which parses. How much time? Oh man I've been doing Rust as a hobby for like 2-3 years. Elm I only used for a month or so, but i found it very intriguing. I wrote a snake/worm game with it ([blog](https://freiguy1.gitlab.io/elm-snake/) [web app](http://ethanfrei.com/posts/snake-in-elm.html)). Other backends: I've heard some hype about Elixir/Phoenix working well with Elm. I think the languages (Elm &amp; Elixir) are kind of similar in that they're both functional. The deal breakers for me with Elixir are that it isn't strongly typed and Phoenix is a good deal slower than Rust web frameworks (at least [in this comparison](https://github.com/trezm/Thruster) I just saw).
They occupy different namespaces, just like types and values do, e.g., if you have a function `foo`, a macro `foo`, and a const `foo`, you can have all three and the names won't 'overlap'. However, they are imported by a single name (which is a little bit of a wrinkle, but it's how Rust has always done things).
Ik checked static and const, but those conflicted with the function.
100% agree, also note that when you declare a macro it is `macro_rules! foo` not `macro_rules! foo!`
When I look on the US and the UK site I see a Kindle version on both. The book is also available for free digitally on the website. 
What's this `(Manga Guide)` thing on the UK site?
Without seeing a code example (one from [play.rust-lang.org](https://play.rust-lang.org) is always a good addition to questions like this BTW!) my initial thought is that this doesn't sound like a situation where global state is going to be appropriate. Have you considered implementing these functions as methods on the struct you create from the file? Calling successive methods with access to \`&amp;mut self\` is pretty idiomatic Rust, IME.
&lt;3
`std::error::Error` is a trait, which isn't a concrete type that can be returned by-value. You need a concrete implementation, like `std::io::Error` (which isn't really appropriate in this context) to return instead. However, `Result` is for fallible operations that return some context or information on an error. Is this semantically appropriate for what you're trying to do? `Option&lt;i64&gt;` matches the return type of `values.get()` most closely, though `.get()` returns `Option&lt;&amp;i64&gt;` so you want to stick `.cloned()` at the end to make it `Option&lt;i64&gt;`: `values.get(target).cloned()`. That only has two possible values, `Some(i64)` or `None`, which makes it analogous to nullable types in other languages. Idiomatically, the `None` value doesn't necessarily signal an error, just that a value couldn't be produced for some reason.
\&gt; I can't think of any other ways of doing this, but for some reason I just feel like passing in the same thing into 5 different functions is the wrong answer. Often times, passing the same thing into 5 different functions is the right answer. If a function needs access to some values, the best way to encode this is to list it as a function parameter.
I've added this post to [my list of posts](https://github.com/crate-ci/crate-ci.github.io/issues/12) to integrate into [crate-ci](https://crate-ci.github.io/), a central living book for CI documentation. Of course if you don't mind sending me documentation PRs to the book and/or example PRs to my [gitlab org](https://gitlab.com/crate-ci), that'd be much appreciated.
It looks like it declares a crate. This is what `mod` does and in fact this is what most nouns do as pointed out elsewhere in the thread (`struct`, `enum`, `fn`, `trait`, `type` etc.). As you learn, or if you have to browse code without knowing the language, it will be hard to guess and remember what sort of thing it might do (all the more that the meaning of "crate" is non-standard!). Of course it's no big deal and at some point you'll just know, but then typing five extra characters to make things clearer for newcomers is no big deal either. (I am really repeating with a few extra words my comment above.)
&gt; Since the only problem with this feature (at least in my understanding) seems to be that it breaks a few crates, making it backwards-incompatible, perhaps it could just be enabled for the new Rust2018 edition only? People are going to have to fix breaking changes when they decide to opt into the new edition anyway. It's not that simple, there's significant amount of extra work to be done to make something an edition breakage. You need to come up with a migration plan and lints that enforce this. &gt; I prefer pub(crate) over crate as a visibility specifier. I think it is much clearer and less confusing. Also, I don't remember seeing discussion about this. This feels like yet another change being added to the language without sufficient discussion. To be clear, both will work. The upgrade plan will ask you to use `crate` in a bunch of places but you don't have to. &gt; but it seems like something trivially automatable (with e.g rustfix). This is the case? One of the edition idiom lints is bare_trait_object which works with rustfix. However, we want the edition upgrades to not involve _too_ much churn, which is why the upgrade is a two step process. The first step includes the minimal changes needed to make your code compile on 2018 (and it will still compile on 2015), the second step contains possibly more extensive changes making your code more idiomatic. Stuff that affects a _lot_ of stuff is better in the second step as an optional thing. A warning should be sufficient for now, folks usually follow them. In a future edition we may make it a hard error. 
It says Kindle edition is for pre-purchase and will be delivered on November 20.
On the German site as well. Wondered about that, too.
You can include the docker-compose file in the repo. If it uses public images, then anybody can reproduce your test configuration.
Is there by any chance a comparison out there of the syntax of the different template libraries for certain common examples (starting, perhaps, with a basic "hello world" page)?
In this context it's obviously meant as the opposite of 'private'. And not the army-rank noun 'private', but the adjective.
It's great to see someone working on making fast template engines that are more dynamic in nature. Thanks for all your work on this. One suggestion I would have is to show how Zapper does some of the simple cases you often see used to explain how a template engine is used, ranging from a basic "hello world" page to a blog post to a page with conditional display and lists.
Hasn't this approach been tested (without success) for most C libraries out there ? Of course you can find bugs while fuzzing, and it's a really good thing to do, but I don't think you will ever “prove” anything this way. 
Should the last sentence be the oppositie?
Since this is my first pre-order, I'd say 100% of pre-order I have participated in have gone this way
Thanks, Sean. I didn't realize that the http/2 out of the box was plaintext. That would explain why there aren't the sort of configuration options I was looking for. So to do http/2 with TLS, for example, you would need to use something like [hyper-tls](https://github.com/hyperium/hyper-tls), right?
The article uses the term "non-buffered" to mean unbounded buffer size both when talking about crossbeam and spmc. I think most people would understand this term to mean zero size buffer (I.e. blocks immediately / switches control to consumer).
There *is* a digital version available now. In fact the digital version has been available during development for ages now at https://doc.rust-lang.org/stable/book/second-edition/ch00-00-introduction.html where you can read the whole book for free. You can also purchase an eBook copy from nostarch. Stop complaining.
I did interchange them, yes. Unbounded would have been better to use.
Simulation a la https://youtu.be/hMJEPWcSD8w See https://github.com/spacejam/sled/blob/master/crates/paxos/tests/quickcheck.rs as an example.
Whoa, take it easy. I have no idea what nostarch is and I didn't know it was the same book as the online doc, just following the post's link on Amazon. Thanks for letting me know.
This is why I used "most practical approach" and "fairly sure". It could be nice to have something like `#[keep_overflow_checks]` to achieve finer control over keeping overflow checks. But even with such functionality code will still panic, which should be considered a bug, while returning `Result` on every arithmetic operation is simply horrendously impractical. And formal verification can get us only so far. (though by any means I would love to see development of formal verification tools for Rust code) So fuzzing is currently the only practical approach which I can see.
&gt; Beyond accepting a raw pointer, this is unsafe because it semantically moves the value out of src without preventing further usage of src. If T is not Copy, then care must be taken to ensure that the value at src is not used before the data is overwritten again (e.g. with write, write_bytes, or copy). Note that *src = foo counts as a use because it will attempt to drop the value previously at *src. It calls it a move, and says it must not be used, not just being careful with drop. Even though the bits aren't changed, in terms of semantics, it should be treated as just as dangerous. Example of undefined mutable aliasing (mutable aliasing without UnsafeCell) by Copying and using a `&amp;mut`: http://play.rust-lang.org/?gist=fa7b977866a6ed14fe8875c1106f7c39&amp;version=stable&amp;mode=release
Ugh, phones. Programming Rust is 1.17. TRPL is 1.21.
None of the modules changes are breaking, including this.
Thank you for taking the time to help! No, Result doesn't seem semantically appropriate here. At the point where I `get`, I know that I have something in the hashmap for that key. So behold this monstrosity. I'll post it here as I try to understand exactly what's happening. use std::collections::HashMap; use std::cmp; fn solve(coins: &amp;Vec&lt;i64&gt;, target: i64) -&gt; i64 { let mut values = HashMap::new(); values.insert(0, 0); for x in 1..=target { values.insert(x, i64::max_value() - 1); for coin in coins { if x - coin &gt;= 0 { values.insert(x, cmp::min(values.get(&amp;x).cloned().unwrap(), values.get(&amp;(&amp;x - coin)).cloned().unwrap() + 1)); } } } values.get(&amp;target).cloned().unwrap() } fn main() { let v = vec![1,2,4]; println!("{}", solve(&amp;v, 100)); } 1. Why does x need to be borrowed in the `get` calls? 2. If I use `cloned()`, would unwrapping it here be the right thing to do? 3. Now I'm getting an `error[E0502]: cannot borrow `values` as immutable because it is also borrowed as mutable` One step at a time.. 
&gt;to a page with conditional display and lists. From reading the article it appears Zapper does not support conditional rendering yet. Hopefully the author will add it soon.
Are http upgrades just used for websockets? Are there any other uses? What about http/2?
If this the way to go, or is there a better pattern for handling this kind of a situation? Thanks for coin in coins { if x - coin &gt;= 0 { let temp1 = values.get(&amp;x).cloned().unwrap(); let temp2 = values.get(&amp;(x - coin)).cloned().unwrap(); values.insert(x, cmp::min(temp1, temp2 + 1)); } } 
[The home page claims HTTP/2 support](https://hyper.rs/).
Three cheers for Nannou! 🍻 🍾 🎉 I'm really looking forward to using it. 
I spoke loosely, fixed.
&gt; removes the `safe` reference `safe` or `unsafe`? but this is really impressive, especially since it isn't even based on Hyper yet it gets great performance!
ha, yes, I noticed that and updated about a minute after I posted it :)
&gt; I also personally dislike in-band lifetimes and lifetime elision. I think it makes the readability of the code worse, as it is more difficult to see where lifetimes come from / where they are defined. I like the current explicitness. I wonder if instead of elision we can just have error messages that say 'write it like this' - that way the code is still documenting, but new devs won't have to struggle? I assume if we can elide, we can do this?
I thought pub(super) and pub(path) always limited visibility to modules in the same crate. Is that not the case?
I'm not entirely sure how deep you're trying to test here, but it sounds like mocking the tor service should be enough if you're only trying to test connectivity.
HTTP/2 IIUC is used out of the box, so you don't really "upgrade" to it
To clarify, this means the 0.2 versions of futures has been yanked. This is nice cause `cargo add futures` will now add the ecosystem-compatible version again.
My biggest frustration with this is that it's blocking stabilization of `try_from` which I've been waiting on for what seems like forever.
Removing extern crates doesn't mean it never existed, and the plan is for editions to stay in use for some time. 
This looks like a fantastic project! Well done. Though, it saddens me that I hadn't heard of this sooner, since I've been slowly hacking away on [a project](https://github.com/nwoeanhinnogaehr/flow-synth) for the last year that seemingly has a lot of overlap. I'm focusing on the exact problem you are trying to solve with gantz except that I allow feedback loops at arbitrary rates. Without feedback, I find that there is little room for abstraction and musical experimentation becomes constrained. But, my solution to processing such a graph is a little bit odd and experimental itself ([design docs](https://github.com/nwoeanhinnogaehr/flow-synth/wiki/Design)), so I look forward to seeing gantz thrive as well in case my implementation ends up flopping. I think we should be able to find a way to share code for individual processing nodes (oscillators, transforms, filters, etc) at least. As long as they stick to a fairly generic interface it will save us both quite a lot of work.
The most common by far is Websockets. HTTP2 Upgrade over HTTP1 uses the same mechanism, but it's very rarely used (browsers don't bother, since some servers automatically reject upgrades they don't understand, even though they could just ignore it). There could also be custom internal protocols that we'll never hear about.
This. "public to the crate" always seemed weird to me. Not that I ever used that feature... But really Rust should just straight up steal "internal" from C# :D
Yet ANother Unsafe Rust Finder YANURF
This problem sounds like it's best solved with \`lazy\_static\` and a \`RwLock\`.
This is no more a problem in Rust than it is in any other language. If you want to pass by reference, do so. If you want multiple owners of a piece of data, put it in an `Rc&lt;T&gt;` or an `Arc&lt;T&gt;`. Also... don't be horrified by the notion of passing by value either. Copying data on the stack is pretty cheap since it's usually held way up in the faster CPU caches. In addition, many CPU architectures have special instructions for copying large blocks of data quickly. SIMD can also speed things up a lot too. If all of the above doesn't convince you, remember that the compiler is smart enough to turn what appears to be a copy into a simple reference when it's safe to do so. **TL;DR: When writing Rust code, the easiest way is usually the best way. Don't be afraid to move data around.**
Doesn't this work for you? That probably is not the ideal solution tho. #[macro_use] extern crate lazy_static; use std::sync::Mutex; lazy_static! { pub static mut ref value: Mutex&lt;Box&lt;Trait + Send&gt;&gt;&gt; = Mutex::new(Box::new(&lt;struct that implements Trait&gt;)); } Then you just do *value.lock().unwrap() = Some(&lt;struct that implements Trait&gt;); You can check an example here. https://play.rust-lang.org/?gist=a20ce4c2c2666620ccb3f0c3b4501abb&amp;version=stable&amp;mode=debug It's really ugly, there may be a better way with impl Trait or &amp;Trait. If it's not going to be written that much RwLock may be better instead of Mutex (but it can choke writes tho if there is a shitton of reads).
i used to like kindle versions - then i discovered ipad pro and the apple pencil, now i prefer formats (like pdf) that i can scribble all over, unfortunately mobi doesn't support that yet.
It says in the name when it will stabilize tho.
THANK YOU!!! Seriously, this is a great move.
Isn't it explicitly saying that it's not a move, but similar to one semantically? Because it's basically two variables having the same mutable reference?
Ok, I figured it out. If anyone comes here later on, looking for a solution, check out: use winapi::um::commctrl::{SetWindowSubclass, DefSubclassProc}; You're going to have to write up a copy of the process_event function, just with a few more attributes: extern "system" fn process_subevent(object_handle: HWND, msg_id: UINT,w_param: WPARAM, l_param: LPARAM, id: UINT_PTR, data: DWORD_PTR) -&gt; LRESULT And instead of ending with a `DefWindowProcW`, you end with a `DefSubclassProc`.
I'm really looking forward to seeing more Rust or even a Rust meetup in Phoenix. 
Even simpler, button clicks send the `WM_COMMAND` event, with the button's `HWND` passed in `lParam` (the window that contains the button will still be the `HWND` parameter for your message processing function). Just check for that and you should be set.