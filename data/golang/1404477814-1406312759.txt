I don't think you're going to see a huge migration away from Go. Node is a hack on top of a Javascript engine. Despite me being occasionally a bit rough on Node, I don't mean that as pejorative, it's descriptive. It is a server processing system built on top of a Javascript engine meant to be embedded in a web browser. It's a hack. It then adds in a lot of server functionality at a very high level, trying to bash Javascript into compliance with high-level implementation of things that should be built into the lowest levels. It's something that Node programmers need to realize and never forget if they want to make the best use of their tool. By contrast, Go is written from the ground level to do very similar things, so there's no need to bash the higher layers into compliance, it's already doing the right things. And so you get things like multiprocessing that Node can't even add without massive, massive work that will probably just make things worse since the top-level language simply doesn't support it. (Yes, I know about Web Workers. I'm talking about real multiprocessing.) Again, that's not a "compliment" or "praise" of Go... that's a _description_. Go is one of the best languages I've seen for working in largish groups while still producing decent quality code. That's going to stay true regardless, I think, and Rust won't be peeling very many companies away from Go. It isn't going to stop being faster than Node. It isn't going to stop being simpler than Node (and Node is getting complicated as they continue to desperately bash "solution" after "solution" to the callback problem, which are continuing to fail at scale). I certainly won't guarantee that everybody who switches to it will stay there "forever", but I will say that once a Node user switches to Go for more than one or two hundred lines of code they will find it virtually _impossible_ to return to Node. (It's hard to show why Go is better in a blog-post size, because Node still works at the "several dozen" lines of code, but once you get to "several hundred" it's no longer even close to a contest. Node is, frankly, so insanely crazily broken that the only way to keep people there is for the whole community to keep telling itself REALLY LOUDLY how awesome Node is and how everyone else sucks, because if a member actually steps out and _tries_ the other solutions they probably won't come back.)
Nice. How do you edit the main page?
Normal build works: $ go build wiki.go Tried to cross-compile to linux (from mac): $ GOOS=linux GOARCH=amd64 go build -o wiki.linux64 wiki.go # github.com/mxk/go-sqlite/sqlite3 ../../mxk/go-sqlite/sqlite3/lib/sqlite3.c:92 ../../mxk/go-sqlite/sqlite3/sqlite3.c:5 unknown #: if ../../mxk/go-sqlite/sqlite3/lib/sqlite3.c:94 ../../mxk/go-sqlite/sqlite3/sqlite3.c:5 6c: No such file or directory: mingw.h Boom. Not going to happen. I checked ming's page http://www.mingw.org/ and it has this blurb: &lt;quote&gt; MinGW, being Minimalist, does not, and never will, attempt to provide a POSIX runtime environment for POSIX application deployment on MS-Windows. &lt;/quote&gt; So, not going to happen with that sqlite library. There are other sqlite libraries, so it is still a possibility. 
Yeah, that's the main problem I had with Node.js. It's a good piece of software made by brilliant programmers, but it stays a hack built on top of the shitty JS we all know.
Usually, programming languages backed by a large corporations don't "go away". For example: * C (AT&amp;T) * C++ (AT&amp;T, Microsoft) * Objective-C (Apple) * Java (Sun/Oracle/IBM) * C# (Microsoft) That is not to say that languages not backed by large corporations (javascript, php, etc) cannot succeed, but given the uptake inside Google for Go, and how much they like it, I think Go will be around for a long time.
The guy almost *is* the node community. If you have a book about node, you'll likely find his name on it. If you've used node, you likely used at least one library by him. I wonder how popular node would be today if Holowaychuk hadn't gotten involved.
Well, Dart is backed by Google, but hasn't taken of (yet, I hope it does...). Although in my comment, I'm not saying that the Go's popularity will fade out. I believe it will be around for decades, and will keep evolving wherever the current situation takes us. What I meant is that this "trend" where everyone who ditched ruby for node and now node for go, will eventually go somewhere else, and they will justify their move with posts talking about how "golang is so bad in so many aspects that I'm leaving". Nobody will ever say "okay, there's a new trend now and I'm gonna follow it because it motivates me".
What is weird is how much shit his projects got from some key members in the Node.js community. Lately it's has been better but a year and a half ago you had some people that took a dump on express every time somebody would mention it.
Rust could never replace Go though, Rust and Go just don't compete in the same niche. For high-level things like what we'd use Go for, there's just no point in dealing with all the lifetime and memory handling, all those extra complexities and the slow compile speed just to gain a negligible bit of performance and a little bit of "haskell safety", just isn't worth it. Currently I haven't seen anything remotely better than Go at doing what Go does, may be something will be created in the future, but not now and we probably don't have a chance to use it for the next several years.
They are not meant to be competing languages. They fill different needs, designed with different approaches and excels at different things. If you want to write low-level stuff, something that needs every tiny bit of performance, working directly with the hardware or graphics, and you want to handle the memory. Basically something that you'd use C/C++ to write, something like kernel, driver, graphics library, a big library that exposes a C interface for other languages to call, a game that couldn't work well if there are GC pauses, or something like what Mozilla is building: Servo, a new browser engine. Then go with Rust, just choose Rust, or plain C/C++ for that. I've made the mistake of "fanboyingly" choosing Go for this kind of task and it hurts, it's really stupid and inappropriate, even though Go can definitely do some, it's awkward. On the other hand, if you want to do something like writing a tool, a server, a web application, a network application or an application to process, send/receive something or whatever that is called high-level. Things that previously people have to use such slow and unsafe scripting languages like Python, Ruby or PHP to write. You don't care about GC, you don't care about memory management, lifetimes and all that stuff, and you shouldn't care because Go is a compiled language which is more than fast enough to do ten times the work. You just want something simple, fast, compiles instantly and makes your code the easiest to read, to understand, to cooperate and to maintain. Choose Go, for the love of god choose Go because it's awesome for the job. One more thing I want to say: I've made of mistake of being such a fanboy, choosing that language I love for unsuitable tasks. And that's the worst thing. There's no perfect language, there is no best language. The best language is "choosing the right tool for the job".
&gt; I'm tempted to stick with Go until Rust hits 1.0 Why would you waste your time doing this? If you're doing to ditch Go without mastering it (to some extent), you might as well put that time to more productive use. Then make this decision that you're struggling with once Rust hits 1.0. Bear in mind that it's what you do with any of these languages that matters - not the language itself.
Programming language is a tool, choose right tool for your task
I feel like a broken record, repeating this line at least once every couple of weeks to fanboys.
Me too :) but what another answer can be on question like: 'what to choose this vs that?' in our sphere
Absolutely right. btw when i'm hear "it solved all of your problem" i dont know why but i remember c++... brrrr
I agree but the thing about these languages is that they're general. purpose. languages.
If you were planning on writing it in python use go. If you were planning on using C++ use rust.
I love Rust for what it can replace but do you feel that Go could replace Python for scripting tasks and bigger apps? I'll try it again next Monday though but I'm curious.
ERLANG IS JUST A POOR LISP CLONE
It has pattern matching though.
&gt; I've made the mistake of "fanboyingly" choosing Go for this kind of task and it hurts, it's really stupid and inappropriate, even though Go can definitely do some, it's awkward. Would you be willing to type a long, crazy, detailed rant about this? I would really like to read one about your frustrations in this area. What specifically caused you trouble? In my case, I can remove the limitations garbage collection pauses and CGO speed cause.
the issue with this commonly-parroted and oft-flippant non-advice, is that every "tool" is multi-purpose and every task is solvable in a score of manners. tools matter. their consideration matters.
To me, Go is small, fast and easy to work with. Extreme productivity once you're up-and-running. Rust is big. Like really, really big. I bet there's probably more complexity in it's package/module system alone, than all of Go. Of course, that big-ness comes with extreme versatility. I wouldn't be surprised if we see a *nix-like OS created where everything (bootloader, kernel, userland, etc) is all in Rust.
I would.
Fortunately robustness is meaningful and "less than X lines of code" meaningless, so the choice of which one to favor is quite clear.
go rust ()
the main page can only be edited by by editing the index.html file/template
i want to display it for a user (as im implementing a client). i want to have as much information of the message available as possible
Here's a fork that has more activity on it. https://github.com/pczarn/rustboot
&gt; Rust suits Go's webservice use-case and does a heck of a lot more. Not right now, it doesn't: http://arewewebyet.com/
Hey, from Rust-land, thanks for this. Agree 100%.
go solves the problem of being a very simple, straightforward language that is pleasant to use, has a good tooling and library ecosystem, and generates fast code. it occupies a space somewhere between C and python, with a good concurrency model built in from the start. if i had to pick the one big thing it did, i'd say go's channels do for the communicating sequential process model what ruby's blocks did for closures - make them the pervasive, natural tool to reach for.
Hello everyone! I've been working on this for about 3 months now, and I'm finally satisfied enough with the server component to share it here. I started this project in an effort to replace dated media servers such as Subsonic, and to continue growing my knowledge of Go. So far, so good! I am more than willing to accept comments and critique regarding the server component. Please feel free to ask questions as well! At this point, I'm sharing this here in the hope that I may be able to spark some interest in creating a web UI for the project. My frontend skills are rather lacking, and while I will be working on something in the near future, I'd love some help if anyone is willing to offer it. Please feel free to contact me or reply here with any questions or comments! Thanks for your time.
Binary protocol aside. What you have there seems fairly idiomatic to me. Any library that you use that does any sort of marshaling does this code behind the scenes and all you're doing is abstracting it by using a library. 
I think Go's opinions are a bit too opiniony for me to enjoy using it over python, though that may just be by python bias tingling (and thus my two lanuages of choice are rust and python)
https://github.com/iron/iron That page should be updated. Anyway, the point is Rust is expressive (http://words.steveklabnik.com/rust-is-surprisingly-expressive) (your post itself). Isn't it what is required for being very productive? Why is it that you can't use Rust for web development?
I looked at Rust recently but the frequent changes to fundamental aspects of the language/std library is frightening and the lack of third party packages makes it hard to be useful (or even to learn it) at the moment, imho. Since mastering Go takes as little time as I've seen for a language, I don't think it's unreasonable to wait for Rust 1.0 and see.
Yes, iron exists, and rust-http and teepee exist, and (soon) condiut exists. But go's HTTP tooling is much more mature. All of these frameworks are brand new, and not nearly production ready, and significantly slower, so far. I love Rust, obviously, but Go is clearly a better choice _today_ for HTTP stuff. Hopefully with some time, Rust will get there, but claiming they're equivalent or that Rust is better _today_ is clearly not true.
I've built a large application in Node and it is a million times (my rough estimate) easier, cleaner, and faster than Ruby and PHP. Those are currently the only real alternatives unless you have a 50 man team to manage all a bunch of esoteric low level stuff that may not add any value (probably won't) to your project (but you will get a lot of free complexity, failure points, and bugs!! YAY!!). I'll wait to see how Go turns out, but from what I've already used of it I don't like the million times you have to type cast and convert variables. A language that can't tell what I want from my variable is a 'dumb' language and de-evolving. 
Iron is already mentioned on arewewebyet.com. (I updated it to that effect over ten hours ago!) The existence of one basic framework does not make it mature and ready for regular web development.
I can see how it seems that way. And I still use Python quite heavily, partly because I'm more familiar with it than I am with Go, but also because there are times where I don't need the performance of Go. Will there be a day when I don't use Python at all? Perhaps, but that day isn't today and the language that takes Pythons place (probably) won't (solely) be Go. 
I think the reason people post these questions is because it takes quite a bit of time and energy to become well versed in these languages. Not because people don't want them to coexist. People just want to make sure they're putting their (limited) eggs into a basket that's going to be worth it. My opinion is that, like someone has already posted, picking the language that better supports your project or goal is the most important part. Many of the languages do have some crossover, but if your project falls into one of those crossover domains simply pick the language that falla closer to your comfort zone and ideals. 
Python is still faster to write due to the amount of boilerplate code in Go (especially error handling). If memory usage and performance aren't at all a consideration, Python is typically going to get you what you want faster. If you would like to run your application faster, more efficiently, Go is going to trounce CPython, and beat PyPy on many/most things. So weigh the development speed and performance trade-offs and choose the best for your usage case. They are similar but still fill different niches.
"Is writing a kernel or other bare-metal code painful?" captures a pretty large swath of usage while still given a pretty clear boundary—well except for languages wherein writing *anything* is painful.
It seems that those kinds of diplomatic non-answers are in vogue in the programming community right now. Maybe it's a reaction to 'language wars' bickering, and that kind of drama sure gets tiring real fast. But to say stuff like "choose right tool for the job" is so empty now that it is basically meaningless. Just another parroted phrase. You don't have to be a know-it-all asshole in order to give more in-depth advice - so if these things are tools, what are they *good* at, compared to each other? Though admittedly the OP hardly gave us anything to work on, so maybe the OP deserved a short and "unhelpful" answer. 
&gt; oh boy.. this is going to be the flamethrower of internet language wars for the next 15 years. :D As time goes on these two languages will grow more and more towards their own respective niches, to the point that most people will realize that any comparison between the two langs was due to their vaguely comparable age rather than being comparable from a technical standpoint, or even a philosophical one. This 'language war' will pass, too. 
Don't try to convert vim users to anything that contains the letters "IDE". They explode.
&gt;&gt;Usually, programming languages backed by a large corporations don't "go away". &gt; Well, Dart is backed by Google, but hasn't taken of (yet, I hope it does...). Not to nitpick, but I think 1kGarand just meant that they don't "go away", presumably after becoming successful(regardless of how or if that happens). I think it's generally true. While not all corporation-backed languages succeed, if and when a language does succeed, the backing corporation will often leverage a significant amount of resources to keep it relevant.
Yeah I've never used Erlang. But I love pattern matching.
Yeah, I agree. I don't mean that Go will "go away". I just think that the herd will flock elsewhere. I don't think it's a bad thing though... just that I take these types of blogposts as a little bit irrelevant: bye x, hello y; bye y, hello z. etc! 
&gt; Wanting to make a multimillion dollar, ultra cutting edge AAA game available on PS3/4, XBox 360/One, Wii/U, and PC? I hope you like either C or C++... Because you won't be using either Go or Rust! Interestingly enough, since Rust uses LLVM, someone has actually built Rust code and run it on a PS4.... But yes, the days of Rust seriously being used for that are long off. But it's possible...
Okay Python isn't "slow" or "unsafe". How is it possibly "unsafe"?
&gt; Go is clearly a better choice *today* for HTTP stuff. Hopefully with some time, Rust will get there So, Rust and Go *are* meant to be competing languages? 
Implement whatever you want in both until you feel that one suits your needs better.
I think there's a crossover point. A small script is usually quicker to get running using python, as go has a little bit more boilerplate. But as a program grows in scope and size (as most do), the advantages of using Go grow as well. The biggest advantage is that changes are much safer -- you avoid most of the little runtime errors that pop up all the time in python. Pylint / pychecker etc can help, but they are limited in effectiveness by python's dynamic nature. And for any sort of networking / concurrent server stuff, I choose Go over python about 99% of the time -- the exception being if there's some big python library that I want to use for which no counterpart exists in go land.
&gt; Python is still faster to write due to the amount of boilerplate code in Go (especially error handling). Bit of nuancing: that also depends on how many times do you need to rewrite/bugfix before you're done, and that depends on a combination of individual skill and how "stern" the language is. I tend make more dumb mistakes while writing Python, so it effectively takes longer to finish. However, that probably says more about how sloppy and chaotic I am if the language doesn't hold my hand (or slaps me on the wrist every once in a while) than anything else.
[This seems to work for me.](http://play.golang.org/p/064mzAxLUB) I guess the gist is to convert it into `unsafe.Pointer`. It can then be converted to a pointer of any type. Both conversions must be done explicitly, though.
yes! you're right, it looks like the trick is not even unsafe.Pointer (Go will complain if you pass something else), but taking address of the first element. Looks like people with C background are forgetting that its not C and pointer to slice is not the first byte. Thanks!
If it's just about learning another language, I'd agree with your point. However, the OP made it sound like an either/or kind of a situation. That was the reason behind the suggestion to wait till Rust stabilizes before comparing the two and learning one. 
Read anything other than the documentation I need RIGHT NOW? Why would I ever do that?
Isn't Rust still in Alpha? You probably don't wanna do something serious in an alpha software. So go with Go. Rust do look promising though, maybe look at it again in a year or so.
Use a type conversion. C.foo((*C.unsignedchar(&amp;buf[0])))
https://code.google.com/p/liteide/
Sublime Text + https://github.com/DisposaBoy/GoSublime
your question is a bit broad but if you want to target the browser or node with your go code [gopherjs](https://github.com/gopherjs/gopherjs) might help a lot.
Just because two Turing-complete languages share some libraries that do the same thing doesn't mean that they're 'competing.'
There are two kinds of people. Those who use a debugger and those who use strategically placed printf statements. I think both approaches work fairly well.
It depends on what you're trying to debug IMO. Printf debugging works great for linear workflows, but I miss dropping into the Perl debugger and being able to change code as it executes to try multiple different attempts at fixing it without having to get to the same point in execution -- like if you have code that loads a remote resource, its nice to be able to breakpoint right after and play with the data instead of just running once and seeing it fail and having to change it and run the whole thing again. 
Do you mean asm.js? If so, the Go toolchain doesn't support it. There is an experimental Go compiler built with LLVM called llgo. You could potentially compile it to asm.js with Emscripten, but I don't know for sure since I could not build it on my machines.
+1 sadly disposaboy hasn't worked on it since april.. hope he is fine.
If your primary goal is to use the native file picker, you'll have to do a (local) file upload to your Go server. This should be fast enough from a user experience perspective, even for larger files, but it won't allow you to modify the original file the user selected. If you need to modify the original file or a file upload doesn't fit your requirements for other reasons, your best option will probably be to render a file/directory browser in HTML. HTH, --fg
I find IDEs don't help me programming Go much, because Go is already a clean and simple language. Often I just find myself using Kate... my default text editor...
That pattern of error handling is conceptually the [maybe Monad](http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#The_Maybe_monad), and is in use many places and languages. Its main advantage is the simplification of the code and the ability to put error handling where it is most convenient for your design. See a fairly robust Stack Exchange discussion about its [virtues and downsides here](http://programmers.stackexchange.com/questions/150837/maybe-monad-vs-exceptions).
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 3. [**The Maybe monad**](https://en.wikipedia.org/wiki/Monad_%28functional_programming%29#The_Maybe_monad) of article [**Monad %28functional programming%29**](https://en.wikipedia.org/wiki/Monad%20%28functional%20programming%29): [](#sfw) --- &gt; &gt;Consider the [option type](https://en.wikipedia.org/wiki/Option_type) *Maybe a*, representing a value that is either a single value of type *a*, or no value at all. To distinguish these, we have two [algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type) constructors: Just t, containing the value t, or Nothing, containing no value. &gt;We would like to be able to use this type as a simple sort of [checked exception](https://en.wikipedia.org/wiki/Checked_exception): at any point in a computation, the computation may fail, which causes the rest of the computation to be skipped and the final result to be Nothing. If all steps of the calculation succeed, the final result is Just x for some value x. &gt;In the following example, add is a function that takes two arguments of type *Maybe Int*, and returns a result of the same type. If both mx and my have Just values, we want to return Just their sum; but if either mx or my is Nothing, we want to return Nothing. If we naïvely attempt to write functions with this kind of behavior, we'll end up with a nested series of "if Nothing then Nothing else do something with the x in Just x" cases that will quickly become unwieldy: &gt; --- ^Interesting: [^Functional ^programming](https://en.wikipedia.org/wiki/Functional_programming) ^| [^Comparison ^of ^functional ^programming ^languages](https://en.wikipedia.org/wiki/Comparison_of_functional_programming_languages) ^| [^Haskell ^\(programming ^language)](https://en.wikipedia.org/wiki/Haskell_\(programming_language\)) ^| [^Windows ^PowerShell](https://en.wikipedia.org/wiki/Windows_PowerShell) ^| [^Corecursion](https://en.wikipedia.org/wiki/Corecursion) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cip7bmk) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cip7bmk)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Golang tends to discourage existing debug flows. You can wire something up with GDB but it is pain, and tends to work poorly. Writing tests + fast cycle time + printf debugging seems to be the norm. I now have a few tens of thousands of lines of Go under my belt -- and I have come to really think this is fantastic way to work. It is an adjustment. 
Remember, you may have full context of what your post is responding to, but your reader probably doesn't and certainly can't mind read what precipitated that response. So, if you are writing in response to something, make sure your reader understands that and has a reference to that something. You might be even more helpful and do a quick summary of the items you are responding too rather than asking the reader of your post to go back through everything in the link before they can start understanding what you are responding to. Having to go down a possible rabbit hole of references within the first few words of a post, instead of clearly laying out what you are specifically responding to doesn't provide a large incentive to continue on in the first place. In addition, in spite of your cleaning up the first sentence a bit, the second sentence immediately encounters the same needs some editing issues. I'm sure what you have to say is interesting; the presentation of that information pushes too much work back on the reader on various levels. 
I quite like Atom.io + GoPlus (which will soon be merged with Go Oracle)
Forgive me, I'm not the brightest light bulb, but could you be more specific about what you are trying to accomplish? Are you building an interface that allows the user to select a file of their choice through the ui? Is this a file that is needed for your app to work, like a config file? Who is your target user? Depending on what this file is and what it is needed for you could allow the user to set an environment variable with the target file string and have your app pick it up and open the file from there? Or could you put that information in a configuration file and have your application read that? This project might be helfpul https://github.com/skratchdot/open-golang For obtaining information about a directory or file you could use the [io/ioutil](http://golang.org/pkg/io/ioutil/) package to get the information which you could render in HTML.
Something I find is that a unit-tested program almost forces you to encapsulate state in the smallest units available - largely because that makes the testing easier, less context to emulate, fewer dummy objects to fabricate, etc. A possibly unintended side effect is that having so little global state makes it easier to debug the program without a debugger. You just don't need to see the state of all the variables at once because they only interact in very limited ways, along well-defined interfaces, with largely orthogonal behavior. Also, communicating through channels has a similar effect for the same reasons.
having used php and java before coming to golang I always found it was easier to debug code with var_dump than the eclipse debugger.
The two input I need are: the VLC path. This can be auto filled by the normal VLC paths, IE /Applications/VLC.app/contents/macos/VLC or C:/Programs/VLC.exe. But it would be nice to give the option of editing that path if it isn't where it normally is. The 2nd path I need is the video file. This could be a 10GB file so I am hesitant to do a file upload as even on fast computers a 10GB disk-&gt;disk copy is a hassle. That is why I need to full paths, so golang can do an os.exec(open /Applications/VLC.app/contents/macos/VLC /Users/Me/Videos/MyLargeMovie.mkv)
I absolutely get where you're coming from. I do a lot of javascript coding as well, and if it's not working correctly, the Chrome debugger is the first thing I reach for. Being able to change variables as it's running is incredibly useful. I think you're right about printf being great for linear workflows though, that's probably a big part of why I don't usually want a debugger.
For non-user friendly ways (assuming a technical user) using Environment variables or configuration files would work. Otherwise, you'll have to come up with a UI to make the user's life easier. Go has [path/filepath](http://golang.org/pkg/path/filepath/) that helps with working with path information, including resolving relative roots and helping you with OS specific stuff, like path separators. For example filepath.Abs(dirPath) will return the full path to the file or an error. Oh, and my prior response wasn't implying that you should upload the file, I was just explaining a way of listing the directory information in HTML. You could expand this by using the packages, along with some custom code, to allow the user to navigate the file tree via what is rendered in the browser. 
I used to go with liteide because it's an all in one solution. I ran into issues opening large files. It lags terribly. Now I switched to SublimeText.
There are several abandoned packages similar to Mango. It's difficult for these packages to compete against the good-enough net/http. The gorilla/context package is a nice add-on for the basic net/http.
If I did that I guess I would end up copying their code which I dont want to do. i get inspiration from the standard library (net/http) so I dont end up just using others code.
Out of interest, what does Rack do that net/http doesn't?
This gives some clues: select vs epoll, much more mutex locking (futex).
This worked. Thanks!
Is it pretty much martini without inject?
He's just talking about sending another (empty) value through the channel - the `warnonce("")` call. Assuming an unbuffered channel with only one receiver, the sender will end up blocked until after the receiver picks up the second message, which is going to be after it's processed the final useful message.
&gt; One of the easiest pitfalls to stumble into when using any external resource is the latency and load associated with creating and closing new connections. That's interesting. Looking at your gist and Go's rpc client, any error in the `input()` loop [will totally kill the client](http://golang.org/src/pkg/net/rpc/client.go?s=7883:7989#L104). Am I reading it right? I'm not sure I like the idea of one failing RPC call killing 100 others. I ask because I have a similar problem. My external resource is over TLS, and it is very expensive to bring up a connection, which causes some nasty latency spikes on API calls. I've been looking at methods for connection pooling or whatever to try combat this, your approach looks interesting but perhaps depends on the implementation of the rpc client.
Well, you're sort of correct. Basically, what we're looking at is: func RpcConnectionCheck(rpcCallError error) { var err error if rpcConnection.rpcClient == nil { log.Println("Restarting RPC Connection due to nil connection") err = RpcConnect() } else if rpcCallError == rpc.ErrShutdown || reflect.TypeOf(rpcCallError) == reflect.TypeOf((*rpc.ServerError (nil)).Elem() { log.Println("Restarting RPC Connection due to error") rpcConnection.Lock() err = RpcConnect() rpcConnection.Unlock() } if err != nil { log.Fatal("Unable to initialize connection to RPC") } } If the RPC connection has shut down or has entered the closing state, OR *any other error thrown by the RPC client* we attempt to reconnect. It's a little overzealous, and a little too quick for my ideal tastes. For example, I really only want this function to do work if A) My RPC Server fails B) I restart my RPC Server Right now, if I update my docker container and restart the RPC server, the webserver will fatal 5 times (supervisord's flapping threshold for restarting), and no longer restart -- ALL before the RPC Server is ready to hold a connection. In my particular set-up, Supervisord handles restarting the application when it fatals; it may not work if you're not using a similar program supervisor. Definitely needs improvement, but it's currently doing a great job for network hiccups. If you believe concurrency might be an issue, I'd recommend creating a connection pool of RPC clients. As the charts show, ~1000 concurrent connections is no problem for one RPC server. That's something I can look into if you're interested; I won't have time until closer to the end of the month, though! Edit: I should add that this current project has an insane timeline, and that this only made it in because someone in #reddit-gamedev had a similar issue, and I figured rather than relying on Supervisord, I could help both of us out by making a minimal structure.
It is just middleware. No routing, no inject, and it plays really really well with net/http.
I think Rack allows you to specify which Web server to use at run-time, doesn't it? That won't happen with Go because it's compiled. You can always run nginx or varnish or any other reverse proxy in front of your Go application though. But if you're talking about something that you'd compile in - I imagine if there are other Web servers (I think http.Server is the only one right now?) they'd be able to serve anything that implements the http.Handler interface. What is the purpose of there being multiple Web servers that work with Rack? Is it because the Ruby community hasn't decided on one server that's the best? If that's the case then that's something you don't need to worry about with Go - everybody uses http.Server.
You would have to recompile the app to change web servers, yes. But if everybody uses http.Server, then I guess there isn't that much need for Rack. I am new to Go, so I currently exploring the web dev options. Thanks!
thanks, with this (https://github.com/joefitzgerald/go-plus/pull/24) it looks like it might be a little nicer than gosublime
Excellent tip! I generally develop (and include comments) on my regexps in [Oyster.app](http://www.rwe-uk.com/app/oyster), but it will be good to be able to leave embedded comments in actual Go regexps now too.
Different commitments, so maybe.. both? But I don't think rust will ever have 2 pages called "how to write rust code" and "Effective Rust" that you can absorb in 2 days but they do have a dedicated person for rust docs/tutorials, so they're doing it right. http://golang.org/doc/effective_go.html http://doc.rust-lang.org/ And, according to this, you might want to wait for rust 0.12 or possibly .13 instead of 1.0 for some kind of language/compiler stability, if not stdlib/API stability (thread also contains discussion about go and C interop/FFI https://news.ycombinator.com/item?id=7978599 this was a couple weeks ago, about building nontrivial apps today in rust, including recompiling rustc: http://www.reddit.com/r/rust/comments/28nvc6/game_in_rust_instead_of_c_how_much_work_would_it/ Oh, and /r/rust is jumping, but stackoverflow, not so much. 
Web apps in Go implement the http.Handler interface. If someone was to write a different web server package for Go then it would have to work with things that implement that interface too.
Another idiomatic solution to the closure problem is for _, it := range iterable { it := it // local to iteration defer func() {println(it)} }
Isn't that what [`http.FileServer`](http://golang.org/pkg/net/http/#FileServer) is for?
Thanks, I'll try to bear that in mind next time. I spend far too much time on Reddit, and made the mistake of assuming the audience would be as familiar with the 'context' of the conversation as I am. Could you give me some pointers on what's wrong in the second sentence? &gt;It also however has some advantages that allow its users to do things that users of many other languages cannot easily do. Grammatically at least it seems fine to me. 
Aye, I believe that's covered in the linked article 
I haven't tested, but this looks like it might be vulnerable to path transversal attacks. What happens if req.URL.Path[1:] contains ".."? Unless the http router or ServeFile, filter that out, this could be very dangerous. 
The author seems a bit too inexperienced with statically typed/fast languages to hitch himself to one particular language already (he writes that he would consider lobbying for greenfield work with Go). 
Try it. Just press "RUN". http://play.golang.org/p/6_y1GkbvcJ
The UI looks nice and clean. Looking forward to trying it out. For anyone interested in the actual IRC mechanics, they're provided by https://github.com/fluffle/goirc
Nope! Safari but I hid all toolbars at the top. 
Can't tell if sarcasm
A demonstration is online and I have updated the readme to help the usage
I use this same setup. Is gud. Fact.
Where do you feel like I could have expanded upon with variable names? I also dislike when it's unreadable, but I felt like I didn't make anything confusing. I really appreciate feedback, so let me know some specifics!
I'm a long time vim user, and I don't understand what you are trying to say. After all, vim also fits the definition of an integrated development environment, although the degree of integration might not be as deep as other alternatives.
Oh wow, thanks for linking this, I love node-webkit and have made some apps with it, didn't know about golang-nw. I'll definitely try it out.
I think the usage here is plain and obvious; even idiomatic when adding methods to a type. For reference, scroll through http://golang.org/pkg/net/http/ or any number of packages and see that when implementing methods, you'll often find things like func (c *Client) ... 
wg is commonly used for Wait Group instances; nothing wrong in my mind here.
Why are you spamming the thread if you do not know the answer? Mindless trolls !! STICK TO THE POINT !
TROLLS !!! STOP POSTING USELESS COMMENTS POSTS IF YOU DO NOT KNOW THE ANSWER !!!
This is probably the most idiomatic IRC library I've seen. Great job!
I wasn't trolling, I was trying to push OP into forcing themself to better understand the problem so they could ask questions better.
Hi, Here is a recap of best available packages for doing what you need : https://github.com/avelino/awesome-go I also suggest you : http://www.goinggo.net/ https://flipboard.com/section/the-golang-magazine-bVP7nS http://www.gopheracademy.com/ Explain go in 2 sentences : Real pleasure to code with, It's great and it's going to be greater
I think you're right when I probably could have added a comment to explain that it's wait group. I just threw a comment in the blog post that explains it's a wait group. I stand by using "s" since I don't think there could ever be confusion there that it means "server."
Looks pretty good, except for the ALLCAPITAL constants which look like a C-like wart. Go tries hard to avoid them, with the exception of some mistakes we made in the standard library during the early days. See https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Mixed_Caps 
[Iron.io: Go After 2 Years in Production](http://blog.iron.io/2013/08/go-after-2-years-in-production.html) [Go - report after 3 months in production](http://www.reddit.com/r/golang/comments/1tgqk5/go_report_after_3_months_in_production/) --- Google created Go out of necessity, since no other language was able to solve the engineering problems that they were regularly experiencing. Concurrency, simplicity, tooling and suitable for large scale projects.
In this case, it's because of the irc specification: http://tools.ietf.org/html/rfc2812
*The founders of Go created it as a side project they came up with while lamenting compile times.
[Dropbox's](https://tech.dropbox.com/2014/07/open-sourcing-our-go-libraries/) announcement mentions moving "performance-critical backends from Python to Go to leverage better concurrency support and faster execution speed. This was a massive effort–around 200,000 lines of Go code–undertaken by a small team of engineers. At this point, we have successfully moved major parts of our infrastructure to Go."
From golang.org: *"The Go programming language was conceived in late 2007 as an answer to some of the problems we were seeing developing software infrastructure at Google. The computing landscape today is almost unrelated to the environment in which the languages being used, mostly C++, Java, and Python, had been created. The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today's server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours."*
Thanks! I know about the mixed caps, but chose to use the exact names used in the IRC RFC for clarity.
I looked at `reddit/reddit.go`. Some comments: * I would use the [built-in HTTP cookiejar functionality](http://golang.org/pkg/net/http/cookiejar/) instead of manually fishing out the `reddit_session` cookie. It's easy to make cookies "work" by making assumptions, but it'll bite you eventually. * `PostLink` should not call `fmt.Println`. If you want progress reports, add a `log.Logger` or channel parameter; don't write to the console unconditionally. * I think `Submit` and `Post` should be methods on `Session`, rather than functions that take a `*Session`. * `Post` should not be exported; it's too low-level to be of use outside the package. * `Response` should not be exported. In fact, I don't think that type should exist outside the context where it's needed – I would say `var response struct { … }` inside `Submit()`. * `Submit` ignores JSON decoding errors. * `Submit` calls `fmt.Sprintf` with constant string. * `Submit` should return the response modhash instead of discarding it on success. 
[Go at Cloudflare](http://blog.cloudflare.com/go-at-cloudflare).
&gt; For starters, I got bitten by the no-circular-dependencies thing a few times, so I decided to put all my interfaces, basic types and constants into a separate package, called "types". While that works wonderfully, I'm not sure whether its the correct approach. It's probably a code smell, but sometimes it's a valid approach. That's a really big "it depends". If we're talking about a package that you expect others to use, though, it's a _huge_ code smell, bordering on straight-up bad code. I shouldn't need to import `github.com/you/yourpackage` _and_ `github.com/you/yourpackage/types`, and there's no way for a package to "re-export" types. (No, type aliasing as in `type Newtype otherpackage.Oldtype` doesn't work... that's not a re-exported Oldtype, that's a Newtype that _can be converted_ to Oldtype but is not a transparent stand-in for Oldtype.) &gt; Another thing, I noticed that a lot of people use global package variables and functions to manipulate them, instead of using objects with methods. One example of this being the gorilla-context package. I went with the tried-and-true way of instantiating a context object with a bunch of methods, and passing it around. Is that a bad practice in go? No, it's a bad practice in Go to use the global context, just as it is in any other language, and just as it is in any other language, seductive and tempting is the path to the Dark Side of the Code. It's still the Dark Side, though. &gt; I also played around with the reflect package, which was quite different from the java counterpart. I'm just going to stick to the meta comment that you probably shouldn't be screwing with that package at all. The community considers it bad practice in web frameworks, but, even assuming you don't really have the intent of anyone else using it, you really should get used to just using interfaces and structs. It ought to be able to do anything you need it to do, though you might need some thin adaptors around net/http to get it done. &gt; Only when I want the variable itself to change, or can I also use them when dealing with objects that contain lots of data, and thus avoid any potential performance problems if the values get copied on each function invokation? If A: you need to change the value in a method B: you've profiled and found copying is taking too long or C: for some semantic reason you specifically need copy or share semantics. I think it's hard to just write out the full rules... you'll get a sense for it over time (and profiles).
+1 to all of this. You also almost certainly don't need or want a `types` package. Use a single package for your entire application until it becomes obvious that you need more.
[Go at SoundCloud](http://developers.soundcloud.com/blog/go-at-soundcloud)
&gt; If you choose your tools to optimise your typing time then you're optimising the wrong thing. I think you took this in an entirely different direction that I didn't even touch. * Fact: Go has more boilerplate for stuff like error handling and dealing with types. This isn't a bad thing, it's a different thing. * Fact: Python is often faster for prototypes of things. It's generally a lot more permissive about a lot of things. This can be good and bad depending on your skillset and your style. * You may see time saved in maintenance down the road with Go, but you may not recoup that initial boilerplate expense immediately. Python is almost hands down faster to *write*. If you can't write Python faster than Go, it's probably from not having a good grasp on Python. I use Python and Go a good bit, and like each for different things, but the time to the first working prototype is almost *always* faster with Python. It probably won't be as fast, have as slim as a resource profile, and you may end up spending more time later if you have to maintain/refactor, but that's a different matter to consider.
Was thinking about building something just like this, thank you. Wrote a multi-server logger. Wrapped irc.Message in local Message struct and added a timestamp field. Thanks again for the package, great job!
&gt; It's probably a code smell, but sometimes it's a valid approach. That's a really big "it depends". Yes, the thing with importing the types package everywhere is a nuisance. I'm not looking into moving all interfaces and such back into their implementing packages. Though I wouldn't go so far as to move everything into a single package as /u/ptrb suggest, that would make things harder to browse when you suddently have 10 "middleware" files + tests in the same package. I'd still rather organize things a bit. &gt; I'm just going to stick to the meta comment that you probably shouldn't be screwing with that package at all. Tbh, I mostly did it just to get a feel of how to use the reflect package. And right now I only use to in the config.go file to clear all slice fields in the struct. That sure beats having to maintain a function that does this manually whenever I decide to add/remove a slice field. &gt; B: you've profiled and found copying is taking too long In general for the B option, if you have a struct with some slice data and/or a big map, how does go handle things when the struct instance is not a pointer? Does it somehow efficiently copy the values on each call without any overhead? Someone has most likely profiled this already.
I may be missing something, but I've not found the use of a package global database pool to be a problem for testing or writing code - i.e. // package models var db *sqlx.DB func ConfigDB(o *DBOptions) { // Pass the pool to the package level DB // Configure MaxOpen, MaxIdle, etc. } func (u *User) Get() (bool, error) { err := db.get(u, "SELECT * FROM users ...") ... return true, nil } // models/user_test.go func TestUserGet(t *testing.T) { setupTestDB() // Wraps ConfigDB and passes in the test options/checks for TravisCI, etc. defer db.Close() // Write test } // package main func setup() { pool, err := sqlx.Open("...") ... opts := models.DBOptions{Pool: pool, MaxOpen: 256, MaxIdle: 64} models.ConfigDB(opts) } My tests just set up their own database connection (or call a helper function that I re-use across each test). My application itself just passes the relevant configuration (parsed from a config file) to the models package on start-up. My handler types are then divorced from the datastore itself, and I get a slightly cleaner API out of it when writing out routes. My handler types are typically something like `type AppHandler func(web.C, http.ResponseWriter, *http.Request) (int, error)` with a `ServeHTTP()` method that inspects the returned status code &amp; error and either serves a pretty 40x/404/500 page, or in the case of no error, leaves the handler to do its own thing. 
The Zeus IDE has support for Go: [http://www.zeusedit.com/go.html](http://www.zeusedit.com/go.html) Also the latest 3.97t version has been updated to support the latest Go 1.3 release. NOTE: Zeus is shareware, runs natively on the Windows platform and runs on Linux using Wine. *Jussi Jumppanen* *Author: Zeus IDE* 
&gt;I thought the point of tokenizers is that they are much faster than regular expressions? That depends
Can someone explain why "global" variables are evil in a procedural language with only slight object orientation? These types of things are used *frequently* in C.
I (personally) don't see a problem with "globals" for things like database pools, configuration variables, etc - things that you either want to access and don't need to change during runtime, or that manage their own locks (i.e. `*sql.DB`, `schema.Decoder`, etc).
&gt; The Go runtime doesn't currently print any warning messages if your program exits with active goroutines. To translate, things happening in the background may or may not work as expected when the rug is pulled out from under them. 
No, I've just been a programmer for a long time and I'm about productivity and not job security. We can sit around in a room an suck each other's dicks and design system that only we can understand or we can make tools that make life easier. Node is one of those tools.
&gt; No, it's a bad practice in Go to use the global context, just as it is in any other language, and just as it is in any other language, seductive and tempting is the path to the Dark Side of the Code. It's still the Dark Side, though. &gt; Given the way gorilla/context works, it *must* be a global map: otherwise it would not be as composable as it is. In other words, if it wasn't just a global, you would not be able to drop it into any net/http (http.Handler) application: you would need to write your router around it. In terms of performance, the global map won't affect most web applications (esp. if you are rendering templates, which will be the bottleneck a LONG shot). If you want to avoid a global context map, then you will need to use either structs w/ handlers-as-methods (ala https://github.com/gocraft/web/) or Goji (https://github.com/zenazn/goji), by extending http.Handler with your own interface that includes a request context. The upside of the gocraft/web approach is the type-safety you get from structs; the downside is that you need to compose a lot of your own middleware and handler types as methods on your Context struct(s). On the Goji side (which uses a per-request map[string]interface{}) the upside is that you have a flexible context map you can add to any http.Handler (and/or wrap one with a closure), with the downside being the need to write out type assertions to pull things from the interface{} - although usually you can write a helper function for each type you want to get/set. 
Global variables get in the way of local reasoning. E.g. if you have `foo(a, b, c); bar(x, y, z)`, it's not necessarily obvious how the `foo` call will influence the behaviour of the `bar` one due to global variables. (Of course, it's not necessarily obvious without global variables, but global variables definitely don't help.)
&gt;For starters, I got bitten by the no-circular-dependencies thing a few times, so I decided to put all my interfaces, basic types and constants into a separate package, called "types". While that works wonderfully, I'm not sure whether its the correct approach. This question bothers me aswell, Where should i put interfaces? The Dependency inversion principle clearly states that high level modules should depend on interfaces not on low level modules so does that mean that the main package should have all the interfaces and implementations in other packages?
Can you briefly explain what is going on with the managers? I'm having a hard time understanding how it makes it easier for testing based on the source code.
D [does have SHA-256](http://dlang.org/phobos-prerelease/std_digest_sha.html) (as well as the rest of SHA-2) as of DMD v2.066 which is currently [in beta](http://forum.dlang.org/thread/53B5FFB4.3010002@yahoo.com)
&gt;However I had some problems figuring out how Go wanted me to compile and/or install my various packages. At the end I did a separate build / install on each file in a package, but still I wasted quite some time wondering what the hell was happening when all I actually need was a build and install. I wonder what he means by that. Because really, after setting your GOPATH there's nothing easier than installing and building a Go project.
After the initial comments I decided to put each interface in the package of the implementation. Since my main package uses these subpackages, putting them in the main I've was out of the question
You might want to look up Cargo for rust, and pick up a more distinct name
IMO there's no need to mimic http's listenAndServe functionality. Make your class implement http.Handler and you can http.ListenAndServe(listen, mycargo). See https://github.com/blang/methodr/blob/master/methodr.go
Why wold you do that? so now your main package is tightly coupled with your sub packages and it doesn't matter if your have interfaces that other packages can implement. To make it loosely coupled you should include the interfaces in the main package and the implementations separately. So if in the future you want to use another implementation you just switchout the sub package and the rest of the program is good to go. Your apporach might have been a good way in say a java program since you need to explictly state what you implement but in Go implementations of the interface is implicit so you don't need the interfaces to be in the same class as the implementation. 
Google homepage doodle http://blog.golang.org/from-zero-to-go-launching-on-google
&gt; Why wold you do that? so now your main package is tightly coupled with your sub packages and it doesn't matter if your have interfaces that other packages can implement. What makes the main package tightly coupled to the subpackage? Although I moved the middleware interface to the main package, being in the middleware package seemed structurally logical. And I can't think of any way a custom mw implementation might be inhibited by having the interface defined in the core middleware package. Just genuinely asking here.
&gt; interface (..) in the middleware package seemed structurally logical Yes according to languages like Java, C++ where you need to implement the interface explicitly class CookieWare: MiddleWare { .... } but in Go the implementation of an interface is implicit so you define in the main package what interface you want to be implemented and use that everywhere so if in the future you want to use a different subpackage that you can just import that and it would work without a problem. &gt;What makes the main package tightly coupled to the subpackage? now if your subpackage implements a middleware for auth and uses cookies, now you want to make a new module with uses redis so you copy over the interfaces(?) or make changes in the main package But if your interfaces are defined in the main package you can easily just implemnt the same interface in the subpackage and just change the import line. 
Can't login to comment via twitter. :&lt; &gt;Unspecified error. #6
Oops I had no idea. I just took my post down as it's probably not fair to them. Did not know the rust community was so tightly integrated with go's.
&gt; Given the way gorilla/context works, it must be a global map: otherwise it would not be as composable as it is. And I've got a case where I have to use a global variable, because the Unmarshal\* interfaces don't have anywhere to initialize a decoder with decoder-specific information to pass to a decoding method. Without thread-context variables, there's simply nowhere left to put the additional information I need. But that's not a license to throw your hand up in the air and just start sticking stuff in the global variables willy-nilly, it's a time to reluctantly give in and work around a problem. And I'd consider a framework building itself around a global variable to be a major negative. It's not worth it to save a few lines of code and wreck the ability to have more than one instance running at the time, a feature you don't need until suddenly you do.
Global variables can present a shared-mutable-state problem in any scenario, "procedural language" or not. Global constants are less "evil", but IMO should be avoided when tenable so as to maximize local reasoning; "magic" identifiers can (in some cases) reduce ramp up time when revisiting/maintaining code. Sometimes they make sense, though. Globals are often demonized as ipso-facto naughty behavior, which is a bit overboard; if you've thought about it and it's the right tool for a given context, so be it.
really awesome.
Well, yeah, that's the thing about global variables. They're more convenient, tempting, easy... until they suddenly aren't any more, and then you're in a lot of trouble because undoing them is a lot of work, and you often just don't do it. But like many of the tempting, easy, and wrong code practices, the problem doesn't emerge in a reddit-sized code snippet. Anything you can fit in a reddit code snippet works just fine. You can even argue that using nothing but "goto" isn't that big a deal in a reddit-sized comment, because even 30 or 40 lines of code using pure gotos is comprehensible. The problem doesn't come until the program is bigger. And so it is here... you may feel like the global variables aren't a problem, but as the size of your program increases and as the number of globals you are using increases, the odds that you will screw up with one of them goes to near 100%. There's any number of ways having one global pool can be a bad idea. You might need to connect to more than one database, as benbjohnson points out you can't run independent tests in parallel with that, and you can't compose together two things that want to use the same pool global variable but to use different configurations on that global variable for some reason. It's easy to look at these problems and dismiss them when your code is small. But, again, I absolutely guarantee you that as your code grows and the number of global variables you casually use increases, you will eventually code yourself into a corner. It may not be this variable and it may not be any of the reasons I just mentioned... it may be another one entirely, or it may be this variable and a reason I didn't think of. Code gets complicated! [This pattern](http://www.jerf.org/iri/post/2929) isn't that hard to use from the beginning, it doesn't add much overhead (Go is actually quite good at it) and prevents endlessly growing signatures (you just add one thing once, instead of a DB connection and a cache and whatever else, etc), and it grows gracefully. In many cases you don't even have to add it to a method signature because you can just embed the environment in a struct itself. It's _slightly_ less convenient than just using a global, but the very first time it saves you it pays for itself, and it's gravy after that. And testing is so much easier with it....
&gt; And I'd consider a framework building itself around a global variable to be a major negative. It's not worth it to save a few lines of code and wreck the ability to have more than one instance running at the time, a feature you don't need until suddenly you do. Note that gorilla/context is not a framework, hence the restriction; and it does not prevent you from running (e.g.) GOMAXPROCS(8) either. I prefer a more tightly coupled router + request context personally, but I'm also saying that there are situations where a well configured (i.e the right mutexes and some benchmarking) global can simplify your code and API.
&gt; When should pointers be used? Only when I want the variable itself to change, or can I also use them when dealing with objects that contain lots of data, and thus avoid any potential performance problems if the values get copied on each function invokation? Well, the C/C++ programmer in me says that all structs should be pointers. However, Gophers tend to prefer using structs as value types since it makes concurrency easier to get right. It's uncommon to see a channel of pointers since the pointed-to item is too easily shared between goroutines. I would argue that library designs that foist the use of pointers on the consumer to be a smell, unless it's absolutely necessitated by the design. Optimizing towards pointers should be done after you've benchmarked your program. In most cases you can just change a func argument to a pointer, without the caller having to change their code, since Go implicitly casts values to pointers when needed, most of the time. The exception, of course, is on func receivers - it's idiomatic to have these as pointers. Edit: also, keep in mind that slices and maps are also more or less "pointer" types. A lot of idiomatic "constructor" funcs also return pointers. So, Go has pointers all over the place. Take a deep look into the standard library and the typical patterns for pointer use should emerge pretty quickly.
That's a good point, but you can certainly work around it without much effort ("work around" is probably an exaggeration): * I can still call ConfigDB from a separate test package and pass it a `models.DBOptions` with the relevant test database config to set the private variable, or I could export it, which is also easy enough: I just prefer to use a configuration struct to keep my package's API cleaner. * You could also configure it in the test packages' (or just the `_test.go` files in the same package) `init()` which would enable parallelisation as the global `*sql.DB` will be initialised before any tests run. Obviously the alternative is to pass a `*sqlx.DB` to my database methods (`user.Get(db *sqlx.DB)`, `user.CreateAdmin(db *sqlx.DB)`, `listings.GetRecent(db *sqlx.DB)`, etc.). I just find not having to pass a pointer to my DB pool to *every single function* a lot cleaner. Otherwise it becomes much harder to create custom handler types without having to write closure-after-closure. I could just write `var db *sqlx.DB` in my package main and pass that from inside my handlers, but we're pretty much back at square one here. My point is that the sensible use of globals can help to simplify your package API, function signatures and custom handler types. Reconciling this extremely useful pattern—a custom handler that returns a status and error with the appropriate `ServeHTTP` method—starts to become pretty verbose. We can either use closures: type AppHandler func(*sqlx.DB, web.C, http.ResponseWriter, *http.Request) (int, error) func (ah appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { // db doesn't exist in this scope, so our AppHandler type needs to be returned from a closure status, err := ah(web.C{}, w, r) if err != nil { // Handle it } } func main() { db, err := setup() ... r := web.New() // Similarly here - we'd need to create a closure r.Get("/", IndexHandler(db)) graceful.ListenAndServe(":8000", r) } func IndexHandler(db *sqlx.DB) http.Handler { return appHandler(func(c web.C, w http.ResponseWriter, r *http.Request) (int, error)) { ... } } Or we can create a struct type that has an `*sqlx.DB` member and create our handlers as methods, but now we're getting pretty clunky (IMO) for **zero** performance benefit or testing benefit (as I've outlined above): type AppContext struct { DB *sqlx.DB } type AppHandler func(*sqlx.DB, web.C, http.ResponseWriter, *http.Request) (int, error) func (ah appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { // db doesn't exist in this scope, so our AppHandler type needs to be returned from a closure status, err := ah(web.C{}, w, r) if err != nil { // Handle it } } func (ac *AppContext) IndexHandler(c web.C, w http.ResponseWriter, r *http.Request) (int, error) { user := models.User{} exists, err := user.Get(ac.DB) if err != nil { return 500, err } ... return 200, nil } func main() { r := web.New() // Every handler needs to be a method on this struct, and we need to pass DB to each one // (but I'll concede it's a lot cleaner than the first approach) r.Get("/", &amp;AppContext{DB: db}.IndexHandler) graceful.ListenAndServe(":8000", r) } Of course, I'm not trying to dissuade you from your approach—which works, and is valid—but I'm trying to combat the "globals are code smell" ideology that I've seen floating around some of the other channels (i.e. not your article). For things that aren't "copied" (like a database connection pool), a global instance adds convenience and makes it easier to change things later. I also appreciate your reply here + on the article comments :)
&gt; You can even argue that using nothing but "goto" isn't that big a deal in a reddit-sized comment, because even 30 or 40 lines of code using pure gotos is comprehensible. The problem doesn't come until the program is bigger. And so it is here... you may feel like the global variables aren't a problem, but as the size of your program increases and as the number of globals you are using increases, the odds that you will screw up with one of them goes to near 100%. I think this is exaggerating the problem. I am not (and nor have I said) that adding global after global is a great idea. I'm saying that a rule of "zero globals" is not always the best approach, and in fact can add complexity. &gt; You can even argue that using nothing but "goto" isn't that big a deal in a reddit-sized comment, because even 30 or 40 lines of code using pure gotos is comprehensible. ... &gt; There's any number of ways having one global pool can be a bad idea. You might need to connect to more than one database... I'll definitely concede this one—you can obviously pass different pools to functions as you wish, but I'd have to say that this would be a pretty exceptional use-case: running two databases (but sharing the same query syntax/underlying package) would have to be rare. &gt; And testing is so much easier with it.... I'm certainly open to adopting the struct-with-handlers-as-methods approach, but I'd definitely like to see an example of where testing is easier with it.
I never ever use panic unless it's really an unrecoverable error that the layer above should not be handling. It's a last resort for an "abort the entire program" kind of error which you don't encounter that often. My general rule: avoid as much as possible.
Sure, but what's the best pattern for handling errors within an HTTP request? Just do something like this? links, err := getLinks() if err != nil { logErrorSomewhere(err) http.Error(w, "Oops", 500) return } Do you not lose the complete stack trace in such cases? Also the assumption here is that you have some per-request middleware to handle recover (e.g. negroni's Recover) so a panic is automatically logged without aborting the program. 
You are using panics like exceptions. This is not idiomatic. See http://golang.org/doc/faq#exceptions *Edit:* To make things clearer: Anyone who would wrap your panicking handlers in the future would have to be aware that it can panic in almost any error case. It should not be the concern of other wrappers to deal with the panics. If the response is an HTTP 500, so be it. That is expected. *Edit2:* You can retrieve your stack trace as well: http://golang.org/pkg/runtime/#Stack But generally you wouldn't even need the stack trace, since almost all errors would be expected and therefore you would know how to handle those ;)
If the error is sufficient enough that a stack trace is useful (i.e. the error is truly unexpected/weird), then calling `panic` seems appropriate if you have suitable handling for it at a higher level. 
&gt; Just do something like this? Yes, exactly. &gt; Do you not lose the complete stack trace in such cases? You should have all the actionable information you need in your `logErrorSomewhere` invocation.
Thanks, I added the golint suggestions, go vet didn't find any problems though.
&gt; Do you not lose the complete stack trace in such cases? Go tends to handle error output in the same tradition as C: rely on logging, rather than full stack traces, for recoverable errors. It's a good idea to have logging all up and down your call stack so you get enough context to debug the program. Think of it like a semantic stack trace, where the output is richer than just "file, method, and line number." Alternatively, opt for "fatter" log lines that emit all the context you need, in one shot.
If it's not explicitly stated in spec, you are strapping land mines to your feet by relying on current possibly deterministic behavior.
You can use [runtime.Stack()](http://golang.org/pkg/runtime/#Stack) to generate a stack trace. Write a wrapper struct that does this for you and you'll never have to think about it again. I'd suggest something with a method set like: type ErrorWrapper { ... } func New(err error) *ErrorWrapper { ... } func (wrapper *ErrorWrapper) Error() string { ... } func (wrapper *ErrorWrapper) StackTrace() string { ... } func (wrapper *ErrorWrapper) Unwrap() error { ... } Whenever you make a new error, pass it to New(), which will generate a stack trace, then if you want to case on the error type, call Unwrap(). People have written better error libraries that do cooler things, but honestly I can't remember a time where I've needed more functionality than this.
As said here, do not use panic as an exception. The word 'panic' is pretty good in describing when to use it: as a "kill switch" to prevent further damage. And yes - something like that construction would be ok imho. Log and let something else manage the error reporting. If you want to include a stack trace, you can use the [PrintStack](http://golang.org/pkg/runtime/debug/#PrintStack) function or implement your own (the Go runtime provides you all the tools you need to do that) - but in most error cases this is not going to be very helpful and just fill up diskspace. And that's speaking from experience with Java programs spitting out stacktraces nobody cares about, 99% is "normal behavior".
I only call panic() when there's no way for the application to proceed / start up. In a web server example, that would be if, say, the server is given conflicting config options. A handler triggered by an external request would never be a panic(). Maybe that one showLinks endpoint has bad SQL, but the rest of the code doesn't. 
This looks great! Starred, I plan on using this...
Nice intro. I'm using bolt to store tracking information, not released to production yet, but very promising so far. Very well constricted code and API. ;)
Not sure about Go's version, but when you need to fix the version of your own package, you may use http://gopkg.in, check it out.
See scripting languages section - http://go-lang.cat-v.org/library-bindings, i think you will find what do you search. Also look at twik - http://blog.labix.org/2013/07/16/twik-a-tiny-language-for-go
use the go build tags // +build go1.2
the cat-v.org is sadly not that well maintained anymore. besides mattn's v8 engine binding there also is [this](https://github.com/idada/v8.go/) one.
Documented at http://golang.org/pkg/go/build/ 
Thanks. I just started using it, and was sad there was no intro article that I could find. I liked using it so much, I decided to I write one :)
Still dangerous: http://play.golang.org/p/0gIwy3Ktw7 They're clearly doing some kind of path scrubbing inside of http.Request or url.URL.Path. Honestly, I don't think such logic belongs there, but I get that it's important for an integrated library in a new language to play it safe. What's really bad is that the docs for http.ServeFile() make no guarantees about embedded relative paths in the request.
Yeah, that's a good point. I don't think it's actually strictly necessary. Ending the application will close the file handle, and bolt will ensure the data is written to disk when the transaction is closed, so there's no need to worry about corruption... however, it's probably good form to close the db anyway. Fixed. Thanks!
There is a native JS interpreter - https://github.com/robertkrimen/otto and it seems to be under active development
How is this any better than using [LevelDB](https://github.com/syndtr/goleveldb) where you also specify a single file path and get/set from it?
&gt; For little to potentially negative gain in convenience, someday they're going to bite you hard. That's not even going out on a limb to predict... they really are that bad, especially in languages with lots of concurrency... like Go. Perhaps we were talking past each other here: I've said that careful use of the *right* global variables is (IMO) fine—just making things a global for utter convenience is not the right way to go. Template maps, connection pools, etc — stuff that is inherently safe to be a global because they are either read-only or protected by mutexes. Calling it a "crime" is certainly exaggerating things. Anyway: here's the current globals in my web application (condensed into a block for posting here): var ( decoder = schema.NewDecoder() bufpool *bpool.Bufferpool templates map[string]*template.Template db *sqlx.DB store *redistore.RediStore mandrill *gochimp.MandrillAPI twitter *anaconda.TwitterApi // Application-wide configuration - hostname, session names, etc. conf *AppSettings ) You'll notice they're either connection pools, instances of an API or app-wide settings (hostname, etc) that are useful in multiple contexts. The latter is especially useful when passing in as options to imported packages, where you cannot simply pass your own `Environment` struct in. I do *like* your `Environment` approach, but it certainly differs from the article, which implies configuring the handler per-route: http.Handle(“/hello”, &amp;HelloHandler{db: db}) In a real app, that gets complicated extremely quickly. Here's what a *subset* of my routes would look like if we had to pass things like that: // Different handlers require different things - not all of them need email/Twitter APIs, but they all need access to the config, template registry, database pool, etc. There's a huge amount of room for error here and you won't know it because your program will *fail at runtime* (just like it will with globals) if you attempt to reference a null map or pointer to a connection pool. forms.Get("/create/new", appHandler(&amp;AppContext{db: db, bufpool: tempBuffer, templates: registry, config: conf, store: redis}.CreateListingForm)) forms.Get("/create/preview", appHandler(&amp;AppContext{db: db, bufpool: tempBuffer, templates: registry, config: conf, store: redis, decoder: decoder}.PreviewListingForm)) forms.Post("/create/preview", appHandler(&amp;AppContext{db: db, bufpool: tempBuffer, templates: registry, config: conf, store: redis, decoder: decoder}.PreviewListingForm)) forms.Post("/create/post", appHandler(&amp;AppContext{db: db, bufpool: tempBuffer, templates: registry, config: conf, store: redis, decoder: decoder, twitter: twitter, email: mandrill}.SubmitListingForm)) That's obviously pretty nuts, prone to error and if you don't realise you haven't passed something, you'll end up with nil pointers and nil maps all over the place. Whilst that's also true for globals, you can at least set them on program start-up - a typo here or a refactor could cause some pain. Taking your approach (correct me if I'm wrong here) we'd have something closer to: func main() { context := NewAppContext() // We'd probably want to pass in an &amp;opts struct here, right? forms.Get("/create/new", appHandler(&amp;context.CreateListingForm)) forms.Get("/create/preview", appHandler(&amp;context.PreviewListingForm)) forms.Post("/create/preview", appHandler(&amp;context.PreviewListingForm)) forms.Post("/create/post", appHandler(&amp;context.SubmitListingForm)) ... } ... which is far cleaner, easier to reason and keeps things close to where they're configured than the previous approach. The downside is that beyond this, we either need to define our functions (elsewhere) as methods on our struct, or end up with potentially lengthy signatures if a function needs access to multiple pools/APIs. I will digress that this isn't really *that* bad in the scheme of things, but it's worth mentioning. I should note that (after writing out some examples) that I *am* slowly coming to like your approach, although I'm not sure splitting out the environment/context struct into another package gels with me. Out of curiosity, does passing a reference to a struct impact performance (i.e. increasing per-request garbage) in any way? Note that for libraries, I'm 100% for using structs and avoiding any kind of globals that a package-user interacts with: you should nearly always have your API as methods on a struct that you return from a `NewThing()` function, with `NewThing()` accepting a struct of options and returning a configured `Thing` (or sane defaults).
Why would err not contain the information required? Also, why not return it as the message to the 500 status?
Ah great, that makes a lot of sense. Thanks!
Here is an example illustrating that: http://play.golang.org/p/BaERBUn6-N It's a bit weird since one might assume that using `:=` would set a variable in the function, but instead it's only available in the scope of condition.
To further expand, I've linked to a couple of contrived examples to show the shadow variable issue that can occur. When first starting out, its easy to get tripped up by the fact that the first way creates variables that are limited in scope to that statement only. http://play.golang.org/p/acdju9byC0 Another example: http://play.golang.org/p/XnXcOuPlls Of course reusing variable names like that should not be done, but it does illustrate the scoping issue that can occur using the first method. If you need the variable to be used beyond the local statement, then the second way is most appropriate.
one big diff off the top of my head (assuming I'm up to date).... BoltDB (and lmbd which it was inspired by) support transactions; LevelDB does not. This might be interesting to you: https://github.com/boltdb/bolt#comparing-bolt-vs-lmdb. It doesn't talk about LevelDB so much as LMDB but you could go find a LevelDB vs. LMDB comparison and connect the dots.
Yep. More people need to know about this shit. Especially for building on separate OSs and architectures.
Honest question. If you have a function in your application that allows you to redirect to another route would you want to panic if you call a redirect to the current route? I am thinking about this right now in a program i am writing. edit: or maybe just the case if you redirect to a route that does not exist.
I don't really agree with your issue of a framework being an island. They are a framework because they each choose to handle the web development process in a specific way. How do you expect them to get together and all say THIS is the way we should do it. revel works great for some things, martini for others, and just the built in http router for other. It depends what you want and what your preference is. edit: not saying golang web frameworks don't have room for improvement but at the same time I don't think your issues are something that is go specific.
We make heavy use of Lua embedded in Go in the [Heka](https://github.com/mozilla-services/heka) project. Go can't talk directly to Lua b/c Go and C are not ABI compatible, so we have a standalone [Lua sandbox](https://github.com/mozilla-services/lua_sandbox) written in C and we use cgo to talk to it. This means mem copies are required whenever data is passed from Go to Lua or vice-versa. Even so, it's pretty fast, and works quite well. If you really want to deep dive, you can learn more why we did this and how it works by watching my talk at [GopherCon](http://www.youtube.com/watch?v=wljEXLJrIyo) and/or my (more recent, shorter, with demos) talk at an [SF Metrics meetup](http://vimeo.com/98689689).
Ah, transactions, I see. Thanks!
I see what you did there...I hope.
Bolt author here. Bolt started out as a direct port of LMDB to pure Go. It uses a very similar file format. I diverged from LMDB because I thought the API could be significantly improved for usability and I didn't want to include dangerous features (e.g. direct write access to the underlying DB file which can corrupt). LevelDB and LMDB/Bolt have completely different underlying architectures. LevelDB uses a log structured merge tree (LSM tree) which uses a bunch of small sorted files to represent the key/value pairs. These small files periodically get merged into larger sorted files -- this is called a compaction. Each time they get compacted they move up to a new "level". It's kind of complicated actually. You can find a [better, longer explanation on LevelDB's site](http://leveldb.googlecode.com/svn/trunk/doc/impl.html). LMDB/Bolt essentially use a b-tree of pages to store data on a memory-mapped file. There's no write-ahead log and all changes are copy-on-write (COW). That means random inserts can be slower than LevelDB, especially on spinning disks. LMDB/Bolt just use a single file as opposed to LevelDB which can grow to hundreds of files for a single DB. Since everything is COW and it's an mmap you can do zero-copy reads which makes reading data (especially sequential data) screamin' fast. Hopefully that gives a decent overview. Let me know if you have any questions.
Cool, the scoping issue seems to be the answer to my question. Thanks so much!
You're right that Bolt will flush the transaction to disk at the end of the DB.Update(). Bolt uses copy-on-write and it updates a checksummed meta page last so you can't get a Bolt database in a corrupt state (unless your disk is corrupt). There's actually a tool in the bolt command line tool called "bolt check" that was added early on that will traverse the whole database and make sure that every page is accounted for and to verify that the DB is in a valid state.
If I read the first one aloud, it goes something like, "If err is -- oh, wait -- If when run() is assigned to err, err is not nil..." It seems a bit awkward, though probably because I don't work with Go very often (yet).
&gt; why not return it as the message to the 500 status? Because the actual error is not the business of the end user and may contain security-sensitive information.
I've used https://github.com/couchbaselabs/go-slab for a similar speedup in https://github.com/dgryski/trifles/blob/master/udprelay/main.go
just wondering why not if run() != nil { is that non idiomatic or does the language not allow it
You'll get much more used to it. Just like replacing long streams of elseif with switch or individual if statements. The more you do it, the more you recognize the streamlined and thought-out design.
Looks like a relatively good candidate for using a [sync.Pool](http://golang.org/pkg/sync/#Pool).
This blog post should include the full modified code. There is at least one code modification not listed which is required to make this work. **Edit:** I tried to get it working, but I wasn't able. This blog post doesn't mention how the arena access is synchronized -- if we take the blog post verbatim, it's racy.
I like this format, if not for any reason than that it matches the "for" syntax
Using sync.Pool makes it much slower.
Use a separate NodeArena for each goroutine.
Again, please share code.
Ah yeah, sure enough. Synchronization overhead seems like it's killer here.
Handy for folks who aren't interested in the other features of GVM, or don't want to spend the time letting things compile.
I think a lot of people need to take a closer read on the sync.Pool documentation. It's a great tool when it's exactly what you need, but it's "exactly what you need" much less often than people seem to think, and when it's not "exactly what you need" it goes to not-very-useful very quickly. It's not a "pool" in the generic sense of the term, it's a very specific "pool".
Using a goroutine to set just one pixel is a helluvalot of goroutines. Have you tried at least doing one goroutine per line?
If you don't set GOMAXPROCS, you're still only using a single core. &lt;dgryski@kaepora[gomandelbrot]&gt; time go run mandelbrot.go real 0m2.389s user 0m2.230s sys 0m0.119s &lt;dgryski@kaepora[gomandelbrot]&gt; time GOMAXPROCS=4 go run mandelbrot.go real 0m1.026s user 0m3.164s sys 0m0.125s 
Thanks for the info - I'm using the go crypto ssh libs - where does one file bugs for that?
Thanks very much, I didn't know this, now it is quicker with goroutines
Just tried this, yeah one go routine per line is quicker than per pixel
[Here](https://code.google.com/p/go/issues/list), I think. Don't forget to search for your issue first. :)
Filed :) https://code.google.com/p/go/issues/detail?id=8341&amp;thanks=8341&amp;ts=1404830946
Thanks, that looks like a really nice way of doing it, I'll try and implement it.
To be fair, this benchmark matches this description from the documentation relatively well: &gt; An appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. (There are multiple independent goroutines that need to allocate `Node`s, although they're not different clients of a package.) In my test, it reduced the number of `*Node` allocations by about 100x. The runtime did increase by about 20%, though -- I guessed this was because of synchronization overhead and because `Node`s are so small (3 words). I think sync.Pool was a reasonable thing to try, though.
Hi everyone and thanks for the replies. What I'm looking to do (should have mentioned in the OP) is script NPC behaviours in a game without having to write my own DSL. While I could write this behavioural logic straight in Go, I'm working with a game designer who has a bit of scripting experience in Python and Lua and with one of those he'd be in a much better place to make his own changes to try things out. Additionally, it'd make the game much easier to mod if there's a scripting language API available. I've looked at go-python, the Heka project and a few of the JS engine that were linked here and I really like the Lua sandbox from Heka (as well as the codebase which uses it so I can see how the two interact).
More to the point: isn't the whole thrust behind concurrency like this to elide the penalty for waiting on I/O? Like you suggest, the context switching cost is nonzero - it only makes sense to go concurrent if the time spent waiting is longer than all the context switches that need to happen on non-waiting threads. Edit: Of course if you have processor locked threads supporting as many goroutines, you can start to reach into a truly parallel state - that may work out fine, until you start thrashing the cache. So in your example, you'd have to spread out *where* those workers are working in memory (all on distinct pages) in order for it to go as fast as possible.
Nevermind; i've decided that i will be better with a merkle tree design, and storing pieces in a key-value.. instead of storying the full blob anyway.. Maybe not as optimal as reading a blob from the filesystem, but this has inherent distributed storage capabilities i think will be useful.. So i think i can use Bolt anyway :)
I created some on https://gophercasts.io I'm also working on some more long form training videos in Go. Stay tuned for release in the next couple weeks 
I wrote an article some time ago about this exactly: http://blog.campoy.cat/2014/02/parallel-computation-of-mandelbrot-set.html
Do you have a link for the Gophercon videos?
http://confreaks.com/events/gophercon2014
You can store blobs in Bolt. It's certainly not going to be great performance. I believe Pressly is storing blobs in Bolt in their [chainstore project](https://github.com/pressly/chainstore). Personally, I'd probably store the blobs as files on disk and just store Bolt for the meta data.
I think there is a middleware standard. It is to simply build an object that implements the http.Handler interface...pretty clever if you ask me. So then it's just a question of how you want to make your middleware object, and how you want to initialize it. Personally, I like the idea of using a middlewareName.New(args...) for customizing the specific middleware instance. Personally, I really like go-tigertonic.
Sorry for not having any code comments, but I really like the name grout in this context :-)
Then again, Java 8 is also listed as "adopt"...
What negatives exactly? I understand Java remains a solid choice, I just don't think anyone should be advised to "adopt" or try it out specifically for what Java 8 brings to the table. Java 8 is an attempt to tack on a "functional" label.
Can you elaborate?
While some people may believe Java 8 is trying to tack on FP into Java, most of these patterns already existed in the Java ecosystem. For example, higher order functions in Java were done by passing anonymous objects that met specific interfaces (i.e. Runnable). Also, these additions aren't being half-assed, [the lambda implementation in Java 8 is arguably better than Scala](http://www.takipiblog.com/2014/01/16/compiling-lambda-expressions-scala-vs-java-8/). The JVM itself has grown features for the other languages it now hosts and Java 8 starts taking advantage of some of these features. No one is porting their Haskell to Java 8, but even languages as conservative as Go have features like high order functions and closures.
I should have foreseen this becoming a string of replies like this. I feel we are both entitled to our own opinions. However, to justify mine I must respond to your evidence. First I will state my original point in yet more detail. Java has always been in the public eye, this post is about Go ending up on a list with other things that are marked "adopt", I find the presence of Java on such a list odd and Java 8 in particular being listed as adopt over other versions of Java extremely odd to the point that the list itself no longer seems credible. Now to address your points, runnable was a fine pattern and arguably meshed more cleanly with the Java ecosystem. Now we have lambdas. To me having lambdas does not a functional language make. Java has deep problems with its type system that must be remedied if we can ever hope to write enforced state-free code in it with the benefits that functional languages get from this paradigm. Scala would not be the choice I would argue for a functional language on the JVM, but that is personal I guess and I am most likely wrong if judged by traction. I disagree with the idea that the JVM grows for other languages. The Indy feature to which I assume you are referring was added with Java 7. tl;dr FP is not just a collection of design patterns as it is being treated in imperative-land. Java 8 treats it as design patterns. I'm tired, bedtime.
This is a great intro to Go - especially for someone coming from typical OO languages. I wish I had read this a few weeks ago. Would have saved me some trial and error.
My power was out for a while. Sorry, I wasn't clear... you should still be pushing lines or something larger (some fractal programs use tiles) down to the worker tasks. Channels are _also_ cheap-but-not-free. The purpose of using the channels is to avoid contention, keep the system loaded, and be easy to program, not make paying expensive costs per pixel work.
&gt;More to the point: isn't the whole thrust behind concurrency like this to elide the penalty for waiting on I/O? I'd go with "yes", that is Go's primary reason for concurrency, _but_ it so happens in this case that you can get a "true" parallel speedup here very easily. This happens to be an embarrassingly parallel problem, which means there's a lot of easy ways to improve them. While concurrency and parallelism are indeed different and I think it's helpful to remember the differences, and while Go is indeed more about concurrency than parallelism, it's also worth pointing out that very few technologies are really _only_ about one or the other. There's a lot of stuff in the middle, despite occasionally vigorous complaints from the more theoretically minded among us, and Go technically sits there, though I'd agree it's more on the concurrency side. (In fact, Go is theoretically not that great a choice for this task, since it'll make it very difficult to use SIMD or anything else like that, but for a learning task, go nuts. If you want a "real" optimized fractal generator the internet's full of 'em.)
&gt; Had they been x and y, they would be unexported, and therefore only visible within the struct. There's one nitpick I want to clarify- unexported struct fields aren't private to the struct. There's only two sets of visibility: package-private (unexported) and public (exported), meaning everything in the same package as the struct [can always see the unexported components of a struct](http://play.golang.org/p/ySlG9K5yfN).
Sure there is. You just need to write a compiler that generates OpenGL ARB assembly, or even GLSL itself.
Hmmm, I just started a project using goandroid, should i wait a few days and try with this?
Sure, What would you like to know ? At the moment the state is if you use Go 1.2, you will want to use the [GoAndroid toolchain](https://github.com/eliasnaur/goandroid) which is a bunch of patches to go, and if you want a framework you can try [Mandala](https://github.com/remogatto/mandala). Read goandroid README to get it going, it's pretty straight forward. Go 1.3 added architecture support but no android (afaik) and Go 1.4 will be getting official Android support. You can use NativeActivity to make your app entirely in Go, but afaik Goandroid &amp; Mandala focus on opengl. For me I require a service so I need to go the Java Native Interface route, which is essentially writing your app in java and the communicating with your go generated binary. I certainly don't use only goandroid, in the past I've used Go predominantly on desktop and Java for Android dev work, but at the moment it looks like it's the only option 
That's very interesting. I also wrote some tiny games with go, but with minimum knowledge on game dev patterns. So far I used a simple state machine to implement some behavior on the game components. Can you explain a little what is a task-based engine ? I tried to google it but found nothing really concluding. Also what do you mean by "more golang-y" ?
Is there anything wrong with, say, https://github.com/frustra/bbcode? I'm not sure what you're looking for beyond something that works.
Here is another one https://github.com/jadekler/git-go-websiteskeleton
Rob Pike has a talk called [Public Static Void](https://www.youtube.com/watch?v=5kj5ApnhPAE) that talks about the origins of Go in the context of boilerplate code. Go has more boilerplate compared to languages like Python and Ruby, but there is thought behind it. If you feel like you need tons of boilerplate in Go, you may be doing it wrong.
Ahh...thanks for clarifying that point. I had run into accessibility issues when working with unexported fields of a struct from other packages and wrongly assumed that applied within a package as well. I'll mark up the article accordingly.
And fixed.
&gt; Java has always been in the public eye, this post is about Go ending up on a list with other things that are marked "adopt", I find the presence of Java on such a list odd and Java 8 in particular being listed as adopt over other versions of Java extremely odd to the point that the list itself no longer seems credible. Are you familiar with the ThoughtWorks radar? They typically only report on new(ish) technologies that are under consideration at the time the radar is produced. They don't need to mention Java 7 or Java 6 anymore. Otherwise, it would make a pretty cluttered visual. &gt; To me having lambdas does not a functional language make. I don't think anyone is claiming that Java is now a functional language. The addition of lambdas is useful in a language that employed verbose design patterns to work around this limitation. 
is it for html2story conversion. The original project i am refering to is in this [link](https://code.google.com/p/boilerpipe/)
I don't think this question was about boilerplate. It's more about boilerpipe, a framework to extract text from HTML documents.
is it for html2story conversion. The original project i am refering to is in this [link](https://code.google.com/p/boilerpipe/)
Good one
Nice. btw just found out about goji - it looks interesting.
Oh, so like BeautifulSoup then? So a quick search for 'html scraping in golang' gave me this: https://code.google.com/p/go-html-transform/ There's probably more out there.
Probably.
I apologize. Had to read few times to have my brain register it is boiler_pipe_ :)
sorry my bad.
The reference compiler for SASS was written in Ruby, which has a bit of a portability problem. And by that I mean it doesn't work well on Windows. A secondary concern was that it was quite slow. [libsass](https://github.com/sass/libsass) was an alternative compiler written in C/C++ to rectify these issues. The repo you linked is merely Go bindings for libsass, not an actual compiler. The LESS compiler was written in JavaScript so NodeJS solves the portability issue. Performance is still crap, but there was never really a huge need for an alternative compiler and none ever appeared (to my knowledge). No C/C++ compiler means no bindings to hook in to. There is no need for a new LESS compiler written in Go so I doubt one will ever surface. 
yes, so ?
I'm just surprised Python 3 and Rust are on the same level. Rust still changes its pointer syntax!
You can create your own `http.Request` [like `Get()`](http://golang.org/src/pkg/net/http/client.go?s=8811:8871#L260) and use [`transport.CancelRequest()`](http://golang.org/pkg/net/http/#Transport.CancelRequest) to kill it yourself based on whatever criteria you want. This lets you terminate requests at any point of their life cycle. If all you want is a basic timeout, [`transport.ResponseHeaderTimeout`](http://golang.org/pkg/net/http/#Transport) should meet your needs.
This is not my project, but it looked pretty interesting. I have found it difficult to do master/template/content layered templates with html/template, but this looks to make such things pretty easy. What do you use for html templates?
Bolt databases are memory mapped, so there littles value in deferring writes to a writer goroutine. You could do all your writes in sync without problem. If you hit performance problems, *then* try out the coalescer https://github.com/boltdb/coalescer
I use a package I wrote myself: code.google.com/p/waskung The html/template package is designed for (mostly) logic-less templates. But I kept importing more and more functions into my templates till I felt like I was Greenspunning PHP. I finally decided, "If I'm going to be writing all this logic, I'd rather be writing it in Go." So I made a package that lets me generate HTML with pure Go that is fairly concise and matches the structure of the HTML: h := new(waskung.HTMLWriter) h.Div().Class("my-div").With(func() { h.H(1).Text("Some HTML") h.P().Text("This is some HTML.") }) Which generates: &lt;div class="my-div"&gt; &lt;h1&gt;Some HTML&lt;/h1&gt; &lt;p&gt;This is some HTML.&lt;/p&gt; &lt;/div&gt;
I'd use a dedicated go-routine for reading in the []byte data, which emits typed items over a channel, so that you can handle partial reads easily, etc. This go-routine does all the deserialisation. For structuring the code and API, I'd take a close look at `net/textproto` in the standard library which is more geared to request/response than to IRC, where you can receive messages asynchronously; I suspect that starting with figuring out _why_ you'd do things differently to `net/textproto` will get you most of the way towards the API which you do want.
You can "trick" html/template into letting you create "optional" content blocks: http://elithrar.github.io/article/approximating-html-template-inheritance/ {{ define "base" }} &lt;html&gt; &lt;head&gt; {{ template "title" . }} &lt;/head&gt; &lt;body&gt; {{ template "scripts" . }} {{ template "sidebar" . }} {{ template "content" . }} &lt;footer&gt; ... &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; {{ end }} // We define empty blocks for optional content so we don't have to define a block in child templates that don't need them {{ define "scripts" }}{{ end }} {{ define "sidebar" }}{{ end }} I'm a fan of html/template because I trust it's security model—when you're dealing with user-data in your templates it pays to be explicit about potentially including "unsafe" content. There's obviously a few quirks though, but I believe some things are being worked on for Go 1.4.
There is an alternative less compiler written in python, lesscpy.
I've always used the standard html/template, but I actually came from .NET MVC so I've longed for something a bit easier. I REALLY love that you can define some mini helpers in code blocks, I also prefer the @if codeblock syntax. I'm definitely going to check this out for my next project!!
That sounds like a nice idea until you have to stub out require() to handle the dependencies that node packages need.. but for simple js code it might work with little modifications.
note: im a go-noob but i would write it like that (?): func logError(e error) { log.Println(e) } func foo() { var err error if err = errorReturingFunc1(); err != nil { return logError(err) } if err = errorReturingFunc2(); err != nil { return logError(err) } if err = errorReturingFunc3(); err != nil { return logError(err) } // do things on success return }
I hate html templating languages. I've now built for of them. 3 of those were in a professional capacity and they all sucked in various ways. When I need to to html templating I take plain ordinary html and transform it. In go I use https://code.google.com/p/go-html-transform/ for that purpose. It lets me write all my logic in a go package with all the power and type safety that gives me and my html is just that. html.
Yes, the linux kernel, the Go standard library and Go itself are full of such cases: https://github.com/jnwhiteh/golang/search?l=go&amp;p=3&amp;q=goto&amp;ref=cmdform - haters gonna hate, I guess.
 func foo() { var err error if err = errorReturingFunc1(); err != nil { goto MyError } if err = errorReturingFunc2(); err != nil { goto MyError } if err = errorReturingFunc3(); err != nil { goto MyError } return MyError: log.Println(err) }
For those using Sass, I would use libsass over go_sass. It is extremely actively maintained 
In case I want to handle all errors the same way (log and exit, or similar) I usually prefer checking the for error after every call and returning the error to the caller. func doSomething() error { if err := errorReturingFunc1(); err != nil { return err } if err := errorReturningFunc2(); err != nil { return err } if err := errorReturningFunc3(); err != nil { return err } // do things on success return nil } func main() { if err := doSomething(); if err != nil { // generic error state for all 3 functions log.Println(err) } }
Once you add proper error message to each failure case, the answer will be obvious. func X() (int, error) { result := 0 if err := fn1(&amp;result); err != nil { return 0, fmt.Errorf("computing X failed at fn1: %v", err) } v1, err := fn2() if err!= nil { return 0, fmt.Errorf("computing X failed at fn2: %v", err) } if err := fn3(&amp;v1); err!= nil { return 0, fmt.Errorf("computing X failed at fn3: %v", err) } result += v1 return result, nil } func WhereCallingX() { v, err := X() if err != nil { log.Fatal(err) } } Also, either log the error, or return the error... don't do both at the same time. Otherwise it'll get confusing where you did log the error already and where you didn't and you'll get duplicate log messages. Or at least only log at higer verbosity level in the function returing the error. Also depending what the functions actually do there can be nicer ways to do it. func X() error { fns := []func()error{fn1, fn2, fn3, fn4, fn5} for i, fn := range fns { if err := fn(); err != nil { return 0, fmt.Errorf("problem at %v: %v", i, err) } } return nil } Or: func failcase(result *error) (failed func(error) bool) { return func(err error) { *result = err return err != nil } } func X() error { var err error failed := failcase(&amp;err) switch { case failed(fn1()): return fmt.Errorf("f1 failed: %v", err) case failed(fn2(1, 2, 4)): return fmt.Errorf("f2 failed: %v", err) case failed(fn3(1, 5, 2)): return fmt.Errorf("f3 failed: %v", err) } return nil }
Wow, definitely not.
Transformations seam as a more natural way of dealing with html. Is there a specific reason why you have chosen go-html-transform instead of something like https://github.com/PuerkitoBio/goquery ? I also wonder what are the performance implications of using transformations. Do you know what aproach go-html-transform uses for parsing html? Is it parsing entire html document into memory as DOM or is it using some other algorithm?
Why would you want to do that?
This looks interesting, I'll play around with it today. Thanks. 
tried it . It works perfect for me
Finally!
The built in template doesn't use simple Go. I would have expected something like ERB, EJS, ie embedded Go. Gorazor transpiles to a simple function pre compile so it's just Go and more importantly partials, layouts, widgets, etc are just normal Go functions. I had the same concerns about gorazor. Sometimes gorazor escapes, other times it doesn't leaving you to use `Raw`. I created a fork "github.com/mgutz/razor" which 1. Escapes by default. Any type other than SafeBuffer is escaped. 2. Templates return SafeBuffer instead of string. Gorazor uses an internal buffer, converts its to a string, then to write to ResponseWriter requires conversion to []byte. Inefficient. 3. Explicit control of the function and return value of a template. My fork foregos the sugary vars at the top of the template and forces you to explicitly define the func signature and optionally the return value. Gorazor forces template and sections to always return string which is a security concern. My fork // view - VIEW is the SafeBuffer result of the current template +func (user *model.User) +return Layout("my title", VIEW, user) // layout +func (title string, body SafeBuffer, user *model.User) 
Whyrusleeping, please fix this, it is important.
Just woke up, On it now!
Haha, thanks! :)
Sorry about that, How does this look? https://github.com/whyrusleeping/hellabot/commit/23ce1b96d5288a64ea7b2141390cfd0e55db46f8
Thank you for the code! And again, sorry for not having that in the first place
 I use go-html-transform because I wrote it before goquery came along. It uses the go's html parser to parse the dom into memory and has a bunch of helpers for transformations. I usually parse the dom once when the server starts up and hold the templates in memory for the life of the service. This has the benefit of only taking the parsing hit once at the cost of using more memory. But you could just as easily to the opposite tradeoff and parse each file every time. Unfortunately html doesn't really lend itself to a streamy parse -&gt; evaluate -&gt; output pipeline since you pretty much have to slurp in the whole document to properly parse it. Mostly due to the fact that there are a lot of arcane rules around adoption of orphan tags and such.
Thanks for the heads up. Never seen that before.
Docker
Been meaning to give Docker a go. Probably now's a better time than ever with learning a new language aswell!
Virtually how I work currently but with Vim instead of Sublime Text 2. It can work, but our environments we use in work can be radically different at times. Slightly hard to maintain multiple versions of nginx, psql, etc on the same machine!
It's pretty powerful. In your controller you can render a single template, and the template itself decides what it's a child of. [Twig](http://twig.sensiolabs.org/doc/templates.html#template-inheritance) is a good example of a very powerful template engine which supports this.
I just noticed that there are some Go implementations that wrap libsass here: https://github.com/sass/libsass/wiki/Implementations
My dev environment is a combination of a ubuntu 14.04 VM and a raspberry pi with raspbian. Both are using gvm to manage Go installs.
I use Vim with more useful plugin just like vim-go.
go/types and related libs in the go.tools subrepo
- $GOPATH to $HOME - Go installed from source, in $GOPATH/src/code.google.com/p/go - Sublime Text 2 + GoSublime - goimports on save - Custom build system, runs go vet + golint + go build + go test with every Cmd+B
Probably the best introduction for web is [Build Web Application with Golang](https://github.com/Unknwon/build-web-application-with-golang_EN). Any time constraints on how fast you need to get things running? Also, what is the complexity of the UI/UX/interactivity/i18n/L10n/amount of existing code? Which browsers do you need to support? I would probably go with React/Go for web interface (if you can force users to use newer browsers). If it's mostly static pages then a HTML/Go could work as well. Angular/Node isn't a bad option either. You could also take a look at Revel &amp; BeeGo. Also GAE has a lot of good infrastructure for making scalable sites. Essentially decouple your data processing from your front-end that way you can vary them and can probably gradually start using Go rather than a full on rewrite.
Just use Angular with a Go backend directly. No need to use NodeJS. For your POC, start with this. It shows how to build a web server with Go. http://golang.org/doc/articles/wiki/ Then add JSON: http://blog.golang.org/json-and-go From those two articles, you should be a good way towards building your proof of concept. Then have a look at the Revel web framework for Go: http://revel.github.io/ Use this instead of the custom server that you wrote above. The custom server is a good teaching tool, but the Revel framework will have all the routing/authentication that you need. For your angular front end, have a look at: http://fdietz.github.io/recipes-with-angular-js/consuming-external-services/requesting-json-data-with-ajax.html 
I find it a bit odd that you are mentioning Angularjs when your task is to fix bottlenecks. Lets try to separate your concerns here. You may want some kind of load balancing. You may want to write more efficient code. Maybe you need a combination of both. I have asked the same questions about how people using Go in production run their systems. The answer I get mostly is just to run it bare metal. This means no Nginx reverse proxy. I personally prefer to use Nginx even if it means slowing down my app. This is due to the separation of responsibilities. I like to write the app and hand it off to someone else to deploy. There is a reverse proxy in Go. [http://golang.org/src/pkg/net/http/httputil/reverseproxy.go](http://golang.org/src/pkg/net/http/httputil/reverseproxy.go) It is very suitable to run in production. I have a setup using one of each, though they are smaller deployments than 10,000+ concurrent users. To make sure your Go app restarts when it dies, I use upstart. I'll let you figure out how to set that up. To make sure your Go app doesn't die, you need to check your errors. If you are using AngularJS, your Go can serve a static html file containing the Angular app. Then, you can feed json data from your Go service. No need for Node.js. If you like Node.js or are more comfortable, by all means go ahead. 
/u/sergixio: I'm the author of the go-plus package for Atom (https://github.com/joefitzgerald/go-plus / https://atom.io/packages/go-plus) . I've been working on a major refactor of the package (https://github.com/joefitzgerald/go-plus/pull/37) for the past 2 months, and it will be released when Atom changes the default editor to React. You should give that branch (https://github.com/joefitzgerald/go-plus/tree/first-use-experience-enhancement-32) a try (make sure to opt-in to using the React editor in Atom &gt; Preferences &gt; Use React Editor) and let me know your thoughts in the pull request.
&gt; Essentially decouple your data processing from your front-end that way you can vary them and can probably gradually start using Go rather than a full on rewrite. This. That has been my argument/opinion all along. Hence the proposed angularjs&amp;node front end and just using go for the data processing/serving. This would seemingly be easier to scale and load balance between servers. The counter argument is we have always been a PHP shop, so we're no longer learning just Go (and more deep understanding of HTTP/TCP architecture) but now adding node, angular, and more advanced JS. Other team members want to focus on one language (go) and either do everything in that, or use PHP for the front end/routing and Go for the data serving. The book/pdf you linked to has been my main source of learning (and sample apps) along with the [gophercasts](https://gophercasts.io). App complexity - right now we rely heavily on jQuery for ajax requests (it's turned into a huge headache trying to re-invent the wheel that backbone/angular/ember etc. handle.) No i18n/l10n yet (or planned in the near future). User base is pretty mixed but supporting back to ie8 based on usage is important. Unfortunately a fairly un-tech savvy audience - mostly ie and firefox users. But, mobile usage has increased significantly so we're looking into separating out the views for mobile and using ionic for that. Appreciate the response and framework/stack suggestions. Thank you!
Thanks for the reply and links. I've followed the Go tutorial and will look into incorporating JSON. One of the downsides I've found when searching for Go info is the lack of "real world" setups/code practices. For instance, so many web app tutorials include everything (all routes and handlefunc) in one main.go file. In a real world app that would be a nightmare for maintainability. Have you run across and tutorials/OSS code that demonstrates a good boilerplate setup to follow?
Appreciate the comments so far guys, thank you! One additional elaboration - if performance was compared between * Go doing backend as well as serving the front end view files * Front end views being completely decoupled from the backend and all datacalls are made as a RESTful API call would the former be several magnitudes more performant? [example benchmark](http://matt.aimonetti.net/posts/2013/06/23/using-go-vs-ruby-for-web-apis/) benchmark's obviously are not end-all-be-all but, this is interesting.
Taking into account IE8/mobile I wouldn't recommend Angular and would recommend plain old HTML. It's a sure bet for a working application, although it's harder to make highly interactive. And, if you design with multiple frontend servers in mind, you will be scalable. Basically, try to keep the frontend server as stateless as possible.
I use archlinux and gvim. If that wasn't good enough, I would definitely use [docker](http://www.docker.com/).
I'm interested in getting feedback from redditors on what kind of content you would like to see in these screencasts. Suggestions welcome!
why not? One less directory to cd into.
&gt; We list the messages returned by golint as information only, because it can have plenty of false positives. Hmm. While there are _some_ corner cases that `golint` might be too aggressive on, in general, I don't think it has many false positives... &gt; go vet can have false positives too, I don't think that's true. Everything `go vet` flags is a bug and should be fixed. Whenever I join a new codebase, my first action is always to make it `golint` and `go vet` clean.
cmd.Process.Kill() is an easier way to do the same. Having a goroutine (or a thousand) sit around waiting is perfectly fine, it's what they are for!
If you're going to cover more web stuff, I'd love it if you could cover how to use APIs with martini. (using paypal/stripe, logging in with OAuth2 using goauth2.) Some best practices would be nice as well, like preventing csrf and others. 
Fantastic post.
Looks like this is more-or-less traditional web app with fancy UI, is that right? Serving static files is fast enough in Go, Nginx is not needed. That said, Nginx/HAProxy is still needed for failover/high availability purpose. Spend some time thinking about deployment. Deployment story is a bit different than dynamic language apps. My solution is to write a simple makefile that: * Builds the go binary. * Builds the SASS files and tar.gz everything including HTML/JS/CSS assets. * Rsync that one .tar.gz to remote servers. As what others said, Node.js is redundant. I built a websocket app previously with Node.js. But we later switched to Go because the memory consumption is ridiculously lower in Go. And more stable too. If you are not worried about OAuth, regular encrypted cookie is good enough, right? Various Go frameworks support that out of the box. Out of bound processes are easy to do with goroutines, unlike various dynamic languages, there's no need to have dedicated queues. 
I've tried it but thing is that because app I am launching spawns its child processes, so if I kill it with cmd.Process.Kill() it does not kill child processes :/
* Boot2docker on OS X * Sublime Text That's it, really.
I just started with Go recently. Based on the recommendations from some of the Google Go engineers at I/O a couple weeks ago, I'm using SublimeText with GoSublime. The two big features that I'm missing are: - ability to command-click to go to definition for methods on objects - ability to see what type a variable is by hovering I believe the latter isn't possible because of limitations in SublimeText's plugin API Are there any editors out there that have these features? I don't need it to be free. 
/u/blakecaldwell Oracle support is waiting to be merged for go-plus (https://atom.io/packages/go-plus) which will provide go to definition support. Please add an issue to the go-plus repo (https://github.com/joefitzgerald/go-plus/issues) for the hover feature - that sounds quite useful and I think it could be feasible once the Oracle feature is merged.
I run both `go vet` and `go lint` on every save. Sublime lets me then `shift+command+click` the `file.go:line` output to jump right to it and fix it. It's far nicer to keep those two happy as you code rather than doing a big sweep later.
templating stuff would be interesting to see in practice 
As someone just getting started with Go, I would be interested in seeing more general language/design topics. The Gophercast videos seem well produced, and Martini seems like a great library... but not something that I would want to use - and the Gophercast videos seemed to breeze over some basics, and get right into some very specific topics, and make heavy use of Martini.
When I have a series of `var` declarations in a row: ` var something int var somethingElse string var thirdThing int64 ` I tend to wrap var() around them: ` var ( something int somethingElse string thirdThing int64 ) ` Any reason not to do so?
I think it's just a style preference. Writing it like that _does_ add 2 lines of code, but whatever looks good to you.
&gt; logging in with OAuth2 using goauth2. *cries*
My company is using Go for a few small app servers for demo apps we are building.
I second this, especially for web application needs.
I'm a fan of a relatively clean home directory.
I am looking forward to what is to come. My only request would be not to focus on topics that can be easily found in the docs. 
As the author of the [Zeus IDE](http://www.zeusedit.com/go.html), I can confirm it has a *go to definition* feature that uses *ctags* as it's source of data. But it does not have the hover feature. Also Zeus is native to Windows but does run on Linux using Wine. 
I'd love to learn more about testing. Especially tests around RPC and channels.
Does it have gocode integration? I think that's the most important feature.
Getting close: github.com/mgutz/gosu + github.com/mgutz/goa
They both have enough false positives that it should not impede a regular workflow. For instance, golint isn't integrated yet with the SSA-based type checker, so it doesn't understand situations where `var x T = expr` is legimate. Govet has similar classes of errors where it fails to typecheck things, and can flag everything from printf-formatting bugs to range loop closure bugs that aren't actually bugs.
&gt; I doubt this is a good practice What's your argument for that?
distributed applications, communicating with other processes using RPC or something better, creating pdf's on the fly, etc.
So passing a channel doesn't make a copy of the channel? I've been passing pointers to channels because I wasn't sure if it would pass by copy, which doesn't really make sense anyway I guess. Need to do some code cleanup :) Great post!
Kill works by sending a signal to the app. Handle the SIGKILL in the app to terminate the child processes on shutdown, or alternately exploit the fact that init inherits orphaned processes, so when the parent PID is 1, a child process would know to terminate. I don't think that any outside process should have to be aware of another process' children.
Principle number 1: channel-based APIs should be used very sparingly. Most public APIs should not expose channels. I think the ones this post mentions are almost all of them in the standard library.
Awesome idea. Could you do a favor to a anonymous guy from the internet, and group your imports in your screecasts? E.g. import ( "net/http" "github.com/codegangsta/martini" _ "github.com/lib/pq" )
Yes, this is a much more important principle. New Go programmers often get excited about channels and try to use them everywhere they can, which unfortunately means they write bad APIs with channels wedged in to places where they don't belong. Don't use a channel in an API just because you want a channel. It might make more sense to write a simpler API, and wrap that as needed in a goroutine.
A channel is a reference type, like maps, funcs and slices. There's almost no need to ever pass a pointer-to-channel.
That great,thanks for your share.
Thank you!
Forgot to add other similar efforts for reference: CoffeeScript, TypeScript, Xtend, MoonScript, Elixir (?)
Oh great. Screen casts by the programmer who made arguably the least idiomatic Go framework out there. Count me in. /s
Generics would be the most important to have. IIRC there was already a project attempting to generate go code for generic functions but I'm too lazy to search now =)
Run "describe wp_posts" as SQL on the remote database and parse the output.
By using interfaces you can mock out database calls, when you don't actually need to test the database code itself. For example I have a UserManager interface: type UserManager interface { Insert(user *User) error Update(user *User) error IsNameAvailable(user *User) (bool, error) IsEmailAvailable(user *User) (bool, error) GetActive(userID int64) (*User, bool, error) GetByRecoveryCode(string) (*User, bool, error) GetByEmail(string) (*User, bool, error) Authenticate(identifier string, password string) (*User, bool, error) } The default implementation of course interacts with the RDMBS. In my code this is implemented as a global variable, *userMgr*. When I'm testing some routes however I don't want to go to the trouble of setting up a test connection, generating fixtures etc. so I instead have a mock implementation of UserManager: type MockUserManager struct {} func (m *MockUserManager) GetActive(userID int64) (*User, bool, error) { return SampleUser(), true, nil } Then in my test code: func TestGetUser (t *testing.T) { userMgr = &amp;mockUserManager{} ....do my test.. }. Because *userMgr* is a global variable in the same package as the implementation code, I can change it inside my test to point to the mock implementation. Of course if I need to test the actual implementation itself (ensuring the correctness of the SQL and so on) I would and should test that code directly, but that shouldn't be necessary for the entire application.
Have you seen http://tardisgo.github.io/ ?
It's called gen: http://clipperhouse.github.io/gen/
So gophercasts.io will continue or would this be another website? I know you ditched martini for negroni but it is still useful and used by people and those videos are great!
Ironically, that's not really a generic generics package. It seems to just generate a few pre-defined behaviors on top of slices which are actually quite specific. It doesn't, for example, let you write your own type and then generate implementations of methods that use different types (like write a generic tree and then generate a string tree, int tree, etc).
Well, step one would be to not do it at all. I'd look instead into [llgo](https://code.google.com/p/llgo/), compiling into LLVM, and proving some sort of integration into Go if you really wanted. Step two, if you proceed past step one, is to really ask _why_ a language that compiles to Golang is that important, and what you're going to get out of it, _that is not solved better some other way_. Do you want a language with generic containers, destructuring, macros, exception handling, and list comprehensions? The solution is not to compile something into Golang... the solution is Clojure. Do you still need some Go code? Well, open a socket and start sending messages; you probably don't need it all within one process. In fact, if that is the feature set you desire, which you may for good reasons, why are you looking at Go at all? Context: I'm a [computer language] polyglot, not a Go partisan, despite liking Go reasonably well (once I came to understand it). I speak Haskell (among many other things), so explaining the virtues of the listed features would be a waste of time; already got that, thanks. My question is, if that's what you're looking for, why would you bash it on top of a language quite hostile to most of those features rather than just using one that already has it? It seems to me the popularity of "things that compile to Javascript" has been misunderstood by a large segment of the programmer population. We do not compile things to Javascript because it's a good idea to add layer upon layer of runtime to code. We compile things to Javascript because Javascript is basically web browser assembly language (give or take asm.js), and if we want to run things that aren't Javascript in the browser, we have no choice. _In general_, trying to compile a language with one set of semantics onto a completely different set of semantics is a _bad idea_. Turing completeness guarantees it is possible, but you _will_ suffer performance problems as the code you typed works down the multitude of layers to the CPU, and in practice, you will suffer some sort of compromise with the underlying layer that makes the top layer less fun to use, and performance will always be a problem too. See Scala, which suffers for its need to integrate with Java underneath. See Javascript in the world of Node, as people put a fundamentally single-threaded runtime on top of the CPU, then try to bash in threading on top of it with promises and this and that and you end up with something slower, more complicated, and more fragile than code written on top of a framework that actually does that stuff from the beginning. So, again, the question is what will you get out of your language that compiles to Go that isn't _better obtained by another solution_? It's not enough to be "a" solution, it needs to be the _best_ solution to some problem. I'm not at all convinced there's a lot of room there. That said, tone note: I mean this as a serious and well-explained question... if you come up with an answer, more power to you! I really don't think there's a good answer here, but I'm open to being convinced otherwise.
Yikes. Sorry for that :/ you can check out my other projects if you want to see more examples of my code.
A bit off-topic from what you're asking about, but I've been thinking that graphical ETL tools like Pentaho, Informatica, and Talend very often use XML as a persistence format, which is transformed into java to implement what the user wants. Jokes aside about using java as a DSL for converting XML into stack traces, this is very painful to work with and debug. I think Go would be a nice choice as the basis for the next generation of ETL tools.
write a program that deletes the language from my disk. 
&gt; ability to command-click to go to definition for methods on objects This works, doesn't it?
Well there are already good reasons in terms of automating stuff that people are trying to do manually, such as generic-style code. (Automated code generation is a valid approach in many scenarios.) Another example is Qt's special extensions to C++. Or Objective-C's extensions to C. Each of these adds a useful layer on top of the base language. I could imagine a 'tweaked' Go which had a few more safety guarantees that I'm used to from other languages. (The same could probably be achieved with annotations and a specialised checker.) But any specialized Go would never get the same popularity as standard Go, so you'd keep on coming back to the core language.
I listed a bunch of features why you would like to remain Go compatible. Especially being able to reuse Go libraries, being part of Go community and being able to migrate to straight Go if the source language goes AWOL are some of the reasons. E.g. CoffeeScript greatly benefits from being able to use all the JS frameworks. It's not just about "being able to run on client", but about being part of the wider JS developer community.
It works for functions but not for methods. I don't think it's a limitation of sublime text, just a limitation of the code being used for go to definiton.
that would be a HUGE undertaking. A JIT is hard enough on it's own, but a JIT which compiles to another language which then compiles? That would be complicated to say the least.
I'm not sure just how viable it would be. He did say it's specific to the Go codebase. I'm sure that the community could improve the general scope of the project once it's released. Off the bat though I wouldn't expect it be fully functioning for all C code. Really cool project nonetheless, I'm really excited for the compiler translation.
Great news then! Thanks for the answer and also for martini, inject and cli!
http://blog.golang.org/profiling-go-programs I use https://collectd.org/ for monitoring
Seriously guys... Just let it go already. No-one care if you're right or wrong.
Haven't tried this yet, but it'll be the first thing I reach for when I have a real deployment I want to instrument. https://github.com/rcrowley/go-metrics
At $WORK we've written and deployed https://github.com/dgryski/carbonzipper and https://github.com/grobian/carbonserver to help scale our graphite cluster. We have some other internal services running with it or investigating using it, but all network daemons serving highly concurrent workloads with low request latency requirements.
Dammit.
We're writing the client and server for the Ubuntu Touch push messaging service in Go. The haptic (vibrations) service is also Go. We also develop Ubuntu's Juju, the next-gen service orchestration system, in Go. 
I gave a couple of examples. Here's a more concrete one: http://play.golang.org/p/iwNN_3op7z The rangeloop closure checker sees the use of "name" in the struct literal, and gets confused thinking that that symbol is referencing the range var rather than being a struct key.
I have a security camera that uploads snapshots to dropbox in quick succession. I have a Go app on a VPS that looks at these images and compares them to detect movement. I chose Go because it's the hip thing to use. Also, the concurrency lets me keep networking and image processing operations on separate threads.
Looks really promising
In CarbonServer main.go you do this: var x = struct { something here **}{** something else } What does the closing brace opening brace do? 
It's an anonymous struct. In the first {} you define the structs structure, in the second {} you define the data
I see! I'll have to look into that. Thanks!
Thanks!
My setup is largely based off of [Golang.org](http://golang.org/doc/code.html) and adapting from this [tutorial](https://www.digitalocean.com/community/tutorials/how-to-set-up-automatic-deployment-with-git-with-a-vps). Except I code in Windows. **$GOPATH** has three folders: **/src**, **/pkg**, **/bin** My code is in: $GOPATH/src/github.com/{{username}}/{{projectName}} **Dev Machine** Win 7 %GOPATH% = C:/CodeSpace %GOROOT% = C:/go Sublime Text 2 with PackageControl, GoSublime, Goimports, AdvancedNewFile, and a few non-Go plugins Custom build for go: &gt;{ &gt;"cmd": "go run $file", &gt;"selector": "source.go" &gt;} **Production** DO VPS (Ubuntu 14.04) $GOPATH = /home/{{username}}/CodeSpace $GOROOT = /usr/local/go **Live** website dir: /var/www/live **Test** website dir (serves to different port): /var/www/test **Deploying/Committing**: On my dev machine, I make system variables for each project, e.g.: %projectName% = $GOPATH/src/github.com/{{user}}/{{projectName}} **When I commit to master**: cd %alpha% git add -A git commit -m "Custom commit message" git push Often, as i push to Github.com, I will simultaneously **push to test** and/or **push to live**: git push test git push live On my dev machine, I have set up "live" and "test" as ssh's into my DO VPS: git remote add live ssh://{{user}}@{{domain}}.com/var/www/live/live.git git remote add test ssh://{{user}}@{{domain}}.com/var/www/test/test.git 
Declares an anonymous struct and then initializes the fields.
FYI, you might get good milage out of running the Python portions of your graphite setup under PyPy.
Doing it as a proxy surely has an appreciable impact on the performance and the actual server response ability that surely it's much better to pull this passively via pcap?
Comments on http://www.reddit.com/r/blender/comments/2ahldf/gopher_mascot_feedback_appreciated/
``` select * from information_schema.columns where table_schema = '&lt;database&gt;' and table_name = '&lt;table&gt;'; ``` Is that what you mean?
Love the detail with the reflection. :D
&gt;threads goroutines :)
Right now i am writing a bot that fetches all the fixed bugs from Launchpad.net and tweets about the ones fixed recently. it's for elementary OS project. i've earlier written a websocket server, a websocket client, a proxy server and a small website
Which can be in different threads
or not :D
Thank you. I will look at it soon.
Creepy as fuck -- I like it. He either wants me to use Go... or wants to murder me... or both. 
Here is more: [Imgur](http://i.imgur.com/yPZvGMd.jpg) I've made a few more gopher photos like this. Just have to think up captions for wallpapers :)
I find the reflections in the eyes to be very distracting. Otherwise, I am very impressed. I had assumed it was a photo.
I'm sure that if you are testing a manually, then yes pcap is a better option. But when you are running multiple selenium tests parallely, then using the proxy you can capture traffic for all of them separately and analyze it in your test.
High density vpn for machines (M2M). The goal is to reach more than 200k connections per server.
that's a beautiful gopher. Top marks
Looks great! Creepy and cute. Haha. Would love to see it on https://github.com/mholt/golang-graphics if you don't mind.
Do you have a go package for interfacing collectd or do you just use `collectd-unixsock`?
Right now I'm building a CLI client for a REST api. My first choice is usually clojure, but in this case the JVM startup time is un-acceptably long for a CLI app, so I started looking at golang. I've been enjoying it so far :)
Agreed.. that is something I want to fix. It was fun putting the golang website in the reflection, but it does kind of impact the image too much.
I see that you copied the [vinyl Gopher from 2011](http://blog.golang.org/gopher/vinyl.jpg), but the more recent [plush Gopher](http://blog.golang.org/gopher/plush.jpg) is much funner. Notice the much smaller pupils and that he's slightly cross-eyed, giving him lots of character.
Not on objects, but on static methods 
We are developing a high-volume payment and billing system.
I'm pretty ruthless about getting content onto /r/golang -- pretty much anything I see on twitter tagged #golang is fair game :)
You're absolutely right. I'm just being overly apprehensive, this being my first bit of CG art that I've publically shared.
I think idiomatic testing, table driven tests, and use of http/httptest/ would be beneficial for many!
Nice touch with the golang.org reflection!
Why not stream the snapshots directly to the VPS, then process it there, and only send stuff of interest to Dropbox?
Since Go is so server/network oriented, it'd be cool to have one or two on non-http type stuff as well. Those of us who constantly do web apps can kind of start thinking like in-browser http is the only kind of web there is, even if we know otherwise. I don't know what would be built, but something dealing with UDP or a certain type of server or something common but a bit left field of the typical web app would be GREATLY appreciated.
So why exactly is there functions for Printf and Println for *Player? Why not run it bare? Also this is giving me quite a bit of inspiration to try for my own game.
Why a channel of bytes? Wouldn't a io.Reader be more appropriate?
I am working on a programming contest hosting application. If you have used the tool PC^2, you know what I am talking about. Except that this one doesn't have any strict external dependencies (JVM for PC^2) and is very easy to get started with. You just download a single binary file and execute it in one computer and all other participants access the interface through their web browsers over the local area network. The html and all necessary assets for the web interface are bundled with the binary using `go-zrsc`. And database is based on SQLite3.
I did that so I could easily switch stdin/stdout to something else, like a telnet server.
The Prometheus Go client (https://github.com/prometheus/client_golang) and its series transformation server (https://github.com/prometheus/prometheus) may interest you. All of it is written in Go.
Sounds interesting, but might I suggest including a screenshot of it in action?
There's a rather similar library called ansirgb, which calculates the colors instead of hard coding them and uses color.Palette's Convert() for conversion to ANSI codes. https://github.com/Knorkebrot/ansirgb The main difference is that it returns just the escape codes and not a colored string, which makes multi colored text faster to render in most terminals. Also it supports background colors, so you don't need hacks like Unicode blocks as seen in the rgbterm_test.go
That's right. http://golang.org/ref/spec#Composite_literals It's an array of byte slices.
I was actually thinking of doing this myself. This is really cool!
That's a nice idea, I'll think about implementing it, could be great for a monochrome mode. Maybe it'll look a little odd for colored output since you still have only two colors and the additional "scan lines" when foreground and background colors differ and you have a "mini block" on top and bottom of the char. Thanks for the suggestion!
Alright, ill get that implemented sometime today probably.
Seriously? Take some karma for Strapping Young Lad on top of a very nifty utility!
Just a peek at the .go sources and pointing out sillies would be useful as a newbie..
I'm biased but I like [mine](http://play.golang.org/p/P-Dk0NH_vf) more :-)
Oh how I hate lousy img hosting
Just a few (mostly stylistic) things: https://github.com/fgx/fg-navdb/blob/master/import.go#L15 Hard-coded path. Some files look like they could use some [gofmt](http://blog.golang.org/go-fmt-your-code) After a [for rows.Next()](https://github.com/fgx/fg-navdb/blob/master/navdb/airport.go#L69), you should check for [rows.Err()](http://golang.org/pkg/database/sql/#Rows). Just to be sure. https://github.com/fgx/fg-navdb/blob/master/navdb/xplane/apt_dat.go#L36 You should maintain consistency when [naming things](https://github.com/fgx/fg-navdb/blob/master/navdb/xplane/apt_dat.go#L36).
Error establishing a database connection
Wasn't that Jan Mercl's? Or did he do the train?
http://justinas.org/alice-painless-middleware-chaining-for-go/
Don't remember who did the train, but [I wrote this one](https://codereview.appspot.com/9961043).
How to scale your martini/negroni/beego/revel/etc website onto multiple servers.
Tldr: runtime.Caller(), runtime.FuncForPC()
Did that with termbox while on a plane: https://github.com/aybabtme/gol When I feel depressed, I: $ gol And my terminal comes to life.
fun.
stealing this
Thanks, Antoine. There are definitely some lessons I've learned since I wrote the Bolt test suite. Removing testify and adding test types are two items on my todo list. :)
I agree with most of this... However, I do like really focused internal unit tests that can single out specific parts of the implementation, to ensure that I have the implementation correct when I first write them, and also to ensure that the implementation stays correct if I refactor some things. This can often be really tough if you have fairly complicated methods in your package's API. Consider a fictional ssh package that takes am authentication string in the form "user:password@domain" .... I would want to test that my code that parses that string works correctly for all permutations... but not have to run a huge setup to mock out a ton of dependencies that don't have anything to do with simply parsing the string, which is hopefully done in a single small function that is very easily tested on its own, but is probably not exported. Yes, sometimes this means the tests have to change when the implementation changes, but I actually find I have to change tests much less frequently than I would have to if I had to run a test that goes through the whole system rather than one tiny part of the functionality (mostly to change the mocking behavior of stuff I don't care about in this test). Obviously, you *also* want tests that ensure the API works as you expect... you can (and should, IMO) do both.
I can see how there are times when you want to test a specific internal piece. However, in your fictional example, separating out to a test package might help me realize that parsing an auth string is generally useful so I might export a mysshpkg.ParseAuth() function. Another benefit to a test package is that it tends to keep your types shallow. You don't end up with type "A" using type "b" which uses type "c" because it's hard to test.
"Of course, a language that no one speaks is dead, so I'm not going to say community doesn't matter." I think PHP shows that community can breathe a lot of life into a dead language :)
I recycle [4096]byte blocks which carry ip frames. They are recycled after sending to vpn connection. 
Hey, the TL;DR version would be: use sync.Pool if you frequently allocate many objects of the same type and you want to save some allocation and garbage collection overhead. However, in the current implementation, any unreferenced sync.Pool objects are removed at each garbage collection cycle, so you can't use this as a long-lived free-list of objects. If you want a free-list that maintains objects between GC runs, you'll still have to build that yourself. This is only to reuse allocated objects between garbage collection cycles. This blog post will have everything you want to know about it, and more: http://dominik.honnef.co/go-tip/2014-01-10/#syncpool
How do you test those mock-ups?
I've cross-posted this here in the hopes of getting some more input/devising a cleaner way to pass an instance of `context` to both my handlers (as a method receiver) and to `ServeHTTP` so that the latter can still make use of the context's template map, loggers, etc. * I *could* just split `templates` out as a global variable, but I'm trying to avoid that at this stage. * `appHandler` must have a function type as a member so I can call `ah.h(w,r)` (where `h` is the handler) at the top of the `ServeHTTP` method—because we'll have more than just one handler. * The biggest "irk" is that I'm passing a pointer to context twice: as the method receiver, and as a struct member for `ServeHTTP`: i.e. `r.Get("/", appHandler{context.IndexHandler, context})` Avoiding that last point (i.e. the repetition) is my main goal here.
The initial caveat is "Don't use `sync.Pool`". Profile your code. If you identify a performance need, only then use `sync.Pool`.
Long lived, concurrent safe pools can easily be made with buffered channels: // Pool holds Clients. type Pool struct { pool chan *Client } // NewPool creates a new pool of Clients. func NewPool(max int) *Pool { return &amp;Pool{ pool: make(chan *Client, max), } } // Borrow a Client from the pool. func (p *Pool) Borrow() *Client { var c *Client select { case c = &lt;-p.pool: default: c = newClient() } return c } // Return returns a Client to the pool. func (p *Pool) Return(c *Client) { select { case p.pool &lt;- c: default: // let it go, let it go... } } I'd also say it's a very beautiful demonstration of Go channels and `select`.
The problem with putting your code in `$GOPATH/src/app` is that your app is not go gettable.
Because I want them to be relative. Relative imports are good for executables because the subpackages are only needed by main.go, and then it's trivial to rename the project or refactor later, not to mention shorter import paths.
Be aware, there has been discussing on removing the (IMHO, terrible 'feature') of relative imports. https://code.google.com/p/go/issues/detail?id=6147 and I think that will be revisited once the private paths are available (possibly 1.4). "The only reason the go tool supports relative imports is to run the compiler tests, which predate the go tool and the concept of GOPATH. I would prefer to refactor the compiler tests so that relative imports are not used, and remove support for relative imports from the go tool entirely." -- Andrew Gerrand 
What a blast from the past, Allegro! So cool to see this around Go. I used Allegro with DJGPP in the late 90s -- had no idea it was still kicking around. 
That's kind of a shame, they work very well for my use case.
Well -- they are a nightmare on large projects (which Go spends a lot of time thinking about) and they are REALLY easy to screw up (copy-paste, now you are using a DIFFERENT ../xxx import). They (relative paths) make refactoring much harder (despite your argument for renaming a project) because it makes it harder to target. In a game, you might have a bunch of loaders... sprite loader, level loader, savegame loader, etc... your end up having it as just ./loader all over the place... so now if you want to change the name of your sprite loader ... it has different names, ./loader, ../../sprite/loader, etc, etc -- and you can't easily use the gofmt tool to fix it. If EVERYWHERE you use the full path, now one simple command can change the path everywhere. (gofmt is awesome for refactoring by the way: http://spf13.com/post/go-fmt) Saving some typing making it less clear and harder to refactor is a "bad idea" I think. Also, some Go tooling (IDE support, 3rd party tools) have some issues with relative includes because of the rarity in the Go community -- meaning you little example could break some IDEs (breaking autocomplete, code-walking, etc). Avoiding relative paths is like using gofmt to fmt you code -- it is the expected and "polite" thing to do in the community, and if you don't -- first posts will almost always be about it. Additionally, for "package only" files --- there will hopefully be an answer soon (https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit) the "internal" packages (but -- again -- they will use full paths, not relative paths). EDIT: Obviously, what you did it really cool stuff and this is a minor nitpick, sorry it derails the conversation a bit. 
lol, was this inspired by the question on #golang last night?
You do make some interesting points, and they'll give me some food for thought as I move forward with the project. Thanks for the tips.
I don't know the specifics of goji so I'll just use net/http, but the idea is the same: Make your own handler type and something to translate. It looks like you're kind of doing this with the (int, error) return. //could make it it an interface and have a handlerFunc if you need that type handler func(c *Context, w http.ResponseWriter, r *http.Request) (int, error) func Wrap(c *Context, h handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { //do setup st, err := h(c, w, r) //all the stuff about (int, error) could go here }) } Looking at your post, where you might apply this is: // In main() ... context := &amp;appContext{db: nil, store: nil} get := func(route string, h handler) { r.Get(route, Wrap(context, h)) } get("/", IndexHandler) (edit:formatting)
Good read, thanks.
It would be fun if the ending state was a Gopher. Not sure how to make that happen though.
it does not finished yet, just bones. 
Thanks a lot for this—this is actually fairly close to what I was considering. The `get` anonymous function is actually superfluous since you can just `r.Get("/", Wrap(context, IndexHandler))` — which is the same as `http.Handle`. Goji is all `http.Handler` interfaces like vanilla net/http. **(Barely!) simplified version of your solution:** type appContext struct { db *sqlx.DB store *sessions.CookieStore // etc. } type appHandler func(app *appContext, c web.C, w http.ResponseWriter, r *http.Request) (int, error) func wrap(ctx *appContext, h appHandler) http.Handler { return web.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { status, err := h(ctx, w, r) if err != nil { log.Printf("HTTP %d: %q", status, err) switch status { case http.StatusNotFound: // err := ah.renderTemplate(w, "http_404.tmpl", nil) http.NotFound(w, r) case http.StatusInternalServerError: // err := ah.renderTemplate(w, "http_500.tmpl", nil) http.Error(w, http.StatusText(status), status) default: // err := ah.renderTemplate(w, "http_error.tmpl", nil) http.Error(w, http.StatusText(status), status) } } }) } func main() { context := &amp;appContext{db: nil, store: nil} r := web.New() // Since wrap returns a http.Handler, we can just use it directly r.Get("/", wrap(context, IndexHandler)) graceful.ListenAndServe(":8000", r) } func IndexHandler(a *appContext, w http.ResponseWriter, r *http.Request) (int, error) { fmt.Fprintf(w, "db is %q and store is %q\n", a.db, a.store) return 200, nil } ----- **Actual implementation** I actually ended up ditching handlers-as-methods and reverted to a function signature that includes `*appContext`. This meant I could still keep ServeHTTP (thus satisfying http.Handler) and it ever-so-slightly reduces heap allocations per-request vs. using a `wrap` function. type appContext struct { db *sqlx.DB store *sessions.CookieStore // etc. } type appHandler struct { *appContext h func(a *appContext, w http.ResponseWriter, r *http.Request) (int, error) } func (ah appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { status, err := ah.h(ah.appContext, w, r) log.Printf("Hello! DB: %v", ah.db) if err != nil { log.Printf("HTTP %d: %q", status, err) switch status { case http.StatusNotFound: // err := ah.renderTemplate(w, "http_404.tmpl", nil) http.NotFound(w, r) case http.StatusInternalServerError: // err := ah.renderTemplate(w, "http_500.tmpl", nil) http.Error(w, http.StatusText(status), status) default: // err := ah.renderTemplate(w, "http_error.tmpl", nil) http.Error(w, http.StatusText(status), status) } } } func main() { context := &amp;appContext{ db: nil, store: nil, } r := web.New() // And just as clean as the wrap() method - no need to pass two references as before r.Get("/", appHandler{context, IndexHandler}) graceful.ListenAndServe(":8000", r) } func IndexHandler(a *appContext, w http.ResponseWriter, r *http.Request) (int, error) { fmt.Fprintf(w, "db is %q and store is %q\n", a.db, a.store) return 200, nil } I appreciate the advice/example though—helped me to think it through. Was stuck with methods on my mind and it was causing tunnel vision.
Thanks for the gold. Been there with the tunnel vision. I included the get helper because I figured if you have a dozen or so handlers it would get tiresome to type all that and even if you copy and paste it's easier to read and make changes later. Might burn some memory, (or not depending on how good the optimizer has gotten), but it does not matter because it only happens once at start up. &gt; ever-so-slightly reduces heap allocations per-request The closure version does the allocations at start up since all that needs to be allocated is the closure itself. There's some extra dereferencing per request to grab the closed over context but, eh, computers love doing that stuff—I doubt the difference would even be measurable. Personally I love closures so I likely overuse them, but you should just write the code that's easy for you to understand. You can always make it faster later after you use the excellent profiling tools to find out where the slow down actually is.
Seems very cool, good job!
I know that global variable is not the best solution, but you can create middleware that adds application context to gorilla context. Then create function GetApp that accepts *request and returns application context. All your request handlers will stay compatible with net/http, and you only get that context in handlers that need it. 
I'm well aware of gorilla/context, but note that in this case it'd be a very roundabout way to achieve this as the "context" here is not a per-request context map, but an application-level context with our database pool, templates map and so on. Request contexts only live for the duration of the request, which would mean we'd need to create a new DB pool at the beginning of every request (!!), parse our templates and so on. They're useful for passing things like CSRF tokens, userIDs or form data between middleware/handlers.
You can instantiate app context on the start of the application, and set to context only pointer to this application context, no need to instantiate on each request.
Can you explain further? gorilla/context is a `map[*http.Request]map[interface{}]interface{}` - we can't pass an instance of our struct to it unless we do so at the beginning of each request and type-assert to get it out again. We'd need middleware that takes *appContext and does context.Set(r, someKey, context). That's a very messy way to do it and if I wanted to use globals I'd just ditch the struct altogether and make my template map, DB pool and so on global variables unto themselves. 
Have you considered [JSON Schema](http://json-schema.org/) for validating JSON? Here is a reasonably complete Go library for it: https://github.com/xeipuuv/gojsonschema
You are right, you have to set *appContext to gorillas context at start of each request. Also you have to type-assert it to get it out. But you can writefunction GetAppContext( *http.Request ) *AppContext. Usually you also need to handle csrf, session and other things for request, so for me it seems not bad idea also add application context without any need to break compatibility of request handlers with net/http. And appContext can hold DB pool, template map and all other information so no need to store each of it in globals. struct AppContext { db *sqlx.DB store *sessions.CookieStore .... } func GetAppContext(*http.Request) *AppRequest { return context.Get("your-key").(*AppRequest) } func Handler(w http.ResponseWriter, r *http.Request) { appContext := GetAppContext(r) } For me this works well.
I really appreciate the call to action, which is find people using it and submit pull requests with fixes to improve understanding. This makes it not just about improving your own understanding, but an effective way to help spread the knowledge and increase code quality.
Good question, As far as I understand that library will not do what i want. It does not set specific limits on the JSON passed in. For instance that will not allow you to say json string user_type is only allowed to accept a string that is "admin" or "user". It would just ensure the passed in user_type was a string and return true. I could be wrong but I had looked at this for a solution before I build this library.
Yes, there is a validation called 'enum' that would allow that.
I've lost the energy to look at any more RESTful framework's for Go. I thought I found one that was not too invasive (https://github.com/ant0ine/go-json-rest) until I discovered that you have no hope of injecting your own standard response (errors are thrown from within the package statically back to the response writer) and I gave up on trying to fork it. So, codehack, does it allow for the developer to provide their own interface to (easily) replace the standardized reponses (success, error, etc)
I think it depends, unfortunately I find my self quite uncomfortable using external libraries, however here is a great (IMHO) example how you can handle them with a small effort: https://github.com/dropbox/godropbox/blob/master/errors/errors.go 
Shameless plug: I've written a [blog post](http://justinas.org/best-practices-for-errors-in-go/) on this. (includes mention of errgo by juju).
yes, responses can be sent via **rw.Respond()** which can accept any object. So it's a matter of making a new struct that works for you. func (self *responseWriter) Respond(v interface{}, code ...int) error {} Relax has a catch-all structure for its errors, *relax.StatusError*, take a look in errors.go. I plan to work further on the errors, I really like Heroku's error responses. But for sure it will be something that isn't static and supports locales. Error responses are simply an alias to rw.Respond(). The thing to keep in mind is that you should send your responses through rw.Respond() if you want them encoded, as most of the work is done for you.
I know you can write helper functions to get/set it—I've been using gorilla/context for over a year now ;) What I'm saying is that using it for this case is just extremely inefficient and also ties you much more heavily to gorilla/context. It's different if you're using it for things like CSRF tokens: you don't generate a CSRF token until the request begins. You do, however, have an instance of `appContext` before it begins, so passing it directly to the handler is going to be much more efficient. Further, if you wanted to access it in `ServeHTTP` or in a wrapper function, you'd need to get it out *twice*, increasing the overhead.
How did you handle tls man-in-the-middle proxy issue? Go's `crypto/tls` currently doesn't allow generation of certs at connection time that would be required to make this work correctly for all websites. We did get this working by patching `crypto/tls` to allow the user to specify a function in the tls configuration and generate a certificate from a self-signed authority. Eventually, we went with the browsermob-proxy library (which does have its own issues) for our implementation, as this was already working. There is a [bug](https://code.google.com/p/go/issues/detail?id=7596) to add this, but it didn't make Go 1.3.
Ah, nice! So, all of what you said is possible. `wingo-cmd` is a pretty stupid client, but Wingo actually does support events. The protocol is pretty simple but undocumented. There exists one reference implementation: [pywingo](https://github.com/wingowm/pywingo/blob/master/pywingo/__init__.py). I'd be happy to help guide you through the process so you can get something working. Either file an issue on GitHub or just come on IRC/FreeNode `#wingo`. (You'll need to hang around since it can take some time for me to get back to you.)
I looked at this a little more and it really is a pain to use. I can see that you can setup some of the same stuff my library provides but it does not offer things like email or checking if a number is an exact length as far as i can tell after looking through all the examples. I was going to write a benchmark of my framework against it but It is hard to replicate the functionality of one vs the other.
ever heard of impedance mismatch?
It looks good, congrats. A couple of things: * you could replace handle() by a map that maps 'string' to 'func (session *session)(cmd command) ' * the DATA command doesn't support dot-stuffing, it should. * 'Too busy' should be 421 instead of 450 edit:formatting
&gt; impedance mismatch Yup, right now is a "research" project to see how far I can go keeping something readable.
Well, dunno, seems like a bit of an unfair assessment. You started up the language, dicked around in eclipse for a long while, then gave up on the language. Certainly you don't blame the failings of Eclipse on go? Ex., it took me basically no time to enable full go everything in vim by installing vim-go. Inline completion, definition jumping, syntax, inline error detection, even built in snippets. As usual, vim lets me run custom build commands on a keybind too. If you're not that familiar with vim, it seems that Sublime and Emacs also provide high quality plugins.
It sounds like most of your frustration was with GoClipse, rather than Go itself. 
Don't use an IDE. Use an editor like Vim/vim-go or Emacs or Sublime/gosublime if you're not there yet. You don't need IDE features for Go. Open a command prompt and type 'go build' to build, it's as simple as that.
I really can't understand this. I write my code in emacs. A simple go build mycode and everything is shiny. It's not Java. You really don't need code completion.
The first Hello World program I made did indeed build successfully with "go build". But as I described in my original post, when I tried "go build" with the second program I made, it didn't do anything. No errors, nothing. It ran and exited. No binary produced either. You don't *need* code completion for any language. I happen to like it though. It's a quick and easy way to see what methods and functions are available, what arguments they take, and what they return. And besides, every little bit of typing it saves is good.
You need a main package to get a binary. You probably built a package successfully, which is useful, but doesn't make an executable binary. The Learning Go book from Marc Summerfield (I think) is really good and walks you through this stuff. Try some Go without a bunch of IDE muddling things up. Go has great tools, so you don't need the IDE so much. Also, Atom from GitHub works great with Go.
Someone commented this advice a few weeks ago of using [LiteIDE](https://github.com/visualfc/liteide) and I have been using it and it's pretty good. Lost very little time with setup but it works wonders with autocompletion.
I had a main package deceleration in the first program I wrote and it ran just fine after compiling it. The second program I wrote just built on the first, so it also had a main package. I'll have to check Atom out.
I'll have to give that a look, thanks for the tip.
Running go build won't produce output on success. It also doesn't produce an output file depending on if your running it on the main package or not. You should read http://golang.org/doc/code.html It tells you all of this.
Unfair but sadly reasonable assessment. No one will argue that go has complete tooling. The main benefit is the language. The tooling is still at an early stage. However, having said that, if you are feeling adventureous again, use LiteIDE if you need an IDE. Im a viman, though i like LiteIDE for debugging.
You should lift the smtp server component from https://github.com/jhillyerd/inbucket / http://www.inbucket.org/ The fewer string operations you do, the faster the deamon will run. So, instead of doing things like split on a string, which assigns temporary variables that need to be garbage collected, you should simply parse the string in place. Do you have any benchmarks for how many messages/sec you can push through this server?
This. I did the same: I've installed Go easily from the pkg for Mac provided at golang.org and then just installed GoSublime on Sublime Text 3. I've also running Gin and added those lines so my project could be runnable by Gin, too. It's dead easy. Probably, you should blame Eclipse/GoClipse with your troubles. Also, did you configured the system variables temporarily (meaning, if you restart your variables are lost) or permanently (meaning .bashrc or something similar)? Because I've seen so many users complaining about not finding the $GOPATH even when they followed a weird blog post about installing Go on Win/Mac/Linux with temporary system variables.
What if you run "go run file.go"?
Just a few comments on the code. Don't let it distract from the article as a whole, I just feel like the boiler-plate makes the code appear to do far more than it actually does i.e. wrap already well-documented functions: * nit: the single-letter variable `s` is often used for **s**lices and **s**trings (or some type that starts with **s**). Ints often use **i** or **n**, the letters actually have meaning, they're not random * your checking of `n != len(b)` seems to imply that `rand.Read` can return `&lt; len(b)` bytes and no error. Correct me if I'm wrong, but http://golang.org/pkg/io/#ReadFull seems say otherwise. Having the check there only makes the code harder to read * It's very important to check errors, but IMO, it is even more important to think about what checking means. If you aren't going to add useful contextual info (e.g. the name of the function), then I don't think you should wrap the error, especially if th wrapping is going to turn it into a `string`. Just pass it on to the caller. In this case, I would get rid the wrapping and check altogether because I don't think it adds, or does, anything useful. I expect to be reading from a real `*os.File` and if that fails, you get a `*os.PathError`, etc. that includes more useful info like the filename; *system CSPRNG* doesn't really tell me anything useful * I'd get rid of the error checking in `GenerateRandomString`, it's just noise. `base64.URLEncoding.EncodeToString` will return an empty string if you pass it an empty slice The code then becomes something more like this http://play.golang.org/p/cNEBffQ7v9 . The documentation can then simply direct you to the underlying functions, and like many stdlib functions, you can just look at the very few lines its implementation and immediately know what it's doing without needing to understand why it's checking this or that
Ok - thanks a lot for the helpful hints.
I'm really amazed by how whiny and belligerent so many of the Go early adopters are. Some have been polite and tried to offer advice, but many are not. I said, "This was my first experience, the behavior was not as expected despite everything being configured properly. It was strange." And yet so many are acting as though I just insulted their favorite choice of hair style. Take a step back people. Go is just a technology, not a definition of self. Just because my first experience with it wasn't unicorns and rainbows doesn't mean I've just called you poo.
From what's been said so far, it does sound like that IDE would be a good choice.
Now if you've read very carefully, which I'm going to hazard and guess and assume you didn't based on your response, while GoClipse was part of the strange experience, it wasn't the *only* part of the strange experience.
`&lt;my project directory&gt;/bin,` - this looks like you have some trouble with GOPATH. Install puts the executable into `&lt;workspace&gt;/bin` and the project is usually in `&lt;workspace&gt;/src/&lt;hosting&gt;/&lt;name&gt;/&lt;project&gt;`. Can you run `go env`. Also see this [Writing, building, installing, and testing Go code](https://www.youtube.com/watch?v=XCsL89YtqCs).
I read it carefully, I even read the comments (your "go cannot produce the program" is in a comment), and that's my response. May be you should read my comment carefully.
&gt; I'm really amazed by how whiny and belligerent so many of the Go early adopters are. I am shocked by how polite people have been consider how horrible your post was... it was basically "I got Go working exactly according to the docs, then I started using a horrible tool, broke stuff and I couldn't figure out how to fix it so Go sucks and I uninstalled it" &gt; "This was my first experience, the behavior was not as expected despite everything being configured properly. It was strange." Lets be honest, the "first" experience was good, you got hello world working quickly and easily. Then you screwed around with the Eclipse blackhole... and when you tried to go back to the console, you obviously screwed something up. The Go binary didn't randomly stop working... you did something wrong. &gt; And yet so many are acting as though I just insulted their favorite choice of hair style. Take a step back people. Go is just a technology, not a definition of self. Just because my first experience with it wasn't unicorns and rainbows doesn't mean I've just called you poo. No, we are acting like you a poor developer / engineer. A better engineer might have come to this forum looking for help, trying to solve the problem, maybe helping others. But to do that would require you to understand the fault wasn't in some "magical Go issue" but your own ignorance and misconfiguration of the fantastically simple Go setup. Grow up and realize the fault lies with you... as the old proverb goes "A poor workman always blames his tools". 
I suspect if you had actually come to this forum for help, brought your code and showed us -- we would be able to point out your errors very quickly. Go is exceptionally simple, and messing it up is hard work. But instead, you came here with "Go worked perfectly, I fucked it up with Eclipse, then couldn't fix it so Go sucks". As the old proverb goes "A poor workman always blames his tools".
Yes. 
Thanks. I didn't know about dot-stuffing. Should be pretty easy to implement. I was actually thinking of using a map. But as long as I didn't want to support run-time updates to the supported commands I thought a static `switch` would be better. It's a bit verbose though.
Thanks for the comments. I haven't benchmarked it, as speed wasn't really a goal. But your point on in-place parsing makes sense.
What's it good for?
Why? Do you mean semantic code completion? Or any type of code completion like omnicomplete or `M-/` hippie-expand?
There is nothing wrong with python except maybe that it is not staticly typed and might be a little slow (depends on the use case). Go is the new kid on the block, and while Go is nice, it doesn't have nearly as many libraries as python does. Personally I prefer Go the language, but when it comes to stable, mature third party packages, it can't beat python at the moment.
i guess, a lot of people are annoyed by the fragmentation caused by python2 and python3. And while go was designed to build large concurrent applications, a lot of people (including myself) find that go is also a very nice fit for small applications for which you usually would have chosen bash for.
Agreed with the other commenters. But one addition: &gt; should I jump ship? No - you should use the right tool for the job in each individual case. Often, the best option will be a mixture of a number of different languages.
There are enough different use-cases for both languages, IMHO. For instance Python offers tons of great packages when you have to deal with data analysis while Go is great for any kind of network and server programming. Python is also really great if you just want to prototype an algorithm e.g. because of the easier to read set and map integration. It is probably not a waste of your time to learn both simply because you can then use the best tool for the job.
I think that's subjective, I've never really had a problem with compilation, but it can be a challenge to read it.
Go can be bootstrapped with gcc. Basiclly, just check out the source (download tarball or hg clone) and run `cd src &amp;&amp; ./all.bash` which will build all the packages and the go tool. You then just have to include `/where/i/build/go/bin` in your `PATH` and you are set. edit: Also see [Installing Go from source](http://golang.org/doc/install/source) which goes into much more detail
Getting a little confused about history, are we? C# was IDE-friendly because Microsoft wanted to sell VisualStudio. IDE's became friendly to Java after Java became popular, not before. 
Have you written a go compiler? That's what the link is talking about rather than it being hard to get your go code to compile.
The best developers don't have a fixed set of skills - they can pick up new languages easily by following the example of your existing codebase. Thus, I don't think this is really an issue for the cases in which I'm talking about - which are primarily large scale systems.
I don't mean not understanding the low-level detail, what I meant is would rarely resort to write my own wheels to handle these problem. For example, I would spend hours testing various load balancing algorithms, figuring where the bottle neck in the application and which part of the process that can be offloaded into a separate process, etc, but I wouldn't even consider writing my http server that are specifically optimized to my own requirement and nothing else. 
RHEL does not include a package for Go. If compiling and packaging it yourself isn't an option, you're out of luck. How do they handle other applications?
What /u/cryp7ix says will work, if you have access to */usr/local/* since it will try to install to */usr/local/go/*. You can also [download the binary](http://golang.org/dl/go1.3.linux-amd64.tar.gz) and run it from your user account. If you do it that way, you need to update the GOROOT as well as GOPATH.
ya nice try pal. Java was released in 1996, Borland JBuilder and NetBeans both came out only one year later. C# is IDE friendly because being IDE-unfriendly is simply demented. 
With Go you don't need to write your own HTTP server. You get it for free with the stdlib (and a very performant one at that.) What you get to do is write code which handles a part of your scaling solution efficiently and scalably and you attach the (free) HTTP (or tcp or udp) server to it and make it network enabled for the rest of your $phppythonrubyperl application to access on demand, or to load redirect out a sub-section of your URI domain into at the load balancer....
So you take a problem bit of code... You write a service in Go that can handle it more efficiently. Provide that to yourself as an API. You consume the API and reap the benefits. Obviously this only works where the improvement from the Go service outweighs the cost of consuming the API you provide (shelling out to a binary, or using a network service (zmq, raw sockets, http, etc all have their cost in terms of latency and bandwidth) So you get the most ROI where you would see huge improvements where faster code and especially more concurrent code will make a huge difference and you're fighting your existing language to make it so... 
Emacs, vim, sublime, etc all have completion if users want. It's just a keystroke away, but not everyone uses it (myself included) when programming in non Java/C# languages. So it seems like a strong reaction to call /u/toothless_tigers's opinion shit and question how it can have support.
I don't get it, everyone says go is such an easy language to read, yet it seems to be one of the more difficult languages for me.
It really does seem like they saw the crazy mess that Perl self-destructed on and thought, "We gotta be like Perl!"
well in MY opinion it is shit. Should I be more diplomatic? Probably yes.. but I do think that people that believe autocomplete is not essential are wasting their time and their employers' time and money.. or are lucky enough to have a job where they are expected to hack 2k LoC a year. You're welcome to think my opinion is shit too... I think I'll survive the event. 
PHP, IMHO, is a pain in the butt for debugging, first of all, and Go is a statically compiled language that's rigorously checked by the standard tools. At first it feels a little pushy and arrogant, but the Kool-Aid isn't that hard to swallow. This simple idea makes writing the code much easier regardless of what you write (including web apps). I think that when you wire up a PHP or a Python app to Nginx/Apache, the OS and web server does the heavy lifting, creating new threads and PHP/Python instances to serve each request. In Go, through the concurrency mechanisms behind the scenes, all this is handled in-house in a single, continuously running instance that's garbage-collected. Consequently, you can do caching of objects and database data inside the app for ALL requests. This is a lot easier on the hardware and web server. In my personal experience, the data structures are a huge part of the programming experience. Objects are very easy to construct, and can be arbitrarily complex while existing on a single screen of text. While I don't think it was intentional from the beginning, the compactness and user-friendliness of the data structures make programming with JSON and XML a breeze. I'd be happy to show you what I mean off-line. One of my complaints about PHP is the difficulty of separating PHP from HTML. While this has probably been improved, the stdlib templating engine has ensured from the beginning that HTML doesn't get mixed up in the code. The XML and JSON engines likewise prevent cross-contamination. Cross-contamination made editor selection limited. The Go stdlib templating scheme combines fairly well with most HTML editing tools with minimal tweaking to your code (I intentionally manipulate things to make line-breaks appear in nice places, but that's it). I hope that answers your question(s).
Some comments: * MAIL FROM:&lt;&gt; is a valid address; it is the null sender address. I think you don't accept this now because parseAddress() requires a @. * I think you might as well advertise the PIPELINING extension because you implicitly support it (almost any SMTP server implementation will, since you basically have to go out of your way to block pipelined commands). * you probably want to cancel the timeouts on the underlying TCP connection when STARTTLS succeeds. * handleSTARTTLS() might want to clear session.peer.HeloName. The STARTTLS RFC is specific that a client must EHLO after STARTTLS and cannot just go on to send MAIL FROMs. * handleDATA() should probably clear session.envelope after a successful delivery. * io.LimitReader may be useful for implementing size bounds on incoming messages and, for that matter, on incoming SMTP command lines. * it looks like the DATA body must be fully sent to you in the normal 60 second command read timeout. You might want a longer timeout for this, especially if you expect to someday deal with clients on slow network links trying to send you relatively big messages. * the code appears to ignore errors on writing replies and assume that any connection errors will be picked up on read. This is probably okay but might benefit from a comment about it. In general you will find that a number of client MTAs cannot successfully establish TLS connections with the Go crypto/tls package for various reasons; one common problem is that some clients send a SSLv2 handshake despite being capable of more modern TLS and crypto/tls just doesn't support this. I found it useful to track TLS setup failures and then stop offering TLS to clients that failed enough times. A certain amount of this code assumes that the clients will send SMTP commands in the correct order and not try incorrect things. Almost all SMTP clients do and enforcing fully RFC correct ordering is kind of a pain so this is perfectly defensible, but it might call for a comment mentioning it. All of these are small issues. About the only Go'isms issue that I can see is you could make more use of standard package functions to handle size limits, reading the message body, and so on. I like how you do the maximum simultaneous session limits by using a buffered channel. (I've got so many comments because I implemented my own SMTP server package and ran into a number of the RFC issues and 'leave the timeout on the underlying TCP connection after STARTTLS' stuff and so on myself.)
This was clear only after reading the article. The title is, I think deliberately, misleading.
Straight from Rob Pike's mouth: [Why learn Go?](http://youtu.be/FTl0tl9BGdc) (6 min video)
Can be made simpler: see [http://play.golang.org/p/xF5N4GjL1T](http://play.golang.org/p/xF5N4GjL1T).
From talking to python users, it really seems like they had the right intentions but somehow couldn't convince the community to go with them... It's really sad. There is a lot of good software with python around but everytime I run into code that still uses `print` as a keyword and didn't specify it needs python2 makes me move away from them more.. Well, at least we now have tools like docker to contain those and make setup reproducable but still.. it's really sad to see what happend.
Yes, the dependencies problem is my number one issue with Python, and Go just doesn't have that issue AT ALL. Beautiful.
(Assuming bash and amd64 - you can change "amd64" to "386" if that's what you're using) cd mkdir src go cd src wget http://golang.org/dl/go1.3.linux-amd64.tar.gz tar xzf go1.3.linux-amd64.tar.gz echo -e 'export GOROOT=~/src/go\nexport GOPATH=~/go\nexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin' &gt; .bashrc exec bash And to test it's working: go get code.google.com/p/go.tools/cmd/oracle oracle -help
You can be as rude as you like. I don't mind. But, I'll repeat: basically all editors have autocomplete. When OP cries about autocomplete not working in his IDE, and how Go has this weak area, he could have just been using vim, emacs, or sublime and had autocomplete work out of the box. He could have also taken a few minutes to look up [a thread](http://www.reddit.com/r/golang/comments/2ac5y2/whats_your_environment_setup/) where people describe their environments, seen [vim-go](https://github.com/fatih/vim-go) and then used it in order to get inline error reports and all sorts of other nifty features. &gt;but I do think that people that believe autocomplete is not essential are wasting their time and their employers' time and money.. or are lucky enough to have a job where they are expected to hack 2k LoC a year. You're welcome to think my opinion is shit too... I think I'll survive the event. I can see where you're coming from. I've had to dance with some enterprisey frameworky code which required an IDE to hide the details so I could reason about it. But when you're writing hello world you really don't need to fuck about with setting up an IDE to do auto complete. Just fucking get to work learning the language.
it's part of rhel7 Installed Packages Name : gcc-go Arch : x86_64 Version : 4.8.2 Release : 16.el7 Size : 15 M Repo : installed From repo : base Summary : Go support URL : http://gcc.gnu.org Licence : GPLv3+ and GPLv3+ with exceptions and GPLv2+ with exceptions and LGPLv2+ and BSD Description : The gcc-go package provides support for compiling Go programs : with the GNU Compiler Collection.
That's exactly what you'd do in Go as well. You wouldn't write your own http server just to tweak such things. 
Quick update: the second project is now online: [yxorp - a tiny reverse proxy](http://www.gomicroprojects.com/2014/07/yxorp-tiny-reverse-proxy.html)
That recursive function *type* state machine is sweet. 
Wait, you have to read the articles before you can comment here?!?
Appengine users are a big reason for this. Go app startup time is milliseconds, way faster than python. Goroutines allow for concurrent programming on appengine while python threading is disabled there. There are many more but this was just the first thoughts of the top of my head.
A lot of people think Haskell is easy to read, but I find in incomprehensible at times. 
Good tips!
Can you explain why Go doesn't? If anything, i feel like Go just completely ignored the concept of dependencies. There is no version control, it just pulls everything from repos.. it seems so fragile. It's my #1 worry with Go. Thoughts?
I maintain a [small utility](http://tmsu.org/) written in Go and the dependency versioning is annoying. All the time you're moving forward it's fine but occasionally an upstream change will stop the latest version of my utility from building until I fix it up. It's also difficult to rebuild older versions due to not knowing what versions of the dependencies were around at the time: you have to cross reference the dates which is not great.
I believe they mean dependencies on the client system. So especially in the non-web development world, when you want to ship a binary, you want it to work. With Python you need them to install libraries, etc (or ship a couple hundred megabyte binary). With Go, everything is in the binary you ship, nothing else needed. You are correct that Go needs to do better on the development dependency problem but the community is figuring that out, albeit slowly.
I'm usually wary of "n things about x" lists, but this had some nice info in it. Nice contribution.
You should probably learn python anyway. It's a 'best in class' scripting language, and basically allows you to get quick jobs done faster than Go. And we all have tons of quick jobs that need doing :-). Python also has easy-to-use libs for everything. Go comes to picture when your code needs to run faster, or your code is complex enough to benefit from static typing (esp. the case when the team size grows).
In the past some of these have been recorded and ended up on oreilly.com for purchase. Anyone know what the recording/publishing situation will be this year?
Ha, probably double-check your main, since it worked for one program, it's probably not a flaw in Go :)
Yes, this is exactly what I meant. Deploying a single, statically-compiled executable is 100% anxiety-free. I just know that it is going to work, and I don't have to worry about maintaining a configuration file that has be resolved by some means on the client where the executable will run. I find that maintaining dependencies in development is fairly trivial. I get a local copy of whatever library I will be leveraging into my GOPATH and just leave it alone. If it works, it works. I don't worry about any changes being made to it in its repo.
For #3, "Use tagged literals", consider what your struct is, and whether you _want_ the compiler to scream if the struct changes. Sometimes you want that, for instance, if your struct is basically a "tuple", in which case go ahead and use the more concise initialization. Sometimes you _want_ to carry on anyhow and use zero-initialized values, in which case use the names. Both behaviors have their place. \#5 is good, but there's some other useful methods you can implement to get some stuff out of the standard library. [GoStringer](http://golang.org/pkg/fmt/#GoStringer) is also a useful interface, for instance. Don't forget you can implement any interface you see in the stdlib, not just Reader and Writer. \#6 should be highlighted. If you don't _want_ the zero default, make sure it is made deliberately meaningless so you can detect it. \#9 is a very important technique to have in your tool chest, _BUT_ I would consider it non-idiomatic Go to do that _just_ to avoid a lock-and-defer call, even one you use in several methods. If your boilerplate grows beyond just that, seriously consider using something like that, but a Lock &amp; a defer Unlock should _not_ be factored out on their own. \#11, which I will add, is that in some circumstances Go can infer the struct you are initializing. If we have: type Something struct { A int B int C int } and you want a slice: x := []Something{ Something{1, 2, 3}, Something{4, 5, 6}, Something{7, 8, 9}, } [you can instead use](http://play.golang.org/p/r6HYWuMDpg) x := []Something{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, } 
&gt; The reason a person starts using Go is because they looked into the language, saw goroutines and channels, and said, "Dude, I have got to try that." The rest is just making excuses. to other people. And that's just your personal opinion that happens to not be in sync with reality most of the time. You made it sound like it's just a cool thing that people do these days and everybody follows because they don't want to seem uncool. There's lots of reasons people start using go or switch to go from another language. Many more than you have counted.
Sigh, *goes to redactor code*
Wow. I was not aware that you can use a function as a method receiver.
Thanks a lot! 
One paraphrased point of the go creators is 'don't pull random code from dudes on GitHub' and they advice on vendoring your dependencies but I like the idea of [gopkg.in](http://labix.org/gopkg.in) which solves this problem quite nicely. Until more people adopt that approach there also is the [godeps](https://github.com/tools/godep) tool which pins your dependencies to specific commits/tags.
&gt;I find that maintaining dependencies in development is fairly trivial. I get a local copy of whatever library I will be leveraging into my GOPATH and just leave it alone. If it works, it works. I don't worry about any changes being made to it in its repo. Won't you then have to ship your entire $GOPATH to any new team members, assuming you aren't developing by yourself? You don't have to worry about you no longer being able to build your code, but you do have to worry that someone who cloned your repo(especially an older version of your repo) will not be able to build a working executable. For anyone who isn't a Go developer reading this: this sucks, but it isnt a deal breaker, I still love Go, I just hope the tooling here improves. There are third party ways to work around it, but then you're depending on every Go developer ever to use the same third party tooling, so I still consider this a flaw in Go as it exists now.
As another perl programmer, specifically one who just had to try to get some old perl code to run again.. I can't state how amazing Go's standard library is. Installing a perl program means installing all of your dependencies. And all of your dependencies dependencies. And all of your dependencies dependencies dependencies.. With Go, the stdlib is good enough that the vast majority of what you'll do is either in it, or requires a library that only depends on the stdlib. When the built in way is good enough, you don't need more than one way to do it and the end result is a MUCH simpler project overall, both in terms of getting it up and running and things like memory usage.
People attribute readability to much to the language and not enough to the author. How well the code is written makes a much bigger difference than the language. 
It's my own experience. And seeing from my co-workers too, using one GOPATH was always more problem less. However it's opinionated therefore cant's say much about it. 
That's a fair point about working with team members, and it shows my bias: I have so far worked solo on Go projects. It could use a better story from the Go core team.
Oh you mean that :) Yeah godep makes it easy. etcd is also using it (and many other projects). 
I know a lot of people will hate me for saying this.. But i think python is suitable only for bash scripting, shell automation, etc.. cant see any other use case where python is a better option than other languages To abuse the use of python to more than that, is almost the same as the javascript scenario with node.js.. it does'nt fit well .. while javascript as a DOM scripting language is simply brilliant.. It take some time to be very well versed in any language out there.. so why not learn Go right away? It's also very different, from the purpose of simply learn something to become a better programmer.. than use things like more fancy functional languages.. can help here.. but i dont see anything to gain here with Python either.. cause its meant for productivity and simplicity.. I think if you are starting now, dont waste your time learning Python, Ruby, Perl, PHP, unless its only for the sake of curiosity.. because those are languages that are slowly dying.. and probably only one scripting language will remain.. and thats probably Javascript.. but then its useful only in some specific cases.. not to be hyped like in the node.js case
okay, maybe I have missread you. If you mean it like 'one GOPATH for the company', that makes sense. You wouldn't want a seperate GOPATH for each tool that you build. Codereuse would be terrible and progress nearly negative. For me as an indipendant developer, having one gopath for all of my projects and clients would just not work though.
They're not.
&gt; #6 should be highlighted. If you don't want the zero default, make sure it is made deliberately meaningless so you can detect it. I suppose the author meant to do it this way on purpose, but my gut instinct is to try to make the un-initalized state of an object as meaningful as possible, as to reduce possibilities for error. In this example, my inclination here is to set the zero state to 'Stopped', since that's technically the starting state for a new daemon/process.
Cool story bro
You sound like you're fairly new to programming. Python will be easier to learn than Go, and there are more, and more diverse, resources out there for Python than Go. I think the difference in learning Go vs learning Python will be considerable for an inexperienced programmer. If you mostly want to do web apps, and mostly focus on the front end at that, I'd choose Python. There's a lot of cool things in Go--I wasn't reading /r/python when I saw this--but expect to gear down and go slow if you're going to use Go as your first "real" language. 
Wish I could go the opposite way... :)
I can't speak for everyone, but here are my two big reasons: - I work on relatively large software projects, and it feels easier to manage the complexity of a large go project than a large python project. In general, I think this is true for statically vs dynamically typed languages. It is valuable to be able to change a shared library API and be confident that the compilation process will catch any dependencies you forgot to update. - I work on services that do a lot of concurrent processing, some of which can be pretty cpu-intensive. Go doesn't have anything like python's Global Interpreter Lock to cause problems scaling to multiple processors.
I tried go. For data modeling, statistics I would never consider it. Surely Python is slow but there is cython which gave me around 200 times speed up when I had to optimize some tight loops which I couldnt vectorize with numpy. The only thing I hate in Python is terrible support for parallelization.
Try cython. It is really impressive. 
The postscript doesn't mention how renderTemplate() is implemented. I assume it renders the template to a buffer and copies the buffer to the requestWriter if there's no rendering error. Otherwise, it would not be possible to write a different response in case of error. I wonder, how would it work if I wanted to write a different success code (perhaps 201 Created) still render a template. 
I think i'm going to give GVP and GPM a try. Godeps is a nice builtin solution, but GPM/GVP solve additional problems for me in a nice way. Granted, i haven't used them yet
I find today's winning combo is a cheap VPS running Go, and a CDN for the bulk data.
Okay, now we are on the same side. :)
Speed and cleanliness. Python is nice for throwing something together, but it gets ugly and it's inferior in performance.
I missed that. Updated it. You're correct through: you write to a buffer pool first before writing to the ResponseWriter. Note that using a pool is a significant performance gain because otherwise you're discarding a buffer containing a few KB (i.e. a rendered template) per request. If you wanted to write a different status code you would just call `w.WriteHeader(http.StatusCreated)` before you call `w.Write(buf)`. net/http will write a 200 header if no other header has been written yet. See this gist: https://gist.github.com/elithrar/fbf3772e6a0a6f997d8a 
Actually, that's not the same thing. In that case you *cannot access the context instance from inside ServeHTTP*, which is why I explicitly added an extra comment (rendering a template) inside the second example. I was previously using method receivers, which were neat but either required me to pass context twice per-request `{context.SomeHandler, context}` or only once, forsaking the ability to access the template map, custom logger, etc in `ServeHTTP` and any future methods for interfaces I need to satisfy.
#3 But that doesn't prevent breaking your structs once you decided to remove/add another field. My blog post is mainly about long-term scalability. Untagged literals are just not scalable sorry, the day will come where you decided to change the struct just a little bit and then you need to update all your structs. #6 You are right, but it's still like using a boolean field for a struct. It's by default false. But assume you're getting the initialization value from a remote server (like a json data). Now is that boolean false set explicitly or implicitly? That's why people are using *bool to have tristate. That's the same reason here. Unless you want that explicitly there is no way to detect it if you don'y explicitly define the zero value. #9 Yes, the first example is just there because everyone is used to use locks with defer. I don't insist on that to much and go and show an example about a db pool connection. Maybe I should remove the lock example and only show the db pool example. Thanks for mentioning though :) #11 I'm using it already at #8 but I didn't explicitly mentioned about it.
I was just wondering about trying to implement tagging for files as a learning experience for go and apparently you have already done it. Two questions - (1) where do you keep the tags? Plain text files or a database? (2) Do you track if the file is moved/its name is changed? If so, how do you do it? 
&gt; But that doesn't prevent breaking your structs once you decided to remove/add another field. I don't think you understood my point, since you haven't addressed it at all. The point of having a static type system isn't to make sure that it never tells you that you're wrong. It's to get it to do as much work as possible. It isn't intrinsically _wrong_ for the type system to break code if you add a field to a tuple-like struct. In fact it can be _just as wrong_ for Go to blithely zero-initialize a new struct member because you used name-based initialization when you shouldn't have! It is not that name-based initialization is "right" or "wrong". It is that it is _sometimes_ right and _sometimes_ wrong. It is sometimes annoying for every instance of the struct to issue errors, and sometimes it's annoying for it _not_ to. You can't just say "always use name-based initialization"... after all, if that is the case and given the way Go is designed (i.e., with a lot of attention paid to these issues), ask yourself, why is position-based initialization even an _option_, if it's always wrong? And the answer is that it isn't always wrong, and sometimes name-based initialization is wrong. It depends on the sort of struct we're talking about.
As written, it seems counter to all the lessons learned with virtualenv, rvm, and similar tools. Version pinning is the biggest advantage here.
I've tried to explain it in more detail with my previous examples. I also updated this section with a more detailed explanation.
Yeah, when Fatih first sent me the article to review I saw the title and was a little worried, but then as I read through the list I was like "Yep, yep, right on, exactly, yes!" Great article.
Nope. Rob doesn't use syntax highlighting or a fixed-width font.
I believe the docs show starting iota at 1 as: const ( _ = iota one two three ) I think yours is a bit more readable though.
We all would, however much trickier 
I wholeheartedly agree with this. 
Nice post. I come from java added to few years of clojure. With clojure I began my passion for literals, specially maps and seqs. So the only topic that I would no agree would be splitting maps and slices to custom types, unless they are really really necessary. I know, it's kinda groovysh (Lang of my daily job), but I don't know, class and struct impose rules that I don't want to follow. ;)
There is some truth to this, but I think it's also certainly true that languages can encourage (or discourage) readable code due either to the design of the language itself, or due to the common conventions. (Often the seed of the conventions is the code in the standard libraries.) In the specific example of Haskell, the tendency is to make things as terse as possible. For example, never adding parens to aid readability (and even going as far as using `$` to avoid parens), **terrible** naming conventions, and in extreme cases the use of point-free style for no apparent reason. The language design is also centered around terseness. Function (and parameterized type) application occurs by mere adjacency, there's an over-reliance on infix operators, return type overloading means you don't know what will be executed unless you know the expected *output* type, and in general there are very few hints to help you understand code incrementally. Type declarations also often have to appear separate from the things they declare the types of. For example, to figure out what the type of a parameter to a function is, you need to count its position, and then find the type in the same positron in the function's type signature. And finally, the layout rules are such that indentation is meaningless on some lines, and critical on others, and the rules for which case you're in are, in my experience, a lot harder to "get" than in other indentation sensitive languages like Python. The end result is that despite having studied Haskell for years, I still find reading Haskell code to be a huge pain. All Haskell code starts out looking like a flat and meaningless stream of tokens, while in other languages I can see the structure at a glance, often even when I'm completely new to the language. The only other language I've ever had so much trouble reading (aside from intentionally obfuscated code) was Perl.
The example didn't use anything from the context, which is why I thought it wasn't necessary. If you need to access those, then that approach makes sense.
renderTemplate() doesn't seem to return the buffer to the pool on error. Is that a problem? Would the buffer pool be better implemented with sync.Pool now that go 1.3 is out? Let me rephrase my earlier question. How would I use renderTemplate() and write a non-200 status code? I can't call w.WriteHeader() before calling renderTemplate(), because renderTemplate() might fail. I can't call w.WriteHeader() after a successful renderTemplate(), because 200 OK will already have been written. Maybe the entire response should be buffered and not only the body. I went looking for more information and found this discussion: https://groups.google.com/forum/#!topic/golang-dev/WLJEtS_mR-4 And also http://justinas.org/writing-http-middleware-in-go/ httptest.ResponseRecorder might be what I want. edit: Since appHandler.ServeHTTP is responsible for writing custom error pages, should it also be recovering panics?
Python has (for now) a much larger ecosystem, job market, etc. For web development it's still a very solid choice with mature frameworks such as Django and Flask. Go is faster, but for 99% of web applications that's not a huge deal - your bottleneck is more likely to be the database. Go shines in specific things like concurrency - if I had to build a chat app or something with websockets, I'd absolutely use Go over Python but for building lots of CRUD screens, Python is definitely easier - I recently started a side project using Go but ended up ditching it for Python + Django Rest Framework and accomplished more in a day than I had in a whole week, not because Go is more verbose/harder than Python (it is, but not significantly so) but because Python just had more off-the-shelf libraries for everything I needed. Python is also much easier for opening up a shell and doing off the cuff scripts. In a couple of years this may change as the Go ecosystem matures and standardizes (so there aren't a dozen competing web frameworks for example, something that plagued Python 10 years ago), but in the meantime there's nothing to lose by learning both.
Does it not worry you that everyone working on your project is likely using different versions of dependencies? And that when your CI server builds and deploys your code, for example, it's possible and likely that it's using its own set of dependencies as well? All it takes is for the author of one of your dependencies to push an insidious, subtly breaking change to master. To me, this seems like very bad advice. The size of the project has nothing to do with whether or not you need version pinning. I've run into issues in Go projects that didn't use version pinning that were only being developed by two authors. The other developer had an older version of a dependency that hadn't been updated in a while. Every time he deployed, he deployed the older version of the dependency which didn't have an important performance fix. Then, when I deployed, the newer version of the dependency would be once again restored to the production environment.
&gt; renderTemplate() doesn't seem to return the buffer to the pool on error. Is that a problem? Yes, it would be - that's a good catch. I've updated the Gist to reflect that. &gt; Would the buffer pool be better implemented with sync.Pool now that go 1.3 is out? It *could* be implemented with sync.Pool, but functionally it would be no better. I just used an existing package that had clean code/solved the problem. sync.Pool is pretty bare bones (it's just an interface) and isn't a magic pill. &gt; Let me rephrase my earlier question. How would I use renderTemplate() and write a non-200 status code? I can't call w.WriteHeader() before calling renderTemplate(), because renderTemplate() might fail. I can't call w.WriteHeader() after a successful renderTemplate(), because 200 OK will already have been written. If you mean the whole renderTemplate() method (and not `ExecuteTemplate`) then you would need to tackle it as per Justinas' article by hijacking the writer. In my implementation, writing the header only occurs after we 'know' the template will execute correctly (because we already wrote it to a buffer). If we wanted to do something else, we could just return the raw bytes from `renderTemplate()` instead, as per the discussion you linked on golang-dev. &gt; edit: Since appHandler.ServeHTTP is responsible for writing custom error pages, should it also be recovering panics? Panics are recovered by net/http and/or custom middleware . No need to handle that in `ServeHTTP`.
I did have a small comment in there (`ah.renderTemplate`), but I get your point. Have expanded the comment to emphasise that.
I'm open to any suggestions. Have done a lot of Python programming but this is my first Go work of any size (and that's not saying much because the xml package makes this stuff really easy). One issue I did run into was namespaces. RSS 1.0 is particular is loaded with them. For example, the docs say that the DublinCore module ships ["in the box"](http://web.resource.org/rss/1.0/spec) - what does that mean, and Pinboard.in for examples uses it. It is namespaced as dc: &lt;dc:date&gt;...&lt;/dc:date&gt; I can match it with the field: Date time.Time `xml:"date"` However, that does not seem to respect the namespace at all. So if another module is used, for example, &lt;x:date&gt;, which one gets matched? I'm also uncertain what modules to include by default. The RSS 1.0 parser matches the DublinCore and Syndication modules currently, but Pinboard uses Taxonomy, and other sites use others. Is there a set of commonly used modules that should be default? Anyway, really impressed with Go thus far, thanks for checking out my code.
Right now, it's pretty barebones. Given some likes and dislikes, it generates some recommendations for the users. Any sort of feedback (positive, negative.. or even contributions) is appreciated. 
Don't ignore errors in your example code. ;-)
Maybe you should make `Item` and `User` into interfaces to make it easier to integrate it.
Very good points. Thank you.
Thanks for the suggestion. You know, the commented out section is not just arbitrary comment. The `go test` tool actually takes that comment part into consideration. So if you have a `Example*` func somewhere in your `_test` files. Then the `go test` tool will run each of those examples as if they were some `main()` func and then match their output to stdout against the comment part. http://golang.org/pkg/testing/#hdr-Examples Thanks for the suggestion though. I will eventually need to write better tests and in that case I will have to use the `testing` package.
Also Go is more eco-friendly (can do same job using less resources). If you care about environment you should not really use languages like Python.
and go took that a step further and made much of the tooling themselves... golint, go vet, gofmt, go run, go build, go install are all made by the language creators.
Yep! 
I remember someone from core team said that "net/http" server is being used by Google in production for some time already. And it works really well.
I use in production webapps, written on Go. Demonize my process (basically it standalone net/nttp app, with wrap around local port) =&gt; proxy to outworld with nginx.
I disagree with python being easier to learn than Go. The compiler and static types are a huge help in getting your code to actually work. Go and Python code look remarkably similar for simple programs that most newbies would write.
What about using something like this [render](https://github.com/unrolled/render) package?
personally I prefer nginx for static content and go application for dynamic content (see templates).. also here is a great example of using go in real producgion: (google dl server) http://talks.golang.org/2013/oscon-dl.slide#1
If you're worried about GC pauses longer than x us, maybe you should bite the bullet and move to c++. It sucks but it also works.
I use nginx as a proxy front-end with SSL support. My process management is done with Upstart. In my experience, it's not smart to try and use Go's SSL support. When I tried it, it was CPU intensive and slow. At the time, this was because the encryption libraries were not taking advantage of the CPU optimizations. As soon as configured Nginx to do the security instead, the site became _much_ faster. Upstart is very clean and easy to set up IMHO. My only complaint is that either restarting upstart jobs as a user is not supported or maybe I just can't figure out how to do it. I've been using Go in production since 1.0 was released (almost 2.5 years). If you have questions about setting up your web environment, hit me offline.
This is great. What are you thoughts on feeds that blend properties from various specs together though? for example: http://www.thestar.com/feeds.topstories.rss has atom and rss2, and as such ocd isn't able to parse it.
For namespaced elements: Bob string `xml:"http://example.org/ns1 bob"` http://play.golang.org/p/4NNoBwS3AG
I actually agree with your hypothesis, though I have some personal biases as it describes my own path. I have a decent amount of history both in the Python community and in the Go community so I'll chime in on why I've *mostly* left Python behind for Go and why programmers in other languages might not have. Among the big 5 scripting languages (Perl, Ruby, Python, JavaScript, PHP), I'd say that 2 undeniably were founded for and still largely popular on the web; PHP and JavaScript. The other 3 are "more" general purpose as languages (with JavaScript on the server being a recent development). Perl found its legs as a sed/awk/bash replacement first, and expanded into the cgi world. This was essentially before computers were fast enough to run large systems built in such a language, and thus it became characterized mostly as a great language for throwaway scripts (not a slight, these are *vitally* important, eg. when responding to outages). Python and Ruby got their popularity later than Perl, despite being around about the same time. The early days of Python2 (and even the late days of Python1.5) saw companies take up Python as a programming language for *systems*; they saw it as a language which was easier and less error prone than C/C++ and less verbose and cumbersome than Java. Its niche was really large, too; it worked well for tool development but turned out to be pretty usable for writing server side applications as well, and eventually spread onto the web (early attempts like mod_python/PSP, Zope, etc made few converts; it was Django in ca. 2005 that really made the big splash). Ruby's popularity grew slower than Python's, but took off with RoR (2004 I believe), giving it explosive growth in the web camp. Later, true to its lineage, it ate into some of Perl's territory as a sysadmin's language, but only because it was already established as a language on everyone's web boxes. It suffered a bit on the systems programming side because the VM during its popularity explosion was initially not as good Python's, and it got this reputation for being slow and using lots of memory (things that are not big deals for web applications; just restart.) So out of the 5, I think only Python really made significant inroads in the software niche that Go has started to make a name in. And most Python programmers there have struggled for years with high memory usage, the single processor limit, and difficulty in achieving high single-processor performance (CPython's hashes all the way down). Go came out as a halfway house between C and Python which *felt* like those languages, too. Java was always there, mind you, but its build/distribution nightmare, verbose syntax and IDE reliance was unpalatable. People aren't ditching RoR, Django, Symfony, etc for large web projects in favor of Go, because those come with *so* many vital batteries that many developers don't know how to fashion themselves. It's a niche that Go might someday infiltrate, but the current library support isn't there for *those kinds of developers*. tl;dr: Python, moreso than Ruby and other imperative dynamic languages, was used in the same niche that Go is starting to slowly dominate, so it's seeing the most initial converts.
"difficulty of separating PHP from HTML" It's no more difficult then separating GO code from html. Noone mixes HTML with PHP anymore. And honestly - PHP is still my primary choice for frontend dev. GO is nice for server-side and high-speed things, but it's not nearly as nice and fun to work with as PHP. 
For server it's not disastrous other than CPU spikes, but I also want to make a client and the you can see the renderer hangs.
This is exactly what I intend to do. If I run into any difficulties without Google-reach answers, I'll pm you. Thank you, kind user!
Constants are no different than other variables. package foo const ( // ExportedConstant is an exported constant, and all exported symbols // need comments like this one. ExportedConstant = 99 nonExportedConstant = 42 )
Just do what the Go standard library does: lower camelCase. E.g., https://sourcegraph.com/github.com/golang/go/.GoPackage/net/http/internal/.def/maxLineLength. IIRC, at GopherCon, one of @bradfitz's stated regrets was that he named some of the io package constants, such as io.O_RDWR, in ALL_UPPERCASE and according to Unix conventions, not the more natural English Go conventions (which would be like io.ReadWrite). So, don't take the few instances of ALL_UPPERCASE constant naming in the stdlib as a reason to do it that way.
Don't :)
&gt; People aren't ditching RoR, Django, Symfony, etc for large web projects in favor of Go, because those come with so many vital batteries that many developers don't know how to fashion themselves. It's a niche that Go might someday infiltrate, but the current library support isn't there for those kinds of developers. Or they simply don't have the time/budget and just need to get the job done without reinventing wheels. 
Thank you. That should be as simple as adding the namespaced elements as suggested by pourbien. There's a couple of ways to go about it. One is to select a few common modules (such as atom) and include them in the definition for RSS 2.0 feeds. The other is to setup separate structs for different modules (as in the RSS 1.0 package and the DublinCore and Syndication modules), and have them available so that people can define new structs that compose from multiple other structs based on what feed they are parsing. I wish it could be a little more dynamic and not require that manual step, but it should work.
Yes, it works really well: http://talks.golang.org/2013/oscon-dl.slide#1 
For the developers, it might be worth it to also look at the proposed design of the [LuaJIT Garbage Collector](http://wiki.luajit.org/New-Garbage-Collector). Mike Pall has a keen understanding of modern processor architectures, and has done amazing work on optimizing the speed of LuaJIT overall. edit: Fix link.
You could take a quick look at this and see if it might help: https://gobyexample.com
Hey, just a heads up. To get your links working properly in Markdown, &gt; (LuaJIT Garbage Collector)[http://wiki.luajit.org/New-Garbage-Collector] becomes [LuaJIT Garbage Collector](http://wiki.luajit.org/New-Garbage-Collector) like [LuaJIT Garbage Collector](http://wiki.luajit.org/New-Garbage-Collector). 
There's no way to spread things out anyway. If it doesn't complete a scan then it has to throw all the work away. That is unless they implement some multi-generational GC, like Java, but that needs an enormous amount of work from what I've read. I think when you know what you're working with (in terms of a simple GC) then you can look for ways around it. For example, you could run two or more processes and share the work between them. The GC times will be independent and a proportion of what they were previously.
Do all of the examples in http://tour.golang.org/ and you will be set. I did all 70+ excercises over the course of about 3 days, and I felt like I knew everything about Go. I was able to turn around and immediately start building fairly complex applications.
Different strokes I suppose, but I had much more trouble getting started with Go than I did with Python, and I came to Python first. There are lots of little things in Go that I think will be hard to understand for a beginner. I like static typing too, and I think well written Go is pretty readable, but it's still not as easy to read as Python. Go has pointers. You will have to understand passing functions around much sooner in Go. Error handling in Go is harder to understand--especially syntax like "if _, ok := err.(websocket.HandshakeError); !ok {". Having an interactive interpreter is very handy for a beginner, and both Python and Django have one. Trying something out in the Go playground is good, but not as good. I'd suggest the OP take a look at the Go wiki tutorial. ( http://golang.org/doc/articles/wiki/ ). I think this is a very good tutorial, but I suspect most beginners will find it daunting, at least if they are striving for full comprehension as they go along. If OP finds the tutorial pretty easy to understand and gets warm fuzzies about Go from working through it, that's a good case for trying out Go as a first language after all. 
Sure, you could absolutely use that if you wanted to. Just create a field in the context as `r *render.Render` and populate it with the output of `render.New()` before you define your routes. The examples there all use anonymous functions which make the library appear "simpler" to use than it looks, IMO. I prefer to keep things simple with my own template implementation (plus templates are often the slowest part of the chain). I'd actually contributed a patch to the Martini version of that package to use a buffer pool instead of a throwaway buffer; I should probably do the same for this one :) 
&gt; Upstart is very clean and easy to set up IMHO. My only complaint is that either restarting upstart jobs as a user is not supported or maybe I just can't figure out how to do it. I use supervisord for this, since typically Upstart stuff (in /etc/services) is owned by root. But I otherwise have a similar setup: nginx for it's SSL termination and SSL cached sessions (useful!), logging, redirects to www and HTTPS (with STS headers from then on!) and so on. It keeps some of that boilerplate out of my Go application as well, which is nice.
Whoops... how did that happen. You'd think I had just started posting to Reddit this month. Thanks.
Yup. Sorry. We were learning. 
Note you can do defer replaceObject(fakeObject{})()
By simply keeping a log of potential points for data allocations you never need to do a big sweep to do GC. It's not memory efficient, but no sane person makes a program with a million independent allocations, instead grouping things up, so there's not huge overhead. This means CGo require hints, but that's the only downside.
After the tour: Have a look at the standard library, API and source.
Yes, I completely agree. If you want your Go to look like Go, read these sources. You do not have to write idiomatic Go all of the time, but you should know how to do so if you use the language.
This does a fantastic job at articulating the strengths of the language. Well done!
I've made several updates to the package: 1. Add an interface to support future implementations based on other data structures 2. Exported common errors. 3. Add gopkg.in support 4. Changed the API to make it clear how the pool is supposed to work. Btw, the package is not a new one, I've just improved it and pinned it to a stable branch
I have wanted varcheck (check for unused global vars and consts) for a long time! I tried to replicate it with gosym but was never fully able to. Thank you! It'd be awesome if these programs accepted command-line arguments like `./...` as the go toolchain does. Otherwise I have to run `go list ./... | GOPATH=$PWD/Godeps/_workspace:$GOPATH xargs -n 1 varcheck`. You can use go/loader at https://godoc.org/code.google.com/p/go.tools/go/loader to get this functionality for free. Also, do you need to resolve imports in varcheck? If an imported package name collides with a global variable or const, you might still want to print that error, but otherwise, perhaps you could ignore "could not import" / "can't find import" errors so that you can run varcheck even on packages whose dependencies you don't have in your GOPATH.
Thanks for the suggestions. I'll see what I can do.
The problem is that sometimes you are writing a library and your code doesn't use the global vars itself, but it is expected that user's implementations do use them. So, how could you know if that global var should be removed?
Yeah, this was Pool before even sync.Pool was released :) Maybe I can change it with the new v1 version.
You know, I don't quite have time for this, but a tool that would unify go fmt, go vet, golint, and make writing additional checks easy would be nice, even if some of it was simply done by shelling out (especially go fmt). I don't have time to write this myself, but I've got a few pet checks I might contribute if I didn't have to wrap it in an executable myself.
Maybe write a test that references the variable? No idea if op's `varcheck` tool checks tests, but that would be the first thing I can think of.
[fatih/vim-go](https://github.com/fatih/vim-go) does all this plus some extras (except for the test coverage, but you can easily add this yourself).
Looks straightforward and simple. Are there any idiomatic ways to implement time-based expirations of items? And is there perhaps a benchmark or example showing the benefits of this package? 
Awesome! I look forward to any videos :D
SublimeLinter+GoSublime does most of this for Sublime. Edit: Links to the various plugins: - [GoSublime](https://github.com/DisposaBoy/GoSublime) - Excellent for completion, not so robust for navigation. - [sublime-godef](https://github.com/ironcladlou/sublime-godef) - Rock solid symbol navigation. - [SublimeLinter](https://github.com/SublimeLinter/SublimeLinter3) - Super flexible linter framework. - [SublimeLinter-contrib-golint](https://github.com/sirreal/SublimeLinter-contrib-golint) - Mostly for stylistic issues, eg. non-documented public variables, etc. - [SublimeLinter-contrib-gotype](https://github.com/sirreal/SublimeLinter-contrib-gotype) - Picks up compilation errors - [SublimeLinter-contrib-govet](https://github.com/sirreal/SublimeLinter-contrib-govet) - Picks up non-compilation issues that are very likely errors, like printf parameter mismatches, etc. - [SublimeLinter-contrib-errcheck](https://github.com/alecthomas/SublimeLinter-contrib-errcheck) - Picks up function call sites where error return values aren't checked.
like your articles, please keep going..
Note that [http.HandlerFunc](http://godoc.org/net/http#HandlerFunc) does the same thing the `myHandler` type does - it provides a `Handler` around a function with the correct signature. [http.HandleFunc](http://godoc.org/net/http#HandleFunc) does this a level higher up by allowing you to just register a function with the correct signature as the handler for a particular pattern, without going through the intermediate step of creating a `Handler`.
Ahh I see. I think I would also rather use my own template implementation. Btw how are you populating `c.templates`? Could you show an example?
In the serveHomePage method you do a check if the url is something other then /. Unless you set it as the handler for another path it will only ever be / so not much of a need to check for it.
Are you sure, I tried it and for this URL http://127.0.0.1:8080/demo it gave me response from server instead of 404 message.
True. If you only set a handler for /, it will be called for any URL. This can be great, btw, to do dynamic endpoints, where you extract part of the URL (by looking at the URL field of the Request) and fetch something from a database.
Note that since a pattern ending in a slash names a rooted subtree, the pattern "/" matches all paths not matched by other registered patterns, not just the URL with Path == "/". src: http://golang.org/pkg/net/http/#ServeMux
Thanks for the tip!
no
Because I wrote that comment on my phone and couldn't check.
I would put a small, maybe 15 LOC, example in the README, which demos what you wrote in your text. And maybe also a screenshot of the result, which is always nice to have :) Except for that, looks cool!
Ya, just added that! Thanks for the feedback!
Yeah, this guy is pretty legit. Just happened to use his inject lib as a dep over the weekend.
Thanks. Appreciate your feedback.
looks pretty and cool thanks!
This looks great! Could you do one for ListenAndServeTLS also showing how to setup the keys and run the server locally for testing (EasyCert and/or generate_cert.go, etc.)? 
[Here's](https://code.google.com/p/go-wiki/wiki/Projects#Console_User_Interface) a list of alternatives if anyone's looking for it. I like [ansi](https://github.com/mgutz/ansi), personally, but I'll look into yours too!
op, upload it **Youtube**. 
In this blog post I highlighted the difference b/w Handle and HandleFunc http://whizdumb.me/2014/07/19/post-a-status-update-on-twitter/ I am not sure if Handle() can be replace by HandleFunc() in all cases.
Can I embed local or web videos?
[An Introduction to Programming in Go](http://www.golang-book.com/) All the documentation on [golang](http://golang.org/).
Your setup is a lot like mine except I use nginx to serve files with go as just an api endpoint and it works very nicely. With supervisord, it made it really easy to specify a lot of exactly what I need to run along with the specific signal to send when it asks the process to stop. I haven't been running my app in production too long; do you have any pitfalls with that setup you wouldn't mind sharing with me?
I feel like you should make your posts more complete. For example, in the "Repeating a string given number of times", you could have talked about the package string http://golang.org/pkg/strings/#Repeat I think it's great to rewrite and understand how those functions works - but the final code isn't perfect.. Maybe you should present the post as "how I learned how this works" and write more about how instead of giving some code as a model. Meanwhile it's interesting to read them and the comments. (also, use for {} instead of for i := 0;; i++ {} for an infinite loop)
It depends on the factory function. Usually you want use this for something like a DB connection, where the HOST is well known and there is a pool of connections. Each time you want to connect to the DB you go and get a connection from the Pool.
&gt; capture traffic for all of them separately Per client or per server? And why I wouldn't want to use pcap (or ngrep) for that?
 $ sudo docker run -i -t tutum/debian:squeeze /bin/bash # apt-get update -qq &amp;&amp; apt-get install -qq -y build-essential gcc g++ wget # wget --no-check-certificate https://golang.org/dl/go1.3.src.tar.gz -qO- | tar xzf - # cd go/src &amp;&amp; ./all.bash &amp;&gt;dev/null &amp;&amp; echo "Again, what was the problem?" Again, what was the problem?
This is for capturing the browsers network requests (so client side). Some of the reasons I don't use a packet capturing tool are: * I don't know which machine will be running the browser when I start up the test (one of dozens in a grid) * The machines run multiple concurrent browsers - how would you filter the packets to match each browsers results? * I want to get the network requests easily in whatever language I want after doing the request in selenium - using a REST server to to serve HAR files allows me to do that. I'm sure there are more reasons I forgot, but you get the gist - packet tools have their use, but they don't match my requirements (at least not easily).
Probably you may want to reopen the review, as Russ pointed out.
Nice, but Docker requires a kernel above 3.8, which was not the case on this system, as show in the post (3.2).
 host $ vagrant box add squeeze http://dl.dropbox.com/u/54390273/vagrantboxes/Squeeze64_VirtualBox4.2.4.box host $ vagrant init squeeze &amp;&amp; vagrant up &amp;&amp; vagrant ssh vagr $ sudo apt-get update -qq &amp;&amp; sudo apt-get install -qq -y build-essential gcc g++ wget vagr $ wget --no-check-certificate https://golang.org/dl/go1.3.src.tar.gz -qO- | tar xzf - vagr $ cd go/src &amp;&amp; ./all.bash &amp;&amp; echo "Still, what was the problem?" Still, what was the problem?
Maybe I'm wrong, but I don't see myself running a VM within a VM, for performance reasons : this server is already a VM. Would you actually do it ? Also, all in all, it seems your suggestion involves actually far more commands than my proposed solution : once the problem has been identified, it just needs a single "apt-get install" and will not increase server load.
You've missed the point completely. Your blog post should sound "How to troubleshoot misconfigured build environment. Analyzing Go executable". Other that that, I really like your way of analyzing static executables. The commands I posted just show that Go builds just fine under Debian Squeeze and there's no reason to suggest otherwise.
I can't understand the whole "what you can do with it" part. Probably because I don't know the standard pkg well.. if _, ok := (*animalToGreet).(Person); ok {} Does that translate to "if AnimalToGreet is of type Person"? Where can I find information on that syntax? (Why the parentheses around the pointer..) Also, (maybe that show some basic lack of knowledge) but I don't know how to do what I want. Cleaned up the code a bit and added comment where I need some clarification.. http://play.golang.org/p/RI4gKY_nC7
benchmark.md mentions that ledisdb uses LevelDB via cgo, and says that is a big cost in runtime performance. Since there exists a LevelDB implementation in pure Go, I wonder whether switching to it would make an impact on the performance. https://github.com/syndtr/goleveldb
I really enjoyed Go Koans: https://github.com/cdarwin/go-koans You'll need to refer to some documentation, but it points out a lot of interesting implementation bits. 
Thanks, I've read that part way too quickly and haven't wrote any code that use it so I didn't memorize anything.
I saw basically nothing better than the default log package. I guess it supports log levels, which standard log might not? However, that sounds like it could be done with a short wrapper.
That's because go will automatically dereference the pointer for you if you access a field or method of the value it points to, as per the [language specification](http://golang.org/ref/spec#Selectors): &gt; Selectors automatically dereference pointers to structs. **If x is a pointer to a struct, x.y is shorthand for (*x).y**; if the field y is also a pointer to a struct, x.y.z is shorthand for (*(*x).y).z, and so on. If x contains an anonymous field of type *A, where A is also a struct type, x.f is shorthand for (*x.A).f. (emphasis mine)
Thanks for the feedback. I will take care in other posts. Appreciate it.
Oh, I did indeed miss your point. Well taken.
The fields capability and built in json formatter are definitely nice
Just for some context, in C you can also access a field of a struct directly, but you have to use ``-&gt;`` operator for that. So it would be ``variable-&gt;value1`` instead of ``variable.value1``. This syntax was rather clumsy, so the Go creators decided to get rid of it and just use dot for everything (thankfully!).
You can do fields pretty easily with printf and inline structs. JSON is another built-in lib that would take not much to just use with std log.
For a library I think it makes sense to do it yourself since you want to limit external deps but for a webapp or command logrus seems like a nice fit.
Note: logrus is compatible with my log rolling package, lumberjack: http://godoc.org/gopkg.in/natefinch/lumberjack.v2
I think the elephant in the room here, is how lacking the standard logging library is. It's so bare-bones you can hardly achieve anything without wrapping it with some boilerplate. I really think Go needs a better logger.
Ah, good call out- I've made a mistake and conflated interfaces with pointers to interfaces so the example as I've listed will not work like that (you can't pass *Dog to something that expects *Animal, even if Dog implements that interface). My bad. Here's an updated version: http://play.golang.org/p/m_RQeo9N1H I updated the blog article as well. Cheers!
Too bad I couldn't spot the mistake! Anyway, everything now works as expected.
The default log package has one fundamental issue: it locks certain data structures internally, so if you have a certain amount of log output, it will essentially stall your program. I'm using Go in what is essentially a soft realtime application, and finding the right log library that doesn't stall our application and still allows us having verbose logs was quite a task. In the end, we stuck to writing our own log library, whose internal structure is based around an essentially lock-free operation. The only (implicit) locking is through internal channels.
Great! Happy hacking!
Yes. This is the closest you could currently get to incremental builds.
So I've implemented various approaches to performing distinct on an input stream of tuples, and measured the performance of each of them. I feel like I'm just scratching the surface, but the road has been interesting and I'd like to hear about other approaches. It is intended to be the first in a series of articles that build up relational algebra in Go pipelines. Feedback is quite appreciated!
Hi k_wolfe, Could you give a bit more information about the error handling issue ? go-json-rest provides an 'Error' method that provides JSON encoding, but you can always use the net/http package to produce your own error HTTP response. (net/http can always be used, like in this example https://github.com/ant0ine/go-json-rest#non-json-payload) Feel free to reply here or to open a github issue. Antoine (go-json-rest author) 
Yes, Go does incremental builds. Packages are only rebuilt when their source or their dependencies change. On my 1.7GHz processor it takes 10 seconds to build the whole standard library from scratch (300k lines of code). As a Go programmer, build times are not something you need to worry about.
You are using "go build" when you should be using "go install". Go does do incremental builds, "go build" tosses them all out when its done.
Here's a similar [Python script](http://www.zeusedit.com/zforum/viewtopic.php?t=7179) for the Zeus IDE that runs *gofmt*, *goimports*, *golint*, *go vet* and *go build* on the current file, each time the file is saved.
No problem. Actually I thought it might be an answer of "not helping you to do X" so I preassumed that. I think your answer is far mor valuable by telling me the "Go way to do things"... Just a question remains: is efficient doing a "strings.LastIndexOf" inside a for loop? I know it will be exponential for each new character the original string has, that's why I assumed regexs in the first place. I thought about doing a for loop and going character by character one by one but I don't understand quite well. The first one could actually find repeated letters but no strings... I thought it could be a "Go way" to do this... 
Never knew about the Suffix tree solution until now, but I was reading about it, and these slides seem to be a pretty good resource http://www.cs.ucf.edu/~shzhang/Combio11/lec3.pdf
That's good to know about, and I'd like to read up on this in due course, but I wonder if it's a bit complex for OP's needs. Sure it'll be faster, but it might be even more of a distraction than the regex example. e.g. see the wiki page on 'Suffix Trees' - whoa dude, that's some serious CS.
By first, good job, man. Well, I don't think a configuration is necessary, if benchmark shows that goleveldb is better than the cgo version, switching might be better. Acordding to Xu shiwei's testing, cgo could cause some unexpected problems, like turn goroutines to system threads. I would avoid it if possible.
BTW I'm using a custom logger I wrote that mimics Python's logging interface, and is not API compatible. https://github.com/dvirsky/go-pylog
Woah, did you seriously generate so many log messages, and ended up making runtime performance unpredictable?!? 
A great start would be for the core team to define a log interface that other loggers can build against for compatibility. Short of that, one of us should define it so people can start programming against it.
Yes, you express it better than me
That question cannot e serious. Go is several orders of magnitude faster as C++ in compilation speed and has incremental builds on package level and C++ (per se, individual compilers might be different on special cases or provide precompile headers) has not (in general).
I agree. Not only for the complexity but also because of my needs. According to some reading, the solution is fast, but it requires first to store the string's suffix tree and I think there's no need because of my needs. I'll take my chances by first trying to divide the problem into small pieces. And then, process everything and store the modification later on a persistent data storage. 
Now we just have to go through [shelakel](https://github.com/shelakel/go-middleware)'s middleware list and be finally done with it.. :)
Read the blog post, and it is quite interesting. Given that you are dealing with relational operations over streams, it'd make a really nice basis for an MQ whereby the subscriptions are on-going queries. I've been working on something similar in Erlang and it throws up interesting possibilities.
Logging key=value support is not to be overlooked as a superior feature. It's all okay when you're doing a one-off or a console program. But if you aspire to write middleware or server software, being able to chew on your logs with something like Splunk is a godsend. There, key=value data is worlds easier to process than having useful tidbits embedded in the middle of human-readable log messages. But to your point, this can easily be done with a short wrapper. In fact, the built-in log package does a great job of handling all the concurrency issues, that it's often a good idea to just wrap the library. For instance, [I rolled this wrapper to handle log levels.](https://github.com/eanderton/grapnel/blob/master/src/grapnel/log/package.go)
And supervisord (supervisor) as alternative.
That is an interesting idea. I'm not sure how to create memory efficient copies of the output of queries (something that I'll have to tackle on the blog at some point, I have an [outline](https://github.com/jonlawlor/rel/blob/master/chan_mem.go) of one at the moment). I think you'd need those, because your subscribers might be slow to take values, and you wouldn't want to block on the slowest of them. They might have have to be pushed into slower storage at some point, or discarded. Then again I don't really have much experience with message queues, except from Akka, so wouldn't be surprised if I was missing quite a bit.
Yup -- supervisord, Upstart, and daemonize are listed as alternatives in the second paragraph :)
The argument made for daemon tools is pretty weak: "We still use this because it’s fast, predictable." The same can be said of Supervisord and other monitoring services. "Written in C" isn't really a benefit in and of itself; and, doubly so when for your use case, a python monitor would do fine as well! Runit is mostly compatible with daemon tools configs as well, and offers extended functionality. Supervisord adds a lot of additional functionality - which may be an actual reason to avoid it outright. Just thought a better overview of the problem space and solutions were needed. On phone, reply if anyone wants more info.
Looks good and is pretty much [what I do already](http://www.reddit.com/r/golang/comments/29r66f/ask_rgolang_lightest_weight_middleware_pattern/). How does this improve over just declaring a chain of handlers and using it as the handler for http.handle? Or similarly chaining the middleware up nicely with [alice](https://github.com/justinas/alice)
I think it makes a very good base layer that you can write other solutions on top of. No, it's not everything to everyone, but just like the go testing framework, it shouldn't be. Not everyone wants the same things. Personally, I don't want third party packages writing willy-nilly to my log. Only the application author can know what and how to log. That's why library packages should never log on their own, just return rich errors that can be logged or not by the consumer of the package.
While daemon tools does have a rocky past, it's in the public domain since 2007 and you can certainly view the source. As you mentioned, extra functionality isn't always a plus -- especially when supervising critical services. Thanks for the feedback!
Right on - edited the public domain part
Instead of writing a bunch of functions with the same signature, I'd rather see an interface implemented by multiple types: type Distincter interface { func Distinct(in &lt;-chan tuple, res chan&lt;- tuple) } This way, callers can swap out the various implementations with ease, they can share a common set of tests, common benchmarks, etc. What's more, `Distincter`s could be chained: you can try a naïve sequential implementation in front of a more expensive map, or have the parallel implementation delegate to N other `Distincter`s without being tied to their internals. Also: have you considered a bloom filter implementation? That would be probabilistic (erring on the side of dropping some messages that aren't actually duplicates) but it has bounded memory use and might be appropriate for some use cases.
This structure: //2 START //1 START //0 START //0 END //1 END //2 END is a good way to explain it. Even though interpose is a great name, [chiasmus](https://www.google.com/search?q=chiasmus&amp;oq=chiasmus&amp;aqs=chrome..69i57j0l5.799j0j7&amp;sourceid=chrome&amp;es_sm=91&amp;ie=UTF-8#q=define+chiasmus&amp;safe=active) is what really stuck out to me here!
You just expanded my vocabulary.
You're right about libraries vs. applications, but still, like a couple of other packages (the flags package comes to mind), the log package in the standard library isn't very good. 
IMHO, nginx is the way to go. I use nginx as a proxy for all of my Go apps. When I had to host a PHP site, and eventually modify it, I used nginx to split the traffic between the PHP site and the improvement that I did with Go. The client couldn't tell where the PHP app ended and the Go app began, and it was very straightforward to do with nginx. I consider it best practice to specify the operating port of the Go app via the command line (typically 8000-9000). For PHP, I use PHP-FPM, which has its own default port configured.
On a technical level, I don't think that Interpose adds much beyond declaring a chain of handlers (because that's all it really does). Perhaps the adapters to liberate almost-http.Handler-compliant handlers will be of use. On a personal level, it took me a couple years to actually wrap my head around this simplistic approach, and also to figure out how to do simple things like nesting multiple different stacks of middleware for different routes (see the last example on the main Interpose README). So for me, this formalizes an approach that I'd like to take to development. I suspect it might help others do the same. On a cultural level, I would like to see an http.Handler-only framework get some traction in the Go community to encourage reusability and net/http compatibility. If there is a robust library of http.Handlers, then folks like you can just pick them up and drop them into their personal frameworks without any modification, and folks like /u/codegangsta can easily bake them into his Martini and Negroni frameworks with a boilerplate wrapper. (*Edit*: Negroni has a built-in http.Handler convertor for just this purpose.) There is a lot of duplication of middleware stacks as each new framework crops up, but if there is middleware built against the http.Handler standard, that duplication can be reduced (and perhaps limited to writing a small wrapper around the http.Handler rather than a full rewrite).
I'm going to put in a pitch for [Interpose](https://github.com/carbocation/interpose), which is fully http.Handler compliant (and has an adapter to accept any Negroni middleware out-of-the-box). Writing middleware for Interpose means you can also use that middleware in virtually any other Middleware library (with just a one-line wrapper) if you decide you want to make the switch later.
I know nothing of the implementation you settled on, but I would imagine that the intersection of lazy evaluation (pass a func to be evaluated instead of values) and per-logger level filtering (ala log4j) would handle that problem space with aplomb. If your logging lib doesn't support either of those, I highly recommend it.
Now this is interesting. What causes std log to lock data?
The problem is that `tuple` is a placeholder for many different types, so the interface would also have to be modified to account for those different types of tuples as well. I tried doing that using reflection, but the result was a bit of a [mess](http://github.com/jonlawlor/rel). Another approach might be to create a structure which represents the operation itself. I tried that out for a [merge join](https://github.com/jonlawlor/relpipes/blob/master/mergejoin.go). I'm still mulling that over - I'm not sure the extra ceremony would be justified by the small amount of code reuse. I think the right choice here might actually be code generation, but before I check that out I want to better justify this approach to data handling. I'm trying to keep it as simple as I can for now, and I'm *still* finding that small details matter quite a bit. A more general approach would probably miss some of those. I have considered a bloom filter and that will be part of a followup about sublinear models(although I have never implemented one...). First I'm trying to make some small operations that larger ones can be built up from. For example, distinct is probably going to be a part of set difference, and I have a draft post on grouping tuples that I'm working on that will be used in most operations.
Well, I am saying you can do this in std log (from memory, may be imperfect): log.printf("%+v", type struct { Name string }{ allData.Name }) Bit uglier syntax, but avoids a lib.
"And yes, I am aware that the whole idea is not particularly very TheGoWay™, but it is useful as a learning exercise, and it is useful for moving fast and optimising later." -- lib author
The whole "Totally not really designed for performance" thing made be giggle. Just a little. Also I know it will never be considered, but Go 2 should have some of these things built in, if only for slices and maps. You know the function types required at compile time. Even if you forgo higher order functions, bringing some of the SIMD capabilities in the SSE instructions could be a boon for performance when working on lists at a time.
Coincidentally I wrote about how to implement a basic reverse proxy in Go: http://www.gomicroprojects.com/2014/07/yxorp-tiny-reverse-proxy.html Of course it is not as powerful as nginx our other mature systems, but if you want to tinker with it, it's a nice learning project.
That's exactly it - it requires me to write boilerplate to get decent functionality, most of Go's libraries don't. Same goes for flag. It's okay I guess, but a couple of much better libraries out there aren't even based on it. 
It's not my submission, but do you have any direction on how to do that? If not, I'll track down the process.
The different-middleware-per-route example is startlingly verbose. It would be nice to see an example with a framework like Martini, where you don't have to set up a separate router.
As mentioned before nginx the best choice as reverse proxy, but apache also can be configured that way. I'm afraid that you shoud do this manually. But it's, raising some other problem: each go site will stay as go binary in memory, so for **many** small websites this configuration might be memory hungry. Plus here will be real pain in case if something will crash or reload or out of memory.. IMO: go is perfect for high speed applications, services and big enough sites, but for small ones here is good old php or ruby.. 
As an additional learning exercise you should add helpful godoc comments.
I've been using tablestruct for some private work, but this is its first public release. I'm interested in feedback and collaboration on its design and workflow. The main philosophy of tablestruct is: keep implementation simple; don't implement a full ORM/eliminate writing SQL in your app; favor compile-time type safety over reflection.
Go apps tend to be a lot less memory hungry than Ruby or PHP (if you are using fpm) processes. I have a VPS with multiple small apps that use Ruby, Python, PHP and Go and the Go app is the least resource intensive one. +1 for Nginx in any case :)
No doubt other supervisors would've been faster to get up and running out-of-the-box. The initial setup isn't a huge concern for us because it's simple to package for future installations and deployments. Our main focus was reliability for critical long-running processes, for which daemon tools has proven itself to us in the past. Nevertheless, thanks for the feedback!
How did you run the PHP portion?
thank you!
Or have apache do the reverse proxying, in this case an option...
That example, while verbose, shows the degree of flexibility of the app (but, to its detriment as an example, doesn't take advantage of it). In response to your point, I've [updated the Readme](https://github.com/carbocation/interpose#wrapped-middleware) with a simpler example of different-middleware-per-route. You still need to bring your own router, but I think this example shows that it doesn't have to be verbose if what you're trying to do doesn't require a lot of complexity.
I thought it's yours since you've mentioned it. I'm afraid there's nothing more you can do rather than pinging gently.
Why not use runit? It's a modern, reliable take on daemontools. Also there's no good reason not to use whatever is native to your distro, ever. Principle of least surprise should apply to ops tools above all.
Not sure why this is even in /r/golang article is not specific to the language in any way at all. I'd much prefer a writeup showing how to natively daemonize, I.E. double fork, dettach, logging boiler plate, pidfile etc.
If you want the right tool for the job, go is probably not it. Your experience will be much better and you will spend much much much less time just using microsoft's own [roslyn](http://msdn.microsoft.com/en-us/vstudio/roslyn.aspx) project to get done what you need to get done. If you wanted to parse go source code you could use the built in go/ast package. Just about anything else will require writing a custom grammar for yacc type things and will probably hurt a whole lot more than just doing it in c#.(http://msdn.microsoft.com/en-us/vstudio/roslyn.aspx)
So I've used this peg parser: https://github.com/pointlander/peg To attempt to parse various things, I'm less then thrilled with it, but I'm comparing it to pegjs (for javascript) which is amazing. My main issues are: 1. cruddy error messages when there is a parsing error 2. doesn't have a good passing pattern (this is where pegjs kicks but) So the general pattern I use with it looks like so: &gt; &gt;objects &lt;- object sp ( ',' sp objects)? &gt; &gt;object &lt;- ( '{' property ( ',' property )* '}' { p.Stack.Push(NewNativeEvent(&amp;p.Stack)) } &gt; / '{' sp '}' ) &gt; &gt;property &lt;- sp identifier sp ':' sp (bool / string / float / number / object ) sp { p.Stack.Push(NewNativeProp(&amp;p.Stack)) } &gt; And then I use the constructors to pop stuff off the stack and and build the objects ... it sucks. 
There is also the native go parsers: * http://golang.org/cmd/yacc/ * https://github.com/golang-samples/yacc I didn't use these because I prefer to work with peg parsers.. or perhaps I was ruined by pegjs. 
&gt;something like Kind of implies (correctly) that there are many options. Nginx is being used more and more due to performance and resource usage. I switched to it several years ago and haven't looked back, it's been a joy to use compared to apache.
PHP-FPM, I believe. There are several good guides out there for setting it up with nginx, I believe the one I found most helpful in the past was the one on the nginx wiki.
Assuming: 1. For some reason I will take as given, you absolutely must use Go to manipulate the ASTs, and 2. You are not _so_ constrained that you aren't allowed to use anything else as at least a component of the solution, my suggestion would be to find a C# parser in another language, and write a JSON exporter for the C# AST objects. You can then write objects in Go that decode the JSON output of the parser. With a bit of luck you can work out some ways of automating the tedious bits, too, since you also ought to be able to come up with machine-understandable specifications of the grammar with this approach, too. And I'd be unashamed about going the other way, too, and using an existing system for outputting the manipulated result. Writing a C# parser is likely to be an enormous waste of time compared to harnessing an already-existing one.
Interesting stuff! Though, I cannot assume or require presence of a .NET or Mono runtime where my built-in-Go C# parser will run.. will investigate this anyway ;)
**Much obliged!** -- for my use-case context this is pretty much the answer I was looking for. Finding an existing "C# grammar for yacc" should be feasible, and then this should generate me a "Go package that can parse C# source code". Good stuff! ;)
i mainly hacked this together because it was too hot and i couldn't sleep. I was quite amazed how painfull string concats and `math.Mod()` were for the execution time. Ps: I want to do the decode part as well but it's really late where I am and the reference implementation in the 2006 blog post is in perl and I never wrote a single line of it so maybe tomorrow.
I don't intend to bring up a firestorm, but this would make much more sense with regard to type-safety if we had generics.
Funny, I'm doing the exact opposite of that. 
And it is probably much easier in that direction yeah?
How do you deal with third party libraries that need other third party libraries?
I also had a great time meeting Jiahua at GopherCon! This interview makes it easier to relate to well-known Go developers. I think it's true that many of us are still just learning, but it doesn't matter, you can still do cool things. I asked Jiahua about his username, "Unknwon" -- whether it was intended or not. He told me it was a typo, but then it stuck. :)
&gt; In my mind, if "upstart" doesn't have a proven track record, nothing I've ever touched is good enough. The problem with Upstart is that there's a vast difference in functionality between versions running on 12.04 and 14.04: you pretty much end up using start-stop-daemon to work around them, which (IMO) reduces the value of Upstart itself. Although I don't care for the politics, the systemd configuration syntax (and the ability to define deps) is much better and more stable to boot. I don't blame the OP for using daemontools: it's a tool that is designed to do one thing, and he's not alone in using it.
You shouldn't "traditionally" daemonize (double fork) a Go application: https://code.google.com/p/go/issues/detail?id=227 
Very nice.
&gt; How do you deal with third party libraries that need other third party libraries? There shouldn't be any problem with that. In the example, the upsilon library is put into the same location as it would have been if you had just run 'go get' on the library from the original author's GitHub repository. So no import paths need to be changed. For the omicron library, we're explicitly maintaining a separate fork of the code, so presumably we're willing to update any import statements that reference the original version.
You're right -- you could replace Go with virtually any other language and the article would still be the same, but it's common to see questions on this topic specific to Go programs and this is one solution.
Could not record it. Am doing a rerun of it in BrowserStack office this weekend, will see if can record it then. Will put the slides up soon.
Runit could certainly be a contender for us, but it doesn't offer anything that we feel we're missing from daemon tools to warrant a switch. We also don't use one specific distro, so it's important for us to have a standard supervisor setup that works on virtually any distribution.
I met Jiahua at the talk he gave at the Boston Golang meetup about gogs, blew the handful of us there away with what he had gotten done in go after only 2 months or so working on his project (a testament to Go but probably more so his passion for coding, haha). Someone asked about webhooks, and he had already built support for them, everyone was laughing in amazement. Someone there asked why he chose Go vs some other language, and to answer that question he just re-installed gogs from the binary and had the whole service running in less than 10 seconds. Great project, Jiahua.
My method does have all files in version control. The top level project directory and all subfolders are considered part of the project and checked into version control.
Thank you so much for not making yet another minimalistic web framework. This looks well done are pretty useful.
I have a need for arbitrary rotation in go, and would really like to see some library add it. I end up calling out to php right now which works but I want to keep my app self contained.
Awesome!
I started using GNU Make for this. Perhaps it's a perversion of the tool, but I can run things like 'make pull', 'make push', and 'make deploy'. The Makefile is generic enough that I can move it around from project project without more than the most basic modification.
This appears to have image rotation: https://code.google.com/p/graphics-go/
Still in Developer Preview, but in case you don't know about it. [.Net Native](http://msdn.microsoft.com/en-US/vstudio/dotnetnative)
I'll poke the issue and see if we can't get the changeset added. Original author seems to be AWOL but perhaps some activity there rouse him.
Well that is interesting, though the discussion seems to indicate that it is a desirable feature and we should expect some sugar to help make it work properly soon.
Looks great! Any chance that drawing text on the images is in the roadmap?
Hope this uses goroutines smartly under the hood ;) At one point I used to do various simple per-pixel manipulations of big 4096x4096 images. This was processing where neighboring pixels weren't accessed and was thus amenable to parallelization. Doing for example all rows "in parallel" instead of sequentially sped things up remarkably! Example: https://github.com/go-utils/ugfx/blob/master/img.go#L89
That's a good catch. I'll add a fix today.
FYI, i'm aware that there are already a few attempts to do this, and some of them are even named goenv :) I wrote my own largely because I a) disliked the way they went about it and b) needed a small, fun, first project to write in Go.
Is it me or that article makes a good case for java (which was 3x ahead in that test) rather than go?
Props for making something cool! BUT, I'm highly in the "one GOPATH to rule them all" camp. I believe that's the recommendation too. But maybe I'm just too small scale to make virtualenvs useful. 
Perhaps for convolution you may want to add predefined filters such as the sobel? The sobel is exceptionally simple to use with what you have, its basically just two kernels, and having it predefined would make life much easier for anyone looking for a portable solution they can just plug into a program.
Coming from a Haskell background (still very actively programming in Haskell), I gotta say this sounds like `cabal sandbox`es. That was (to my knowledge) one of the biggest positive changes in the Haskell ecosystem's package management. You said yourself that there were already tools to do this, but a good implementation of local dependencies sounds like a great idea.
This would be a good package to build a full blown image editing program off of. Good work!
I found this today. It looks like a really cool idea: http://labix.org/gopkg.in
the AMQP model works well for that, subscribers have their own queues and a process/goroutine dispatches in to consumer queues. Then you just cap them at some space or apply some policy on full consumer queues. Yea scaling MQs isn't easy and is often application specific.
This is definitely the direction I'm going with not just Go, but just about everything. As nice as all the ORMs and everything else are in some ways, they have some pernicious effects that really start to bite you at the scales I tend to work at. Once you have an ORM, you start to feel like everything has to be in your one database. You forget that it's all just code, and you start tying yourself too deeply to the ORM without giving it a thought. It shapes your thinking and limits you in a profound and difficult to easily describe ways. Better to clearly define "here's what I want to be able to save and here's what I want to be able to retrieve", and then write to that interface, as simply as possible. It's more (literal) typing at first, but you can start doing all kinds of things after that; trivially wrapping things to go into memcache, pull some data from one database and some from another, just a whole lot of things that you wouldn't even have thought of. It makes it _really_ easy to test both sides of the interface, in exactly the way ORMs often make it pretty difficult. And plain ol' DRY and the usual techniques of avoiding code duplication can make it so you aren't even duplicating that much code. I won't go as far as some people and call ORMs useless, but they charge a great deal more than people realize.
I sometimes words myself.
I'm not sure about recording but the [portaudio](code.google.com/p/portaudio-go/portaudio) blindings seem to be quite solid.
Thanks for writing this. I've spent quite some time trying to deploy my first Go app (with one external dependency) to Heroku yesterday. I was using godep, so I ended up having to `git add -f Godeps/`. This git subtree strategy looks like reasonable alternative.
"You should use Go because it's not PHP"
Why are they building on shared machines?
Beautiful. Is there a place where the convolution matrices for emboss, edge detect, etc are described? I checked out wikipedia but didn't find the same formulae, and the simplicity of the matrices is intriguing.
Why in god's name did Clypd implement a custom scroll for this page? It breaks pretty much everything: two-finger back and forward doesn't work, inertial scrolling is jerky and unnatural, scrolling from within an iframe (like Reddit's iframe) doesn't work at all, and zoom breaks entirely as well. And that's just what I found in the 15 seconds I spent trying to navigate around the page without going crazy. What are the advantages of implementing a custom scroll method that would justify the time and expense of implementing it? I can't see a single advantage to this, and I mean that honestly. Not in some sort of "I hate everything different" way.
Well, the way it works is by leveraging the unique structure of power of 2 values in base 2: * All powers of two in binary are a one followed by some number of zeroes; `0001000`, for example * Subtracting one from a power of two is all ones; `0000111`, for example * Shifting to the right and bitwise ORing will "pull" the ones from the left to the right, resulting in a number of ones: `00100100` -OR shifted by 1-&gt; `00110110` -OR shifted by 2-&gt; `00111111` -OR shifted by 4-&gt; `00111111` ... etc With these three properties, you can find the higher power of two (inclusive) by following the algorithm and shifting once per number of bits. The lower power of two (exclusive) could then be calculated by shifting the higher power of two one to the right (a division by two). Determining which one is closer is then trivial. You should be aware that: * There are many different numeric types, `int` is implementation specific size: [http://golang.org/ref/spec#Numeric_types](http://golang.org/ref/spec#Numeric_types) * Shift behavior differs for signed/unsigned integers, which means this algorithm will need to be adjusted for negative numbers: [http://golang.org/ref/spec#Arithmetic_operators](http://golang.org/ref/spec#Arithmetic_operators)
You are sort of trying too hard. Bit bashing is fun (as I [well know](https://github.com/thejerf/gomempool/blob/master/pool.go#L493) ("I'm so excited, 15 years programming and I've never had this good an excuse to get down and seriously bash bits.")), but good ol' fashioned logic works too. Once you have the next higher power of two, the next lower one is just one bit shift away, then figuring out which is "closer' is then just a matter of subtracting the values in the obvious manner and seeing which remainder is smaller. Bit bashing isn't going to speed that up anyhow, that's all _extremely_ fast operations.
&gt; ardb LedisDB is influenced by [SSDB](https://github.com/ideawu/ssdb), and I only wanted to develop a similar one with Go before. Excuse me for not being familiar with ardb, so I can not tell the difference between them easily. (I see ardb's source, it's an awesome one) LedisDB can be embedded in your own Go project, which may be an attraction for Gophers, I think. Thank you!
If you work in a real python environment with multiple projects virtualenv is not stupid. It's required. Haven't worked with go much, so I can't say if it makes sense in that environment.
It's obviously... obvious, but it's a similar name to github.com/jmoiron/modl :)
&gt; Does the library allocate the new image storage, or does the user supply it? I would think the image would allocate a new image and return it, like the other methods of this class. &gt; Second is that it will cause aliasing: how do you fix it? Perhaps take an interpolation method as a parameter? I'm no expert on this. &gt; Third, is it rotated about the center, or a different point? About center makes the most sense to me. &gt; In which plane do you rotate? Show it handle 3 dimensions? If so, what should the back side of an image look like? How should cropping work afterward? I would just accept one angle and not worry about 3 dimensions.
Yeah, I was considering using it, seems well done, there are more: - struct model (i forgot the link) - https://github.com/jmoiron/sqlx However I wrote this since I needed a more general approach in a very thin implementation. The idea is to use a generalist approach independently if you are using sql/redis/cassandra etc... 
I've written another article on relational operations in Go. This was originally going to be part of the article on distinct, but it ended up way too long, so I split this one off. (The next one will take much longer to write) I hope you'll find this as interesting as I did - Go can be fast even when you don't expect it to be. I didn't expect a slightly complicated unordered group operation on million(s) of inputs to be basically as fast as a (more straightforward) ordered implementation. Feedback is quite appreciated!
It tends to happen. At the very least you'll end up with a CI server that's pulling down source, building it and running tests for a bunch of different projects, and being able to trust having isolation there every time is really important.
It feels like a similar situation, but of course w/ Python it's a run-time problem too, as you're not deploying compiled and linked code. Even just for development it saves you from an entire class of issues.
In my oppinion you should use golang after initial prototyping in some faster to write dynamic language. It will get your app to production phase faster and when you hit performance wall then rewrite component by component in golang.
Great writeup! I've never used a decentralized pattern but find it fascinating. Great read. Have you personally built anything with Iris?
Link is giving the following error: open 2014/hammers.slide: no such file or directory
The talk from FOSDEM: https://www.youtube.com/watch?v=WTRORimPvHE
Nice overview; I'll have to take a look at Iris!
A single GOPATH works in pretty much all cases. Either you're doing small personal projects, and always working off of head, in which case there's no harm in sharing external repositories, or you're on a big project and using one of the many revision locking/vendoring solutions out there. Either way, there's no harm in having a single gopath. I would go so far as to say that if you *need* more than one gopath, you're actually doing something wrong, and should stop whatever it is you're doing that requires different gopaths, and find a different solution. I think Go looks a lot more early stage from the outside than it does to long standing members of the community. Google has almost nothing to do with the Go community other than the fact that several of the core devs work there. There is no blessed approach from Google. There *is* a blessed approach from the experienced members of the community, and that's generally a single gopath (though not everyone agrees, of course).
If you need this, your interfaces are too big.
Ha, thought I was the only one. When the page first loaded, it wouldn't scroll at all with my mousewheel. And holy crap is that the heaviest blog page I've ever seen... what is there like 10 megs of javascript behind it? Every scroll made my laptop churn.
Or you like editor integration and don't want to write 2-3 functions by hand :-)
I may not be reading that properly, but which function is being executed for the main loop and where is it setting it to tick at 1 minute intervals?
Pedantic maybe, but worth reading is http://golang.org/doc/effective_go.html#mixed-caps — the majority of the Go ecosystem doesn't use `underscores_for_variable_or_function_names`. As for the article: you should show it "in use" and/or provide a link to a complete example. I'd also consider using the (well tested) [redigo](https://github.com/garyburd/redigo) library.
I think it's 3 skews, but that's only one kind of rotation.
Nothing in production, although I have used ZeroMQ extensively and, to a lesser extent, nanomsg. Iris looks like a really appealing alternative. Not the same throughput but there are some obvious benefits (like service discovery, load balancing, etc) that make the sacrifice worth it I think.
Did you measure memory usage during those benchmarks? If not, an easy way to have a quick idea would be with https://github.com/davecheney/gcvis.
Hi, please check out the example: https://github.com/gihnius/redis_online_counter
just created an example: https://github.com/gihnius/redis_online_counter
Sure! It seems that some persons here are talking about what they don't know nothing about! Development in Python withou virtualenv is a nightmare! And thank you for this! 
Yes, you can use p.X. This isn't a very good example of the benefits of pointers. I definitely suggest doing research as the topic of pointers is covered in many debates regarding other languages. Here is a quick link I snagged, http://stackoverflow.com/questions/1863460/whats-the-point-of-having-pointers-in-go And now the eli5 version of pointers. This is a core topic to understanding many programming languages and data structures, golang or otherwise, so eli5 isn't really going to do it justice. Here goes.... Go is a pass by value language. This means when you call a function, a COPY of the arugments is made and passed to the function. If you modify the copy in the function, the original value is unchanged. If you pass a pointer to the object, the function can modify the object and the original value (the same value) will change. Why is this good? I imagine instead of passing simple x, y values to a function you're passing 100MB of image/audio data. Do you want to make a COPY of that data? What if you want to modify the data in the function?
Nice! Why did you do it this way: https://github.com/josharian/impl/blob/d9ec1c7ad323cf259c6d56c7db399a7d959b0f58/impl.go#L227-L230 instead of generating a new ast and stringifying it? (I'm not at all familiar with the go/ast pkg so forgive my ignorance)
Actually I was just curios to play with this after I saw the post on HN a couple of days ago. I think they have both their places. If you need accuracy above 10m, sure. On the other hand MGRS doesn't have a checksum. Apart from these differences, this small bit of code was quite nice to learn the profiling tools, which was the main reason I shared both encoding functions. Seeing how much a couple of innocent string concats cost was very interesting.
[Pointers](http://www.golang-book.com/8/index.htm) [Structs and Interfaces](http://www.golang-book.com/9/index.htm) Those chapters might help you in your understanding. 
&gt; Hi, please check out the example: &gt; https://github.com/gihnius/redis_online_counter 
I guess that required less thought to implement. Generating AST definitely sounds like it's less prone to errors and edge cases though.
Just off top of my head, change this line `sender.Bind("tcp://*:5557")` to use localhost as well. 
To modify the original value instead of a copy of the value.
From what I can tell you have to deploy the iris service along side the service you write. So you'd make a docker container that has 2 services, irsi and your app. This makes deployment a little harder. Am I wrong?
Whenever you call a function in Go and pass a struct as an argument, you're actually making a copy of that structure behind the scenes and then passing that copy you created as argument to the function. Now suppose you want to have only one copy of a structure in memory and pass that around, instead of copies of that structure - you can then pass around a *pointer* to this structure. It is faster and saves memory and gives the function that is receiving the argument a way to modify the structure (and everybody else will see the change because you modified the only version of the structure in memory). It's like I have a magazine and I want my friends to read the magazine. Not using pointers is the equivalent of me xeroxing the magazine and giving them the copies for them to read - and if they highlight something important on the magazine, only they will see it because they modified their own copy of the magazine. Using pointers is equivalent of them sitting by my side and reading the magazine with me. If I modify the magazine by highlight something, or John does it, everybody will see the highlighting because we're seeing the same thing (the original version).
While we are on the topic, I've notice two symbols used in pointers. &amp;, and *. I'm guessing that &amp; is used when manipulating the pointed-to value, and * is used to manipulate the pointer itself. Is this true? Thanks :3
I tried that package out (which worked like a charm!) and the problem is that the benchmarks that I use generate a large slice of data to send through the group functions, which I ignore in the benchmark, but gcvis includes it in the memory use. I'll have to use a different approach I think.
Heh. Thanks. Thinking "address-of" and "value-of" when reading those symbols should help me get used to this a bit more. I understand the idea of passing by reference from PHP's &amp; symbol and JavaScript's default functionality, but the additional pointer symbol has been causing some confusion.
&gt; I only know some Python where there are no pointers Actually, in Python it would be more accurate to say that _everything_ is like a Go pointer. What's different about Go is that it lets you _not_ use pointers and use values directly, without boxing them in a reference/pointer, which raw Python doesn't have a way to express. (NumPy and some similar libraries provide such functionality, but the core language does not.) It is only _more_ accurate and not _entirely_ accurate. because neither a Go pointer nor a Go value is exactly like a Python reference, but a Python reference is certainly _more_ like a Go pointer. (To be honest, when it gets down to it, almost no two languages have the exact same "pointer", "reference", or "value" semantics.)
This isn't very idiomatic and there are some problems with the documentation. For on Call takes a parameter of an unxported type. Timeout is an int and ultimate units aren't indicated. IMO this sort of behavior should be in a very small self contained type and not be part of the function call flow.
you have to add contributors to the live thread before they can comment. Not really a chat room.
I've been using Go for a few weeks now - I'm going with the single GOPATH approach. My concern is that as some of my dependencies mature into new versions, backwards compatibility is broken, and now I have to update all of my apps using it. Unless I'm missing something, the single GOPATH approach really is like global pip install. I need to find a good way to version my dependencies.
Fair points on the docs and types - I've fixed those up a bit. I get what you're saying about not part of the function call flow. I'm not sure I agree, but I'm willing to play around with it and see where it goes. Thanks for the feedback!
As others have pointed out that's a poor example. Here's an example which demonstrates the difference between passing a value and passing a pointer to a value: http://play.golang.org/p/BHfEDsfPm6
Please don't use shortened urls. 5 years, you should know better.
Plus I got a "Oops! Something went wrong." on the jump page. Never even got to the article. Very weak all round.
Huh-what? LevelDB is trivial to beat. "we added monitoring and learned that if you have a write-heavy workload then you are not going to have a good time with LevelDB. We aren't unique in learning that." http://smalldatum.blogspot.ie/2014/07/benchmarking-leveldb-family.html Try LMDB http://symas.com/mdb or Bolt...
I only just realised last week that I was doing it wrong, when I tried 'golint'. Have you considered deprecating them all, in favour of idiomatic CamelCase equivalents? I guess there's currently no concept of deprecation but a comment 'deprecated: see CamelCaseEquivalent' would do fine. 
The "pattern" part of this honestly makes the code much harder to understand. Which one is bad - CircuitOpen or CircuitClosed? I shouldn't have to be an electrician to understand the code. Closed usually implies the end of something, but in this pattern it's when you reset from a failure. (note - this is mostly criticism of the pattern, not your code) I'm not a huge fan of the callbacks either (and you might want to call the callbacks from a goroutine so you don't have to wait for them to finish).
If you are having trouble seeing the code on his slides, [here is the same talk given at GopherCon](https://www.youtube.com/watch?v=YPQ-aFjJX5Q) and you can see the slides a lot better.
A small flaw with Go is that once you cast a structure through interface{}, the compiler can't help with the cast to an interface type on the other side if that object is missing a method or two; it becomes a run-time problem. One needs an explicit unit-test, provided it isn't left out by accident, in order to ensure that a custom type really does implement a given interface. So having automation like this is a quick-and-simple error reduction mechanism for implementing large *and* small types.
The single gopath keeps you honest. If one of your dependencies updates, it updates whether you pull down the new version or not. If someone go-gets your code, they'll get whatever is the newest version of that dependency. There are various solutions to keeping your code insulated from upstream changes... godep is one of the best - https://github.com/tools/godep This is what a lot of the big Go projects use to make sure their code is always buildable.
A pointer is nothing but an address. There's several reasons why pointers are available in the language, but the biggest issue with pointers is that it gives you the ability to pass in a parameter either by value or by reference, so when you give a variable to a function, you can decide whether the function operates off of a copy or gets to manipulate that part of memory directly. Passing by value is usually safer and more predicable at the cost of sometimes being more expensive.
Your commentary doesn't follow Effective Go's [suggestions](http://golang.org/doc/effective_go.html#commentary), which lint would pick up. You should have the first word of exported variables and functions match the name of the function, and every exported type should have commentary. Just a good habit to get into - most of the structures are almost self explanatory, which is nice.
Even if you don't recompile the app, subsequent runs of the same application may keep giving you the popup. OSX tends to identify binaries by a signed signature. I used to get this popup continuously with Eclipse as well since it was an unsigned binary. You can sign apps yourself to prevent the firewall popups: http://superuser.com/a/300841 But as jan1024188 said, bind to localhost instead of * and the problem should go away. But if you do need to bind to external interfaces, you'll probably continue to get that popup.
If you haven't seen it already, this blog post may be of interest to you: http://noypi-linux.blogspot.de/2014/07/golang-parser-generator-ebnfyacclex.html
Yeah, that's the one I'm considering trying. Seems like a workable solution. 
I always like this guy's posts about Go. And this time I find his philosophical/metaphysical connection quite interesting.
The sound of silence. 
If you want desktop apps, look at this [UI PROJECT!](https://github.com/andlabs/ui). Its cross platform. There is also a [WEBKIT PROJECT!](https://github.com/mattn/go-webkit) in go as well.
checkout gustavo niemeyer go-qml https://github.com/go-qml/qml
I think the Webkit project is what I'm looking for, but I'll have to experiment with it a bit
As I read your article, and after some tryouts there are almost two more aproches to the problem. 1. If what you need to pass is a string, you can use a request.Header. Its writable, and in the context of web services could be a good idea. Proxys, and appservers, sometimes comunicate with this. Also, if you marshal to json, you can store in a Header some info. This, way, we don't touch the api, and all stays intact. 2. Another way, I'm thinking, is implement io.ResponseWriter in a new struct, with a context extra field. But this way, You have to wrap, all your middlewares in some "controller". Another think I don't like a lot, is the wrapped middleware chains... Is not readable a wrap of a wrap of a wrap, and also, in middleware terms is not clear, when you are pretouching the response or postprocessing it.. just for think about it. 
Maybe you are looking something like this: https://github.com/CzarekTomczak/cef2go
Looks cool, time to add GoDoc.
Thanks for the feedback, actually not my article but that's a decent idea, using the headers as a medium isn't too bad.
#5 is an excellent way of expanding upon the usual positive point that Go is "simple" or "easy to learn." "Low cognitive load" is another excellent phrase I've heard to refer to simplicity in languages.
Of course no, actually i'm new in golang and this little project has on point for now: to learn golang and it's concurency model. Of course i dont say that everybody must use this super-lib and of course i dont suggest to use it in production, because i am not sure will it work better than standard solution or not. In the nearest time i am planing to do benchmarks for this because i am very interesting how golang about performance and it's libraries. I understand all of your words about complexity and of course i prefer tobise standard practices and not reinvent a wheel. Just for learning as i said above at least for now
sync.Pool is probably the easiest way to do it without managing your own memory pool.
If you are writing the response.body to something that implements io.Writer, io.Copy is usually the preferred way to handle this. If your io.Writer also implements io.WriterTo it saves you the allocation (as stated in the comments at http://golang.org/src/pkg/io/io.go?s=11987:12047#L331)
Avoid ReadAll. What are you doing with the data? You can probably process it incrementally instead. 
Seriously, there must be an easier way...
You can use a header, but I'd be cautious about that: if you're expecting headers to be *only* set by your application you may run into some unexpected bugs (bad) when a request header accidentally overrides it, or open up security issues (worse) if someone intentionally attempts to pass in data. And yep, wrapping http.ResponseWriter is another option, but one that starts to impact on your use of the vanilla http.Handler interface. PS: Avoiding that(crazy(wrapping(r))) is why I recommend stuff like [Alice](http://justinas.org/alice-painless-middleware-chaining-for-go/) or [Goji](https://goji.io/) to most. 
I think it's totally easy but the blog post comes across a bit verbose imho. The main tl;dr is &gt; Don't `go get` your fork. just `git remote add` your fork and push to that. 
If you know the size of the allocations you need before allocating a []byte, that's what I wrote [gomempool](https://github.com/thejerf/gomempool) for. Note the usual "sync.Pool" suggestion is less useful in this case, because sync.Pool is designed for homogeneous objects, and for byte slices you probably don't want to have to hand out the largest possible allocation for everything. The package provides statistics that you can examine to see whether you need to tune it after you use it for a few runs. Though I wrote that because I had a need for it, I would also consider examining whatever it is you are doing just to verify that there really isn't a way to stream somehow, as that will be yet again faster and more efficient. In other words, is there a way to consume the io.Readers being produced as the result of the web page requests via some sort of io.Writer-compliant interface? I don't know what you are doing, so I can't speak to that. It's just worth a look. But for instance, if you are sticking them in some sort of database, you may be able to find an interface that permits that (the postgres one has one, IIRC). Or perhaps you can rewrite your processing code as an io.Writer.
looks cool! see my PR for more feedback :)
How does this compare to the crc32 and 64 performance on amd64? It is implemented [in hardware](http://golang.org/src/pkg/hash/crc32/crc32_amd64x.go) there.
I put up my own personal benchmark in there, comparing xxhash{32,64}, fnv{32,64}, adler32 and crc32. xxhash64 is by far the fastest, crc32 is by far the slowest on my i5. Keep in mind that the actual xxhash implementation is in C, I only wrote the go-wrapper for it, I didn't implement it in Go. Using it internally in a memcached-like project of mine (soon-to-be published).
Thanks for leaning on a proven/solid cookie implementation. It might even worth allowing users to pass a `*sessions.Store` as a field in `AttarOptions` so they use their own/existing gorilla-compatible store. I would also put tests on your "important things to do next" as I think testing 'critical' stuff like auth, CSRF protection and cookies/sessions is extremely valuable.
One of the most important things to do when contributing to an open source Go project is use gofmt, you're in deep trouble if you don't!
Check this: https://github.com/astaxie/build-web-application-with-golang/tree/master/en However if you look at the code of: https://github.com/gin-gonic/gin you'll find that is very simple.
this is an tutorial for how to develop api by beego. but you don't want any framework. So I think I can't help you. http://beego.me/blog/beego_api but this tools may help you: http://apiblueprint.org/
Aah ok. Just been searching on youtube, and now I know why there's just one video up there (sourcegraph).
Thank you very much! :)
you'er welcome. You might also want to read up on [this](https://elithrar.github.io/article/map-string-interface/) article (if you havn't yet) outlining the pro's and con's of different context passing techniques. I also had to think about this as well when I hacked together examples for the the new middleware package [interpose](https://github.com/carbocation/interpose). I decided to pass the `*http.Request` back with the auth callback to let the pkg users decide how to handle it and not make a decision for them. (See Issue [#3](https://github.com/carbocation/interpose/pull/3) for the discussion with /u/carbocation) edit/ps: I'm sure he would be glad to take an example PR for interpose from you :)
Thank you for your feedback. I have added those features to my to do list and will implement/fix them asap.
 Golang Support Both Linux and Windows [cloud hosting services ](http://www.computehost.com/cloud-server-hosting).
&gt;&gt; Third, is it rotated about the center, or a different point? &gt;About center makes the most sense to me. I'd let the user supply the point that you use as the rotation's center. You can always have a wrapper around this method that rotates around the images center.
Download and use [golint](https://github.com/golang/lint) on your code base. `[]float64{latitude, longitude}` should be replaced by type Location struct { Latitude, Longitude float64 } Or some variant thereof. (Personally I'd strongly consider locking down the constructor to make it impossible to construct illegal Locations, but fully sealing off that possibility would be a challenge in Go so it may not be worth it.) On a general computer science or physics note, it doesn't seem to me that two Locations have any meaningful addition construct in the first place. Nor do two locations identified by degrees latitude and longitude have a particularly meaningful subtraction operator, either; "2 degrees east" has no universal meaning without further specification. Once a location has been constructed you should not be performing simple arithmetic on it. But ignoring that for the moment for Go learning purposes, you may want a pointer receiver method on a Location to change it. It's an awfully close call considering you're just saving the caller from doing: loc.Latitude += 8 loc.Longitude += -3 Under the circumstances, Lat and Long is enough for the names of the members, too; I was just being complete for learning purposes.
Consult this, http://golang.org/doc/effective_go.html#names , for style questions. Underscores aside, the is no visual distinction between those two function names. Seems like you're running up against go's lack of function overloading. Consider using a names which indicates the plural nature and/or type of the second version. Also keep in mind that a exportable function must be capitalized. AddLatLon(lat float64, lon float64) AddLatLons(lat []float64, lon []float64) AddMultipleLatLon(lat []float64, lon []float64) AddLatLonInterleaved(latlon []float64) unless there are other ways of adding points, perhaps the following AddPoint(lat float64, lon float64) AddPoints(lat []float64, lon []float64) AddPointsInterleaved(latlon []float64)
Wow. Your company decided to write an XMPP server in PHP? … So, without answering your question: why do they want to write an XMPP server? It's likely that you can solve whatever problem you have using a [component](http://xmpp.org/extensions/xep-0114.html), which is a much more sane project to tackle. Writing an XMPP server is like writing a web server. You *could* do it, but it's a lot of work and you're very likely to do it poorly. Besides, in general there are ways to use existing servers in front of your own custom code, so you should probably do that instead.
Go uses a custom hash function that's based around the AES-NI instructions on your processor: http://golang.org/src/pkg/runtime/asm_amd64.s#L890 . (If that file changes, look for 'runtime aeshash'
&gt; fully sealing off that possibility would be a challenge in Go To do this, it's a matter of exporting an interface, and implementing all the private details as members of a non-exported struct. IIRC, it's the only way to completely hide an implementation.
Just curious why you and your company don't choose something that is *already* written? There are lots of XMPP libraries and XMPP servers available. I would like to convince both of you that rewriting someone as common as an XMPP server is unnecessary.
If you want some feedback you should put the code somewhere we can look at it. Regarding the functions you are asking about in this question. Why the two versions? It seems to me what you really want is just the first one. Go's lack of underscores here is hinting to you that your API choice here is a code smell. As to the general question of naming Go methods the method name should be AddLatLng and should be a succinct description of what the method does. CamelCase is the norm for Public methods and pascalCase is the norm for private methods.
I elided over some details. The reason it would be a challenge is that one would also have to provide all the API that one might want for a location, because if you don't provide it, the client won't be able to use it. By contrast, in the scope of this particular conversation, just sealing over the constructor just to provide an "AddLatLong" or "AddLocation" method that then really has no ability to correctly maintain the invariants is of little value, on par with the "accessors" you'll often see in Java that are just direct sets and gets of the relevant variable... one might as well have left them public. In this case it seems to me that using this merely as a struct and leaving them public is the way to go for now. (Yes, I'm aware of the argument that you could go back and change them later, in practice you rarely ever do, and that's partially because the very existence of these accessors in the first place usually strongly implies you've got a struct-like class. Or just aren't very good at OO... if a huge number of your classes have a lot of exposed properties like this you probably aren't doing actual OO.)
Here's one for building RESTful APIs in Martini. I know you said no frameworks, but it could give you some pointers in the right direction. http://0value.com/build-a-restful-API-with-Martini
uhcar, you mentioned that you're a new gopher so you might want to steer clear of Martini. The creator of it had a very respectable post about it and how it is not idiomatic Go. As he mentions, that doesn't mean it's a bad design or a bad framework. It just may not be a good way to start learning Go. Here's the post if you're interested: http://blog.codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/ He has an alternative project, Negroni, which may be a better choice if you wanted to go down this route for learning. Personally I think your gorilla/mux choice is good.
Why not use ejabberd or other free xmpp servers?
https://github.com/lxn/walk is good for native.
&gt; Some more recent hash function designs have attempted to reuse parts of the AES -- to be precise, to use an internal operation which maps well on the AES-NI instructions which recent Intel and AMD processors feature. See for instance ECHO and SHAvite-3; these two functions both received quite a bit of exposure as part of the SHA-3 competition and are believed "reasonably secure". There are very fast on recent Intel and AMD processors. On other weaker architectures, were hash function performance has some chance to actually matter, these functions are quite slow. -- from [stackexchange](http://security.stackexchange.com/questions/8048/why-aes-is-not-used-for-secure-hashing-instead-of-sha-x) So maybe it is one of those. 
I would recommend going through the source code of the [standard library](http://golang.org/src/pkg/) to get used to the Go way of doing things.
This example at [gobyexample](https://gobyexample.com/pointers) may also help - the rest of that tutorial is also far more in depth than the one at play.golang.org