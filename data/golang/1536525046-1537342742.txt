Sorry, you are correct. So I'll ask one more time, what is conceptually different, than calling reflect.TypeOf(1) where 1 is accessed as an interface, and having []int and passing them to []interface. In most cases it would be implicitly a read-only, as it would panic if you tried to store a non int back into the slice, but it wouldn't have to be if the called method stored an int. It makes everything easier to use, with very few type safety issues, certainly less than most of the other popular languages - it will panic at worst, not corrupt memory. The interface author writes methods that take a collection of that interface - not the concrete types a "caller" is working with, so you are continually copying your concrete types to a slice of the required interface, especially when you concrete type "implements" multiple interfaces. Collections are hugely important, and this support is VERY weak. 
One other thing, the following is valid code in Java - the casts are not even a warning, and you end up with a List of MyObject that contains a MyObject2. There are plenty of footguns in development - removing these needs to be balanced against expressiveness, functionality and performance - otherwise everyone should probably just write everything in Haskell. &amp;#x200B; import java.util.ArrayList; import java.util.List; public class CollectionTest { private interface MyInterface { void dosomething(); } private static class MyObject implements MyInterface { @Override public void dosomething() { System.out.println("hello"); } } private static class MyObject2 implements MyInterface { @Override public void dosomething() { System.out.println("hello"); } } private static void myfunc(List&lt;MyInterface&gt; array){ for(MyInterface a : array) { a.dosomething(); } array.add(new MyObject2()); } public static void main(String[] args) { List&lt;MyObject&gt; list = new ArrayList(); list.add(new MyObject()); myfunc((List)list); } } &amp;#x200B;
I think I agree with everything, except for the issues you mention with Python 2/3. I've not had any problems related to the switch for a couple of years now.
i basically learned 1. js.Global() is basically the window. 2..Call() basically is how you get id/class tags 3. .Set() is used for calling js events 4. js.Value is a js value 5. js.NewCallBack() is how you pass functions 6. .Get() is how you get dom elements But I didn't see anything for changing css of an element? 
Experimentation is great indeed. \- it is not a "protocol", is it? it does not mention "protocol", "TLS" or "network", so I wonder where you read that, it is as the descriptions says: "a simple io.Reader/io.Writer NaCL/AE go interface" and a simple tool that uses it, it is nothing more and nothing less than an interface to [golang.org/x/crypto/secretbox](https://golang.org/x/crypto/secretbox) / NaCL in an io.Reader/io.Writer form. If you decide to use it as TLS and expect it to replace TLS, yes, you are wrong and your use case is indeed wrong. Regarding interface validity, the language contract is on the prototype/behavior afaik, there is no mandatory requirement of buffer being exactly the same size on both end that's left to how you want to use it, archive/tar and and archive/zip both implement io.Reader/io.Writer (and their respective data format define the size/format) and you cannot Write from one to Read from the other. As said it's not a protocol, nor network aware, nor whatever you seems to be worried about, it does not have a "structured data format", a very raw enveloppe for any kind piping you'd like to do in command line or in your code as well as an experiment. Thanks for the suggestion nonetheless and Noise is fun, but as you said TLS already fill all my network protocol encryption/authentication needs.
Wasm doesn't have any API for DOM manipulation at the moment as far as I'm aware.
Yeah there is only Go -&gt; JS -&gt; Dom. Eventually Go -&gt; Dom will be a thing.
Yeah I've been learning that creating my own type from scratch with the "syscall/js". Learned really quickly ``` just.Global().Get("document") ``` Is not a type. So I've been setting up a doc struct with js.Value properties to take the method values in so you can actually reuse some of this stuff. The examples on the wiki barely did that. They mostly did it the js way by just var a := js call. 
Any explanation as to what happened? 
Nope. They just said they're terribly sorry.
This does not work for me.
It‚Äôs just the DOM, so you have to .Set the css attribute. Honestly, it‚Äôs not as nice as ES6+ yet. Until someone writes a nice framework for DOM manipulation, it‚Äôs going to be like pulling teeth to do frontend in Go WASM. 
You can coerce what you want outside the stdlib: https://github.com/clbanning/mxj/blob/master/examples/reddit01.go
Yeah, I've been trying to, but I haven't spent much time with C. The only languages I've used seriously are C#, JS and Python (but only for quick 20-30 line scripts for pentesting). But I've spent a little bit of time with C and as I've been learning Go I've been thinking "Oh, this is kinda like C" or "This part kinda resembled JS". The way I think of Go is that it's a compiled language saying "I'm a scripting language mom! It's not a phase!"
Yeah, after looking at what you've done and also the Monkey language interpreter from "Writing An Interpreter In Go" I've figured out how it's done. Although now looking at a bunch of other code, I feel like this system (although it works) is too similar to other code around. I'm going to work on a new parsing system that doesn't involve object oriented programming and is hopefully just as powerful. 
I had the same issue too. 
Lost me at "Indentation based".
I have never understood how people can find such syntax pleasing or easy to read. Give me my clearly delineating braces any day.
Thank you! I might look inyo Swoole and Crystal, seems really interesting.
AFAIK you can't do .o files with golang. 
There is no problem if you are doing open source
Goffeescript
Reddit picked an amazing thumbnail for this post!
You're modifying \`chat.Users\` in \`Start()\` and you're reading \`chat.Users\` in \`BroadcastMessage\` from two different goroutines.
I might probably have any idea how to get rid off OOline struct. I need to pass user name and conn from HandleConn to Start
It's Go. Not Golang, not GO, not GoLang, nor GOLang. golang.org is just the domain.
Do you have a link? GitHub maybe?
[Here's the link.](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
It‚Äôs the profile pic of the github account. ü§∑üèº‚Äç‚ôÇÔ∏è
As I said in the beginning, if you're willing to give up type-safety, it's entirely possible to do so. But the reason Go doesn't allow you to pass a slice of a concrete type as a slice of an interface - even if the concrete type implements the interface - is that it isn't willing to give up type-safety here. Note, in particular, that the function could pass on the slice further and given that there is nothing distinguishing a "read-only interface slice" from a regular slice, it might unexpectedly panic at some point. So, you could also maintain type-safety by making the read-only-nes explicit (introducing read-only types). If you're willing to make the type-saftey tradeoff, you can always use `reflect` yourself - see e.g. [sort.Slice](https://godoc.org/sort#Slice).
A) That doesn't change the fact that the license doesn't require you to ship sources, only "relinkable" files B) there are several ways to satisfy this requirement: You could compile your program as .a files that you link into an executable and ship the executable and .a files for license compliance. In go, .a files are basically just tarballs of .o files. This might require some work to do, but if you don't want to ship sources, this is probably what you'd need to do. [https://stackoverflow.com/questions/15551293/what-are-a-files-in-go](https://stackoverflow.com/questions/15551293/what-are-a-files-in-go)
I think the UX can be improved, never let your users down!
Cool project. maybe consider adding color support?
Hey! There is a section for how to start with Go and a long article showing differences between a Struct and an Object, Value receiver vs Pointer receiver and more. You are right there is no much content because we are in state of getting more authors and we are working mainly on advanced topics which takes time to prepare! The main goal is to encapsulate everything you need to know under one roof and provide advanced content, build a community, focus especially on reverse engineering successful projects and all concepts around it. Thanks for patience! I wish there woud be more content right now as well!!! Stay tuned!
Write down your suggestions please ;)
Happened to me as well in the past, maybe someone reported it or some bot flagged it automatically. I'm sure it won't happen again.
As a non-American-with-English-as-second-language person myself, it was quite difficult to fathom what the speaker was really talking about, especially the "prove" part. He just went rushing though points without giving detailed explanation. He is in a hurry or something. I have always liked the way Rob Pike and Russ Cox talk, but something weird about this guy. And thanks to all the Go contributors for amazing release.
It could be a problem or could be a feature either way :) Thanks anyway! You made my day!
Funny, I've been thinking of doing something similar, but borrowing heavily from python's syntax and idiomatic style. I agree that a dynamic, interpreted language with channels, goroutines and interfaces is severely lacking (AFAIK). I just _really_ don't like the syntax of Og. Still, impressive work, and I think the rest of the comments should be a bit less negative.
body, err := ioutil.ReadAll(r.Body) **if** err != nil { respondError(w, http.*StatusInternalServerError*, "Couldn't read json body") **return** } **var** LoginDetails models.Login err = json.Unmarshal(body, &amp;LoginDetails) **if** err != nil { respondError(w, http.*StatusInternalServerError*, "Couldn't read json body") **return** } // Get matching user from DB **var** FoundUser models.User db.Where(&amp;models.User{Email: LoginDetails.Email}).First(&amp;FoundUser) // Check passwords inputPassword := LoginDetails.Pass correctPassword := utils.CheckPasswordHash(inputPassword, FoundUser.Pass) fmt.Println(inputPassword) fmt.Println(FoundUser.Pass) passwordCheck := bcrypt.CompareHashAndPassword(\[\]byte(FoundUser.Pass), \[\]byte(inputPassword)) fmt.Println(passwordCheck) **if** correctPassword == *false* { respondError(w, http.*StatusForbidden*, "Password incorrect") **return** } &amp;#x200B; &amp;#x200B; \^\^ Theres the code I'm using for the login function. (Directly using the bcrypt app now to check too and it's still giving me an error despite printing the same values..
Stared! Add a readme too üòÄ
Goffeecrypt // fixed
Thats great üòÄ
Relevant explanation for these: https://medium.com/dailyjs/the-why-behind-the-wat-an-explanation-of-javascripts-weird-type-system-83b92879a8db
And the terrible name. And the way-too-hip intro.
I would suggest some things: 1. Instead of writing a comment before some piece of code, use that comment as a hint to create a function/method that does what the comment said 2. You are repeating yourself move duplicated code into functions/methods and reuse them 3. ALL your server is in one file, did you consider moving definitions of structs to their own file? 4. The use of types can be improved, instead of creating an empty struct to use as the value of a map, create a constant with a name that represents that an use it, the value of the constant will be an empty struct, but it will read better
There are a few good standalone raft libraries in go, a bit of googling will let you find them. Don't implement one yourself unless it's for educational purposes. It's less trivial than it seems and will cause you to lose focus on your project. 
I've found this https://github.com/hashicorp/raft but the only documentation basically boils down to source code comments
That's how you document go code, that's how the entire language is documented. Use godoc to render it to be readable. There should be at least one more decent library IIRC. 
Much thanks for the feedback! 1. Good point 2. I would move "notify message" to notify function. I don't see any other duplication though. If you could point me, I would appreciate that. 3. Actually I didn't. I think I left structs in the file cause I was following a goal of readability. For instance majority of golang core files contain structs and methods in the same files if I'm not mistaken. 4. I don't think we can create const that represents an empty struct :( 
How about using a netrc config to specify credentials to use for https? It works for me with github (without needing the ssh insteadof rule), so I guess it can probably work for gitlab too... Example: https://gist.github.com/technoweenie/1072829
There is a middle-ground between "using etcd" and "writing my own Raft implementation" - mainly "re-use an existing Raft implementation" :) To build RobustIRC, we used [hashicorp's raft implementation](https://github.com/hashicorp/raft). You can also use [etcd's raft implementation](https://github.com/etcd-io/etcd/tree/master/raft) as a library. &gt; I'm creating a software that will run on multiple devices in a cluster. These are my requirements: FWIW, this list omits a whole bunch of important requirements to make this tradeoff. For example: * What are the consistency guarantees you need? Raft can provide linerearizability, but stronger consistency comes at a higher cost * Is the workload read-heavy, write-heavy or both? i.e. is it rarely written but read often? Or vice-versa? IMO the write-throughput of raft alone isn't amazing (the read-throughput *can* be better, but mostly when you opt for weaker consistency). Something like cockroachdb (which essentially shards raft) might be better * How many nodes? If you need even tens of nodes, you are going to want to scale the storage/replication layer independently - replication becomes quickly more expensive, the more nodes you have, so it is problematic if you can't do the consistency protocol among 3 or 5 nodes only. If you need more nodes than that, using etcd makes sense, as you can run 5 etcd-instances and have N instances of your software access them. * How important is durability, really? If the answer to any or all of these is "doesn't really matter, the workload is small-ish", I'd probably recommend using raft as a library, because it means your workload shares fate with the storage system, which makes it *far* easier to reason about how the system as a whole behaves (otherwise you have to spend time thinking about what happens if the application becomes separated from etcd). FWIW, the "rolling your own" alternative I *wouldn't* recommend. Raft is simpler than Paxos, but still non-trivial and it's easy to make mistakes.
You don't have to add ".git" to your imports ? That's what I was expecting, it's weird that it doesn't work for me
Oh, you mean like how our subreddit is golang. 
to get a rendered version of it, use `godoc.org/&lt;package&gt;`, e.g. godoc.org/github.com/hashicorp/raft 
Hey all, I've written a proposal for a new, type-safe tagging system for structs and struct fields. &amp;#x200B; This has been bugging me everytime I use Go so I finally thought about a solution and wrote a proposal. &amp;#x200B; Any feedback welcome.
Why is adding the .git on import statements wrong if it works?
It's not that it's wrong, but it feels weird, because it's never added on any other import
I don‚Äôt really see the point of this. You could just create a RegisterType function that you call in init and get the same benefits without new syntax. 
CockroachDB is basically wath I was going for before discovering Raft. Would you say running two separate Rafts (One leader for the cockroachdb and one for my raft service) would be a good idea?
The same argument could be applied to the existing tag system. &amp;#x200B; The point is to have the metadata directly on the structs, not in some other central location.
So I'm all for it and support your effort but I'm not sure what sets you apart from the other similar sites. Maybe something to keep in mind. 
\&gt;despite printing the same values Can you show \&gt;fmt.Println(FoundUser.Pass) ? It seems to me that FoundUser.Pass returns a raw passwords instead of the result of "bcrypt.GenerateFromPassword(\[\]byte(password), 14) " result.
Thanks!! Will update the changes.
&gt; but I need to run code on the leader. That's my issue IMO this is a bit of a yellow flag. You have to be aware, at lest, that there is no way to know that the leader is *actually* the leader (i.e. there might be two or more nodes that simultaneously think they are the leader). For any data and side-effect that flows through the raft-log (i.e. if you are not persisting data anywhere else and if you're not sending it out, essentially), that doesn't matter, because at worst you do duplicate work that then is discarded during replication. But then again, if your data flows completely through the raft log, you don't really *need* to run code on the leader anyway. *In general*, it would be preferable to a) use etcd/cockroach with linearizable reads (AFAIK that's not the default), b) only act on values read from the storage (guaranteeing that you don't suffer from split-brain stuff) and c) making whatever action you take on their basis either idempotent (e.g. by attaching the logical timestamp raft provides for the read, so that you can ignore actions that are already done). That way, you don't need to run code on the leader and handle split-brain scenarios. But in any case, you have to make sure that the system processing the side-effects is aware of what's happening, raft or not. It's theoretically impossible (AFAIK) to guarantee exactly-once-delivery, so even if you use raft and only run code on the reader, you need to accept that either a) occasionally side-effects get dropped or b) occasionally side-effects get executed multiple times. It's hard to tell exactly, without having a better look at the actual problem you are trying to solve. But doing distributed consensus is tricky and it's not simply done by bolting something on an existing storage solution. You should think hard about whether what you are doing in your application is actually correct during split-brain scenarios. That being said, "thinking hard" is made easier if your application shares fate with the storage code, so I'd tentatively recommend using an existing raft library here. And, if possible, trying to come up with an alternative architecture that doesn't require running code on the leader anyway.
[removed]
Having done work on a similar system (event tracker, 1ms P99), I definitely respect the authors having tackled this problem. I also appreciate that they took some time to give somewhat of an explanation of why I'm seeing good go-kit adoption recently by some established players over, for example, chi. They don't really solve the same point, which was obvious, but it's good to have more data as to why particularly people are choosing go-kit :)
Note there have been a few proposals very similar to this; for example https://github.com/golang/go/issues/23637 
I wonder if it could have anything to do with the ", mine just looks like this, but for github: &amp;#x200B; &gt;[url.git@github.com](mailto:url.git@github.com):.insteadof=https://github.com/ &amp;#x200B;
It sounds more like you just want distributed locks and a message bus (or load balanced calls) to distribute work.
Ah thanks for pointing that out, I missed that one while searching...
Thanks for the answer, the r/ was a type on reddit, I don't have it in my actual config, I got the same as you (minus the ")", which is a typo from you I assume)
It‚Äôs def a problem, since you can only have 1 client connected to the server at once... this is because you can‚Äôt run a client without the server, and if you want to start another client, the port already is occupied But ur welcome! Keep it up!!
imo choosing Thrift in 2018 is a weird choice, especially when you have other tools like gRPC / Protobuf.
I code in levels. If it won't work any other way without jank, it's getting added. The git config seems more janky.
Turned out that my User struct had a json property "-" set so it was removing the value set for it so it was always hashing empty string.
[removed]
At the moment, this is not really possible with the standard library. You ought to be able to do this by defining your own marshaling and unmarshaling functions for the types you'd like to have by implementing [Unmarshaler](https://golang.org/pkg/encoding/xml/#Unmarshaler). However, if you look at the type on that function, you'll note that there's nowhere to put or find the user map that you want to use. So using standard interfaces it's not going to work well. One option is to copy the standard library and change it to pass in some sort of value to the unmarshalers, which will also require you to define a new interface for that and implement the code that prefers it. This isn't _too_ hard, but it's a bit much at the beginning. The other option is to make a three-step pipeline. Instead of going XML straight to the final product, you can go XML -&gt; Intermediate -&gt; Final product. The intermediate will more directly represent the XML, and then there's a function that will run across that and return the final product instead. You may also have to go the other way for marshaling, too. I've had to do this for some JSON APIs, too, because I'm using the Go swagger support, but I don't want to expose my internal types to it. So I've got intermediate types that specify the API in terms of strings and ints and the other standard types, and then I've got code that will take those and turn them into my "real" types, validating them at the same time. It's certainly _convenient_ to be able to marshal straight into your target types, but in my experience, in the _general_ case, that's not really possible. Marshaling libraries that start getting too clever and powerful in trying to enable that is where you start getting the bad security issues where someone can run arbitrary code through your "convenient" unmarshaller features.
[removed]
They mention that most/all of their other systems (eg: Python/Java) already use Thrift for message serialization. Personally I'm more interested in why they went with RocksDB instead of pure-Go solutions like BoltDB or Badger.
yes it was, I've removed it. What about the citation characters in your example?
I removed it as well :-). the quote are used to set the value from command line, in the end, when you read the config, it shows exactly like you.
I strongly discourage you from using the etcd Raft implementation. I‚Äôve tried to do it before for a different project and it was not a good time. Here is a talk I gave about the experience: https://www.youtube.com/watch?v=c2RyuTyVHxE
free programming?
I meant: free code. Its not the most difficult thing to make. But if you want to have this made by someone they will probably want something in return for it. &amp;#x200B; Plus: the recruiter is very specific in what he wants. The log file and the [https://github.com/jinzhu/gorm](https://github.com/jinzhu/gorm) dependency, for example, are really unnecessary for determining the proficiency of the coder.
Very true. The slice would need another bit to mark it read-only during the creation. Still I am not sure the sort.Slice() that takes an interface is type-safe enough... there's a line. I think if the VERY common use cases of generics were reviewed, a simpler but workable and useful solution could be arrived at - would it be everything to everyone, no, but nothing ever is. Just needs to be useful and workable for enough people.
We do something similar at work but how come their qps is so poor? We get close to 6K QPS with Go and our solution is far more distributed. This is strange for a ad platform.
Btw, made a lot of improvements to the command line and web clients. Lots of bug fixes too.
Just curious: in your opinion, what's wrong with Thrift (especially when compared with grpc/pb)?
I felt the same way RE: oddly specific requirements being bizarre. I deliberately engineered in "talking points" and used sync.WaitGroup with virtually no good reason to do so. I also strongly coupled the models to the repository and put things in strange places (more on talking points). I've never thought of someone issuing a challenge as a way to get free code. I suppose the channel buffer fill/drain is nice as it's size is configurable via constructor, but what's that for a half-competent golang dev? An hour it took me.
[removed]
But I need to run code on the leader for other reasons that don't have anything to do with shared storage. I'll have a bunch of nodes that are actually real life IoT devices and these need to be told what to do by the leader. That's why I need to run code on the leader, because I need to coordinate the work among the followers. I was thinking that maybe I could take advantage of the Raft's leader election to do so. Also Raft is very much needed because I'll have a distributed database and consistency is very important. Sorry for not explaining that better before.
[removed]
&gt; The slice would need another bit to mark it read-only during the creation. I want to re-emphasize: This is not an implementation problem. It's a type-theory problem. The type-system of Go as it exists can't allow doing it. It either needs to a) add a read-only specifier *to the type-system* or b) accept lack of static type-safety in this case (which is also a change to the type-system). And the reason why it's not possible and likely won't happen, is that go wants to do neither. There is a c), which is generics, which will be able to express "a slice of some concrete type that is only known at the call-site" as a first-level concept in the type-system. &gt; Still I am not sure the sort.Slice() that takes an interface is type-safe enough... there's a line. It's not. It's just "the most type-safe it can be in the current type-system". And it's "going to be type-safe once we get generics". &gt; I think if the VERY common use cases of generics The goal shouldn't be to solve some common use cases. The goal should be to solve the top X usecases. I'm not convinced the use case you bring up is a) solvable without parametric types, b) in the top X of usecases for most sensible metrics of "common" and c) worth the price. FTR, what you are describing is exactly the way to solve this in pre-generics Java. And Java still decided to add generics, even though the usecase you are bringing up was already solved in exactly the way you are suggesting.
&gt; But I need to run code on the leader for other reasons that don't have anything to do with shared storage. I'll have a bunch of nodes that are actually real life IoT devices and these need to be told what to do by the leader. Why does the leader has to tell them? ISTM it would be better if they talked to the cluster and just took their instructions from committed values. Whether they read them from the leader or from a follower shouldn't matter. &gt; I was thinking that maybe I could take advantage of the Raft's leader election to do so. Yeah, but contrary to intuition, the Raft leader election doesn't actually guarantee that there is only ever one leader at the same time. It is very common in Raft, to have multiple nodes *think* they are the leader at the same time. It's just that the Raft replication protocol means that only writes by *one* of them will eventually end up in the linearizable log. If you take, say, etcd in linearizable mode, it will give you this exact guarantee: All etcd-clients will read exactly the same values in exactly the same order from the etcd-cluster. That's the guarantee you're interested in and it doesn't require you to know which nodes are the leaders. So, after this discussion, I'd change my recommendation to: a) use etcd, in linearizable mode. b) have one or more servers that read values from etcd. They are guaranteed to all read the same values in the same order. c) Have your IoT devices talk to those servers. It also makes sense to send the etcd timestamp with every message to the IoT devices themselves. Because they *might* switch between different servers for different requests and then receive stale values. If they send the last logical time they know about with their request, the server can then wait for their etcd-connection to catch up with that. --- Sorry, I know this is complicated, but that's because distributed systems are difficult :) I hope what i wrote here helps and lets you come up with a working design :)
&gt; Not candidate but leader, maybe waiting for one heartbeat just to make sure he's the only one or something like that A Node can never be sure that it's the only leader. That's not how Raft works. For example, a new election could've taken place and finished, while the response to their last heartbeat was stuck in a network buffer somewhere. Don't rely on Raft leaders being unique. FWIW, I recommend [The Secret Lives Of Data](http://thesecretlivesofdata.com/raft/). It's been three years or something since I looked at it last time, but AFAIR it brings up these scenarios, where two nodes think they are leader at the same time.
Thanks for sharing. I hadn't seen ginko used "in the wild" before, is an interesting tool! A few thoughts on project structure: * Loving the use of the cmd/pkg/assets hierarchy. But I notice most of the business logic is in an internal package. Some of the benefits of putting the main package(s) under cmd is that you can have multiple binaries, or to share the business logic (namely internal/app/coinjar/coinjar.go) as a package that can be used in other applications. If you don't intend to do this, then it's reasonable to put the main package in the root for easy discovery. Although in this case it would be a preference decision. * internal/app/coinjar includes code for a number of different areas, and could potentially be broken down into separate packages. Certainly handlers.go could be placed in a separate package to coinjar.go since they have very different concerns. * The CoinJar interface could be placed in a separate package to the StarlingCoinJar implementation (coinjar and coinjar/starling respectively). This would allow you to add different backends at a later date without having a dependency on all of them at once. You could also create fake backends for testing that could be used across multiple packages without being compiled into the production binary.
I only meant, if I call sort.Slice() and don't pass a slice, the code panics. So saying Go is type-safe right now is not accurate in my opinion. Just because it is documented, in a large an dynamic system you might not know when/how this method is called. It is not as if I am calling unsafe.Slice() where the panic might be expected. So given that Go is already statically unsafe, all I am is suggesting the simplest (mainly to use , but also to implement) way to attack the common (call it top X if you like - still an opinionated list) use cases. Anyway, after more investigation I am of the opinion that generics are not a worthwhile addition to Go, and I honestly believe the community is going to come to that conclusion to, so then we will see where that goes...
If your repo is in a subgroup, you might be running into this issue: [https://gitlab.com/gitlab-org/gitlab-ce/issues/37832](https://gitlab.com/gitlab-org/gitlab-ce/issues/37832) Seems like this was by design (tradeoff between security/privacy over usability), in order to prevent leaking private groups and projects.
mutating any container as you iterate over it is just a recipe for disaster.
your issue is that the player you get out of the range is just a copy. Modifying it doesn't modify the original inside the array.
\`atTable := make(\[\]Player, 3)\` Is creating a slice of values, so in the second range loop, you're actually creating a new instance of the player each time. If you were to create a slice of pointers: var atTable = \[\]\*Player // append new &amp;Player{}s The range loop would be operating on the values referenced by the slice itself. &amp;#x200B;
I can understand the "reason", but I don't think it makes it "always unsafe". If the operation creating a copy of the []concrete into interfaces to call []interface, then it could just be language definition, that writes to the array will not be reflected in the original, and caller beware. The other methods, like a read-only flag on the slice, are add-ons and not strictly required. It is no different than calling sort.Slice() passing a non-slice and having it panic. If you call method([]interface) passing a []concrete, any changes are not reflected at the caller it's just part of the specification - since you can't do that now at all, it doesn't break anything. I don't see it as materially different than how the expansion of slices work - if you don't assign back to the source, it probably isn't doing what you expect - but the code still runs without crashing.
Reddit does not allow user-created subreddits with names short as "go". You can try it.
_implying name "Go" is not terrible_
I thought that it had something to do with that mode of copying, but I had no idea how to implement the solution with pointers properly. &amp;#x200B; I think I got confused by the definition of slices as being pointers to a data structure themselves. So, there'd be no need to address them by reference as they would've been modifying the underlying data structure to begin with. I think I'll need to spend some more time going through this topic.
The variable referencing the slice is a pointer, but the contents of the slice may be complete values. I've been caught out by this a number of times (also by the fact that the same memory is reused for range values). Let me know if you have any more questions about it, happy to help.
You could avoid using reflect in https://github.com/knrt10/asciiConvert/blob/master/cmd/root.go#L49 and rewrite: y := reflect.ValueOf(g).FieldByName("Y").Uint() as: y := g.(color.Gray).Y 
&gt; If the operation creating a copy of the []concrete into interfaces to call []interface, then it could just be language definition, that writes to the array will not be reflected in the original, and caller beware. I also told you above [what the downsides of this idea are](https://www.reddit.com/r/golang/comments/9d4yl8/how_the_go_runtime_implements_maps_efficiently/e5lpiwy/). TBH, at this point you don't seem to be interested to understand the reasons why Go is as it is, as much as wanting to disagree with them on principle. I think you're going to have to make a determination to take Go including the decisions you disagree with, or build your own language and make your own tradeoffs.
The answer is, it-depends. For a first party adserver, lot of CPU intensive features are run, which process a huge number of objects, and run complex algorithms. 
That doesn't help - you'd still have to setup authentication for the proxy.
 wget https://github.com/golang/dep/releases/download/v0.4.1/dep-darwin-amd64 chmod +x dep-darwin-amd64 mv dep-darwin-amd64 $HOME/bin/dep # or $GOPATH/bin/dep, or /usr/local/bin/dep
There are examples on the official doc: https://godoc.org/math/rand#example-Shuffle &amp; https://golang.org/pkg/math/rand/#example_Shuffle
&gt; the same memory is reused for range values So, range operator then makes a shallow copy of whatever value is passed to it, right? And if I want to manipulate the underlying data I need to pass the values by reference. Is that what you mean?
Thanks :) but it's the same example i linked in the post... So unfortunately don't get me ny closer to the solution..
Uh OK. I didn't read the screenshot before because it's a screenshot. In that case, please see: https://www.reddit.com/r/golang/comments/9epvt5/range_operator_in_the_loop_what_am_i_missing/e5qlrju/
1. \`e\` is string, the examples were based on byte arrays. I'm not sure if you can access runes of string that way. 2. Even after you manage to get this working, you are changing a copy of the elements in the \`words\` array. You should use: \`\`\` for i, \_ := range words { e := words\[i\] } &amp;#x200B;
The example is not the same as what you did because it operates on a slice of strings, whereas you operate on a string. You could cast to \[\]byte `b := []byte(e)` if you want to scramble individual words.
Yup, that fixed it! And thank you for the advice, the copy/original thing in go is something i dont stumble upon as much in other languages i use. Still not used to it :)
Yeah, what I ended up doing, fixed it :) 
Original slides available: [https://github.com/devalshah88/gophercon\_talk/blob/master/gophercon\_slides.pdf](https://github.com/devalshah88/gophercon_talk/blob/master/gophercon_slides.pdf)
Ouch ... Wasted [https://media.giphy.com/media/gXafk5v7CTVgQ/source.gif](https://media.giphy.com/media/gXafk5v7CTVgQ/source.gif)
This is a separate issue from your code example (I was mostly ranting with that point, sorry). If you have a slice of pointers, and assign the range variable to something you will always end up with the last item in the slice, because the range variable uses the same memory each time you go around the loop.
Hello /u/elwizaracom üëãüôÇ
This post has nothing to do with the /r/golang subreddit ü§î
[You and your friends are spamming Reddit.](https://www.reddit.com/domain/pushmio.cf/new/) https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer
I'm pretty sure they're all the same account. The wording is identical. It's a really dumb website.
Rocks is design to optimize writes. 
This kind of crazy syntax seems to be "the new thing" in all these toy languages sprouting about... i was starting to wonder if i was the problem because i dont find it pleasing at all
Even easier if you don't want to manually unpack the files, you can use the `install.sh` script and override the version using the `DEP_RELEASE_TAG` envvar: ``` $ export DEP_RELEASE_TAG="v0.4.1" $ curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh ``` I had to peg my dep version to 0.4.1 on Mac because 0.5.0 wouldn't work properly. To be honest, haven't bothered to update since.
[removed]
[removed]
It was really chosen more like 2015/2016, when open source gRPC was still in relative infancy. I'm not sure if we would make the same choice today. Source: Reddit dev (though not the one that gave this talk)
Thanks 
This is a very excellent talk, and even the source code he uses to illustrate is interesting. After watching it twice, and trying this design out myself, it occurs to me that you can't really have parser -&gt; lexer feedback, which happens all over the place. C's typedefs, at least, and let's not speak of C++ parsing. I mean, maybe you could if you were super careful about how many tokens ended up in the lexer-to-parser chan, but even then it seems dicey. Is parser to lexer feedback a problem with this design?
reddit's infrastructure in general is super trash. their api sucks and has a ton of undocumented issues and legacy code bugs that are quite literally 1 line fixes that they dont bother to fix. That python codebase https://github.com/reddit-archive/reddit is awful. They're definitely bottlenecked at the reddit integration side or maybe just don't have quality engineers that know enough to performance tune python let alone go.
hmm I didn't know what it was so just did a fast google search, seems to be this will save the data in json format.. such thing I do not want.. I want the data in good old plain sql so I can use it as sql. I they also have a xml option if that is easier.
https://golang.org/pkg/bufio/
yeah I saw this.. but did you see all the manual work doing output? I was hopping for something opensource that will just parse the file and create the sql output to dump it later mysql &lt; result.sql or similar I saw commercial tools and online tools that allow for free only 50M etc but this is way more than that. if python can do it I find it hard to believe there is no libs for that on go. 
First of all, I feel ya. I am not a pro in either but I absolutely hate fighting with the front end and love the backend work a lot more. As far as useful advice, I don‚Äôt think what you want exist. You really have to options, either stick with what you know, specifically Bootstrap, ionic, etc. Or just take the leap and jump on the react band wagon, this will give you a huge headache at first but you will be able to write a much better front end and even get into native app development with react native. You will have to learn more JS than you care to know but JS have become a necessary evil. Especially that other languages are copying its features now to capitalize on the wide spread knowledge of JS. Same as JS copies java syntax to do the same. 
Hi, I'm no good in CSS either. Html/template + vanilla JS + materialize css did the trick for me. I hope it helps.
You should be able to pipe the data into your postgres client via STDIN
&gt;Thanks. I might have to give Materialize another look. Mostly I want the out of the box styling I can tweak and a really really really easy grid that keeps me from having to fight making a vertical full screen app. I I don't want to have to adopt a whole framework and npm build environment just to get started. 
I think converting a slice of runes is better so unicode works correctly. r := []rune(e)
&gt; I say is way to many to do manually do with out making a mistake or missing one, code has to do it itself so there is no mistake. In that case, I would just copy all of the data into a jsonb column as the other commenter had suggested. You can write a few queries which normalize the data afterwards.
thanks I will put some focus on jsonb as long I can convert to pure sql later, the idea is that if I want to share my program, so I can just or give the .sql dump so people can import themself or a side tool that will download the latest cve's on json and convert it to a .sql dump.. this way avoiding for the end user complications, is already complicated for me :D 
TJ Holowaychuk https://github.com/tj
since I see no much success finding a go lib or open tools.. did anyone use this before? [https://sqlizer.io/signup/](https://sqlizer.io/signup/) looks very promising and is cheap, I only need to do it once a month when a new update comes out. 
With JSONB you can have everything SQL from indexes on fields to JOINs. pg is a nice Go ORM, specialized for PostgreSQL which saves embedded structs as JSONB fields. [https://github.com/go-pg/pg/](https://github.com/go-pg/pg/)
I never used that but I have used https://sqlify.io/convert/json/to/sqlite which is free and doesn't require signing up.
I already try that.. I keep telling you guys to check the links.. this is huge... and is for every year. You've reached your plan limit. The file provided contains 199190 rows, please upgrade your plan to convert unlimited rows
Hmm didn't do a full read through as I'm on mobile. Regarding the large interface though, my first thought is to break up some of the more "CRUD" type functionality into separate interfaces, e.g. one for webhooks and another for emojis. Idk if that's very idiomatic in go though. Maybe I'm just too used to seeing this kind of code in very OO heavy languages like c# and Java. Seems pretty solid though, man. Love the name too :p
is actually cheaper than the other one for the amount of rows that I have, I may give it a try
Great article, really well structured! Unrelated to the Go part but I‚Äôm curious about the streaming Spark jobs.. How do you ensure their reliability? Do you preserve state in case a job crashes?
I agree with your comment, one thing worth adding is jsonb uses up a lot of disk space so if you have TBs of data, you should take this into account.
Jsonb is Postgres.
As far as I remember JSONB uses far less space compared to JSON. It is the JSON type that uses lots of space. But you might be right about GIN indexes for they might be using a bit more space than normal indexes.
The `player.Hand` stores a shallow copy of the slice. That means it stores a copy of the slice's 3 internal "header fields": p(ointer to array) &amp; len(gth) &amp; cap(acity). When you append, the shared underlying array may get modified (unless a new array is allocated when cap is not enough); but only the header in the shallow copy is modified. So, the original `atTable` contents doesn't see increased length. See also: https://blog.golang.org/slices
Anything you do to avoid learning CSS will very likely end up being more effort and pain in the long run. If you're truly KISS then you shouldn't need for the website to look incredible so you wont need to learn every facet of CSS to do this. &amp;#x200B; Learning CSS is a skill which will remain relevant for you for many many years, just do it.
Is a valid point , I will make sure we stand out ;) Thx!
The point of the talk was to give an overview. If something interested you and you want to learn more, you can go learn more in depth after the talk. The "prove" stuff is super interesting but would not be possible to cover in a single talk alone. It's true that I err on the side of talking too quickly (to not bore people, at the risk of alienating some), rather than talking slowly (which reaches more people, but turns some people off too).
As with all security questions, you need to ask yourself a bunch of questions: what are you protecting against? What is the cost of failure? How much pain are users / clients willing to put up with in the name of security? How much can you afford to spend on security? How fast do you need to be able to respond to an attack in progress? How soon do you need to become aware of a security breach? Once you've answered all of those questions, you're usually left with a solution space of zero size, and need to go back and reevaluate until you've given yourself an option or two. There's everything from a full blown OAuth2 implementation with client IDs and secrets with per-user and per-application quotas (think AppEngine Cloud Endpoints) all the way to secret API keys in HTTPS headers, or even no authentication at all. TL;DR: we'd need to know a lot more to give you just one answer :)
And limited content. It is a great idea though.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Go, Rust and the cost of brain power ‚Ä¢ r\/golang](https://www.reddit.com/r/programming/comments/9evydw/go_rust_and_the_cost_of_brain_power_rgolang/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
[removed]
I don't like apps that are too JS heavy.
Thanks for taking a look :D I'd thought about point 2 and had decided that it's a simple enough app that that would introduce more complexity for little gain. Since I'm hoping to add more features though I'm going to probably end up doing this. Point 3 I'm definitely going to do. I had thought about it at the time but I was still wrestling with how packages functioned so didn't get it done.
The whole aplication is a API, there will be a admin SPA to users manage and control the solution and runners that will do things and send it back to the API. And yes, OAuth2/OIDC is needed to integrate with Facebook, Google, etc.. but still gonna have plain old password logins and i can't figure out yet how to use this. Create a session with a token? About the runners, it's a whole diffent story, no human involved, just a daemon running exchanging information with the API. I'm seeing lot's of people saying to not use JWT: [https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid](https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid) &amp;#x200B;
Gave more details at the answer to titpetric.
[removed]
Arguably "inheritance" is what differentiates OOP from older modularization ideas. That's called "embedding" in Go. The article mentioned it but did not explainit . Here, Admin "inherits" User. https://play.golang.org/p/2jZMCGEfxW
Neat. I assume you accidentally found this when attempting to pay respects to a deprecated API.
I honestly expected more. This article is basically "Rust is hard, Go is enough". Just as a disclaimer, I learned Rust in the past and decided against continuing with it. But I still see a lot of benefits that can come from Rust's features. I am freaking tired of `nil pointer dereference` for example. Data races are a big trouble, especially when dealing with someone else's code with no unit tests. Sum types are great for modelling some systems. Rust's `Error` trait has always had a `cause()` method for better wrapping. There is global mutable state, which lets stupid people do stupid things. I don't mean to say that Go is a bad language. But Go without nil, without global variables, and with more compile-time checking would probably be a better language (for me, at least).
My take is that in a commercial setting, Go likely makes more sense for a software house? Easier to hire for, less cognitive overhead. What's your take from that perspective?
My take is that in a commercial setting, Go likely makes more sense for a software house? Easier to hire for, less cognitive overhead. What's your take from that perspective?
&gt;My take is that in a commercial setting, Go likely makes more sense for a software house? This is undeniable. But the root cause of that seems to be the fact that in order to really understand The Rust Way, you need to be an experienced C++ programmer willing to change to a less stable language with less libraries and tools. &gt;Easier to hire for, less cognitive overhead. There is always a trade-off between these things and other things, like correctness and speed. If they were to hire only "easy" people who don't like "cognitive overhead", they would just end up in a shop full of That-dynamic-weekly-typed-language-everybody-likes-to-hate-on programmers.
https://github.com/niemeyer/gopkg/issues/63 It was fixed but broke again. Note that it is GitHub's issue.
Is Go a pigeon?
You can‚Äôt make a webpage without the DOM*, so using GopherJS or WASM doesn‚Äôt really help at this point. If you don‚Äôt want to learn CSS, you can try Bootstrap or Bulma. Those vastly simply the design process. \* well, there is Canvas but that‚Äôs also hard. 
This. I call this pattern the "Unwrap Culture". Instead of getting a panic when dereferencing a null pointer you now have... a panic when dereferencing a null pointer? `unwrap` is cancer. Even the introduction of the `?` operator doesn't solve this. They should outright ban `unwrap` in Rust 2021 or whatever the next edition will be.
[removed]
"At NinjaDojo, we recognise that our language of choice for our stack is ultimately pretty boring. Without a doubt it lacks features that some have come to expect. It ruthlessly prevents you from working out creative ways to get around its limitations. Nil pointers will strike if you don't account for them. These are all the result of a compromises that were made to keep the language simple" &amp;#x200B; I remember a scientific article about how the language affects the way how you think...like tribus that have totally different names for different scales of the same color, this makes the whole tribe able to distinguish and identify much more colors than the rest of the people. At the end the autor talks about programming languages and how this can be applied to programming languages too (that at the end it's more similar to speaking languages than people think). &amp;#x200B; I think that go is great for productivity, "get the shit done", but at the same time when I program with go I'm less creative and clever, although that can be good in some circumstances...are here people with experience in functional languages or languages like ruby, perl,smalltalk (python doesn't count because it's very 'one way') that can give us your opinion about if think different when program with go compared to these languages???...
[removed]
Any real security that a regular developer does is going to have challenges with security. There's a reason it's an entire field of study. To that posts points, they have an idea and framework they are working on to likely sell. Pretty much, half true and half FUD marketing. As such you need to pick something and just learn the good and bad about it and implement it. Many companies and developers use jwt for security just fine. It means you need to understand the approach and it's issues. 
And right at the bottom of the page: ‚Äúthis project no longer maintained‚Äù. Pretty much sums up the lifecycle of my open source projects. 
And this, my dudes, is why you vendor.
From where did the quote (sic!) ‚Äúthis project no longer maintained‚Äù come from? Definitely not from the OP link. What you can actually see there is &gt; 2018-07-01 This **package** is no longer maintained. Please see the **v2 version** at &gt; &gt; https://github.com/cznic/cc/tree/master/v2 (emphasis mine)
It is good to see people recognizing this. Go is not object oriented - no "like"s, "resemble"s or the likes. That notion is a recipe for disaster.
I disagree, but it should probably require explicit opt-in. I use unwrap during prototyping because it saves time, and I occasionally use it in production when I've already checked for errors. There *are* legitimate use cases, but I agree that it's overused and unnecessary.
Rust just isn‚Äôt that hard guys... I got productive with it in a week. Yes I still have to look things up. But my god it‚Äôs nice in rust land. You just need to code one non-trivial thing in rust from scratch and struggle with the borrow checker a bit and learn the main enums like Option&lt;T&gt; and Result&lt;T&gt;. Go is great. Rust is great. Learn both. Use both. 
I downvoted because I did *not* in fact imply that Go wasn't a bad name. It is a horrible name. But saying that OgLang is bad *is not* implying that GoLang isn't.
Hmm I wonder if you could have a resource interface and then a struct for each resource type e.g. guild/channel. So your session interface can have a method like Get(resource) and you can pass in a pointer to a resource struct and return an error. Then in the Get method you can call the resource's implementation with necessary session tokens etc. The pattern comes to mind with marshaling in go. If the method isn't supported for a particular type, maybe have a typed error. 
thx for feedback dcOd!
OOP is great, is not terrible, is only not pragmatic or useful in concurrent/parallel world where programs communicate via events/streams instead of one stable state. Thx for feedback!
I'm also having problems today with multiple packages with the following error: go: gopkg.in/fsnotify.v1@v1.4.7: unrecognized import path "gopkg.in/fsnotify.v1" (parse https://gopkg.in/fsnotify.v1?go-get=1: no go-import meta tags ()) I'm guessing also due to github issues based on: [https://status.github.com/messages](https://status.github.com/messages)
I totally understand that doing both is just a pain but the benefits are huge. It's a real pain though. The benefit though is that you just have end points and you don't have to implement a go system in your code base. You can actually just have it make data somewhere else. Also, templating is a heavy load on the server which I'd imagine is expensive. Point being you won't have to mix code, it'll actually make you delete code. So your initial coding will be a giant pain but your end effect will be amazing. Here are my resources on it but if you need a repo I'll pm you it. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
I don't see why people do this, the very next sentence points to the v2 version, which is.
I think a lot of people mix up "way of doing things" with go's concept of types. What I mean is when you do js you tend to throw things into variables and do object.property.method.another-method. The issue that I think sorta happens is that people who use js are doing two things. 1. Using really high level code. 2. Working under a really productive environment. What ends up happening is what many know when working on couple year old code bases or they are simply there to ship apps out as soon as possible. I believe many companies that use go tend to be big cloud or API infrastructures that are planning to keep their big code base. Too many times I see online this environment get mixed up with others and the need to be productive. I really almost never see these two environments get expressed explicitly in threads. So you get this back and forth between what's important to people or businesses. It's almost weird to read day after day when no one talks about these needs. Sure I'd like to say they shouldn't of built js in this way cause it's hard to be reusable but idk all environments people are in. 
Have you tried [duit](https://github.com/ktye/duit) or [Nucular](https://github.com/aarzilli/nucular)?
I always hate that guy that deviates from the specific question to mention alternatives, but I am going to be him. Is it unreasonable for to write a translation layer to/from your existing items from/to more serializable structs? There are other benefits to this too (i.e. security issues, inadvertent field additions don't accidentally explode your size, clarity of what is sent, etc).
&gt; I am freaking tired of nil pointer dereference for example. Data races are a big trouble, especially when dealing with someone else's code with no unit tests. Sum types are great for modelling some systems. Rust's Error trait has always had a cause() method for better wrapping. There is no global mutable state (IIRC), which lets stupid people do stupid things. The thing is that all of these can be (and are) solved in other languages, but rust tries to do it without a garbage collector. So dealing with the complexity of rust only makes in domains where having a GC is unacceptable, which on modern computers is relatively few.
well, even when you vendor, if your code is on github and github is flaky/down, it ain't help a bit :)
&gt; There is no global mutable state (IIRC) Yes and no. The most obvious global mutable type, a `static`, requires `unsafe` to use, so most people don't. If you just need global state, lazy-static gives you that, and if you need it to be mutable but safe, you have to use a wrapper type like RefCell or Mutex to give it to you.
Implement [`encoding.BinaryMarshaler`](https://golang.org/pkg/encoding/#BinaryMarshaler) and [`encoding.BinaryUnmarshaler`](https://golang.org/pkg/encoding/#BinaryUnmarshaler) on your types.
What most people disliking unwrap seem to miss is that a panic is a controlled and clean termination of the program (even giving you a stacktrace), whereas a segmentation fault, due to a null pointer deref for example, is a safety mechanism deployed by your OS and hardware to prevent your bug from causing more serious troubles. Null pointer derefs happen by accident, unwraps are explicit. Don't like the unwrap? Replace the `.unwrap()` call with error handling. Don't like the segmentation fault your C program is producing? You better bookmark those GDB shortcut webpages. unwrap is only a problem when it is used unnecessarily. It's a form of assertion, stating "this `Result` is an `Ok`" or "this `Option` is a `Some`". Assertions are useful for producing hard errors for things that really should not happen. Not everything is a soft error that can be digested sensibly by your program.
It's normal. You can expand it and see what it is -&gt; 4 lines of setup calls. It's setting environment variables, building the executable, then running it.
Let me reprhase it, I think Go is not primarely object oriented. Inheritance/Composition are only additional features as history shows. Go was designed for concurrency and paralelism, Objects were not.
^^ Yep There's probably a line somewhere for posting code that is inappropriate by its very nature... but this isn't it.
Yay more go conferences!
We're talking about *Go* and Rust here. In Go it is also a controlled panic, and it is much better than what you might get in C/C++. But it's still a runtime error that could have been avoided altogether if the language forced people to actually think about what happens when their assumptions are broken.
Thank you so much, I'm relieved. &amp;#x200B; The first time I saw it was when I had incorrectly setup my GOPATH, So I assumed it was an error or a warning. I'm slightly annoyed that I just spent an hour trying to figure out and fix something that is fine.
I disagree, sometimes you know for sure your `Option` can't be `None`, for instance, just like you can know for sure your pointer is not nil or your slice index is valid in go. Imagine if we gopher had to do `if err != nil` every time we were trying to dereference a pointer or index a slice, because, hey, you never know.
Plus you can downvote everything. E V E R Y T H I N G
Go *is* object oriented. Object orientation is just encapsulated data + logic. Go has that. Go doesn't have inheritance, and you're right, don't try to do inheritance in Go. 
Interfaces can only be fulfilled by values that have methods on them (objects), so I'd have to disagree with you there. Types with methods have existed since before 1.0. It was definitely designed with OOP in mind, just not inheritance.
My primary language is Scala and I lean more on the functional side than OOP side of that community. Most functional solutions to problems I‚Äôve encountered can be closely reproduced in Go, though they are sometimes not idiomatic Go and can cause performance issues. There are some language features in Scala that are missing from Go that make things much easier or encourage functional programming such as pattern matching, type hierarchies, collections manipulation, algebraic types, and an emphasis on immutability. I suppose with generics on the way, libraries can blossom up for algebraic types and functional collection manipulation, though you have to weigh the pros and cons when choosing libraries that change certain fundamentals of programming in the language. 
in what world is this a controversial comment!?!? upvote this man, Jesus Christ reddit
It's odd though: the v1 package is "no longer maintained", and the v2 package is "Work In Progress. API unstable." Hmmm.
Formatting for /u/Emacs24's code and last sentence (you need 4 spaces stackoverflow-style): type ReadResult oneof { Bytes int EOF struct{} Error error } type Reader interface { Read(buf []byte) ReadResult } ‚Ä¶ buf := &amp;bytes.Buffer{} tmp := make([]byte, 1024) for { switch v := file.Read(tmp) { case Bytes: buf.Write(tmp[:v]) case EOF: break case Error: return fmt.Errorf("failed reading stream: %s", v) } } ‚Ä¶ I mean, you cannot forget about unhandled choice ‚Äì compiler should raise a question about it and you will not pass `EOF` you easily can with Go.
Furthermore, Alan Kay invented the term "object oriented", and his original conception [did not have inheritance](http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en). So Go is definitely an object-oriented language. Sometimes C++ or Java programmers like to argue that Go isn't OO because it doesn't have inheritance. I like to respond that in that case, C++ and Java aren't OO either because they don't use message passing, which was a vital part of the original definition of OO.
This is a pitfall I actually fell into as well when I first started with Golang, having a background in OOP. Just for the sake of informing you don't "inherit" the method from the embedded struct in your example. Your structure just embeds another one within itself and can call it's method, but it's not that the "parent" struct has inherited that method, Go just dereferences to the embedded struct's method automatically. &amp;#x200B; It's actually a lot easier to view and understand when you commit the mistake of embedding 2 structs with the same method name and Go doesn't know how to react, in which case you have to specify which of the 2 structs to call. An example [https://play.golang.org/p/Dmk8H4oOaDX](https://play.golang.org/p/Dmk8H4oOaDX)
Pretty sure that's how reddit works by default.
The talks from the main auditorium only have audio in the left channel, bummer. The breakout sessions seem fine.
wouldn't JavaScript fit your definition better than Go?
One of the big rules is that only the sending side can close a channel to signal, and that only if it's the only sender. If you ever think you want receivers to close a channel, what you really need is a second channel. Then, every time the sender sends, it uses a select statement to both send on its channel and check the "return" channel for being closed to signal termination. I'm reading between the lines (since your post doesn't have a lot of details, after all) but there's a good chance that's your core problem. If not, well, it's still a thing to know.
The object (in the grammar sense) of my comment and that of the person I was replying to wasn't about Go, it was about Rust only. I mentioned C to give a comparison. I can't comment in any way about Go since I've never used it, I'm just here to offer different perspectives on `unwrap` in Rust. You're describing the misuse of unwrap in Rust and the analogue in Go. I completely agree with you, wrong uses of unwrap are problematic. The misuse of a (generally good) feature of a language is not a problem with the language though, but rather with the programmer. Learning to use it correctly is part of the learning pocess of the language, just like everything else. You also can't assume that a programmer who doesn't understand the implications of unwrap is able to express his program's error handling clearly in code. To some people, the program either succeeds or dies. If you take away unwrap from such people, they probably won't add proper error handling but will rather find other ways to implement their "something-went-wrong-get-me-out-of-here" function.
&gt;in order to really understand The Rust Way, you need to be an experienced C++ programmer &amp;#x200B; That's a big misconception IMO. Rust is very different from C++. Especially the way you structure your types and organize your code is a totally different world (traits, no classes or inheritance, ..) It's probably better to not know C++ because you have to unlearn a lot of habits. Rust is difficult to learn though, I'll admit that. &amp;#x200B;
First talk is good compilation of questions to prepare for a job interview.
I don't have a problem with either and don't think "the old guard" need to go anywhere either. Plenty of minds for all. Plenty of hands and enough neuro-plasticity to use a variety of tools.
[removed]
There is no inheritance in Go.
I think it really comes down on how you define Object-Orientation. And in my opinion what the mainstream considers OOP is simply wrong. Neither Classes nor Inheritance are mandatory for it (see prototype based languages). I really like to mention Alan Kay here as he is the most important figure in coining this term. He created Smalltalk and developed a lot of theory of OOP. I just can highly recommend reading this article https://medium.com/@atherlangga/retracing-original-object-oriented-programming-f8b689c4ce50 about Kay's ideas. It is lengthy but absolutely worth the read. The TL;DR of this article is: &gt; So, there you go, the key ideas of OOP are: &gt; &gt; 1. Messaging &gt; 2. Local retention, protection, and hiding of state-process &gt; 3. Extreme late-binding of all things Good examples of OOP the article mentions are: LISP, Smalltalk, JavaScript and Erlang. So Go is not a good example for an OO-language but really interfaces come here to safe the day. IMO all languages that support dynamic dispatch are OOP to some degree and so Go is.
K, that's what I needed to hear. I am currently in the middle of my own "non-trivial" thing and to be honest, I hate Rust and love it at the same time. Your comment is giving me the motivation to continue.
Are there any reasons to have it at all, even with `unsafe`? Dave Cheney has an [article](https://dave.cheney.net/2017/06/11/go-without-package-scoped-variables) where he ponders, what Go without package-level variables would look like, and he concludes that the only actual reason to use them is some form of global "database", like Unicode tables, which in Go cannot be `const`. In Rust any type can be immutable, so why the need for mutable global state at all?
The issue is that the fields are unexported, so nothing else has access to it. Consider a simple encoder that takes all the bytes and just copies it. Your struct, which happens to be 20 bytes, gets cast as a 20 byte array and copied to a file. However, your struct holds a string, which is itself a slice (pointer). So, when you read those 20 bytes back into memory, the string will point to a slice that doesn't exist, and be complete garbage / fault. So, to properly encode, you *at least* need to know the types of the fields, to know whether it's a pointer that needs nested copying.. Which is only possible on exported fields, which is the very point of exporting fields. If your struct contains only non-reference types, then you can just do a direct memory read of the size of the struct, and assuming you use the *same* binary to read it, it will mostly likely work most of the time, with very few guarantees about anything. The realistic solution is to export the fields (whether by uppercasing them directly, or adding methods that export them as others suggested).
That's the [diamond problem](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem) which you face in all languages supporting some kind of multiple-inheritance.
Ooh this is interesting it does seem I could be mistaken, then is it correct to say that embedding structs is inheritance of methods? 
Thank you!
You can write C++ without creating any objects. You can write Java with just one class. You can write Perl 4 style Ruby. You can write Common Lisp with no objects. You can write functional JavaScript. Nevertheless, they're all still OO languages. OO does not require inheritance, and does not require that you write in Java style.
That's not the same API. io.Reader can return n&gt;0 and err!=nil. On purpose.
Get free temp email id for life time use send directly yourname@stopee.com https://www.stopee.com
&gt; you could write perfect Go [...] without creating a Struct The fact that you can write obfuscated or unnecessarily complicated code is not an argument against Go being object oriented. 
These sorts of things more typically occur because the senior engineers behind the recruiter want to have something to talk about with you. Some people dislike the homework assignments, but personally I'd rather have a 2-3 hour project and then be able to discuss various ideas and options around a piece of code I wrote, than whiteboard-style draw-out-this-algorithm.
There's an easy way to listen to those with fixed audio: * Open VLC -&gt; Media Menu -&gt; Open Network Stream -&gt; Paste Youtube URL * Audio Menu -&gt; Stereo Mode -&gt; Mono
Well, "obfuscated or unnecessarily complicated code" is your subjective perception ;) I dare to object (see what I did there? :D), such a code is actually much more straightforward and easier to maintain in comparison to a pointer being passed all over the place. **Regardless,** **I just realised we are probably all wrong and mainstream definition of OOP is focused on mechanics (inheritance, polymorphism etc) instead of the original principles (see** [**http://www.carlopescio.com/2012/12/ask-not-what-object-is-but.html#more**](http://www.carlopescio.com/2012/12/ask-not-what-object-is-but.html#more)**)** as @doomfrog666 mentioned in the comment: [https://www.reddit.com/r/golang/comments/9evh6x/is\_go\_an\_object\_oriented\_language\_gophersland/e5st60y/](https://www.reddit.com/r/golang/comments/9evh6x/is_go_an_object_oriented_language_gophersland/e5st60y/) I am going to rethink the definition and adjust the article and summary with latest findings.
The next language I intend to learn is rust, if I ever get bored of go
Check out this: golang.cafe 
Very useful perspective @DoomFrog666! Actually, I cited Alan Kay myself in the article but then I unfortunately zoomed mainly on the second point, Local retention, protection and mainstream "Encapsulation". From the following 2 blog posts: \- [http://www.carlopescio.com/2012/12/ask-not-what-object-is-but.html#more](http://www.carlopescio.com/2012/12/ask-not-what-object-is-but.html#more) \- [https://medium.com/@atherlangga/retracing-original-object-oriented-programming-f8b689c4ce50](https://medium.com/@atherlangga/retracing-original-object-oriented-programming-f8b689c4ce50) I realised the theory behind OOP is more much complex then I previous though, focused too much on the mechanics and the typical "car -&gt; doors, wheels...". I am going to rethink few things and adjust the article with latest findings ;)
Hi, I know that larger sample sizes are better, but like the smaller size for easier visualization. Nevertheless, thanks for the pointer!
You know, I think I accidentally bumped into that case. All of my outputs were the same. I can't remember how I did it though. But now I'll know to look out for that!
People need better words, a suggestion for anyone out there: * Use v1, but don't complain about bugs not getting fixes. * Use v2, but don't complain about API breaks. 
Struct-Embedding really blurs the line between composition and inheritance. Considering embedding just delegates to the embedded structs and the methods on the structs themselves are staticly dispatched and can only reach up to 'super-structs' this acts more like composition even though the extending struct truly inherits the methods of embedded ones.
https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53
I thin I've found a "solution" that's way cleaner. I made a `response` package in my project package response import ( "encoding/json" "log" ) type Data = interface{} type Meta = interface{} type Response struct { Success bool `json:"success"` Data Data `json:"data"` Meta Meta `json:"meta"` } func New(s bool, d Data, m Meta) Response { return Response{s, d, m} } func (r *Response) MustMarshal() []byte { j, err := json.Marshal(r) if err != nil { log.Fatal(err) } return j } So I can use it this way res := response.New(true, AnotherStruct{"value1", true, 1}, nil) w.Write([]byte(res.MustMarshal()))
&gt; need to be an experienced C++ programmer I would not agree with that as I most certainly am not an experienced C++ programmer, but have written multiple non-trivial programs in Rust. It took a little while to understand the language but once I did, things started making a lot more sense and I could see myself using the same patterns in other languages as well. 
I've been programming Java for 10+ years and still look things up constantly. If "looking things up" is somehow a barrier for someone...maybe programming isn't the field for them. 
I completely agree. They can often feel like boilerplate, but explicit transfer layers are extremely important in the majority of cases. In addition to what you've mentioned, it helps ensure a proper separation of concerns in code and makes it significantly easier to adapt to changes in data structure requirements down the line.
What I've seen on this is that very rarely will you ever actually have unstructured data in an API, so empty interfaces is probably not the way to go
 type Payload struct { success bool `json:"success"` data interface{} `json:"data" metadata: interface{} `json:"metadata,omitempty" } payload := Payload{ success: x, data: y, metadata: z, } serialized, err := json.Marshal(payload) if err != nil { // do something } err := w.Write(serialized) if err != nil { log.Fatal(err) }
3rdparty.Bar will be serialized. Any of it's private fields won't be. Presumably, that's intentional - they don't want you arbitrarily setting it (which includes setting it by changing the binary format)... 
Er, were you trying to cross-post this somewhere? Posing to the same sub is more harmful than useful.
I needed generics so I learned rust. It‚Äôs nice here. I still use both; Go‚Äôs concurrency model is much easier for web requests. 
[removed]
Then make it unsafe, like the other parts of rust that 'you know' are correct when you use them, like raw pointers. The point you make is exactly right; that *is* the difference between go and rust; rust is just trying too hard to be cool and approachabl, like go, when the fundamental proposition of the language is safety and compile time safety. ...but those are contrary objectives, and unwrap causing panics is a common, irritating failure for rust, causing runtime errors and crashes. All I can say is if I'm using rust, its because what I'm building needs to be rock solid and fast. Otherwise, I'd just use go, which is also fast, but perhaps not quite as 'rock solid' in the same capacity, or fast in the same bare-metal sense. So, tldr; rust panics due to unwrap fundamentally call into question part of rusts core value proposition. (and yes, I know panic and memory corruption are different, and rust still offers strong secure garuntees, but when a crate randomly crashes your program, its still rubbish)
I had no idea Liam McPoyle worked on Go!
Yeah, you article really brought up memories of the article I mentioned an I guessed that you actually did read it as well, so I linked it. And I am a bit sorry that my comment did not relate to your article at all. So before I leave some feedback I first have to thank you that you brought up this topic. I do not mean OOP in Go especially but what OOP is in the more general sense and you really nailed some points: The part of the original conception, and &gt; Yet, everybody uses setters (a guaranteed way to ruin your state) and gets OOP wrong right at the beginning but that‚Äôs a topic for another discussion. The last point really bothers me a lot especially when people teach OOP (especially in Java). Another thing I really liked was that you encourage people to use functions (also higher-order-functions) but at least in my opinion this is not something special about Go or something 'functional' but rather procedural programming pure! Algol, the first procedural programming language even supported this and yet some people are still stunned by their use. You also explicitly stated that OOP is not the primary paradigm of Go which I can just emphasize. However one point you overstate imo is the concept of encapsulation. If you take a look at python you really see that is it not mandatory to enforce strict visibility/accessibility rules. In python it is just a naming convention and it works just fine. This is actually very similar to how Go does it, just not checked. (In general Go seems to be heavily inspired by dynamic languages.) Sorry for the long comment. Maybe I write more about it in the future. :)
[removed]
[removed]
The best unbuffered channel metaphor I‚Äôve found is the baton hand-off in a track and field relay race. ‚úÖ
üíØ
RocksDB is closed to mysql to some extent. It is more mature since it is back by facebook. A pure go solution may not need, as developer mostly interact with go orm or database wrapper
That you don‚Äôt see that MyType IS an Ider - you are not constructing - or dont have to be constructing a new anything - that is an implementation detail, is the crux of the problem. You are basing your arguments on the way things are currently not the way they could be, and that is why your ability to see better solutions is hindered. I come at this with no baggage and my eyes open.you may take the position that linear memory layout of structs is fundamental but it doesn‚Äôt stop the implantation from passing inner closures to do the type conversions as need be. The performance argument is nonsense as Go is mot that fast to begin with. Go is about safety and simplicity and decent performance. 
P.S. I gather this may go away with the draft handle/check construct: https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling.md
is it really god tier tho if it isn't rust
Why should I switch?
Huh... I'm genuinely curious why this link is getting downvoted? When I showed some folks the key macro, one guy mentioned this was being considered for 1.12.
It's not controversial, just stupid and rude.
You can actually get to unexported data using the reflect package, but it's a bad idea still. If it's unexported from a third party package then they don't want you getting to it, or serializing it. It's now an API issue.
[Don't let your dreams be dreams.](https://novelkeys.xyz/collections/switches/products/the-big-switch-series)
Oh man, I want a whole keyboard of these, but I can't justify spending that kind of money...
Possibly in the future - usually AMAs are done on a team basis and I know other teams at Reddit have done them in the past.
To be honest, I could probably be convinced to give Rust another try if their documentation was even half as good as Go's. It's not even in categorized alphabetical order, which means you have to already know where things are in order to find them. Combined with the JavaScript/Python per-file module system, which I also rather dislike, can make some libraries' documentation an exercise in randomness. And that includes the standard library.
John Graham-Cumming did a [talk](https://www.youtube.com/watch?v=SmoM1InWXr0) at Gophercon in 2014 about channels that you might find helpful.
I‚Äôm C/C++ developer with more than 10 experience. And I still hate C++. When Rust was introduced I was incredible happy. Not anymore. Why? Short. See no difference. Rust promised to be much easy to use, to read, to develop. For the real I do no difference. Same over engineered shit. Personally for me I see no pros to switch to Rust from C++. Zero. Yeah. Some simple things. Yes. But in general. No. On the other side Go promised and delivered huge improvement for business apps development. Huge improvement. Especially for junior developers. So. Maybe I‚Äôm wrong. Please convince me.
Where did you place your package (i.e., the path in the FS)? Is it inside or outside $GOPATH? What is the exact import statement? What is the exact error message? What is in your go.mod file? Did you change the GO111MODULE env var? (Default is "auto")
It seems you are trying to do something of an integration test. You can run write a go test file that runs a "fake" http server. The following are links to help you get started: https://golang.org/pkg/net/http/httptest/#Server https://stackoverflow.com/questions/31685872/golang-http-integration-tests?rq=1
Looks pretty promising. Thank you!
&gt; we are probably all wrong No, "we" are not wrong. Some people tie "object oriented" intimately to class hierarchies and the "isA" relation typically provided by inheritance. That shift in definition might be explained by widespread use of languages like Java and C# which are advertised as object oriented: They are but one should not reverse the logic. OOP is not by definition what C# provides as a type system. 
You **CANNOT** import a go module from go source code on another folder, unless your go module is written in your `$GOPATH`. The package declaration in `go.mod` is local to that folder. So if you're on another folder and your want to import your code, you need to first `go get` or `go install` your library. Or else Go wouldn't know where to find it.
Thx! &gt;However one point you overstate imo is the concept of encapsulation A bit on this note, the reason why I focused mainly on encapsulation is because that's what I see developers usually getting wrong. They design an Object that represents the "domain", real world scenario but then they expose methods that change the object in an unrealistic way, or they use some kind of setters like methods. Actually I would be interested in your opinion on: **Local retention, protection, and hiding of state-process.** I am not big fan of pointers in Go because I think the Structs are leaking state when refered via pointers. The fact I change the state on line 1, then I expect this on line 10, but meanwhile a goroutine on line 5 changed it again to something unexpected is imo an unmaintainable design. I like to think about Struct as immutable DTO (then pointers are fine) or mutable but private, local. WDYT?
Ah I understand. Would have been rather clean too. Except that this won't scale well given all the sub resource types. I know there are around 80 endpoints or something, and the number of structs is closer to 140. &amp;#x200B; But otherwise I'd be all over that design.
Yeah, I kinda prefer the former myself as it keeps the various structs smaller (more of parameter objects tbh). If you go with the latter, you shouldn't really need the session parameter though, I don't think. I suppose it depends how much functionality you think the various structs need, e.g. does it make sense for the API to have channel.Send(msg, ...) or a session.SendOnChannel(channel, msg, ...). 
You're not wrong.
Its a big key that he made working
Hey. Thanks! One question: why do I need \`t.Parallel()\` if \`[t.Run](https://t.Run)(...)\` already run it in goroutine?
Go is not an Object Oriented language. But it is possible to use/represent Object Oriented concepts in Go. No where among official documents it is ever introduced as an OOPL. At least they had to say "Go is a native, Object Oriented PL" on the front page. &amp;#x200B; It does not support polymorphism directly and information hiding is supported at package level, not "object" level which is the way of OOP. Inheritance does not exists because you have to be able to put any instances of any child types inside a variable of the parent type which is not possible in Go. &amp;#x200B; &amp;#x200B;
In the same sense you could say Go is a Functional Programming Language! Because you can pass functions around! &amp;#x200B; And one could say assembly is object oriented! The level and precise mechanics of concepts and abstractions is important. &amp;#x200B; Replacing concepts with vague interpretations and put those vague interpretations into use carelessly does more damage than bringing any good.
what's the raw output in bytes?
That is mojibake.
Hi author here. We've created a new file format designed specifically for configuration: SAN (pronounce `/se…™n/` like `sane`). You can find the spec here: [https://astrocorp.net/san](https://astrocorp.net/san/) and Vim syntax here: [https://github.com/z0mbie42/vim-san](https://github.com/z0mbie42/vim-san) SAN was created because of a need to have a Safe And Neat configuration format (with comments, unlike JSON, easy to parse unlike YAML....). It's an open format and any feedback is wlecome.
&gt; SAN (pronounce /se…™n/, like sane) ???
Sounds insane.
I am Groot!
[removed]
\+1 for Vue and especially Vuetify. I am rebuilding our rails-based dashboards at work using Go as the api back-end and Vuetify as the front-end. I have the same front-end/CSS phobia as you do and I am loving how great Vuetify makes everything look with so little work from me.
&gt; /se…™n/ Not sure if this is the confusing point for you, but this is the [International Phonetic Alphabet](https://en.wikipedia.org/wiki/International_Phonetic_Alphabet). It shows you how to pronounce any word from any language. 
You got it ~~wrong~~ ~~too stereotypical~~ too idiomatic. The better way - and still not breaking the rules as it were - is: if myValue, err := myFunction(); err != nil { // do stuff to handle error } Saves a bit of vertical space :)
Your string encoder cannot parse the result. Try another encoder.
[removed]
I seriously don't find this any better than TOML or YAML
This is basically HCL isn‚Äôt it?
Why this over TOML? Or, why not a TOML parser with a strict mode to enforce the differences? https://astrocorp.net/san/san-vs/
Hi, One of the distinguishing point is that the format is standardized to be ported to other languages and go far beyond Go. One of the killer filler feature compared to HCL is that parser must implement (not yet fully defined) a way to retrieve the file metadata (layout) in order to allow programs to manipulate files with comments without destroying them (the comments). A true configuration format put comments as first class citizens.
Is there any way that I can detect if the returned string has any of these mojibake characters?
YAML is ambiguous, not really safe and indentation based. It was designed for data serialization/deserialization like JSON, not for configuration. Concerning TOML which was the main inspiration The main evolution is putting comments are first class citizens and letting programs manipulates files with comments without destroying them (the comments).
Depends on if you need `myValue` outside the if block. It's scoped to only exist in there.
Isn't this essentially JSON with comments?
JSON have `null` which is totally non sens for configuration (because JSON was designed for data exchange). JSON is hard to parse ([https://news.ycombinator.com/item?id=12796556](https://news.ycombinator.com/item?id=12796556)) &amp;#x200B;
Knew what the link would be before I clicked. Nice
The main reason we hate TOML is it's syntax. it's totally unclear what types are `a` and `b` here for a person who didn't read the spec [a] [[b]] While in SAN, it's obvious a = {} b = [ {} ] &amp;#x200B;
Haha me too. &amp;#x200B;
I disagree with the fact that there is already 14 configuration formats. The fact is I see only 3 formats that fit the configuration niche (and are not programming languages like Lua or pure data exchange format like JSON): * TOML * YAML * HCL unfortunately INI and HCL does not have a real spec which is a stop to the mass adoption. [YAML is bad](https://www.google.com/search?q=yaml+is+bad) really. &amp;#x200B; It remains TOML, but as you can see in other comments it has drawbacks that we not accept
[removed]
JSON5 has multi-line strings comments, and has many other human- and configuration-friendly features. Does SAN allow quoted keys, or multiple key-value pairs on a line?
[removed]
Just an advice, don't log.Fatal() in packages, returning an error is better.
Yes. One of the problem is: what to choose between JSON5 and HJSON ? Why building around an existing format designed for data exchange (thus which allow `null` a non sens in a configuration) while we can design a format specifically for the needs and specifies of configuration ? 
The primary error management system in golang is the function returning an `err` variable (golang supports multiple return) which must be checked. This can result in a lot of lines like the one OP's key types.
The code it outputs is a fairly common idiom in Go. 
At least trailing commas aren‚Äôt prohibited. Looking at you, JSON. Also YAML is overly complex and often hard to read.
How is null any different than any other invalid value? For example: name = null name = 7 name = "null" SAN would only prevent the first one, but for your configuration, all of them may be nonsense. In any case, why wouldn't you validate configuration? Also, how is `null` a universally nonsensical value for configuration? There are definitely use cases for it.
True but TOML is fantastic. I've considered flipping over to it at some point but need to find a desire to switch
One of the thing we does not like in TOML is that keys can can duplicated which is very prone to error and typos which is bad in a configuration file. an other thing is that you can define a table in multiple places: [a] x = 1 [b] y = 2 # imagine you have 200 lines here [a] z = 3 which is bad &amp;#x200B;
Really it would be better to push TOML forward than introduce another one. Think about Markup and how many people have extended or made special flavors of it. Do TOML+. Please. &amp;#x200B;
I have a project and it's structure is pkg/ src/ vendor/ go.mod/ My package is in the pkg/ folder and that is added in the GOPATH Inside the pkg/ I have github.com/temppkg/. So my import statement should look like github.com/temppkg/ Error message I'm receiving is go: github.com/temppkg@v0.0.1: invalid github.com/ import path "github.com/temppkg/ My go.mod file contains the github.com/temppkg v0.0.1 and other third party modules like logrus etc. Yeah I did change go111 env variable
On mobile, gif isn't loading for me. So this was a very confusing post.
Besides mtr or traceroute functionality, a simple feature for example, what if i want to sort and compare btw multi targets.
&gt;Do not assign the key if you want to express the absence But what if there is a default for something and you want to use a configuration setting to have it be unset? 
This doesn't seem to work for me. You just press the F key in the browser?
Yes, go to a package page and press F. Press ? for help.
This appears to be your sixth post on this subject. Can you post a full example of what you are trying to do so that someone can just show you the right way to do it?
[removed]
good point. maybe it's a bad design if a default should be unset. maybe the default should be not set
Sorry, i only tried on the iOS mobile App.
&gt;Electron is a full-fledged web browser No. No. No. And No. I really wish people would stop saying that. Electron uses the Chromium **rendering engine,** it lacks squillions of things that make a browser a browser, things like tabs, bookmarks, url bar, extensions, etc etc etc. I know how much people want it to be that way to be able to piss on it more easily but no, sorry, it is **NOT** a full-fledged browser. /offtopic
`unwrap()` is always the first thing I think of when people claim Rust doesn't have nil point errors. Well, technically yes, Rust doesn't have nil point errors. It has None Option/Err Error errors instead. Yay.
Why are your modules in a `pkg` subfolder in your project? That is not conforming any specifications .
Clicky, tactile or linear?
Null is just one of many ways of implementing the concept of "none" vs "some". While null might not be appropriate for your uses, it's great for others (especially the closer you get to hardware). You can't (and shouldn't) forbid everyone from using that concept or implementation. In a configuration file, null/none doesn't have to represent a pointer. It could represent explicitly accepting a default value, un-setting a value, or anything else. You may also want to distinguish between the user deciding to use null, and forgetting to specify the setting at all. Having string means that every non-string can be its type or string. Having number means that every non-number can be its type or number. Having null isn't any different, and you can handle it the same way you would a number that failed to parse correctly, or handle it as a default value, or whatever you want. The nice thing about configuration files is that you can use the same format for lots of things, but define different meanings and validity checks for each one. Removing null removes the ability to express certain concepts that are common in configuration files. Contrast this with removing the number type. At the end of the day, you're reading a text file and converting to your number type, so natively supporting numbers is just a convenience feature at best.
Triple \` only works on `new.reddit`, so a lot of people are seeing mangled garbage on your comment. Get rid of them and replace the start of each line in your example with 4 spaces.
I usually keep my packages in the pkg folder. And since I was trying to use these packages with the mod tool, they are present there.
Clicky, of course. üòÇ
So you import them like `import "yourapp/pkg/some/package"`?
Yeah 
Why is go.mod a folder?
My `Response` struct would just define the enveloping structure around the response data (the `Data`field), so I can just "drop-in" the actual struct for the `Data`field. Correct me if I'm wrong, thanks!
Oh that‚Äôs a gif?
Sending `nil` errors/interfaces on a channel is ok and behaves like any other value. https://play.golang.org/p/E1fLdCUNWey
Local retention, protection, and hiding of state-process (encapsulation) is an absolute worthy goal. It is however not exclusive to OOP. The two general approaches are that you can eliminate state as much as possible or segregate it into smaller and smaller units. The first approach is more functional the second more OOP. The issue I have is that modern OOP fails to deliver this. I think we really have to acknowledge that objects are inherently state(ful). Holding a reference to an object is a reference to state. If you alias/share it, it becomes essentially global (mutable) state. Ofc shared mutable state is what we want to avoid. Rust is actually a great example of how to deal with that problem. It does not provide any new mechanics, it just forces you to follow basic rules to circumvent the issue: Either you share an immutable reference or you have to transfer ownership (a deep copy also works). There is a principle in OO that states: "An object is responsible for it's own (private) state", this is the exact same idea. Taking this seriously, all mutable references to state an object holds would have to be owned by it. This leads to a strict hierarchy of objects with no interconnections or cyclic references. Brian Will has made a highly controversial presentation on exactly this topic https://youtu.be/QM1iUe6IofM?t=18m7s which I can highly recommend. Coming back to Go and procedural programming, we do have value-types and share memory by communicating, so a lot of issues don't apply. But yeah, as you said pointers (that change state) are the only source of trouble we can get into. One part is good documentation as we can not express that a function/method does (not) change state. The second part is being careful with the `go` statement and what we send/receive via channels. Dangerous constructs include (mutated) slices and anonymous functions that capture their environment (closures).
According to the [TOML spec](https://github.com/toml-lang/toml#user-content-keyvalue-pair), keys must be unique. Maybe you picked a TOML parser that does not follow the spec.
"some of the most popular apps in Linux is built using Qt" LOL
You can check that yourself with the flag `-gcflags '-m'` when compiling. Go's escape analysis depends heavily on context and also on the Go-Compiler version (the more recent versions are smarter).
You have a few options: 1) If you don't send an error on the channel, send nil instead (which fills the error interface fine), and then check for nil 2) If it's a single use error channel, you can close the channel if you don't send an error. You'll check to see if an error was sent via \`err, ok := &lt;- errChan\` 3) If you want to be doing other things until an error shows up you can poll the error channel by having a loop with a select statement in it
When you close the channel though you get an infinite number of nil values of it.
Rust and C++ are entirely different levels of complexity. I would counter your points but you havent made any so im not sure what I can say other than you are wrong and probably have not tried Rust seriously in the past year or two. Give it a go. Its much better. I write go and have used rust in the past and seriously prefer rust, but still love writing go. 
What you are searching for is commonly called a mock. There are many forms of mocks some really dumb ones, some very smart. You can write one yourself or search for one that fits your needs. Using decoupling techniques and dependency injection mocking and testing becomes way easier, your case seems pretty simple though.
[removed]
TOML is horrible for expressing any kind of structure, because it's nothing but kludges on top of Windows INI files.
Interesting point of view but I don't Totally agree. Can you tell me precise examples where null is legit to use in a configuration file other than unseting a default value (which maybe is a bad design) ?
Right !
[removed]
Takes a lot more than relational tables is what I mean.
What exactly don't you agree with? As for the example: Suppose you wanted everything to have a default value, but you wanted the user to acknowledge accepting the default. That way if your update your code to require new configuration, it will be obvious to the user that they need to review their configuration file. name = "" // Someone with no name. name = null // Accept the default name. Could be 'Bob' or '' or something. Whether that's a good or bad design, in reality there are many things beyond our control that we must account for, such as how our tools interact with other tools that have their own quirks, requirements, limitations, and bugs. Having the option to use null/none is very useful.
This is the third episode of Go After Dark, where we code cool graphical effects in Go. In this episode we create a so-called roto-zoomer that allows us to arbitrary rotate and zoom an image. As a side-effect we may also learn stuff about texture mapping. &amp;#x200B; Watch the effect in your browser (WASM) [https://afterdark.klauspost.com/ep03/](https://afterdark.klauspost.com/ep03/) Source Code: [https://github.com/klauspost/gad](https://github.com/klauspost/gad) &amp;#x200B; Hope you enjoy! &lt;3 &amp;#x200B;
Thanks for streaming this! Great to see this kind of example. For those watching the recorded version, it actually starts at 31:30.
you posted some more code but you did not say what you are trying to do. What are you trying to do?
&gt;configuration niche I'm curious what makes configuration a niche when one might still benefit from say having variables, and simple arithmetics that's normally found in a programming language. In fact, it seems like configurations for complex systems have evolved into using languages akin to basic programming languages. Examples: * Borg, the cluster manager at Google, has its own configuration language * Aurora [http://aurora.apache.org/documentation/latest/reference/configuration/](http://aurora.apache.org/documentation/latest/reference/configuration/) * Starlark for Bazel (and other build systems) [https://docs.bazel.build/versions/master/skylark/language.html](https://docs.bazel.build/versions/master/skylark/language.html) * HCL, as you've pointed out And to your argument regarding spec for adoption, starlark has a formal spec and also stable java/go implementations: https://github.com/bazelbuild/starlark/ 
The reason is you're forcing the entire app to quit where the error could be handled gracefully. Meaning that a bad input data could crash your server.
What's the difference between this course and the ones you have on Udemy for example?
I suppose you have tagged the temppkg project as "v0.0.1"? (Just to rule out that the required version cannot be found.) Maybe try `go mod tidy` and see if it either throws errors that are more helpful or fixes the dependencies. (And a a side note regarding the vendor directory: Go maintains a local cache for dependencies that you can prefill through `go mod download`. (Otherwise, `go get`, `go build` etc will fill the cache automatically as needed.) So if you use the vendor dir purely for local caching, the Go tools do that already for you.)
Thx a lot for your explanations, I do agree with it completely. Also I like the video, is incredible how stubborn people are and the guy got 4k dislikes for a very well presented topic due to many lazy, shallow arguments. I updated the article btw and I am moving on. I will most likely update it in the future again if more evidence, good ideas come up. Enjoy life hehe.
It would be great to create Dockerfile and Makefile. So everybody can check your "child" :)
The "Learn to Code Go" course is new on Greater Commons. It has new perspectives on the material; insights gained from teaching the language over the last few years. It also has A LOT of hands on exercises with solutions (insights gained from teaching the language over the last few years).
So Golang provides two types of channels: buffered and unbuffered. Unbuffered is more about synchronization. You cannot send multiple values to unbuffered channel. If you send, then you need receive. Otherwise buffered channel can hold multiple values (depends what you defined) and be not blocked.
SAN really just seems like a simplified JS syntax, but `#` instead of `//` for comments, `=` instead of `:` for assignment within maps, and no commas required to separate map elements. Not sure why we need this. Just use TOML. 
Oh damn. YAML hasn't changed since 2009...
For language support, it is vim-go. For other feature, Maybe you can read spacevim's doc. it has many built-in feature.
It¬¥s compiled with gopherjs, so it¬¥s webgl ... playable here: [https://skatiyar.github.io/pacman/](https://skatiyar.github.io/pacman/) It¬¥s pac-man for my skill-level. I can eat everything :-)
I just added Kanban boards to it as well....
such as code format, async file finder. multiple cursor, key binding guide.
Can you share your go.mod here? At least a redact version of it? 
&gt; It does not support polymorphism https://en.wikipedia.org/wiki/Composition_over_inheritance
I'm curious about the lag each time you eat something.
I've purchased both of your udemy courses would love to skim through the updated version...
The fact that no real performance difference was shown in the load test shows that they were completely constrained by the performance of their database, network, or something else. Ruby should be _much_ slower than Go.
This is Java with Go syntax.
Yes. Go and Rust from different world on purpose. I‚Äôm no trying to compare them. I‚Äôm taking about promises and delivery. Go promised simple and fast and good enough language for business apps. And they done this. Not perfect but very good. I‚Äôm not using anymore Ruby, Python and many others. Nothing still cannot replace Fortran som math staff. Rust promised better C++. And this is kind of awesome. And this is relative easy task. Anything can be better than C++. This badly designed and over engineered peace of shit. But they fail. I got same over engineered C++ with little changes in syntax, a little improvement over building time, etc. Still badly reading. I can read and understand any Go source code few times faster than any Rust code. And this is have nothing todo with complexity of task. And again. My background is C and C++. And yes. I still prefer C over C++. And yes. Already have experience building for over year huge business project with other 8 Rust developers. One‚Äôs even done calculations how much faster we will done same development with Go. For me after this year Rust just another C++ ‚Äúkiller‚Äù. Not enough better to become famous.
"Clean architecture is well known architecture these days." I see...
I do not know exact folder structure you have. Hope these two link will help to identify difference and also to resolve issue https://github.com/golang/go/wiki/Modules https://dave.cheney.net/2018/07/14/taking-go-modules-for-a-spin
It is a design principle and strategy. It is not a characteristic of an OOPL. It is a best practice - the composition over inheritance I mean. &amp;#x200B; As I told before it is possible to reuse practices from OOP in Go as it is possible to use practices from Functional Programming in Go. &amp;#x200B; That does not make Go neither an OOPL nor a Functional one.
Totally agree with you. It's like Java or Rails design.
Looks to me like it‚Äôs designed to be a pedal, so you can crank up all those if err != nil with a single foot movement. It is pretty funny.
I would disagree that a c++ killer is an easy task and that rust is so complicated to understand. First time working with it I agree go is so much easier to understand but if you actually have experience with rust like you say you do I find it much more easy to understand the lay of the land as a result of it's ergonomics, more standard package layout, and less hacky approaches. Look at big projects in each language. I find k8s so hard to follow due to its insane explotation of go and it's runtime whereas something like tikv or redox while not quite as large are far simpler to follow. The level of abstractions these projects are at is quite different but I still find the matrix of readability, performance, tooling, and reliability still favors rust. Go is great but at the end of the day is just easier for devs to transition to and that's the biggest showstopper. Objective evaluations mean nothing to big companies only the time to deliver new products which go delivers but at a cost. 
If you want to have another AMA, then you should probably ask them on golang-nuts mailing list about it.
That's a good example when a comparation of languages actually makes sense. Context and expertise matter.
have you considered decreasing the frequency in which the potions are displayed the further you progress up the map? I imagine some sort of exponential decay would be effective. I have been going upwards jumping from potion to potion. I've been pretty much invincible.
Going by DoomFrog666's recommendation, it looks like it does: // main.go package main import ( "fmt" ) type Node struct { value interface{} } func main() { fmt.Println(Node{"string"}) } And then running: $ go run -gcflags='-m' main.go # command-line-arguments ./main.go:12:18: Node literal escapes to heap ./main.go:12:19: "string" escapes to heap ./main.go:12:13: main ... argument does not escape {string}
Are you sure that we are talking about [the same `std` library documentation](https://doc.rust-lang.org/stable/std/)?
Those are not Go related stuff, those are plugins that enhance this Vim distribution. So you still didn't answer my question on what is new for Go development 
I used the word 'niche' to put a contrast between it and a 'general purpose' data serialization format like JSON. Maybe for some advanced projects a Turing complete language is needed for the configuration but we strongly believe that **less is more a**nd for the vast majority of cases a simpler and expressive format is the direction to take.
So you have to rely on some random person's repo to access the dom for doing work on the frontend?...I really hope you are wrong. I was already trying but I just think that is pretty pretentious. Cause you know how many people are going to access the dom in different ways? Wasm is already like 3.5mb and there are no bench marks between files. But now you have the deal with the window from scratch? 
Free means you don't have to pay any cash
Right choice. 
The bar for adding new stuff in the standard library is high. https://tip.golang.org/doc/faq#x_in_std. It is possible to have an x/ repo for a DOM API, but it's highly unlikely to have something like that in the standard library. There is a lot of enthusiasm with wasm in the Go community. So a good DOM API (by a random person) is bound to come out sometime. Up to you whether you want to use it or not.
Thank you a ton. I really didn't know this existed or that people were making libraries. I thought it was just the wiki which is coded more like js then go. But still a really big let down but I blame all the js framework support for this, just never thought after learning so many js frameworks that I'd be right back here again. We're talking years of frustration. But thank you.
So goods sold for bitcoin are actually free?
You have to provide *a* email address. https://www.guerrillamail.com/inbox got you covered.
Not failing to recognize your bias at the start will be your biggest failing. There is more ways to build distributed systems outside ruby (terrible choice) Kotlin (really? dealing with null) and Go which tbh is awesome but would be hard pressed to convince people here to move away from working systems for. Your basically building an Oauth2 service. Not exactly rocket science and most of the global distribution stuff is managed by aws/provider of choice. Your already using a distributed system so why not just use containers/serverless and just use whatever language you need to get the job done? C/C++/Go/Python/Php/Java... it really doesn't matter if your not building a monolith. 
Hi, sorry for stupid question, but can you explain and give an example of real life application for this code? 
It isn't stupid ;) So the purpose of the app is to giving possibility share messages between services with the unique entrypoint For me it's just educational thing 
Yep, I'm sure. Great intro, and it's all downhill from there. Reading through that I'm remembering some of Rust's bizarre 'Ooh, this is cool. Let's throw it in there.' design decisions... Semicolons and multiple types of returns always struck me as the perfect example of something being just a bit off in the design process. I know I'm sounding like I hate Rust, but that's really not true. It's for a ton of interesting ideas, many of which are pretty well implemented. It just has too many small annoyances that build on each other, eventually resulting in me inevitably switching back to some other language. I _really_ want to like Rust; I don't think there's any language that I've tried to use so many times. But I don't. I just don't like it.
The argument in the link conflates the configuration with the program's representation of the configuration. Even if your configuration supports `null`, it _doesn't_ mean that you have to _store_ `null` values. That's a choice you make as a programmer. You could also choose to trigger an action, raise an error, ignore it, or whatever. As for your design philosophy, I'm not saying that `null` is always good or bad design. I'm saying that `null` is sometimes _necessary_ design given situations beyond your control that you must account for anyway. Adding `null` support does not give you two ways of expressing the same intent _unless you let it_. In any configuration format, the number of "ways" of expressing a variable is one more than the number of types the configuration supports. For SAN there are at least 5 ways: * `name = 1` as number type * `name = "Bob"` as string type * `name = []` as array type * `name= {}` as object type * omitting it altogether Adding `null` would just increase from 5 to 6. It's up to you to verify that the correct type was selected. It's up to you to decide how to _interpret_ a different type. It's up to you to decide whether or not to _store_ an incorrect type. It's up to you to decide whether to use a parser that distinguishes between number/string/null and one that treats them all as strings and lets you do the final step in the parsing process. Personally, if I'm not using JavaScript, then I don't want to be restricted to JavaScript's types. I want to treat everything as a string and validate every configuration for correctness. Therefore, supporting number types would add useless complexity to the parser over just using string. But `null` is different, because it's a concept of an explicit Some vs None, which can be applied even to aggregated types like `[]` and `{}`. It can be useful in any situation. So what I'm saying is that you don't have to use `null`, but removing `null` removes expressive power, which is different than removing a type like number, which is an arbitrary type to support anyway.
Packt Publishing books are generally not good. Has anyone read this one?
I'm with you, but there's an easy solution: Temporary mail addresses :)
while that might be true (sorry for wording it this way but i did not try and dont want to because i found the book elsewhere) having to provide an email address is still annoying. I think some time ago when you wanted to download the Java SDK or something, you had to give them some emailaddress too. Friggin annoying.
no free means it doesn't cost you, there are many ways of being drained without the need for cash to trade places....
Frankly, the best advice I could give is to manage your resources efficiently. Ie database, url calls, files. Ensure that that piece of code or module does 1 thing and 1 thing right.
Using `fmt.Println` will make anything escape to the heap though since it will convert any value passed to it into an empty interface, which is essentially a pointer. You can see it in this modified version: ``` package main import "fmt" type Node struct { value interface{} } func test() Node { return Node{"string"} } func main() { if test().value != nil { fmt.Println("hello") } } ------- $ go run -gcflags='-m' ./cmd/test/main.go # command-line-arguments cmd/test/main.go:9:6: can inline test cmd/test/main.go:14:9: inlining call to test cmd/test/main.go:10:14: "string" escapes to heap cmd/test/main.go:15:15: "hello" escapes to heap cmd/test/main.go:14:9: main "string" does not escape cmd/test/main.go:15:14: main ... argument does not escape hello ``` `"hello"` escapes to the heap, even though it's a simple string value. It does look like blank interfaces will escape to the heap though no matter what. I did a few more tests though and it looks like if a function returns any interface instead of a struct, the returned value will escape to the heap due to the nature of how interfaces work in golang.
Less potions ruins the "user engagement" metric. We need people to stay alive and keep playing forever. Better for ads. ...oh wait, wrong project.
emails can be translated into cash too.
Another option is: [https://github.com/disintegration/imaging](https://github.com/disintegration/imaging) But perhaps you should explain why the option you linked is "not suited to \[your\] task"? All image manipulation in Go will tend towards a similar workflow of: * open * decode * resize * encode Are you having an issue that you haven't described?
https://peter.bourgon.org/go-best-practices-2016/
This recent video provides a lot of insights into the current and future work the go team is focused on: https://www.youtube.com/watch?v=rWJHbh6qO_Y
Fantastic! Thank you
If by temporary you mean [email@email.com](mailto:email@email.com) LOL!
Thanks mate! &amp;#x200B;
True. c.f. one book on Go concurrency, obviously written by a non English native (which is OK, I'm not) and which ended up being incomprehensible, even for me. Apress books on the other hand, are usually great and worth every penny. Never ever paid for a bad one. 
Whoever owns [bob@bob.com](mailto:bob@bob.com) hates me, I know it. 
I meant a temporary mail service like temp-mail.org :)
[removed]
I read the first 100 or so pages and for a go noobie it seems to be pretty good. I liked the content but the font was too small for my screen so I dropped it
It doesn't come at any cost to you
Check out `bild` ([https://github.com/anthonynsimon/bild](https://github.com/anthonynsimon/bild)), it can resize, too (among a few other things).
ok, so there's some confusion here between the channel itself being nil, and passing a nil value *through* it. A channel is a value just like everything else in go. Channels are pointer types under the covers, so they can be nil or not. i.e. ``` var errChan chan error = nil ``` This is a nil channel... trying to receive or send to a nil channel will block forever. ``` errChan := make(chan error) ``` This is a non-nil channel. You can send errors or nil values over it just fine (they'll block until there's both a sender and a receiver). You can `errChan &lt;- nil` and then when you `err := &lt;- errChan` ... err will get the value of nil (note that you can't do this from the same goroutine, since the send will block until there's a receiver) 
Oh, I agree. My point was just that as far as mandatory email forms go, this one is pretty mild.
Packt is one of the the worst publishers out there. Avoid their stuff like if it was cancer.
[removed]
Coding from the perspective of a vision-impaired developer. Did you already know how a screenreader pronounces "GitHub"?
`bugmenot.com`
The URL refers to localhost. Someone probably made a copy/paste booboo here.
So in Firefox it's using a full core and the pacman itself moves by mm when you press directional key... The Chrome's tab is crashing with not enough memory error.
Ooops, thanks!
Good point, I did not notice that the OP is not the author. (But OTOH, it appears that the author DID read my comment, so: mission accomplished ;-) &amp;#x200B;
I hate that site. Damn hackers have copies of all my stuff.
Not all Packt books are bad. The problem is that Packt do not seem to select the authors base on their level of expertise and their writing skills. You can find everything from mediocre to great. 
redis does not provide a way to do that. the best way would be if your keys were prefixed by what kind of data type they were, so "hll:foo" or "bitset:bar" instead of "foo" and "bar", then you could just skip by key name. Something like this COULD work as a filter for the values: func isASCII(s string) bool { for _, c := range s { if c &gt; 127 { return false } } return true but that won't work right at all if any strings you store are UTF-8 and not plain ascii. There's also no guarantee that a bitset value is not a printable string, for example: 192.168.99.100:6379&gt; SETBIT foo 1 1 (integer) 0 192.168.99.100:6379&gt; SETBIT foo 3 1 (integer) 0 192.168.99.100:6379&gt; SETBIT foo 4 1 (integer) 0 192.168.99.100:6379&gt; get foo "X" because 0b1011000 is 88, and 88 in ascii is 'X' 
 func (c *CustomType) UnmarshalJSON(d []byte) error { var tmp CustomType if err := json.Unmarshal(d, &amp;tmp); err != nil { return err } c.FieldA = tmp.FieldA // etc return c.validate() }
That still seems to have the same error, as `json.Unmarshal` will call `tmp.UnmarshalJSON` and you end up in "recursion hell".
This has the same recursion problem that OP mentioned though. You'd get `json.Unmarshal() -&gt; CustomType.UnmarshalJSON() -&gt; json.Unmarshal() -&gt; CustomType.UnmarshalJSON() -&gt; ...` forever, unless there was an unmarshal error.
To be honest, you need to watch the videos first, even though they don't really teach you to code but they make you comfortable with syntax. Then try to hack stuff together like comparing maps or do a map and use it or try to parse something to []bytes. Then try to create a server. Then create a handler. Then create the database. Then try to make it all work together. Then try to get different inputs and try to show the data differently. Then try to search for it. Then try to run a service. Then try to mix data and another API and so forth. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
Type cast CustomType(r).validate() *should* work
Sadly it doesn't, as I defined validate as accepting a pointer (although I guess it could also _not_ accept a pointer). In the end I just stored `CustomType(r)` in a variable before calling `validate()` on it (see my edit).
It's possible with a type alias, see my comment above.
Neat!
Meh, I gave up trying to use symlinks to solve this problem a long time ago. While the compiler itself will work fine, a bunch of other tools (like dep) had issues dealing with the current directory being a symlink. The only way I've found it to work (semi)correctly is if you put the actual code in your GOPATH (~/go/src) and then create a symlink to that directory somewhere else (~/projects/some_project/go_repo in your case). But even then, dep would barf.
Haha, I tried it first too!
Thank you, that was exactly what I needed
Sent you a PM /u/tscottmcleod Thanks for a great course! 
Take a look at https://github.com/titpetric/factory/resputil - i type errors and responses separately, and provide some utilities that make it easier to return errors and values in API calls. It‚Äôs one possible way of doing it, maybe not the best way because it doesn‚Äôt take into account things like http status codes in responses.
That isn't any kind of valid text, imo. Not with those null bytes. Googling "HYLL" turns up [this data structure](https://stackoverflow.com/questions/23164374/redis-hyperloglog-pfcount-side-effect#23227052). Did you try what /u/newbgopher suggested and use `PFCOUNT`? (I don't know what that is; I've never used redis in anger.)
For my use case using GET is something I can't avoid or replace but thanks for all your help :-) 
It's being phased out? Do you have a source for this? Thank god though, when people ask me about developing with Go, I always say the most trouble comes from the environment. 
Hi ! I'm the creator of Og. I'm really open to critics - good and bad - as long as they are constructive. This language is not meant to be a real one, but if you are interested in discussing about what I did wrong, what could be improved or if you want to get involved, please feel free ! :)
Time. Which can be translated into work. Which can be translated into....(wait for it)...... cash
With this logic nothing is free. So little time is taken that it's insignificant. If you are applying for shit like this during hours which you are being billed then that's your issue.
https://github.com/golang/go/wiki/Modules#installing-and-activating-module-support &gt; Invoke the go command in a directory outside of the $GOPATH/src tree, with a valid go.mod file in the current directory or any parent of it and the environment variable GO111MODULE unset (or explicitly set to auto). https://github.com/golang/go/wiki/Modules#gomod &gt; A module is defined by a tree of Go source files with a go.mod file in the tree's root directory. Module source code may be located outside of GOPATH.
Everything you have just described is a product of poor architecture decisions. 
That is one seriously low budget spam account.
Keep all the packages in one repo
I will message you access. :)
I will send you a link for access.
Your Go stuff will be under ~/projects/src/ instead. It‚Äôs hard to accept at first but then it turns out to be no big deal and you wonder why you fought it so hard at the start. 
You don't need to be packaging it up each time you make a change. Use the go cli during the development and then distribute it using a Docker image 
Eh, the purpose of Docker is to have more control over there software running inside it, to include the resources it can utilize. For this a docker will inherently have less resources than the system it itself sits on (your pc). If you're moving your Dev environment around different machines frequently, a docker might make sense even with the performance hit. If build speed is all you're after though, it might be better to just code directly on your machine.
You can improve the speed of building in a container by volume mounting in your build cache. It still won't be as fast as your machine, but it should help quite a bit. \`-v $(go env GOCACHE):/root/.cache/go-build\`
Everytime I read something along the lines of "simpler syntax means simpler code", I refer to this is example: ++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++. It is so simple.
&gt; Do I understand correctly that golang is incompatible with this structure? No. Go as the language is fine with whatever structure you think is appropriate. *But* you will have to invoke compiler, linker, all tools, whatnot by hand. You do not want to do that (really). What you want is to work with the go tool. The go tool pre Go 1.11 requires your code do live below $GOPATH/src. A lot of people shout "but I ... " upon reading that the first time but it absolutely doesn't matter. You set up some folder, set GOPATH to it and create src. Nobody is harmed, hindered or constraint by a folder called src. You'll get used to it (and it actually is much nicer than what other languages do). The go tool starting from Go 1.11 no longer requires any folder layout. That is very fine, especially on throwaway CI systems. For your local development $GOPTAH/src is still fine, fast and convenient. "Projects" and git repos is a _different_ topics. If you want a Go package to be `go get`able or to be downloaded automatically by Go 1.11s go tool during build you need to follow some constraints (or provide some infrastructure). These constraints are natural and convenient, so do not try to fight them just because language X does it differently and language X's way of doing things works fine for you. Just peek at common tools on github how it is done.
You can take a look at my solution for developing inside docker [https://github.com/IhsanMujdeci/golang-docker-livebuild](https://github.com/IhsanMujdeci/golang-docker-livebuild)
Hi, to me it seems that you are trying to compose these operations in the wrong place. Unmarshaler is the one who "validates" your payload (byte slice) against a set of rules like: is that field a number, it has the correct number of commas, etc. Validator is the one in which your unmarshaled payload is checked, like : it's the struct's field empty when it shouldn't be, do you have a reference with that id, etc. The caller of the umarshaler should be the one which should call validator as well, despite the fact the code will be "longer", with many error checks.
You could try out our docker container and see if this works for you. We use it on a daily basis and compile times are pretty good in most cases. [https://github.com/dkfbasel/hot-reload](https://github.com/dkfbasel/hot-reload)
Most of you say it is a bad book. What would be a good book for mid level developer? Mid level I mean when you know slices, interfaces, concurrency and etc. but not sure how to organise code, want to know more about best practices.
hi, thank you for your answer ) issue that I have with resize is quality fo result. I am using Lanczos3 function (which is suited best from my point of view) with resize lib and the results are much worse than when using GraphicsMagick. BUT it's new area for me (images and etc) so mb I doing something completly wrong. In this case pls tell me about that.
Actually ended up implementing it, like this (it's a bot that auto-deletes every new message, creates a message to say what was deleted, and delete it's own messages after 5 seconds): [https://pastebin.com/VjqEL7Kh](https://pastebin.com/VjqEL7Kh) &amp;#x200B; Ty for the tip, it actually feels pretty nice.
There are rarely concrete answers for this sort of thing - choosing the best filter options depends on image format, content, reducing vs enlarging, etc. Best idea is to try some options on your test images and see what looks best to you, but generalising for user-provided images will sometimes be hit-and-miss. By all means try some of the other libs and see if they give you better results, too. For reductions I tend just to use the box filter from the above lib - it's fast and generally produces decent results (though my definition of decent and yours may differ! ;-) ). Good luck!
Hi ! Thank you for that comment. It's still an early design (with a very poor name, indeed), if you have any suggestion to make the syntax (or the name) more appealing, don't hesitate ! I'm alone on this personal project that's more an experimental hobby on my free time than anything else, so any critic is good to take !
 golang.org/x/tools/go/analyses/nilness -- Google‚Äôs SSA-based nilness check If this is what I think this is, then freaking finally!
It sounds like you're rebuilding the Docker image every time after doing a Go build, then running the Docker image. Maybe you should just continue to use `go run` with something that re-runs `go run` when your source code changes in a container using a volume. Personally, I don't use Docker during development of Go applications. I develop on Linux anyway, for the same architecture, and that's close enough for me. You should also not though, that `go build` is _not_ slower than `go run`, when you use `go run` it's actually doing a build still the same way that `go build` does, but then is running the binary it builds from a temporary directory - so it is something else you have introduced to your process that is slowing it down (likely what I said at the start about rebuilding the Docker image each time).
&gt;For this a docker will inherently have less resources than the system it itself sits on Not true! Docker only orchestrates the process to be (oversimplified) in it's own namespace and 'chroot', and cgroups. The process itself will run on the same linux kernel as your host, and by default have all resources available, unless you specify otherwise. *The catch* is that if you use Docker for Mac (or Windows), there will be a (hidden) VM on your system, that indeed does have less resources than your host does. So your claim is pretty un-nuanced. Claiming a build will always be slower in Docker is simply not true. On my Linux dev host, there's absolutely no difference in build time. There might be a tiny amount of overhead involved when starting a container, but that is unnoticeable. &gt;If you're moving your Dev environment around different machines frequently, a docker might make sense I totally agree, this actually is the only use case I see for developing/*building* in Docker: reproducibility The OP states that `go build` is slower than `go run`, which of course is always true (Docker or not), and: &gt;To run my Go program inside the container, i have to build the binary first and then run the binary which is totally **not** true. You can simply `go run` from a container without any problem: &gt;`docker run -it -v $(pwd):/usr/src/myapp -w /usr/src/myapp golang:1.8 go run main.go lorem.txt` &gt; &gt;*Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu.* This will (most of the time) be just as fast as without a container (yes, even on my Mac). Please bare in mind that there are two use cases for Docker when doing any kind of software development: building it &amp; running it (Dev &amp; Ops --&gt; DevOps). Building with Docker is nice because it facilitates reproducible builds, which is nice if you have a large team with a hybrid (BYO) systems environment. It is also a best practice for doing stuff like CI/CD. It's not by coincidence all the popular CI platforms like Travis use containers for their build systems (Dev argument). Running it with Docker is nice because containers provide me with a standardised way of deploying to software to my (staging/production) environment, and managing it when it's in there, without actually having to care what is inside it (Ops argument). So please don't start discussions like these without properly informing yourself about the tooling, best-practices and what you are actually trying to achieve. This thread might as well be named: "Ferrari's are crap cars!"; just because you want to go grocery shopping with a Ferrari instead of racing it, what they are actually meant for, is silly to say... *"Master your tools"*
I've read the first chapter, and it already includes some bad advice - using json decoder to read the request body and calling it a day. Not sure if I should trust the information from chapters that deal with topics unfamiliar to me.
I don't really understand why everybody is building their app in the container. It feels so against the way go is meant to be used. You can do a local build for the specifc OS/ARCH you run in the container and you can make it static so you don't even need the go sdk inside it or anything else besides a libc.
Indeed I based my work from [http://livescript.net](http://livescript.net) that compiles to JS, adding on its way some functional concepts. I would like to please everyone but it's not possible as you mentioned it, my first goal was to write less code while staying as close as possible to the Go's syntax. I think what irritate some people is the syntax of the function definition (also the lack of visual delimitation with braces) that is unusual. This put aside, I think Go would greatly benefit from some functional concepts like statement as expression, polymorphism, function composition, or even generics that would ease the development. One of the things I criticise about Go is its verbosity and all the boilerplate code you have to repeat in order to use simple features (i'm looking at you, \`sort.Sort()\`) My attempt was to make things slick and straightforward in that way, but I'm still very far from that goal, as these comments confirm. I'll take a look at what I could borrow from other well established languages like Python (even if it's clearly not my favorite :p) Thank you again for that positive and constructive comment ! 
AFAIK, these days it's not really a big deal. By default, everything goes into \~/go, but you just need to put something in your profile.rc (or equivalent) which reads "GOPATH=/path/to/go/files" If you're feeling super awesome, you can also add "PATH=${PATH}:/path/to/go/files/bin" so you can run your applications once built and installed.
How hard could it be to set up a simple env variable? Maybe the problem is behind your keyboard
Do you mean that i should develop in my local environment ? Doesn't it kill the purpose of Docker ? lol
If Google didn't lie, the correct url should be: [https://mlesniak.com/post/2018/09/13/go-guitar-/-visualize-sound/](https://mlesniak.com/post/2018/09/13/go-guitar-/-visualize-sound/)
This. Electron is the new Flash. Please stahp.
Am I the only one who came here thinking that was a rewrite of the archlinux Pacman in go lol
https://golang.org/cmd/go/#hdr-Preliminary_module_support &gt; Go 1.11 includes preliminary support for Go modules, including a new module-aware 'go get' command. We intend to keep revising this support, while preserving compatibility, until it can be declared official (no longer preliminary), and then at a later point **we may remove support for work in GOPATH** and the old 'go get' command.
between the keyboard and the chair..
&gt; my first goal was to write less code while staying as close as possible to the Go's syntax. 1. I don't think "writing less code" is a useful goal. I think it's counterproductive to clearly expressing ideas. 2. This is not close to Go's syntax in any meaningful way. &gt;One of the things I criticise about Go is its verbosity and all the boilerplate code you have to repeat in order to use simple features I think this feeling comes from a confusion between "simplicity" and "facility". Go's goal is to be _simple_, which is a property of _design_. Facility, OTOH is a property of operation. For comparison, Python is _facile_ but _complex_. Go is _difficult_ (relatively speaking) but _simple_. &gt;I'll take a look at what I could borrow from other well established languages like Python (even if it's clearly not my favorite :p) By all means, pick something other than Python! I simply submit that the current syntax is close to the worst possible design choice -- and I say that with no disrespect whatsoever. This is a truly enormous accomplishment, and you should be proud of your work!
what
I didn't break it, but as far as I can tell you have a bug in handling end-of-lines. The [spec](https://spec.commonmark.org/0.28/#line-ending) defines a line-ending as (emphasis mine): &gt; A line ending is a newline (U+000A), a carriage return (U+000D) not followed by a newline, **or a carriage return and a following newline**. However the library doesn't treat windows eols(U+000D U+000A) as line-endings. If you process text coming from a windows machine, the paragraph separators don't work. 
https://www.amazon.com/Practice-Programming-Addison-Wesley-Professional-Computing/dp/020161586X/
Yeah, I agree with you on this. If you add autoenv or direnv, you can have the GOPATH set up when you \`cd\` in to the project so you don't have to remember to do it. I haven't experimented with go modules yet, but it definitely looks interesting.
No, docker is more commonly used as a deployment mechanism and not a development environment 
You sure? A carriage return and a following newline should end the line because of the newline, so DOS line endings should just work.
https://golang.org/pkg/crypto/cipher/#AEAD
I created this tool to be able to run applications like stunnel with hot configuration reload on Kubernetes (docker image will be published soon). &amp;#x200B; I listed a number of alternatives in the readme which weren't the perfect solutions in my case, but I'm a [NIH](https://en.wikipedia.org/wiki/Not_invented_here) syndrome warrior, so if you are aware of better tools for the job, let me know. &amp;#x200B; Also, I might recommend this feature to [dockerize](https://github.com/jwilder/dockerize) to implement.
If you think setting GOPATH is hard, coding is probably not for you.
[removed]
Is this compatible with other routers such as Chi? They both appear to be using the same handler parameters.
Can also just use JWTs.
Yes quite sure: $ dos2unix par.md &amp;&amp; mdtool par.md dos2unix: converting file par.md to Unix format... &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;test paragraph break&lt;/p&gt; &lt;p&gt;another line&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; $ unix2dos par.md &amp;&amp; mdtool par.md unix2dos: converting file par.md to DOS format... &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;test paragraph break another line&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;
Yes, I use Chi and securecookie in one of my projects.
Yes, I was using it with httprouter. Gorilla's tools are all designed as a convenience layer over top of individual go components and can be mixed and matched as you please.
Here is a talk about naming conventions in go. [https://talks.golang.org/2014/names.slide#1](https://talks.golang.org/2014/names.slide#1)
https://github.com/golang/go/wiki/CodeReviewComments#variable-names Recommended to read it end-to-end (along with [the FAQ](https://golang.org/doc/faq)).
&gt; with a type alias &gt; &gt; type InnerThing Thing Nitpick: that's not a [type alias](https://golang.org/ref/spec#AliasDecl), it's creating a new distinct type.
Hey did you check out github.com/dave/jennifer when creating this? It might make your code generation cleaner...
Also, looking at the `mdtool` output in my other comment I think that the end of line at the end of the document should be stripped. The [spec](https://spec.commonmark.org/0.28/#blank-lines) says: &gt; Blank lines at the beginning and end of the document are also ignored. But the example shown has no blank line after the header.
Oops! You're right. Thanks :)
What sort of performance difference are you seeing between go run and go build? It's a little surprising that go build would be notably slower on it's own, since they have to compile the same code. Does this include building/launching the container? For Docker apps, I rarely test an application inside a Docker container as part of my main workflow. I (try to) do TDD for most work, so everything is verified with go test, and then I'll manually test the full application running locally with go run/go build. Running the container locally is something of a last step, when I want to see everything integrated. This does mean I need the same resources and dependencies on my local machine as would be in the container, which adds some setup work, but if you wanted to, you could build a "dev" container that mounted your copy of the code to quickly rebuild internally (I've never tried doing this, though).
You get what you pay for, lol.... I tried a few of their books and they are a disaster. Spelling mistakes everywhere. Bad English all over the place. Who proofreads and/or edits these books? It's terrible.
\++
What specifically doesn't work? your description pretty blurry..
A lot of common sense in there. Short names are still weird though :)
I've bookmarked to read later. Thank you.
/u/fox20012 your programming career is doomed üòÑ
Just curious, what's your main reason for moving to Gitlab? Personally, I will stay on Github for the social coding experience, even though it's a Microsoft's company now. The social coding aspect adds a lot of fun elements to development imo.
Never name variables with 1 or 2 character regardless of the programming language.
One of Go's primary creator's / designers is Rob Pike. For quite a while he has held that variable names should be short. You can read some of his writing on it here: http://doc.cat-v.org/bell_labs/pikestyle Note as well that the stdlib is full of very short variable names. For example, take a look at the [Buffered Reader](https://github.com/golang/go/blob/go1.11/src/bufio/bufio.go#L126-L137) implementation. Check out the "Read" function too for another example. Of course, Rob Pike has many opinions which have heavily influenced Go. That doesn't mean you have to follow them if you disagree with them. Just because [his editor of choice](https://usesthis.com/interviews/rob.pike/) is [acme](http://acme.cat-v.org/) doesn't mean you have to start mouse chording and disable syntax highlighting to write Go.
You can use https://gitlab.com/ulrichSchreiner/go-web-dev/blob/master/gopath.sh to create the layout with the ci variables. 
I think GitHub is fine, for open source projects. Anything private goes on my GitLab.
This is the exact reason for me too 
The test I've been using to verify it is to go to a public method in the library I call from my application, the library is under $GOPATH/src/github.com/pkg/sftp/, and add a panic() right at the top of that method. I then go to my application code, run it and want it to panic. It currently ignores the changes, running an unmodified version. I've tried `go install`ing it first. I've tried GOCACHE=off. When trying with go test, I include `-count 1` to avoid test caches. But it never hits the panic in the local change.
You can add the library to the \`/vendor\` directory (using the same url path), that will override any other installed versions of that library url.
Yeah, I should have included that. Above all else in fact. Agreed.
As noted by OP, GitLab has much to improve in terms of social coding with features such as following and starring. Besides that aspect, GitLab is already a drop in replacement for GItHub with dome neat extra hussle-free features
I exported all my 13 active projects from github to gitlab a couple weeks a go, and loving it
Why do you prefer Gitlab for private? I prefer to keep my private in the same place as public.
Yeah, people don‚Äôt give props to how GL is an absolute beast next to its competition. 
[removed]
Ok. This inspired me to add another wrapper function and do some refactoring of the repo. See: https://github.com/clbanning/mxj/blob/master/examples/reddit02.go
I use GitLab CI. They don't publish a working GKE manifest so I posted one here if you're interested in having your runners on GKE :) &amp;#x200B; [https://mattouille.com/articles/2018-08/kubernetes-through-iteration-with-a-startup/](https://mattouille.com/articles/2018-08/kubernetes-through-iteration-with-a-startup/)
GitHub only allows one private repo unless you're a paying subscriber. Some people, especially hobbyists, don't really need to pay for that. It's just a convenient location to stash code and sync it between different workstations.
Shameless plug - [simplesessions](https://github.com/vividvilla/simplesessions) framework and network lib agnostic cookie library. It uses gorilla securecookie under the hood to implement client side cookies.
Yeah, we run it on prem (I'm one of the admins that set it up) have about 3750 projects in it across different groups, not all go off course, and 100+ builds running at any given time generally, on the runners my team manager, it's just awesomely powerful to empower the teams to do things themselves. The only problems I generally have are developers who don't know what they're doing and then doing stupid things that I have to work with them to correct.
My guess is you are changing the wrong method. Can you show a full example of what you are trying to do? You can also just run `git diff` inside the repo to verify you changed what you thought you did. I tested this on one of my projects and it paniced just fine.
go get doesn't work properly if you've got a protected subproject without global git config tweaks and/or proper .netrc - just a heads up
Yeah... brown bag time. The method I was "sure" was being called wasn't. Ran it in a different way and was able to get the panic. Sorry everyone... nothing to see here. First time I've downvoted my own post.
I think that the GitLab provides more productive and powerful environment when you get familiar with its design and navigation. In my opinion, GitLab's design seems more semantic than the other vcs and gits.
go get should never be read on your build server it should only be run in your Dev environment
Russ Cox has a short article on naming that the Go guidelines take some inspiration from. I have found it to be a useful way of thinking about names: https://research.swtch.com/names
Or, just keep the go container running as a daemon pointed at bash with your go path mounted, then create an alias to exec into it and build or pass -it and go run?
One or two character names are common but so are one syllable names. Consider the very common "buf" (for buffer) and "err" (for error). 
Careful you‚Äôre not a misbehaving netizen. Recaptchas are used for a reason. 
You don't need docker for that at first place. Just install go and run "go build".
Mine too, gitlab runner knocks the socks off any other ci I've used. I've been using it for 3 years now. Maybe circle is coming close but just having runners wherever needed is amazing when deploying to multiple different hosting providers. You can even run them locally on your dev machine.
Use runner private tokens.
Oh good. My memory isn't that faulty... yet.
Gitlab also does things a lot better than GitHub in other areas though. The runner is insanely good, issues are so much better, permissions for contractors and other 3rd parties are manageable and 3rd party integrations at least exist.
The usage of docker builders allow us to handle every commit to every in-process branch to give immediate, emailed feedback from the server after running .gitlab-ci.yaml file. All without having to have dozens of "build machines" that are 99% idle.
Turns out I was suffering from head-up-ass syndrome and wasn't actually calling the methods I thought. Thanks for trying to help. 
Hey! This is an interesting use of channels and seems like it would work. I did have a question: How does your end solution handle your previously made point: "The state may change while we‚Äôre processing a request, causing us to process part of the request with one state, and another part with another. This isn‚Äôt a big deal in our example, but becomes more of a problem as the time needed to handle a request increases." &amp;#x200B; I wonder if a simpler path might be to add the piece of state to the http.Request's context. This would ensure a request starts and ends with the same state. Additionally, you could use the atomic pkg to update the state value(s) in place and avoid any race conditions in accessing them. Thanks again for the write up :) !
I am using GitLab to build a project Go with `go.mod`. How do you guys suggest to deal with the `$GOROOT/pkg` directory? Some here says to do not run `go get` during build. So, what's the right way to do not need downloading all times the dependencies? obs: when I use the `cache` with `/go/pkg/` path it's says have found nothing to cache.
or maybe you were thinking of dockerhub
&gt; Just curious, what's your main reason for moving to Gitlab? [This](https://www.reddit.com/r/github/comments/9ebinm/i_havent_left_microsoft_github_with_the_alarmists/). My open-source GitHub organization was unavailable for the public for hours because of a stupid bot. They just auto-suspend you and you have to contact support to prove you're not a giraffe. That's beyond sane, in my opinion.
I don't think what I'm doing is malicious, it's basically crawling forums for mentions of LoL champion skins, the end goal is to see how various attributes increase or decrease the discussion around them. I've just found that many forums use some form of Captcha / Recaptcha (sometimes via Cloudflare) which leads me to where I am now. 
Right, but you‚Äôre specifically trying to avoid protections they‚Äôve put in place for certain reasons. It may not be malicious in intent but it unethical. 
I guess, but needs must at all that. 
Figured this out about 3 minutes ago! So now, most of them are printing, but some of the values being reported back are &lt;nil&gt;, probably because i'm not accounting for the KVP's being there. Thank you for this though! &amp;#x200B;
This fixed that other problem though: &amp;#x200B; type AssetGroup struct { Name string Type string Criteria interface{} Notes string } func CreateGroup(group rapid7vmconsole.AssetGroup) (AssetGroup) { var criteria string if group.SearchCriteria != nil { criteria = group.SearchCriteria.Match for _, filter := range group.SearchCriteria.Filters { criteria = fmt.Sprintf("%s : %s %s %+v", criteria, filter.Field, filter.Operator, filter.Value) } } else { criteria = "" } g := AssetGroup{Name: group.Name, Type: group.Type_, Criteria: criteria, Notes: ""} return g } &amp;#x200B;
PDF files are like a mini file system, in a way. Very interesting file format. Any way each text blob in the document could either be actual stream of text letters, or it could be an image of text. For the former case it‚Äôs fairly straightforward to extract the text if you study the file format. In the latter case, you‚Äôll still need a library to perform OCR on the embedded images.
I am written a web crawler framework [Antch](https://github.com/antchfx/antch),it can make easy create yourself web spider. [https://raw.githubusercontent.com/wiki/antchfx/antch/imgs/antch\_architecture\_01.png](https://raw.githubusercontent.com/wiki/antchfx/antch/imgs/antch_architecture_01.png)
I think this is what you're looking for: ```go package main import ( "fmt" "github.com/martoche/pdf" "bytes" ) func main() { r, err := pdf.Open("strings.pdf") if err != nil { fmt.Println(err) } p, err := r.GetPlainText() if err != nil { fmt.Println(err) } buf, ok := p.(*bytes.Buffer) if !ok { fmt.Println("the library no longer uses bytes.Buffer to implement io.Reader") } fmt.Println(buf.String()) } ```
Pun intended?
Any advantages over Bitbucket?
I build go in docker so no need to symlink or use modules. Just upload it into an object storage or use the artifacts in gitlab or push them elsewhere.
You do not understand docker. The purpose is to create predictable builds. Means you can build the same image from the same dockerfile now and in a year with the same result. Means: Either build the binary before and inject it with add during the build. Or: Use a multistage and the finals only runs without the building FROM golang:1.7.3 WORKDIR /go/src/github.com/alexellis/href-counter/ RUN go get -d -v golang.org/x/net/html COPY app.go . RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR /root/ COPY --from=0 /go/src/github.com/alexellis/href-counter/app . CMD ["./app"] 
We moved from github.com to gitlab.com (long before MS acquired github) and honestly in summary we regret it (for context: we're 20 devs, multiple (private) micro-service repos and run on gitlab.com in the silver / premium pricing tier). While gitlab has a few niceties here and there, there are in retrospect some dealbreakers which sparked an overall sentiment in the team to move back to github. Those issues are in descending priority: - BIG: No support for multi-repo code search (this limitation only applies to gitlab.com, but that's where we are). I really wish we would've known this before our migration: https://gitlab.com/gitlab-com/support-forum/issues/3059 - General UI / UX performance (i.e. how long it takes for a page to load after a click) is noticeably slower and inconsistent, compared to github. On the good side this seems to have improved a month ago when they moved from Azure to GCP/k8s, but it's still behind github. - Instability: Pretty often outages of the site or some services, 500 errors, slow performance for some time etc.. Again this seems to have improved after the move to GCP/k8s, but need to see how this holds up on the long term. In general we also feel that gitlab has a tendency to release incomplete features with severe limitations that render them often useless in practice (and not just a demo case). I.e. the k8s integration is tied to projects instead of the group and makes several in-practical assumptions about how you label your pods to become useful. Not everything is bad on gitlab, some of non-trivial things I would miss on github.com are: - Generally the MR/PR flow in gitlab is nicer and allows for more automation. I.e. You can click a button to _schedule_ an automatically merge and delete the feature branch once CI completes. In github you can't auto merge a MR after CI completion and the button to delete a branch only appears _after_ the merge has been completed. Also a really big deal is that on Gitlab you can fast-forward merge a MR into master via the UI, which is impossible in Github. - CI / Pipelines are really nicely integrated into the MR flow and yes you get a generally good (but far from perfect) CI/CD system out fo the box. That being said I think github is catching up on this slowly with it's checks API and almost all CI/CD systems (some of which may be better suited to your needs than gitlab ci) are better integrated with github than with gitlab. I really hope gitlab can improve some of the pain points I mentioned and keep up against github + MS and wish them all the best luck. If anything I think the acquisition of github by MS will just make github stronger - keep in mind that MS has a non-trivial background in creating tools / tech to make devs more productive (some of the notable ones: TypeScript, VS Code, C#, the regular Visual Studio is also not that bad, when you ignore it's hard ties to Windows). Just to be clear: I don't want to appear being a gitlab hater or saying gitlab is generally bad. I just want to warn / make you aware that not everything on gitlab OR github is better vs the other and before you make a switch from one to another make a careful, practical evaluation with multiple repos and CI. Otherwise you might end up regretting your decision and just cost your team valuable time / productivity.
I was feeling exactly the same as you when starting out with go and coming from a Java "Clean Code" background. The one important thing to notice is: &gt;The basic rule: the further from its declaration that a name is used, the more descriptive the name must be. I have since adopted this style and really like it even outside of go. The iterator in a for loop doesn't really need to be *count*, simply *c* is just fine here (if the loop body is small and it is clear that it simply counts). If you declare a *BufferedReader* and you only use it in the succeeding 5 lines, *bf* won't create any confusion about what it is or what it does, but it actually does make the code a little more readable simply through the reduced number of characters / text to scan through. If the context is scoped to 5-10 lines I use short variable names, if the variable is used outside of that, I use descriptive names. This seems to work really well so far.
It's free for students. But microsoft scares me away.
[https://github.com/stefansinca/robin/blob/master/ping/ping.go#L174](https://github.com/stefansinca/robin/blob/master/ping/ping.go#L174) instead of if $var == true, use if $var &amp;#x200B; [https://github.com/stefansinca/robin/blob/master/ping/ping.go#L217](https://github.com/stefansinca/robin/blob/master/ping/ping.go#L217) not sure this is needed, just call strings.Join directly instead? &amp;#x200B; [https://github.com/stefansinca/robin/blob/master/ping/ping.go#L160](https://github.com/stefansinca/robin/blob/master/ping/ping.go#L160) If you don't mean for TStart to be exported, make it tStart &amp;#x200B; [https://github.com/stefansinca/robin/blob/master/ping/ping.go#L153](https://github.com/stefansinca/robin/blob/master/ping/ping.go#L153) non-main packages generally shouldn't exit, which is what log.Fatal does [https://github.com/stefansinca/robin/blob/master/ping/ping.go#L100](https://github.com/stefansinca/robin/blob/master/ping/ping.go#L100) same, but switching method to returning (Ping, error) would be a more idiomatic way to handle it &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
Thank you for taking the time, and also for the valuable input.
Oh wow, didn‚Äôt know about this one. Looks really good at first glance. Thanks!
If the inner struct defines lower, upper and value as *Strings, you can unmarshal into that struct and use them as required after inspecting the operator field. The missing values should be nil pointers if they aren't found in the json, if I remember correctly.
first go for implementation of blockchain its a small project with the use of file system then go for libp2p its a good lib for p2p network or your own preference library and after that you can make full factional dapp in go easy way just use nodejs and its library
https://github.com/dlsniper/gopherconuk
My courses on https://greatercommons.com/ show you the fundamentals of how to build with Go. Take those courses first, then get back in touch with me. discounted access code coverBandwidth 
Thanks a lot ;)
https://github.com/ethereum/go-ethereum Could it be useful?
I came across this a while ago, may be worth looking at: [https://github.com/perlin-network/noise](https://github.com/perlin-network/noise)
Learn about election tampering and the usefulness of paper ballots first.
This is pretty much all the links I know. https://www.vividcortex.com/resources/the-ultimate-guide-to-building-database-driven-apps-with-go http://www.alexedwards.net/blog/organising-database-access http://go-database-sql.org/index.html https://github.com/golang/go/wiki/SQLInterface Structs to tables - https://github.com/samonzeweb/godb/blob/master/README.md 
thanks for the info.
How to be a jerk 101
I'd just use [Poppler](https://poppler.freedesktop.org), which comes with a a `pdftotext` command-line tool you can fork and exec with. I don't know how big your PDFs are, but it's pretty fast. Tested running it on a large tech book (371 pages, 6.1MB PDF), about 1.2 seconds on my laptop. 
Don't know about the OP, but two reasons we use build containers is reproducibility and to be able to use exact versions without having to rely on locally installed tools. For example, if you have Protobuf files and want to run `protoc` (including `protoc-gen-go`), you have the choice between relying on a locally installed version, or using a specific version via Dockerfile. If you do the former, the resulting output files might actually differ if dev A runs `go generate` and dev B then runs `go generate` with a slightly different Protobuf version (we've seen this happen). Docker is underrated as a tool to run other tools (as opposed to generating images that you deploy somewhere). It's really nice to have complicated build scripts that make use of heavyweight third-party software without requiring that the developer know anything the toolchain. 
Yeah. If I was doing any sort of professional work, I'd drop the dough without much consideration. Just a cost of doing business and a perfectly good place to spend considering all the benefit you get from it. But in my hobbyist life, I try to spend as little as possible.
[removed]
OK, fair, but I thought OP talks about a dev environment.
Typically you can just reuse the same DB handle across your whole app. The SQL library has a connection pool under the hood so it's not a problem, but I'm not sure how firebase specifically is implemented. I've used it a bit but mostly for one off stuff and just used one client with multiple calls.
Yes I think that's the best free solution. My PDFs are 1 to 10 pages. There is also docconv which has go bindings to pdftotext I believe. I'll have a deeper look soon. Thanks!
Thanks for the code! However this uses github.com/rsc/pdf which is not very performant I believe. I'll test it soon and get back to you.
Thanks for your input! I think TET is the best solution (or close to) performance wise, but it requires a quite expensive license for PDFs bigger than 1MB. Do you know if their source code is available? I'll probably test it against other suggestions here.
You could also use an inotify variant like [https://github.com/fsnotify/fsnotify](https://github.com/fsnotify/fsnotify) to have event-driven alarms
I've used the heck out of TET. It's very fast, and will actually give you character by character data from the pdf. I built a wrapper around it that creates a grid of characters and uses the char by char method to render text into the grid, then extracts text from the grid line by line. It worked beautifully to process W2 forms generated by moronic mainframes. We processed hundreds of thousands of W2's with that method in around 20 minutes. I haven't tried it with cgo yet, but it should work quite well. There's a single header and library import, and not much else required. The support is also top notch.
You're right. Fixed.
That one is mdtool's fault. Fixed, thanks.
Yes.That's a good suggestion. But the application is running inside K8s and I don't have control over it. The health probe of the pods seems like doesn't capture the hanging also... 
I did a test against a single pdf with about 13,000 words and it took 146ms. Not sure if that meets your speed requirements. It probably depends on the average document size. I'm not sure if Unidoc would fare better. I'm not familiar with its method of outputting raw text, though I'm sure it has one.
Also great. :)
Sounds like you need to fix the health probe. Your probe is probably responding happily when real application flow would get stuck.
What is YCSB?
Thank you! &gt; How does your end solution handle your previously made point We start the life of every request by getting a value copy of the state as it was at that time, and that copy can't be touched by any other goroutine. To make sure of that, we need to be careful that the state struct doesn't contain any mutable values (slices, maps, ...) and to make copies of those as well if it does. The language just doesn't give us many guarantees for immutability. &gt; I wonder if a simpler path might be to add the piece of state to the http.Request's context. Then we still have the problem of making sure that no one modifies the state while we're working with it, so we need to put some kind of lock around it while we put the state in the request's context. Someone may also argue with you that doing that is an abuse of the context package ("[Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions".](https://golang.org/pkg/context/), plus we now have to start casting from `interface{}` so we lose what little help we get from the type system. &gt; Additionally, you could use the atomic pkg to update the state value(s) in place and avoid any race conditions in accessing them. That only helps with making sure we avoid race conditions in individual updates. Suppose we have a state struct ``` type State struct { A int } ``` and we have a long-running requests `X`. Then there's nothing stopping this sequence from happening: ``` Request X starts its life with state {0} Request X checks the value of state to use it somewhere Something updates the state to {1} Request X again checks the value of state for something else ``` and we have sadness. Wrapping the whole `State` in an atomic operation puts us more or less in the territory of a mutex again, with more complications as the complexity of `State` increases, and we also get as `interface{}` casts as a bonus.
a `[]byte` slice doesn't have to contain string, it can be arbitrary binary data. `Printf` with `%s` will try to print the content of the slice as string, but if isn't it one, you'll get weird characters. Using `fmt.Println` or `fmt.Print` you'll get the byte values.
thanks a lot :)
It is exactly what I need.üëè
Does it support full github markdown?
Maybe You can use strace with the -c option to check what time is spent in the network. 
&gt;I have a done a little bit of CPU profiling with pprof and I get a result of 3% of total time being "cpu profiled". I am assuming the remaining 97% are network calls, that would totally make sense since I am calling AWS SQS and Elasticsearch a lot. This does not make sense, network io is none blocking in Go, once you git any for of io you give up control of your goroutine to the scheduler so another goroutine can run. The CPU should always be busy processing data and not waiting on io. Can you update your answer with the actual results you got or link to them if they are too big, I suspect you are miss reading or interpreting the results. More than likely the '*result of 3% of total time being "cpu profiled"*' is the fact that the profiler is a sampling profiler and this is stating that 3% of calls were profiled - but that is my interpretation or your interpenetration of the actual results.
Why do you copy the compiler into the repository itself?
I think you are right. Full text from the box in the corner: Type: cpu Time: Sep 16, 2018 at 9:05pm (AEST) Duration: 1.08mins, Total samples = 1.87s ( 2.89%) Showing nodes accounting for 1.62s, 86.63% of 1.87s total Showing top 80 nodes out of 289 So that's just from the sample. 
Now this utility support a simple traceroute-like feature.
I feel this is the right answer.
I need to resize images to 480x640, 720x960, 1080x1440 and 1440x1920. The images are usually photos of people..
Except when working with vgo. 
Sure for CI, but developer needs to configure his personal token to go get anything. 
Sorry but what's an MCU? A microcontroller unit? (I'm not a native speaker, and google brings in some Marvel's crap.)
That's because it is.
This isn't REST. This is RPC over HTTP2. It's fine to do RPC, it's not REST. REST need to have URLs build into the response messages so the client doesn't have to know ahead of time where to get a resource. gRPC has to know ahead of time where the endpoints for various resources are. That's why they make a client.
It seems to be using [`russross/blackfriday@v2`](https://github.com/russross/blackfriday/tree/v2), which says it supports common extensions such as tables, fenced code blocks and more, so it might be pretty close to GFM.
A lot of repos use the "good first issue" label. This search might be of use: [https://github.com/search?l=Go&amp;q=label%3A%22good+first+issue%22&amp;type=Issues](https://github.com/search?l=Go&amp;q=label%3A%22good+first+issue%22&amp;type=Issues) I tend to end up contributing to projects I use myself, libraries and tools I use at work, etc. Adding godoc and testable examples can be a nice way to get a feel for a project without having to have super in-depth understanding of how it works.
Yes Micro Controller Unit.
Take a look at https://www.codetriage.com. You can find a number of open source projects that could use some help. 
You could add tracing to your code and use something like [Jaeger](https://www.jaegertracing.io/). A small Hello World [tutorial here](https://github.com/yurishkuro/opentracing-tutorial/tree/master/go)
&gt; REST need to have URLs build into the response messages so the client doesn't have to know ahead of time where to get a resource I am convinced you are referring to [HATEOS](https://en.wikipedia.org/wiki/HATEOAS), not [REST](https://en.wikipedia.org/wiki/Representational_state_transfer). I may be mistaken.
The article mentions that Part 2 is where the REST component is added in. I'm assuming it will use [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway).
I figured out the way. I defined the module name in the "require" construct with v0.0.0. Then I used "replace" keyword to point that package to the module in any folder in my FS. Thanks for your help I appreciate it.
In the thesis, REST requires HATEOS. Pretty much everything else is RPC/HTTP. 
Or you can use NEO, there‚Äôs a nice tool for compiling NEO smart contracts using go: https://github.com/CityOfZion/neo-storm
I thought I couldn't hate emojis more than I already did... I was wrong.
it's easy, contribute to something you are already using.
I don't really use all that many Go tools, although I have been contributing to one or two I do use.
If you have free time and want to contribute to something, im working on this thing, im still learning about Go, any contribution is welcome https://github.com/Kilgaloon/Leprechaun
this is pretty cool! good job! will rwtxt.com be available for a while? I kind of want to use it
Will have to look later. This is a field of been super interested in. I currently do a lot of embedded programming in C/C++ because, well, their standards. But I‚Äôve been interested in how modern languages like Rust might give us benefits in this space.
There are two problems with this proposal: 1. For functions returning multiple values (which is very very common in Go), it means the auto channel must be a channel of some kind of auto struct, which is not something straightforward enough. 2. For people who don't care about the return values, they need to do something with the auto created channel or it's leaking memory.
While this is not an effective way to find projects, it might introduce you to a few while you're just chilling on reddit. I've seen people asking for feedback on their projects at this subreddit, so I'd recommend reading those posts and just start a discussion (or do more). I posted a project a few days ago and was lucky enough to get suggestions that, I think, greatly enhanced my project's readability. While it wasn't a contribution in form of code or comments, it showed me a different way to think about my design. Which I am truly greatful for.
Do you mean "absolute beast" as in "pretty bloated classic Rails web app"? I used to use Gitlab but now prefer gogs or gitea. They are just so much lighter weight. The CI piece is interesting but Drone is actually getting pretty competitive at also a much lighter weight.
I believe that the original interpretation is correct. All goroutines were blocked for 97% of the samples. You can check this against the total CPU time the kernel reports, as see in 'top' (if you run long enough), or printing the result of syscall.Times() before exiting. IME such low CPU utilization is common for naively written programs (fetch 1 data set, process fetched data, loop) which fetch from non-local storage.
Yeah, that is just the summary line of the profile - it only tells you about the profile and does not really give you any details about how your code preforms. For that you need to analyze the detailed report to find where most of you application spends its time. But this will only give you CPU performance, by optimizing it you may be able to improve throughput (requests per second) but might not see much of an impact on latency (how long a request takes) if your work is largely I/O bound. For latency you will need a different set of tools as the CPU and memory profiles will not help much with this. For this you should look to your metrics system (or start by adding a metrics system - [prometheus](https://prometheus.io/) with [grafana](https://grafana.com/) with the official [go client](https://github.com/prometheus/client_golang) is a good way to go). With this you can add metrics around how long each request takes in total as well as how long each outgoing request takes - as well as loads of other performance related metrics. With this and placing the metrics in the right places and using the right graphs you can gain a lot of detail about where the biggest slow downs are in your application from a latency perspective. [Percentiles](http://www.statisticshowto.com/probability-and-statistics/percentiles-rank-range/) are good for this latency metrics. Combining this with CPU and memory profiling of hot areas and seeing what you can do to reduce the impact of external services (mostly timeouts where appropriate) you can reduce the latency while increasing throughput of your system. Or at the very least understand what your application is doing even if you have no control over it at this point in time (like an external service).
The first point is good. But I think the second one may not be true. If the proposal is to do the autochannel behavior only when the semantics are "&lt;- go add(1, 2)" then it is implied that the hidden channel is drained. I don't necessarily agree with the proposal though. 
1. CGO works with structs, nothing serious. Compiler will detect `&lt;- go` and create appropriate wrapper function (that is trivial), and only one thing is automatic struct to `val, err` conversion. func sync(a, b int) (val string, err error) { /* stuff */ } func async(a, b int) chan struct{ val string, err error } { /* async stuff */ } But the struct is useless, and `&lt;- go` should detect `val, err :=&lt;- go` or `(nothing) &lt;- go`. And expand a struct when it needed. 2. `chan struct{}` to catch end of execution of a function without a value. Ok, if there is a value, but it's not used. For example select { case val, err :=&lt;- go add(1, 2): // case val, err :=&lt;- go add(3, 4): // case &lt;- time.After(): // } Values of both `add` functions can be not used. And after the select GC clean channels with values, since there is no references to them. No memory leaks.
Ah, this way a channel must be buffered. To be sure that a function will write to it.
Yes! I'm in Kalamazoo and would love to attend and present too.
For example: select { case err :=&lt;- go exec.Command("wget", "google.com"): // handle the err case &lt;- time.After(5*time.Second): // it looks like google is down } Or var fl, err = os.Create("file.txt") if err != nil { // handle the err } defer fl.Close() select { case _, err := &lt;- go io.Copy(fl, someSource): // handle the err case &lt;- time.After(10*time.Second): // timeout } &amp;#x200B;
:( I wish but I'm in Illinois.
My schedule is pretty busy, but I'd love to attend if the time works.
I live in GR, I'd be interested.
I‚Äôm based in Holland and would be interested. 
Marvel Cinematic Universe
Thanks for your experience in gigs and gitea, I'll check em out.
Haha for some reason I always use that one, too!
I don't understand how does it have anything to do with CGO. Go is a strong type language so `val, err := &lt;- go func()` doesn't work. Also it conflicts with the existing [multi value receiver operator](https://golang.org/ref/spec#Receive_operator) (e.g. `val, ok := &lt;- ch`).
thanks so much will check them out, out of curiosity do you work there?
No, I don't. I just happened to read their blog and remember that they had openings for Go developers some time back. 
I know [Vend](vendhq.com) have some Go in production.
Make a new client like concourse.NewClient: https://github.com/concourse/go-concourse/blob/master/concourse/client.go
[https://github.com/snickers/snickers/issues?q=is%3Aissue+is%3Aopen+label%3Aeasy](https://github.com/snickers/snickers/issues?q=is%3Aissue+is%3Aopen+label%3Aeasy)
[removed]
[removed]
Dave Cheney had a talk about errors so I‚Äôd watch that. (https://youtu.be/lsBF58Q-DnY) My takeaway from that was to return a regular error that you can assert for behaviour. This way you can minimize package dependency but still extend the functionality like you want. 
There's some cool undocumented stuff here that you can see if you dig through the source code. &amp;#x200B; You can drag and drop files into the editable text area. The resultant link is pasted in markdown automatically. Hotlinks for images, links for everything else. All attachments are jammed in as blobs in the sqlite database. &amp;#x200B; There's automatic document similarity algorithms running, which links documents together. &amp;#x200B; Search function works with wildcards. &amp;#x200B;
[Weta](http://wetafx.co.nz) is using Go for some of its project 
Come along to the go meetups if you don't already. https://www.meetup.com/Go-AKL/
I totally agree to favor gogs (or gitea). Am I the only one having memory issue with GL ? Git Lab is so slooooooooooow compared to gogs.
So 1. if there is `val, err`, `_, err`, `_, _` and `=` or `:=` then the statement expands anonymous structure like `struct {val string, err error}` to this variables 2. if there is not, then we just drop the structure; if a function has no reply, then empty structure used 3. the hidden wrapper function wrap reply of function with the structure, and pass the structure through the channel 4. in this case `&lt;- go` multi value receiver operator doesn't make any sense, since programmer has no access to the channel. The channel can't be closed, programmer can only read one value from it. Nothing more. Also, the channel can't be assigned to a variable. About CGO. If we call a Go function from C, then we got structure ([https://golang.org/cmd/cgo/#hdr-C\_references\_to\_Go](https://golang.org/cmd/cgo/#hdr-C_references_to_Go)).
What about cities in Australia? We're a [Perth company](https://www.ninjadojo.com.au) that uses Go. :)
E.g. just treat `&lt;- go` as language statement that works another way, neither than `&lt;- somethingExceptGoFunc`
Overlooking that the recieved value will always be 0 because the channel is closed when you read from it ( as the defered close is called upon function return)... There is something that all proposals must prove to the Go team in order to be accepted: &amp;#x200B; That the benefit gained from a change is much greater than the costs it brings. &amp;#x200B; In the past the Go team hasn't felt that "syntactic-sugar-so-the-programmer-can-type-less" was a good enough reason. But who knows, if you can make your case in a way that convinces them otherwise, the proposal may stand a chance, GL! &amp;#x200B; 
I think being able to do this automatically is a good idea, but we'll probably be able to handle this case with generics in Go 2.
YES, just tried. same results. But, i tried with rust binary running, it also has around 4GB Virtual Memory, does this means, it is upto OS how much to allocate for program ?
Apart from the ones mentioned: func Foo() error { err := SomeOperation() if err != nil { return err } _, err = ioutil.ReadFile("filename") // Type error: can not use error as TemporaryError return err }
Thanks, yeah im looking considering Australia as well if Auckland doesnt work out.
&gt; This way you can minimize package dependency I don't think this argument makes sense. In general you are still having a dependency - you rely on the function you call, to behave a certain way. You also will still import the code from *some* place. So I don't really see how any dependency got minimized. You only crippled the ability of the compiler and static analysis tools to detect the dependency and make sure you didn't make any mistakes. e.g. the prevention of circular imports isn't overly pedantic compiler issue, it's there to prevent you from creating a probably broken package structure: You should build your program in layers. Personally, I don't get why removing an import-line is so important to people.
If everything is right then my CMD had a problem 
you might be interested in this: https://zinc.rs/
I'm not sure why you think that just using an anonymous proprty of type `error` implies that your type will implement the `error` interface. You still need to add the `Error() string` method.
Rather than a picture you should copy your code to [the go playground](https://play.golang.org/) (or just as text in the post) so people don't need to type it all out again to test it if they don't immediately see the problem.
Well is there a problem I've tried for 1 hour now and it seems to work but like it won't allow that last input to go through. Sorry about that I would expect people here to take look at a beginners code and be like that's wrong. 
Do you want me to type it in a comment or what. But I assume you ran it and there is no error besides the redundant \n 
Ad? I thought they call it "Growth Hacking"? :p Yeah, I'm not the best blogger and was trying to hit a more general tone than write something filled w/ tech jargon etc., but you're right, "We switch from Python to Go and saw a 10x boost" was one of the blog titles we came up with; that and, "There's this thing called concurrency, if you're do some scraping, better use something that allows you make multiple http calls at once" -- not sure how much that would resonate. &amp;#x200B; We're just happy we took the plunge tbh; between the baked-in concurrency and the \`net/http\` lib - Go was made for this!
&gt;- existing tools won't lint for that I expect that would be simple to add, check if the return value implements error instead of exactly error. Whether or not an interface also satisfies error should be easy to check at compile/parse time. - you can't use the stdlib tools for working with errors (in your code only) Could you give an example? A FooError type is automatically coerced to error: https://play.golang.org/p/IyTIL_BJ2Yl - the function can't be used in places expecting a function that can return an error That's true; it's trivial to wrap though: func SpecialFunc() FooErr {} DoWithFunc(func() error { return SpecialFunc() }
+1 for playground 
Generally you would Edit your post. The best thing would be to paste the Code to the go playground and add a link to your post. Also I'd work on my attitude if i were you. This isnt a official support where employees are getting paid for their time. 
I know sorry if attitude is not the best but working on a basic thing for an hour makes you pissy I'll edit the post and add the code there :) 
[From the spec](https://golang.org/ref/spec#Interface_types): &gt; An interface T may use a (possibly qualified) interface type name E in place of a method specification. This is called embedding interface E in T; it adds all (exported and non-exported) methods of E to the interface T.
Yeah, I ran into it when I tried using this in some existing code. It's trivial to fix and it's not a huge problem, you just need a separate variable for different types. If you had a really long function that calls dozens of other functions that each returned a different custom error type, that could be bad since you'd need a dozen different typed variables, but I think you should just break up that function at that point.
Thanks. That is to say, I‚Äôve written a handful of embedded code in Rust and actively following that, but definitely interested in alternatives. Go could be good. Not super interested in the embedded Node.js stuff or MicroPython because it just feels wrong lol.
Here is the code in GO playground [https://play.golang.org/p/SVXAaED\_mpE](https://play.golang.org/p/SVXAaED_mpE)
Really? I have no idea what you mean?! üôÉüò© It must be the core unicode support in Go that made be go overboard üòÖ
https://up-for-grabs.net/ "This is a list of projects which have curated tasks specifically for new contributors."
&gt; It's trivial to fix and it's not a huge problem, you just need a separate variable for different types. It's enough of a problem that the Go creators introduced `:=` to fix it. It's main feature (over `var` declarations) is that it allows *some* variables on the left hand side to be newly defined, while *other* variables are not. The "other variables" here being `err` in &gt;90% of cases, because it was the motivation for this behavior. Don't get me wrong, I like the approach, I contemplated it myself. But I think for it to be practical, there need to be two changes to the language: 1) we need to add variant subtyping for functions and interfaces (so that you can use something with a method `Read([]byte) (int, MyError)` as an `io.Reader`) and 2) it needs to be allowed to redeclare `err` with a different type - either by using type unification, or by just special-casing `err` and always have it have the lastly used type. Ideally, you'd also want 3) to solve the nil-pointer confusion, so you can actually return concrete error types (reducing the boilerplate and unnecessary indirection that comes with wrapping them in interfaces), but that's optional. Unfortunately, even 1) turns out to be non-trivial for Go as it is.
Oh this topic interests me! Using github.com/hhrutter/pdfcpu/pkg/pdfcpu to extract the images followed by gocv.io/x/gocv to deskew then github.com/otiai10/gosseract to OCR then (because I haven't figured out how to use pdfcpu to do it) github.com/jung-kurt/gofpdf to rebuild the pdf with transparent text so it's searchable. 
I ran your code on the Playground, fixed the two compiler errors, clicked Format, then it compiled just fine. Doing this on my phone, though so ymmv.
Yes but I try running on CMD and it runs but won't allow the last input 
By CMD I‚Äôm guess you mean windows command prompt? I‚Äôll check this when I get home tonight, curious to see wth is going on.
Ok thank you 
It's not required. You can implement HATEOS in your REST service, but not necessarily it needs HATEOS to be a REST service.
Just had an idea. Since you‚Äôre on Windows try adding a newline in your format string for scanf. So *fmt.Scanf(‚Äú%s\n‚Äù, &amp;name)* ‚Äî do this for *like* too.
Ok that might work 
My dude 10000000000000 gratitudes of thanks it has worked üòÅüòÅüòÅüòÅüòÅüòÅüòÅüòÅüòÅüòÑüòÑüòÑüòÑüòÑüòÑ 
Would you also happen to know how to have the input read even with spaces like std::getline(std::con (string)) in C++ 
Well like if I say play sports it will only include sports 
&gt; This is literally the reason `:=` exists. Could you please point me to the document you got this information from?
https://tip.golang.org/doc/faq#Why_does_my_Go_process_use_so_much_virtual_memory
Let me know, I am working for a nice company in Sydney and our next product is a fully distributed project in go (no blockchain!)
Of course there‚Äôs a way. Take the time to scan the docs for the fmt package. There‚Äôs more than one way to get input.
It's a proposal for Go 2, so "more current than tip". It's the first source I could think of :) I've heard that elsewhere too (and it makes sense intuitively, given the differences between `var x, y = Foo()` and `x, y := Foo()`), but can't remember all the places. `:=` is in the first submitted version of the spec, so there's no way to actually refer to the design rationale (as it happened offline, long before Go was open sourced).
&gt;GoFr lol bien jou√© les mecs :'D
Ok, makes perfect sense. Thank you again.
For [reference](https://godoc.org/fmt#Scanf): &gt; Newlines in the input must match newlines in the format. 
IIRC, the maximum size of memory allocated by a process increased in Go 1.11. I think the increased allocation is space reserved for the bitmaps, ie. the mechanism resolving internal pointers to allocation addresses. In any case, virtual memory size is not important. It's virtual after all. Watch for the RSS size instead, that's what the OS must really handle.
Gauffres.
ZeroLog takes an io.Writer in its constructor so you can implement that interface and make it print what ever you want. ZeroLog also comes with a built in console writer which might give you what you are after: https://github.com/rs/zerolog/blob/master/console.go#L40 but if not its a good base to see how you can implement your own writers for Zerolog.
It is not "RPC over HTTP". Look at the [proto file](https://github.com/amsokol/go-grpc-http-rest-microservice-tutorial/blob/part3/api/proto/v1/todo-service.proto) with HTTP/REST annotations for each method. Also please look at the [REST client](https://github.com/amsokol/go-grpc-http-rest-microservice-tutorial/blob/part3/cmd/client-rest/main.go). It does not know anything about gRPC. It uses GET, PUT, POST methods and JSON.
Well, it is very good questions. Proto compiler does not understand GOPATH or go.mod. It requires to provide path to include file obviously. So I decided to copy include files to the project third_party folder. I am not sure is it the best approach but for me it is the easiest way to manage them.
Thanks, that got me going (just need to implement an http.Client with basic auth. But at least I'm getting Unauthorized responses from Concourse ATC now.
Alright, you are absolutely right, it will be REST. However, what's the point of restifying gRPC? I would prefer the method of RPC over HTTP if I need to have a gateway. 
Vend and Movio are posterchilds.
Mouais -- je crois que c'est plut√¥t "GoFr" == "Gopher"
Ptet bain qu'oui. 
Je trouve pas dans Overcast (ce qui utilise Apple Podcast Directory, je crois). Est-ce-qu'il y a un lien RSS?
My try: https://play.golang.org/p/a9fQVjqCpEO Changed the `Scanf`s to `Scanln`s per other suggestion from the thread.
[http://feeds.soundcloud.com/users/soundcloud:users:503020458/sounds.rss](http://feeds.soundcloud.com/users/soundcloud:users:503020458/sounds.rss)
F√©licitations ! Tu est le premier √† relever... :-)
Go has potential, but as I mentioned in the video it can struggle on low-end MCUs. When you get down to 16KB flash, then there‚Äôs not a heck of a lot you can do. Having said that, Go for ESP would be excellent and I intend to write support for the ESP32 and ESP8266 for emgo. 
Thanks so much for this post! I've been wondering about this myself and all the posted resources here are great!
Hey gopher, I made a ec2 mocking library for testing aws-sdk. I would like to get feedback from the community. It is not that mature, even library is tailored a bit for internal use. If anyone interested in using, Please raise issue I'm happy to refactor in more generic way &amp;#x200B; Cheers!! Happy Coding. &amp;#x200B;
Well I tried all of these changes with scanf and they didnt seem to work 
Merci pour le podcast, c'est pr√©vu d'inviter d'autres personnes dans le podcast ?
Congratulatamos ! Euh... yo usted le primo qui se relevantado !
Oui, Peut-√™tre m√™me dans l'√©pisode 03. Si vous voulez participer, n'h√©sitez pas √† me le faire savoir par mail, en me pr√©cisant comment (rubrique, interview, jingles, cover itunes :-) ) 
Il gagne quoi, une peluche?
I don‚Äôt think the goal is to remove every single import line but more to prevent a calling function from having to also import another package (the one defining an error). Asserting for behaviour does not break any static safety. And a normal error value is a well known value to return. 
Also, watch Dave Cheney‚Äôs video. He seemed well aware of the reasons why circular import loops are more than just a pedantic compiler issue. PS, sorry my other reply wasn‚Äôt directly to your comment. Misclick, but at least there aren‚Äôt a ton of other comments. 
Bonne question... On va trouver ! @sacrehubert: contacte moi par mail...
Let's imagine I'm freelancing and I organize my code like `~/projects/client_name/project1`. Under Go's system, without changing $GOPATH each time I switch between projects, then all projects using golang cannot be organized inside the respective client directory. This is a perfectly valid complaint and worth fighting for.
No. Put your files in `~/projects/src/client_name/project1`. It's not worth fighting for and resisting the Go convention just makes things needlessly difficult and wastes your time. 
first time seeing this newsletter, filled with great stuff! 
H√©h√©h√©, puisque vous insistez! :)
√âl gana qu√©, un animal de peluche? 
I sometimes look at the projects I use and am excited about. Like Logstash üòã
If you don't want to write code to solve your problem, you could run it through `jq`, something like this could work for you: $ echo '{"time":1494567715,"level":"info","message":"hello world"}' | jq -r '. | "\\(.time)\t\\(.level)\t\\(.message)"' 1494567715 info hello world
Well, I would not say it is so much work to make rest client. You have to add annotations to proto file and few lines of code to start HTTP/REST gateway. Nothing more. So I like gRPC too. It is great protocol inside Company. But if we are talking about to publish API outside gRPC is not the best one. You have to use HTTP/REST. Gateway allows you to do it easy. IMHO.
&gt; 2) it needs to be allowed to redeclare err with a different type - either by using type unification, or by just special-casing err and always have it have the lastly used type. You can also solve that by declaring (not "re"declaring) `var err error` first. Then you lose the advantage of the special-purpose error, though. I find myself generally just returning `error` and casting in the caller if I need something, which fits with how almost everything else works.
&gt; I think shadowing your error variables is a bad practice. Use `errcheck`. If you overwrite an err without having handled it, it counts as ignoring it. And you need `errcheck` for the common case of just not saving the error at all. If I'm statically verifying that every error is handled, it ceases to be bad practice and just becomes an optimization (runtime or human convenience), because you could trivially rewrite the code so that each err is in its own conceptual scope and there is no longer truly any shadowing going on. (You can't truly do that since you can't scope just one variable like that, but you could imagine what that looks like.)
&gt; more to prevent a calling function from having to also import another package (the one defining an error) But what I said is, that this is not a goal that has any benefit. On the contrary. It's cosmetic at best and harmful at worst. The package will end up in your binary anyway, it does not matter at all how many or which packages import it. Safe from the issue of cyclic dependencies, that you can break with this pattern. Which you shouldn't. &gt; Asserting for behaviour `interface{ Temporary() bool }` (the pet example) is not "behavior". It's a marker-method - an emulation of inheritance. That's *exactly* my criticism of this post/talk. You are not actually using interfaces to abstract behavior (what they're for), you are doing it to hide types from static analysis.
Maybe https://github.com/CovenantSQL/CovenantSQL/tree/develop/rpc
You can use godoc.org to see the documentation created by godoc. Check out [godoc.org/github.com/concourse/go-concourse](https://godoc.org/github.com/concourse/go-concourse).
I've been writing a simple toy project over the past few days which generates profile pictures based on usernames, and it's at a point where I'd like some feedback on the code/design. It's my first full project in Go and I've enjoyed writing it. The code provides a web server and also command line tool to generate profile pictures. Here's an example hosted on now.sh: https://ppic.now.sh/jackwilsdon You can change the size of the image by setting the `size` query parameter: https://ppic.now.sh/jackwilsdon?size=128
&gt; Then you lose the advantage of the special-purpose error, though. Right, but the point was exactly to get that.
&gt; because you could trivially rewrite the code so that each err is in its own conceptual scope That's what I'm actually doing, but it looks ugly.
&gt;it also exposes extra information without having to do a type assertion. &amp;#x200B; That may be true, but for others to use your code, it does imply that they have to know the type to understand they have to treat it as an error. One of the adages of go is that errors are values. As such, you can use \_anything\_ as an error \`\`\` type foo struct { Code int64 Reasons \[\]string Related error } func (f foo) Error() string { return fmt.Sprintf( "%d error, reasons:\\n%s\\n\\nRelated: %+v", f.Code, strings.Join(f.Reasons, "\\n"), f.Related, ) } \`\`\` Now this is an error type, return it in a way that it's plain to anyone that they have to handle the error: \`\`\` func doFoo() error {} \`\`\` You can't assume that the caller will need to access specific behaviours of the error type. In fact, more often than not, they'll just stop what they're doing and fail (hopefully gracefully).
&gt;The package will end up in your binary anyway. What ends up in the binary isn't everything in the package, it's what you use. So removing an import isn't just cosmetic. Similarly, if you return an error value with a 'Temporary() bool' method attached, if it's passed on to the next caller, then it will be pulled in. If it's used, it will be pulled it. If you handle the error without using it, it won't. I wasn't saying to OP that 'interface{ Temporary() bool }' is what OP should do. I was suggesting the path that Dave Cheney's talk advocates. Which is return an error 'func() error'. Then if you want additional behavior on top (admittedly should be a rare occurrence) then you add the 'Temporary() bool' method on top of the error. You don't have to export the custom error type as you're just returning an error value. But if someone happens to want the 'Temporary() bool' method they can assert for it. Seriously, watch the video before telling me what I was trying to say when I wasn't saying that at all. If you still disagree with that method, then fine, we can discuss those points. Though I'll still likely disagree. Dave Cheney is fairly well respected I believe and his viewpoint isn't just some off the cuff reddit comment, but a very well informed opinion based on working with Go code from near the beginning of the open source community for Go.
Have you tried the `net/http/pprof` editor? Just import it, and hit the corresponding endpoints, capturing the data. You'll get a full breakdown of the call-graph, you can profile memory and CPU usage and all sorts. It can, amongst many other things, just tell you how much time is being spent waiting for responses, DB connections, etc... There's a [golang blog post](https://blog.golang.org/profiling-go-programs) about it.
Name me a function that does not deal with IO and returns a string that is *malformed* (non valid UTF-8) and the documentation does not state otherwise. If you return a byte-slice, well I don't care. I will not make any assumptions about it. The problem with not having UTF-8 in a string is that rangeing over it will yield hilarious results, converting it to a `[]rune` will also be undefined and the all functions that read runes in general will have a rough time effecting a lot of interfaces and especially the strings package.
 scanner := bufio.NewReader(os.Stdin) for { line, err := scanner.ReadString('\n') }
 reader := bufio.NewReader(os.Stdin) fmt.Print("Enter text: ") text, _ := reader.ReadString('\n') fmt.Println(text) 
Please do not call the values returned by `bufio.NewReader` to not confuse them with what `bufio.NewScanner` returns.
Did it get hugged to death by this subreddit? The site is down as of 1:54 PM EST.
Virtual memory is not real memory, go read about vsz and rss
That's rather nit-picky. 
You demonstrated no knowledge of the video by saying I was suggesting something I didn't and wasn't in the video I quoted in the first line of my reply. My whole post was about his video, so saying he's respected in the community isn't an appeal to authority. If you have an article stating your position I'll read that when I have time, but I'm done for today.
https://github.com/DATA-DOG/go-sqlmock is potentially nice to be aware of, although I haven't used it.
Aeroqual[Aeroqual](http://www.aeroqual.com/)
If you want to test with a real database rather than a mock, I personally favor using something in-memory which is an option for SQLite and prevents massive slowdowns from replicating data to test databases. If you have stored procedures or are simply not compatible with SQLite, you will need to make some complex, slow framework or try to do everything in transactions that you roll back at the end of each test.
I fixed the link 
Would be super interested in the October 9th meetup
Great video for newcomers. But, imho, the most important part such videos lack is the fact that not only named functions can be `defer`ed, but also anonymous. [Like this (playground link)](https://play.golang.org/p/NWE6edMepXW). So you can put some logic at the end of your function call, depending on the outcome of certain events that took place during function execution.
Why not try to mix the two. https://play.golang.org/p/wVKJGyhRS_f Personally I always thought jQuery felt messy. I still need to separate things into blocks of types that are reusable but messing around it's not bad.
Thanks. I did read through that too, but found it about the same as looking through the code itself since there are no descriptions. If I get more familiar, I'll try and contribute a sample starter and some human documentation to go-concourse.
It's worth just consider what tests you expect to catch what, and what rate of change and risk there is. It's always just a matter of increments of confidence and automation vs human. Peer programming, DBA review, plus any full system tests or human regression tests could cover some of these, or the rate of change and associated risk could be lower. Using a real database could get you a bit better confidence, but slow your tests down. On a previous project it took me quite some time just to provision a database in a container (a few minutes to run through schema upgrades). Even then, there's every possibility with some database types that your setup won't really match prod (sharding, behaviour when an in-memory table is lost on db reboot?). You probably also won't catch issues with the query plan or lack of indexes etc. If you use a real database and run multiple tests, you'll probably have as more statements to do setup and teardown of state than the changes themselves, so you could find that you expend a lot of effort. Plus/Minus side - once set up, hopefully most of the change is in the business logic that shouldn't be too tied to tests on how the data layer functions, so in terms of day to day changes, these are possibly lower value. You could pull it out and version it separately from the business logic to reduce the testing overhead. NB: This is not a post saying "don't automate" this is a post saying that you should know what value each test provides and always compare overhead to that value. Testing everything perfectly is a very high overhead.
I would say: 1. With Go, the callback (and promise/await sugar) insanity goes away. You write regular synchronous code everywhere. 2. With Go, you can use multiple cores. 3. With Go, the stdlib includes almost everything you need. 4. Go is far behind Javascript for mobile platform development. 
[removed]
You could have just written it down. It just wasted 5 min of my life. He just talks about [this](https://golang.org/ref/spec#Passing_arguments_to_..._parameters): func f(ii ...int); ss := []int{0, 1, 2, 3, 4} f(ss...)
https://play.golang.org/p/N8MS9jdxuNO Go string value is a sequence of bytes. Full stop.
[removed]
If you have a load balancer in front that is aware of stuff like this, for example Traefik then you wouldn‚Äôt need to worry. Otherwise you‚Äôre wanting to do this yourself, remember to store the certificates somewhere so you don‚Äôt request a new one on restart due to rate limits. Along with your TLS config generate a certificate using https://godoc.org/golang.org/x/crypto/acme/autocert
I agree that it's better to use external TLS termination. Despite the fanfare that it's not necessary, I'd operationally prefer not to have to rebuild and re-deploy my Go applications because something in `crypto/tls` got patched. Apart from the autocert suggestion, `crypto/tls.Config` contains a `GetCertificate` callback which allows you to dynamically return a certificate in response to the TLS ClientHello message. So, you could hypothetically return a different certificate to every client. This is mentioned in the [docs for `crypto/tls.NewListener`](https://golang.org/pkg/crypto/tls/#NewListener).
If you hadn't yet made any serious movement on this, I just wanna throw my hat in as well and say that this package is really important.
As others have mentioned, the Go SQL mock library is by far the best I've seen yet for testing database interactions. That being said, based on everyone's comments so far, it's important to know the difference between *unit testing* your interactions and writing *interaction tests* for your code. For the latter, you'll need to go without libraries like Go SQL mock and just call the database directly. But that may involve writing some database cleanup code along the way. 
It depends on your use case. For self hosted small repos gogs is great, for large teams working across multiple departments, not so much.
I think what you‚Äôre asking is: How do I host the .well-known value on my website without shutting down my server and running the letsencrypt server? If this is simple custom web server you‚Äôve written, you could add some functionality to an admin panel to start hosting this file. Lets encrypt can be run manually and will wait for you to host this file. Otherwise you are looking for some non-Go solution. 
\&gt;How would you guard against these types of issues? Just an idea, 1 how about ORM? (eg Gorm), you have less chance of making raw sql statement. 2 use stored proc ? (dont write raw sql on the code, let db handle it with correct param, less chance of making mistake from code, well still chance of stuffing up stored proc, but thats that) &amp;#x200B; to have good Db scaffolding, you need migration scripts, extensive size of data (not few 100Mbytes, but Gigs) and automated ways to build/rebuild Dbs. Common problem I have experienced was the statement running overtime (query timing out), locking other table/data, causing 1000s of http timeout, and SQL written with 10s of joins that arent tested for performance causing above issues. These arent really code issue, but rather full CI/CD problem to solve. So I always ask devs, whats the expected size of the table ? 10M? 10G? 1T? design it accordingly and fill the staging DB matching the expected size of table. &amp;#x200B;
I was under impression that autocert does renewal automatically
I'd use https://github.com/testcontainers/testcontainer-go I use the java version extensively at work both for postgres, cassandra and pubsub emulator.
That being said my mind read scanner and i thought \`bufio.Scanner\` and not a \`bufio.Reader\`. I had to re-read it a couple of times to see it. Also \`bufio.Scanner\` would be a good fit since it handles multiple types of line endings.
it dose but if you have somthing running on port 443 it will refuse to renew 
[removed]
awesome. I was wondering what the equivalent of dicts was, and voila! maps, which are after all a mathematical abstraction (mapping keys into value)
The easiest answer is going to be to put the certificate on some kind of reverse proxy (or load balancer, what have you) that updates frequently, and have a long-lived SSL cert on your service or just unencrypted if it's on the same box. If you used nginx as a reverse proxy whenever the cert updates you could just send a `SIGHUP` to reload configuration. If you want an all-golang solution, then you have two options, one involving a custom listener (that you can pass into `http.ServeTLS`) or another that would require a custom `http.Server` implementation. If you create a custom listener, you can initiate the socket with `SO_REUSEPORT` which would solve the problem you mentioned below ("two things are trying to use port 443"). You'll be able to have two things on the same port, and then kill the old one as the first comes up. For the second you would need an `http.Server` implementation (heck, feel free to copy and paste the stdlib) that has has an `UpdateTLSConfig` method that will change the TLSConfig pointer/struct inside the server (don't forget a sync.Mutex or an atomic.Value to prevent race conditions!)
You might want to look at all the pre-made image libraries from several years ago: - http://scott.sherrillmix.com/blog/blogger/wp_identicon/ - https://www.splitbrain.org/projects/monsterid - https://robohash.org/ - https://wordpress.org/plugins/wavatars/
I love both languages, Python tends to be more loose when it comes to accessing variables from outside and inside conditionals. One thing that perhaps someone can enlighten me - why did Go not follow with the traditional try catch error handling? 
The overview of a proposal for an evolution of Go's error handling goes into the reasons they eschewed traditional exceptions a bit: https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md The very short version is because using exceptions for error handling makes it hard to tell where/when errors are going to occur &amp; what the code-flow will be when errors do occur. This matters a lot more for long-running server software than short-running user-facing programs. As someone who's written server software in Python that tries to be robust and been burned multiple times by unexpected exceptions, I really appreciate Go's approach to error handling.
Plus it has origins in C. I especially like how while writing kernel modules i get back/can add my own error codes. I can understand exactly where a problem occurred. Plus I don‚Äôt think try-catch would have gone well with go channels. 
Oh, and I can't forget the whole https://meta.stackexchange.com/questions/37328/my-god-its-full-of-unicorns
I was thinking more about what I said and although the nginx answer is still the best, I was silly about the last option (custom http.Server) HTTPS is really just HTTP *over* SSL (or TLS); they're different layers of the stack. You can end up creating a new listener (layer5) and put TLS on it (that's update-able) and then use that to create an `http.Server` and it'll transparently be TLS. Let me spin up an example
I'm a *strong* proponent of testing against the real database. Mocking has several problems: * you're never going to notice performance problems until you hit production * you can't test specifics of your database * using mocks for testing discourages the use of database-specific features (this is a biggie) "But setting up and tearing down a real database is hard and manual". Rubbish. I have several production platforms with extensive unit tests that all have an automated database setup/teardown. Each test creates a brand new database, populates the schema, potentially populates it with test data, runs the test, and destroys the database. Yes, it adds overhead. But you should have CI, and who cares if your tests take 30 seconds instead of 25? Also, the setup/teardown framework took a little time to write, and it costs me two lines of code to implement in a test. Back to that "biggie" above. If you are scared to use database specific features because you can't test them, you may as well use a dumb key/value store, or something similar. You're wasting a valuable resource. Nothing does referential integrity, field validity checks, row-level auditing etc better than your database. Use them. Additionally, look at a schema management tool as well, that's another thing you can and should test. Even with complex schema updates, I never feel fear about pushing the "deploy" button on my production applications, as it's all been heavily tested already. There is zero manual intervention as well. My rule of thumb - if I can put bad data in my database via the SQL monitor, then I have failed in my database design. Those low level constraints should be completely enforced by your DB, *not* your application. 
If you have a `http.Handler` implemented for your web server, it looks like autocert should work for you. Here's the example from the godoc: ``` log.Fatal(http.Serve(autocert.NewListener("example.com"), handler)) ```
[removed]
I think you‚Äôre absolutely right. I‚Äôm not that familiar with testing in Go but this is the sort of thing I would mock at the unit test level and then explore at the integration level. It‚Äôs really easy to fall into the trap of ‚Äútesting the x‚Äù where if ‚Äúx‚Äù doesn‚Äôt work as expected the application is doomed. What I mean is like basic insert statement testing or testing that method calls still work. A test needs to have some external value. From that I would expect testing to focus on complicated queries or queries that have dire negative consequences. As you said it‚Äôs gotta be worth the effort of building up and tearing down the schema and all that. I‚Äôm going to post a link to a [Go schema migration tool](https://github.com/golang-migrate/migrate/blob/master/README.md) because I wasn‚Äôt aware one existed until just now. Actually there are many of these. (Check awesome-go.) Also I want to point out the existence of tools like goqu, sqrl, and Squirrel which could enable you to test your sql on something like SQLite and then run your application against something like Postgres.
Firestore client uses gRPC to communicate with the backend. [gRPC supports connection pooling via HTTP2](https://github.com/grpc/grpc-go/issues/682). So you should not need external connection pool. You should create one client on startup and reuse it for all API calls. Do not bother with calling client.close() since it is going to live for the duration of your application. If you do need to recreate the client, use a cancellable context in the constructor.
The thing about per-test bespoke docker images is that they tightly couple your build toolchain to individual tests. That‚Äôs a maintenance nightmare and makes it harder to read the test since the test data is in some other directory far away. It‚Äôs way simpler than that: make your DB code accept the name of the table as a parameter, then at the start of each test, drop and recreate a test table using CREATE TABLE LIKE ... INCLUDING ALL. You can populate the DB tables with regular insert statements at the beginning of the test.
Python is definitely my go-to language. When a situation arises where Go is a better fit for performance or compilation reasons, I'll switch to Go.
I don't get to do much with Python because I spend so much time with C# and Go, but I often reflect on how well Go and Python compliment. I also think Python has the kindest community with huge diversity of interests and pursuits and Go one of the most talented.
Thank u
[Netograph](https://netograph.io) is a security/privacy-focused startup based in Dunedin (but with an international dev team). Our entire back-end is written in Go, from the ground up. 
bufio scanner is the tool for the job: scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Println(scanner.Text()) } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, "reading standard input:", err) } ([from stdlib docs](https://golang.org/pkg/bufio/#example_Scanner_lines))
Does this support a similar workflow to [Python's VCR package](https://vcrpy.readthedocs.io/en/latest/usage.html), where responses are stored in files (as test fixtures)? I've always enjoyed using that, but I wasn't able to understand your README examples (sorry). It looks like maybe with your package, you have to manually construct the responses? One technical nit, I am really not a fan of Go packages being imported with massive names like `go_mock_yourself_http`. Something shorter and without underscores would be much nicer and save me having to alias the import. Overall, I like the initiative.
What is WMS?
How hard is the move from python to go? I'm just beginning python &amp; imagine I'll develop many 'bad' habits that will plague me later with Go !? :(
&gt;Also a little confused about his "slices" section; either I misunderstood him or he misunderstands slices. I think he's explaining it very weirdly. A slice is very similar to a list in Python. In both cases, you would normally call `append()` in order to add a new item outside of the bounds of the existing values. However, when you call `append()` on a slice it actually returns a reference to a new variable instead of mutating the original object. Arrays and slices in Golang also support predefined boundaries without defining existing values. For example, `var a = [2]string` would roughly translate to doing `a = [None for x in range(10)]` in Python. However, once you've reached the boundaries of an array in Golang, you cannot append a new item to it without first defining a larger array and manually copying all the existing values (which can be an expensive operation). Under the hood, slices do something similar, but instead use pointers to more efficiently reference the old value. Think of something like a linked list. In most cases, you probably want to use a slice, but arrays have their place. Byte manipulation comes to mind.
Hmm, which one of these is not like the others? $ du -hs jackwilsdon.* 4.0K jackwilsdon.gif 4.0K jackwilsdon.jpg 260K jackwilsdon.png You should include some notes on usage -- for example, which ones take more server CPU or server bandwidth? Which ones are more efficient on the client (probably not Jpeg, but you never know until you benchmark it.)
mdr pas de g√©n√©riques
Python is much quicker to write, but you end up with code that's fraught with runtime errors. Go is slower and more methodical to write, but you end up with a faster, more stable result. Which attribute is desirable depends on the specific task. I use both languages frequently.
I recently wrote a wrapper for a Go program in Python (using Go's C shared library). It was fairly painless. Definitely a good option for some situations where you need to speed up part of a program.
Annoyingly Go doesn't have sets like Python does. I just use a map to a bool instead but you miss out on a lot of cool built in set operations.
My thoughts exactly. Though I don't find Go to be *that* much slower to write, especially when dealing with concurrency. And the structure generally keeps it more readable and maintainable so it can save time down the road. Not only that but I generally spend much more time debugging my Python code (because of all those runtime errors that Go compiler would have caught) so the two can come close in terms of development speed. Typically I use Python for quick data manipulation, testing, and analysis.
Can you point me to a 'French for Go developers' podcast first?
I always have a test helper function around that takes care of the database. Here's one example of it https://github.com/go-surf/surf/blob/master/sqldb/testutils.go#L10-L65 What is important for me is that this helper function is by default expecting a database running on localhost on it's default port. That works great for CI or running tests locally. If you must run database using non standard settings, you can configure the connection via an environment variable. Another important feature of this helper function is that it skip the tests if a connection to the database cannot be established. This way your tests do not have to `if` it. Here's another example https://github.com/husio/gbb/blob/master/gbb/postgres_bbstore_test.go#L16-L17 When testing locally, I always have a PostgreSQL instance running in docker `docker run -it --rm -e POSTGRES_PASSWORD='' -p 5432:5432 postgres:alpine`.
I always question if the change to Python to Go, for example, is something really "worth". If you need performance to your application, maybe you'll need to change your paradigm about how have you been working on the problems instead of just switching languages. The idea of scaling with language X or Y has several points to take into consideration and I've seen some good solutions with Python that scale reasonably well, also you might take so much time to change your whole code-base to a Go-based solution just because you want to leverage the usage of the \`go\` keyword to build concurrent solutions.
&gt; I have several production platforms with extensive unit tests that all have an automated database setup/teardown. Each test creates a brand new database, populates the schema, potentially populates it with test data, runs the test, and destroys the database. Same here. Plus table-driven tests on top. We test 100 different queries against 5-10 flavors of test data (~100k rows), and the whole thing runs in less than 10 seconds. Yes, we wrote a framework, and yes, we've done a lot of optimizations to the DB, but it isn't rocket science. DBs are designed to be lightning fast! It's usually shitty testing code that makes the whole process slow. &gt; who cares if your tests take 30 seconds instead of 25? This is entirely dependent on the SLO you've set with your developers and how many other tests are in the pipeline. I promise my devs their patch lands on master in no more than 15 minutes after a PR is accepted. If my devs write tests that take too long, we send the patch back for rework. If my infra is dragging out, I fix it by next business day. &gt; look at a schema management tool as well Or build your own. Dead simple. * Put a table in the DB that keeps track of schema version * Write your DB init code as a series of migration queries (CREATE TABLE, ALTER TABLE where each query bumps the version number * Immediately when you connect to the DB, check the schema version table. * if there's a mismatch between the table and your code, say DB is at 3 and code is at 5, well, run the last 2 queries and Bob's your uncle. Test in staging (while under 5-10x prod load for funsies) and your push to prod will be like nothing happened. Prego! 
One approach I've used is to have the tests run against an In Memory database like H2. That way I can run the tests multiple times in different environment with no problems.
There's zero unit tests in this project. Hard pass.
Haha I'll get started
Nice work!
Thank you!
&gt; It can't be built by a single person. Single people have coded entire operating systems. You don't have to do that here. Just spitballing here, but your code base will double or triple in size with proper unit testing. That's all. Another big missing piece: documentation. No code comments. No README.md. No idea what the code does. `godoc` fucking gives you the docs, if you could spend a little time commenting your functions, interfaces, variables and such: https://golang.org/doc/effective_go.html#commentary Think about it this way: if you don't give a fuck about the completeness, the quality or readability of your project, why should anyone else?
Hey, thanks for the reply. But I was looking for solutions around testing the actual SQL code/interactions not how to bootstrap docker containers.
Thanks for the reply. Yep, I assumed this erred on the side of "Integration" tests if a real db was involved. I think calling the database correctly has many advantages, many of them mentioned in the comments here already.
Nice and simple idea, thanks!
Thanks for the reply. I've actually got all this bit sorted. I was after solutions/ideas on how to test the actual SQL code/interactions not how to setup and connect to the db.
As a Python user and learning Go, this sum up is handy. Thanks.
This is brilliant, thanks! I'd love to hear a bit about that framework of yours and how you make use of table driven tests with it. Is there code you can share? I'm particularly interested in how you might be bootstrapping the db (test fixtures, manual sql statements etc) and how you are doing your assertions.
https://gist.github.com/NHOrus/50a74986e2414dd9d5976c1396c047b6 well, this is my take on simple, secure https webserver with Let's Encrypt certificates with autocert, that mainly shares files I want. Some stuff is omitted or censored. Mostly copy-paste from various sources, not even in git.
It's not a drop-in though, you have to rewrite your apps to take advantage of golang, and some patterns and ways of doing things don't translate at all. I'd be careful of saying golang is magically faster than python. I bet there was a lot of work that went into that yawn.
Is there a good "Go" counterexample? 
What do you get? What output did you expect? Here's a version that will run continuously. Run it locally; on Go playground it will time out. https://play.golang.org/p/jiWTixhbnBw
Untested, but something like: func main() { r := rand.New(time.Now().UnixNano()) // create a random source for time intervals, optional for i := 0; i &lt; 2; i++ { go Remind(strconv.Itoa(i), r.Intn(5)) // convert iteration count to text for reminder, and pass random interval between 0 and 5 } select {} }
Each one of your sensors exposes a Name() and a Read() method, create an interface that encapsulates that functionality, provide your implementations in another package, e.g. lightdriver.New(), sounddriver.New(), and store those in a slice of drivers(or whatever you name your interface). From there, your ticker logic could just iterate over a collection of drivers, for _, driver := range drivers { }
Yep, good point! 
I would change the goroutine example to use a channel or alike to signal when the goroutines are finished rather than having the 'read input' by the end. This would then also show one of Go's built-in features.
This is beautiful!
Also, Python is a scripting language, while Go is a low level, "system language". You wouldn't write an operating system in Python. You would in Go.
? Which documentation are you talking about? As far as I understand, WASM is highly experimental at the moment.
I love Python 3, but honestly, Py2 is for the birds.
That was the point when I asked what (s)he was looking for: "concepts" may have been the topic indeed, as explained in the later post in this thread. But I realize my formulation may have sounded sarcastic, which was not the goal.
 The problems though by not having an API I think are huge. Anyone who has spent time on js frameworks knows this. 1. If I build my own API this will not transfer to other projects. So something that takes forever will be repeated? 2. I don't want to memorize 100 people's apis every week, I did that for years and I'm just done. I magically hope they create an API that's easier then domobject.method(eventhandler, method Cal) 
All your DOM manipulation must be made through JS, not WASM, so, yes, if your app is DOM-manipulation heavy, you'll basically be writing JS in go. But WASM is useful when you have a big module (like, I dunno, an AI engine or a game engine) that performs complex calculations with little to no user interaction, and then only use JS and the DOM when you need to update the view. Imagine a chess board. You could have the program's AI (the computer player) that is written in go and transpiled to wasm. Then, the view, i.e displaying how the computer chose to play, and being notified of how the human player played, would be written in JS (because it manipulates the DOM).
nice, except [https://github.com/upper/db](https://github.com/upper/db) is way better ORM than gorp ‚Äî resulting code will be shorter and better
This is a great write up. Python has nearly 30 years of documentation, libraries, and user growth from which a new developer can learn. Go.....not so much. I will say that I GREATLY prefer python 3 string formatting to Go, but that's more about simplicity and familiarity. For me, where the whole concept breaks down is the whole object-oriented paradigm for Python is well described and highly intuitive, the (I hesitate to call it object-oriented) paradigm with Go is just beyond my comprehension. So at this point, I have started writing Go scripts but more to replace older one-off python tooling that I have. Nothing that leverages classes in any meaningful way. I have been trying to find use-cases and reasons to shift from Python to Go for some of my bigger projects, but I just have had the hardest time understanding how the whole Go OO paradigm is supposed to work.
Hey bro! first of all, thanks a lot for the feeback, i really appreciate it :) About the HTTP flows recording, i'm right now adding support for it. As you said it, right now you would have to build yourself the Mock Responses you want served (there is a logging option to dump/sniff communication flows in a nice human readable format but still you would then have to build from it the desired Mock Responses by hand). I will send you a message once i finished developing this feature, if other responsabilities don't me, i should have it ready in two weeks top :) About the long name, you are not the only one that tells me exactly the same thing so i might consider it in the near future BUT i will be totally honest with you, i love seeing the "brand" name complete in the code LOL :) Again, thanks a lot for the feedback! Cheers! &amp;#x200B;
Learning your first language is really, really hard, no matter the language. Learning additional languages is much much easier because you're mostly just learning new syntax and a few language specific things rather than re-learning how to program.
Sometimes they'll be called hashes too, just FYI :-) C++ would call them unordered_map I think. (map exists, but I think unordered_map is closer)
WMS is abbreviation form of Web Map Service. According to WIKIPEDIA (I think this is quite accurate): "A Web Map Service (WMS) is a standard protocol...for serving georeferenced map images over the Internet. These images are typically produced by a map server from data provided by a GIS database."
You may want to read up very carefully on the generics proposal, and track it carefully, because this is the sort of project that will probably never quite be practical until that's done. I've taken a swing at this myself and it's just... not... quite practical, really. (Similarly for the "let's create an API for creating a nifty network of goroutines connected by channels!" It's gonna be a lot easier with generics. Without them, you just can't quite get a slick enough API.)
I'm trying to use ID interface{}. The reason being that the database ultimately cares about what the ID. No where else really cares. So why define it? As to your specific example, I think it matters on the context. If you disassociate the struct from its ID, I like type FooID int32. You can trace the origin of the ID clearly. Where you'll get bit is having to do the same thing with an idea from multiple sources.
Whenever I possibly can. It's great! Pros are type safety and the ability to add behaviour (I often have a pair of methods `Field() zapcore.Field` and `Fieldn(name string) zapcore.Field` attached; some types end up with more useful stuff as well. Often these conversion related, so the methods are short and easily inlined, and they confer good additional readability on the calling code. The big disadvantage is the extra casting you have to do at times to do any arithmetic on them (ids have less need for math but once I started to add semantics to my ids it quickly spread elsewhere) or when you pass them to functions that demand a primitive type. The benefits that come with the type safety so far outweigh the downsides though that I don't even bother thinking twice any more so I'm almost certainly forgetting a few minor, inconsequential details. If I find there's semantic value in something having a type, it gets a type, end of story.
I'm referring to differences in functions, methods, classes, etc., from Python to Go. Are they very different? Variable typing is VERY different between Python (very loose) and Go (very strict). This alone is a huge difference. Question is are these differences large enough that moving from Python to Go is not easy? 
That does look quite appealing to be honest, having things like `func BuyItem(customerID CustomerID, productID ProductID, quantity int)` instead of `func BuyItem(customerID, productID, quantity int)` 
Functions, classes, methods, etc. are all the same concept across most all languages. Once you have the concepts, it's not a problem to move back and forth across languages -- you're just learning any specifics about how a language implements that concept. That's what I mean when I say that learning additional languages is much easier than the first. Strongly typed and weakly typed languages are a bit more of a step IMO, but both paradigms are alive and well, so you're likely going to end up using both at one time or another. One can move back and forth between them easily. So learn what you want to learn. Either you'll like programming and end up learning several languages, or you won't and it won't matter.
If the IDs are used/stored/processed external to the struct such that there are local variables or function parameters of the ID's type, then yes, I would typically make new types for them, to get compile time safety that I haven't typo'd Foo/Bar. It's extra typing, but compile time safety is sweet and there's very little downside. But as another comment mentioned, it may be preferable in some applications to largely treat the Foo/Bar structs as black boxes, and for the APIs involving them to (almost) always expect entire structs (or struct pointers). In that case I would typically not make a unique type for the ID. Another case you may want to consider is if external code is always dealing in plain ints, and every time you use an ID separately you always cast to and from the specific type, it's likely the compile time safety is largely illusory (since you could typo the cast just as easily as the field type) and you'd be better off just using ints the whole way through. So in the end, my answer is "sometimes, it depends." Helpful, I know. :)
[removed]
interface{} is the worst type you can use for anything, because it isn't any type at all. If you truly want to abstract it, define a real interface.
Are you creating a function for the model to take in different struct types? I wanna say you prolly can then you a type switch and base your behavior from there. If you base it off of each property/column then I think it might get messy. You might want to just keep it to types with all columns and then decide in that function which type you need from a type switch. It's hard cause it depends how much you are going to change your API. You eventually have to make a presumption. I suppose maybe split the functions into services, then split more functions into types, then if you really need it further into properties/columns. But I would keep in mind with each function to make sure it can be reused directly from the database, otherwise if you stack apis and have them tree out after getting the data, you are going to have this only can add to and not delete service that will get 10 levels deep... For everyone. 
In my opinion, designing with integer IDs is a bad pattern, as there is an implication that they are allocated sequentially. Doing so requires some sort of central coordination. I personally use UUIDs wherever possible, and ensure that the database backend will handle a duplication appropriately. If you want to do maths on the ID for some other purpose, create a new column for that which isn't doing double duty (again IMO).
I went to the intro to Go tutorial. Although the course was listed as co-taught by Johnny and Carolyn, Johnny taught for the entire session. Carolyn (and a few others) served as assistants. Even so, looks like there are slides for both of them, so that might be useful for those wanting to see a second perspective.
Why not, let's see: &gt; What challenges did you face when rebuilding it in Go? I guess the main challenge was to "unlearn" a bunch of stuff I inherited from years of OOP/Python development. Things like not everything has to be a Class, you can satisfy your urge to Namespace everything with "struct method receivers", no Constructors but initialize your Struct with "New" funcs etc., were a little alien at first. I *was* worried about all the talk of "lack of generics" and was dreading being stuck in "type recasting hell" (Java) but all in all it was quite painless. I think I only used the `reflect` library a couple of times if that. As far as real hard challenges, I remember being stuck trying to encode/decode JSON/XML to Structs, but managed to find some helpful packages such as `github.com/tidwall/gjson` which made the pain go away for the most part. That, and `github.com/puerkitobio/goquery` where my most used packages. Overall I found the development experience quite nice -- I'm in love with the static type checking and build process now! It's made refactoring things a lot easier knowing the compiler would yell at me if I made a mistake. I didn't find myself having to write tons of little tests to cover every little eventuality like I did with dynamically typed Python just so I could make code changes without any unforeseen side-effects. &gt; In which part did you see the most performance improvement, scraping? There was definitely an overall performance improvement -- the only real bottleneck were network calls. Your usual scrape job would require multiple network/http calls and the ability to run them concurrently was night and day better (obviously). I guess this was the main reason I was eager to rewrite in Go, the concurrency model *is* that good/easy. (I remember taking a look at some of the Python solutions like "asyncio" and thinking I'd be better off learning Go than trying my luck with yet another library and another layer of abstraction.) The only real gotcha that became a time-sink was dealing with "race conditions" where I would have multiple go routines updating a struct. I discovered the use of `mutex.Lock/Unlock`, and more importantly, the built-in "race detector" (https://golang.org/doc/articles/race_detector.html) which was an absolute life-saver. &gt; Anything you learned that you would like sharing? Apart from "there's a reason Google developed this new language, use it, especially for server/backend services" I can't really think of anything else. I would say that there's something "mature" about Go. Coming from Python, where everyone is trying to be best "Pythonista" and anxiously trying to find the most elegant way to write a piece code; there's something refreshing about Go's direct Struct&gt;Functional style. &gt; On a scale from 1-10, how difficult did you find the process to be? With 10 being the hardest I would say it was about a "3" and even that is a little high :D Sure there's a bit of a learning curve, but the time invested is well worth it. The documentation (+GoDoc) are excellent, "Tour of Go" is surprisingly quick to get you going, and The Playground is also very useful for newcomers. +1 Would do again! :D 
It was empty of data, using the mysql container initialization and running a sequence of SQL files. It's just not a super fast thing to do, especially if you're setting up a load of other containers at the same time. However, there are still some settings like sharding, or the behaviour with read replication, or the amount of index memory caching that may not match without a larger setup. A local setup for unit tests cannot fully mirror large production environments, so you may have to accept on a certain level of accuracy in comparison (certainly not enough to run per/load tests). Not talking test infra, since this was about unit tests. If you had to provision an AWS, production sized database for unit tests it would probably take longer and be quite expensive. More so if you have one ready to go and people queuing to use it. Now, if you want to run load tests, that's a different thing from how you might run unit tests. You have to do that on an infrastructure that's representative. It's not usually similar to your unit testing setup, which is designed for fast turnaround. You probably drive it at a different level than unit tests, in order to orchestrate scale and attempt to be semi-representative of user behaviour. Load testing is not the same as integration testing, and neither of them are the same as unit testing. Work out what testing gets you what value.
Only for DOM manipulation you need to use the syscall/js interface. Other than that, you can completely write Go code without bothering about anything. See here - https://github.com/agnivade/shimmer where I use the https://github.com/anthonynsimon/bild library which is otherwise used in other platforms, to manipulate images completely in a wasm context. Pure Go. No JS.
Nice, one thing I have never seen anyone do in a Go SSH Tunnelling library is multiple ports. They always seem to be on a 1:1 basis like in your example. 
This seems to be an ssh port forwarder, and not an ssh tunnel. SSH has a separate mechanism that uses TAP/TUN devices that is more appropriately named tunnel.
Not really. We're in the process of rewriting several python services as go services. Granted, I have much more experience writing go than I do writing python, but the most difficult part was puzzling out the data structures used by the python services, since they weren't clearly defined by the original authors. I began my career back in the early 90s writing C, so perhaps that's why go seems so natural to me. That aside, go may take longer to write for some developers, but overall, that investment can lead to 20 to 30 times perf improvements, and reduced need for container scaling. We have already seen those speed improvements, less number of containers and cost savings. And our infrastructure is much simpler now. 
That's an interesting idea, I think the n:1 mapping would be easy to achieve. I think doing 1:n doesn't make much sense, ¬ødoes it?
[https://github.com/search?l=Go&amp;q=label%3A%22good+first+issue%22+state%3Aopen&amp;type=Issues](https://github.com/search?l=Go&amp;q=label%3A%22good+first+issue%22+state%3Aopen&amp;type=Issues) This link will only leave issues with open status instead of including closed issue. 
Here's my example. The DB returns int64. I don't have to cast interface to int64 anywhere except in the DB code. If I create a real interface, then I have to preserve the knowledge of the underlying DB type. The DB layer talks only in terms of function: you give me an interface ID, I give you a struct. If I have a real interface, won't t controller have to know how to convert the /path/:id to an int64 and thus remove the abstraction that no one really needs to care?
Thank you for taking your time answering all questions thoroughly, I really appreciate it. :) Good luck with your website.
\[...\] We do not want to break the ecosystem. Go 1 and Go 2 code must be able to interoperate in programs with ease. \[...\] [https://github.com/golang/go/wiki/Go2](https://github.com/golang/go/wiki/Go2)
Good point, maybe I should rename it, although... ¬øsometimes people just refer to it as an ssh tunnel without technically being one? ¬øWhat do you achieve through a ssh tunnel? ¬øAll the traffic being sent to the remote host? 
&gt; If I create a real interface, then I have to preserve the knowledge of the underlying DB type. You are doing this anyway, by encoding it in your actual code, rather than in your interface. This is a bad plan and will trip you up in future.
Hi, I tried to run &gt; go build -mod vendor It works in the current project directory. But after cloning the project to another directory (for example /tmp) go can't find the first dependency and ends with an error: vendor/github.com/syndtr/goleveldb/leveldb/errors/errors.go:14:2: cannot find package "." in: /tmp/project/vendor/github.com/syndtr/goleveldb/leveldb/storage This continues until I run `go mod vendor` again. What am I doing wrong?
If there are go2 features to be adopted, there will have to be specific ... constraints, lets say, how these features will be introduced into the language. It isn‚Äôt impossible for package authors to provide v1 and v2 versions, but obviously there‚Äôs little point in doing so if people would be encouraged to migrate to v2. I shudder to think that the term ‚Äúlegacy codebase‚Äù will one day soon refer to go1 code. Just like the roadmap: TBD
Here's my system architecture. Web Controllers -&gt; IUse Cases -&gt; IRepository I stands for interface. The web controller doesn't do anything with the id; it passes down to the IUse Cases. No implementation of the Use Cases does anything with the ID other than call the IRepository with it. Individual repositories can store IDs however they like. IDs don't span repositories. If they did, the underlying repository will have to know about how the other repositories store their IDs. The best I can see your comment to mean is something like this type ID interface {} &lt;-- Does nothing, just says I'm and ID. Then a Repo might have type DBID { ID DBID int64 } The problem now becomes away to let the controllers create an instance of the ID without getting bogged down in knowing about the DB tech.
Depends on your storage mechanism. Postgres does not like UUIDs. It cause bloat and performance issues.
I saw a talk where someone from the Go team was presenting and laughed at the Python 2 vs 3 situation. He said they specifically want to avoid that. Probably Go1 syntax will remain unchanged, Go2 will just bring new stuff to the table, so Go2 is backwards compatible with Go1. Migrating libraries could be done incrementally to take advantage of the new features module by module.
I vaguely feel faint hints of irony...
Upvoting. That's what I recently am curious about.
Sure. https://blog.2ndquadrant.com/on-the-impact-of-full-page-writes/
It's hard to understand your actual setup from such a high level overview, but my first instincts are that you should never be creating instances of the ID if they do not 'belong' to that package. If you do need to store an arbitrary DB type in a struct from a different package that you want to pass around, then at the very least you can create an empty interface type in DB called 'ID' or something like that.
&gt; "The most amazing achievement of the computer software industry is its continuing cancellation of the steady and staggering gains made by the computer hardware industry." - Henry Petroski (2015) I feel like Go is really going to help remove the sluggish, bloated "Majority Code" all us past/current/future PHP/Ruby/Perl/Node.js developers used to write. Go will help to cancel out the energy loss from bitcoin.
I'm not sure this section is accurate: &gt; Of course, this is due to the inherent UUID randomness. With BIGSERIAL new are sequential, and so get inserted to the same leaf pages in the btree index. As only the first modification to a page triggers the full-page write, only a tiny fraction of the WAL records are FPIs. With UUID it‚Äôs completely different case, of couse ‚Äì the values are not sequential at all, in fact each insert is likely to touch completely new leaf index leaf page (assuming the index is large enough). The uuid-ossp module does support sequential UUIDs, but I'm not sure exactly how that translates to the btree leaf pages. I have however bookmarked this page so I can attempt to reproduce this later on. Cheers!
You‚Äôre technically correct, but everyone I‚Äôve ever worked with has used the term ‚Äússh tunnel‚Äù for this. So for better discoverability the author should probably keep this name. 
My architecture follows Clean Architecture. https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html My general issue is years of making the detail that is the database a first level construct. I'm tired of saying, implicitly, this entity has a DB ID of Long, or int64. The only place that ever needs to really know the ID is the database. Making the ID, whatever the type, is leaking the DB abstraction. Now the whole system will know about the database's preferred ID type. The code as it stand says, the layer that cares about the ID is the DB. The DB will return an error if it can't understand the ID type. For example, if it gets a string that can't be converted to int64, it will return the error. The error is defined in the IRepository layer. All implementations of the interface may return such an error. Mongo might not like getting an int64. Arango may require UUID. PG wants an int64. All of them can return a common error saying, "Something went wrong. You sent the wrong id type down the line". Only the DB implementation should be responsible for this. 
&gt; The DB returns int64. I don't have to cast interface to int64 anywhere except in the DB code. For that, you are better off with something like `type DatabaseID int64`. It isolates you properly from the database implementation detail, and on the day that the ID changes, you get the full support of the type system in dealing with the change. If you change it to a UUID type or something, all the conversions will fail and the compiler will point you right at the code to fix. If you have `interface{}`, nothing will fail at compile time but runtime will still fail. If you've got things like IDs showing up in a URL, you can only isolate the rest of the system so much. `interface{}` doesn't really isolate; it just kicks the can down the road. You still have to do every single bit as much as you'd have to do with a concrete type, you're just doing it without noticing, and without support.
[removed]
Totally agree, the go type system is painful for this use case, this put apart, goes is very practical and used in production for at least 4 months
You say I'm kicking the can down the road. I same I'm depositing in the proper box. &amp;#x200B; Let's say you have an Entity called User. It has a key with multiple columns. type DatabaseKey struct { Col1 string, Col2 string } Would you then have a User defined like this? type User struct { ID DatabaseKey, FirstName string, .... } If you do, everywhere has to know what the ID structure is. Do you need to make a test about a use case like updating a person's name? That test has to know about your DatabaseKey. In the web controller each controller has to know how, or at least invoke a function that knows how to change some param to DatabaseKey just to pass it down to the repository. Do you separate layers in your code? Do you have explicit dependencies from the web controller down to the database? Gophers seem to do this. For example, does your controller KNOW that it needs a Thing which KNOWS that it needs a Cassandra backed object?
i've been curious about this for awhile because i like sqlite but want to stay pure GO, anybody have any real world experience with it? any sense of performance?
Indeed, ssh tunneling and ssh port forwarding are often used as synonyms, e.g. here: \[SSH port forwarding - Example, command, server config | [SSH.COM](https://SSH.COM)\]([https://www.ssh.com/ssh/tunneling/example#sec-What-Is-SSH-Port-Forwarding-aka-SSH-Tunneling](https://www.ssh.com/ssh/tunneling/example#sec-What-Is-SSH-Port-Forwarding-aka-SSH-Tunneling)) The conceptual difference is subtle: * An SSH tunnel sends traffic over an encrypted connection. This is useful for making security-unaware protocols like FTP safe. (Just tunnel the FTP traffic through SSH.) * SSH port forwarding makes a local port accessible on a remote host (or vice versa). The other end now appears to be a local connection but in fact the traffic is tunnelled through SSH between local and remote host. In the end, the result is the same. You have a local and a remote port, and encrypted traffic between them. Hence I think it is ok to use "SSH tunneling" and "SSH port forwarding" synonymously. 
Video streaming service [https://www.shift72.com](https://www.shift72.com) uses it for some backend systems
RemindMe! 
[removed]
Thats great! Well done you. What I like in Golang besides the typing is the way data structures implement interfaces and passing things around by pointer (although I would prefer C++ const reference passing). I think it's inevitable go will evolve something like const reference passing (read and write only channels were refreshing).
We just treat pkgA like any other third party module even though it's in the same repository. Make changes, test and commit the pkgA then `go get -u` it again to update the go.mod anywhere that requires the new version as a separate step. Go modules will happily pull specific versions of pkgA for different applications all in the same repository. It might seem slow at first but we've found positives like better testing, collaboration and more thoughtful API design since you have to commit and PR changes to shared libraries before you can use them in services.
Can you point to _any_ other Go project that does IDs this way? 
replace pkgA =&gt; ../pkgA
great libraryb
I have wondered about this also. It would be nice if say the vendor directory could be optional somehow. You could check out your code in the appropriate path under vendor and iterate both at the same time. 
No. In my experience all go projects are essentially Transaction Scripts (https://gunnarpeipman.com/architecture-design-patterns/transaction-script-pattern/). Gophers seem to eschew architecture by preferring direct coupling. The idea appears to be that there is little possibility that any domain feature like use cases and repositories will ever migrate off their given database infrastructure. If they do, the whole application should be rewritten anyway. If that is true, I'm not philosophically there yet.
TL;DR All languages support error handling. The Go community actually _implements error handling_.
After Abstraction Hell in Java/PHP (where every property is wrapped in one-or-more functions), I'm happy to have "direct coupling" for items there are no reasonable plans to change. Then again, I'd also argue `int` is a pretty [short-sighed primary key](https://arstechnica.com/information-technology/2014/12/gangnam-style-overflows-int_max-forces-youtube-to-go-64-bit/).
It's important to remember that postgres does not return `RowsAffected` and you should probably use a `RETURNING` clause instead.
int64. Decoupling provides the ability to easily test. If your system does not expose dependencies like SQL (I'm looking at you tx in ever fricken call), then you can make testing simpler. You don't need to mix out tx just to call a function. You don't need to fully instantiate the object tree to test validation logic.
&gt; The Go community actually implements error handling. I've really felt this too, and it's been interesting because I see *myself* developing new habits. It feels like Go sort of guilt-trips me into handling errors. You **could** just ignore that error, but that `_` assignment is still there menacing and taunting, a reminder of my own laziness. And I always give in, I always cave, and wind up renaming it to `err` and handling it.
This is one of the reasons that I think any way of cutting down the code repetition a bit needs to _not_ be error-specific. And yeah, you're not kidding about the JavaScript error handling. I'm working on a fairly large JavaScript project right now and good gracious... Error handling is an utter disaster.
Yeah I think rust has almost ideal error handling. It's explicit, which I like about go, but it's minimal noise. And I love how in rust the errors are type safe and will do conversions from one type to another, so you can have different layers of errors and not lose information. I like how with the failure crate, adding context to an error is simple one more line. The downside is that you have to write some boiler plate error conversion code to get there and it's a little complicated for new people.
oh cool thanks 
That is almost as bad as writing \`if(true){ return true; }\`. Man, where is the programmers intuition in this community? It is bad from 1000 Km away!
There's a difference between error handling and error catching. Go does error catching well but handling is implementation specific. I personally hate that they teach about the panic function on the golang website and the accompanying recover function much later.
You can use `:=` if any identifiers on its left aren't already variables that exist, so you can write a, err := func1() if err != nil { return err } b, err := func2() Because `b` didn't already exist. Otherwise, just use `=` to reassign the existing variable.
You'd have a zero-value pointer, that doesn't make any sense. Just think of the nil pointer as the zero-value of a pointer.
I'm sorry.
You need the check before because *maybe* you just want to log the error without exiting the function, and *maybe* you want to quit the function after the error. If you quit, then the calling function needs to be aware of the error and maybe handle it more properly. In its turn, that function might even return the error to an higher caller, all the way back to the callback, at which point the error should be properly traced and documented in your logs.
I know what a nil pointer is. What I'm getting at is that it's a great big hole in Go's otherwise explicit error handling. Almost everything else that can go wrong requires you to explicitly handle the error, but nil pointers shit all over that and leave you right back in exception-handling territory. Just worse, 'cos it's a panic, not an exception.
I would closely compare uncaught exceptions to losing teeth.
Oh, *that*. Yeah. It sucks. It adds more `if ptr == nil`.
How to read a paragraph and not absorb any of it 101
:D Die fucker!
I think you have a good thing going here. It says "By default it reads the default linux ssh private key location $HOME/.ssh/id_rsa." Is there a way to alter this default behavior? Read specific id file? Use ssh agent?
Have you enabled module support and type `go mod download` a first time?
how exactly has Go "implemented error handling"? it sounds like they just hand you back the error and expect you to do something with it. but if you don't, it's not their problem. there are plenty of languages like that...
Reflection is also fraught with runtime errors. `interface{}` is practically duck typing.
That's kind a sad conclusion about Rust. Knowing beforehand what Passenger needs to be able to do, I would have imqnt3e that it would be a perfect fit. But it's also encouraging to hear that cgo wasn't a deal breaker either. [cgo is not go](https://dave.cheney.net/2016/01/18/cgo-is-not-go) always sits in the back of my mind as a caution, but the times I have used it, it has been perfectly reliable.
Yea I enabled it when I created the project. I used the module template in GoLand. Also, yes I've run go mod download.
&gt; Other languages often have multiple return values, error types, exceptions, and exception handling Haskell functions that fail return a single value of type `Either`, which must either be handled or propagated further up the call tree, and doesn't require three seperate `if err != nil { return }`. This pattern is common across the standard library and the greater Haskell ecosystem. Rust also does this with its `Result`. I'm not sure you've looked at other languages to make the claim that Go is the first language to do error handling correctly. 
Oh sure. But buggering about with reflection or `interface{}` is an *explicit* step outside of the "normal" run of things. You *know* you're playing with fire. 
&gt; buggering about with reflection or interface{} is an explicit step outside of the "normal" run of things Not really. Tell me how to write an ORM without reflection or generics? This is a basic building block of any CRUD application.
Every line of code is an explicit step. That's not a meaningful statement.
Haskell and Rust are great languages, but their learning curve means they can never be mainstream like the C-family and derivatives (Java, Go, PHP, etc). I trust Rust developers to handle errors at every level in the supply chain. JavaScript on the other hand is often a lost cause of nested npm package failures.
I like that both Rust and Go MAKE you handle the error. I think where Rust beats out Go is being able to do `something()?` and have the error automatically be returned if necessary. 
Yeah I much preferred pattern matching on Result (Ok/Err) than the `if err != nil` messiness.
Are you being obtuse on purpose?
That's why they call it computer science and not software engineering. Error handling is messy and requires experience to do well. That is hard to teach.
I mean the "normal Go way", not "normal applications". I'd expect a large proportion of Go apps to use `interface{}` *somewhere* for JSON serialisation or the like. The point is that in any reasonably designed app, usage of `interface{}` (or reflection) is limited to certain areas of the code, which makes it easier to deal with. Pointers are *everywhere*. 
&gt; Every line of code is (at least one) explicit step Of course it is. But when you define a function that takes `interface{}`, you know you're "off the reservation". When your function takes `*pointer`, you have no implicit idea whether it's guaranteed to be not nil. 
This sounds more profound in your head than it actually is.
&gt; Haskell and Rust are great languages, but their learning curve means they can never be mainstream like the C-family and derivatives I don't think the OP is claiming that Haskell/Rust are going to be mainstream. However, mainstream languages would certainly be better off adopting good features from non-mainstream languages. For example, most languages in the Java family (Java/Scala/Kotlin etc.) have lambdas.
Hey Todd, Are your Udemy courses as up to date as the ones on your site? I'm new to the programming / web development scene. Up until this point I've focussed on front end, mainly pursuing React.js. I have an opportunity to get my foot in the door with a big tech company in Australia. The catch is they have asked me to learn Golang and suggested your courses on udemy ([Web Development w/ Google‚Äôs Go (golang) Programming Language](https://www.udemy.com/go-programming-language/) &amp; [Learn How To Code: Google's Go (golang) Programming Language](https://www.udemy.com/learn-how-to-code/)). Cheers &amp;#x200B;
I wouldn‚Äôt consider a language with garbage collection as *low level.*
These are not shortcomings of the Go WASM implementation. WASM is still in the early stages, hence if you want to do things like DOM manipulation, you need to call back into JS today. In the future that (and many other things) will improve, follow the WASM future feature issues if you want to see how: https://webassembly.org/docs/future-features/
Start on greater Commons
That makes perfect sense to me. IMO, most panics are generally not meant to be recovered. How are you going to recover from a deadlock or running out of memory or disk space? I suggest that you think of panics more like assertions than like exceptions. Most devops would prefer to have your task crash, drop a stacktrace to syslog, and let some monitoring program spin up a clean instance from scratch in a consistent way instead of each task having custom logic to try to recover from panic-worthy situations. The other use for panics is of course when you want an exception like mechanism, and for that you need recover. but that's the last thing we want to encourage new gophers to do is to use panics in all the places they are used to using exceptions.
&gt; [not the first language to] do error handling correctly, [but the first for] the community implement error handling correctly Isn't that functionally the same thing? Haskell and Rust (Scala has a stdlib error monad as well) have language level error handling constructs that are used by their communities to implement robust error handling in their libraries, in ways actively promoted by their development teams. 
yeah, that's why go has panics ... /s
&gt; I didn't say Go was the first (or only) language to do error handling correctly then you are being hyperbolic. &gt; Correct error handling usage in other languages is often really bad. 
If your only comparison is to exceptions, then Go's error handling is arguably better. But there are more options out there, and compared to them, Go's error handling is an embarrassment. There's tons of boilerplate around it, and the compiler still doesn't care whether the error is checked or not. Rust, Swift, Haskell, and Kotlin have all shown how to do it safer \_and\_ with less boilerplate.
One of my few major complaints about Go is that it \_doesn't\_ make you handle the error. Some of my hardest to track down bugs have been places where I simply forgot to write the \`if err != nil { return err }\` snippet, causing the function to continue on even in the failure case. Because the \`err\` variable was used later in the function, there was no compile error--not even a warning!
using multiple return values for this feature (instead of union types or something) was imho a bad idea for this because you still have an (invalid) object representing the value if you don't handle the error. making things worse is that in Go, instead of getting nil (like in Java or C#) you can wind up with an apparently-valid object whose fields are initialized to their default values. so your missing error check can actually obfuscate the source of the error much further, because there might not be a panic at all. many languages (such as swift, rust, haskell) enforce that you check for the error before using the result -- and they do it without requiring three lines of boilerplate. I liked Go but don't drink too much kool-aid, IMHO. its error handling features were explicitly the smallest thing the authors thought could work, and designed around being keeping the type system simple, not around safety. 
rust and haskell programmers consistently use their existing patterns for this, but i agree that they're not very mainstream. and haskell probably never will be. i agree that many language ecosystems are stymied by having a history of implementing error handling badly. a lot of languages with c-like syntax have a version of this problem. in particular, implicit stack unwinding is imho really ugly, except in the case of unrecoverable panics. (or at least panics you're really not supposed to recover from, like the ones in Go and Haskell) i think it was good for Go to design its features for this from scratch instead of imitating another language. (i think Go's approach is similar to Lua's, actually, but Lua was an untyped language and Go wasn't, and no one thought Lua was a sterling example of language design worth imitating) however, i seriously disagree that Go's approach is safer than what other languages are doing in this space. (you can see my other comments in this thread for examples)
i think one strong point of Go's approach is that most lines of your code can't implicitly branch. this is not true of most languages with automatic stack unwinding, where you can call a function without an `if` and end up not continuing to the next line of your outer procedure anyways. this is also true of C, one of the languages that inspired Go, and it's a C feature that more programming language designers should try imitating. not implicitly branching is a major consideration for implementors of libraries like SQLite, who think 100% branch coverage is important. (i am personally a giant fan of branch coverage as a criterion for correctness) i still think the consequences of missing an error check in go can be dire and it shouldn't ever be possible to do that. i also think go's extreme verbosity makes it more tempting for people to go back and cleverly "prove" an error can never happen when it turns out it can -- just to avoid adding more lines of error handling code
&gt; you can wind up with an apparently-valid object whose fields are initialized to their default values... the golang idiom is to to always return value and an error. if the caller purposely ignore the error (discarding with _), then it's up to the caller to handle what default value of an empty struct means. also, as a lib designer you would never return some initialized empty value of a struct with `struct{}`, you would force return ptr type so caller can check for nil.
We might be getting off topic, but a lot of people _do_ think Lua is a sterling example of embedded language design. It was built from the ground up for its current purpose.
This sounds like a function of any kind of middleware as opposed to specifically being a router library feature. Just wrap handlers with middleware that derives a new context with a timeout 
i do prefer to return ptr type! but i've already used several common Go libraries such as gORM that operate on uninitialized records instead, to the point where i would say this advice is widely disregarded already! (much as a lot of advice about typesafety in C is ignored)
This is exactly what I needed. I didn't understand it's use till now. Plus the document @snowzach linked to below was helpful
i am actually a giant Lua fan, which is one of the things that originally turned me onto Go, but I think the space Lua targets is really different from Go. it's a dynamic language with pretty weak safety features where Go claims to be a language you can build your whole system in
But as you can see, this is pragmatic, subjective experience where this error handling results in less downtime. I‚Äôve never once accidentally used a nil pointer when an error was returned because the idiomatic way is to check if the err != nil first. I agree with OP, but the Go 2 draft looks like it will reduce the number of lines of boilerplate error checks. Can‚Äôt wait. 
One nice thing about nil pointers is that you can check for them in your methods. func (s *MyStruct) foo() error { if s == nil { return errors.New(‚Äúit‚Äôs nil, dummy!‚Äù) } }
Not sure why the downvotes. REFLECTION IGNORES THE TYPE SAFETY PEOPLE. YOU ARE INDEED PLAYING WITH FIRE. There are times where you need it, but you trade off type safety. Same as any other strongly typed language. 
I was like whaaaat? Then I saw his username. It checks out.
I can't share proprietary code but [this project is similar](https://github.com/golang-migrate/migrate/blob/master/MIGRATIONS.md) when it comes to how migrations are handled. Difference with us is that its triggered as part of the DB connection process in our service, so that we guarantee our service connects to a DB with the expected schema. Table driven testing is orthogonal to this technique. Don't know how testing would be any different, it follows the same pattern of set-up, test, tear-down, repeat w/ next test. What we have is a wrapper `WithMigratedDB` that connects to a "warm" DB running on the test server. The wrapper takes a closure in which you write your test, so the wrapper handles all the overhead: connect to the DB, migrate (if needed) to the latest version, truncate the tables, and invoke the closure. Somewhere inside the closure you'll insert your test data, call the code under test, and check the result. Assertions are also orthogonal to this technique. Your testing tables would contain all the expected outputs, and you're just checking equality of ints, strings, etc.
Your link is wrong, it's prefixed with r/ which lets reddit think it is a subreddit.
https://www.manning.com/dotd?a_aid=nathany&amp;a_bid=53f68821
&gt; If you had to provision an AWS, production sized database for unit tests it would probably take longer and be quite expensive Provisioning != testing. Do the provision once, keep the DB warm at all times, and write your framework to clean up before / after testing (as you see fit). Now you can run tests as many times as you like with virtually no overhead. &gt; A local setup for unit tests cannot fully mirror large production environments Doesn't have to for unit tests. You're only testing the query functionality of the SQL engine against your code. You're not testing how the DB scales. &gt; More so if you have one ready to go and people queuing to use it. One DB server can host many databases. We never have a queue because everyone gets their own database on the server. Again, we're only testing the query functionality of the DB... &gt; Load testing is not the same as integration testing, and neither of them are the same as unit testing. How very helpful. We've got all of the above in our CI pipeline. Lots of optimizations to ensure we run only what's needed for a given patch. And extended load testing happens after hours, when no one's pushing patches. But that's nothing to do with this thread.
List of relatively high importance without lambdas: - C - Go I can't think of other examples. 
this is the correct answer
Thank you, by now you can specify a key file through \`func (tun \*SSHTun) SetKeyFile(file string)\`. But for now it expects key files not to be password encrypted.
Go does have lambdas, they are just called ‚Äúfunction literals.‚Äù Or did I misunderstand your question?