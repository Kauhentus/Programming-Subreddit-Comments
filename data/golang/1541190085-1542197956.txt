Not desktop friendly either. 
[removed]
thanks
&gt; I moved to next slide Look at Mr. Can Move To Next Slide over here! I had my legs up and the mouse suggestion did not work at all, only saw first slide.
Oh yes, the old 'abstract away the awful' so you don't have to look at it. When I do this I always tell myself that I'm going to go back and fix it later. Tell me lies, tell me sweet little like.
I believe this is borderline ilegal but I can't help myself ¬Ø\\\_(„ÉÑ)_/¬Ø https://play.golang.org/p/6XdW3-FXgMP
I haven't tried making use of it yet but AFAIK part of go modules is supposed to fix the messing around with GOPATH, might be worth checking out if it actually fits your needs; https://github.com/golang/go/wiki/Modules
There is no inheritance in Go, and without additional context, it's impossible to determine what your actual goals are. But with composition you might do something like the following (`Derived` here is obviously a misnomer): package main import "fmt" type Fooer interface { Foo() string } type Base struct { f Fooer } func (b *Base) Foo() string { return "Base.Foo()" } func (b *Base) PrintFoo() string { if b.f != nil { return b.f.Foo() } return b.Foo() } type Derived struct { } func (c *Derived) Foo() string { return "Derived.Foo()" } func NewBase(f Fooer) *Base { return &amp;Base{f} } func main() { base := NewBase(nil) fmt.Println(base.PrintFoo()) baseComposed := NewBase(&amp;Derived{}) fmt.Println(baseComposed.PrintFoo()) } Output: Base.Foo() Derived.Foo() 
The link in the message is to the main site, which still doesn't show the updates for me, so here is the [link](https://tip.golang.org/doc/devel/release.html#go1.11.minor) to the tip.
To me, the reason an error isn‚Äôt the best fit for a map lookup is two fold. 1. A map lookup that ‚Äúfails‚Äù isn‚Äôt an error, it‚Äôs expected behaviour. 2. A map, being a container type, often doesn‚Äôt have enough context to produce specific errors. My counter example would be the `io` package. `io` methods return an ‚Äúerror‚Äù when the ‚ÄúEOF‚Äù occurs. The thing is the ‚ÄúEOF‚Äù is not actually an error, it‚Äôs expected behaviour. As such the signal being returned as an error means you need to check for `io.EOF` before handling the ‚Äúreal‚Äù error. An alternative would be to signal end of input as a Boolean, for example if n, eof, err r.Read(p); err != nil { fmt.Println(‚Äúwe have an error that is defined not an eof‚Äù) } else if eof { fmt.Println(‚Äúreading is finished successfully‚Äù) } `if.EOF` gives you absolutely zero context over a Boolean and misrepresents itself as an ‚Äúerror‚Äù when it is an expected / desired behaviour. Not just that, it‚Äôs actually in the happy path - the supposed error free path. All that being said, in practice, the absolute difference between using a Boolean or an error as a simple signal is marginal.
IMHO, you really, really need to pick a different name 
Like you would do it in C.
&gt; I wasn't the one who suggested Hugo to you yes, you weren't the one idiot. 
&gt;I wasn't the one who suggested Hugo to you. right! you weren't the unique idiot here
Excuse my ignorance here. Why release a 1.10 point release given the 1.0+ backwards compatibility guarantee?
I haven't read one single good packt book that is free of grammar errors, factual mistakes, bad advice and lots of blatant coding errors. so I concur!
Thanks 
It's a IoT messaging platform written in go by a Serbian startup that supports mqtt, http and websockets but they're working on adding coap eventually. Think of it like aws iot: it's messaging with a little bit extra (provisioning devices and whatnot) but you otherwise need to write code on top of it if you want to do anything useful, hence the go SDK. 
I'd like to know, too!
Are you saying that you want the TemplateStruct to just have ‚Äú/image.jpg‚Äù instead of ‚Äú./static/image.jpg‚Äù?
Usually these are done for security reasons, but I'm not sure with this one as I haven't read a changelog yet.
At work we are still on 1.9. Going to 1.10 vet now links and requires all the vendor code (before it just analyzed). This broke our pipeline and we haven't had time to fix it. 
Maybe /u/andybons _‚Äîthe author of that message‚Äî_ can chime in to explain.
Closed issues for the 1.10.5 release: https://github.com/golang/go/milestone/81?closed=1 From the Release Policy ( https://golang.org/doc/devel/release.html#policy ) &gt; Each major Go release is supported until there are two newer major releases. For example, Go 1.5 was supported until the Go 1.7 release, and Go 1.6 was supported until the Go 1.8 release. We fix critical problems, including critical security problems, in supported releases as needed by issuing minor revisions (for example, Go 1.6.1, Go 1.6.2, and so on). So, until 1.12 is released, 1.10 will receive fixes for "critical problems".
&gt; Shouldn't the http.StripPrefix function allow me to directly specify the file names without including the relative paths? No. It simply strips a prefix from the path before invoking the handler that it wraps (which is your `http.FileServer`, `fs`). It doesn't do any magic to anything else, and in particular it doesn't change anything about the way filenames are resolved in a difference piece of code.
[removed]
 C:\Windows\System32&gt;dumpbin /exports zipcontainer.dll Microsoft (R) COFF/PE Dumper Version 14.14.26433.0 Copyright (C) Microsoft Corporation. All rights reserved. Dump of file zipcontainer.dll File Type: DLL Section contains the following exports for ZipContainer.DLL 00000000 characteristics 6B594983 time date stamp 0.00 version 1 ordinal base 4 number of functions 4 number of names ordinal hint RVA name 1 0 00006600 CreateFileStream 2 1 00006560 ZipContainerCreateArchiveOnFile 3 2 00006540 ZipContainerInitialize 4 3 00006550 ZipContainerUninitialize Summary 1000 .data 1000 .idata 1000 .reloc 1000 .rsrc F000 .text 
btw when you say non-windows - what OS is it then ? 
It doesn't have to be Go and apparently it won't be. We are looking at our choices for the testing/QA/automation tools in my company. The obvious choice is Java. I wanted to propose Go instead. I was hoping there would be something but apparently Go has almost nothing in the domain of QA/automation.
Checkout the milestones to see what was fixed: https://github.com/golang/go/issues?q=milestone%3AGo1.11.2 https://github.com/golang/go/issues?q=milestone%3AGo1.10.5
i think you are hitting something down the lines of this : https://stackoverflow.com/questions/21589245/share-net-libraries-with-go
and possible this : https://stackoverflow.com/questions/44447318/c-sharp-dll-class-library-functions-called-from-go-language
`&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;` Bug/security fixes are patches. Minor releases bring new features that don't break backwards compatibility. 
Isn't foo ().catch() just a try catch underneath?
What is your policy for "updating" the golang version you compile your application with? My hope was, coming from php, once the code is stable and out the door I only have to worry about security issues, which are caused by packages(read insecure code) rather than worrying about the go-core. I was also hoping to get of the "we need the latest, greatest and best version of software X", which GoogleChrome and Firefox are promoting. Shit works, don't mess with it, unless it is a public exposed service.
Already expired :(
To say this another way, security and bug patches should, in general (not just go) be issued for a couple of recent releases where viable so that people don't have to upgrade minor versions in a hurry, since functionality differences are allowed between minor versions but wouldn't be expected between point releases. 
it's in your handler logic. You've got a handler looking for requests for "/static/", and you then strip that prefix off the path and send them to the fileserver. Anything that doesn't match "/static/" gets the ShowPage handler. func main() { fs := http.FileServer(http.Dir("static/")) http.Handle("/banana/", http.StripPrefix("/banana/", fs)) http.HandleFunc("/", ShowPage) http.ListenAndServe(":3000", nil) } will work just as well (i.e. you would need to change you ImagePath to "/banana/image.jpg" to get the image). the problem is that you either need to specify the page as the default, or the filehandler as the default, if you're going to use the default mux for this. i.e. either your code treats everything as a file path inside static, except for "index.html", or it treats everything as a request for the html, except for things starting with "/static/". Of course, if your system is small enough you can just big-switch it: func main() { http.HandleFunc("/",bigSwitch) http.ListenAndServe(":3000", nil) } func bigSwitch(w http.ResponseWriter, r *http.Request){ switch{ case strings.Contains(r.URL.Path, "image.jpg"): http.ServeFile(w,r,"/static/image.jpg") default: ShowPage(w,r) } } then, any request that has "image.jpg" in it anywhere gets the image, and everything else gets the HTML
Banana fiber is used in the production of banana paper. Banana paper is made from two different parts: the bark of the banana plant, mainly used for artistic purposes, or from the fibers of the stem and non-usable fruits. *** ^^I'm&amp;#32;a&amp;#32;Bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Unsubscribe**](https://np.reddit.com/message/compose?to=BananaFactBot&amp;subject=I%20hate%20potassium&amp;message=If%20you%20would%20like%20to%20unsubscribe%20from%20banana%20facts%2C%20send%20this%20private%20message%20with%20the%20subject%20%27I%20hate%20potassium%27.%20)&amp;#32;|&amp;#32;[**üçå**](https://np.reddit.com/r/BananaFactBot/comments/8acmq6/banana/?st=jfof9k8d&amp;sh=acd80944)
A router is a thing that decides what handler to call when given a request. A handler is a thing that is given a request, and a method of responding to it, and does something with the request to create a response. Why can't your handler call any function it likes to parse the request body, create some suitable response, and send it back via the responseWriter? Why are you trying to pass a reference through the context?
this. Your code has to deal with the different types at some point, and do something with each of them. You cannot have the same processing code for an int as an array - you must do something different with them at some point. You can choose to do that while parsing the json, or after handing your neatly-parsed structs to your business logic. It doesn't really matter. Somewhere in there you'll have to do something different with it, and the overall result is only different by where you choose to handle that difference.
Since each goroutine *knows* the chunk it is downloading, isn't it a matter of just attaching this additional piece of info to the result of each go-routine? Another way of doing this would be to assign a sequence number when you are spawning goroutines (which are also part of the goroutine result) so that when you have all the outcomes, it's just a matter of sorting this sequence identifier and stringing together the bytes to re-assemble the file.
Each goroutine knows the chunk details it is downloading - like the start offset and the size. When writing to a file, it just writes at the offset that it is downloading. Look for "seek" or "fseek" to set the file position to read/write.
The name is already taken :( https://en.wikipedia.org/wiki/Getty_%28Unix%29
IMHO, you really, really need to pick a different name.
I thought the same thing, but I think it‚Äôs tricky for them - Go 2 is already a defined WIP, and bumping to 11 wont work as that‚Äôs already released - so existing, presumed unexpected ‚Äúmajor‚Äù fixes are left to the minor version in this case. It‚Äôs almost as if they‚Äôd benefit from a 4th number to indicate this, but I think in practice we‚Äôve all accepted go‚Äôs versioning in general.
Is this because you are seeing the print statement 8 times with the same value printed? Pass in the 'i' variable to the function you are executing as a goroutine, that will give the function a copy of the variable i at that point in time, in stead of what you are doing now, which is sharing the i value with all the goroutines, meaning they most likely will all print the value 8 (or just the latest value in the for-loop)
 package main import ( "fmt" "sync" ) var wg sync.WaitGroup func main() { for i := 0; i &lt; 8; i++ { wg.Add(1) go func(x int) { fmt.Println("Thread: ", x) wg.Done() }(i) } wg.Wait() } &amp;#x200B;
explanation: [https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html](https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html)
Run `go vet` before running your code. This will give you the following hint &gt; loop variable i captured by func literal
I think I may have a misunderstanding of what context actually is versus what we've named a struct to hold pointers to a variety of services in our app such as the database, memory cache and state(dev or production mode). We've gotten to a point where our overall structure has allowed people over time to write code in our package that holds the router and handles those routes that I feel honestly shouldn't be there. For example while yes, some requests can be finished with a quick db call, others have a massive sequence of events that should be broken down and placed somewhere else to handle this business logic. I feel that whichever function is handling your request, it should pre process the request(vars, etc), make a call to the business logic function it needs to call with pre processed data, which then returns you the result or an error and then the function handles the http response with an error, a write json, etc. This thought is due to the package that handles our routes... is defined in such a way and used in such a way that it should only handle our routes, and executing some function to receive that data. We're missing a layer that let's us clearly define a space write business logic functions with their helpers, etc. As I'd really like to break these larger functions down to smaller pieces that might be able to get reused üòÑ
Consider the Go runtime as a 3rd party library that does require updates 
What's good about my question?
Not that much of a problem IMHO. A Go microservice framework is sufficiently distinguishable from a CLI terminal manager and a [British American petrol-industrialist](https://en.wikipedia.org/wiki/J._Paul_Getty) of the same name. And FWIW, the name Go was also already taken when Go the language got its name. https://en.wikipedia.org/wiki/Go_(game) https://en.wikipedia.org/wiki/Go!_(programming_language) https://en.wikipedia.org/wiki/Go_(verb) https://en.wikipedia.org/wiki/Go 
[removed]
I should note that even though the title sounds like the removal has already happened, the Go support code hasn't been removed yet from the code base. It's just very likely that it will happen unless LLDB spontaneously finds a new maintainer for the Go plugin.
For things like this you won't need a framework as all this (http server, json handling, etc.) is already built into Go. Google for some Go Rest tutorials and you'll see how easy/fast it is to spin something up.
Don't use pointers, and figure out a way to make zero values useful defaults (or make it so zero values are not valid options, so you can detect when the user doesn't pass anything in). It will take more time to model your data in this way, but your code will be far better for it.
This looks promising. Thank you!
This person previous stole the entire go-micro codebase to implement this [https://github.com/AlexStocks/dubbogo](https://github.com/AlexStocks/dubbogo) and continues to lift significant portions of code. Author, please find new ideas for your derivative works, use better naming and provide credit back where you're quite literally lifting code.
Glad you like it! :D
Thank you, this is an interesting answer. After asking it, I thought that I would prefer not to use the language at its lowest because I forget how things are pieced together etc. Sometimes being limited is better than writing a completely custom system. I've looked down the frameworks and I know there are purists who advocate using the language but as you point out, it is unreasonable, so I think a framework is needed. I want to look at iris and beego, but will also check out gin.
How big a number?
I see this so much. Routing is simple. Business logic is hard. A router is literally a simple function that decides what handler to use to deal with an incoming request. That's it. But Rails and various frameworks have decided that a router is a complex thing that should handle every edge case in the world, apply the correct middleware, and generally be the heart and soul of any web app. It's doesn't need to be this way. Make you router simple, and get it to call the appropriate business logic. The business logic service/package can handle initialising the database, etc by itself
but I've already migrated my test and dev environments, because I needed them migrated to test my new code. How do I (at the same time) test both that my migration won't break my database, and that my new code won't break my database? 
Oh! I'll update the README. 
Actually, when you download the main problem is the bandwidth. It's easy to split the file, name them differently, download each part in different goroutines and then merge them all at the end. But if the bandwidth is limited to 2MB/s it doesnt make any difference having 1 thread at 2MB/s or having 2 thread downloading at 1MB/s each
Thanks for this lib, BadgerDB seem fast not stuck with 100k+ record when I tested with default bleve index store, I will use this to replace ES, bleve search result was good enough and 80MB vs 1300MB is too tempting, disk for badgerdb store is a bit large but cheaper than RAM for me
Here's a fun thing extracted from some code we use at work: just define type OffsetWriter struct { io.WriterAt offset int64 } func (dst *OffsetWriter) Write(b []byte) (n int, err error) { n, err = dst.WriteAt(b, dst.offset) dst.offset += int64(n) return } and then `os.Open` your output file *once*, and for each chunk initialize `ow := &amp;OffsetWriter{w, offset}` where `offset` is the starting position of that chunk. Then you can `io.Copy` from an http response into each of those `OffsetWriters` in separate goroutines, and the data will land in the file in the right place. Getting the range parsing and all of the error handling right is nontrivial (our library is around 1,000 lines of code, although at least half of it is parallel hashing, speed monitoring, etc.) but the basic idea principle is something I came up with and had working in an afternoon. Contrary to what /u/r2d23d says, chunked downloading can pay off massively. Sure, if you have a slow connection, nothing is going to let you get the file faster than your connection can move it, but in our case (downloading to servers with multi-gigabit links), we've seen up to a 10x speedup in some situations.
Excellent write up. Very Go. Just enough to get started and no more. Also conveys the concept very clearly. Thank you for doing this.
nope
Some places/proxies might cap the per-connection bandwidth, so opening multiple connections is also a way to go around that. &amp;#x200B;
I wrote a library to do this: https://github.com/porjo/braid
You're conflating two interfaces in one class. Layer them properly. https://play.golang.org/p/pt4uSUgKu7Z
This site really needs to be worked on for mobile friendly view
For a trivial example like this you can inject in a `func` into a calling `func`: package main import ( "fmt" ) type printFunc func() type foo func() string func newPrinter(f foo) printFunc { return func() { fmt.Println(f()) } } func newBase() printFunc { return newPrinter(func() string { return "Base.foo()" }) } func newDerived() printFunc { return newPrinter(func() string { return "Derived.foo()" }) } func main() { b := newBase() b() d := newDerived() d() bd := newDerived() bd() } For something more complicated you might have to use an interface. But it all depends on what you are actually trying to achieve. There is no point trying to replicate inheritance in a language without inheritance. Inheritance is just a tool, a means to an end, not an end in itself. 
Are you writing to disk instead of buffering it all to memory first? ISTM you‚Äôll be bottlenecked by slow disk speeds, but I guess you never know until you benchmark it. 
If your data can contain `null` or has optional fields and you need to model this accurately, use a pointer. If not, don't.
Buffering disk writes in memory is a feature that the OS gives you for free, it's generally not necessary to reinvent it yourself. Anyhow, our writes are going to fast SSDs, so there's a decent amount of disk throughput available :)
I am working on a Gameboy emulator myself, I found a few good resources like a [specification manual](http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf), [another specification document](http://problemkaputt.de/pandocs.htm), and a [really good talk on the gameboy here](https://www.youtube.com/watch?v=HyzD8pNlpwI) &amp;#x200B; [here is my far-from-complete emulator](https://github.com/Jumballaya/Gameboy) ... there are some more links in the readme about building a gameboy emulator.
Isn't delve using lldb as a backend on osx ?
[removed]
Eek, I don't know. Good question.
Yeah, but that requires the bittorrent infrastructure to handle dynamic source (peer) connections. It's not exactly generalisable to any given file download from some http server - unless of course you had a pre-compiled list of valid sources to download the file from.
or alterntively put `i := i` before the go routine, though personally I prefer your suggested way of doing it as arguments 
I can‚Äôt wait for the future of this stuff. I‚Äôm tired of hearing about node using the same language front and back. 
Quick look at the documentation seems to confirm this: https://github.com/derekparker/delve/search?q=lldb&amp;unscoped_q=lldb
[removed]
I'd start with https://github.com/randall77/factorlib . My package https://github.com/dgryski/go-factor isn't fully ported from C yet.
I've really enjoyed badger and bleve for my last project. It's great!
If the service is public, I agree with you. Update, test and release. For private services where you control inbound, or there is no public input, you have a bit more choice. Maybe you do need to, or maybe the bug fix has no impact on you. I like to keep services up to date with Go releases where it makes sense to. When you go back a work with a service again later, the code has already been built and deployed running the latest version of Go, or at least something relatively recent. If your build/release process is smooth then it might be fairly trivial to build and release existing services. You can always rollback to the previous version. It depends! :)
I bought a book not long ago about using Go in the front and back. It's called isomorphic Go. It uses a transpiler to change Go to JavaScript. (GopherJS is the library, I think.)
I personally don't automate that because I have a lot of projects on my machine that have their own, so I need to use a vendor tool. For newer projects I'll use Go modules. I'm not sure of a plug-in that would allow you to choose your vendoring tool per project, but if there is that'd be sweet.
I personally don't automate that because I have a lot of projects on my machine that have their own, so I need to use a vendor tool. For newer projects I'll use Go modules. I'm not sure of a plug-in that would allow you to choose your vendoring tool per project, but if there is that'd be sweet.
[removed]
There is also the SQLCipher project, which is open source: - https://github.com/sqlcipher/sqlcipher - https://github.com/mutecomm/go-sqlcipher (based on mattn/go-sqlite3) 
I recently switch to go (still a nub) from php. Go is go nice and for your everyday projects it is very easy to use. There is a learning curve with arrays, slices, maps, and using data, but overall it handles http very nicely with an official package. # Php became a mess I left php (still use it from time to time) because it is slow and cluttered with frameworks. There are so many frameworks that it is a giant circle jerk. I have so far made 20 or so projects in go and use maybe 5 or 6 packages. * fmt * strings * net/http * html/template * database/sql &gt; net/http, html/template and database/sql literally replace all frameworks. There is very little need for a framework when you have these. Those are basically Batman's tool belt of webdev in golang. Follow any tutorial and you will have a good grasp to get started using go for the web. # Go is the new C When C came out you saw a huge innovation in programs and software on the desktop space. I feel like this is what we will see from go, but on the web. # GoUI Another big reason I wanted to get into go is that it creates a compiled product. You download it, send to others and so on. Currently, go doesn't have an official gui package that I know of, which is sad for a new language in 2018 in my opinion. I think it would be a great benefit for go to have an official package for this. For people who are seeking 1 language for multiple things, so would be a very useful tool. Lets say someone who has a webapp, but then want to offer an offline version or downloadable version. Go would be perfect! &amp;nbsp; While go doesn't have an official gui package, there are still many options of there (still mad at go) that you can use. I have used a lot of different ones, some work ok, some I have barely been able to get working and others I could only get working on windows (even though they say it works for mac and linux), so you might have to search git hub or check out some tutorials to find something that works for you. &gt; hint hint, golang... hint hint. 
Thanks for sharing. I've been thinking about doing a similar style CLI to manage investigations about technical issues.
OP here. I am looking for volunteers to technical review my Golang book. Please read the blog post for more details. If you're interested, please let me know via email: baiju.m.mail@gmail.com
You're right that a framework is needed, but Go stdlib is already a framework on is own. We're not purist we're just lazy to learn others frameworks.
If you use the new module support those packages (modules, really) get downloaded automatically.
So far I like the straightforwardness of Go as a language, and the fact that it cross-compiles in one binary. Being able to program in Linux and cross-compile an .exe for Windows to use at uni is nice. I like it better over python because there is less "magic" going on. Nevertheless, I want to study more about concurrency and channels, I still cannot use it intuitively. So, I will most likely keep using Go for now. &amp;#x200B; For testing and debugging, there are a few things I like. First, you cannot compile if some variable is doing funny things (like using a string instead of int) or is not declared, so you avoid problems at compilation time, and not at run time. Second, there is a race detector included in Go. However, sometimes it is easy to miss the scope of a variable. Sometimes I use `foo, err := func()` for assignment, with `foo` being a variable previously defined, and then I wonder why I am not getting the expected result. &amp;#x200B; I would love to see your manager and how you approach some of the problems along the way :)
I'm worried. Won't wasm be a huge security risk? You won't know the code that's running on your system when entering a website 
What went wrong?
https://webassembly.org/docs/security
it doesnt seem to pass the comparison even tho they both have the same value
When the method is post you might have to do a ParseForm. https://godoc.org/net/http#Request.ParseForm
thanks once more. I get the value on the server (whenever i print its printed) but if i compare it with another variable with the same type and value it doesnt work .
What is the new modiule support ?
Thanks just tried it and the result is still the same 
The [wiki page](https://github.com/golang/go/wiki/Modules) looks like a good introduction.
FormValue["method"] returns an array. I think you want FormValue["method"][0]
i think you mean r.Form\["method"\]\[0\] @[**intolerablekane**](https://www.reddit.com/user/intolerablekane/) made mention of earlier. I also tried it and had the same result.
If you use r.Form[]. You have to first use r.ParseForm(). If you have then you should try printing the value and seeing if something wrong there 
Looks good, but there's still no way for a consumer to know if a company uses your CPU improperly, for things such as crypto mining. People did it with JS even though anyone can look in the code and see it, this won't be true for wasm. 
It won't help here. I'm talking about printing the value without implicitly calling its String() method. 
I'm lost then. `r.FormValue` returns a string (not a slice) and that is what OP is claiming isn't passing the comparison test. Why would %q not be appropriate if that is where he claims the comparison is failing?
We don't have a complete code. If OP is claiming both values are the same and tests it with printing functions, comparison must succeed or values must be different, but printing makes them look the same.
Wow Thank you all for the help, the problem was from postman. Glad to be part of this amazing community.
you can scramble your js code (or compile to asmjs which is a superset of js) and it will be hard to read, no difference to wasm.
Go routines and channels are amazing once you get the hang of them, but remember not to overuse them once you're able to. It's easy to just want to use channels for the sake of it because they're cool and unique, but often it's unessesarry and makes the code confusing. 
The delve channel on the Gophers Slack says we should be fine.
Ok guess i asked
I believe you accidentally posted this comment twice FYI
Damn I was afraid of that - the app was hanging for me when I hit submit. Sorry about that.
I think the name "Go After Dark" is quite brilliant from a marketing perspective. I'll be giving your series a look!
We're still in the middle of an opinion based conversation. You alone can not speak for a whole community and if you use community X, Y, or Z, the data isn't complete. It doesn't account for the tons of programmers that don't post or vent online. Anyway, about the last thing you mentioned. I don't like having a single file for routing in php. I have a private framework that I license that simply blocks direct access to "index.php". There is a single file that needs to be included (sometimes you end up doing `include "../../frame/init.php"`). It normalizes some things like PWD and common libs. The expectation is that every directory delivers a page. If anyone ever wanted a pretty URL, they would have to make a rewrite for it, but GET data should just work out of the box. Now... header/footers... haha that's fun. I had to do a ghetto thing to make footers happen with just a single include. I used `register_shutdown_function` and I had to use the extract function against $global to make the system template-able. In all, I liked the framework I made, but I still had that I had to make a framework to meet customer needs and make things work the way php wants to work. I'm definitely not calling php perfect, but what I am saying is that it is a tool, it works, either learn to use it or use a different tool that works how you want it to. 
This is exactly what I use and it's *very* flexible and powerful.
https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/ https://github.com/golang/go/wiki/WebAssembly I was kinda messing with it... But stopped cause I'm waiting for actual goroutines. https://play.golang.org/p/d_UziITZdoj
The name of the language is Go, not Golang.
Cool !
Tried checking out the kubernetes repo, nearly crashed my browser 
Hence me suggesting that the strings that are different but look the same be printed with %q, which will show whitespace, newlines, tabs, etc clearly (eg \t for tab)
I've read up about web assembly a bit already. Have played with emscripten and llvm compilers directly with some varying results. Goroutines would be cool, but I'm just aiming to build some cryptography features once and just use them on both the frontend and backend. I think your example may be the reverse of what I'm trying to do. I think this tutorial has some functionality that I'm trying to achieve. I followed it from top to bottom with Go 1.11.2: [https://medium.zenika.com/go-1-11-webassembly-for-the-gophers-ae4bb8b1ee03](https://medium.zenika.com/go-1-11-webassembly-for-the-gophers-ae4bb8b1ee03) I'm getting this error now: ``` wasm_exec.js:257 Uncaught (in promise) TypeError: Reflect.get called on non-object ``` I think I may have just hit a bug that isn't hashed out yet. 
Is there any guideline about when to use 'Go' and when to use 'Golang'?
Thanks for the feedback. I have corrected it in the blog post. I quickly check the book content, I am using 'Go' everywhere. It looks like I cannot edit the title of the Reddit post.
Remove the go.sum file and see what the CI server produces. 
&gt; Can I build to wasm and call functions from JS to just get return values? In 1.11, not directly. You can call a Go function from JS and set the return value in a JS variable. This indirectly achieves what you want. But in 1.12, we will have sync callbacks which will be able to return values. Here is a quick sample of what can be done in 1.11 - cb := js.NewCallback(func(args []js.Value) { out := 1 // result of some computation js.Global().Set("myVar", out) }) js.Global().Set("myFunc", cb) Now from JS, call `myFunc()`, then you will see `myVar` being set to 1. The only issue is it won't be synchronous. For which you will have to wait til 1.12.
Ikr?
So it's pretty much asynchronous function calls until we get 1.12. That's fine enough. :) Strangely enough though, it seems any function I set inside Go for JS to call, when I call it, it does run the function but results in "Uncaught (in promise) TypeError: Reflect.get called on non-object". I've been trying to figure that out for a few hours now.
Use "Go" or "Go Programming Language" when writing ordinary text. Possibly use "golang" in hashtags and other contexts where a single token is required and "go" is not specific enough.
Could be related to this issue where some modules are getting different checksums in different environments. https://github.com/kubernetes/kubernetes/issues/69040 One of my colleagues saw this and was able to get past it once on 1.11.1 
BASICALLY an interface describes a set of requirements (methods). Any type that adheres to those requirements (implements those methods) can be passed in place of the interface. It's similar to the OO interface/implement principal but you don't have to state that you implement it, you just have to.. well.. implement it. How to use it is simple. Say you have a bit of code that serializes data to (somewhere) but also needs a name to identify the output. You could make an interface e.g. `type NamedWriter interface {` `Write([]byte) (int, error)` `Name() string` `}` Then any type that implements the Write + Name methods can be passed to the method. Including types that you didn't make, for example the stdlib os.File type.
Glad to hear you resolved your issue. Have fun with wasm !
this looks amazing.
Great idea, good execution.
I've been wanting to build a 3d file system viewer for a long time. I built a weak version in Python with Panda3D but never went anywhere. This one looks awesome! I read a little about https://wettel.github.io/codecity.html and it's really cool.
Can be a bit awkward when you're using err like that. Just define it before continuing: var err error
Sure, but what's the reason for the assignment operator showing the error for third assignment and not the second one.
* `file, err := os.Open(filename)` declares both file and err then sets their values * `jsonFile, err := ioutil.ReadAll(file)` declares jsonFile and sets the values of both it an the existing variable err * `err := json.Unmarshal(jsonFile, &amp;board)` err already exists and there are no undeclared variables in the statement so trying to declare one is an error. The solution is to assign a value without declaring by using = as in `err := json.Unmarshal(jsonFile, &amp;board)` 
The variable err was declared via the first := operator. On the second operator it was allowed to be redeclared because you have a multiple return values ( try changing to -, err:= and you'll get the same behavior as the third operator... Basically as long as you are declaring at least one new variable it will let you redeclare one(as is happening with err in your examples) I tend to either declare the variable at the beginning of the function or as part of the return signature like (board Board, err error), if I expect to reuse and check the err variable many times, etc...
I asked around on Twitter a few weeks ago if there was interest in a writeup for deploying Go apps based on Docker scratch images, and the response was overwhelmingly positive, so I finally got around to writing it.
The go toolchain, including dep, does not support symlinks. In some cases it may work, but it's by accident rather than design. If you have a multi-language project, you have roughly three options: 1. Clone entire repo in $GOPATH/src/github.com/yourcorp/yourproject, and use absolute paths for imports in the Go code. 2. Clone repo wherever you want, but keep Go code in go/src, and enforce GOPATH=/path/to/repo/go to build. 3. Use a tool like [gb](https://getgb.io) instead of the regular go toolchain to build.
The left-hand side of `:=` must contain at least one new variable, otherwise you can just use `=`, which will fix the problem on the third assignment.
According [documentation](https://golang.org/ref/spec#Short_variable_declarations): &gt;!Unlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original.!&lt; &amp;#x200B; In the last case you are trying to redeclare err, while in the previous cases you are re-assigning it due to a new variable
[removed]
It crashed my iPhone 
You can tune badger and other LSM tree based key-value stores to use less disk space, albeit mostly at the expense of background/periodic compaction tasks.
"If all you have is a hammer, everything looks like a nail", I guess, hahaha. &amp;#x200B;
Nice, I didn't know these existed. 
&gt; Note that we‚Äôve removed the CMD /myapp line because (probably for good reasons that I don‚Äôt fully understand) You want to use the array form of CMD, which bypasses the shell: CMD ["/myapp", "arg1", "arg2", "etc"]
Yo! So I just wanted to stop by and post a link to my random generation library that I made for game development, dngn. I've been working on it for the past couple of weeks, and it's going pretty well so far. This is the first release, so it still has a lot that could be improved about it, but it's OK for a start, I think. Check it out if you have need of random generation in your game development pursuits. So... Yeah, that's basically it. Thanks!
Looks groovy - well done
SML = Standard ML. ML used to be "meta language" for LCF. It's not "Standard Machine Language". Also, there's a structural pattern matching in Go. switch at := a.(type){ case []int: case Foo: } What would be nice to have is value pattern matching. So you can do this: switch at := a.(type) { case at[0] == 0: case at[0] == 1: case Foo: }
If you're already v2 but without the \`/v2/\` path I would think the easiest thing to do is start at v3. Adding go modules IS a breaking change as it requires a new versioned import path.
lol, you're never going to get that in Go 2. We won't even get method overloading.
Looking at this issue, I'm not sure the author is interested in a Go version: https://github.com/KieranP/Game-Of-Life-Implementations/issues/7 Pretty much discarded game of life code from official Go docs because "Go doesn't have classes" ¬Ø\\\_(„ÉÑ)_/¬Ø
Two reasons I can think of: 1. `run` needs to be called inside other methods besides `Run` 2. It separates concerns/logic and makes refactoring easier. If you were to add some functionality to `Run` that is not concerned with actual `run`ing, that can be added directly to `Run`. for instance this: &amp;#8203; func (p *Pinger) Run() { p.prepare() p.run() p.Done = true } is much easier to go through vs `Run` having all that logic at one place. In your case since all `Run` does is call `run` it's hard to justify this. But if you do need to add such functionality to `Run` later on, you would probably be separating `run` logic.
When you're talking the difference of a few single-digit MBs, it's likely not worth the hassle. Keep your package manager around to add dependencies if you ever need them. The alpine base image is 2.1mb in size, and you can remove the package manager from production images to limit attack surface. If you want to squeeze out a few mbs in size, use upx to compress your go binary.
Was v2 a breaking change from v1, does v2 have a different import pass from v1?
You definitely don't need the v2 to be in the file path. If you add the go.mod declaring the module name (not including the /v2 suffix) and make sure that you tag the resulting commit with a semver tag (eg `v2.1.3` if the repo only contains one module, or `foo/bar/v2.1.3` if your module is at path foo/bar within the repo) and/or make a branch with the same name (but only the major version part), that should do it. Your dependants then do `go get your/package@v2.1.3` and it should just work. I've been doing just that with several repos for months now, some with one module per repo, some with many, at least one of each being v2 or higher.
Sorry, but this is definitely not true; adding module support is not a breaking change. See my other comment.
[https://github.com/golang/go/wiki/WebAssembly](https://github.com/golang/go/wiki/WebAssembly)
oh i didnt knew the json as code thing, thanks for that :) other than that I use vim mode and rich go too but also wanted to know if there is more cool stuff out there :)
No, but I don't understand how OP expects to support v1 and v2 with the same path. This leads to dependency hell.
Check out Range Loops on https://blog.golang.org/strings
does it have to satisfy two interfaces? 
yeah, UTF != ASCII, and Go strings are UTF, so when you iterate over a string you get each rune, not each byte.
Yes you're correct. \`string\` in Go is a utf8 string, so \`string()\` type casts the byte slice to a utf8 string. A range loop over a string iterates over runes in that string. rune -&gt; int32, which represents a unicode codepoint. You see \`c\`'s type in second range using \`reflect.TypeOf\`.
This is not 100% correct. &amp;#x200B; When converting a byte slice to a string using \`string(mySlice)\` , \_nothing\_ is encoded or decoded. The bytes are copied \_as is\_. Note that they are copied, because strings are immutable, and you don't want the string to change if the original byte slice changes. Source: &gt;a string holds *arbitrary* bytes. It is not required to hold Unicode text, UTF-8 text, or any other predefined format. [https://blog.golang.org/strings](https://blog.golang.org/strings) It's only when you \`range\` over the string that the bytes will be interpreted as UTF-8 code points: &gt;A for range loop \[...\] decodes one UTF-8-encoded rune on each iteration. [https://blog.golang.org/strings](https://blog.golang.org/strings)
I think, you kind of miss my point. There are plenty of tools to test software, so why don't you pick one of those instead of making it yourself?
I think he meant to say ‚Äúinterpret‚Äù, but ended up saying ‚Äúencoding‚Äù. Either way this is a good answer, have an upvote. tldr; strings are slices of bytes and vice versa; if you range over a byte slice, you get 1 byte per iteration. If you range over a string, you get 1 or more bytes (rune), but the index will always point to the underlying byte slice. 
[Concurrency in Go](https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/) &amp;#x200B; This book was very useful for me.
I would strongly advice against this option. 1. You still need to check field values. Check if something is nil, or if something is a "zero" value is the same effort. 2. Using "magical" zero value numbers will just introduce errors at some point. Using pointers and "nil" values is the way to go in my opinion.
Just Rich Go, it's pretty baller. with Sublime Text I used GoSublime for ages which is also really good, they've moved to a different major version now and I haven't really been using ST as much so I'm not sure what it's like now.
The go formatter, it comes with the golang extension pack of vscode . Or you can call gofmt -w file.go from the terminal 
It's hard to find advanced books in any language since advanced means narrower topics, narrowing both the audiences and authors. However, Thorsten Ball wrote a couple fantastic books: Writing an Interpreter in Go and then he wrote Writing a Compiler in Go. He's a fantastic writer, has engaging content, and he dared select an already-experienced audience for the first book and then dared to take a step further and write a book that--while it could stand alone--is best as a follow on to the first. In terms of other books, there really aren't a ton out there. A lot of my reading comes in the form of reading docs and libraries of repos I find fascinating. I recently came across [SuffixArray, which is a fantastic index tool to have in a standard library](https://golang.org/pkg/index/suffixarray/) for the first time, and I've learned a lot about both Go and how one might implement a scripting language like JavaScript by studying [Goja, a js re-implementation](https://github.com/dop251/goja) which isn't perfectly idomatic Go, but the choices make sense in a context mixed with JavaScript-specific choices. I've also looked a lot at [Bleve Search, and upside down index for powerful, flexible searches of arbitrary data--even geo-bounded queries on coordinate points](https://github.com/blevesearch/bleve), which makes simple key value databases like [Boltdb](https://github.com/etcd-io/bbolt) and [Badger](https://github.com/dgraph-io/badger) easy without having to worry about item retrieval causing you to re-implement a lot of what you miss in a SQL database. Otherwise, I've looked at specialty projects like [Ebiten, a game library](https://github.com/hajimehoshi/ebiten) and [Go-git, which is a Go implementation of Git](https://github.com/src-d/go-git) and can make for some interesting tooling projects.
Don't remember but a couple of the emacs keybindings plugins are the first things I install after VSCode.
On top of default [Go extension](https://code.visualstudio.com/docs/languages/go), I'm using [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one) and [YAML Support by Red Hat](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml) (RIP Red Hat üíÄ).
I think the only GUI OP was writing about was web-based. But I do agree, it would be nice to have an officially maintained, really "Go" GUI package. I've used gtk2, gtk3, and Qt bindings in Go, and the Qt bindings are _by far_ the best I've used. One of the biggest benefits I've found from Qt is that the documentation is _so_ much better. When I was trying to get to grips with GTK development I kept hitting dead pages, tutorials relating to old ways of doing things, and I was constantly hitting deprecated functions or methods of doing things. With Qt, I just had a really pleasant experience - compilation was slower, but Qt presents information easily to you as a developer (e.g. I wanted to be able to position a window on the current screen in Qt - SUPER easy in Qt, not as easy in GTK).
+1 for reading repos specially for protocol implementations. go is such a readable language that you can follow along the actual implementation of a protocol spec.
If I understand your use case correctly, then I think this would be very close to ideal for your use case, but I wouldn't get too worked up over the extra 5MB that this method saves you over an alpine base image.
This related Dockerfile was posted a few days ago: ``` # Sample from @citizen428 https://dev.to/citizen428/comment/6cmh FROM golang:alpine as build RUN apk add --no-cache ca-certificates WORKDIR /build ADD . . RUN CGO_ENABLED=0 GOOS=linux \ go build -ldflags '-extldflags "-static"' -o app FROM scratch COPY --from=build /etc/ssl/certs/ca-certificates.crt \ /etc/ssl/certs/ca-certificates.crt COPY --from=build /build/app /app ENTRYPOINT ["/app"] ```
We've been using \`graphql-go/graphql\` for a while before coming across \`gqlgen\`. Our original reason for switching over was because the former lacked any movement, especially on data loading / parallel execution. But, it's definitely been our go-to / choice of GraphQL library since. And, it pairs well with our auto-generated protobuf models. Great job, and looking forward to schema stitching so we can migrate our older GraphQL APIs over gradually :) &amp;#x200B;
Over what protocol? SMB?
**Globals** Globals are bad for quite a few reasons. Here are just a few: * They collide with type / function names. What do you call your global? `DefaultFoo`? `FooSingleton`? None of this is very nice. * It's harder to identify where globals are used in your code; that is to say, if you look at some other part of your code, and are trying to figure out what dependencies that code has, it's a lot easier to look at a struct with a bunch of fields that are the dependencies, rather than searching through the code to find all of the references to global variables. * Referencing global variables makes testing more difficult; you can't swap out dependencies as easily. How would you re-use a type but with a different dependency? You'd still need to use DI, why use globals at all if you are going to mix it with DI? Just have one consistent approach. * Using globals limits your options for constructing types in general, and limits how you control when something is constructed. It also might make using patterns like the factory pattern a bit trickier, unless you make a factory a global? (:puke:) * Using globals means that some code could actually replace part of, or set a dependency to nil - and you'd have to hunt down where that happened as it affects your entire app. * You're possibly more likely to introduce race conditions. I think in general it's easier to be careless with global variables. **\`models\`** This one is a bit of a tricky one in Go. People have package names like `types` for example (which I'd still argue is bad). Normally what I do is group up "models" (and other types alongside the models) by domain. Even then, it can be difficult to avoid stuttering in this case (e.g. `user.User`, or `container.Container`). I try to find package names that provide some more context, or that specify the "parent" domain; for example, `auth.User` (and then next to that maybe you could have something like `auth.Gateway`, as a type that interacts with some database using that `auth.User` model). Package naming is hard, but "good package names" should be descriptive, and provide context. I like to think of it as when you read any top-level type / function from a Go package, it should read nicely, e.g. `search.Handler`, rather than `controllers.SearchController`. You eliminate the unnecessary duplicate information, and stick to idiomatic names.
Yes, SMB
After long consideration, I started my graphql api development using gqlgen. I use MongoDB as db backend. It works great... Is there any example on how to use subscriptions? 
Can't use docker and virtualbox at the same time, bummer.
More fake news from the NYTimes. Sad.
True.. if I were able to, by myself, deploy a service where 5MB per micro-service made a difference... I would have entirely different sets of problems no related to micro-services. :D Still, it is good to know that this could work. I was going the route of a full blown golang dev setup with ubuntu server, etc. I much prefer smaller/faster images. In fact, what I like about this is.. if I understand it right, I could very well use this in a build pipeline where a CI/CD might kick this script off that builds the application, then builds the binary image that would be deployed in say staging or production. I am sure there is more to it than that.. and I am in process of learning about Kubernetes, Helm, and Bonzai Cloud platform.. so hopefully all of this comes together to make a slick complete CI/CD pipeline for local as well as cloud development and deployment. 
While you're right that single-digit MBs isn't worth worrying about, the alpine base image is 4.4 MB.
Uh oh, no responses and increasing downvotes. &amp;#x200B; Is this out of place? I found a like a thread, but it's from 5 years ago. 
Oh, cool. Didn't know about this. Thanks for sharing. I'll update my post when I get a chance. üëç
Some quick answers (while commuting): * Go is used beyond Google, there is a living, active, and growing community. * The standard library is quite rich and well documented. Search there first for any of your projects. * For 3rd-party libraries, check either of: * [https://godoc.org](https://godoc.org) * [https://golanglibs.com](https://golanglibs.com) * [https://go.libhunt.com](https://go.libhunt.com) * [https://awesome-go.com](https://awesome-go.com) godoc.org is perhaps the best place to search as anyone who is serious about their library checks it in there. &amp;#x200B;
Thank you, very informative. Even after reading your answer and the second link from /u/neoasterisk 's comment above, I'm not fully convinced that a "models" package is an anti-pattern. His link provides though a good alternative in using the top level package of you application for structs that would be used in a more generic way. I haven't had the chance to implement it yet in the project I'm currently working on, but when I do, I hope I'll remember to come back with a followup.
Maintainer of the library here. üëã &amp;#x200B; I've been skeptical of the use of \`sync.Pool\` since I've inherited this repo so happy to see someone writing the needed tests and benchmarks! If you have the time, a PR would be greatly appreciated :)
I've was just looking into this today! Only thing that makes me gravitate towards prisma is the database integration. That's our first step: making our types/tables available via a graphql api. The next step is more custom types which gqlgen is more suitable for I think.
Pretty sure you have to install ca-certificates as an extra, and reports for alpine size vary. Docker hub says 2,1mb, one of my machines says 5mb (probablly an older alpine image). Should be pretty even with distroless/base anyway.
https://github.com/browsh-org/browsh/issues/232 Issue with Firefox 63. Download 61 and point browsh to it in the meantime
There is a chat example in the repo.
Godoc.org actually scrapes websites for go packages
I've been meaning to add some docs for using prisma + gqlgen for a while now. They have an example https://github.com/prisma/prisma-examples/tree/master/go-graphql
Yeah, using the top-level package also makes sense, because it follows that same domain rule. If there is no other parent domain for the model other than just your app as a whole, then that is where the model belongs IMO. Some people choose to not put things at the top level though, mainly for folder organisation, so they can find things easier. Upspin have a [good example of this](https://github.com/upspin/upspin/blob/master/upspin/upspin.go). The domain of these types is just... "upspin", and that is totally valid. The import path ends up being `upspin.io/upspin`. If you were using the Github URL it might look a little more weird (it'd be `github.com/upspin/upspin/upspin` in that case...), but it allows them to avoid putting those files at the top of their repository, which would clutter it up a little. If you do have that more specific domain (e.g. in "modular" applications) then you might choose to split up models more in a more granular fashion like I mentioned in my original comment.
My guess is Go is simply less popular than other languages such as PHP (particularly for web). Also lots of CMS packages are huge monolithic applications that attempt to include every feature possible. This really isn't an idiomatic approach for Go applications to my knowledge. There are relatively many e-commerce solutions that make use of Go, however. The difference is they tend to be proprietary components of larger microservice architectures. I recall a UK based bank that uses Go for their entire stack. 
v1 and v2 have different *import paths*, but they don't have to have different *file paths*. You can use VCS commits or branches to differentiate the two.
v1 and v2 have different *import paths*, but they don't have to have different *file paths*. You can use VCS commits or branches to differentiate the two.
It's used extensively outside of Google, and it powers most of the cloud native things (Docker, Kubernetes, etc) as well as most of the Hashicorp tools. It's very much a mainstream language now, in the sense that there are high quality packages available for most common tasks and it's widely adopted. You should give it a try over a weekend. I wrote a [primer](https://weberc2.bitbucket.io/posts/go-getting-started.html) for pointing experienced developers who are new to Go in the right direction for common tasks like testing, documentation, dependency management, etc. Something like a TODO list webapp could give you good exposure to the project management/tooling concerns, while something like a static site generator could give you exposure to the ecosystem (both projects are feasible in a weekend).
perfect, thank you
Ah... to me `controllers.Search` seems more descriptive than `search.Handler` but I'm coming from a background of grouping by functionality not by context - as you put it. In my opinion this makes it easier to hide the internals of the `controllers` group (which are more likely to be irrelevant for other packages) than having them be public so they can be accessed by `search.Handler` and `element.Handler`, samd. But I feel like these things are very much up to every developer and their preferred style, and blanket statements like "such and such is an anti-pattern" are invalid by default.
Indeed that a red flag in code. Question: would the compiler optimize the repeated \`string(x)\`?
Possibly wrong place to ask. We are not psychic and cannot answer the future.
While this might be technically true, I expect it will be confusing for a lot of people if you do that.
I found this video regarding sync.pool quite useful, I found it in my weekly: [http://rev.vu/ml0wq](http://rev.vu/ml0wq)
every single detailed query in the actual post addresses the present. the title is the purpose for inquiring about the present
In my opinion https://github.com/therecipe/qt is the most mature. But pay attention to licensing if you're not doing open-source projects with it.
thanks :) 
Hi DarkElDestructo, I came across this link in my weekly, should be interesting to sort out: [http://rev.vu/rDjKA](http://rev.vu/rDjKA?utm_campaign=Issue&amp;utm_content=share&amp;utm_medium=email&amp;utm_source=Golang+Ninjas+Newsletter)
It's not entirely true that Golang isn't suited for e-commerce. Check for example this article from Snipcart which I came across in my weekly: [http://rev.vu/YwJPE](http://rev.vu/YwJPE?utm_campaign=Issue&amp;utm_content=share&amp;utm_medium=email&amp;utm_source=Master+the+World+of+Golang)
That's what I am trying. Maybe there are plenty of tools in other languages but there are very few for Go. In fact I've only found 1 so far and it will not be enough to convince my company to use Go for testing instead of Java.
By the way @darkeldestructo, I remember I also recently read an interesting about the state of GUI app development with Go: [http://rev.vu/k6Kxb](http://rev.vu/k6Kxb)
&gt; Golang Ninjas Newsletter This does seem to have better content and isn't ad infested like Golang Weekly, but it lacks a proper ^^1 RSS option instead of email, unlike GW. &amp;nbsp; &amp;nbsp; ^^1: ^^There ^^is ^^a ^^feed, ^^but ^^all ^^items ^^contain ^^the ^^author's ^^profile ^^description, ^^not ^^the ^^actual ^^newsletter.
Are you hitting database issues or CPU issues? If you have any profiling traces I would be happy to take a look to track down any performance bottlenecks. [Gitter](https://gitter.im/gqlgen/Lobby) is probably the best way to track this down (dm me for anything sensitive).
Thanks for the link! Unfortunately, that feed isn't much better. For example, the entire content for the latest issue of the newsletter is: &gt; The Economist and Go, detect smokers in movies, harmful mmap &amp; more I understand why they want to collect emails, but I'm just not comfortable with that :/
Plenty of e-commerce solutions written in Go, they are just not open-source and available on github.
I‚Äôd like to find a working cart example in golang other than snipcart (not a fan of their pricing model). 
Your benchmark needs to actually call Write to see the difference, since gzip.Writer lazily creates the underlying flate compressor. https://golang.org/src/compress/gzip/gzip.go#L190
Could also be useful for others using the package where `Run()` becomes your exposed API point and you later change the `run()` implementation. Maybe later you might want a `run(someStructOrArgs)` and `Run()` could create a default struct or arguments to then pass to `run(someStruct)`. Older consumers wouldn't then have to change their code when calling in.
By FAR the best solution is https://github.com/gotk3/gotk3 Download glade which allows you to drag and drop GUI components and throw save file is XML. Load the XML with GO and add functionality. They have examples and for the stuff with poor documentation you can easily find the Python equivalent to base it off. Ive made three small projects with it and I'm thoroughly satisfied 
`file,err := os.Open("M:\\directory\\file.txt")` That should work fine. I have a few SMB shares as network drives and I use standard way to open them. "M:" is arbitrary. 
This didn't work for me, is the M supposed to be the server name or something? 
Never mind I got it working
[removed]
[removed]
M:\ is like C:\
For people on old reddit, OPs post [looks like crap](https://i.imgur.com/zrRZswL.png) because Snoodown doesn't support the three-backticks code blocks, so I fixed it: Benchmark: BenchmarkWriters-4 10000000 125 ns/op 176 B/op 1 allocs/op BenchmarkPoolWriters-4 5000000 301 ns/op 176 B/op 1 allocs/op Test code: package webserver import ( "compress/gzip" "testing" ) type fakeWriter struct{} func (f fakeWriter) Write(p []byte) (n int, err error) { return len(p), nil } func BenchmarkWriters(b *testing.B) { w := fakeWriter{} for n := 0; n &lt; b.N; n++ { gzip.NewWriterLevel(w, gzip.BestCompression) } } func BenchmarkPoolWriters(b *testing.B) { w := fakeWriter{} for n := 0; n &lt; b.N; n++ { z := zippers.Get().(*gzip.Writer) z.Reset(w) } }
Correct, dockerhub shows the compressed size while local always shows the uncompressed size.
Has anyone seen good examples of SQL resolvers? I've bought into the idea about GQL on the front-end, but as a back-end engineer it just sounds nightmareish to have to deal with all the N+1 queries.
I think the only thing in net/http that serves the file system is https://golang.org/pkg/net/http/#ServeFile 
reading this comment was a brain damage simulator
No allocations, no Pool required. The Pool can be useful for bufio.Reader to read HTTP connection. Since, it has internal buffer. But this depends on network speed. And it depends of number and frequency of new connections. And how long they are alive. But. An http connection already has internal *bufio.Reader and *bufio.Writer. And the connection uses the sync.Pool. https://golang.org/src/net/http/server.go#L279 https://golang.org/src/net/http/server.go#L800 Small objects, like a gzip.Writer or flate.Writer structures should not use sync.Pool. I have tried to use the Pool with []byte, capacity of which is 10. With the Pool it's slower. And, sorry, but I don't know what is the boundary. I think 1024 bytes at least. It depends.
Took some googling based on obscure mentions in the paper but these are apparently the same project: http://mrg.doc.ic.ac.uk/tools/godel-checker/ https://bitbucket.org/MobilityReadingGroup/godel-checker https://github.com/nickng/gospal 
Here's a self-contained benchmark that actually exercises both the gzip writer and the pool: package main import ( "compress/gzip" "io/ioutil" "sync" "testing" ) func BenchmarkWriters(b *testing.B) { w := ioutil.Discard d := make([]byte, 1024*1024) for n := 0; n &lt; b.N; n++ { z, _ := gzip.NewWriterLevel(w, gzip.BestCompression) z.Write(d) z.Close() } } func BenchmarkPoolWriters(b *testing.B) { w := ioutil.Discard var zippers sync.Pool d := make([]byte, 1024*1024) for n := 0; n &lt; b.N; n++ { z, _ := zippers.Get().(*gzip.Writer) if z == nil { z, _ = gzip.NewWriterLevel(w, gzip.BestCompression) } else { z.Reset(w) } z.Write(d) z.Close() zippers.Put(z) } } And here's the result: BenchmarkWriters-4 500 4000054 ns/op 815969 B/op 17 allocs/op BenchmarkPoolWriters-4 500 3272799 ns/op 3726 B/op 0 allocs/op
The repo has a \[dataloader example\]([https://github.com/99designs/gqlgen/tree/master/example/dataloader](https://github.com/99designs/gqlgen/tree/master/example/dataloader)), which is specifically designed to work around n+1 problems, whether it's with SQL or any other external service.
I haven't been able to play around with qt to much. I tried it for one thing, but I found another package on git that has a nice example very similar to what I needed. Do you know any sources or sites for documentation?
I may have explained something a bit off, let me know if there are any points you are confused about and I can try and fix them.
auto imports are based on goimports, which is a fork of gofmt, which requires somewhat valid syntax to run (and corrects the rest). I suspect completions might be the same? But tbh IDK.
Slices double every time an append will exceed the capacity of the slice, up to 1k. After 1k the slice will grow by 25% or so each time an append would exceed the capacity. Like was previously mentioned the values from the old slice are copied over to the new slice and the old slice is garbage collected.
The source code for growing that backing array is ‚Äògrowslice‚Äô in the file https://golang.org/src/runtime/slice.go. If I understand it correctly, it doubles up (2x) until the slice is of size 1024, at which point it only increases by 1.25x (1024x1.25=1280). 
[Go-Outliner](https://marketplace.visualstudio.com/items?itemName=766b.go-outliner)
I have read that article, though looking at it again, I think I should reread it now that my understanding of the language is a bit better. I guess my thought is that if a slice can create a backing array at runtime without knowing what the length will be at compile time, it seems kind of arbitrary that you can't use a variable to indicate the length of an array when declaring it yourself. For example, appending to a slice of capacity 100 will make a new slice, with a new backing array of capacity 200. But I can't create an array using a variable as it's length because the value isn't known at compile time. Does that make sense?
Thank you- this is a direct answer to my question!
&gt; What is the easiest way to limit number of concurrent goroutines? If you want to limit concurrency, one of the easiest ways is to use a buffered channel as a semaphore, like this: func main() { wg := new(sync.WaitGroup) work := getWork() wg.Add(len(work)) sem := make(chan struct{}, N) for _, w := range work { go doWork(sem, w, wg) } wg.Wait() } func doWork(sem chan struct{}, w *Work, wg sync.WaitGroup) { defer wg.Done() // Sending to the channel increments the semaphore. // It blocks, if N goroutines are already active (buffer full). sem &lt;- struct{}{} defer func() { // Reading from the channel decrements the semaphore // (frees up buffer slot). &lt;-sem }() w.Do() } 
i would rather give my down syndrome child a push and watch him fall trying to ride a bike with training wheels than teach him how to balance
https://research.swtch.com/godata2 https://dave.cheney.net/2018/07/12/slices-from-the-ground-up https://blog.golang.org/slices https://blog.golang.org/go-slices-usage-and-internals https://research.swtch.com/godata https://www.ardanlabs.com/blog/2013/08/understanding-slices-in-go-programming.html https://nanxiao.gitbooks.io/golang-101-hacks/content/posts/the-internals-of-slice.html http://www.golangprograms.com/go-language/slices-in-golang-programming.html https://play.golang.org/p/DhT__tgtd6 
I have tried that, but it seems that it will add \`+incompatible\` at the end of the version within the \`go.mod\` file, and it will not update to newer versions automatically. Neither will it pick the latest version available, but will it pick the **first** \`v2.X.X\` that has Go modules support...
I do not expect to support v1, to all practical purposes it does not exist. The import path to v2 (without \`/v2/\`) IS a unique path.
You may want \`sem &lt;- struct{}{}\` before you \`go\`, or you're not limiting goroutines but rather you're limiting concurrent calls to \`[w.Do](https://w.Do)()\`. That may be what you wanted, or might not.
[removed]
cool. It even supports coexistence of the following patterns, which HttpRouter doesn't support. /a/b/:c /a/:b/c /a/:b/:c /:a/b/c /:a/:b/:c
&gt; it is my first GO open source project Impressive!
LRU = Least Recently Used for those who were wondering like me
Thanks, I really appreciate it. I think I'll have to wait till February for synchronous functions though... unless I can get `syscall/js` working from ( https://github.com/neelance/go/tree/wasm-sync-callbacks ). Some of the stuff I want to do kinda has to run synchronously and I don't really want to deal with callback hell and promises. lol
&gt; That may be what you wanted, or might not. It is. There is no point in limiting the number of goroutines.
I don't think using r/w locks is generally a good idea. They have high overhead for short to moderate critical sections. They are useful if I/O is involved, which dwarfs the lock penalty. Otherwise the overhead of maintaining the read/write counts is often more expensive than the work. I've documented the evolution of my work on making LRU-style caching concurrent ([CLHM](https://github.com/ben-manes/concurrentlinkedhashmap/wiki/Design), [Guava](https://github.com/ben-manes/concurrentlinkedhashmap/blob/wiki/ConcurrentCachingAtGoogle.pdf), [Caffeine](http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html)). There's some similarities on the record/replay idea, though I think you'll do much better using custom ring buffers instead of channels. It's a bit odd to not have any benchmarks to design and tune with. Instead of having the value implement a type, like `Size()`, consider instead having a custom type to evaluate the value by. In the case of size, I use the term `Weigher`. Instead of letting expired entries pollute the cache (or relying on a heap), consider instead using a [Hierarchical TimerWheel](https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels). This allows amortized `O(1)` operations. LRU is a decent but suboptimal policy. The two leaders are TinyLFU and LIRS based policies. I can share privately new work on making TinyLFU adaptive which improves it on recency-biased traces. The various policies have many interesting insights and are worth exploring.
Perhaps this helps: https://gobyexample.com/worker-pools
I am interesting in this to, I have created some basic webapps (nothing that special), but I would like to test out new things and I am sure there are things I'm not even thinking about since i'm still learning go.
not very clear what you really need, * gowebexamples.com to see how you can use Golang for web development * gorm.io for ORM * gopkg.in/go-playground/validator.v9 for validation * [www.youtube.com/watch?v=oL6JBUk6tj0](http://www.youtube.com/watch?v=oL6JBUk6tj0) for directory structure &amp;#x200B;
I always use the shorthand declaration in such cases ‚Äî the shadowing means I don‚Äôt need to keep track of whether it has been previously declared were I to refactor the function later: ``` if err := json.Unmarshal(jsonFile, &amp;board); err != nil { ```
Good work! However, your benchmark result is much different with mine: https://play.golang.org/p/VFG4O7rXYzz $ go test -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/go101/tinyrouter Benchmark_HttpRouter_0bytes-2 100000 16363 ns/op 4592 B/op 65 allocs/op Benchmark_TinyRouter_0bytes-2 50000 32436 ns/op 11232 B/op 117 allocs/op Benchmark_GorillaMux_0bytes-2 10000 159985 ns/op 20368 B/op 182 allocs/op Benchmark_GoRouter_0bytes-2 200 6142533 ns/op 4305315 B/op 6245 allocs/op Benchmark_TrieMux_0bytes-2 50000 26099 ns/op 8528 B/op 91 allocs/op Benchmark_ChiRouter_0bytes-2 50000 33886 ns/op 9152 B/op 91 allocs/op Benchmark_HttpRouter_16bytes-2 100000 16050 ns/op 4800 B/op 78 allocs/op Benchmark_TinyRouter_16bytes-2 50000 33680 ns/op 11440 B/op 130 allocs/op Benchmark_GorillaMux_16bytes-2 10000 154375 ns/op 20576 B/op 195 allocs/op Benchmark_GoRouter_16bytes-2 200 6201644 ns/op 4309836 B/op 6262 allocs/op Benchmark_TrieMux_16bytes-2 50000 26661 ns/op 8736 B/op 104 allocs/op Benchmark_ChiRouter_16bytes-2 50000 35708 ns/op 9362 B/op 104 allocs/op Benchmark_HttpRouter_256bytes-2 30000 44019 ns/op 13952 B/op 299 allocs/op Benchmark_TinyRouter_256bytes-2 30000 59081 ns/op 20592 B/op 351 allocs/op Benchmark_GorillaMux_256bytes-2 10000 155757 ns/op 20576 B/op 195 allocs/op Benchmark_GoRouter_256bytes-2 200 6154858 ns/op 4310654 B/op 6440 allocs/op Benchmark_TrieMux_256bytes-2 30000 55897 ns/op 17888 B/op 325 allocs/op Benchmark_ChiRouter_256bytes-2 20000 71897 ns/op 18514 B/op 325 allocs/op Benchmark_HttpRouter_1024bytes-2 10000 128137 ns/op 48896 B/op 949 allocs/op Benchmark_TinyRouter_1024bytes-2 10000 148087 ns/op 55536 B/op 1001 allocs/op Benchmark_GorillaMux_1024bytes-2 5000 285729 ns/op 64672 B/op 1066 allocs/op Benchmark_GoRouter_1024bytes-2 200 6246293 ns/op 4333939 B/op 6981 allocs/op Benchmark_TrieMux_1024bytes-2 10000 145246 ns/op 52832 B/op 975 allocs/op Benchmark_ChiRouter_1024bytes-2 10000 167792 ns/op 53461 B/op 975 allocs/op Benchmark_HttpRouter_8192bytes-2 2000 959762 ns/op 380032 B/op 6812 allocs/op Benchmark_TinyRouter_8192bytes-2 2000 903253 ns/op 386672 B/op 6864 allocs/op Benchmark_GorillaMux_8192bytes-2 2000 1036610 ns/op 395808 B/op 6929 allocs/op Benchmark_GoRouter_8192bytes-2 200 6911638 ns/op 4611506 B/op 11939 allocs/op Benchmark_TrieMux_8192bytes-2 2000 876312 ns/op 383968 B/op 6838 allocs/op Benchmark_ChiRouter_8192bytes-2 2000 925558 ns/op 384630 B/op 6838 allocs/op Benchmark_HttpRouter_65536bytes-2 200 6483429 ns/op 2989184 B/op 53443 allocs/op Benchmark_TinyRouter_65536bytes-2 200 6520520 ns/op 2995824 B/op 53495 allocs/op Benchmark_GorillaMux_65536bytes-2 200 7031300 ns/op 3004960 B/op 53560 allocs/op Benchmark_GoRouter_65536bytes-2 100 12150916 ns/op 6842147 B/op 51430 allocs/op Benchmark_TrieMux_65536bytes-2 200 6508991 ns/op 2993120 B/op 53469 allocs/op Benchmark_ChiRouter_65536bytes-2 200 6614583 ns/op 2994049 B/op 53471 allocs/op Benchmark_TinyRouter_FlexiblePatterns_0bytes-2 50000 33874 ns/op 12336 B/op 140 allocs/op Benchmark_GorillaMux_FlexiblePatterns_0bytes-2 10000 208178 ns/op 24800 B/op 223 allocs/op Benchmark_GoRouter_FlexiblePatterns_0bytes-2 500 2199744 ns/op 1471675 B/op 2048 allocs/op Benchmark_TrieMux_FlexiblePatterns_0bytes-2 50000 32371 ns/op 10160 B/op 110 allocs/op Benchmark_ChiRouter_FlexiblePatterns_0bytes-2 30000 39083 ns/op 11265 B/op 112 allocs/op It looks, gorouter is both slow and memory consuming. Feature comparisons: Mux/Router | Flexible | Support Regexp | Feature Rich :--------:|:--------:|:---------:|:---------: HttpRouter | No | No | No TinyRouter | Yes | No | NO GorillaMux | Yes | Yes | Yes GoRouter | Yes | Yes | No TrieMux | Yes | Yes | No ChiRouter | Yes | Yes | Yes HttpRouter is the fastest for very small response sizes, but its patterns are very not flexible. The performances and flexibility of TrieMux and ChiRouter are both surprisingly great. TrieMux is faster than ChiRouter, but ChiRouter is feature richer than TrieMux. 
Might be [https://github.com/google/go-cloud](https://github.com/google/go-cloud)
Models are data structures which map the business domain of your service. They generally correspond to entities inside of a state store somewhere (database, cache, etc), but don't necessarily have to. Even if they do, they should be functionally independent of any specific state storage; instead of having a UserDatabase model, have a User model and a Database "handler" which knows how to interact with a User model. 
Yes I've the same issue, is a little annoying
With a variadic, the parameter is accessible inside the function as a slice. So you'd need to nest that if inside a loop. You can use 'range' for looping over that. for i, num := range nums { ‚Ä¶ }
So I can never use if / switch with variadic? 
Sure, just handle it like you would any other slice or array. If you are using a variadic, you are expecting the number of parameters passed to the function to be variable. So you could call the function like "variadicFunc(1)" or "variadicFunc(1, 2, 3, 4, 5)". In the function, you need to set it up to be able to handle a variable number of values in that parameter.
Have you done the introductory tour of Go[1]? That should teach you about the standard types and related concepts. [1] https://tour.golang.org
https://github.com/upspin/upspin
You are probably right, and indeed I hit a couple of circular dependencies working like I do now. I have every intention that once I have more time to dedicate to code cleanliness I will be able to reiterate and make it more beautiful, for now I'm focusing on solving the problmes. :D
You could, you just have to iterate through the variadic *then* apply your if/switch logic. Case in point: ``` package main import ( "strconv" "strings" "fmt" ) func variadic(nums ...int) string { var text []string for _, n := range nums { switch n { case 1: fallthrough case 20: strNum := strconv.Itoa(n) text = append(text, fmt.Sprintf("Number is: %v", strNum)) } } return strings.Join(text, "\n") } func main() { fmt.Println(variadic(1, 2, 3, 20)) } ``` Will output: ``` Number is: 1 Number is: 20 ```
Sample code is in the description I think. https://youtu.be/oL6JBUk6tj0
I always like to give a shout-out to https://github.com/andlabs/ui in these threads. It's still extremely alpha right now, but the underlying https://github.com/andlabs/libui is being built from the ground up specifically for go. It's been making slow, but steady progress towards becoming a really nice toolkit. That said, it's still far behind GTK and QT bindings in both features and stability.
ES is fantastic but it's memory usage is obscene
Thanks, I did not know that. The About doc says, "To add a package to GoDoc, search for the package by import path.", so I assumed adding only happens manually.
For windows only you can use [https://github.com/lxn/walk](https://github.com/lxn/walk) But rather use Qt [https://github.com/therecipe/qt](https://github.com/therecipe/qt)
Yeah the circular dependency issues in graphql-go made working with complex data structures difficult. I found we could get around the circular dependency build error by initialising the circular reference in init(). But my data structures can refer to each other in more of a web than a circular... I ended up with these terrible init sequences like: func init() { initArticle() initImage() initBlog() ... } And if I moved the order around it would break... not great. I need to give gqlgen a go. 
thanks @watr, you are kind
I think your observation with the single worker not being able to keep up. That's something I saw in my own code with synthetic workloads, assuming that there were no pauses causing allowing the worker to catch up. My solution was to make the buffers bounded and, in the case of reads, lossy. If unbounded like this library, you could induce that with buggy code that was stuck in an infinite loop. However, since draining should be very cheap it shouldn't be a problem in practice. Guava's cache has unbounded linked queue buffers and while it's been a bottleneck, it hasn't been reported by users as causing memory leaks. Perhaps I misunderstood, but won't the bucket selection still contention with uneven access distributions? Say 32 buckets, keys 1..10, and key 3 is always selected. In your case, wouldn't bucket 3 be highly contented on and an increase to 64 buckets would make no difference? The bucket has to be locked for every read to reorder the LRU chain. I think you're correct that keys are distributed evenly to the buckets, but my point is that it doesn't help much in solving lock contention due to caches having uneven access distributions to those keys. Sorry if I come across a little preachy. It's been a hobby for a long time and I enjoy the discussions, but also perhaps over think these things.
Are you sure you've got a suitable go.mod file in the repo for the latest v2 version? It sounds like you're hitting [this case](https://go.googlesource.com/go/+/master/src/cmd/go/alldocs.go#2378) which suggests there's no go.mod in the module you're importing.
There are several different types of models and people have a nasty habit of just calling them all "models" and expecting you to use context clues to know which one they mean. It sounds like you're talking about domain models. https://en.m.wikipedia.org/wiki/Domain_model Knowing the right term will help you find best practices for using them. Go doesn't have any special rules for domain models. Language agnotic practices will serve you well. See also https://en.m.wikipedia.org/wiki/Model-driven_engineering https://en.m.wikipedia.org/wiki/Model-driven_architecture and https://en.m.wikipedia.org/wiki/Domain-driven_design
You can't make dynamic length arrays because arrays aren't slices. They are a lower level construct. You absolutely can make slices with dynamic lengths and capacities. https://play.golang.org/p/Nl8srba9s0v
how does it work ex on windows as a binary ? you still only need to do "go build'" an the exe will contain all - or do you need to install gtk etc on the recieving end + the exe ?
Another vote for https://github.com/therecipe/qt I've tried several native GUI libraries using Go, including gotk3, and matt-n's GTK2 bindings too. The GTK bindings are both okay themselves, the problem I have with them really is a problem with GTK itself. The documentation is terrible, with broken links, old tutorials, and deprecations all over the place. I made a couple of simple things with gotk3 in the end, and in my time with it still had to get my hands dirty and write some more bindings (the first time I did contribute them back to gotk3, the second time I was having to add so many that I looked for other solutions and found therecipe's Qt bindings). The most recent thing I tried to develop was a Linux "panel" or "bar" application, something that just has things like your current workspace, running apps, the time, a system tray, battery and network status, etc. I started it with GTK using gotk3, but it was just super verbose code, lots of error handling that seemed unnecessary, and I struggled to do what I wanted with it as a panel. The main problem I encountered was getting info about the current screen. I wanted this panel thing to run on each display, with the primary display having a more feature-rich bar (but also keeping it all configurable). With Qt I could just loop over the screens, and move the window on that screen, relative to the screen itself, not the whole X display (which is what I would've had to do with GTK, it seemed). Other than that, the Qt bindings also do actually work like Qt documentation tells you, and the docs are really great. Super clear, the API just makes sense, and I've not found a single missing function so far whilst using it. The only drawbacks I've found with the Qt bindings is that it does take longer to compile via `qtdeploy`, and if you're using an IDE like Goland (and you might encounter this elsewhere too) then because the bindings are in _very_ large files, it can sometimes really slow down your editor when you try to go to the definition of something in the Qt SDK. I've generally not had too big of a problem with this though.
Actually, the standard library is one of the best projects you can browse ;) 
This is a standard layout and refers to some of the most important projects https://github.com/golang-standards/project-layout. Here you can find other interesting projects https://github.com/avelino/awesome-go/blob/master/README.md
What would be a good use case for this? Local in-memory cache?
Things I noticed while looking at the code :) With regards to https://github.com/urban-wombat/flattables/blob/master/flattables.go#L376. Go has a builtin formatter already (https://golang.org/pkg/go/format/#Source). Instead of https://github.com/urban-wombat/flattables/blob/master/flattables.go#L388 you can use https://golang.org/pkg/go/token/#Lookup. In https://github.com/urban-wombat/flattables/blob/master/flattables.go#L359 you can specify all the funcs at once. This https://github.com/urban-wombat/flattables/blob/master/flattables.go#L202 breaks with unicode. PS: also format your source, it makes easier for random people to read and modify the code. :)
&gt; format your source, it makes easier for random people to read and modify the code. This. The quickest way to get your code utterly dismissed is not to gofmt it. 
project looks great. if you can get a consistent performance boost ill switch from gota. if i could make one request though. what all these packages need for golang is persistent object storage. with spark i can spill outside of memory, save to parquet, orc etc,without having to write to csv or db. if you can add performant serialized objects (preferably orc) im sold.
And here's a [link to the article](https://hackernoon.com/transitioning-logging-and-monitoring-systems-at-the-economist-3c6116ba30a8) that doesn't require an email address
We have both. But the database issue was reduced with dataloaders. But the main problem is the query parser, it spend a lot of processing on profiling. I will post it on Gitter later, but I will try to reproduce it on a small example before. Thank you!
Are there logs I can check to see what the problem is?
I believe go has it's own executable
That's because Python scripts are not programs and cannot be executed directly. Even in Unix, where you can "execute" a script, interpreter defined in shebang is called implicitly. You have to run Python interpreter and give him the script to execute. 
It shows _exactly_ which file does not exist: `python C:\...` The argument to `cmdExec` should look like `cmd.Exec("python", filepath.Join(cwd, getPageData.py), "-c", site.URL)`. (Note that constructing paths using `+` is incorrect) PS: Please never post screenshots when the problem is defined by source code and there's a text output in the terminal.
FlatBuffers seems to be a lighter form of Google's ProtoBuf, and seems to be used mainly for game data serialization and in Facebook's case for client-to-server communication. [src](https://google.github.io/flatbuffers/)
A slice can't be equal to a single number, but you could certainly have your condition in a `switch` or `if` act upon the length of your slice or an individual value inside, but you don't know if it'll be empty or how many there will be, which is why a loop might be handy.
I do recommend this highly! It gives you a simple way to learn all the very basic language terms so that you can understand the syntax while reading examples later.
Are you saying that if you `fmt.Println(blog.Body)` right where you put the "now lost" comment, the data is incorrect?
yes, I just double cheked and this is the moment I see my specials characters are lost From what I understood I must use a scan to view to content of my *sql.Rows (the result of the query) so I dont see how to debug further with the result of my query 
[removed]
That was my thought too, if the data was mangled during the Scan. Also, [you'll want to set timezone=UTC in your PostgreSQL connection](http://lpar.ath0.com/2017/11/go-postgresql-time-zones/) if you want timestamps to be correct.
Don't take my word for it, listen to Rob Pike. [https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=6m25s](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=6m25s) &amp;#x200B; But hey, if you want to deal with nil pointer dereference crashes in your software, be my guest.
I might didn'y pay enought attention on this doc line because I tought it was just for to connect to the database I will check this thanks
Goroutines are like threads, but more lightweight and managed by runtime. Use them for parallel operations and when you need a subroutine that has to live "in the background". Channels are used to communicate with goroutines, synchronisation and queueing. 
That was my understanding, but I still struggle a little with with I should use it. Let's try an example. What if I'm building a website that, for the sake of simplicity, just accepted a request and returns a response. Would it be best practices to use goroutines to handle the request? Can I leave the net/http package to handle concurrent requests for me? Should I look towards implementing asynchronous request handling via just the net package (eg. [this talk](https://youtu.be/afSiVelXDTQ))? These are questions I just don't have answers to because I'm not used to thinking in terms of threads and concurrency. That's, for the most part, what I need help with.
For request / response. net/http already creates a goroutine for you. Kind of, the rough answer to using features is "when you need it". If you don't see the need for it, don't use it. However, the problem might be that you don't know that in a specific situation the goroutine would help. So, there are few things here. Try using them in different scenarios and learn how to use them. Ask for reviews on reddit/slack. Few common cases: 1. You have multiple requests that are slow on their own, in that case you may be able to use parallel requests to speed it up. 2. You want some process to be running in background (e.g. polling some other server for information) 3. You want to respond to the request immediately instead of waiting for something to finish. (e.g. uploading a video and running a conversion on the video). But all of them it's starts with needing to not block a goroutine. And, channels now provide a good way to connect these things together nicely.
The http package already uses a separate goroutine for each request, so you're good there. :)
I have no idea how this templating engine work, but here is a bit of documentation for the system used in twig https://twig.symfony.com/doc/2.x/tags/embed.html
That's good to know! I think that in particular was causing my a headache.
Both seem crappy to me. :)
You might want to try Output() or CombinedOutput() instead of Exec, seeing the output and stderr might help you track down what the actual problem is
So what is your suggestion?
I tend to go with the approaches mentioned here: [https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1)
I found the problem. It was caused by using ClearDB. It can't support migrations in the free version as I understand. That's why you need to pay for the better version or do migrations using remote connect to your database. My solution was to switch to PostgreSQL which works perfectly on Heroku.
You mix WIN/*nix path separators: use path.Join(cwd, ‚Äúyourscript.py‚Äù) for OS independent path manipulation.
Sorry it's not clear, perhaps the [example project](https://github.com/Xeoncross/got/tree/master/example) will better demonstrate. "Templates" can mean the whole file or the actual template block definition which makes explaining this hard. Basically, you define a common template name [in each of your "pages"](https://github.com/Xeoncross/got/blob/master/example/templates/pages/about.html#L1-L3). (This is often called `main` or `content`). Then in the layout you simply [use that template](https://github.com/Xeoncross/got/blob/master/example/templates/layouts/main.html#L37).
This is extremely interesting, I'm only part way through reading it. Noticed you had a typo. Search for "And example for that would be determining the endianess of a machine."
MVC was a good start to bring some sort of "order" to web sites. However, with Go you can use "domain" designs like "clean architecture" to better ready your simple website for the day when it's also a load proxy, mobile endpoint, and distributed micro service layer. Design for the objects that represent what you are building - not for the HTTP gateway like Ruby/PHP taught us.
&gt; (in about 1k LOC) we present a Go implementation of the ixy network driver... ...with 24.9803 million packets per second it is ~10% slower then the C implementation while offering various advantages in other areas as a high-level language
Highly recommend endpoints return *http.Response, err. If err != nil that‚Äôs a 500 response, so log it and return a generic 500. Everything else is an HTTP.Response!
This, very much this!
Definitely taking this approach! Thank you for your response!
MVC is a poor fit for HTTP, in my opinion. There are only http requests that get routed to code (handlers, endpoints) that respond directly or return an error. There are opinions on how skinny or fat the handlers should be. I prefer fat-but-don‚Äôt-repeat-yourself, particularly with respect to entity bodies ‚Äî but I‚Äôm not even certain that‚Äôs all that important. :-)
Impressive! I love playing around with Brainfuck and here's an interpreter I wrote a while ago that I've been optimising recently: https://github.com/nomad-software/bfg. With mine, I get about 15 seconds (interpreted) to render the mandelbrot program on my PC and with your compiler it takes about 1 second lol. I might have a go at a compiler next, rofl!
That was worth my time reading for sure
Very nice! Make sure to add it to https://github.com/golang/go/wiki/ResearchPapers
That's a good point. I knew it was best practice to rely on a queue for emails but in the past I presumed it was due to the asynchronous processing benefits. Not violating HTTP semantics seems equally important.
[removed]
[removed]
I heard a rumour that Fuschia's networking stack is written in Go. Might be interesting to take a look at that, too.
I see how that makes sense from an abstract standpoint but it doesn't provide much clarity when the rubber hits the road on a reasonably common use case like a web application with an API. For example, if you have an API that provides content negotiation and different representations. That is likely some middleware, but does that mean you should have a middleware package? What about handling errors? That might end up as a somewhat pervasive concept as errors likely need to transition from specific package errors all the way up to errors the user might see. If we use a framework or libraries to help with other functionality (cookies, sessions, file uploads, templates, etc.) how do effectively organize the code as some of these elements need hooks in the domain logic in addition to the HTTP layer? &amp;#x200B; Apologies if this comes across as dense, but I've seen folks offer standard Go idioms without any context, leaving users to discover the pitfalls themselves. A great example is "*Do not communicate by sharing memory; instead, share memory by communicating.*". The impact is that often people go down rabbit holes trying overuse channels thinking a lock is not idiomatic and should be avoided at all cost when in reality, the rule is there to push people to design the interactions between structures rather than simply sharing the same structure. This is not intended to critique the excellent suggestions, but more to raise some awareness that a "best practice" still needs to be implemented and can often be less clear when you're actually organizing your code. &amp;#x200B; I'm hopeful others will provide some more context into why they have chosen a particular package layout. In the meantime, I think the OP would do well to try things out and see what happens!
Yes, reporting is hard, and either boils down to complex joins (RDBMS) or custom map-reduce runs over the data (NoSQL). Personally, I really want to see embedded stores like bolt/level/badger improve on this in the way Mongo added basic support for relations and TiDB or Coachroach support full SQL.
[removed]
[removed]
Really, really cool. Just a few notes though, you should run this through a spelling / grammar checker. There are quite a few mistakes. For example: &gt; Network Interface Controller (NIC) drivers used to be pieces of software that ~~**was**~~ _were_ locked away deep within the kernel and ~~**was**~~ _were_ rarely touched.
(different person) I would agree that there's no benefit to limiting goroutines, but there may be a benefit in the form of backpressure. If it's restructured as sem &lt;- struct{}{} go func() { defer func() { &lt;- se }() doWork(w, wg) }() (or whatever equivalent) then the `range work` will stop consuming form the channel if no workers are available. This also means that if the channel fills up, producers will also block when writing into it, which could naturally ask them to slow down (depending on what you're writing this may be beneficial or it may be harmful).
Very interesting thesis, and as a LaTeX enthusiast, I had to say your that your document is gorgeous ;)
You should read http://calmerthanyouare.org/2015/01/07/optimizing-brainfuck.html
Yes, each bucket holds an lru cache structure and it is locked on access to the bucket. So yes there might be contention, but it is distributed across the buckets, as opossed to a single lru structure that would be always locked and concurrent access is impossible. It was a simple solution, that on my tests worked fairly well for the usecases I had (basically a replacement/complement to using an in memory KV store like memcached or redis). 
Oh yes, I'm sure it was a nice solution and your code is very nice and clean. The peak throughput of alternative approaches doesn't matter if a simpler solution satisfies your performance requirements. A lot of solutions like memcached and redis don't have great concurrency because the network is the bottleneck, so they get to focus optimizing other areas.
I personally don't like ELK - The need to define data schemas is terrible for using it for logging productively for developers, and the behavior when there are type mismatches in the schema is terrible. I saw a project switch away from it entirely for those reasons, the lack of richer features and lack of support for 64bit integers, among other things. If money is not an issue, Splunk dominates as the most powerful solution that I've seen, but that power (and their advice) can push you towards misusing it instead of getting good solutions for metrics or tracing etc separately. 
[removed]
+1
This article is well and good and is something that I want to do, however I'm still trying to figure out how to "put this in production". I am developing in windows and I need to deploy to a raspberry pi. How does this work? Second step after deploying is I need to be able to make an "image" of this so that my boss can burn said image to an sd card on his raspberry pi and go with it. &amp;#x200B; What i'm doing right now (which is probably cringe worthy) is cross compile the go app and bundle it into a zip file. I copy that zip file over to my image generation script which unzips downloads a plain rasbian lite image and configures the pi as needed with chroot. Once that is done I can compress this img file and give it to my boss. How would this change?
I've heard the plan is to target Fuchsia with Dart for the general programmer. I'm going to be very disappointed if it's not Go that they choose to be the primary language.
Use go command line flags to pass in the path to your text file on the command line. https://gobyexample.com/command-line-flags Then use the os package to open the file given the provided path. Then you can read from your file. https://gobyexample.com/reading-files Should be pretty basic.
You can read from [`os.Stdin`](https://golang.org/pkg/os/#pkg-variables) and stream the file in with something like `mybinary &lt; somefile.txt`. Or grab a filename from `os.Args` and open it the usual way as per the other comment.
Thanks a bunch!
Awesome, thanks my man.
Haven't used it but this might be useful to you? [https://github.com/solo-io/packer-builder-arm-image](https://github.com/solo-io/packer-builder-arm-image)
I read through your thesis and it's very informative and nicely presented. I wonder how C would compare to ASM in the same space?
Exactly what I was going to comment. It's how I remember it being done in K&amp;R too. 
It is still early, but you could look at [https://bitbucket.org/rj/goey](https://bitbucket.org/rj/goey). There is no CGO on windows, which is a big win. There is a port for GTK on Linux, and development for Cocoa on MacOS is coming along. Even if you don't think the package is ready/sufficient, it also uses a declarative API for creating GUIs, which might be of interest even if you choose a different package.
I have written a minimalistic log aggregator here - https://github.com/agnivade/funnel. I use it in production. Feel free to try it out.
I think that might depend on the database driver and the database's API. I think most of them will give you a different error if you can't connect vs if your schema is wrong.
https://www.vividcortex.com/resources/the-ultimate-guide-to-building-database-driven-apps-with-go http://www.alexedwards.net/blog/organising-database-access Tutorials - http://go-database-sql.org/index.html https://github.com/golang/go/wiki/SQLInterface Structs to tables - https://github.com/samonzeweb/godb/blob/master/README.md 
For sure, they will. It is just a bit harder to untangle the error message. In case of an incident you want your health check to be as clear and descriptive as possible.
I wish people stopped doing this. You at least want busybox, having a package manager is even better. No one cares about your 1MB savings, what I care about is debugging the service, check for FDs, sockets, tcpdump to see requests coming in. Great blog post, terrible operational habit.
&gt; Kernel calls require a computational overhead due to context switches, therefore slowing down the software considerably, and has generally proven to be simply too slow for specialized applications This is an interesting point and one I had not realised. But I'm curious now (and it's probably outside the scope of the thesis) what impact having a network driver in user space might have on real-time requirements for the driver? For instance, say someone launches Slack or Chrome or Photoshop and the Memory IO becomes saturated. Now your network driver is hung and cannot do anything, it's blocked on an IO request.
What exactly is the use case for having BusyBox let alone a package manager in a production container? Are you sure you're not wishing your container was a VM a little too hard?
Really, how many changes per minute you expect ? Regardless, since you are on golang, take full advantage advantage of websockets for communication and mutexes + channels to be sure only one client changes the data in the json file at a time. Also, channels + websockets can be used to send changes one client makes to all other clients so you can update their interface. I would also rethink the strategy, ditch the json file and go for a RDBMS storage for the data. I would see only benefits out of that. You can convert to and from JSON at any point as / if needed. &amp;#x200B; Start by implementing the basic communication and update propagation of changes to all connected clients (websockets). After that you can implement the channels, mutexes etc needed to save the changes in a file (or really !!! a relational ACID database). &amp;#x200B;
We had a problem here in my company with the with the \`Ping()\` method that didn't return any connection error when the application has network problems, basically the problem was on MySQL driver. We updated the library that had the driver and the \`Ping()\` started to work. The problem is the Postgres driver have the same issue, so we can't use the \`Ping()\` method. So we just have a common \`SELECT\` to check if this service has any network problems.
depending on your use-case there can be some downsides to SSE, namely \_very\_ long lived connections the browser can start to struggle with memory, websockets are more complicated (but libraries wrap that anyway) and has better browser support)
&gt; Great blog post Thank you so much! :) &gt; what I care about is debugging the service Well, it depends a bit on your working flow. In my team, we prefer not to log into the servers for debugging; that's why it's not a blocker _for our usecase_.
How else are you going to bung things up by adding undocumented "patches" at 16:50 on a Friday?
Have you looked at [Couchbase](https://docs.couchbase.com/couchbase-lite/2.1/swift.html#getting-started)? It provides an interface to do exactly this.
I don't get your point. Connections will be as long lived in both ways - that will be as long as the tab is open? At least with SSE the connection will be multiplexed in a single one even if multiple tabs are open, and the browser handles reconnection automatically. Besides, its easier behind proxies.
And the browser can't GC the never ending stream of new docs in the request that never ends. With Websockets as a packet based protocol the browser can discard all but the newest payload. Both have pros and cons.
Ah. Very easy to deal, just reconnect every few minutes and the old EventSource will be GCd.
I would also recommend using multi stage builds to copy the binary from your build container to your run container, that way you don't need git in your prod container.
Will the new runtime environment be supported by MemoryStore?
This is an interesting extraction and repurposing of the idea that's been talked about around the go2 generics draft (https://go.googlesource.com/proposal/+/master/design/go2draft.md): writing functions that work on "any struct with field X", without the overhead of interfaces and getters. I'm not 100% clear if this formulation of the idea would remove the performance overhead, but it at least removes the cognitive and source code overheads of getters and setters. I am worried about the complexity of the feature..
I'm partial to https://github.com/urfave/cli To me, it seems less complex than Cobra and allows me more flexibility in how I handle the internals of my CLI commands. At least, that's the impression I had when I started building a CLI command a year ago and I don't regret the decision.
[removed]
What ? If you use the good link, it would be better : https://docs.python.org/3/index.html Or this one if you want to see the python standard library : https://docs.python.org/3/library/index.html
Any idea? &amp;#x200B; \`\`\` Step 8/15 : RUN go build -installsuffix 'static' -ldflags '-w -s' -o /app /src \---&gt; Running in 4152a6b304cd system/router.go:5:2: cannot find package "." in: /src/vendor/github.com/NYTimes/gziphandler system/router.go:6:2: cannot find package "." in: /src/vendor/github.com/julienschmidt/httprouter system/router.go:7:2: cannot find package "." in: /src/vendor/github.com/lpar/gzipped language/en.go:4:2: cannot find package "." in: /src/vendor/github.com/oblq/i18n language/lang.go:5:2: cannot find package "." in: /src/vendor/golang.org/x/text/language \`\`\`
Which way around do you want this? * Request -&gt; GraphQL -&gt; RPC -&gt; GraphQL -&gt; Response * Request -&gt; RPC -&gt; GraphQL -&gt; RPC -&gt; Response For option 1, you would just make your resolvers (or equivalen) call the RPC methods. For option 2, you can normally execute queries programmatically. So, just make an RPC method to that processes a GraphQL query, then send the response back as JSON encoded bytes or something?
The standard library is an excellent learning resource, but it also differs a lot in style from how you'd probably structure an application. A mix of this an the other suggestion of upspin is excellent.
How *do* you debug? I've ran into all sorts of issues over the years with disappearing network interfaces inside the container, blackholed interfaces. Routing issues, where I can traceroute from the host, but not from the container, etc. If there is an alternative method, I would gladly use that instead.
No one spoke about changes, I expanded on my use cases above ^^
Previously my team and I mostly used Ruby for everything. This [gem](https://github.com/sethdeckard/m3u8) was really useful and it suits our need perfectly fine. Now we would like to move to Golang. As far as I've searched, [this](https://github.com/grafov/m3u8) is the best m3u8 package for Golang. I've tried to implement some simple features with that package and it does not have the flexibility that we want. Hence I've ported the Ruby gem to a go package. Please let me know your thoughts. Comments/ contributions are much appricated.
If you're running it from a Python wrapper (which it looks like you are) then it probably depends whether that wrapper is capable of processing stdout from the Go process that it launches, and throw them to its own stdout which is what you will see in Terminal.
[removed]
Yes that worked. Totally shocked. I'm new to Go, white space matters?
It does matter and you are correct.
I could have sworn I was not having this issue a few months ago. How do I check that the wrapper is capable of processing STDOUT? How do I fix it? 
Ok, so the solution is to learn whitespace nuances. Should I hide this post? 
Hmm... Likely HATEOAS is not terribly popular amongst gophers. https://jeffknupp.com/blog/2014/06/03/why-i-hate-hateoas/ But if you are trying to implement it without library usage, surely then that is as simple as including URLs in your responses to the API? I don't see where that needs any particular extra effort - it is basically the same concept as when you include a 'Next' and 'Prev' link in a webpage. Use your current information to construct a link; include it in the returned JSON. Done. If what you are really asking is, "How can I have this done for me instead of me having to manually include all this extra stuff," then that is precisely what frameworks and libraries are for - to do for you the things you would otherwise have to manually do. Here are some libraries for doing HATEOAS in Go (ignore the Hades one, it is not actually a library for doing HATEOAS, just a proxy for it): https://golanglibs.com/search?q=hateoas&amp;sort=top Personally, I would take a deep look at why you want HATEOAS, and consider the arguments made here: https://jeffknupp.com/blog/2014/06/03/why-i-hate-hateoas/ and here: https://medium.com/@andreasreiser94/why-hateoas-is-useless-and-what-that-means-for-rest-a65194471bc8 The only 'smart' client that currently exists is an end-user, and writing a HATEOAS API for an end-user is normally just called 'building a website'. The point of an API is to enable a dumb program to interact with your application without having to 'parse' and 'screen-scrape' and 'understand' to get by - instead, you as the developer read the API, encode the out-of-band knowledge to use it, the API itself drops all the extraneous explanatory guff and makes that smooth, and all is well. HATEOAS is kind of 'hey, you took away all my guff to make a smoothly interacting API... give it back, I wanted that!'
use just `if ok {` please. no need to compare a bool to `true/false`.
`python -u dev_appserver.py app.yml`
From what I've gathered, dev_appserver.py will start a dashboard running on http://localhost:8000 which lets you manage the running instance, chances are logs from your application are also there. Note this is entirely speculation and not tested by myself at all.
Cobra and urfave/cli both enforce an inversion-of-control architectural pattern that's difficult to maintain. IMO, Kingpin is the only widely-used CLI library that takes an appropriate architectural approach.
nah, someone with the same problem in the future might find it in a search and be helped. Probably not, but it's not like it's hurting anything.
man, that is fucked up. I would not have expected that, and I've been coding in Go for years
I'm the author of the [OCaml version](https://github.com/ixy-languages/ixy.ml) of this driver and I wrote a [tutorial-ish thing](https://github.com/ixy-languages/ixy.ml/blob/master/doc/memory.md) explaining parts of the driver's memory interface. It's still WIP but you may want to take a look.
ummm... what? why? why would you do this? so confused...
It's a cliffhanger for php movie wachter... You should definitely watch "go" xD
Every time the author is asked this, I think the answer is roughly along the lines of, "because I enjoy Go, but I have to write PHP all day, so I wrote this for fun! Also, maybe I'll be able to write some helpful tools in Go that can do nice things to my PHP."
My first reaction is: "Please, please don't use this package." My second reaction is: "Maybe this package wouldn't exist if the Go standard library could reverse a string?"
At the very least this is a useful reference for PHP devs to understand how common stuff is done in Go.
I like [`argparse`](https://github.com/akamensky/argparse). It's pretty simple (you create a `Parser` and then call methods to create args. No globals or reflection.) Dependency-less as well.
goimports/goformat are your friends. Friends don‚Äôt let friends write go without goimports. üëçüèª
It is very hard to abstract over things in Go for a variety of reasons: * Lack of parametric polymorphism ("generics" * Lack of sum ("tagged union") data types * Extremely verbose function syntax Go is so close to being a really ergonomic imperative language. These things I mention aren't very complicated and provide high value. I still like &amp; use Go, but I always end up having to do annoying things: * Copy &amp; paste or used mutability to work around lack of parametric polymorphism * Return `(MyType, bool, error)` instead of using something like `Found MyType | NotFound | Error error` due to lack of sums In a vacuum, none of these things are that painful, but it feels like a death by a thousand cuts sort of thing. Sadly, I don't think Go will ever move in the direction I desire, as it seems pretty culturally opposed to all these ideas.
thank you, was wondering about that
If you break out the requirements you'll likely end up with 1) an artifact that represents your application, 2) the configuration necessary to run correctly and 3) the context where the artifact + configuration runs. Docker provides some framework around these requirements. The artifact can be the container. The artifact can also be the container + config. When running the container, you can use the docker daemon (or something else) that might be more convenient to work with over time. Put another way, you can run multiple docker containers and manage that using the docker daemon (or runc, etc). There are some downsides as well. You need to be very explicit about things like what volumes/ports you are using. Ensuring these aspects are consistent eventually requires some concept "orchestration" where it can assert things like port mappings are OK and volumes are mounted correctly. Depending on the application, you might have some hoops to jump through to access resources on the machine. The automation in development can be hit or miss as well depending on how you define and plan to configure your containers. Less bundled config in the container means you'll need to map local \`docker run\` calls with what you expect to run in production. None of this is insurmountable by any stretch, but when people solve these problems with docker, they often are OK with some limitations that are unsaid. Another good example is the size of the artifact. There are other options such as systemd that do many of the same aspects as the docker daemon. Config management tools can certainly manage these aspects. While you might lose some isolation, you also may not need it. If you are scaling to more than 1 VM for the same process, whether that process is running in a container or not is inconsequential b/c you've likely become hardware bound. Similarly, if you do use docker and try to use some automation, it is not free to operate the platform with most folks having to write configuration management tooling to setup and configure the generic "nodes". At the end of the day, the decision to use docker is really dependent on your requirements. If this is a personal project and you want to learn docker, then that is more than reason enough to use it. If you are creating a proof of concept that might evolve into a system that needs to scale, you may be able to get up and running more easily with a unit file and an Ansible playbook. You might be running in a cloud that offers a hosted orchestration tool (k8s, EKS, etc.), in which case, it might be less work understanding that API and toolchain than getting ramped up on Ansible. The point being is to do what makes sense to you as you're the one doing the work. Good luck!
maybe try `db.QueryRow` \- your SELECT is not executed.
No, formatting does... whitespaces generally don‚Äôt, but line breaks do 
Do you want objects? Because this is how you get objects...
congrats!
no, there's a huge difference between the duck typing of Go, based on interfaces, and proper objects. What you're talking about here, attaching data implementations to interfaces, is the start of objects. The key point about interfaces is that they don't specify implementations. They just describe behaviour. You're specifying an implementation of the behaviour. Everything you're doing with the struct, you could do with getter/setter functions on the interface, which would still leave the implementation up to the provider. Specifying the struct means specifying the implementation, and that's where you start getting into Objects. 
Been running my blog with Hugo for years. Congrats!!! Ps - does Hugo ship with a default theme yet?
&gt; no, there's a huge difference between the duck typing of Go, based on interfaces, and proper objects. &gt; &gt; that's what objects are, bags of methods as reference.The "no true OO" trope with Go needs to die. Go is an object oriented language. Everytime you do i/o in go you are using OOP. This isn't optional.
Currently, that's not the case.
Always `go fmt` your code. This does prevent you exactly from this kind of little surprises and makes you code more readable for other gophers. Proverb 7: &gt; Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.
Restic 
Ellipsis in Go are associated to ‚ÄúVariadic Functions‚Äù [1]. ‚Ä¢ When `defining` a variadic function, the ellipsis go on the **left** side ‚Ä¢ When ` calling` a variadic function, the ellipsis go on the **right** side func sum(nums ...int) int {} // sum takes an arbitrary amount of integers. sum(nums...) // call "sum" function with an array of "nums". Variadic functions are used to simplify the definition and execution of functions that are used to process an arbitrary amount of data with unknown size. For example, let‚Äôs say that you want to create a function to sum numbers. At first you define the function like this: func sum(a int, b int) int {} sum(2, 2) // returns 4 But later, your co-worker asks you to modify it to support a 3rd parameter: func sum(a int, b int, c int) int {} sum(2, 2, 0) // returns 4 And later, another co-worker asks you to modify it to support a 4th parameter: func sum(a int, b int, c int, d int) int {} sum(2, 2, 0, 0) // returns 4 You could keep adding more and more parameters, or you can create a variadic function that accepts either 1, 2, 3, ‚Ä¶ N number of parameters. Then all your co-worker requests will automatically be supported without having to modify the code any further: func sum(a ...int) int {} sum(2, 2) // returns 4 sum(2, 2, 0) // returns 4 sum(2, 2, 0, 0) // returns 4 Here is the example working [2]. [1] https://en.wikipedia.org/wiki/Variadic_function [2] https://play.golang.org/p/7u1uCBeYyCk
Ellipsis in Go are associated to ‚ÄúVariadic Functions‚Äù [1]. ‚Ä¢ When `defining` a variadic function, the ellipsis go on the **left** side ‚Ä¢ When ` calling` a variadic function, the ellipsis go on the **right** side func sum(nums ...int) int {} // sum takes an arbitrary amount of integers. sum(nums...) // call "sum" function with an array of "nums". Variadic functions are used to simplify the definition and execution of functions that are used to process an arbitrary amount of data with unknown size. For example, let‚Äôs say that you want to create a function to sum numbers. At first you define the function like this: func sum(a int, b int) int {} sum(2, 2) // returns 4 But later, your co-worker asks you to modify it to support a 3rd parameter: func sum(a int, b int, c int) int {} sum(2, 2, 0) // returns 4 And later, another co-worker asks you to modify it to support a 4th parameter: func sum(a int, b int, c int, d int) int {} sum(2, 2, 0, 0) // returns 4 You could keep adding more and more parameters, or you can create a variadic function that accepts either 1, 2, 3, ‚Ä¶ N number of parameters. Then all your co-worker requests will automatically be supported without having to modify the code any further: func sum(a ...int) int {} sum(2, 2) // returns 4 sum(2, 2, 0) // returns 4 sum(2, 2, 0, 0) // returns 4 Here is the example working [2]. [1] https://en.wikipedia.org/wiki/Variadic_function [2] https://play.golang.org/p/7u1uCBeYyCk
Ellipsis in Go are associated to ‚ÄúVariadic Functions‚Äù [1]. ‚Ä¢ When `defining` a variadic function, the ellipsis go on the **left** side ‚Ä¢ When ` calling` a variadic function, the ellipsis go on the **right** side func sum(nums ...int) int {} // sum takes an arbitrary amount of integers. sum(nums...) // call "sum" function with an array of "nums". Variadic functions are used to simplify the definition and execution of functions that are used to process an arbitrary amount of data with unknown size. For example, let‚Äôs say that you want to create a function to sum numbers. At first you define the function like this: func sum(a int, b int) int {} sum(2, 2) // returns 4 But later, your co-worker asks you to modify it to support a 3rd parameter: func sum(a int, b int, c int) int {} sum(2, 2, 0) // returns 4 And later, another co-worker asks you to modify it to support a 4th parameter: func sum(a int, b int, c int, d int) int {} sum(2, 2, 0, 0) // returns 4 You could keep adding more and more parameters, or you can create a variadic function that accepts either 1, 2, 3, ‚Ä¶ N number of parameters. Then all your co-worker requests will automatically be supported without having to modify the code any further: func sum(a ...int) int {} sum(2, 2) // returns 4 sum(2, 2, 0) // returns 4 sum(2, 2, 0, 0) // returns 4 Here is the example working [2]. [1] https://en.wikipedia.org/wiki/Variadic_function [2] https://play.golang.org/p/7u1uCBeYyCk
Ellipsis in Go are associated to ‚ÄúVariadic Functions‚Äù [1]. ‚Ä¢ When `defining` a variadic function, the ellipsis go on the **left** side ‚Ä¢ When ` calling` a variadic function, the ellipsis go on the **right** side func sum(nums ...int) int {} // sum takes an arbitrary amount of integers. sum(nums...) // call "sum" function with an array of "nums". Variadic functions are used to simplify the definition and execution of functions that are used to process an arbitrary amount of data with unknown size but the same data type. For example, let‚Äôs say that you want to create a function to sum numbers. At first you define the function like this: func sum(a int, b int) int {} sum(2, 2) // returns 4 But later, your co-worker asks you to modify it to support a 3rd parameter: func sum(a int, b int, c int) int {} sum(2, 2, 0) // returns 4 And later, another co-worker asks you to modify it to support a 4th parameter: func sum(a int, b int, c int, d int) int {} sum(2, 2, 0, 0) // returns 4 You could keep adding more and more parameters, or you can create a variadic function that accepts either 1, 2, 3, ‚Ä¶ N number of parameters. Then all your co-worker requests will automatically be supported without having to modify the code any further: func sum(a ...int) int {} sum(2, 2) // returns 4 sum(2, 2, 0) // returns 4 sum(2, 2, 0, 0) // returns 4 Here is the example working [2]. [1] https://en.wikipedia.org/wiki/Variadic_function [2] https://play.golang.org/p/7u1uCBeYyCk
nice thanks!
Applications in Fuschia will be written using the Flutter framework which is based on Dart. 
Awesome-Go https://github.com/avelino/awesome-go/blob/master/README.md Or if you want a searchable site check out https://golanglibs.com
https://tour.golang.org/welcome/1
That‚Äôs not what OP is asking for. When you go to the linked website for ‚ÄúPython Tutor‚Äù you will see that one of the features that makes the website stand out is the ‚ÄúGet Live Help‚Äù button, which allows you to chat with people in real-time about the code that you are writing in the pad. The ‚ÄúGolang Tour‚Äù only provides the pad, but you are supposed to learn by yourself, which is not bad, but OP seems to be specifically asking for a website that both allows you to run Go _and_ let you chat with people. /u/s4nskrit I don‚Äôt know of any website with both chat and Go support. Adding Go to ‚ÄúPython Tutor‚Äù sounds like a fun project, here‚Äôs the source code [1]. Meanwhile, you can join the Gophers Slack group [2] where you can chat with other Go enthusiasts. [1] https://github.com/pgbovine/OnlinePythonTutor [2] https://invite.slack.golangbridge.org
Thanks again! Chatting is ok, but I like the visualize execution feature. Once I grasp the basics of Go I will attempt to create a similar site like Python Tutor for Go, it does seem like a nifty idea for a project. Thanks for the suggestion!
The two links are pretty good ones. I've worked with a HATEOAS API before, and I bet zero people who developed against it actually found the resources they needed by following links from the root resource. Also, note: can be pretty terrible for micro-services as it forces a high level knowledge of your API into most endpoints. Do what that project did later and expose good API documentation as Swagger or something.
Both C and C++ are much more complex than Go, but even with their complexity /u/pgbovine was able to add support for them on ‚ÄúPython Tutor‚Äù. Maybe if you [ask him nicely](http://www.pgbovine.net) he can add support for Go as well. I will take a look at the code and try to contribute to the project, because it really seems like a nice tool.
For loops are surprisingly dangerous. They warrant careful inspection. ``` for i, o := range oArray { o.value = x // Warning modifying elements from the iterator } ``` Unlike most other languages the value provided by the iterator is a copy, mutations are not persisted. You must use `oArray[i].value` to change the list. Use a consistent pattern when modifying an array. ``` sum := 0 for i := range iArray { sum += i } ``` If you're working with arrays of integers, it's easy to confuse the index and the value. No warnings are given. Red flags: - Mutations of objects in for loops - Unclear index vs value when working with [int] 
That's really awesome! I will also make the suggestion to /u/pgbovine
I really like the idea of perkeep. Basically it wants to be a personal storage server for literally all of your media. Photos, videos, tweets, whatever. It's all searchable and for images it places pins on a map for places you've been. It's one of the older Go projects and has a full time developer working on it.
I just looked at his CV .. wow! - [http://pgbovine.net/philip-guo-cv.pdf](http://pgbovine.net/philip-guo-cv.pdf)
Regarding your edit, generally questions that the majority of the users in this sub won't find interesting get voted down to zero. It doesn't mean you did anything wrong and generally decent questions will get answered even if down voted (as you saw).
Thank you for letting me know. I read the rules and I didn't know if I did something wrong or not.
The things you mention are the things that get ironed out during a development workflow. A solid production quality container orchestration tool is not going to spontaneously stop routing to your container or produce and behaviour where doing a ‚Äúdocker exec foo sh‚Äù is going to be of any value.
What about the support of 7z format in the future?
Sure! Pull requests to add new formats are welcomed. Just has to be a pure-Go solution.
Thanks! Yeah, initially I wanted folks to be able to run on any specified port, but I don't think the negotiations with LetsEncrypt can happen by default (using autocert) on ports other than 443 (but looking further into this)!
I want to give you gold, but I have no gold to give, so here have an upvote.
Hugo. Kubernetes. Docker. Traefik. Syncthing. Prometheus.
Undoubtedly, Kubernetes.
https://github.com/upspin/upspin
The article describes very clearly how to break out some code from main into a separate package. However, I fail to see where dependency *injection* happens.The `timenow` package depends on the `net/http` package but this dependency is added in a rather straightforward way rather than injecting it. But maybe I just have a different model of "Dependency Injection" (DI) in mind. To me, DI enables high-level code to call into low-level code *without having to hard-code a dependency to the lower layer.* (I once wrote an [article](https://appliedgo.net/di) that describes this view of DI.) In this model, `timenow` would have its own abstraction of an HTTP client (expressed through an interface that declares just an abstract `Get()` function), and package `main` would then do the wiring and connect the `Timenow` object to a particular HTTP client package that provides an implementation of the `Ge()` function. `timenow` would thus not have to depend on `net/http`. But as I indicated before, there are certainly different notions of DI around, and I am in no way trying to imply that my view is the only possible one.
Hashicorp stack, i.e. - https://www.vagrantup.com/ - https://packer.io - https://terraform.io - https://nomadproject.io - https://vaultproject.io
I mean some prefer the comparison (not me) because it's sometimes more obvious what's happening especially when using ! That can be missed easily 
Neither, personally I like [https://github.com/jessevdk/go-flags](https://github.com/jessevdk/go-flags). I like the declarative approach a lot more than the imperative one used for many other options, and it's extremely feature-rich.
Note that Vagrant is Ruby.
The official go k8s client is pretty terribly designed.
one solution for the moment is to encode html special characters before inserting them in the database https://www.web2generators.com/html-based-tools/online-html-entities-encoder-and-decoder I will post later here when I'll find a real solution
Yep, and that's why I started this discussion. Cobra is very popular indeed but its architecture is somewhat questionable.
You can't import `internal` packages from another project. If you need the library, the only option is to copy paste it.
What about timezone data? (as per https://godoc.org/time#LoadLocation) Here's a Dockerfile another guy did that copies the zoneinfo.zip and sets the ZONEINFO env var: https://github.com/jeremyhuiskamp/golang-docker-scratch/blob/master/Dockerfile 
Hi use [ConstantTimeCompare](https://golang.org/pkg/crypto/subtle/#ConstantTimeCompare) instead of [this](https://github.com/Bijan-Massoumi/PoW_Web-Server/blob/master/server/protocol.go#L113) to prevent timing attacks use [regular expressions](https://golang.org/pkg/regexp/#MatchString) instead of [this](https://github.com/Bijan-Massoumi/PoW_Web-Server/blob/master/server/loadtree.go#L36) do proper error handling in case of [read](https://github.com/Bijan-Massoumi/PoW_Web-Server/blob/master/server/protocol.go#L21) or [write](https://github.com/Bijan-Massoumi/PoW_Web-Server/blob/master/server/protocol.go#L23) error don't use [plaintext passwords](https://github.com/Bijan-Massoumi/PoW_Web-Server/blob/master/server/loadtree.go#L26) instead you can use [bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt) or [pbkdf2](https://godoc.org/golang.org/x/crypto/pbkdf2) you can use [JSON](https://golang.org/pkg/encoding/json/) messages and Go structs for validating instead of implementing your own message parsing write tests
&gt; If you need the library, the only option is to copy paste it. Or to ask upstream nicely to publish/maintain it as a non-internal package.
Is there a summary of what's changed in the rewrite?
Thank you let me first read about the case of gophers against HATEOS.
if you have infinite loop without break, code after the loop will be unreachable
Not sure what the code is because the snippet is not complete, but the for loop will always exit after the first iteration returning err. So it makes sense that the return nil is flagged as unreachable. And it's not the compiler, probably one of the linters your editor has tells you that. The compiler doesn't care about unreachable code.
I didn't think so but you are indeed correct: https://play.golang.org/p/dZYSulYzy5c
That is not the Go compiler producing the error. That is go vet running on the playground code before running go build (much like it happens before running tests).
Terraform
The whole idea of an internal package is to be, well, internal. That is unavailable to others.
It's one way to handle it. And I like it! You should have separate goroutines polling for incoming requests and then using a service tool to handle that request. And of course, using channels is great but only if you use multiple consumers in this event. Have you tried spawning multiple consumers using goroutines?
Need I put up the whole function??
Need I put up the whole function.
yeah it's probably go vet. But since I like my code clean and idiomatic I am looking for a better way.
Yes, it works, I just confused about creating new channel for every request.
Oh, definitely don't do that. Do you have more of the code to share? I'd love to help out somehow. 
Prometheus is one of them 
`func Subscribe(stream pb.DataStream) error {` `for {` `in, err := stream.Recv()` `if err == io.EOF {` `return nil` `}` &amp;#x200B; `if err != nil {` `return err` `}` `}` `//return nil` `}` This is a grpc client subscribing to a gRPC stream. Should I put break before return?? just leave out the last retrun statement, it seems to compile.
`func Subscribe(stream pb.DataStream) error {` `for {` `in, err := stream.Recv()` `if err == io.EOF {` `return nil` `}` `if err != nil {` `return err` `}` `}` `//return nil` `}` This is a grpc client subscribing to a gRPC stream. Should I put break before return?? just leave out the last retrun statement, it seems to compile.
func Subscribe(stream pb.DataStream) error { for { in, err := stream.Recv() if err == io.EOF { return nil } if err != nil { return err } } //return nil } This is a grpc client subscribing to a gRPC stream. Should I put break before return?? just leave out the last retrun statement, it seems to compile.
main.go: [https://pastebin.com/BVdjUfay](https://pastebin.com/BVdjUfay)[https://pastebin.com/BVdjUfay](https://pastebin.com/BVdjUfay) handler/handler.go: [https://pastebin.com/L02pHhnB](https://pastebin.com/L02pHhnB) &amp;#x200B; First idea was to use one channel for all responces, but I can't guarantee right responce reading sequence this way.
Thanks for the link! Kind of surprised to see the performance of C#.
I typically prefer creating channels as singleton resources (global per app). It‚Äôs easier for eyeballs to see during peer review and easier to close properly. Is there a reason to have one worker? You can have a pool of workers that run while not EOF {} to read the data.
If you're sending something to a single worker and waiting for a reply back, then it might actually be better to use a mutex. Golangs internal logging package uses this to write logs sequentially to the same output without writing over them. Mutex's are also much lighter than creating a channel per request, which can build up quickly. ``` type Processor struct { mutex sync.mutex ... processor attributes ... } func (p *Processor) HandleRequest(r *Request) { p.mutex.Lock() ... handle request ... p.mutex.Unlock() } ``` This creates an artificial queue of goroutines behind the mutex. Each goroutine waits for the previous goroutine to release it's hold on the mutex so it can process it. This doesn't work when you have multiple workers, but works when you're trying to limit access to the same output.
‚ô•Ô∏è
There are few open issues and a PR about that. I don't use symlinks in archives myself but will accept contributions to add support for them!
Basically everything. The godoc and readme are the best explainers. It used to be two functions (Make and Open), now it is like 6, with room for more. Still easy to use, but configurable now.
The reason is simple: worker communicates to serial equipment.
It was my first thought, but I want to extend this code to have priority queue and two sources of requests.
No questions about the future of the language at all? Interesting.
try to not use "else" https://play.golang.org/p/p7ZIoGsU__H
this is interesting: https://i.imgur.com/PQL8YBr.png
question about diversity though https://i.imgur.com/PQL8YBr.png
Just don't return after the loop if you don't have a break inside the loop. 
IIRC, the previous two also had this question, so nothing new here, really.
It is fine if you keep closing the chan after each job is done. I like it.
they [did](https://blog.golang.org/survey2016-results) have [indeed](https://blog.golang.org/survey2017-results)
Just use graphQL.
I don't want them at all!
&gt; Likely HATEOAS is not terribly popular amongst gophers. HATEOAS isn't popular among a lot of developers, it has nothing to do with Go. most API client do not do API discovery at first place. For instance every Google HTTP client for every service is code generated, very few of them even use the notion of resource linking. If Google doesn't even do that why should i and my small team bother doing that? for what "intelligent client"? 
It's probably harder to implement it in Java due to Java libraries typically being distributed in binary format. But I'm pretty sure you could implement them using subtypes by compiling them to class hierarchies. But Go libraries are distributed as source, so I don't see the difficulty. It's not like their physical representation is an "open question" or anything. On top of that, you can implement functionally equivalent types to proper sum types using structs &amp; type-switching &amp; information hiding already. I have read through discussions on GitHub about this issue w/Go and never once seen someone actually explain why providing simple sum types (the dual of `struct` and nothing more fancy) would be a problem. The most I've seen is "I don't see why this is more useful than interfaces" which imo hints at a lack of experience working in a world with sum types and without oop-like constructs like interfaces.
&gt; coding in Go for years &gt; not expecting formatting to matter Pick one
You have a bug in your code when you submit a job request. If the queue is full and you hit the default case, then nothing will ever put a value on the done channel. But you then wait on the done channel regardless and will sit there forever. 
Then you would want three different channels. Your regular queue, your priority queue, and a done queue. You have one worker that reads from both the regular and priority queue in a type switch with priority queue taking precendence. When the worker is done processing that request, then it places the request onto the done queue so that further action can be taken on that request.
[https://mattermost.com/](https://mattermost.com/) wanting to work with this moved me to learn Go in the first place (still very new)
What if I don't? Memory leak? Is it necessary or just a good practice?
Guys, you are awesome. Thank you for your knowledge sharing.
Hmm. I don't get this sentiment. It's not like you *have* to use generics in any language that offers them. Personally, generics would greatly help me condense some files down and improve testability. And, generic data structures would help everyone. Why are you so against them?
Everybody know what you win with generics. But more difficult is to know what we loose if it's not well integrated in the langage (simple) design.
Maybe readability of generic functions? The Go 2 draft design of generics looks fine to me. 
Good practice. If channel is open forever and never used it will be gced 
whoa, you're right: [https://play.golang.org/p/7Cu14QFSGlw](https://play.golang.org/p/7Cu14QFSGlw) can you explain that?
ok, this is even stranger: [https://play.golang.org/p/SxcT9\_OBuJm](https://play.golang.org/p/SxcT9_OBuJm) but I guess it explains things
In bcrypt.GenerateFromPassword, you may be setting the cost too high.
How many platforms do you need to support?
i'm new to Go, but maybe you could populate a field with the path in an html template with an image tag and issue a comman to the os shell to open the file in a browser
this looks awesome
This was just a thought experiment to see if it would work. It does! 
It really doesn't. The contracts are an entirely separate language which looks the same but works completely different to everything else in a source file. As far as solutions go, `go generate` is better than contracts. Also, a generic type system which can't be used to describe the generic types already in the core language? That's borderline insane.
Have you done a speed comparison between the different JS contexts?
Linux on amd64 is the only one I care about 
I have not, but I would bet good money it's a lot worse. v8 has hundreds of optimizations that Otto lacks.
Or dependancy management!
Token &gt; Session üòä
You almost made me believe you had good enough reasons to do what is universally described as a bad idea. Some day I‚Äôll understand why developers are inextricably drawn to this horrible practice. Until then, I‚Äôll create such things during configuration and pass the configuration to everything that needs it.
Yep, IIRC the usual recommendation is that you should shoot for about 100ms hashing time. Another trick is that if you have other expensive work to do before or after the hashing (e.g. looking up stuff in the DB), you can do that in parallel with the hashing.
Which part is bad?
a Windows vm in a Linux Vm oin a Windows os?
Wow, this is just hilarious. I wonder if I can port JavaScript core to wasm with emscripten. This deserves gold. 
Accessing a non-existent key in a map gives you the "zero value" of the type ‚Äî in the case of an `int` it's 0.
Maybe not a full generics like interface, more types like accepting struct based interface, accepting pointer based struct, and accepting certain struct with list of fields alike implements but for object properties
But when login, I should compare password hash everytime. Or is there any other way?
If it's right, then ok
Can we go deeper? Compile Go code... using GopherJS that is compiled to JavaScriot with GopherJS, running in Otto, compiled to WebAssembly, running in a browser.
Oh yeah. You don't really have to use generic if they added it. People said something the same when PHP added bunch of the functions a while ago.
I'm curious, what is terrible about the design?
You need to learn about how to use cookies/sessions securely if you want users to log in once and browse your site. Bcrypt takes long time by design so it's not vulnerable to brute force attacks.
It doesn't follow conventions very well, it's overly abstracted and extremely difficult to follow, and building it is pretty painful. Packages rely on different versions of different packages within the same repo. Its not fun to use at all. I wirk with it on a day to day and i really dont enjoy it in the least. Oh and the public api is very poorly documented.
Go is a lot about the ease of reading other people's code. So even if you do not use generics yourself, you would have to read and understand them in code written by others. Every new feature added to Go makes Go code a bit more difficult to understand and to reason about. This is not specific to generics; however, generics seem to add a lot new semantics, more than other additions to the language did in the past. So while I do understand the benefits of generics, I also understand those who would rather not have them in Go. (Personally, I never missed generics in my projects, but I am pretty sure I will start using them once they are available.) 
You can use the libraries Pixel (github.com/faiface/pixel) or Ebiten to draw an image to an OpenGL window.
Each day we stray a little further from God's light
I had seen a video somewhere, can't remember now. The speaker was running Chrome inside Chrome, and used the inner Chrome to load something .. either a game or some photoshop kinda application. All compiled using wasm.
Unfortunately, cpio is still around ‚Äì rpm uses it. Similarly, dpkg still uses ar. 
Typo: modukes -&gt; modules
Fixed, thanks!
Hi, I struggled with the same problem for the while. The solution was the following: 1. make sure the checkbox [X] Enable Go Modules (vgo) integration beneath: Settings/Go/Go Modul (vgo) is enabled. 2. make sure you have NO entries beneath: Settings/GOPATH/Project GOPATH THIS IS CRUTIAL!!!! and make sure both checkboxes are checked: [X] Use GOPATH thats defined in system environment [X] Index entire GOPATH This make it finally work fo me
I just took the survey. All I wanted the Go team to know is `nil pointer dereferences` problem should be looked at.
Since I never used RHEL/CentOS, I'm in favour of just getting of both now that IBM got 'em.
Nice
##### Go programmers horror. Human: there is `go generate`, now you can do all you can imagine with Go. Zombie: generics, where they are? 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/devops] [jsonfmt: like go fmt but for json](https://www.reddit.com/r/devops/comments/9vk01a/jsonfmt_like_go_fmt_but_for_json/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
That is a good thing. To be away from lie. 
Nice! You may want to try https://stedolan.github.io/jq as well
Hmm. So, basically just a way to apply MarshalIndent to arbitrary JSON file? You might look into whether simply calling json.Indent would work and let you skip unmarshaling and remarshaling and achieve the same effect. Also, have a look at https://github.com/TylerBrock/colorjson for an example for 'custom marshalling' with respect to your comment // TODO: support to customize indent - it gives both an example of how to do it, and is itself something that you might choose to expose as an option in your formatter. e.g. adding -c for colorize, or something like that. Also, https://github.com/hokaccha/go-prettyjson, which is what colorjson was based on. The more generally used term for this sort of formatting is pretty-printing, hence the above 'go-prettyjson', and https://github.com/jmhodges/jsonpp is another example of a json pretty-printer that is like your jsonfmt in basically being a thin command line wrapper around the built-in indent functionality.
github.com/TheGrum/renderview is meant for just this - it wraps gtk2, gotk3, or shiny and lets you take a function you've written that generates an image.Image into an interactive program - get pan/zoom and with gtk2 or gotk3, also get parameter editing for your function as well.
&gt;Let me save you some time and predict the top most wanted feature using my state of the art Machine learning package written in Go, it is gonna be "generics". how do you code now without maps, slices and channels?
And yet, reading already generic code now (usage of maps, slices, channels) is fine, but reading interface{}-ladden spaghetti code that tries to work around the lack of generics is quite a chore. How would making the later more like the former degrade readability here?
After working on some projects with a structure of a monorepo + well-defined internal libraries in private repos, frequently using GitLab suborganizations, I came to the conclusion that the go modules stuff is truly an experiment (compared to vendor, which worked pretty damn well) and it's nearly unusable in more complicated environments. Additionally private suborganizations are broken with Go on GitLab and [you basically have to use a fork of `dep` to import libraries in suborgs](https://github.com/golang/dep/pull/1983). No other vendoring solution works with broken go-import tags. Go Modules as-is, without any tooling for the proxy, have been only pain for me. The worst part is that if you have a complicated non-go-mod project, you can't use libraries that use the virtual `vX` syntax in their path. Hopefully they either fix the whole thing or someone implements a proxy sorting out all the pain points.
He's got a fever and the only prescription is modukes.
I agree that contracts are a separate ugly language that looks bolted on. On the other hand, I would be very disappointed if we got generics without a mechanism for `bounded parametricism`(which contracts are). I kinda like Roger Peppe's suggestion in [1]; "I propose that instead of allowing arbitrary code in contract bodies, we allow only an extremely restricted syntax. Every statement in a contract body must consist of exactly one expression that uses exactly one of the following operators: - all arithmetic and logical binary and unary operators - channel send, receive and close - array and map indexing - function call - type conversion - interface conversion" - [1] 1. https://gist.github.com/rogpeppe/45f5a7578507989ec4ba5ac639ae2c69
I wrote a very simple version of one of these too, if you‚Äôre curious to compare. https://github.com/shurcooL/cmd/blob/master/jsonfmt
Meaning? I find the output pretty straightforward. Or do you mean within the go compiler itself?
[removed]
I think you‚Äôre talking about a really good talk by Gary: https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript
https://astaxie.gitbooks.io/build-web-application-with-golang/en/
you mean like something in udp?
This is great, thank you!!
Hi, Thanks for the insight. I got similar conclusion, but with no prior experience with golang it is hard to say so. And an existence of hidden go-import protocol was big surprise for me. Especially knowing that choosing the vcs server have an impact on possible structure of the project. 
Regarding 2 and 3, even a slow modern server with a single core would be able to handle an amazingly huge amount of traffic, in most any language if coded reasonably well. &amp;#x200B; However Go is a very pleasant language in general and has a great ecosystem for doing backend web development, so it is absolutely a fine choice. &amp;#x200B;
Francesc Campoy has a good youtube channel that covers a lot of good topics. He also does code reviews which helps to point out some common mistakes or make design recommendations. https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw
Ideally I would like to see empty interface become or get extended as a generic. Maybe some compile time flag which give you a generic support at the cost of compilation speed. Default can be current runtime checking . If an empty interface can accept anything at runtime, why not extend it to compile time. Wouldn't that be what generics do? No cost, but a little bit in compilation. Accepts anything, gets verfiied at compile time. Will that requires a syntax change, perhaps yes. May be interface {} should be extended. Don't know.
It sounds like an app that could be written in literally any language and meet all your needs on a $7 heroku dyno. That being said, I agree with point #1 you should try a new language, and Go is a good one to try.
[https://github.com/ethereum/go-ethereum/](https://github.com/ethereum/go-ethereum/)
influxdb doesn't have clustering in their free and open source release, they ask money for it and call it something else too so the use case is adding clustering that is available to everyone i'm guessing
Gah, as usual, when you write out the problem and ask, the solution suddenly becomes obvious. Missing } at the end of the json stream. Bah. For those of you that looked thanks anyway!
What does your `TicketList` look like? The one passed to `tmpl.Execut(w, TicketList)` I'm guessing it is an array, not a struct. Since the context you're executing on is an array, you want to range over `.`. Here's how this would look for you. &lt;html&gt; &lt;head&gt; &lt;title&gt;Reserved Users&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{range .}} &lt;!-- Since we are ranging over . (TicketList), the . now refers to a single Ticket within the TicketList --&gt; {{ .ReservedBy }} {{end}} &lt;/body&gt; &lt;/html&gt;
we should not have nil pointers in the language
We use modproxy https://github.com/modprox. Docs need to be updated but it works
The problem is that you're converting a byte like 8 into an ASCII/UTF8 character. When you do that, it's converted to the ASCII character value 8, which is actually "backspace", not the character `8` which is actually ASCII number 57. use fmt.Sprintf to produce the output you want, treating each byte as a number: https://play.golang.org/p/AxQzmspAon9
When byte is casted to string it means interpret these bytes as utf-8 code points. The numbers in the ip adderesses happen to be non-printable utf-characters and thus nothing is displayed. You need to convert the numeric values into their printable versions by either using `fmt.Sprintf("%d", data[i])` or use `strconv.Itoa(int(data[i]))`. [I've built a playpen demonstrating these techniques.](https://play.golang.org/p/2C20_NGq-0z)
When you cast a byte slice to a string, you get a string that contains those bytes, so `{127, 0, 0, 1}` is equivalent to `"\x7F\x00\x00\x01"`. Since those are non-printing characters, you don't see a whole lot. The most straight forward way to implement your string function is probably with `fmt.Sprintf("%d.%d.%d.%d", i[0], i[1], i[2], i[3])`.
Global variables.
https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk I use this to turn web pages to epub files for long reading. https://play.google.com/store/apps/details?id=com.softesk.grabMyBooksFull https://www.grabmybooks.com 
Thank you!
Thank you!
Thank you!
Thank you!
Ah yes, that's the one !
I'm trying to an exercise on the tour, and they've set it up to backed by []byte array. Yes what you did is exactly what I'm looking to do
To be honest if you are more of a videos person then go here and do audit course for free https://www.class-central.com/course/coursera-functions-methods-and-interfaces-in-go-12050 If you are a doing person then I'd start by copying text from one file to another like this. https://gobyexample.com/writing-files It is simple and you know your goal and you are going at your own pace. Watching online courses tend to go too far ahead when starting out. 
tomorrow night I have to study all these comments. really good stuff. but what you're saying about the byte to string cast interpreting the byte\[x\] as utf-8\[byte\[x\] \] doesn't seem to fit with what I'm reading on-line that string \*is\* essentially \[\]btye array with one added piece of meta-data meaning to say that it's just an arbitrary array of bytes, like the \[\]byte. &amp;#x200B; the problem is, I know now thanks to you guys, is in the fmt.Println which is what is interpreting the bytes as code points. &amp;#x200B; Indeed, changing the IP address to reflect printable ascii characters--[https://play.golang.org/p/LATRa-IrP-P](https://play.golang.org/p/LATRa-IrP-P)\-confirms this &amp;#x200B; but the amount of information about string processing in this thread and in your comment and code in particular is staggering and worth the price of his failure entirely. &amp;#x200B; &amp;#x200B; &amp;#x200B;
&gt; Go Modules as-is, without any tooling for the proxy, have been only pain for me. The worst part is that if you have a complicated non-go-mod project, you can't use libraries that use the virtual vX syntax in their path. Hopefully they either fix the whole thing or someone implements a proxy sorting out all the pain points. This is contrary to what is being said on https://github.com/golang/go/wiki/Modules though? &gt; . To help with this, Go versions 1.9.7+, 1.10.3+ and 1.11 have been updated so that code built with those releases can properly consume v2+ modules without requiring modification of pre-existing code. (When relying on this updated mechanism, a package that has not opted in to modules would not include the major version in the import path for any imported v2+ modules. In contrast, a package that has opted in to modules must include the major version in the import path for any imported v2+ modules). Is this wrong?
Can you link me to the portion of the tour you're looking at?
It's right there [in the FAQ](https://golang.org/doc/faq#What_is_the_purpose_of_the_project),
Try using type switches: [https://tour.golang.org/methods/16](https://tour.golang.org/methods/16)
sure thing: [https://tour.golang.org/methods/18](https://tour.golang.org/methods/18)
&gt; would not include the major version in the import path for any imported v2+ modules I used dep with [golang-migrate](https://github.com/golang-migrate/migrate), I might have done something incorrectly but I really didn't have time to mess around with this thing. It said that packages with `/v4/` weren't found. Note how the main package imports `"github.com/golang-migrate/migrate/v4/database"`.
The only thing you can really do is wrap that into a function: func CtxString(ctx context.Context, key interface{}, default string) string { v := ctx.Get(key) if v == nil { return default } str, isStr := v.(string) if !isStr { panic("not a string!") // or something } return str } CtxString(ctx, "x", "") Or you could error if it isn't a string, but that really complexifies using it. (At least unless the Go2 error proposal goes through in which case it would probably be a better solution.)
I have the same thing, I think part of the reason is that GO111MODULE=auto doesn't automatically do the right thing, namely: pick Go modules if go.mod is defined, otherwise use the classic way. Additionally, go get can't install new packages anymore (as opposed to adding dependencies) and I need git pull for that, is that a feature or a bug?
ccgo can translate a modified sqlite to Go. https://github.com/cznic/sqlite
Uh, isn‚Äôt most of this in the stdlib at this point? https://github.com/klauspost/compress/issues/3
Is this going to be used by ebiten?
Can we compile this to WASM and run native apps in Electron?
By that very logic the number zero should be forbidden.
Eh, really hard to say, maybe I did something incorrectly, but there's really no time to mess around with such trivial stuff (that already you know how to solve using another solution) when you're dishing out one project per week and there's a queue of clients. For now, I would recommend using https://github.com/golang/dep and keeping your project in `$GOPATH/src/github.com/path-to-your/repo`. Then run `dep ensure` after you add a new import and upload the vendors directory to the repo. There aren't that many libraries being ported to Go Modules just yet (and most of them are just single package libraries, so they work with both systems), so it's not an issue. I only struggled with golang-migrate for database migrations.
Luckily the repository has a file, appropriately named README, that answers your question: https://github.com/klauspost/compress#performance-update-2018 and https://github.com/klauspost/compress#overall-differences
You might like this... This is the jsgo playground, loading, compiling and running itself: https://play.jsgo.io/github.com/dave/play
worked perfectly, thanks :)
gonum/stat has a lot of things, for example [http://godoc.org/gonum.org/v1/gonum/stat/distuv](http://godoc.org/gonum.org/v1/gonum/stat/distuv)
See, this is why we need people to post context instead of just linking to a library. On the phone the github view is abbreviated and, last I checked, most of these changes were in. But, you are correct, there are some updates for 2018 if you paw through it. Try it without the the smarm next time.
var myFantasticID ID
So how can i assign it a value then of \`thisID\`? &amp;#x200B;
https://play.golang.org/p/3j9_E-STsiu
Alternative method: myFantasticID := ID("thisID")
var myFantasticID ID = "thisID" Or myFantasticID := ID("thisID") 
p-python..?
Also, generally avoid using context storage unless absolutely necessary.
Writing code is easy compared to maintaining code that other people have written. In C++ or Haskell, everyone creates their own weird little world. In Go, the weird little worlds look almost identical. To me, apart from the fast compilation times, this is what makes Go brilliant. Generics could easily destroy this feature.
Have you tried to read code where people use interfaces? It‚Äôs confusing af and generics would be simpler to read 
There are already direct C to WASM compilers. 
I'm looking for the more circuitous route to awful things.
Yea, u r right. 
Stackdriver is pretty great. You can tell it how to convert structured logs into metrics and graph it. Also it's one of the cheapest options I've found. I would also recommend against ELK. It can be hard to keep running, meaning it will cost you in operational costs. Go with something that is managed. Prometheus is also awesome. PromQL has a bit of a learning curve but is very powerful. It can even scrape expvar endpoints if you don't want your go apps pulling in an additional dependency.
&gt;Undoubtedly Undoubtedly is a strong word; Doesn't that depend on if **best** means... * Popular * Useful * Well written (maintainable) * Fast * etc
Darch is written in go, so I figured you guys might find it interesting.
why?
I... Don't see it? Why do you equate `nil` and zero?
Two big reasons, it's not compile time type checked, and it's not discoverable &amp;#x200B; func do(ctx context.Context) { // stuff } &amp;#x200B; In this example, it's impossible to know what arguments are required, or are optional for the function without looking at the documentation.
Sorry but there is nothing working in that repository :-) &amp;#x200B; I planned to work C programming on a VM hosted by a Go program, and I didn't plan to support other dynamic libs. &amp;#x200B;
Yes, my intention is to eliminate Cgo (at least on Windows) from Ebiten.
&gt;Well, the main use of Cgo that I see is less about header parsing and more about linking static libs. Curious how the latter will be handled. Good point. I don't plan to work on static libs. Standard libs can be implemented in Go. Other functions like Win32API would also need to be implemented on Go side.
yep but is it fine to use it when you have lots of functions that need to take the same arguments and you want to save on some effort?
Thanks for your feedback. The original draft of the article had the abstraction for the HTTP client and the time formatter.. but it would have required other refactoring steps that aren‚Äôt digestible in a single article.
There are many reasons it when context can be appropriate, and if it works for you, use it how you want. I typically would use a closure for the scenario you outline - however it's not always feasible. I use context a lot for lifecycle management of services. The other two area I've used it previously in production is: * identity management in a request, and; * nested REST interface query for example i have a route that looks like this: /assets/{assetId}/props/{propertyId}/other/{otherId} I have middle-ware for each part of the route r.Route("/assets/{assetId}", func(r chi.Router) { r.Use(h.resolveAsset()) r.Route("/props/{propertyId}", func(r chi.Router) { r.Use(h.resolveProperty()) ... by the time it reaches the request handler, all the relevant assets have been populated in the context.
&gt; when you have lots of functions that need to take the same arguments A struct could help here. It's only one additional argument for every function with an arbitrary amount of shared context information inside. It is self-documenting, compile time checkable, and readable.
Maps, slices, and channels are simple to read because their generic aspects are limited. If universal generics would be as easy, the Go team would have included them in Go 1.0 already. &gt; interface{}-ladden spaghetti code that tries to work around the lack of generics You put three different aspects into one half-sentence, which makes it hard to reason about. Let me separate them to find the underlying problems: 1. Empty interfaces: Every Go tutorial, article, blog post etc. about interfaces warns about (ab)using empty interfaces. They are required in very specific circumstances but are unnecessary in most problem spaces. 2. Spaghetti code: This is a problem between chair and keyboard. Bad programmers can write spaghetti code in any language. 3. Trying to work around the lack of generics: Again, a problem between chair and keyboard. If someone desperately wants generics-like behavior in Go, they will go great lengths to create something that makes them feel like having reached the abstraction level they think they need. I daresay that most of the interface{}-laden spaghetti code that tries to work around generics can be replaced by clear and idiomatic Go code if the developers think more carefully about their specific problem at hand rather than trying to abstract away everything.
Yes, but if you were to select only one mechanism for structuring code in a hierarchy (apart from functions and structs), `interface` is a solution that covers a lot of ground. Adding generics would add another mechanism on top of this, while also not increasing readability, maintainability and teamwork. When I say "readability", I don't mean how easy code is to read locally, looking at a single file, but in terms of how much digging that potentially must be done in order to understand the code you are looking at.
I'm new to context based go programming, it would be better if you could give a very simple snippet
Yup. Thinking about interfaces as data structures is going to be seriously confusing for newcomers especially. 
Timeouts are actually quite complicated when you start to think about their edge cases and as far as I know there is no way in go to get a function to end without the function itself deciding to do so. Any method that seem like they do this tend to just leak resources/thread in the background. &gt; If it does not complete within this period, the program will be terminated. If this is true and you only require the whole program to terminate after three seconds you can let the OS do the cleanup work and spawn a simple goroutine that sleeps for 3 seconds and then exits the program - most of the time this is not what you want though, but if it is then it is the simplest method. go func() { time.Sleep(time.Second*3) fmt.Println("Timed out") os.Exit(1) } doSomeThingSlow() If you don't want to just end your program and let the OS clean up for you then you must do this yourself. The [context](https://golang.org/pkg/context/) package gives you a time based struct that you can pass around and periodically query to see if it has expired - then when you detect it has you can get what ever function you pass it into to detect this and return. Something like: (untested) ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() doSomeThingSlow(ctx) ... func doSomeThingSlow(ctx context.Context) { loop { select { case &lt;-ctx.Done(): fmt.Println("Timed out") return default: } // do something useful } } Most slow stdlib functions now accept a context to allow them to timeout and quite often you can propagate the context of your function to them if desired. Note, there are quite a few example out there with timeouts outside the function started by a goroutine. But none of these stop the function in question, all they do is allow the calling goroutine to continue and ignore the response from the function - the function is still running in the background and if you do this multiple times with heavy functions or functions that might deadlock then you will leak resources over time.
There are quite a few problems with this example, - The work is not interrupted and so continues in the background - You leak a channel that blocks forever - You leak a goroutine that will sleep forever If you add a println and delay that the end this shows the processing continuing: https://play.golang.org/p/T9gAO6g_6lw and if you save the channel to a variable and read off it again you can get the returned value. This is not a good way to deal with timeouts and instead you should use the [context](https://golang.org/pkg/context/) package and handle the timeout internal to the function. Sure in this contrived example all these will be cleaned up by the OS once the main process exits, but in more real world workloads this can cause huge problems and so should be avoided.
Hi there, In these cases I would usually do three things. First look up what the status code is supposed to mean: https://httpstatuses.com/409 Next, check the documentation of the API you are consuming (if any). Many APIs are not exactly standard conform on these (and to be fair, some codes/cases are simply very ambiguous), so as the last step I would try to look at the response myself. Don't try to decode it, just print out the raw text. Absolutely no error handling considered here: response, _ := http.Get("http://ifconfig.me/ip") io.Copy(os.Stdout, response.Body) 
But according to his question, time.sleep with select is the right answer
[removed]
[removed]
``` func DoWithTimeout(timeout time.Duration, doFunc func()) { select { case &lt;-time.After(timeout): break default: doFunc() return } // timeout handling panic("did not complete operation") } ``` By changing the signature of `doFunc` you can pass any function in.
I did, in a top level comment.
No, not really. "An HTTP server that proxies all requests to other HTTP servers and this servers caches all incoming responses objects" would be a caching forwarding proxy. You could (probably) get nginx to do that somehow (at least for non-HTTPS targets, not sure if nginx supports CONNECT), but there are tools much better suited for this kind of use case, e.g. something like squid. 
There exist situations when running a separate process is not possible (e.g., cloud foundry).
Kubernetes? You are trying to make a PUT with an object but the "current" version you are presenting in your change is stale and someone else has already make a change and the version has been updated. You need to refetch the object as you may not have current state. Chances are you and another process are in a race condition to mutate the object. 
https://github.com/andlabs/ui/blob/master/examples/controlgallery.go awesomeness! thanks!
Qt has go bindings as well I think?
&gt; electron app. Any input on this? Electron is really for webdevs who don't know and won't learn a language other than JS. If you're not scared of native development, which I'd hope a Go programmer isn't, it's pretty trivial to whip up a native window with a WebKit (or MS equiv) component in it to serve as the HTML frontend to a Go program. It'll use a few MB RAM and disk space instead of the hundreds Electron uses.
All of them.
My initial response would be: You don't. A slightly more constructive response would be that you could write a small code generator and call it using go generate.
I agree, that's not the point of the interface at all.
I guess I'm not exactly in proper mindset here... So, after some searching I implemented a stack that could take any variable type. Basically something like this: type ( AbsStack struct { top *node length int } node struct { value interface{} prev *node } ) I have all the methods implemented in this AbsStack structure which takes `interface{}` as parameter types. &amp;#x200B; My initial thought is if I could use this abs type to derive `floatStack` and `stringStack` . In traditional OO mindset it doesn't seem too difficult but I found it a little intuitive for me to figure it out how to do that in GO... Maybe I should change the way I think when playing with GO?
Yes, `AbsStack` looks okay to me. You can now cast-check `value` or use ‚Äúreflect.TypeOf‚Äù [1]. [1] https://gist.github.com/marz619/a0e6d3884a4d0d271ddb89ab76368690
Inspiration: https://github.com/robpike/ivy
Whatever floats your boat mate. Personally I like the idea of having html/css/JS as front end since it's a well developed framework and ressources for it are almost unlimited. I must agree though that it would be nicer to have a native way to build UI with go. 
You can try to add functionality from here: [https://github.com/lydell/json-stringify-pretty-compact](https://github.com/lydell/json-stringify-pretty-compact). I often use pretty compact
&gt; Personally I like the idea of having html/css/JS as front end since it's a well developed framework and ressources for it are almost unlimited That's *exactly* what I was talking about. Only using the native engines that are included with any modern OS instead of bundling an entire browser with your app. You still get to use web tech to build the UI, just without the massive overhead of Electron.
I don't think you quite know what a CLI is. Cobra is cool and simplifies a design pattern for CLI tools, but it alone is not a CLI. Power Shell, Bash, Korn, Z, etc. Those are CLIs. 
Thanks it worked
I'm trying to collect some best practices on developing applications using Golang ranging from architecture, package structure to some operational details (like using Prometheus and Jaeger for instrumentation). &amp;#x200B; I already includes quite a few things, but I thought it's time to share it. :) (Hint: it's probably worth checking pull requests/commits to see how and what changed over time as I tried some things)
[removed]
mdaffin has a great explanation comment at the top. Thanks man
Instead of thinking of it as polymorphic behavior, think of it as removing unnecessary restrictions and dependencies. 
Happy birthday to golang
Nice boilerplate but you should switch to go modules for your dependencies instead of dep and maybe include a web framework like echo ?
&gt; html/template what do you mean? 
&gt; github.com/CloudyKit/jet, JINJA2 !
Look at the docs. Specifically reader and writer interface. https://medium.com/golangspec/interfaces-in-go-part-iii-61f5e7c52fb5 https://research.swtch.com/interfaces https://www.golang-book.com/books/intro/9 https://www.youtube.com/watch?v=83J256zByHA https://github.com/golang/go/wiki/CodeReviewComments#interfaces https://play.golang.org/p/pv7o3G32I1 https://itnext.io/interfaces-in-golang-f1aea1ba31cb https://medium.com/@matryer/golang-advent-calendar-day-seventeen-io-reader-in-depth-6f744bb4320b http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go 
oh, right. I misunderstood the title/description, it's rather convoluted. it indeed is a caching forward proxy.
Interesting, I've never tried to figure out to plot a lat/lng coordinate system onto an image. With the cost of mapbox / google maps this could be very useful. https://github.com/asgaines/glocplot/blob/master/conversions/math.go
Thanks! Have you tried it out on your location history? Assuming you've also sold your soul to Google for some location services ;)
Good news for companies that are hiring programmers with "10 years experience in Go" -- only 1 year left until they start finding honest developers! ;)
Use the `{{ block "name" . }}` command. 
Really like Go. Congrats on ten years.
Can you trust packages from anyone?
[removed]
It also made me a much better engineer by following the Go way of doing things and actually \_thinking\_ about different ways of doing things.
I couldn't find a Go persistent queue that had a storage engine customized for the job, so I wrote one.
Through the marvels of open source the code is out there for you to review before using. A general rule of thumb is you should never use external code without reviewing it in any commercial or otherwise critical program. The origin country is irrelevant.
The term "custom storage engine" probably overstated what it is. It is just set of files that get appended to and then eventually deleted as items are dequeued. Using a key-value store for a persistent queue, for example, probably isn't going to be very efficient, and it's going to have more complexity. The simplest solution possible is better in my opinion.
if i wanted to display on the object within the array that had a boolean set as true, how would i do that? 
So... Varnish? 
It doesn't look like you ever call anything that will fsync your data to disk. This will probably lose data in the face of power loss. If you don't fsync, you're data has only been transferred to the kernel to eventually be written. Only once it's fsync'd is it actually on disk. And even then some hardware lies and can be iffy, though any decent drive ought to get those final promised writes down after power is cut. Wait, is this opening and closing the files on every single addition and removal? oh wow. lol. This may work so long as it never hits power failure, but it's going to be very slow. Congrats on getting something working that does what you need though. You'll learn a lot as you hit the limitations of your current implementation and get forced to re-architect as you learn more about the underlying system. 
Yes, it could be improved if I keep the file open. Thanks for the suggestion.
Copy-paste. Do not import this. 
I use interfaces a lot to abstract my dependencies. Interfaces are the "language" of my application. The business logic never calls a dependency directly, rather it just uses the interface. I implement the interfaces using the dependency. E.g data storage may use files, SQL DB or a document store. But my application logic doesn't care about the details, it just calls the Load()/Store() methods on the interface. At initialisation time I inject the required implementations into the application. Let's say I was storing data to flat files but requirements change and we need to use store remotely on an object store. Wet just implement the interface with the new technology and inject the new dependency instead of the deprecated one. This approach helps with testing as well. We can create mock implementations of the interfaces to test the application logic. It may sound silly but I make interfaces for almost every dependency: logging, http, you name it. If I want to change logging providers I just code the new implementation and plug it in...no changes to application code required.
You would just add the members of the struct to your template. They're just presented as text. {{range .}} {{ .ReservedBy }} {{ .IsReserved }} {{ .IsPurchased }} {{end}} I made a playground for you here to look at how it can work. [https://play.golang.org/p/uccQ9SjfYQN](https://play.golang.org/p/uccQ9SjfYQN) I recommend you look at the documentation for [text/template](https://godoc.org/text/template), contains good examples. 
&gt;So overall, of course for example Rust and D are objectively more advanced or even better languages than Go, but I have discovered that Go makes me write more maintainable code I agree with this block 100% - Go is obviously not the most advanced language - but that's the whole point. Go lacks features that do not add enough value to warrant their potential risk. The "top of the top" may be slightly/significantly worse in quality or functionality than languages like Haskell or Rust, but in pretty much every other case I think Go is a better choice. &amp;#x200B;
Does it look like code duplication ? :)
Forgive my ignorance, what's the use case for this?
So‚Ä¶ Squid?
There are a few current and former Googlers with over 10 years of Go experience now. Not a ton, but some.
&gt;Does it look like code duplication ? :) Does it look like code duplication? :)
map and filter are essentially abstractions. These abstractions are very clear to those who have practiced some modicum of functional programming and do make for terse code. However, when dealing with brand new programmers, they can struggle with these abstractions as it requires reasoning about collections from a higher level viewpoint. When you have a larger team consisting of programmers of varied skill levels, it can be helpful to stick to fundamentals.
If you're using a language where it's idiomatic to use `map` and `filter` and so on, you'd certainly hope that any programmer who claims to be familiar with that language understands how they work
As it was said before, read the source code. It‚Äôs good for you anyway. Then just copy paste out what you need. 
Not as all, thanks for the comment. At the most basic a distributed lock is necessary to ensure only one process (or instance of a program) can perform a particular action. An example could be something as simple as multiple processes modifying a shared file in an object store like S3. For my own use case, I started thinking about this after writing a lightweight monitoring and DNS failover agent. I wanted to be able to deploy many of these monitoring agents anywhere so a shared queue or backend datastore was not ideal. However, the cluster of agents still needed some means of coordination. Specifically, I didn't want many of the agents trying to update DNS at the same time. With a distributed lock this task could be serialized so only one agent will check DNS and, if necessary, update at a time. Hope that helps clarify some of the motivation. Its a bit of a special case, but I suspect many use cases would be.
I was at Google Sydney when Rob would come down for the summers. Nigel started working on Go (I think?) after Wave was shutdown, and (if I‚Äôm recalling correctly) someone sent a mail around informing eng-syd of a new language we could try out. It might have been just before public release though, so possibly still 9 years.
Came here to say this. jq is an amazing tool that can do amazing things. It should be a POSIX standard IMHO.
Spend enough time on /r/programmingcirclejerk and you'll end up in /r/foreskin_restoration/
Doesn't Kotlin have lazy streams anyway? Multiple `.map`s and `.filters` get fused so the final `.toList` only traverses the collection once. This is a weird criticism. 
I would. However, I've also worked with some very green programmers. 
Exactly. I had a junior developer in my team once say .. let‚Äôs not use very Kotliny specific constructs and functions because it‚Äôs difficult to understand. This was in a Kotlin backend. Why use Kotlin then at all? Never had I wanted to move out of a client project as fast as I did when I worked with that particular guy. 
Nine years, still no sandbox/pinning of Go dev tools :(
&gt; `data.map { it -&gt;; Pair(it.first(), foobar(it.second()) }.filter { faz -&gt; faz.second() &gt; baz }` This example is bad. Writing stuff that way can make anything look confusing. You should really [read this link.](https://vector-of-bool.github.io/2018/10/31/become-perl.html) At a minimum, you should format it properly: data.map { it -&gt; Pair(it.first, foobar(it.second)) }.filter { it -&gt; it.second &gt; baz } But, no one should use such terrible variable names in practice, which is why the article I linked to is so important. Please, read the whole thing.
One way to think about it is you are definitely (or at least highly likely) not the the most security-aware person who uses those packages. And if those people who are more concerned and cautious have decided to use those packages, you can probably use it too. Plus it‚Äôs open sourced so there will be people reading through their code constantly to check if there‚Äôs loopholes. It‚Äôs really not about if they are Chinese made or not, political climate is the same bad everywhere if you think about it.
This. Misusing features, does not make them bad.
I really like easy cross-compilation and the fact that a lot of the basic stuff is build into the standard library. What I really hate about Go is huge binaries with a lot of RTTI in it. And the lack of some basic for other programming languages stuff like generics and exceptions.
You just perfectly described why I personally have only dabbled in Go and haven‚Äôt dived in deeper into the language.
Almost. The pipelining uses different hard to read syntax.
The article starts quite well, but when it reaches "Disadvantages", falls on its face. In "Lack of Frameworks" it states there is no major framework for Go. The "major framework" is not defined, but from the examples we can assume author means rich web frameworks and those do exist for Go. In "Error Handling" author claims error handling in Go is bad and there are tools for error stacking, but it's a workaround. No mention about "errors" package, that does exactly what author was looking for. Also, error handling by return value is considered a disadvantage, despite the fact it is the same idea as in C and similarity to C is mentioned as an advantage couple of paragraphs earlier. In "Package management" author complaints about inability to define package with version in project dependencies, what was fixed with Go modules in 1.11 (article was created on 2018-11-10). 
I was completely open to accepting disadvantages if they are valid. But I don't understand the "lack of framework" complaint. First off, is it suggesting that a language needs a framework to be considered useful, as a blanket statement? Also, what kind of framework? The examples given suggest web frameworks. Regardless of their value, Go does in fact have framework options, albeit no blessed "rails" framework. And the part about package management... Am I missing something about Gemfiles or does Go not have the equivalent with module go.sum files and the lock files of the earlier package managers? If you wanted reproducible exact versions, you have had that ability for a while. 
Hi again. To be clear, interpreted does not mean dynamic typing. 
Why is this not popular compared to Logrus?
We have very data-processing/number-cruching heavy applications, so there are a lot of instances where a quick map or filter is just begging to be added.
&gt; graceful reload (using github.com/cloudflare/tableflip) and shutdown Don't you mean graceful restart? Because just reloading can be done trivially without the need of "frameworks, that don't add any value". 
Of course all the variable and method names were faux. But since the code I work on is doing a lot of data processing we also have a lot of iterators. Especially if prototyping or in a hurry. And often those iterators are modified later to do more things, which reduces readability. I am not saying that those languages or features are bad in any way, I actually really like Kotlin, but the features made me be lazy and write less readable code than I would have liked. If I were a perfect software engineer I wouldn't care which language I am using and I wouldn't have written this post, because I would use every language the way it is intended with perfect clarity, but alas, it is not so.
Right, it's restart for the moment, but Viper supports triggering events upon config change for example, so yeah, reloading can be trivial. I don't see though how any of that has anything to do with frameworks.
I could tell this came from pcj from a mile ago... https://old.reddit.com/r/programmingcirclejerk/comments/9vy7er/go_taught_me_what_good_software_engineering_looks/
Is `glog` not cross platform?
I could tell this obnoxious joke came from pcj from a mile away... https://old.reddit.com/r/programmingcirclejerk/comments/9vy7er/go_taught_me_what_good_software_engineering_looks/
&gt; but if we have generics Go will become another language where I do (in pseudo Kotlin): &gt; data.map { it -&gt;; Pair(it.first(), foobar(it.second()) }.filter { faz -&gt; faz.second() &gt; baz }And that is exactly what made me write subpar code in the existing languages. not_sure_if_retarded.jpg
What's the original?
For simple dialogs or file selection you can use https://github.com/gen2brain/dlgs , no cgo, but on Linux you need to install zenity or qarma.
Both have the same features more or less, except one was here before the other. It's not because google made it that it's necessarily better.
This doesn't look tremendously feature rich, and it might not be ideal for microservices where something like zap, or logrus may be more appropriate.
&gt;The business logic never calls a dependency directly, rather it just uses the interface. What is the benefit of it?
How does interface do that? Sorry for my noob question
You mention that Go can be a great language for scripting? Could you expand on this? I like to write Python code for something that needs to be done quickly and possibly only used a handful of times. In what ways would Go be superior in this situation?
Well it is better for a subset of scripting tasks. In my case I often process data in long-running scripts. The issue with Python is that it will often fail due to a typo late into the running of the script. A compiled language is better for this. But if you do short scripts that have a short run time and you have 100% code coverage in every run then Python would probably be the superior choice.
Go noob here. Can you tell me what `runtime.LockOSThread()` does in main.go?
You can write bad code with advanced features. That does not, however, make them bad. And making you do more work is generally a bad thing. One of the main problems I have with Go, though, is that *readability doesn't mean you can understand the code*. Sure, at first glance "oh, a for loop" seems a bit clearer than "a call to this map and filter thing, what are they" but that map/filter version is a lot more declarative, so once you read the documentation for them you can actually understand what the code is doing *at a high level* instead of getting bogged down in details. Due to Go's ridiculous lack of things like generic types (except for channels, slices and maps...), it's impossible to make fully reusable abstractions which may be at first harder to read, but make it much easier to know what's going on. Here's an example: in JavaScript, there's a function called `Promise.all` which takes an array of promises (asynchronous tasks) and returns a promise containing the results for all those promises - this is useful for when you want to, for example, fetch several pages in parallel and do something with the results. In Go, *you cannot write this*. The type system cannot express a function doing this (without `interface{}` which adds a lot of boilerplate and destroys type-safety). Instead, you have to do it the long way - make a for loop spawning all the tasks, have them write to an array (slice...) and then wait for them all to finish, bloating your code with logic which you shouldn't really have to repeat but which you're forced to. There's also the error handling. I completely agree with errors-as-return-values, but Go handles it horribly. Due to, again, its weak type system, you can't have something like `Result&lt;T, E&gt;` or `Option&lt;T&gt;` as in Rust, so you have to return two values and have one of them be `nil`. There's nothing requiring that you check for `nil` as there would be for a `Result` and your code is filled with `if err != nil { return err }` everywhere a function might fail. This criticism could also apply to Rust-style `Result`, but they saw the need for making your code focus on what it does and not how, instead of sacrificing convenience for a "simpler language", and added an operator which does roughly the same thing as `if err != nil { return err }` would (in the `Result` style instead, though), so you can just write that, making your code clearer and shorter. This brings me on to the *second* issue: the division between the language authors and users. Go does have generic types. Clearly, they're not "impossible to implement nicely" as has been said. It's just that nobody but the language authors can define them. And there are `make` and `new` and `range` and all that which are magic and can't work on user-defined types. And channels get dedicated syntax for some reason, which third-party code can't define or interoperate with. Also, there's the dependency management, which either involves "vendoring", including all the third-party code you use with your source, or having everything break constantly because it's all pulled down from the latest available version on Git.
&gt; This approach helps with testing as well. We can create mock implementations of the interfaces to test the application logic. And the bigger a project gets the more benefits you get out of tests.
I am in the habit of writing good comments. A comment before a for loop makes more sense 6 months down the line than writing a comment for a chain of function calls over the data. This is not absolute, but this is how I mostly feel. Also I wouldn't have implemented anything in Go without the new version pinning feature.
The reason you weren't finding other options is that graphics vendors don't write drivers for other languages. Every single language that exists needs to call into an os or gui framework DLL or compile against C or C++. You can do it pretty efficiently in a lot of languages, and Go is okay at it, but since Go has better threading, the compatibility with C takes a little more work. That's why people recommend avoiding cgo. But it doesn't apply for guis unless you prefer to call into shared objects, which isn't more portable / simpler bit can be preferred sometimes. Overall it's basically the same thing. Just don't worry about it.
that won't work &amp;#x200B; how would I specify a place \*in the middle\* of the master page where the content of a children page will be insterted?
I didn't ask about something that's almost
That seems pretty subjective, but I at least would struggle to understand what a complex for loop was doing more than some maps, filters and reduces.
[removed]
I do think, though, that a decent language should at least *leave you the option*.
https://godoc.org/text/template#example-Template--Block
bounds to the main thread
You send "test1" to the channel, then in the loop, you pull "test1" out of the channel - it's gone from the channel once read, which is why it is only printed once. Reading from a channel is a blocking operation, so your program sits on the channel read until you send a new value that can be read ("test2").
Thanks for the suggestions, I will take a look at these libraries. &gt; Just as a warning, this is not java. This is not object oriented and if you try to go in with the complexity java creates you will have no fun times. I think this is why I'm looking at another language, even if I don't know it yet. I've implemented a similar rest client script in a scripting language which takes 50 LoC for the whole thing. &gt; Also just to make sure: The whole project could also be done 90% without any "framework" and still be small, easily readable and totally fine. I know, but it will be extended in the future into something more complex, so a framework will help. To avoid any large issues, I'm trying to just create the client side in Go (I've already started using net/http or Resty - which produces a 6mb binary), then decide if I can take the risk to do it in a language where I'm not very experienced with.
I wish they had added stuff like error levels to the existing log package.
You can write this in basically any language. I don't think working with unstructured XML is particularly fun in Go, but that might not be a problem here. From an engineering perspective, I'd probably write what you want in a scripting language (JavaScript or Python) because the requirements you've shared don't really require Go's strengths.
*Calls to map/filter aren't complex* compared to repeating a for loop everywhere.
With `nil` "effectively all operations" is more appropriate. As a part of the language it introduces a whole class of errors which otherwise wouldn't exist. Zero is a member of *sound* types, which for some operations results in a singularity. \`nil\` errors OTOH are present with \_any\_ operation associated with the value. There's a reason it's nicknamed ["The Billion Dollar Mistake"](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare).
Lets say you have a type A that can do x and y, and you have a function that needs to do x. Using an interface that only includes x as input to the function is a better description of what the function does then type A.
\`net/http\`
Do you find it easier to read deeply nested loops and conditionals rather than chained higher order functions that perform stream fusion?
+1 for using logrus 
Well, I know basic Javascript and Python, but I have no desire to be deeply involved with any of them. I was looking at Go as a better alternative.
Because microservices ain't got no time for no loggin'! Not do they have the room
`net/http` and `template/html`.
Why would that matter? The only people who demand cross platform software also hate and refuse to use Windows and macOS, and are too dumb to use FreeBSD
Personally I think it's an innocuous argument, however I do like both approaches and still find the simplicity of Go to be quite elegant in comparison. Kotlin is a huge improvement over the wordiness of Java which I feel stems from the fact that Java is already overloaded with boilerplate and papered over complexity.
Hmm, crypto usage aside (there is fix for your TODO is to use for with `|=` and then use constant time compare byte from subtle package), you should really propagate errors using return. I'm unsure about prefixing function names with dg* either - what purpose does it serves? 
Well you‚Äôre asking about a Python templating system. You aren‚Äôt likely to find an exact match to Jinja.
Reddit: readdit question carefully
You ask if the worst case Go or best case alternative is better? Not a fair comparison. In my experience I get best case Go code more often that best case alternative language code.
This is very interesting: *DiskGem currently is not available natively on Windows due to cmd.exe not supporting unicode, 256-color or emojis*. Why a program for secure file transfers requires 256-color output and emojis? Most of the Unix terminals don't support 256-color palette, so your program is not operating-system-specific, but terminal-specific. AFAIR only 2 Linux terminal types have this feature and a) they are not used by default in most distributions, b) they are only available in graphical emulators. Besides, underneath `gocui` is `termbox-go`, which uses terminfo database, so your program should work even on monochrome terminal, where color mode changes are simply ignored. BTW, if it looks like on a picture, it's not "command-line UI". It's TUI (Text User Interface). CLI is a different thing.
I'm not sure where this best case / worst case came from. Higher order function chaining is idiomatic in Kotlin, and isn't a "base case scenario". It very rarely breaks down, and if it does, it does in the way you describe (many many chained functions that don't impact performance but may impact readability). As for Go, if nested loops and conditions are worst case, what's the best case in Go? Can you give me an example? What would it's equivalent look like in Kotlin?
From the README it just looked like it was more geared at logging to system logs, not just to stdout (though it would be supported of course, by using the io.Writer support). I suppose it does have log levels still and all the usual stuff! Nonetheless, Zap and Logrus are well cemented for a reason - good docs, lots of features, and in Zap's case, good performance too (switching from Logrus to Zap actually made a startling difference in an couple of apps I've worked on that are quite noisy in terms of logging).
&gt; LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated. &gt; &gt; All init functions are run on the startup thread. Calling LockOSThread from an init function will cause the main function to be invoked on that thread. &gt; &gt; A goroutine should call LockOSThread before calling OS services or non-Go library functions that depend on per-thread state. &gt; &gt; From: https://golang.org/pkg/runtime/#LockOSThread
That's really great. Can you share some more best practices that makes code more professional and production ready?
As usually, it would be cool if you'd drop a line or two right there into the announcement about what Darch really is and not require me and everyone else to click through two web sites. 
I work in a mostly Java shop and have had incredibly difficulty in convincing very good Java devs that Go is a good alternative to Java. Luckily for me, Oracle is helping a little bit. For the problem you describe, I have a hard time seeing how Go would be better than gradual typing with typescript (except, as you've said, you just want to learn Go).
If you don't want line buffering, you need to turn it off. http://www.linusakesson.net/programming/tty/
&gt; With nil "effectively all operations" is more appropriate. Comparison is fine and very useful. &gt; Zero is a member of sound types And nil is a sound and useful value of any pointer type. &gt; There's a reason it's nicknamed "The Billion Dollar Mistake". By the author. You cannot actually get effectively rid of a nil or some equivalent sentinel value in a language with pointers. After all, a pointer _is_ a number, so I insist on the zero analogy. Integer division by zero and nil dereference are in the same category.
[removed]
&gt; then decide if I can take the risk to do everything in a language where I'm not very experienced with. You will have no problem picking this up. Based on what you described, golang is ideal and also far simpler to implement this kind of program than Java IMHO. 
This is great. This is something I‚Äôve wanted to do since I released ‚Äúexpress-vue‚Äù 
For what it's worth, the *real* challenges come from changing membership lists.
This isn't a product announcement. Should I describe Darch in every blog post I ever write? Or is it enough to link to godarch.com where the description is front-and-center?
this sounds like a perfect use case for go -- it has a similar use case to java. you should be able to do this with minimal dependencies.
&gt; Should I describe Darch in every blog post I ever write? I was talking about this your Reddit post specifically and nothing else. My point is that you do not appear to grasp that random people (even those who lurk in a particular place such as r/golang for long enough) do not share the context your have in your head with you, and consequently they do not know what "Darch" really is. So here we go: I stumble upon a Post in a subreddit I follow; the post is titled ¬´Give Ubuntu/Darch a quick ride in a virtual machine.¬ª and consists of a link to an external resource. OK, so I go like ¬´WTF is that "Ubuntu/Darch" think even is?!¬ª and start to spend time skimming through the linked wall of text, and then through another ‚Äî linked from there. That's all to actually learn what that "Darch" think is. What I'm asking for, is to have a single short sentence here in a Reddit post which would tell anyone what "Darch" is. Just to illustrate, look at [Debian's security announcements](https://www.debian.org/security/#DSAS). Take [this one](https://www.debian.org/security/2018/dsa-4329) for example. It's for some piece of software called "Teeworlds". The announcements spends exactly seven words to give the readers full understanding about what that thing really is. No, really, it's _that_ simple. 
a tty usually defaults to line edit mode. You need to find a way to put it into raw mode before starting your reads. some bg on tty: http://www.linusakesson.net/programming/tty/ Maybe as simple as this tiny lib: https://github.com/creack/termios You can read more about this in the "Canonical mode" section of the termios(3) manpage. 
I think it would be very hard for a language to have pointers and not have nil pointers. I might be wrong though. Are you aware of any such languages ? I would be curious to learn about them.
That's it. Comments are lies since computer executes code not comments. 
You may need to learn the basics of networking instead. I guess you are talking about two devices behind an IPv4 NAT, so their IPs are only private and can't be directly contacted from the Internet. The issue is at the network layer, not the transport layer (TCP) or the application layer (HTTP, which uses TCP by the way). You will need to have at least one process accessible from a public IP, typically the server if it's a client/server architecture.
Like /u/bemend wrote I think your question hints at a lack of knowledge about how network communication work in general, and more specifically how a NAT router works, so I‚Äôd follow his advice and read up on the basics and specifics first. Once you have a bit more insight you might consider implementing something like [NAT hole punching](https://en.m.wikipedia.org/wiki/Hole_punching_(networking)) to do what you want, but it will definitely require a 3rd party beside the two peers to get any direct communication working (unless you can use IPv6 as mentioned). But don‚Äôt let a lack if knowledge bring you down however! We are all beginners at some point, so keep it up and you‚Äôll get there. God speed, and good luck!
Hi ChristophBerge, &amp;#x200B; First of all, thank you so much for you reply. &amp;#x200B; I referred to things like iterating over the arrays, sort arrays and missing operations from other programming languages such as map or reduce, How many times we need to implement it? We often write loops just for calculate a value produced by the list of elements or even for filtering the records in the array... this would not be required anymore if we use Koazee. Beside of this, Koazee takes advantage of reflection and provide us a "generic" interface that we can use for operating with any time of arrays. &amp;#x200B; On the other hand we can define stream (or arrays) flows and evaluate them when they0re required, inspired by lazy evaluation. For example, if we need implement the below code we could be required to write much more code and this would not be as clean as it (from my opinion) &amp;#x200B; *package main* *import (* *"fmt"* *"github.com/wesovilabs/koazee"* *"strings"* *)* *var lenLowerThan6 = func(val string) bool { return len(val) &lt;= 6 }* *var concatStrings = func(acc, val string) string {* *if len(acc) == 0 {* *return val* *}* *return fmt.Sprintf("%s %s", acc, val)* *}* *var concatStringsWitDash = func(acc, val string) string {* *if len(acc) == 0 {* *return val* *}* *return fmt.Sprintf("%s-%s", acc, val)* *}* *var streamFlow = koazee.* *Stream().* *RemoveDuplicates().* *Filter(lenLowerThan6).* *Map(strings.ToUpper)* *func main() {* *array := \[\]string{"koazee", "telescope", "is", "fucking", "so", "great"}* *fmt.Println(streamFlow.With(array).Reduce(concatStrings).String())* *fmt.Println(streamFlow.With(array).Reduce(concatStringsWitDash).String())* *}* &amp;#x200B; &amp;#x200B;
It is a technical reason. Protecting IP is a stakeholder requirement, code obfuscation is a technical solution for that requirement, WASM is an effective method of obfuscation.
I want to emphasize that It's definitely not easy, but Rust permits "pointers" for different purposes that cannot be initialized to null: * `&amp;a`, a reference with with a lifetime guaranteed at compile-time. If you have a live reference to something, that something cannot be de-allocated. * `Box&lt;T&gt;`, single owner pointers. * `Rc&lt;T&gt;`, multi-owner smart pointers which are reference counted. In Rust we can can model uninitialized values with [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html). But custom zero variants are also common.
Thanks for your wisdom, knome. I wasn't aware that closing a file doesn't actually flush it to disk. I decided to keep the file open and sync after each write. The performance is still a little faster and (\~.35ms - .4ms per enqueue or dequeue to SSD) and it's safer than batching up writes which would involve a period of time in which data loss could occur. If it's a short enough time batching would likely be acceptable, but I'll leave that for another time or person. If you are interested in taking a crack at speeding it up further, I'd welcome your input. Or if you wanted to take the project further I'd be willing to add a link to your implementation for people who want super fast speeds. I like what I've done, but not sure I want to take it a whole lot farther.
This can be done without much effort in any language with zero libraries. I would recommend simply trying it for yourself next time as there is no "best" language for you to use, it is all subjective. That way you will get a better understanding of what you enjoy working with.
That comment isn't helpful. What are these plentiful techniques that can connected one NATted computer to another without a third party being involved?
They are STUN/TURN/ICE, they are used by the most popular p2p technologies like BitTorrent and WebRTC, and no-one said you weren't allowed to introduce a third party.
Each of those require a third party server. /u/bemend said: &gt; You will need to have at least one process accessible from a public IP Which is the STUN/TURN/ICE server that initiates the handshake.
Your business logic should only worry about business logic. Whether a record comes from a flat file or SQL doesn't matter... that's an implementation detail that your business code shouldn't have to worry about. If you change a dependency you shouldn't have to worry about the business code being affected in a few hundred places. You just make sure the new DB implementation is solid. Another benefit is that you can create mock implementations of your interfaces for testing. You can test your entire application without having to worry if the DB is available and in a specific state. You can also test your DB implementation independently of the business code! The benefits of this keep increasing add your codebase grows in size and complexity. Also, use this approach for your libraries. If you need to do some logging, create a simple Logger interface and use this whenever you need to log. Most logger implementations have the same function names so if you use them in your interface you should be able to drop almost any logger in to your code. Imagen: not being tied to a logger package! Do a Google search on golang clean architecture. There are some great articles that explain it in more detail. Once I adopted clean my code had become so much easier to write and maintain.
/u/bemend's answer was fantastically unhelpful, because it presented p2p connections behind NAT as a logical impossibility, which they are not, and failed to mention the way to achieve them, which is STUN/TURN, either because /u/bemend is ignorant of th lem or because they don't want OP to actually solve their problem.
But they did say it was possible as long as you have at least one process accessible from a public IP. In point of fact, the OP *did* say that they just have two computers they want to connect together, which sounds incredibly like an implication that they have no other servers to connect together.
Here's an article that changed my thinking (for the better) and made me a much better software engineer. Take particular note of the stuff about domain types and services https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 Also very useful: https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091 And an explanation of clean architecture in go (there may be better ones out there) : https://medium.com/@hatajoe/clean-architecture-in-go-4030f11ec1b1
https://godoc.org/github.com/chanwit/vuego 
A generic typescript to Go WASM transpiler would be nice...
As far as I know go mod is backwards compatible and not using go mod is forwards compatible so that should not be introducing any problems here. Your problems are all to do with renaming the package in a backward compatible way. I am not sure that is easily possible. You may consider forking the package instead of renaming it and leaving the old one up for existing projects while encouraging new users to use the new import paths. Then you either need to keep the versions in sync or drop support for the old one and get everyone that is using your package to update the import URL to receive new features and fixes.
So is minification 
Chist you're paranoid. If OP already had a third device with a public IP they'd already have used it (at least that was my understanding).
why a link to the 2-year old article?
well, somehow I've been able to find it in other languages
Fair enough, that answers it pretty well. 
Okay. I feel like I'm leading you astray. Your current implementation won't lose any data so long as you don't kill the VM or cut power to the box it's running on. Once data is written to the file it ends up in the kernel write buffers awaiting the kernel deciding to actually push it down onto the disk. When you call fsync, you're asking the kernel to stop waiting for more information and write it now ( it wants to write in full pages usually, so it will keep things in kernel RAM until they're ready ), and you're asking the kernel to let you know when it's done, so fsync blocks until all the pending writes on the given file descriptor have gone through to disk. Since it takes a while for data to be physically written to the medium, this call will block here waiting. So it's not uncommon to make a bunch of writes to a file, filling the kernel write buffers with all the information you want in the file, and then to fsync it down onto the disk. That's what I meant by caching, yes. But then you have to deal with how do you tell when you got a partial write, etc. Transactional information is pretty hard. If you ignore being power-cut safe, then you can just write to the file and read from it as you are ( though not closing the file will still be a big win ) and ignore fsync completely, with the caveat that the file may be in an inconsistent state after a hard reboot. It's not an easy problem, and a lot of persistent file stores go to a lot of trouble to get things right. So, if you're not worried about the persistent segments surviving a power cut, don't worry about it. Just understand that's a failure state you don't handle, and that you might need to clean up and refill the queue from a source that does care should a power failure hit. I hope some of that makes sense : )
[removed]
[removed]
&gt;I hope some of that makes sense : ) It makes sense, and I am starting to understand about transactional information being pretty hard. But you've got me thinking about how to make it faster when you know that you need to enqueue/dequeue a bunch of stuff. So, as a test, I removed both the fsync and the close as you suggested and the benchmark for each operation takes 1/10th of the time. I'll see if I can figure out how to keep it easy and safe for normal use, but allow "turbo mode" for people who are willing to accept the possibility of a power cut losing some data in exchange for speed. Thanks for sticking with me and explaining in more detail.
I 100% agree with you. Monads and higher order functions should be taught alongside data structures. For whatever reason, they aren't even introduced in most colleges unless you take a course using a functional language. I prefer map and filter -- but I know from experience that the US school system does a poor job of teaching algebraic fundamentals -- let alone functional programming. There's nothing in Go preventing the usage of map and filter, and I have certainly written a few of my own. But I appreciate the 'one right way to do things' policy that has been applied to the core of the language. Asking "how do I loop over a collection" should rarely be answered with "well...that depends".
Because they say it is used in production in DO. But yeah, if the feature you want is missing then I guess there's no choice.
The Go tool has hard coded support for gopkg.in. Maybe you can change to using that for v3?
I could second net/http too If you need fast productivity, check Echo, it is great for centralized error handling and avoid some boilerplate (streaming, marshaling,..) You would want to check gobuffalo too 
&gt; As far as I know go mod is backwards compatible Does this also apply for versions &gt; 1.x? (Because of the change of the import path from 2.0 onwards)
Thank you for your detailed reply. I do see that the Koazee API can result in quite concise code compared to classic looping. My point is that while classic array operations are more verbose, I would not see them as a hassle. Maybe it depends on what one is used to.
I have not read about that one yet. Honestly are there any concrete plans for 2 yet@ most of what I have read is very interesting but mostly wishful thinking and early stage planning. As of yet I have no clue what the plans are for keeping backwards compatibility with go 1.x libraries which if they don't do it will cause a split in the community like every other language that has done this.
May I also suggest Crystal programming along with Golang because it is very concise syntax and less LOC to code and as fast as C. I learn both Golang and Crystal at the same time.
Read the first two sentences again. I answered your 2 questions. You asked for a recommendation / opinion. Recommendations / opinions are subjective, therefore don't have to be limited to Golang
I tried to read the project's README. Did I understand correctly that the project is about generating some JS lump from the Go source code, which I then need to somehow host with an external HTTP server? If yes, how it that different from just reading HN from a web browser in the first place? 
Here's where you lost me. &gt; In Go, a string is an immutable sequence of runes. No, it is a sequence of bytes. Not being pedantic, the difference is important. Assuming string is a sequence of runes causes bugs and is a also security concern.
As it is written CompareInsensitive doesn't even compile because the argument to unicode.ToLower is a rune, not a byte. Even after adding the cast the function is wrong if the function contains any rune that encodes to more than one UTF-8 encoding unit. https://play.golang.org/p/qsE-9Kwg5UR Golang Ninja should vet their articles better.
No, the power of a strong community is that it has a self-healing mechanism. Reddit/r/Golang is such a community. It‚Äôs good to have these critical discussions, not only to write better Golang, but also to get a better perspective on the teams of big vendors such as Digital Ocean. It would be nice if the author reacts too
You're awesome man! 
Damn straight. Now go out and do something awesome for someone else ;)
https://golang.org/pkg/net/http/#ServeMux 
I think the part you are missing is that it's become common to create hacker news clients in various languages. It's sort of a more advanced version of a simple hello world.
It's compiled and much, much faster than Python. The concurrency patterns make more sense as well if you ask me, and you can do a lot of stuff out of the box without fiddling with too many third party dependencies. 
I love this library, but it really needs module support. Until then, I have to use gomock.
`./...` is a Go-ism, so it won't work with anything else. [It specifies a set of packages](https://golang.org/cmd/go/#hdr-Package_lists_and_patterns).
How are you printing? Because `fmt.Println(big.NewInt(1))` works fine.
big.Int has [an implementation](https://golang.org/pkg/math/big/#Int.String) of [fmt.Stringer](https://golang.org/pkg/fmt/#Stringer), which is used by the fmt package to print things if available.
I found some documentation about usage of `...` in go tooling here: https://golang.org/cmd/go/#hdr-Package_lists_and_patterns Hope it helps.
big.Int conforms to the [Stringer](https://golang.org/pkg/fmt/#Stringer) interface: https://golang.org/pkg/math/big/#Int.String
Gosh, I don't think the Wikipedia quite knows what a CLI is either: :) "Application programs (as opposed to operating systems) may also have command line interfaces. An application program may support none, any, or all of these three major types of command line interface mechanisms: 1. **Parameters**: Most operating systems support a means to pass additional information to a program when it is launched. When a program is launched from an OS command line shell, additional text provided along with the program name is passed to the launched program.\[...\]" [https://en.wikipedia.org/wiki/Command-line\_interface](https://en.wikipedia.org/wiki/Command-line_interface) &amp;#x200B; Happens to the best of us. :)
The information isn't going to expire. It's not about a lack of features. It's about an owner that rewrites commit history which obscures work of others and potentially hides changes. The owner also refuses to talk about it and address it to move past it. Instead he continually claims that everyone either asking legit questions or simply making negative comments is somehow all a single troll. If you don't care about the controversy, that's fine,. but it is still risky to use a library that most of the community has decided they don't want to support and contribute to since it could be abandoned much easier than beloved frameworks like Gorilla Toolkit.
&gt; but if we have generics Go will become another language where I do (in pseudo Kotlin): data.map { it -&gt;; Pair(it.first(), foobar(it.second()) }.filter { faz -&gt; faz.second() &gt; baz } As opposed to writing out the same code in 20 lines, making it more error prone and harder to reason about? Or how about splitting it up into helper functions littered all over your code base which still make it harder to reason about instead of seeing everything in one spot? 
That explains why it doesn't seem to work with cd. Thanks for your reply.
Nothing is forcing you not to use for loops in any of the other languages you mentioned that support functional constructs.
I am a go developer and in terms of project structure me and my team mostly follow the same structure as your link. However, IMO since golang gives you a lot of flexibility on how to set things up it‚Äôs mostly your call on if you want to follow all of those rules or not. Just keep in mind you want to make things as easy as possible for yourself and anyone using your code in the future. In addition, my experience with go modules has been pretty good and I would recommend it over dep. Just my thoughts.
Oh, still the standard library. You use a little more code, but it makes it far easier to debug issues with routing. The article kostix posted is pretty good at showing why some people prefer this. Personally, I'm not really sure it adds any extra code to my projects to use the standard library. The standard library gives you prefix routing, and you can split on the separator or switch on the method for additional granularity.
You haven't said why the tests fail, but I'm guessing the relative path to the views from tests is not the same as the relative path to the views from when you compile the main application. You could make it use the correct path by passing the template path into the function that's doing this, and you wouldn't have a test failure, I'm guessing, but I can only guess since you didn't mention the error.
Then you didn't understand my question.
So if I'm understanding this correctly, the idea is to basically just stick a proxy in front of multiple InfluxDB nodes, and have the proxy duplicate the data and send it to each node so that they all have the same data. Is that accurate? How reliable do you think this would be, and do you see any issues? I run InfluxDB as a backend for our monitoring metrics and the lack of clustering is a bummer.
At some point this will become the hello world of data scientists, I am sure XD
There is no such distinction. Only packages that are needed for the build will actually be downloaded.
Thanks!
When would 'devDependencies' be useful in the context of Go modules?
If I learn Golang then I can treat my friend lol?
Ur understanding is not right. There is a keeper which manage The cluster by consistent hash(CH in short). It provides add/delete influxdb HTTP interface. It also provides HTTP interface to get The cluster mapping data which generated by CH to map virtual influxdb node to a physical influxdb node. The kafka-connect-influxdb(KCI in short) get the mapping data from zookeeper. KCI got metrics from kaka And store data into a virtual node by its measurement key AND CH hash algo. And then stores data into a physical node. The zookeeper just stores The meta data like mapping data And influxdb physical node address. 
Probably in the context of using the build `-tags` parameter ?
Oops! Seems like I dropped a ‚Äò)‚Äô at the end. It‚Äôs fixed now!
I see. Thank you for explaining.
I suppose something like Go Generate or Go Bindata. Though, Go Generate is part of the Go toolchain anyway, so maybe not so applicable. For me, I just install them globally. I really can't imagine there are that many dev/build dependency-style Go libraries.
You have a typo in this line: "Some observations before we start, after I **dowlaond** that dataset, I made some pretty simple modifications there:"
There's some other ones I found. If you need some help I can look it over for you
I recently sort of realised how to use docker properly after learning docker-compose and I'm basically trying to figure out the correct way of developing with docker. I want to find the correct development loop which before was code then "go run whatever", but now should be code then "docker-compose build . &amp;&amp; docker-compose up" or similar. If I have other containers like a db I want them to come up too as part of the go code.
AFAIR Windows shell used triple-dots for path navigation (two levels up). You probably remembered that. 
It works in bash too. I wasn't sure why go install wanted to be looking two directories up to compile source files a few directories down.
I'm not talking about "go install", but normal path navigation, for example with "cd".
You need to create a 16 bit gray scale image: https://golang.org/pkg/image/#NewGray16
How are you using the png package? Is it just for output? What people usually do is preprocess the data to increase the feature of the data you care about. This is usually done using floating-point instead of integers. Just adding more bits to your colors will preserve the data, but does not help you virtualize it.
Ask Google
We use it. Mocks are fine at a very narrow level of abstraction, and a pain at the wrong level. For example, mocking a dependency that provides a `GetAPI func(*http.Request) (*http.Response, error)` is a nightmare. However, mocking a dependency that provides a `GetUser func(name string) (User, error)` can actually be helpful for testing.
At my workplace, we use it. We currently mock a single interface; we have mostly not had the need but it nice to know that's it's there when you need it. 
&gt; First, exception handling tends to be slower and more memory intensive. This is false.
Why is your first example a nightmare?
I found your effort quite remarkable. First, you created a beautiful dedicated landing site for your library. Second, at a moment I felt the name "Koazee" is a little bit weird, but I amazed when I know that it stands for Koala and Chimpanzee. Anyway, the main premise of Golang is its readability and code consistency. It is expected that anyone can grasp what is done with an array/slice just by looking at the code. Adopting a new library only to process an array would not be selling that much. However, I recognized that your API is actually adopting map-reduce pattern in a functional way. So, you can advertise it for doing so. A high-quality map-reduce library is still rare in Go, so your library might gain potential traction in that area. If I may suggest, map-reduce is being used largely to process big data, it might be helpful for your code samples to showcase that area. Not to mention, people love to be convinced by a benchmark analysis, to give more reason for the community to use Koazee since you can convince that its API performance is among the best. I know that managing a library is hard and requires a lot of effort. So, just take my words here as appreciation and a suggestion so you can get more users in the future. Good luck. &amp;#x200B; &amp;#x200B; 
That's \*exactly\* what a command line interface to an application is, man, as opposed to a graphical user interface. A CLI doesn't have to be interactive, that's not what the "I" stands for.
&gt; GitHub reports 100% Makefile lol Which I guess is technically correct considering this [1]. GitHub should actually show ‚Äú99% Markdown‚Äù because there‚Äôs only one line in the Makefile, and that line is a comment üòÖ [1] https://pastebin.com/raw/TYaMDXmb
&gt; Requirements &gt; &gt; WriteFreely has minimal requirements to get up and running. You'll only need: &gt; &gt; - The ability to run an executable &gt; - A MySQL database &gt; - A reverse proxy (for running in production) &gt; - About 15 minutes I think this is a mistake. For the problem they're trying to solve, it does not make sense to require MySQL. Use SQLite or BoltDB instead and give users a downloadable backup of all their data without the headache of managing a database. Get rid of the intimidating Nginx stuff and have WriteFreely handle everything itself. You can keep reverse proxying as an option for shared hosts, but it makes no sense to require it.
stb\_image maybe? there are go bindings for it or sdl2 image extension
What your overall impression from go + ML? Is it convenient as python? 
[removed]
I believe the dependencies in the test files aren't included in the final binary since the tests aren't. So it acts I'm a way like dev dependencies...
I think using SQLite or bolt would make out of the box scaling a hassle, not only to build the app, but to manage as a sysad. 
Most people don‚Äôt need massive scale for their blogs.
When Go 1.12 lands, presumably with TLS 1.3 support, I'll wrap up and tag Caddy 1.0 with it.
nk2580, I agree that it is bad to couple infrastructure services with business logic. However, it could easily be argued that something like a persistent queue is the infrastructure layer and not the business logic. Business logic, in my mind, is really the business objects and the behavior defined for them by business analysts, which would not apply to how a persistent queue is implemented under the covers. My 2 cents.
Haha, but someone will grow and it it can't scale to accommodate growth, what's the point in using this when we can already scale things like WordPress?
I frequently have this function too - it's called `dieIfErr`
If you put a CDN in front of your blog, you basically aren‚Äôt going to outscale it. A blog is all GET requests. I‚Äôve handled an Alexa top 50 site with three severs and a CDN because even a newsroom full of reporters/editors is not that many writes. SQLite can handle it, and if it can‚Äôt you can afford to pay someone to fix it for you. 
I use it, and it's great! It is silly to just say "don't use mocks", they are definitely helpful. If you never ever use mocks, at least some of your tests will probably be huge, slow, and painful to write. And you'll probably end up with code that is just impossible to test reliably without horrible hacks. Eg. if you ever write a test that depends on the system's clock, you're doing it wrong; use a mock! That said, you should design your system so most if they time you don't need them.
[removed]
It'll be great to have support of ed25519 in tls and x509 packages
Wow, that's as exciting news!
I'd get rid of the `-cmd` flag and just consume any non-flag args. Convention if you want flags to be able to appear in those args without quoting is to allow an optional arg in the first position of `--`, and not parse anything after that. Perhaps consider a more robust flag parser too, so that you don't have to duplicate flags (and their help strings) to support short and long flags.
But your query is already cached on several levels! Why are you adding another layer of caching? The OS caches, the DNS server it queries caches, what possible benefit can a third level of caching bring?
Hey mrzon05 thank you so much for your suggestion. And I really appreciate your comments. &amp;#x200B; Regarding to the benchmark analysis I just started to work on it, and even though the performance is worse thann I expected I will be working hard on improve it. Once the performance is as good as possible I will put your suggestions on practice and I will work on providing a real and strong map-reduce labriry. &amp;#x200B; Thanks again
I think there is an open GitHub issue which talks about this feature . For now what you could do is create a tools.go file which contains only import statements of these dev tools. Then go mod vendor. But the GitHub issue is more informative. Don‚Äôt have a link at hand. Something related to ‚Äûvendor dev dependencies‚Äú
This project sounds interesting, but the readme leaves me puzzled. What would be the typical use case? What rules must the input obey, and what to do with the output (which seems to be some sort of AST representation)? What is a plugin in this context? What is its role, how does it drive code generation, and why should I send an AST tree to a plugin via stdin? I guess I am just missing something obvious, maybe all the pieces fall into place once the broader context of this project is known.
Why is it even required to add an \`/etc/passwd\` file? You can simply write \`USER 65534\` in your Dockerfile and you'll be fine
DNS TTL is intended to control caching, not only local caching. The recursive DNS server you are using now is already caching and using TTL to decide when to refresh. But it's true. Local DNS cache is useful where you have to resolve same names often or when machine is connected to a slow link. There is no harm in "over caching" DNS.
Not all OS cache DNS. You may use your own cache whenever you think you need it. For example, SMTP servers often send mail to the same peers and have their own cache to decrease traffic and send messages even when there are temporary problems with local DNS servers. 
Hey there - the README definitely can be improved and comments like yours help direct what needs attention, so thank you. A typical use case is hard to define, but I've used this to generate http routes / CRUD funcs for each struct type in a "models" package, tests that use generated mocks, SQL statements (by looking at fields of a struct type and translating their names to table column names), etc. The input only needs to follow the rules of Go syntax. After that, it's up to you to decide how you want to interpret the simplified AST in your plugin. Think about what a tool like GoDoc needs to do in order to produce the output it does -- that's the kind of thing you can create with toast. A plugin is simply an executable in your $PATH, that reads bytes from stdin. It can be written in any language. In the plugin, the bytes are decoded from JSON to objects, and the plugin package in the repo does this automatically for plugins written in Go. The role of the plugin is to take that simplified AST from toast, and use the data to generate other code (or plain text, docs, images, whatever). The data describes your code like inventory: what packages have which files containing what structs, interfaces, funcs, types, etc. The plugin would iterate through that data and write other files that are based on your interpretation of the data. 
Agree, here's [original issue](https://github.com/vektra/mockery/issues/213) about go mod support. Also there is a workaround example using docker. As an alternative you may also like to check [https://github.com/maxbrunsfeld/counterfeiter](https://github.com/maxbrunsfeld/counterfeiter)
On Linux, you can read from `/dev/urandom` and translate to 7bit-printable domain, i.e. with Base64 encoding or hex. Depending on the traffic, you may need additional scrambler to feed system entropy (i.e. Haveged). 
a) best not to use a variable "len", as that is the name of a builtin func b) Using modulo for non-power of two amounts can bias the results. Maybe modulo the byte by 128 instead, and if the value is out of range (ie. greater than 94 in your case), then discard the result and continue to the next byte. You'll have to loop and possibly refill the \[\]byte with more rand data to ensure you get the requested amount of bytes. This should provide a more uniform selection of the ascii chars.
Haveged is mostly snake oil with no proof of its effectiveness. 
Is that required to run something in particular?
&gt; no proof of its effectiveness Do you mean no proof in its ability to provide good entropy?
I was happy to find that my raspberry pi has a hwrng. That's unavailable on anything else that I have and haveged has been my savior. &gt; Yes. Do you have any links to the source..?
Yes, it feeds data into the entropy pool. That's no proof it's actually *good* entropy.
It's good enough for generating session tokens
So is using urandom (which doesn't drain‚Ä¶) without voodoo.
I'm a fair bit past the stage of being a typical 'net kiddo so looks like I missed this trend. Thank you for the heads-up.
By the way, you might find [this issue in the Go tracker](https://github.com/golang/go/issues/28654#issuecomment-438123146) to be of interest: the reporter is experiencing a memory leak which apparently happens in the stdlib code handling TLS connections in `net/http`, gets a suggestion to post it to the bug tracker where the issue gets triaged and debugged ‚Äî only to discover one of its 3rd-party packages provides that memory leak for them.
Have you profiled? The sore thumb to me is `make`, you're allocating memory every function call. Can you find a way to get rid of that allocation each time? Maybe have a buffer that you reuse or get the caller to provide their own (depends on how the result might be used etc). Also the random length thing seems a bit weird, if you can constrain it to a constant or couple of different constant lengths then you give the compiler the possibility of loop unrolling and associated optimisations. 
I don't see the random length? And sync.Pool can give you nice reuse functionality and thread safety. 
A bit late to the show, but: ‚Ä¢ (as most people said here) if you're still learning, definitely don't specialize in a specific language because at the end of the day a language is just a tool you're using to achieve certain goals/objectives ‚Ä¢ that's why the fundamentals matter: once you're comfortable with a certain level of fundamentals and can break down a problem into very small steps, then you can specialize in language that is your tool of choice for the sets of problems you're interested in solving ‚Ä¢ look into Go's origin at Google, understand what problems they were trying to solve and why they created Go - it will give you a better understanding of what you can use it for That being said: ‚Ä¢ commercial adoption is still quite slow and you won't find that many "Go shops", BUT it's used more and more for distributed infrastructure, DevOps and some IoT. If you really want roles that work with Go, try to aim for those kinds of teams within companies.
I've written many programs in C, C++, Perl and Go that process files 5 GB and bigger. It doesn't take forever. Just 30-60 seconds. Line by line is the way to do it. If your lines are ridiculously long then field by field. And don't use regex. Some people know how to use them properly but most people have no idea how to optimize them and get things like unanchored, exponential backtracking. Or in Go they do that AND compile the regex every loop.
Import them to sqlite, then do all the calculations in there
Why not use go mod? Doing this currently, works like a charm.
If you don't want to jump the fresh `go mod` approach just yet, then look at `govendor`. But, what does ¬´it seems¬ª mean anyway?
https://golang.org/pkg/time/#LoadLocation This will either error or panic, I can‚Äôt remember which
This Stackoverflow question has a pretty comprehensive answer: https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go
üôåüèº
&gt;&gt; I use this on a website to generate session tokens and passwords. &gt; I don't you're looking for crypto-level security for the random strings your generating. Yes, use crypto-level random for that. At worst, you're oversecuring something, at best it'll save your bacon. It's not like performance is going to be an issue. For that reason I tend to default to crypto-level secure and only drop back to non-crypto-random if it becomes a performance problem. It's never been a performance problem for me.
Check out https://github.com/flosch/pongo2
One thing I found when working with CVS files was to break the application down to about three go routines. One for ingestion, one for calculation and one for writing the output file. Then depending on if you need things output in the same order or not you can tune the processing part more efficiently.
All very good points, but I think the most important thing to avoid is a situation where you are shipping an "open source" project with closed-source plugins.
I agree with ZanLynx that it is not immediately obvious why this should take "forever". I'd expect the code to be bound by disk IO speed and not much else. The core loop would be [something like this, which will stream it through](https://play.golang.org/p/LY6Cv-A5LLP), for a CSV conversion pipeline. Memory usage of that will be nearly nil. If you save something per-line, be a bit more careful.
Nice, hopefully soon I can replace my code https://github.com/incrr-core/core/tree/master/vendor/github.com/njones/generate with an official interface... This looks cool and I hope things are going in the direction I think they are headed for package management!
[removed]
That sounds reasonable (and I hesitated adding the line). But the question was about generating strings which use about 3/4 of the full byte space, so it negated a bit of "crypto-level" in my mind. But the adage of pre-mature optimization still applies, and checking to see if it's a performance problem is wise.
Let me put it this way: Wordpress already exists. If you make a new product, it will not be as good as Wordpress at being Wordpress, so do something different. Let them have "being a blogging engine with a ton of plugins that uses MySQL" and find something you can do uniquely that they cannot. Here are somethings that a Go blogging engine can do that WP won't be able to do: - Single binary - Security - Sane templating language and my suggestions: - Good caching - Single file DB 
Yes, its simple as this, but be careful to use it (random string)\[[https://play.golang.org/p/lPqgQh8-2lf](https://play.golang.org/p/lPqgQh8-2lf)\]
But why?
Mainly out of curiosity and poking around.
If we're open to skipping `go`-based solutions, [I'd give q a plug](http://harelba.github.io/q/). If you're comfortable with SQL, it's as if every csv file is suddenly accessible via SQL syntax (and joinable, etc). 
[removed]
[removed]
I have sent you a pull request adding tzdata to scratch :)
Perhaps I haven‚Äôt understood what‚Äôs going on properly. Why isn‚Äôt translating the vendored library treated as part of *its* development process and not that of the client code?
[Prior discussion](https://www.reddit.com/r/golang/comments/9wk812/go_package_for_caching_dns_lookup_results_in/) (to avoid discussing what already has been discussed before)
The libc resolver does not cache. If your OS caches, you're using a distribution like Ubuntu that installs a local cache like dnsmasq. Just assuming the host caches DNS, is wrong.
The issue we're trying to smooth over occurs due to the difference in capabilities of a developer vs. a translator. The translation of the library is part of its development process, but the translation staff can work and contribute translations independent of the development toolchain. As a developer, I write some code using translatable strings and create a file of English translations. I can run 'go generate' on the library and push both the translations file and the generated source code which embeds that file's contents. Now, a translator sees the English translations file in the project and loads it in their tool. This tool just creates the German translations file. They don't run 'go generate' because they don't have the go toolchain on their box. Instead, they push the translations file and the embedded file source gets generated downstream. We seem to have options such as: 1. Translators add the go toolchain to their environment and push both translations and generated code 2. Follow translation file pushes with a pull + generate + push process to sync the generated code with current translation files 3. Some alternative to the standard generate which keeps our current behavior Is that clearer with the example?
An io.Reader is not guaranteed to fill its buffer. crypto/rand in particular can do partial writes when /dev/urandom is busy. You need to use [io.ReadFull](https://godoc.org/io#ReadFull) in this case. Panicking is probably fine because usually /dev/urandom will only error out if something is very wrong with the system. This may be of interest to you: https://github.com/carlmjohnson/opensesame/blob/master/pass/pass.go
After reflecting a bit longer, I think this question unstuck a constraint that was being held unnecessarily - chasing a requirement that the translation files and generated source always match. However, that is likely only a hard requirement when a release occurs which is a developer owned process. Thanks!
What I‚Äôm having trouble understanding is how moving to Go modules has screwed up the existing workflow. How are you exchanging the strings files with the translators in the first place? Are they pulling from and pushing to the git repo? In any case, I probably wouldn‚Äôt try to get the translators using a Go toolchain (or any dev toolchain) unless they‚Äôre technically capable. If anything goes wrong, they‚Äôre not in a position to do anything but call you to come and fix it. Are you not using git hooks or some other tool to automatically regenerate the Go files when assets/translation files change? That‚Äôs how I always do it. I forget otherwise.
[removed]
Yes, the translators push and pull from the git repository directly. To this point, we avoided forgetting the source generation step by misusing generate. Since Go shares libraries via source, we were assured that the generated source is in sync b/c the generation step was happening at compile time. There is the matter of ensuring that generation occurs across all required libraries, but we accomplished that with the recursive invocation. With modules changing that paradigm, I believe we will have to move to a hook or other automated reminder mechanism.
&gt;An io.Reader is not guaranteed to fill its buffer. crypto/rand in particular can do partial writes when /dev/urandom is busy. You need to use [io.ReadFull](https://godoc.org/io#ReadFull) in this case. The crypto/rand Read() does use io.ReadFull() under the hood. [https://golang.org/src/crypto/rand/rand.go?s=799:837#L13](https://golang.org/src/crypto/rand/rand.go?s=799:837#L13) &amp;#x200B;
I think you need to be careful with your wording. When using consumer in the context of queues, you're talking about a pub/sub way of attaching to a queue. SQS is polling only.
Oh neat. I guess you only need ReadFull if you use crypto.Reader directly. 
[removed]
Literally any simple SQL query will take ages to execute.
That seems fair enough. Go on ;)
How many testicles can I rub it on though?
Nice. I created [something similar](https://github.com/zerofox-oss/go-aws-msg), though it uses a fan-out pattern similar to how http.Server works. The other benefit is that it defines it's own interfaces and Message struct, so you can use it for multiple backends. 
I have two arms. This will do.
Respectfully disagree, I don't think consumer implies a pub/sub model. Subscriber, sure. Consumer is fairly common language [when talking about SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/standard-queues.html#consuming-messages-using-short-polling), even when excluding SNS. 
There is nothing elegant about this. It's a pointless use of channels. They provide practically no value; the theoretic value they might provide (allowing concurrent fetching of more work vs performing work) is not enabled by the rest of the code. And even if it was, it'd be just premature optimization.
With that level of coupling, it may make better sense to use build tags and provide specific build for different use cases, or use hashicorp-plugins which are also very good alternatives to golang plugins
‚Äúconsumer‚Äù is used by Kafka as well, which is not pub/sub either
Thanks. I've decided to go with Java for the rest of the project (web service, database communication), but I'm writing the client part in Go. I've had some issues but I start to like it a lot. 
Thanks. I've been working with Go all day today, I had some issues but I managed to setup my module without GOPATH and now have dependency management as well. I decided to go with Java for the web and database part, but I'm writing the client in Go to become more familiar with the language. It's not a personal project so I must be careful :)
I'm a freelancer and only work on small, one-man projects, so for me, everything basically flows via email. Never mind any translators pushing to repos: the client typically wants the translation strings emailed to them in a bloody Excel file ‡≤†_‡≤†
Efficient or clever are not things you should be optimizing for in password generation. For session secret, just use the raw bytes from a secure random function and base64 encode it when you need printable characters. 
That you take in a len to the function. If you're generating tokens of some kind they're usually going to be of a consistent length. I had a quick look at the assembly output and it's not really different when hardcoding it so perhaps either it's not as useful as I thought or go doesn't utilise the info for optimisations as aggressively.
What data are you processing that lines would be so large they need to revert to field by field processing instead? Honest question as I'm super curious.
Go binaries (including the Go compiler and related tools, as they're written in Go) only work on those platform versions as of Go 1.11. The release note phrasing might be a little misleading: support for platforms other than OpenBSD, macOS, and Windows aren't affected. In particular, Linux and FreeBSD have the same version support in Go 1.11 as in Go 1.10. Does that answer your question?
No one to the right of Karl Marx is ["allowed"](https://github.com/lucasmenendez/gop2p/blob/master/LICENSE) to use this...
If theyre both the same package and the same folder, then you can reference anything from either file, so if struct Dogs is in one file, you can reference it in the other
[https://www.golang-book.com/books/intro/11](https://www.golang-book.com/books/intro/11)
That's one hell of a spin, seems like you're just here to start a political flamewar because you happen to disagree with this projects politics.
Thank you, that's kind of what I was thinking. 
Hm, somehow I don't think that clause is standard to the MIT license...
While it remains to be clear if the author believes anyone to the right of Karl Marx are fascists he wouldn't be wrong for getting that impression since the license states that Donald Trump is a fascist which sets quite the precedent. &gt; For example: Donald Trump is a fascist; if you donated to his campaign then all rights provided by this license are not granted to you.
Fantastic!
But this thread isn't about the license, it's about something cool someone made. I don't think this is really the time or the place to be debating whether Trump is a fascist or to start flaming about the license because a particular commenter feels directly called out by it.
The petty license will kill any possibility of a decent traction for this project 
I never had to myself but a guy I knew had to with "CSV" that somehow had 64 KB long lines. So he just read up to the comma into his buffers.
Thanks, I have been using gorilla/mux for a long time now (habit I guess), will try the stdlib.
Same package, don't need to import anything in the same directory.
Couldn't he target white supremacists and sexists instead? It would still target Trump and his supporters.
It's not just non-standard, it's not free software, and impractical to either enforce or prove compliance with. I'd be surprised if any other projects or companies were willing to risk using it.
glibc can cache all kinds of name lookups through nscd and nsswitch.conf. I worked at an email company where they actually used nscd instead of dnsmasq because it was lower overhead (just a simple function call for a cache hit rather than a socket to localhost which needs a file descriptor)
&gt; Also, here in my country people usually associate Chinese products with ‚Äúlow quality clones or imitations‚Äù Then why not write your own high quality code?
Please refrain from mounting a strawman attack: I used the article 'a', not 'the'.
Has my code caused you severe migraines, get on the forum for support :)
&gt;\- You MAY NOT be a fascist. &gt; &gt;\- You MUST not financially support fascists. &gt; &gt;\- You MUST not publicly voice support for fascists. Well, not I support fascist, but it's not a open source license for sure.
If you can unmarshal that csv data to a struct, you can easily marshal to json. Focus on getting your data into a struct somehow and the rest will fall into place. HOWEVER, I don't think the csv spec accounts for any level of nesting.
We have https://forum.golangbridge.org/ since ages (in addition to [the mailing list](https://groups.google.com/forum/#!forum/golang-nuts)) and an IRC and Slack channels. Did we really need another forum? 
The dude who made the didn't even know what a fascist is. :/
Your point b) needs to be at the top. It not only can, but does provide biased results: https://play.golang.org/p/U6eJ-AEVnYS (not pretty, but I wanted to use OP's original function unmodified). Characters starting from 'e' have a significantly lower frequency. 
nothing wrong with giving it a 'go' [( Õ°¬∞ Õú ñ Õ°¬∞)](https://knowyourmeme.com/memes/%CD%A1-%CD%9C%CA%96-%CD%A1-lenny-face) 