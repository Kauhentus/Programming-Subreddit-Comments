Every time I see `interface{}`, I shudder a little.
http://golang.org/pkg/image/draw/
What makes it so bad?
Bad only if you think `void *` in C is bad too.
I started programming computers with languages like JavaScript, PHP, and Python. I don't have great knowledge of system languages. I have been enjoying watching go grow.
A keyword like *any* would be more beautiful, but *interface{}* expresses directly what it is: an empty interface.
It's much too verbose for something so fundamental. It makes it much less natural to write.
Ok, thanks. If i understand it's nothing WRONG, it's just unattractive.
The fact that most of the go language is attractive, concise, with less repetition than for example java, makes it more maintainable and easier to write.
When you do move onto some statically typed language, remember that `void *` or its equivalent, like `interface{}` in Go, is generally a sign of bad design.
It's a sign of a lack of parametric polymorphic types, whether that is bad design depends on the goal of the design. I think the way parametric polymorphism is done in Java and C++ is bad design and it would be bad design to add that to Go. 
Don't you think you're being a bit bias here? On one hand, you said the use of `interface{}` is only bad *depending on the goal*, but on other hand you made the absolute statement that parametric polymorphism in Java and C++ is always a bad design. Templates and Generics may not be the best design, but it is at least a step up from `void *` and `Object` since it provides some level of compile-time checks.
I've done Java and C in college and at work. There are some experiences i haven't had yet. Coming from a more dynamic background, i don't find the fault in saying "i'll take anything" as it seems to be the goal in this case. The argument of being a symptom of a deeper problem makes a lot of sense tho. Thanks everyone for your input 
I hope you're kidding that you find `interface{}` and `void *` as things that are "nothing wrong." Do you understand why statically typed languages are preferred over dynamically typed languages for mission critical systems?
The empty interface is just part of how interfaces work in Go, it's not specifically for handling generic types, similarly void * is just how pointers work in C. Both C and Go lack a system to handle parametric polymorphism, it's not bad design it's intentionally leaving out a feature to reduce complexity. C++ and Java intentionally included a system for parametric polymorphism and it's horrible to use and this really effects the languages as a whole. They have actually driven developers away to more dynamic languages with no compile-time checks. PHP is a horrible language but it's amazingly popular mostly because it's main competition was C++ and Java. People can understand PHP. There is a balance between compile-time checks and language complexity. You can't actually get complete compile-time checks, there will always be runtime bugs. Most people will never write any Haskell, so all it's compile-time checks won't help them because they'll be writing in a completely different language. Until the Go devs can come up with a way to do parametric types in Go without the horrible complexity it adds it's best that they leave it out. 
Not sure how much experience you have with C++ but STL is considered one of the best design in software, and parametric type is key in its power. This shows it's not the idea of the parametric type that is bad (Haskell people rave about them), but rather the lack of comprehension on the fault of the lesser programmers.
And you are right that the empty interface is not meant for handling generics. It is this abuse that I'm frowning upon.
A programming language is a user interface. Blaming a user for being too stupid to use your user interface is generally considered bad form. You speak of the "lesser programmers", but typing is specifically designed to make up for the short comings of most programmers. We make mistakes and static typing systems can help detect some of those mistakes. I know devs who write code that works first time in PHP but they are the exception not the rule. I also know programmers that 'get' Haskell ,they are also an exception. The fact is that we need more programmers than there are human beings that don't make mistakes, or that have the mental capacity, background knowledge and interest required to understand complex type systems. The design of programming languages that have a good balance between detecting mistakes and overall required comprehension is required. I'd rather have developers writing code in a language that is mostly type-safe(like Go) than in a language that lacks any kind of typesafety(like php,c etc.).
Programmers write code, codes don't write code. So, blaming the tool instead of the wielders is just ridiculous. No. A static type system is not supposed to "make up for the short comings of most programmers." Where did you get that from? Rather, a type system defines the correct domain for which correct algorithms can be devised to solve the problems. Dynamic language folks tend to just throw random darts in identifying their domain space, and hence end up with incomprehensible code. Contrast that with Haskellers, where the language requires you to define the domain... Once the code compiles, it usually just works too. Just curious, where did you get your training in computer science?
No, why?
My Computer science training, like a lot of people, came from years of self-taught learning plus a CS degree at a local fairly average university. I would say that I represent a fairly average programmer. Things that I have trouble understanding are very likely to be things that are widely difficult to understand. I've attempted Haskell a few times, it starts off simple enough but has a very steep curve and I'm yet to reach a point where I'm comfortable with it. You just have to look at the number of blog posts on reddit 'explaining' monads to see that Haskell is very difficult to learn for the average programmer. It could be assumed that if the level of education was better then the average would be better and these concepts would be comprehensible by more programmers. But perhaps the average capabilities of the large number of people required is just far less than you hope, which seems to be the case. 
You're either trolling or don't know there's a thing called Google. Either way, no response from me would make this conversation productive.
One of the more bullshit statement people make regarding one language over another.
Iteresting... It appears you don't know wtf you're talking about then(since you obviously can't answer)
Your goading skill is as good as your programming.
fmt.Print
&gt; Not sure how much experience you have with C++ but STL is considered one of the best design in software By who? And if this is true, why even many C++ programmers don't use it? And why do things like BOOST exist?
You really must not have used C++ much.
Some redundant code in the ResolveIP example in first `if' statement, you print the usage statement twice, in two different ways. I assume from the previous few examples that the first line using fmt.Fprintf was the one you were really intending to use, but I could be wrong. I like the book so far, though. 
I'm sure the author will appreciate the feedback, but I'm not sure he reads /r/golang, so you might want to email him instead :)
I'm considering doing the same next year for my distributed systems class. Last year I switched to Python from C++, which was a big success. We spent a day learning Python, and in exchange for that day we gained the ability to tackle much more complicated projects. The tedium and incidental complexity of C++ proved to be more of a tax than the overhead of learning a new language just for the course. I suspect Go would give a similar payback, while being better suited to distributed and concurrent programming than Python. I'll be interested to see how it turns out at CMU.
Ok. What seems bs in the perfectly clear and simple things I said ? So you think that after having used java since its first days I cannot have an opinion ? Or do you simply wander by insulting people when you're not the same opinion ?
Dude, that same stupid statement you made was the same statement made for java against C++ when java first came out. So, I find it ironic that now the newer generation of idiots is making the same claim about another language over java.
I coded in C++ before java (and Lisp, C, Pascal, Smalltalk, etc.). The fact that you think that people qualifying the clarity of code are idiots says a lot about you. I won't play you game of insults (I guess I'm at least 20 years older than you) but you should certainly think a little about your reactions.
A good hint, yes. So it shouldn't be a problem to introduce an alias. Could be 'any' or 'empty'. 
Initial thought: Downvote as not really golang related. After listening and coding: Upvote 
Kaiser, Krieg, Kanonen
Simpler implementation: http://pastie.org/2607350
interface{} is not the same as void*. interface{] can hold pointers and values, and is type safe at runtime. void* can point to anything but can't hold values, and isn't type safe at runtime.
How is it type-safe? If you have a variable of type interface{}, you cannot invoke any of the actual methods that it actually support without an ugly cast. An casting an interface{} into some other interface is exactly the problem of C++ casting void * to &lt;some other type&gt; *.
interface{} is type-safe because you can't treat it as any other type until you cast, and at cast time you know if it is safe. So, you can't accidentally treat one type of data as another. Type-safe. When you have a void* in C, you can cast it to whatever you like, but there is nothing at runtime to make sure the cast is valid, because a void* carries no type information. Type unsafe. In the C++ world, interface{} is a closer relative to boost::any than to a void*.
Agree. `interface{}` is safer than `void *`, and it is closer to `boost::any` since a runtime cast to the wrong type would throw an exception (or `raise` an exception if Go's case). So, can we say `interface{}` is equivalent to Java's `Object`? The latter is not generally considered type-safe. I'm sensing a lot of fanboyism going on with Go. Guys, remain objective. Go is by far not perfect, and the lack of generic type is a problem that even the authors recognize (but decided it is a tough problem that should not be solved haphazardly).
Currently, it's only moderately faster. It still seems slower (on the more common non-pathological cases) than pretty much every other commonly used regexp engine. However, with the nicer parsed structure, I imagine there are some solid speed-ups to come (including the free ones that come with compiler and runtime improvements). I wonder how much the possible speed is hampered by the fact that it is polymorphic on input and memory safe. Most other RE engines that I'm familiar with basically deal with a sequence of bytes internally, and are written in C or C++. Edit: It appears that some of the "only moderately faster" may have been blowback from a registerizing bug. At tip, the new regexp implementation takes about 55% of the time the other took to run the regexp-dna benchmark on my machine. So, yay new regexp.
(Edit: Oh god. I accidentally wrote a book. Sorry, this is what happens when I'm procrastinating other things.) `interface{}` is almost equivalent to `Object`. `Object` has methods, and it can only hold references to non-primitives. Also, all class instances are Objects, whereas an `interface{}` can just hold anything, though I admit that distinction is weak. So, they're similar, but I'm not comfortable calling them "equivalent". And personally, I do generally consider `Object` to be type-safe, in the sense that it also doesn't allow you to perform operations intended for one type of data on another. I do think it's fair to say that using `Object` or `interface{}` reduces the static type safety of your program, though, and well-designed generics can provide a much greater degree of static type-safety. And yes, there certainly are Go fanboys, just as there are Go haters. The issue of user-defined generic types in Go often gets brushed off because from what I hear most people actually writing Go programs don't find it to be much of a problem, so many don't feel the need for a solution, and are actively opposed to any solution that makes Go significantly more complicated (as pretty much every solution would). I also think some Go enthusiasts bristle at claims that Go is unsafe because it lacks parametric polymorphism in part because few make the same claim about Smalltalk, Clojure, Erlang, Javascript, Ruby, Python, Lisp, and other dynamically typed languages. Go provides a significantly greater degree of static type safety than all of those languages, but few complain about them being unsafe. The difference is that Go makes it visible and awkward to operate on values without a known static type. Clearly, this is a bad thing if you need to write a lot of code that would benefit from static parametric polymorphism, but it seems that very few people do. So far the Go community seems to have gotten by just fine with reflection, type switches, and the occasional duplication. I'm cool with that. I personally much prefer having to check a cast now and then over the complications that come from the interaction of non-uniform types and generics. But, as a Go Fanboy, I'll readily admit: the lack of parametic polymorphism makes it harder to write statically type-safe and reusable code in some circumstances.
There is already a patch under review to produce some nice speedups. My understanding is that this is a mostly unoptimized port of RE2 to Go, and is meant to be the starting point for a more optimized implementation than old/regexp. It is already dramatically faster than old/regexp in some cases. But then, even old/regexp already was dramatically faster than most commonly used 'regexp' engines out there in a few ("pathological"?) cases.
Have seen your code and yes, it handles pure refreshes with less code. But the intention behind my implementation with the goroutine us the releasing of the cache memory when it's not needed. 
My guess is we'll see a significant improvement once the Go implementation special-cases "one-pass" regexps like RE2 does. I'm pretty excited to see how for Go's regexp implementation can go, actually. It literally has the best implementor possible (one of the main developers of the language and the primary developer of arguably the best regexp engine in the world), so it's a great test case to see how Go looks/works for tricky and performance-critical libraries.
Yep. That's the main trade-off in my implementation vs yours: it only does thing when you call it. If I were caching big data, I'd almost certainly use yours over mine.
For background on the design see: https://code.google.com/p/go/source/browse/src/pkg/exp/sql/doc.txt
I followed this and thought it was a good introduction for those looking for how to translate OO constructions to Go. Even though later I realized that we should not try to translate them literally, the familiar vocabulary helped me to get started.
I'm always dubious about abstracting away the SQL database, having written a Limbo implementation of the Postgresql protocol. I've also written an 9p file server in Postresql plpgsql stored procedures but that's another story. Databases might talk an SQL like language but that's where similarities end. Postgresql is asynchronous, for instance, and can send you database events you've asked for, I presume other high end DBs will do the same. Looking through the code, it talks about queries returning rows, I see nothing about cursors. I really really hope this is someone that knows a *lot* more about databases than "select * from table" 
I suspect that for "low-level" stuff you can call bits of the specific driver directly. But for most apps where being 'portable' across databases is more important than using obscure SQL features/extensions, I think this will work nicely. Yes, it is sad that most applications barely use 1% of the functionality in most SQL servers, but I'm not sure who's fault this is.
Ah, portability, premature complication. 
Common denominator features because you *might* change SQL servers in some mythical future.
I know a lot more about databases.
The common denominator features is usually way more than what anyone uses. Again, this might be unfortunate, but it is a general problem with the state of SQL databases and their usage. Also, more specific comments regarding requirements and specific API improvements would be more useful IMHO.
That's usually not the main reason why you'd want to standarise stuff, such as creating a common DB API, though it's often a big selling point. Having a common api makes it easier to create a community around an area. People can talk to eachother and understand common concepts. People can more easily move from one platform to another without relearning an interface. (i.e. having a common DB api is quite practical, just as it's quite practical for most cars to have the same interface - It'd be no good to reorder the brake and speed pedals even if there were technical benefits to do so on e.g. a Toyota).
So now libraries are about building community ! 
I've had to come back. /me stands staring at the floor for a bit, shakes head, wanders off.
Yet you may still know nothing of good API design (although given, Memcache is simple to use, it's hardly the same complexity as wrapping up the common features of a bunch of different RDBMs). Not saying that I or anyone else does, just that understanding how to mix paint does not make you a great artist, which seemed to be your implication.
A lot of web developers do most of their testing on sqlite, even though they deploy to mySQL or Postgres.
Really, what a bunch of fucking idiots. I'd heard there was a talent shortage but I didn't know it was *that* bad.
It is much worse. How do you think a joke like MySQL ever got off the ground? But 'fully featured SQL databases' are not much better, having turned into their own operating systems, including their own application servers, process management, user management and even raw disk management and thousands of other things. And all this has drifted way offtopic.
For.... databases?
It has drifted (that was you) , but you say those things of (non-MySQL) databases like it's a bad thing. I'd much rather turn my database server on and it boot into PostgreOSQL. 
The main topic of this blog is the new Go programming language from Google Inc., how it develops and how it is situated in the software landscape.
I've written a preliminary PostgreSQL driver for the database package: https://github.com/jbarham/gopgsqldriver It's incomplete and is certain to contain bugs, but is usable at least for testing, and IMO validates the generic API. (Note that I'm also the author of the pgsql.go package, https://github.com/jbarham/pgsql.go, which AFAIK is the most widely used PostgreSQL library for Go.)
blogspam
This is interesting, of course, but it's also done before many times. If you're interested in performance, why not do an article on the expensiveness of various other operations? Like slicing and other operations on slices, starting gouroutines, reflecting on interface types, etc.
Self-promotion, yes, but with +3 weeks of posts on page 1, that doesn't seem to be a problem yet.
There doesn't seem to be much useful content so far, the 'benchmarks' presented have been discussed in the mailing list and are not very useful or meaningful (the channel performance measurements here are rarely dominant or even noticiable in most Go programs, and they are highly dependent on platform specific implementation details that are subject to change, they are also misleading and can confuse people as it is usually a bad idea to use this as the basis for choosing between buffered and unbuffered channels). Contrast with [this very insightful and educational blog post on Go performance profiling](http://blog.golang.org/2011/06/profiling-go-programs.html) that every (Go) programmer should read.
I had downvoted you, but after reading the post, while I don't think it is quite blogspam, it comes close as it just basically regurgitates without proper context some discussion from the mailing list which is more likely to be misleading than informative.
you only need 3 upvotes for that
You can even do it yourself: package main import ( "fmt" ) type any interface {} func Print(x any) { fmt.Println(x) } func main() { Print("foo") Print(5) }
I've not tested it (no use yet) but thanks to the author for the beautiful markdown documentation.
ah just 8 days too late ... I just wrote this :) Cheers moreyes
Nice, is it public? And if so, please post a link!
NOTE: you need to use the weekly release to make use of this functionality. It has A LOT more features than the old package.
hey neat
FACT: This library was written by someone who looks like Sylar from Heroes. Thanks John
omg I don't see it. But I won't pretend no one has ever told me that before.
That's very nice.
Cool. I'll try it even if I've yet made a lot of programs in go. 3 suggestions : * put the *Compile* button near the code zone, to diminish mouse moves * add a key shortcut for compilation * add a *Format* button (using gofmt) edit : one more : a *Reset* button 
noob question - what are the &lt;&lt; and &gt;&gt; operators on slide 14?
This is really nice, but I feel it could be *more* noob-oriented.
I read this as "Go on, OpenBSD."
Shift-Enter to compile and run. See slide #1.
thanks.
&gt; if (len(flag.Args()) &gt; 0) { You should always run gofmt before publishing your work ;)
http://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts
Ok, so then the two constants being declared are: &gt; Big = 1&lt;&lt;100 &gt; Small = Big&gt;&gt;99 So then Big would have the Binary value of 01, shifted 100 times to the left. (1 with 100 zeros) which in decimal is (i presume) 1267650600228229401496703205376 (the value that the error message gives me when I try to do needInt(Big)) or ~1.27+e29. Then Small is equal to Big, binary shifted 99 times to the right giving me a binary value of 10 - or decimal 2. Thanks! 
Noted! :P
It's not shifted to the left in decimal notation, it's shifted to the left in binary. So you get 1 &lt;&lt; 1 becomes 2 1 &lt;&lt; 2 becomes 4 1 &lt;&lt; 3 becomes 8 1 &lt;&lt; 100 becomes 2^100 which is smaller than 10^100 as you can see from printing it out as: 1267650600228229401496703205376. [edit] You are right in that you meant 1 with 100 zeros after it, *in binary*... which isn't what I thought you meant initially.
That's ok, you meant well.
Why use maps for sparse rather than something like ccf or rcf?
I hadn't spotted the [netchan](http://golang.org/pkg/netchan/) package before reading the Go1 doc ... cool .... well I'll look forward to the new version of that too.
No reason. Patches welcome.
Few comments: Continuing the parent comment, you could've done if flag.NArg() &gt; 0 { Where you used `path.Base`, it's probably better to use `filepath.Base` as you're dealing with file paths as opposed to generic slash-based paths which is what the path pkg is for. `MD5OfFile` should probably return the|an error instead of just nil where you have code like: var md5sum hash.Hash = md5.New() it's better to do md5sum := md5.New() I personally hardly ever use `var` I don't think you really wanna use the builtin print(ln) there aren't many guarantees about their behaviour and probably not with their existence in future go released either
Guess it is about time to start a serious project in go, Awesome. I really like all of these changes they want to implement for go 1, especially go replacing goinstall and make!
good plan, I was never happy with the weekly shifting sands.
sweet! thx.
In short, yes. Your example is a runnable program, not a package, and therefore must be compiled separately from the package. The standard go makefile will build exactly one target (either a package or a command). You can write more flexible makefiles, of course, but that's not worth it at all. (plug: http://go-gb.googlecode.com)
I encountered this same problem, and never did find a good solution (though I can't say I tried too hard). I put the package in the main directory with a standard .pkg-style: http://github.com/russross/blackfriday/blob/master/Makefile I added an addition build target which just runs `make -C example` to compile the example directory. In there I have a standard .cmd-style Makefile, but with a few extra lines to refer to the package in the parent directory: http://github.com/russross/blackfriday/blob/master/example/Makefile Note that I am not pulling from the system-installed location of the package, but using relative directory references instead. This was mainly for my convenience when developing: the version I have installed is usually behind the version in my working directory. This works most of the time, and `make` from the root directory will work fine. However, `make` from the example directory will not rebuild the parent directory. I'm sure there are ways around this, but I've never been bothered enough to work it out. I'd love a better solution, so hopefully someone will chime in with a nicer way to do it.
As far as I know a lot of people consider cursors bad practice... But if I understand you correctly, you don't want any generic convenience library for databases at all. But rather DBMS specific libraries that are highly optimized. Your choice, but I guess 95% of the users don't need high end DB performance.
I picked cursors at almost random as something people may be familiar with. I just consider another wrapper around your data storage one wrapper too many.
The link in my previous comment is to my go project builder, gb. gb can also create makefiles that will do correct incremental building, if you still want to use make.
You might hate Solaris for many reasons, but you might be forced to use it. I think that Solaris with Go can only be better than Solaris without Go. If you want to make your life easier under Solaris, [plan9port](http://swtch.com/plan9port/) works. 
interesting, i guess they really mean it when they say this is not v1 yet. oh well, better make the big changes now
Almost no one used vector anyway, and those that did can easily refactor it out of their code using http://code.google.com/p/go-wiki/wiki/SliceTricks
container/vector has been deprecated for almost a year.
I'll try it out. I've avoided gb because I didn't want to require any additional dependencies. I suppose it can't hurt to give it a try, though.
I'll be presenting SVGo and conducting a workshop using it at SVG Open 2011 next week: http://www.svgopen.org/2011/papers/34-SVGo_a_Go_Library_for_SVG_generation/ 
Thanks! Be sure to look at the "placemat" https://github.com/ajstarks/svgo/blob/master/svgdef.pdf
From what I can tell, he's leaving out features in favor of a small footprint. It looks to me like he's using the 6g/8g compiler while from talks that I have seen, gccgo outputs a better optimized executable and a smaller footprint. It would be interesting to see what it would be like compiled with gccgo. Just some thoughts.
The reason Go has to dynamically link against libc is not for performance reasons, but because OS X is badly broken and basically blocks any application that has its own resolver instead of using the one provided by Apple. It is a sad state of affairs, but not Go's fault. 
Better scheduler, better garbage collector 
This is the sort of thing I had envisioned when Rob and Andrew first introduced Go and called it a "systems language" 
It's not "badly broken", it's because Apple defined the shared libaries to be the official ABI. Same for Solaris, BTW: they guarantee that the symbols and calling conventions will stay the same, but take the right to change the underlying system call numbers, because the underlying system calls are not an officially exposed interface.
If the kernel syscalls are not an 'exposed interface', I don't know what is. They have basically broken one of the most fundamental and deep principles of Unix, and there is absolutely no rationale for doing this. Among other things this makes cross-OS-cross-compiling impossible, and is plain stupid. This is one of the few things that Linux and *BSD still get right, a program built ages ago will still run fine in a modern system if it was statically linked.
&gt; This is one of the few things that Linux and *BSD still get right, a program built ages ago will still run fine in a modern system if it was statically linked. And on OSX and Solaris, a program built ages ago will still run fine in a modern system, even if it's dynamically linked. That's exactly the reason _why_ they disallow static linking.
Dynamic linking was a very bad idea back in the 80's when Sun introduced it to Unix as a horrible hack to try to make up for how insanely bloated their OS was. It breaks all kinds of stuff, and provides no real advantages [at a great complexity and performance cost](http://harmful.cat-v.org/software/dynamic-linking/). To try to force people to do dynamic linking is sheer insanity. Good that Solaris has become pretty much irrelevant and Linux and *BSD have ignore its worst braindamage.
You are right, gccgo will probably result in smaller and may be even more efficient executables (Keep in mind though that efficiency is not really important in this scenario. If `rm` takes 8 cycles, I wouldn’t care). However, right now the aim is to keep it as easy as possible for people to participate and will therefore focus on the standard toolchain. Maybe I will compile release version with gccgo, although I'm not a big fan of gcc in general (also: Cross-compiling is way easier with {5,6,8}g).
Some people just don't want to rebuild and redeploy all of their hundreds or even thousands of programs that all depend on a certain library in which a bug was fixed. But apparently, ease of deployment is no real advantage, and those people are just stupid, right?
Except that none of that works in practice. As Windows and OS X have found out, in practice the only way out of DLL-hell is to package every program with a copy of the libraries it links against. That and then you have [versioned symbols](http://harmful.cat-v.org/software/dynamic-linking/versioned-symbols) and other such insanity that makes everything even *worse*. With dynamic linking it is much harder to know exactly what code is loaded by a program, making it harder to know if it has been properly fixed or not, etc. And the advantage for deployment is pretty much bullshit, look at Debian and how you pretty much have to download a new copy of everything when a new version of a library is out, yea, a few times you can get away with just downloading the lib, but it is the minority and what does it gain you? Saving some bytes here and there in your disk? While you have to keep a bunch of different versions of a lib around, and when you delete the program that uses them you end up with unused garbage lying around. Static linking is infinitely more simple, more reliable, more secure and more efficient, and specially more easy to manage. 
&gt; look at Debian and how you pretty much have to download a new copy of everything when a new version of a library is out, yea, a few times you can get away with just downloading the lib *LOL* what?! You're just being delusional, claiming such bullshit is no basis for any serious discussion. If Debian would practice static linking only, it would mean that every time a bug in the libc (whatever implementation they'd use) gets fixed, all 10000+ packages would require a rebuild. How often did it happen to you that you had to redownload all of the packages on your system because of a (e)glibc update? Exactly.
Thanks for the clarification. I will correct this. Do you happen to know where to find the mailing list post that discussed this design change?
There were several threads about this. It has something to do with OS X's built-in firewall.
Actually, only the programs that used the part of the library that has been updated would need to be re-installed and really only the binary diffs of the changes would actually need to be downloaded. These programs would work in past and future versions and be easy to copy between systems, they would also load much faster due to the lack of a need to do linking at load time.
When a bug is fixed in libc that doesn't mean every program that links against it is affected, libc updates are relatively rare. At the same time, most packages in a Debian install are... guess what? Libraries! Which are only needed because packages are not statically linked, most of this libraries are only used by one or two programs, and this does *waste* space because the whole library needs to be included, while with static linking only the symbols actually used by the program are used. If all Debian packages were statically linked, the amount of 'upgrade churn' would be much smaller because the number of packages also would be considerably smaller, plus the whole process would be infinitely more reliable. Also see how programs like Google Chrome, which depends on a ton of libraries ends up just statically linking everything up.
Can a framework (.framework bundle on mac) now link with a google go program and can I easily make C bindings? I tried this language a rather long time ago and at least the former got me caught up.
Those don't need to wait for Go 2, because they don't affect the correct execution of a program written against Go 1. They could happen in Go 1.1, for instance.
Is this page describing a specific dev branch somewhere? I don't see the OpenBSD support in the main dev tree.
A nod to Django? ;-P
Doubt it, this templating language is very different from Danjos (which I personally find unusable).
jan - thanks for all the docs!
Thanks for the great post :) As an aside, I see one of my favourite suburbs in there :)
It is in the main dev tree, see for example: http://www.google.com/codesearch#search&amp;q=openbsd+package:http://go%5C.googlecode%5C.com
Ah ok. I my confusion was caused by this message: Make.inc:45: *** Invalid $GOOS 'openbsd'; must be one of: darwin freebsd linux plan9 windows . Stop. Did not find Go environment variables. when I called "all.bash".
You must have an outdated tree, do `hg pull -u`, the code that generates that error is here, and openbsd is listed as a supported OS: http://code.google.com/p/go/source/browse/src/Make.inc#32 
My tree was from yesterday. I was on the 'release' tag though. I changed it to 'weekly' and the right parts showed up. Thanks for pointing me in the right direction.
`release` is not the same as "dev tip" :) (weekly isn't either, not sure how much progress there has been on the obsd port since the latest weekly)
I'm not familiar with hg but I did an 'hg update' with no revision specified. I'm assuming that will get me "dev tip"? That version compiled fine too. I tried to grab "A Tour of Go" linked to elsewhere in this subreddit but apparently it only works with the release version. New languages are exciting! Thanks again for your help. 
I still find it weird that people are writing new software for terminals that only exist as emulators now. 
Text interfaces are really nice and terminals are the standard way to provide a text interface. Plan 9 has a a wonderful non-sucky text interface that completely disposes of the terminal emulation crap.
Since I'm the author of both the article and mentioned software, I think I can answer that: because that's the type of user interface that allows me to work in a way that is (to me) more efficient than other UIs. Also, such software is usually less bloated.
I appreciate the article. Just a heads up, I was a little turned off by some of your comments on your post (and I'm betting other people were as well). These in particular: &gt; Sorry, but I won't bother to discuss with you if you don't understand the specific problems I'm having and &gt; Yes: http://lmgtfy.com/?q=baconbird You also had some good comments: &gt; I totally admit it, I'm dumb, and so I enjoy using programming languages that make things reasonably easy for me. Sometimes (actually most of the time) saying nothing at all is better than saying something berating. I don't normally comment about things like this, but I figured you might appreciate the constructive feedback.
Unfortunately things are changing in Linux. The only sanctioned interface for calling the kernel is some user mode shared library shim you get when building the kernel. It seems in practice the syscall ABI didn't change so things are looking good but I'm not sure how long this will last. 
As a different point of view I would like to point out that I was a little turned on by those comments...
&gt; The only sanctioned interface for calling the kernel is some user mode shared library shim you get when building the kernel. Uhu? Since when?
I could swear I read it somewhere, but it was probably another kernel and my memory got mixed up. It seems Linux syscall ABI is guaranteed never to break and at the moment you can run binaries compiled in Linux 0.99 days. It's great to see that at least in this regard Linux does the right thing.
Making the syscall ABI stable as opposed to publishing a shared library is a superior solution as it supports both statically and dynamically linked binaries and makes it so much easier to cross compile for that OS/arch combination. Mac OS X, Solaris and Windows go for the shared library approach, but that doesn't make it good. Putting a stamp labeled stable on something doesn't make that thing right, or good. It just marks it stable. By the way, even though issuing syscalls is not an officially supported interface Windows and Solaris never changed the syscall ABI. **Never**.
I wrote this because there wasn't anything like this. There was something in gocode but it was all bound up and I wasn't going to try to unravel it.
Have you taken a look at http://golang.org/pkg/go/ast/#Importer and http://golang.org/pkg/go/types/#GcImporter ?
Aha, so that thing'll do what I'm after? I've wasted a couple of days then. :/
I mean, I think it should be in the standard library. I wasn't expecting it to be there though.
I wouldnt say that. Now you have a good insight into the format. :-) And it willed probably come in handy at some point like the c equivalents are. Neat idea. Thanks.
Yep, this is the standard dashboard for internal commits and external projects maintained by Andrew Gerrand, a member of the Google Go team. The counter of the external projects is increased each time somebody installs this project via goinstall. Additionally there's a build system checking the external projects, but there's currently a problem which Andrew is investigating.
Your package shouldn't start with "go/", though. Anything without a domain name is basically the standard library's namespace. Your Makefile should be like: TARG=github.com/bobappleyard/go-pkg You can keep your "package pkg" in pkg.go, though. 
Dunno about the former. For the latter, I did something the other week using them and it wasn't too hard. See [here](https://github.com/bobappleyard/readline/blob/master/readline.go#L5-22) and [here](https://github.com/bobappleyard/readline/blob/master/readline.go#L86) where `_completion_function` gets defined.
I have to agree with p8m, but on a serious note. &gt;specific problem "fork" is not like "go function" The other poster really didn't understand the issue. Is there a particular reason OP should explain it? This isn't a classroom. The author wanted to share his thoughts and communicate among peers. I like it. &gt;lmgtfy The author published it publicly for a reason. It is insulting not to google such things first. Catering to that kind of request only perpetuates that behavior. &gt;i'm dumb I believe this remark is quite the opposite of berating. OP succeeded with Go where he failed with Perl, and consequently produced a much better performing piece of software. The author admits that there may have been a way, but it was obscured by the black magic of Perl. Sounds reasonable to me.
&gt;usually less bloated Since it doesn't rely on a graphics framework, it doesn't have framework-y extras not needed by the application. Some people Vim, some people emacs, some people windows... whatever lets you create value is fine.
I was originally resistant to this idea, since it's the first time a interface has been predefined in the language. But it's grown on me since even the runtime needs to have a definition for error. 
Didn't know about this one. Sounds super convenient, but how would you secure it?
I think it is mostly useful for debugging/monitoring purposes, I would usually not publish any sensitive data with it, although you probably could use a firewall or somesuch to block access to it in production from outside your network.
Exactly true. Every web server at my workplace has dozens of exported variable pages for monitoring, alerts, and debugging - you just don't allow access from your frontends. The hard part is making those metrics easily updated but still threadsafe - which is why libraries like this are so useful.
I think I am going to watch this thread. I would enjoy android programming a lot more if it wasn't based on Java :(
Oh tis' my dream to use channels instead of threads for concurrency. I am guessing like 50-70% code reduction. Plus performance and lower memory usage. To good to be true. Where can I contribute to help the porting effort!
It will be interesting to see if Google will eventually support a way to create packages which don't run in the Dalvik VM.
Sounds about right: for debug/mon, keep it all internal only. Although I can think of a few places this would be useful, even in production deployments...
this is likely not going to be a simple task. much more compelling is scala for android, since it uses the JVM platform: http://code.google.com/p/scalaforandroid/ Samples: https://codereview.scala-lang.org/fisheye/browse/~br=trunk/scala-svn/android-examples/trunk 
Scala negates most of the advantages lateefj wanted from running Go apps on Android (lower memory usage, performance, channels, ...)
Not UTF-8 friendly?
Or maybe jgo, if it is completed and stable.
I think it's worth mentioning that you can use goinstall to build the command that imports "pkgdirname", though it involves either building the command within your existing $GOPATH or adding a 2nd directory to $GOPATH. At the moment I consider goinstall to be fairly unsuitable to building local projects, unfortunately.
SVGo Workshop slides: http://speakerdeck.com/u/ajstarks/p/svgo-workshop
this has been my bugbear with go, I hope this works out
goinstall
Can someone explain to me (or link me to) the benefit of this? 
The gc suite won't produce vectorized code. Gccgo might produce vectorized code but its goroutine implementation is poorer. I recommend sticking with gc. Don't over-emphasize performance, certainly not in this early stage. 
Hm, that's unfortunate. Maybe I'll just write the portions I'm concerned about performance with in a separate library and use cgo, then. (I'd rather not do a bunch of work and then realize down the road that I'm not able to optimize it at all because vectorization is still unavailable in Go.)
Yes, you can use cgo, you can even write them in assembly if it's critical. 
Hi author here. This code was really just an experiment which I tossed over the wall :-) So please keep that in mind if you were thinking of using it for something :-)
Happy Birthday Go!
its come a long way in a short time, looking forward to go 1.0
May it grow at least as old as C.
Go is turning two, but the next release is going to be called Go 1? Terrible language! No generics! etc.
Terrible comment!, etc.
Go was lacking a vector logo so I quickly traced one in Inkscape. http://www.yellosoft.us/public/images/go.svg
... mascot
Two years old and STILL no try/catch!? It's almost like they don't want error handling!
Please...don't comment about what you don't know and without at least worrying to read a little bit the documentation! Just a little help: http://golang.org/doc/go_faq.html#exceptions
Jesus christ, pedantic much? It was a joke man.
In my own works, I was pleasantly surprised by the efficiency and low verbosity of the *image* and *image/png* packages. The kind of very simple things that involve dozens of classes and dozens of lines in a language like java can be made in a few non-nonsense lines in go.
Note that http.DefaultClient doesn't work on App Engine. Apparently it does work in the dev_appserver, which is a bug I'll look into fixing.
This is a good question for the golang-nuts mailing list. You should have posted it there. 1&lt;&lt;100 means the number 1 "shifted left" by 100 places in binary. That means that Big represents the number 1*(2^100). The point of the example is to demonstrate that, although this number is way too big to fit in a regular integer variable, Go's constants are ideal numbers and can therefore hold such a large number. Small being Big&gt;&gt;99 is the inverse operation: Big/(2^99). Combining the two gives Small equal to 2.
That makes sense. Thanks!
An online version for godoc: http://gopkgdoc.appspot.com/pkg/github.com/wsxiaoys/colors 
If anyone could help with writing a Makefile, that'll be very much appreciated :) I'm still learning makefile syntax.
Very cool, inlining the text! So far in my programs I've baked the ANSI color sequences into constant strings then concatenated them into my strings, but I love your approach so much more :D Just one small modification I would make, is to expose the compilation of a string into an ANSI color escaped string, just in case you might want to use the normal Printf functions, or send the string across to some other terminal.
Suggest you abandon Makefiles and just use goinstall or [gb](http://go-gb.googlecode.com).
thank you :)
Are you going to port over the goroutine implementation as well? Or are you just keeping Go semantics and ignoring all the other under-the-hood benefits?
thanks! very useful
Uriel must have missed the part where this is released under the GPL :) neat project, though.
I just added Sprint &amp; Sprintf methods, this should satisfy those requirements.
I've been working on a Metar parser... so I checked over your source code expecting to find something similar. It appears to just check wunderground and similar online resources. Is that right?
AFAIK (from the description): that is right.
Can I run this on app engine?
I don't think so, at least not the AMD64 asm.
Very neat, I wonder how fast it is compared to the reference implementations? Now we need some sort of higher-level linear algebra library (in the spirit of Eigen for C++), and Go will become an awesome language for numerical stuff.
A few remarks : * very interesting ! * more information on front page regarding the form of the url would be welcome. I made a lot of tests and almost gave up * it doesn't seem to be compatible with Firefox 8 (ubuntu) * why only packages and not programs ?
Or you can :!gofmt -w % and then :e to refresh the buffer. 
TIL that ResEdit isn't a Mac program but a Windows program. My childhood is hurt... More seriously, it would be interesting to have some experience returns from people using this GUI framework or other similar go solutions (especially the cross-platform ones).
Don't need the retab! calls, use -tabindent=false. 
Go has [awesome profiling tools](http://blog.golang.org/2011/06/profiling-go-programs.html). Did you try them?
Wait, doesn't go recommend using tabs instead of spaces? It might also be that I don't understand what you do. I'm not very familiar with vimrc
Well, from a generic non-Go-specific viewpoint, there are a number of things you can do to make this more efficient. For one, when you brute force prime checking, it is sufficient to check up to sqrt(n), not up to n/2 as you do. Another thing you can do is pre-compute a long list of primes using the Sieve of Eratosthenes -- maybe even use multiple goroutines to generate this concurrently -- so prime checking is faster. Alternatively, use a more sophisticated primality test -- see Miller-Rabin, etc. 
Looks great, thanks!
Yes, they recommend tab indented code. But the great thing about using gofmt is that it doesn't matter. You just run it again using tabs when necessary. Otherwise you just set it the way you like (eg. I prefer spaces as well).
For generating all factors you can create two lists: potential primes (factors &lt;= sqrt(n)) and the rest. So that loop going up to number/2 generating all factors can have its runtime shortened substantially. You can also (as pointed out by others) generate a list of primes up to sqrt(n) and just check the factors against that rather than repeating that check_primes loop each time, the execution time will be bound by the time needed to generate that list of prime numbers. Also, http://swtch.com/~rsc/thread/ has an interesting algorithm taking advantage of channels/procs to generate the prime numbers up to some limit.
&gt; Also, http://swtch.com/~rsc/thread/ has an interesting algorithm taking advantage of channels/procs to generate the prime numbers up to some limit. Note that while this algorithm is interesting and neatly illustrates how channels and (go)routines work, it is not supposed to be a particularly efficient way of calculating prime numbers.
Yes, the 'retab's allow me to edit in spaces but save in tabs. I prefer spaces in code, but this allows me to never have to worry about that. Gofmt will do it's thing and while I am looking at the code I can use spaces.
The goal is to follow the standard, which language wide is to use tabs.
Yes, you can do that, but it's laborious. This does everything automatically and I don't have to worry about it. I open the file, it changes tabs to spaces, I edit code, save and it corrects the formatting and saves the file in the standard gofmt. All I have to do is :w
shrug... it's :&lt;cntrl-p&gt; after it's been done once. It's a nice section of .vimrc though. I'm just slow to add much to mine.
Is there a way to have vim run those commands on write? Seems much simpler than the OP's vimscript. 
 set rtp+=$GOROOT/misc/vim autocmd BufWritePost *.go :silent Fmt Is all I've needed for Go.
Thanks for this! I prefer to have a very spartan .vimrc and this makes the cut. 
You probably want BufWritePre since you want to save the formatted code right? The live above will change the formatting after writing the file.
No. I often make further edits in response to what goformat did to my code, so I prefer it saves exactly what I typed and then formats it afterwards. Some people would want it to just format while saving and BufWritePre is the right solution for them. ironyCurtain may certainly prefer that.
There is no word about Erlang in this document. So why introduce it in the submission title ? Is there something I'm missing (I know nothing about Erlang) ?
The reddit submission has the same as the title as the first slide.
If you declare a struct that you parse in the standard way using the json package, you have the same access without map lookup. And you can profit of hierarchical structs, all numeric types, and so on. What's the advantage of the jconfig solution ?
Ok, thanks for the clarification. So was the slides author trolling or is there something evident about both concurrency systems ?
Erlang has message passing (somewhat equivalent to CSP), but no shared memory.
Compare to http://code.google.com/p/goprotobuf ?
Uriel isn't a troll he just has really strong opinions about the way things should be done. 
Not 100% correct. ETS is a form of erlang shared memory that comes with OTP (Erlang Term Storage). It's like an in memory "NoSQL" style storage area for any old erlang term, so it's not accessed in a traditional way, but it definitely is a shared memory construct and you have to be a little careful with it :-). And by being careful I mean using MNesia with transactions on memory-only tables can be a fairly elegant way of handling consistency. It even works across networks. Go has a lot of catching up to do in these areas, if people want to use it for the same space as Erlang. I'm not sure that's the right direction for Go though. http://yarivsblog.blogspot.com/2008/05/erlang-does-have-shared-memory.html
Any way to find out who made this?
ETS is not really equivalent to Go's real shared memory. It can be used to solve similar problems, but is not the same.
I didn't write this presentation, nor did I pick the title.
I should have mentioned it in the title: Dmitry Vyukov, of 1024cores.net fame and that is now at Google.
True... but someone accused you of trolling and I thought that was not fair at all. Simultaneously I think Erlang and Go have a bit less of an intersection in problem domains than many might immediately think. Erlang will likely never get the performance of Go doing things the way they do now, and yet at the same time it's a very robust system for building big distributed network services. I'm not sure I'd do that with Go yet. 
&gt; Simultaneously I think Erlang and Go have a bit less of an intersection in problem domains than many might immediately think. &gt; &gt; Erlang will likely never get the performance of Go doing things the way they do now, and yet at the same time it's a very robust system for building big distributed network services. I'm not sure I'd do that with Go yet. I completely agree. Although there is a question of what one means by 'big', Doozer seems to be quite successful and robust.
nice presentation!! i'm a little distressed that a lot of these nuggets are being hidden in slide decks scattered about the web though....
A quick look at both shows that this project uses the google code project as a library, and that the protoc version there is a minimal, proof of concept sort of thing.
jconfig is nothing fancy. It says so on [its homepage](http://www.stathat.com/src/jconfig). The advantage of jconfig is that it is easier to load and parse the file. You do config := jconfig.Load instead of declaring a type to parse into, opening the file, parsing it. I'd say that would take a minimum of 15 lines of code, perhaps more depending on the type. It's intended for simple configuration files. If you want something more complex, you should go ahead and parse the json yourself.
Glad you like it. Let us know if you end up using it for something cool.
Doozer is interesting, but the last time I tried it I couldn't build it due to difficulties pulling dependencies.
goprotobuf is the support library that is used by the generated code, plus the bit that generates code from the intermediate representation. gotoc is a program that parses .proto files and produces that intermediate representation. It's closest to a proof-of-concept at this stage. I wrote it on an airplane flight last year as an exercise.
Nice try, Pike.
this is one reason i am pushing go...i can reasonably expect other reasonably bright coders to be able to pick it up quickly. mastery is always elusive, but you can start working with go very quickly i compare that to other languages i have espoused in the past, namely haskell, that are almost impossible to sell to coworkers due to the huge lead time to learn it
Totally unnecessary comment. 
The goprotobuf package provides a compiler protoc-gen-go which parses .proto files and turns them into .go files that you can compile into your code. http://code.google.com/p/goprotobuf/source/browse/#hg%2Fcompiler
Really? Andrew Gerrand is the only person blogging about Go in the universe. From what I can tell, apparently the only bug is that he's the only one using it.
Go back to your Java closet. There are plenty of programmers using Go, many, myself included, are payed for it. 
Don't feed the trolls, just let it Go. 
protoc-gen-go does not parse .proto files. If you can find somewhere that says so, let me know and I'll fix that.
That's is, by the way, why i think Rust http://www.rust-lang.org/ will have some potential. It has some Haskell-goodies (patter matching, immutablity, a Prelude-like standard library) but since it is also influenced by Python, Ruby, C/C++ etc it tends to be less pure, less beautiful, but a lot more accessible and thus more practical (for example it has more low-level control).
Bull shit :D
Generally Go software uses goinstall. If you run doozerd's all.sh script it will goinstall everything you need (only three dependencies from the same authors, really). 
It has a dedicated page since a while ago: http://gorilla-web.appspot.com/pkg/gorilla/mux/
Added linting and codeintel via gocode. Still rough around the edges but working alright for me. [screenshot](https://github.com/traviscline/komodo-go/raw/master/example.png)
Slightly off-topic but, is Komodo worth what they're asking for it? It looks like it would appeal to devs who want a consistent IDE regardless of the OS they're working in. I'm going to grab the trial but wanted to see if you guys had some experience using it. 
how about making the tabs 8 spaces? Or formatting the code with gofmt upon save or logical block completion or something like that
Komodo Edit is my editor of choice, but I don't see enough additional value in the IDE to justify the, what, nearly $400 price tag? If it was $100 or less I'd buy it immediately; not even for the features necessarily, but just to support ActiveState for making my favorite editor.
That's all controllable in Komodo -- outside of this extension. (I set tabs to render as 4 when editing Go). Sorry about the confusion. Regarding gofmt integration: komodo has great macros and commands, making a keystroke-bound 'gofmt-current-buffer' would only take a few minutes. Edit: on second thought, maybe I can at least hint at 'prefer tabs over spaces' from the language extension, not sure, I'll look into it. All the above still applies though.
Use Komodo Edit, it's open source (openkomodo). I actually was referencing the komodo source frequently while making this.
I updated the screenshot to show it's actually tabs (but again, controllable per language in komodo).
The Rx builder in IDE is pretty nice. I'd consider buying it if available as a commercial extension or something.
Just gave me the idea of abusing komodo's linting as a way to run gotest continuously.. Would have the benefit of in-editor feedback for current failures (would also catch compilation issues). Would be useful.
See, that's an example of a major feature in the IDE that's really nice but which I'd *rarely* use.
Any way you can write up a how to on how to get this working for a newbie? I have go and Komodo installed on my Ubuntu machine but I'm not sure what to do next.
Yeah, I'll write up instructions and get them into the readme there before too long. It'll be pretty straightforward. edit: clarified a bit, feel free to ask for assistance.
I've wrote similar app but with *inotify* trigger for any Go source file http://paste.pocoo.org/show/528062/ After compiling this script as *builder*, go to your project directory and type: ./builder "&lt;compilation command, like gb&gt;" "&lt;command to run after successful compilation&gt;"
tldr complainers often complain without any understanding of the topic or desire to investigate it ok, so? also how is this relevant to anything Go? 
The discussion on /r/programming is more verbose : http://www.reddit.com/r/programming/comments/ny77g/rob_pike_talks_about_modern_programers_lack_of/ But, as a Go fan, I think that this rant brings nothing, should not have gone public and doesn't deserve two reddit posts.
It is relevant because Rob Pike wrote it. Honestly, if it was not Pike I'd call this trolling (here come the downvotes). It doesn't help to create any sympathy and worse, it feeds animosity. This was the most awesome thing I've read on this discussion: http://goo.gl/fk7fg It comes from a member of the Dart team (and designer of several small languages). That is Being Nice™.
An off-tangent question: Go has this neat feature where the keyword `var` asks the compiler to infer the type. So in the code example in the article, func genTest (n int) func (res chan &lt;- interface {}) { return func(res chan &lt;- interface {}) { for i := 0; i &lt; n; i++ { math.Sqrt(13) } res &lt;- true } } is it possible in Go to have the compiler infer the type of the return value of the function `genTest` instead of repeating it with `func (res chan &lt;- interface {})`?
Nope. 
a question - are goroutines launched inside a function required to terminate before the function terminates? 
No. 
Sources? I hadn't heard this. Also, could you quantify "quite a bit slower"? I don't know otherwise from what you are saying, which is why I seek sources.
When passing multi-word data around channels only a pointer to the data is sent. It's as fast as it can physically be.
People might wonder what the advantage of using such a tool over instead http://play.golang.org is.
Local execution and using local resources should always be faster than another site?
Devils Advocate: My local files are not on the website This is my main use for the Python REPL. I programmed hot-key access to a Python interpreter loaded with utility functions/goodies. I use this multiple times a day.
Have you looked at [igo](https://bitbucket.org/binet/igo)?
Looks interesting. It might be what people are looking for. Let's get it more publicity!
how do i get dozens of libraries i have built over to play? how do i get back history of previous statements i have tried? play is not a replacement for a repl. 
I might not want to copypaste my (currently imaginary) 100kloc program to play.golang.org to test a few new things on a REPL.
or, just use a real REPL like most other languages use and skip all this crap
This looks cool! I can open this on the side and use as a experiment ground and as a documentation, etc.
The Go distribution does come with goplay, a local tool similar to the one on the website.
It isn't the moving of the data that is expensive, but the locking and runtime interaction with the channel. Mutexes beat chans for raw speed.
There is a bit more machinery to a channel send than that.
Not in the code I'm seeing: http://code.google.com/p/go/source/browse/src/pkg/runtime/chan.c#146 Some very simple checks that employ only memory lookups so it reschedules if the chan is sync and it can't send, else it's just what I described above. It's true that there is *some* overhead in that function, however. I'd be willing to bet that except for some simple, optimized cases, the overhead written by the programmer to deal with mutexes is significantly more costly than the overhead of a channel send. I do agree that careful code that uses mutexes can be faster that using channels, but one must not left the impression that channels are slow, they are very fast and I believe in very few cases replacing them with mutexes for speed makes sense. Sometimes I do replace channels with mutexes, but I do it because in that particular case it simplifies syntactic structure, not for speed, I've shown you an example on IRC :-). 
~~It may be just me, but it seems strange that the creator of this would trust himself to create a client that's more secure than pidgin or another alternative that already exists. It seems foolhardy to trust your own code like that.~~ EDIT: Never mind, he's on the Google security team. He's just modest, as bradfitz says.
Doesn't seem to be any claim that it's more secure. The only reason to trust code that is not your own is if it's had a lot of review by a wide range of people. All projects start with unknown security implications.
I believe that construct loops only on exceptional conditions, it really shouldn't. 
I'll take a different tack, then. Can you show me go code imitate a channel using only sync.Mutex? That is, a type with .Send() and .Recv() methods. 
I can implement a Go condition variable using mutexes, so you might want to change the phrasing of your question a bit. Am I allowed to use only one mutex? If that's the case, no, I can't emulate synchronous Go channels with only one mutex, I can emulate asynchronous channels with *no* mutexes, multi-reader, multi-writer lock-free queues exist. I say this doesn't matter at all. The condition variable is used with synchronous channels to wait for the other half of the operation. If you use mutexes instead of channels, when you read the data you want to make sure it has been written, so you'd still use a condition variable (or equivalent) to wait until the data is available. In both cases you need to wait if you want to synchronize. If you don't want to synchronize you'd use an asynchronous channel, and you won't hit that waiting code path except in exceptional conditions (as I already said). Even with a synchronous channel you won't hit that code path IFF there's a channel receive. | Channels | Mutexes -------------+---------------+------------- sync | mutex + wait | mutex + wait -------------+---------------+------------- sync | | already | mutex | mutex synchronized | nowait | nowait -------------+---------------+------------- async | mutex | mutex For any scenario, sync or async, whether you are already synchronized or not, you do the same thing. Again, I agree with you that simple, optimized code that uses mutexes is faster than using channels, but that's because channels are generic, mutex + conditional wait, while your code can elide those conditional statements completely if you know that you don't need it. What I am trying to say is that channels are fast, most likely fast enough, definitely not slow :-). When you want to use mutexes instead of channels it should usually be because of syntactic simplification, not because of speed.
Foolhardy unless you're as good as Adam, perhaps. In addition to all of Go's crypto code, he's also responsible for a lot of Chrome's and Google webserver's crypto/TLS code. He's extremely modest.
Ah, I see! Thanks for the explanation.
Another reason he has more faith in his implementation is that Go is memory safe, which rules out a whole class of attacks. (That's not to say there couldn't be other holes, of course.)
I did an experiment some time ago. The goal was to asynchronously send a lot of integers from one thread to another. A simple benchmark revealed that Go's channels required 173 ns/op vs. 6.03 ns/op for my own channel implementation. So, as you can see Go channels aren't the fastest possibility, but they can be easily used in nearly all applications. For example, my lock-free channel implementation did some busy-spinning on pinned threads to avoid context-switches (so you can only create a few of them) and it didn't supported "select". Therefore it's really great to have the choice. In most cases Go's channels provide the best trade-offs but in some rare cases it might be reasonable to use another specialized implementation. Also note that you can not generally tell what's the fastest approach. If I remember correctly, Go channels are on their fast paths mostly lock-free, so they scale much better than a central Mutex, but the constant costs of sending and receiving from a channel are a bit higher. Alternatively, for data with high read ratios a COW based approach normally easily outperforms both. As I have already said, it's good to have a choice.
I can't see a lot of use for recovery and I can imagine panic itself only being used in the main of a simple application. However I can imagine recovering from a panic in a library I'm using that someone else wrote.
At least the old/current regexp lib seems to use panic/recover as a control flow mechanism. Looks like the new one does not (there are a few instances of 'panic' there too but no 'recover')
this article is a classic example of people who don't understand exceptions
A comment like that always needs a follow-up. What do you think it's missing? What do you think is not understood?
You misunderstand panic(). If your code includes a panic you shouldn't expect that anyone will catch it. It's certainly possible for someone to do it, but you shouldn't expect that they will. panics also only propagate up to the start of the goroutine, kill the goroutine and then if not recovered from will kill the program. Recover is generally only used to prevent the whole program from exiting in the case that the panic is part of some kind of repeatable action. eg. a panic while handling a http request shouldn't effects the http server's ability to handle future requests. try { open file read perform close } catch { log, reraise, return error, etc } The difference between that and the return value example is that in this example you can't see how this will flow unless you know what exceptions can be thrown from each of the called functions. Changes to these functions changes the flow of any code that calls it and all that code will have to be checked to make sure it still flows correctly. Go tries to make it clear "on the page" what is actually happening and tries to avoid changes in one part of code effecting other parts in unpredictable ways. 
Assginability, eh? :)
not yet
Is that different than `Future` in other languages? (of course, `Future&lt;Error&gt;`, not a future that throws an exception when failing).
this is excellent. im working on a golang based app platform for my company using the weeklies. Go1 being released at this stage of development will be perfect timing.
I managed to compile your package, mmap-go. I updated my sample to use [mmap-go](http://pastebin.com/uvazZLbY). I don't know if I'm using it correctly. But my alterations in map_array doesn't reflects in the mapped file. I'm correct in using it "map_array := (*[1000]int)(unsafe.Pointer(&amp;mmap))" ?
The comments at the top of http://code.google.com/p/rsc/source/browse/fuse/fuse.go : // Package fuse enables writing FUSE file systems on FreeBSD, Linux, and OS X. // BUG(rsc): The mount code for FreeBSD and Linux has not been written yet.
This really exemplifies the sort of thinking that brought my attention to Go in the first place... and Russ even mentions my niggling pet peeve: &gt;"When we first launched Go, many people published packages that had to be installed in certain places, under certain names, using certain build tools, in order to be used." Hopefully with this new command eventually all the existing packages and projects will be motivated to follow the Go convention.
Took me a frustrating 15 minutes to understand why my local projects needed to be on a gopath, but I freaking love `go`, the tool. If the docs had more detailed information about how GOPATH(s) are used in `go`, I think this is awesome. It's an organized ecosystem of easily importable and installable packages. (I'm also excited for `go get` to drop and I wish that `go doc -http=:4000` would be supported in it) oooh, a virtualenv would be neat, but it would also be super trivial, it would just be a matter of exporting GOROOT/GOBIN/GOPATH, no?
I assume the GOPATH thing might make more sense to someone who uses Java. I just switched from release to weekly so I'm still fixing some code I've written, then I can't wait to try playing with this new tool.
Thanks for the link. I hope the official documentation and introduction to Go1 will have this kind of spirit. But a question : Supposing you can store all your projects in one repository but that all this projects use a lot of resources and different languages, go being only a small part, can you still efficiently set GOPATH as the root of your project directory ?
I believe so, since go will ignore directories without any go code in them. Similarly, if you never try to "import" any of the directories without go code in them, the tools shouldn't try to build them. The mailing list thread (if you read the entire thing) has a couple of people who set GOROOT=/home/USER and moved _all_ of their source code under ~/src, go and non-go code alike.
Hi, edsrzf. I posted this same question in [stackoverflow](http://stackoverflow.com/questions/9203526/mapping-an-array-to-a-file-via-mmap-in-go). A user posted there how to do what I want. Take a look there.
Am I missing something? Why not just write `for _, v := range e` if you don't want to do the look up four times?
Thanks, TIL. The Python model for references is so much easier than the standard C-style. I always get confused about &amp; and \*.
Thanks! Is there anything in particular you thought was confusing and in need of a comment? I'll look into the packages you mentioned next time I work on this.
yes, You can get similar behaviour to error return values from checked exceptions by wrapping every function call in a separate try/catch block. 
Most errors are just passed up the stack. Try/catch is only necessary when some action is required. With explicit error handling, you also have to check for an error, even if you do nothing but pass it up. 
Statements like "Could Go be faster than C?" are meaningless. Another example of a statement like this is, "yet on average, for large programs that are coded by decent coders, c continues to be the best performing language by a worthwhile margin".
I cringe whenever some titles their work in [such a manner](http://en.wikipedia.org/wiki/Begging_the_question).
I enjoyed it up until the picture at the end. Super tacky, just another form of sexism in a (currently) male dominated field.
God, what is with the rash of topic nazis on reddit lately. Threads are always full of tangential conversations. It's a "comment" section and I'm "commenting" on the presentation of the articl.e
motherfucking borrowed/recycled blog content is fucking awesome but those memes are fucking motherfucking tired somewhere a php forum is missing its class clown
It's funny that even maven, for all it's shrotcomings, got library dependency management right. Go tool doesn't even lets you specify versions. Requiring library author to have always working master branch, and forbid API changes are just dumb restrictions posed by dumb tool.
I should publish my websocket code. It's a websocket server for PeerConnection signaling in WebRTC. No actual PeerConnection API on the server, just pure websocket and passing the signal to the appropriate person. Now if the Chromium team gets multiple PeerConnections enabled I can start to release my video/audio chat app.
I added some go routines and channels as an example how to support "push" notifications. http://snipt.org/uOgg0
Can you please explain/refer to a place listing Maven-like library dependency weaknesses?
The Go tool supports versioned tags/branches, so it's possible to have an unstable tip in your repo.
it uses ruby symbols in go!
What exactly about this blog is borrowed/recycled?
I've started a little document about the setup at http://www.tideland.biz/GoToolsAndEnvironmentVariables. Here I describe how I set up my directories for own and 3rd party packages and the environment variables. The tool description is still growing.
I'm using the latest release of Go and can't compile: $ make [...] tranceiver.go:20: can't find import: encoding/gob `gob` is now in the root of pkg so I've replaced `import "encoding/gob"` by `"gob"`. Now I get this: packet_interface.go:25: undefined: error tranceiver.go:40: err.Error undefined (type os.Error has no field or method Error) tranceiver.go:47: err.Error undefined (type os.Error has no field or method Error) The code is using the type `error` everywhere, but I doesn't seem to be defined or I can't find it. **edit1**: ok so this type is [recent](http://groups.google.com/group/golang-nuts/browse_thread/thread/d10a951c8197889a/6c3ea5e5d98e10d9?show_docid=6c3ea5e5d98e10d9) in Go. Updating to Go weekly, will post result. **edit2**: ugh, still not compiling: $ make [...] 8g -o _go_.8 *.go gui/*.go messages/*.go battle/*.go color.go:19: can't find import: "sdl" The wiki says: &gt; In order for the client and server to compile, you must install the packages in the Packages directory. However, calling make will automate this together with compiling the client and server. SDL is in the Packages directory but the automatic install doesn't work.
Awesome will take a look at it.
`gofix` is your friend.
My primary use cases are "What would a given reddit look like with different moderation policies and different voting patterns" and "building a more interesting front page". Also I should add that I clearly am not the main demographic of reddit so votes are not a good indicator for my interests. Right now in [/r/socialist](/r/socialist) I have slightly modified the AtheismBot running. Both of them are pretty simplistic: mine reads [/r/socialism](/r/socialism) and applies a basic filter using a ban list of domains, users, and keywords and then a second approval filter using number of Upvotes, Downvotes, and Comments. Once a given post is approved the bot constructs a self post with this information and submits it to [/r/socialist](/r/socialist) (which is a mostly dead reddit). The idea being that you get mostly the interesting stuff and less of the silly content free stuff. The guy who wrote the AtheismBot has a pretty good explanation over at [/r/atheismbot](/r/atheismbot). All I've done with the atheismbot (besides getting it to run on my Mac) is a lot of fiddling around with these criteria and I'm not really satisfied with the results. Really what it boils down to is that these criteria are to crude to tell if a submission is actually interesting or not or is appropriate to the reddit or not. Then a few things caught my eye. 1) The TLDRBot here on Reddit and [SMMRY](http://smmry.com/) (The bot uses smmry and I'm pretty sure both are done by the same person). 2) [A client-side Bayes classifier for Hacker News](http://rogerbraun.net/a-client-side-bayes-classifier-for-hacker-new) And I began to think that there were better ways to do what I wanted to do and that those ways might actually be doable by someone like me. So I've been sort of rolling this idea around in my head: given all the data we actually can know about a given post we could determine the likelihood of the content being interesting and/or topical... and the beginning place for that is an Reddit API wrapper.
I found the source code, but it might be a better option to host it on GH or Google code.
You should *really* write a README or something... # compile with go $ hg up release $ 8g gobl013.go $ 8l -o gobl gobl013.8 # run as root because the default configuration uses port 80 and gobl # fails silently if it can't bind a port $ ./gobl -r=cms And that's it for me. I get a copy of the homepage on localhost:80. Also the deployment page is not up to date. There's no `-c` or `startcms` flag. If I understand the documentation correctly, there is a web GUI to edit pages but I don't even know how to access it. Too bad. $ cd .. &amp;&amp; rm -rf gobl* 
Agreed.
Not only that but with the source code in the state it's in, I'm not super enthusiastic to go rushing to run this as root. No reason it couldn't take an http flag to specify the IP/host/port.
Doesn't need Apache. &lt;3
I'm sure there aren't any Go programs that do unless Apache's being used a front-end server and that's not usually the case.
Hi All, I apologise that gobl.me/documentation failed to make clear a few important things. @trtocm: You can configure port # and other things in configs/config.json. It is set in HTTPServerPort. I usually use non-80 in development mode. The current config in download file was copied from production - gobl.me runs gobl. @pro547: I seriously wanted to use google code, but I wanted to stress-test gobl at the same time. The download file is currently served by gobl. @anarcholibertarian: Dev is currently done by only me and I have my own versioning system. If the project starts becoming complex, I may switch to a formal VCS. @aaptel: I meant gobl.me/documentation to be the "readme", but I think I see your point. I will work at it. The GUI is essentially running gobl with "-r=cms" flag. Login path is localhost/login/en. Initial admin user is root; password is also root. If gobl is run w/ "-r=ws" flag, then there is no GUI - everything is CLI. This mode is not for devt. Thank you for all the comments. Highly appreciated. I will continue to improve the documentation page.
You can change it in the json config file, but I agree.
Some advice: Please please please, use a version control system. It improves your capacity to incorporate patches from the community, it helps other people understand what you were thinking when you made coding decisions and it plays nicely with the go tool - a tar ball does none of these things. Using git or mercurial add little to no overhead and changing early is (marginally) easier than changing later - even if you still insist on serving tar balls from your site. Run gofmt over your code. There is no reason not to and gofmt'd code is the community standard. Consistently formatted code eases reading, and poorly formatted code looks sloppy.
Not only all of these reasons, but it's just silly easy to get up and running with GitHub. "I'm the only dev" just isn't a good reason.
I had my reasons, but your reasons make sense. I will learn those and do them. Thanks.
That was not the only reason, but no matter. I don't think github does mercurial, so I may put it up elsewhere when I get to it.
I know this is really trivial, but I appreciated the way it was intro'd on the G+ announcement. It will be harder for my friends to ignorantly mock me and my obsession with Go if I can point to this.
Which G+ announcement? I saw Andrew's here: https://plus.google.com/106356964679457436995/posts/NYg6HD7cpsz Was there another? 
I appreciate it but please let mysql die.
What's wrong with it?
Almost everything. edit: Some examples... * No sane defaults(truncate strings by default, ignore warnings by default) * No proper master-slave implementations * No support for users * No cascading triggers * No typed ENUMS * No concept of schemas or schema inheritance
Nah, it was mostly, &gt;It has always frustrating to say "We use Go at Google, I just can't say how." So I'm happy that now I can say that YouTube use Go in their core infrastructure, serving more than a billion requests per day with this service alone.
 $ gofmt -d gobl014.go | grep '^+' | wc -l 579 $ gofmt -d gobl014.go | grep '^-' | wc -l 571 
Oh, sorry, yes. It should be /pkg.
(Care to explain the downvote? I'm rereading it, and it still looks like a simple question).
Even if you do not use github yet, you can name your directory with the name of your future github repository. When you'll be ready, uploading it to github will require no change from other packages.
Did you make real programs in Go ? Error handling verbosity **is** a problem but saying that the language is ridiculously verbose is... well... ridiculous... 
I'm curious. You've been, uh, silenced very quickly, but is there something beyond error handling you dislike? Frankly, in my opinion, it's just as easy to (probably stupidly) ignore errors in Go as it is in any other language I can think of...
What language doesn't have verbose boilerplate for handling errors?
It certainly has support for users. The fact that you missed that makes the rest of your claims specious.
Maybe Erlang, but it cheats: its philosophy is simply let the [light-weight] process dies and let the internally-built supervisor process restarts it.
Go's control flow is *explicit*. That means that in the places it can return, it says "return". If a return is dependent on an error, it's wrapped in "if err". That looks like verbosity. Actually, it's honesty. Ruby, C++ or Java could return from *anywhere*. Your short simple Java function is actually a functional part of a handler mechanism six calls up the stack. This hidden complexity *will* bite you.
What I was thinking about was simply a shortcut. Let's say you have a function that returns A, B, error (I never saw a function returning more than one error). Instead of writing var a A if a, err = doThing(); err != nil { return nil, nil, err } You could have a, ^ := doThing() The ^ meaning that if the value is not nil it takes the place of the returned error of the function, which would then end as with an explicit return. All other returned values would then be uninitialized if non named, or at their current value if named. The only weakness I see is the possibility it could lead to many developers using it everywhere without thinking anymore about the errors and their handling. And that may no be SO important, as error handling verbosity is only in my opinion a small problem, more an imperfection that anything else.
Thats an interesting suggestion. This would make the syntax less verbose, and might demand implementation of a common error handler. But.. how would you suggest we proceed if the error handler (doThing()) were to error? Should it simply panic? Can we recover? Theres really nothing that prevents it from returning err all the way back up to main() (or to no where in the case of a go routine). Eventually, action has to be taken.
That's not true. I used to be an exception hater for years. Good exception handling mechanism such as those in Haskell and Python finally converted me, and considerably simplify and shorten code which is otherwise a mess of error handling. In addition, Go already has defer, which is a partial step toward what is necessary to handle exceptions. 
Either I don't understand what you write, either I was the one unclear. doThing in my example is not an error handler but the function that can make an error.
Hrmm.. now that I rethink my response, youre right (and Ive been drinking). I read that statement wrong, but Im still curious how you would propose we deal with \^? Would it just trigger a defined handler? edit: Again, I shouldnt be responding hahah. Im curious, but Im wondering what you propose other than saving a couple of lines of verbosity.
Yeah, it could look up the singular error typed return parameter, use that, and set the others to zeroed values. But my syntax was to try and avoid introducing that much magic, by spelling out explicitly what to set. On the other hand, bare ^ wouldn't require named return parameters. So maybe it's worth having both, yeah.
It doesn't. It has support for a user combined with a host.
[Already posted...](http://www.reddit.com/r/golang/comments/qad2z/vitess_facilitate_scaling_of_mysql_databases_for/)
I am speaking of the compiled application. How could I distribute it to other people (Internet at large), etc.
I think the executables Go makes depend only on the platforms architecture and libc. You just ship your exe and youre done. The joys of static linking :)
Wasn't possible to embed a scripting language? or just use a socket server/webservices to provide new plugins?
Nice article. &gt; The one big potential negative is that it’s compiled. In Python I often find myself stepping into third party libraries. Always having the source code is fantastic. One print statement deep in a someone else’s code can really help comprehension. No being able to do this in Java was a problem That's a problem only if you use third party libraries without source code (Are there a lot of them available ?). If you got your libraries with source code, you can always fix or change them then make a go install. Or do I miss something ? For my part I like my server program to run, and to run fast. I want it to be compiled and optimized by the compiler. Regarding the read-eval-print loop, I have a simple void program that I call with a small bash script doing the compilation and execution, and I change this program when I want to test something. That's not terribly long to use, I just have to add a alt-tab between code typing and execution.
Or he could load shared libraries, and then the plugins can be written in C or C++? Would that work with Go?
I was looking for a xmpp (or jabber only) library. The're one written by Russ Cox, but it's working only with gtalk, and there's another one I can't remember right now, that does not work with current weekly build. So, instead of Go, I'll give C a try or fallback to Python.
&gt;embed a scripting language that was my first idea too taken from http://go-lang.cat-v.org/library-bindings: * [campher](https://github.com/bradfitz/campher/) - Embedded Perl in Go. By Brad Fitzpatrick. * [golua](https://github.com/afitz/golua) - Go wrapper for LUA's C API. By Adam Fitzgerald (aka fosho). * [go-python](https://bitbucket.org/binet/go-python/) - Bindings for the CPython C API that enables you to use Python from your Go programs. By Sebastien Binet. * [go-v8](https://github.com/mattn/go-v8) - Bindings for the V8 JavaScript implementation. By mattn.
That should be much better once Go 1 is out, which should be in a few weeks.
A Go program can't daemonize itself, but a second program can be used to run a Go program as a daemon.
OK, understood. But I don't think that it's totally impossible to do with compiled languages as long as they have nice things like reflexion, look what can be done with a remote debugger. 
I think this is a fallacy. If you are in an environment that compiles your code quickly and easily, then you can do all these things in a compiled language. Go play, for example, is fairly interactive. Functions don't exist by default to let you inspect types the way you would in many REPL languages, but they'd be fairly easy to write using the reflect package. Bonus: you can go back and fix mistakes without having to undo damage and retype entire blocks of code.
I work in a group that participates in a lot of large and small bioinformatics projects and we've been moving in the oposite direction, abandoning a couple of large java projects with complicated plugin systems and focusing on writing focused tools (using go, python, java and other languages) that comunicate via the defacto standards of web services and unix style file based io. Swappable plugin architecture seems like a good idea to software engineers but when a scientist comes up with something they want to integrate it will most likely involve extensive code already written in R/python/matlab/perl/C/Fortran/Java or involve querying a public database using REST/JSON-RPC/SQL/HTTP. No one wants to rewrite completely in an unfamiliar language and figure out a whole new type hierarchy just to see how something works with a new system. Go has been a great language for us because of the ease with which we can set up a system to accept tasks over web services and launch and monitor corresponding command line utilities load balanced out over a number of servers. Users can write tools to work with our systems in any language or wrap existing tools using their scripting language of choice. 
I don't understand. Are you saying that fast compilation is equivalent to a REPL?
XMPP is a truly horrible protocol, all implementations for all languages are incomplete, crippled, or plagued by incompatibilities. In any case, you can use cgo to link against a C implementation.
That's not saying much is it? For many purposes a Porsche is the same as a dump truck. Those of us that love dynamic languages live inside supercharged REPLs and we miss them when they aren't present. We can achieve some of the uses in other ways but it's a work flow we find to be less than optimal. That's fine if we're ganging something in the trade off. The stuff I use golang for aren't the same as what I use ruby for. I've been playing with golang to make things like autocompleters, and I simply can't do some of these things in ruby the way I want. But I do miss my Pry REPL :)
http://www.manpagez.com/man/3/daemon/
Are you trying to say you don't want a dump truck? Everyone wants a dump truck, dump trucks are awesome! Also, it's not just dynamic language users, we Haskellers use ghci constantly.
Could you point me to a github repository that offers this or some sort of build scripts? Thanks...
If you think this idea deserves some attention from the Go team, please don't refrain to suggest fix regarding the presentation or the core topic (for example because I'm not a native English speaker). If you find a problem rendering this idea stupid, please tell it too. 
you're probably get more responses from the GoNuts group.
You could use "return" instead of "throw" when talking about the error value. That confused me at first since I thought you were talking about some form of exception handling. I feel this would be a tad too magical to be go-like, but the basic idea of removing boilerplate in error checking is good.
Did you just reimplement INTERCAL's "COME FROM"?
Just in case if you're not paying attention closely to golang-nuts. I discovered that thread by accident.
There are many ideas but why not just use exception handling ala Java, C++, C# 
how does the ^ relate to the return value? There doesn't seem to be any connection in that proposal. I could see a conditional return being useful. eg. return err != nil; err Errors aren't special in Go, they are just another kind of value like an int. 
Why ? We see rants after rants based on the "verbosity" of go. Of course, they're rants, and their examples are sometimes biased. But they come mostly from smart coders who express themselves in rant because they're like disappointed lovers who feel that the language isn't as good as it should be. And even faithful Go lovers like me cannot ignore that we **do** have code that is less expressive and readable that it should be because of those *if err!=nil* tests. As I said in my blog, we could generalize. But the gain, there wouldn't be as important. Errors, in my opinion and in the one of people concerned enough to rant, **are** often special enough. And we could have the best of both worlds. 
One of the important things that people should be learning from Go is that errors aren't special. Until recently the language itself didn't even have the concept of an error and now it's only mentioned as a built-in type similar to other built-in types like int and bool. Errors are just values, some values indicate an error in one context and normal in another. Making it easier to handle error values that satisfy the error interface actually makes it easier to ignore and mishandle error values that don't.
I was trying the ./make.bash approach and was having issues with it. I was told not to use it more or less, or at least that's what I took away: http://code.google.com/p/go/issues/detail?id=3136 But I may have been making some other silly sort of error. I wound up with a pair of zsh functions that I use to generate the compiler/standard-libraries (`gma_setup`) and then (`gma`, think "go make all") to build all targets and zip them for a given project. https://github.com/colemickens/scripts/blob/master/dotfiles/_zshrc_golang edit: Gah, of course I didn't link to a specific revision of that file when I filed that bug against Go... here's what I was originally trying to do (mirrors the ./make.bash technique shown here) https://github.com/colemickens/scripts/blob/a492c7341bb648d09eb847b82ec0bad3a8daa8c9/dotfiles/_zshrc_golang
Its a bit odd to have the recommended package name be different from how its declared (e.g. ghclient vs client). If ghclient is the recommended and documented package name, then why not actually use it as the declared package name?
i have been doing this in will-be-production code for weeks, for many different json formats here is my advice: start with structs. if your json has a known structure, try to match the struct to it as best you can. at some point of depth, you will either: 1. have a format which isn't predictable 2. have data you are willing to treat as opaque at this point, use interface{} i recommend against using interface{} as your go-to for binding the entire json in cases where the json has a known structure, as you limit your ability to use the type system, and as you will find, go itself becomes less cooperative. here is an example: {"Foo":{"Bar":{"a":"b"}} assuming Foo and Bar are fixed: type FooStruct struct { Foo BarStruct } type BarStruct struct { Bar interface{} } which basically says anything inside Bar is opaque. you can still get to it, but its a pain in the ass the nice thing here is we can then say stuff like var foo FooStruct foo.Foo...// do something foo.Foo.Bar ... // do something etc...we don't have to deal with maps and such just remember some gotchas - if you have maps etc in your struct, you still have to make() them! this can get a bit tedious for big structs, but its worth it if you want real types and obviously, if you have no idea what the json will look like, interface{} is your only choice
This comment is served by Python.
ah, the token RTFM. I run fucking Gentoo, I read the fucking manual :)
I suggest you wait a week or so for the Go1 release and try again then. There will be a binary release, distros will package it and everyone will update their code for it so most third party packages will actually work. Currently the Go ecosystem is a bit of a mess, many third party packages are either written for the old release or one of a number of weeklies since then and now. The weeklies aren't supposed to be stable, they are just the changes that happened in the last week. Sometimes some new features aren't really finished and can be confusing for anyone not following development closely. 
There is nothing to fix. The OP is essentially complaining about the instability of an unstable release. Check out the 'go' tool. Building packages is incredibly simple.
Should be a la Python or Haskell
Python exceptions suck as much as any others, specially given how much they are used for all kinds of insane convoluted control flow hacks.
Hardly. 
I pulled the nightly go, and go build ws.go gives me: ws.go:23:9: import "code.google.com/p/go.net/websocket": cannot find package Is there any magic I need to do?
Never mind, figured it out. I had to get the source of the project first and then install it: go get code.google.com/p/go.net/websocket go install code.google.com/p/go.net/websocket
&gt; Because pretty much everyone agrees exceptions, specially ala Java, C++, C# suck. Everyone? Even if they would suck there are no alternatives that are better 
because alcohol is a great way to get people to come and meet with strangers. Plus, drinking is both fun and optional. Finally, why even have a meeting without alcohol? That seems weird, right?
So... far... north...
He asked why so many meetups involve alcohol. There was no critique, just said "not to be a downer", then asked. I agree with you. Coding and beer go together like coding and beer. 
Let's go
I think you mean, "Let's go*lang*"
so when go1 comes out, should i ditch on weeklies? are weeklies going to start becoming more experimental and dangerous?
My main concern is a similar issue I had with the BarCraft meetups. I love golang, and I'd love to meet up with other people over it, but unfortunately I'm shy a year to come drink at a bar (less than a year now.) Good luck with the meetup though, maybe I'll see you guys later this year for some coding and beer!
ah, yes. sometimes i forget i wasn't always old.
Haha, as a Wisconsinite I fully understand the sentiment. In this state turning 21 is nearly a rite of passage. You cross that age and you wonder how you survived the last 20 winters without some vodka in the gut.
That's unfortunate, considering the most-installed package of all time, except for the go tour, is web.go.
&gt; go to know FTFY
There's a lengthy Google preview at http://bookstore.iuniverse.com/Products/SKU-000541025/The-Way-to-Go.aspx as well as the TOC at the link above. The ebook's in Adobe Digital Editions format, not PDF. I'm ok w/ that; you do get 628 pages for only $4. No review, yet, as I've only had 15 minutes with it. I like that common Go idioms are noted, and there are tons of code/examples (you can download the code from the link), even exercises. Some new stuff I haven't seen: p492, he advocates a method of error handling where he wraps all critical error checking in a closure and executes it immediately, then checks for err once; interesting. Chapters 16 (pitfalls) and 17 (patterns) have some quick tips that seem useful. 18 (common snippets) has a quick reference for common syntax/structures in one place; definitely bookmarking that one. One of the early chapters refers to Go 1, so I assume that the author has taken that into account regarding any language changes. edit: I suppose folks want to know if it has anything Go tutorial/Effective Go don't have. He seems to supplement the online material. There's more coverage of Channels/goroutines/lambdas and templates than I've found elsewhere. Section 15.6, he refers to the codelab wiki on golang.org, and then expounds on it which is helpful.
I think we're going to relax for quite awhile after Go 1 and let things settle while we work on writing code _using_ Go 1. (We've been looking forward to the stability too.) Go 1 will be branched and craziness can resume on trunk later, but no specific timelines are planned.
Don't name it foo.go. That breaks the go tool, which assumes *.go are local files, even if you say "go get github.com/USER/proj.go". If those are the only two choices, that argues in favor of go-foo, but even go-foo is bad because: You really want your import names to match the default directory. That is, given: import "github.com/USER/bar" Your code should be able to say: x := bar.New(...) And you know where bar is from. Having something like: import "github.com/USER/go-bar" is then odd, since "go-bar" isn't a valid identifier. You either force people to assume s/^go-// from mentally mapping the import name to local package name, or you force them to do stuff like: import bar "github.com/USER/go-bar" ... for readability, even if that's redundant with the package name in the "go-bar" directory. In conclusion, drop the "go-" or ".go". You don't have to name other languages in their project names, do you? Keith Rarick was theorizing the other day that people are only doing this now because Go is new. But if you have to, use either "go-bar", or put the package name in a child directory like I did here: https://github.com/bradfitz/gomemcache Where you would do: import "github.com/bradfitz/gomemcache/memcache" It's a little longer, but it has both "go" in it, and the import path matches the package path. 
Looks quite good, and pretty cheap, only 4 bucks for ebook version. EDIT: In fact, it is very good in term of keeping content up-to-date. The book talks about Go 1 beta and not r60 or older releases.
Some examples of project types and names would be great. So we all get off on the right foot.
I don't think that would be a fairer comparison, writing in that async style is much more painful and cumbersome than writing the blocking style.
Yes, the key line is: &gt;The wonderful part is I had no idea Go did this. I wrote each version as simply as I could, and the Go version just turned out amazingly fast. And that is true. Go makes it harder to write an especially poor server with no extra knowledge out of the box. **But** the same is true for Node.js! And, honestly, the async style of Node is not much harder (or much different) than a looping style. The best way to illustrate this is with code. I hope to have time to post a few alternative examples onlines soon.
gobrew woulda been a cooler name, just sayin' (Especially since VM has *strong* connotations of virtual machine)
just update your code for go 1 and forget about hacks like this. 
The name is more or less a reference to Ruby's RVM.
Try gofix on it. If std lib changes is the problem, gofix should be able to fix it. 
Eh, sadly I have to disagree. Hooking into bash/zsh like RVM does is rather a mess imho. I think it's a shame that sort of system is so necessary for Ruby, and would really like to see Go not go down that path. Well, to be fair I'm not sure if it's more a failing of package managers or Ruby, but either way I'm not a fan of the situation.
I'm not sure where the failing lies either, and I'm not necessarily a fan of how they implemented RVM. It just makes life much easier when there are a number of environments to switch between. It appears that GVM isn't an official tool, and frankly, I don't do enough with Go yet to have a need for such a tool. Have you used other sorts of "version managers" for switching between tools that you think would be better? That's not a loaded question. If there is a better solution to be emulated, I'm interested.
tools like perlbrew are typically designed to let you work with *newer* versions of the sdk than the one available in your package manager. govm seems focused on supporting and extending the life of older sdks. since go1 will settle the api and syntax changes, the best thing to is to just migrate. olders sdks won't get backported bug fixes. no one on the mailing list will waste their time answering go r59 questions. staying with an old sdk is a dead end. just fix your code
The force is strong in this one. I'm predicting April 1. 
That's the twist? The language was a joke all along?
The joke is that under the covers, Go is an elaborate syntax rewriter that just reverses the order of your declarations, and #defines a bunch of stuff.
Where? Maybe you are thinking of RC1?
I didn't see it, so for me its a good 're'post
I'm not sure, but I suspect you'll see a pretty big surge of content updates once Go 1 is released.
You're confused. This is the first time Go 1 RC 2 has been posted to the /r/golang subreddit.
Yep. 
It's not but checkout http://godashboard.appspot.com/project This is better. Cat-v is full of libraries that haven't been updated since the 0.6 release. 
I like the approach used by Gary Burd's documentation tool available http://gopkgdoc.appspot.com/ more so than the cat-v index. It stores a pretty comprehensive list of projects in the project index as well as creating a nice repository of documentation for golang community libraries. I used to host my own documentation for my redis library, but now I just use the service instead (http://gopkgdoc.appspot.com/pkg/github.com/simonz05/godis)
yay!
Now witness the firepower of this fully ARMED and OPERATIONAL yadda yadda yadda...
a question: should i now stop using weeklies? 
Unless you're interested in tracking the development of the core (which will be moving much more slowly now), there's no reason to track the weeklies.
I agree mostly, except for end-user binaries. I have a project (devtodo2) that generates a binary called "todo2", from the source tree "devtodo2". The go tool always generates a binary with the same name as the containing directory, so it generates a binary called "devtodo2". To preserve the original name for my users I've had to keep the Makefile around :( Edit: I also have a man page that I install, and "go get" et al. have no solution for installing anything but Go binaries and libraries, AFAICT.
You're probably right. I'm used to deploy go sources on my servers (thus I can simply run test, benchmark, and so on everywhere, compile time not being a problem). So I don't really know how to deal with different archs.
or just a simple shell script that call go tool and then rename the file?
What are the problems? File an Issue.
What I do, sharing a filesystem between Linux and OS X, is set the GOBIN environment variable, so the final binaries go to different directories. (pkgs already do this by default) 
There ARE problems, this is a real task. I had a lot of code to rewrite due to changes in error, or date/time API, or file hierarchy walking. And of course to replace the old database drivers to use the new (simpler) database/sql. But for 10k LOC, this will be done in a few hours at most, and only once. And it's worth it.
That's a good point. My go code being mostly on open-source projects with friends, that was always fun, but I can guess that my customers would have a different opinion...
Put the source in a directory called "todo2"?
The Makefile uses "go build -o todo2". The problem with "go build -o" by itself is that it then requires the user to manually install the binary somewhere. Not a big deal, but another step that is nonexistent with make: make install Done. vs. go build -o todo2 *.go install -m755 todo2 /usr/local/bin install -m644 todo2.1 /usr/local/share/man/man1 My point is that the "go" command is not a complete replacement for make, and nor should it be. It does however, simplify and unify the process of building Go code *significantly*. (I've updated my previous comment to mention the man page, which is the other main reason to use a Makefile.) Edit: Wording.
I wish they renamed the language to either golang or Go1 (with no space) so it could be googleable.
Might as well use a makefile, since it can execute arbitrary commands and people already expect to type `make'.
&gt;There has never been a better time to be a Go programmer. Yeah! 
I know nothing about pkg-config, but it might be worth including this in the main Go distribution, just today I did a `go get` that failed because I didn't have pkg-config installed, and as far as I know it is not available for Windows either.
That's a good reason to use it for the 5% of cases where performance matters. 
Compared to most languages : * Less superfluous code *(tip : if your IDE can generate code for you, that means you have superfluous code. If it helps you generate comments, that's just ridiculous)* * less superfluous settings * less superfluous concepts, design patterns, facades, etc. * less surprises. If it compiles and runs the first time, it's probably not too buggy * no time waiting for compilation A Go code is clear, readable, and don't you make desperate because you're looking for the implementation lost among comments decorations, indirections, thread synchronization, exception catching, or code only meant to obey interfaces. The other language I see which has the same properties and is fun too is javascript, but it's fun only until you share the code with people not sharing the same style or not rigorous...
Maybe because their ranking on TIOBE wasn't their first preoccupation ? If you're looking for something specific regarding the go language, simply put "golang" in your query, it works very well.
I think the solution to this is for everyone to just start calling it "golang" _everywhere_. The community can solve this problem without waiting for the language maintainers to make a change.
I verified that you must, indeed, if you're blogging for example, use the "golang" keyword accordingly. But that's not so terrible. BTW... I just realized that by replacing "Go" by "golang" as the related category on my blog I may have say to TIOBE that "Go" is fading :)
sure, I'm not saying it will affect a lot the success of the language or anything. It's just... it's google we are talking about! I would have loved to be in "that" meeting.
You should probably go for Python instead if you are new to programming. So far I have only seen Go tutorials aimed at experienced programmers.
I don't think "Go" is a terrible name. It's short, its a great language keyword, it evokes "Google", etc. The search engine problem is overblown. But then, I think significant whitespace in Python is just fine, the parentheses in Lisp don't bother me, and I've made serious use of both vim and Emacs in the past. Maybe I need to learn to be more angry.
It's not just for Go. Tiobe's ranking is unreliable at best. I think it's the only index still around, though (since langpop stopped updating around one year ago) and sometimes a wrong answer is better than no answer at all. Ironically all these articles about go failing to gain traction are probably going to boost its position in the next month's Tiobe index.
I'd advise against learning go as your first language. I say that purely because it's not a extremely popular language. When you're learning something new, it's always best to start learning with the most popular thing, simply because there'll be the biggest community and the best beginner help. So start learning with Python or Java or even C. There's a huge amount of established literature for these languages, and they're very stable. Go is a really cool great language, but there isn't a huge amount of searchable help, and a lot of it is out of date.
In my opinion, if it's a first language, then it really does not matter what you learn. What you should be aiming for is understanding language structures, small algorithms, coding styles, etc. which follow similar ideas across almost all languages. So just pick up any one. That being said, the language you should ideally go for first is the one that your friend or neighbor is using, and who can help you with it. There will be a fairly steep learning curve if you are a total newbie, and what you need is typically a helping hand so that you don't irretrievably slide down the curve and hate programming for being only for geeks, nerds, and scientists. And once you are over that first steep hump, it is a valley of many minor humps - each of which you can get over much easier. And Go? Sure, absolutely, why not. It's a simple language with very clear, straightforward constructs, that behave exactly as stated. It is easy to obtain, easy to set up, needs no specific development environment or editors, is very fast, its coding style is succinct, and your ideas have an enormous space to grow into. I'd say, give it a go. Here are some resources: http://golang.org/doc/install#install http://tour.golang.org/#1 http://golangtutorials.blogspot.fr/2011/05/table-of-contents.html
For Go to really make sense, it helps to understand how exactly memory works in your computer—the heap, the stack, pointers, addresses, the difference between int and uint and long, etc. So, I think it makes more sense to learn Python first, then go back and learn Go when you're ready for something more low level. 
Well, there is [this](https://go-book.appspot.com) which is aimed for beginners.
Really, who about TIOBE and its joke rankings?
Go is a game, python is a snake, ruby is a gem, Java is a country. When I search for python,ruby or Java I get the programming language. These languages have been around for over a decade. Go is young. "go" will start meaning "go the programming language" in about 10 years. You can help this along by linking the word "Go" to golang.org
I've been teaching myself go sporadically, but I wouldn't recommend it as a starter language coming from a fundamentally non-technical background(though go seems to be making great strides in bringing the bar lower to understanding a compiled programming language). I've gone into python and ruby without knowing a thing and picked up some over time, so I'm picking some things easier(others not so much). If you're totally new to programming, it might be frustrating but that depends on a lot of different factors. What would make it a good choice would come down to *you* really: what your proficiency level, coping with the frustration of something new and possibly dense, how you deal with math and computation stuff, how you learn, and what investment you want to make in your learning, etc.
I'm not sure a newbie programmer would be able to easily go through this tutorial. I don't think the explaination of structs or pointers would be satisfactory for a newb. Newbies need a more thorough explanation.
Good programmers can learn new languages quickly. Which one you start with doesn't matter nearly as much as programming often. Practice makes perfect. Anyone telling you that the first language you learn matters is a language zealot who is not so subtly trying to get you to learn his favorite language first. You can safely ignore such people.
Well, there are limits to the good possibilities. Prolog, for example, would not be a very good choice for a first language. :P
If somebody today's write something about Go without knowing he should use "golang" as keyword, chances is he didn't spend enough time researching the subject. I don't think you'll miss so many pertinent results.
C has an awful tool chain and ugly IO interfaces. Java crams down your throat oop crap at every corner. Python is better, but relies too heavily on high level data structures which are too much magic for a beginner. 
Yes, all those things are true. But they also completely miss the point.
It clearly is, the first few slides chiefly discuss the differences between Go and other languages.
I learnt C as a beginner, so you could say anything Goes. But it wasn't easy and Go requires a similar level. Python is definitely an easier path and will probably be more useful to know. I think if Go was your first language then you might be quite disappointed with mainstream languages.
http://blog.golang.org/2012/03/go-version-1-is-released.html
Someone should start a rankings site based on commits on Github and other public code repositories where you can tell more reliably what language is being used.
I sell software that helps in surveying plants. As long as my customers think that nobody knows Go and that they'll be fucked if I leave my job, they won't like me coding in Go. EDIT : now that I think about it, a courageous director in a steel company helped me launch my big project in Java when it was still beta. A few months later the java program was successfully surveying plants and it still does :)
C is also a very common letter. 
I [wrote a review](http://www.amazon.com/The-Way-To-Introduction-Programming/product-reviews/1469769166/ref=dp_top_cm_cr_acr_txt?ie=UTF8&amp;showViewpoints=1) for The Way to Go on Amazon. TL;DR - Fantastic content, shitty writing.
I find it odd that it is so hard to search on google for a google product. Yes golang is what you should use but the name of the programming language is "Go".
The author of the post is the creator of HAML and SASS for the record.
Great example of non constructive criticism.
I think the reason for GC was that manual memory management is hard in concurrent code. You not only have to keep track of liveness of objects, but also keep ownership very very clear. This is too much work to be worth it.
&gt; You should probably go for Python instead if you are new to programming. From a language point of view, why would you prefer to learn with Python than Go? Go is simpler, clearer and with much less magic, it is much easier to know what code does in Go than in Python.
&gt; When you're learning something new, it's always best to start learning with the most popular thing, simply because there'll be the biggest community and the best beginner help. I'm not convinced, much of that 'help' can drive you down very bad paths that take many years to unlearn.
&gt; I think if Go was your first language then you might be quite disappointed with mainstream languages. As opposed to being disappointed after ages of using them and then finding out the are full of unnecessary complexity that wasted years of your life?
Larger community, lots and lots of libraries (both in the stdlib and 3rd party libs), many resources explicitly aimed at programming newbies (this may come for Go in the future). Even if you have to worry less about low level stuff with Go than with C or C++, it is still more low level than Python. I think it is best to use a language that lets you worry as little as possible about low level details when learning to programming. Learn the basics (variables, loops, functions, etc) and then get lower and lower. Don't get me wrong though, Go is a great language.
I would like to see some more sources if possible.
http://i.imgur.com/lOXD6.png
I suppose we will have to agree to disagree.
You're arguing a bit in circles. First you claim that starting with C can't be *incredibly* bad since universities and colleges teach it in the first year. Then you claim that first focusing on a dynamic language such as Python would be ridiculous. And yet [a good number of the colleges and universities on this list](http://wiki.python.org/moin/SchoolsUsingPython) do teach Python as a first language. By your definition it cannot be ridiculous, right? Colleges and universities may pick a first language for a number of reasons. One big one is inertia -- I learned starting with C and I'm super-competent thereforem, so if it was good enough for me.... And if you believe that universities would never do something incredibly bad, consider how medical schools are shifting away from long shifts of sleep-deprived residents. It wasn't good for the residents or for the patients. Second, you imply that a first language should get you close to the hardware. So if C is good, wouldn't assembly be better, and direct machine code better still? Hell, why not microcode? Why not learn semiconductor theory before learning how to program? Even you realized the problem of heading down that path, but yet you dismiss Ruby and Python for not being close enough to the hardware. Please remember, we're not talking about the totality of what someone might learn in a degree program, we're discussing which language to start with, which language is best to help people break up big problems into a series of steps (i.e., calculations, assignments, conditionals, loops), breaking things into re-usable components (i.e., functions, objects), distinguishing among basic types of data, building algorithms. There are a lot of useful things you can learn and become facile with before ever needing to talk about a memory address, the heap, the stack, and so forth.
&gt; "Four out of five language designers agree: Go sucks. The fifth was too busy [to answer] actually writing code [in Go]." This one? I took it to mean that the detractors were complaining without having tried Go. Is that right, or does it mean something else?
I think your interpretation is correct.
if you leave off the parenthetical guesses, I'm pretty sure what it means is that four out of five language designers say go sucks; the fifth is too busy coding up his own language to bother even commenting on go.
At least their software solves a real problem (and presumably makes life easier for many people), unlike most code out there.
Sure, but that doesn't mean it can't be boring.
Sure, I'll send a member of parliament right over.
Good idea. I'm good at AI. I'll reprogram him. There are a lot of bugs in those nasty bots.
Russ Cox, the guy who wrote the Regex package for Go, has a hate-on for PCRE and backtracking regexp engines in general. Brad Fitz, one of the other Go developers, implemented backtracking regular expressions and suggested merging them in to the Go regex package. A beautiful troll.
Here is the Gtk3 version using gobject-introspection: https://github.com/norisatir/go-gtk3
Cool... what about go-cocoa?
Can I use this for Windows too? I suppose I need to have GTK for Windows installed, but is that enough?
AFAIK it should work on Windows. But on windows you can also use [walk](https://github.com/lxn/walk) to create native UIs.
You should wait for Go to have a pet store on AppEngine, though.
Those projects are dead.
I asked the same question a few days ago on OSdev, and you might want to join here: http://forum.osdev.org/viewtopic.php?f=1&amp;t=25089
Cool, never heard of this forum before. Thanks for the link!
Thanks for the links, I'll check these out.
Good link but don't leave us and keep us informed if you make some progress on this topic ;)
I'm not sure I understand your problem but your *src* directory should be in a directory itself in your GOPATH env variable. Then you can simply do go install shared or go test shared or go install appOne my projects all look like this : /myproject /myproject/go /myproject/go/src/ /myproject/go/src/appOne /myproject/go/src/appTwo /myproject/go/src/appShare And I put the non go stuff in other directories of /myproject
Essentially that's what the error message says "named files must all be in one directory". So the proper way would be to make those things visible in shared. You can use `import . "shared"`, that way you won't have to explicitly say that you are using things from that package, but it still requires the visibility changes.
I'd like to point out that your program underrepresents the number of goroutines spawned - the line "count++" is not threadsafe, since it reads, adds and writes (separate operations). N goroutines trying to do that at the same time might have the cumulative effect of adding 1 to count! Normally this would be pretty unlikely, but your program is a bit of an outlier. Of course, with GOMAXPROCS=1, it isn't an issue. 
on my MBA, with a bunch of things open, I got up to about 560k from the sample provided, but I got 760k with the following: package main import ( "fmt" ) func main() { c := make(chan bool) go func() { count := 0 for &lt;- c { count++ fmt.Println(count) } }() bomb(c) } func bomb(tick chan bool) { for { tick &lt;- true go bomb(tick) } }
Not sure if you could write the OS kernel in Go but you'd certainly be able to write most of the core programs and libraries for a system. If you had some sort of microkernel architecture (where most features are provided by server programs which run on top of the kernel) then many things like file systems and probably drivers should be workable in Go.
Interestingly, I switched to an atomic add, and added a stdout flush just in case anything was getting lost in a buffer when it was killed, and got just about the same result.
How much RAM and how much swap space? OS info? 
 $ uname -a Linux bacchus 3.0.6-gentoo #5 SMP Tue Feb 28 18:38:51 EST 2012 x86_64 Intel(R) Core(TM) i5 CPU M 560 @ 2.67GHz GenuineIntel GNU/Linux $ free -m total used free shared buffers cached Mem: 1932 1635 297 0 64 464 -/+ buffers/cache: 1106 826 Swap: 2047 98 1949 $ go version go version go1 * * * Basically, Linux x64 with 2 GiB RAM and 2 GiB swap. Main memory was closer to totally free when I did the test (maybe 1.7 GiB free), and swap was basically totally free.
&gt; A goroutine will only yield its thread when it performs one of a set of operations, which includes (but might not be limited to) IO, channel communication, stuff in the sync package or an explicit call to runtime.Gosched(). Excellent - this is very much what I was curious about. I had hoped that they hadn't repeated the mistakes of other threading/memory models, and glad they did.
Interesting; so that would seem to mean that only the first bomb() call would ever run.
`import .` is discouraged, it mostly exists only to make building tests easier. And I don't understand what does it really buy you here, what is the problem with putting it in a 'proper' package and importing it as such?
1.426.294 here, but it worries me a bit that the program simply gets killed after that, without any chance to recover :'(
I believe that the garbage collection is cooperative, just like the scheduling. Possibly triggered by allocations.
Try refreshing this page and the demo link again. http://jasondelponte.com/goapps/apollo is the entry point now. 
Cool, and cool to hear SmugMug is using Go!
I can't see anything, some problem with the embedded Google Docs(yuck)? In any case, I have to doubt the value of more silly micro-benchmarks without really looking into what is going on or how things perform in real systems.
Thanks! I think that some things are hard to roll on your own correctly, especially mitm proxy, but maybe you're right. no brainers: package identifier - the problem is that image is a very overloaded name, that doesn't give any hint to the content of the package. More subtle: * filtering behavior - indeed a bug, first matcher should take. * ReqHandler.Handle return bool. I thought about it, but it makes it harder to return a canned request instead of the original request. I'm still not sure.
On slide 41, what do the arrow operators do in the function definition? func worker(in &lt;-chan *Work, out chan&lt;- *Work) 
Nevermind, found it here: http://golang.org/ref/spec#Channel_types
I don't think that would've been a very practical decision. I can't think of a way to implement rune-based strings without big sacrifices in memory or performance.
It would just waste space and wouldn't actually make unicode easier to deal with anyway.
Why? You can have an array of runes if you really want it, but UTF-8 strings by default works really nicely and is very efficient.
The problem with UTF-8 is indexing is linear time. Python has always had constant time indexing of strings, so there wasn't another way to do it besides using UTF-32 all the time, which is crazy. 
If you really need indexing in linear time, which I find very doubtful, you can always keep an array with index pointers. I understand the reasons why they did it that way in Python, but I still question whatever it is worth the extra complexity.
It's complex, but only if you're dealing with the C. It's all transparent to end users who do things in Python. [According to the PEP](http://www.python.org/dev/peps/pep-0393/), they actually saved memory in a test they did with Django, FWIW.
The backtick isn't actually special here. The tag can be any string literal. The backtick is only used for tags because tags often contain double-quote characters, and it's easier to just use a backtick string literal than it is to escape the embedded quotes.
Slides don't work on Android?
Nothing quenches my thirst for programming quite like refreshing Go(TM).
stealth marketing :-)
"Next generation coca-cola music *experience*", are they going to start doing this too?
:-) i do agree with them though, that is a nice looking Vim theme
struct tags for json and all! time to buy some coke
I'm not sure I like your separation of concerns. You have a function named SocketHandler that takes a socket as a parameter. Every line you read from the socket you output to a log. If you get an error you write an HTML snippet (one line in a list) back to the socket. Why mix generic logging w/ HTML?
lol, well, sort of. Yes, it is my code, but it isn't node.js; it's the client side of my websocket application. It's a Spotify app. The browser in Spotify is actually Chromium, so you can use canvas and websockets and a few other nifty HTML5 goodies.
Clean your screen, with coke.
How do you implement goroutines in llvm? Do they support microthreads?
Disclaimer: I'm a vim user, and I don't think I'd ever switch to an IDE. I'd miss a programmable editor too much. On top of that, the Go tool is so stupidly simple to use, that an IDE loses a lot of its value. (As opposed to say, managing a Java environment... [shiver].) I also have no experience with existing Go IDEs. With that said, here are some ideas off the top of my head... Excluding the obvious ones like auto completion, some sort of "jump to" feature, etc... Also, most of these ideas assume you don't mind relying on the Go tool. (I think you should rely on it.) * gofmt support would be a must. A nice little button to "gofmt" your code would be great. Or... I think it would be great to automatically maintain two modes. One mode is "public"---i.e., the code you commit. The other mode is private and is code formatted to one's tastes. For example, the public mode would simply be 'gofmt -w blah.go' while the private mode could be something like 'gofmt -tabs=false -tabwidth=2 -w blah.go'. * Since the Go tool is so simple, I'd think that the IDE could very easily provide some sort of interface to it. i.e., automatically running 'go get ...' on package import or something of that sort. A package browser (using the current GOPATH) would be cool. * Maybe a godoc browser to look at documentation for code locally? (This could even be incorporated into little tooltips over function calls and whatnot.) * The IDE should also be aware of Go's built in unit testing infrastructure. The IDE should have a button or something that says "test my code" and it runs the appropriate Go command to do so. * It could also use the Go tool's CPU/memory profiler. Maybe there's a way to automate this so the user doesn't need to add CPU/memory profiling code to the project, but I'm not sure. I guess it could be done if the code was importable, but it would still take some trickery. * Here's a possibly contentious idea: provide some sort of "generics" support. i.e., "rewrite this code using X type instead of Y type." It'd have to enforce some function naming convention, i.e., 'funcNameX' translates to 'funcNameY' where 'X' and 'Y' correspond to the type names of X and Y. That's all I can think of at the moment. In hindsight, it looks like my vision of an IDE simply becomes a GUI for the Go tool. I'm not sure if that's the direction you want to take it, but it might also be indicative of how awesome the Go tool is. Also, for goodness sake, make your keybindings configurable :-)
Just dropping a wishlist... * Dropdown on package.[___] * Dropdown on f := NewFoo() ; f.[___] * Autocompletion while typing, eg. pack[age/er/...] * Keyboard shortcuts for build/install/test (Cmd-B, Cmd-I, Cmd-T) with configurable behavior (ie. "go build" or "go build -v ." or etc.) * GOPATH displayed prominently somewhere * gofmt on save Sublime Text + GoSublime does almost all of this already, but is rather difficult to configure and keep running. I think that's a good model, if it could be significantly simplified.
Disclaimer: I'm the main GoSublime author. Sounds like you are experiencing bugs? the one about fixing go tool paths have been experienced by some users. I haven't experienced any of these issues so I added the ability for you to set up the environment. AFAIK this has nothing to do with GoSublime, but the user's system not passing the environment variables to Sublime Text. Step 4 makes no sense as GoSublime has in the past provided example build systems to show you how to integrate the tool(s) you used to build your projects. If you look at it now you'll see that the examples are gone because I didn't want to maintain then(I didn't use any of them myself) and we now have a dedicated build system that gives you access to your $SHELL. anyway... if you see an actual bug, feel free to file it...
If any redditors are planning to go and would like to hang out and talk about code, reply or message me.
I think most of the Go team will be in town and planning on attending this one.
Yup. I'll be there.
I'm not working on anything yet, I've just been looking at Go IDEs and I couldn't find anything really special out there right now.
I'll be there. Super excited to meet everyone.
looking forward to a meetup in nyc
You just missed one - last Friday!
Flying all the way from oz just for that, that is dedication to the Gopher! ;) (Actually there is a chance I might drop by all the way from Scandinavia, but I like the spring/summer too much here, so is a small chance, hope you guys have great fun.)
&gt;The problem I was running into was that the golang JSON package requires upper case names (i.e. exported names) for marshalling and unmarshalling data WTF?
Sounds like there's been some changes, so I'll try reinstalling today. I'm really surprised you've never experienced the environment problems. It's happened consistently for me on OSX 10.5 thru 10.7 that the things I set in the Environment section (eg. PATH) aren't available in any of the other command lists (eg. the gofmt command) and I have to therefore specify the full absolute path to all of those tools. Just remembered another one: attempted autocomplete after '.' when I type it _in comments_. Is that fixed too?
We've updated it with more awesome: http://websomtep.danga.com/
I guess this highlights the importance of filling bug reports because I don't use os x nor windows so they suffer a little especially os x as i have windows in a vm. though thw path issue has been reported on ubuntu but again i can't reproduce it... anyway a long time ago i added the ability to set abitrary environment variables in your config so you don't need to set the full paths to the binaries. the bug about completion in comments was reported and fixed a long time ago as well
Meetups are fun. Typically there are a couple of presentations by people with interesting projects and experiences to share. Often there is food. Sometimes there is beer. I don't know the details of this event, because I am not involved with planning, but I can say that every technology meetup I have attended has been a good experience.
just look at what visul studio does for c#
The presence of corner cases doesn't mean env vars on an entire OS are broken. I run tons of software that relies completely on a huge set of env vars with no issue. I'm curious to know more about these edge conditions but they don't support your conclusion.
&gt; So you have your env variables set in environment.plist? No, I don't. Nor should I need to, if I'm setting them explicitly in the sublime-settings. The implication of putting an ENV setting in that file is that it's _explicitly_ applied to every command run from there.
The word "client" evokes "standalone", to me, whereas this is a Go library wrapping the API.
I know most changes are trivial (typos and the like), still there are several other bugs fixed and would have been nice to have a changelog of the same style as the weeklyies had. Yes, one can look at the repo history linked, but that is a bit to detailed. Or perhaps just a list of bug # that have been fixed, that should filter most of the tiny stuff and show most sutff anyone might care about. Other than that, it is great, now can't wait for the next weekly snapshot on the way to 1.1 ;) (Again it would be nice to have some visibility on the timeframe for 1.1, is Go going to do time based releases, or is there a feature roadmap (I know there are a few issues marked 1.1, will it be released when all 1.1 issues are fixed? Really would be nice to know what the plan is.)
Unlike most weeklies, there are no functional changes or additions in this release. It's just fixes, and nearly all of them are trivial. The majority of the changes are documentation tweaks. It is a boring list, but it couldn't be summarized in any meaningful way. If you care, read the history. Most people don't. We have no plans for 1.1. It will happen at some point, but not for several months at least. Here are the fixed issues between go1 and go1.0.1: ~/go% go get code.google.com/p/rsc/cmd/issue ~/go% hg log -r go1:go1.0.1 -b release-branch.go1 -v | grep ^Fixes | awk '{print $3}' | sed 's/\.//' | xargs -n 1 issue | egrep '^[0-9]' 3429 change 'affect' to 'effect' in http://golang.org/doc/code.html 3437 time: cannot find zone on Windows 3267 text/template: panic in mistyped call 3442 encoding/base64: panic on invalid input 3444 time.RFC822 is not RFC822 compliant 3449 database/sql's Exec doesn't propagate error from subsetTypeArgs 3420 doc: Broken link in "doc/code.html" 3433 net/url: Go incorrectly unescapes URL and breaks HTTP Redirects 3482 os: IsPermission broken on Windows 3478 minor typo in Go 1 Release Notes 3489 html: EscapeString(`'`) should not be &amp;apos; 3502 TLS certs are rejected if they have trailing spaces 3510 fmt: panic on printing math.MinInt64 with %b format 3367 crypto/tls: wrong private key used for SNI connections 3487 time.Parse fails with a single decimal digit 3474 doc/articles/image_draw.html: ColorImage should be Uniform 3522 doc/style.css: Incorrect lay-out package list with long import paths 3507 net: race between Close and Read 3549 reflect: document TypeOf(nil) 3545 cmd/gc: escape analysis bug 3492 path, path/filepath: document that Clean removes trailing slash 3546 encoding/json: '@' not allowed in tag name 3562 mime: be stricter parsing media types 3569 doc: Over escaping in Writing Web Applications article 
&gt; Unlike most weeklies, there are no functional changes or additions in this release. It's just fixes, and nearly all of them are trivial. The majority of the changes are documentation tweaks. Yes, i know. &gt; ~/go% hg log -r go1:go1.0.1 -b release-branch.go1 -v | grep ^Fixes | awk '{print $3}' | sed 's/\.//' | xargs -n 1 issue | egrep '^[0-9]' Ah, this is perfect! Still IMHO should have been part of the release announcement anyone that ran into any of those bugs will be happy to hear, but is a minor nit.
&gt; a minor nit. Keep 'em coming. ;-)
Well, I like the ring to "gonoip" :)
I found it useful for one, so thanks. Was there ever any follow-up describing maps and channels like he mentions at the end? I only found his follow-ups about interfaces.
Or Gno-IP... On a more serious note, it would be neat to have one that could support multiple dynamic-DNS providers, selectable via config. I might look in to making my own for DynDNS or something, just for fun.
It's a dynamic DNS protocol/service.
Specially with [mgo](http://labix.org/mgo) around, which I haven't used personally but seems to be getting rave reviews.
Just a PR post... nothing to see here.
According to me, nowadays the most essential feature is the PR for golang. This is another PR link. https://plus.google.com/115477067087672475993/posts/dfaHXKc9CGb
To see instantaneous results from changing code a la lighttable. http://www.chris-granger.com/2012/04/12/light-table---a-new-ide-concept/
I agree about the FUD symptom (the discussion on this topic on /r/programing was depressing) and more generally the fact that it's very hard to have problems with the GC without trying (hard) to get them (even on 32 bits) but it's not true that there can be no problem on 64 bits systems, it's just very very rare.
This looks pretty cool. Could you describe your method, or point to your implementation, of message (de)serialization on client &lt;-&gt; server (js objects &lt;-&gt; json over websocket &lt;-&gt; go types)? Lot of code on your repo.
The messaging system is pretty simple. Take a look at [game.go](https://github.com/jasondelponte/Apollo/blob/master/game.go) and [message.go](https://github.com/jasondelponte/Apollo/blob/master/messages.go). I have predefined structures in my message.go file that are created by MsgCreateGameUpdate() and returns a MsgGameUpdate object. There are several builder methods that will append data to the struture before the passing to json.Marshal(), before transmitting the message. The messages are also only built and serialized once, then transmitted so i'm not building the messages every time for each player. The exception to this is messages to specific players. I use a generic structures as the base of the in messages. For incomming messages I check for fields which are not nil, and process that data. MessageIn struct, and GetPlayerActionFromMessage() is a good example of this. For outgoing messages I set the message type in the message constrcutor then use a builder pattern to add data relevent to the message type. The client's (de)serialization is very simple. (and should be improved). The client will receive the JSON object from the websocket and use the object directly [client code](https://github.com/jasondelponte/Apollo/blob/74c2fe25408d89349370b3881b38bf5d89ebaafb/assets/js/apollo.js). WsConn.onMessage determines the type of message, and calls the handler for that section of the message. (setGameType, processEntityUpdate, processPlayerUpdate). I also made sure to limit the network track by using short naming of the serialized fields, and only send changes instead of the full board at once. When a new player joins they will see the full board, but any messages after that will only be what changes on the board, or broadcast of other player actions.
I assume you are referring to the GIL. Realize that the threading module in Python is for concurrency, not parallelism. This is well documented and therefore it is not "broken", just "sub-optimal". Parallelism can be achieved using the multiprocessing module.
The problem is that because of the GIL python has to try to multiplex many preemptiable threads in to a single flow of execution. So it's constantly fighting the OS scheduler that keeps scheduling the threads in the wrong order. It's kind of a mess but it's an unavoidable outcome of the C compatibility that python relies on. It's not really much of a problem and it's only a problem under certain circumstances, just the the problem with the Go GC.
The irony when we could be playing Go with Go.
Now we just need someone to design a programming language called "Chess".
I'm sorry, I'm really dumb, I don't understand this game, could you explain it beyond "The purpose is to match colored blocks to gain points." When I click on blocks, sometimes it 'sticks' (the block stays smaller) other times it doesn't, sometimes I get points, sometimes I don't, but I don't understand what the rules are. Edit: Ok, I think I get it, I need to click as many of the same color as possible, but some times even the clicked squares disappear and that was confusing. What I still don't understand is where is the skill and what is the multiplayer aspect of the game. I just don't get it. Other than that, cool :)
one point i disagree on...his suggestion that front-facing webservers like nginx are no longer necessary unless your application is trivial, this is false. just look at the knobs you can tune in nginx's https serving...none of those knobs are available to turn in go's https server. thats just the start....go look at any nontrivial nginx.conf and tell me where these features are in go's server. with all due respect, slides also confused concurrency and parallelism otherwise, great slides!!
This is really inspiring. When http://browserquest.mozilla.org/ came out, I decided I wanted to attempt to port it to GO/Dart, but have not found the time to really start yet.
Very cool! I had never looked at this before. I'll have to dig into their code. I'm curious what they do to keep client/server in sync. My solution was just to ignore commands from clients which weren't valid at that time. But if a client missed an update their board may always be out of sync. But since we sockets are basically tcp connections that may not be a noticeable problem. 
The matching part is a bit wonky, and I've found a few scenarios were the server gets confused what the first color a player chose and refuses to let them select another even though they don't have any actually selected. I probably should of added some instructions, but you're right it is a color matching game. For each match you make you get 1 point. Multiple matches you'll get a point for every block, except the first. 
"Its hard to understand then java" set up a little short story in my mind. Someone struggling with Go at their computer and then the [Duke](https://upload.wikimedia.org/wikipedia/commons/a/ab/Duke_java_maskot.gif) bursting through the wall, Cool-Aid style.
Nice! Development is moving really fast then. :-)
This looks great, thanks!
I am on Linux, so that's an option. Thanks!
(Don't) check out the "what's hot" page. It's like FWD: FWD: + 9gag + Facebook spam posts. :/ It's really embarrassing and it's worse when it happens on a popular developers post. They post something thoughtful and significant and then children come out to write inane nonsense like, well, like the examples listed here already.
&gt;This version should be completely up to date with respect to Go release "weekly/weekly.2011-08-10" Post again when it covers Go 1 ...
Its been updated for Go1, the website is just out of date. The github repo and the PDF files are all recent as of today from the looks of it.
As cybwraith said the site is not updated. The pre-built PDFs were last updated today! So it's updated with respect to Go 1: http://www.miek.nl/files/go/?C=M;O=D
One of my favorite aspects of Go is that it has low-level features like stack-allocated structs and lightweight coroutines – can (or will) your implementation do these things well?
I intend to implement local-variable structs as unpacked local variables. This may prove... *involved*... in the case of structs containing other structs as members (by value), but it should be doable. A method call becomes a call to a static method which takes as a parameter the value of each field. Again, the nested-struct case requires some thought. My first implementation of goroutines will be the naive one, but I will fix this before I declare the project completed. One-thread-per-goroutine is almost certainly unacceptable for a non-toy Go implementation.
And to leverage existing Java libraries and code, etc. I am curious to see how the JVM stacks up performance-wise against the native implementations. My current guess is that it will do slightly worse.
Because I have to release all the software that I compile with your compiler under GPL.
That's totally not my intent here; requiring GPL for all compiled software would be idiotic and preposterous. See the edit I just made to my above comment. Would LGPLing the runtime part fix the problem?
I don't know, I think you'd have to be a bit more specific in your licence. Just saying it's licensed under GPL provides no information on how I can use it, but I'm not knowledgable about licenses. Have a look at other compilers to see how they do it.
Go already compiles natively on windows, linux and osx though
I certainly think so!
When I want to punt on the license-choice issue I default to MIT - it's more free and I don't care if corporations use my code.
Here here. I've never had an even half-well engineered software package not compile on the supported platforms as advertised. I really don't understand the appeal of the JVM.
No, you don't. It's not a derivative work.
I personally see most Go projects on github. As far as my experience dictates, the Go packages supported by Golang devs (i.e., freetype-go, graphics-go, etc) are hosted on Google, and most third party libraries seem to be on github. Also, I'm pretty sure that Google Code now supports git. Regardless, I don't think a choice between hg or git will impact community contribution that much. Both are widely used.
hmm, I changed my server setup earlier today where i figured out how to put the websockets part behind niginx instead of being publicly exposed. It ws down for an hour around then. If it still isn't working for you i wonder if something between you an the sever is blocking port 81. That is the port the websockets are going to connect to. Nginx will close the connection if no action is received from a client if 60 seconds. I need to add client side ping to prevent that, but it actually works out well for now since it prevents clients sitting on a connection forever without doing anything.
Nice troubleshooting. I am behind a firewall that blocks port 81 it turns out. Tried behind no firewall and I can see the game.
I'm not a target as far as contributors are concerned(I'm not a Java nor GPL let alone GPLv3 fan)... but anyway, you shouldn't just assume that someone's objection to the license has anything to do with proprietary software. e.g. I'm about to *copy*, yes copy a module out of pkg/exp/types so I can embed it into my own project, thus bringing back a useful tool(gotype) and have a bit more control over it and if it were GPL that would be difficult if not impossible.
I agree Scala's a very reasonable choice given the requirements.
Some JVMs do escape analysis, so objects can be stack-allocated, too.
&gt; Regardless, I don't think a choice between hg or git will impact community contribution that much. Both are widely used. I disagree. Code on code.google.com is a hazzle. I very rarely read or write issues on projects hosted on Google Code. While on Github the entry level to participate on a project is lower. However, it really depends on if people are actually using your project. On my Redis client I get 70% of patches via Github and the rest over email by people who are not on Github. These 30% not on Github are so far corporate russian developers who probably don't use Google code either. I'm have a feeling that less of the other 70% percent would send their patch if I wasn't on Github. But this is obviously just my opinion and I have no real stats to back up my claims. 
You got me and IANAL. Honestly I didn't see the problem with the GPL in the first place, though. 
I certainly hope the struct implementation works out, I guess we'll have to wait and see. For goroutines, I get the impression that the main implementation's runtime multiplexes them onto a small number of native threads, but I honestly don't know whether the JVM's concurrency features allow that sort of approach. Would Fork/Join be of any help?
OP said he's considering relicensing in the future, so I'm *assuming* that means no outside contributors. Or is there some sort of contributor agreement for contributors to give the OP a perpetual, unrestricted license to their work? 
I totally agree with you. Github's user experience is fantastic. Superior to that of Google Code in every way, aesthetic and functional. (Github's pull request implementation alone suffices to establish its superiority for collaborative projects, no?) But the user experience of `git` itself is terrible, especially to the uninitiated. To the point that I fear that, if I were using `git` I'd screw everything up beyond my ability to repair it or otherwise get stuck in the course of day-to-day operations, but I have no such qualms about `hg`. Fortunately, I can just stick to `hg-git` or Github for Mac (meh?) and thereby avoid the minefield of `git`'s baffling CLI. Right? Or does the fact that I find `git` prohibitively ugly somehow diminish my hacker cred? (Sarcastic rhetorical question.)
First, IANAL -- This is just speculation. That's exactly it -- being GPL'd, any outside contributors could argue that they expected to license their contributions to you under the same terms. I think the way this is commonly done on github is via pull request. A contributor forks the project, makes their own contributions under GPL, then you could incorporate the work via git pull. At that point, you've now got GPL code in your project, so cannot change terms ever unless you remove said code, or get permission from every contributing author. If you want flexibility, you might require contributors use a flexible license that permits relicensing under different terms... like MIT license :-) 
Haha, I don't think it diminishes your hacker cred, and while there is definitely some disdain for git's CLI, it's extremely mild compared to yours. (In my experience.) I've been using git for a few years now and I haven't managed to bork anything yet. On the other hand, I haven't used it in terribly complex ways either. I don't mind mercurial either. I slightly prefer git-style branching, but mercurial's has become close enough at this point that I find it suitable too. I would just tell you to use hg because there's nothing worse than working with tools you hate. But you also admit that Github is better. So you're in a bit of a predicament. Perhaps hg-git and Github is the right way to go, but I would have much less faith in hybrid source control commands than I would either git or hg on its own.
Unfortunately I'll be away from the Bay Area visiting family that week. Will any of you be at I/O?
TIL there is a new drawing of the gopher. And not much from the comments as I still haven't understood "Go is not particularly strong in data-typing".
[HTML5 link](http://channel9.msdn.com/Blogs/Charles/Erik-Meijer-and-Robert-Griesemer-Go?format=html5).
Of course, the "gimme all your stuff" license. :-) 
Being Microsoft, it's probably mandated. Being the developers side of Microsoft, they probably prefer the raw MP4 themselves so don't pay much attention to the player. At least that's my guess.
To be honest, I think [llgo](https://github.com/axw/llgo) is a more interesting and potentially useful project. But don't let my opinion stop you, how useful something is can't be known for sure until somebody builds it, and there are many surprises.
&gt; Now, what are your objections to the GPL? There are many reasons, but in this case simply using the same license as Go seems the most natural and practical thing to do.
I was thinking, that page looks far too nice to actually work under IE! Turns out I was right. It has a bunch of extra elements in IE9.
"this is stupid" is right
I've downloaded the mp4 file. Thanks anyway :)
I finished reading the book: Fantastic book! Clear and concise =)
Please, please don't use . imports. That should only be used for testing, and even then only sparingly. It should never be seen in non-test code. 
Yeah damn it. Go has potential for other things. I wrote 2 web clients (bots, more specifically) in Go. Although "web client" might sound like the opposite of "web server", it's actually closer to "web server" than "desktop application" is.
Maybe it won't be so damn slow. Also the Java GC creams Go's. 
Yeah, this also runs in about 24ms: http://play.golang.org/p/Cw9PKxFOZP I think the OP's point would have been clearer using that example, since it much more closely matches the Java program's logic and also doesn't pathologically backtrack.
A completely different project, with different goals, but check out [go-java](https://github.com/elazarl/go-java) (still WIP, and draft), which transliterate Go code to Java code. Also have a look at kilim for coroutines/lightweight threads on the JVM.
Actually fairly insightful. I learnt a couple tricks from this talk, thanks.
Does the talk suddenly make an odd noise and freeze at certain points for anyone else? I thought it was vimeo being weird but then I downloaded the video and it's still there..
It was a very useful talk. I already knew about every piece that you shared, but I never thought to use it quite the way you did. I hope to see more of these talks. Every one of them expands my idiomatic Go thinking just a bit more. Do you have any advanced topics on the plans for the near future? Most of the talks are introductory to get people interested, but I'm hoping to see some more challenging content for those of us already on the hook. Oh, and good luck with the laptop on the next one...
Make a dir called example.
I'd like to see that very much!
is it fair to ask 'Why did Google pick Java for Android...' when that was really Rubin's choice before he sold it all to Google?
I've had this thought several times, but I think this article doesn't do it justice for several reasons: * We don't need Google to do anything. Android already supports running native code, so Java isn't strictly necessary. Basically, there can be an open source "Go Android" project that implements the Android APIs in Go, using native code, and relying on JNI only where necessary. * Java is mostly bad because it's, well, still kind of slow -- and when it's not slow, it's very expensive in memory. You can check out http://shootout.alioth.debian.org/ if you don't believe me. This became pretty obvious when Ubuntu released a video of their full desktop running from an Android phone at full speed and me wondering why my regular phone software lags. * Android is a flexible enough platform to not need to dictate one language to rule them all, imo.
&gt; Google ultimately picked Java because of its popularity and being a systems programming language, meaning it can do some low-level hardcore stuff (like C), while higher level languages (such as JavaScript) don’t have that sort of control (or efficiency). Higher level languages don't have the sort of control java has? Are you kidding me? Stopped reading right after that because, obviously, this guy doesn't know programming languages.
the legal problems google now has with Oracle/Java would not go away by switching to another language, they would just piss off a ton of developers who have written stuff in Java for Android if they even suggested moving away from Java at this point look at the problems Nokia now has with third party developers by ditching their promised way forward for all devices (Qt was promised to work on Symbian/Meego), now everything must be ported
 * Not all Android devices are the same processor (Arm7 snapdragon, Qualcomm MSM7000, Tegra, CortexA8, Ti OMAP, Samsung SSPC110, Marvell PXA300, Rockchip RX2918, etc.) * JVMs are, in general, widely available across the embedded world. * There was a large existing developer base of people that had done similar technologies, such as set top boxes, which were all based on java. Apple is a different story since there is just 1 (I guess sometimes 2) phones.
* It's not like you can't have a compiled language that still works the same on multiple architectures. It's a just a standardization issue of C that this isn't the case. * Cool, but JVMs still suffer in performance
I hate java too, just like all the other trendy coders these days ... but I think that's the reasoning as I've heard these reasons pointed out before for multiple, similar projects
While that's true, Dalvik's performance isn't really revolutionary compared to the open source solution or oracle's. The reason for that is that Java's multithreading and memory management models are inherently memory intensive. Yes, while Java can manage C-like performance in certain conditions -- and actually faster under it's hotspot technology as of late -- the memory consumption can't keep up. It's for these reasons that Python, with it's global interpreter lock and lack of real threading wins against Java in memory a lot of the time, despite being much less well optimized.
He certainly does not know what a systems programming language is. On a zOS mainframe, how do I address physical memory at offset 0x10 with Java? 
&gt; On a zOS mainframe, how do I address physical memory at offset 0x10 with Java? Is this the single definable quality of a systems programming language?
I haven't used it yet, but I am going to be trying it out in the next few days. While my non-feedback is not helpful, I hope it adds to any encouragement you already had to keep pushing forward on it. Go is seriously lacking in _good_ UI tools right now when compared to other languages, so I'm hoping a few good libraries get driven through the bugs and challenges to a stable, reliable library that can be used in production. I'm rootin' for ya! I'll come back and say something of actual value later when I've given it a real _go._
I like it, a lot. X is asynchronous, Go is asynchronous, stuffing everything through a thinks-like-C synchronous single threaded widget toolkit is a painful departure from the underlying simplicity.
Switching is the wrong way to do it. Just release a binary-callable interface to the Dalvik parts of Android, and Go can hook to it.
Go does offer the infrastructure to compile on demand (for any CPU arch, if they have a compiler) because the ease of dealing with dependencies.
Yes, please, lets have some advanced talks at Google I/O, the lack of any advanced talks last year was greatly disappointing.
I have another bit of feedback for you. I am thinking that it might be a good idea to change the git repository name to replace the usage of the `.` in the name. I tried to use the built-in package management of go (go get ...) and it seemed to fail with the following error: package github.com/skelterjohn/go.uik.git: invalid version control suffix in github.com/ path I am thinking that the installer system is trying to determine the version control system of the repository from the `.uik.git` file extension instead of using `.git`. Anyhow, it is a pretty minor problem, but I thought I would bring it to your attention as changing it would make the library much easier to install in the future.
"go get github.com/skelterjohn/go.uik/..." will work just fine. It's not the "go.", it's the fact that you're appending ".git" to a repository path on github, which has some special case rules in the "go get" source.
Can you give a link to the slides that works?
I'm still doing some learning about Go and I am interested in the use of channels such as GetConfig. I see that your event handler does the following within a select block: case g.getConfig &lt;- g.config: I'm wondering if that case is only selected when the `g.getConfig` channel is being requested elsewhere (eg. `conf := &lt;-grid.GetConfig`). If so, this is a pretty cool feature that I wasn't aware of with channels.
Make use of sun.misc.Unsafe class, http://codethink.no-ip.org/wordpress/archives/712 Or if you want to stay portable, write a native method. There are many systems programming languages that done offer pointer manipulation like C or C++ do, and yet they were used to build working operating systems. You just need some bits of assembly to do certain low level tasks, which C and C++ also require in many cases as well.
So, what do all this widgets look like then using this toolkit, or are they themable?
It's far too early to worry about that kind of thing yet, except to say that they all have a field "Paint func(draw2d.GraphicContext)", which can presumably be set somewhere. It'd be easy to have the NewX() function do a lookup to find out what should be in its .Paint function.
Yes, from my perspective, I don't mind at all that it looks different. But what might be useful is to pay attention to non-visual behavior configuration set for GTK or QT, stuff like "does the cursor blink" (because I hate blinking cursors and switch them off) or "what is the default language" or "how are fonts rendered, subpixel or antialiased" or the such like.
I did some reading, and now I understand their opinions. Dynamic linking in C is made more easy because the operating system itself is written in C/C++, so the bindings are already there. Trying to get the linux kernel to interact with bindings for a non-C language would probably be very difficult without forking the kernel itself. And I overreacted. If I keep most of the code in the controller and minimize the number of actors, it should be a few dozen megabytes at most. It would be nice, though. 
Or is the user using some kind of high contrast huge fonts black/white theme because he sees bad.
I believe most modern OS's still do some form of demand paging (I could be wrong - haven't researched in a while) http://en.wikipedia.org/wiki/Demand_paging
The language is really irrelevant. The real issue here is not that it's difficult but that the Go authors believe it adds unnecessary complexity - dependency hell can break binaries when upgrades occur, binaries aren't portable across Linux machines, etc. Also, unless you have different code for every actor, the number of processes you use should be irrelevant; the executable should be loaded once and mapped into each process's memory space. There won't be 100 copies of the code in RAM for 100 processes.
Static linking is simpler than dynamic, especially with symbol versioning. The single file is a standalone package of what you need to deploy. I argued against it for GHC (Haskell) and I stand by that. 
If you're worried about binaries "at scale", you will come to love statically linked binaries. Otherwise you may have to fight through "DLL hell". When you start dealing with hundreds or thousands of machines of varying vintages of OS images, throwing a statically linked binary out there solves a lot of packaging and dependency management issues. The OS can do its own thing with whatever libs it wants, because your server is isolated from the vagaries of OS library choices.
Yes, you can avoid this problem. Try using gccgo. A hello world program using fmt package compiles to a 26K binary (gccgo 4.7.0, amd64)
Fun fact: Google statically links all their C/C++ code they run on their servers. It seems you are severely confused regarding the characteristics of dynamic vs. static linking. Static linking is faster and more efficient. If you have many processes static linking also means fork() is much faster.
Yeah man, Node is weird. No real company would use it, since it increases the amount of servers you need, and thus your costs. Well, who knows, I suppose.
Well, as always, the benchmark is silly.
Important topic, to be sure. It's in mind, and we've got some ideas for how certain kinds of events might come in from go.wde. Do we want (eg) a NextWordEvent? CopyEvent, etc? The way these events are created from user input is platform- and user-dependent, so it might have to be that way. I'm certainly keeping all that kind of stuff out of go.uik. Thanks for the encouragement.
Why did this post get downvoted to oblivion?
Most benchmarks are.
Try `go build` instead of `go build chat.go`.
Ignoring the content and concentrating on the title: No, Go binaries are not always really entirely statically linked. If you use e.g. the net/http package and do not disable cgo, the resulting binary will dynamically link against a couple libraries.
When compared to languages without module systems lets say.
The OP seems ill informed about how dynamic and static linking work. A dynamically linked helloworld will require 8.6MB. A statically linked hello world can be as small as 900KB. Dynamic linking annoys me because I end up having to have multiple versions of large complete libraries that programs only use a small fraction of.
Thanks, Looking into it.
I like yours better - uses fsnotify. I couldn't find a notify lib, so I just run "go install &lt;path&gt;" every second, and detect if it did anything or not.
That the fast compile times in Go were already possible in the 80's with languages like Turbo Pascal and similar ones with module systems. It is only a novelty for many young people nowadays, because the world decided to go with C and C++, with their preprocessor mechanism that requires keeping parsing all include files several times.
Stupid question but isn't it the job of a continuous integration server? Buildbot, jenkins, CruiseControl...
Until you have to fix a security vulnerability in a widely used statically linked library. Then things get really, really painful.
&gt; Most module based languages that compile to native code, have the symbol table stored either inside the binary modules, or externally in also in binary format. You need more than just a symbol table because you really want cross-module inlining. &gt; Go also makes use of binary information in the packages, as far as I know. Or am I wrong here? Just open an .a file in a text editor. There is some binary content, but a lot of the interface description is actually human-readable. &gt; Do you have a link for the math issue? I have not found anything. http://codereview.appspot.com/6206077/
Breaking news: A native, compiled language is faster than an interpreted one. 
I don't know much about Concept, but I love interfaces. The reflect package helps with figuring out types inside interfaces. It's very powerful.
efarrer, That would work if you only did communication one way. But if you grabbed a record then tried to update it, you would have all those extra fields in the xml.
a true and great post, but by now there have been so many that have outlined the major weaknesses of node... the node community probably won't ever care. few probably have any idea if their apps are network IO bound, cpu bound, db bound etc, and for most of their trivial, low/no traffic applications, it doesn't matter, they could be serving pages with any stack and get reasonable performance. node will one day be naively mis-applied to an application for which its model fails spectacularly. only then will the community even bother discovering what it means to run a single-threaded app server. its worth noting coincidentally, that nginx has a similar execution model, but it is not an application stack in itself, simply a protocol server, so it does not suffer the same faults
The Node community has never cared much about facts.
They are [even more painful if you use dynamic linking](http://harmful.cat-v.org/software/dynamic-linking/versioned-symbols).
Not if you encode theStruct.TheInnerType rather than theStruct.
Ron doesn't understand symbol versioning. You can't stop maintaining a function because it is published with an older symbol. You have to keep applying bug fixes, until you can eventually remove the old version (which might not happen). Once you realize that, versioning schemes are suddenly much less attractive.
Very interesting read. Thanks for sharing. There are a few things I'd like to comment, but keep in mind, I'm no go expert. It's just stuff I believe to be true after reading some documentation. If I'm wrong, I'd be glad to be corrected. &gt; Enforcing a brace placement style and other conventions means the compiler can be super fast. I thought there is no enforced coding style. There is a standard coding style, which is whatever gofmt produces (actually defined that way in documentation), but the compiler doesn't rely or optimize on that. Everything that is syntactically correct will compile just fine regardless of indentation and braces positions. &gt; Names imported from a package are accessed by using the last component of the package name as a prefix Aren't package names flat? As "image/color" is the color package in the image folder? In Java, the package is named org.this.is.ridiculous.stuff, but in Go, it's just the stuff package with a path to find it in front. That also simplifies greatly the concept of web-aware packages. &gt; Go is not object-oriented. In its purest sense, object orientation is just data structures and methods for them. With that definition, Go is object oriented. But what exactly object orientation is, and what the minimum feature set would be to justify calling a language object oriented, is not well defined. I'd say Go supports an object oriented coding style.
Actually you must place braces in the correct places for it to compile. This will give an error: if foo { thing() } else { other() } this will not if foo { thing() } else { other() } 
&gt;Names imported from a package are accessed by using the last component of the package name as a prefix Package names are whatever is written in the packate statement in the source. It is convention to have that match the last token of the import path, but this is not enforcement by anyone or anything.
Yes, I'm very aware of that. Wasn't my choice in this case. Trying to make the best out of the situation.
Google Go is a low level systems language, it is not at all suited for web development. Just program the site in PHP, it's probably the best choice for a novice like yourself.
Simple - just write a Go interpreter in either PHP or JavaScript.
this isn't true at all. Plus, if the language wasn't suited for web development why is there a templating engine and a http webserver **built into the standard library**
The rule is dead simple to understand: *it's adding in semicolons, unless the end of the line is obviously unfinished*. A brace, or a conjunction like + at the end of the line, means "expect more of this line to follow", and the compiler doesn't add a semicolon.
PHP and Go are very, very different. GoDaddy is a bad choice. Cancel the plan. Just do it. This is like backups and using the same password everywhere. "I know, but it surely won't happen to me". It always does, sooner or later. Run while you can. You'll thank me later. edit: more importantly, it flat out doesn't appear to be possible.
Horrid, horrid advice, from terribly inaccurate information about Go's capabilities... to *shudder* recommending PHP.
It's as annoying as you let it be.
This was a pretty silly comment. If you're gonna fanboy/troll, at least give a (false) reason rather than just making a (false) statement.
I completely agree with that. When I am writing new code, or debugging it, I tend to add and remove fmt.Printf calls, and I hate having to remove the fmt import every time I am left with no debug statements. Same goes for unused variables, just because I haven't actually used them yet while testing another part of the same function. I can understand the "allowing code with warnings to compile is bad" mentality, but why not a flag to allow warnings, much like the invert of -Werror? 
I completely agree. Go's style has matched mine in everything but this, so I'm just a little disappointed to find somewhere where it strayed. Not a serious complaint.
SOPA? They regularly shut down domains on a whim? Their hosting is overpriced, shared, and constantly hacked. What is "good" about GoDaddy?
That. sounds. horrifying.
http://play.golang.org/p/VOw_JkAgJq -- rand.Intn(high-low) + low 
They're different. In Java etc, you can use catch to do flow control within a function, similar to an if statement. In Go, a panic destroys the entire stack frame and you're on your way up the stack. You can't proceed down an alternate path of execution in your function.
For debugging use print() or println(). If you want something better formatted, try the following: const Debug = true func Debugf(format string, args ...interface{}) { if Debug { fmt.Printf(format, args...) } } func Debugln(args ...interface{}) { if Debug { fmt.Println(args...) } } 
Thanks a ton! That solution is so simple and elegant.
In other news, programmers can't resist trying to shoehorn their favorite construct into languages designed to not include them.
Yes. It's the whole point. Any kind of read, whether from a file or from a socket, uses event-based IO under the hood. The code looks linear, so you can actually reason about it without shooting yourself. There is a single thread reserved for all IO operations. When a goroutine wants to read something, that thread adds it to its whatever, and the goroutine will get woken up once the read completes. In the meantime, other goroutines will get to use the thread the first goroutine had been using.
I get that there are much better options, but that is not what I am asking about. It likely isn't my choice now that he went and bought it from GoDaddy, but if I can I'll try to convince him to switch to Heroku or AppEngine. At the very least, even if I end up not using Go (probably PHP or Python in that case, hopefully Python), I would at least like to switch from GoDaddy to DreamHost or something.
Again, this isn't my choice. And I'm aware of their differences, I've coded in both. But I do agree with you, and if I can convince him to switch I'd be so much happier.
It's usually not the best way, although for a very small number of situations it could be acceptable. You'd never catch me doing it, though.
Thank you for providing your (false) reason. Sorry that you feel compelled to unsubscribe. Don't forget to take your ball.
When I first read about the defer-recover idiom this is exactly what I thought. It's arguable that there's enough different about the two that they warrant different names, somewhat like the new/make issue. I could recreate a Java-style try-catch mechanism pretty easily if I had any desire to, though. There's a fundamental difference in philosophy, however. Go allows you to throw an exception if that's what you need, but the primary error handling mechanism (and the one recommended for libraries) is to use return values. Libraries in Java are encouraged to throw exceptions as the primary error reporting mechanism, and exception use is a core language concept.
As I see it, there's not much practical difference between returning an error value and having a checked exception in Java. In both cases, the caller is made explicitly aware that "Hey, this thing you're calling can very easily screw up in this particular way!" Then you can either deal with it, semi-manually pass the error up the chain, or just ignore it with an empty `catch` (Java) or setting it to `_` (Go). Panics are basically like unchecked exceptions. They can happen deep in the call stack at any time and destroy your whole program, so it's the job of library writers to try to keep them from happening if at all possible. The advantage of the Go-system over the Java-system is that the two kinds of exceptions are syntactically different enough that users are made aware that the first kind are normal and the second kind are not. Also Go probably gets better performance with return values, although I'm not sure if that's true.
Choir boy. Complete and utter choir boy.
I know, how did he pass the entry exam?
Well that wasn't very nice or helpful... I wouldn't consider myself a "Go programmer" just yet since I've just really started poking around in the language a short while back, although I've known about it for longer. The only other languages I've had experience with have been interpreted languages and already had things like the above question done and wrapped for me as built-in functions, so I wasn't able to see how it was done. I have no background in C or Python, so Go is definitely out of my comfort zone... But isn't that what learning is about? Everyone started somewhere. The math isn't hard, it was the application of the math that just didn't dawn on me... I guess I thought the answer would be much more complicated than it was, so such a simple solution never crossed my mind.
Your readme could do with explaining what xsteam is ....
That is a good point. I'll work on that in a bit.
Have a read of http://golang.org/doc/articles/godoc_documenting_go_code.html Personally I find gopkgdoc to be the bomb. Especially since it added hyperlinks between types recently.
IIRC the way it actually works is before a goroutine performs a blocking operation the runtime spawns a new OS thread if necessary and migrates all the other goroutines over, then lets the goroutine making the call go ahead and block its host thread. If it operated the way you describe then the IO worker thread could only have one blocking call outstanding at a time. 
I wasn't intending to push away. I was just asking anyone else if they thought it could be a troll. See my reply to the OP elsewhere.
That'd be exceptional.
This pretty much nailed it, I have no formal training in any sort of programming past a web design class in highschool, I only do programming as a hobby.
Finally, every pun is fun.
Whether you have multiple goroutines or not, IO will be done in its own thread using epoll or kqueue. Of course, if there is only one goroutine waiting on IO, it will have to sit idle until the IO is done. Yes, if you want concurrency or parallelism, you have to ask for it.
Thanks for that. It's actually because of GHC that I learned static linking is better than dynamic linking. Before, I just assumed dynamic linking was the best, since 'everyone' used it, so I was surprised to see GHC doing static linking. If GHC had done dynamic linking instead, I probably never would have looked into the pitfalls until now.
Sometimes the painfully obvious solution can be hard to see, even for somebody experienced. At least this happens to me rather frequently, but I'm not very smart anyway.
If you guys bought hosting just for this project and development hasn't really begun, then there should be a very minimal cost to switching hosts. If you can, grab a VPS or something (linode is awesome) instead of dreamhost. If you really want Go, a VPS is the way to go because you can run it on any port you like.
&gt; Yes, it might not be obvious and perhaps one could get to adulthood without having noticed but you're not 100% sure they're not joking. True. But pointing this out to that person is called "being a jackass."
This approach only works with X. If you need something cross-platform, you're definitely better off outsourcing, I think. This can be done using my [xgbutil library](https://github.com/BurntSushi/xgbutil). You can find a simple example [here](http://godoc.burntsushi.net/pkg/github.com/BurntSushi/xgbutil/examples/screenshot/) and the source code [here](http://godoc.burntsushi.net/src/pkg/github.com/BurntSushi/xgbutil/examples/screenshot/main.go). Simple usage: go get github.com/BurntSushi/xgbutil/examples/screenshot screenshot (You may need to prefix the second command with the path to your GOPATH's bin directory if it isn't already in your PATH.) This will show a window with the screenshot in it. The important bit is that 'ximg' satisfies the draw.Image (and therefore, image.Image) interfaces, so that it can be used like any normal image. Let me know if you have any questions. xgbutil is just beginning :-)
Hm, I would actually hope that in Wayland this not be possible for a non-elevated application to capture screenshots. For security reasons, though I don't know that Wayland will prevent it. X sure won't.
Why would someone troll /r/golang and why would someone choose this form as a troll when there are far more easy targets?
thanks :D
So choir boy is the new put down of /r/golang now?
With "screen" I meant "When I have some data that I put on the screen, then make that data also implement the Image interface". They both work with rasterized pixel data, so it shouldn't be that hard, right? But that's easy for me to say because I've only been using software rasterized stuff where I play with the pixels - all my data *is* pixel data anyway. Implementing the Image interface is trivial then. If the rendering takes place on the GPU, like with the OpenGL or SDL libraries, it's less obvious, but still doable. You'd have to copy the output of the GPU back to RAM first, after which, being pixel data anyway, it shouldn't be hard for to implement the Image interface on that data. My guess would be to use an FBO for rendering, which allows for putting the result on the screen and/or copying it back to RAM from the texture. But if you're using something like GTK, then sorry, but I have no idea what to do if the GUI library itself doesn't provide help for that.
Really cool, time to look into writing a sane WM in Go!
Ditto to what are595 said. We're asking how you're getting the pixels of the entire screen in the first place. (Which includes wallpaper, other windows, etc.)
Nice work!
Well, he's hosted a Wordpress blog on it for about a year now, and he can't get unused time refunded. That's GoDaddy for you.
Ah. Let that be a lesson to _him_ then. :-) It's too bad that you won't be using Go, but I'm glad that it sounds like you get to use something that isn't GoDaddy anyway.
Yeah, sorry for the confusion. Anyway, I think you'll end up with system-specific solutions no matter what. Good luck!
[shrugs] I hope you're getting paid and not a share of "the profits"; this guy doesn't sound too smart. Good luck :-)
rather off-topic, but: gotta love anything which states "no random limits! Anything up to &lt;random limit&gt;!"
4gb isn't a random limit. It's 2^32. Most likely tied to its use of 32-bit pointers in the index.
Is it just me, or is this "random" not so random? Every time I run it I get the same numbers, even when changing the amount of random numbers it is the same result. (16 22 22 24)
Go's panics don't really work very well as "normal" error handling. That is, things that the code should notice and work with. The fact that you can only recover() from a panic in a deferred function call means that whatever else you wanted to do in this function is gone. Go's panics are only meant to be used in situations where things have gone so wrong that they are not recoverable. Bugs, for the most part.
Based on some valuable user feedback several Go auto-complete issue where raised with this first Zeus release. With the help of this feedback there is now a new beta release that greatly improves on the Go intellisense. This latest Zeus Go beta can be found here: http://www.zeusedit.com/go.html Edit: The nineth version of the Zeus Go beta has now been released. 
Agreed. I don't think I conveyed it particularly well, but I was trying to say that in my second paragraph.
This is several more amplitudes of awesome then I can even begin to comprehend. I am happy when I get something to run.
So which database has a rand() limit that gets determined every time you create a new database?
No, any consistent number isn't random. But in the context of the phrase, "no random limits!", "random" is being used to mean "arbitrary", and 2^32 *is* an *arbitrary* limit.
Dude, hot swapping is not a feature of the programming language. You are excited about the wrong thing.
Wayland prevents this.
"The largest reasonable amount of RAM at the time this database was designed" is an arbitrary number, whether it's 640k or 4GB. "The current size of the majority of UNIX implementations' `off_t`" is an arbitrary number, whether it's 32 bits or 64 bits or 128 bits. Any limit that would not be the same if the database were designed today or even a century from now is an arbitrary limit. As such, the 4GB limit on database size in CDB is *very much* an arbitrary limit.
Interesting about embeddable types -- sounds like a way to get the benefits of type polymorphism without the headaches of an inheritance hierarchy. I didn't realize that before.
This project is still a work in progress, but it is fully functional. I've included several JS test cases using jasmine which are automatically executed when you start jasimen and guard while developing. The guard task will also run all of your Go test units each time you save a file. (This probably won't be great for everyone, but removing 'server:test' from the app:build task will stop that) I'd like to add a bit more docs to it so things are clearer once I get a chance.
Embedding doesn't give you polymorphism. It only gives you composition with delegation. Interfaces give you polymorphism.
This is very interesting. Go web development needs some love by the looks and this is a great start.
Hmm, your handle rings a bell. Were you in #qtile on OFTC?
&gt; Any limit that would not be the same if the database were designed today or even a century from now is an arbitrary limit. You have it backward. Any limit that *would be the same* were the database designed one million years from now is arbitrary. "[Based on random choice or personal whim, rather than any reason or system.](https://www.google.com/search?q=define%20arbitrary)" That the system has 32-bit words may be arbitrary, but the database exists within the system. djb's choice to use 32-bit words was informed directly by the system. It is not an arbitrary limit.
&gt;I have heard from at least a couple of reliable sources (Googlers) that Go gets quite painful when things get complex due to synchronous message passing As opposed to Haskell which is quite painful right from the start. 
Where was monad-par needed for the second example? Unless I did something wrong, I got it working without that.
Oops! Mea culpa, you're right. Thanks! I guess I added that first, based on the comments, and it didn't work until I added the other imports. I didn't notice it didn't actually need Control.Monad.Par.
SASS, CoffeeScript, Rake, Sprokets, Ruby Guard, Jasmine, and managing Ruby environments? ...how is telling people to learn a Ruby toolchain helpful for the Go community? I've been programming Go for the past six months (the past two full time), and I have no idea how to use any of those things.
imported and not used: "monad-par"
&gt; even some skilled in Haskell I'm one of them, by the way.
I read that and said 'thats crazy'. But interesting.
&gt; laziness This is *also* a con. (I consider laziness more of a pro than a con, but you've got to mention that it makes reasoning about the run time complexity of a Haskell program more difficult.)
Some additional cons (in my opinion): * More difficult to reason about, at least in the small * Being higher level, generally less efficient. * Fewer, less consistent libraries in the standard lib. 
There probably is evidence for this but I wonder if it's so clear. As to efficiency, take the obvious, but admittedly dubious http://shootout.alioth.debian.org/u64/benchmark.php?test=all&amp;lang=ghc&amp;lang2=go As to being more difficult to reason about, it might depend on the problem domain, certainly http://hackage.haskell.org/package/stm makes a lot of reasoning *infinitely* simpler than it is in almost any other known language; other things are less simple, sure. Usually when people speak of the difficulty of 'reasoning' they are thinking of efficiency; I would think, though, that semantic reasoning is much, much easier in Haskell -- that is, it is much, much easier to write obviously correct programs; one or another of them might turn out be a dog from a performance point of view, but they can all be used e.g. with [quickcheck](http://hackage.haskell.org/package/QuickCheck-2.4.2) to validate optimized versions. (Quickcheck is much more powerful than my 'reasoning' capacity [and most any testing tool](http://video.google.com/videoplay?docid=4655369445141008672)) Much of the difficulty reasoning specifically about *efficiency* arises from the use of types and form of programming that are simply not available in standard languages, and which the language very much inclines one to employ; if one sticks to unboxed types and so on, there is of course little trouble in Haskell as elsewhere -- but one resists this a bit, for sure. (By the way, frequently the would-be fancy high level thinking we associate with Haskell results in stunning optimization, see for example the stream fusion libraries, especially the mighty [`vector`](http://hackage.haskell.org/package/vector-0.9.1) -- something like `Data.Vector.Unboxed` and `Data.Vector.Unboxed.Mutable`again relieve one of a huge amount of tedious reasoning in dealing with the underlying arrays, but everything is always insanely fast.) Which of the 'standard libraries' that come with the ghc or the Haskell Platform are 'inconsistent' ? (Nb. though `vector` is among the greatest Haskell libraries, it doesn't belong to a 'standard library' in any sense.) I suppose some of these http://golang.org/pkg/ are missing from the Haskell ecosystem but I think it would take quite a bit of work to show there was any crushing deficit. People seem to reason a priori about these things. You can easily get good advice if about things not shipped with the Haskell platform.
Haskell is more difficult to reason about? I'd say it's quite the opposite. Purity and referential transparency mean you can reason about things equationally, which is much easier. Laziness does make performance less predictable, if that's what you mean. Higher-level does not imply "less efficient", it just as well implies "more efficient" (Haskell's high-level-ness allows for its automatic parallelism mechanisms which make things easily fast). About the libraries, that's the con "Less mainstream".
I think the reference is more to the Go stdlib, which is quite complete and consistent. The status of third party libs is harder to evaluate.
Completely agree. However, the pro-Haskell guy should be aware of this "pain is not always bad" philosophy (even if it's dubitable the underlying statement regarding said pain applies). After all he mentioned the "pain" of using Go, as opposed to Haskell.
Haskell blurs the line with hackage, the Haskell platform and "blessed" libraries. Are you comparing the libs in the Haskell Platform to Go's standard libraries?
I don't think I said that Haskell was certainly more concise; the syntax for, say, updating mutable and seemingly-mutable things like marrays is *far* more verbose. (There is a lot of that in these modules.) For example, what is `i++` in another language might look like ` do {x&lt;- readBlahRef i; writeBlahRef i (x +1)}` in Haskell; which is, uh, a bit of a pain. I have seen it argued (by a leading contributer to the flood of new superfast libraries of the last couple years) that the lack of a dedicated syntax here gets in the way and (I think he said) may lead to more errors in writing. It can be argued that it is semantically clearer and correct and composable, even if a less practical You can define operators to make it much more 'normal' but no particular method has every caught on -- [here's a typical reddit-tutorial illustration of one possibility](http://www.reddit.com/r/programming/comments/s112h/the_downfall_of_imperative_programming_functional/c4afeug) given en passant by the [exceptionally brilliant](http://hackage.haskell.org/package/pipes) Tekmo; I've seen more economical renderings; anyway you can infer what the fragment would "really" look like by replacing the defined terms :). The algorithmic content of the Haskell shootout entries is probably mostly the same as for the Go entries, just faster; all the entries seem to gravitate around a few models, especially the ones written by C masters. I should say, the Haskell entries not been modified for about two years, somehow a flurry of activity came to an end -- many of them didn't compile until I and others adjusted the flags and other trivia recently. The last two years have seen a revolution in superfast libraries so there is hope that if activity started again they could be either much shorter or much faster or both. But of course this is 100% prophecy. What works against renewed activity is the spread in the 'community' of the conviction that the benchmarks are 'unfair to Haskell', since they micro-manage everything, and specify that things happen that wouldn't in a radically different language from the one he is envisaging -- see e.g. [the opening comments in binary-trees entry](http://shootout.alioth.debian.org/u64/program.php?test=binarytrees&amp;lang=ghc&amp;id=4); that module is much faster as it stands if you just chuck the 'strictness annotations'. The conviction that the 'benchmarks' are unfair has some truth in it, but is beside the point since one can do it, and it anyway it seems to matter to people. I think once the more modern libraries are included in the Haskell platform -- fortunately he does install the platform -- activity might pick up, at least if my purely prophetic utterance above, that they can make things simpler but still fast, comes true; we'll see. That the Go entries use less memory is likely a permanent feature, but I think people only thought of speed in designing these entries. (It is a good thing he doesn't chart compile times :) ). Another reason for the length of the Haskell entries is that once a good module was found it tended to stick -- new modules were just updates of the good one when someone thought of a tweak that would win another 1% speedup; these always add several lines; and in general there is the incoherence of many hands. The most hilarious entry is [the going one for k-nucleotide](http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&amp;lang=ghc), which implements a complete imperative hashtable library in 200+ lines, in accordance with the (arguably silly, but who cares) requirements of the benchmark ; it used to be pretty fast by comparison with the others but is now the leading embarrassment; I can't tell if changes in the compiler have worked against it, or other languages have improved. (The unrelenting change in the compiler and still more in the whole ecosystem is another thing that works against these particular modules, but in principal in favor of the language -- as I said, many of them simply failed to compile not long ago, in fact this has happened at least twice when he updated the compiler in the period since they were mostly written.) I was writing a replacement k-nucleodtide just using mutable "vector"s from the vector library (which came after all the entries) reasoning that the only hash function one needs is a perfect hash function so the indices can be keys etc; if I'm not making some mistake, it is many times faster (even than the Go entry, though that could probably be much faster) and *many* times simpler, but I haven't been moved to finish one of the painful bits of it, partly because I don't know if he will accept it; he did accept structurally similar ones in the past, but maybe the DIY hashtable entry has proven to him that it is possible in Haskell. Of course it would be more fruitful to concentrate on things like STM than the shootout, but the latter is sort of interesting, I mentioned it above only because I saw what I thought was a groundless a priori assertion of go's superior efficiency. The general matters brought up in the original post here are where Haskell is certain permanently to shine. 
Thanks for the detailed and thoughtful response, sorry for not being able to provide an equivalent answer. &gt; Another reason for the length of the Haskell entries is that once a good module was found it tended to stick -- new modules were just updates of the good one when someone thought of a tweak that would win another 1% speedup; these always add several lines; and in general there is the incoherence of many hands. This is precisely to what I referred to, Go has not had this kind of progressive micro-optimization of each benchmark, and it shows, many such 1%'s add up, both to code complexity and to performance. 
The ghc is removing more and more libraries that used to be its responsibility; increasingly the only "standard library" is `base` which is comparatively minute. I don't get the idea about "completeness and consistency" (!). If it is something about Hackage then it should be kept in mind that Hackage is a *completely* uncurated collection; things up on it in have been kindly made available by their authors for easy installation especially in the handling of dependencies; it is no different from github, which could easily replace it with a suitable system for tagging things and recording dependencies. On the other hand, the equivalents of what you think of as the "standard libraries" *are* all on Hackage -- most are on github too, along with the ghc itself and peoples' Project Euler directories... It is a bit like complaining of the mixed quality of things you can install with `apt-get install` and using this as an objection to Debian and linux generally. Maybe it could be clearer which are the standard sensible libraries for doing things -- the Haskell Platform does this a tiny bit but it is to some extent focussed on things that are (a) difficult to install because of the connection with C libraries or the underlying system and (b) actually installable on all three leading platforms, all on condition that they are sound. In fact only a couple of the modern libraries are included. I guess if the idea of 'mixed quality' is around, the In truth though it takes about 30 seconds to find out, for example by pointing your irc client to #haskell, asking and leaving, I do this all the time. (I apologize for talking too much on this page which isn't my proper place, but the questions are interesting. I hope I'm not seeming too aggressive, it is just over-animated style.)
&gt; On the other hand I think it is easy to underestimate the miraculous properties of the ghc, especially given that it's basically a one, now two, man operation -- but this is patriotism again. Note that the main Go compilers have been for most of their history pretty much a one man show, a man that was also busy with many other projects (from various Go libs to re2, to Google Code Search and god-knows-what-else-inside-google, not to mention other side projects like p9p)
Do you know what the significant differences between CSP and the Actor model are? I've tried to find a straight answer about this many times and I've always been unable to come up with something meaningful. I've found some small differences but never anything that truly seemed to differentiate them. I should note that I haven't done much concurrent coding outside of sh and go.
tell me what the monomorphism restriction is in sixty words or less without referring to external materials this is what we talk about when we say haskell is difficult to reason about
how many string libraries does haskell have? more is not always better
The MR makes definitions that look like `x = ...` without parameters left of = and without an explicit type get a monomorphic type rather than a polymorphic one, to make computations that look memoized actually be memoized. The MR sucks, and I hate it, but is it really your argument as to why Haskell programs are difficult to reason about? Really?
Yeah, fully transactional updates everywhere is a great boost for reliability.
I've seen that page before. If those are really the big differences then they seem totally equivalent to me, in the sense that I could mechanically translate a program from one paradigm to the other without making architectural changes.
Care to post links to some of your work?
Not to mention space usage. I've seen some subtle bugs where tons of thunks have accumulated in memory because of that laziness. A little strictness where it was needed solved those problems, but it was still hard to tackle.
Yeah I'm in the same boat. Doing a systems course next semester though, so hopefully six months from now it will mean something to me!
This is off-topic, but I see that there are fifteen other people reading this document at the moment - six of those are Dutch (like me), two English, two French, and five Chinese. I didn't know Go was relatively popular in the Netherlands? It's 16:00 here, so it probably isn't because everyone else is asleep at the moment - French, Germans and British would be awake right now as well. Yes, I know, small sample size.
Dutchman reporting for duty!
For one, just trying it out and it is VERY fast
Cool, but it would be cooler to see the "Examples" as unit tests rather than just documentation.
You're right, I added that to the repo. I also changed the Node struct to hold a value of arbitrary type instead of the .isEnd boolean. If .value == nil, the string is not contained in the trie. This means you can now use the trie as a key-value structure or simply do *trie.Insert("bla", true)* and use if !trie.Find("bla") { // "bla" not contained }
python rebels?
The Zeus Beta5 version is found here: http://www.zeusedit.com/z300/zeus-beta.zip 
Because the scheduler and garbage collector in Go currently suck, and parallelism aggravates their flaws. Goroutines are foremost a tool for exposing concurrency, the fact that goroutines can be assumed to be executing in parallel does not in fact mean they will, or that it will be efficient.
If my parallel routines are already completely independent (they are basically just job workers in an 'embarrassingly parallel' problem) then, if I understand you correctly, I should be able to use GOMAXPROCS without much or any concern, right?
Yes. But even when you're less certain, just write a few benchmarks in your _test.go and run it with GOMAXPROCS=x to check.
I come from Python too. Python may be easier to read, but I really love how easy it is to do common stuff like this in Go. A complete benchmarking suite: myapp.go myapp_test.go In myapp_test.go: import "testing" func BenchmarkMapGet(b *testing.B) { m := map[string]string{ "foo": "bar", } for i := 0; i &lt; b.N; i++ { _, _ = m["foo"] } } func BenchmarkMapSet(b *testing.B) { m := map[string]string{} for i := 0; i &lt; b.N; i++ { m["foo"] = "bar" } } \# go test --bench=B \# GOMAXPROCS=8 go test --bench=B (it runs the benchmark a bunch of times, with a different b.N each time, to reliably determine the running time of each invocation.)
You can get even fancier with: &gt; go test --bench B --cpu 1,2,4,8 Which will run all benchmarks four times with GOMAXPROCS set to 1, 2, 4 and 8.
Nice.
Because Zeus can work as an IDE for many different programming languages it can be a little confusing and it certainly does take some getting used to. 
I don't know anything about the vim modeline. What I do know is the gofmt.exe utility has *tabwidth* and *tabs* command line options that lets you control how the tabs are handled. usage: gofmt [flags] [path ...] -tabwidth=8 : tab width -tabs=true : indent with tabs Don't know if that helps?
I think he literally wants to set the tabwidth to 4. I think it's `tabwidth` but I haven't used vim in ages.
&gt; idiomatic haskell does not... You're welcome to contribute what you consider to be better Haskell programs.
Ah, gotya. Yup, that is precisely what I have too.
That's precisely what you want. :-)
It's worth mentioning a lot of the niceties of Go are due to it's library and tool *design*. They're not related to the language or implementation. Much of it is possible because of the fresh start that's been made.
I came here to say this. Any implementation that exposes the necessary unix primitives can do this. Unlike Go, some of them let you do it as part of normal operation, not through special casing like this.
When GOMAXPROCS is larger than 1, the allocator needs to use atomic memory instructions, which hurts performance. See `runtime·markallocated`.
This is a great article, I always love seeing Go's currency put to good use. But I have one niggle: goroutines are not threads. It's conceptually tempting to think of them this way, and in purely concurrent terms it might be OK. But goroutines are much lighter weight than threads, and so the use of the word "thread" carries a connotation of a higher performance cost than what is actually occurring.
set tabstop=4 set noexpandtab 
if two threads simultaneously attempt to mutate the list, one waits for the other to finish. This is done with some kind of atomic primitive operation (likely available directly on-cpu or in the OS). lock-free refers to the fact that something in the program is always moving forward, not that every thread is simultaneously performing work. That guarantee is known as a wait-free system, not a lock-free one.
This is actually pretty sweet; I didn't realize Go made cookie handling so easy. I might definitely poke around in your code at some point; I'd like to scrape reddit for all my posts, and it looks like you've done the leg work on logging into reddit with Go. Nice work :-) Some advice? Use [gofmt](http://golang.org/cmd/gofmt/). It maintains a universal coding style and it's heavily used among the Go community.
this has been formatted with gofmt -tabs=false -tabwidth=2 
The thing is that the cookie handling that I'm doing is totally stupid. I want to actually drop the cookies in to the mongodb database and reuse them later if they are still valid. 
&gt; I ran gofmt on my computer and it... just sat there. because you told it to read from stdin
The link above now points to the latest Zeus Beta 7 release.
the link is broken
I'm not sure how I feel about your method of synchronizing. Why use channels and closures when wrapping a mutex around that closure code would achieve the same effect? Some efficiency is lost using channels here, and I'm not sure it makes the code clearer.
Extremely feasible. Go has actually had X bindings for quite some time, and it appears that [someone has already tried to translate dwm into Go](http://gitorious.org/dwm-go) using the now-obsolete Go X bindings, although that project has been inactive since December 2011. I've [rewritten the X Go Binding](https://github.com/BurntSushi/xgb) to be concurrent, close to feature parity with XCB, and to support most X extensions. I've also written [xgbutil](https://github.com/BurntSushi/xgbutil), which should be extremely useful to a plethora of low level X uses. In particular, window manager development. Here's [my post](https://groups.google.com/group/golang-nuts/browse_thread/thread/e4bbef854703c44b) to the go-nuts mailing list announcing XGB and xgbutil. I've also [written quite a few working examples](http://godoc.burntsushi.net/pkg/github.com/BurntSushi/xgbutil/examples/) for xgbutil. Finally, I'm [working on a window manager of my own (Wingo)](https://github.com/BurntSushi/wingo) that *could* be helpful, but it's currently in a state of extreme development and may be more confusing to look at then not. If you have experience with XCB, you should feel right at home with XGB. It will also make your life easier to familiarize yourself with xgbutil so you know when it can be useful to you. In fact, XGB is so similar to XCB that it should be trivial to translate any XCB call to an XGB call. I'm not too familiar with dwm, but as far as Go's X support is concerned, you'll be golden. If you're looking for help, I'm on freenode's #go-nuts and #xcb channels with the same handle as here.
&gt; This is done with some kind of atomic primitive operation (likely available directly on-cpu or in the OS). Interesting. I can appreciate the use of an atomic primitive via the CPU, but if it was in the OS, isn't that the same as a mutex? &gt; lock-free refers to the fact that something in the program is always moving forward, not that every thread is simultaneously performing work. That guarantee is known as a wait-free system, not a lock-free one. Yeah, after I posted my comment I did a little research and discovered some literature on lock-free and wait-free stuff. It's actually quite cool, and after ten years in the field, this is the first I'm hearing of it. I'm eager for a situation to arise in which I could use it.
I hear there's a large following behind Wayland now, with Ubuntu pushing it. Might be interesting to port something like dwm to Wayland via Go instead. Though don't yell at me if you think Wayland is a bad idea :)
Thanks for your feedback, I have replaced the channel-based synchronization with a RWMutex.
I don't use Geocoding enough, but I would assume that it would be nicer to have ReverseGeocode("40.7453721,-74.0078293") be ReverseGeocode("40.7453721", "-74.0078293") [splitting into two arguments instead of a composite string] or ReverseGeocode(40.7453721, -74.0078293) [using float64 (which you already use in your Address struct anyway) instead of string] instead. I would also recommend (though, again, I have little experience in Geocoding) that you use the LatLng type that you already have defined in your code in other places that you use a Latitude and Longitude together as a pair, such as the Address struct, similar to how you're doing it in the GeometryData struct. If I recall correctly, that's how other Google code does it and it is more consistent. Otherwise it seems good to me!
implementing flame?
I don't know of any video (I didn't see any cameras) but the talk did happen and it was great. Particularly the Q&amp;A session afterwards. Many thanks to Russ for patiently and carefully answering so many questions!
How do people get this far seemingly without reading any of the docs whatsoever?
I read that. didn't help. The problem was not related to go at all (namely that I'm a dummkopf and had no clue how to permanently set an environment variable)
So you didn't set GOPATH like the docs said? And even then you weren't following the directory structure indicated by *either* of those documents? So you just can't follow basic instructions? I don't know how what they said helped as they basically crudly paraphrased the docs that you "had all ready [sic] read". (edit) Your other reply still doesn't make sense. Your directory structure *does not* match that document and it's just a matter of time before you're back with more problems. I don't know how to be "nice" about it. Both of those documents in less sentences than anyone has written here, explains precisely what a "workspace" is in the GOPATH sense of the words and the appropriate subdirectories. The environment variables I sympathize with completely, especially when you can expose them to bash without exporting them fully into the environment, let alone restoring them in entirely new shell instances, but your issues are... more basic than that, or at least in addition to that.
Useful post. Lets be dicks to people trying to get into a fresh language that has almost no uptake.
:)
finally a fix for the emacs mode breakages! very frustrating to have screen freeze when selecting lines with comments in them...
I don't link Dart to Go anymore than I link Go to any other language. Either you read only the title, or you just felt an urgent to say that you hate when people link Dart to Go because they're both of Google, and here seemed like the the easiest opportunity. Either way, I hope you didn't downvote (unless you had another good reason).
That makes sense. I suppose my confusion comes from the way the spec defines the operation of x.(T) which makes it sound (even though you're right - it's unnecessary) that this operation is actually possible.
Actually, looking at the [spec](http://golang.org/ref/spec#Type_assertions) now, it says right at the beginning that x must always be of an interface type. T can be either an interface type or a regular type.
Author uses non-idiomatic code which readability and comparisons difficult. I've run the code through their respective formatters and uploaded it here: https://gist.github.com/2932444
To add to sirseal's feedback, there is just way too much copy on the "About" page. Make the colors something other than 100% contrast, it's incredibly hard to read, and I spend all day in a light-on-dark text editor.
Thanks for the feed back. Go is considered a procedural language with object oriented qualities to it. However its been explained to me by uriel and a few other devs in #Go-Nuts that its not the best practice to try and conquer problems with an object oriented class inheritance model mindset using Go. Which is a very big part of how Cocos2D is designed. 
Just a light grey on a deep dark grey would be more than fine. It's not a style thing so much as a "100% contrast is generally a bit grating" comment. :)
Look at these other sites which are quite readable for some examples: http://www.panda3d.org/ http://www.ogre3d.org/ http://irrlicht.sourceforge.net/ You'll notice a common trend; light backgrounds, dark font. Crisp graphics without blurring (specifically on the title image). Edit: BTW, these days, there's not really a lot of need for an entire website for a project until it gets pretty big. You could do a lot worse than just hosting the code on github and _then_ making a website for it when / if you actually need it for something.
&gt; its not the best practice to try and conquer problems with an object oriented class inheritance model mindset using Go. It just tends to make things more complicated. Writing C#, I found myself overthinking about how the class I just wrote makes sense, and I also wasn't able to read what my program does without scrolling or switching file every 2 seconds. There are [ways](http://golang.org/src/pkg/) to write awesome Go code without the "object oriented class inheritance model mindset".
Ahh. Okay. I didnt know if you guys wanted more color or rather a dark on light color scheme. I personally like black backgrounds with light text. But I can see that the amount of people who would like that is probably slim. Ill make an option for either way. 
The project is just starting out. Right now im trying to research on the best solution for openGL and Go. Thats why there is nothing in the main repo. That will change soon though. :) 
So I updated the site. I also created a mascot gopher pup whose design is inspired by Gordan and Cocos2D's coconut. :) 
Didn't know defer had that much overhead on some machines. Thanks.
(3): [False](http://golang.org/doc/go_faq.html#Is_Go_an_object-oriented_language) Go has no type-hierarchy.
In my experience, projects that "announce" like this before any actual code is written fail to produce anything useful 99.9% of the time. But best of luck to you! 
no plain text version? ouch!
A 90% white on a 90% black-grey would be fine :)
The abstract for the lazy... In this paper we deal with the impact of multi and many-core processor architectures on simulation. Despite the fact that modern CPUs have an increasingly large number of cores, most softwares are still unable to take advantage of them. In the last years, many tools, programming languages and general methodologies have been proposed to help building scalable applications for multi-core architectures, but those solutions are somewhat limited. Parallel and distributed simulation is an interesting application area in which efficient and scalable multi-core implementations would be desirable. In this paper we investigate the use of the Go Programming Language to implement optimistic parallel simulations based on the Time Warp mechanism. Specifically, we describe the design, implementation and evaluation of a new parallel simulator. The scalability of the simulator is studied when in presence of a modern multi-core CPU and the effects of the Hyper-Threading technology on optimistic simulation are analyzed.
Feedback or pull requests welcome :P myGengo is a translation service: http://mygengo.com/ I plan on adding examples in the README next.
Im tackling the OpenGL headers now. I was actually hoping other developers would want to collaborate on the design considering its the Go version of cocos2d which is going to be different than the CCNode object inheritance model. I was hoping the website would help connect me with other developers who also have great ideas. I have some people following my repo on github so I feel satisfied. However... Alot of people are flaming me on the fact that I announced a project without code. There would be code if a Go OpenGL project was mature and supported legacy openGL mesa (specifically v1.4 for my netbook) and windows opengl32 v1.1. Some people suggested using the SDL wrappers. Thats not a solution im fond of. Atleast not for graphics. 
Gah! With every point release I keep hoping they implement the GC improvements that are due :) Oh well, maybe next time. Glad to see golang-nuts activity is livelier than ever and that new people keep flocking to the language. 
&gt; Gah! With every point release I keep hoping they implement the GC improvements that are due :) Oh well, maybe next time. If I had to guess, any major GC (and/or scheduler) improvements will mark a 1.1 release. &gt; Glad to see golang-nuts activity is livelier than ever and that new people keep flocking to the language. Same thing with the IRC channel. It's wonderful :-)
GC changes are major. They'll be in 1.1.
Your link doesn't support your claim of "False".
I think the problem is that, as someone else mentioned in the thread, many people tie OO to inheritance. Personally, I don't really think of Go as an object oriented language, but I think that might be because the term "object oriented" doesn't carry a lot of semantic value. I think of it as interface-oriented and composition-based. That being said, I was being quite literal in my earlier comment. The link specifically does not support the claim that Go is not object oriented. It says "yes and no", which is not the same as "no". I agree with the "false". I just don't think the evidence provided supported the assertion.
Good ideas. Will do.
What does the Go Playground use? Perhaps there could be code reuse or collaboration with that. 
If you want it to be good, let everyone edit this list, directly.
I actually looked for the Go Playground source before I started doing this, but after searching a bit and finding nothing I gave up and did it myself :/
Comments and critiques are welcome. I'm not sure if anyone would find this useful or well written but I'm eager to improve.
Thanks. Yes, I saw some comments in other posts about formatting and was frightened into compliance!
Actually the idea behind this was not to use a full-stack web framework but make use of what's already in the std. This is a utility bridge for using plain net/http and html/template but allowing you to re-use portions of handler logic with some convenience in adding functionality to templates. Trust me, I am with you on the crazy proliferation of web frameworks but this really isn't intended to open that can of worms.
Thanks for the pointer. I updated some comments now, hope they look better!
Why not use yacc?
I made a programming language in Go, but I'm afraid to put it here because it commits a few faux pas... go get github.com/bobappleyard/tsi go install github.com/bobappleyard/tsi Then run tsi and you're away. It depends on `readline` so you'll need to install the relevant packages. A basic description of the language is here: http://go.pkgdoc.org/github.com/bobappleyard/ts
This is really sweet. I've actually used Go's XML package quite a bit and didn't even realize you could this! (Then again, I've never had to.) The author said in the comments that benchmarks (against Java?) are going to be added. Those will be pretty cool to see.
Noted for further study. Thank you!
Automatic semicolon insertion is a must! Because it's a dynamic language and because most of the users will be Go folks (which are used to NOT end every statement with 2 key presses).
Finally, something to succinctly explain Go to colleagues!
That was a great presentation. Kudos to Russ Cox for re-recording it due to bad audio quality.
I'm not sure that it's a good idea to give the impression that Go programmers have something against Microsoft.
So what's the gopher's name!? I did know you can do those things, but did not know all those ways that they can be used. Good read.
Same as you except that I "did not know *some* of those ways that they can be used". But something like this is always refreshing.
Not any more, watch the full talk: https://www.youtube.com/watch?v=JE17r3n1kz4
Using close to broadcast - awesome! But is there any way to broadcast more then once? :) 
The Gopher is the Unnamed. It exists on a planescape of utter torment.
broadcasting on channels has some worrying issue with pointers and references. Generally a goroutine sending a pointer through a channel knows that it shouldn't use that pointer again, and a goroutine receiving a pointer through a channel can assume it has exclusive access to that value. At least that's the convention. Broadcast would break this and mean that sending a pointer through a channel would require addition synchronisation to work correctly. Broadcast isn't a common operation anyway. But if you really need to do broadcast then the http://golang.org/pkg/sync/#Cond pkg can help. 
Using Chrome I get "Someone tried to postMessage from an unknown origin" twice and I'm left with an empty white rounded rectangle against a black background. I can see the content if I use Internet Explorer and highlight the text to scroll up/down.
&gt;*some* Good call :-D such is algorithms
Whenever I read traditional `type name = value` style code now, it seems so backasswards to me. The Go way just reads like English, "There's a variable named values that is a slice of pointers to DataItem's." 
huh? When "The Gopher?" was born it had a name, or, it did until recently... and it still does, to me at least.
4 and 6 were the neatest.
How can you just un-name someone? That poor gopher...
Not sure what you're asking. Are you referring to the multiple GOPATH directories? I really guess I don't understand what you're getting at at all. The `go` tool is built to be very usable, especially for `go get`ting a random project, having it be immediately available to all other projects that you can build via `go build`. (And, if you follow the convention and don't "cheat" and invoke the compiler by hand, it's *quite* convenient). I don't know what you mean by "added import level directory" more specifically.
In 8 and 9, we have this : done &lt;- struct{}{} Can somebody explain why a struct{}{} is given to the channel ?
An empty struct has zero length, so they're effectively free.
Depends if it's already compiled. The source goes in `src`, yes.
lawl