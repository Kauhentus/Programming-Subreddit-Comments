&gt; const nbytes = 8 &lt;&lt; (\^uint(0)&gt;&gt;63) Yes, I know the "four perhaps shifted left one" to find out if `uint` is 4 or 8 bytes on this platform, but the sizeA calculation works for any "unsigned-integer-type", including one from another package. See https://play.golang.org/p/yAyKFwZkSE
From the error message, it certainly sounds like the socket is indeed already bound. Very strange indeed! Let us know if you found out the reason for this anomalous behaviour. Also, perhaps you could post your detailed error listing and "netstat -ao" output?
&gt; 1e87508d-89c2-42f0-8a7e-645a0f50ca58 How did you build a syscall.GUID out of that ? I can google for "1e87508d-89c2-42f0-8a7e-645a0f50ca58" and I can find: 0x3EB685DB, 0x65F9, 0x4CF6, [8]byte{0xA0, 0x3A, 0xE3, 0xEF, 0x65, 0x72, 0x9F, 0x3D}, but I can't find out how to convert it. 
Indeed, it is so lazy it should be a Haskell joke.
I am not the creator of this, but found it to be very useful. Definitely worth checking out.
Can't find the doc for syscall.GUID since it's Windows-only but it follows the same structure as the [Win32 GUID](https://msdn.microsoft.com/fr-fr/library/windows/desktop/aa373931(v=vs.85\).aspx). The string representation gives you the numbers to use. So for `1e87508d-89c2-42f0-8a7e-645a0f50ca58` you get `syscall.GUID{0x1e87508d, 0x89c2, 0x42f0, []byte{0x8a, 0x7e, 0x64, 0x5a, 0x0f, 0x50, 0xca, 0x58}}`. 
https://blogs.msdn.microsoft.com/dgorti/2005/09/18/only-one-usage-of-each-socket-address-protocolnetwork-addressport-is-normally-permitted/
github.com/caarlos0/env is also an alternative
Would the OP need to run netstat with admin rights to see results of bindings to ports under 1024? Or can you always at least see what's bound to privileged ports?
IIRC, netstat will show all used ports. Binding to a port under 1024 though should require admin rights. Until we get more details from him, we can only speculate!
If you already have written the logic it makes no sense to integrate http shit into those packages; keep that layer as is and call it from http handlers. You can add an http.HandlerFunc for each endpoint which calls your existing functions. If your existing functions take io.Reader and io.Writer params that would be very easy and simple.
Just skimmed the README, aren't environment variables case sensitive? The example sets them in all caps and then reads them in lowercase... edit: Yes [they are]: &gt; Uppercase and lowercase letters shall retain their unique identities and shall not be folded together. And yes this package looks like it's [doing it wrong]: envVar := strings.ToUpper(tagProperties[indexEnvVar]) [they are]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html [doing it wrong]: https://github.com/bradylove/envstruct/blob/e42d579b41e72905ab0a5234df74e26bbc6368e5/envstruct.go#L36
I noticed that too. Just opened an issue.
Help from a couple of smart guys at work, thanks Kevin and Vasko!: https://play.golang.org/p/p17ZApwz4A From https://golang.org/pkg/bufio/#Scanner.Bytes: "The underlying array may point to data that will be overwritten by a subsequent call to Scan"
I'm intrigued. Can you elaborate on the structure of your data in mongo? Is it basically a list with a bunch of flat records (with each record containing key/value pairs for owner, original location, ctime, and file contents)?
why use anything else that what he wants to use? there is nothing wrong in using whatever he chooses.
https://www.reddit.com/r/programming/comments/3dvzsl/why_you_should_never_ever_ever_use_mongodb/ IDK
I connect from this machine all the time. I'll add that to the OP.
+1 - I've had SO many nightmarish issues with MongoDB. Granted, this was usually when we would try to scale it out.
It looks like you're not seeing the port to connect to. Maybe your other client has a different default?
Did you open an issue?
Rethinkdb is not a good direction at this time. https://rethinkdb.com/blog/rethinkdb-shutdown/
That's marketing BS.
I'm inserting millions if not billions of documents. And I'm thinking of scalability as well.
This is good information to have. Right now, i'm just prototyping the thing so i'm using mongo. I think that a nosql db is the right container for this type of use case. At least at the moment I do.
Have you tried specifying the connect string like so: postgres://username:password@rds.host:5432/db ?
Thanks. This is pretty much what I was thinking too. Have a new program that imports those packages and uses a handler to call them. It makes the most sense to me and allows me to do things like use the packages individually or via the http server. I just don't have any good examples of something like this to reference. 
Yep.
If you want interoperability with std library tools and other people's tools, sticking with std library interfaces (implementing or consuming them) will be your best bet.
I'm pretty new to Go, so I'm not totally sure how to find out other than scowering the Gorm source itself. I can say, when I tried to run my app after installing Gorm, I got: Alexs-iMac:app alex$ go run main.go ../../jinzhu/gorm/dialects/postgres/postgres.go:7:2: cannot find package "github.com/lib/pq" in any of: /usr/local/Cellar/go/1.7/libexec/src/github.com/lib/pq (from $GOROOT) /Users/alex/Code/go/src/github.com/lib/pq (from $GOPATH) Which is why I then installed lib/pq
Looks like it then. Try adding connect_timeout=10 to your connection string above and see if it times out and gives you an error after 10 seconds. Might give you more insight into the connection problem.
 db, err := gorm.Open("postgresql", "user:pass@something.rds.amazonaws.com:5432/db?connect_timeout=5") Still did not return a value.
SQLite3 does fine with a couple million documents. A well maintained PostgreSQL node should handle a couple billion rows. Throw in some slaves to get better read performance. MongoDB is probably not the worst possible idea but SQL databases have atleast two orders of magnitude stronger consistency which reduces your client code.
I've used PG Admin 3, SQL-Tabs, the command line, and a Node.js application to connect to this instance, which makes me think this issue is specific to Gorm.
I personally love the standard environment and many companies run on it. Are out of curiosity, which part of it do you find "shitty"?
were you running on App Engine Standard Environment? if so the free tier is high enough that any "hello world" or even a relatively low traffic app should be for free I'm happy to help if you got charged for something you didn't expect, btw
It looks like many ios developers will start using one of those frameworks for the backend. Kitura is ready to use with Swift. Just one language. I think sooner or later new ios developers will not use Go, Firebase ... they will just pick up one of those frameworks sooner or later.
This is out of scope from the original question. It would be similar to suggesting the OP switch to drinking soda instead of coffee while coding because reasons. The question was about integrating existing business logic with an http front end. Not choice of database or beverage. 
That's a lot of code for "discfg is an interface around DynamoDB".
I thought middleware was supposed to run on every request and the comments clearly state "initializes the Datastore and attaches to the context of every http.Request". Also that is a local var, I don't think Gin is saving that in a global context.
You're not setting the timeout. According to the docs for lib/pq: * connect_timeout - Maximum wait for connection, in seconds. Zero or not specified means wait indefinitely. `postgres://username:password@rds.host:5432/db` is not a thing. As far as I can tell it causes lib/pq to attempt to connect to localhost. So, db, err := gorm.Open("postgres", "host=something.rds.amazonaws.com user=awsuser dbname=db sslmode=disable password=awspassword connect_timeout=5") &gt; FWIW I can see that none of my requests are hitting AWS. What method did you use to determine this?
Oh so treating mongo/nosql like a relational db produces unexpected relational db results... You might as well tell me you expected redis to never lose your data too... Nosql is not relational/transactional. And cannot be treated as such. Makes it not ideal for all use cases, and also requires you to think about storing your data differently. None of these are mongos fault. Their the fault of the person who implemented.
The first part of the comment, "Store is a middleware function", is wrong. `Store(cli *cli.Context) gin.HandlerFunc` is not a middleware function, it _returns_ a middleware function. One that encloses over the created connection. When the server starts up it calls `Store(cli *cli.Context) gin.HandlerFunc` once to create a connection and return a middleware that "attaches that connection to the context of every http.Request".
Yes, an abomination. It's like programming in javascript in Go.
I had almost the same reaction, Iris is still a 1 contributor project and not for lack of willingness of others to work on it. Also, the author seems to be too focused on Github stars as if it was some irrefutable proof of quality. Author always uses that argument when responding to any criticism. It is immature.
To be fair, this is probably someone learning Go by porting an idea from another language. Like how everyone tries to write a generic map and filter in their first week of Go and then regrets attempting it instead of using a for-loop. 
I guess I assumed that because lib/pq link to the Postgres connection string documentation, they support Postgres connection strings. AWS's console to view connections and connection attempts, specifically.
It's even worse. It suppresses the noise by linters so the dev forgets about the bad comments
There is no perfect way to secure a binary. If you give someone your binary to someone they can bypass any protection given enough skill, time and desire on their part. Having said that, I recently implemented licensing for a project of mine. I concentrated on one thing - to make it easy for paying customers and not to punish them, while still providing some level of protection. I used asymmetric encryption (RSA) to sign licenses. This is roughly what I did: 1. Generate private-public key pair. 2. Wrote a simple keygen app that signs a license with the private key. A license is simply a text file, which describes the licensee and the feature that should be enabled in the app. For example: licensee = John Doe max_users = 3 expires = 10.10.2010 The keygen adds the signature to the license and I ship it to the user. 3. In the binary I have embedded the public key only, which I then use to check the signature of the license. If the signature is valid, I assume that the information in the license is valid and was issued by me. You can get creative about when and how often you check for the license to make it harder for crackers: 1. Always compile with '-w -s' ldflags to strip any debug information from the binary. 2. Check for license in a background goroutine. 3. Embed the public key on multiple places. I have very basic knowledge about encryption, and yet I was able to make it work in about 2 days (including writing my key generator). As I said this can be cracked ... probably easy by a skilled cracker, but even large corporations that invest a lot of $$$ get their systems cracked in days, so I do not think that there's anything that we can do better :).
I just downvoted you because you care about that so much you yelled (capslock) about it.
Well, fuck you too.
+1. DRM is something many developers (and plenty others) fundamentally disagree with. If you want a pay to play model, charge. But people will bypass it whether you have DRM, or not. Don't spend all your time trying to make sure people won't steal, because they'll do it either way if it has value. The people who are willing to steal your software wouldn't have paid for it in the first place, and DRM will just drive more people away
There is none. The best options that even exist hold not even a year against dedicated groups.
i was running the program once and trying to run it again but the connection was already created. Now i have the problem of the connection doesn't wait for the input from the console. pretty sure it just closes the connection because i dont write to it quickly enough? not 100% though. when i run the client it just stops. 
pretty annoying that a example program wont work. kind of questioning weather it was a good idea to introduce sockets into a chapter that's meant to be teaching the concept of goroutines and adding the possibility of stupid network errors. 
What do the error or other logs for the server hosting the script show? It may require additional headers.
You need to include a Content-Length header, otherwise the server doesn't know when it's done reading the request. Any reason you aren't using the built-in HTTP client in Go? It's a lot of work to properly implement the HTTP protocol when you could just use an existing standard library instead. Edit: I should also add, if you are implementing HTTP from scratch for educational purposes, you should definitely get comfortable reading RFCs, especially https://www.w3.org/Protocols/HTTP/1.0/spec.html Make sure you pay attention to the meanings of "MUST", "SHOULD", "MAY", etc. in the context of RFCs.
I believe that the Angular team was working with Go for the backend. https://github.com/angular/universal/issues/391
I definitely second this. If you want to avoid headaches with go tools, just put your go projects into a proper GOPATH. It's not worth trying to work around. To keep my code separate from other go code I have two paths in my GOPATH. "go get" installs into the first path it sees in GOPATH and I keep own projects in the second path.
Here's another one: https://github.com/gliderlabs/sigil
To be honest I saw a lot of annoying things in the code. First off, with respect to the context, they use a custom Setter interface for the ToContext method, but the FromContext method requires a ctx.Context type, yet the Store middleware handler factory returns a handler using a gin-based Context. The DB for this seems like it could easily just be accessed via a global or through general accession methods from the looks of it unless I'm missing something here. ~~Not to mention there seems to be a needless struct embed instead of just using typecasting with type aliasing on the sql.DB type.~~ EDIT: After looking a bit more the last statement I made is wrong, it makes sense, but Jesus there's a lot of magic in the back. 
It's not their priority and investigating whether it's even a good idea is a super low priority for me, but it is on my list of things I'm supposed to be doing. Not a great answer, eh? 
The section "Problem with conditions" shows complete lack of understanding of the way mutexes and condition variables are used.
Impossible to say, what the question was, but maybe this: https://play.golang.org/p/kzhOgaDoE3
Well show me what you got so far? you at least need func (mystruct Mystruct) String() string { return "" } Then you also need those values with their indexes let say something like for i, val := range arr { // use index and val for your strings: [1:value] } Then maybe you could put them into a string together like this fmt.Sprintf("[%v:%v]", i, val) Then try and put it together using the `strings` package somehow. :D I did most of it for you. Take it the next step!
Thanks. I feel stupid. I didn't realize that I could use range for array - however, it's putting the string together in one return statement that's really getting me confused. But after resting my eyes for a few I'm going to tackle again with your suggestion. Thank you. 
I always found this method helpful https://golang.org/pkg/strings/#Join
the "you can't even connect an external database" part.
I don't see `sync.Cond` used very frequently. Honestly, the docs don't do a great job of explaining what it's useful for. Here's one concrete example: Imagine you want to poll for some condition: for !condition { } This works, but the loop is way too tight, and there's probably a race condition. You could add locks and a `time.Sleep` to the loop body, but that has disadvantages as well. What you really want to do is _block until there's a good chance that the condition has changed_. `sync.Cond` gives us a way to do this. In this code, the loop will only run once per second: cond := sync.NewCond(new(sync.Mutex)) var i int go func() { cond.L.Lock() for i != 7 { fmt.Printf("got %v :(\n", i) cond.Wait() } fmt.Println("got 7!") cond.L.Unlock() }() for range time.Tick(time.Second) { cond.L.Lock() i = rand.Intn(10) cond.L.Unlock() cond.Broadcast() } I use this technique in my [stm](https://github.com/lukechampine/stm) package to efficiently retry transactions only when one of the variables they depend on has changed: https://github.com/lukechampine/stm/blob/master/stm.go#L138
That's an interesting typo.
Wtf with url's in readme? Wtf with typos(?) in post and readme? It's a joke?
I totally removed Gorm and am just trying to connect with `database/sql` and `lib/pq` and am running into the exact same problem, which makes sense as Gorm's postgres dialect runs on lib/pq.
Hey. This is awesome. Thanks. Your example worked exactly how you said in the first case, and then connected successfully in the second case. Since it was clear I _could_ connect, as you said, something else about my code was wrong. In the main function of the app, the call to initialize the database was the line after `http.ListenAndServe(":8080", Router)`, which (for whatever reason) seemed to be the problem. If I move `initDB()` to the line before `http.ListenAndServe` I am able to connect successfully. Now I suppose I'll troubleshoot why that is... 
It would be nice if the documentation described what this software actually does.
What surprises you most about the way Go has grown and the uses you hear it being put to? What is the most unexpected use of Go you've come across?
Imagine you have a system where you pass around several different structs that all are supposed to do a similar job. If you write an interface defining the methods that defines that job, you can use the interface type in your functions which use those structs instead of having strict struct types there. So instead of having to write different code to print every single element in your system for example, you can instead write a function which takes in a "Printable" interface which requires the "Print" method for each element. This example is actually very close to a real use case-- in go's fmt package there is a "Stringer" interface which requires that elements define the "String() string" function to be a part of. Then, if you ever fmt.Println(myStruct), it'll use your struct's specific String function in the log. 
There are example commands and a full response showing all the data returned by the different AI back ends. What exactly are you wanting to see? 
I think to understand the usefulness of interfaces, looking at the io package is the most insightful. Basically every go code that needs to receive or pass binary data will use an `io.Reader` and every go code that wants to write out something will use an `io.Writer`. With that, the user of that code can decide whether they want to read or write the stuff from a file, a buffer, a network connection… You don't use the interface to just group together methods; you use it to specify "I can use any thing that can do this". The usefulness of structural instead of nominal typing (that is, to implement interfaces implicitly) is, that it allows to define interfaces for third-party packages. For example, say you want to log stuff in your package, but give your user control over where to and how to do that. You *could* take a `*log.Logger`, but that would severely limit what they can do; you can not have a nop `*log.Logger` (it will always at least format your logging statement, even if you discard it then, and formatting takes time, which is important for verbose logs). You could instead write an interface that has the relevant methods of a `*log.Logger` and take that. Then your users can write their own nop-logger, which actually does nothing, unless debugging is enabled. Or just pass a `*log.Logger`. Without the flexibility of structural typing, you couldn't do that. You'd need to rely on the author of the `log`-package to write that interface and specify that a `*log.Logger` implements it. There are other benefits too: Breaking dependency cycles, for example and that it encourages writing small, self-contained interfaces, instead of big ones (like in java).
Well, the obvious elephant in the room is "what do if there is interface overlap?" and the only real answer is; avoid by using very explicit function names and try to seperate code that could overlap interfaces with differing functionality. At their core, interfaces aren't really much magic, they're descriptions of capability. Some interface like io.Writer simply states that all structures that are capable of writing data can be used as it's type instead. This means underlying code only needs to handle the io.Writer interface and can then handle all other structs or types that are capable of writing as per interface definition. Secondly, the implicit approach solves a bunch of problems; you don't need to declare something to be part of an interface on top of writing the methods for it. Writing the methods of an interface is sufficient to fulfill an interface according to the compiler. You don't do much different when it's explicit except that you now have a buttload of interface relations on some end.
You can download the new version of Hugo at the bottom of the [release notes](https://github.com/spf13/hugo/releases/tag/v0.17).
Haha, I should read man pages more often! I was unaware of -f! Oh, well. Had fun writing it and learned about an edge case in scanner.Bytes() ;D
Yeah, whole string or substring. I could toss a -e in for regex, but with a vastly more powerful tool in grep -f (see my reply above)... Maybe the one advantage would be that multifilt is importable for a Go program.
Congratulations to the Hugo dev team for the release! You guys have an amazing piece of software in your hands, keep up the great work.
That sentence was sufficient. You should include it somewhere.
interfaces are the only way to achieve polymorphisme in Go without resorting to reflection.
It looks like `mf` does provide one minor advantage over `grep` (at least, I don't see yet how to do it with `grep`). You can specify multiple `-v`s and a `-f` (but `mf` only filters out text, it does not return matches in its current state). That does not likely balance how much more slow `mf` is over `grep`. If I get really bored, I can look into making faster by implementing [Boyer Moore String Search](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm).
It's probably a stupid question, but.. &gt; It means that you can write your content using Asciidoc[tor], or reStructuredText. no HTML?
How long since it fasted? :&gt;
At least for the naming thing, that makes it even more important for it to be corrected. Early exposure is key in this kind of thing to build familiarity.
No, it's a HTML generator.
&gt; HTTPError, OSError; not HttpError, OsError. I sent an email to the author, lets hope he'll correct it.
Like others have mentioned, misusing condition variables can lead to all softs of problems, just like misusing channels leads to a completely other set of problems. I'd like to add to what others have said, though. Your point about "Channel Can Timeout" (with the implication that condition variables cannot) is a statement specifically about the Go standard library's (arguably weak) implementation of condition variables. (For an example of condition variables that can time out in another language, for instance, see http://en.cppreference.com/w/cpp/thread/condition_variable/wait_for). Best I can tell (https://github.com/golang/go/issues/9578), the reason for condition variables in Go missing timeouts is political -- channels are the "preferred" way of doing synchronization, so the language maintainers are happy to gimp everything else. Out-of-band signaling of channel closure is actually a really nifty feature. Unfortunately, it's pretty error-prone, and incomplete. Forgetting to use the two-arg form of channel receive simply gives you the zero value for whatever type you're expecting to receive. Such signaling also doesn't go the other way around. Closing a channel from a receiver works, but sending to a closed channel panics, rather than giving an error (or falling through to the default case in a select statement). Finally, you say you use buffered channels to avoid blocking senders. Unless you know a priori how many values will go through your channel and you size it big enough to contain all of them, you can still fill up and block your sender.
Hi, Tim! It's nice to see you on here. For benchmarking, it's best to use the benchmarking facilities: https://golang.org/pkg/testing/#hdr-Benchmarks Dave Cheney has a great article: http://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go Also worth noting is that /u/alecthomas has a great project covering this topic: https://github.com/alecthomas/go_serialization_benchmarks I'm not sure what the discrepancy in results is caused by, but if you spot something wrong with Alec's repo, I'm sure he'd welcome a PR. --- Edit to add: I setup the project locally with a random image and moved the protobuf function to the end. The results were different than your's, and, worse, they were incredibly sporadic. This largely supports the need to use the correct benchmarking tools. 2016/10/09 15:51:45 Reading photo.jpg - 6062 bytes 2016/10/09 15:51:45 Encoding output.bson - 6098 bytes - time: 59.542µs 2016/10/09 15:51:45 Encoding output.json - 8114 bytes - time: 89.438µs 2016/10/09 15:51:45 Encoding output.xml - 13547 bytes - time: 594.851µs 2016/10/09 15:51:45 Encoding output.pb - 6076 bytes - time: 42.824µs --- Second edit: After moving the code into benchmark functions, these are the results: benchmark iter time/iter --------- ---- --------- BenchmarkMarshalBSON-8 300000 4206.00 ns/op BenchmarkMarshalJSON-8 100000 24548.00 ns/op BenchmarkMarshalPB-8 500000 3245.00 ns/op BenchmarkMarshalXML-8 3000 344674.00 ns/op I'll get these changes up in a fork in a moment. --- Probably the final edit: https://github.com/daved/compare-api-encodings/tree/fix/tobench0 P.S. Let's go for beers soon!
Cool, nice benchmarks. You will see different performance characteristics with larger files for sure. Alec's repo looks at a normal API schema with fields like string, int and timestamp, no []byte fields. I am interested in kind of an unusual use case 2016/10/09 18:39:56 Reading photo.jpg - 5085 bytes BenchmarkMarshalBSON 1000000 1671 ns/op BenchmarkMarshalJSON 200000 9367 ns/op BenchmarkMarshalPB 1000000 1243 ns/op BenchmarkMarshalXML 10000 165345 ns/op 2016/10/09 18:42:32 Reading /home/me/testimg.jpg - 136356 bytes BenchmarkMarshalBSON 100000 23545 ns/op BenchmarkMarshalJSON 10000 235499 ns/op BenchmarkMarshalPB 50000 24911 ns/op BenchmarkMarshalXML 300 4418925 ns/op 2016/10/09 18:49:11 Reading ./big_buck_bunny_720p_2mb.mp4 - 2107842 bytes BenchmarkMarshalBSON 3000 378679 ns/op BenchmarkMarshalJSON 300 4229422 ns/op BenchmarkMarshalPB 5000 360552 ns/op BenchmarkMarshalXML 20 69939283 ns/op
Canadian High School. No computer science department.
One good reason why that "startup errors" one should definitely be "Maybe": Kelsey Hightower [talks a bit about this](https://medium.com/@kelseyhightower/12-fractured-apps-1080c73d481c#.xerautb18) in his "12 Fractured Apps" blog post. Panicing would make sense in the face of truly unrecoverable errors. For example: You expect some envvar to be provided to you, and it isn't. There's little chance of being able to recover from this. But there are a class of startup errors which stem from "I'm trying to connect to something and it isn't responding" where a good suggestion is: Don't panic (yet). Retry N times, and then panic if it still can't. Its an important distinction because many times you have a service which relies on some other service, and you're using some orchestration tool to deploy both at the same time, but the first service starts first and gets to that connection check before the second one is ready.
I've added another branch with variable data size processing using the flag `-size`. For testing run `go test -bench=. -args -size={int}`. If the size is not set the tests will use the embedded image data, and the size is limited to 1024. 1MB BenchmarkMarshalBSON-8 5000 351.19 μs/op BenchmarkMarshalJSON-8 500 3181.34 μs/op BenchmarkMarshalPB-8 5000 340.55 μs/op BenchmarkMarshalXML-8 20 54051.85 μs/op 128MB BenchmarkMarshalBSON-8 50 33.73 ms/op BenchmarkMarshalJSON-8 5 302.39 ms/op BenchmarkMarshalPB-8 30 35.05 ms/op BenchmarkMarshalXML-8 1 4556.18 ms/op 384MB BenchmarkMarshalBSON-8 20 92.23 ms/op BenchmarkMarshalJSON-8 2 704.40 ms/op BenchmarkMarshalPB-8 20 90.28 ms/op BenchmarkMarshalXML-8 1 12784.65 ms/op 768MB BenchmarkMarshalBSON-8 10 184.86 ms/op BenchmarkMarshalJSON-8 1 1466.56 ms/op BenchmarkMarshalPB-8 10 183.56 ms/op BenchmarkMarshalXML-8 1 25723.24 ms/op 1024MB // no XML: '-bench=(BSON|JSON|PB)' BenchmarkMarshalBSON-8 5 243.79 ms/op BenchmarkMarshalJSON-8 1 2782.18 ms/op BenchmarkMarshalPB-8 5 239.10 ms/op --- Edit (forgot to leave a link to the relevant repo): https://github.com/daved/compare-api-encodings/tree/new/variable-size-bs
Take a look at Dave Cheney's fantastic talk on SOLID Go Design: https://www.youtube.com/watch?v=zzAdEt3xZ1M (edit) Specifically when he talks about the Liskov Substitution Principle, about 11 mins in. 
Man, I wish I was this smart in high school.
Why not just use stunnel?
Ponder: https://play.golang.org/p/8M53XKti_T
So, PHP, Node.JS, Go and now Swift. That's 4 backend languages being written by developers. Can I ask what your boss thinks he is doing? The level of technical debt in your company must be frightening. Plus seems no standardization to speak of? I've worked in a company that had this problem. PHP, Node.Js, Ruby, Go, and some other person was writing something in Erlang. It got to the point that every new project was written in the flavor of the month. Thankfully our "boss" moved on and I was given the reins for a bit. Guess what I did. I stamped out all other languages, made the devs port over apps in other languages to Go. When I left, they were a Go shop. The outcome? Projects were standardized. Projects turned around quicker than before. Developers could jump into any project because it was built on standards within the company, we didn't have to wait for someone to come back from holiday or being sick or looking at dev notes. In fact, when some team members (like me left for pastures new). The company didn't actually need the number of developers it thought it needed due to some projects needed X lang. So savings for the CEO. He was happy about that. It's easy to standardize. I can't see the case for node.js, php or even swift in the backend now. Unless someone can enlighten me? I'm genuinely interested! Thanks p.s I used to love PHP developed in it since 2009. Same with Node.JS is was awesome when it came out. Now, I just develop in Go. Not interested in learning Swift, Ruby, Erlang or any other language either.
Many IOS developers will develop their apps (smartphone, tv, tablets, desktop) and the backend with Swift. They will only need to know one language. Google might try to do something like this with fuchsia, Andromeda, no Linux therefore without Go.
Crane, maintained by dataman-cloud, is a docker control panel based on latest docker release. Besides swarm features, Crane implements some badly needed functionalities by enterprise user, such as private registries authentation, ACL and application DAB(distributed application bundle) sharing. The smart fuzzy search function give user quickly access to the desired page. Crane can help storing registry auth pair, from where you can choose a predefined registry auth pair when deploying a DAB, without the need to docker login when access private image. Crane can also help sharing your private images with your coworkers easily. Features Swarm features: Portal every feature of swarm almost. Crane has highlighted the common swarm functions and improved the user experiences through the friendly frontend. Stack templates management: User can save a running stack as a template, by which others can deploy repeatly. Image management: The private image owned by user can be publiced to others. Fuzzy search: A in-memory index maintained by the backend serves the function. Node operation: Crane details about a node such as kernel version, docker info, docker images and also containers running on the node. Network Management: The overlay network CRUD. Registries Authentation Managment: You can save your private registry username/password pair to Crane, with which a to-be-deployed stack with restricted image access can attach. Webssh: Command 'docker exec' is the magic behind it.
Sounds interesting, bookmarking this to try their demo later as it seems to be down at the moment!
OP specified 1.0, so it's relevant.
FWIW, I believe it to be pretty straightforward to build a thing that makes diagrams of type hierarchies and call graphs and the like from go source code, if you build on guru (or the go/types package itself) and graphviz. I did that myself at some point. And that would probably be the most useful thing in that regard that would add value over diagrams manually maintained in third-party tools.
You can get detailed information about a Go program using [go/ast](https://godoc.org/go/ast). Presumably you just need to loop through that information and put it into an XML document and then you can use an existing tool to convert that into a diagram?
https://www.sqlite.org/fileformat2.html
Also, HTTP 1.1 also specifies that it must use either a Content-Length header or use chunked transfer encoding. &gt; A user agent that sends a request containing a message body MUST send a valid Content-Length header field if it does not know the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response. 
It's too bad... I 100% agree that "I still think the Go ecosystem deserves a decent functional programming language". I like the Oden idea but I think the syntax was just too weird. I think it would have been better to adopt something like Elm, which is gaining traction in the JavaScript space. People who use Elm are looking for a server-side version. I wonder if I an Elm compiler that compiles to Go would get traction.
Thank you very much. &gt;Are you done with it That's a very good question! The thing is that I started out writing a general purpose tutorial to get started with writing webapps, I then added a building an API chapter, then I added how to write a cli client in Go. What I found out that there is no upper limit at all to the book. There is always more and more content which I can keep adding, sadly though I have limited time as everyone else, so I decided to publish the book for now. When I find time in the future, maybe, I'll add advanced topics like websockets and stuff. As for now, yes, I am done with it, this is an introductory book which teaches writing web apps in Go language without a framework.
Stunnel doesn't allow me to serve multiple protocols from a single port. Plus, with the new acme/autocert library, I get easy integration of free certificates! I'm also using tlsmuxd as a SNI reverse proxy because I will be running multiple websites. I don't think stunnel supports that either.
edit: the code in question is now https://github.com/nhooyr/tlswrapd/blob/8c935cbf75e76d9327f06a074bedc80593f84c76/proxy.go#L102-L122 1. I use a buffer pool to minimize allocations of 32KB buffers. 2. struct{} takes zero memory. It's a very efficient way to use channels for signalling. 3. I'm calling cp twice with swapped arguments. Once in a new goroutine and once in the current goroutine. One will read from c1 and write to c2 and the other will read from c2 and write to c1. The first goroutine to error will be able to send to the first channel because it has a buffer of one. Then it will close both connections and log the error and disconnected message. With both connections closed, the other goroutine will error, but it will not be able to send on the first channel, it will just cleanly return.
Whiteboard
why do i have to pay $50 for this... 
You do not have to pay anything for it, to download reduce the price to 0$
Actually, I had the book on gitbooks, but for some reason gitbooks doesn't work. Leanpub is one of the best formats for anything. I have kept the min price as 0$ so anyone can download it for free and can choose to pay something for me if they want to show their appreciation. As compared with gitbooks, I found that leanpub is amazing. Also, take a look at https://github.com/thewhitetulip/web-dev-golang-anti-textbook/ this is the source of the book, the book is open source, and check out the material and then judge if you would rather not open an account on leanpub. Seriously, it takes a few seconds.
It would be great if you could record some videos and load them in Udemy. Your book would be a great complement to that course and you could have plenty students that would be willing to enroll. Included myself. Thanks for sharing. Cheers!
I love how people constantly downvote this thread, for those, can you please tell me why is this post being downvoted? 
Most people would welcome any initiative in that regard. Promotional videos on YouTube plus a profesional course on Udemy or other platform of your choice. People would pay for the udemy course for sure since it gives a feeling that they get a better education since you pay for it. More quality and more commitment from the teacher is also a plus. 
This is a true fact which makes me wonder if I should put a price tag to the book :-D This is unrelated, but when Audi had launched a vehicle for students and priced it for $ 15K, people didn't buy it because it was considered "cheap", when they raised the price to $ 20K, they got a flood of orders :-D I do not plan to put it for a long time now. Thank you for helping me decide. I will keep the book for free and put the video course on Udemy, that way, readers can download the PDF if they don't want to pay for the course and the course is a premium.
https://github.com/griesemer/dotGo2016/
The basis of this is obviously attractive, and I want to like it, but I don't understand why storing a db must be done as a package global. The generated code could offer `sb0 := generatedpkg.NewBoiler(sql.db) Boiler`. Instead of `pkg.FindPilotG(id)`, and `pkg.FindPilot(db, id)` package functions, it would have `sb0.FindPilot(id)` and `sb0.FindPilotIn(db, id)` Boiler methods. This would improve freedom for composing types and simplify usage without harming testability. I apologize if I've misunderstood something or spoken incorrectly.
This would be breathtakingly exciting.
Was RMS this grumpy when he was alive?
was anyone from here attending? what is this about, indexing multi-dimensional arrays or iterators? is there a supporting proposal?
Cool. I'll see if I can do it over the weekend.
It's a fair point :) Thanks for the feedback. Two things to point out about it however is that this makes it more difficult for people to bring it into an existing web project for example. Their application state has to change the types it's using, this way, you still simply have your sql.DB everywhere, and you use it with sqlboiler anywhere. Also the alternatives you've suggested are syntactically pretty much the same as what we have so usability gains are fairly minimal, and I'd say that you actually have *more* freedom with this approach since you have to design the types and compose them yourself in order to manage this connection :) If I did it again I'm not sure that I'd change, but it's definitely worth some thought! edit: Don't use pointer syntax in reddit, makes everything italic.
&gt; A great deal of students are waiting for a course in Udemy about web development in Go. I also believe that Todd McLeod (the author of this course: https://www.udemy.com/learn-how-to-code/) is working on a web development course. I think he is taking an approach that is pretty similar to his original udemy course where he goes over all of the common libraries and explains how to use them. I am also working on a book + screencasts that are pretty similar to Michael Hartl's Rails Tutorial (https://www.railstutorial.org/) in how and what they teach. They focus on building a photo gallery application from scratch. I haven't really considered publishing them to Udemy (I am instead delivering mp4s and ebooks to everyone who purchases). Is there any reason why you generally prefer Udemy over something like this? I ask becuase the Udemy route means authors have to give up ~50% to Udemy vs keeping say 90% of the proceeds and then investing that into more books + education content.
 asRunes := []rune(str) l := len(asRunes) 
Why not just reverse it, and compare? Runes go a long way too.
I guess I don't see the problem. Why would the divide-by-2 compare ever fail on realistic input? Yes, you could have different size characters, but if you do, I think you just guaranteed that it's not a palindrome?
Reversing the string at the byte level will make two identical multibyte characters differ from one another.
Characters may be multiple runes long (see grapheme clusters), and reversing at the rune level can make two identical grapheme clusters differ.
I think that I don't understand your library enough to be able to reach any clarity. At first glance it seems to create something large and rigid, but I'll give it a try sometime and see if that concern materializes.
That's why I'm saying runes. Runes should keep the multibyte character like '你' in tack, I think. Though I have to cook up a short script to be absolutely sure about that. :) 
Yep, this works absolutely fine: https://play.golang.org/p/_MD94Z3qhB Playground to prove it.
Hello Mr. Pike. I thought that using runes would solve this issue. Also, going with the rune reverse algo which is in the bare string package, would that solve the problem? I have a short playground here to prove it: https://play.golang.org/p/_MD94Z3qhB which correctly preserve a multibyte character.
So you don't have to dig through the comments, here is the design document: https://github.com/golang/proposal/blob/master/design/6282-table-data.md
Note that there is a very substantial revision to the proposal in progress: https://go-review.googlesource.com/#/c/25180/
godoc.org has a package dependency graph feature: https://godoc.org/bitbucket.org/weberc2/fastcsv?import-graph Not quite the resolution you're looking for, but it helps visualize the package dependencies, and you can click each package to see specifically what its constituents depend on.
Google Compute is not App Engine though. Are you sure you're not using App Engine Flexible Environment? If it was App Engine you'd see: "App Engine Frontend Instances" I am not in the GAE team, but I am a developer advocate for Google Cloud and I do know App Engine quite well :)
That doesn't work for multi-rune characters: https://play.golang.org/p/-S3T_Qqh12 Further reading: https://blog.golang.org/normalization &gt;Theoretically, there is no bound to the number of runes that can make up a Unicode character.
Agreed
How is passing a channel across a channel represented in UML?
Yes, I was noticing that the commits had slowed to a trickle a little while back. I'm really hoping that this doesn't mean the end. I know our company as well as quite a few others are pretty heavily invested in RethinkDB and most have offered to help as contributors. Currently, their "open-rethinkdb" channel has over 400 members, quite a few of the more advanced features (specifically the Changes API) were supported pretty heavily by external contributors. It seems like there are lots of people who are interested/invested in seeing RethinkDB continue. With that being said: I'd still use it over MongoDB but I'm also not going to hold my breath on continued development. I remain cautiously optimistic. 
Does twitter have a new chat feature? 140 characters seems like a bad way to have a discussion. Maybe do it on reddit?
Never used one, had no need with standard library, but take a look at Beego.
This tends to come up very often, and [Gorilla web toolkit](http://www.gorillatoolkit.org/) is a solution that many people recommend. It's not a framework, but rather a set of tools. I prefer the standard library, myself. It has everything I need without being excessive or being problem-specific. Templates via [html/template](https://golang.org/pkg/html/template/), logging via [log](https://golang.org/pkg/log/) or [glog](https://github.com/golang/glog) if you want more control, etc. I don't think using these things equates to making your own web framework, but that depends on how much of a plug-and-play solution you want. All of that relies on knowing how well your site/service fits into whatever frameworks you are looking into - you don't want to end up having a constant nightmare of trying to shoehorn your problem into some framework that's trying to lead your service in a different direction.
I like revel https://revel.github.io in combination with gorilla for csrf, but I dont know how well revel will be maintaint.
Good point!
Fair enough. Nice.
thank you very much. I will modify all you suggested in my next version.
Those benchmarks have been proven to be irrelevant and outright wrong a few time now. Please don't use them to compare anything.
which one is better gorilla mux or https://github.com/julienschmidt/httprouter
Perhaps the [Iris](http://iris-go.com/) Framework is something to look at. [Documentation](https://kataras.gitbooks.io/iris/content/) and [on GitHub](https://github.com/kataras/iris)
Why you got a downvote. If you literary just type this into google =&gt; 'how to structue a golang api' the first 3-4-5 results will tell you most of the things you'll need to know. Sure, most of them use the gorilla muxer, but just replace that with net/http router, and bamm. You're at the same place. Most of them don't use any special magic. Be a bit more proactive my friend. That will get you a long way. Learn how to search for your answer. Sure asking is okay most of the time, but like I explained a year ago, people's time is precious. If you ask a broad ass question, chances are, you'll get a down-vote or smart ass people to answer you, or no answer at all. Now, if you would have asked a more specific question, like how do I take care of A CORS request from my reactJS once your API is all setup, or how do I create a middleware which does an OPTION first for each request, that's a whole different game. You'd probably receive a couple of nice answers. In short, if posting a question, be more specific, and always try to find some answers on your own first.
We use echo extensively for various applications. Very nice and easy to use. Version 3.0 will also bring back some simplicity that was lost with version 2.0
I only use gorilla, but if you really want a framework I think echo is good to try.
Do you want to get stuck with an awful architecture? Because that's how you get stuck with an awful architecture.
Modern compilers are always better in optimising than one programmer. Stop worrying about it and finish your stuff first, before you go to performance works. And if you do that, working with a profiler to find the hotspots and retesting them after change, will get you faster and better results than those small things as string creation. So back to topic. Why don't you just ```buf := bytes.Buffer{}```? I couldn't find the source code of your benchmarks in the article and now have to assume that you *aren't* reusing the buffer variable. Which is wrong, because it would be the only logical reason in your ID generating case to do so. By the way, string concat with + is often only a problem in script languages like it was in PHP 5.
Yeah. The more I think about this, I think you might be right. I was thinking it would be faster with nosql if i had primary-keys that I could define easily but there's limitations on what i can do there and i'm not sure it would be wise to create some super lengthy private keys either. Since I'm just prototyping it, I should check with postgres as well and see if there's room for improvement.
The methodology of this article is okay but I fear it falls into a classic trap of benchmarking. If you benchmark without enough rigor and understanding, you'll draw the wrong general purpose conclusions from specialized preconditions. There are a number of flags to tip you off. The most important one is that the typical way you should use bytes.Buffer is to simply declare one: var buf bytes.Buffer This is important. If you look at some [meaningful source](https://golang.org/src/bytes/buffer.go#L13) in the buffer implementation, you'll find that it allocates a 64 byte array as scratch space to avoid the exact performance issues that this article is re-creating by pre-allocating a buffer each time. It also means the buffer itself and the scratch space are stack allocated. It can be controversial to tout this as great or important, but it will lower GC pressure in real programs. GC seldom impacts benchmarks but _occasionally_ it can impact long running daemons. It would have been nice to look at [strings.Join](https://golang.org/src/strings/strings.go#L342) as well, as it is a duplicate of other code benchmarked separately in the article. The snarky tone about `bytes.Buffer` being better because it's "low level" or what have you is unnecessary. `bytes.Buffer` is nice because it is an `io.Reader` and `io.Writer` implementation, and it's a superb general-purpose way to build buffers of bytes safely without having to deal with the lengths and slice offsets and such of everything. You cannot use the "+" or Sprintf methods on, say, a slice of strings, and you wouldn't want to use them on large buffers. At the end of the day, with these types (eg not with `[]byte` or something that isn't as copy-happy as strings), and with keys this small, you won't be beating the + method. If you can absolutely guarantee keys will always be this size, then congratulations, you've found a way to safe ~20-40nsec/key, and if you're doing a batch job on billions of keys, this adds up to real time. However, benchmarks can lie, and this one lies a lot. In a similar vein, insertion sort is better than quicksort on small inputs, but it's the _wrong_ lesson to learn that insertion sort is better or faster than quicksort. `bytes.Buffer` _should_ be your first stop for building non-trivial buffers. It just so happens that these examples _are_ trivial. Benchmarking your use case is the Right Thing, but be careful about drawing generalized conclusions or lessons without rigorously going after _why_ your benchmarks happened the way they did.
&gt; Modern compilers are always better in optimising than one programmer. That's a bit of a sweeping statement. Modern compilers are great at optimizing within the bounds of what they know and can assume, but just looking at data oriented design techniques in game engine programming there are still massive optimizations that can be made in a targeted fashion by a programmer with a great understanding of the language and processor behaviour. 
&gt; Stop worrying about it and finish your stuff first, before you go to performance works. Amen (at least in general). "It has to run before it can run fast."
I've been writing a website using go that just uses net/http. Writing all the handling code is a lot of fun and a great learning experience.
Sorry, my intention was to say "don't go grasping for bytes.Buffer when you have something trivial to do", not that bytes.Buffer was good for nothing. And also to never assume something is faster or less allocate-y than something else without benchmarking it.
Please, give us a decoder!
I think you're asking about my shell, since I didn't use ssh. My shell is fish shell: http://fishshell.com/
I have followed the twitter handle a while ago. Nice work man!
ive been thinking the same thing. just trying to seperate out specific concepts into their own packages files etc. thanks for posting this question. 
tl;dr: TIL there are compiler optimizations
What is based Go version on your ebook? Would like to know more about context and http2 in Go 1.7 for Web App.
Sounds cool. I'd not heard of them until your post. You can execute the gitlab runners on your own kubernetes cluster. So the speed hasnt been an issue.
Check out [OCaml](http://ocaml.org/) together with [js_of_ocaml](https://github.com/ocsigen/js_of_ocaml). The OCaml compiler generates fast native code and js_of_ocaml lets you retarget your code to JavaScript.
I think it was only one person handling both accounts, because the top three comments were made from one account &amp; immediately afterwards the other account continued the conversation. Even I'm baffled. I'll email you in some time, currently on mobile. Just to be clear regarding the context, expert nces of recording right? :)
I'm not familiar with Travis but I'm pretty sure you can run as many GitLab CI Runners as you want, and they run jobs in parallel. I even see [autoscaling](https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/configuration/autoscale.md) is an option. What makes this commercial option better, other than someone else is managing it for you?
Thanks very much, will try to read as much as possible.
Imagine having 64 and more threads in parallel :D That's what Semaphoreci offers.
Why so downvoted? Beego is really good!
Oh yeah, sorry if that was confusing! I meant I can pass along any/all advice I was given about recording videos to help you out and recommend a few products if you are going to be buying things like a webcam, mic, etc.
Thanks for the response! I've heard some issues with how sync.Pool is used and tbh, I'm not super familiar with it. What would you consider a good use of sync.Pool? Is [this](https://github.com/Sirupsen/logrus/blob/master/entry.go#L11) an abuse of sync.Pool as well? (That's where I first discovered it)
Are you implying the open source GitLab CI can't scale to 64 threads? Perhaps you meant to only compare with GitLab's SaaS offering? I was talking about a self-hosted setup.
My understanding is that `sync.Pool` hooks up with the GC at a low level. It's go-routine specific, but only in the way that all memory (de)allocations need to be done in a race-free way. I don't believe there's any penalty over and above what would be there for any GC'd buffer. Is that not the case?
gin
You're focusing on (easily googleable, frankly) details too much, never thinking about your packages' structure and interoperability, it seems. With this approach the code turns into a mess so fast it's garbage even before being typed.
Agreed, I really enjoy working with Beego. I am very productive using it, the bee tool is fantastic, the ORM is very handy also. 
So you are using your database to save and retrieve code? Is there some particular feature offered by the database not possible with code reversion control and continuous integration tools?
What about a readme?
It does, but [still](https://golang.org/src/sync/pool.go#L84). I don't know about the general case, specific cases still need to be benchmarked. But I used a `sync.Pool` once in the hope of improving performance, in precisely this kind of usecase and it slowed things down, instead of speeding it up.
I'll throw in a (shameless) plug for my own screencast series. Here's a cast that shows a complete program, package layout and all: https://www.goin5minutes.com/screencast/episode_11_json_apis/ Note that the code is open source and linked to from that page. Hope it helps.

oh what would I give to have a built in `-ftree-vectorize` and `-O3` level optimizations in Go
There is a link at GitHub repo to explain about whole of the project: http://mylg.io If you have any questions please feel free to ask here.
That project is maintained by a person obsessed with Github stars. They also don't give credit to other codebases Iris uses (disrespecting licenses), and doesn't take critique very well. Better stay way from it and work with projects where authors are more sane and open.
I'm not looking for a fw like RoR in fact I have a bunch apps which running batch and another expose API running in Go :) The main focus of this thread is hear experience from another folks in terms of web fw (or libraries for web development). But in any case I'm not looking for something like Rails. 
Thanks. I'm afraid the path I'm following is the right. I have many services running mainly with stdlib. But I would like to hear another folk the state of art on this one. 
This is simply a library though. I'm rather interested in actual lifecycle anecdotes. Is one easier to maintain in the long run? Does one often crash?
I followed the same pattern as you. When I started I used [goji](https://github.com/goji/goji). Now I just use the standard library with httprouter and [graceful](http://gopkg.in/tylerb/graceful.v1). I think it's totally fine to go with a framework at first because you'll be done much faster. I haven't kept up with goji, but when I was looking through frameworks (a ~year ago?) it had the best documentation and examples. I was able to mostly copy and paste a few examples with barely any knowledge of golang or web frameworks and everything worked fine. It wasn't hard to switch over to stdlib later. When/if you do switch to stdlib you should post again, I would love to see the kinds of patterns people have developed. I would be happy to share mine, but I don't have the time to write it out right now. Good luck!
Link is broken to documents can you repost the link. Then ping me
Nice, especially for conversions from strings. I was just about to file an issue requesting that Bool conversion from string should include yes, no, y, and n, when I discovered that the Bool converter uses strconv.ParseBool() and thus is bound to ParseBool's set of recognized input strings. Drat! :)
The "Check it out" link at the end of the article points to the old gover!
s/Drat/Yay/g :- ) Reasonable suggestion, thanks! [Allow yes/no boolean conversions as suggested on reddit](https://github.com/cstockton/go-conv/commit/5ed1e331c5e95491b1d13da58850a19a2e6150f4)
Yes, sorry. the link has parantheses which messed up the formatting. /u/strings__
That recomendation was for v2 storage. v3 storage is more memory efficient.
Hah, gotta hand it to integrating go test and go generate. Makes quick changes easy and regression free.
Read this first: https://www.consul.io/intro/vs/zookeeper.html Then I suggest looking into a different technology for your datastore as neither of those are a good fit for what you need. I'd choose Postgresql as it has a kv engine to but it can work with a json document just as well (even better than solutions like mongo for example).
The Go community believes that frameworks or ORMs abstract out lot of essential information or knowledge which a developer should understand and be responsible for the complete code of the application (read: evil) Simply put, libraries are the way to use 'go', which don't provide any magic like Rails like the naming patterns etc., There are many frameworks, but the bigger community does not encourage to start out that way.
I can't point to good examples, as even with my code the layout constantly evolves. Currently, I structure everything in one package, and this package *shouldn't* be 'main'. Within the package I structure things in files, based on their logical representation. For example, I'm currently writing a "crontab" like system, and I structured files like this: main.go app/job.go app/job_index.go app/job_run.go app/job_parser.go app/handlers.go app/handlers_api.go app/log.go app/log_save.go app/common/database.go app/common/respond.go app/common/sql.go The logic to my splitting this into three packages is the separation of concerns: main.go is the runtime, and only contains things that are important when you run the app (config, router setup, ...). The package 'app' has all application structures in logic. I keep structures in 'short' filenames, so "job.go" will only contain the `Job` struct (and related helper structs/interfaces). The code which works with this object is then inside `job_run.go`, and others. This is helpful when doing an overview or when searching for some code. The `app/common` package is self contained. By that I mean is that it contains absolutely *zero* application logic. It only uses standard or public (external) packages which are vendored in the app. This is a hard rule ('must') to avoid the diamond dependency problem. At some point I did structure the structs into a separate package, but since I always had to add logic to them, it quickly becomes tedious. Single-responsibility principles at work usually mean that in such cases some logic needs to be either duplicated (code smell/debt) or shared, which ultimately exposes you to dependency problems (circular/diamond dependency problem). So far, this way works for me, and whatever front-end (ReactJS in your case) I can set up in main.go, but I could potentially skip that and just serve these static assets in nginx (or whatever web server). I'm willing to discuss this further if you'd like. I write about Go things on my blog [scene-si.org](https://scene-si.org), I wrote a book on API/Go subject, and I'm a friendly person who welcomes DMs :D
At first glance it seems that converting to ints32 and lower could produce panics.
Think they meant gitlab.com (saas). Self hosted still has a cost. You either own hardware or pay a provider like Google or AWS.
?
What is the difference compared to https://github.com/spf13/cast ? ;-)
To help people understand your requirements, what does 'large cluster' mean to you? How many keys, how big are values, what are peak read and write rates? 
I really like Griesemer's prototype. It demonstrates two things: - It looks possible to have user-defined operators ([], +, -, *, etc.) without making the language too much complex. - If this is possible, Go could become a really great alternative to Python/numpy. Example (from the repo): a := NewMatrix(4, 5) a.Set( 4, 2, 7, 9, 1, 5, 0, 1, 8, 3, 5, 6, 3, 2, 1, 7, 9, 0, 1, 2, ) b := NewMatrix(5, 3) b.Set( 3, 4, 5, 0, 3, 1, 3, 2, 1, 8, 2, 6, 2, 7, 1, ) (a * b).Print() 
A lot... just read the repo readme.
https://github.com/AllenDang/w32/blob/master/dwmapi.go https://github.com/search?l=Go&amp;q=DWMWA&amp;type=Code&amp;utf8=%E2%9C%93
Foo is neither true nor false. To try to convert it into a bool should return an error. This package never returns errors, which means that you'll never know if you've run into an error case. Name: Bob How old are you, Bob? Smith Hello, Bob age 0. There's a reason the strconv functions return errors. To me, Bool ("1") returning true is extremely surprising. It feels like the package is trying to make Go work like javascript, which is exactly the opposite of what I want :)
Thanks
This just popped up today, might be useful for you if your data can fit in RAM: https://github.com/tidwall/summitdb
I've missed that part. Then I guess Cassandra will be a better choice. Anyway neither Consul or Etcd make any sense whatsoever for the scenario proposed but it's funny to see how many people would abuse them. 
I can't seem to get any output from it, ever. I'm feeding it results from gometalinter, using various linters, on a wide range of commits, e.g.: % gometalinter -j 2 --deadline 10m --vendored-linters --disable-all --enable golint --enable gosimple --enable vet --enable ineffassign --enable deadcode --enable vetshadow --enable staticcheck --enable gofmt --enable misspell --enable errcheck --enable unused --enable unconvert ./... |&amp; revgrep master~1000 I've also tried using single linters (through gometalinter and without it), and actual commit hashes. I've tried using `./...`, `./package/...`, and `./package`. No results ever. Unfortunately I can't share the repo for debugging.
Here is a running example of the suggested design on the playground: https://play.golang.org/p/-qDVnb0tW6 Please consider this alternative: https://play.golang.org/p/m-9GUyekop There are a number of advantages: * When embedding the "status" type into the "job" type, the status' mutex won't pollute the job's field names. * Separating the status check `isOn() bool` from the status update `setOn(bool)` is easier to read, and prevents the possibility that a user misuses the combined version `Take() bool`. * While not as fancy/impressive, simple names are easier to read. * Keeping the `on` field unexported forces users to interact with it via provided methods.
I wish AWS Lambda would work with Go binaries.
Hi! I'm using the StatefulLock from a separate package, so I'm required to have visible `Take` and `Release` functions, but in hindsight and your recommendation, `Locked` should be `locked`, true. Given a lot of JS background, keywords like 'on' are used in event emitter/receiver patterns, so it might cause confusion, and I tend to use 'is' for value comparison/validation (IsActive, IsValid, IsError, etc.). `GetLock` and `ReleaseLock` might be more appropriate. I'd avoid more generic `Get` just because it's likely that they would be implemented on the `Job` struct. Thanks for the playground links, I'll keep in mind to post them in the future!
Also, thank you for the insight from some other posts you've made. The benchmark comment on some other thread a few days ago regarding BSON/... made my todo list. I'm just looking for an opportunity to make some benchmarks. You're a blessing to the community! :)
Thank you! I hope it's part of everyone's purpose to grow and reinvest in the community. Keep pushing for well-being!
Love to get this as a GitHub issue, but: 1) Running that same gometalinter command, does it output issues when not running through revgrep (eg just running gometalinter)? 2) Does the following show a patch which contains a line of code that should error: git diff master~1000 3) Can you run the same command adding the following debug flag to revgrep: -d 4) Can you simplify the command to, for example, just golint |&amp; revgrep master~1000 5) I'm not familiar with master~1000 (if you're certain that's what you what, can you explain what the behaviour is compared to HEAD~1000), usually I just use, can you try that?: |&amp; revrep HEAD~1000
Yes, it would be nice with native support for Go on Lambda. For now we can use http://apex.run
Any reason you're not implementing Take and Release with a single line of [CompareAndSwap](https://golang.org/pkg/sync/atomic/#CompareAndSwapInt32)?
I'm looking at this on mobile and the layout makes it pretty unreadable. I'm using chrome on android.
SummitDB is pretty much [Finn](https://github.com/tidwall/finn) for Raft and [BuntDB](https://github.com/tidwall/buntdb) for the database. Both are embeddable. 
I've removed the mobile viewpoint so the text column should be wider. Is that any better? Otherwise you could try toggling "the view as desktop" option in chrome.
Thanks. I was more hoping that embeddability would be addressed more explicitly by the Summit documentation (or even an explicit API itself). I can see from the cmd main.go how to start the needed pieces though.
Re: map, if you have the expected map and the resulting map, you could just loop the first map (outer loop), and then loop the second map (inner loop) to ensure any value in one, is found in the other. No need to worry about order in that case.
That's a good point, this survey is perhaps better titled as "What, and where are you building with Go in the cloud?
[More on the new release here.](https://code.visualstudio.com/updates/v1_6)
I wish something like burntdb allowed separated process to be the readers vs writer. E.g. One process only writes and other processes read. Though I suppose I could modify one to do this.
Until I zoomed in, I genuinely thought it was a trash can.
Do you have video links of the talks?
Gaaawwhh, my eyes.
Halloween edition.
You are welcome!
Looks like they made all the white in the icon transparent instead of just the background. And then presumably tested it with a light-themed VS Code...
You can replace it with the one provided by third party extension: vscode-icons. https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons
That's much improved, thanks! There are obviously ways to work around these things but I suspect a lot of people would not bother.
Considering [Renee](http://2.bp.blogspot.com/-XXod7hwtHu8/UB3BZD9uZjI/AAAAAAAAFFc/X7wQlWx_K5k/s1600/babybjornstrand3.jpg) [French's](http://3.bp.blogspot.com/-KJBPZvUr_EU/UA38e_MYTiI/AAAAAAAAFAA/Qn9R43omx-I/s1600/bjornstranduw.jpg) [other](http://3.bp.blogspot.com/-aNVt3Ej8q7U/U-B3rs8hmJI/AAAAAAAAGVI/4l_AAxKh-5s/s1600/coastergophs.png) [artwork](http://4.bp.blogspot.com/-AHmR9HwMMzo/UiSO6jby3yI/AAAAAAAAF2I/IMhdRyoQkcc/s1600/bjornstrandbacks.jpg) I think an eyeless, soulless monster is appropriate.
Excellent, I am excited to see this working!
a lost, confused and powerful monster is appropriate with Renee French's guidelines. Also, I have the same face every time I re-read my old code
It haunts you. Those data races.
Technically it would still be two lines, CompareAndSwap(0,1) and (0,1) to release?
Your `StatefulLock` (try-lock, whachamacallit) isn't a lock. You have essentially implemented compare and swap, which is a processor instruction (exposed through sync/atomic). This is a processor instruction commonly used to *implement* locks due to its memory atomicity. Your implementation is done in an incredibly expensive fashion, *using* mutual exclusion locks that internally use compare and swap in spinlocks, potentially calling out to the scheduler. It would be much more efficient to use atomic.CompareAndSwap, which does exactly what you want here. For fun, I have implemented the (MUCH) faster, lockless atomic variant in a similar style as sync.Once: A `SemaphoreRunner` whose `Do` method only runs your function if `Do` isn't already executing: https://play.golang.org/p/65hsJqRvwZ ... I'd also like to add that, if you need this functionality, I suspect that is is due to some design flaws somewhere else in your application
The thing is, if you're interested in the state of the lock, not in acquiring it, then you're not looking for a mutual exclusion lock at all, but something entirely different. Also, feel free to just link to the book when people ask. It's not an advertisement if people ask for it. :)
The author spent a few months in Go. In the last 5 years I've quit Go a few times but always come back. 
If that works in Kotlin it makes me want to stay away. 
I extended my example with CompareAndSwap* here: https://play.golang.org/p/pRW39xrRp1 - I didn't go with a "runner" as I would have to declare a strict function interface, I'm returning values in real world code - Reduced everything into CanRun() bool and Done(). (previous take/release). Works like a charm.
I don't agree. The point of the example is to show that there isn't - and can't be - a clean equivalent in Go to "map" in Ruby/Kotlin/Swift etc. The fact that it's a poorly constructed example (because you can use a pointer to an existing function in the case where all you want to do is uppercase a string) doesn't invalidate the point. If you don't happen to have an existing function to hand, the lack of lambda expressions limits your options: write the function out in longhand elsewhere and supply a pointer to it, or write the full function expression, including its complete signature, inline.
Peccato che la comunità italiano è ancora un po' piccola. Per chiunque parla italiano, c'è il Google Groups ( https://groups.google.com/forum/#!forum/golangit ) e pure una meetup a Roma (http://www.meetup.com/it-IT/golangit/). Auguri Renato! ---- It is a pity that italian community is still small. For anyone who speaks italian, there is a Google Group and a meetup in Rome. 
Given this info, with sync.mutex I'd have landed at the exact same performance of compareandswap (but the second one is optimal/shorter, which is good :)). I don't have one lock for all jobs, but only one lock for one specific job. As the job runs at most 1/sec (in practice 1/min at the moment - crontab) there's absolutely no lock contention for my use case.
This was discussed by the Go team long ago, and there wasn't really a use case for it. The functionality you want has nothing to do with sync.Mutex, and won't share any functionality or internal state with it. As a separate item, this would then, internally, become the aforementioned 7 lines of code, with 2 lines actually doing something. See https://github.com/golang/go/issues/6123 for the original discussion.
No excuse me. You posted a blog dedicated to how you have moved from Go then back to Java based on failings you found in Go. Then when an actual Go user points out how your code is *clunky* you even agree by replying *Fair enough*, yet you still proceed off on yet another tangent saying how Java is still better than Go when you bring up *maps*. I would have thought your choices are simple. I you truly like Java (or some other language) and find it (or them) better than Go then obviously the choice is for you to just keep using Java. But for you to come to a Go forum complaining about a language you obviously have not taken the time to study and learn, then posting *clunky* code as some sort of proof is just plain fool hardy. 
I swear, a good 70% of peoples' complaints about Go boil down to "I don't want to have to write a loop".
From the OP's link: &gt; I would not, for example, want to use Go to write software which relied heavily on an “Actor”-based approach – you can do it, but it’s pretty clunky compared to the expressiveness offered to Akka by Scala’s case classes and pattern matching. Obviously the OP doesn't like the look and feel of Go. Actually I don't see any problem with that position, other than trying to claim one language is better than another. As I mentioned in one of my early replies in this thread, I have tried and hated using Java. Does that make Java bad. No. It just means I don't like it. It's pretty simple, just use whatever the language works best for you.
Hi, again. Must{n}() funcs are expected to panic on failure. There are good use cases for such explosive (implosive?) behavior, but this isn't one of them. I'm not sure what else "on" would mean, and it is the shortest choice, so I would use it until I saw confusion occurring. There is nothing wrong with an alternative if a longer name is acceptable for you (e.g. active, running, etc.). Apologies if I'm in error, but unless you demonstrate a race condition there, I feel confident that it's not racey. onMu is not truly redundant (mostly). If the "status" type is intended to be embedded into other types, and the other types contain embedded mutexes, there will be a collision. The collision can be resolved by setting the "status" type as a named field. Then were back to accessing the mutex with additional naming anyway. In either case, the collision must be avoided. The purpose of the types and how they relate to each other should guide the decision on this. For myself, I tend to not embed mutexes unless it is going to be free of confusion/collision.
&gt; While the rest of the world functionally As a 20+ year professional programmer, I will have to bow to you experience and assume you are correct, since in all that time I have never worked with a functional language. For me, in all that time I have only ever used procedural languages.
I see your point, some of the languages I am thinking about are Java, Ruby, Javascript, Groovy, Kotlin, Scala, Clojure, Swift, Python, C#, Rust etc. Anyway, maybe I was a bit abrupt, it's just that Go has it's pro's and con's in certain situations and they've been well highlighted pretty well by the author.
More like 50% lack of generics, 30% complaints about being forced to clean up empty imports, piecemeal for the rest.
&gt; My first programming language, back in 1984, was Logotron Logo. Functional language. Since then: BBC Basic, Inform 6, PLT Scheme, Visual Basic, C#, Python, Java, Prolog, Haskell, Javascript, Erlang, Mozart, Clojure, Go... I'm not sure, but I'm assuming somehow I should be impresses by this? Are you a *Jack of all trades, master of none*? &gt; If you've spent 20 years walled up in a procedural paradigm without ever once taking a peek outside, that's your lookout.You obviously have an opinion and that is fine. That is correct. In that 20 years I've stayed where the money is. To me programming is simple. It's a profession, not a religion.
&gt; If the question is, "should I use Go or Scala to implement this actor-based solution" The answer is just use which ever programming language works for you. There are plenty to choose from.
nice. It would be interesting to know which Go version (and toolchain?) was used for the benchmarks.
Yes. Go is focused on maintainability over flexibility. It feels like we get a blogpost for this every month now. I like jerking off to writing clever implementations and abstractions as much as any curious programmer, but I get more satisfaction out of getting work done with less surprises and less obstacles.
&gt; Go isn't good for everything. In fact Go might not be good for anything that you are doing. The reality is simple. See if it works for the problem at hand and if it works use it, otherwise drop it for something else that does work. Go is just a tool. And like any tool, you need to pick the right tool for the job.
Why are people interested in RPC? Do we just have young "smart" Google engineers that didn't learn from the past? http://bill-poole.blogspot.com/2008/03/rpc-is-bad.html?m=1
tl;dr &gt; ...even as I winced at some of the things Go was taking away from me, I wondered what it was optimising for instead. What if Go wasn’t a worse Java, but a better something else? I decided to stick with the language, and see what it might have to teach me about an area of the programming language design space I hadn’t explored before. &gt; As much as it has its detractors, Go also has many fans: people who love programming in it, who find it satisfyingly productive, who read their own Go code with pleasure and confidence. Let’s assume they’re not simply deluded. What is Go doing for these developers? &gt; The general principle [in Go] is to favour the transparent and ready-to-hand over the remote and opaque, the concrete and literal over the abstract and magical. It’s like speaking a language without metaphors. &gt; Returning to Java (and Kotlin) development after a couple of months of Go development, I found myself more willing to consider that the concrete and immediate expression of some piece of program logic might serve better than trying to pull out a more generic version of the same logic that might never be re-used in practice. I discovered the value of a certain sort of “plain speaking” in code. Also, a clarification I hadn't thought necessary: I work on multiple projects in multiple languages. "Returning to Java...development" does not mean "giving up on Go in disgust and running back to Java, my first love". It means finishing an engagement in which Go was the main language used, and starting one in which Java was the main language used. It's very likely that I'll use Go again in the not-too-distant future.
Hey all! Happy to answer questions about go-qemu on here or on #go-qemu on freenode. Also check out its sister project: [go-libvirt](https://github.com/digitalocean/go-libvirt), which is a library that can speak the libvirt RPC protocol, with no Cgo required. Hope this is useful for someone!
goimports takes *forever* for third-party libs. :( At least this is the case within vim-go.
"It works on my machine"
Very nice, I enjoyed. Thanks for the links at the conclusion. 
I'm baffled that so many people here interpreted this article as "Java is better than Go" rather than "Java and Go have different philosophies". It's like they read the title with the least charitable interpretation and stopped at that. I'm sorry for all of the defensive responses to your well-written, very reasonable article. Thanks, I enjoyed it and will share.
Odd. Must be a bottleneck in vim-go? I'm on a 2015 MBP with far fewer directories in my GOPATH and it can take 30 seconds or more.
When's the last time you updated? Brad Fitzpatrick made a bunch of speed improvements a few months ago.
Probably not since then. I'll update and give it another go.
Yes. Or even worse, you could change the *meaning* of a field without changing its type, in which case you would get more insidious errors. It's not a very safe package, and I don't recommend using it for anything unless you understand all the implications. It's more of a novelty.
No argument, just speaking towards those that seem to feel this are critical issues after having only tried Golang for 2 weeks. I find myself not missing generics and why the heck wouldn't a developer not WANT to clean up empty imports lol.
More like, "Go makes me actually write and think about what I code." Just because you have to write some extra code does that make it clunky? If people had some patience, over time, they would learn to leverage the language and be able to improve their code. At first, sure your code make suck or feel clunky, but that's part of learning. No one is going to know an entire language, it's features, libraries from the get go (pun wasn't intended).
Thanks for the detailed response! For the record, I didn't think the post was anti-go.
vim /s
I'll admit that I use the embedded struct quite often. Every time I refactor, I try to get it working with an interface, but the interface ends up being large and brittle. It also makes it very annoying to work with slices because you run into this problem: https://github.com/golang/go/wiki/InterfaceSlice In my code, I'll always have a `[]ConcreteType`, but to use that with anything wanting an interface, you have to write a manual conversion from `[]ConcreteType =&gt; []Interface`. Having to convert everywhere seems to defeat the entire purpose of the interface itself.
Thanks for taking the time to point out my error! I was clearly not taking on your use case properly and provided bad code. I'll play with it some more and only reply again if, after being more thorough, there is anything useful to share.
I should have been more clear. I wasn't objecting to nesting structs; I was commenting about your woes with large interfaces and conversions between slices.
I tried Atom and noped right out of it, right back to Sublime. I later tried vscode - following Francesc's guide - https://medium.com/google-cloud/go-tooling-in-action-eca6882ff3bc#.d7txk369e - and have stuck with it since. Code is noticeably slower than Sublime at times, but consistently faster than I've ever seen Atom. And, fwiw, the test coverage highlighting (once I saw it) was what really tempted me.
Sweet! Thank you for this!
Your suggestion is fantastic: https://play.golang.org/p/SKWbhOXh-r It works well, is fast, and resolves the concern about "Take". cc: /u/titpetric *I hope I didn't screw this one up as well...
Agreed. Full-time Go programmer here, disappointed to see such needless hostility from our ranks :(
Not huge values, but many many keys (millions)
No worries. I know something about race conditions from my time with c++, java, easy to miss. And as I said via other comments, I wouldn't be exposed to it with my use case, but other people with different use cases would. The scheduler which is dispatching jobs in my case can dispatch them 1/s at most. Even the race example is convoluted, because it's basically a loop anyway :) Tare care :)
Author here. Thanks for pointing this out. Indeed, the collision rate is an important aspect of the quality of a PRNG, and the quality of the output is what separates a cryptographically secure PRNG from other PRNG's. In general, CSPRNG's have to pass a couple of strict statistical tests to qualify for use in cryptography. I should have pointed this out in the article. Let me see if I can fit this in somewhere.
Ciao Renato, riusciresti a farne una versione epub o pdf? Saluti Franco
Embedding structs for function reuse is critical in a the code I write to avoid having to rewrite base functions for everything. I have thirty entities and all of them have X and Y values and I want to be able to set and shift their positions all the same way, so I use an embedded 'Point' struct. This article points out one example where struct embedding is a bad idea, but its example is also one of the incredibly impractical 'animal' examples, so I don't know how useful it is for a real use case comparison.
One option would be to use the underlying parse package directly. https://golang.org/pkg/text/template/parse/ `Parse` will give you back a set of Trees (usually only one if you call it right). That tree will have a single list node. If there are no actions, that list should have exactly one member, which will be a TextNode. Its an option. Are you reusing templates multiple times, or is it an on-demand type thing?. Have you benchmarked just doing the full template every time? What are your performance requirements? Regex is not exactly fast either, and I imagine executing a single text node would be pretty fast, with parsing being the biggest time sink, but also probably pretty quick compared to network for example. 
You don't need any external libraries for your project, everything is already in the go core packages. You will find the most examples for this packages and you will learn the most about go. Use [encoding/xml](https://golang.org/pkg/encoding/xml/) for xml parsing. All you have to do is define a struct for the response. You can use [net/http](https://golang.org/pkg/net/http/#example_Get) for the GET requests and parse the body into your struct. The [database/sql](https://golang.org/pkg/database/sql/) is all you will need to query the database and finally the time package for the [interval](https://gist.github.com/ryanfitz/4191392). Using libraries for this application would be overhead in my eyes.
I think the project is also going to need an [sql driver](https://github.com/go-sql-driver/mysql).
Bravo Renato, buona fortuna col tuo libro! :)
maybe a bottleneck in vim, try neovim or vim 8
Ciao Franco, al momento è disponibile solo su Amazon e GooglePlay come ebook, credo che GooglePlay ti permetta di leggere l'epub ma con una pratica un po' articolata, ti consiglio invece di scaricare una app di lettura gratuita, per Amazon c'è Kindle, per Google c'è Google Play Libri. Fra qualche giorno l'ebook sarà disponibile anche su Kobo e sto valutando di farne un'edizione cartacea con Amazon Createspace, ma con i progetti che ho in piedi al momento, potrebbero volerci un paio di mesi per impaginare come si deve testo ed esempi di codice. Ciao, Renato
Grazie Davmuz, spero proprio che la guida sia d'aiuto a tutti coloro che la leggeranno :-)
I use neovim, but have had the same problem with vim 7.3 in the past.
Honestly, after reading through the post, I think the biggest piece of constructive criticism I would offer to the OP by far would be to change the title. And I would further say that the only thing "wrong" with the title is simply the knee-jerk reaction it can inspire in the reader (I had the same reaction, until I read the article). The article itself was thoughtful and well written, and in the end I did not find it disparaging to Go's strengths and philosophy. I would summarize it as follows: the author initially didn't like Go's restrictions and lack of certain features he had grown accustomed to having in other languages. Despite that, he decided to keep an open mind and honestly evaluate it. In doing so, he not only found value there, he found that he could even improve his coding in Java (for example) by applying some of the principles he learned to value in Go. Really, I think being able to step back and let go of preconceived notions and entrenched personal preferences in the name of trying to find the good in something new and different seems like the height of intellectual honesty. I say well written!
Thanks! So the struct would be the data container - 1 struct for each DB record I assume? 
Thanks for this. 
The same arguments that apply to a cli or whatever, also apply to a web-app: If it panics, that means it has a bug and pretty much all distributed computing out there assumes, for correctness, that nodes stop if they have such a failure. So, you *should* crash on panic. That being said: If you do *really* want to do that, you'd need to wrap every go statement in a function, which calls `defer func() { recover() }` and then continues with the argument to go. You're unlikely to be able to actually do that, because you depend on other people's go-code and they might use goroutines themselves, but it's the only way. So yes. The correct way, to deal with this, is to make your infrastructure resiliant against such sudden failures. For a simple webapp, using systemd or something to restart on failures might be sufficient. Doing it reliably for larger stuff is why companies spend big money on teams that take care of it. Because it's not easy.
Which makes Kelsey Hightower just as wrong ;)
Docker is not a security feature. Don't use it as such. There is a reason why you can't simply run a docker-container with any major cloud provider (and instead need to provision machines that will then get scheduled by something like Kubernetes). Which is that *docker is not secure*.
GoLang is much more practical. 
It depends very much on how you use C or C++. Some of it's uses (e.g. kernel or game development or other software that needs near realtime performance) are not well-covered by go, other use cases are very, very well covered by go (such as all kind of networked software). If you'd see how Google uses C++ (outside of, say, chrome), you'd see where the "go is supposed to replace C++" comes from. Google-C++ is essentially go-light.
My company's solution is to wrap everything in calls that will log and recover from panics without crashing the app: func CallWithPanicProtection(f func(), prefix string, shouldTerminate bool) { defer func() { const howFarBack int = 10 if recovered := recover(); recovered != nil { l4g.Info("CallWithPanicProtection panic recovery: %s\r\n", recovered) message := fmt.Sprintf("Run-time panic in %s: %v", prefix, recovered) LogStack(howFarBack, LOG_LEVEL_CRITICAL, message) // Log this report with Sentry reports.ReportsInterface.CapturePanic(message, recovered, nil) if shouldTerminate { // Give the log4go log time to flush time.Sleep(time.Second * 3) // Re-panic if this is a high-level enough problem panic(recovered) } } }() f() }
No. This is meta information. This is the reason tags, hashtags, keywords and the HTML`meta` tag exist. Unsurprisingly so, at the top of the article there's already #golang and if you check the HTML code you can easily see that there's already a golang keyword among others. In fact even if the content of the article contained none of the words Go or GoLang, you'd be able to find it just fine.
&gt; wrap everything That's overkill. Identify which functions can potentially panic and wrap (or defer recover) those.
That is accurate if you are describing a 1995 search engine like Alta Vista. 
There are panics in the go standard library
&gt; Parse will give you back a set of Trees (usually only one if you call it right). That tree will have a single list node. If there are no actions, that list should have exactly one member, which will be a TextNode. Thanks. Very clean and elegant ! t := template.Must(template.New("line").Parse(templateStr)) fmt.Println(len(t.Tree.Root.Nodes)) I don't want to do template execute every time unnecessarily because this is in the hot path of my application. No, I haven't benchmarked it. This is a personal project of mine that I have just started. So focusing on creating the basic features now. But definitely will benchmark once I reach a stable version. Thanks for the help ! 
Nicely put. The crux of the matter is to choose the correct language for the right job. As you rightly mentioned, golang fits very nicely for all kinds of backend networking related stuff. In my previous company(a CDN), we used C++ for everything - web server, proxy cache, image processing, log processing. Because the founders knew C++ and didn't want to try out a new language. While that makes sense, there was a new project which could have easily used Go. But hey, no one listens to the junior engineer right ?! Anyways, I digress. So yea, Go may not be a "systems programming" language, but it can definitely replace C++ in a lot of scenarios. 
&gt; And, I mean, it IS wrong. A lot of people use the term "golang", therefore I'd like to introduce you to the Merriam-Webster Twitter account as to what constitutes "wrong" in language (i.e: if you're finding yourself constantly telling people some use of a word is wrong, you're wrong). &gt; Yes, I know that I'm a pedant, but it's just so silly to me. Why don't we all start saying JavaLang and CLang and RubyLang while we're at it? If suddenly a lot of people start saying that (with C it would be an improvement, really) then sure, go ahead.
Spot one billion differences between a programming language and a person.
Lighten up, it was a joke.
The article brings up many good points but there really isn't a catch-all solution out there and so tying the research to Go as the solution doesn't make sense. Every need has its own solution. * A language with a VM allows for more lenient performance concerns as a VM can often outperform a compiled executable due to optimization strategies that target the running hardware. * Software with unpredictable memory usage patterns may need managed memory instead of garbage collection, and the language should provide safe ways to manage the memory. * Parallelizable computations will run better on GPUs. * For extreme performance requirements, ASIC will outperform general purpose processing units. * Rapid user-facing application development often benefits from a language with faster edit/run loops, even if it executes slower by orders of magnitude (we perceive 60Hz as smooth). * If dealing with data flow between concurrently running processes with shared memory, the chosen language should allow that to be expressed safely. * The software may have to run on a very wide range of hardware. * Sometimes the tooling around it is a more important factor than the other features of the language you choose. There's arguments to use a lot of different languages, including C, JavaScript, Rust, Assembly, PHP, Python, and of course Go as well.
That's horrible. 
In the case of a web app / http api you want to return an error to your user (but let them continue to interact) and log the information for your debugging. I use [this](https://github.com/kpurdon/http/blob/master/recovery/main.go) middleware to do that for my go apis.
someone else pointed out this too and I have to agree that it didn't came out as intended. I'm not saying that Go is functional, just that it should be embraced "as it is" without trying to force OOP into it
If you think it's that "funny", why pile on? And why not at least do it on-thread, so it's hidden due to negative votes by default?
I'd just like to interject for a moment. What you’re referring to as Go, is in fact, Go/Lang.
It is also accurate if you are describing a 2016 search engine like Google. Semantic markup is honored and encouraged, because it makes search that much more powerful.
Okay but to your point the group of people calling go golang are the creators so much in fact that the main page of where you go to get go is called golang.org . So if the creators didn't intend for it to be known as golang ever why use it as a name for their own site hosting the code and documentation . 
Cool! Good article all the same, thanks for writing it.
Because a string is, essentially, a struct that holds a pointer and a length. This is necessarily so, so that the compiler knows the size of a `string` at compile time (e.g. when passed as arguments) and it makes slicing more efficient, because two slices can share memory, but have differing lengths. Assigning anything to it, overwrites that struct, but it won't mutate the memory that string is pointing to. That is, what is meant when we say "strings are immutable". When you look at `&amp;a`, you are taking the address of that struct. You can also unpack the address of the [underlying memory](https://play.golang.org/p/U8kIn3Xn4y) to see how this is working. A different way to look at it, is that `a` is not a `string`, but a `string` *variable*. By doing `a := "hello"` you are saying "declare a variable with name `a` of type `string` and store the string `"hello"` in it". The string remains immutable, but the variable is mutable (or indeed… variable :) which is why they are called that). Contrast that with `[]byte`. You can store a `[]byte` in a variable, but you can not only reassign the variable, you can also change the memory that `[]byte` points at (and thus also influence all the variables that have the same `[]byte` stored in it), so to speak.
https://groups.google.com/forum/m/#!topic/golang-nuts/EXvylZB6ILk Tl;dr string variables are mutable, but string *values* (I.e. The array backing the string) is immutable
Creating a string directly from a byte slice and then expecting the string to be modified along with the modified bytes is not allowed. Example of an invalid program: https://play.golang.org/p/UIu3bgD7Z4 Currently (built with a 1.7 compiler) this prints "0 100", however this behavior is not guaranteed. The compiler could determine that because the same byte from the same string is printed each time, and the string is not allowed to change, a temporary could be saved to the stack so the value only needs to be read once. Then the program would print "0 0". This is a very common optimization in C and C++ compilers when the const qualifier is used, and I'm a bit surprised that Go isn't already taking advantage of the immutableness of strings to do the same. Needless to say, you should not rely on this behavior at all. It may lead to changes in your program's observable behavior, or even undefined behavior (yes, in the C++ sense of the term), in a future release of the compiler.
Its just not that. The values of the template are going to be dynamically populated. So if there is no template action, those values will be redundantly created. edit: and the execute code does a state.walk which has considerable code.
Agreed.
Would this be similar then to nats.io and its ability to start a server embedded from the library in your code? If so, where does petrel diverge from the features of nats.io? 
[Bike Shedding](https://en.wikipedia.org/wiki/Law_of_triviality)
&gt;I am unfamiliar with nats.io, but from a brief reading of their documentation, their server is standalone: It can run as a standalone daemon, but it is also a library. I am currently using it in a project where the server is embedded into the app to easily host client connections. &gt;&gt; The executable name for the NATS server is gnatsd, which stands for Go NATS Deamon. Yea that is what the cmd that is produced is called. &gt;So it wouldn't seem, at a glance, that nats and petrel are similar in that regard. In general, nats looks much more like a contemporary of other zeromq and rabbitmq. &gt;I don't have the expertise (or the time to gain the expertise) to write something which promises to handle tens of thousands of transactions per second. Petrel started as a very small project, to scratch an itch. It proved surprisingly capable, so I expanded its scope a little bit, and tried to get the quality to a place I was happy with. I think it's useful, and I hope others may as well, but I've never viewed it as competing with anything -- especially large projects from corporate teams :) Totally a fair statement. My question was really just asking if you knew about how your newly announced solutions compares with others. I figured if you are announcing a new solution for people to use, that you might be able to give a high level comparison in that announcement to the existing options. Otherwise I would need to invest time to dive into every option that is announced just to see what it does compared to others. You being in the head space of this problem might have already known. No worries. Just had to ask if you had looked around and could give that high level explanation. 
I think linking to the README would be preferable than linking to the release page. That aside, this looks really really nice! Will probably try and use it a bit this weekend :) Thanks for sharing!
I have no idea how to use this tool. Does it support vim?
How does it differs from xdebug? Does it supports vim?
Well, no, good grief. When I said we wrap everything, I meant we wrap main and the top-level function in any new goroutine. Everything is wrapped, but we don't do it for every single call.
`42` is immutable too. https://play.golang.org/p/USGq-LOjtK package main import "fmt" func main() { a := 42 fmt.Println(&amp;a) a = a + 13 fmt.Println(&amp;a) a = 7 fmt.Println(&amp;a) } Yet the variable stays in the same memory location, the same way: 0x1040e0f8 0x1040e0f8 0x1040e0f8 
&gt; Your biggest problem is that you don't understand what a pointer is. *No.* I have dozens of years experience in C and kernel programming. I do, in fact, know what a pointer is. But I was just as confused about the output as the OP. &gt; pointer is just an address, it has nothing to do with the value of a variable or how it is stored. That is correct, but meaningless in this context. It turns out that the variable `a` does NOT point to the string, but to an intermediate structure that eventually points to the string. The extra level of indirection is *specific to Go*, so people can be familiar with pointers but still not be magically know why this program does what it does. &gt; I would study this at first place if I were you. I downvoted your post for being wrong and coming across as condescending. This problem had *nothing* to do with understanding pointers. (P.S. We would say the above phrase as "I would study this first, if I were you". The phrase "First Place" is mostly used for winning a competition, although sometimes it can be used like this: "You should have known that in the first place".)
Awesome, that was crystal clear, thank you! :)
Can you give an example? i.e. How would this differ from directory navigation? Anything quicker would be great
You should be able to wrap your request handler s in middleware that can recover from a panic and log (or otherwise handle) it. That way your whole server doesn't crash, you get information on the crash, and don't have to litter you code with recovery concerns.
what are you using for layer 3-5 ddos protection? just curious 
Hey, thanks for the feedback. I addressed the bit about websockets [in this comment](https://www.reddit.com/r/golang/comments/57fcp4/petrel_its_like_websockets_minus_the_web/d8stol1) but I'd like to emphasize that I haven't said that *anything* is "wrong". Deciding that something isn't the best solution for my use case does not mean that it has intrinsic faults, or that it isn't the best solution for another use case. Utility is not a zero-sum game :) I think that a lot of the rest of your questions stem from my use of websockets as a comparison, but to briefly answer them anyway: * Petrel is a general-purpose networking library, which definitely handles raw bytes and (depending on configuration) will pass request payloads to handler functions entirely unmodified. * The minimum request payload size is zero bytes, but there is a 4 byte length header. If HMAC is enabled, the MAC is the 32 bytes between the length and the remainder of the request. The maximum request length is set via configuration, defaulting to "no limit" (which is really the max value that will fit in the length header, an int32, so 4GB). * Petrel does automatically route requests to their handlers. This routing key is the first series of non-space runes following the header(s). The payload is everything following whatever whitespace comes after the routing key (or "command", as it is referred to in the docs). There must be at least one space between the command and payload. * As a result of this, while petrel is pretty minimal on the wire, it is not maximally compact. If you're watching every byte, you probably want a fully-packed protocol. * That said, petrel doesn't care if the payload is a ProtoBuf, or JSON, or packed decimal, or EBCDIC, or... * There is no built-in data handling/processing/munging of any sort. If you ship JSON over the wire, your registered functions need to know that it's JSON. They will be handed the exact payload bytes which came over the wire. My apologies, but I can't give you the sort of comparison you ask for at the end of your comment, as I haven't used any of those tools. I will be coming up with a better explanation of petrel's design and uses though.
Thanks. I'm using https://github.com/joonty/vdebug as xdebug client for vim. Hopefully vdebug will support dontbug soon.
I bet you could also get away with something like a combination of `NewInt(...)` and `Lsh(64).Or(...)`, which may be faster than the decode cost, but I haven't tested it, and you may not care about the performance implications (or you don't need this at all and you're just curious :P).
If that is the case then you can use vim+vdebug with Dontbug today. As long as Xdebug is supported, which is true in your case, Dontbug is supported
I appreciate the detailed reply! 
I've resorted to regex before (shudders)
&gt; occupy 1 byte per character, Err, that's not the case assuming by character you mean a "visual character".
You'll need to convert the input data to utf-8 before playing with it. I've had good success with Roger Peppe's charset package: https://godoc.org/github.com/rogpeppe/go-charset/charset My data provider guarantees that input is in ISO-8859-1, however I've caught them multiple times where they've copy/pasted utf-8 into an 8859-encoded XML. Somehow their tools don't catch such bugs and Go is stricter and better at it. Looking at you, Environment Canada :)
I'm just a go beginner, but they have different uses, don't they? ShuffleA affects all data structures pointing at slice, while ShuffleB doesn't (assuming it just shuffles the contents of the array). I don't remember having seen this mentioned in the context of naming, though.
well A and B only affect slices of that particular type, the only real difference between them is that one destroys the original slice by modifying it; while the other returns a new slice, leaving the original untouched
No idea. The European conferences tend to draw people from more countries just due to the fact that Europe has more of them. Perhaps here "International" means "English" instead of "Italian"? Maybe it's all just marketing. :)
Hashicorp's raft package is pure Go.
Glad you had fun and wrote something to help you get familiar with Go. A project is always a great way to learn a new language. That said, you couldn't go through the tour? It is not some academic course; I think I went through it originally in like an hour or something trivial. It is just a tour and gives you an idea of some basics for interaction with Go. *Shrug*
I've used this for creating some tools as well, I like it, it just works. I do wish it had some common widgets, but perhaps I should just built them for it. 
You really shouldn't be experiencing panics. If you are, you should look into your coding style and ensure you are following best practices.
I really really want to use gopherjs. I hope the package size gets smaller. It's just far too big right now to consider using. I realize it's a project made for fun, but I'd love for it to be production worthy one day. 
I did not go through the entirety of the tour. But I did go through the basics. I found that without a context to apply all the concepts, I just forgot them after a while. So after the first couple of sections, I went to work on my project. I visited the remainder of the tour through google searches etc. as I looked for solutions.
I agree to some extent. For public facing apps the size is a blocker. For internal "admin type" apps it should be fine and a good choice. The main guy behind gopherjs is brilliant, though (look at how he solved Goroutines!), and I'm very hopeful that he will get some effective dead code elimination in place.
Even though it will make deployment a bit harder and might lead to version problems, I honestly believe the right way to go is to compile std-lib packages separately or something like that, so they can be served via a CDN and only need to be loaded once. The issue with size is, that a lot of the code is *not* dead. For example, the fmt package is traditionally enormous, because of all the unicode tables and stuff. And you can't really get rid of them, because they are actually used.
Slices are reference types, kind of like hidden pointers. You don't need a pointer to a slice to be able to modify it within a function.
Out of curiosity, how DID he solve goroutines and channels?
Richard Musiol (neelance) should explain that, but you can start at the bottom here: https://github.com/gopherjs/gopherjs/issues/15
If you're only shuffling, and not changing the length of the slice or replacing it with a slice allocated elsewhere in memory, there is no reason to pass a pointer to the slice. Slices are just (data, length, capacity) tuples (in some order). If you modify the values it points to, the "original" slice (which is an exact, shallow copy of the original) would be modified. For example: function Shuffle(slice []Card) { for i := range slice { j := rand.Intn(len(slice) - i) + i slice[i], slice[j] = slice[j], slice[i] } } will work as expected and modify the passed-in slice. Pointers to maps, slices, and interfaces aren't used much (although for example if you want to modify the length of a passed in slice, you would need to pass a pointer to it). I would say that usually, if the function is simple, such as shuffling, it doesn't really matter what you do. If someone doesn't want their slice modified, they can just copy it before calling. If the function is complicated, and, for example, also returns some other value, then it is probably undesirable to modify the arguments if it would be surprising.
How is the cost benefit only for large scale? 
Just configure your init system to restart the service if it exists. This is a solved problem, don't reinvent the wheel.
From what I've understood last time it was more of a local (Italian only) and this time they want to go international. But I may be wrong.
You _do_ need a pointer if you add or remove items
Then create a pure go implementation of MPI.
Thanks! I will look into using WMI. 
For small services it's fairly trivial to write a RESTful API, and very easy to write a client to consumer them. To do the same in gRPC you must write and compile a protobuf file, for both the server and client. You can't just give a client the URL of your service. This requires far more coordination. If you're large, it's worth it. Faster and more efficient services can save lots of money. But for a small business or one man operation it's less likely to be worth the hassle.
I tried to load a Gopher.js app on my iPhone the other day and the tab crashed. Memory isn't just a download size issue: it also affects how much RAM the target device needs. 
&gt;That is correct, but meaningless in this context. It turns out that the variable `a` does NOT point to the string, but to an intermediate structure that eventually points to the string. The extra level of indirection is *specific to Go*, so people can be familiar with pointers but still not be magically know why this program does what it does. I'm not sure it's useful to think of the variable itself as pointing to something. The variable *holds* a structure which is the string value itself, which *points to* the character data. There's one level of indirection, which is the same as in most variable length string representations (aside from short string optimizations and such). `const char*` in C has the same amount of indirection, and the same mutability characteristics. You can reassign the `string` variable as much as you want, you just can't mutate the character data pointed to by a particular string value. And reassigning the variable doesn't change its address, which is what the OP was observing. The important thing to remember with Go is that there's nothing like C++ references going on. While we can call strings a reference type, they aren't implicitly dereferenced. The reference itself is a first class value, so taking the address of the string takes the address of the reference and not of the backing data.
I understand that is alienating and it is unfortunate that it turns people away, but it is a natural attitude to develop in a field where making a mistake can cost people lots of pride and money at best and their lives at worst. Cryptography is not something you learn just by doing in the way that a lot of development can be learned. The victory conditions are very different. There are no guides on how to "do" it and there's no way to tell if it is "working". When people look for information like this, that's when cryptographers react with "No. Stop going in this direction." Traditional intro to cryptography curriculums look something like this: 1. Learn about a crypto concept used in the past 2. Break it 3. Understand why it was vulnerable 4. Come up with a solution to the vulnerability 5. Learn and compare against the solution used in real life 6. Repeat onward through history You can find course content and research papers from respectable universities online, and white papers from real life projects (such as the primitives you want to learn about, from the teams that developed them) to learn deeper. And if you're seriously interested in being a cryptographer, you need to surround yourself with cryptographers. Get an apprenticeship, go to grad school and find a fitting advisor, etc. If you plan to _touch_ a crypto primitive (e.g. AES, bcrypt) in a project available to the public you need to understand that shit at every angle known to man. If you're curious still, I recommend starting with Avi Kak's lecture content offered online from Purdue University. It's a great introduction to the math and history of cryptography if you are starting from zero. Edit: mobile typo Edit: Also for reference, libsodium and its bindings are pretty much the industry standard higher-level toolkit.
The official Go blog says “It's a powerful tool that should be used with care and avoided unless strictly necessary." https://blog.golang.org/laws-of-reflection
&gt; Whenever they look for guidance, they're always told "crypto is for real developers, now go play outside kids." Myself included. Here's the thing: crypto isn't for developers or software engineers *at all*. It's for security engineers and academic cryptographers, the vast majority of whom won't actually be implementing crypto, and certainly not from scratch. I'm not a security engineer (though I am gong back to school with that intention), but a couple good resources are the [Matasano challenges](https://cryptopals.com/) and [Over the Wire](http://overthewire.org/wargames/). If you really want to "play with crypto" I would strongly suggest attempting to break something rather than attempting to build something.
If you want to learn on your own time here's a few youtube playlists that teach crypto at a university level: 1. [Computer - Cryptography and Network Security](https://www.youtube.com/playlist?list=PL71FE85723FD414D7) 2. [Introduction to Cryptography by Christof Paar](https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg/videos) Christof Paar also has a [book](http://www.crypto-textbook.com/) that you can purchase that is aimed at university students wanting to learn cryptography. 
The last I heard about an audit was from a talk by Brad Fitzpatrick where he said there hasn't been one (I'll have to hunt down the link) . But most of the crypto libraries were written/reviewed by [Adam Langley](https://www.imperialviolet.org/) who is a security engineer for Google so there's that if it comforts you any :) EDIT: link of Brad's talk https://youtu.be/rHBbqjWCGq8?t=3346
The package is now available on MELPA :)
I think a Go crypto guide will be great. Java has something similar: https://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html
Is this true? Go doesnt return memory? Are you sure you know what you are talking about here?
Err. ... yeah. I don't remember saying any of those things in my talk :/ https://go-talks.appspot.com/github.com/dgryski/talks/dotgo-2016/slices.slide#1 (Script in presenter notes -- press `N`)
&gt; https://www.reddit.com/r/programming/comments/3dvzsl/why_you_should_never_ever_ever_use_mongodb/ This has been busted several times also. Make your own conclusions do not take some other folks rants for granted. 
The whole point of a union though is that the properties overlap in memory, leading to memory savings and unsafe code :-D
Its better to stress that *all* talks, hosting, presentations, lightning talks, etc will be in *fluent English*. Having non-Italian sounding names as speakers helps as well... (or better, known international names, like DotGo has - was there last week) Even if that would be the case (?!) I am very hesitant to go there. Because Italy has a bit of 'native speak' ring to it. I like Italy very, very much. I have very fond memories of Florence as well but those are very far fetched from something tech... Cannot image the city of Florence being big enough to have some kind of international tech scene ? Please elaborate to convince me :-) 
How do you do versioning without a Makefile or script?
&gt; The first thing that should trigger a "huh, I need to look a bit more into this" reaction is: there is a single contributor to it. And it was always a single contributor. The author of the project actively rejects PRs and the occasional accident when a PR gets merged that contribution will be obliterated any time soon after, when the author decides to flatten the history of the repository (again). Which helps deliver the next point, API stability. But before that, I'll briefly mention that the issues that are opened on Github are almost always edited to reflect a different reality, comments get deleted and conversations get locked. It happened to me (I admit that I could have done better in the initial message but I couldn't change things as my issue was instantly locked by the author and I couldn't do anything about it anymore). https://github.com/kataras/iris/pulls?q=is%3Apr+is%3Aclosed ? I'm new to this whole controversy, but some of these complaints strike me as a tad harsh. There also appear to be a lot of licenses in the license file. __Edit.__ this brings up an interesting question: does one have to manually include licenses in a project that pulls dependencies via `go get`? Wouldn't the individual building the binary have access to the licenses anyways?
&gt; and unsafe code Not in Rust, FWIW.
My solution is to use fat structs instead: https://play.golang.org/p/HtGt1FW2sS type Union struct { Type UnionType Foo int Bar string Baz Baz } The struct may be fat, but it's still a lot better than incurring an extra alloc for each of instance (and you still have the option to heap allocate and pass around pointers if you like).
It's expressly mentioned in the article that he copy pasted code from the other library plus renamed functions, and also stripped license requirements (Attribution, in this case). 
Can swagger be used to go the opposite direction? Generating the swagger API website from annotations that I place in go code? 
It all adds up. The guy rips other people's code, doesn't attribute, squashes pull requests _after_ skimming the code from them, and then has the cajones to then take donations from unsuspecting people. It's a series of red flags that point to a bad citizen in open source. It is not the type of thing we should be encouraging. 
I really appreciate your thorough response. Although, I think we might be talking about two very different things. I'm not really talking about learning the art of cryptography itself, I don't plan on attempting to implement chacha or bcrypt "for fun." Much less making anything like that public. Like the video that OP posted, I'm more interested in the cryptographic "building blocks" that I can and should use in my every day work. Anecdotally: 3 or 4 years ago, I would have asked "how do I hash passwords?" And I would get an answer like "don't hash your own passwords, it's incredibly difficult to write a secure hashing algorithm." True... but the answer I needed was "a good place to start would be to use bcrypt, but you may want to consider these alternatives and here's a link to a blog post that says when you want to use this over that." I myself am guilty of reading far too deeply into beginner questions. If someone were to ask me how a webpage works, I would more than likely start by trying to explain how DNS works instead of telling them that there's a computer in a warehouse that's just waiting for your browser to ask for the webpage, and then it responds with something called HTML. The point I'm trying to get to is that I hope that security professionals will start to think more about providing accessible advice and "good enough" defaults to get us headed in a better direction. Projects like Let's Encrypt and Caddy server are great examples of how we can democratize secure practices. It's not perfect, but it's better than nothing. 
From my perspective/opinion, yes and probably. To learn more about 2, try to see the talk that Elias Naur gave about `gomobile` and the direction it's heading in at dotGo 2016.
Those are called cryptography primitives. A library that allows to access them (e.g. a function called bcrypt()) is still too low level for a security expert to recommend. Even if someone told a user to hash with bcrypt, how would that user know what parameters to choose? Would they know to salt the password? Would they know how much salt to provide? Would they know how to generate the random numbers? That's why there exist very high level toolkits such as sodium, or gorilla's session store, which have functions like GenerateSecureKey(). If you plan to go any deeper than GenerateSecureKey() or EncryptAndSign() then all of what I said above applies.
Nice solution 
What's the distributed story here? It looks like rest+web interface on top of Bolt. Also, if the goal is speed, you may benefit greatly from using this instead of Bolt: https://github.com/syndtr/goleveldb
&gt; It looks like rest+web interface on top of Bolt. **Nothing more, nothing less.** I just needed something like this for handling another project's configurations and I thought that it might have been handy for someone else. Do you have any suggestions on what else could be useful to have?
I remember when I first saw the project I immediately starred it just because it was written in Go (a language I like, and want to see more projects use), I didn't consider any other factors. Much later, after I saw the drama, I realized I should go and unstar it. But I'm sure many people never showed that initiative.
Thanks for u comment. Sometimes we wanna generate a XLSX file without .Net or Java applications, accroding to assessment some popular open-source library, I can't find out one library that support save charts after write an exists XLSX. Some times these library will lost some colors or style of Excel, so I decided to solve this problem and create a library support read and write XLSX with charts. Note that the Excelize doesn't support creat chart.
Some time ago I merged PR with removing Iris from awesome-go (https://github.com/avelino/awesome-go/pull/1135). But he want to re-add it, and see what happenned.
pretty sure we need. also I've just published some news about it.
The existence of _etcd_ is the main reason behind the development of Gerph: I needed some of _etcd_'s features but did not want to roll the entire package. IMO making a clone of it would not benefit the community - I see no purpose in replicating an estabilished product as an homegrown project, if not for learning purposes only.
Have a look at https://github.com/go-swagger/go-swagger One of the examples is how to do what you need, if I understand you correctly. Hope it helps.
I do not think we need to add 20 license files, just refer to it, I have done it in my project an android app based on a FOSS app: https://github.com/thewhitetulip/hashtag-notes/blob/master/README.md#hashtag-notes a book: https://github.com/thewhitetulip/web-dev-golang-anti-textbook/blob/master/README.md#note Always attribute things you took from others!! Not doing it defeats the purpose of FOSS, FOSS was founded on this reason that we can build things on top on what others have built without IP issues, free as in freedom.
Nice post. Have you seen Go 1.7's subtests? They are great for improving the output of table tests https://blog.golang.org/subtests
&gt; Adding 20 license files to a project is a bit ridiculous, If you include code whose license requires giving attribution, you should do it. &gt; no one looks through licenses to find dependency information. Agreed. That's not the purpose of a license file.
Or one can just copy paste all the licenses in one file, or at least link to the author attributing their work
&gt; If you include code whose license requires giving attribution, you should do it. You already are including it by using that dependency. It is not legally required to include it in any other way, nor is it even recommended. Nobody wants to see a project bloated with license files. If there is no license reference in the dependency then you can simply put all of the license headers in a single license file. 
I have done the same, but I found my state machine version using the scanner in Go is many times faster than the regex. 
sometimes it is nice to have an option that is not as strict. For me installing 3rd party software is very difficult where I work. The charset was not an option.
I'm actually not afraid of the backlash since all the backlashing seems to be just fury and then self-deleting comments. But thank you for your concern. It also happens to be the truth as I see it based on all the evidence there are in the public (I'm not advocating that I hold the universal truth). First time the author may have had an excuse, poor English, being new to programming, etc. Now it seems he's doing it all over again and I've seen far too many people tricked by the fact that it has stars on Github. It's the only reason I've published that, to make people aware of it and I hope people will understand that. It's sad this has to leave a stain on the community and frankly it's a pity that all that time invested in creating iris is thrown away by all these issues.
&gt; It is not legally required to include it in any other way [than implicitly via `go get`] Ok, if this is true, then I am fine with it.
&gt; It's 100% stdlib compliant, every other router I've seen is not (or has stdlib compliancy hacked into it) What about https://github.com/gorilla/mux ? Seems just as compliant (takes http.Handler, exposes an http.Handler, just as chi)
That's what we in the industry call "a dick move"
thanks very much @thesilentwitness :) - I always suggest if you're deciding on some underlying tech for a project, first look at the api, then second read the source to see if you can understand it and how well it's put together. 
_Compression saves bandwidth. What a surprise._
Sounds like it would be better to use HTTP/2 (which provides most of the features and then some) or QUIC (which provides all and then some)?
I didn't know about the Iris situation. Based on the Iris situation I've read yesterday and today I likely wouldn't use it. Both of the threads informed me, at the very least. Likely others too. So no, I hope people don't stop talking about it, I hope that when someone is asking about "which framework to use", someone pops up and says "I just joined yesterday but don't use Iris". For that matter, Iris author frankly doesn't seem to be a troll. Just awfully misguided in his practices. I understand that it might be a mild inconvenience for someone who spends their entire time immersed in the language community, but hey, you are the vast minority. The rest of us would really have no way to find out if it weren't for things such as this.
I personally agree with you, but I'm not going to hold a grudge against people who don't. They are under no obligation. They are following the law in regard to the license I have provided in my open source projects. If I cared, I wouldn't have licensed it in such a way, or I wouldn't have made it open source.
It's surely better. Regex is for when you don't have time or care enough to build a proper parser/state machine.
Summary: use your static html Hugo blog to host your vanity import URLs. Note: for the stuff about using an alias template for subpackages, you need the latest master of Hugo, it didn't make it into the latest 0.17 release.
It's not builtin to the language, it's just a struct TaggedUnion { UnionTypeEnum tag UnionType value }; (apologies if the syntax is wrong, it's been a while since I've written C).
Any link to the Elias Naur talk? I've been trying to find it but cannot.
Could also call it copyright infringement I think. 
There was also this interesting article: http://parellagram.com/posts/carving
So you didn't read the article. Okay, thanks for letting us know.
&gt; The behavior of go get is documented though, so it should be obvious to users that care. Absolutely. I was more thinking about possible legal obligations. Specifically, if a third-party license says something like, "if you distribute code based on this code, then you must include this license file", and you push your code to GitHub, Gitlab, Bitbucket etc, would you then be required to add a copy of this file to your project, despite the fact that the original can be found *somewhere* if the user cares enough to try and find it? Me, I'd rather be on the safe side and copy the license file over. Yes, I might be overly cautious about this point, but I can live with that :) &gt; I feel like it's unreasonable to release software under a license that does not require attribution while still expecting it. I completely agree. I was not referring to any particular license though, as this sub-thread spawned from a rather general question on licensing. Apologies, I should have made this clear from the start. 
There are two "de facto" widely accepted Go web stacks. One is the standard library's net/http, the other is httprouter. Similarly to how sqlx is widely known to be a good extension to database/sql, the Gorilla toolkit extends upon net/http. As for httprouter, there's things like labstack/echo and gin that extend upon the first to cover some common situations that you might or might not face in the particular project you're working on; but if you are facing those situations, you would've had to roll your own solution anyway. Now you could say "why two stacks". Well net/http supports a lot of features that are commonplace and often expected across the industry, while httprouter sacrifices some of them to squeeze some extra performance in case you don't need them. If you have such a hard time reading a couple of project pages to understand why they exist, then just go to net/http and if you need something on top, Gorilla.
Granted I'm new to Go, but I really like that Echo handlers return `error`, which makes centralized error handling a lot easier. I kinda wish there where some alternatives but I didn't find any yet.
There are already a bunch of better alternatives. Stop talking out of your ass.
&gt; the same kind of cabal was orchestrated against Martini's author , until he quits Go's community. I don't think that ever happened.
You can use recover middleware for panics.
Good part of Iris, yeah
No I wasn't talking about panics, but rather about regular errors. In my REST API Echo allows me to use it's [NewHTTPError API](https://godoc.org/github.com/labstack/echo#NewHTTPError) to return non-2xx replies in a simple way similar to other libraries. But where it gets useful for me is when I'm using for instance [`validator`](https://github.com/go-playground/validator/) and Echo allows me here to simply return those validator errors from a request handler. All I have to write for this is `return err` and that's it. In the [central error handler](https://godoc.org/github.com/labstack/echo#Echo.SetHTTPErrorHandler) I can then catch those errors and handle them accordingly. In my case I'm for instance formatting validator errors to contain the failed validation keys in an array, in order for the web frontend to correctly mark the incorrectly filled input fields with e.g. a red outline. The only DRY alternative I can think of using regular standard HTTP handlers is to wrap each possibly failing function in a method that would generate the reply accordingly, but IMO that's a lot more cumbersome than a central error handler, since you now have to write `return formatReplyForLibraryXYZ(req, res, err)` everywhere instead of simply having `return err`.
He just wrote Negroni instead as a more idiomatic option.
What's your criteria for choosing a problem? Why did you stop doing the 100's and jump to the 1000's?
I'm not saying this with fact but do botted stars exist? 
This guy... I don't think there is any basis for calling this harassment. It would be a concern for any team using or contributing to open-source software if commit history is being squashed and licences are being removed, seemingly at random, on purpose! It's not just the go community to consider, it gives open source software a bad name.
(in no particular order) Go in 5 Minutes: https://www.youtube.com/channel/UC2GHqYE3fVJMncbrRd8AqcA Applied Go: https://www.youtube.com/channel/UCsf0cZc4jnvE5-CjEhWN8pg The Go Programming Language: https://www.youtube.com/user/gocoding Gopher Academy: https://www.youtube.com/channel/UCx9QVEApa5BKLw9r8cnOFEA Boston Golang: https://www.youtube.com/channel/UCWeX1DrOg9unIw9-PkS_tWA Todd McLeod: https://www.youtube.com/user/toddmcleod Golang UK Conference: https://www.youtube.com/channel/UC9ZNrGdT2aAdrNbX78lbNlQ Golang Vids: https://www.youtube.com/channel/UCz7KItbg3owOqMpB5IjI7sA Golang TV: https://www.youtube.com/user/golangtv JustForFunc: https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw
Great list, thank you!
Missing JustForFunc https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw
i started with Echo, then moved to Iris, then totally regreted my decision, and now i'm back to Echo
Oh wow! thanks!
Thanks for the shout out @aboukirev just wanted to say that go-playground/lars is an http router and not a framework hence needing to write some things yourself :)
at the time there was no tests
Yes. Something similar happened with the [PHP-FIG](https://news.ycombinator.com/item?id=11661986).
Yes. Star botting is actually a thing.
It is a programming language and you can use it to write programs. For more info, see golang.org.
Go is a general purpose programming language, so you can do all sorts of things with it (though I don't think it's a good candidate language for Android/iOS apps yet). It's especially good for web backends, where concurrency matters (few languages can compete with Go on concurrency). That said, it's an easy language to learn--much easier than Java or C++. Head over to http://tour.golang.org for some interactive tutorials. I haven't done the tour in a few years, but you should be able to get through it in an afternoon. Once you've done that, you should have a pretty good idea about how the language works--enough to start writing interesting programs. Getting a Go development environment set up is a bit tricky (I have an installation guide [here](http://weberc2.bitbucket.org/posts/installing-go-on-linux-and-osx.html), but I don't know that it's very good and others should feel encouraged to recommend additional guides), so feel free to come back and ask questions. Hopefully others can chime in here with some good introductory resources (specifically good links about $GOPATH or good GUI text editors).
Here is a [good article](https://commandcenter.blogspot.com.au/2012/06/less-is-exponentially-more.html) about the language design and how it differs to C/C++. However Go stands out from the languages you mentioned by having simple &amp; straightforward constructs to do powerful concurrency. So if you're writing socket servers or require elaborate synchronization, Go can make this quite natural. I would say its weak (at the moment) in developing GUI and scientific/numerical software. Probably quite a bit more. But if you follow the language enough, it is evolving at a steady pace and _carefully_ tackles its shortcomings rather than doing a half-arsed hackjob.
it's a good question, i looked a bit into go as well and I was wondering, if and how i could write programs for windows is that easy with go, or should i look into something different?
I don't really understand why this guy keeps on telling cheap lies and believes he can convince others? It's like shooting himself with AK-47.
Great ! Thank you all very much for the info !!
Their English is so bad I couldn't understand what was going on. So, what is going on? Why should I care? 
You can write programs in Go and compile them for Windows, but they'll likely be for the command line. If you're looking to build GUI apps for Windows in Go, there's a pretty good list at https://github.com/avelino/awesome-go#gui for GUI toolkits in Go. I've never tried any of them, but https://github.com/lxn/walk seems to be specifically targeted for windows. Good luck!
Oh man thanks!! This is really awesome, because I really liked gin so far. I do wonder what the use case for multiple errors per request is… Don't you abort the processing with the first error anyways? Or can you think of anything where this feature could be useful?
I don't know, maybe if the error isn't fatal, we can simply record it and proceed anyway. the middleware then logs everything 
I'd like to point also that official `context` is well suited for request cancellation. However, it's not as good for passing values down the middleware/handler chain - to many reallocations of entire request that lead to sometimes unpredictable results. I much prefer 3rd party context that wraps these additional parameters/values and parsed information from the route and provides various convenience methods. Cleaner testable code is achieved that way.
Depends. The author has been called on the second time for various issues with the project and for the second time he's trying to downplay them. Right now the project closed the issues in an attempt to hide the previous issues opened. If you really want to read about it do it here: http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html. I've done the post to warn people about it and it seems the author is doing more to destroy his image and credibility by each second that passes. At least some people have their code mentioned again in the project but there are still plenty of other issues. I hope this helps shedding some light about it. P.S. I'm not a native English speaker so any tips on how to improve it would be great. Thank you.
LOL :D
Gotta say, I am a happy user of [chi](https://github.com/pressly/chi). Zero regret moving to it from gorilla/mux.
Except this solution was called aids from the beginning and has proven to be that and more. 
Why in the world would you destroy commit history? It is one thing to have release branches, it is another to *literally* destroy commit history. Why not just create a web page and release it? (Besides, you know, not be able to steal other's code)
I don't find anything already written in Go, but here's the interface you'll want to use: https://msdn.microsoft.com/en-us/library/aa289172(VS.71).aspx
Not so much the project but the author. Essentially faking test results when he first pushed the package. Since then, he has been stealing code under the guise of open-source and claiming it as his own. He acknowledges he does it but won't fix it. 
I think you misunderstood the original post you responded to. In no way is your point an exception to mine; I hold the same position as you on this project, but that's all unrelated to this particular thread, since the person I responded to was complaining about the slow pace of standardization within Go.
Heh, sounds like it. Thought it was in reference to iris being the project for the standardization.
This isn't shitting on someone else's work. This is literally illegally removing another project's license. Besides that, he's being a HUGE dick to the rest of the Go community. You. Do. Not. Squash. Commits. in open source. I mean, forget squashing commits, this guy goes one level further: he edits git's history so that all contributions look like they're from him, and then he squashes those too. First of all, it's literally impossible to navigate the history of his project, which is against the spirit of open source, but second of all, it's incredibly rude to completely wipe out others' contributions. And he does it *all for the starz bruh*, fuck that. He's literally doing this for fake internet points.
FWIW I consider Rust to be just as easy, and _maybe_ even easier to set up because it has no concept of GOPATH / a central project directory. (P.S. hi :) ) Also, even easier if you use the `rustup.sh` install script available at https://www.rust-lang.org/en-US/downloads.html
MPI and OpenMP, go-circuit. HSA and ROCm(https://github.com/RadeonOpenCompute) have no golang bindings I am aware yet. AMD Zen motherboards are coming out in November I believe so that would be a good time to consider using rocm and possibly exploring its possibilities with golang.
Thank you very much! I'll head over there and try to learn the syntax. I will also check out the installation guide. I really appreciate the help.
Got it! Thank you very much, I will take a look at the article. I appreciate your reply.
Hahahaha okay okay I'll try not to :)
If you want to explore the world of writing webapps, read my book :-) It is a practical based tutorial on how to write webapps in Go without a framework and assumes 0 knowledge about how to write webapps . https://github.com/thewhitetulip/web-dev-golang-anti-textbook/
Just downloaded the PDF. I love the formatting, will definitely be reading through this for reference.
Also http://gophervids.appspot.com
&gt; but there was no "installation" section or similar. It's in the wiki: https://github.com/golang/gddo/wiki/Development-Environment-Setup I used to run a private gddo instance at my previous company for our internal code. I just ran it on internal network, and gave it GitHub credentials that had access to our private repos. However, there have been many changes to gddo recently that tie it closely to Google App Engine and other stuff, making it harder to run it stand-alone. Also, this might be somewhat relevant/helpful. https://godoc.org/github.com/shurcooL/cmd/godoc_router I used that to augment the private instance with the rest of godoc.org for all the public stuff. But, this was a few years ago, so it might be out of date.
An alternative approach which might fit your needs. Run `godoc -http=:6060` Navigate to `http://localhost:6060/pkg/` Tada! All the code in your $GOPATH (which includes stdlib) now has a web interface.
I think it's simple and clear. How can Go know where you'd like to store your personal code? Setting a single env var to tell it that seems very reasonable. I suppose it having a default sensible location if GOPATH is unset would be okay too. Then, if you're happy with the default, no need to set GOPATH, and if you want to change it, you can. The downside of that is if you accidentally run `go` with that env var not set, it'll potentially start looking in the wrong folder and give you weird/unexpected results, instead of just a clear error. (There is a [proposal](https://github.com/golang/go/issues/12488) about this or something related to this.)
Thanks! Which PDF? there are two, leanpub.com and one from gitbooks.com I love the leanpub one!
They probably need to delete the whitespace first, using [strings.Replace](https://golang.org/pkg/strings/#Replace) or smth like that.
Hello, I wrote such web-service as a test project. Currently it hosted on azure. You could check it out. http://paste2run.azurewebsites.net/ It's stable now, but I'm still working on it. Currently, each container running with next restrictions: - RAM restriction - CPU restriction - Timeout - Dropped all Linux Kernel capabilities - Disabled networking - PID limitations - Max Stdout/Stderr Bytes Here you can find list of Docker vulnerabilities: http://www.cvedetails.com/product/28125/Docker-Docker.html?vendor_id=13534 Most of them affecting old Docker versions, but I'm still looking on them. Also here you can find presentation about Docker security: https://www.blackhat.com/docs/eu-15/materials/eu-15-Bettini-Vulnerability-Exploitation-In-Docker-Container-Environments.pdf 
As far as I know, this is the only way we can run godoc :-D
I've only wrote it because it breaks the user experience of Go newbies so much it creates a bad image on the ecosystem. 
You could have go render form data in a template and then process that with an api endpoint. I would look into forms and rest.(rest is just a concept, forms are standard html syntax) I hope this helps.
Yep, this is the reason why I do not use iris and it's good, isn't it?
I would like to know your point of view on the fact that the git history is squashed to show that the author is the sole person who commits to the repo. Objectively, is it against the spirit of FOSS? (note: I am not hating or anything, just an objective question)
In addition to [cs-guy's `-a` post](https://www.reddit.com/r/golang/comments/57t486/edit_stdlib_for_tracing_or_debugging/d8v5gky), note that you can avoid messing with the whole system's stdlib (and risk forgetting to undo your changes correctly) by copying over the one package you want to modify into a `vendor` subdirectory. (e.g. something like `mkdir -vp vendor/os &amp;&amp; cp -pR $(go env GOROOT)/src/os/exec vendor/os`).
Thanks!
agent := stackimpact.NewAgent(); agent.Configure("agent key here", “MyGoApp”) The Configure func looks funny. Why not to have NewAgent take some Options struct?
Mainly to avoid additional object creation and also to explicitly initialize the agent. Normal use cases shouldn't require options other than what Configure takes. The agent object is actually the option holder in this case.
https://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 3674 times, representing 2.7955% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d8x7ybw)
Nice to see the community coming up with all sorts of interesting analogies !
What is a use case for this? edit: why would anyone down vote this question??? I just want to know how people are using this! I really don't get reddit sometimes.
Yeah, I should have mentioned that I specifically want GoDoc.org because it's got a more impressive user interface, and I want to use it in a demo for Go prototype to our Python organization. Probably not a big difference, but it seems worth the while to get a few additional oohs and ahhs.
I just checked your comment history. Please don't troll here.
I'm hoping I can get my own code on a private godoc.org since its feature set is much nicer than that of the godoc tool.
I'm not sure I agree that the sql package is "quite verbose". For small-medium projects that don't have a ton of relationships, it's very suitable. For anything with more than a few tables and relationships, I will concede that one should consider an ORM of some form.
Fuuuuuuck. I can't believe this. I spend 2 days on writing a chat using websockets with Iris. Now I don't want to touch this. I kept telling myself "do not read reviews until you're done, do not do it" because everytime I do it just slows me down and fills me up with unnecessary doubts. Should have done it this time. 2 days wasted. 
I've used both, they're pretty straightforward. Check out https://github.com/spf13/pflag for a package that can do both. Edit: yes I linked the wrong package, I meant "github.com/spf13/viper" 
Suffer until you become a physics-defying superhuman? 
Quite enjoyed this. 
if it's possible, maybe you want to change the format of your config something like hosts - name: A method: ssh port: 22 interval: 2 - name: B method: http port: 88 interval: 5 then you can use gopkg.in/yaml.v2 to parse it 
Stopping an initialized agent is not supported. There might be Destroy() method in future releases if requested by developers, which will properly terminate all tickers. Agent should not be confused with a client, such as for example an HTTP client. One agent runs for one program, it is active from the start until the end.
This worked for me only when I ran godoc as root.
Every problem in computer science can be solved by another layer of abstraction. Except to many layers of abstraction. Seriously though, this is now a layer, around a layer, around a layer around a database driver. :)
It seems like this could just be a PR against SQLx?
I love good analogies and examples, the only way to make it interesting and understandable. At least for me :)
I know enough about channels, but decided to click anyways. Glad I did, was a fun read.
Please let me know what you think :)
I'm not seeing an SDK directory. What SDK are you referring to? EDIT: Another user mentioned that this belongs to the app engine sdk. I'll poke around that when I have more time.
Thanks for the post. I have a pictographic mind, so these kinds of analogies really help simplify what can be fairly complex subjects.
Ain't pretty, but it works: package main import ( "fmt" yaml "gopkg.in/yaml.v2" ) func main() { h := map[string]map[string]ConnectionData{} err := yaml.Unmarshal([]byte(content), &amp;h) if err != nil { fmt.Println(err) return } fmt.Printf("%#v\n", h) } func (c *ConnectionData) UnmarshalYAML(unmarshal func(interface{}) error) error { m := map[string]interface{}{} if err := unmarshal(&amp;m); err != nil { return err } if port, ok := m["Port"]; ok { p, ok := port.(int) if !ok { return fmt.Errorf("invalid port: %v", p) } c.Port = p } if in, ok := m["Interval"]; ok { i, ok := in.(string) if !ok { return fmt.Errorf("invalid interval: %v", in) } c.Interval = i } return nil } const content = ` hostA: ssh: Port: 22 Interval: 2 minutes hostB: http: Port: 80 Interval: 5 minutes ` 
This is what I was going to say. I think the number one problem people have with yaml is trying to make them too implicit, which makes them hard to parse. 
I think this little layer can save hundreds of lines of "SaveThisWithTx" or dead locks, and people don't necessarily think of using this kind of trick
Great post, although it probably did not have the desired effect on me. Instead of coding some channel logic, I'd rather want to play Portal right now :)
Go has been needing a full-featured GUI binding for a long time. Can't wait to try it.
Oooooh, looks very interesting. I'll try it out when I have some free time over the weekend :)
I'm not super familiar with QT. Can someone explain the difference between this and [go-qml](https://github.com/go-qml/qml) As someone looking to throw a cross platform UI on top of some go code, what are the pros and cons of these 2 approaches. Is one strictly better? If so, why? If not, is it a matter of preference or are they each better suited towards different tasks/goals?
What's next? "If-else in Go. Introduction for good lads Gopher boys"? Nearly 470 words and 3k characters on what, something explicitly explained over https://gobyexample.com/variadic-functions? Don't get me wrong here, it's more like community is basically drowning in super beginner-oriented Medium BS sort of style documentation, which (might) not be a good thing after all. The amount of dumbed down tutorials on Go over the Internet is sort of crazy especially given the simplicity of the language itself, isn't it? What surprises me more is that people tend to upvote practically ANY content related (or endorsing) Go in one way or another, regardless of its nature.
This was a really good explanation that I will definitely reuse 
My point wasn't to say, that you should use either in your package. But that one should use either *instead* of your package. &gt; Currently httpteleport uses very simple wire protocol - it just prepends each http request and http response with an unique id. Both HTTP/2 and QUIC additionally use protocol specific compression, AFAIK. QUIC also uses custom congestion control and prevents TCP head-of-line blocking (and does some other cool tricks). &gt; I'm unaware of http/2.0 implementation as fast as fasthttp. Wasn't really talking about fasthttp (or any implementation, for that matter) at all. Was talking about the theoretical limits of the protocol. And it would seem to me, that in a fair comparison of implementations, both should easily beat your custom one.
Yeah, I agree. I really like this but it would be much better if it was part of sqlx itself. 
Probably because you were trying to bind to a low port, such as 80
All of the instructions seem to assume you are installing the Android runtime or the iOS one. Is that by design?
You used auto code generation for parts of the bindings ? for example network.cpp
Hey I'm probably a bit biased, but I will try to give you an objective summary. go-qml is a binding for the Qt qml module and primary targets mobile development. This binding is a binding to most of Qt's modules (more than 30 + qml) and targets both mobile and desktop development. Qml itself is explained here http://doc.qt.io/qt-5/qmlapplications.html &gt;QML is a declarative language that allows user interfaces to be described in terms of their visual components and how they interact and relate with one another. If you want to use qml, you need to write qml code and this is an example of how a qml file could look like. Rectangle { width: 200 height: 100 color: "red" Text { anchors.centerIn: parent text: "Hello, World!" } } Qml is also often described as a better version of js and even through you can build user interfaces with qml, those will mostly look alien on desktop targets. In Qt 5.8 the qml module will have themes for android (material) and iOS and can mimics the native user interface elements of both systems. Also you should use qml if you want to create a uniform look on all of your targets. go-qml created a custom binding around the qml module, which allows you to write more Go-ish code. So you can iirc access exported Go structs from qml. This binding is a general binding which maps the Qt Api and tries to bring each Qt functions as unaltered as possible to Go. The communication between qml and Go is therefore mainly made with signals and slots and feels more like the standard Qt approach. If you want to build desktop user interfaces with a "native" look, you should use this binding. Also even through go-qml is aimed torwards mobile developmend only this binding supports the android and iOS targets. go-qml officialy supports Qt 5.1 (newer versions may also work) and has currently problems with the new cgo pointer rules in Go 1.7. This binding supports Qt 5.7 and will also support Qt 5.8, once it's released. I could write a lot more, but those are probably the key points.
Yes, the whole binding is auto-generated once you run the setup.
I'm already planning to add something like that :)
Thanks, that makes things much clearer. Out of curiosity, did you consider contributing to or forking https://github.com/visualfc/goqt ? It looks very similar to this, although it doesn't claim to support iOS or Android.
Ok. That makes sense, you should totally get this up on https://github.com/avelino/awesome-go and maybe consider adding some of this info about how your project compares to others to your wiki or README.
Yes, I was a bit lazy in that point. I will probably take the summary from above and add a few more infos. Thanks for the tip :)
Since it was already mentioned in the mailing list and replying to upvote seems odd. Mega ++ for an easy option to exclude /vendor.
I have done such, I still hit limits up until I set a somaxconn of 1024. This seemed to also slow things down a great deal (as would be fairly expected). Is there anything else you might know of for socket tuning?
Yes thus far, I'm just using database/sql. I think i'll need pq for things like bulk inserts but i'm not quite there yet. Thank you!
This looks amazing. I was wondering... how does this work in conjunction with goroutines, and the qt requirement of only modifying qwidgets from the main thread? I saw in the "qt.go" init() that is uses LockOSThread, but I wasn't sure if that guarantees the main() thread will also be the same as the one that ran init()? Do users need to also call LockOSThread() in their main() ? Are there any caveats to using goroutines?
Thanks I'll have a look!
Are you using backend keepalives? Either you're leaving out some important detail like massive fluctuations in load, not reusing connections to down stream services or you have a misconfiguration. It's incredibly unlikely you're going to exhaust ephemerals behind a properly configured reverse proxy. 
Some more distributed DB systems, besides the already mentioned Cassandra (in no particular order; also, I never used any of them and thus cannot comment on their pros and cons): * [CockroachDB](https://www.cockroachlabs.com/), implemented in Go. * [RethinkDB](https://github.com/rethinkdb/rethinkdb) * [rqlite](http://www.rqlite.com/) * [TIDB](https://github.com/pingcap/tidb) (Go) **EDIT**: Fixed the links to CockroachDB and to rqlite (copy&amp;paste errors). And it's rqlite, not rsqlite. Sorry about the many errors.
True that, this is the reason I switched from Python (Django) to Go. My question was, would it be helpful if my book has an accompanying video series?
This was a good article. Once you get comfortable with channels, don't go crazy overusing them though, as they're not always the cleanest or most efficient way of communicating. This guy explains the shortcomings better than I would: http://www.jtolds.com/writing/2016/03/go-channels-are-bad-and-you-should-feel-bad/
It is new to me that this is such a hot debate. On one side I see "Crypto is for security engineers and cryptographers" and on the other side I see "But as a developer in my company/product I'm still in charge of hashing passwords and other crypto-related stuff" (I'm part of the latter). This is very odd to me that there isn't a friendlier documentation for the uninitiated with just a few suggestions of how to at least get started kinda like the video I linked on this post. That was great, I think we need more of that. I wonder if people more knowledgeable about crypto is just naturally reluctant because of the nature of the problem domain - Security is a **big deal** after all and many can't afford to have crypto beginners to screw things up. But on the other hand, there's a lot of people **already** tasked with hashing passwords and implementing SSL connections that are doing it with almost no direction, and when they turn to those who understand to problem domain only to get a "crypto is not for you" answer is a huge loss for everybody. They (myself included) are already tasked with implementing crypto stuff on their job. There are no security engineers around. So the job will get done either way. That's why I think that some guidelines or at least good suggestions should be made available, so everybody has at least an idea of what algorithms are best fit (or not) for each situation.
I think it supports public and private, but if not you can use the public godoc for public code and that for private code
This is priceless!
Iris author really teaches how to be a dictator in open source.
It is hard to get someone to help you out with documentation or anything for that matter. I speak from experience. I asked ten people to help me with the FOSS book I initiated, and only a few helped me out, others ignored. I understood that people are busy with things! It is difficult to build a community around your project. Also, the quality of project does not depend on how well you speak English. (although the quality of the tech docs can be considered a measure of quality) Even I am not a native speaker.
No I haven't tried any of those. This is just a project that I try to make progress on every day.
Wait, you've separated reading and writing to a JSON string into two libraries? Why?
IMO Cassandra is an overkill for 100K entries.
It can be slightly awkward to work with middleware in gorilla/mux. Chi does a better job of this by providing an "Express-ish" API. Also, chi was very early to adopt Go1.7 net/context, giving it a modern, idiomatic interface. For me, chi does more than just provide routing - it provides a clean, idiomatic backbone to a Go http server.
Thanks for that. I hadn't seen chi before but it looks really good. 
Can't wait to try this out! Nice work!
It's launching open-source process right now (setting up CI, core maintainers team, etc). Check out their slack. 
I believe the requirement is out-of-the-box replication which most RDBMSes don't handle well. Unfortunately, there aren't a lot of simple distributed KV stores out there. Maybe the OP can try [etcd](https://github.com/coreos/etcd/blob/master/Documentation/op-guide/performance.md#benchmarks) which fortunately is written in Go?
You don't need to explicitly call LockOSThread() in your main(), the call in init() should be sufficient enough. And yes, there are caveats with goroutines. As you stated above it's only possible to modify visual Qt elements from the "main" thread (that started the Qt main event loop). If you use goroutines there is no gurante that the routine will run in the main thread, which leads to problems. So it's necessary to use Qt's signal and slot mechanism if you want to cross threads. These "safe" functions are labeled with "signal" or "slot" in the Qt docs. Alternativly you can also create your own signals or slots and use them to safely cross threads, just take a look at the "quick/bridge" examples which shows you how to communicate with qml from go and therefore needs to cross threads.
I'm not sure if qml is the recommended way on all desktop platforms. If it's used in KDE and Ubuntu, then probably because it's way more flexible than the old c++ widgets. But qml started out as a way to simply write mobile applications. I would probably still favour the old widgets over qml for plain normal desktop apps, because they already come perfectly styled. And I could write all my code in c++|go instead of switching between c++|go / qml / js. Qml on the other side is more usefull for mobile development, because it mimics the native style there and also has better support for multi-touch and such. Wheather the old widgets look horrible on mobile (take a look at the screenshots in the readme). Qml is also better suited for game development, because the underlying technology is build with that in mind.
It's mostly an aesthetic decision. GJSON has shown to be pretty useful for one specific purpose, getting values. Adding mutations to GJSON seemed strangely uncomfortable. Gives me the heebie-jeebies. That being said it would be rather trivial to simply add Set functions to GJSON if this would suffice.
This doesn't solve the problems that affect people who use, let's say, glide, which depends on commits to be able to build.
&gt; What you said is wrong. Setting the vars isn't the hard part, intuiting how they're used by the Go tool is. This makes me come back to my initial comment. &gt; Besides, the OP is a sophomore; there's no reason he should know about environment variables. That is one of the most ludicrous statements I've read on a programming related topic.
You mean you're *GLaD* you did.
In retrospect, it might have been good if the zero value of pointers had a different name than the zero value of the rest of its uses. No more nil interface confusion. 
&gt; golang is for googling I always google just with "go": "go toml parser", "go lua binding", "go svg generator", ... and I don't get worse results than with "golang". I think it's a myth that Go is not googleable.
In my pnoise benchmark I saw a nice boost with Go 1.7.1, would be interesting to see if Go 1.8 improves it further: https://github.com/nsf/pnoise/commit/1dd95cf7692841c91067818a37e92370f3caeedf. But I'll wait for the release.
Holy mama every release manages to amaze me. Keep up the great work!
&gt; The zero values of different types are not comparable. interface nil and most non-interface nil are comparable.
Yes, but then it's your maintenance burden instead of theirs. Keeping an up-to-date copy of code in your own repo is a much bigger headache than just importing someone else's that gets all the bug reports and fixes etc.
agree
Don't celebrate just yet, there's a chance evil-mode, org-mode, and my love for lisp could sway me.
It is a Go proverb that "a little copying is better than a little dependency". Remember the [left pad incident](http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)?
The way I (try to) remember it is: * `HandleFunc` lets you Handle a request with a Func, whereas * `HandlerFunc`makes a Handler from a Func. Neither statement then makes sense if you get Handle/Handler swapped in your mind. Handle (verb) vs Handler (noun).
The really interesting thing about such a list is that it doesn't really have that much to do with how good those people were at programming, and rather the ideas they had, or even the random success of projects they just happened to be involved with.
Oh, I see! When i was using the search function it couldn't detect it because of the other crap there. Thanks for clearing that up!
Thanks. For the extra lazy: &gt; Looks like this is related to the change in how bytes.Index works. @TocarIP &gt; When looking for a smallish multicharacter string (in this case, 26 characters), we used to look for the first character, then check the remaining characters, then repeat. Now we use fun SSE (AVX?) instructions to look for multiple characters at once. The new way will definitely be faster when the first character matches but the rest don't (it is not slowed down by partial matches). The old way looks like it is faster when there are few matches of the first character. I'm surprised about how much faster it is, however. &gt; It is possible that we should do some combination algorithm, looking for just the first character and switching once we get a few false positives (partial but not complete matches). &gt; All that said, the regexp is still doing &gt;1GB/sec. I think this may be an instance of "something blazingly fast got a bit less blazingly fast".
Go is the name of the language. golang.org is the name of the Website. It's that easy. Compare to: Rust - rust-lang.org, Pony - ponylang.org, D - dlang.org. When I talk or write about Go, I always always say or write "Go". My blog articles are invisibly tagged with both "Go" and "golang" to make the search engines happy, but in the text I never use the string "golang" when referring to the language. 
I've successfully used Pact in a Go kit demo recently; would it be useful to write up a blog article on it?
I can confirm therecipe/qt binding holds a great deal of effort making it appear far more mature than what usually surfaces as an alpha. Hats off to the people that made this happen. One startling observation: qt/widgets/widgets.go is 10MB!!! There's a lot of oomph in there.
dont give a shit about performance, just make `go` follow symlinks correctly when discovering vendor/, and stop asking for bullshit GOPATH customization; just shove that shit in ~/go every time Go's package system is so screwed, everyone and their dog has a third party Go package manager alternative NPM works, RubyGems works, hell even CPAN works. WTF google
Nice rant
Golang should only be used for search and hashtagging.
Gopath can suck it.
I count four: * Ken Thompson * Rob Pike * Russ Cox * Brad Fitzpatrick (in the databases section)
[30,000](http://i.imgur.com/hoakzBo.png).
I have a repository with 1049 stars, still find it difficult to do what you asked.
I use a vendor symlink and it works fine. Care to elaborate?
This doesn't seem to have anything to do with Go.
Not related to Go save for that gopher picture.
I always say golang to avoid confusion.
Interestingly I wrote a blog post about this a while back when covering Go's func Type http://www.integralist.co.uk/posts/golang-webserver.html
I had starred this repo a long time back, Now after reading all this shit drama, I removed it. Currently saw the repo, he squashed everything. The entire repo has 10 commits lol.
That's true and the author acknowledged this at the end of the post. I'd still argue it's relevant because it shows how to create a policy from a compiled binary, which is what go produces. If helps with adoption of Go, even just a little bit, then I don't see the harm.
Issues have been being closed recently at an astonishing rate, getting ready for the freeze. You can see a graph https://dev.golang.org/stats ; The last line in blue that's taking a nosedive is issues marked 1.8.
We might get lucky and receive a mips port with 1.8: https://go-review.googlesource.com/#/c/31473/
If you google long enough, using 'go' will suffice.
&gt; Hence, in addition to substantially improving STW time, the hybrid write barrier should also reduce the overall complexity of the garbage collector. Sounds like a win-win. Are there any trade-offs? If it's such a good idea, why wasn't it implemented earlier, given it's based on such old papers? &gt; that combines a Yuasa-style deletion write barrier [Yuasa '90] and a Dijkstra-style insertion write barrier [Dijkstra '78]. Or are parts of this very novel?
They get you to the trending page: https://github.com/trending?l=Go Iris is there as of 2016/10/20. And the more stars, the higher you are in the search results.
It is the idea of combining the two barriers that is novel.
In this first sentence, I tend to use "go". In this second one, however, I prefer using the term "golang".
In Python it's called unpacking argument list (https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists). Haven't found anything in Golang spec about it in neither section where variadic functions are described (https://golang.org/ref/spec#Passing_arguments_to_..._parameters) or arguments (https://golang.org/ref/spec#Arguments).
Sounds good, thanks 
Wow great article. Exactly what I was looking for, thanks!
Afaik Google does indeed some magic stuff when searching for "Go".
&gt; Are there any trade-offs? A few of the write barrier elisions are no longer safe, so the generated code is a bit bigger and a tiny bit slower. But otherwise what /u/gohacker said: the novelty is the combination of the two barriers. 
Oh I'm aware, I was just amused that at the time I looked it was 1-off from 2500
Lets Learn Algorithms - But don't use this algorithm. (a joke). I like the goal of this series and I like using Go for it.
I'm currently using this book. Go routines and channels still to come. The exercises and sample code along with the authors explanation of the language are adequate - no problems so far. Google for the source code if you plan on doing the exercises - which I suggest - it makes reading the code easier in an editor along side given the formatting of pdf documents. 
Is it something unrelated to ROC GC effort or a new approach instead of ROC?
Hey! I've read through your code, and even though I'm still a beginner gopher, there are some things I think are of interest to you: * You have an A+ score on [goreportcard](https://goreportcard.com/)! Well done! The only thing missing is the license file :) * mq.go:40 - I believe it's always better to have the "smaller" if in these scenarios. Instead of checking for the "success" scenario, check for the "failure" scenario. That way, you don't have to put an extra level of indentation in a bunch of code. You could do it like this: if err != nil { return "", err } if res == nil { return "", ErrMyOwnErrorIndicatingAnAbnormalCase } // Handle success scenario here * func brpop() - I don't know why only this function has a bunch of extra newlines around. That makes for an inconsistent style * mq.go:62 - are you missing a "return" statement inside the if? * Inconsistencies when handling errors - you log.Fatal() in mq.go:28, but everywhere else in the code, you only fmt.Println() with the error message * mq.go:93 - are you missing a "continue" statement inside the if? * I'd argue that mq.go:96 should be inside the if of mq.go:97 * mq.go:67 - isn't this construct the same of rewriting mq.go:66 as `for i, record := range records[1:]`? This new construct is cleaner, without losing readability * Good uses of defer! You seem to understand this concept well Two extra comments, this time about the design of your algorithm: * You shouldn't need those global variables for the db connection and the sql insert statement. Try to make the code more modular. Think like this: if someone were to later extract your functions to a module, would it still work? If you rely on global variables like that, it wouldn't. However, I don't see why not just pass the db connection and the statement as arguments to the functions. * You seem to create a goroutine for every record you want to insert. This is a good choice if the goroutines mostly will just be stuck in I/O or something not processor intensive. However, if those goroutines end up processor intensive, you might want to review your decision to spawn one for each record. In this case, it would be better if you spawn a few goroutines which would just read from a channel, and then do the processing-intensive task. Like a pool of workers. Since you're still learning stuff, try to change your code to use channels instead! They're nice :) That turned out longer than I thought, but I hope you enjoy what I wrote! Edit: formatting
I guess this kind of looks like [Currying](http://stackoverflow.com/questions/36314/what-is-currying).
Unrelated.
ab uses a single OS thread even if the concurrency is set high, so it doesn't perform well for testing at high load. I've seen this in the past and switching to wrk helped me generate a lot more load. There are a lot of other tools in this space as well, such as vegeta.
...and of course never challenge a benchmark that confirms your bias!
Go has `const`, e.g. `const foo int = 5`. Is this what you want? The value of foo cannot be changed.
&gt; It should be noted that there is a bit of a bug in this implementation in that the chunk could read until the middle of a hodor and it wouldn’t get replaced properly. Since this code is for demonstration only, fixing it is an exercise left to the reader. I am actually wondering how would one go about solving that.
Thank you, but no I know about that and that is not what I meant. What I mean is: Java: public void Work() { final int i = repo.GetInt(); i = repo.GetInt(); //error } What I imagined it should look like in go: func Work() error { val i := repo.Int() i = repo.Int() //error } So, single assignment variable as method result some other non-constant runtime value.
Is this the same as C#'s `readonly` modifier?
Don't be so ignorant.
It is function composition (just done in an indirect way). And in some people's worlds, decorators are just syntactic sugar for function composition, so it's also that... except without the sugar ;)
I think this is a case where a loop is better than recursion, as go doesn't support anonymous recursive calls. A case can be made for having no side effects for it to truly be functional: `type Printer func(m MyObject) (MyObject, error)`. I'd love to see a functional version of this code that is as succinct as this - really.
When we've had to do similar things, we usually read into a buffer that allows us to "peek" ahead. If you want to get really fancy, to ensure that hodor is always replaced, but hodorfoobar isn't, you can implement word boundary detection. http://unicode.org/reports/tr29/ has a very good algorithm for doing this. Or you could always just look for space or punctuation for word boundaries to keep it simple. That just doesn't work for some languages though, and you will have to deal with cases like "don't" where the punctuation is not a word boundary.
+1 for this Not adding one dependency to your project, but having a type which groups your `error`s and implements `error` itself.
Thanks!
there are also better http libs and json libs for .net if you wanna go down those roads though.
TBH I prefer this "vanilla" benchmark instead of trying to pair up the best 3rd party libs to hit higher numbers. This lets you see what you get out of the box. 
A slightly less good errorList is in go/scanner, if you'd really prefer a no-dependency solution.
I still can't understand why you don't want to use a `const` for this purpose: package main func Work() { const I = "1" I = "2" //error } func main() { Work() } &gt; `main.go:5: cannot assign to I` It's just because you cannot "catch" the error when assigning, instead of letting the compiler complain? In that case, I don't expect Go to include something like that, ever?. However, you can have your own Final type with a very simple implementation, which will allow you to assign a value to the variable only once: package main import "fmt" type Final struct { Value interface{} Final bool } func (f *Final) Assign(value interface{}) bool { if !f.Final { f.Value = value f.Final = true return true } return false } func Work() { var I Final ok := I.Assign(2) notOK := I.Assign(4) fmt.Println(ok, notOK, I.Value) } func main() { Work() } &gt; true false 2 See it in action here: https://play.golang.org/p/bTW6uqjikP 
Neither does reddit karma. Some people still do crazy things to get it.
I think you're right with just returning one error, it's probably the cleaner way of doing it vs having two returned with one being the slice. Going to look further into using an interface, thank you!
Thanks!
I performed a similar benchmark with Go and regular ASP.NET a couple of years ago with similar results. We went with Go and couldn't be happier about the performance. We do prefer https://github.com/wg/wrk instead of ab for benchmarking and are using github.com/pquerna/ffjson/ffjson with the builtin net/http web server. Our main server is running in production these days, is highly concurrent using goroutines and performs between 50 and 100 Redis operations on average per request with server side latencies of 5ms at 95% and 11ms at 99%. RAM usage is normally around 8-10MB.
(Note that this final implementation is not threadsafe (Not that Java's "final" is threadsafe if you don't put in the legwork...)) The reason he can't use const is that he wants to have something be assigned to, say, the return value of a function. Consts can only be compile-time constants, which is very different from Java's "final", which means "assigned only once", and which can also be applied to any variable/field. ... Whether what he's trying to do actually has a purpose, and isn't just an attempt to write Java in Go is another thing, however.
errors.Wrap
If you put too much logic in your cli, then you can't reuse it as a library. In other words, if you want to share your library out, don't put anything public in package main. Thanks for the feedback, and for the star on Github!
they break the API.
For only 140 bytes per request, his Go implementation (9k/sec) seems a bit slow. I think he'll get much better throughput if he go with TCP and simpler payload structure.
Oh dear. Bubble sort is *still* being used as an introductory algorithm? It should never be taught to anyone, ever. Insertion sort is superior in every aspect, including more intuitive and easier to grasp for people who haven't done programming before. Even selection sort is much superior. It's never a good idea to teach bad habits.
meh? I guess I don't really see the point. 
Use the stdlib `net/http` if you want to benchmark against another language. fasthttp is not http. 
On my i3 6100 (dual core) 8GB RAM and using **net/http** I get 45k req/sec using [hey](https://github.com/rakyll/hey) [Benchmark](http://imgur.com/a/mxw73) [Code](http://imgur.com/a/JYIvZ) 
We use upstart to manage our binaries, and upstart handles logging for us. Tip: Don't use upstart. Use systemd.
Hey, for standard log package, the key is giving a file as log output while creating a new logger. An example is here: https://play.golang.org/p/GSTMBG5ERv. This of course won't work in playground but it shows the main idea.
 This is a Go response for https://medium.com/@rymcol/benchmarks-for-the-top-server-side-swift-frameworks-vs-node-js-24460cfe0beb Currently only `/json` handler is implemented. `/blog` implementation is left as an exercise for readers :) Go version used - `go tip` aka `go 1.8`. # Build Time Results ``` time go build real 0m0.466s user 0m0.544s sys 0m0.068s ``` # Memory usage 1. After process start: 5Mb 2. Peak memory usage for 10 concurrent clients: 9.5Mb 3. Peak memory usage for 100 concurrent clients: 10Mb # Thread usage 4 threads. It has little sense with [GOMAXPROCS](https://golang.org/pkg/runtime/) :) # JSON benchmarks Results: 160K qps ``` ./wrk -t 1 -c 20 -d 30s http://localhost:8090/json Running 30s test @ http://localhost:8090/json 1 threads and 20 connections Thread Stats Avg Stdev Max +/- Stdev Latency 137.60us 518.44us 22.56ms 98.28% Req/Sec 160.97k 8.89k 171.46k 89.70% 4820802 requests in 30.10s, 836.28MB read Requests/sec: 160160.69 Transfer/sec: 27.78MB ``` # Conclusions Go is much faster than Swift and node.js :)
This. Most well configured logging strategies I've seen work like this: &gt; application -&gt; stdout/stderr -&gt; some daemon manager -&gt; syslog or file read by some kind of consumer (such as syslog-ng). Or like this: &gt; application -&gt; file/socket By doing this your application does not have to manage log files or send requests over syslog directly. The added bonus with this setup is you can still log to a file if you want with IO redirection or even let some other system (such as docker) handle stdout/stderr for you. **EDIT** The above works with non-go applications too.
But they did improve in the last revision, I remember something that the latest go version brings net/http performance up to pair with fasthttp. No source however, pretty sure it was on golang subreddit a few weeks-months ago
Are you planning on doing anything with the data or do you just need it printed out?
Oh that's cool. i will take a look at that and plat around with it. Thanks again!
You did notice the GH repo and post is incomplete in regards to the full testing setup? - no steps to scale up to x3 with swarm - no idea if he scaled front or backends or both in what kind of relationship (.net he said he had x3 for front and x1 for back, while go had more?) - how many servers? there's just one listed, but considering the concurrent nature of go, I suppose that's where the additional reqs throughput is coming from, and .net? Supposing I/O network is the bottleneck it seems logical it would scale out via process model on the same machine. - even in single run docker mode, there's no limits set to limit to cpu cores to ensure one process doesn't invade the others cpu resources That being said, I don't doubt go outperformed .net. I just doubt that the benchmark results are somehow... comparable. And I'm not sure they aren't tainted by running on the same server either.
I saw that the MIPS32 support was mailed for code review in Gerrit. Do you think the MIPS32 support is coming with go1.8?
F yeah variadic arguments for options are awesome. I don't exactly know where I've seen them first, but I definitely need to write an own article about them. I've seen them with enum/const/iota to represent single flags (turning things on-off). I suppose these guys could also be typed, since you have to somehow process whatever WithMaxAge() and other funcs would return into struct vars? I guess it's on my todo list to do some tests :)
It cannot. fasthttp's improvements come from the new API. There are more details on the fasthttp repo. However, because only net/http supports http/2, it is probably significantly faster than fasthttp's http/1.1. Perhaps that is the comparison that you saw?
You're welcome! I really hope it will help you. :-)
Can someone explain what's the difference between `net/http` and `fasthttp`? Also if fasthttp is better why isn't this going in the core?
You need more moustach... uhh I mean Ron Swanson.
Thanks! :) Can you link for any of your projects so I can take a look?
Usually what I do for smaller/simpler apps is to just start by keeping everything in a main.go file. When that grows larger, I start separating code in other files still under package main. If I notice that there's some functionality that could be extracted in a separate package then I create that and refactor. Rinse and repeat. For those cases, letting the structure of the code get "decided" dynamically and change as the project grows has worked pretty well for me. Nevertheless, if you know that the case is complex then you really need to first start designing on paper, which will hopefully reveal what packages are important for your project and then write the code.
This is a pretty good rule for something that starts small. For things that don't of course it's good to have a defined structure from the start. Also for projects getting built by teams it's good to have a defined pattern.
&gt; What I don't get is why he still has 5000 stars? do people not remove stars from his repo once they find out about Iris and the authors dealings? I had just fallen over the Iris blog post. read it, and jumped to reddit and came to your post. I had removed my star. Thank you for your post.
Thanks! This is probably one of the best advices!
Shouldn't this also include re-runs for the other languages so they are consistent to the machine running them?
Yeah, doesn't seem indicative of anything...
That's good, there are a variety of multierror packages too: https://godoc.org/?q=multierror
According to the [FAQ](https://github.com/valyala/fasthttp#faq), it also doesn't support HTTP 2.0, so if you need it, you can't use fasthttp.
I have found good advice on this post: “Standard Package Layout” @benbjohnson https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1
interesting.. Thanks. This looks useful and will look into it.
A distributed database seems like overkill and a pain to maintain. I have a similar use case and what I do is exchange the API key for a JWT token that contains only the claims I need to serve the request from the API endpoints. My API endpoints don't have access to the user database. they are dumb in the sense that they just validate the token and serve the request. If the token is expired, they are redirected to refresh the token first. 
Another misconception about stripping binaries in 2016 : that there is any point in doing so. Bill Clinton was President the last time I stripped a binary. 
Generally I tend to agree. However, using Go on embedded devices is becoming more viable. These still have somewhat restricted storage or network bandwidth, so stripping is a useful way of fitting a handful more binaries on there.
What happens if you use `go install`? What error messages do you get?
Thank you both :)
Almost seems like a bare basics introduction to getting up and running with Go, and the GIF generation is a small fraction of part 3. However, it *is* a good introduction, so no complaints there. :)
Would you consider [this repository](https://github.com/hacdias/caddy-filemanager/tree/dev) organised? What would you change? **Edit**: and [this](https://github.com/upframe/fest)?
I know some people prefer to write out "if err != nil {" 1000 times to be "explicit" but I feel pain looking at it because it reminds me of all my rust enthusiast friends mocking Go users. We have first class functions! Errors are values! Why do people do this!
Search for uiterm
I always felt that insertion and selection sorts were much simpler than bubble sort. I never understand why it is used for education.
That guy sure likes stickers
Thanks.
Ha! You beat me to the punch by an hour. I've had the same idea about using context.Context to pass the request parameters. I thought this was the nicest way to avoid locking into a custom context implementation. Though, it has a performance hit. My Project uses the same approach but it is only for learning purposes: https://github.com/synepis/yar/
Assuming you have $PROJECT_ROOT/cmd/mycli/main.go, while at the root, `go install ./...`.
Why not use https://github.com/pressly/chi
The main issue with the std library is that it doesn't coalesce fragmented frames. A client can send a fragmented message and you will have to rebuild them yourself. Gorilla handles this for you.
I agree. Weird decision by /u/campoy .
Stripping binaries also makes it somewhat more difficult to remove any DRM since without the symbol table reverse engineering takes a lot more work. It's not a *good* reason, but please don't make the mistake of assuming this is a size optimisation only.
Why not call it YAHR ?
Because I toyed with the idea of having a pirate for a logo for it :) 
Error handling in Go can actually be very pleasant. Handling errors from packages you didn't write can only be as coherent as those packages allow you to be (ones that don't export their error types are difficult), but even in the worst case you can still eliminate redundant checks by doing something like in [this blog post](https://blog.golang.org/errors-are-values).
Looks cool ;) If someone wants such router, performance is not his main concern. I personally prefer to stay close to stdlib.
The checks are not redundant. The blog post you linked explains _precisely why_ it is idiomatic to check if err != nil 1000 times, because it forces you to handle error values at a given call site rather than throwing a blind exception or wrapping in a try block.
In this case not really needed but indicative of favoring io.Writer. 
Why's that? Efficiency?
I've seen people do this here. I don't mind people posting questions like this and gophers replying with mini-project ideas, anything that inspires learning and collaboration. However, if someone does have an actual place for this I would be interested to hear about it. And my toy project: a source code line counter. I know lots of these exist, but you could use the go parser and do some more detailed analysis of go code. You could count `_test.go` files separately, count how many functions are used in examples, how many functions are used in tests (like a simplified go cover), etc.
I think it's because those are three simple algorithms that can be used to show how to analyze the time complexities of algorithms, later stepping up to more complicated algorithms; my first day of Algorithms that's basically what we did.
It took a while to figure out all the various approaches and see what works best, but the coding didn't take too long. However, if you're just starting out I wouldn't suggest this as a first project because it doesn't really exercise all the fun parts of Go (e.g. channels and go routines). I'll leave it for someone more experienced to chime in on this.
I suppose that's one way to look at it. The curl requests get pretty complex and I don't expect my users to go to that depth. So this is effectively a CLI to that API itself and it does the "cURLing" for the user. 
If there was a need for text formatting before adding it to the buffer I think something like: fmt.Fprintf(buf,"%s %d",a,b) is cleaner than buf.WriteString(fmt.Sprintf("%s %d",a,b)) but if you already have the string ready to go buf.WriteString(s) seems cleaner
It'd be a good project to make such a place.
I'm fairly new to the go programming language but still understand your documentation and examples. Pretty nice, keep it up.
Happy to hear that! Cheers.
Go to google and type "site:github.com" or "site:gist.github.com" + "golang simple" + "chat/websocket/channels/crawler". This pulls up working projects you can start to play with, modify, and pick apart, break, and expand into neat things. Github provides something better than a single tutorial - dozens of projects doing the same thing in a variety of ways so you can learn about pitfalls or benefits of different ways of using Go for the same projects. Does this crawler handle timeouts? Does this mutex based map work as well as a channel based map? Is this websocket library reusing structs? 
 panic("cannot insert the same path twice") You shouldn't panic on everything!
CouchDB is one of the eventually consistent databases, which is probably not what you want for API keys. It'll be easier on you if you can have writes be updated synchronously to all of your read replicas, so that you don't have to deal with "is this an invalid API key or has my replica not been updated yet" sorts of issues. If you already have couchdb set up, it might be easier to patch over it instead of running additional servers though. The JWT recommendation sounds like an easier way to go. I can only offer database advice.
&gt; You see even this I am not sure what you mean. Does "locally" imply that you would otherwise build a web app remotely? "Local"/"Locally" refers to the laptop/desktop computer you have in front of you. Any deployment to AWS/GAE/DigitalOcean, etc is not local. /u/iends is recommending you start small and build a web app that runs on your computer, so you can test it out from the same machine. I second this recommendation. Work on one part at a time, so you're not bogged down by the complexities of getting them to work together. &gt; What other apps are there? and presumably they are more complicated? Multi-page apps are the webapps of the 90's, before the big javascript craze. The web-pages are generated on the server, so there's little to no javascript framework to deal with. Go's standard library has all the tools to build out a simple multi-page app (net/http, html/template). You can focus on learning the server-side code, html, and templates. Once you're comfortable with that, move on to incorporating a JSON API to the site. Then you can focus on building a single-page app using those API endpoints. Single-page applications, which is the target of React/Angular/Aurelia/etc javascript frameworks, are more complicated than traditional multi-page apps because they need all three of these parts (back-end, API, front-end) at once. Each one can be a career, so avoid trying to tackle them all at once. Focus on one at a time and you'll get comfortable with the ideas involved. EDIT: Starting with a small Go codebase will allow you to get comfortable with your text editor and git/github and experiment with different setups without worrying too much about making mistakes. 
Well after checking in depth I like the simplicity of MemcachedDB. Makes me think of Beanstalkd in terms of simplicity to deploy and run (which I use because of that). I like the ACK policy options. I will first try this route thanks. :)
Hm, I noticed something I've probably been doing wrong for a very long time. I notice that when printing an error type in a fmt.Errorf, /u/campoy uses `%v`, whereas I normally use `%s` (I have mistakenly thought that error implements the Stringer interface when it really just has the function `Error() string` and not `String() string`). So have I just been very lucky that all my errors have been string values? 
you might enjoy this talk I wrote some years ago https://talks.golang.org/2013/bestpractices.slide#3
the guy (oh hi, it's me) also says it's a personal choice why is it so "insane" in your opinion?
yup
I'd recommend skipping React unless it's strictly necessary for your project. You're not just learning React, you're learning ReactJS, Javascript, ES6, JSX, Babel, maybe TypeScript, webpack, and probably a bunch of other stuff I'm unfamiliar with. If you're unfamiliar with all of the things you've already mentioned then you'll be doing a years worth of learning before you're even in a position to write something.
I'm currently checking this out. That's kind of neat. Thank you.
As useful as this idiom is, it seems inapplicable for most error handling situations that arise. I also don't see the difference between the above code and just wrapping it in a loop: bufs := [][]byte{p0[a:b], p1[c:d], p2[e:f]} for _, b := range bufs { _, err := w.Write(b) if err != nil { return err } } 
What level of understanding do you have of HTML? Can you construct a basic HTML document with headers, paragraph content, lists, links, images and whatnot? If not, you will want to start there. Once you are comfortable with basic HTML, then you can move onto either learning back-end technologies like Go or further your education in front-end technologies like CSS and JavaScript. Going full-stack hog wild is a bit much to worry about right off the bat. Totally doable in reasonable increments though.
mhmm, /u/nameless912 has told me to not use net/http. So should I or shouldn't I?
I have a very basic understanding of HTML and CSS. I am in the process of learning Go. Yet I dont feel I have a full understanding of the minimum construction of a web application, hence why I am asking.
I'm not the OP, but I can share my opinion... To me, given I'm familiar with what both funcs do, it _feels_ like taking this (unrelated) code: _, err := io.Copy(w, r) if err != nil { // handle error } And replacing it with: b, err := ioutil.ReadAll(r) if err != nil { // handle error } _, err = w.Write(b) if err != nil { // handle error } You certainly _can_, but why... Unless it's a temporary state, or is done for consistency, it just seems silly to use Fprintf with the format string of just one value like "%s" or "%v" instead of just writing that single value directly into writer. Just my opinion.
I don't see how your change and mine are related, sorry. The reasoning behind changing to fmt.Fprintf is to show that rather than having many calls to buf.WriteX it is often preferable to keep it in a call with Fprintf. In this case, though, it is completely a personal preference. As I said.
Thanks so much for this.
Do you know how the performance of `buf.WriteString(text)` and `fmt.Fprintf(buf, "%s", text)` compares? Is it roughly the same, or different? By how much? **Edit:** WriteString is roughly 4x faster than Fprintf approach according to this benchmark, and makes fewer allocations. https://play.golang.org/p/duiMXCfqxU So what I meant with my sample code above is that you're taking something simple and fast, and rewriting it with a version that is less efficient. Like I said, it's completely fine to do if it's done for consistency with the rest of code nearby, or if there's a chance the "%s" will soon become "foo %s bar", etc., and the performance difference is not significant in the context of what's being done.
Are there any objections/drawbacks on using something simpler, like jQuery, rather than React to create simple front-end pages? The JS community might want to go with the newer tech, but for back-end people who don't want to pay the learning-curve price going with easier solutions should suffice, right? Please correct me if I'm wrong.
Do what feels right for *you*, bro. Everyone here will recommend what they learned because they'll think it's the best. My bias should be clear, I started with Gorilla mux and never really looked back.
this is where Lua shines...a single 5mb runtime and your scripts are source, so they are measured in KB, not MB
I love Go, but I would really recommend Ruby on Rails for a dev starting out with web development. - There's a huge amount of material out there for beginners (like the free and good http://railsforzombies.org/ ) - Every decision about the tech stack has already been made for you. This causes troubles for experienced programmers, but for beginners it gets rid of sooo much uncertainty. - Rails is a pretty good example of an MVC file structure for a project. - Deployment (via Heroku) takes care of devs ops.
Are you missing an `export GOPATH`in your rc file?
Hi everyone, many thanks for upvoting and following the Twitter account. In the past 24hrs it's gone from ~260 to over ~370 followers! So awesome. :)
index.html Hello World The key is to just start hacking. 
Your program needs to be in $GOPATH/src/foo/ (or more commonly $GOPATH/src/github.com/username/foo)
The idea behind that was that if you by accident register the same path twice without realizing the router will blow up immediately (when you start the app). I could have gone with the error return approach but it seemed like a one off operation (route registration) that you wouldn't want to handle errors for. 
It's only controversial if you write trivial applications. It is a consensus in any professional development team dealing with highly dynamic requirements.
No, your metaphor breaks down. The quantum physics of web dev is React-drive web sockets. That's suitably far down the list. TDD is to being a professional developer what calculus is to a professional physicist. You can get by without it, but getting the basics down early is going to make you a lot more desirable as a colleague.
I too would like to know about this, could be very useful. How hands off was Swagger? Did it just look at your code and know or did you have to list all of your endpoints?
Did I not answer those _exact_ points? Go away. Your argumentative attitude is the perfect example of why golang community has such a shitty reputation.
https://goa.design/ https://stoplight.io/ (not Go, just a swagger editor)
Well yeah that's why. You usually want to have it in Event Viewer (god knows why) I still do not know what the advantage is of abstracting it from your app into something like syslog. What if you want to route it to something like Splunk ? Also for me there are too many cons / pros for both (single file log and syslog).
&gt; golang community has such a shitty reputation What?
I'm afraid it does. No MINSWAN equivalency in Go community.
A little while ago I created [https://github.com/go-playground/pure](https://github.com/go-playground/pure) which is basically a pure stdlib version of [https://github.com/go-playground/lars](https://github.com/go-playground/lars) that uses context.Context for the params and the performance hit is barely noticeable and static performance (compared to lars) even better for anyone that's interested :)
I think part of the go philosophy is to use as few external libraries as possible. The different web frameworks will buy you some nice features, but I would start with the core and work out from there.
godoc documents code, swagger documents web-apis
&gt; Well yeah that's why. You usually want to have it in Event Viewer (god knows why) If you're not running Windows you usually don't want logs going there....I've seen it setup the opposite direction several times even. Take the one or two Windows servers and have them send their events to a central host along with all the other hosts. &gt; I still do not know what the advantage is of abstracting it from your app into something like syslog. Also for me there are too many cons / pros for both (single file log and syslog). * Less code in your application to manage log files, directly sending to syslog, etc. * You end up configuring logging (file based, syslog, whatever) the same way for everything. * If you're managing dozen or hundreds of applications and dozens or hundreds of applications having every app do something slight different is a major pain and difficult to keep control over. This is especially true if you have a mix of in-house and 3rd party software. * Logging inside of you application, either to syslog or to a file, introduces a possible point of failure if there are disk or network problems. * Bugs in the handling of syslog or files can cause problems for the application. * It's simpler (just send output to stdout/stderr like you normally do locally) I never said the way I was suggesting that syslog is how it should be for everyone. If you're not operating at scale and with multiple applications/hosts syslog does not make a lot of sense. However, handling the log file itself inside the application does not make a lot of sense either for many of the same reasons stated above. Output redirection is a standard construct of the OS and in my opinion is a much better way of capturing the output of the application over having something like --log-file as an argument in most cases. &gt; What if you want to route it to something like Splunk ? You still can. A common setup I've seen is something like this: application@host1 | logger -t [turns stdout/stderr to syslog] -&gt; syslog-server@host1 -&gt; syslog-server@loghost -&gt; splunk/ELK stack Routing is controlled by the daemon running listening for logs rather than your application. If you need to change the routing, do some preprocessing or do something else entirely you modify and restart the daemon rather than modifying and restarting your application. 
Sure, but react is really really good. And the js insanity is coming from the node world, not the react world. With that said, jquery really is fine for a first go.
DISCLAIMER: I'm the author of eawsy/aws-lambda-go. First of all, it does not run in a docker container. The docker container is here in order to provide convenience for those who are not on Linux. In the end, it is a binary compiled for Lambda target system and Mac or Windows developers need a way to cross compile. Second, it is vanilla Go for the end-developer. The end developer writes vanilla Go code without any restriction. You know when you write Nodejs or Python functions for Lambda, these functions are also loaded on top of the AWS proprietary runtime. This project aims to provide an open-source layer which behaves in the exact same way that AWS official ones. Moreover, the provided layer is so Go and AWS idiomatic that if in the near future AWS supports officially a Go runtime, the users of this projects have nothing to change to port their code. This is the key point about this project comparing to the widely used "fork a process in Node or Python to run a binary" method.
Oh man! That was a fast response :D BTW amazing project
The way azure does it is a lot tidier, but it is getting there for AWS at least.
Fair enough. :) I'm man enough to see if I'm wrong. So, yeah. I was wrong. I apologies for the incorrect assumption. It is a cool project! Gratulations. :)
What's the advantage of this project over apex (which also supports go)? Would be interested to see some benchmarks. 
You are using unexported fields on your struct. They need to exported (start with an upper case letter). And if the names don't match, other than casing, then you need json field tags to map the names https://blog.golang.org/json-and-go
Thank you!!
Are you talking about Azure Function? They don't have any Go language support for now. See : https://github.com/Azure/azure-webjobs-sdk-script/issues/354
Good writeup. There have been several similar ones posted in here, and the Go documentation itself does touch briefly on these concepts. But new comers to Go often don't fully understand what is going on when performing operations on strings. It's always good to have easy to comprehend information for them!
That's not the same thing.
 import "github.com/eawsy/aws-lambda-go/service/lambda/runtime" 
The only thing that keeps me from learning React is the crap-ton of other tech I need to learn to get the first page loaded on my browser...
Man! This is awesome! :) I was kind of building something like this as well. I was using React but I suck at it. :D So it's awesome to see a full project from which I can learn. Nice job! Well done. :)
Excellent app and excellent article! &gt; I’m admittedly not an ops or Nginx configuration expert, so I owe a lot to The Google and Stackoverflow for getting this working. Did you have a look at [Caddy](https://caddyserver.com) when choosing the Web server? It provides most (if not all) of the features you requested from Ngnix, and I have not yet heard of anyone having to do extensively research via search engines and forums to get Caddy up and running. &gt; I didn’t want my project code heavily dependent on a third-party framework, lest I leave the project for a bit and come back to find the library deprecated or no longer compatible with updated language versions. A valid concern, givne the experiences in other language ecosystems (most notably Node.JS). I only wonder how big the danger of facing dysfunctional third-party library code actually is in Go, considering that Go has the [Go 1 compatibility promise](https://golang.org/doc/go1compat) (which, in a nutshell, says that the latest Go 1.x will compile any Go code no matter which Go 1 version was used to develop that code initially). 
Thanks for recommending my site and book :) I am glad you are enjoying them both.
I think insertion sort is easier to grasp conceptually, but I feel like it is harder for beginners to translate it into code. I am on my phone and about to go to sleep but happy to discuss this further tomorrow if you want.
Thanks for the write up enjoyed reading it and well done on getting the project completed 
My guess as to why your down voted is because this is a Golang subreddit. But I agree wholeheartedly with you. Ruby on rails already has a more mature community around it. If you get stuck anywhere, you'll find threads on stackoverflow way easier than with whatever you'll find with Javascript or Golang. 
Did you ever consider using pure Go for the HTTP service? In theory it can meet all of your requirements including HTTPS(yay let's encrypt). I wonder if you could also load balance it haha
what do you mean?
...and then there's this counterpoint: https://groups.google.com/d/msg/golang-nuts/liVZE0wTTZw/9qia5WrgBgAJ
No disadvantages that I can think of. In fact I think Go is the best language for backend web development for almost any application, and especially for beginners (I rarely use absolutes like "best", but I think anything less would be an understatement--only in the rarest niche cases would I use a different language). Most languages have a steep learning curve, either because the language is complex or the tooling is. Go makes both easy (to build a Go project, just run "go build" anywhere in the project tree--no Makefiles, maven files, setup.py, project.json, etc required). Further, most languages require an external web server process to invoke your web application; these tend to be complex to set up and deploy--Go's web server is just a module in the standard library, and it's dead simple to use. Go also makes deployment super simple--everything compiles into a single executable file, so deployment is as easy as copying that file onto the target machine; almost every other web language will require you to install a runtime (e.g., the Python interpreter, Node, or Java or .Net virtual machines) and all of your third party libraries; this typically also means configuring the environment so your application's runtime can actually find those libraries in the file system. This is really just scratching the surface of what makes Go a great web language--there are many other reasons (Go is among the fastest, it's easy to learn, expansive standard library, etc). Let me know if you have any questions.
This should help you out https://godoc.org/golang.org/x/tools/cmd/benchcmp
I prefer https://github.com/rsc/benchstat because it eliminates benchmarks that are so close that the difference is insignificant.
This is really helpful, I was under the impression that Go is more difficult to learn. My current situation is that I'm finishing my computer science undergraduate degree this year and I'm focusing on web development as my future career. I know PHP, HTML, CSS and some JS from uni projects but nothing major. The impression I get is that in web development it's best to stick to the newest technologies. Go seems very attractive since I've done some C and C++ projects in the past and really liked it. I have setup my development server and I'm ready to start creating some websites and web apps. The only thing left for me to decide on is the back-end language. From what you describe Go seems like the best choice. That said I did have some people tell me: 'PHP is a better place to start since it's mature and most CMSs use PHP' 'Node.js is better than Go if I want to focus mainly on simple apps and websites as opposed to large scalable systems.' 'Go doesn't have as many libraries and frameworks as other languages and you will find yourself reinventing the wheel and writing things from scratch' How much of this is true?
I think so. The job market just isn't there that I can see. If you're extremely good and well known in the Go community maybe you can more easily find Go freelancing jobs but the market seems pretty saturated based on the availability of open positions. (A somewhat related and interesting read: https://news.ycombinator.com/item?id=12759064) The other point is that most small businesses don't need the performance and scaling ability that Go affords, so by giving some of that up you can usually ship faster with other ecosystems. 
The question is more: What else could you (seriously) consider? Java? C++? Haskell? Node.JS? Python? (Painful, very painful, well ..., please, slow)
Something like Go2 would have been appropriate in 2013 (when the world was still mostly unaware of Go), but now not until 2023 at the earliest. Go has incredible momentum and is being used in some key projects. The downsides to making big changes to Go far outweigh the positives (even just at the language level, assuming this post is correct and a future syntax could be compiled to the same runtime). Most of the stuff people complain about ends up being stuff we are embarrassed about when debating with Rust folks online but otherwise not fundamental. Look at CoffeeScript...many JavaScript folks were certain it was an improvement, but the masses mostly shrugged and it became a dead branch. If I am going to sacrifice source code compatibility I might as well just explore something entirely novel like Pony that goes places no other tool does. The third-party libraries I rely on aren't that obscure.
I was in a hurry when preparing the "response". Now it contains more info. I'll update it with Swift and node.js results on the same hardware in spare time :)
FYI, Go 1.8 should give nice performance boost for Raspberry Pi thanks to [SSA for ARM](https://github.com/golang/go/issues/15365).
Strongly disagree. Mixing code from different versions will be a total mess and probably just kill Go entirely. Its far too early to even be considering Go2, it would just be an exercise in killing momentum to satisfy a few "key influencers". Its important to remember that outside of our bubble, most of the world is just becoming aware of Go, there is no value in confusing them.
Yes according to [the original blog post](https://medium.com/@rymcol/benchmarks-for-the-top-server-side-swift-frameworks-vs-node-js-24460cfe0beb#4039) :)
The mess of the "cutting edge" of the community abandoning their commitments to their Go1 libraries since it will be easy to do so from a tooling perspective as you note, and it will scratch all of their perceived itches so they will all be eager to migrate. Meanwhile, the rest of the world will just be learning about Go and will be totally confused as to the schism.
I'd prefer go-fixable changes only. But actually I don't want a Go 2 within the next decade. There is some cruft that could be dropped, but it only bothers people with cleanliness OCD.
This is again really useful, I'll take some time to play around on the server and see how far I can go with this.
&gt; If that, then a conversion from []byte to string will also need to return an optional error. Yes, because every time you're converting from []byte to string, you're possibly committing an error. Right now, there's just nothing to tell you about it. &gt; Also, for many use cases, you will want to limit the allowed characters depending on application, making the check redundant You can't "limit the allowed characters" until you know that what you have *is* characters. &gt; and in other use cases you want to preserve the underling data even if it is not valid utf8, where the []byte type is not as descriptive. A string without an encoding *is* a meaningless bunch of bytes. It's more descriptive, not less. &gt; Most software can handle invalid string data well, such as displaying a �. I don't see why you need the programmer worry about it every time. I have no words.
Nice thread link, thanks, I'll read into it.
Good lord, if this happens early enough, we'd have millions of questions asked, like they did about Python, 2 or 3? I frankly think that it is too late and too early for thinking about Go2.0, if it were a few years ago when the world was quite unaware of Go, then it'd have made sense to clean up the language(if it åctually requires cleanup), but now, as the world is beginning to understand and appreciate the power of Go, it would not be wise to make breaking changes to the language.
PHP runs something like 80% of all website. it is most definitely you'll come across it if you create websites for a living. I'm more of an enterprise developer and only do website for lunch money. So far I have not had to deal with wordpress/drupal. I think you should post in /r/webdev to get a better answer. Either way, don't stop with just PHP. I have been a developer for 15+ years and am still learning new stuff.
http://www.skillsyouneed.com/write/capital-letters.html Rule 1.
&gt; No you should be excited. No thanks. Personally. I'd rather see Go keep going with version 1.x and keep the compatibility promise as they have been doing. Java has been out 20+ years and it's still in version 1.x. In fact they do this marketing trick where they advertise Java 1.7 as Java 7. Also, I get much more excited when we get a new Go version with zero to none language changes and a bunch of performance improvements.
I highly recommend this talk by Audrey Lim, as it gives the answer to question better and more convincingly than I could. https://www.youtube.com/watch?v=fZh8uCInEfw (Spoiler: I think it's fantastic choice as a first backend language.)
So now if you're writing a library, do you choose Go 1 or Go 2? Obviously the former because that's where the users are. Now if most library developers follow suit, the transition will be slow, just like it was for python.
I love Go, but for a solid base of understanding, I'd start with C or C++. 
Buildbot.
Can't you use the new application ELB it supports HTTP2? https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/
Isn't that the point of this article?
Except that Go's gRPC performance is slow. It may be just that benchmark is written with no optimizations but it is still a lot slower than C++. 
Many languages can introduce new functionality without breaking backward compatibility. If Go 2.0 is defined as breaking compatibility, then I don't see the need to ever have one. Java is not in 2.0 even with so many more years of development and additional features. Go also don't have the Java problem of running on old a old VM. If someone what to make a Go like incompatible language, don't call it Go 2. You can even call it GOTO for the pun. You can also do whatever you want to call existing Go code. Personally, if I hear Go core devs talk about breaking compatibility that would require migration stages. I will stop developing new code in Go. Small changes like where you just have to rename something is fine.
I didn't see mention of new features in 2.0. Of course, I'm wondering if it will include generics or not. :) 
Another idea if we were to have a Go 2.0 is to restrict syntax changes to be such that we could have a tool that could automatically transform code from Go 1.X to 2.X. This could be done in conjunction with Dave's idea to ensure the barrier to switch syntax and standard library packages is minimal.
Go 2.0 gets released, tons of library authors port their code to 2.0 and stop maintaining the Go 1.0 versions of the libraries. And now I'm forced to port a Go 1.0 project to Go 2.0 if I want to get bug fixes for the used packages, because I can't call Go 2.0 packages from Go 1.0 code. :( And I have to explain to my customers why they have to pay for this. I've seen this pattern before with certain full-stack web frameworks for other languages, and it was an unpleasant experience, especially for large projects. 
 &gt; Backwards compatibility is not about syntax or features, backwards compatibility is about investment. So glad that there are sane people designing and influencing language. Too many of new languages care about everything except long term investment of their users (I'm looking at you D, again, how many libraries and people come and gone while you kept breaking your spec with every patch? You could be Go 7 years ago, if you understood difference between "not mature yet" with "immature by design").
 Whatever your job is please know that suicide is not the answer.
This is a great list of things to know, but it could be too much learning to present at once. I think there is a lot of value in starting with a few things. For instance, I think Git is my most important development tool (short of a compiler maybe if you want to nit-pick), but my team has hired new grads who had never used source control. They learned it in a couple hours of tutorials and follow our guidelines for change management with few hiccups. They absolutely need to use it, but I don't care if they know it when they start. Likewise, if the OP uses coding for a hobby, Git might become necessary quickly to collaborate with other people on Github. But the tech itself is simple and will present itself when it becomes necessary. I fear that despite your great list, the OP already seems to be suffering from far too much "noise" in selecting a starting point. This is just one example since I think you have a good list and we can both agree on the high necessity of Git. In this regard, I think /u/nameless912 has the best recommendation overall, though I would probably have suggested starting with bare standard library instead of Gorilla (though that is still an excellent library and toolkit to check out very soon). The hardest part of coding in the beginning can often be writing a couple lines of code and hitting compile.
Part of the "not as many libraries" comment seems to come from the a lot of Node libraries use tons of dependencies where Gophers tend to try to inline simple functionality that doesn't need to be hidden away in a library for no fantastic reason.
I understood point to be "How to avoid Python2/3 and D1/2, if possible at all..."
Someone posted recently asking for ideas. You could see what they suggested here: https://www.reddit.com/r/golang/comments/58sznm/resources_for_learning_go_by_creating_something/ I think it might be fun to add more to the tooling. My last project I never finished was a "unused code" finder that was based off [deadcode](https://github.com/tsenart/deadcode). I remember at one point I wanted a unit/measurement library, python has some good ones like [pint](https://pint.readthedocs.io/en/0.7.2/). And you could always look into supporting other projects. I've always been interested in [gonum](https://github.com/gonum) but I've never taken the time to learn it. Another idea would be to make some kind of "test tester" for `go test`. The idea is to take a test that passes, change the input and make sure it doesn't pass. I have no idea if something like this is possible (first you have to make sense of when you can/should do this). I've had table tests in the past, but I screwed up the loop over the table so I wasn't actually testing anything. Edit: I just realized gonum has a unit package.
freelance and small teams won't care what language you use to accomplish a task typically. I would recommend Go for the simple reason that it's a fantastic language and the places it excels best are possibly being easy to learn, being easy to understand others' code, and being easy to keep up reason about. For me, it is the fifth most used tool after C#, JavaScript, Python, and TypeScript because of my employer. I still love to work with Go because I feel like I can be great at Go with only a little effort now and then. The opposite is true with C#. It has so much in the framework and so many handy shortcut adding keywords and libraries that I don't know that I'd be an expert if I only used it on hobbies. As far as Node and PHP go, I would discourage them. You'll learn enough JavaScript and TypeScript over time (if you're doing web) that you'll probably wind up adding Node to your toolkit anyway, and Node is a LOT of layers of JS to learn at first. For PHP, it isn't the future. There is plenty of work there, and there might be forever, but PHP developers seem to make a lot less money overall, and they get teased a lot (unfairly--people shouldn't really be so opinionated about languages) by other developers for using a language that makes a lot of clunky decisions about syntax that don't match any other languages. You can write fantastic PHP, but it has a bad reputation, and I have never felt the need to add it to my career.
Looks like you have to have Github account for that... well, one day ;)
Methods like Thread.stop() are deprecated since Java 1.1 (1997): https://docs.oracle.com/cd/E19455-01/806-3461/6jck06gr5/index.html And still available in Java 8 (actually 1.8), 20 years later: https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#stop-- 
They really should fix the `make/new` ordeal. And non-latin characters not considered as upper case. :)
If you want to keep things pure-Go, I've been replacing my Makefiles lately with code like [this](https://github.com/nstratos/make.go).
Ahh, nice. I actually searched the page for "generic" but didn't try "template". Thanks.
Which is 1.8
How is Go a replacement for JS? Asking as a noob here. Is it a replacement for node or can it do a lot of front end UI tasks much like a templated framework like Python's Django?
Thanks. I was considering this one already and this comment adds a bit weight to this option.
I second Buildbot. [Here](https://github.com/rust-lang/rust-buildbot) are the configs from Rust if you need a starting point. 
The context of the conversation is programming language for backend applications, so its competition would be Node and PHP. I'm not especially familiar with Django, but I suspect that Go has a lot of the same components (HTML templating, JSON support, HTTP support, etc), but perhaps less integrated since Go is much more general-purpose than Django. The Gorilla project in particular might be a better analogy for Django since it's a framework for building web applications in Go instead of a loose collection of single-purpose libraries (e.g., Go's std lib). Go can also compile to JavaScript by way of GopherJS, but I don't believe this is actually used in production anywhere. Hopefully I answered your question?
I am going to take your example as being close to what you want to do, because it's very hard to answer such a general question. I would create an interface that captures what information I actually want to use these various types for. For instance, we can derive lat/long from both named locations and coordinates, so I would make those two types implement the following interface: type Location interface { Coord() (lat, long float32) } and then your snippet in main() could go in a function, parseLocation, that returns a Location. If you want examples in the standard library, look for parsing code. For example, look at the types in the go/ast package and how they're returned from the go/parser package, or the Token type in the encoding/xml package.
what's wrong with the container/heap package?
Will the default $GOPATH available in shell or just used by go tools?
Maybe not no libraries, but lack of mature libraries in the data mining space. 
SNMP MIB SMI parser I would love to have the equivalent of SNMP4J-SMI in Java or snmptranslate from net-snmp. http://www.snmp4j.org/smi/doc/
https://github.com/golang/go/issues/17262#issuecomment-255894942
Unless a Go1 application can call a Go2 library, all library developers will continue developing in Go1. If this is a case, the community will probably split like the Python community did.
The idea is neat. A good start for learning Go. Separate some of that code out and make sure you use go fmt.
All of our projects have a Makefile internally, and we have this at the top of our Makefiles: export GOPATH = $(realpath $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))/../../) export GOBIN = ${GOPATH}/bin export APP = $(shell basename "$$PWD") By doing this, you are ensuring that your GOPATH is two levels up from your project path. For example, given repo/src/project/Makefile, your GOPATH will be repo/; this only really works well if you use a unirepo/monorepo though, so YMMV. For very large projects/multiple projects/teams, I highly encourage giving unirepos a try.
use two terminals 
Personally using this in some bash script: export GOPATH=$(echo $(pwd -P) | sed -E 's#(.+)/src/.*#\1#') Just in case there are more than two levels to go up. Working well so far.
Why not just use the vendor directory? If each project has its dependencies in its own vender folder, then all your projects can live happily in the same GOPATH without any issues. You can still use multiple GOPATHs if you really want to, but the vendor directory fixed the problems that made multiple GOPATHs necessary, and IMO it's more elegant. Furthermore, this proposal doesn't take away your ability to use multiple GOPATHs. It just makes it easier for new users who haven't learned about the GOPATH yet, or those who are happy with the default.
*slow clap*
If the Go stdlib were tossed out and rewritten, would container/heap simply not exist at all, or is there a better way to implement it? The heap algorithm is easy enough to implement as needed, but useful enough that I was happy it was in the stdlib when I needed it.
I see what you mean, but that's really not in the scope of things that the Go authors can "fix". If you want to get `$GOPATH/bin`into your `$PATH` without knowing what `$GOPATH` is, you could always do something with `go env` to extract that path. I still think this is a good change, as now you can compile things without environment changes, and most people don't start off by running go get'd/install'd binaries anyway. Everyone who wants to set `$GOPATH` will do so anyway.
Session caching for TLS. Go crypto only implements ticket caching. Some major servers only support session caching. 
Aha, it looks the unsafe.Pointer callings will make some side effects. But I can't confirm it now. package main import ( "unsafe" "runtime" ) func printMemStat() { runtime.GC() var stat runtime.MemStats runtime.ReadMemStats(&amp;stat) println(stat.Alloc) } type sliceStruct struct { ptr unsafe.Pointer len int cap int } type stringStruct struct { ptr unsafe.Pointer len int } func fc() (int, string) { bs := make([]byte, 1&lt;&lt;20) //print(((*sliceStruct)(unsafe.Pointer(&amp;bs))).ptr, "\n") // this line will make side effect printMemStat() str := string(bs) //print(((*stringStruct)(unsafe.Pointer(&amp;str))).ptr, "\n") printMemStat() return len(bs), str // len(bs) is to avoid bs being GCed. } func fd()[]byte { str := string(make([]byte, 1&lt;&lt;20)) //print(((*stringStruct)(unsafe.Pointer(&amp;str))).ptr, "\n") // this line will make side effect printMemStat() bs := []byte(str) //print(((*sliceStruct)(unsafe.Pointer(&amp;bs))).ptr, "\n") printMemStat() bs[0] = byte(len(str)) // avoid str being GCed. return bs } func main() { println("=========== fc") n, s := fc() println(n, len(s)) println("=========== fd") bs := fd() println(bs[0]) } Outputs: =========== fc 1083952 1083952 1048576 1048576 =========== fd 1083952 1083952 0
Just added [node.js results](https://github.com/valyala/swift-response#just-for-fun-nodejs-performance-on-the-same-hardware). Conclusions: - node.js is more than 10x slower than Go in both throughput and latencies; - node.js doesn't scale well to 20K concurrent connections.
[Switched the code](https://github.com/valyala/swift-response/commit/6750c28ab16bbd20d58259f5ebcd8c3490e283ed) to `net/http`.
I use a vendor directory with glide.
The newcomers are going to love that (without realizing it)! The experienced will have their GOPATH set to whatever they want/need anyways!
I personally prefer it to be set directly to $HOME
It just got the go ahead today :)
Thanks, that's what I want.
Worst spelled article I've read in years
Thanks, `go env` is the way.
It would be complicated to explain all the advantages of AWS Lambda against a dedicated server here. So I invite you to take a look on the AWS product page of AWS Lambda here : https://aws.amazon.com/lambda/details
I work on projects with tons of deps as well. But it still sounds like you aren't using the vendor directory. You also seem to not be reading what people are typing. Regardless of how complex the projects are, the vendor directory in each one will get selected first. 
&gt; with dependencies at different versions... So this is the root of your problem. I see now. Keeping dependencies clean and as few as possible is good development practice. Unfortunately I cannot see your project to judge how important are those dependencies that they have to be different versions but it's a bad sign that leads to a harder to maintain project.
That is not what you should be taking away. Glide or godep doesn't matter. They just help get the packages into a vendor directory (ideally). The official go tool supports the vendor location. So a single gopath works regardless of your package manager tool. 
What's wrong with having 10 directory levels if the project needs them? But does it? This does not justifies having different GOPATHs as far as I am concerned. But if it works for you then ok.
&gt; If I have a single dependency in my GOPATH that conflicts with a single dependency of Kubernetes (of which there are hundreds)... then I have this problem. Uhh... are you telling me that you are using Kubernetes as a library? But even in that case, Kubernetes has it's dependencies vendored. How can they be conflicting with your own dependencies? Either I do not understand the problem or you do not understand how vendoring and the tooling works.
 &gt;Instead of answering my simple question that came about as a result of real world Go usage... I was repeatedly told I was incompetent, despite no one addressing the actual content of my question. Let me ask you, if you have two projects that have vendored dependencies, and you have opted to use godep which uses GOPATH as its staging area before vendoring into the target project, then how does it actually matter in practice if the GOPATH is mutated in the process? Wouldn't each project continue to use the vendored version? Now if I am still missing something, then I am sorry. I switched to glide a little while back. But even when I was using godep, I still have always ever set a single GOPATH once. 
many thanks for the explanation and clarification! I suddenly realized that the assumed fc and fd optimizations together would make the walkaround, f2, in the **More About Substring** section become invalid. BTW, in the walkaround f2 function of the **More About Substrings** section, there are two copying actions for the underlying bytes. So I think adding an optimized strings.Clone function would be great. The strings.Clone function will always alloc a new memory block and only do one copying action. 
You're typing sentences that does not attempt to solve any problems here, instead they comes off as someone throwing pebbles from an ivory tower. 
so don't change it on your machine then
Try reading the article next time.
basically yes. For all the negative feedback you're getting in this thread, it does basically boil down to: - If you have trivial dependency trees, use a single common GOPATH. - If not: use a smart dep tool like glide or use multiple GOPATH's. It's a problem. I know, lots of people would like to pretend its not a problem, but, as you've obviously experienced... it really is; it's widely acknowledged as a problem. On the bright side, there's an active working group trying to solve these issues; you can get more info [here](https://groups.google.com/forum/#!topic/golang-dev/Og1p9ECURBI) or by visiting the #vendor channel on the gopher slack. :)
To be clear, the proposal would permit Go 2 code to call Go 1 code.
That's nice, but it doesn't solve my major annoyance with Go, which is that it doesn't let me work on Go projects checked out to arbitrary locations (for example in my "code folder" alongside the rest of my projects), without either having some mechanism in place to change my environment variable for me, or remembering to do it manually. 
This is fucking stupid.
It's interesting to me that for their packages they take the philosophy of preferring libraries to frameworks, but for the tooling it's more like a framework where it fights you if you don't do it their way. This change -- sort of -- helps people get started, but I'd rather see easy ways to use go outside of a gopath, so my code can live next to all of my other projects. 
Iris broke my code so many times that i cannot remember(had to switch to GIN) (API breaks without warning,commit history deleted (multiple times,including my Pull requests))
&gt; "Make the zero value useful." - Rob Pike About time!
It is not just a worker queue. You can also create functions to be called from a web front-end or an mobile application through API Gateway, so, it can be your web apps/mobile apps backend.
From what I gather, the idea is that if you want to use it without being subject to AGPL, you need to buy a enterprise license.
Why?
For this use case, an empty interface is fine, and there is nothing occurring which necessitates a more broad language-level "generics" implementation. If one wraps the relevant functions with the necessary type handling, runtime errors should be a non-issue. This is similar to the standard library implementation of the context.Context interface. Please review http://research.swtch.com/generic.
Another excellent talk by Katrina Owen.
Curious question, why do you need multiple gopaths?
I agree. I really can't see how this proposal can help beginners. They will still create a helloworld.go somewhere in their disk which is outside the GOPATH (e.g.: ~/Sources/gotest), they will try to build it, and it will fail. I have a proposal that is more comprehensive, and would fix the situation for beginners: https://github.com/golang/go/issues/17271 Unfortunately, it partially conflicts with the proposal that was approved, so I will have to rework it.
&gt; And I doubt you'd be fine with a library using interface{} everywhere in place of well defined types. If the situation requires it, and it is reasonable. context.Context is a good example as previously stated. Using hyperbole adds strength to a position when it's subject (or it's subject's nature) is emphasized, but not when it's subject becomes convoluted/disconnected. While interface{} can be used everywhere, negating it because of that fact is poor reasoning. Using interface{} is a cause for reconsideration of a design, and, if still elected, cause for due diligence in implementation, but it should not be treated as forbidden. &gt; We are basically opting-out Go type system in order to perform an operation that cannot be described by Go type system... Yep. Based on the link provided, it should be clear that the responsibility for correctness of genericity must be placed somewhere. In the case of Go, specifically use cases like the one we are speaking of, that place is with the developer. I understand that your opinion is that you do not like this fact. I understand that I accept the decision made by the Go team, and I do not apologize for that. If there is an acceptable generic solution added, I will be content, but while I have no solution to offer for everyone, I will solve the problem on a case by case basis.
I don't necessarily **need** them but I find it cleaner. If I go get something then it lands in my ~/libs/go folder, where it will happily live. My personal projects largely live inside ~/projects/go partly because the ~/projects folder hosts a large amount of stuff in it. It's a reasonable setup IMO, it keeps things seperate (at the cost of some pain when some random library doesn't do proper makefiles)
Not everything afaik, they removed some stuff.
Awesome session /u/campoy, I have really been enjoying the series so far. Keep it up! :) 
You can use the shell for that: `${GOPATH%:*}`. Or sed or whatever, there is no need for a new tool.
&gt; The context of the conversation is programming language for backend applications, so its competition would be Node and Python. Don't forget Java &amp; C#.
There is a pair of tools to accompany the paper: https://github.com/nickng/dingo-hunter and https://github.com/nickng/gong
Java and C#.
Golang needs lambda expressions
I mean, use maps for hashset and container/heap for pqueue. Pretty weak points by the author. But really, if you need speed above all else, don't use go.
What version of HBase are you looking at? I haven't heard anyone mention Stargate in forever. HBase now just calls the HTTP API the "HBase REST Server". As far as Thrift, I'd avoid that as well. Around HBase 0.96, the project moved toward using protobuf solely for client integration. Even the REST API uses the protobuffer API internally. Thrift might still be supported, I'm not sure, but there hasnt been much activity in the `hbase-thrift` project for quite some time. Lazyshot's go-hbase client is based on the protobuffer API, and should work well on anything newer than HBase 0.96. I've successfully used this library for some minimal testing I did with HBase 1.2. If you want to avoid protobuf, the REST API is actually fairly easy to use, though trying to query a lot of data can be problematic. I didn't try any existing libraries to do this; it seemed unnecessary. `net/http` was sufficient.
GOROOT is where go should be installed. That's different than GOPATH. It's usually better if Go is installed system wide. I keep GOROOT as the "default" `/usr/local/go`. If you have Go installed system wide by having something like`GOROOT="/usr/local/go"` then each user can have their own GOPATH which might be different. This really helps if there's many users using the same machine.
Where are you publishing this? I'd also be interested in this. I have a few sites already in Go, but auth still seems to be one of the hardest parts.
My best guess for the downvotes is that the title is a little bit misleading.
Any suggestions for changing it? I originally had more on it making it specific to the database SQL package, but it was sooo long. I don't love the current title but I also didn't know what else to use :/
Really? I have used the SQL package for a while and have never read anything explaining this. I don't doubt that it exists, I am just shocked I never ran across it.
I don't remember how I learned it, I either read [Effective Go](https://golang.org/doc/effective_go.html#blank_import) or googled "golang import _" You are right that someone might miss it. Looking back, most packages seems to assume import _ is common knowledge.
Maybe something like "Why we import SQL drivers as the blank identifier (_)" Unfortunately I can't edit this post but I can at least change the article.
It worked exactly the same for me. I don't think it's a bad title, on the contrary. The job of the title is to be little bit flashy as long it's not too "click bait-y". So I think it serves its purpose. It did for me at least; I don't know about others.
Thanks for linking the part in effective go. Definitely useful to reference.
Ooh nice. We tried Hound for a while but ultimately found it clumsy and annoying. I've been wanting something like this that is more flexible.
On one hand I appreciate the rundown of which sites support Go. I didn't know hackerrank did before your post and I'm glad to know it now. On the other hand, I would argue that a language having a place in the competitive scene isn't based purely on speed or verbosity of the code, but rather it is about allowing more people to compete without having to learn a whole new language just to get involved. Every person I know who did or does competitive programming like this does it with whatever language they are most familiar with. They don't learn a new language because it is faster (hint: c always wins) because 98% of the time that speed difference doesn't matter. Any high quality problem shouldn't come down to "if you coded it in c you would have passed but x is too slow". Those types of problems don't really teach you anything and they aren't typically fun. The scanner class in Java is crazy slow compared to using a buffered reader yet I think I have only seen this be a real issue once on an obscure site (spoj iirc) and as a result the number of Java programmers who completed the problem was incredibly low. I suspect this is part of the reason why topcoder doesn't even use stdin for input. The spirit of these competitions is all about coming up with algorithms that are fast enough in big-o terms, regardless of implementation language. If a site is leaning heavily towards problems where that isn't the case it doesn't mean there isn't a place for Go. To me it means that the site itself is losing focus and writing bad problems. I would rather see support for more languages than less, and I commend hacker rank for supporting so many so well. Regardless, the article isn't bad. I just disagree with the premise that there isn't a place for Go in the competitive scene.
`golang` is better be used as meta information for searching purposes. Just tag your article with `golang` and then there's no need for unnecessary "Golang" in the article's content. Besides there are other parts of the article where you mention the word "golang" with appropriate usage this time. &gt; so the first thing I did was Google "golang sql" So I am pretty sure the article will be found regardless. 
Looks good! What are the java pieces used for?
Same with image format decoders: https://golang.org/pkg/image/
I would be interested as well :-)
The reason of existence for the index variable in for-range loops is to make it possible to access the current element via the [] operator, but you can't access a position in a string with s[runeIndex].
Thanks for feedback. Could you provide more details, namely what is the output of `gonote list` and what type of OS are you running?
Does Fragmenta really support SQLite? It's mentioned in the docs, but... After a quick grep'ing, I can't find any other references to "sqlite" in the source code.
I'm not sure if your post was intended to be spiteful, but unfortunately I can't find any way to use it as constructive criticism. If you want to criticize my writing and code based on poor code, bad design, or really anything that would have a negative impact on people learning Go then I welcome it with open arms. In fact, I'll even give you a early access to my book for free so that you can provide feedback as I write. In the end it will only make the content better and that is what I ultimately want. On the other hand, criticizing me over not putting 2 and 2 together in this particular case seems pointless. It isn't improving anything, and I think this blog post in itself proves that I understand Go well enough that when I don't know why or how something works and decide I want to find out I am capable of doing so. Or perhaps after reading one blog post you have decided I am not qualified to write a book about using Go, in which case I will just have to respectfully disagree and let the book speak for itself when it is finished.
Fair point -- actually that makes me withdraw my complaints about it. 
&gt; I'm not sure if your post was intended to be spiteful, but unfortunately I can't find any way to use it as constructive criticism. It was neither. I wasn't trying to hurt you, but I also wasn't trying to criticize you. I was commenting on the apparently poor state of CS literature. This post enforces my belief that CS books seem to largely be a cash grab by publishers without adding any real value and that I should be weary to buy any.
Honestly: It was a mistake to make range over `string`s behave differently from `[]byte`s. It would've been better addressed by building a rune-iterator into unicode/utf8. This way * People assume strings will always contain valid utf8, which is false. * People assume iterating over runes is the best thing to do, which is *especially* false with the last point. * People get confused by the fact, that those two very similar types create such different behavior.
Thanks Veonik, that actually helped me a lot. I was just switching to the REST API, but wasn't sure if ditching thrift was a good choice.
I currently use siege. Would like to know as well. 
instead of var m interface{} json.Unmarshal(b, &amp;m) f := m.(map[string]interface{}) do this https://play.golang.org/p/CU3vlKvZ8k var m map[string]interface{} json.Unmarshal([]byte(`{"Name": "Quoll", "Order": "Dasyuromorphia", "id":1}`), &amp;m) fmt.Printf("%+v", m) see also example in https://golang.org/pkg/encoding/json/#Unmarshal which uses a struct instead of map[string]
Agreed. These days it's more about quantity than quality.
This would add complexity to the language, just for some minor syntactic sugar.
Sorry, I don't see your point. You say it like I don't agree with you, which I obviously do.
There's also [Vegeta](https://github.com/tsenart/vegeta)
It certainly does, thank you! Impressive performance.
just wrap the untyped functions with your own typed ones for the type you need and use this wrappers. then you have you type checking.
Would love to receive one as well! :)
Actually, there is [this](https://github.com/codesenberg/bombardier/wiki/Comparison-to-other-tools) wikipage. It has a [section](https://github.com/codesenberg/bombardier/wiki/Comparison-to-other-tools#vegeta) about *Vegeta*. AFAIK *Vegeta*'s garbage generation(high) and performance(low) haven't changed since then. Feature-wise both tools are somewhat similar, expect for UI and some knobs(*Vegeta* supports multiple targets, HTTP/2, rate limiting, cert specification and redirects).
From what I could tell in a couple issues, it looks like the author doesn't have a way to test on Windows. Did you look at it on Linux?
Take Go's philosophy on documentation: it's extracted from comments. Idea being that the closer to the source the more immediate the redaction, leading to better documentation and avoiding the paint to write documentation separately and keep it in sync. Also, Go is a "Get Shit Done" language: you don't design Go programs as you would design a Java project. You write the code, prove it works, then generalize and clean up the mess. What you're left with is clean, idiomatic Go. Extrapolating from those two points you may see how backwards the concept of writing and maintaining an UML diagram for a Go program seems to a gopher.
Eliane (/u/lesarchitectures) will be here to answer questions if any! Overall it was much more time-consuming than we expected but it was a ton of fun, for us and the attendees :)
My counterpoint to this is that I would rather you judge my book, or really any book, writing, or courses based on the quality of the content. It sucks to be used as an example of "the poor state of CS literature" when you haven't even read my book to validate that claim. For all you know I could have written the best book the Go community has seen to date, but you have already dismissed both my book and likely most of my writing as having no value or being a cash grab because I didn't immediately understand something that you think should be obvious. I completely disagree with that sentiment and am offering you a copy of the book to persuade you otherwise. That isn't to say that others might be writing for the wrong reasons, but it frustrates me to be lumped into that category after spending months working on a book with the hopes that it will help people learn to love Go like I do. PS - I have been using Go for several years. I have also been a web developer for much longer, giving me a fairly decent background for writing this book.
Please don't post pictures of code ...
I see a lot of `map[string]string` as function arguments. I cannot blame the author, it is not easy to both build a web app _and_ satisfy idiomatic Go.
It depends on the definition of strong typing. When it goes to interface type values you're allowed to only call methods from that interface. Having f.ex. empty interface type value (which is satisfied by all types) doesn't allow to call arbitrary methods. Of course having such argument allow to pass any parameter. In other cases type assertions are needed first. They hold if dynamic type is identical to the one from assertion.
I agree there are some sites where coding in anything but C++ is a disadvantage, but I still hope that more sites like Hacker Rank support more languages because it serves as a great entry point for people who might not otherwise experience competitive programming. The top competitors may not ever use Python, Ruby, or even Go, but there are still a large number of competitors who will only be introduced to competitive programming if we support these languages. Because of this, I hate saying "there isn't a place for &lt;x&gt; in competitive programming" because it only serves to dissuade companies like Hacker Rank from continuing their efforts to support more languages. There is a place for Python/Go/whatever in competitive programming. It just might not be the same place as C++.
Note that this doesn't do any actual video decoding, it simply transfers the bits and lets you know, based on the duration that you provide, when you can start watching the video assuming your bandwidth stays relatively constant.
Oh! I just skimmed through the readme. Thanks for clarifying. 
It requires changes to go crypto. They only support ticket session caching. 
In a previous life, I had to interact with an array of SOAP systems (mostly for carrier services like FedEx and UPS). While I was seriously considering writing a SOAP package for Go, the biggest issue I kept running into was Go's static typing (I wish I still had access to that codebase so I could give some concrete examples). In the end, the method I used for making SOAP calls, was to stuff the XML into a `text/template.Template`, and littering the template with `{{.SomeField}}` interpolations, then executing the template with either a struct, or `map[string]interface{}`. This approach worked surprisingly well, as it was easy to become acquainted with - and modify if necessary - since it was just a large, raw string. It was also pretty fast, because we were avoiding all of the reflection-based stuff in `encoding/xml`. EDIT: Also, I recall there were a few occurrences of some SOAP APIs using ISO-8859-1 encoding (as opposed to UTF-8), which threw a few wrenches into the works when trying to use `encoding/xml`. Again, I wish I had access to the codebase so I could provide some examples.
Woah... this is amazing. A set of structs like this is exactly what I was hoping to find a way to do. It almost feels like cheating to use this... hahah. Thanks for the tip!
Sorry about that. I couldn't get the json chunk to format correctly. I'll figure it out for next time in case I ever have to post something like that again.
I think it's deeper and not exclusive to our field but rather a more degradation of authorship in general. It is so easy to slap a few pages together and call it a "book" these days. In a way it's a win for liberation of knowledge, but it goes back to information overload. We don't have the age old publishing firms and market forces acting as a quality filter. These days anyone can self publish on Amazon, LeanPub, and the rest. It has it's pro's, but it also has the watering down effect. This phenomena isn't exclusive to Computer Science (albeit I will say that calling a book about a programming language or a tool a "book about CS" is roughly the same as calling a book about how to use a telescope a "book about Astronomy"). In a lot of ways, I view these "books" as glorified blog posts in an organized fashion that I happen to pay a fee to view.
&gt;The point is that Go can help data scientists produce deliverables that are actually useful in an organization and that they will be able to support. To able to deliver, you'll have to have a product first. When Go has something that can compete with Python's Scikit-learn, then we can talk about delivering products.
&gt;We don't have the age old publishing firms and market forces acting as a quality filter. Spot on.
This looks like a very useful tool for developers using any language and even people in related fields, yet it is - like many other projects - only posted in /r/golang, a very limited audience.
It will happen in time. The Go community now is where the Python and scipy community was 5 years ago. 
Submit a PR.
Hey, this is cool, however what I like about ours is that it accepts arbitrary input schema, pretty much whatever you can specify as JSON can be dereferenced via dot-notation in the template itself. Thanks for linking to it. We're actually relieved that other people had a similar idea, but I couldn't find anything up until now.
Go doesn't use pull requests. 
I think the important thing is the investment and support from the people who get paid a lot of money. Without support it's not going to get there. 5 years is a long time. Go was designed with networking, distributed applications in mind. So, it moves very quickly in that space. I don't think it was designed with data science in mind. Without money and manpower, it won't be that far from where it is now in 5 years. 
I am not posting this in /r/devops and still get downvoted?
Python in the data science world got to where it was through grad students faculty, and open source contributors. 
yup, you need an interactive session to perform EDA, running scripts wont make it anymore since jupyter came to the stage.
I might be mistaken, but this does the same: https://godoc.org/golang.org/x/time/rate. It also supports cancellation.