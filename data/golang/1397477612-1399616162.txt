The Zeus Version 3.97s has been released. In terms of Go, this release adds support for the goimports utility and updates the ctags database to match the latest Go 1.21 release. http://www.zeusedit.com/go.html **NOTE:** Zeus is shareware, runs natively on the Windows platform and runs on Linux using Wine. *Jussi Jumppanen* *Author: Zeus IDE* 
Looks nice but it seems like your code does not use termcap / terminfo. Every terminal accepts different control sequences, just because the control sequences you use work on an xterm doesn't mean that they work everywhere. People have developed termcap and terminfo (databases that contain information about what terminal accepts what control sequences) to work around these issues. If you want to have a getline implementation that works everywhere, try using termcap or terminfo.
I'm not the author, but this is a deliberate design choice as it was with [linenoise](https://github.com/antirez/linenoise).
So it's a broken piece of code that assumes everything is a VT100 (hint: it's not) like other programs that assume an int is 32 bits or every machine is little endian. I'm still waiting for a proper solution.
terminfo / termcap is extremely complicated, but that's what you have libraries for. I agree, it would be a good idea to write a curses replacement in Go that combines all terminal-dependent code into one module.
You are exactly right. Should be pretty straight forward. The only tricky part is right now I am hiding the History implementation from the user. So need a way to expose that so they can call save/load on it. Pull requests are welcome :)
I see one useful side effect of the non-pointer version to enable copy-then-modify patterns: func (t T) WithValue(v interface{}) *T { t.value = v return &amp;t } But other than that, I don't know that I really would want ever pass by value otherwise. Is the performance impact and code confusion really worth the safety of reducing side effects on gets (or am I missing some other valuable aspect to it)? [Edit: Corrected my return value to reference t. Thanks for noticing uncreativemynameis.]
I think it is clear what you're saying, but I also think that it could be implemented with something like vgo (well, to some extent, since not all methods are necessarily covered with a constraint by vgo).
Agreed. Kind of doubt an hour between registration and the keynote will be enough time.
It's a little weird that pointers have two different roles. One, they signal that a call should be done by reference instead of by value, and two, they make a type nullable. In practice, this isn't a problem, but from a conceptual point of view, it's odd. 
I would consider it to be one role: "Point at a location where a value can be found, and that location can be 'nowhere'". The "nowhere" part is important because otherwise the default value of a pointer would be very strange (what is the value of `x` in `var x *ValueType` if not `nil`?) Now, you could of course introduce a "nullable" operator (which would mean you still pass by value, but that value can be `nil`), but I can't say I'm convinced that'll make code more understandable.
I'm not sure what you mean? The empty value of an interface is `nil`. In all other cases, it will hold a dynamic type (which has to have a method set compatible with the interface's method set) and the value itself (which can be either a pointer or a value). Now an interface can actually hold a pointer of a type that has the value `nil`, which is not the same as a `nil` interface. :) But it's well-defined, and if you want to dig into how it all works, I suggest playing around with the `reflect` package.
I mean if Nilable were a separate thing from interfaces. 
&gt; I love Wine, and think its a great effort, and can get a surprising number of programs to run reasonably well. I concur. I'm always amazed when I see what the Wine developers have managed to do. &gt; Things work, but in my experience they're always just... not... quite...... right. I can't add much to this as Zeus has only ever been lightly tested on Wine, but in that few hours of testing no issue we found. In fact a Zeus painting bug was detected :) While there are users that do run Zeus on Linux using Wine, I can't tell you much more than that. I'm sure as you say there are bound to be things that aren't quite right. &gt; This just won't work at all. That is a bit of a show stopper :( &gt; Finally, and this is probably just a documentation issue, if neither of the first two points were issues any more, they don't disclose their license agreement. The license is in the first page of the installer and also in the help file. I thought it was also copied to the disk, but on checking this I could not find it. That will be fixed. &gt; Specifically they don't tell you if your purchase is licensed to a single user, or a single machine, etc. Am I expected to buy two copies in order to use both my laptop and my desktop? For the installer license: **1. License/Installation** *One registered copy of Zeus may either be:* *Used by a single person who uses the software personally on one or more computers.* *OR* *Installed on a single computer and be used non-simultaneously by multiple people.* So in other words one user, with one license can install the software on any number of machines. Thanks for the feedback. Cheers Jussi 
Didn't know until now that etcd was being written in Go. That's good news. I've been thinking I should find some code by others and read -- I'll probably learn a bit from it.
This is a joke that I wrote while somewhat inebriated a few years ago. I thought it'd amuse/horrify some people out there. :)
So which is better? :)
I went Go to avoid PHP. :(
True. That's something I hadn't considered.
That's awesome. Finally being able to put my Linguistics qualifications to use, the vowel in your IPA /ɜː/ is the same vowel as the "e" in "pet", followed by the long vowel symbol. What you were probably looking for is /fə(ɹ)/, unless of course you want it pronounced like "fair".
A little off topic, but how do you guys feel about writing getters and setters in go?
This made me smile for sure :)
You can find the presentation here (no reg required): http://rcrowley.org/talks/strange-loop-2013.html#1
A good place to look is this trending pages on github, https://github.com/trending?l=go
Oh, thanks! I just took the IPA out of the word gopher on wiktionary (iirc) and hoped it'd be correct. :)
It's is my first project with golang. So, all tips are welcome! 
You're a very bad person. You're giving me flashbacks to when I last wrote some PHP (10 minutes ago).
IMO There's only a few reasons for writing them, and if these are the reasons then I'm totally OK with it: 1. You want to make a field publicly read-only. So you'll need a getter. 2. You need additional logic in the getter/setter. 3. Consistency. If the majority of fields in the struct have getter/setters then I may add them for all the fields even if a few don't need additional logic.
It would be helpful for the FAQ to also note the definition of a "small struct". Whatever the pointer size is or smaller? I suppose I could see that, but wouldn't that depend on the platform? Although probably difficult to code, it seems like a linker/optimizer detail to me...
Thank you very much! I'm getting an error on that line above: f, err := os.Open(inputFile) the error is cannot use inputFile (type *string) as type string in function argument How / why is inputFile a string? When I run the file in the terminal, I pass it a file name.
try f, err := os.Open(*inputFile) [Source](http://www.golang-book.com/8#section1). I forgot to de-reference the string pointer back to the string value.
but its not just third party packages. http://godoc.org/reflect how about: `GoDoc: Package Documentation`
&gt; `select message, date from commits where 'Fuck' in message` That made me chuckle. Great work!
nice work! I recommend you add binaries as releases, so non-Go users can easily download and install the Gitql command, without having the go tool installed.
It's an operator to signify sending to a channel or receiving from one. But you can also use it when creating a channel to specify whether you want to channel to only be able to receive, or only be able to send data: ic_send_only := make (&lt;-chan int) //a channel that can only send data - arrow going out is sending ic_recv_only := make (chan&lt;- int) //a channel that can only receive a data - arrow going in is receiving This example is from [here](http://golangtutorials.blogspot.com/2011/06/channels-in-go.html)
Don't worry about it. Your transcription was "correct," as was beefsack's. There isn't really broad agreement on how to transcribe everything. For example, I personally would have transcribed it as /fɚ/.
Nice!!!
Nice project. I also experienced issue #10 while trying to install on mac os x. 
This was a little confusing at first because the author said they wanted the zero value of the Int64 but then they set the default to 512. If I understood the article correctly, they could have left the line out assigning parent.Int64 = 512 and it would have just been 0.
If you change the type signature of `PutBits` to `func (enc *Encoder) PutBits(bits ...bool)` and don't change the body at all, you can remove `PutBit` entirely. Same for `PutBytes`. This allows both of: enc.PutBits(true, true, false, true, true) bits := []bool{true, true, false, true, true} enc.PutBits(bits...) Idiomatically, I'd expect creating an Encoder to wrap a [bufio.Writer](http://golang.org/pkg/bufio/#NewWriter), and let that manage all the written bytes, letting you just worry about the current fractional byte. You sort of ended up reimplementing that yourself. You may want to consider composing it in and letting it be exposed, so you don't have to forward all of its methods by hand, though you'll certainly need to at least wrap `Flush`. (As you already seem to know, but I'll put out here for others, you _don't_ want to just write single bytes at a time to an io.Writer. The io.Writer interface specifies that it is perfectly legal for a Writer to interpret each Write request as a single packet, a single disk access, or any other very expensive "single" thing to be doing one at a time. A bufio.Writer is an easy way to wrap around that.)
would love to read your book
&gt; If you change the type signature of PutBits to func (enc *Encoder) PutBits(bits bool...) and don't change the body at all, you can remove PutBit entirely Nice! I'll definitely add that next as having the two functions seemed a bit redundant. &gt; You may want to consider composing it in and letting it be exposed I'm not sure if it would be a good idea to expose it as then may you end up writing data to the buffer whilst still having the hidden bits unwritten. Unless I'm misunderstanding something (which is probable). Finally do you think it is ok to read a io.Reader one byte at a time? Thanks very much.
No need for paying someone. Work through the tour twice. Read the spec. Read effective Go. Read the spec again. Read effective Go a second time. Read the documentation of the standard library properly and run and try tu understand the examples. Peek at the implementation of the standard library in the areas your main focus lies. Will take 4 days.
It is hard work writing a book and this book is technically not finished yet. Instead of spending time telling everyone why not to read the book, why not work with Kyle to help make the book better? Writing a book is a collaborative process and requires constructive criticism. Help from those who have the expert knowledge is always welcome.
&gt; but have extremely limited time 
[Golang Weekly](http://www.golangweekly.com/) usually has new and interesting packages. Sometimes people announce new packages in the [mailing list](https://groups.google.com/forum/#!forum/golang-nuts) as well.
You can subscribe to [gitly](http://gitly.co/) and they'll send you a weekly email with trending repos in GitHub. 
&gt; I'm not sure if it would be a good idea to expose it as then may you end up writing data to the buffer whilst still having the hidden bits unwritten. Unless I'm misunderstanding something (which is probable). You can override the methods so that you convert a normal Write call into PutBytes, if you like, and like I said, you'll want to override Flush. (If a user reaches straight in to the bufio.Writer, well, they lose. I'm comfortable with that. I do sort of wish there was a way I could embed a type and have the methods delegate straight in while not making it a public member of the struct. Maybe in Go 2.0.) As for the Reader question, reading [the docs](http://golang.org/pkg/io/#Reader) it sounds like the expected behavior for a Reader is to read in whatever is "natural", then hand them out as requested. Come to think of it, I didn't learn about that Writer behavior from the docs, though; I learned about it when I sent out a huge stream of tiny little packets when I was serializing a struct out to the wire, and when I checked it with a tcp dumper I noticed I was getting one packet per Write call.
Good point, although I did (at least) attempt to correct for the ambiguity. You'll notice on the graph that the search for Java uses a beta feature of Google Trends to filter by searches related to the programming language. And if we were to use "go", I think the problem would be even worse (HBO Go, the verb go, etc). Perhaps Java is not a fair comparison though - would JavaScript be better?
No offense, but with "extremely limited time", you won't master anything, no matter how much money you pay and how many tutors you get. 
Also checkout: https://github.com/trending?l=go Which shows the current trending Go repos.
Upvote: because learning is about repetition and doing things over...only then will it start to sink in.
[Here you go](http://www.matasano.com/articles/crypto-challenges/). Better than a book. (I assume you're snidely asking him to show his credentials. He has them. That's unlikely to be a productive line of snark.)
It's a great idea! I will think about it and if you want help, would be great! :)
Crypto isn't the best thing to try to learn while writing a book to tell everyone else how to do it. This isn't like writing a book on how to do graphics or something, where corrections can be harmless. I know a lot of people are getting that "I got a D- and a sad smiley face in bright red ink" feeling when reading that, and that's uncomfortable, but this isn't T-Ball, this is serious stuff. Claiming to be a crypto expert when you aren't one can have real, negative consequences for anyone who believes and follows you.
*uck! lol I haven't mac os right here, but I think that DYLD_LIBRARY_PATH should be set instead of LD_LIBRARY_PATH. Other feedback could be amazing! Really thanks! 
haha This feature could be really util :P 
Thanks for your feedback! It's a good idea. But, in other hand, gitql is a good way for non-Go users start with that awesome language! lol 
That doesn't always work. Think about this can a surgeon work with Kyle to help him write a book on transplant surgery. Probably not. I think this is in the same area.
FWIW someone posted goline package hdre few days ago which could be helpful in making the REPL.
Ohh, maybe is https://github.com/nemith/goline ? if not and you find, send to me, please! 
I wonder if "golang" has another meaning in a dialect of Chinese?
Nice. I just signed up. Have you completed it yourself ?
I, too, would like to master various skills without putting in the time. [Doh](https://www.youtube.com/watch?v=c9EBhaULToU).
Why not reach out to Kyle first? Tell him the problems and let Kyle make a statement and pull the book. Then Kyle can correct the problems and publish the book again at a later date. I just wish there was more community sometimes. People who put themselves out there deserve the opportunity to correct their mistakes with dignity.
I'd create a bits_test.go file that contains something like this: package bits import "testing" func TestBitToInt(t *testing.T) { if bitToInt(false) != 0 { t.Fail() } if bitToInt(true) != 1 { t.Fail() } } func TestPutBit(t *testing.T) { e := NewEncoder() if e.Len() != 0 { t.Fail() } e.PutBit(false) if e.Len() != 1 { t.Fail() } e.PutBit(true) if e.Len() != 2 { t.Fail() } } func TestPutBits(t *testing.T) { e := NewEncoder() if e.Len() != 0 { t.Fail() } data := []bool{false, true, false} e.PutBits(data) if e.Len() != 3 { t.Fail() } } ... and so on. It's pretty easy to add a travis auto-build. Put a .travis.yml file in your root: language: go go: - 1.0 - 1.1 - 1.2 - tip script: go test Setup an account here: https://travis-ci.org/ Then, you can put a auto-build badge in your readme. It's really good to do.
&gt; Perhaps Java is not a fair comparison though - would JavaScript be better? No, because you can't find a comparable term for Go. "go" is too broad and "golang" is too narrow. You can use "golang" only to compare Go to itself.
For Hack Day, I'm going to be working on a hardware hacking project. I'm building a payload for a high altitude balloon, controlled by Go running on a single-board computer like a Raspberry Pi or BeagleBoard. PS- If you're interested in helping out, you're totally welcome to. Some of the things that will need doing: - I want to create a "mission control" console built with Go and ncurses that pulls the balloon location/distance/bearing down from the APRS-IS network/API, location from a local GPS, and enables real-time chat between chase vehicles - Improvement/testing of Dustin Sallings' APRS package: https://github.com/dustin/go-aprs - Integration over GPIO with CHDK and Canon Basic scripting language running on the camera to trigger photos, videos, etc: http://chdk.wikia.com/wiki/Canon_Basic 
I did a search on baidu.com and nothing other than programming-related pages turned up on the first twenty result pages. Guess it really is popular in China, but I would also really like to know why!
Add **?signin=1** to the URL to get past the popup.
When I need a package I have a concrete use case, and then I find it via godoc.org.
?share=1 works too. This was from my mobile so I didn't get the annoying nag screen.
Experience with other languages often does not map directly into Go. Your edit does not mean that mastering Go won't take time.
I posted this because I don't think /r/golang should just be a cheerleader for Go. If you can't recognize and discuss limitations of your favorite technologies, you don't really understand them.
Use sync.WaitGroup
We are going to be demo'ing work to date on Documize. We switched from the dark side (.NET) to Golang -- some interesting reasons/insights. Looking forward to seeing you guys at the Hack Day!
This might be of interest to you: https://github.com/bmizerany/perks
I think the point is he doesn't want to wait for them to finish, but to time out after a second. I agree that it's bad it waits one second regardless, though. Edit: is there a way to wait for a WaitGroup with a timeout?
Yes, the algorithm used by go-fastquantiles is much faster is my tests. It processes ~37M items in ~30s, vs. 5m45s for perks/quantile. I noticed there is an unmerged pull requests with some performance tweaks for bmizerany's package that should have a speed up, but it's hard to beat O(log log N) per-element update cost. CKMS (the algorithm used by perks/quantile) is targetted more as a a space-improvement over the regular GK streaming quantiles algorithm, but not a computational cost improvement, whereas the Zhang-Wang fast quantiles algorithm was specifically an attempt to dramatically improve the computational cost of pure GK.
For background, [Jonathan Oliver's "Why I Left the .NET Framework"](http://blog.jonathanoliver.com/why-i-left-dot-net/) is an interesting read. You can see why Microsoft are so rattled that they set up the [.NET Foundation](http://www.dotnetfoundation.org/)...
Something like var wg sync.WaitGroup // Call wg.Add() and wg.Done() for each worker. timeout := time.After(1 * time.Second) done := make(chan struct{}, 1) go func() { wg.Wait() done &lt;- struct{}{} }() select { case &lt;-done: // ... case &lt;-timeout: // ... } ~~Sorry about syntax, I'm on a phone.~~ Edit: fixed See this Go blog post: http://blog.golang.org/go-concurrency-patterns-timing-out-and
That's the one!
Wow. I should play with channels. I've been coding Go for some time now but the nature of my project means that channels are unnecessary. That's pretty cool though.
That is how one quantifies a proper response.
I'm tempted to pack up and ship the Raspberry Pi cluster that Erik St. Martin and I built - the 20 pi's all have Go installed, there could be some fun hacking there. 
&gt;Although it's possible to get by without generics it's a massive pain in the arse. Having generics would make creating collections that aren't built in like sets, linked lists, queue etc so much nicer. Making a Binary Search Tree implementation in Go just for fun, so far the only thing that is clunky is having to type assert the value every time I get it out and wrap it into an interface type when I put it in. And I wouldn't call it a "massive pain in the arse". The interface for the value is just two methods, Less() and Equal(), and it seems to me that creating linked lists, sets, and what have you wouldn't need a bigger interface. So I can't see how the lack of generics would stop people from implementing data structures in Go. The thing that I do consider annoying is the fact that you can't just convert, say ``[]int`` to ``[]interface{}``. You have to allocate a new slice yourself and then fill all the elements in a cycle. This is annoying, but not a "massive pain in the arse". Maybe I just have low standards :)
Thank you! Started following the mentioned twitter account and will take a look at your starred repos later.
Couldn't you implement the golang [cipher](http://golang.org/pkg/crypto/cipher/) package's interfaces (specifically, the Block interface) and then use the normal crypto libs to perform Rot13? I know it seems like overkill, but the standard lib is pretty great and I personally became much better at go when I started reading its source.
My goal is to help on an open source project. Leaning towards Camlistore, but also thinking about Docker. Also, would be more then willing to help out anybody that needs it on pretty much any project.
You end up losing type information and type safety though when using interface{}. There's also the problem of functions that operate on slices, for example a function to shuffle a slice, you would have to write that function for every type you need to do it for. There's also the mess of making a slice sortable. You may just have a higher pain tolerance than me! :)
I applaud that sort of thinking (no sarcasm), but in this case I think wrapping Reader, Writer, and RuneReader is the correct method. All the cipher code that uses Blocks appears to also use initialization vectors, and it's silly to create a "block" method that lacks them, when the Reader etc. works fine.
It looks like you might as well remove `Rot13` and `Rot13Rune` and rename `rotByte` and `rotRune` to those methods (and all references).
Oops. Thanks for that. Is it relatively new?
No, but the argument can be made that it's part of the library and not in the language itself.
Two projects: * Porting exercises to Go for exercism.io. Last I checked, there are about 45 exercises available in Ruby that don't have Go equivalents. * Fsnotify needs some love, but may start on a ground up implementation of kqueue, FSEvents, Inotify or Windows - particularly to better understand the details of each. We have a meetup (Edmonton, Alberta) the following Monday, so possibly spending some time summarizing all the awesome takeaways for GopherCon in preparation for a talk. 
Well, a somewhat more fair comparison with Ruby would use one of its event-based systems. I'm not a Ruby programmer but I believe the dominant one is called [eventmachine](http://rubyeventmachine.com/). Go will still win, most likely, but not by anywhere near as much, because this is going to be an IO-bound task. On my machine, just starting ruby and requiring eventmachine is ~0.2 seconds from a warm cache, and that's probably about the advantage Go would have. For this simple case, Ruby isn't that much worse code-wise, either, since you're not really doing anything with the results. Where Go would start winning is if you also wanted to do processing in those threads, where you could "just do it" instead of having to massage your code to fit into the event-based paradigm. (No matter how nice the Ruby affordances are for that, it's even better to not have to do the massaging in the first place.)
Go is engineered with different things in mind than C#, Java, Rust, and even Python. And it's new. Of course it has its limitations and deficiencies. If you absolutely need the features of those languages, and you're trying to squeeze them out of Go, you're doing it wrong. While I appreciate a balanced discussion environment considering both sides of an issue, it bothers me when the war wages on with battles that use phrasing like "better than" or "worse than" which are subjective at best. The top answer in this discussion seems to promote other languages using that phraseology assuming that their design goals are inherently "better than" Go's, or that Go is generally a "worse choice than" other languages, when really, I think it's just their purposes and values are *different* at the core.
The Reader is wrong. Need to rot13 before the error return. Returning (non-zero, io.EOF) is perfectly valid. 
That's really interesting, I didn't know the history of the algorithms and the exact motivations behind them. Thanks =)
I'll probably work on DVID (https://github.com/janelia-flyem/dvid), either adding bitly's bloom filter for versioning or adding Google datastore/blobstore as a storage engine. Would be great if some experienced Gophers looked over code with me because I'm pretty much the lone Go programmer at my research institution. By the way, are we setting up lightning talks in the morning or is that slated for the pre-Gophercon party?
I'll probably be hacking a bit on Heka, and will definitely be available to help anyone else who is interested in doing so, or even just to get started using it.
our company also uses GWT, but we are thinking of switching. Should it be node or go or something else? What do you think?
Actually, ruby &gt; 1.9 is great on waiting for IO. It is very underrated in this regard, this code is just as fast as the go code. I like go, but posts like this just show that any tool in the right hands is better than just any tool ;) require 'open-uri' # we'll just use two sites 25 times for brevity websites = ["http://www.google.com", "https://www.facebook.com"] threads = [] 25.times do websites.each {|site| threads &lt;&lt; Thread.new { open(site) }} end threads.each {|thread| thread.join } 
If I wasn't clear, I really did mean to say that Go's advantage here would pretty much be confined to the startup time difference between the Ruby &amp; the Go. In this particular task it turns out that's a significant percentage of the time, but that's really just sort of a coincidental aspect of the task chosen, not interesting.
Yeah, that's a good point.
Good catch. I'll fix that.
More simplifications and optimization to not generate so much garbage in Write: http://play.golang.org/p/m0xo05UDZ2 
Is Hack Day the 26th? I think I might be leaving a bit early that day. Nonetheless, some things I might work on: * [sqlx](http://github.com/jmoiron/sqlx) and [modl](http://github.com/jmoiron/modl) could use documentation, planning, code cleanup * [jigo](http://github.com/jmoiron/jigo), jinja-in-go, is still at the very early stage, only a lexer and a tiny bit of a parser/ast so far.
Thanks for the feedback, what would the purpose of the wrapper be? Just to interrupt the work in progress? If so then I figured it was best to leave that up to the user, since they'd know better about how best to achieve a graceful termination. I disagree that it has no value without, I think that's overly dismissive. But I agree that most use cases within Golang shouldn't require this, or any pool library for that matter.
&gt; what would the purpose of the wrapper be? To terminate a goroutine, when it's waiting for a lock. So-called interruption point / cancellation point.
I'd be definitely interested on a hands-on tour of Heka. 
This is awesome!! One of the most amazing things about Golang to me is that it is so fast, and just keeps getting faster. Given the flexibility and the power of the language and its concurrency features, performance this good is *very* impressive.
I downvoted the submission not because of criticism of Go or its content, but because Quora is a piece of shit seo spam site that is a significant contributor to making searches for answers more difficult.
pool.Close() will interrupt the waiting goroutines and close them down. It currently waits for the remaining work to be completed/timed out rather than calling for them to be scrapped, but if that's what you're asking for then it's simple enough to implement. If not then I clearly need some sleep before coming back.
The "tip" is 1.3, as it says on the top of the post. The bottom part is just the dump for op/ns. Read the whole thing for the 1.3 benchmarks compared to the older versions.
&gt;I wonder why there would be such a difference between string and int keys in a map What is the time to calculate the hash of a string, and then make sure that the key requested == the key found ? Hint: it is proportional to the length of the string. What is the time taken to copy a struct{...} vs the time taken to copy a reference. 
I changed it. Others could change it more, but it's at least better now. 
OK, I see now. It's pretty deceptive, because he compares every incremental improvement, except for 1.2.1 =&gt; 1.3. So the 1.0 =&gt; 1.3 improvement looks amazing, whereas actual the 1.2.1 =&gt; 1.3 improvement is pretty minor.
If you get something wrong on your blog, it's unlikely to have any consequences, let alone disastrous ones. That's why a mistake or typo on your blog can be fixed by sending you an email, and no one is really affected. It is important that this comment by ptacek gets as much publicity as possible, so that no one reads the book and then implements it in a place where security is essential.
Basically, use a string when you're not going to modify it much, use a byte slice when you are. Immutable vs. mutable. Nothing that the documentation doesn't cover.
True
These challenges were a great excuse to start using Go - some of my first Go programs were specifically to solve some of these challenges. I would definitely recommend giving these a shot.
Your wg.Wait() doesn't do anything.
How is #404040 "light grey"?
Must be the typeface. But I most definitely can't see the text on this page. Especially all the lighter grey text (looks like quotations maybe?)
Not my first language, sod off, but thanks for pointing it out. 12 days later.
This amuses me :)
Thanks for clearing it up. I thought that was the whole code and you were calling wg.Wait() on all your goroutine workers.
No tests, would not use.
Good insights in this article, thanks for sharing.
I wish I'd included the code for that benchmark, but I didn't want to wait for the go-ahead. A lot of people seem to assume that the benchmark was testing the two types I was talking about in the post, but actually they tried to isolate map inserts on string keys vs int keys and that's it; all else was the same. The reason they are named as they are (`TypedSetInts`, `TypedSetStrings`) is because the *original* implementation used [go-sets](https://github.com/deckarep/golang-set), which are `type Set map[interface{}]struct{}` underneath. I'm very suspicious of unnecessary use of interface{}, and you should be too. The full profile output for all of that is: BenchmarkGenericSetStrings 1000000 3713 ns/op BenchmarkGenericSetInts 5000000 674 ns/op BenchmarkTypedSetStrings 1000000 1809 ns/op BenchmarkTypedSetInts 5000000 353 ns/op The "Generic" versions use the set implementation, the others use `map[string]struct{}` and `map[int]struct{}`. The takeaways: * wrapping keys with `interface{}` isn't computationally cheap even in comparison to the mapinsert operation * the generic sets use extra memory ([two words](http://research.swtch.com/interfaces)) because `interface{}` is basically a header and takes up space, unlike `struct{}` which doesn't * ints were faster than strings, which was expected; the strings in the test were of typical length for our data, which is like ~30 chars. 
You make a really good point, one which is echoed in the excellent ["Profiling Go Programs"](http://blog.golang.org/profiling-go-programs) post on the golang blog. We actually did measure this for one of our lower cardinality bits of data (compact key use on the order of ~10k): BenchmarkIndexerMap10k 20000000 87.6 ns/op BenchmarkIndexerMap100k 20000000 87.8 ns/op BenchmarkIndexerSlice10k 50000000 47.3 ns/op BenchmarkIndexerSlice100k 50000000 52.6 ns/op BenchmarkIndexerRandBaseline 50000000 33.7 ns/op These used random numbers in the 10k/100k range. The RandBaseline just generated random numbers to give me a sense of what the rand overhead was. Unfortunately for the data I'm talking about in the blog post, the keys are prohibitively large and sparse; order of hundreds of millions, with 10% active at a time. The distribution is kind of top heavy, we can't guarantee we won't see very low IDs ever again.
That's what I expected, really. But I figured it was also a good enough general reddit post that it was worth putting up there. I've had to catch this in my own code a couple of times, accompanied by forehead slapping. (It was in Perl, where I suspect the difference was even larger than it would be in Go. Perl is... slow.)
One thing you could do to reduce memory is change the map in dictionary.go from `map[string]bool` to `map[string]struct{}`. A `struct{}` uses no memory, see http://dave.cheney.net/2014/03/25/the-empty-struct. In your Contains() function, you'd change it to be: func (dict Dictionary) Contains(word string) bool { _, ok := dict[strings.ToLower(word)] return ok } 
I sent them an email but they've not replied. Wonder why.
Damn, I'll have to pocket that trick...
They were really bogged down recently. They sent out an email saying they are doing most of it manually. I'd wait a little while. If you still haven't heard back, PM me.
Good call. It's been changed. Just out of curiosity, what's the thinking behind never having empty lines in your code (ie, separating code in a given function into blocks of related instructions)? I've noticed that it's a prevalent style in the standard library as well.
I thought that Go was popular in China as it was a useful technology for writing programs on rooted Android phones, specifically proxies.
But that doesn't explain why https://github.com/astaxie/build-web-application-with-golang has 3000 github stars.
Thanks for the tip! I had come across that at some point, but I didn't want to complicate my life before I got something working. :)
I think an important reason is: some people stood up to popularize it, then a cozy community is created.
Because it is a brilliant explanation of how to build web applications. In fact I suspect the popularity of Go in China may be because of this book, rather than the other way round. English translation [here](https://github.com/Unknwon/build-web-application-with-golang_EN)
I'm a gopher, and I'm living in China. golang.org blocked because GFW. many gophers use proxy access golang.org or other golang resources maybe blocked by GFW. so maybe there are more gophers in China. 
Thank you, I had browsed through the code snippets in the Chinese version and it had looked pretty good - did not know that it had been translated.
Has it occurred to you that maybe the fact that 1 in 6 people on Earth is living in China is an important factor?
Thanks!
There's also a recency factor, Chinese users now make up a far larger percent of internet users than ten years ago. As a result, older languages (ie Java) have less original Chinese content. I think if java rose to prominence today, you'd see the same mix of Chinese an English content.
This is not true at all. The Go community in China barely talks about anything related to programming on rooted Android phone. In fact this is my first time hearing about this There are quite a few big Chinese IT companies using go fully or partially for their backbend service and I believe that's what majority of Chinese use Go for. 
I wonder how much (if any) influence the fact that Go source is UTF-8 has (making it possible to use Chinese characters for variable/function naming built-in to the language)?
Very easy UTF-8/rune support is likely a big reason.
I add blank lines for major breaks between sections. In a few line function there's rarely a major break. I dunno. Just preference. Fit more code on the screen this way, too.
That's a fair hypothesis. One way to answer that is to check how visible China is in other programming language communities, relatively speaking.
&gt; One redditer suggested that, perhaps, “golang” is in fact a word in a dialect of Chinese. Well, "Go" is the surname of my (Chinese) mother, and I have to admit the connection might have given me an irrational soft-spot for the language (the name is probably an unusual romanisation of Gao, btw). But since this is about "golang" rather than "Go" I don't think that effect applies to other people with Chinese ethnicity.
Maybe because Go is unicode friendly? (and display 世界 on http://golang.org)
Well, I feel bad to see such a good question sitting here, so let me at least acknowledge we see you. :) I know nothing about CAN buses, but I'd guess you might be able to bind a C library via cgo. I find cgo a bit quirky and underdocumented, though... it may not be quite as simple as you'd like.
What you want to do is not platform independent. So you will need to study what options the operating systems offers you. In Linux, you have for example SocketCAN (https://www.kernel.org/doc/Documentation/networking/can.txt) and you should be able to use it with the "net" package as far as I know. 
golang.org is hosted on Google's servers.
My pet theory: because Go affords Java-like performance for developing web apps, *without* the verbosity of Java frameworks. English is not their native language after all, and given the choice many would rather not deal with walls of public static pattern factory adapter builders all day.
I asked the author of [gorm](http://github.com/jinzhu/gorm) this in some unrelated email correspondence, but he didn't seem to know why, either. My suspicions are: * Go is pretty simple, which helps adoption generally * Go has great unicode support, vital for CJK * Go has good Windows support, also vital *in* CJK
fair.
Thank you for replying. There are some solid C libraries out there that I could make use of so I will look into some other cgo implementations and see what I could achieve using this route.
I am a Linux user and have done a good amount of work with Socketcan in the past, so that would be my preference. I found no documentation about using the net package for the CAN bus, but CAN is a network interface so perhaps it is possible but undocumented. I am away from my CAN enabled device all weekend due to the holidays, but I will test this on Monday and hopefully start doing some work! Thanks
This is a great record of how HTTP can be handled in Go. It certainly makes more sense out of the Martini approach of request wrapping, and dependency injection.
Nice. 
That fixed it, thanks. Could you have some command line argument display the table schema (or add to the help menu) so I don't have to refer to the github page?
Except that Chinese is really fucked up in Unicode, causing a lot of Chinese / Japanese / Korean to dislike this encoding.
Go isn't a scripting language; that's a Go _program_. Try compiling it, then running it: go build -o nessus nessus_xml_parser.go time ./nessus -file edit: also, you shouldn't commit your binary to GitHub...
Sorry didn't know what is considered a "script" or a "program". Can I ask the reason why not to commit the binary? 
Apparently Go supports it quite well, to the extent that you can use Chinese characters for your variable names.
The term "script" generally refers to a program written in an interpreted language like Python. In Go, your program is compiled into a native binary before being run, so the computer isn't running a "script", but actually executing the machine code. You can put a binary on Github, but it won't be useful because: 1. The binary won't work for everyone and they can just make their own binary from your code 2. You won't be able to understand the diffs 3. They take up a lot more space than the actual code itself.
Profile the programs. Time is likely dominated by DB operations, not either Go or Ruby.
As others have pointed out, Ruby is interpreted, while Go is compiled. Every time you run an interpreted program, the interpreter (the "ruby" command in your example) has to start up, read in the program, and execute it. On the other hand, compiled programs work in two phases: First, the compiler takes your source code and converts it into code which can run directly, without an interpreter. Second, the compiled code is run directly as its own program. Because of this distinction, you only ever need to compile a program once (or every time you make changes to the source code). So long as you haven't modified the source code, you can just run the same compiled binary over and over again without recompiling. The reason that your Go code is running slowly in your example is that the "go run" command compiles and runs the code. Thus, every single time you run it, it unnecessarily recompiles everything. If you first compile and then just run the compiled binary over and over, it will save you a lot of time.
How the fuck would that work given that the first character's captialization makes a huge difference in variables names in go?
Interesting idea. Would love to hear more!
haha Go compiles so fast that some people think of "script"
That makes sense about the binary thanks, I'll keep that in mind and remove it. 
I have been looking into the copy cmd seems to work better for large inserts. Just need to look at how the data needs to be set up.
This is not the point. The Unicode consortium did goof when it came to something called Han-unification where they encoded Chinese, Japanese and Korean into the same set of characters (i.e. CJK). The approach taken by Unicode is both extremely unsystematic and outright broken in other cases. (e.g. why are both forms of 青 encoded but only one form of 請 even though it can be written with both forms of 青?) This is a huge PITA for font designers and writers.
* Use multiline strings * Not sure why you have both "readyData" and "ReportItem"; one would do.
http://golang.org/pkg/math/rand/#example__rand 
Thanks!
Thanks
Actually it's written by Japanese. Japanese is using a large amount of Chinese characters.
How random?
 func getRandomNumber() int { return 4; // chosen by fair dice roll. // guaranteed to be random. } ^[xkcd](http://xkcd.com/221/)
[Image](http://imgs.xkcd.com/comics/random_number.png) **Title:** Random Number **Title-text:** RFC 1149.5 specifies 4 as the standard IEEE-vetted random number. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=221#Explanation) **Stats:** This comic has been referenced 62 time(s), representing 0.3664% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
Are you just being a dick or do you actually not understand the problem?
Multiline string: func insertStatement(db *sql.DB) string { return `insert into network (host, mac_address, netbios, fqdn, os_name, plugin_name, plugin_id, severity, cve, risk, description, solution, synopsis, plugin_output, see_also, exploit_available, exploit_ease, metasploit_framework, metasploit_name, canvas_framework, core_framework, exploited_malware, cvss, month, year) values ($1,$2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25)` } Use embedding: type readyData struct { Ip string Os string Mac string FQDN string Netbios string ReportItem } // ... then you can do this: rd.ReportItem = host
My favorite go random bit generator: package main import "fmt" func main() { c := make(chan int, 1) for i := 0; i &lt; 100; i++ { select { case c &lt;- 0: case c &lt;- 1: } fmt.Println(&lt;- c); } } 
Not really random just like throing a D10
When you get down to the Newtonian mechanics of it, throwing a d10 can be pretty random :)
Thanks for the input :-) Ah I see. Yeah, you called my java background. I will clean that up in an upcoming commit.
_nerd voice_: Technically, the docs describe select as **psuedo**-random. 
Also note how the cpu usage was much less.
I haven't actually read the code, but it may give you a place to start. https://github.com/oleiade/trousseau
What kind of app are you building? If it's a web app, I would recommend using environment variables to store sensitive information like AWS keys. This function in the os package should do the trick: http://godoc.org/os#Getenv
yeah, thats a fair question. The plan was to store private keys because I want my service to be agnostic of git host. There is/will be clear documentation to definitely DO NOT use your own private key, but setup a "machine user" ala https://help.github.com/articles/managing-deploy-keys#machine-users and only give access to the appropriate repo that needs the read/write permissions. that being said, it is probably a good idea to explore the oath option for github/bitbucket which would provide better UX anyway. thanks for your comment.
I like the const idea but wouldn't it be better to put them in the function the will be used, instead of having global variables?
Ah - understood. 
Global variables are bad. Global constants are fine as long as they are there for a good reason. 
thx. how does that compare to https://github.com/kisom/aescrypt?
add that "export GOPATH=$HOME/Projects/Go" to your ~/.bash_profile http://unix.stackexchange.com/a/21600
Thank you, but it is saying .bash_profile is no file or directory in my home ( ~ or $HOME ).
I think Haswell chips have this as well.
Do you have a .bashrc ? You can also put it there if you like. If you don't have that, what shell are you using. You can see by running: echo $SHELL
I don't have .bashrc either. I'm using the terminal in Mavericks. When I ran echo $SHELL, I just got /bin/bash
Haswell chips are recent amd64 chips.
Also have a look at [dkeyczar](https://github.com/dgryski/dkeyczar). I'm not sure how much reviewed is the code. Probably not as much as the original Keyczar.
The files might have to be created. My .bash_profile sources my .bashrc which has my GOPATH in it. (On a Mac. Make the files and it should just work.)
That is odd -- I serve thousands and thousands of TLS connections per second -- I suspect scoith is right. 
If you can reproduce this, submit it as a bug?
What generation?
After reading http://golang.org/doc/code.html ('Your first program') doesn't the documentation encourage a package specific directory layout?
You are using bash. If you don't have it, create .bash_profile in your home dir. or you can add it in /etc/profile. 
"top-of-the-line"
As a Chinese coder,I would say that,Yes, Go is very popular in China, and its popularity is most owe to Xu shiwei, a famous programmer in China.He has made a great effort to promote Go since 2011, and in his startup, more than 90% of their code is written in Go. 
If it's Nahalem (Bloomfield / Lynnfield codename, 860-960 model no) then it doesn't have AES-NI.
http://www.linuxfromscratch.org/blfs/view/6.3/postlfs/profile.html explains it quite thoroughly.
Are you using DHE-RSA without session caching?
According to /proc/cpuinfo it's: Intel(R) Core(TM) i7-4500U CPU @ 1.80GHz. 
And according to [this](http://ark.intel.com/products/75460/intel-core-i7-4500u-processor-4m-cache-up-to-3_00-ghz) it supports AES-NI.
Performance is better now: Server Software: Server Hostname: localhost Server Port: 3000 SSL/TLS Protocol: TLSv1/SSLv3,ECDHE-RSA-AES256-SHA,1024,256 Document Path: / Document Length: 21 bytes Concurrency Level: 8 Time taken for tests: 29.129 seconds Complete requests: 1000 Failed requests: 0 Write errors: 0 Total transferred: 138000 bytes HTML transferred: 21000 bytes Requests per second: 34.33 [#/sec] (mean) Time per request: 233.033 [ms] (mean) Time per request: 29.129 [ms] (mean, across all concurrent requests) Transfer rate: 4.63 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 140 229 41.5 224 410 Processing: 0 4 4.7 2 40 Waiting: 0 3 4.6 2 40 Total: 140 232 42.0 229 421 Percentage of the requests served within a certain time (ms) 50% 229 66% 246 75% 257 80% 264 90% 285 95% 307 98% 336 99% 358 100% 421 (longest request) For comparison, non-HTTPS: Server Software: Server Hostname: localhost Server Port: 3000 Document Path: / Document Length: 21 bytes Concurrency Level: 8 Time taken for tests: 0.068 seconds Complete requests: 1000 Failed requests: 0 Write errors: 0 Total transferred: 138000 bytes HTML transferred: 21000 bytes Requests per second: 14690.54 [#/sec] (mean) Time per request: 0.545 [ms] (mean) Time per request: 0.068 [ms] (mean, across all concurrent requests) Transfer rate: 1979.78 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 0 0.4 0 5 Waiting: 0 0 0.3 0 5 Total: 0 1 0.4 0 5 ERROR: The median and mean for the total time are more than twice the standard deviation apart. These results are NOT reliable. Percentage of the requests served within a certain time (ms) 50% 0 66% 1 75% 1 80% 1 90% 1 95% 1 98% 2 99% 3 100% 5 (longest request) That's a difference of nearly 500x. Command was: `ab -c8 -n1000 http[s]://localhost:3000/`
I don't know. What can I read to learn enough to answer this?
Your benchmarks between PHP and GO are probably using different cipher suites. Different cipher suites can have drastically different performance, you will notice the biggest performance difference on benchmarks that do lots of small requests rather than a few large ones.
I'm just benchmarking go TLS vs non-TLS. See my reply to ratatask.
Thank you very much!
SSL will always be slower, although your benchmark is pretty much a worst case scenario. The cipher suite you are using is one of, if not the most secure you can use. It is also one of if not the most slow. ECDHE adds latency and CPU usage cost the the beginning of a SSL connection, it also offers perfect forward secrecy. However once an SSL session is established it can be reused for all the web-pages's resources. Thus you only need to pay the ECDHE penalty up-front. Your benchmark is a ton if tiny requests that dont use sessions. The vast majority of the word being done is establishing the SSL connection.
Is that to imply that a browser would have a much lower latency after initial connection?
Then this clearly means you're doing something wrong.
&gt; I don't know. What can I read to learn enough to answer this? I think this answer concludes this topic. 
Play nice!
Which line? package main import ( // Default packages "fmt" "log" "runtime" "net/http" ) func handler(response http.ResponseWriter, request *http.Request) { fmt.Fprintf(response, "Building site...... %s", request.URL.Path[0:]) } func main() { runtime.GOMAXPROCS(runtime.NumCPU()) // Launch handlers http.HandleFunc("/", handler) log.Println("Launching listener on port 3000...") err := http.ListenAndServe(":3000", nil) //err := http.ListenAndServeTLS(":3000", "certs/server.crt", "certs/server.key", nil) if err != nil { log.Fatalln(fmt.Sprintf("Oh holy crap! Something went horribly wrong: %s", err)) } } 
I'm on the phone and can't link now, but there's another relevant bug too, where the initial processing of a private key is very slow. I encountered this in a test case that ran slowly due to simply opening 3 4096-bit keys, and nothing else. That took about 1.5 seconds. Don't run one request, benchmark thousands... If it is this problem, it's just a one-time startup fee, not a pervasive slowdown, and isn't _that_ big a deal. Edit: Got back to a computer faster than I expected. ("Hooray", sick children!) My guess is that you're hitting [this bug](http://code.google.com/p/go/issues/detail?id=6626). Also, regardless of our guesses, in general, the proper next step when the question is "why is my code slow?" is to [profile](http://blog.golang.org/profiling-go-programs). If the profile still doesn't make sense, at least when you ask the question and provide the profile you're much more likely to get intelligent answers. Note how we're sort of collectively groping around (me included)... that's essentially because we have no profile to go off of.
Yes, also many browsers will negotiate a lesser cipher that will be faster. If performance is an issue you can change your server cipher negotiation order so ECDHE is not chosen, it comes at the cost of perfect forward secrecy but you might get a bit of a boost in requests per second.
What can I google in order to figure out how to set this up?
I had a look and most of the information about it is for Nginx or Apache. Part of the reason there isn't much info on it is because its not really an advisable thing to do as you compromise security. Before going down that path [try running your benchmark with the -k flag](http://www.peterbe.com/plog/ssl_session_cache-ab) and [do some reading on SSL performance](http://chimera.labs.oreilly.com/books/1230000000545/ch04.html). 
Author here, happy to answer any questions :)
I see that other people already clarified the problem with your benchmarks (ECDHE).
Did you try to build go yourself? If not, maybe to package isn't compiled with support for the aes instructions for compatibility reasons.
Ah, I think I gotcha. So the method receiver specifies the type for the object instance this method will be called on?
Not exactly the answer you are looking for, but regarding the AWS credentials you should simply use IAM roles. You create a special role that the instance will have, and assign it to the instance. AWS will generate keys for it and will regenerate them periodically.
It's not only the type, but the name you give it when you refer to the data in the method. There is no "this" in Go so you specify the name as well.
Your remark is snide without contributing to the conversation.
"Java-like performance", that's an insult to Go.
How is that an insult? I'm curious.
In theory, a method is just a function. For example for type T int func (t T) Foo(){} func (t *T) Bar(){} these are internally mostly identical to functions type T int func T·Foo(t T) {} func T·Bar(t *T){} You can't actually define methods like that yourself, but that's their internal representation. You can, however, call a method like this: var t T T.Foo(t) Method receivers are very similar to the first argument for methods in Python, only that we don't call it self by convention, but treat it just like any other argument.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Go (game)**](https://en.wikipedia.org/wiki/Go%20%28game%29): [](#sfw) --- &gt; &gt;__Go__ ([simplified Chinese](https://en.wikipedia.org/wiki/Simplified_Chinese_characters): 围棋; [traditional Chinese](https://en.wikipedia.org/wiki/Traditional_Chinese_characters): 圍棋; [pinyin](https://en.wikipedia.org/wiki/Pinyin): wéiqí, [Japanese](https://en.wikipedia.org/wiki/Japanese_language): 囲碁 *igo*, [Korean](https://en.wikipedia.org/wiki/Korean_language): 바둑 *baduk*, [Vietnamese](https://en.wikipedia.org/wiki/Vietnamese_language): *碁圍* *cờ vây*, common meaning: "encircling game") is a [board game](https://en.wikipedia.org/wiki/Board_game) for two players that originated in [China](https://en.wikipedia.org/wiki/China) more than 2,500 years ago. The game is rich in [strategy](https://en.wikipedia.org/wiki/Strategy_game) despite its relatively simple rules. &gt;The two players alternately place black and white [playing pieces](https://en.wikipedia.org/wiki/Game_piece_(board_game\)), called "stones", on the vacant intersections (called "points") of a [grid](https://en.wikipedia.org/wiki/Grid_graph) of 19×19 lines (beginners often play on smaller 9×9 and 13×13 boards). The object of the game is to use one's stones to surround a larger total area of the board than the opponent. Once placed on the board, stones may not be moved, but stones are removed from the board if captured; this is done by surrounding an opposing stone or group of stones by occupying all orthogonally-adjacent points. Players continue in this fashion until neither player wishes to make another move; the game has no set ending conditions. When a game concludes, the controlled points (territory) are counted along with captured stones and [komi](https://en.wikipedia.org/wiki/Komidashi) to determine who has more points. Games may also be won by resignation. &gt;Go originated in [ancient China](https://en.wikipedia.org/wiki/Pre-Imperial_China). Archaeological evidence shows that the early game was played on a board with a 17×17 grid, but by the time the game had spread to [Korea](https://en.wikipedia.org/wiki/Korea) and [Japan](https://en.wikipedia.org/wiki/Japan), in about the 5th and 7th [centuries](https://en.wikipedia.org/wiki/Centuries) [AD](https://en.wikipedia.org/wiki/AD) respectively, boards with a 19×19 grid had become standard. &gt;==== &gt;[**Image**](https://i.imgur.com/j9ivaZt.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:FloorGoban.JPG) --- ^Interesting: [^The ^Go ^Game](https://en.wikipedia.org/wiki/The_Go_Game) ^| [^GameGO!](https://en.wikipedia.org/wiki/GameGO!) ^| [^How ^the ^Game ^Go](https://en.wikipedia.org/wiki/How_the_Game_Go) ^| [^Go ^\(game ^show)](https://en.wikipedia.org/wiki/Go_\(game_show\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgxjca9) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgxjca9)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Not too much. Using Chinese characters for variable/function names is considered as a bad style even in China. But Go *is* better in terms of dealing Chinese characters stored on file systems/databases. (comparing with C/C++)
Have you tried using the "crypto/tls" package to set up the socket for your server? I just finished writing a server that uses TLS and I set up the listener using the crypto/tls library, deployed it on an i386 VPS, and it serves content blazingly fast. Maybe your problem is in the net/http TLS routines?
Well, for one, Acme was created by Rob Pike. So I guess that's probably a pretty big reason!
Nice for namespacing in a package, as well. Method receivers are "sticky" to the receiver type, so they don't clutter as much.
such as python.org, github.com, code.google.com, youtube.com, these sites not working sometimes, espically https connections. it's so painfull to go get code.google.com/p/... in china.
Acme has been my main text editor for a couple of years now. I program in other languages besides Go, and I've never had any issues with Acme or regret the change. It's quite easy to write small scripts (in any language) to get Acme to do what you want.
Here are some gems from you: &gt; I'm just benchmarking go TLS vs non-TLS. &gt; I don't know. What can I read to learn enough to answer this? You clearly know next to nothing about TLS. Yet you create a topic titled "Why is golang TLS performance abysmal?". Then you post your "benchmarks" based on measuring the wrong thing. Your topic is a idiotic ignorance shower without any sign of intelligence. Go read a book first. Sorry, I'm over my quota playing the nice guy for idiots who make conclusions based on ignorance today.
I use Notepad++ as well. Also wrote my own custom lang file https://github.com/scottdware/npp-custom-lang
You should really have a link...
=]
+1 for the name. Retro ("old but cool").
- More info at http://acme.cat-v.org/ - Video tour at http://research.swtch.com/acme - Original paper (I think) at http://plan9.bell-labs.com/sys/doc/acme.html
I usually do. I've found it a pretty clean experience. By the way, there is a not-very-active acme subreddit at /r/Acme (I'm the mod there)
Thanks, Fixed it.
Anyone tried it on a laptop? I was interested, but they make such a big deal about having a three-button mouse in the video tour, I didn't even bother to try. 
As you said, the math package functions take float64's. I usually prefer to add a few convenience functions so I don't have to cast variables all over the place. As long as the function name is clear (e.g min() / max()) I think this makes for cleaner code. Not sure if either way is a "bad" habit, I have seen a fair bit of both reading others' Go code.
Acme and sam are the only editors I use, for any language.
In a Mac (with plan9ports), you can simulate all three buttons using Alt and Cmd and your trackpad. I think in Windows machines the same is achieved with Alt and the Windows key, or maybe Ctrl. I created a patch to use Ctrl to simulate the 1-2 chord, in a Mac.
We're going to open registration desk on Wednesday night after the Pre-Party at 9PM. Those who wish to beat the thursday morning crowds can register early.
Looks pretty easy to replace https://github.com/ian-kent/Go-MailHog/blob/master/mailhog/storage/mongodb.go with a storage agnostic layer and drop in sqlite. 
I had actually considered forking it and making it use an in-memory store by default. Honestly, when developing I don't care about persistence. There was one I saw awhile back that stored messages at flat files on the filesystem, I think. Something similar would be fine for basic persistence. If it's not going to be used as an actual email service there's really no need for the extra dependency and complexity. That said, I love the project and think that with some more storage options it could be a really killer dev tool. Starred the repo!
Oh, this looks awesome. Gonna test it later :)
The term "receiver" dates back to Smalltalk times; in Smalltalk you "send a message to a receiver" rather than "call a method on an object". In Python, the receiver is explicitly named as the first argument of a method and is usually named `self`. In languages like Ruby and Java, you have implicit receivers, where calling `foo(blah)` in a method may mean `self.foo(blah)` or `this.foo(blah)` if applicable. Whereas in most languages the receiver is almost always a pointer (e.g. in C++ the type of `this` within type `T` is either `T*` or `const T*`), in Go it is possible to define methods on a type wherein the receiver is a value. This FAQ explains that making this decision between a value receiver and a pointer receiver is slightly easier if you imagine that you're writing a plain old function, not a method. A general rule of thumb is that if your type is immutable and not a giant struct, then you can benefit from having value receivers.
I definitely agree, but I know a lot of web clients and such do not play nice with a self-signed certificate. I wouldn't be entirely opposed to doing it this way, but I worry that it might even cause more troubles than it's worth, if browsers and other devices will spit out warnings when the user accesses the UI. EDIT: If I were to do it this way, I would probably just pass a session token with each request as a query string parameter. It's probably the path of least resistance.
Make sure to tell people about the leaks in your abstraction. I'd recommend you note your main dependency golang-geo in your readme and that this program is constrained by the rate limits of APIs used in that library (Google Maps, MapQuest). 
You said it was an API, so clients could potentially include your own certificate authority or something to validate the cert. If it's not an API and you need to handle browsers, then HMAC-SHA1 will definitely not work as well. OAuth 2 is something that you can easily leverage existing libraries (or even built your own) but it will require also SSL. You can use OAuth 1.0a which is built on top of HMAC-SHA1 but it is way more complicated to implement on the client side.
Why is a request for code review something that is getting downvotes ? It seems like it would make sense to encourage developers who want feedback.
ab is the wrong tool to measure https performance. Nothing else is even worth tuning until you ditch ab. 
Without HTTPS, it would only have to be done once without HMAC, but I see your point. I'll check into OAuth, or potentially just tokens if nothing looks satisfying. The service won't be anything worth compromising in the first place, but it still bothers me that I might have to resort to an insecure solution.
Well since you are sending credentials in plain-text anyone can get access or recreate tokens so it totally [doesn't matter](http://blog.rootshell.be/wp-content/uploads/2009/05/fail-owned-fence-security-fail.jpg) what you do with API. I would suggest to go with TLS/SSL, (maybe also OpenID) and OAuth2. These will be way easier to implement and much more secure than anything you will come up with on your own. Since Go doesn't have any production ready OAuth server providers, use one in PHP or Java.
It looks to me like Go is only used by 2.90% according to the post?
&gt; Well since you are sending credentials in plain-text anyone can get access or recreate tokens so it totally doesn't matter what you do with API I'm not sure its so clearcut. An HMAC scheme prevents certain opportunistic attacks, even when plaintext is leaking. I know people are probably sicking of hearing about Heartbleed, but sites using such schemes (such as cryptsy) were able to defend against many potential replay attacks/stolen API keys, even while leaking all their request data, by use of a HMAC-SHA512 scheme on top of their pwned TLS. You'd have to capture a user login session (real credentials) and use that to steal the HMAC secret, which is more difficult (login requests are far rarer than API calls) than stealing an API token. Maybe this is already obvious to you, sorry if so.
I suggest asking this question on https://groups.google.com/forum/?fromgroups#!forum/golang-nuts. 
That's very cool, thanks for the mention. I haven't played around with Haskell since my languages classes in school. Seems very clear and readable.
Agreed. This sub averages under 10 posts per day, almost all of them on-topic and interesting to *someone* interested in Go. Not sure where the downvotes are coming from.
Instead, I would prefer to use a database built in Go to get easy deploy: *Key-value* * https://github.com/boltdb/bolt https://godoc.org/github.com/boltdb/bolt * https://github.com/cznic/kv http://godoc.org/github.com/cznic/kv *SQL* * https://github.com/cznic/ql http://godoc.org/github.com/cznic/ql 
Seriously. If anything, I'd like to see more code review requests. Not only does the OP get a good critique, but it would be a good opportunity for everyone here to learn something new.
Sweeeeet!!! I have been looking for something like this for a month! edit: This seems to be a thin layer over https://github.com/kellydunn/golang-geo. Just to clarify for anyone else confused at how so much could fit into such a small package =)
Thanks &gt;In things like your messagesIndexJsonHandler, you are handling errors with glog as well as your own writer function. This is not a bad idea, but it is happening a lot. Maybe make some generic error handlers? Just an idea I had previously added helper functions but it caused masking of useful info like the file name and line number from which the 'line' was logged. e.g. log message with the filename and line #. I am not sure if there is an easy way to get this information from a helper function. Like you said a helper function would greatly reduce the verbosity of code. Do you have any pointers at hand for this? I0422 20:26:18.902777 16735 config.go:30] loaded config: &gt;Why is formNameWhiteList in the global scope when it's only being used by one function? I wanted to avoid creating a regexp object for each function call, Is there a way to not have it in the global scope and call regex.Compile on init? Do you thing the config would be a better place for this? Thanks again for your time and valuable comments and the praise. Most reviews just point out the bad things (which was all I was looking for), It is awfully nice of you to mention the things you liked :)
Looks cool! This project complements a streaming media server I am currently writing in Go! I'll definitely check it out.
 func randint(min, max int) int { rand.Seed(time.Now().UTC().UnixNano()) return min + rand.Intn(max-min) } 
Hey, no problems man. We're all learning =) &gt; Like you said a helper function would greatly reduce the verbosity of code. Do you have any pointers at hand for this? I like doing something like this: https://github.com/jadekler/git-go-websiteskeleton/blob/master/app/common/error.go. Just a small function that checks error and prints a stack trace if it is not nil. You could probably throw something small like that in your main.go. &gt; I wanted to avoid creating a regexp object for each function call, Is there a way to not have it in the global scope and call regex.Compile on init? Do you thing the config would be a better place for this? I see - that's a good concern. You could put it in your config but your tradeoff in that case is readability of your code (e.g., where is this random regex thing coming from?), so I'm not sure. It may be that your current solution is the best choice. =) I am rather lazy about managing small variable allocations - I generally opt towards the less performant way of simply re-defining it each function call, so I probably shouldn't advise on this topic if your concern tends towards memory management.
It seems like it has some really good ideas, but I'm ultimately just not comfortable enough with my mouse for this editor to work well for me. For example, in order to execute most of the "chord" instructions, I have to use both hands, as I can't seem to do it with a single hand without a LOT of false clicks, resulting in executing instructions I didn't want.
You might find my [post on end-user auth](http://words.volant.is/articles/authentication-golang-web-applications/) helpful. In particular, hawk seems like it might fit (some of) your use case.
Here is the changelog: http://gcc.gnu.org/gcc-4.9/changes.html
I just ran it and poked around, and that was the usage figure. Not in any way on a massive install with many projects. But I don't think raspi would be a good choice for that either.
Not sure if this is what you're looking for, but I'm personally quite fond of the [email](http://github.com/jordan-wright/email) package I created to make robust sending emails really simple.
$200 for a "cloud" thing... I could just buy 2 2TB drives for that much.
Can my mom buy the tech know-how, support, and standalone PC for that. You're not the target market, but that doesn't imply the market doesn't exist.
Cool. I'd be interested in seeing an objective comparison to Martini.
I like [Martini](http://martini.codegangsta.io/).
One more vote for Martini, but if you're looking for something a bit more comprehensive then [Revel](http://revel.github.io/) is a good choice, too.
alright! I can dig into this. 
I think people are rediscovering the benefits of static typing for performance and correctness reasons. The latest generation of statically typed languages[0] all have some level of type inferencing which helps. If Python is fast enough for you, it’s a fantastic language. The problem is once performance or codebase demands scale, dynamic typing rears its ugly head and there are no simple solutions. At work we sidestep this issue by writing a plethora of tests, but now dynamic typing productivity gains are offset and we spin up a lot of AWS instances for performance. [0] Go, Rust, Scala. Haskell and OCaml have had it for a while.
This library is pretty sweet. I'm going to start using it, because fmt.Println just ain't cuttin' it any more.
Another vote for Martini. If you want something even lighter, I can recommend Gorilla. Though for simple things go's built in net/http library is miles ahead of most other languages.
Web pages or apps? very different needs, there.
[net/http](http://golang.org/pkg/net/http/)
The great thing about Go is that it's pretty much a "batteries included" language. I use very few external libraries, as it has built-in http, regex, gzip, crypto, big integer, reflection, and json libraries. Check out the package API docs at: http://golang.org/pkg/ 
Anyone tried their product? It seems expensive. It costs $218.00 for 1TB hard drive plus $49/year after the first year. 
apps
oh dear! This reads like ... making a bash script or a less painful batch script. Yeah.. I'll have to put some more nights aside for this. 
Why 5 downvotes? Reddit community just jealous? This is awesome!
I'm guessing you haven't used Go much based on the `:=` comment. If you haven't yet, I would recommend going through the [tour](http://tour.golang.org). After that, try reading the [Effective Go](http://golang.org/doc/effective_go.html) page form the website. You should be able to hit the ground running after going through those.
I just started reading into it today. Many new things to learn. I didn't realize how deep the tour is. The type of thing that must be done in chunks in my case. I look forward to the challenge, this language seems to hold promise. 
It uses the Stringer interface by default, which I find annoying. You can turn it off with `spew.Config.DisableMethods = true`. Other than that though, it's invaluable and awesome.
Once you learn how the stdlib is put together though, you'll love it. Give it a bit of time.
I think [tomb](https://launchpad.net/tomb/) is so useful it should be in the stdlib. [testify/assert](https://github.com/stretchr/testify) is also a nice assertion helper for tests.
If I'm reading what they offer correctly, they've basically built an ARM based NAS with a single 2.5" 1TB drive for your data, then another tiny drive (maybe even like a cheap flash drive ... dedicated to "backing up" other SmartMonkey's via peer to peer "synch"). Their software is a mixture of open-sourced projects nicely bundled (Linux or BSD OS, things like SMB, etc). Then basically use their servers to command/control/coordinate the syncing (likely via bitttorrent sync) of your SmartMonkey device with other SmartMonkey devices ... assuming you pay for their service. As noted by another redditor here, nothing special for the someone technically literate to do by themselves for a fraction of the cost ... but there is likely a market for those that are only plug and play types. To attract them, the key is the iOS and Android apps for sure ... along with a nice pretty WebUI.
Having recently embarked on a magical mystery tour of Go web frameworks, I'd like to share what I've learned. The back-story: I'm professional senior-level web developer with over a decade of experience. I've worked with dozens of languages professionally and wanted to put some Go code into production on a hobby project. I was hoping Go would minimize the server's footprint and be able to handle a decent amount of traffic without me needing to upgrade to a better server. Ultimately, I wound up implementing the same site in several different Go frameworks. Here's what I found: * [Revel](http://revel.github.io/) - Great framework. Based on others' recommendations, I got started with Revel. I found it easy to get up and running. The documentation -- while not quite complete -- is sufficient to handle most common cases. And the code is easy to read and follow if you get stuck. Nice features include convenient extensions to the html/template package, hot code reloading so you only have to refresh the page when you make a change to the code instead of having to recompile and reboot the server, and sensible defaults for routing, sessions, and session flash storage. The server's performance was comparable to serving the same content via Apache + PHP, which I tested. Unfortunately, I was already running nginx + php-fpm on the same server and getting slightly better results. This was slightly disappointing. Because of this I decided to test other frameworks to see how they compared. * [Beego](http://beego.me/) - After playing with this one briefly, I realized that it was apparently a fork of Revel. I couldn't figure out what was different, exactly, without diffing the source so I decided to move along. * [Martini](http://martini.codegangsta.io/) - Martini was really simple to set up and get up and running with but the documentation is sorely lacking. Luckily, the source is fairly easy to follow along with so I took a couple days and rebuilt the app I was working on with Martini. After being pretty pleased with the results, I decided to move forward with fleshing-out some more parts of the app, but had to stop when I realized Martini lacked TLS support. Since the site I am building is meant to be served nearly exclusively via HTTPS this was a dealbreaker. * [Gorilla](http://www.gorillatoolkit.org/) - Excellent documentation, readable code, framework not included! This isn't a framework so much as it's a "toolkit" -- a series of utilities that help you build your own site or framework without forcing you to do it any particular way. It provides session management, routing, and a variety of other tools. You still have to use net/http and html/template to piece together your own site. It wasn't very hard to do. After a hiccup with the TLS performance benchmarking and some help from /r/golang, I got the site up and running and it just screams! * [Goji](https://goji.io/) - This was featured today on [Hacker News](https://news.ycombinator.com/item?id=7629485). The site's gorgeous and whereas I don't have any desire to rewrite my web application a fourth time it may be worth a look to someone who hasn't yet chosen a framework. All-in-all I'd say Revel is the most mature of these projects and definitely worth giving a look if you don't know where to begin. If you want to learn how to write a server from scratch in Go, then Gorilla may let you get up and running without having to hash out all the details of session handling and routing by yourself.
Your Goji link goes to Gorilla.
Thanks! Corrected.
I'm curious how you came to the conclusion that Martini does not support TLS. I (and many others) have no problems using TLS with Martini. Is it simply the lack of documentation on using TLS with net/http?
I came here to post this. I've been using Martini lately and love it. Would love to compare the two.
Martini does work with TLS. :) You can just use it as a handler for the http.ListenAndServeTLS call. 
If you want a *really* random number (that's safe to use in cryptography or against attackers trying to guess the random number) you should use `crypto/rand` (after making sure `/dev/urandom` has enough entropy by checking `/proc/sys/kernel/random/entropy_avail`). If you don't care about that and just need an insecure random number, use `math/rand`.
I like martini too. gj
for simple web stuff, martini: https://github.com/go-martini/martini
[Goji](https://goji.io/), a micro framework, was [announced today over at HN](https://news.ycombinator.com/item?id=7629485). The developer posted an interesting [comparison to Martini](https://news.ycombinator.com/item?id=7629548) in the thread. https://goji.io/ https://github.com/zenazn/goji
&gt;Support for Plan 9 The circle is almost complete.
You can't tell me what to do you idiot. See how I'm not holding my tongue, idiot. Also, I'm also contributing in two ways. 1) pointing out your flaws so that people won't take your false claims seriously. 2) pointing you to a correct explanation what you're doing wrong, that has already appeared in the topic; surely there's no point in copy-and-pasting it. To sum it up again, this whole topic is just moot, a waste of people's time and reddit's space, and is nothing more that a wrong claim based on your ignorance. No, I won't say "it happens, let's sing together and forget about it". And again, go read a book first, Mr. "[professional senior-level web developer with over a decade of experience](http://www.reddit.com/r/golang/comments/23phrc/go_web_frameworks/cgzggjo)" yet who doesn't know the first thing about TLS.
No surprises here. He is the guy who simply doesn't even know the basics of TLS, yet [outrageously claimed that go's TLS performance is abysmal](http://www.reddit.com/r/golang/comments/23hltg/why_is_golang_tls_performance_abysmal) a few days ago by measuring the wrong things.
/u/MaxK I apologize if the above comment reads as harsh. If you are having a hard time working with Martini and TLS I'm interested in hearing your feedback as I desire for Martini to have the best documentation possible. Thanks for the feedback so far!
code in the main package is generally more difficult to test. I'd recommend moving most of your logic into a separate package and keep your main package as thin as possible... just flag parsing, starting up the server, etc.
I feel like its more like web.go. web.go is dead, since its creator hasn't updated it since forever.
Someone on HN mentioned that os/fsnotify was [pushed back to 1.4](https://groups.google.com/forum/#!msg/golang-dev/bShm2sqbrTY/IR8eI20Su8EJ), which is kind of disappointing.
How do you use Go with NaCl?
I suppose we'll just have to keep an eye on https://code.google.com/p/go-wiki/wiki/NativeClient
Then again, from what I can follow from that discussion (admittedly, not that much) it sounds like they have plenty of stuff that needs to be sorted out before they want to expose that API to the public and be stuck with it.
Plug for my little skeleton (https://github.com/jadekler/git-go-websiteskeleton) for anyone that wants to stick to net/http and some basic mux. :)
Done! Now you can see the "schemas" with gitql -show-tables Thanks for that good idea
Thanks, CheckError seems to do a much better job of printing debug information.
Thanks, I've had difficulty with organizing modules and getting issues with circular dependencies in the past, Do you have any pointers on how to organize packages?
Sync.pool finally. So much boilerplate code can now die. 
Sure, but have you reached the point yet where compile times are becoming an issue?
Ermahgerd.
That post mentions how it would benefit go tools, but the package itself is very useful.
how about http://www.golang-book.com/ ???
See the original post's second paragraph under **Rule 1 for good Go errors**.
&gt; The documentation -- while not quite complete I'm a Revel maintainer. Any tips on how we can improve it? I'd like to give the entire thing an overhaul, but any specific examples of things that were lacking or frustrated you?
Right, and then OP goes and does it anyway.
I just started a club to try to help people learn go. Its called the Go Code Club. The first lesson starts this week. http://gocodeclub.com
If I am reading this correctly (and I include this caveat precisely because I'm not 100% sure), that's not true. The original error is recoverable, via `.Cause(err)`. The "core" problem with collapsing it to a string is that the data is _gone_. The question of interface is a secondary one (important, but secondary). Note the Go core library already has cases where it returns errors that wrap errors.
I'm anxiously awaiting all of the recorded content from Countersoft, I really really appreciate that they're doing that. "Yes! The awesome folks over at Countersoft have offered to sponsor the recording of the talks. More details will be available as it's worked out." from the website. 
While I think requests for code reviews or project announcements are fine, I think this post was just poorly formed. Release announcements should include the name of the project and link directly to the project page / source. Code review requests should include the name of the project in the title and probably be a text post. For full-project reviews, some guidance from the author as to the layout of the source and any particularly tricky spots are useful and make reviews much more productive.
Yes.
Just landed from Seattle. See you at the party tonight. 
Yes, you are reading it correctly. When using errgo, the convention is to always use errgo.Cause when checking errors for particular types or values. That way the code will work regardless of whether the error has been wrapped or not, assuming the cause has not been masked. 
Really wanted to make it out but I'm far too busy at work to get time off. I hope the presentations and videos will be up shortly after the event.
For everyone flying in, the RTD bus is a good, cheap transportation option. $11 each way and runs about every 30 minutes. Mostly direct to the downtown station near the hotel. Bring $11 cash. 
Although the Post/Redirect/Get pattern is mentioned in passing in the docs, it's never explicitly spelled out that Revel *requires* you to use that for POST data. I spent more time than I'd like to admit trying to figure out why the flash wasn't working as expected.
At the SFO airport now, working on my presentation. 
Shell, CSS, Perl, Python and now Go. All of them are more or less dark blue. I learned to love the purple and I learned to accept the yellowish brown (it's Go as in gold after all), but now it's barely distinguishable from the other languages many people here frequently use :(
Kind of interested why it wasn't called libav-go if it's just bindings.
Camlistore https://camlistore.googlesource.com/camlistore/+/master http://camlistore.org/
The term API is super broad/vague. Could you be more specific about the kinds of environments and types of APIs you are trying to learn about? Maybe start a paragraph with this fragment as a started "The kinds of things I'm interested in knowing more about are"
Defer's real value is that it's guaranteed to run even if code "below" the deferred function panics. Using it to "get around" code having multiple exit points, without using the "even if there's a panic" aspect of them, would be a code smell, IMHO.
The type tells the compiler what the value has to be. The name tells the programmer what the value does. I think it fits in very well with Go's goal of being easily understandable source code. For example, a function signature that returns a string could be anything. One that returns a string named filename has the most important information exactly where it needs to be.
Finished mine on the plane...
Sitting in SFO. Can't wait!
wish I could attend.. hopefully next year. Can't wait to catch the talks videos' online as soon they get published. 
Thanks for the feedback!
Who's doing Go in Michigan? I'm in Kalamazoo, you hiring?
In the taxi now!
Thanks for listening!
Have fun all you lucky Gophers. Wish I could join you, have a great time and bag lots of schwag!
So many people can't go to America for this big meeting like me, Could someone share some photos or videos on th gophercon? Thanks!!!!!
I'm from Kalamazoo as well! Not a professional gopher yet, but hopefully soon!
I took it in this afternoon and it was very easy and comfortable. Beats an $80 Uber fare. 
all of the talks will be recorded and posted. https://mobile.twitter.com/GopherCon/status/458992492906835969
I noticed in a few places (utils.go for example) you are logging errors, then returning null or empty string. It's a standard pattern to return the error along with an empty value so the caller knows the value is invalid. It also gives more context about the problem.
In a cab to the Marriott now!
This is excellent. I've wanted something like this.
I'm going to be there starting tomorrow. Ended up getting an airbnb in Boulder ( working from [my company's](http://quickleft.com/) Boulder office Mon-Wed). Excited about it!
Actually this is what author commented on HN &gt; Actually, Goji grew out of a single deficiency in "pat": the fact that it does not have a standard way of defining request context. &gt; The big use case here is how you'd write a middleware that did authentication (using API keys, session cookies, ???) and emitted a username for other middleware to consume. With net/http, you end up with a lot of coupling: your end handler needs to know about every layer of middleware above it, and you start losing a lot of the benefit of having middleware in the first place. With an explicit middleware stack and a universal interface for middleware contexts, this is easy: everyone can code to the same single context object, and instead of standardizing on weird bound variables (or a global locked map a la gorilla), you just need to standardize on a single string key and a type. &gt; I think my ideal world would involve Go providing a map[string]interface{} as part of the http.Request struct in order to implement this behavior, but until we get that, I think Goji's web.C ("the context object") is the next best thing. &gt; There's one other thing pat hacks around: the issue of how to pass bound URL variables to the resulting handler. At first I was a little grossed out at how pat did it, but I've sort of come to terms with it. I still think Goji's way is better, but I don't think it's the reason I wrote (or a reason to use) Goji.
And if you want to take it with you (offline), they have the [FULL PDF version of the book](http://www.golang-book.com/assets/pdf/gobook.pdf), too. EDIT: I'm currently working/learning off this book. The physical copy annoys me since the page numbers are by the book spine; maybe missing an offset page in print.
I wish I could go... Oh well, next time.
Flew in from San Diego, yesterday; excited for it to start.
According to the linked code, the unserialize does this... for _, member := range value.Object { result[member.Name] = unserialize(member.Value) } ...so you've already got a map[string] interface{} there. It's all quite simple code though - most of it is the un/serialize, so maybe you'd be better doing the http.Post yourself and unmarshalling the result directly into a struct with the same definition as specified in the data sheet.
Even without the defer, the fact that you can look at the returns of a function and understand what they mean by reading the names is great.
It's relatively fast, you can add something about 100 000 short strings per second into it and one million short strings (hex numbers) takes something about 250Mb of memory.
https://github.com/elcuervo/minimalweather
Kalamazoo here too, but I work from home for a company in Chicago :)
I think I may just join that. Is there a set schedule? 
So I'm not mistaken there is no authentication layer? Would it be possible to add?
Not as of yet. I am announcing the first topic today. I will be taking community input with where to take things from there.
Yes and no. defer means "ensure this runs when this function exits". That's about it. Yes, it happens to insure you against panics, but it also ensures that you don't "forget" to do something that you know you need to do at the end of the function. This is pretty valuable if someone decides to modify the code later to add an early return. The defer still works, whereas simply calling the same code at the end of the function would not. Defer isn't free, so you should use it judiciously, but preventing programmer error can be pretty valuable in and of itself.
If you're at GopherCon and want to contribute, submit at http://gophercon.sourcegraph.com/submit or tweet at us to cover a specific talk. And if you have any suggestions for the liveblog, please let us know!
Thanks for liveblogging this from all the gophers that couldn't make it!
Forms use HTTP method Post, so you'll have to add a router to that. (goji.Post()? not sure bout goji) The values should be in *http.Request, which is r in your parameters. 
well they can use Get as well. So how do I use ` r ` then?
We are liveblogging at http://gophercon.sourcegraph.com. Let us know if you have any specific questions you want us to ask any of the speakers.
Docker has a really good API, you can find the top level router and everything here: https://github.com/dotcloud/docker/blob/master/api/server/server.go
Not if you specify `method=get`...
change goji.Get to goji.Handle I think, I have never used Goji, and then in the hello func, name := r.PostFormValue("name") or do r.ParseForm() then use the values in r.Form. I prefer the first way. http://golang.org/pkg/net/http/#Request.PostFormValue
Use [FormValue](http://golang.org/pkg/net/http/#Request.FormValue) to extract html form data. And then r.FormValue("form-field"). package main import ( "fmt" "net/http" "github.com/zenazn/goji" "github.com/zenazn/goji/web" ) const form = `&lt;form action="/hello/save" method="POST"&gt; &lt;input type = "text" name="q"&gt; &lt;/form&gt;` func hello(c web.C, w http.ResponseWriter, r *http.Request) { if r.Method == GET { fmt.Fprintf(w, form) } field := r.FormValue("q") fmt.Fprintf(w, "Hello, %s!", field) } func main() { goji.Handle("/hello/:name", hello) goji.Serve() } 
Okay, here is what I have so far in my hello.go: package main import( "fmt" "net/http" "github.com/zenazn/goji" "github.com/zenazn/goji/web" ) func hello(c web.C, w http.ResponseWriter, r *http.Request){ name := r.PostFormValue("name") fmt.Fprintf(w, "Hello, %s!", name) } func main(){ goji.Handle("/hello/", hello) goji.Serve() } and here is my hello.html file: in the body: &lt;form action="" method="get"&gt; &lt;input type="text" name="name" /&gt; &lt;/form&gt; How do I connect hello.html to hello.go so that the golang code gets what is in the input and returns hello, name in the form submitted page?
I will be working on an X-Trace/Dapper/zipkin - style tracing service.
socket.io
Can we get this stickied for a while?
You specified get on your form. The values wont be in r.PostFormValue().
what about python cookbook?
Sorry for OT: How about this one? https://github.com/mattn/go-xmlrpc
libphonenumber: https://code.google.com/p/libphonenumber/ Somebody started, but they didn't get super far: https://github.com/teltechsystems/gophonenumbers
oh, so is there r.GetFormValue()? Also how am I supposed to organist the files? Right now hello.html and hello.go are in the same dir. Is hello.go supposed to be in /hello/ ? How does the form submission know to submit it to hello.go and not another file in that dir? For example, in php, the action is then changed to action="/hello/index.php", so should I do action="/hello/hello.go" ?
Qt would be nice to have in Go. As far as I can tell, the only reasonable way to do desktop apps right now is to skin WebKit and connect to a local Go server.
I was half joking, but it would be nice to have some n-dimensional arrays, and go is perfect for using functions in a vectorized manner.
It should be just [FormValue\(\).](http://golang.org/src/pkg/net/http/request.go?s=23078:23124#L795) You tell the form where to submit, and have your routers handle the submission. e.g. &lt;form action="/sds" method="get"&gt; &lt;input type="text" name="name" /&gt; &lt;/form&gt; will get handled by your router: goji.Handle("/sds", hello) 
Looks interesting, I'll give it a try and see how it goes. Thanks. The returned data looks a little easier to deal with, but I'm still getting my head around interface{} and reflecting data types. 
I swear I saw QT go stuff almost a year ago.
XMPP library/server.
I guess the big question is whether you could get reasonable indexing notation for arbitrary dimensions to access the underlying continuous 1d slice. A numpy array is basically just a struct holding a pointer to the first element of the array, a type, strides to tell you how far you have to move in memory to access the next row and column, the number of elements and a handful of flags. 
Thank you very much for your help. So I have hello.go at $GOPATH/src/web/hello.go and index.html is $GOPATH/src/web/site/index.html Here is what hello.go has: package main import( "fmt" "net/http" "github.com/zenazn/goji" "github.com/zenazn/goji/web" ) func hello(c web.C, w http.ResponseWriter, r *http.Request){ name := r.FormValue("name") fmt.Fprintf(w, "Hello, %s!", name) } func main(){ goji.Handle("site/", hello) goji.Serve() } and then index.html looks like this: &lt;!Doctype HTML&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Form&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method="get"&gt; &lt;input type="text" name="name" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; So I `go run hello.go` and then I open index.html, locally in the browser ( because I don't have a server that has Golang yet ), and the input field comes up. I type and submit, but it goes to $GOPATH/src/web/site/index.html?name="whatITypedAndSubmitted" What am I doing wrong? Why doesn't it pass the value of the name URL parametre to the GoLang code? 
Uhm, if you don't specify a form action it's gonna use the address you're in currently. Did you go to localhost:8000 when you ran your server?
pygame a man can dream
I am going to port colorific library from Python to Go next week. Not sure how golang's image library will stand up to PIL. This is gonna be hard.
Oh, okay. So I change the form action to point to the Dir hello.go is in or to the file hello.go ? No. localhost:8000 is different than the location of index.html. I want this to work locally, but then with my domain later.
Nusoap or some soap library
sqlalchemy and alembic
Something I noticed a while back is that go lacks an SVG parsing library. There's one for writing them, but no parsing is supported. Not that it's an easy thing to do.
Not exactly what you're asking for,but a liblasso interface or even just a from scratch saml2 implementation would be so nice to have. Go is a systems language and I think having some SSO options would really help in the enterprise and business integration world. 
Spring Security for Go would be nice. Any ACL based security really.
that would be very great, but maybe it needs a pretty loooong weekend. [Python Cookbook](www.amazon.com/Python-Cookbook-Alex-Martelli/dp/0596007973) DO offers a wealth of useful code for all Python programmers.
No, it has existed for a while in alpha form in the [qml](https://github.com/go-qml/qml) project.
There was a pretty decent one (cjones.org/hg/go-xmpp2.hg/xmpp) but it only really implements the very core of the language but not things like MUC. It looks like it recently disappeared.
Or "at least", blas + lapack.
Not really a favorite, but a [SUDS](https://pypi.python.org/pypi/suds) clone would be handy. 
Mutagen, the Python library for handling audio files.
Something like https://github.com/jackyb/go-sdl2 ?
As it has been said in the thread, niemeyer works on a Qt binding it pretty actively. It works on Ubuntu Phone already and handles touch events, even while working on the desktop! So it's a great effort and I don't want to duplicate work/split development for a better cause (a.k.a. Wayland/Mir).
*sqlalchemy* Go has now a pretty good ORM(-like) library selection, please point out any features that you miss from, say, gorp or gorm? *alembic* It has it's uses but as in the near future I don't see Go used in a graphics pipeline and the project's huge LOC is a bit daunting. Maybe later :)
This looks like the one! Thanks!
esprima - produce an equivalent of http://esprima.org/demo/parse.html
That's awesome. I need to join. I think the thing that helped me with other stuff on things like Codecademy (I get that it's not something in which you'll learn the entire language, but will get a nice intro to a few different languages), was that there were exercises in which I could learn syntax and then directly apply it. 
pygame is basically just python wrappers to to the C library SDL2, which has numerous Go wrappers.
&gt; Numpy and the Python scientific stack is really Python's killer feature for a lot of people. I wouldn't say that. What I would say is that without a decent matrix algebra module, some stuff becomes prohibitively time-consuming to implement. That's why BLAS and higher-level libraries/components are so important. Even if they aren't great, they do exist.
Agreed. It would be awesome if this at least had some Ajax Long Polling support, to greatly increase compatibility. 
libtoxcore, might be only wrappers, but that would open up the development of *better* webkit+go-based cross-platform Tox clients. I tried that, but unfortunately I just can't understand some of the quirks of cgo.
The [alembic](http://alembic.readthedocs.org/en/latest/) he's referring to is a tool for managing SQLAchemy schema migrations.
Go hasn't got a good interpretation story. I've looked into it, and it's virtually impossible to bodge one on right now. Go 2.0 would pretty much have to take it as a feature for this to happen. Yes, I'm aware of gotools/go/ssa and such... on the journey of a thousand miles, Go has traveled a couple hundred in the last year, but there's still a long way to go, and some of the problems are pretty fundamental (like runtime namespace access not seeming to exist right now, I see no way for a interpreted go "script" to access the "fmt" module in a generic way, as opposed to preloading a "blessed" set of modules which is way less useful).
jinja2
No. Just no. We need to quietly let soap die. Please. 
Flask! Flask was the first framework that I could really dig into to learn python for the web from scratch (ie, more than just modifying things that other people wrote). If there were a Go version of Flask I would learn Go tomorrow!
That's essentially what the guides are saying but I guess I'm not making the connection of how to get the tags into the page at https://X. If our code is hosted on github, how do I get the tags into the page at https://X?
That would indeed be tempting.
I think I see it now. The meta tags aren't added in github but are on a hosted site which contains the HTML. I think that's where I was missing the point. 
I ran your code and made a working version [here](http://play.golang.org/p/Om9vIsMnZP) Obviously wont work on that site, but if you replace your hello.go file it should work. just go to localhost:8000 on your machine to see it. It is probably not idiomatic to how goji works, but it seems to work fine for me. It also works with either post or get depending on how you want the form to work. Edit: Oh, also change the form action to action="site"
Mostly everything you've mentioned looks good at a glance -- it's usually good, especially when you're just starting, to see how far the standard lib can take you. A couple remarks: - For background jobs, why not just use goroutines? - For AWS calls, try [Go-AWS-Auth](https://github.com/smartystreets/go-aws-auth) -- it authenticates your requests to AWS which, in my opinion, is the hard part. You'll find it's quite easy to use and doesn't do any black magic.
Thank you for your reply! I'll take a look at goroutines. So, for AWS, use Go-AWS-Auth for authentication and then use HTTP APIs for the AWS services that I mentioned.
Thank you very much! It is finally working! Now, i am running the file through the terminal, how can I end it without closing the terminal? `killall hello.go` doesn't work.
I would check out "squirrel" for avoiding both orm and string manipulation of sql. (On my phone, so you'll have to search for it, sorry.)
Thanks! This, I guess: https://github.com/lann/squirrel
And also Goji, which was released today: https://goji.io/
Personally, I really like sqlx - https://github.com/jmoiron/sqlx It basically turns db access into something similar to json marshal/unmarshal. So, you still need to do sql queries, but you can easily get the rows in and out of structs without a lot of boilerplate. I prefer it to more normal ORMs because I like that it doesn't have any magic. I can still see everything that's being done.
In the terminal just press control+c
oh, awesome. Thank you! Thank you very much for your help!
Thank you!
Thanks! I'll check gorm out. About the debate between raw queries and ORMs in Go, all that I've seen is this: https://news.ycombinator.com/item?id=7629686
Thanks! I also found this which also mentions sqlx: http://jmoiron.net/blog/golang-orms/
maybe python requests
Go check out https://github.com/tuxychandru/gorepos It is a simple lookup service that you can run at a url like 'mycompany.com' and it will preform lookups from a config file to map remotes to logical import paths. We use it simply because our git server does not support go-gettable urls. Other uses are being able to reference 'mycompany.com/somepackage' instead of 'github.com/sumedude/somepackage' so that you have flexibility down the road to move it or fork it without rewriting import paths. 
Cool, I have been playing with a similar product/feature using noVNC (https://github.com/kanaka/noVNC), with Go for orchestration (via my libvirt-go wrapper) and the websocket proxy. To my surprise the vnc proxy part of it was really simple to do using the stdlib and existing websocket libraries. Go really kicks ass for these kinds of projects
I would agree with you. But our main data provider gives us data using Soap. The fact they use soap is one of the few reasons we haven't completely switched from PHP to Go. 
You poor, poor souls. You could also write an interface layer using your existing code to expose that data in a more same manner. I've been known to stand up a Java app to do requests and translations before. :p
I would be very interested in seeing this! Is this something you're able to share? Blog post, example code, whatever. 
&gt; Go’s built in net/http package means we are able to do live deploys and keep on-going development invisible to users. Can anyone elaborate on this?
Ew, slide"share"... 
Something to do with listeners that hand off requests/sessions before stopping, I don't actually know what that means, but I read it somewhere.
I assume they will eventually show up here as well... https://github.com/gophercon/2014-talks 
It wouldn't be particularly tricky to port, but it's not trivial either. Maybe an hour of work. Why do you need us to do it for you? Is some part of it hard for you? How will you integrate it into your stack?
See the strings and regexp packages. In fact, I infer from "looking for values in an array" that you haven't followed the basic documents on golang.org (the answer is a map by the way). If you really want to learn, I suggest you read first (rather than trying to write). The language spec is small, and the libraries you need are simple enough.
It could be, but do you really need it? You have a class that doesn't really hold any data, that in the $dict. So you should perhaps just have a function that reads that takes a file and returns a dict ( which seems like it could just be an array ). Honestly just go for it if you want to learn. Have some test data if you're worried you'll get it wrong. 
The answer to such questions can be found in Effective Go and standard library.
datejs
 for i, token:= range matches { ... } IIRC. token will be the current value of matches, i is the index (you can and probably will have to omit that by replacing i with _ if you are not using i)
I will check this out. Thanks!
This is one of the most naive/meaningless comparison of languages I've ever seen. At one point the author is actually comparing line count although the pieces of code are barely similar in what they do. Comparing languages by line count is pointless anyway ...
Oh shoot, damn you Google :) We already have something pretty similar called [goose](https://bitbucket.org/liamstask/goose), check it out!
How does it improve on the existing template stdlib? 
+1 to using Martini.
1) copy paste template from jinja2 (so all the static websites tools in python), django, or drupal 8 - so "templaters" can feel at ease and not learn another syntax. 2) doing nested templates ( already possible with existing template stdlib, see http://stackoverflow.com/questions/11467731/is-it-possible-to-have-nested-templates-in-go-using-the-standard-library-googl ) 
iregretmostofit.com is available :)
Can you format this better, i.e. appending 4 spaces on each line in the code block? Edit ---- Never mind. Here it is formatted: package main import ( "fmt" "net/http" "github.com/zenazn/goji" "github.com/zenazn/goji/web" ) const form = `&lt;form action="/hello/save" method="POST"&gt; &lt;input type = "text" name="q"&gt; &lt;/form&gt;` func hello(c web.C, w http.ResponseWriter, r *http.Request) { if r.Method == GET { fmt.Fprintf(w, form) } field := r.FormValue("q") fmt.Fprintf(w, "Hello, %s!", field) } func main() { goji.Handle("/hello/:name", hello) goji.Serve() } 
Thank you.
[Blog post reflecting on Russ Cox's excellent talk](http://gophercon.sourcegraph.com/post/83922236197/reflections-on-russ-coxs-c-to-go-talk)
Check out https://github.com/ant0ine/go-json-rest
Hah, now I realize what felt different about GitHub.
You have to check that the second map exists, as the empty value of a map is nil the values in the map will be nil. Something like m, ok := toReturn[i] if !ok { m = make(map[string]string) toReturn[i] = m } I dont know about your usecase but it might be better to use a struct instead of a nested map?
&gt; Go’s package system makes sharing code incredibly easy. That means we can share the code developed for the new console between projects seamlessly. This is what green master policy enforcement do to code sharing.
They are starting to show up in the github repo.
I think that the net/http example of panicking is not quite what you think it is. The trend I've seen in stdlib packages is that panicking can happen if some statically-verifiable property is broken. In this case, the path arguments are expected to be static string literals. These should be correct at compile time, and so panicking is essentially a way of saying, "this is an incorrect program that just managed to compile, but in an ideal world, it would not have been allowed to compile; try again."
That's kind of what I was getting at. I'm sorry if that wasn't clear enough.
Don't you want to delete by key, not by value? In other words, your `for _, mapOne` is only using the values in the maps, not the keys. Try using something like `for key, mapOne` and deleting by key.
Nice article. One thing not mentioned is that error messages in general should begin with a lowercase letter, so the messages can be printed and combined with other errors using colon separators. The "HTTP" examples are okay, because that's an acronym. http://golang.org/doc/effective_go.html#errors http://blog.golang.org/error-handling-and-go 
I thought I tried that. Oh, I was doing: for key, mapOne := range toReturn{ if stringInArray(mapOne["token"], stopWords){ //delete(toReturn, mapOne) delete(toReturn, toReturn[key]) } } and was getting the same error. But I think you meant this, which did work: for key, mapOne := range toReturn{ if stringInArray(mapOne["token"], stopWords){ //delete(toReturn, mapOne) delete(toReturn, key) } } 
I first heard about docopt in a video-recorded talk from PyCon. I visited their page again today, www.docopt.org, and learned that docopt is also available for several other languages, including for go.
It's a cool idea in theory, but I don't really like it in practice. The Go port is especially unidiomatic. It throws away type safety and adds a bunch of unnecessary parsing at runtime. (It also makes multilingual help strings a pain, but I guess not many projects worry about that even if everything else is translated.)
okay, thank you. The reason I ask there is that no one answers my questions there. But I'm learning. I think soon I'll be able to solve problems as they come to me. Thank you all, greatly, for the help.
No, this convention is not meant to compare errors. It's only so that when printed out, you can assume the error will be prefixed lowercase, and possibly give you context as to which module originated the error. I just put links in my original comment to more error conventions.
Maybe someone could take the idea of docopt but implement it such that the concerns you raise are addressed? Personally, I don't think I would be able to do it at the moment, but maybe sometime in the future I can? Or someone else could do it if they find it useful.
Via HN. Discussion: https://news.ycombinator.com/item?id=7651988
https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Error_Strings
Could you possibly provide us your lexicon.txt file? I can take a hack at this for you.
oh, yes, of course, I forgot. Here it is: http://pastebin.com/BiqviPGj Thank you very much!
Line 37 you have an infinite loop. If err is nil, it never changes in the loop so it will always be ni and never print anything. It should be an if. line, err := r.ReadString('\n') for err == nil{ lineAsArray := strings.Split(line, " ") tagsSplice := lineAsArray[1:(len(lineAsArray) - 1)] tagsString := strings.Join(tagsSplice, " ") lexicon[lineAsArray[0]] = tagsString }
Beat me to it!
:) *edit: people always beat me to it, it was nice to be first for a change.
You're absolutely right: for safety's sake one should always check the "ok" value when type asserting. I omitted it there since we know what the function returns and it's such a brief example. Also, functions should document the error types returned (if they are custom types), at least generally, like `os` does.
Great article, but I feel like there is a misprint. First they say that when you make a library your vendored packages should be at ``vendor`` and then they say: &gt;If you’re shipping a library, create a ``vendor`` subdirectory in the root of your repository. Treat it just like a prefix in package paths; for example, copy the dependency ``github.com/user/dep`` to ``_vendor/user/dep``. Shouldn't it be ``vendor/user/dep``, without the underscore? **EDIT:** It's been fixed.
By prefixing vendor with an underscore, it will be ignored by the go tool chain when you say "go test ./...", for example.
I know. The article used to have a misprint, but they fixed it now.
cool thanks
It's a lot of little things. For my personal interest, it's the way it's explicitly designed to be used in a larger-scale multi-programmer environment with lots of little things like go fmt, the decoupling permitted with implicit interfaces, solid testing as a first-class consideration, and just generally a lot of these other small things that add up to a nice language that really does relatively gracefully grow. In the strict sense of "academic", it's entirely uninteresting. In the personal sense of academic, if you haven't used a language with lightweight multi-processing like goroutines, it's a good place to learn that, as most of the currently-practical alternatives are much farther out of the mainstream Algol-type languages.
You should be more specific about the use case you're looking for. I can come up with multiple structures that fit your somewhat-vague question, that require different approaches.
Go seems to have a nice place in the shift back from dynamic languages. People use dynamic languages because they significant expressive power to get things done. That power isn't free though. Without static type checks, the burden of making sure types line up is pushed back onto the weakest link, the programmer. Also, much of the fancy code generation pushes complexity into the runtime. Many consider the trade offs worth it especially when compared to a traditional static language. Languages like Go, Haskell, and Rust are narrowing the gap. 
Hi, Assuming I have 'n' number of workers already started, concurrently picking jobs off a queue of size 'm'; At some point I would like the ability to signall all workers to stop picking jobs. One way I would have do it with my limited golang skills would be to have each worker listen on secondary channel of size 'n' for an 'interrupt' msg and then stop processing the queue; my main go routine would then send 'n' 'interrupt' msg(es). Not sure this is the sane/safe way to do it, so I would welcome any pointers or documentation on the subject. Thanks
Are there any other gophercon videos? I'd love to watch some talks.
Oh, that makes sense. Thanks for clarifying!
Go is almost as easy to code in as Python; and like Python comes with a lot of handy libraries for common protocols. But unlike Python, Go isn't slow. Go should be a lot safer than C or C++ security-wise — arrays are bounds checked; casting is limited. Also there are sane crypto tools right there in the crypto library, so you aren't tempted to roll your own crypto (which is always a mistake). Go is less verbose than Java. Goroutines and channels don't seem to make people's brains melt the way that debugging callback-ridden code does. Thinking of goroutines as workers lets you think about complex data pipelines in reasonably sane ways — kind of like a Unix shell pipeline but with parallelism and without so many tentacles. Go compiles really, really quickly. This matters a lot for large industrial code bases (and think of where Go was created). It also means things like comprehensive testing and push-on-green are less time consuming.
What's wrong with using named return variables? 
It sounds like what you want is to send your jobs in on a channel, which has n goroutines running picking jobs off that channel. When you want to stop them, close the channel, and have the processing goroutines watch for that correctly (per z\_ryad's point). All readers will observe the closed channel, allowing them to safely shut down after they complete whatever it is they are working on. If you want faster completion, you'll have to program in something yourself; there is no generic way (and almost certainly never will be) to forcibly stop a goroutine from running. If you need to be able to arbitrarily terminate the system, note that while channel readers can safely observe that the channel has been closed, writing to a closed channel is a panic, so it's not safe to terminate the whole system by closing the channel in an unrelated goroutine. In that case you can have the source goroutine use a switch statement to either "write the next task to whoever receives it" _or_ "read the termination request". `select` statements can select on both reads and writes to channels.
What do you intend to do with the queue of jobs when the workers stop? Should it continue to grow in memory?
The official word is that they're in post-production and will be made available in the next 2-3 weeks. [Source: twitter @GopherCon](https://twitter.com/GopherCon/status/460251718853214208). I'm excited to see them too!
I also think its a great first low level language. If you've always stuck to things like perl or Python, go is a great language to learn to better understand programming. 
What's a language-architect- astronaut?
 // Don't do this. f := &amp;Foo{} // or, even worse: new(Foo) f.Site = "zombo.com" f.Out = os.Stdout f.Dest.Key = "gophercon" f.Dest.Value = 2014 Not too sure what's so bad about this. I like what they suggest instead: f := foo.New(foo.Config{ Site: "zombo.com", Out: os.Stdout, Dest: conference.KeyPair{ Key: "gophercon", Value: 2014, }, }) But can't really see why the first one is *that* bad (and by that, I mean taking the address of the newly initialized struct). Is it because you're avoiding using initializer syntax? The Effective Go doc actually has this as an example: `return &amp;File{fd: fd, name: name}`
Someone who judges a language by its feature set rather than the amount of friction they experience when using it to develop a good product.
I've been watching the subscription count on this sub, and it's accelerating.
Iteration order is explicitly randomized. I remember the CL but can't find it right now. (And yes, I was surprised to see it added. Then again, it seems fitting for a language designed to foster correct programming at scale to prevent reliance on undefined behaviour).
Go's simplicity is both a blessing and a curse. Blessing because the language is unlikely to get more complex. A curse, because it will take forever to get new features into the language when hip new languages adopt them at a quicker pace. For example, generics.
&gt; It should be a rule that if you make a new X, you explain why it's better than existing Xs on its homepage. Why? Django doesn't do that with Rails. Flask doesn't do that. "Better" is entirely subjective and a comparison is only going to open you up to criticism. In the open source world, good documentation, a feature list and a clear code base should give a potential user enough information to make an informed decision.
Yeah perhaps some of that could be ported. The link you posted has many more stars, which is probably because of the increased browser compat. It only works with client version .6, which is too bad. I'm not sure what the major points are that are blocking it from being closer to 1.0
Seems cool. How can I learn to use it, though? I don't have a comp.sci. degree (and I can't afford getting one either), but I think machine learning *is* fascinating. I know there are courses free online, but I'm not sure they are a useful way for me to learn this stuff.
I imagine I'm not the only one who likes go because it eschews the feature-soup of some other languages. 
Project hasn't been updated in a few months, it only has KNN implemented right now. Machine learning does a lot of matrix operations, does golang have a good way of handling them?
&gt; What about shared state is so bad? He comes from a functional programming background so this is dogma. Same with his comments about nil.
&gt; lack of pattern matching Can someone please explain to me why pattern matching is different than just making the first line of your function a `switch` statement? Not trolling, I honestly just don't see why people consider it different and better than a `switch`.
[Image](http://imgs.xkcd.com/comics/workflow.png) **Title:** Workflow **Title-text:** There are probably children out there holding down spacebar to stay warm in the winter! YOUR UPDATE MURDERS CHILDREN. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=1172#Explanation) **Stats:** This comic has been referenced 70 time(s), representing 0.3894% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
It's not and you shouldn't. Please *go away()*. (I'm hoping to save time avoiding pointless discussions that are philosophical or artistic at best. And no, sorry, [computer science is not science. It's engineering.](http://www.youtube.com/watch?v=lL4wg6ZAFIM))
This is another Go OSS project of mine that I'm using to expand my knowledge of the language and its inner-workings. I'd be extremely interested in gathering advice on the best way to test an application such as this. Most of the complexity lies within downloading and persisting files - do my test methods need to download physical files from the web as well, or is there a straight-forward way to stub that behavior out?
Yes!
Because it's his favorite feature, and any language that doesn't have it is bad.
It's interesting to see the "Go is flawed because it's doesn't work like Language X." argument from the perspective of an Erlang developer, but that's all this is.
That one does have weekly deadlines, but you can ignore it if you don't care about the grade. It's all prerecorded, so you can work on it whenever.
The course has has scheduled assignments and readings if it's still on going. Most people just register and don't do the scheduled stuff and just watch the course videos at their own pace. 
[A relevant and necessary post I found at HN](https://news.ycombinator.com/item?id=7656597) &gt; Considering this is four months old and the only method implemented is still just knn, I think it's disingenuous to (a) call this a library and (b) write in such general terms (admittedly, hindsight is 20/20). I don't mean to detract from the premise behind starting the project, but language like "I couldn't find any comprehensive ML library for Go, so I decided to write one" has a bit more hubris than is warranted.
I wasn't writing the post to explain why each issue is bad. Shared state is an issue for both reasoning about what a program will do, finding bugs, testing and the ability to restart a process. This is important for process isolation and isolation is important for fault tolerance. As I said, the preemptive model used by Go is much better than most but relying on time is more overhead for the system and Go relies on both time and function calls (since it can only preempt during a stack check). The Erlang model is lighter weight, easier to reason about and less likely to end up staying long in an unpremptable state. I have no reason to whine about the lack of generics when discussing the reasons Go isn't suitable for fault tolerant system built for low latency. As for nil, why should it exist? It is a great way to have runtime exceptions that could easily have been caught with static typing and an Option type or in Erlang's case with static analysis. And it forces you to code defensively, which means more code and more bugs when you don't cover all your cases.
The switch statement doesn't necessary have or not have pattern matching, and pattern matching isn't necessary to exist in function headers to exist in the language. In Erlang and Haskell instead of switch there is case and in ML there is match. Pattern matching is not exclusive to function headers or case/match expressions, but when used in those it is different from a Go or C switch in that you are matching not on true/false equality but fitting a pattern, such as a tuple or a list: case A of [{X, Y} | _] -&gt; X + Y; [X, Y | _] -&gt; X + Y end. This case statement will match on a list with the first element being a 2-tuple or a list of at least 2 elements. You can then add true/false guards: case A of [{X, Y} | _] when X &gt; 0 -&gt; Y/X; [{X, Y} | _] -&gt; something else..... end.
What do you mean by import path?
An important thing to remember is that Erlang is built to support fault-tolerance with its VM and GC details. Go is not built for fault-tolerance, due to it being unable to provide isolation for parts of its source code. So, Go is meant for creating more fragile software where having shared state is not an issue. Just separate goals.
I'll tell you why *I* came to go and liked what I saw, although it may apply more to me than to others. I was struggling at the time with reconciling what I knew about parallelism and concurrency in languages like Python, Javascript, and Java with the fundamentals of parallelism and concurrency as espoused in theory. It seemed like the tools weren't really doing a good job of it. There were so many pain points, it was very obvious that a lot of these languages considered parallelism and concurrency as purely an afterthought. I imagine that they probably were! When I tried out Go, I had never used Stacklets or Messages (of any sort) in any language before. I was instantly in love. This was a very powerful and fun way to design a system! Unfortunately I still haven't had the chance to build anything particularly large in Go. My biggest project was a small library I published that creates the basic `map`, `filter`, `reduce` (et. al.) constructs as higher-order functions on channels returning channels. Lots of fun to write but I haven't really used it much for anything.
Yes, the slice will be in random order at first. And then you do some magic which is called "programming" and sort the slice (e.g. by use of package sort) and voily, magic happened: Everything is good.
Hi, author here. Thanks for posting it. As you can see, it's definitely incomplete as it stands - it's a little embarrassing to highlight how little work I did :) - as I haven't been able to spend as much time on it as I would have liked. If anyone fancies working more formally on it with me, send me a mail at stephen dot whitworth at hailocab dot com
Not OP, but maybe our github profiles so we can check out each other's Go work?
Isn't it the case that go-routines using channels to talk don't have to share state?
That doesn't look very type-safe...
You can disagree all you want. "True computer science" or algorithm analysis is not closer to science. It's closer to mathematics, [which is not a science](http://www.feynmanphysicslectures.com/relation-of-mathematics-and-physics), [but has long been an effective tool for science](http://en.wikipedia.org/wiki/The_Unreasonable_Effectiveness_of_Mathematics_in_the_Natural_Sciences). On the other hand, people are calling everything science these days to be perceived respectable, so why not. We should call the efficient design and study of waterwheels a science too, since there is maths there. And if we're going to call psychology or linguistic or any heap of man-made "knowledge" a science, why not computer science.
Yeah I was figuring something along those lines. Or maybe just a more generic import "my-url" that could have anything (personal site, GH profile, etc).
Pretty much, always good to know what people are working on.
Yes, that is the re-definition of science through the second half of last century. If you also look at the right menu on Wikipedia, you'l see that psychology and linguistic are there. Since you're apparently not a (real) scientist or literate in the [philosophy of science](http://en.wikipedia.org/wiki/Philosophy_of_science), let me summarize what happened in a practical manner. A lot of new departments popped up in the universities in the last 150 years, and to be treated with respect and not as charlatans, they added "science" (or "-logy") to their names. What was then called science more increasingly became to be called "natural sciences" by them to avoid confusion. This is the reason why most people call any stamp collection or heap of "knowledge" a science these days. So we have a lot of so-called sciences today that pretend and strive to be as respectful as physics. Only they're not, and what effectively happened is science became a cheap word instead. I see you're not a thorough reader. Because if you were, you would also noticed that in the remainder of the introduction section of that Wikipedia page, it goes on and explains this: &gt; In modern usage, "science" most often refers to a way of pursuing knowledge, not only the knowledge itself. It is also often restricted to those branches of study that seek to explain the phenomena of the material universe.[6] In the 17th and 18th centuries scientists increasingly sought to formulate knowledge in terms of laws of nature such as Newton's laws of motion. And over the course of the 19th century, the word "science" became increasingly associated with the scientific method itself, as a disciplined way to study the natural world, including physics, chemistry, geology and biology. It is in the 19th century also that the term scientist was created by the naturalist-theologian William Whewell to distinguish those who sought knowledge on nature from those who sought other types of knowledge. And no. You don't become scientist by "creating" new machine learning algorithms, nor machine learning is the same thing as data mining. Just like you don't become one when you find a new way of making more cash in a gambling house or "inventing" rounded corners.
My professional background for 10 years has been mostly C and C++ on various platforms, be it various Solaris, Linux, Windows or Symbian OS. I started following Go shortly after it was announced, and to me, Go was a godsend. So many things that have been rather complicated or just annoying in C++ suddenly became so much easier, and programming felt like the simplicity of programming C, except more robust and ready for modern requirements, especially the web and parallelism (I know, concurrency is not parallelism, but Go's concurrency concepts enable parallelism in Go's runtime). I started using Go professionally over a year ago, and since then almost exclusively, and I've never felt any happier than before when it comes to programming. As silly as that may sound, I explicitly mention that because I struggled with episodes of major depression for years (probably even a decade without an official diagnosis), and the simplicity takes away a lot of day-to-day frustration out of my job. As mentioned before, I've used C++ in large environments for years (one particular codebase consisted of about 2.5 million SLOCs of C++), and I really like the language for what it is, but I never saw anything interesting in its first successor language, D. Having read through an ad-hoc AMA of its creator on /r/programming, I must admit I find everything going on around it pretty dull and boring (the term navel-gazing comes to mind). And when Rust popped up, I went through language introductions and took a look at the concepts, found it alright, and yet I don't find it nearly as appealing as Go, simply because I so many complications and patterns that reminded me of C++ that just screamed "possible frustration" in my face. tl;dr coming from C/C++, I use Go because it's the only programming language/ecosystem that keeps my day-to-day programming frustration down.
There are some proposals to add native matrix support in Go. The last proposal I saw seemed pretty good, not sure what the core developers thought of it though.
Looks very similar to [sync.Pool](http://tip.golang.org/pkg/sync/#Pool).
I think that calling this pattern matching is stretching the case quite a lot. That is just a glorified if statement and has definitely very little to do with pattern matching.
Except theirs is not GC-aware and the (parts of the) pool cannot be de-allocated when necessary. Also, a quick look reveals a bug: they're not setting the cap for the returned slices.
See also [gomempool](https://github.com/thejerf/gomempool) ([godoc](http://godoc.org/github.com/thejerf/gomempool)). I expect to check to see whether it's worth using sync.Pool to back the stores here at some point. 1.3beta1 is pretty fresh. Some small API changes would be necessary (mostly to the Stats, since I can't track when a pool discards things, so the "depth" parameter is useless). Note that sync.Pool covers a different use case; sync.Pool is homogeneous pooling. Heterogeneous pooling is different, though it can use sync.Pool in the background. I would strongly suggest adding some statistics to your own implementation, err... "viki engineering". If you think allocating 8K buffers is a good example value, odds are pretty good you're brutally overallocating and not actually using anywhere that many buffers at a time concurrently. And maybe you are... I'm just saying, odds are good that you aren't, and you haven't got a way to tell. My statistics told me my intuition about how many buffers were in use simultaneously in my code were quite wrong.
It wasn't clear what exactly was being benchmarked here. Most of that time is taken up by the code inside the loop, so it's not benchmarking the pool or anything related to it AFAICT, and furthermore, those benchmarks don't do the same thing... so anyway... I hacked around a bit to waste some time here: http://play.golang.org/p/A_biSmSwQ9 my results are at the bottom of the file.. make of it, what you will... I had the great idea to write it in a file inside the `bytepool` package, if you want to run it yourself. Bearing in mind that benchmarks are usually flawed in one way or another. I found `allocs/op` more interesting than the `ns/op` because that's ultimately what the aim of pools likes these are: to reduce the number of allocations. Here I see `20068 allocs/op` on the concurrent benchmarks for the `bytepool`. It'd be interesting to know why that is, when all we're doing is pulling things out of the pool.
That is Erlang, so no types, though Dialyzer for static anylisis of types you can add as specs to functions is really huge and something any dynamic language should have. A Haskell example to show the use would maybe be with a union type: data Tree a = Branch (Tree a) (Tree a) | Leaf a case t of Branch left right -&gt; ... Leaf l -&gt; .... case
The point was about readability of a project by a new Erlang programmer joining the project. Not a person unfamiliar with the language.
I would rather say that this is the level of the critique rather than what is in the article. 
My 2 cents about Go. 1. The language - very simple. Orthogonal feature set. Not many ways to do a "thing". No "cool" features that aren't immediately useful in some pragmatic way. *Very* easy for me to read other people's code, unlike Haskell/Scala/C++ which let programmers get a bit *too* creative. Go has opened my eyes to the fact that concurrent code doesn't have to be hard. It's still "hard" in languages like Java/C#, for example. 2. The tools - statically linked executables, fast compilation, easy cross-compilation. go fmt, go vet, go build, go get, go test, the race detector, the cpu/memory usage analysis - all built-in. That is amazing. 3. The eco-system - this is a big one. Lots of useful packages, amazing std. lib. Due to point 2. - easy to find, install, read packages. It's amazing how much better the Go eco-system is compared to the jungle that is C++ for example. 4. The community - an absolutely phenomenal amount of best practices, wikis, videos, articles, documentation...I've tried reading two books on Go so far and both are basically useless because the sheer amount of information on Go out there makes it very easy to get going. The go-nuts and go-dev mailing lists are fantastic. Add all these up and there's no reason for Go *not* to get traction and momentum going. 
go for embedded? awesome!!
OP here. I hacked this up during the GopherCon hack day on Saturday and cleaned it up enough to release today. I'd love to get feedback from all of you. I had been thinking about writing a code generator for this for a little while, as I find myself constantly rewriting code to search for an element in a slice, removing a single element from a slice, etc. My original plan was to just use `text/template` for this, but after attending the panel discussion where Rob Pike mentioned using the excellent libraries in the `go/*` packages I decided to implement it that way. I'm very glad I did, because it means that the generic code you can write is (in most cases) valid Go code itself. 
One idea I just had might be to run a gopkg.in-like service which translates generic code on the fly through this tool, so you wouldn't even need to generate it yourself.
It isn't. Pattern matching and a weak type system is a dubious benefit, it's almost always morally equivalent to a [type switch](http://www.jerf.org/iri/post/2917). In a strong language with actual sum types like Haskell, it becomes useful again, but in Erlang in practice you're almost always switching on what ought to be types.
Two things: 1. Strong typing but without the hell of deep inheritance hierarchies Go lets you write interfaces *after* a class is written, or add functions to a class in another file. So you can notice a pattern and write an interface that states the requirements --- without having to ensure that all the classes inherit from the same class. This plus type inference makes it much easier to write statically typed code than languages like Java and C++. 2. Non-blocking code without callback hell Go implements channels - this is a critical super-exciting feature for anyone who wants to write scalable services. It's worth reading up on, and has a long history in the academic community. Go is (I think) the first popular language to implement channels as a first class construct.
Yeah, the thing is that from your post what I get is that Go is not good for anything substantial or just for clients, however Google designed Go for its own problems and it is used inside youtube, dl.google.com and other google's services that may not count as backends with high requirement as much as the ones you talk about but nevertheless are not trivial services... At least that is what I get from the article...
I have done something similar with FUSE so I didnt have to generate actual source files. Additionally, instead of having to import the generics thing and use generic.T / U / V, it supports arbitrary types for replacement as well as specifying the package name. Overall though, this generic-as-type-substitution path gets you 80% of what people want out of generics while being very nice to program with and debug.
 func Foo(x int)(int int); vs func Foo(x int)(res int, err int); And it's easier to distinguish which return value is what. 
Really? I have a purple one but would prefer a blue one.
&gt; The thing is that goroutines share the same heap, in Erlang you don't. That brings to mind an interesting question. We all hear, time and time again, the issues of mark-and-sweep with respect to concurrency. But it goes the other way too: I guess it's possible to stall a goroutine on access to *allocation* on the heap?
I wish I could get even the blue one. Shipping to Europe was abysmal the last time I checked.
Can you quantify the runtime parsing overhead vs. what you'd consider acceptable?
Or just fix the module that's there?
I'd definitely be up for attending.
Save me the trouble and read at least [this](http://en.wikipedia.org/wiki/Karl_popper). Applied mathematics is just mathematics. Unlike science, mathematics as a whole is based on axioms and proofs based on these axioms, which in turn is not even designed to be falsified experimentally, nor it's based on any sort of experiment which is the foundation of scientific method. And no, the output of your program is not an experiment. It's just applied mathematics. Last but not least, something that is not science is not necessary bad or wrong. It's just not science. Love or mathematics are not science for example, and they are good things.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Karl popper**](https://en.wikipedia.org/wiki/Karl%20popper): [](#sfw) --- &gt;__Karl Raimund Popper__ CH FBA FRS (28 July 1902 – 17 September 1994) was an Austrian-British [philosopher](https://en.wikipedia.org/wiki/Philosopher) and professor at the [London School of Economics](https://en.wikipedia.org/wiki/London_School_of_Economics). He is generally regarded as one of the greatest [philosophers of science](https://en.wikipedia.org/wiki/Philosophy_of_science) of the 20th century. Popper is known for his rejection of the classical [inductivist](https://en.wikipedia.org/wiki/Inductivism) views on the [scientific method](https://en.wikipedia.org/wiki/Scientific_method), in favour of [empirical falsification](https://en.wikipedia.org/wiki/Falsifiability): A theory in the empirical sciences can never be proven, but it can be falsified, meaning that it can and should be scrutinized by decisive experiments. If the outcome of an experiment contradicts the theory, one should refrain from ad hoc manoeuvres that evade the contradiction merely by making it less falsifiable. Popper is also known for his opposition to the classical [justificationist](https://en.wikipedia.org/wiki/Justificationism) account of knowledge which he replaced with [critical rationalism](https://en.wikipedia.org/wiki/Critical_rationalism), "the first *non justificational philosophy of criticism* in the history of philosophy". In political discourse, he is known for his vigorous defence of [liberal democracy](https://en.wikipedia.org/wiki/Liberal_democracy) and the principles of [social criticism](https://en.wikipedia.org/wiki/Social_criticism) that he came to believe made a flourishing "[open society](https://en.wikipedia.org/wiki/Open_society)" possible. &gt; --- ^Interesting: [^Karl ^Popper](https://en.wikipedia.org/wiki/Karl_Popper) ^| [^Debate](https://en.wikipedia.org/wiki/Debate) ^| [^Falsifiability](https://en.wikipedia.org/wiki/Falsifiability) ^| [^The ^Open ^Society ^and ^Its ^Enemies](https://en.wikipedia.org/wiki/The_Open_Society_and_Its_Enemies) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch4pnix) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch4pnix)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; The keynotes were delivered by Rob Pike, Russ Cox, and Andrew Gerrand (all members of Google's core Go team). All? Ken Thompson is quite a big name to forget about. And what about Brad Fitzpatrick, who was actually there?
And the [video I originally referred](http://www.youtube.com/watch?v=lL4wg6ZAFIM) is just 1.5 mins. 
I would definitely be interested in attending something.
Who is they? If you don't mind me asking. 
You should take a look at the Plan 9 source code. The style of the C source is very Go as well and impressively clean.
No mention of `json.NewDecoder(resp.Body)`? No mention of profiling? No thanks.
Interestingly, I posted same thing a year ago, and got lots of downvotes: http://www.reddit.com/r/golang/comments/10fxi3/russ_cox_replies_to_why_im_not_leaving_python_for/c6d56be
Well, looking at the rest of the thread, that is pretty obviously the result of vote-brigading from outside the Go community.
Really? "That's science." Wow. Just like that. You know, my grandmom tuned the sugar in my coffee to my taste over time. She must be a scientist too! What you describe is barely engineering, and not even remotely science. Are you intentionally being thick? What part of empirical falsification or nature of a scientific law (which is supposed to be able to *predict new things* ---that is to say, you must be able to get *more* out of the theory than what you put into it in the first place and predict new phenomena. Ringing any bells? No? I thought so. Quantum mechanics -&gt; superconductivity, general relativity -&gt; black holes, gauge symmetries -&gt; new particles [like Higgs boson] among many many examples.), or not just being based on mathematical axioms can you not understand? Anyway. Dealing with illiterates like you who think they know what they're talking about without actually knowing anything is just a waste of time. Yes, yes. Computer science is a science. Reflexology and gambling are too. Astrology is also a science. Now please go away and do whatever "science" you want to do. Tell each other that you're doing science and be happy in your little world. And last but not least, never ever read books and stay away from "natural" sciences ---prefer unnatural sciences. Pretend that is a thing.
I would also be interested in attending.
As far as I know, no, you can't. I think the reason is that if you re-assign (which doesn't require allocation) a pointer from struct B to struct A, you'll have a problem if the garbage collector has scanned A but not B. It will scan B, not find the pointer you have reassigned and delete the pointer, even though it's still accessible from A.
Crazy? I don't think so. You just need to be proud - as a C++ programmer - to be smarter than (most) Java programmers.
I think you're constrainig the word too much. We already have a word for what you call science. Natural sciences or physics. This is the reason for the modern usage of the word having become wider than just those subjects. Profiling algorithms is also an empirically falsifiable claim. This algorithm is faster than this other for this data is a falsifiable claim. This machine learning algorithm is better at classifying this type of data than this other ml algorithm is also a falsifiable claim. The nature of the algorithm also often allows us to predict how it will fare on particular data sets. Predictive power and falsifiable claims right there. Also, nice ad hominem arguments there. Stay classy. [Edit: complexity analysis also gives us predictive power of the growth of the running time with new data.]
Are there any die-hard C++ programmers who actually like anything that's *not* C++ ? I haven't met any personally. 
Yes, with C++ you need enormous mental capacity as truly understanding the language will take up at least 80% of it! (Don't disagree with me until you have tried to debug Boost on a poorly supported platform!)
Go has really helped me to reason correctly about concurrency in program design. Take the case of multiple threads needing to loop through an array and add/remove members. One way to model this that applies to just about any programming language is to acquire a mutex lock before beginning iteration, and releasing it when done, so that threads don't modify the array while another thread is doing a modification, leading to indeterminate results. This is easy to do in Go, but there's another more *Go-like* way: Rather than having each thread do the work of modifying the array and locking all other threads out while it's doing so, instead have a single goroutine dedicated to the task of modifying the array that runs in a for loop and starts by reading from a channel. Then have each thread post it's work to that channel, and allow the single thread to pick up the item on the channel, and modify the array. Because there's only one thread that can modify the array, there's no need for locking. The dequing thread will block on read until someone does a write, and if you use a buffered channel, your enqueuing threads won't block either while waiting for the dequing thread. Thinking in terms of channels and *'a single thread being responsible for a given data structure'* really helped me move away from explicit locking metaphors which are much harder to reason about and prone to incorrectness leading to increased latency, and in worst case scenarios, deadlocking.
That discussion went to shit pretty darn quickly, but can be summarized as such: c++ developers hate (go/python/ruby/haskell/c/anything else not c++). To demonstrate their hate, they will find c++ features that don't exist in that language. I appreciate that everyone has their own opinion, but I'm not interested in hearing Yet Another C++ Programmer complain about a lack of generics.
I dont beleive thats a thing. C++ is rather occult.
Yeah, It's like 5x now of the original version, you linked, but it isn't really functional besides 2-4 public functions (I realized how huge the original project is). I'll announce it here once it's ready.
I just want to put it out there that free resources for coding are incredibly useful for new (cash strapped) programmers like myself. Thank you so much for the time you put into books like these! 
You have a public repository? I wouldn't mind doing some work on it and my current work project would benefit.
`cout &lt;&lt;` is why Go will never have operator overloading.
Programmers can't be trusted, unfortunately.
This interested me, what language should I use if I don't want to hold back the computing world?
Operator overloading would be great if it came with a man with a gun who would come to your house and shoot you if you try to use it for something besides BigInt and Rational classes.
Good lord. The lack of regex support in the early stages of c++11 was so annoying because I could never get the Boost library to correctly link even though all of the steps have been followed. There was literally regex.h and regex.hpp/cpp and the functions were left with a little statement of "to do".
Haskell? Seriously though, there is a type of programmer who rates a language by the number of features it has, regardless of how they are bolted/glued/duct taped/perched precariously on a language. The idea of stripping out features and replacing them with simpler constructs is foreign to them.
Yes, I totally wish more people would use a versioning system that's useful to end users and gopkg.in!
Funny how a discussion about Go carried out by C++ developers ends up in a trench fight about C++ features and war stories. Funny how any software project involving C++ ends up in fights about C++ the language, rather than what the project is trying to solve. Notice a pattern? Imagine a bunch of mathematicians who love so much drawing math symbols that they end up drawing symbols all day, becoming experts at calligraphy and forgetting about doing maths. And then the rest of the world tells them that what they thought was calligraphy is just downright ugly. I would also be a bit pissed off.
Go doesn't have exception handling, so operator loading will be a very bad ideal, it encourages people ignore error type and just return the result. 
I'm a Chinese programmer, it true that Google is popular in our it circle, but there are other reasons why Google App Engine is popular. One of the open-source proxyies to pass over the GFW, go-agent, in an app to deploy on GAE. A free account of GAE provides about 1GB data throughput per day. That's enough for personal usage. Thus, go-agent encourage users to deploy for their own GAE, the deployment of go-agent is fully explained in their project Wiki: https://code.google.com/p/goagent/wiki/InstallGuide Oh, Goagent is NOT implement in Golang, but this do explain why GAE way more popular in China than anywhere else. Another proxy is called Shadowsock, implemented in many languages, but the best version suggest by the shadowsocks author, is Node.js. Chinese people's need for proxies drive many of them become at lease an half IT engineer. Most Chinese people uses 百度(baidu.com) as their first search engine, dgryski also try search term golang in baidu, but baidu also provide similar tool like Google Trends, let's see the data: http://index.baidu.com/?tpl=trend&amp;word=go%D3%EF%D1%D4%2Cgolang%2Cgo Image: http://imgur.com/BgfIh3c I use 3 terms, go/golang/go语言 (golang in Chinese) ，the data percentage matches the rank result in the blog about golang.org. I didn't explain the popularity of Go itself, but I believe just google says so, I didn't feel it very popularity in my circle. 
I'll put one up when I finish work today (in about 8 hours), the link will be here.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Demarcation problem**](https://en.wikipedia.org/wiki/Demarcation%20problem): [](#sfw) --- &gt; &gt;The __demarcation problem__ in the [philosophy of science](https://en.wikipedia.org/wiki/Philosophy_of_science) is about how to distinguish between [science](https://en.wikipedia.org/wiki/Science) and nonscience, including between science, [pseudoscience](https://en.wikipedia.org/wiki/Pseudoscience), other activities, and beliefs. The debate continues after over a century of dialogue among [philosophers of science](https://en.wikipedia.org/wiki/Philosophy_of_science) and [scientists](https://en.wikipedia.org/wiki/Scientist) in various [fields](https://en.wikipedia.org/wiki/Science), and despite broad agreement on the basics of [scientific method](https://en.wikipedia.org/wiki/Scientific_method). &gt; --- ^Interesting: [^Pseudoscience](https://en.wikipedia.org/wiki/Pseudoscience) ^| [^Philosophy ^of ^science](https://en.wikipedia.org/wiki/Philosophy_of_science) ^| [^Scientific ^method](https://en.wikipedia.org/wiki/Scientific_method) ^| [^Falsifiability](https://en.wikipedia.org/wiki/Falsifiability) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch5uwdx) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch5uwdx)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I happen be a C++ programmer that loves other languages too, but I also pride myself as a technologist. I feel that the most embarrassing thing anyone can say in this industry is "that's not in my wheelhouse." And so *this* month, I'm learning Go. Go and C++ are different animals, for very different reasons. Yeah, I miss generics in Go, but aside from the STL, I don't leverage them all that much in C++ either; and iteration is lightweight enough in Go that it's not all that bad. Besides, not everyone is wiling to wrap their head around what the compiler is doing by generating code while it's compiling code - this actually becomes a seriously large hurdle for using such features in a professional environment. So the Go developers may have done something smart here. Anyway, I'd wager that if Go had everything C++ had, and did it better, people would still turn their noses up at it. Case in point: D.
I own several of the books written about the go language, and while they are helpful, I believe the online resources are actually more useful. In particular, the Effective Go document, the standard library's godoc and source, and the #go-nuts channel in irc.freenode.org (along with lots of practice) have let me pick up this language faster than any other one I've ever used.
You could [panic/recover](http://blog.golang.org/defer-panic-and-recover). But it might not be what you want since most Go APIs panic and recover internally so that they can provide errors codes as return values. If you start providing APIs that need you to setup a deferred recover call before using them, you won't win many friends.
&gt;As it happens, it read it straight off the network, in my case it read it off the disk, but the code as originally written didn't care.As it happens, it read it straight off the network, in my case it read it off the disk, but the code as originally written didn't care. This sounds great!
It doesn't change that "not everything is a file". You shouldn't just jam one interface on top of everything.(Actually, you can read that for Go too, though since it's so easy _not_ to, the temptation isn't there, I find.) Plan9 in a way doubles down on the problem by also jamming "directories" as a concept on top of a lot of other things that really aren't "directories". Sure, you can get a long way doing that... I did say that, after all... but it's still a semantic mismatch, and you still pay a price for the mismatch. Having interfaces that are precise, correct, and easily composed is far better.
Also matrices and vectors. I really agree that operator overloading is hardly useful, but oh my, the readability when you don't have it for those rare cases you need it...
 func (t *ThingVector) Dequeue() Thing { // Could be done in a single line, but I find that's clearer d := t.vec[0] t.vec = t.vec[1:] return d } It looks like you're trading speed for memory usage for long-lived, thoroughly-used queues. Since dequeuing doesn't free the memory, the space required is the total number of items ever enqueued instead of the length. *Except that* when append reallocates, it won't copy the now-unused cells from the front of the array, so the memory cost shouldn't be too high in practice. A downside is that performance of enqueuing is unpredictable: usually cheap, sometimes quite expensive.
warning: I'm a go newb. So it seems like multilingual help strings shouldn't be too hard - running usage through the go equivalent of gettext (e.g. https://github.com/samuel/go-gettext) would need to be done, but I think that's common for doing such things for any language and for all user-visible strings anyway, right? For type safety, you lose compile-time type safety, but can't you add run-time type checking via type declarations? E.g. var foo := docopted_var["-d"].(string) ? Again, I get that this is runtime type checking. The python answer is to add a schema checker to validate that the types are as expected or break at run-time. Since this is based on run-time user input, though, type checking and coercion to the desired type seems to be where it's gonna have to happen no matter what.
[edit after joshrickmar's comment] That was an interesting point, so made a test to check allocations: for _, junk := range NewThings(10, size) { fifo.Enqueue(junk) } runtime.ReadMemStats(&amp;mem) start := mem.TotalAlloc for i := 0; i &lt; size; i++ { fifo.Enqueue(fifo.Dequeue()) } runtime.ReadMemStats(&amp;mem) after := mem.TotalAlloc t.Logf("used ~%s", humanize.Bytes(after-start)) Then I tried replacing the Dequeue with : func (t *ThingVector) Dequeue() Thing { d := t.vec[0] copy(t.vec, t.vec[1:]) t.vec = t.vec[:len(t.vec)-1] return d } --- PASS: TestVectorMemoryIsBounded (0.00 seconds) fifo_test.go:130: used ~0B With the original one: func (t *ThingVector) Dequeue() Thing { d := t.vec[0] t.vec = t.vec[1:] return d } --- PASS: TestVectorMemoryIsBounded (0.00 seconds) fifo_test.go:130: used ~33KB So copying the data at each Dequeue consumes much less memory, indeed. However, simply reslicing doesn't leak memory. Ben Johnson made a little infographic to show why: https://gist.github.com/benbjohnson/55cc1fb598b215ea71b8 So why not use this version? Because it's slow: $ go test -bench Dequeue PASS Benchmark_Dequeue_32 1000000 1467 ns/op Benchmark_Dequeue_64 500000 4371 ns/op Benchmark_Dequeue_128 200000 12454 ns/op Benchmark_Dequeue_256 50000 35910 ns/op Benchmark_Dequeue_512 10000 117879 ns/op Benchmark_Dequeue_1024 5000 403144 ns/op Benchmark_Dequeue_2048 1000 1508551 ns/op Benchmark_Dequeue_4096 500 6203944 ns/op Benchmark_Dequeue_8192 100 24755472 ns/op Benchmark_Dequeue_16384 20 98520843 ns/op Benchmark_Dequeue_32768 2 514876822 ns/op Benchmark_Dequeue_65536 1 2143165751 ns/op Benchmark_Dequeue_131072 1 8542878207 ns/op Benchmark_Dequeue_262144 1 36275363095 ns/op The benchmark timesout before finishing. Dequeuing like this is O(n^2) since for N values in the queue, dequeuing all N of them will copy N-1, N-2, N-3... elements at each dequeue.
Don't allocate a new array, just copy the slice elements down an index copy(t.vec, t.vec[1:]) t.vec = t.vec[:len(t.vec)-1]
Rust would be the logical choice, yes, but I'm not convinced it's happening in large numbers. C++ programmers aren't programmers, they're *C++* programmers. It's taken them years to hone a particular set of skills that applies to a particular dialect of C++ and I just don't see them jumping ship in significant numbers. After all, it didn't happen with the other "big hope" - D. 
You're a rare breed. I love C but hate C++, or at least the 8-9 pre-C++11 "dialects" that allowed that community to eat itself, and Go is right up my alley as well. I think C++11 is at best "ok", compared to its previous incarnations, so hopefully C++14 or whatever closes the gap even further, but working with C++ programmers has been... painful for me. I happen to like "book" C++ - exceptions, RAII, std::vector and std::string and so forth but most C++ guys I work with tend to have thin wrappers over plain C code which drives me insane when I have to point out bugs in the code that wouldn't normally happen in either post-1996 C++ or any other language. Maybe I'm just bitter. 
&gt; Besides, not everyone is wiling to wrap their head around what the compiler is doing by generating code while it's compiling code - this actually becomes a seriously large hurdle for using such features in a professional environment. IMHO, this is more of a tool issue than anything else. I've worked extensively with macros in Common Lisp, and I loved that I could get Emacs to expand a macro into a separate window for me. I could probably deal with Boost if there was a MACROEXPAND-1 for templates. &gt; Anyway, I'd wager that if Go had everything C++ had, and did it better, people would still turn their noses up at it. Case in point: D. I believe you're right. I think it has to do with the very high price paid to get good at C++. For too many people, once they've managed that, there's no desire at all to look for something better, because then they'd have to start over.
I think Go for the most part is a nice step forward in language design for distributed and cloud based applications. No requirement for a VM (it's packaged in the binary) and whole most other languages were designed with the idea of multiple processors in mind, Go was designed more with virtual environments and cloud structures in mind. That said, it's got a lot of buzz but it's not a miracle. Don't underestimate the benefits of academic interest though. My primary reason is just that I enjoy it. I think it strips away the layers of crappy tools people have had to spin up to make working in a language tolerable (looking at you Java). Also the low level nature of Go is a great reinforcer for fundamental programming concepts to me and it's a great example of how unnecessary a lot of our convenience structures are. It's also flushing out a lot of bad thinking and mistaken conceptual models in the programming community. How many people have posted critiques of Go that are really about their own inability to think in any other paradigm than OO programming?
Thanks for cluing me into 'recover'. I didn't know that was possible in standard go code - although I would expect that using it would be flagged on a code review! &gt; If you start providing APIs that need you to setup a deferred recover call before using them, you won't win many friends. Agreed. The Go way seems to be to be honest about disclosing your failure modes up front, and let the consumer handle mishaps right after the call. Although, it sounds kind of tidy to drop one-time error handlers under 'defer', I can see how we've managed to reinvent exception handling, including all of its drawbacks. Suddenly, I'm reminded of the javascript-callback "pyramid of doom" antipattern. These things don't always work with the simple case, and the correct case usually destroys any notion of using shortcuts to eliminate a zillion calls to .fail(myFailureHandle).
&gt; IMHO, this is more of a tool issue than anything else. I think you're right. The one major flaw involving templates is that, *without a concept checking implementation*, the user of said templates may at some point be forced to debug the template code. It's a powerful feature, and one of my favorites, but it's also half-baked IMO. &gt; I think it has to do with the very high price paid to get good at C++. You'd think there would be supreme bragging rights from being able to say "C++ made me such a badass that I eat other programming languages for breakfast", but that doesn't seem to be the case.
I may not be understanding your question properly but you can have unbuffered channels that store as much as you put in them, buffered channels keep to a particular size but unbuffered channels should grow or shrink as needed. What do you mean by locality? If you mean ordered, they yes they maintain order.
While it's a very "Go" solution, there are two reasons why you wouldn't want to abuse a channel as a list: 1. ~~Channels are implemented as doubly-linked lists~~ See thread below. 2. Channels are guarded by a mutex, or a lockless syncing primitive of some kind While I have not bench-marked this, I would wager that a channel would be *slower* than the linked list in the article. That said, if your linked list is being used for shared state across two or more goroutines, then a channel is the right answer.
A quick search happened to turn up [this](http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/), linked from [reddit](http://www.reddit.com/r/golang/comments/v9onh/parsing_huge_xml_files_with_go/). It's probably a good prototype and may carry you through to production, depending on your needs. I wouldn't be surprised it would be slightly faster to deal with the tokens directly, but I'd wait for it to be a problem before I worried about that. Also, thanks for your question... I'm glad to have learned the answer myself.
I recently had a need for something similar, to do it I: 1. set up [elasticsearch](http://joelabrahamsson.com/elasticsearch-101/). 2. Wrote a the parser (which i based off of [this] (http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/)) 3. Used [elastigo](https://github.com/mattbaird/elastigo) to push each `item` into ES.
thank you
No recruiter is going to help you go around them. Hopefully they're not a recruiter and you get a PM. 
Because you can't iterate over a channel without pulling values out of it. Also channels need to have a pre-defined size max size. If you use unbuffered channels, you need two goroutines to synchronize reads/writes. All in all it's just not appropriate.
so i downloaded elasticsearch. I can run it by running the .sh file form finder. How can I run it from the terminal? How can I exit it / kill it? how can I run it in the background? running $./elasticsearch -f doesn't do anything.
no problem. thank you.
I wrote some similar code for a queue of messages, except that as I expect the common case to be that a queue often never has more than one thing in it, if that's the case, instead of moving the slice forward one element, I actually go the other direction and back it up: if len(t.vec) == 1 { t.vec = t.vec[:0] } else { t.vec = t.vec[1:] } Then the next "append" will simply reuse the same storage. Thus, in the common case, you get 0 queue allocations. You could get more clever, but the bang/buck ratio probably goes south. Obviously this won't affect any benchmarks.
Good call. I gave the source another look: http://golang.org/src/pkg/runtime/chan.c You are correct: it would appear that the acutal channel storage is indeed an array (slice). However, chansend() and chanrecv() are anything but lightweight functions, and would invariably produce a lot of overhead compared to simple array addressing.
And here I was, wondering why there were Plan9 c compiler guts nestled deep within the go source distribution. I hadn't made the connection to Pike and Thompson. Very cool.
A more fair comparison would be between a slice of Things vs a linked list of Things and not the `interface{}` implementation that's in `container/list`. Not that it would change much, but still.
&gt; sending email via API services This has essentially turned email into a potential racket in the future as the number of mail providers steadily squeezes out all the small guys by blocking them.
No, I don't think so.
This would be a good solution if you just need to get the data out of the XML for searching later.
This link helped me out a ton a few days ago. I was parsing a huge XML file, and was using around 125+MB of RAM to store the data. Not good. Using this dropped the memory usage to about 5MB, as I only had to save one entry at a time. Although - I'd like to find a way to make this concurrent. I'm not sure parsing the file concurrently works, though, since you will be trying to parse a token after the decoder already moved on.
This is cool! One suggestion: it'd be great to have an option to just print out an example email or maybe just print out all of them (or write them to a file or files) so that you can verify that your template and CSV have worked properly together before sending. Maybe even something that would validate CSV or templates or both together and report errors?
Totally agree! Will add a debug flag in the coming days. Edit: I've gone ahead and added a debug flag. It prints out all of the raw emails and doesn't send them.
Brilliant vision! I can see that happening. I'm of the opinion that the gocircuit crew (http://gocircuit.github.io/circuit/) can provide the underlying infrastructure for a truly distributed OS. The ability to send type-safe data across networks between concurrent processes is amazing. If we can work out an "OS node" paradigm that can auto-scale and communicate with all of it's other nodes, then the way clustered systems is implemented changes dramatically. One more thing, Go does come with a seeker interface in the standard library. See http://golang.org/pkg/io/#Seeker for more info.
Vendoring your repo is the only way to cut repeatable releases, and tagging is the de-facto way to mark them. It's a better solution than gopkg.in in every dimension except, arguably, initial ease-of-use. Also, gopkg.in encodes practices that I consider harmful. Specifically, I mean how it promotes an arbitrary concept of version into the URL through an awkward convention, which will need to change anyway once the source VCS isn't GitHub. I think there's definitely a role for versioning import proxies in the Go dependency management story, but gopkg.in as it exists today, unfortunately, misses the mark significantly.
It's bad because there are several expression points where you have a partially-initialized Foo structure. That style of object init is a relic, I think, of languages where you don't have explicit struct literal syntax.
Sometimes named return variables clarify intent, but, more often, they obfuscate it. Scanning a function and seeing a naked `return` means you have to parse the preceding code somewhat laboriously, and look for instances where the implicitly-defined return variables have been assigned-to. Much easier for code readers and maintainers if you default to explicitly `return nil, fmt.Errorf(...)` or `return x, nil`.
A few small nits: The Go calling convention is described correctly, but the runtime is largely C (compiled by a modified Plan 9 C compiler), and C compilers return values in a register, not on the stack. The Plan 9 ABI is significantly different. Yes, the compilers come from Plan 9 (Inferno, actually), but the calling convention was modified. E.g. on Plan 9 first argument is usually passed in register. 
[**@rob_pike**](https://twitter.com/rob_pike): &gt;[2014-05-01 14:16:07 UTC](https://twitter.com/rob_pike/status/461871691631976448) &gt;If you are using Go as a teaching language, please let me know. [#golang](https://twitter.com/search?q=%23golang) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/24ggy2%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
4 people interested is a start. I'll try to drum up some more support and report back.
If you hit an error when sending the emails, you print an error and abort. I think you'd want this only in some very specific situations. Most of the time you would want to handle the error and keep going. eg. If you have a malformed recipient at email 100 or 1000 and the smtp server rejects it, you exit and must start over. Now you need to keep track of which recipients already received the message or risk sending duplicates (which nobody likes).
And enneff wants to know if anyone is using Go [for porn](https://twitter.com/enneff/status/461895727841828864). Makes me wonder/worry what they're up to....
Clearly, they wish to teach people how to make porn sites, and would like examples of both for their courses.
32bit darwin and 32bit windows both work properly on 64 bit versions, it's just linux. This works because darwin/windows always include the 32-bit C runtimes. Some linux distributions (namely desktop ones) probably also include the 32-bit runtimes by default, but I haven't checked to verify this. I'm trying to decide whether I just distribute all of them natively or if I special case linux 32-bit to not use the native libraries. I suspect freebsd would have this problem as well, but I believe those users are technical enough to understand what's going on that I wouldn't have to worry.
I love projects like this, a great example of how easy it is to get up and running and make useful utilities easily. I also enjoy your configuration file idea. I wrote a simple utility [servethis](https://github.com/tehbilly/servethis) that does almost the same thing, but was designed mostly to provide an alternative to an old bash alias for python's test http server for quickly sharing a directory. Note, I do have another branch where I'm hacking away on support for a daemonized version, one background process to handle the serving and just registering different contexts for each path to serve. Your configuration file seems to handle this pretty nicely with the 'serves' block. One thing I'm curious about, for why you usin' make?
It was the limitations of Python's HTTP test server that actually led me to write this (also it's dog slow on a PC, let alone on a RPi), but at this stage I'm seriously considering using it instead of nginx for my own website. The Makefile is mostly because I'm lazy and it saves me a few keystrokes here and there and integrates better into VIm with my current setup.
I don't know, in matlab we used to just multiply matrices with `A*b`, but I guess that depends on the definition of "serious" job.
Throwing this out there because I won't get a chance to play with it until later on tonight at the earliest, but decompressing/extracting archives isn't all that terrible with stdlibs. Threw together (and tested) some samples [in this gist](https://gist.github.com/tehbilly/a9cfa13292c1c9934ba9). Obviously the gzip-and-untar one should really only be used for smaller files as it loads the contents in memory, but that was the sake of brevity. You can use a buffered reader/writer to a temp file to make it slightly slower but much more memory friendly. Anywho, if you don't get around to it by the time I get a chance to (which may be awhile) I hope this helps.
Having come from years and years of doing Java and later C# (ick), making the switch to Go and not having generics really rubbed the the wrong way at first. Interfaces were confusing, and pointer semantics, especially with regards to interfaces almost turned me away forever. But once I got the hang of goroutines and channels, and doing things the Go way, life became a lot easier and I miss them less. Duck-typed interfaces for type-def'ed objects can largely replace generics when you know what you're doing, and select on type assertions can get you the rest of the way there. It's a different way of thinking, but it's entirely manageable.
whomp whomp?
This looks pretty interesting, thanks.
Awesome! That's not as bad as I might have thought, although it doesn't deal with the more complicated stuff like uid/gid modtime/atime, symlinks, etc. It's entirely possible that absolutely none of that matters for our admittedly very targeted use case though. If that's so, I'm willing to take the shortcut.
Added, thanks.
I had to read that a few times to make sure I got it correctly when I saw it for the first time.
Not entirely sure how it's handled. Damn you, now I'm curious with no way to test it! I'd assume operating system and user defaults if the go runtime doesn't use the information available in the archive. I know tar at least includes uid/gid and permission mask. 
error: // Receiver Name func (engine *Engine) Start() { car.Engine.Start() } unless car is a package level var, that code doesn't make sense.
It does, but you should have your Git repository in your project folder, then a go get github.com/aspic/g-wiki will put it in $GOPATH/src/github.com/aspic/g-wiki. Mostly important for libraries that need to be imported consistently, but also nice for other applications. From the perspective of your local file structure your are correct and nindalf is wrong, it is just the convention to add only the project folder to version control.
I am a game developer working most of my day in C++. I also use Go in production for a server side of my company's project and I am trying to write a 3D engine and hopefully a game with it as a free time pet project. I was driven by Go's pragmatic approach to development.. the simplicity of the build system, the expressiveness of duck typing and the channel approach to concurrency. Of course, like many C++ devs, I miss things like operator overloading (this one, a lot!) and generic programming.. but the more I use Go the more I find that I can live without them and that I don't mind repeating some code.. it's nice code nevertheless :) I think I am a sort of white fly here because most Go users seem to come from scripting languages like the OP and not from C++. 
I’ve been writing Ruby for many years (and still do) now, and I have found Go to be a great companion language since it has characteristics quite different from that of Ruby. One big thing for me is the ease of dealing with concurrency in Go. The fact that Go, generally, is much faster than Ruby is also nice.
This is awesome. Do you think you could apply the same approach to 3rd party C/C++ libraries such as, say QT or something?
Coming from Python/Java/C++/JavaScript(!), I just love how simple Go is in comparison to all those languages. Absolutely adore how the tooling is far superior to absolutely all of them - messing with pip/Maven/Gradle/Node/GCC feels positively medieval now.
Yeah, I wrote https://github.com/rif/spark a while ago with only 61 lines of code :)
https://code.google.com/p/go-wiki/wiki/Range - just FYI it's perfectly safe to write: for _, listener := range cfg.Listeners { instead of: for i := range cfg.Listeners { listener := cfg.Listeners[i] It's even better to write: for _, l := range cfg.Listeners {
Good spot! Ta.
Coming from python, I just wanted to make simple, easy to distribute tools that work across different systems. Python seemed to be the solution until I started actually trying to deploy code. It was too much of a headache, and I like that go makes native binaries. Also, goroutines make concurrency fun to learn.
porn.google.com soon in beta?
Nice post, thanks. Was looking for something that connects a few more dots between Ruby and Go and this covers some interesting topics.
I have been writing Ruby for quite some time now, mostly developing web services and smaller automation tools. Reading about a lot of big companies rewriting essential parts of their infrastructure in Go made me curious. I’m now looking into Go as a first step towards something "closer to the metal" and really like it so far. I’m especially interested in web service architecture and will start rewriting one of my smaller Sinatra apps soon to see what problems I’ll encounter.
Coming from Java, and still a beginning programmer in general, I must admit that Go is cool. That's what initially drew me to the language. After that, I like thinking about all of the standard CS concepts and how they may or may not mesh well with concurrency. Also it's also powerful but not unwieldy (garbage collected) , and it's really fast. The other thing I like is the environment to program in Go is very nice. The ability to create a binary for a hello world program is really cool, this is something I have yet to learn in any other language, and go just makes it easy. 
I've spent a long time coding in C++. I'm now aiming to use Go wherever I can, and will only resort to C++ where absolutely necessary.
I'm a mathematician, and I write software for my research in a variety of languages, lately Python (using Sage) and GAP, occasionally Haskell. I tinker with some side projects for fun in a few different languages, and I keep gravitating towards C-style languages. I've written stuff in C, C++, and Objective-C. I've always liked C-style languages, something about it's nice combination of low-level and simplicity. It just feels nice to sling pointers around. Go was advertised to me as a modern C-style language, and so I worked through the tutorial and it was a lot of fun. I think my next side project will probably be written in Go, whatever it is.
I'm a backend software engineer but have done a lot of website development too. I'm interested in go because of the language features (structs, interfaces, goroutines, channels, etc) and simplicity of the language. I've been hacking Java for the past 3-4 years, but have done a lot of erlang in the past in addition to the usual spread (python, c, c++, ruby).
I'd seen this used in the Hugo source code and have been meaning to give it a try! Sadly I have been a little slammed lately and not been able to code much at all, same reason the Hugo management handler has been put on hold. Gotta say, though, all of your libraries I've used have been quite pleasant. Cobra is my favorite cli utility by far. JWW is on my short list to try next, I've been using logrus so far but always enjoy trying alternatives.
Great! Thanks.
This is literally the coolest thing I've seen all week. I am seriously going to go look at mindstorm prices now
I'm coming (most recently) from Python, D, and C++. I'm interested in business programming in Go, specifically for its clean and exception-free error handling idioms. Go's built-in concurrency and channel models are the icing on the cake, since there are no C-like languages that provide these features out of the box. To me, understandability of third-party code isn't nearly as important as performance, reliability, and security. To that end, Go wins out over Python by being a compiled-to-machine-code langauge, that is strongly typed, and is simple to construct. However, we get a boost in readability anyway since the language is relatively simple. What I miss from other languages is mixed-paradigm support, and lack of concessions for DRY. I would like to see generics implemented, which would support both of those "missing" pieces. That said, after digging through some projects like "revel", I really don't see too much code duplication going on, so I'm encouraged that lacking those features won't be a big issue once I start writing sizable apps. What I look forward to is not NaCl, but official Android support. I would prefer to build apps on Go over Java (and Objective-C for that matter) any day of the week.
&gt; Second, PHP's inconsistent function names, argument orders, and return values were clearly evolved and not planned. I believe the inconsistency in the standard PHP libraries, with respect to naming, stems mostly from earlier versions where PHP wrapped standard C/C++ libs. I believe the platform authors used the original C names wherever possible, in order to court CGI and system programmers of the time; so there was clearly *some* planning involved. At nearly the same time, Java and .NET showed us that this bit of pragmatism had stiff drawbacks, and that making the entire standard lib uniform trumps immediate familiarity in that it accelerates learning and recollection when moving forward with the language. And it's a shame too. PHP with a well-groomed standard library set would have been something nice indeed.
nil can actually be quite powerful.
Been using a version of this for a while, thought I'd share the code. Feedback is welcome.
Look, I dig go, but java is much more functional than cobol and has a much richer ecosystem than it ever did. 
I've been a RoR/Javascript developer for 5+ years now, and I've mostly been happy with that setup. But there are some pain points in the areas of concurrency, speed, and ease of deployment, which I don't think will ever really be resolved within the Ruby ecosystem. Those are all areas where Go shines. There are certain aspects of it that can be hard to grasp, like channels and interfaces. Those things take time to get used to if you've been working in Rails for long enough. But the language is super-fast, easy to understand like Ruby, and easy to deploy to any kind of server you want. So there's enough ease there to outweigh the frustration of learning a new language. Also, useful software tools are already being written in Go (talking about Docker, Ngrok, etc.) The users of the language seem to be carving out a niche for it, much like what happened with Ruby. I think that's a sign that it's going to have staying power.
He's implicitly answering the question "what will be the legacy software of the future?" - which is not so much judging the language on its own as estimating how ubiquitous Java is right now and predicting that Go will be.
Btw, some of those benchmarks are a misleading. The binary-trees one is meant to test the GC of a language, which leads to slow benchmark times for Go. But then the C++ version is allowed to use a pool/free-list to cache memory to be used for the tree. If Go were allowed to use a free-list, it would be much much faster. Edit: to add. Go #6 for the binary-trees solution would be ranked "3.9" overall using a pool implementation. It's listed in the "wrong" section of the page.
Via HN. Discussion: https://news.ycombinator.com/item?id=7687301
Taxi from airport to downtown is $53 flat.
They absolutely accept replacement programs if you think you can do better. As a relatively new, relatively small language, there is likely room for improvements. http://benchmarksgame.alioth.debian.org/play.php#contribute 
Yup, indeed. I've submitted a few solutions for Dart probably a year ago. But the benchmark has inherent problems that you need to understand when looking at the results. It's not so much "what's the fastest way you can solve this.", it's more of "solve this problem using this algorithm." Some algorithms just perform better with some languages than others. So it's not always a totally fair comparison. The one I called out is [binary-trees](http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=binarytrees&amp;lang=all&amp;data=u32). [One of the Go solutions](http://benchmarksgame.alioth.debian.org/u32/program.php?test=binarytrees&amp;lang=go&amp;id=6) is listed as being "wrong" because it uses a free-list to bypass excessive garbage collection, but it is 3x faster than all the other Go solutions. But the [C++ implementation](http://benchmarksgame.alioth.debian.org/u32/program.php?test=binarytrees&amp;lang=gpp&amp;id=7) for that same problem also uses free-lists (apr_pools) but is considered a correct solution. So it's not exactly fair.
Full stack web guy. I've worked in Java/PHP/C/C++/Ruby/DotNet/Javascript, PHP seems to be the default fallback position if I just want to get things done. Haven't wanted to write PHP once since I started with Go. Things I am loving: 1. It makes concurrency use the same paradigm that I am most use to as a network programmer (I/O). 2. A solid, focused and coherent stdlib. 3. Speed! Performance absolutely crushes similar systems built in PHP/Python/Ruby. 4. No callbacks/scoping weirdness (ala Node.js).
Delphi and Object Pascal, as learning tools, are fantastic. They don't seem cool. But there is some really good stuff in there. Pascal was at one time considered a great teaching language, used in many schools. It was almost universally replaced by Java. Which... yah. As someone who has been interviewing and hiring programmers for almost two decades I would not say this has worked out well. 
That's like 90% of what people are using it for.
I think a SOA backend is the perfect scenario for Go. * How's the deployment done? scp the binary, restart init service * ORM? I've used https://github.com/jmoiron/modl and I like it. I understand it's mostly niceties around gorp. * Editor? Sublime + GoSublime is great. * Migrated from X to Go, performance? Much performance. * More productive? Yes. I believe this stands as the Ultimate Truth.
thank you, that's exactly what I meant by that statement! Maybe I was just being too trollish with the title ;)
I asked a related question few days back. Hope it helps: http://www.reddit.com/r/golang/comments/23yqen/building_a_real_webservice_in_golang/
Can recommend Sublime Text + GoSublime as an editor setup. Offers automatic code formatting with gofmt, autocomplete for the stdlib and imported packages and a lot of other nice things.
Go isn't Matlab. [Matlab is a scripting language which incorporates a translation layer that maps common matrix operations to the relevant LINPACK and EISPACK matrix kernels](http://www.mathworks.com/company/newsletters/articles/matlab-incorporates-lapack.html). Unless you are willing to rewrite Go to include such a translation layer for your overloaded operators, operator overloading is useless in serious jobs.
Good point, I got carried away in the moment and continued calling it BufferString somehow :) Will fix now, thanks! Edit: fixed. *phew* Thanks again!
We've doing something similar over at Documize. REST API via Gorilla Mux. "Heavy" processing runs in separate processes on different machines which the REST API invokes via RPC. Hence the REST API is fairly "light". Hope this helps you.
You know, I have problems acknowledging the fact that you can concat strings in Go with `+`, and I'm not sure why. I catch myself using `fmt` to put two strings together, which is obviously very slow in comparison due to reflection. Grr! Then there's a convenience factor ... fmt.Sprintf("Blah blah error, message=(%s), user=(%s), ip=(%s)", msg, user, ip) or "Blah blah error, message=(" + msg + "), user=(" + user + "), ip=(" + ip + ")" :( Benchmark shows `Sprintf` is around 4x slower. I guess you just gotta watch for it in performance critical code.
Minor nitpick, "using the Buffer class", it's a type; Go doesn't have classes :P
Yeah, unless it's performance critical *and* benchmarked to be the actual bottleneck, please stick to Sprintf. That other one is hideous, and I really doubt that a lot of performance critical code needs to print such strings.
Hi there. This is pretty much exactly what I am doing at [Walkbase](http://www.walkbase.com) right now - slowly replacing performance-critical parts of our back-end with Go. Deployment is currently just using SCP / service restart. We're in the process of setting up our CI system to "speak Go", after which it will automatically run unit tests / deploy whenever we push something to master. For now we've been using lib/pq to talk directly to the database (We use PostgreSQL). Sublime + GoSublime + goimports has been working great for me, YMMV. As for performance, the initial re-write is showing (single-threaded) gains of around 25x which has made both myself and our sysadmin very happy. Memory usage is also down ~30-40%. Productivity is always a hard question to answer. Personally, I think while writing Go is a bit slower, you tend to write it correctly the first time around, so I would call it a net-win, at least for our use cases so far. The testing framework / tools are also great in Go and have inspired me to integrate more TDD in my own work flow. On the whole, I have been very happy with Go so far and plan on continuing to replace parts of our back-end with Go equivalents, especially services where I am not satisfied with the current CPU / memory usage.
It'd be also interesting to see how fmt.Sprint performs.
If you want something like gunicorn for Go, I recommend https://github.com/zimbatm/socketmaster . It's worked really well for us. You only have to worry about gracefully shutting down your Go app. The more complex signal handling and forking is all handled by socketmaster.
Hey, do you know of any good math library in Go?
An important thing to make note of is that the graphs only apply when doing very large concatenations. Confusingly, those graphs aren't what the code for the linked benchmarks actually tests. The linked benchmarks are comparing the speed of doing many small concatenations rather than testing the speed of very large ones. This is fine, but it's important to make the distinction. In the actual benchmarks, when concatenating 10 short strings, the naive approach is actually faster. The more efficient methods don't really surge ahead until you reach well beyond 100 concatenations. This creates a case where trying to micro-optimize can actually result in slower, unnecessarily complicated code. Where the more complicated methods really come into their own is when you're doing thousands of manipulations. In this realm the immutability of strings is clearly problematic. []byte becomes more suitable in these cases. In fact that's exactly what's going on in the benchmarks, it's nothing more than using []byte and converting it back to a string at the end. In this realm where you're trying to keep your code efficient, there's no good reason to keep converting to and from strings until you really have to. I take two things from these benchmarks. The first is that when dealing with small concatenations, there is no good reason to avoid the simple naive route and plenty of reason not to. The second is that when creating or manipulating very large blocks of data, it may be better to use []byte as your base type, only converting to a string if you must. 
This doesn't negate the work done in there, but I'd observe that in most cases, the best way to concatenate strings is to not concatenate them in the first place. Most need to concatenate large strings comes from some API having (in Golang terms) `string` where it ought to have `io.Writer`. If possible, rather than collecting strings, it's way more efficient to pass around an io.Writer (preferably buffered), and simply write the strings out to the target directly rather than collecting them all up front. An `io.Writer` can be converted to a string fairly easily, but a string can not be transparently converted to a stream. As it happens I've spent the last two days fighting this, in a non-Go API and environment pretty hard-coded to `string`, and I lamented the fact that a stream was not an option. So I'm pretty keyed up about this right now. :) Like I said at the beginning, it's still good to know the fastest way to do this because sooner or later you'll encounter an API that gets it wrong, and you'll need to know how to deal with it. This, incidentally, isn't really a Go-specific thing; nothing stops most languages from passing around an output stream instead of expecting a string. It's a common API-scalability error in many environments; concatenating a few small strings together every so often isn't a problem, but it doesn't scale up well, and people designing APIs don't always get that.
I have this line in my .bash_profile: export CDPATH=.:/usr/local/go/src/pkg/:$GOPATH/src/code.google.com/p:$GOPATH/src/github.com
Nope, I do not. 
Woah! That's very cool :D How did I not know about this? It makes sense that this would exist, but I never even considered that it might.
I replied to the comment which claimed "real world matrix multiplication never uses operator overloading anyways". So matlab is pretty real in a some cases, and does use operator overloading.
WHERE ARE THE VIDEOS
I much prefer plus and inlining the variables with the text. Call me crazy, but in some cases seeing what the 4th %i out of 6 is more complicated than just having the vars there. Even if " + + " is 6 more chars (spaces included).
Patience, young jedi. Being edited, they are.
Just to add another data point, we use Go for the services powering [Microco.sm](http://microco.sm). I did a [talk about it a while ago](https://speakerdeck.com/mattcottingham/building-an-api-with-go-at-microco-dot-sm). If you download the pdf, the links will even work...
If need .bashrc, why do not use simple bash wrapper func? Expl (to .bashrc): function cd_wrapper() { case ${1} in "me" ) cd "~/Dropbox/Programming/go/src/github.com/alexhenning" ;; *) echo -n "cd wrapper error\nunk dest \"${1}\"\n" ;; esac } alias bash-go='cd_wrapper' And use: $ bash-go me
The shortcuts were just a bonus, the real reason I added it was to go to the right package location since I was working on some xml stuff and the latest version of Go had some added support for xml, so I wanted to be able to look at the current encoding/xml without remembering where it was stored (since the path for each version is different when installed with gvm). It's probably not a problem if you're only using one version of Go, then YEPHENAS CDPATH trick would solve the problem in one line. Also, I got to right some Go code and learn some things.
Patience is hard. I'm waiting for them too :)
Is this the same concept as [marks](http://jeroenjanssens.com/2013/08/16/quickly-navigate-your-filesystem-from-the-command-line.html)? 
Excellent writing. I now understand some of the finer points of the type system much better. I appreciate that you quote the spec and link to the wiki to lend authority to your writing. 
I agree, because you see the name of the variable inline with the string you are printing. I like seeing something like: "Hello, " + username + ", your user id is: " + userId I can easily skip over the quotes and + symbols.
Over at SendGrid, we've started moving some internal services to Go. From the results we've seen so far, we plan on Go being the dominant language for the company's backend services moving forward. We are still playing around with the best way to deploy because we want to have a unified methodology for all our services that span some six or more languages. The services that we have replaced do not directly interact with the database, so I've no recommendation there. As for development, we have a few devs using intellij, but most use Sublime+GoSublime and/or vim. Performance improvements have been great. Personally, I feel that the code is more maintainable that some of the legacy stuff. The main reason for this is the concurrency model in Go is simple. 
I see how that can be useful. Thanks.
LiteIDE has the same and it's open source.
Thanks for clarifying my ideas.
This is useless since there's $CDPATH. 
Question: What happens if you embed two types that implement the same method? ~~Answer: it compiles but doing outer type.method is a runtime panic.~~ Edit: http://play.golang.org/p/J3P7yTiTQf It will compile unless you try to do `outer.Method()`, then it fails at compile time.
You are confusing entirely different concepts. Operator overloading is one thing. The way Matlab lets users "just multiply matrices with A*b" is a completely different thing. I've provided you with a link to a Mathworks site which explains what is involved in Matlab's "just multiply matrices with A*b" feature. It has nothing to do with operator overloading. That's not how Matlab implements their matrix and vector operators. Plain and simple.
Oooooh this is very nice, kudos.
Also, with the arcana of C and fortran print format irregularities still rattling around my old brain I'd rather not have to think about them unless I absolutely need fixed width decimal point formatting.
This is my first Go project so feedback is very welcome. I used Martini because I do a lot of Ruby programming with web frameworks. However, if I were to start again, I'd probably go with Gorilla without all the magic. Not that it is bad, but the project might not really need it. Keep in mind that Disgo is not production ready. My goal is to migrate all the comments on my sites from Disqus to Disgo in a few weeks.
This is something I have always wanted to learn! I hope the entire 10 part series is actually produced,
The goal of this package originally was to simplify the use inotify in go. Then I found fsnotify. Now may plan is to make a cross platform (via fsnotify) and encrypted file synchronization system. So I suppose still calling it fsmonitor is a little inaccurate, perhaps I should change that. Any name ideas? My long term goal is to create a system, inspired by things like dropbox and google drive that is also encrypted, client side, that anyone can use and host. There will be client code, what comes from this repo, and once I get something a little closer to feature complete I will start on server/web code. The purpose of encryption.go currently is just reading files in chunks so that I can at least work out some of the bugs with file I/O with this system. encryption will come later. Thanks for the link to Notify. I was planning on doing that eventually, I know the dangers/shortcomings of time.sleep on production code. Just last night when I was working I realized that the queue was probably overkill and that I could probably just use channels everywhere instead. Thanks for the feedback, I really appreciate it. When I get a little closer to feature complete I will probably post here again to show everyone. 
It looks like the whole series is already written and was posted at once. He has code up on github.
Awesome! Didn't see it on my phone! Thanks for the confirmation!
Instead of building a new server why not a new type that supports all the interfaces and behaviors of File except for multiple object storage backends? Dumb plain old storage so to speak. You could still implement a smart backend object storage with more features that can be swapped in place of the dumb plain old storage backends.
In this case, it's not a problem but sometimes it can be: the *\_, l* form creates a copy of the value of each element of cfg.Listeners; sometimes you want the actual element (e.g. if you're mutating it).
That sounds like a good idea. How though, using plain dumb storage, would I manage synchronization? Or am I missing the point entirely? To give you a little more context, the current architecture I have in mind is as follows (and is not finalized): * email &amp; password authentication before establishing a connection with the file server * Every individual file has its own key pair that is used to encrypt / decrypt the files [1] * Users have an AES key that is generated using their password * This AES key is used to encrypt the key pairs so that they can be stored on the server without the server host being able to read the keys and decrypt a user's files * Once authentication is successful, files are synchronized to that client [2] * While the client is active files are syncronized [1] - There are some reasons for using keypairs instead of just using an AES key that may not be obvious. For example, using a distinct keypair per file allows files to be shared without compromising the security of all of a user's files. [2] - I do not yet have implementation details for this part yet, I have a feeling doing synchronization well will be difficult I really do appreciate the feedback; that is what I hoped for when posting here!
The client, in this architecture, would drive synchronization. You would need to either keep a local database that identifies what is on the storage or be able quickly query the storage for characteristics of the data being stored. If the files are intended to be encrypted and the user key is what is needed to unlock the key pairs then you could store the encrypted key in the file. Figure out the structure of the format you will use to store on the backend. Think about each file as a container rather than just an encrypted version of the file. Are you going to sync the entire file when it changes or just changed blocks. Are you going to use a rolling hash to calculate those changes? Fixed or sliding window block size? I have a bit of experience implementing something like this but in c++. I would love to get in on this with you and it would be a perfect way for me to really learn go, but it might be a conflict of interest for my employer.
&gt; If the files are intended to be encrypted and the user key is what is needed to unlock the key pairs then you could store the encrypted key in the file. Encryption is the main goal here but I do not see how storing the keypair in the encrypted file is useful if the keypair is used for encrypting and decrypting the file. I may not be totally understanding what you mean here. &gt; Figure out the structure of the format you will use to store on the backend. Think about each file as a container rather than just an encrypted version of the file. Ideally, the server is as dumb as possible since we want to keep a user's file out of the hands of everyone except themself and those they choose to share files with. As a result having the encrypted files be containers really does make sense, I like that, in fact my initial thought was to store meta information like filename, filepath, modtime, etc as a part of the encrypted file. That way even the name of the file can be encrypted (and therefor hidden from the server). &gt; Are you going to sync the entire file when it changes or just changed blocks. Are you going to use a rolling hash to calculate those changes? Fixed or sliding window block size? This is something I cannot answer but not because I have not thought about it. Because we assume (and desire) that the server is dumb, it knows nothing about a user's files (except perhaps size because they *are* storing it) then a lot of data about the last uploaded version of a file would have to be kept locally to be able to minimize future bandwidth use via hashes or other methods of only sending a changed part of a file. I have a lot of random notes/thoughts about this piece of the project but none of it is tested or vetted in any way yet. I'm happy to have more people interested in helping me make this a reality. Currently it is just myself and one of my roommates (sadly he is currently too busy to help much recently he is interested). 
&gt;Encryption is the main goal here but I do not see how storing the keypair in the encrypted file is useful if the keypair is used for encrypting and decrypting the file. I may not be totally understanding what you mean here. If you decide to have the storage for the file end up being a container a portion of it would be the std_data of the file encrypted another node would be the keys to decrypt the std_data encrypted with the user AES key. &gt; &gt;Are you going to sync the entire file when it changes or just changed blocks. Are you going to use a rolling hash to calculate those changes? Fixed or sliding window block size? &gt;This is something I cannot answer but not because I have not thought about it. Because we assume (and desire) that the server is dumb, it knows nothing about a user's files (except perhaps size because they are storing it) then a lot of data about the last uploaded version of a file would have to be kept locally to be able to minimize future bandwidth use via hashes or other methods of only sending a changed part of a file. I have a lot of random notes/thoughts about this piece of the project but none of it is tested or vetted in any way yet. I'm happy to have more people interested in helping me make this a reality. Currently it is just myself and one of my roommates (sadly he is currently too busy to help much recently he is interested). All of the above items that will need to take place in the client and be managed by the client. But this could be part of the metadata in the container. One thing to think about also is how to rebuild the local metadata from storage if the local data becomes corrupt. Keeping a clean delta tree on the storage will help prevent merge nightmares from happening in the future.
I wrote something that uses the SSH client with certificate-only auth. You can use it with files created by ssh-keygen. It's here: https://github.com/bowenl2/sandhog/blob/master/sandhog.go I borrowed most of it from somewhere; I can't find where.
Have you looked at [nanovg]( https://github.com/memononen/nanovg/blob/master/README.md)? The api looks nice. It's in c++ but it should be easy to port/rewrite.
Thanks. The slides were very informative. Do you happen to have a video/recording of the talk?
Check out the net/http package at http://golang.org/pkg/net/http/ Also, take a look at Revel and Martini: http://robfig.github.io/revel/ https://github.com/go-martini/martini (Sorry for the format, typing from my phone)
Unlike php, its not a scripting language. It compiles to binanies whuch can then be executed. I using it for some web apps, replacing some olde python.
Also Gorilla http://www.gorillatoolkit.org/
Yes, that's primarily why Go was created. See the [Writing Web Applications tutorial on golang.org](http://golang.org/doc/articles/wiki/) which guides you through creating a simple wiki server.
PHP is a joke.
I guess I'm a little lost as to the motivation. You can already compose `http.Handlers` in a chain-like manner, i.e. http.Handle("/gophers", GzipHandler(CachingHandler(innerHandlerThatActuallyDoesStuff))) // and then like ... func CachingHandler(inner http.Handler) func(http.ResponseWriter, r *http.Request) { return func(w http.ResponseWriter, r *http.Request) { if v, ok := cache[r.URL.Path]; ok { serveCached(v,w,r) } else { inner(w,r) } } } I guess I'll ask the same question as /u/daydreamdrunk, what does using this package net me that I don't get in the above construction? Everything I can think of seems within reach without having to introduce more types. It's cool to see packages that try to play nice with `net/http`'s interfaces, whereas I found stuff like Martini middleware kind of chucks a lot of it out the window. So good job on that front! :)
As far as I understand, operator overloading does not relate to the underlying implementation. The point I was trying to argue is: 1. Operator overloading is sometimes good, because it lets you use familiar mathematical notation where it makes sense, for instance when multiplying matrices. 2. The industry indeed uses mathematical notation for matrix multiplication, for example in matlab.
Here's the co-founder of Wordpress, saying that if he had the chance to re-write Wordpress, he would write it in Go. :) http://www.reddit.com/r/IAmA/comments/1jg781/i_am_matt_mullenweg_cofounder_of_wordpress_18_of/cbed1jk 
In India at least it looks like its time for golang to take center stage - http://blog.joshsoftware.com/2014/02/04/does-the-next-decade-belong-to-go/
This was the most understandable piece of Golang tutorial that I've read. Receivers and Interfaces are explained easy. A great starting point for every Gopher. 
That's very cool!
Yes, but not in the way you expect. With PHP you freely mix code and markup (HTML). Go is in a way much more rigid, but at the same time much more flexible by seperating code from content. Have a look at the templating package while you're at it. http://golang.org/pkg/html/template/
Thanks - commenting since I want to spend a week with Go and this looks like a good starting point.
I was stuck at the receivers and most notably the Interfaces - I couldn't understand them. The examples in Golang.org are not very practical... I stumbled on it via GitHub ... It was really hard to find and doesn't come up in Google.
This is a very nice and comprehensive tutorial for web programming in Go. Thanks for your work.
Well, honestly, seeing people using Martini in that way was my main motivation. People seem to like it though, so I wanted to try to make a package that provides similar benefits without losing the simplicity of net/http's APIs. Beyond that, I've had to do some work where I ended up with this: HandlerA(HandlerB(HandlerC(HandlerD))) and I think HandlerA, HandlerB, HandlerC, HandlerD is just easier to read and cleaner to implement in the Handlers. It makes things like returning early because of an error (e.g. authentication) rather nice.
I agree to some degree. For the last two years almost all of my work has been in Golang. He was asking for a comparison to PHP and where it differs.
This is the best and most comprehensive tutorial on writing Web Apps with GOlang: https://docs.google.com/file/d/0B2GBHFyTK2N8TzM4dEtIWjBJdEk/edit
If you think that specifying the data type is the biggest difference between Go and PHP, you're going to have a bad time.
https://twitter.com/GopherCon/status/461558996659605504
[Probably](http://www.meemes.com/sites/default/files/styles/galleria_zoom-copy/public/Soon-gordon-gopher.jpg?itok=EWpTLVV6)
I'm surprised the entire thing wasn't live streamed :/ But yes, they're coming soon.
wow that's a huge document, thanks!
PSA: This is a repost of a very popular tutorial that was published over a year ago and translated also about a year ago (IIRC?).
I wish I could write Go for AVR/PIC, a tiny non-GC version.
How about the performance?
Yes. Here's the translation: https://github.com/Unknwon/build-web-application-with-golang_EN and here's the original: https://github.com/astaxie/build-web-application-with-golang
I know it's not really related, but what packages are you using for your sublime setup?
Go pretty much requires a 32-bit machine. 
i wrote/ported couple of scripts while I learnt go, hope you can find something interesting in there https://github.com/senthilnayagam/go-web-developer 
Check out martini. It makes serving static files and web apps pretty simple. 
Probably what you're missing is what to put in the URL to get to the web app. You need to find your server's host IP. I don't have a Mac, so maybe somebody else can chime in, but from the other machine on your network, you put the IP of your server machine in where you used to either put `localhost` or `127.0.0.1`. (If you needed a colon and another number for the port, you'll still need it on the other machine.) Bear in mind that this IP is almost certainly valid only on your local network, and this will not work for any form of external access. (At this point, that's a feature, not a bug.) It is also possible for the server's IP to change, though generally the address it receives from the router will be fairly stable. Still, if it suddenly stops working from the remote machine but it still works on the serving machine itself, that's the first thing I'd check, whether the IP is the same.
Can't you do it concurrently or something?!?!?! :D
Yep... but with ARM processors becoming ubiquitous, I would say that the future is definitely rosy. Kudos to the Go core team for playing the ARM support story so nicely. The only weirdness is "Intel Galileo." The particular 586 processor used by Intel does not support Intel MMX, which is currently required for some operations in the Go runtime (64 bit atomics, for ex.) 
Atom is now open source: http://blog.atom.io/2014/05/06/atom-is-now-open-source.html
Aaaaa all these GopherCon posts and no videos.
Cool. Is it OSX only?
Getting some stuff ready to start playing with this now! I've had a Pi for a bit now and been looking for an excuse to start messing with controlling things with the GPIO pins.
If you just want to access it on any machine on your own home network, just listening on 0.0.0.0 (let's assume TCP port 80) should do the trick. Then, you get the IP address of that machine (ipconfig or ifconfig depending on your platform), and - on the other machine - browse to that IP address.
Honestly, at that scale, the leverage Go gives you is kind of overkill. While I can't speak to PIC work, I've done some AVR assembler and it's worthwhile for many applications given the (relatively slow) processor speed and how timing sensitive that makes things. And with a mere 2-4k of RAM to work with, I'm not convinced that Go gives you that much more over C or C++. While I can imagine Go being steered into some tight spaces, compelling language features like channels, maps, and slices (and possibly closures) all go away without GC support. That leaves you with a C language variant with some subtle improvements like better namespace management and type inference on assignment.
Slices are just pretty arrays, and maps don't need a global GC. Only channels are not easily portable to micros.
Just for learning, i write this small http/fileserver http://github.com/jordic/file_server
Thank you!
I'm actually teaching a newcomer Go right now. I'd absolutely recommend it.
Start here! http://www.golang-book.com
i am actually using that haha. I've gotten to multiple functions and feel slightly lost. first chapters went by with a breeze finished all the problems in no time haha. Slices and Arrays took a little longer (still kinda meh on them) And have been trying to get the 2nd problem on the multi function chapter done for a few hours now ha Edit: i do love the way he writes the tutorials though. it is very informative.
*disclamer : i'm from clever cloud* There is http://golang-cloud.com/ build by the http://www.clever-cloud.com/ team. I use it.
Having a full-featured llvm Go compiler would be great! On a side note I remember about half a year ago there was a problem with the grabage collector (or rather no garbage collector whatsoever). I wonder if it's fixed by now.
I started with VB.net as my first language. Personally I would recommend you start with Python because its interactive prompt allows you to learn the language in a quicker more iterative way that gives you much quicker feedback with regards to what you code. Going from Python to Go is not too hard of a job once you get a hold of the language.
Heroku works as well. They have a go specific buildpack[1] but I prefer cross-compiling and then only pushing the binary through heroku using the null-buildpack[2]. [1] https://github.com/kr/heroku-buildpack-go [2] https://github.com/ryandotsmith/null-buildpack
I've had good luck with OpenShift. Its free for a small app. Getting started is easy from the example repo they bootstrap you in with.
Attachments were added in a pull request https://github.com/zachlatta/postman/pull/4
I can't seem to get your pricing widget to work, so I can't determine how the cost compares to other solutions.
I use [dokku](https://github.com/progrium/dokku) on Digital Ocean. They have servers starting at $5 and dokku basically acts as a free PaaS like Heroku with only a bootstrap script and a bit of config.
Cloud Foundry (https://run.pivotal.io) can also be used to run go apps using buildpacks. You can use this buildpack: https://github.com/cloudfoundry-incubator/cf-buildpack-go Alternatively, the null buildpack can be used with a binary as suggested by divoxx. Disclaimer: I work for EMC, which owns a significant amount of Pivotal.
What resources would you recommend? I personally hit a wall after learning the basic syntax. If I want to learn any sort of structures or technique, there's plenty of documentation in other languages but in Go someone may have never done that before.
Thank you so much for this expl, it's really helpful to me. The devil is in the details :) PS: sorry for the late reply.
Thank you. This is an interesting example.
Consider [Google App Engine](https://developers.google.com/appengine/docs/go/gettingstarted/introduction?hl=en). I don't use but [go read](https://www.goread.io/) does! It's well integrated into a powerfull framework and free for small projects.
Also a new comer here. If someone could point me to some great beginner project ideas (appropriate for using Go's features), I'd appreciate it 
Choose a language that will keep you programming, switch if it is not the right fit. Find a problem you want to fix, and try to fix it. Keep doing this. If you can't think of something ask your buddy. Also here are some resources http://dave.cheney.net/resources-for-new-go-programmers
llvm is an amazing compiler infrastructure for starters. It will be able to do optimizations gc compilers won't be able to.
They're using libgo from gccgo, which includes the garbage collector. I'm not sure they completed bindings, if not it should only be a matter of time.
Is Pythagorean theorem an empirically falsifiable claim? And is it science? Because, dear idiot, as I mentioned several times, applied mathematics is *not* science. And I was not referring to the falsifiability of the "claims" of computer "science" by and on it's own, I was referring to the lack of it. Theoretical computer science is just applied mathematics based on physics-motivated axioms, and what programmers do usually is engineering. &gt; Anyway, your friend popper says that falsifiability is a necessary and sufficient condition for something being scientific I initially didn't think you were an actual idiot. Clearly, you were an illiterate who doesn't know how to read things. But now I know. You are indeed a real idiot. And just a waste of time. Bye.
Pythgorean theroem is not falsifiable, it is proveably true. For it to be falsifiable, it needs to be a statement about the real world, such as where we say that A takes a shorter time to run than B for the given array (data).
Oh really? Glad you were here to save the day. A proof based on the *axioms* of the Euclidean *geometry*, a branch of *mathematics*. Mind you, it doesn't hold in [reality](http://en.wikipedia.org/wiki/Spacetime), since we're not living in a space with Minkowski metric. And as much as you would like to use the word "data" to meaninglessly ascribe or associate the measurements in scientific experiments with computer "science", it's just that. Meaningless.
Does this mean that we can run go on GPU like rust? http://blog.theincredibleholk.org/blog/2012/12/05/compiling-rust-for-gpus/ Can't wait to see the benchmark of massive goroutines being distributed to a 192-core system like this. https://developer.nvidia.com/jetson-tk1 
Right, so you disagree with Popper that falsifiable statements are scientific. I'm truly honored to be talking to a demarcation problem expert here! So, what are your criteria? Why is physics science? But really: "In Popper's later work, he stated that falsifiability is both a necessary and a sufficient criterion for demarcation. He described falsifiability as a property of "the logical structure of sentences and classes of sentences," so that a statement's scientific or non-scientific status does not change over time. This has been summarized as a statement being falsifiable "if and only if it logically contradicts some (empirical) sentence that describes a logically possible event that it would be logically possible to observe." --Wikipedia on demarcation. So, seeing as one can logically think of a scenario where one can measure the running time of two sorting algorithms and discover whether one is slower than the other, the statement, A takes a shorter time to sort this data than B, is falsifiable, and thus, by Popper, scientific. Now I'm not saying that all of computer science consists of such statements, much as all of physics does not consists of such statements (though they are more in physics than in CS). I'm just saying that CS produces some statements that can be regarded as scientific by poppers definition, and thus makes it viable to be called science. Now please, stop with the ad hominem crap, and show me an error in my proof, or just accept that computer science is somewhat scientific. Here is an article in which this very problem is discussed, and as I've said, artificial intelligence is more like science than most other fields in CS (though you dismissed the power of AI when I mentioned it being used like in Netflix). http://www.eden-study.org/articles/2007/three_paradigms_of_computer_science.pdf Now, I hope that we can just accept that there are many positions that can be taken on how CS should be viewed, but science is certainly one of them. Now please. If that published article does not settle it (and please read it all, especially the end/conclusion), you might have to check your own literacy. Please stop calling people illiterate/idiots, it really just makes you seem like a pompous ass, and really drains your credibility. N.B.: I never said programmers were scientist. They are software engineers, and are indeed practicing engineering, but they're engineering based on computer scientific results most of the time. 
I use Digital Ocean as well. Had no idea about dokku though. I'll definitely have to check that out!
Not the perfect place to put this plea, but I would like to make a suggestion: Sticky this post. The videos are going to be coming out over the next little while, and it would be great to have a single thread to contain some of the interesting discussion these videos produce. Also, the stand out videos can be made visible due to the discussion they generate. My understanding is that there are not as many videos from GopherCon as there are for some other (larger) conference, so it's not quite as big of a deal, but it would still be useful. Edit: To add something slightly more substantial, who thought having an animated Gopher run across the bottom of the presentation every so often would be a good idea? It's distracting, for no good reason.
There is always the go playground ( http://play.golang.org ) to get up and running quickly as well. 
I'm a professor in theoretical physics. I do (real) science for life. What do *you* do? And I amazed at how you wrongly inferred that I "disagree with Popper that falsifiable statements are scientific". Your skills of deduction and understanding what is written continue to amaze me. That quote is, if you read all the way through, taken out of context. It is the criterion for a *statement* to be scientific or non-scientific. For example, "I am not wearing green trousers at the moment" is a scientific statement in the sense that it is falsifiable. Doesn't mean you'll be doing science by answering this question. On the other hand, the question "how many ghosts are there in this room" is a not a scientific question. But of course, given that you probably didn't even heard of Karl Popper before this thread, the misconception and confusion shouldn't surprise me. And hence, are you being thick on purpose, or or are you just another idiot? As I mentioned, the whole thing is based axioms. Rest is applied mathematics. You disagree? Check a popular science book on quantum computers, it should be accessible for the layman or computer "scientists". Then come tell me the running time of computer-"scientific" algorithms is not based on some mathematical *axioms*. I wonder when people will coin the term quantum computer scientist. Probably after charlatans take over after physicists lays out the foundations. &gt; ad hominem Grow up. And hangout at hacker news less. Using Latin phrases randomly doesn't make you sound intellectual. Quite the opposite, in fact. In particular, when there is an English word for it. If you're being called "idiot" by an expert, it might mean more than an insult. Think about it. &gt; show me an error in my proof Proof? Do you even know what a proof is? I see why this whole science business is confusing you. Here's more *ad hominem* stuff for you. You idiot. &gt; it really just makes you seem like a pompous ass, and really drains your credibility. Lucky for me, I have a real life, and my "credibility" doesn't depend on what I say to some idiots on some random web-site or how many coins/trinkets/karma I gained. &gt; Here is an article in which this very problem is discussed, and as I've said, artificial intelligence is more like science than most other fields in CS &gt; Now please. If that published article does not settle it (and please read it all, especially the end/conclusion), you might have to check your own literacy. Right, so I should call a dog cat and abandon reason just because some random computer "scientist" from Essex wrote an article in a no-name journal with impact factor joke of a 0.458! Now you are right, this is not kind of the stuff I'm literate in. Any peer-review request from a journal with IF less that 2 goes right through my trash can. And, no thanks, I won't waste my time reading it either. But no, that article you probably didn't even read all the way through must settle it, right? After all, that's how things work in your world. Just stay there. I've wasted enough time here. I won't be replying to you anymore. Just go read a book. You'd fail with an F without any second word on it if you were in my class. Nothing worse than a righteous ignorant who wrongly thinks he's right and continues to dispute. Luckily, we don't see much people like you in physics department. You know, where people who do actual, real science.
I don't think the lightning talks were recorded. 
If you have a small app and want something cheap, than DigitalOcean. If you want PaaS, maybe Google Cloud (App engine has Go runtime, tho its incomplete).
http://confreaks.com/events/gophercon2014
http://confreaks.com/events/gophercon2014
http://confreaks.com/events/gophercon2014
I think it is to draw your attention to the sponsor banner. 
&gt;A gopher appeared from Nantucket, &gt; &gt;With types so shaped he could duck it. This rhyme and the java poem were my favorite. Thanks for sharing.
I'm teaching my daughter Go as her first language, as I think it's simplicity makes it very suitable as a teaching medium and yet it will be useful to her long-term, even if she writes the most complex of software. As for materials, https://gobyexample.com/ is a good resource I'd add to the others in this thread. 
If you are a beginner its best to do ProjectEuler problems. You will need to learn enough of the language to implement the problems. You don't have to work out all 470 problems. Target 100. By that time you will be sufficiently comfortable using the new language. Then you can try to implement some real world tool or app that already exists. It will teach you to use the language in real scenario. May be you can try to implement a simple command line based bittorrent client. That would be a good challenge.
Actually this is what I am doing. If you are interested take a look at my github: https://github.com/zhaphod/ProjectEuler 
Rob Pike's [remarks about the select statement](https://www.youtube.com/watch?v=ZtoZeVadnYA#t=2327) [~38:49] made me wonder who else has tried/succeeded implementing select and channels in another language.? Due to boredom last weekend, I created a specification compliant implementation of golang [channels and select in Objective-C](https://github.com/mathewreny/MRChan). My code obviously doesn't beat golang at speed (or style) but it only took 350 lines of code and was fun to program. When put in a loop my select statement has run over 100,000 times per second which is plenty fast for my needs.
:) Glad to be of help
Are they only three videos? The UI is awkward and I couldn't find any next button or something similar. I think more videos will be added with time ?
All the talks were recorded. They're being posted as they become available after the post-production.
Right. I believe ad hominem is the best way to refer to that logical fallacy, but sure, I must be using that instead of "to the man" just to sound smarter. I think you misunderstand what I'm talking about on running times. CS does say that the time complexity grows, not that the running time grows. Time complexity is indeed proveable, and not scientific, but the fact that higher time complexity means that the algorithm will be slower in reality was determined by experimentation (or more in the reverse, people noticed that some algorithms run slower than others, and came up with time complexity to explain the phenomena, just as a physicists noticed that things fall down, and came up with the theory of gravitation). That's what makes it science.
I'm not aware of anyone having that very unique talk recorded. I'd be interested in seeing even the last few minutes you have recorded.
These instructions are wrong. Do not follow them. echo export \$GOPATH=\$HOME &gt;&gt; .bashrc Done. that is all you need to do. If you need to reach for sudo, you've made a wrong turn.
True, but never underestimate the power of a true REPL interactive terminal. The flexibility gained from instaneous execution and viewing the results as there being manipulated is something can't be understated. Go does compile quick enough for it to be of use for this purpose, but I found iPython is simply the best way to teach people
&gt; I don't think the lightning talks were recorded. &gt; All the talks were recorded. I guess you mean all regular talks?
What? Have you never heard of items in an array referred to as data? Data is just collection of information, I'm not trying to use it to refer it to experiments in any way. The experiment data in this case would be the measurements of the running time, not what data the algorithm is operating on.
&gt; maps don't need a global GC. Maybe "need" is too strong a word, but I can see code like this: var x map[string]Foo x["foo"] = &amp;Foo{} x["foo"] = &amp;Foo{} // replace the first value ... relying on a GC to function correctly. It's possible to do this without a GC, but you'd have to micro-manage the keys and values both to prevent leaks.
I don't speak Objective-C.... am I reading your docs correctly that your select busy-waits? That's not a criticism, just a question. One of the problems with implementing a Go-like select in many high-level languages is that the high-level language has very deliberately sealed you away from the very low-level functionality you need to implement it efficiently. The previous question isn't criticism because it may indeed be the only way to do it. If you wanted something CSP-y and was less worried about being Go-y (Gooey? Go-ic? What's the right word here?), you might be better off with Erlang's model. Each "mailbox" has its own queue, and you can "receive" from a mailbox, which will either examine the mailbox for a matching message, wait until it gets one, or timeout at some point. It's easier to get much closer to this in standard languages, because a standard "condition" variable (as seen in Go's `sync` package) can do most of the work. It's also designed with the idea that one "thread" (for whatever that may be in your local language) can listen to just one Erlang mailbox, and receive all the messages on it, whatever they may be.
Yes, but not with the official documentation. 
I'm very grateful for the sponsored the videos, since I wasn't able to go. The production level I would say is VERY good compared to some of the previous go talks that are online
Content is CC share-alike... only available on Youtube.
ヽ༼ຈل͜ຈ༽ﾉ
Super cool.
It's written for programmers. It necessitates a certain amount of prior knowledge and also employs a lexicon that might be unfamiliar even to newcomers with a programming background. Same as any language specification, really, but the big languages have entry level guides available. Go is slowly starting to get its own bulk of beginner-friendly content. Also while programming in general is largely self-taught I'd recommend a newcomer to spend time with an instructor until the basics have been properly assimilated. It's not hard to start off with bad habits.
That talk was incredible.
Both Confreaks and [PyVideo](http://pyvideo.org/) only host videos on Youtube these days. You can't blame them, really. It's free hosting for videos that are going to take a lot of bandwidth. If Youtube's HTML5 player were better, I wouldn't even mind. I watch most of these videos at at least 1.5 times, and if the video is available through HTML I can do `$('video').playbackRate = 1.5`, but the rewind-the-last-10-seconds experience is a lot worse than with e.g. VLC. Note: this selector only works directly on youtube. It won't work with the video embedded in the Confreaks page. [youtube-dl](https://github.com/rg3/youtube-dl) is awesome. You can also plug the youtube address into VLC's network tab when opening media. A shortcut for this: hit CTRL+N. That works too, but grabbing the entire file first works a lot better.
For the curious: https://github.com/axw/llgo
Question: would this be a good place to start for exploring possible language extensions? The reason why I ask: I've been working with the go/ast and go/token packages for over a week now. They do the heavy lifting of parsing just fine, but are useless for semantic analysis on their own. Since llgo is a complete frontend, it would appear to be a logical step towards writing a preprocessor, or even language improvement prototypes.
I just use file2hd. Either way both break YouTube's TOS. These could still be hosted on a Google Drive and have sharing yo enable direct linking for a free hosting solution.
I think Go is a great language to use to learn programming because the language itself is so small. There's very little to learn, and yet you can make any program you want using it. Any other mainstream language is going to have a bigger learning curve because there's just more to the language. Also, Go was designed to be easy to read. This means that any particular line of the code should be very obvious what it does. There's very little magic in the language, which makes it a lot easier for newbies. Yes, there are a LOT of features that other languages have that Go lacks. This is a GOOD thing for newbies. Run through the go tour (tour.golang.org) to get a handle on how the language works, then write a small command line application that does something useful/fun for you. Maybe rename a large number of files in a specific way, or make a simple text-based game. Whatever it is, make it something that is interesting for you.
Gopher is going away - videos are being re-rendered now without the distracting little bugger.
You are correct. Busy waiting seems to be an anti-pattern which is a good excuse to continue refining my code. Condition variables are definitely the way to go. Fortunately I don't think it will be too difficult to make that change. One of the reasons why I wanted channels to be a standard Obj-C object was so I could pass channels over channels. I will probably try to implement Erlang mailboxes for fun next because I need the practice. Thanks for the constructive feedback!
This will be a fun series...
also [sqlite3](https://github.com/mattn/go-sqlite3)
I don't want to *say* "I called it", but I at least [*mentioned it*](http://www.reddit.com/r/golang/comments/24pcu7/disgo_comment_hosting_with_go/ch9mil3) (giving myself a pat on the back). Good to see they're tackling this problem with the language I would argue to be the best for it.
what can i ask it? I tried a few things, 'show me a map of los angeles, ca' yielded nothing 'what is 2 + 2' was correct, but the fact that it said 'did you mean 4' was kind of odd. I'm not sure what I'm supposed to use this as beyond a calculator? EDIT: Also, 'what is my ip' said I was in the UK, when I am in Southern California, USA. It's using the server's IP to get that answer.
Python and Go are 2 different animals. That said, what optimizations did they use in python? That is the real question. It will be a long time until you will have the support in go that you have in python for libraries. And, you will never be able to do super crazy things, like I can in python/numpy(MKL).
I've debated about doing that but I prefer transactions where everyone benefits, and tbh, I pick my friends based on criteria other than programming talent. 
That would be neat. Is a g4 Mac ppc64 or ppc32?
&gt; I'm actually teaching a newcomer Go right now. teach them haskell,, God haskell is hard :c 
What's a "gc compiler"?
Demo http://podcasti.radioterminal.si/#!/
Slovenian Gopher. Cool. xD
&gt;And, you will never be able to do super crazy things, like I can in python/numpy(MKL). Why not? MKL [product page](https://software.intel.com/en-us/intel-mkl/) states that it's "Compatible with all C, C++ and Fortran compilers", so cgo bindings are theoretically possible.
The new repo is https://github.com/go-llvm/llgo (libgo branch)
Sorry, I was thinking "garbage collection" for some reason.
Looks like he used martini. Http://www.github.com/go-martini/martini 
Mac G4 is ppc32
Based on the languages that you have been exposed to I think Go would help you understand some additional concepts that you may not have explored before such concurrency, interfaces, and some of the benefits of a statically typed language -- mainly speed and type safety. Your minimal coding background maybe to your advantage when learning Go. Many people stubble while learning Go due to strong comparisons to other languages or getting stuck worrying about Go's "missing" features. You'll have the advantage of learning Go without all the "baggage". Finally, it's a very exciting time for Go right now. Call it hype, but the energy surrounding the language is very high. That means you'll find many people excited about sharing their knowledge and discoveries. This includes the core maintainers, just checkout the go-nuts mailing list. I consider this the perfect climate for those with a minimal coding background like yourself. 
Creator here. The IP address is a bug. Sometimes it works and when it doesn't it just gives the server's IP address. Well I'm not sure what to call it but on the [about page](http://www.gingerbill.org/about.html), there are some examples. When I started making this, all I wanted was to get quick information on a subject/topic. `what is 2 + 2` is correct but assumes that you really wanted 4 not the answer to 2 + 2, if you understand me. Asking `cube root of 12` will give you `3 √12 = 2.28942848510666`. `show me a map of los angeles, ca` I'm been wanting to add map functionality for a while but adding it is quite difficult. It's a project in itself. OpenStreetMaps seems the best option if I'm ever going to do it. Searching for `xkcd` will result in the latest xkcd comic, a quick summary of it, a like to the site, and meanings of it. Searching for `lonely avenue album by ben folds` will show the basic information about that album (artist, release data, tracks, cover, etc.) If a "card" has more information, is will have a link at the bottom saying More at... The service is still technically in beta but it will always be as I can always add more to it. It's useful for me so it could be useful to someone else. 
However, a G5 mac is something derived from POWER4 ISA, which is 64-bit. 
Will your port work on a G4 Mac or only ppc64?
I'm going to open source some parts but not all of it. The API is open at the moment but documentation is not finished yet.
It is just an SQL database. The way I've got it to be fast is to understand the query quickly. The bottleneck is the plugin system at the moment (word search or regex only). Apart from HTML, CSS, and JS, everything is written in Go.
To be a little less obtuse.... golang in general should not be used as a proper noun in casual conversation. It's used in tags and occasionally URLs to make the pages more searchable, but if you're talking to an audience of Go developers, just call it Go. Calling it golang makes you sound like a newbie at best, and at worst, someone who totally doesn't know what Go is. This is not intended to be harsh criticism, lots of people make the same mistake.
What happened to the Heka video? It was there a few days ago and now it's gone.
My dream would be to see how you implement the OWASP top 10 security methods in GoLang.
Yes, importing the package (the import string is the same as the path on disk, minus "$GOPATH/src") imports all exported values in that package into the file where the import statement is, namespaced by the name of the package (so import "github.com/natefinch/foo" will have types like foo.MyType). You can have multiple types/functions etc per file and multiple files per package. How you organize files and types etc in a package is totally up to you, there's no right or wrong way to do it.
cool! Didn't mean to be so negative, it's always nice to have an alternative out there and very cool to see it was written in go!
I appreciate feedback, thank you. It's hard to test it on my own. Go made life so much easier and quicker! Go is now my favourite language.
My dream course will show a web project like http://golang.org/doc/articles/wiki/ a practicable solution with some go basics
Yes, but I only use a framework if it really helps. In Go, I tend to stay away from the big, lumbering libraries that do lots of black magic. Typically I choose a smaller framework like Martini because most of the time all I need is better routing, convenient middleware (like request data binding), or quick &amp; easy error handling. Most of the time, though, `net/http` does the job for simple projects or when I'm chasing after high performance.
beego: http://beego.me
I'd like to see a tutorial that uses play.golang.org and teaches the absolute basics (fmt.Println, if/else, for loops, functions) without asking the reader to install anything or invest time in learning to use the command line. I have a friend who's interested in learning the basics but I doubt they're going to go beyond the basics, and I think asking them to learn to use cd, ls, go run, etc is just going to be time wasted when they could be learning programming instead.
yii for web，martini for api
I haven't tested net/http yet but am going to. As i am from the Python world, i'm searching for something more like Flask (or Sinatra for Rubyists). I've never liked big frameworks like Django or Rails. If you had to choose equivalent to Beego, Revel &amp; net/http in other languages, what would you choose (in terms of "size") ?
For advanced: * Writing libraries * cgo/gcc * panic/recover * How common concurrency patterns map out to Go concurrency or their alternatives. * Performance tuning runtime (i.e. MAXPROCS best practices) 
Web API = go-tigertonic https://github.com/rcrowley/go-tigertonic Great library (not framework). It makes the work of writing a production ready web API (JSON especially), a breez. The other beauty about it is that it uses the Handler interface for everything. That means the lib works with other Golang libs very well. 
I don't have any hard data at the moment but as long as you don't call from Go to C(++) inside a tight loop, the performance hit shouldn't be *that* bad although it exists. Trying it out and profiling is the best method to get precise answer.
See also https://groups.google.com/forum/m/#!topic/golang-nuts/RTtMsgZi88Q 
Gorilla for secure sessions and routing. The rest is all Go.
Martini.
The slides were not synced with the video.
i use the gorilla packages mostly for sessions and routing http://www.gorillatoolkit.org/
Ah ok
Gorilla for sessions and routing here. 
&gt; Is goroutine scheduling and switching designed with multiple cores in mind? Yes. This is the main thing.
llgo uses go/{ast,token}, and go.tools/go/{ssa,types}. You could investigate language extensions with llgo, but it would mean modifying those core packages.
I don't know much about GPU programming, but I think the only real difficulty would be with runtime support. Just as the article says "an extremely limited subset" of Rust is supported, so it would be for Go.
So channels are implemented with atomic operations? 
Sure. But that's not something you should need to worry about as a user. They "just work".
Yes. No frameworks, but I use parts of the gorilla toolkit. Bias: I'm one of the maintainers of gorilla :)
Martini :) 
You might want to have a look at this article http://www.goinggo.net/2014/01/concurrency-goroutines-and-gomaxprocs.html Be sure to check out the comments. 
Yeah, that's what I've heard as well. Why? Why is that not the default? I'm not trying to be whiny, I'm just honestly curious as I suspect there is an architectural reason behind it that's relevant to OP's question.
You're setting the number of threads to distribute the go routines across. 
What kind of threads? The documentation says OS threads, and OS threads can only run on one processor at a time. If GOMAXPROCS is not set above 1, does Go run on multiple cores? If not, why is GOMAXPROCS not set to default to the number of cores?
For the majority of programs, things will often run faster with GOMAXPROCS is set to 1. This seems counterintuitive, but if you know about cache misses, think about what happens when core 1 causes a cache miss in core 2, then core 2 causes a cache miss in core 1, and this goes back and forth. That would slow things up a lot, and it's easy to accidentally make it happen. 
Because for most programs, things will actually run faster with GOMAXPROCS set to 1. If you know about cache misses, think about what happens when core 1 causes a cache miss in core 2, then core 2 causes a cache miss in core 1, and this goes back and forth. That would slow things up a lot, like 2 orders of magnitude, and it's easy to accidentally make it happen. If you know how GC works, think to yourself: How might GC encourage such ping-ponging cache misses with multiple threads? tl;dr: It's still not always trivially easy to write efficient parallel programs. 
I’m relatively new to Go but Martini is really nice. It seems to be similar to Sinatra and Express (it even say it in the readme) and I have a Ruby background, so I was looking for something like that. From what I understand so far it’s a really lightweight wrapper around the built in `net/http` package and it also passes the actual `http.ResponseWriter` and `*http.Request` to the route so you can manipulate everything directly.
beego is awesome with high performance
Thanks. The architectural concern is familiar to me but I can't help but feel disappointed by the design conclusion. To me, it seems like the 'answer' to this problem is that the problem of cache-thrashing between processors should be *impossible*. That is to say, two coroutines should be never be able to access eachother's address space, and instead should only be able to share stare by channels. That seems to be the idiom, but it's not *enforced* because coroutines in Go can be closures from another coroutine's address space. This requires memory sharing. I feel like this is a wart on the language, although at the same time I feel like 'fixing' it would involve creating a fundamentally different language. My understanding - which is limited at best, I admit - is that Go's coroutine model is based on a fundamentally more complete concurrency/parallelism model inherited from Erlang, which does indeed include the memory segregation properties that allow 'true' isolated parallelism, where state is only shared via messaging.
No, that's not true. Switching from one process or thread to another on the same core requires a context switch. In a symmetric multicore processor, all CPU cores can run simultaneously. Processes on different cores can run at the same time.
Can one OS thread run on two processors at the same time? If GOMAXPROCS is set to 1 (the default), can two threads ever be running (not blocked on a system call or otherwise idle/waiting) at the same time in the Go runtime? Can more than one co-routine be actively executing on any one thread? My understanding is the answer to all of these is 'no'. I would argue then that there is no way for Go to be multi-processor unless GOMAXPROCS is changed from its default of 1. That's my point, sorry if I was confusing. Edit: Also, and this is entirely parenthetical to the above: If a thread is scheduled to run on processor A but then gets rescheduled to run on processor B, does that not imply a context switch? My understanding is that it does cause a context switch. "Context Switch", to my limited undergraduate education (heh), refers to (at minimum) saving the register values and PC of the active 'program' to the stack and then loading a new values and continuing. Switching cores must certainly involve a context switch (and a whole lot more!), no? PS: Re-reading this, it sounded a bit hostile. I want to be sure that my tone is accurately conveyed as being thoughtful. Thanks for your help in my understanding of this concept, as it's been troubling me about Go for some time now. :)
Yes, also detailed information about best practice deployments would be awesome, how to connect different parts of a web service infrastructure, how to communicate between these parts efficiently, things like that.
&gt; Can one OS thread run on two processors at the same time? Yes. On Linux, at least, there is no distinction between a process and a thread. Two different processes can run on two different cores simultaneously as can two OS threads. There is a thing called CPU affinity, which means that processes or threads which share a lot of memory are less likely to be scheduled on different cores, but it is still possible for two different threads to run simultaneously. &gt; If GOMAXPROCS is set to 1 (the default), can two threads ever be running at the same time? No, for obvious reasons. Two goroutines cannot run simultaneously if GOMAXPROCS is set to 1, as there is only one OS-level thread running, and hence only one physical core can be utilized. &gt; Can more than one co-routine be actively executing on any one thread? I'm not as familiar with the Go runtime as I am with the Linux kernel, but I would expect the answer is yes, as long as GOMAXPROCS is greater than 1. &gt; Also, and this is entirely parenthetical to the above: If a thread is scheduled to run on processor A but then gets rescheduled to run on processor B, does that not imply a context switch? Yes, it does, but the context switch is not between two different processors, it is between threads. There is one context switch to replace the current thread with a new one on processor A, followed by another context switch to replace the thread previously running on processor B with the new thread. But once the context switch is complete, two threads are running simultaneously on both processor A and processor B. &gt; PS: Re-reading this, it sounded a bit hostile. I want to be sure that my tone is accurately conveyed as being thoughtful. Thanks for your help in my understanding of this concept, as it's been troubling me about Go for some time now. :) No problem. Asking questions to clear up understanding is good. I apologize as well if my answers ever sounded hostile or condescending. I just want to make sure you are better informed about the nature of multiprocessors and OS-level parallelism.