Could you recommend some resources to better "get" interfaces in go?
delve and Visual Code are my regular basis tool to debug go, and also fmt.Printf.
I agree, I would make it a struct channel with sender or worker ID embedded in.
Disclaimer: I don't know go. Never tried it or learnt it. This is a serious question. So let's say I make a custom container that implements some particular algorithm or constraint or whatever. Let's suppose I need two instances of that, one that contains strings and another one that contains integers. Do I have to write two identical implementations of the same structure replacing the type, or is there a better alternative?
you already know the answer because of `lol no generics`
Having to configure in vscode for each target is a hassle. Wish there is some sort of dynamic template with variables to make it more generic. 
Nice, jus tested it on Mac and notification is working fine. How about assigning a logo in the notification message?
Ok but seriously, is this really the correct way to do it in go? The official, sanctioned, idiomatic way?
Perhaps next year but not sure if there is interest. Could be great if Google put Golang on cloud functions too.
What are the advantages over NSQ?
TextMate with its Go extension
I can recommend gopy, I've used it to expose gosnmp for Python use- it's got some support for CFFI too so you can build bindings that'll work with PyPy though personally I've found it to a be a little flaky (CFFI side only, Python side is rock solid, using it in a production system).
Do you know any projects not using version control systems? Every software I know uses some kind of vcs, but sometimes not exposed to public.
I suspect that OP may have meant "package versioning" instead of "version control".
Because cool kids use github 
Yeah, I meant tagging releases. Sorry for the confusion.
It does, and so does Scala, however you also lose interoperability with pretty much all libraries you're used to using. These native variants of JVM languages are awesome to see, but they're also a completely separate ecosystem that has a _long_ way to mature.
On macOS osascript is used to execute AppleScript for showing notifications. I didn't found option for icon, it seems it will use app icon from resources in .app bundle. Linux and Web do have option for icon, but then, it can be used as url, or just name for predefined system icon etc. It will probably complicate things so I leave that out for now. Bigger issue is that i am not sure what to use on Windows for notifications. For now that is just a MessageBox that will block and wait for user action. Maybe to open a real window and then close it after some time, will need to check that.
hi-res on github - [eu](https://github.com/jstpcs/lnxpcs/blob/50faca595270f3b73332b0066a6122728d223669/calendars/2018/eu/hexadecimal-go-eu-dark.png)(week starts on monday) and [us](https://github.com/jstpcs/lnxpcs/blob/50faca595270f3b73332b0066a6122728d223669/calendars/2018/us/hexadecimal-go-us-dark.png)(week starts on sunday). preview on [linux.pictures](https://linux.pictures/projects/dark-go-programming-hex-calendar-2018).
The real answer is that you basically never need the same container to hold two different, completely incompatible types (like strings and ints). It just doesn't happen in real code. Either you have related types that can be represented by a common interface, or you really only have one type and you just feel like the container *should* be generic for... reasons. Maybe if you *really* need a well-known algorithmic container, like a red/black tree (which in my 18 years of development experience has been.. uh, never) then you could use one of the various code generators out there to ensure your two (it's almost never more than 2) implementations are the same. No, it's not ideal... but again, this is really *not* a common case. Anything that is not a very well-known generic algorithm is going to get specialized to its usage anyway, and likely won't be able to be shared regardless. When coming from languages that have class inheritance and generics, it's often hard to see how to reuse logic without those features. But once you've developed for a while in a language without them, you start seeing how to better use interfaces, standalone functions, and composition to replace them. I remember in my job before last, writing Java and C#, I had a type that seemed like it should be generic to be reusable, but when I started to go down that path, the code got so much more complex that I (luckily) just stopped and went back to hard coded types....and you know what? we never needed the generic version. I think this is far more common than most people realize.
I agree with the other answers that you should simply make all workers send to a single channel. But if for some reason you still want an array of channels you could do something like this. https://play.golang.org/p/Ev-kY0ve1G It's a fun exercise but not that useful :P
I didn't mean to come off that way.
That's the benefit of a package though. The code wouldn't have to be written over and over again.
Should we use sandglass as an alternative to kafka?
Thanks for posting this. I have the book by Terence Parr and was going to go through it again for a new project that I wanted to do with Go. He obviously uses ANTLR, so this post will be a great to help bridge what's done in the book with actual Go code.
You might find the comments on HN informative: https://news.ycombinator.com/item?id=15895863
I'd been using IntelliJ with the Go plugin for a while, switched to GoLand once it was released, it's looking excellent. I'm really looking forward to Go 1.10 so I can take advantage of having coverage for all packages super easily in the IDE.
 err := drinkCoffee(me) if err != nil { return fmt.Errorf("failed to drink coffee: %v", err) }
The `// +build` directives are unnecessary since you used OS suffixes in your file names. The Go compiler will automatically exclude `beep_windows.go` on non-Windows platforms, for example. Also, you wouldn't need to negate every other platform. `// +build windows` means "Windows and only Windows".
I'd go with a ```panic```
Please consider not doing this.
I also use IDEA with the Go plugin; what are the advantages of switchting to GoLand (other than possibly reducing some “clutter” in terms of features unrelated to Go that take up screen space)?
That's one perk I have definitely noticed, another is that you seem to get updates faster when using the individual IDEs. Even the EAP for GogLand got updates before the IntelliJ plugin. Aside from that, there are a few things that are put in different places (e.g. the Go part of the settings is in a different place in GoLand compared to IntelliJ).
This seems like a (less mature) alternative to Kafka, kind of reminds me of NATS Streaming. Pretty interesting, will keep an eye on it.
I used to be a fan, now I'm not. The Go plugin stopped working and I had to crack it in order to be able to continue using it in Webstorm 2017.3. This is NOT what I call a good product. They added this artificial roadblock because they want to cash in. I'm not pay 400€/year for the full blown IntelliJ package just to have both ECMAscript and Go editing. They have got to be kidding me.
I've been using GoLand since it was first released as GogLand EAP. It's come a long way and they actually respond to feature requests quickly. I was using LiteIDE, which is the second best Go IDE IMO, until JetBrains added a couple of the features I requested. One that I thought was surprising they didn't have to begin with was a simple 'build' option when right clicking on a package.
"controllers" skip 1. get your OO and DDD out of your head and learn to Go. 5. profit
How does this differ from InfluxDB?
kubernetes is a piece of work. incomplete docs that make you so frustrated when you want to run your own multi-master cluster that you're driven into the hyper-expensive offerings of GCE and AWS. Normal humans will have a big headache with kubernetes.
maybe check how chrome implements desktop notifications seen as webapps like slack can do desktop notifications when using chrome.
You probably should read this: https://blog.jetbrains.com/blog/2017/12/01/clarification-on-go-support-plugin-availability-in-intellij-based-ides/ The communication could have been better, but GoLand IS WebStorm + Go. So from paying 5.9€ / month now you have to pay 8.9€ / month, which means the Go support is 3€ / month. And you get 2 months free if you pay the 12 months license. As for paying 400€ / year, that's a gross exaggeration. The IDE is 89€ / year and drops to 53€ / year after 3 years of usage. All the IDEs from JetBrains, 15 of them, cost €250 / year and drops to €150 / year after 3 years of usage. GoLand was added to the Toolbox without increasing the price. And I'm sure you can write to support and explain your problem, since you are a paying customer and that's exactly the support they should help you with.
``` for _, sip := range mugOfCoffee { drink(sip) } panic("NO MORE COFFEE!!!!!!!!!!!!!!!!") ```
The plugin for IDEA Ultimate and GoLand are the same and they are released at the same time (within a few minutes / hours of each-other). The location in the settings is indeed different since the IDEA plugin need to respect the IDEA options whereas in the IDE the settings are tailored towards Go development.
When tested with GopherJS in Chrome in LInux it looked like it is a custom solution, doesn't seem to use any of the notifications daemons and D-Bus protocol. Chrome also has some restrictions, it must be called after "user gesture", like onclick event, and site must use TLS cert. So far everything is in native Go so I would not like to add something that adds cgo dep.
I think `drinkCoffee()` should be exported, as drinking coffee outside of the house is a common use age.
&gt; One of my favorite features is just the simple auto package importer. It's just so convenient if you use a new package it knows about it will add the import automatically. That sounds like plain ol' [`goimports`](https://godoc.org/golang.org/x/tools/cmd/goimports), I think? I think practically any editor/IDE has integrated support for that.
&gt; I'm not pay 400€/year for the full blown IntelliJ package just to have both ECMAscript and Go editing. I know very little about GoLand, but [their website](https://www.jetbrains.com/go/features/#front-end-and-back-end-development) says it supports JavaScript: &gt; The IDE inherits from WebStorm its first-class support for front-end languages and frameworks. The IDE offers top-notch coding assistance for JavaScript, TypeScript, Dart, React and many others. The support for Angular and Node.js is available via plugins.
I've never tried to run my own multi-master cluster, nor do I ever think I will even try to. :-) Especially with the new AWS Fargate https://aws.amazon.com/fargate/ and EKS (Managed kubernetes on AWS). Fargate looks simply incredible for keeping the cost low on a small cluster. :)
Do you mean like `StripPrefix`?
No, I'm explained the meaning of this lib in article - “How to chain HTTP Handlers in Go” https://medium.com/@cashalot/how-to-chain-http-handlers-in-go-33c96396b397 
Sounds like you're both reimplementing stdlib and using a *lot* of code and words to do that. ¯\\\_(ツ)_/¯ 
ye it's definitely a custom solution because it definitely doesn't use my libnotify setup. But thought it might be good resource example seen as chrome is completely cross platform, especially seen as you haven't got the windows platform completely figured out (linux is pretty straightforward with libnotify and D-BUS).
&gt; There are two valid use cases for panic. &gt; One example would be a web server which fails to bind to the required port. No.
Give me an example of how to do the thing I explained in article in go standard library
Sure, I will check, but considering how every browser usually comes with it's own UI toolkit, and amount of C++ code there, I am not very optimistic about that :) Perhaps something with https://github.com/JamesHovious/w32 or https://github.com/lxn/walk can be done. I never really programmed with win32 API so everything is new for me.
I do like GoLand, but not sure it's practically worth money if you've already got IntelliJ IDEA. The Go plugin is for all intents and purposes exactly the same.
Yeah, I'm not exactly sure there are any advantages. I think the main advantage would be a cheaper product if all you wanted was to work with Go.
Correct me if I'm wrong, but with goimports there is no autocomplete for an unimported package, right? With Goland, you get autocomplete suggestions even if that package is not referenced in your code.
`goimports` and autocomplete are pretty unrelated, but [`gocode`](https://github.com/nsf/gocode) can do autocompletion for packages that aren't imported.
Sigh. Costs money, of course. Ah well.
Just buy it and submit an expense report to your company. There is nothing wrong with professional development tools costing money.
Sorry for taking the `beep` (two e's) package name :D
Nah, programming is just my hobby. I'm fine with good old vi anyway.
No problem, I also checked your library when I was browsing through github :) I actually referenced a lot the other `beep` https://github.com/johnath/beep/ , that is in every distro. And yes, I suck at naming packages :) I didn't mention, beeep can also be used to play beep tunes like from this collection here https://github.com/ShaneMcC/beeps , just Beep them in loop, but only in Linux.
I work on a very large JS project. It has not "descending into chaos" in the slightest. We've been working on it for years. 
I switched to VS Code a while back, installed the IntelliJ key map and theme plugins to ease the transition. Within days I cancelled my IntelliJ subscription. Haven’t looked back since!
Does it have high unit test coverage?
What you're looking for, particularly with the demands for flawlessness and video file support, doesn't exist in Go right now. You might want to look into Electron.
thank you! I think you're right. It's sort of a mess trying to do a desktop thing with go right now, there seems to be no clear winner or even a well adopted desktop library. I'd love to even understand which are the front runners but thus far I can't tell which ones are the best choices. https://github.com/asticode/go-astilectron-demo seems to be the choice for me. 
Well, for starters NSQ doesn't guarantee in-order event delivery when they spill out of the memory channel and onto disk.
No. It has high e2e/integration test coverage though.
Whenever you use a compiled language you are "depending upon generated code"
Favourite feature, select code, refactor menu, extract function. And the code is bite extracted to a function. Doesn't always work perfectly, but very unique.
Did you take a look at https://github.com/zserge/webview ? Basically you create a local server and access it through the application (webview).
Ah, so no actual tests to ensure code quality remains high, and instead tests ensuring superficial functional requirements are met.
I have been using VSCode, and started playing with GoLand, after I was able to fix the debugger, using JetBrains support, I am sold, I will be purchasing it, because $89 is very reasonable for such a great IDE. I do highly recommend VSCode to anyone starting GO, but if you would like a very slick and professional IDE, I really don't think you can go past GoLand.
Speaking of the plugin - What is the difference between Run kind: [File, Directory, Package]? How do those options map to the CLI go build and go run commands?
I really don't understand the purpose. ServeMux can be served by any path and you can easily chain handlers and muxes together.
You can convert the type in a range to a map of interfaces: https://play.golang.org/p/WFlFyydp-3
You can easily wrap your `map[int]user` to `map[int]interface{}` : https://play.golang.org/p/jG4nkGTU9H But if all your map types have a common behavior why not use methods and define an interface?
You may also find https://github.com/variadico/noti interesting - it does Windows too) 
&gt; Remember the empty interface says nothing. That's why Java abandoned the equivalent of `interface {}` 15 years ago.
This doesn't really work with VSCode, that's the only reason I switched back to GoLand.
I'm not trying to troll but I hope it's acceptable to share an outsider's perspective here. I've used 20+ programming languages, I've seen good and bad aspects of each, and I've done a lot of C and assembly so please don't peg me as a theory-obsessed academic. Compared to Go, I've never encountered another language with such a prevalence of defensively smug, anti-intellectual attitudes. With most languages people can acknowledge that there are shortcomings and that ideas from the wider programming world might help to address those shortcomings. The closest I've seen in another language is the attitude of some old-school C programmers... I suspect this is not a coincidence. I realize that not all Go programmers are like this, but it's hardly rare either. I find anti-intellectualism beyond distasteful, it's honestly one of the worst things about American society and I don't want it anywhere near my programming language, which is why I'll never willingly use Go.
File will call `go build` on a specific file, using it's absolute path. If you had two files in a main package, and the file with the `main` function in depended on something in the other file, then it would fail to compile here. Other packages will still be imported. So, if you had another package, or a third-party library imported, it would still work here when building a specific file... just not files right next to the file you build. Example of build command: $ go build /go/github.com/foo/bar/cmd/main.go Package uses the actual package name, like what you'd use in an import statement. When using the package run kind other files in the package you're building will be imported, along with other packages' files. In other words, if you're building a main package, it should build your whole app fine if your main package contains multiple files. Example of build command: $ go build github.com/foo/bar/cmd Directory is pretty much the same as package in it's behaviourl, instead of passing a package to `go build` though, it will pass the path to a directory (the path might show up as `.` in the build setup steps in the IDE). Example of build command: $ go build . # or $ go build /go/github.com/foo/bar/cmd
Nice to see, but how is this different than `bytes.Buffer`?
I feel exactly the same way.
It prevents its internal byte slice to escape.
InfluxDB is a time series database, Sandglass is a queue.
There was also a `ReadFrom(r io.Reader) (n int64, err error)` method but has been removed because there was a bug with it and Go 1.10 is around the corner. Maybe in the next release.
In your opinion, what advantages could this have over https://github.com/asticode/go-astilectron-demo?
&gt; Compared to Go, I've never encountered another language with such a prevalence of defensively smug, anti-intellectual attitudes. &gt; I find anti-intellectualism beyond distasteful, it's honestly one of the worst things about American society and I don't want it anywhere near my programming language, which is why I'll never willingly use Go. Anti-intellectualism... that's new. I've heard Go being accused for many things but never this. Care to elaborate?
I think it's more lightweight overall, but probably less features
I don't know when you switched, but I haven't had any issues with it in the past few months working with vsCode
It works completely fine, you just have to have the setting "go.autocompleteUnimportedPackages": true.
If you have IDEA Ultimate 2017.3+, then you get the same features, that's true. However if you don't need everything IntelliJ has to offer, or you want a streamlined (and faster) IDE for Go only, then GoLand's the way to do it.
Looks like a typical Y, X problem. Anyway. You need to manually convert map[int]user to map[int]interface{} with a for loop.
A lot of shilling here for a commercial product. 
Meanwhile our company is making millions of dollars selling great software we all love working on. Thanks for you opinion and erudite insights! (turnover is almost 0).
Unfortunately I can't think of anything off hand. I read a lot of tech blogs, probably like a lot of people here. For myself I find that building things, and continuously looking at how others are solving similar problems, is the way to go.
I have set the setting. Last time I tried was a couple of months ago.
Couple of months ago was the last time
Thanks, I will check, looks like I can find some pointers there.
I can recommend: https://dave.cheney.net/2016/08/20/solid-go-design especially the Interface Segregation Principle. Also: https://github.com/golang/go/wiki/CodeReviewComments#interfaces
The adodb and odbc drivers should work. https://github.com/golang/go/wiki/SQLDrivers
&gt; I'm trying to connect to a .accdb database and I can't get the connection right. A little more information about the problem would really help people help you. What have you tried? What errors do you get? Minimum example of code that isolates the problem?
Getting a stack trace costs too much to do on every error.
Sure, but it also makes it very difficult to debug certain bugs.
I haven't done a whole lot of looking around in the go std lib lately (or really any go code), but I know about the whole pass-error-as-last-return-value standard. All of the ```Write``` functions will either panic via ```copyCheck()``` or _always_ return a ```nil``` error. I expect this is fairly uncommon? The comments even mention the ```nil``` error specifically. Why have ```error``` in the function signatures at all? Future proofing? Sticking to a common user expectations api? ```Grow``` may also panic but doesn't pretend to have an ```error``` value. Just (pedantically) wondering about the design decision, even though I'm sure in-practice it will never really affect me.
Too bad the package won't work with your data structures though and you'll have to keep rewriting it. If only there were a way to create code that acts as a wrapper around a, lets call it 'universal', data type. Then your 'universal' containers and algorithms could be used for all sorts of different programs.
It's to implement the `io.Writer` and `io.ByteWriter` interfaces, making it pluggable with tons of already written code.
Having `Write()` return `(int, error)` allows `string.Builder` to be used as an [`io.Writer`](https://godoc.org/io#Writer). Explicitly documenting it to return `nil` allows callers that _know_ they're specifically using a `string.Builder` to elide error checks. This doesn't feel like an ideal solution, but at a minimum `bytes.Buffer` does the [same thing](https://golang.org/src/bytes/buffer.go#L156), so at least there's precedent.
Interfaces. - `.Write` returns an error because `io.Writer` says it must. - `.WriteByte` returns an error because `io.ByteWriter` says it must. - `.WriteRune` returns an error because `bytes.Buffer.WriteRune` and `bufio.Writer.WriteRune` return an error. - `.WriteString` returns an error because `io.stringWriter` says it must.
Yep.
Thanks! I forgot about how go goes about the implicit interface implementations.
Call me harsh as much as you want but I really dislike it when people overuse words. The top link in this "curated" feed was full of bugs: https://www.reddit.com/r/golang/comments/7itpex/http_file_upload_and_download_with_go/
I tried GoLand and love it, but sometimes when I update my project vendor folder(around 100MB), GoLand then keep high CPU(100% of one core) for very long time, actually I don't know if it can finish because I gave up when my laptop to hot then. 
[removed]
https://play.golang.org/p/hQ0-bjp-oW pot := make([][8]coffee, 12) for _, cup := range pot { me.Drink(cup) }
Realistic example of [drinking returning err](https://youtu.be/PAAkCSZUG1c?t=13m41s).
A more idiomatic way to do this in Go would be to create an interface that has a method that returns a []byte. You then have your user type, or whatever type you want marshaled to JSON, satisfy that interface. Finally, you use the interface name for the values in the map and change the argument of marshalDictValuesToJSON to handle the map to your interface and your code should work for any object that satisfies the interface. So, the result should be the following: `package main import ( “encoding/json” “fmt” ) type JSONmarshaler interface { marshalJSON() ([]byte, error) } type user struct { First string Last string } func (u *user) marshalJSON() ([]byte, error) { json, err := json.Marshal(u) return json, err } func main() { userDict := make(map[int]JSONmarshaler) userDict[1] = &amp;user{“Davy”, “Jones”} userDict[2] = &amp;user{“Jeff”, “Johnson”} a := marshalDictValuesToJSON(userDict) fmt.Println(a) } func marshalDictValuesToJSON(dict map[int]JSONmarshaler) map[int][]byte { dictJSON := make(map[int][]byte) for k, v := range dict { bytes, err := v.marshalJSON() if err != nil { continue } dictJSON[k] = bytes } return dictJSON }` 
Sorry for the crap formatting I wrote this on mobile. 
Since you ask, yes. I've worked on &gt; 50 discrete services on the JVM across several languages with instances of those services probably still numbering in instance counts &gt; 8000 several years removed. I've spoken internationally at conferences about doing so and am a published author on the topic. I don't really value service per host as a metric beyond 10-15 services assuming any measure of concurrency. That quickly becomes an issue at scale, whether I/O being a bottleneck, cache misalignment inefficiencies or failure modes being problematic. The JVM has made many strides over the years in terms of CDS, JIT time improvements, class unloading and reducing memory overhead (https://stackoverflow.com/a/46516509 as an example) although those all favor vanilla Java vs. over the top languages and these improvements can be leveraged in containerized workloads if done correctly. Can you squeeze 10MB less out of a Go process than a vanilla Java JVM process? Of course. Is that worth the time? Not in my experience and the upside is regularly blown out of proportion. I don't have any skin in this game. I spend most of my time in Python, Rust and Go these days but this myth of the JVM being *so* over bloated that it's not usable for microservies needs to stop.
I join st don’t know where to start. I have o problems making SQLite dB connections but do not know the proper way to connect to an access DB. 
I’ve used the golang sql library to connect to SQLite with no problems. I don’t know where to start when trying to connect to a MS Access DB.
godoctor does this as well http://gorefactor.org
Yes, but how about nested handlers?
This shows how good your LiteIDE actually is. I mean it is not good. Because GoLand is only slightly better than, to say, Emacs with a set of packages providing autocompletion, refactoring, etc.
Did you try to follow the [example](https://github.com/mattn/go-adodb/blob/master/_example/mdb.go)? 
What do you mean nested handlers?
Gotcha... did you install the ODBC driver? https://youtu.be/biSjA8ms_Wk
Thank you!
When you have handler for all /api routes, than inside this handler you declare few another handlers for /users /photos , etc. And inside them you declare even more.
Well then, we can conclude we don't agree then. Have a nice day.
You can chain ServeMux in order to do that.
Can you show me an example, please?
you're welcome :) 
Ok, thank you for your answer. To be fair, I kind of see your point. I am working in c# too and to be honest writing a custom container is in fact pretty rare. It's more common for me to write a generic method, but maybe you are right saying that having them makes you see them everywhere. Thanks!
The article this is responding to is so stupid it doesn't really merit a response. It is a horrifying insight into the mind of a PHP developer though.
Php....lol!
It was actually a comment rant on /r/AskProgramming, asking if this guy's advice on Go was legit. I figured I'd thoroughly break it down since the OP couldnt spot the issues. 
Here's a sneak peek of /r/AskProgramming using the [top posts](https://np.reddit.com/r/AskProgramming/top/?sort=top&amp;t=year) of the year! \#1: [Why is it so damn hard to ask a question on StackOverflow that doesn't get negative ratings?](https://np.reddit.com/r/AskProgramming/comments/7gw7tk/why_is_it_so_damn_hard_to_ask_a_question_on/) \#2: [Good Programming Youtubers?](https://np.reddit.com/r/AskProgramming/comments/6mpbg3/good_programming_youtubers/) \#3: [Am I crazy for believing we should form a trade union or guild?](https://np.reddit.com/r/AskProgramming/comments/5hqkw5/am_i_crazy_for_believing_we_should_form_a_trade/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Hackernews [comments](https://news.ycombinator.com/item?id=15903101) if anyone's interested.
`bytes.Buffer`, I thought you were my friend https://syslog.ravelin.com/bytes-buffer-i-thought-you-were-my-friend-4148fd001229
A pattern which works in cases like this is as follows: 1. Reasearch any information on how to connect to an MS Access DB using *whatever the Microsoft supplies* and the technology of your choice. Say, if you need ODBC, search the internets for "ODBC+MS+Access". 2. Research the examples in the library you want to use (say Alex Bainman's `odbc` package. 3. Combine the two. ---- Also please note that stating "I've tried … without success" is no different than stating "Please give me the working code". That's not how things work; you should share the code of your attempt(s) and state explicitly what, and how, failed.
&gt; But another point I want to make is that in Go, you absolutely, under no circumstances, should be even trying to reuse code or define an interface. Sooner or later, it will bite you in the ass. Wuut ? &gt; Writing code has to be pleasant experience. Writing code is like painting or sculpting. You have to have a passion for it. You have to love it. I can't even begin to describe how pleasant of an experience it has been writing in Go. P.S. The quotes are from the original article which this article quotes. 
Can you please file an issue about this and the devs will figure out a way to help you? It might be a bug in the IDE or a third party package but it's hard to know unless some investigation is done.
Thanks for almost tipping my server over :) Seriously, thanks! 7k hits in the last few hours from HN and counting on my $5/mo. peasant server from namecheap. 
if you look at the String() method, it does some extra unsafe pointer hackery to avoid copying the internal byte array into a new allocation.
If it's just content, get CloudFlare in front of it and cache the actual page itself. Your $5 VPS will go a hell of a lot further than 7K hits in a few hours.
I’ve just moved from PHP to Go. What a difference. And I couldn’t disagree more with the original article. I’m writing high-level APIs and reusing code all over the place. It’s not spaghetti. It’s well structured. Yes I miss the magicalness of Laravel, and more specifically Eloquent. But I know what I’m writing is far more performant, strict, and terse. And considering the app that I’m being paid to write is replacing something written in PHP, it better damn well should be. 
While part of the programmers community keeps arguing which language is better, I smile and return to work productively in Go
Sure, here you go: package main import ( "fmt" "net/http" ) func main() { booksMux := newBooksMux() api := newAPI(booksMux) v1 := http.NewServeMux() v1.Handle("/api/v1/", http.StripPrefix("/api/v1", api)) http.ListenAndServe(":8080", v1) } func newAPI(booksHandler http.Handler) *http.ServeMux { mux := http.NewServeMux() mux.HandleFunc("/stats", serveStats) mux.Handle("/books/", http.StripPrefix("/books", booksHandler)) return mux } func serveStats(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "serving API stats") } func newBooksMux() *http.ServeMux { mux := http.NewServeMux() mux.HandleFunc("/show", showBooks) return mux } func showBooks(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "showing books") } ([Playground link](https://play.golang.org/p/8tE-IAReij)) Run it on your machine and visit: * `http://localhost:8080/api/v1/stats` * `http://localhost:8080/api/v1/books/show` 
7k hits in a few hours ? That does not seem too much at all for a 1cpu, 512MB box. What's your stack ? Just curious.
Any of that code opensource? I'd like to see some actual code an not just people claiming they did this or that :)
Thanks for response! I need a time to think about it
I thought I was on garbage, but Ive got a gig of RAM default and up to 4gb burst. Its just apache, wordpress, caching, and a CDN. 
I see, maybe there was an issue at the time.
I had no idea, my max traffic up to this point has been 1k in a span of about an hour. Things got messy so I got a CDN hooked up, along with a cache so the DB didnt get overloaded. I suppose there really isnt very much logic in a blog so it makes sense that it would scale up easily with a cache. 
I literally had a broken backwards compatibility issue on PHP a few days ago resulting in pretty much catastrophic failure. Core packages might be unit tested, but their clients which have already been implemented don't fit into these unit tests. I had a function like this: getNews($id, $pageNumber, $pageSize, $exclude) which has been amended into: getNews($id, $filters, $pageNumber, $pageSize, $exclude) as the previous usage was ($id, 0, 20, 405050(high ID int)) you would assume out that it would fail, but in fact was executed as ($id, filters=0, pageNumber=20, pageSize=405050, exclude=null. Only a warning is issued for such a refactor. Now imagine fetching pretty much the whole news archive of 400k+ news items for every query that was supposed to get 20 of them. Out of memory errors, pretty much nonexistent backtraces in such situations, servers going into swap, and a really long time before I figured it out and a fix could be deployed. TIL: If you're adding parameters in PHP, add them to the fucking end of the function signature. Fuck. I guess you would have the same issue with GRPC but at least the Go compiler would complain about that when a function signature changes. I dunno man, this was the worst thing to happen with PHP after 15 years+ of experience.
*wordpress*. Eh.
Yikes. That's the runtime error from hell.
I added a thrown exception into the database class to try to catch the very specific query, the problem is that of course that's 1) production code, and 2) that you can't really include the complete backtrace into every sql query as a comment to figure out what path the query is coming from. Also tried xdebug traces which pretty much filled out a the disk from a single webnode with thousands of traces and then you're trying to sift through all those MBs/GBs of data to find the correct trace that would pinpoint the origin. Best info was coming from the exception trace and not the profile trace. Just diagnosing this issue took over an hour, resolving it took a hard refactor over a significantly large codebase which again took more than an hour. We couldn't revert the API signature at that point because another part of the system was already using the new API signatures (which, thankfully, changed once in something like 5 years). There are serveral (a LOT) of ways which would make this thing more diagnosable. One of which is keeping a request trace ID which would be active through the life of the request, and would be included in the SQL queries as a comment. While you wouldn't necessarily get a program trace, you'd have more information about entrypoints that would let you look more specifically for the issue. A significant contributing factor is having insight into those PHP warnings, but there are significant obstacles to implementing them fully, boiling down to undefined coding standards (as go fmt but for php), and the `@` operator which silences these warnings. Error handling, that thing which is clear and absolute when it comes to Go. PHP Notices are ... I have no idea what they are. They are somewhere between stdout and stderr, and you don't really catch them like exceptions or handle them like values, but you could register an handler for them? Man, fuck this language.
When I'm at work I make sure everything is top class. For my personal blog - I'm a lazy bastard.
Replace apache with nginx. It will do a world of difference.
Just did a little googling and it looks like some folks are reporting 1000 concurrent users with no issues on similarly powered DO droplets. I'm gonna load test my current setup and see where it breaks.
The funny thing is you hear constant bitching about error handling in Go. It's probably one of the best parts of the language. Combined with a solid linter and logging, I've only ever encountered runtime errors from straight-up rookie mistakes...uninitialized maps, nil pointers with no checks, etc. I worked with PHP for a few months before I nearly tore my hair out in frustration. I'm sure if I had more experience I would have been able to debug faster, but sometimes it just fails in the most obtuse fashion and the error output isn't usually helpful. I spent so much time coding defensively I was constantly in an existential crisis. 
Really? I will look into it. I asked one of my mentors about nginx vs apache the other day and he said it didn't really matter. He's a bit of a traditionalist though.
There are better examples where PHP shines, mostly when you're doing very untyped transformations of significantly large data structures where you don't necessarily want to strongly type that stuff out for various reasons. But then there's everything else from an inconsistent stdlib, lack of threading/goroutines (or async queues), memory management, ... if PHP itself would run as a sort of JVM and not just a collection of processes with a FastCGI interface (and we're talking tens or hundreds of them), ... considerhing some of those problems exist since PHP4 today on PHP7, and they bolted additional issues onto it along the way (like having sort of but not exactly json notation of array declarations?!?) these issues are only getting amplified. I love the Go backwards compatibility promise. While you do need to upgrade bits and pieces of code now an then to support new features, I haven't come across an example where I would actively have to change some code that works on Go 1.4 to work on Go 1.9. That's the biggest hidden cost of PHP, because code tends to stop working even between patch versions from 5.2 to 5.3 to 5.4 for example. As you can tell, I have a lot of bottled up rage and frustration about PHP.
Please turn the problem into a small, self-contained program at the Go Playground.
Support .go-version yet?
As an aside, what is your workflow with cases like these? I often run into these questions, but due to poor judgement, I don't answer them myself via benchmarking. Do you open up a new project and write the bench? Do you open up a new source file and write the bench under the related test file? etc I feel like I want to add a plugin to my editor to open up a new file, sort of like a Go Playground, which makes benching quick, dirty and easy. Without deciding if I want to add the bench to my project, or etc.
Yes... Panics on binary launch are an important step. We are talking about initialization checks only though. 
I've had a pretty similar experience over the last year. Laravel to Go has had me searching for a couple comforts of Eloquent, but overall I love Go.
While I don't believe this is the majority reason that some people try Go and don't like it, I think there is a substantial minority that never stop trying to use Java's OO model in Go, which results in a poor experience. I suspect this is the case because a number of people come out of school with the belief that the Java-style OO model _is_ OO, and anything that does not conform to that style is simply not OO, and also, not good, basically by definition, because OO is by definition the correct way to program. I'm guessing this because it isn't just Go that I see them in; I see people complaining about how hard Python is to use because truly private variables are annoyingly difficult, or I see them pick up Haskell and the first thing they do once they learn the basics is try to implement an object solution, or immediately pick up one of the couple that already exist. I can't tell you whether any given one of them stay stuck, but I know we keep seeing them because the schools keep turning them out. (I think perhaps the pace has slowed since I graduated ~14 years ago from a program that tried its level best to teach me that too, but there's certainly still quite a few programs out there teaching Java/C++ === OO, and OO === good.) It's a well known issue when starting with a new language to try to program X in Y ("Java in Go", "Python in Haskell", etc.). Given how simple Go is, it is simply a disaster to try to program in the intersection of Go and some other language like Java; you're left with something that is a terrible Go and a terrible Java and less than the sum of its parts.
&gt; When I try to set a Collection to a Migration.Up, get this error: ../src/github.com/deusdat/arangomigo/migrations_test.go:24:27: cannot use c (type Collection) as type Operation in field value. You are misunderstanding embedding, thinking it is a form of inheritance, but it's not. Inheritance provides an "is-a" relationship (`class Dog extends Animal` makes `Dog` a subtype of `Animal`, every Dog is-an Animal), but embedding provides a "has-a" relationship (`struct FooClient { *http.Client }` does *not* make `FooClient` a subtype of `*http.Client`, it just promotes the methods and fields of `*http.Client`, but they remain unrelated types. A `FooClient` has-an `*http.Client` - in this case, it uses the client it has to make HTTP requests). Go also provides a way to subtype, but not via struct-embedding, but via interfaces. E.g. a `*bufio.Reader` is-an `io.Reader`, because it has a `Read([]byte) (int, error)` method and the latter is an interface with that method set. Now, I don't *fully* understand what you are trying to do, but you probably want one of these: * Change your Migration to have Collection fields ("every migration ups some collection or downs some collection"), instead of Operation * Make the Collection a field of Operation, instead of the other way around ("every operation operates on some collection") * Make Operation an interface (e.g. `interface { Execute(db *DB) error }`) and have Collection implement that interface ("A Migration has an Up and a Down Operation. A Collection is-an Operation, i.e. can be brought up or down") * Make Migration an interface and have Operation implement that interface ("A Migration is something you can do to a database. You can perform an operation on a database") Hope that helps :)
Nginx rocks. Better config files and more performance. 
Declare package level variable with parsed template: var layoutTemplate = template.Must(template.ParseFiles("templates/blog/layout.gohtml", "templates/blog/navbar.gohtml", "templates/blog/index.gohtml", "templates/blog/footer.gohtml")).Lookup("layout") Replace calls to GenerateHTML with call to template: layoutTemplate.Execute(w, data) 
I think that you're on the wrong post?
Wow. That was an elegant solution. Much appreciated.
&gt; I think that you're on the wrong post? Ah, I was intending to reply to the thread below me. Sorry for that, thanks for the heads up. 
As an aside, what is your workflow with cases like these? I often run into these questions, but due to poor judgement, I don't answer them myself via benchmarking. Do you open up a new project and write the bench? Do you open up a new source file and write the bench under the related test file? etc I feel like I want to add a plugin to my editor to open up a new file, sort of like a Go Playground, which makes benching quick, dirty and easy. Without deciding if I want to add the bench to my project, or etc.
Wow this is great, it's going to help in some of the places I've seen security issues with people who use unsafe byte slice conversion. It won't fix security issues for places that reuse a single buffer such as this one I just commented on [yesterday](https://github.com/nuclio/nuclio/issues/277#issuecomment-351007523) but it WOULD fix places that are doing [byte slice conversion](https://github.com/chmike/securecookie/issues/1) due to needing to conditional appends before creating the string. The implementation is quite clever, the byte slice that backs the Builder only appends and reads the backing slice, never changing an existing index. This combined with the fact a string is simply defined as: type string struct { str unsafe.Pointer // []byte slice len int } Means that any string returned by the builder can never race with a future generated string despite the fact they are all backed by the same []byte slice ("unsafe.Pointer" above). Because an array or slice can have different indices read and written to concurrently, you just can't read and write to the same index. It enforces these rules with the clever "copyCheck()" which is called by every public method that mutates state. The builder struct which is defined as: type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } func (b *Builder) copyCheck() { if b.addr == nil { b.addr = b } else if b.addr != b { panic("strings: illegal use of...") } } So the first first call to a public method it stores the receiver address into the addr field. If the builder is then passed to another function by value the entire struct will be copied including the addr. Since it will live in a new frame the receiver address will be different than the pointer stored in addr causing a panic which blocks the writes keeping the immutability guarantees of existing strings. A cool technique that might actually be nice in things like sync.Mutex instead of relying on the noCopy empty struct and go vet- though the extra conditional branches and extra word here may need much more consideration. In summary this will shine most when you are conditionally building a string like often found in String() methods that you may use multiple fmt.Sprintf's along with concatenation which can quickly cause a lot of allocations. Instead you can do the below for only 1 allocation: func (p *Person) String() string { var b strings.Builder // We can ensure capacity for all fields before hand b.Grow(len(p.First) + len(p.Last) + len(...)) if p.First != `` { b.WriteString(`First: ` + p.Name) } if p.Last != `` { b.WriteString(`Last: ` + p.Name) } // ... return b.String() } Nice and clean! This will also be great for libraries that are allocation monsters due to string gone wild, such as logrus (not to pick on them specifically, but it would help tremendously I think with building messages from fields). Only other thought is a small improvement to the implementation may be a way to reuse the existing slice backing some how when reset for producing more than one string of unknown bounds. Since you could have a good deal of capacity still available that is safe to reuse, something like b.buf = b.buf[len(b.buf):len(b.buf):cap(b.buf)] in reset I *think* (don't hold me to that I could be wrong) would still maintain a correct implementation but potentially save some allocations. All and all a real nice addition to the standard library, kudos to contributors involved.
In any X vs Y comparison, people will have their own biases. "doesn't really matter" is not an objective and technically specific answer at all. I would recommend to do your own research and derive your own conclusion. Nginx has fundamental architectural differences than apache. I am not going to blankly declare that it is better than apache. But I can say for sure that **it does matter** whether you use nginx or apache. You can go through the famous C10K page -http://www.kegel.com/c10k.html to make yourself familiar with some basic approaches to webservers. And then go through http://www.aosabook.org/en/nginx.html to really understand where nginx fits in.
I couldn't have said it better. You have hit the nail on the head mate ! &gt; I suspect this is the case because a number of people come out of school with the belief that the Java-style OO model is OO, and anything that does not conform to that style is simply not OO, and also, not good, basically by definition, This. So much this. And if this is the state in US, you have no idea what goes on in other countries like India. It's a part of a bigger problem where courses are learnt just to get the grades and not for the simple enjoyment of learning. And when people get a job, they just regurgitate whatever is just taught to them. There is no zeal to learn more, to raise the bar and most importantly to become a better programmer. It just makes me sad.
It really pains my soul that every lib that exposes programmatic mouse movements for Linux just hooks into X11, and as far as I see robotgo doesn't support wayland. It's so easy to do it properly via libevdev which would support both X11 and wayland as it's a layer or 2 below both.
So coming from a younger developer who did try a few languages (history: c, java, c#, python, php most prominently) can you recommend a good starting point for go in form of a book like learnyouahaskell? Because from just playing around a bit it seemed really awesome but kind of confusing for a newbie.
It doesn't matter, as long as you're comparing apples to apples. If you're comparing apache with prefork, mod_php ,and mod_rewrite, of course that is going to be slower than nginx with php-fpm and no .htaccess rewrite support. Apache with worker, php-fpm, and static rewrite rules will perform just as well as nginx.
It is one of the most useful powerful/most overlooked features of Go though - but it's pretty nice. Certainly the io.Writer/io.Reader and related interfaces are underestimated a lot. Sadly, there's no standardized filesystem interface. That would have opened up a lot more possibilities. There are some 3rd party solutions though, and the http.FileSystem interface tries to achieve something similar.
The reason for using x11 is that wayland was not supported by default before Ubuntu, Linux other features also rely on x11, this is a problem, It takes time to migrate to wayland.
&gt; GopherJS was instrumental in showing me that creating a Go to JS compiler was even possible and whenever I had a question about what a Go statement should translate to in Javascript, I looked to GopherJS for inspiration. Hmmm. I wonder how much inspiration came from gopherjs ?
Joy author here – the compiler is completely different but I used gopher's output a handful of times to see how they did the translations.
Oh well, this is a very mixed bag. From my perspective it doesn't matter at all until(!) you reach proportions and requirements of Facebook or Uber. I can shell out a full rest API, with frontend, south, in, database migrations and full and manageable http caching support in no time with something like symfony or laravel. It would take me considerable longer to do so in go? Is go worse because of this? No. 75% of the delivered packets will come from a cdn/haproxy/varnish anyway. The rest is bottlenecked against some kind of datastorage anyway. Spinning up one more PHP or Go node is hardly a problem sub 500k users. 
Nice. I'm reading into it. It's nice to know it already has first class support for "React &amp; Preact"... How hard would it be to use it in a project with VueJS instead?
Yes but you're implementing a brand new library right now and creating a x11 dependency when a solution exists that purely depends on Linux core features, ie. abstracted below both x11 and wayland, which means if you implement your Linux support with that solution you won't have to reimplement it if/when wayland actually becomes used widespread, which is already happening actually, eg. Fedora uses wayland by default. See https://en.wikipedia.org/wiki/Evdev
**Evdev** evdev (short for 'event device') is a generic input event interface in the Linux kernel. It generalizes raw input events from device drivers and makes them available through character devices in the /dev/input/ directory. The user-space library for the Linux kernel component evdev is called libevdev. Libevdev abstracts the evdev ioctls through type-safe interfaces and provides functions to change the appearance of the device. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
[Here is the list of the contestants](https://github.com/avelino/awesome-go#gui), but I also have no clue if a winner will exist. Most libraries are incomplete or have odd/annoying dependencies.
Wayland is the future, thanks for the suggestion and will be done gradually.
Speaking of GopherJS, how do the two compare against each other?
GitHub link for people at work?
Cool, if you get stuck on using evdev directly you can always ask me, although judging from your code you seem to know what you're doing. I started playing around with libevdev a few weeks ago but I'm not a C/C++ programmer so I've mostly done stuff using go with cgo (just hooking into libevdev) and played around with python-evdev for prototyping initially. From my experience it's really easy to use libevdev for a plain mouse, ie. relative x, relative y movements and button clicks. Although I'm aiming more towards virtual touchpad which is a bit more complex and has left me scratching my head a lot. GL
S3, Hugo and a CDN. No instance costs.
So I didnt learn from a book but I already had experience when I started. It sounds like you do as well. The best place to start is tour.golang.com, then lookup go by example. Id read through those and then download go, get your environment setup (vscode has some great go extensions), and start replicatong the examples. Once youve got all that done, you can look up Todd McCleods series on YouTube. Its a bit dry but hes fairly thorough. From there Id build a restful API, start off with a trivial one, then build something a little more complex. Once you can build up a solid API youre basically competent. The stdlib can do just about everything besides embedded software and decent GUI development so just read the docs and participate in the community. Go seems complex at first, but once you get past that inital plateau its one of the simplest languages there is IMO.
Hugo is a lot of grunt work. But that could probably scale virtually infinitely.
write a custom JSON Unmarshaler?
You keep asking this question over and over again but you seem incapable of answering this: What is ` .go-version ` ? I've never heard of this, I have no idea what it means or what it should do. Can you please explain what do you want with it?
I have been thinking about both, the the problem that still isn't solved there is the fact that the parent struct wont like having a field that is a struct with TypeA or TypeB. Is there a way to solve this?
Just give an error message and exit with status 1 like any other sane program. Stack traces are for programmers, on programmer errors.
See: http://eagain.net/articles/go-dynamic-json/
Ah that does make sense, the only thing that is unclear to me then is the final product. Since there will be multiple "Sound" structs which all reside in a encapsulating struct, what type should I give the field where the "Sound"s will be in? That is the only thing unclear to me.
chruby, nodenv, pyenv, and jenv support automatically reading a .&lt;language&gt;-version file at the top level of a project directory and loading the corresponding version of a language into $PATH. For anyone who contributes to multiple software projects, this is a godsend, dramatically reducing the amount of manual environment configuration when rapidly switching between different projects. If Go(g)land supports .go-version, then the editor is tremendously useful for my purposes. If not, I’ll stick with vi thank you very much.
I'd love to add Vue.js support :-D The problem with Vue is that it wouldn't be just Golang, so you'd need to build up the tools. Maybe a faster route would be to use Joy inside the existing Vue compiler, but I'd like to invert this at some point.
Yeah, I'm going through some of the pain of finding / tweaking a template for it, but it also means pretty much no security concerns (which also seems to be a semi regular issue)
Ha yeah, it's all cool! Maybe the fact that it was a back and forth episodic story that stayed in the people's minds played a role in its success. For those things there's usually some luck involved but I truly thought the article was great and that's why I linked it. Besides if I didn't do it, the article would be still linked by someone else. Such is the fate of good content. Oh and I also liked the UI of your blog. In any case, I am glad I was able to help. Cheers!
&gt; chruby, nodenv, pyenv, and jenv support automatically reading a .&lt;language&gt;-version file at the top level of a project directory and loading the corresponding version of a language into $PATH. There is no Go tooling that I'm aware that supports this. Can you please point me to where I can find such tooling? &gt; For anyone who contributes to multiple software projects, this is a godsend, dramatically reducing the amount of manual environment configuration when rapidly switching between different projects. You don't need this. GoLand can automatically detect a Go SDK, and if not you need configure the SDK only once, then apply it to all projects. Have you tried to use this and the IDE failed to automatically add the Go SDK to the project? The IDE automatically injects the GOPATH and GOROOT both as environment variables and into the PATH environment variable with their corresponding GOPATH/bin and GOROOT/bin directories. Do you actually have a problem with this as it is today? Have you tried the IDE and it's not working? &gt; If Go(g)land supports .go-version, then the editor is tremendously useful for my purposes. If not, I’ll stick with vi thank you very much. As I said, you only need to configure the Go version once and the IDE will use that across projects. You can then adjust it to each project as needed, in case a project as a particular need. It will also pick up any updates to Go itself in the paths it's watching, in case you have multiple Go versions that you use.
I _think_ the answer to your question is the JSON.RawMessage type, but I'm not quite sure I'm navigating the shift between the blog post's examples and yours correctly. If you put it into a Playground example we may be able to be more clear. (Even if it starts as a non-functional one.)
Honestly, have you even tried to Google for this? There are so many solutions out there that do what you want. Here's what I get when I search for this on Google: https://www.google.com/search?q=site%3Agithub.com+goenv&amp;oq=site%3Agithub.com+goenv&amp;aqs=chrome..69i57j69i58.7309j0j7&amp;sourceid=chrome&amp;ie=UTF-8 Then click the first link and they mention .go-version is right there.
Usually I'm a big proponent for using the right tools for the job. That said, after reading the justification, this is actually really cool. I really like the examples and how easy it seems to make it, and idiomatic you can still write to achieve the same results.
I don't have open source projects to show but I ported 2 projects from PHP - one vanilla PHP and the other one was using Symfony. The latter has structure that translates quite well and templates translate straightforward too. What I got was compile time errors rather than runtime errors that peppered the original project. Once fixed, the project is a pleasure to work with. Currently porting Drupal 6/7 (6 upgraded to 7) project. Have application that migrates data, keeps user credentials as-is. I implemented hashing to be exactly as in Drupal 7 to avoid resetting passwords for existing users. I am using table inheritance in PostgreSQL to implement CMS-like structures - some content types share certain fields and I have to return/display mixed content often. Again, works beautifully and I am having fun working on it. The code is completely different, of course, because Drupal is all about hooks and what a spaghetti that is. 
I actually haven't done that.
Would something like this work? https://play.golang.org/p/f1RCSK18-Y 
The only way to be able to parse the stream effectively without having large structure is a guarantee if `TransactionType` will always be the first field and custom parser based on this fact. Another approach is to switch from ``` "transaction": { ``` to ``` "transactionA": { ``` You also can consider switching to protobuf with its `oneof` to have something like ``` oneof transaction { TransactionTypeA transactionA = 1; TransactionTypeB transactionB = 2; … } ``` All in all, the JSON is a poor serialization format for such kind of data.
Thanks, will do. I've heard the same about the stdlib and am pretty interested after the article. So it had some good sides after all I guess :D
Traffic started dying down a few hours ago. Roughly 15k unique visitors last time I checked!
Yeah I think Im at 11k malicious attempts blocked on WP as of now. I never thought about the security issue. 
Well at least your competition is setting a low bar for you :)
https://github.com/matthewmueller/joy/issues/56 was given on HN an answer this questions. Different starting points, but it's not very technical right now.
Oh, and the source code is available on GitHub! https://github.com/campoy/justforfunc/blob/master/25-go-parser/main.go
You need to hook the draw calls of the target process and inject your own drawing code. https://stackoverflow.com/questions/11810854/opengl-directx-hook-similar-to-fraps On windows this should be fairly simple using the right WinApi calls. You can draw the vector using DirectX (or the hooked API). I assume go has bindings for these APIs
Don't worry about it, use the data structure with the most convenient api for your problem. 99% of the time, the speed of the code you write don't matter. If you run into speed or memory issues, then profile your code. At this point, you may attempt to write a benchmark that reflex the hot paths in your code. Put them in your test file to test for regression in the future. I say attempt, because it is incredibly hard to write good benchmarks. Take the grandparent article for example. The real answer is that + on string and buffers are optimized for different situations. +s are optimized locally and statically, the compiler sees the +s and produces a string as fast as it can, assuming there are no more operations on that string. The buffer is optimized for future operations not known at compile time, it has defaults that work well in the worst case. You can write a bench mark that makes + faster than buffer, but you can also write a bench mark that makes + much much slower.
perfect, didn't think about that. I found https://github.com/gonutz/d3d9. thanks.
Or if the logic to process each message type could be contained in a `Process()` method on each type then you could have an interface for it and the parent type could store it.
How is sustained performance for this? Considering the fact AVX puts out a ton of heat I am interesting to see if any throttling is present here.
Why not?
can you position this against docker? e.g. how does this compare to a `FROM SCRATCH` docker. is it a microkernel?
AVX512 is clocked lower than AVX2 so this will reduce power consumption somewhat. But given the fact that you can do a lot with a single core (especially when compared to AVX2), you would rarely need all cores to process simultaneously. We haven't seen any additional throttling beyond lower clock but we will keep an eye out for it.
Very interesting, however the docs suggest the output is ES3 however the goroutine example uses async/await syntax. How does joy plan on tackling browser inconsistencies? I would rather it outputted ES6 :/
Academically, Vorteil is a micro-kernel. In practice, it behaves like a unikernel, merging itself with the application binary and running as a single process without distinct kernelspace and userspace. Compared to containers, running Vorteil can result in leaner, more efficient machines that cost less to run. They are also 'just' virtual machines, which makes the deployment stack (on Google Cloud, for example) a lot simpler. Docker and Kubernetes are not required, though we plan to bring support for Kubernetes soon. There are also potential security benefits, which we'll investigate in future blog posts.
Cool; I love seeing optimizations like this. How often is SHA256 the bottleneck in a pipeline that involves network or the disk (and how common are pipelines without those)?
unfortunately that is not comprehensive enough for me. A viable solution I'm considering ttps://github.com/murlokswarm/app#gettingstarted wasn't on that list (maybe I should add it.)
How to use Postman for this code?
Remember: "When in doubt, use brute force." -- Ken Thompson Optimize later. You're already good at speed, you're using Go, not JS :P
Thanks for the reply! 
Well, SHA256 is one of the processing tasks that need to be done (payload verification), so doing this more efficiently also frees up CPU usage for other tasks
Still I didn't see a list of advantages over GopherJS.
Why would anyone prefer this over statically linking your binary and pushing it into a scratch container? No information on final image size so no way for me to know if it's actually sub 10MB in which case I'd be interested and it would be a good alternative which would allow go commands otherwise I don't see the value personally. 
Like so so many others before you, please use the search functionality to discover the fact that your approach is actually not good enough to create the minimal docker container for this.
Or you could just use [multi-stage builds...](https://docs.docker.com/engine/userguide/eng-image/multistage-build/)
Thank you! It really great thing, i just update my article and all builds, reduce size by ~250 mb.
For the Body of the request, select "form-data", then add a key such as "uploadFile", of type "File". If you do that, a file-upload form-element should appear in the Value column, where you can upload a file.
Now runs "goreturns" on the output file.
what are the tools? Browserify or Webpack? do they just uglify and minify javascript? sorry, if my understanding of js build tools is a bit stale. However, if this is about some deeper node.js magic that vue does during the build phase, I found this package https://github.com/FranckFreiburger/http-vue-loader It claims to load .vue files directly from your html/js. No node.js environment, no build step. So, in theory, we can use Joy with Vue straight away, am I right? 
I actually enjoy the flexibility in $GOPATH and such. But it requires a Unix-background which is a thing and not nothing. Other than that I wouldn't say it's been that hard to learn Go – at least compared to other languages, documentation and their respective communities. However, would say learning Go can be much more difficult without querying the Gopher Slack community because of the ease of use, helpfulness and fast responses.
Been learn for ~1.5 weeks. I've got lots of experience in other ecosystems, so I tried to forget what I knew and use the docs to learn best practices. That said I've run into pain around: * Package management. I'm using Dep now, but setup on Windows wasn't documented and I can see this being a huge hurdle for more junior developers. Plus how new Dep is, is a problem, since a good built in package manager is pretty much a standard in other ecosystems. * Pointers. This is a concept I understood but have never used explicitly. I'm still getting to grips with when to pass a pointer or value, and haven't seen any good guides on this. Also understanding how `interface{}` copes with pointers is a bit tricky, as it's the only implicit usage I've seen. * Knowing the right time and ways to handle exceptions. It makes code a lot noisier and I'm still not convinced I'm doing this right.
Yeah, Gopher Slack community is gold.
Overusing channels for concurrency without fully understanding the performance issues. I remember using channels and goroutines to implement iterators for a database system I wrote and being disappointed with Go's performance until I profiled and tested a normal struct-style iterator. The concurrency features are awesome when you need them but some of the tutorials and examples surrounding Go make it look like you should use them more often than you should. Even with concurrency, if you study the standard library and many of the popular projects, you'll find mutex locking more often. Channels are great at solving certain problems, but to a beginner it's not always obvious which ones.
The most difficult thing for me to understand when I first started were channels. It's so easy to use them wrong, and to find yourself in the middle of a deadlock if you're not sure what you're doing. Following this, it was just understanding proper concurrency (avoid race conditions, etc.). For a good while, I used mutexes instead of channels for what I needed (which worked fine for what I was using at the time). Eventually, I knew I had to master channels... and finally did so. I think there's a love/hate relationship for them (some say they're needed, others say avoid them at all costs).
This looks very very cool! Would one need to generate a new disk image for each instance or can you simply copy an existing one and spin it up? 
this material was published 7 month ago, when dinosaurs ruled the earth
Object vs. pointer receiver in methods and working with slices, because these were the first things to grok. Afterwards, I already switched to thinking in Go rather than trying to apply my previous programming experience to it and learning went smoother.
Go, despite being very simple in syntax and in its development practices, is not easy to enter. For example on Windows, people are not used to Environment Variables. And also command line flags (we were using horrible, meaningless, predefined, monstrous XML files which we did not fully understand) - and yes; there is now Ubuntu on Windows and the such. And people should learn early (in Go) to not be afraid of working with files (which implies not being afraid of byte slices `[]byte`). And config wastes a huge amount of time for newcomers to Go. There are certain aspects of Go community that I do not like much and this is one of them: putting no value in conformity. We should at least reduce main options for things to two or three. Anybody with more experience, can do whatever she/he see fits.
And yet stilll relevant in regards to explaining blocking and threading models of all the languages in question. It has it faults but really not as useless as you seem to suggest.
Great to see Go expanding in this field! I work on a genomics research lab and also use Go to develop tools hehe :)
You are not wrong, but not everyone wants to overhead associated with the ```os``` package. In addition to my prior comment I'd like to add that a panic really only has a long term place in ```main.go```. There is VERY rarely a need to have a panic in a library.
The hardest thing for me was shedding the indoctrinations of OOP languages and resisting the urge to bring those concepts over to Go, and really learning how to do things "in Go" After that, once you have pretty good grasp of the language and gotten to the point where you understand your 5 or 6 standard lib packages you use daily to get your job done, the way to become better at Go is not to learn more about Go or the ecosystem, but to become better at computers, in general. Understanding schedulers, thread contention, mutexes and lock-free programming, allocations, heaps and stacks, this requires mechanical sympathy, and understanding the trade offs of adding complexity for the level of performance you are trying to achieve versus what is good enough. I would argue however that these last two points are how you become advanced in any new programming language and these concepts tend to translate. Go helps you reach that point faster.
&gt; You are not wrong, but not everyone wants the overhead associated with the os package. Sorry, what overhead?
Great article framing IO performance. I think it would be very useful for people undertaking new backend builds.
From the issue, it sounds like the author started with great JavaScript interoperability and is working towards better Go interoperability whereas GopherJS did the reverse. I asked in the issue if that is correct, but I think it seems like a clear difference, and when / if the projects pass each other, I think the opposite focuses will only add great synergy to each other--assuming Joy takes off as a solid active project.
* The Windows installation/configuration guide was, and still is, incompleted concerning the setup of a custom workspace (Don't forget that $GOBIN!). * No official dep manager was a bit weird and it often caused my project(s) to break since one of my dependency was very often updating. * The ``append`` API was a bit odd but nothing bad once you learn it. I would have thought that you would operate on a slice and append an element to it: ``mySlice.Append(el)``. I didn't expected to use some global function and save the result back to the original slice. * Trying to stop thinking in OOP (I'm making progress). * I guess stopping to write parenthese and the backward syntax for declaring variables was a whole different challenge by itself but it wasn't hard nor do I believe that it is a problem. It's all about getting used to it.
There is a github issue related to this subject. https://github.com/matthewmueller/joy/issues/56
As far as I can tell, at the end when he switches to "c-backed BLAS", he's actually still using the Gonum implementation (which is a mixture of Go and C). You need to register the c-based implementation with the `blas64` package, and I don't see that import anywhere in his code. I don't know how much faster the C implementation would be for this case, but our Go implementation is much faster than his naive implementation partly due to better algorithms (both in the serial code and in how it is parallelized), and also because we have some amount of assembly implement SIMD instructions (better versions coming soon!) tl;dr: If you were impressed by the iteration speed at the end, you were impressed by Go/assembly, not by C. 
Totally unexpecting those results. Very nice.
You can use websockets to keep an open connection and just periodically write the data to live stream it
So, when cross compiling... how do we override the -o in build. I'm on Windows trying to compile for linux, but it's appending the .EXE extension on the end of the linux build. Is there a proper way to override the '-o' build flag, or have the IDE know when the environment settings are set to build LINUX (GOOS) that the filename generated automatically should take this into consideration?
Unless you have a larger project or enterprise needs, Go libs tend to be stable. I'm not saying you need to ignore package management, but I wouldn't bother with while you are learning it. GOPATH + go get work well.
I want to have a goroutine running and waiting for for a signal to start its jobs, it will then loop till its told to wait again... Is this the best way to do this?
WS_EX_LAYERED is an extended style control value - it needs to be set in the first parameter of CreateWindowEx, not the fourth.
Self taught programmer here. Is this the kind of thing you'd learn in a CS degree?
wonderful! works great! bless you &lt;3 https://i.imgur.com/QC3MuK2.png I'm gonna go ahead and try drawing using https://github.com/gonutz/d3d9 the vectors drawn shouldn't be invisible too I hope 
If you want to learn the information needed to create your own answer start with the blog post [Share Memory By Communicating](https://blog.golang.org/share-memory-by-communicating) as a great introduction to this problem. Pipelines and cancelation might be a good next stop. Otherwise someone will probably give a good code example I’m sure. 
This is a data race: examplefunc is not guaranteed to ever see exampleBool changing. Use channels to communicate signals: https://play.golang.org/p/0nVrWsCmfT
It may sound a little noobish, but getting my head around the intricacies of interfaces took me some time.
No problem, man. I think the vectors shouldn't be invisible unless you're drawing them blue, if I'm interpreting everything correctly.
I vaguely feel that the underlying problem might need a different solution. Why do you need to keep the goroutine alive between the working phases? Why does the goroutine have to be stopped from the outside? A more common approach than sharing a boolean is to let the goroutine die after work is done and spawn a new one when the next request comes in.
Mostly no. This is definitely in the set of things you're expected to pick up in industry. I'm sure there will be people who can say that _their_ program covered it, or they covered this stuff in an optional class, but I do not believe it is common. It _is_ quite common to cover "threading". But that will be it; not the multiple models, not node-style async, not Erlang-style processes, etc... just C/C++/Java-style threading. And when you cover threading, you're still pretty likely to learn about "semaphores". Not anything else.
Thanks. Justifying going back to school for a degree just gets harder and harder.
Tone: Friendly. I do not mean this as a personal criticism, but it is not the best way to do this, it is actually pretty much the worst. In concurrent code, you should pretty much never use time.Sleep. (I've rarely used it in test code, when I can't get anything else to work, but even _that_ is a huge code smell.) At the moment, your example is a bit too trivial to sink any teeth into; can you give a slightly more detailed example of what you are trying to accomplish?
Some of the benchmarks are pretty unfair. They are using PHP 5.4 which was released almost 6 years ago and support for it ended 2.5 years ago. It was literally released before go v1 was released. In benchmarks between 5.4 and 7.1 (which isn't even the newest version), a lot of results are showing a 4x-5x performance increase. Obviously it will never be as fast as Go, but at least make the fight fair compared to something similar like Node.
In grad school we did, but not really undergrad.
It's like with any cool tool, learn to use it, not overuse it. Use whole toolbox, not just the hammer. Mutexes, channels and `sync/atomic` all have its place. I saw people overuse, for example, `sync/atomic` for a thing that is read rarely and changes **once a year**, makinf otherwise simple code overly complicates
Not directly, but a typical jr/sr level OS course when I went through (15-20yrs ago) would cover the the underlying fundamentals. It was then up to you to learn which platforms (in this case, php, go, node, java) did things in which way. 
&gt; A more common approach than sharing a boolean is to let the goroutine die after work is done and spawn a new one when the next request comes in. This. Look at using barriers / a group (ex. errgroup.Group) for synchronization. Channels for communication. And context.Context for timeout / cancellation / etc.
Completely bullshit article using horribly outdated examples. You don't need callbacks in node (async/await anyone?) and you can do concurrent work in multiple processes and the php version is outdated by several major versions.
Yeah, just do either a periodic query with JS AJAX or to a long poll with ajax (you make a request, then you block in the net/http request handler until something interesting happens). I'd avoid websockets for something like this. For the live prices, make a http handler that takes a list of IDs (user needs updated prices for all of these IDs), query them in a single query, and return them all at once. After you do this on the client, do a JS `setTimeout(FetchAgain, 5000);` .
My recommendation is to work through the [SICP](https://mitpress.mit.edu/sicp/full-text/book/book.html), not necessarily because it's the bestest thing ever, but because I think it really hammers on the topics that are A: challenging to pick up ad-hoc and B: _extremely_ valuable in practice. Not the Scheme part, but all the stuff they do in it, including implementing it. If someone came to me and said "I don't have a degree, but I have worked in industry and I've worked through the SICP", and could substantiate that, I wouldn't worry much about their credentials. Now, I'm unusual that way, but still, that's how I'd feel about it. (It is possible to work through the SICP in your choice of language, but I kinda recommend doing it straight. And yes, it may seem a bit on academic side at times, but, well, that's what we're here for, right? And a lot what may seem very academic comes back around to brutally pragmatic before you know it. Being able to write a compiler or an interpreter is one of the things that separates the wizards from the monkeys.)
Nvm... found this: https://youtrack.jetbrains.com/v2/issue/GO-3703
The virtual disks we generate for Vorteil do not need to be unique, so copying an existing disk is something we do all the time to speed up our deployment times. There are some use-cases where you might want each disk to be unique. Improvements to the speed of our disk-building logic are always being made, but even now we generate the virtual disks for many applications so quickly that it's barely noticeable (often less than 1 second). Treating Vorteil disks as single-use and disposable is painless as a result.
1. GOPATH and good directory structure for applications. I Read/watched a lot about it beforehand, yet it was Slack Community who finally helped me to figure it out correctly. 2. The way how to code idiomatic in Go. This is just so different to the way how I used to work, and I am still piss off on myself that "I know nothing", so for the first time I am not able to design my code upfront, I always have to stick with naive approach and then refactor. Yet after that - the code is so clean and self-explanatory, I just love that ! 
the node code ran on a single core, on a 4 core machine... Still not fair
No. I learned vanilla PHP and vanilla Javascript (no frameworks, no node) in college. This is stuff you have to (in my experience) learn in intership / job or on your own time / in your own projects. That's something I think needs to change about CS degrees. This is important stuff, just as important as having a class on databases, imo.
And it doesn't use dumb-init. That's a newbie mistake.
ICYMI: https://medium.com/@neha/cryptographic-vulnerabilities-in-iota-9a6a9ddc4367 
Not only that but I would argue that if you are to start comparing php to Java, NodeJs and Go, you might need to start looking at libraries that provide the same functionality instead of relying on curl (ffs it's 2017).
Thanks a ton for this! The only reason I've been wanting to go back to school is to "fill the gaps" of my knowledge so this was really exactly what I was looking for.
basically, just the nuances around GOPATH and how the tooling interacts with it (specifically around vendoring).. Took a bit of trial and error to get the source paths/repo setup in a way that I liked that would work with the tooling. As someone who cut his teeth on c/c++ but has spent the last few years in c#.. it was fantastic to not have to write a class for every damn thing you need to implement. That said, I do miss generics from time to time..
Also he’s looking at cpu bound workloads. In many cases workloads are IO bound. Granted Go handles both well where as Node requires you offload cpu bound tasks to other procs.
&gt; The key point here is our programmers are Googlers, they’re not researchers. They’re typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt. – Rob Pike This could explain parts of the anti-intellectual attitudes in GO
It's a fairly large import to bring in if you are not already using it elsewhere. I can't find the reference but there is an article by Pike (I think) that discusses the early on decision to move the ```error``` interface out of ```os``` and into it's own package simply due to the amount of baggage the import adds. 
I think the problem is that it looks like you want to use goroutines like you would threads, but they aren't threads, they are goroutines. Go is really efficient at creating new goroutines, you would probably be better served by spawning off a new goroutine to handle a new unit of work and letting it die afterwards. Have a group of things that can be done in parallel, spawn off a goroutine per item in the group, and let Go handle the scheduling details behind the scenes for you
Yeah, I agree. The only one that really had a fair shot was Go. Node, PHP and Java were all not optimized or were a much older version. He even admits that in the article.
`pwgen`, `apg`, `makepasswd` to name some
You're confused about that. Using a single function from a package only adds that function (and its dependencies) to the binary. `error` is builtin now because with `os.Error`, too many things had to import `os`, and then `os` couldn't import them. Nothing to do with overhead.
As a java/golang guy myself I can see lots of things that could be done differently. Not using servlets but using vertx.io would be the biggest one...
/u/_zombiezen_ 's example works. But perhaps a simpler example like this - https://gobyexample.com/channel-synchronization might be easy for you to understand.
Name of the package should be clear what it contains. Seeing `doz.Str(i)` in code is not clear. For example, if it were `base12.Amer.Int(i)` it would be clear in it's intent. `dozenal` would also be better, however most people don't know what it means without searching. https://github.com/TUSF/doz/blob/master/doz.go#L56 and https://github.com/TUSF/doz/blob/master/doz.go#L84 are confusing in that both functions `Int` and `Str` return a string. Use consistent naming scheme `BigInt`, `Int`, `Int64` depending on what it accepts. For parsing you can use `ParseBigInt`, `ParseInt` etc.
no. it's for go plugins. dynamic lib loading basically.
I went back. The reason? The pay. I was talented but could not get interviews because I did not had a bachelor degree. So I calculated with an hypothetical pay increase it would take me 4 years to get back in the green. Then you get paid way more. It was so much fun because having experience in the field gives you a different point of view when learning. You can go further.
&gt; `dozenal` would also be better, however most people don't know what it means without searching. Might be true. I'll probably change the name to `dozenal` for now though, seeing as dozenal people would rather the `base12` bit be `base10` instead, if you know what I mean. &gt;Use consistent naming scheme Gotcha. Actually, your `base12.Amer.Int(i)` example has me thinking it might be good to have a "Formatter" struct that holds the usable digits and methods. Just have a couple default options. Not sure if it should have a method for each built-in integer type though. `Int64` and `UInt64` should be enough, no?
Worth noting that MIT has video lectures freely available for SICP https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/ My favorite bit is that the implementation of `eval` that is used was engineered to fit on the 5 blackboards they had.
hmm, maybe it's late but I thought that was why you could do VST'S using golang? (or just that it was much more awkward than using C++)
Turns out what I really wanted was "github.com/takama/daemon" for what it's worth to anyone checking this thread
Just for the fun of it, how about adding "colloquial" output? Like 1, 2, 3, 4, 5, half a dozen, 7, 8, 9, 10, 11, a dozen, a baker's dozen, a dozen and two,..., 17, one and a half dozen, 19,..., 23, two dozen, 25,..., 119, a great hundred/a small gross, 121,..., 143, a gross/a square dozen, 145,..., 1727, a large gross/a cubic dozen, 1729,... 
&gt; Might be true. I'll probably change the name to dozenal for now though, seeing as dozenal people would rather the base12 bit be base10 instead, if you know what I mean. I know what you mean. However, one of the questions is about communication. Would people who like `dozenal` system understand what `base12` means or not? Even though they might not like it, I would guess they will still understand it. Your code is still written in decimal notation. So, I would say, meaning of `base12` can be more easily inferred than `dozenal`. (There's prior-art `base32`, `base64`, `base58`). However, when you reach for a dozenal system you probably have a reason and knowledge about it; so `package dozenal` might be fine and clear for the target audience. (There's prior-art `hex`.) &gt; Not sure if it should have a method for each built-in integer type though. Necessary, probably not. I would write it for `int`, `int64`, `*big.Int`... Or if it's always unsigned, then for the corresponding unsigned types. Then later add things as the need arises.
[removed]
I feel you, I often feel it should be far easier to get interviews than it is. Not that it's the hardest thing, just that I'm in a really hot market so I would expect it to be easier.
Disclaimer, I've never used Gin ever but I've heard people say great things about it. &gt; how much slower is it compared to standard libs in terms of performance The answer lies in the [Readme](https://github.com/gin-gonic/gin#benchmarks) and the [detailed benchmarks](https://github.com/gin-gonic/gin/blob/master/BENCHMARKS.md). But really, the performance of a router is minimal compared to the IO (db &amp; network) of your app. &gt; I've done some stuff in the past with the standard libs There's something to be said about learning to do things with the standard library first before you jump into frameworks but it seems that you are already passed that phase. &gt; and are there other things that make it less than a great choice? The only potential "problem" could be that gin has quite a few [dependencies](https://godoc.org/github.com/gin-gonic/gin?import-graph&amp;hide=1). So it's quite a lot of code imported into your project which you might not need. What you should keep in mind is that you are doing a trade off. You gain convenience and productivity while you lose some performance (which doesn't really matter) and ease of maintenance (hard to be proven). So, especially since we are talking about a small/personal project, I think that you should use whatever makes you the most productive/happy. 
&gt; The only potential "problem" could be that gin has quite a few dependencies. So it's quite a lot of code imported into your project which you might not need. Isn't most of that standard lib ?
If you want to get sub-10MiB images, take a look at [upx](https://upx.github.io/). I've made images for Go binaries that are normally 17MiB using the `-s -w` build flags, Alpine and UPX, and have had the image come out at about 9.7MiB. The startup time sacrificed is negligible (~100ms). If you used scratch with UPX and those build flags, you might be looking at an image size of around 2.9MiB for that same 17MiB binary. So, if your binary is smaller without those build flags just using `go build`, it'll be even smaller!
With the flags I'm typically getting between 5-10Mib final size. I'll definetly give it a look as I haven't heard of it before, thanks for the suggestion. Another tool for the belt hopefully! 
Most is the standard lib, and the rest is made by the same developers (apart from grpc, yaml and two others).
What happened to the GUI?
It seems that gin gonic uses a function signature of: func(c *gin.Context) for handlers instead of the standard func(w http.ResponseWriter, r *http.Request) This makes using various libraries trickier.
&gt; I'll probably change the name to dozenal for now though, seeing as dozenal people would rather the base12 bit be base10 instead, if you know what I mean. Within a given programming language, you don't really want those sorts of context changes. Many non-English programmers still program in English, because that fits with the rest of the language community and code better, a far more intrusive agreement than numeric base! While you may write a program that exposes a dozenal-based number experience to the world, you really want to stick to a consistent base within the implementation of that program, and the entire rest of the language and libraries are in base-10, most notably including the fact that including a number constant in the code in the form ONE-ZERO will result in, well, ten. So even within a "I like dozenal and think everyone and everything should use it", `base12` remains the correct thing to call a Go library. By the same logic, if you _did_ have a dozenal-based programming language, the correct name for a library implementing conventional Arabic numerals is `baseX`, not `base10` there either.
It does feel like Gin has a lot of things I would need to import elsewhere and then make them work with the lib I'd end up using. Maybe it's because it's a new framework for me, but I am digging it :) Thank you for the nice and informative reply. 
I took classes on c#, vb.net, php, and js. Then I went full swing into python but restful frameworks sorta soured me. Like Django and the others. They are just so massive. I got fed up with the giant framework errors that were not readable. Then I went to nodejs. It was okay but a giant amount of files but at least it had good tools. Then express was acquired and I got mad again because I figured that was that. I organically traveled to frontend cause of mean stack. Js everything was the rage. I got seriously mad again at all the changes from angular, react, and Vuejs. I was tired and frustrated and felt like I wasted my time. Then I was introduced to go and I never looked back. ~~~~~~~~~~~~~~~~~~~~~~~~ •No framework, •no .net boilerplate code, •no giant unreadable errors, •no big visibility issues, •I can drill down as low as I wanted, •no breaking changes, •no npm •no giant environment •no researching for certain problems with certain versions, with certain frameworks •no relying on my IDE for integrated environment •no borrowing someones project to learn. •no spaces concerns •no paying for environments •no people saying that how you code from 2002 •just low level fun that is mine.
So far Gin works for me, so I'll use it for now on small things and when I come against problems such as that, I think I'll be a lot smarter when it comes to all things Go :) Thanks for the reply, I'll keep that in mind for the future.
Interfaces, structs and how multiple can fulfill the requirements. How to properly use the time library. Going from the much easier to remember YYYY-mm-dd H:i:s to whatever special constants go chose. Interfaces again. Handling errors since in some cases it seems you have to typecast to an error to get the error? --- I mainly come from PHP so i'm used to using the classes and overrides. Learning the Go way 
I would agree that using base10 would be problematic, but I don't see a problem with using dozenal. As a point in support of it as opposed to base12... perhaps it might be interesting for supporters of dozenal math to extend your library to be able to use go generate to process a .doz file with go code written in dozenal, and translate it to a .go file written in decimal? Then you could actually code in dozenal, not just use dozenal in the output of the code. You would obviously need to pass the unicode values for 10 and 11 in to the go generate command, but that shouldn't be a problem, I think? 
gin.Context implements stdlib context, however it only supports keys of type string, whereas stdlib context allows custom types and the go docs even recommend using a custom type for your context keys. As to the whole context cancel thing, that just isn't implemented last time I checked.
&gt; so if it even supports context.Context, I doubt it is well integrated. It 'implements' context.Context but the methods are all just stubs and don't do anything. &gt; This makes using various libraries trickier. There's a [WrapF](https://godoc.org/github.com/gin-gonic/gin#WrapF) function for interop with stdlib handlers.
The fact that any developers/programmers aren't familiar with environment variables just baffles my brain, I know it's true, but I'm still in disbelief. 
This! `sync.Map` is an awesome advert for why generics are needed.
Interesting. Just wondering if this could this be implemented in a DHT?
Ok, so vcli can be found at github, but where is the hearth of it? Kernel sources?
There's also implementation of consistent hashing here: https://github.com/golang/groupcache (which was mentioned here: https://talks.golang.org/2013/oscon-dl.slide#1).
The basic idea is fairly simple: https://twitter.com/mholt6/status/605357512183799808 What do you need with a library?
Yeap, you can. Hash ring can be used to locate bucket for a given key with minimal disruption while adding/removing a bucket
I have to create something like Nginx TCP upstream proxy, but with dynamic backend. My services are deployed to Mesos. I would like to redirect elasticsearch.mydomain to HOSTIP:9300 mysql.mydomain ti HOSTIP:3036 etc
The request is logically immutable (you are not supposed to change it) and passing a pointer is cheaper in required stack space. The response you are supposed to modify heavily and may even replace completely, So a mutated version is a new object to be passed down the chain. You cannot screw it up with mutations if it's passed by value.
If we are replacing our number system with something worse why not have values for every letter of the alphabet as well as the numbers just to complicate it even more?
You could always try using Caddy with its net server type: https://caddyserver.com/docs/net -- essentially a TCP proxy with just a couple lines of config.
Thanks guys. I will check both tomorrow. Too bad Traefik doesn't support TCP. Really good service 
I've been in .NET land for 15 years and there was one way to do config; the Microsoft way, the XML. The only occasions I needed to pay attention to environment variables, were those ones that was related to another tool (JAVA_HOME, ERLANG_HOME, etc and of-course PATH). But other than that, environment variables were not in use when developing apps (with practices such as 12 factors or whatever).
Advice after skimming article: - Read in env vars at runtime, why should I build a new image to change config - No need to expose port in dockerfile - Have your dockerfile build the binary and copy from that stage into your scratch/alpine/minimal runtime image (fetch vendor deps here) - Go doesn't really need makefiles, commands are v simple - Strip binary on build 
Confirmed, this is how we do it. It's an experimental feature and might be a bit paranoid, but we also delete src after build and squash our docker builds so that our source isn't pushed as a layer to a docker repo. The images are smaller that way, too.
ResponseWriter is interface.
Check put Consul 
Write a kubernetes ready service from zero - step by step. Step 1: Write a microservice in any language. Step 2: Define a dockerfile or docker Bezel build rule. If it's a Go microservice, use a bare image. Step 3: Run it on kubernetes.
Alright, I'll give it a look.
It took me some time to check on issues flagged by `goreportcard`. Those issues seem to be with the `goreportcard` tool itself (bugs filed), and not with the `fst` source. Based on this I merged the implemented suggestions into master and tagged v1.0.0. I will not me claiming specific "production" fitness out of liability concerns.
Good points. Regarding the use of a Makefile, they are very useful in a team environment as a form of working documentation. If anything special is needed it goes in the Makefile and doesn't get forgotten. I also find them really useful for CI/CD and use the Makefile targets instead of lots of CI/CD product specific config.
Every implementation of the ring hash I've seen seems to just copy Brad Fitzpatrick's bug you are referencing which ignores hash collisions. Brad's bug is relatively benign because he uses md5, but everyone else 'optimizes' with crc32 or fnv32 and gets hard to find bugs. I even had to write my own to fix it: https://github.com/tinode/chat/blob/master/server/ringhash/ringhash.go
Thank you for the reply. I've learned from it. One thing I think I'll do is get rid of the complex type of migration with up and down. I've researched other migration tools. They use the up or down with the filename: 2016-01-07.up.sql for example. That saves on that difficulty. I will also look at using Maps vs struct or maybe using a map as an intermediate format. This way I can detect the type of the struct after deserializing into a map and then work with the maps later.
I used to be against makefiles for go for the same reason, the standard go tool chain commands are simple. However for building a properly stripped and statically linked binary you need a relatively complex command as compared to just `go build`, especially if you're including a version constant or git hash in the binary. Further it's nice to have `make image` to bake your Docker image with the right tag and push all in one.
I used to be against makefiles for go for the same reason, the standard go tool chain commands are simple. However for building a properly stripped and statically linked binary you need a relatively complex command as compared to just go build, especially if you're including a version constant or git hash in the binary. Further it's nice to have make image to bake your Docker image with the right tag and push all in one.
Envoy supports TCP proxy - https://www.envoyproxy.io/
I originally used Gin in some of my projects too, but now I have switched to [chi](http://github.com/go-chi/chi) and it feels quite natural to use, and most of the available middlewares are compatible with it, so it's more convenient.
I am using a combination of -s -w and upx packer for building my binaries. https://github.com/ipcjk/mlxsh/blob/master/scripts_go/cross_compile.sh
As I understand the "EXPOSE" statement is only a documentation directive, it doesn't have any actual port forwarding functionality behind it, it only shows up in `docker ps -a` output, possibly confusing people (or telling them which port the container listens to, so you can set up port forwarding from there, or just to know it if the container is on a shared network). You might not *need* it, but then again, people don't need many things like unit tests and stuff ;) every bit helps.
Can confirm, PHP is shit in production.
I don't know about a library, but there are several component libraries that would allow you to make a pretty much straigh port of the linked js file; - [pbkdf2](https://godoc.org/golang.org/x/crypto/pbkdf2) - [crypto/sha3](https://godoc.org/golang.org/x/crypto/sha3) for sum256 good luck ? ;)
There was [this gh issue](https://github.com/golang/go/issues/17988) which seems will not be implemented, and there's also [user events](https://github.com/golang/go/issues/16619) which is still open, but it seems to be akin again to manually instrumenting your code with it, but at least you'll have tooling around it when you do? When it's ready.
Writing Go is kinda depressing if you enjoy Lisp, though.. 
i've been going Go for about 6 months now and i still have no idea what channels are or how to use them. not even sure where to start learning them either, [the tour](https://tour.golang.org/concurrency/2) doesn't really make sense to me maybe i'm just dumb, who knows
It is NOT. There are various plugins missing that Webstorm has but Goland doesn't and you can't get them into Goland because they're not available for Goland. 400€/year is the price for IntelliJ Ultimate - all languages all plugins Webstorm 2017.3 can't use the Goland Go plugin because it depends on "Go-Language-Capable". Either you don't know any better, in that case please stop spreading misinforation or you're lying.
Looks nifty, thanks ;)
I am actually one of the maintainers of vim-go. I never use GoLand, I was just curious. So .. Please keep your freaking attitude to yourself please thanks.
&gt; Maybe if you really need a well-known algorithmic container, like a red/black tree (which in my 18 years of development experience has been.. uh, never) Uh... ok. Kids, be careful who you take advice from
Read the 'Signalling' section here: http://nomad.uk.net/articles/interesting-ways-of-using-go-channels.html
&gt; out of liability concerns I think your concerns are misplaced, given that you're using an OSS license that specifically disclaims liability for basically everything that could go wrong. As far as fitness-for-production, the question is really: "has anybody used this in production without problems?"
https://github.com/shopspring/decimal
Any reason why you implemented your own here? From what I've seen in real-life workloads, jump hash is far superior to other available hash rings.
There is a link at the bottom of it to a Gist that has the source of the function that will be added for the purpose in 1.10. You could use that: https://play.golang.org/p/2-m5aR0_3T But more importantly, you should understand what you are asking of the computer, and what tools you need to use to accomplish what you want. Floats are a very particular animal, and you need to spend some time to understand them, what they can and can't represent, and what error is being introduced in your calculations. Blindly rounding (at whatever stage of the calculation you intended to do it) is *not* going to make your answers more correct in general, even though it may seem to help specific cases. If you actually need, for example, precise calculations to a particular number of digits of precision, and you don't want to actually learn about float's limitations and how to track the valid precision through calculations, then you pretty much have to use something much slower than floats. That is after all what floats are, a compromise that allows fast floating point calculations to be implemented in hardware without requiring potentially arbitrary amounts of either time or memory. For many, many purposes they are just fine, giving us fast but approximated answers. For certain particular situations, the error in them can explode dramatically, producing wildly different results than naivety would expect. But we find them useful most of the time nonetheless - running Discrete Fast Fourier transforms on audio data, for example, where the error amounts to tiny differences that do not generally detract from the usability of the result, and where a more exact calculation would take so long as to ruin any hope of achieving real-time performance, or in doing perspective transforms on triangles to render 3D graphics, where we need to do multiple millions of triangles per second. But where precision counts - in financial calculations, particularly, where no-one is happy if all the numbers don't add up in the end, we tend to fall back to something like a Decimal package. For other situations where precision counts, but speed is still required, well, then someone has to sit down and actually work through the calculations with reference to the IEEE standard, and consider how each operation affects the precision of the calculations. Often, this actually involves reworking the math (hey, look, algebra did turn out to be useful in the real world!) to find alternate computations that attain the correct results while moving through a series of calculations that do not disastrously affect the precision. See: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html Also: http://ta.twi.tudelft.nl/users/vuik/wi211/disasters.html 
I think I've said before that part of the reason I can enjoy writing Go is that my toolbelt is full of tools. If I could only have one, Go would not be it. But when I'm writing code professionally, to be honest, when Go stops me from doing something I want to do that is complicated, it's usually a good thing. As for the fact that it annoys me, well, they call it a job and pay me for a reason. I _can_ turn out Haskell code that uses all the bells and whistles and elegantly solves problems with carefully-crafted constructions that implement all kinds of guarantees and implements the solution in terms of a handful of lines that implements the core logic, but it's just not professional for that to be the artifact I leave behind me. But I sure did learn a lot getting to that point, even so. Even with the carefully-chosen, somewhat meager tools of Go, I've managed to find some ways to do many things quite nicely, and without going too crazy on the non-idiomatic stuff.
这次在北京开么，谢大？
&gt;Better performance by handling errors at runtime instead of pawning it off to the compiler Honestly what? How does that make any sense?
The solution, I believe, is to simply pass `t`, not `&amp;t` to Unmarshal. Rationale: You need to pass a pointer to a struct which can take the intended data as a dynamic value in the `interface{}` to Unmarshal. From `pickT`, you return `new(Collection)`, which is such a pointer. But then, you first store it in another interface type (Migration) and then take the pointer *of that*. Meaning, yaml will a) see that it gets passed a pointer and b) try to store the value in the pointee. But the pointee is of interface type (and *that* interface value will then contain the actual struct, but yaml doesn't do this additional redirection). If you instead pass `t` (which has interface type) it will first be converted to `interface{}` and then passed on - so the argument will directly contain a `*Collection`, as intended. The difference here is, that if you convert/assign one interface type to another, it won't get re-wrapped, but the dynamic value in one value will just be transferred to another. But if you store a non-interface type (like a *pointer* to an interface), it will get re-wrapped. It's not easily explained, I'm afraid. You can see the effect here too: https://play.golang.org/p/ia181c_Pwp (note, that Printf also takes an `interface{}`)
You won the Internet Golang problem of the day. That did indeed work. I could have sworn I had that. Thank you.
In Go is -0 equal to +0?
Yes.
This is a package I've been working on in my off time for communicating with the Internet Game Database. While working on a different project, I realized there was no Go package for working with this extensive video game database so I just decided to make one. Through the client, you can retrieve the following information and more: https://imgur.com/ZKgMSHB You can take a look at the full list of what's available [here](https://api.igdb.com/features) and [here](https://igdb.github.io/api/endpoints/). The project was a learning experience so it went through a lot of changes until I was happy with the overall structure of it. If you have any questions or suggestions, please let me know!
Man, waiting that long for every commit would drive me crazy. Ever heard of squashing your commits before pushing?
I fail to see the joy in waiting multiple seconds to make a single commit.
This looks pretty fun. I'm gonna try and keep up. My only wish: Start it sooner! Like now! Haha. I'm scheduling it on my calendar or you should set up a calendar people can subscribe to. 
http://i0.kym-cdn.com/entries/icons/original/000/015/652/230114_908223010.png
Cost/benefit. In those few seconds you're checking for a lot of reasons you might later discover your commit sucked, at which point it's going to cost you more than a few seconds. Of course, I'm so fantastically awesome at programming that my few-seconds-check _never_ catches anything. Ever. I totally never forget to update one of the executables when I change something or forget to document a new function or break a module I wasn't thinking of when I changed something or any of the other things that have happened just today... I MEAN, _could_ have happened just today, if I wasn't so awesome, but totally didn't. You can't prove anything. Just look at this pristine git history. But, you know, you _other_ mortals should probably use something like that.
Most people run the checks before merging a feature branch.
Agreed. It has it's merit, though I'm curious if the same effect could be achieved by using a pre-push hook? *(assuming git has one)* Eg, that way commits aren't as slow, but you still test before giving it to anyone? I know it's less valuable, but clearly if a person complains about the speed of per-commit testing, then compromises will be made *somewhere* - so I'm just trying to discuss a compromise that still safer than just doing tests by hand on the side.
I'm in!
As in math.
Sounds like my kind of excuse to learn Go, looking forward to when it starts!
Math has nothing on https://en.wikipedia.org/wiki/IEEE_754
**IEEE 754** The IEEE Standard for Floating-Point Arithmetic (IEEE 754) is a technical standard for floating-point computation established in 1985 by the Institute of Electrical and Electronics Engineers (IEEE). The standard addressed many problems found in the diverse floating point implementations that made them difficult to use reliably and portably. Many hardware floating point units now use the IEEE 754 standard. The standard defines: arithmetic formats: sets of binary and decimal floating-point data, which consist of finite numbers (including signed zeros and subnormal numbers), infinities, and special "not a number" values (NaNs) interchange formats: encodings (bit strings) that may be used to exchange floating-point data in an efficient and compact form rounding rules: properties to be satisfied when rounding numbers during arithmetic and conversions operations: arithmetic and other operations (such as trigonometric functions) on arithmetic formats exception handling: indications of exceptional conditions (such as division by zero, overflow, etc.) The current version, IEEE 754-2008 published in August 2008, includes nearly all of the original IEEE 754-1985 standard and the IEEE Standard for Radix-Independent Floating-Point Arithmetic (IEEE 854-1987). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Quite the opposite. IEEE754 was free to specify whatever. But it's math where -0 and +0 is always just the same and only one real number.
Exactly, not so curious by the way, it was used during the KSK Key Signing Cerimony, https://www.youtube.com/watch?v=b9j-sfP9GUU
[removed]
I'm enjoying to work with https://gobuffalo.io 
My vote is down for Buffalo, https://gobuffalo.io If you _must_ use a framework, then that's on the better side of them, the development is very active, the Slack channel on Gophers Slack is very helpful and the pace of development is really healthy. On top of those things, Buffalo is built on selected Go packages which are known to be stable, reliable, and follow Go's best practices. I'm not dissing the other existing frameworks, the efforts others put into them are really nice (safe for iris, of course). However, Buffalo's holistic approach to web development seems to be gaining the minds of the gophers. Personally I use gorilla/mux and sqlx whenever I need to write something, but that's because I work exclusively with CLIs and API servers rather than anything client facing. Hope this helps.
I think It's Iris Framework https://github.com/kataras/iris
Thanks for the suggestion, i'll work on it. Meanwhile i added the public key import form a keyring file
Often used for group-level password recovery too.
I'll second that; I spent far longer than I should have settling on Chi.
Author of that framework is a known to be problem child in the community. https://news.ycombinator.com/item?id=11976798 stay far away from it. He bought all his github stars according to a few users.
He also has pawn reddit accounts that he will occasionally post under. Hence the first part by this user. Not to mention, he deletes all critical discussion from GitHub. 
How is goji mux?
Please open an issue on https://youtrack.jetbrains.com/issues/Go and attach your IDE logs that you can obtain via ` Help | Collect and Show Logs in... `, the format of the file that shows up should be with ` logs-*.zip `. Also please attach a screenshot of the above tab but with the first part of the output expanded. This doesn't look like something that can be fixed here. Thank you.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/docker] [Golang Docker time.Sleep behavior](https://www.reddit.com/r/docker/comments/7k3yua/golang_docker_timesleep_behavior/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
sounds like a a buffering issue to me. Docker-compose most likely has some buffering which is only flushed once the program exits.
The kernel is not open source at the moment. But absolutely free and no restrictions. 
Done, thanks
I use a single $GOPATH set to $HOME/go. I then use $HOME/go/src to develop out off. So my package might be in.. $HOME/go/src/gitlab.com/username/packagerepo (I would have probably used ''go get'' to grab a bare repo a created) 
Count me in!! And thank you :D
Not really a framework, but I've loved using httprouter. It's just a mux, but I really never felt like I needed anything else.
What’s your thoughts on sqlx and pop vs the straight sql package? I’ve been using httprouter and sql for the majority of our internal rest/protocol buffer api services. Every time a new one comes up I contemplate using sqlx or pop but never pull the trigger. 
Maybe this will help? https://stackoverflow.com/a/39497651
` sqlx ` provides some pretty good, missing, features compared with ` database/sql `. ` pop ` takes things to a next level but I'm stuck in the habit of writing my own SQL code always so I'm not sure I can go back to that level. httprouter is also a pretty solid choice for the http routing part.
running it as a service so it's available on demand
This may not be applicable to you as it's more of a framework for rest api's than webapps, but I love goa My typical project is a react spa front-end talking to a goa, rest api back-end. https://github.com/goadesign/goa
Prometheus is great, but it isn't for tracing. You might want to take a look at OpenTracing and the Jaeger project.
&gt; The real answer is that you basically never need the same container to hold two different, completely incompatible types (like strings and ints). It just doesn't happen in real code. Brah do you even structs
I think Chi does basically the same things but it didn’t have to transition to using context because it started later. 
Most of those people only run those tests on the final commit of the feature branch. There's *huge* value in making every single commit be good, as opposed to just a good "final state".
Most of those people only run those tests on the final commit of the feature branch. There's *huge* value in making every single commit be good, as opposed to just a good "final state".
This right here!
I have been looking into kallax lately. https://github.com/src-d/go-kallax. It's still new but the idea is nice.
Use single $GOPATH. Arrange your code like so - https://golang.org/doc/code.html#Workspaces
Wow, buffalo seems like the sort of thing go people would usually be 1000% against. I personally don't feel that strongly about it, but I don't really use anything beyond gorilla either. I'll have to try it and see on my next small project.
Yeah ... not really. Sounds like one crazy dev enforcing crazy rules.
/u/everdev, there's a post on /r/docker that may be relevant. Because it's Docker doing the buffering, the solution is going to have to come from that side. AFAIK Go does not buffer outgoing writes to a file (which os.Stdout and os.Stderr start as by default, behind their io.Writer interfaces); if you want that behavior you are expected to wrap bufio in yourself.
Prometheus works by pulling metrics from your services. If you have short-lived services, you can also push metrics to prometheus via a push gateway. 
[This](https://hackr.io/tutorials/learn-golang) will help you in finding community up-voted Go Resources saving your time.
If you’re talking about sending logs somewhere, check out rollbar and sentry
[removed]
https://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html
The question is about a framework. So rather than be unhelpful and say you don't need one, I came to the conclusion, thanks Brian Ketelsen for the talk, that probably it's better to be helpful. So yes, this is the one imho. 
The documentation should be helpful or should be improved if not. Don't make it harder for people to learn, instead make it easier by improving the quality of the existing documentation.
I was just curious about the paper and its usage, so wrote it :)
Sure. But we don't live in utopia, so documentation can't be enough.
Oh wow, haven’t seen XML in like two years in .NET Core world
DI ? Its not explained anyware ?
lol It's dependency injection.
But if the documentation is not good enough to explain what happens then the documentation needs to be fixed. So I don't understand what you hope to achieve here.
All right, i explain in another key - not each person can understand documentation, so they need more detailed explanation.
It's about two years (since late 2015) that I don't write .NET! For me .NET Core is a bit late. I've been there since ~2000 (.NET Beta) and the culture was different in specific ways. And I do not know of the current status of .NET Core. I really liked F# (and C#)! But the development process was frustrating. And now after using Go for about two yeas, I can imagine I would not go for any alternatives that are not providing some of Go's development practices (single binary, gofmt, etc); any time soon.
I'm sorry, I just don't understand what problem you are trying to fix.
https://gobyexample.com has a few
I just recreated a fresh project, in which case it solved this issue 
I've created three separate projects, all have the same error. I've also tried reinstalling. 
I’m guessing he probably wants to see examples of code in use rather than the higher level explanations the documentation provides. I think The Go docs are pretty good but based on programming experience level I can see how some of the documentation could be confusing.
If code examples are needed then the examples offered in the documentation, such as https://godoc.org/encoding/json#pkg-examples should be improved. But it's still part of the documentation and they should be fixed there in that case as that's the first place people go and check to see if there's any example of how to use the said code.
Nah, that's what a squash merge is for :)
I agree, and too boot, our CI server is eon's more powerful than my local machine. It can spin up enormous amounts of CPU power out in AWS and run entire test suites in a multitude of parallel processes to absolutely blaze through tons of tests much, much faster than my single machine can do. I suppose if your project is small, and your tests are extremely fast (or few in number, given the size of the codebase) this could be sane. However, there is absolutely no way the approach scales in a reasonable way to make devs happy to have it included a year from now.
Jump hash gives a more even distribution of keys but has the limitation that you can only add and remove nodes at the "end". If you have 5 nodes and node 2 dies the redistribution won't work. With a ring hash this problem doesn't happen. So, jump hash is more suited for permanent storage systems while a ring hash is more suited to for a dynamic caching system.
:( My first guess was: Ohh, maybe a new Data Integration (DI) Container ... , so it is context dependent. ( http://www.abbreviations.com/DI ) 
Ben Johnson did this for a some stdlib packages. His posts are really good: [https://medium.com/go-walkthrough](https://medium.com/go-walkthrough) He covered: * io * bytes/strings * encoding * strconv * fmt 
Very nice article, but a really small detail really upset me: is it normal in any circles to write a polynomial as `y = ax + bx^2 + c` instead of `y = ax^2 + bx + c`? (It just called my attention, of course it is not wrong by any means)
You might want to submit some pull requests to add documentation then. 
Great use of interfaces. 
thanks
Soo ` map[string]interface{} ` and good luck not getting a panic at runtime. Why not pass a dependency directly, explicit, so that not only the compiler can tell you when something is wrong but also testing can be done easier. And it's not like you won't have a hard dependency on the package you use because you need to assert the type before using it, or risk it and try a cast directly because yolo.
I use a single GOPATH, and I've taken the habit of organizing all my source code into it it. I use dep as a dependency / package management solution and I no complaints. I actually use $Home/code as my GOPATH, since I don't limit my repos to Go, I figured $HOME/go might be a bit odd. I use VSCode as my primary editor for everything these days.
I'd have to agree with /u/dlsniper. Buffalo seems to be the best of the breed out there. However I mostly use Gorilla Mux and a very highly forked version of SqlBoiler for an ORM, although anytime my SQL code get's more complex than "pull this table or view either by ID or in full" I usually write custom stored procedures. There is an prevailing wisdom that you should only use the standard library. I do feel it is mostly complete for a good amount of application needs, especially if you are doing a client side SPA or something with little complexity, I do feel like there is room for and solid use case for a framework like Buffalo. My advice is this, learn the standard library first, then evaluate your framework options. One thing I am big on is how easy and awesome middleware is built around the standard HttpHandler and HttpHandlerFunc, those are sacred, and if a framework breaks those, it better have a compelling use case as to why.
I just started with Go and I like Gin framework. Very easy to start with and good features (like binding JSON). According to their github it’s the fastest restful framework. I have tested a simple endpoint 2 days ago which does write post rescues to MySQL on my local machine and was able to serve 10k requests in 2 seconds 
New to go as well, I use one path $HOME/go and put all apps under src. I use Goland IDE and I love it. 
I watched the webcast on the homepage and this project looks fantastic. Thank you for the suggestion! 
For recreate the Classic Mode, is simple to scaling screen x2 or x4, in order to increase dimension of pixels. For Dithering Mode, is necessary segmentize the screen buffer, get average color of the segment and finallly get the brigthness of the segment. With average color and brightness, you can decide what bitmap or another graphical element puts for represent this segment. Et voilà. Check this: http://no-carrier.com/index.php?/work/processing-textmode-engine/
Congrats to Marc-Antoine and others. Opening an issue over there was a pleasant experience (10/10 would open another issue again).
It would be a good idea to write that somewhere in the readme. I also did not understand what DI meant until I read the example. Later, I noticed that it is listed as one of the topics, but I think it should be more obvious.
[Please no more Java.](http://objology.blogspot.gr/2011/09/one-of-best-bits-of-programming-advice.html)
I've found that this sort of carefulness is exceptionally useful. Improved readability, rationality, and maintainability. This sort of poor OO design wastes a lot of time and money in our industry. It may not be "nice" to hold the line of proper design, but I think it worthwhile.
Check out Instana: http://www.instana.com We provide sensor for monitoring the Go process which ALSO includes a nice SDK for tracing Go applications. We also provide you the ability to correlate your Go Traces with calls to and from Java, Node, Python, Ruby, .NET and PHP. I just had a customer create a Trace which included a SPAN that represented an HTTP proxy server written in Go. The Go Span was included in context between two NodeJS services. 
I find there to be two general rationales for structures. The first being application-level contextualized data which tends to be long-lived, and the second for messaged data which tends to be short-lived. For context types, this might be `srvrContext{DB, Envvar1, Envvar2}` with methods such as `ServeHTTP(http.ResponseWriter, *http.Request)`, and for data models this might be `User{Name, Age}` with little to no methods. If a message structure needs to be operated on, it is useful to do so with functions which can be unit tested using a data-driven approach. For converting types, it is usually better to create funcs like `NewXUserFromUser(User) *libx.User)` where possible. Methods like `T.String()` are a great counter-example to this bias. If a context structure needs to be tested, it is useful to turn to functional testing with little to no data-driven tests (particularly using sub-tests) to cover the available methods from an external/surface standpoint. Though, where reasonable, those methods should be broken down into unit testable functions. It's worth adding that application-level context is simply a name to differentiate from subroutine-level context à la `context.Context`.
How does it know the heap sizes? Is there configuration needed? Looks pretty damn cool to me! I've been trying to debug a memory leak in a hefty app for the last few days and this could be a god send :) Also have you tested it with GCP apps?
Learn `git bisect` and become one of the crazies, then.
It uses pprof (in non-interactive mode) to get heap information. The app bombards the server with requests and records heap dumps throughout. Just install it and make sure the app you plan to test is in your $GOPATH. You can also set it to download the latest version (of the app to test) with go get. As long as the GCP app is written in Go it should work.
Using go maybe, using `-buildmode=plugin` no.
That's a very confusing name for a project!
ill give it a shot on monday! can the app be anywhere in your go directory (gopath) or does it need to be top level?
Thank you! I've only used it with a top level package. A sub level package will work, if it is the package specified (package/path/toplevel/sublevel-pkg ) during the test. If you run into any issues do not hesitate to ping me :). $GOPATH/src of course, this setup is due to the fact that cleo is using go get to download packages.
Not a blog but you might benefit from the book http://gopl.io/
&gt;implying it's big enough or complex enough to need that much documentation. TFW your languages native containers library consists of three short files that amount to about 2.5 useful reusable types overall. (lol no generics)
Not a blog but you might benefit from the book http://gopl.io/
Not a blog but you might benefit from the book http://gopl.io/
Explain?
&gt; Its goal is to provide compact and [fluent](https://en.wikipedia.org/wiki/Fluent_interface) interface to [...] func StartEventsConsumer(context ff.Context) { context.EventBus().Consume("events.topic", func(context ff.Context, event ff.Event) { var payload string event.ReadPayload(&amp;payload) context.Log().Info("Received event '%s'", payload) }) } No thanks, we like programming in Go, and this does not read like good Go.
**Fluent interface** In software engineering, a fluent interface (as first coined by Eric Evans and Martin Fowler) is a method for constructing object oriented APIs, where the readability of the source code is close to that of ordinary written prose. A fluent interface is normally implemented by using method chaining to relay the instruction context of a subsequent call (but a fluent interface entails more than just method chaining ). Generally, the context is defined through the return value of a called method self-referential, where the new context is equivalent to the last context terminated through the return of a void context. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Beware: AVX-512 speed comes at the cost of making the rest of the server slower: https://blog.cloudflare.com/on-the-dangers-of-intels-frequency-scaling/
I don't understand why this sub is being so hostile to newcomers and downvoting this redditor's comments. To me, it seems like they likely have little programming experience to begin with and perhaps the documentation doesn't do enough for them. The documentation is also likely fine for most experienced users. Suggesting that *they* improve the documents isn't helpful at all because they are looking to understand. How can you expect to improve something they don't even understand?
Last time I didn't hold anything back on one of your posts I was down-voted to oblivion. How does this compare to Apache Gatling?
A bit late to the party, but depending on needs beyond simply tracing for microservices alone, you might be interested in https://lightstep.com/product. 
&gt; I don't understand why this sub is being so hostile to newcomers and downvoting this redditor's comments. Me neither. That being said, I did downvote your comment because you too didn't spent time to understand the question nor my reply so it produced a low quality reply. Here's why: &gt; To me, it seems like they likely have little programming experience to begin with and perhaps the documentation doesn't do enough for them. The documentation is also likely fine for most experienced users. Suggesting that they improve the documents isn't helpful at all because they are looking to understand. How can you expect them to improve something they don't even understand? To me the OP's question: &gt; Hello! I wonder is someone created blog with detailed explanation of any Go's std lib unit? If no, i thing about to create this, for anyone who wants to start hacking with Go. reads like this: is there any other documentation resource besides the golang.org/pkg (or godoc.org/-/go/)? If not, I want to create it. Now, if this person is a newbie, it is naive to think that they are capable of producing a good learning resource for others newbies to learn from. I cannot trust that someone that can't comprehend the current documentation / language will produce a correct documentation for it due to their inexperience and the pitfalls that the language has in certain areas. As such, asking them to contribute to the language by adding documentation / examples to the standard library means that they will have the chance to have their content reviewed by a lot more gophers, not to mention some of the best gophers in the world. In turn, having their contribution merged will result in them helping future newbies learn the language better as well as contributing to the language and its community. As for the documentation being fine for most experienced users, then having a newbie coming and saying: "hey, this is something that's not easy to learn" by opening an issue or sending a CL to fix the existing content / add new content is exactly what the Go team has been asking for years now. So yes, instead of wandering off and producing something on their own, they should be encouraged to speak up and contribute to the language.
&gt; utils &gt; models &gt; controllers &gt; routers &gt; repositories [SOLID Go design](https://youtu.be/zzAdEt3xZ1M?t=6m43s). ([Text version](https://dave.cheney.net/2016/08/20/solid-go-design))
Thanks buddy! ;)
&gt; Apache Gatling This reddit can be cruel sometimes. With this being specific to Golang projects, it requires no manual action (additional coding) to get heap information and samples. 
This is a semi-commonly reinvented wheel: - https://github.com/DHowett/ranger - https://github.com/jfbus/httprs The real challenge is getting all the details right, like ETag changing as you're reading chunks. See DHowett/ranger issues and recent commits for more. See also https://talks.golang.org/2013/oscon-dl.slide for a great implementation of something related, and very good ideas about e.g. rounding up to 2MB boundaries.
Go is the same as the standard library of all other languages. They all provide API documentation, most include at least some examples. Go has examples and documentation built in to the tool chain so I think it’s one of the higher quality experiences out there. Quality is relative though so it may come up short at times for people, when it does they just research the problem. For example doing things like writing json to a file just google “go write string to file” for example. That said it sounds like you are interested in writing about Go, so I think you should do just that. But if your looking for feedback on *what* to write about I don’t think any individual package in the stdlib stands out enough to need supplementary coverage. At the API level the documentation is really good. But other than to support the current packages examples, package documentation doesn’t span across multiple packages to solve more general problems. So it can be a bit overwhelming to do something that may be trivial like read xml from a file and write json to another. You are introduced head first into a foreign (but awesome) concept like interfaces by io pkg and marshal interfaces, struct tags, slice caveats and all basic control flow at once. So if you were wanting to write in genuine service to other gophers I believe making testable examples that solve larger problems that may require more than one nuanced stdlib package would be helpful.
thanks for feedback! I thinking about another approach, because it is dangerous to break compiler type check. And I'll write the meaning of DI somewhere in README.
&gt; Now, if this person is a newbie, it is naive to think that they are capable of producing a good learning resource for others newbies to learn from. I cannot trust that someone that can't comprehend the current documentation / language will produce a correct documentation for it due to their inexperience and the pitfalls that the language has in certain areas. Maybe! I don't know what level of detail they are talking about or what they plan to accomplish. Perhaps they want to learn and blog at the same time or want to have a more personal project with a small group of people. Why does it even matter if they are capable of producing a good learning resource? Also, I wouldn't know how to contribute meaningfully if I was a newcomer myself and would find suggestions that I make a CL to improve the documentation pretty intimidating.
&gt; Maybe! I don't know what level of detail they are talking about or what they plan to accomplish. Clearly more than what it is present today in the documentation. Otherwise what would be the point? &gt; Why does it even matter if they are capable of producing a good learning resource? Because that's what the statement says, it's supposed to help people that want to start with Go. If the output of this exercise is bad, then those people would have a bad experience with Go which will do nobody any good. &gt; I wouldn't know how to contribute meaningfully if I was a newcomer myself and would find suggestions that I make a CL to improve the documentation pretty intimidating Have you asked for help on how to do that and not received it?
&gt; Clearly more than what it is present today in the documentation. Otherwise what would be the point? Yes, obviously. I'm saying I don't know how much beyond that. &gt; Because that's what the statement says, it's supposed to help people that want to start with Go. If the output of this exercise is bad, then those people would have a bad experience with Go which will do nobody any good. My point is if this is something they want to do, then let them have at it. Maybe they'll produce something awful and learn from their experience. Who are you to tell them not to even try? &gt; Have you asked for help on how to do that and not received it? I mean, I know how I would go about doing that now. I wouldn't even know how to ask for help when I was learning how to program precisely because people are so hostile toward even the simplest questions. I just don't understand what people downvoting an innocent question think they are accomplishing.
At least Java has generics
lol why are you all downvoting this guy? it's a nice succinct tutorial. Also not super experienced with Go here but the code he uses looks exactly the same as any other go code I've ever seen. What does Java have to do with anything at all? 
what is this even supposed to mean?
Ok but the fact is that Go doesn't have classes or anything like that no matter what so it's not like you can really be that different in any sense regardless lol. 
The linked content does clarify and justify important distinctions. However, it is understandable that many developers would find the nuance, and benefits therein, to be unimportant. Please consider the content of the articles again sometime.
[removed]
Might be good to elaborate on why you would not use web sockets. 
Hello, The Gin-Gonic framework has my seal of approval. I personally chose this option after being misled by Kataras’ Iris claims of performance. Gin uses an adjusted julienschmidt’s httprouter as the backbone. This actually delivers a strong backend performance, complete with HTTP/2 support, as compared with fasthttp, a strong alternative if you simply ‘have to go faster’. As a developer, you should consider if this is the interface (API) you wish to use with julienschmidt’s technology. I currently use httprouter as it comes, in an effort to better appreciate what fits around a routing technology. Design is the process of making a concept (more) useable, simply or otherwise. Do not overlook the requirement of a framework’s design. It’s acceptable if you have a need for performance, but surely people run better with kneecaps? As a community, I’d love for us to explain why we’ve picked our routing solution. For those who need paths to start from: gorillamux seems to be like the basecamp at Mount Everest. Compare benchmarks equally with the framework’s usability. Avoid Iris; poking it gently with a stick is fine.
&gt; Not super experienced with Go here but the code he uses looks exactly the same as any other Go code I've ever seen. And this is exactly the problem. This is just bad code. It is essentially Java with Go syntax. Such no effort articles are harmful because new gophers will see them and think that this is what standard or even good Go code looks like. They are going to learn from this and reproduce it (because we learn by copying). The Go community is growing, while the good learning material is getting harder and harder to find which leads to bureaucracy. It doesn't take a genius to see how problematic this can get down the road.
&gt; It is essentially Java with Go syntax. Exactly this is the problem with a lot of people. "If you know Java you can do C#" - No you fucking can't. Both languages are close to each other and you can successively program what you wanted to accomplish, but you are doing it wrong if you are doing it with 100% Java style and not using C# how it's supposed to. Same thing with a lot of languages. I know Java, C#, PHP, Scala, a lot of other shit. I completely acknowledge that I need to really focus when I'm coding Go, because I can't just use the structure I use in another language and apply it blindly to Go. Even if what I write would work, it's not good enough. If it's not using the language as it's supposed to be used and I never end up learning the right ways to code, there will be problems later on and the code structure won't be optimal -- someone that has programmed with Go for a few years will have problems getting in to the logic of what I've written and them fixing bugs or adding features will be that much more cumbersome. The problem accumulates when someone codes incorrectly and then publishes their code. Like this guy did. Some new people will google "go gin example", get his code and repeat his mistakes. I had a lot of problems learning C# by example when googling stuff and often ending up in a website (something like coding friends csharp or so, was often first hits with google when you looked for answers) where people were providing the wrong ways to do things a lot of times. I think they were Indian programmers and needed to get their name to have hits to proceed with their profession (not trying to be racist or anything, but I know competition in India is a whole lot different than in Western countries) It was really difficult trying to wade out the right ways of doing stuff from all the wrong ways. And the problem was exactly that, the wrong ways work too, in some cases. But the right ways work in all cases. A great example of Javanism or Csharpinism or whatever leaking to Go code is error handling with panic(). You *can* use it as an exception and it totally works too, but holy fuck is that the completely wrong way to do things. And when looking at the right ways to handle error situations with Gin just a few days ago, I found a piece of code that called for c.Abort() and then panic() only to recover at a higher level in code. SMH
Dependency injection can be done without external packages - see e.g. [here](http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/) or [here](https://appliedgo.net/di/). What is the specific use case for this package? (Or, what would be difficult to do without it? What pain point does it address?)
What do you mean by “tutorial”? Good start can be any p2p library and papers on p2p protocols implementations. Worth checking Python Kademlia?
Nice! This also work on windows, at best with Power Shell 6. And with some code changes this is also possible too. ``` pixterm -s 2 -tc 100 -tr 100 my_image.jpg &gt; ansi_image.txt cat ansi_image.txt ``` https://pastebin.com/EmY0Y4pV
&gt; public static &lt;I, O&gt; ListenableFuture&lt;O&gt; chain (ListenableFuture&lt;I&gt; input, Function&lt;? super I, ? extends ListenableFuture&lt;? extends O&gt;&gt; function) [dear god make it stop](https://youtu.be/5kj5ApnhPAE?t=2m12s)
Ha, my comment was discovered by certain pseudo-intellectual circle-jerkers. Those people apparently have reached levels of intellect that are not even possible and which prevent them from comprehending what is wrong with the code above. Ironic.
&gt; Yes, obviously. I'm saying I don't know how much beyond that. This doesn't make any sense whatsoever. &gt; My point is if this is something they want to do, then let them have at it. Maybe they'll produce something awful and learn from their experience. Who are you to tell them not to even try? This is an open thread where anyone can state their opinion. If the author of the thread agrees or not with it, is, unfortunately, not in my control. &gt; I mean, I know how I would go about doing that now. I wouldn't even know how to ask for help when I was learning how to program precisely because people are so hostile toward even the simplest questions. I'm not sure what more can be done to list the places where one can get help from than: https://golang.org/help/ &gt; I just don't understand what people downvoting an innocent question think they are accomplishing. This is not a "simple" question, rarely one is. People downvote things all the time, for various reasons, from low content quality, to questions that have been already asked, or because they just feel like it. This has been discussed plenty of times and now the question seems to be your only anchor point so I'd advise you to search and read more on this. Cheers.
Same feeling, but there is a flag to run the test after file generation. View the commands with `go-test -h`.
rip pager
And yet it's your pseudo-wiseness that does a disservice to the whole Go community. Yours and of the guys who have never used generics and have never missed them. Unironic.
httprouter is enough..
P S E U D O - W I S E N E S S S E U D O - W I S E N E S S 
Beware spying upstream: https://github.com/matthewmueller/joy/issues/67
Beware spying upstream: https://github.com/matthewmueller/joy/issues/67
Note: GPLv3. https://github.com/matthewmueller/joy/issues/60#issuecomment-351919351
Where's the kernel source?
"I am supremely confident will not break anything. " Famous last words. . . I mean the compile time checks are great but I'd knock on wood after making a statement like that.
Come back when you change that..
Looking at this "IOTA" thing, they say the IoT preferred data format is "Trinary/binary, JSON". Really, trinary as a wire format, over the internet?
If you look at [GoBuffalo](https://gobuffalo.io/docs/directory-structure), they have a similar folder structure and it is a widely accepted go framework which many gophers use
As someone at the beginning of their go journey, could you provide any resources that you found to help with learning the go way of doing things beyond the basics?
 &gt; they have a similar folder structure Folder structure is different than package structure. But even if it uses a similar package structure that doesn't mean that you should too. Bufallo is a web framework that attempts to cover the needs for as many people as possible. Unless you are building a web framework as well, this is not a package structure you should use. Write clean and simple code, choose good names, avoid generic, ambiguous names and think twice before using -er objects that are pushed from other languages.
It looks like the link to the Binary format is broken under the "wasm format" section. &gt; The wasm binary format is described here.
Also: [Go Object Oriented Design](https://nathany.com/good/)
Sorry, no. I just played around a bit at start, making myself a simple API with the standard library at first. Didn't follow any guides or anything, just started off with learning how to manipulate data and what are the best ways to do it, when to use references and how errors are handled. I am still by no means anything but a novice, but everyone starts from the bottom ;p My first realer projects were making a load balancer that changed the real endpoint depending on request (important clients to servers with more resources) and then consuming third party webservices, such as sending message to Slack when diskspace was running out etc.
https://i.ytimg.com/vi/9HIlNhuFgb0/hqdefault.jpg
lol image post
I'm not saying the code in this tutorial is perfect, but it can point people in the right direction and give them a starting point. I personally find that folder structure much more readable and easy to maintain, but who knows, I have a background in PHP and Python so maybe I'm biased in that way.
[Here are a few nice links though](https://dave.cheney.net/resources-for-new-go-programmers), Dave Cheney is good at writing things about Go
It would seem they indeed changed a bit the sitemap of their website... The correct link is now: - https://webassembly.github.io/spec/core/binary/index.html Sorry about that.
They're interested, but the 20-40% overhead has been deemed too much.
Go binaries are static by default and I imagine official golang/alpine could probably be used for multistage build? Final note that I would highly suggest staying away from upx in general unless absolutely required. If you do use it curate and test your options or your destined to segfault with brute usage. Basic binary stripping via upx or (safer bet strip &lt;bin&gt;) is going to be safe and give a decent result. In the world of 10tb hard drives I think shaving 20%-50% more of a few mb isn’t worth the risk.
Our team has adopted a style similar to [how DigitalOcean organizes their code](https://blog.digitalocean.com/cthulhu-organizing-go-code-in-a-scalable-repo/), but have modified it a bit to support using `dep`. The root of our monorepo is a `GOPATH` workspace, organized like: src |- company |- service1 |- lib |- vendor Gopkg.toml Gopkg.lock Makefile - All `dep` commands are executed within the `src/company` directory; we have an alias set up on all our developer machines to make this seamless. - The `Makefile` contains all the build steps necessary to build every project. - `service1` and like folders are each vertical project; all of them main packages, most of them web services, some of them cli tools. All of these folders have a `MAINTAINERS` file which contains email addresses of the people to contact for that specific project. - `lib` contains code and resources shared between services, including grpc protos. - `vendor` contains dependencies shared between every project, and it isn't committed to git. There are a few reasons why we've found this to be a good setup: - Monorepos have their downsides, but being able to track every change to our backend in one repo with no additional tooling (aka straight on github) is huge. It also makes our build process easier; no need to worry about our CI systems being authorized to access private repositories for shared code, because everything is in one repo. - Sharing external dependencies can suck, but forcing all of the projects to reference the same dependencies usually makes us better about keeping them and our referencing code up to date. Most of the time, project code which relies on an external dependency is "proxied" through shared code in `lib`, meaning its just a single point of update for every project and we control the APIs our projects use in accessing those external dependencies. - Import paths are shorter; just `company/lib/whatever`. 
Thanks!
Note that `strip &lt;bin&gt;` isn't safe and can cause problems for Go files. The recommended way is to use `go install -ldflags='-s -w'`. As for whether it's worth it, there are more considerations than just disk size; not everyone always has a 300Mbit internet connection, and things can add up quite fast if you have dozens or even hundreds of Go binaries.
I don't know if this is strictly always true. I have found that I sometimes need a CGO_ENABLED=0 to enforce static builds.
&gt; Note that strip &lt;bin&gt; isn't safe and can cause problems for Go files. The recommended way is to use go install -ldflags='-s -w' I would report the problems you are facing because I imagine they are a bug. Go produces elf binaries. They have a standard- nothing special about the implementation of strip in the Go linker other than it's faster because it does not need to shell out to strip an existing object file. Both implementations will strip the elf files section header of dwarf fields and remove symbol information (symtab) which is where a majority of the savings comes from. This doesn't affect stack traces in Go programs because they are stored in a separate symbol table (gosymtab). You can easily test this with something like: go build -ldflags '-s -w' -o s1; go build -o s2 &amp;&amp; strip s2 diff -y &lt;(readelf -a s1) &lt;(readelf -a s2) du -b s1 s2 ./s1; ./s2; # works fine go build -o s3 &amp;&amp; upx --brute ./s3 # I've never seen this work, only segfault for even a basic println. The data will more or less be the same, though strip may save a small bit of data through more sophisticated restructuring, but it's output should always be legal. On the other hand UPX is much more aggressive and can do things like change the entry address of the program which is not legal for a Go program. Which is why I warned against it. &gt; As for whether it's worth it, there are more considerations than just disk size; not everyone always has a 300Mbit internet connection, and things can add up quite fast if you have dozens or even hundreds of Go binaries. I can't say for certain that a group of people out their are not facing productivity issues due to network connectivity, and are only being saved by shaving 30-40% off their "hundreds" of Go binaries. I can say for certain I do not believe most Go developers are part of this group.
It's definitely the default, it just can't be strictly *honored* for all builds.
Kelsey Hightower has written about this topic in the past: https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07 Take a look at how cert bundles are being included, did you try your example with any SSL calls?
I'd say [Go By Example](https://gobyexample.com/) is pretty damn good. (Or that's what got me up to speed rather quickly, when I first started playing around with Go).
Your question is quite general. There's a lot of topics here. There are file sharing programs, distributed databases, concurrency control, distributed consensus, and a bunch of other things. What are you interested in? I'm generally interested in stuff in this area. What do you want to do?
abso-freaking-lutely starred!
Awwww - That's super sweet of you to say it. Thank you so much! 
The joke doesn't really work as well in my experience, as focus on good error messages has improved since C/C++.
Please link to the [original code](https://github.com/gonum/gonum/blob/ad5995341f50f70b5f9667a5409d7c1d1005ab14/floats/floats.go#L623-L649) when you post. Also note that [there are problems](https://www.cockroachlabs.com/blog/rounding-implementations-in-go/) with this code, and worse, it's not what you really want here. You should read [this](http://perso.ens-lyon.fr/jean-michel.muller/goldberg.pdf).
This. I read that you need the certs, so people use alpine and install cacerts. 
If you use a 2-stage build process with Alpine or the Golang image as a base you should be able to copy /etc/ssl/certs/ca-certificates.crt from the first container to the second: COPY --from=0 /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt 
I disliked the r/ProgrammerHumor post. Honestly, understanding pointers only takes a couple of minutes, and anyone who is a career programmer should be able to explain them, along with other memory-management basics easily. With that said, newer languages like Go tend to look at what struggles programmers have had with past languages, and try to remedy those issues.
hey, I want to learn About distributed systems. Where should I start? I have read some stuff on libp2p website but I want to learn more.
You can also use nats.io 
gRPC works good. Although be aware of handling errors properly, especially for streaming endpoints.
gRPC works good. Although be aware of handling errors properly, especially for streaming endpoints.
I really like the idea. Without playing around with this much I wonder what is stopping the proposal of this change to be implemented in the core package? Will tracking of the paths and similar cause a drop in performance? For my use-cases it doesn't matter but it would be nice to see this land in the core package instead. Great project nonetheless! 
Just added support for .ass/.ssa subtitles. You can still manipulate .srt, .ttml, .vtt, .stl, etc. and do parsing, writing, syncing, fragmenting, unfragmenting and merging. Support for Teletext coming soon.
Of course, you can. But nats isn't the best option for RPC communication. It fits better when you're building event-based system. 
Thank you so much for saying that! :) First of all, We'd be really happy to donate this to core! Secondly, For most use cases, the performance drop is so minuscule that it can be ignored. Finally, We'll be benchmarking this and posting results soon! 
The best option depends on your specific needs. Do you want message queues? Brokerless (nanomsg/Mango) or with brokers (NATS)? Do you want a full microservice framework (go-kit, go-micro), or just the communication part (gRPC)? Is your main problem the right serialization format (gob, protobuf, flatbuffers)? Do you have to integrate with other languages (gRPC vs pure-Go net/rpc)? Are the microservices in the same LAN, or do they need to communicate across the internet (that is, are authentication and wire encryption included, and does the protocol require open ports other than HTTP(S))? Does the library have to implement specific communication topologies (pub-sub, bus, pipeline,...)? Etc...
I'm a huge fan of [nanomsg](http://nanomsg.org/). There's a [pure Go](https://github.com/go-mangos/mangos) implementation available.
Right. But the question wasn't about RPC. It was about bidirectional communication beween microservices, and that is what we are using nats.io for :-)
`strip` not always working is somewhere in the FAQ, or something rsc (or someone else "of authority") has said. I forgot the details, but it's a known issue, and I believe there are no efforts to fix it right now.
For progress - look at this: https://play.golang.org/p/N6xL8_fnV2 As for the time - I'm not sure about the creation time, but [os.Chtimes](https://golang.org/pkg/os/#Chtimes) could help with the modification date...
This gives me an idea for automatically syncing subtitles to a video. How hard would it be to sync an existing subtitle file to a movie? Assuming the subtitles are for the same version of the movie but is slightly out of sync from the start? We’d have to check audio for voice text and check where it begins... and now I realise that this won’t work for different languages when text is on screen etc... :/ /rant?
So there is no way to move file simply right? I mean I must use copy to transfer file to another drive, and now to transform date to workaround it, right?
I'd like to add https://twitter.com/rob_pike/status/942528032887029760 from one of the creators of Go, Rob Pike on traditional OOP in Go. I think it's worth focusing on learning the ideas behind the language before bringing in what you already know from other languages. A full cup, and all that. :-)
You might be looking for [os.Rename](https://golang.org/pkg/os/#Rename)?
This is actually a good idea. The hard part would be to get the delay between the text and the audio but once you have it, you can use the `.Add()` function to sync the subtitles.
But it cannot rename on different drives
Well most of the time I have problems finding subtitles when existing tools don't find any at all that fit. Then I have to manually download a bunch that seem to sync well. Would be neat if I could just any one of them and that it would sync them in a pinch. Well, I've got finals atm so I don't have any time for it :p
I usually see the latter of your examples. When you get further into linear algebra you see a lotta weirdness and every convention goes out the window when you get to decomposition. This thing irked me: 598824.2200000001 USD
I know I’m probably risking a flame war here but I’d first see if I cannot eliminate bidirectional communication in the first place by turning to more reactive architecture as it’d reduce coupling. I often see request-response where systems are divided by implementation-specific function (e.g. caching, email) rather than by bounded contexts (ordering, stock management). 
Yeah, the io.Writer interface strains a bit here. I won't call it _broken_, but there are some io.Writers that require special handling around closing and/or flushing in a way not represented in an io.Writer. gzip and base64 are another two examples of such things. Usually the outer-most handler can handle it, but I find if you want to write a _maximally_ generic io.Writer wrapper you have some more work to do to pass through Close _iff_ the wrapped value is an io.Closer, Flush _iff_ the wrapped value implements it, and whoknows, maybe a couple of others, I can't guarantee that's enough.
I see, perhaps if you remember where you saw such a thing you could share, until then I’ll go with the empirical facts I listed. I did find [this](https://dominik.honnef.co/posts/2016/10/go-and-strip/) though when typing “golang faq strip rsc” which seems to explain why some people believe it’s broken. Anyways no big deal really it’s a pretty trivial matter I just wanted to prevent people from using upx as mentioned by the poster. 
Oh yeah. sure. So you're correct, you should perform a copy and then update whatever m-times and such if you need to. I asumed that the stdlib would be equivalent to `mv file file2`, but it isn't as it's basically just the rename syscall.
Language communities form their own terminology, so Go has "pointers", because that's what the Go standard says. I don't fight community's terminology because that's an uphill battle. But as I know quite a few languages, I also have a sort of generalized terminology I use. Nobody else uses it, because the vast majority of programmers seem to find one community they like and then mistake their chosen community's vocabulary as the One True Computer Science Vocabulary. But in my personal terminology that I use in my head, the difference between a Pointer and a Reference is that you can do arithmetic on a pointer. That is the key attribute that makes them so hard to understand, and such a security and quality catastrophe. In my terminology, what Go has are only _references_. You can pass a "reference" to a function, but it isn't allowed (modulo `unsafe`) to then start rooting around in memory with that pointer; it can only get at the referenced object. This is much easier to deal with. You'll also find that because of this, it is fairly rare in Go to have a double-pointer, since in C/C++ the double pointer is usually so a function can perform pointer arithmetic on the referenced pointer, and I've never seen or written a triple pointer in Go, whereas you will definitely encounter them in C. (C++, it depends on how "idiomatic" it is; idiomatic modern C++ has little use for a triple pointer (at least, one that is user-visible as a literal `***` in the type system), but older code may have it, and you may always have some crazy guy doing crazy things in the system "because it's faster than STL" or something.) Consequently, no, there really isn't an equivalent in Go, because Go pointers lack the essential elements of complexity that confuse people in C/C++. (You don't have to use my personal terminology, or even think it's got a hold of the correct/best distinction... but you _should_ understand that "C pointers" and "Go pointers" are very different beasts.)
And that is sad story... Anyway tnx for reply
It's depressing that the relentless mediocrity of Go's default JSON decoder renders this necessary, but boy am I ever grateful you've done it! Kudos, and many thanks.
That's what most copy utilities are going to do anyway: create a new file and update the timestamps. 
&gt; If you do use it curate and test your options or your destined to segfault with brute usage. I had a really difficult time passing this sentence. I'm guessing you were saying: &gt; If you do use it, curate and test your options or you're destined to segfault with brute usage.
Terminal progress bar for Go: https://github.com/cheggaaa/pb
I use gvm to manipulate different versions of go and different environments for each project: https://github.com/moovweb/gvm
This is really cool. I just started using Plex and found out that its subtitle support is abysmal. That piqued my curiosity about how subtitles were implemented.
Ya, [Traefik](https://github.com/containous/traefik/blob/master/Dockerfile) does this, though they have the certs versioned in the repo, the approach is pretty much the same anyway. ``` FROM scratch COPY script/ca-certificates.crt /etc/ssl/certs/ COPY dist/traefik / EXPOSE 80 ENTRYPOINT ["/traefik"] ```
I can't stress how important this is. By coupling all services with direct messaging you essentially build a distributed monolith. This is very very hard to pull off. Should you decide to go this way, please take a look at https://github.com/istio/istio as this will reduce the work load of this approach. I can't stress how important tracing is in this world. you could however instead let each service cache the data they need from other services in their own little database, this gives you true resilience and decoupling. If you one up that idea and go on event sourcing and a persistent queue, for instance kafka with no retention on data, secret doors will unlock! ;) On a more serious note, seriously. Look up Event Sourcing, CQRS and Kafka before distributing your monolith. Have a nice day! :)
Hmm that’s giving me a 404
I don't think this has anything to do with io.Writer per say. The zip.Writer is technically an io.WriteCloser and the Writer.Close method documents that "Close finishes writing the zip file by writing the central directory". When dealing with file formats, it's important to note that many formats actually have a footer of some kind, so calling Close before extracting the bytes out of the underlying io.Writer is necessary.
This bit was total news to me: &gt;Any concrete type can have methods: ints, bools, slices, even funcs
I used that ton of files in the gitignore solution. Or rather, I only add a few files to the project ever. I never use "git add ." when working in Go. I also normally avoid creating packages for a project I'm the only one working on, I don't need the namespacing when I have full control over who tramples over who. Fighting $GOPATH is pretty painful. I fully recommend making your IDE conform to having the projects be in the gopath.
&gt; and my VSCode project wasn't in my Go SRC folder You could open VSCode on `$GOPATH/src/github.com/deranjer/goTorrent`.
Go pointer syntax is more confusing than in C/C++ because of Go's decision to adopt "C statements but Pascal declarations" without changing the unary symbols used. When we read *A //pointer to type A *a //that pointed to by variable a &amp;a //pointer to variable a whenever we see a unary `*`, we must ask ourselves whether what follows is a variable or type. If it's a type, `*` means "pointer to", otherwise it means the opposite, i.e. "that pointed to by". Perhaps Go should have used `&amp;` instead of `*` in type declarations, i.e. &amp;A //pointer to type A to be more consistent and thus readable for newcomers. But it's too late to change it now. 
I got it
Maybe it’s just Apollo 
I only skimmed, so I'm not sure if he elaborates, but you have to create a new type first. You can't just `func (i int) String() {...}` and expect it to work. You must first declare a new type: `type Int int` and then `func (i Int) String() {...}`. Same with all the others in the list.
[removed]
Brother, I BEEN manipulating ass.
It started as a port of LMDB, so I suggest that you look into the literature https://symas.com/lmdb/technical/#pubs
&gt; I’d first see if I cannot eliminate bidirectional communication in the first place I agree 💯
Well, that's disappointing.
Yeah, generally the rule is "You can't declare methods on types defined outside of your package", which makes sense otherwise you could end up depending on two libraries that both try to define int.String().
Hello, Ruby on Rails.
[lol](https://www.reddit.com/r/programming/comments/7kfc7c/object_oriented_go_the_basics/)
&gt; once again I find myself wondering why anyone would ever actively choose to use Go. It's just such a primitive, limited language. You might as well just use C instead, they're almost the same thing. [Go at Google: Language Design in the Service of Software Engineering](https://talks.golang.org/2012/splash.article)
Don't fight the $GOPATH. Work with it. 
Thanks, I figured that would have to be my solution. For some reason I was nervous about messing around directly in the SRC folder, but fighting $GOPATH is just too much work.
This is extremely profound. You have opened my eyes.
I did a meetup talk about the big picture, it doesn't explain the low-level details but I tried to explain *why* things are the way they are. It might help. http://eagain.net/talks/go-nuts-and-bolts/ I do have a walkthrough of some code *using* Bolt, intended as a way to bootstrap understanding of Bolt and FUSE: http://eagain.net/talks/bolt-mount/ Apart from those, if you have any specific questions, maybe try asking those instead? I don't think there exists any full write-up of the file format or such.
I'd be surprised too, but it would be a fantastic topic.
[removed]
FYI, BoltDB (https://github.com/boltdb/bolt) is no longer maintained. The community started a new project called bbolt: https://github.com/coreos/bbolt
&gt; Should use gRPC for speed and serialiced communcation, or use RabbitMQ (AMQP) to make data transport orchestration asynchronously and redundantly. This is exactly the point. Different approaches/architectures serve different goals. You name four aspects here: Speed, data serialization support, asynchronous vs synchronous communication, and redundance (of data transport). [This post](https://www.reddit.com/r/golang/comments/7dx6pp/ask_golang_how_are_you_writing_your_microservices/) shows how widepread the answers can be when asking about implementing microservices. If I had to decide about the technology stack for a startup, I would probably create a few quick&amp;dirty prototypes for each of the candidate technologies, to get a feel for each of them and to evaluate how well each one meets the requirements.
Your GOPATH can be multiple directories, with the first in the list being the location where code is downloaded to. So if you wanted, you could set your `GOPATH=~/internet-go:~/my-source-code` to keep `~/my-source-code` as a directory limited to just your personal projects, and `~/internet-go` as the directory where everything gets downloaded to.
Undoubtedly the best possible comment regarding this topic :D
Too bad you didn't comment on the [reddit thread](https://redd.it/7e7a6b) about my project named [go-astits](https://github.com/asticode/go-astits) :D
Too bad you didn't comment on the [reddit thread](https://redd.it/7e7a6b) about my project named [go-astits](https://github.com/asticode/go-astits) :D
GOPATH is ultimately going to go away (or significantly change; ie not require projects be inside it), which is the end game for 'dep'. For now, live with it (eg. GOPATH per project, or nest your solution inside it). 
Not sure I fully understood your problem. Here is some input that may help you. You should consider using [this](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) go project organization. That is the one I use for a big application I'm developping. I split it in packages which is more convenient for tests and stepwise development. So in my ~/go/src directory, I have a directory named myApp with its main.go file. In that directory I have subdirectories for the packages. I do keep everything under GOPATH because go tools rely on that. 
sounds like a job for justforfunc
Some libs: blas, GoLearn, Gorgonia, TensorFlow
For code generation there is ``//go:generate` already, if you look into the tools like `gofmt` there is already code for manipulating the ASTs/etc. If you look into tooling such as `grpc` you will see that generating stubs from simplified representations *in order to speed up the initial development* is already a common paradigm.
it's not a good idea.. it takes more time to write that tool than to learn Go syntax which is quite easy and predictable.. 
No, BoltDB is still maintained, but only for bug fixing. It is just no new features.
Spend your time learning and practicing the syntax. Once you've mastered it, you'll be glad you did. It's a really expressive and readable syntax and I now prefer it over more traditional c-style formatting.
Citation needed.
Thank you for adding this. It bugs me when people act like the project is dead just because the creator decided it has accomplished the goals it set out to accomplish and no longer needs new features.
Use Java if you want to use Java; Go is not Java, and trying to make it behave as such is not really a good idea.
I see. Now that I think about, if I had spend as much time researching about the Go syntax than researching this, I would already have good grasp of the syntax. Too much coffee I guess.
I wouldn't say, this is a bad idea in general. It might not be useful to anyone (including yourself), but might be a great little project to learn something about go and precompilers. Just take it as an exercise.
Well, here you go then -&gt; https://github.com/golang/dep/wiki/Roadmap (hint: control-F GOPATH)
https://www.reddit.com/r/golang/comments/7h02zn/whats_the_point_of_gopath/dqn6p4k/
&gt;Is it a good idea? No. This is a very bad idea.
Came here to post this link. I've read this book and it's fantastic. I don't think any blog post can possibly get to the level of detail, and include the amount of examples and exercises, to do learning Go justice.
+ `gonum`
Return a non-nil error value.
Pinging /u/sbinet
Faktory is one. It's not as mature as sidekiq but is built by same person who created sidekiq. https://github.com/contribsys/faktory https://github.com/contribsys/faktory_worker_go
You should probably wrap the DB error rather than hiding what actually happened. Also, don't defer closing the database until you know it opened without an error. So: db, err := InitDb() if err != nil { return fmt.Errorf("post creation failed: %v", err) } defer db.Close() https://blog.golang.org/error-handling-and-go Similarly for the second part, and removing the unnecessary else clause: // Create a new post err := db.Create(&amp;Post{Title: title, Content: content}).Error if err != nil { return fmt.Errorf("post creation failed: %v", err) } return nil &gt; But I was wondering if this can be written in a way where I can discard the return value. I don't think I understand what you're asking for. Discard which return value? The error value returned? That's what tells you what actually happened, so why would you want to discard it?
I don't think you should use it, but I do think writing compilers, parsers, etc is a very good academic challenge, and writing one would probably be a fun experience. By the time you're done, you'll know the Go way to do things. ;) @Loves_Portishead mentioned go generate, and that could be a way to call your tool.
If you don't want to have error handling all over the place, I can recommend this talk: https://youtu.be/1B71SL6Y0kA It demonstrates using lifting from the functional world to reduce clutter. Takes a bit getting used to, but can make things a lot nicer IMO. Apart from that, the is no "throwing" of errors like in Java, you just handle them or pass them on as-is or wrapped.
Go Buffalo is a smooth transition for folks already familiar with Ruby on Rails.
Interesting, I'm will keep it simple for now, I'm creating a laboratory to test the scheme that I created, and decide where I should apply each technology Thank for you comment, have a good day :)
Can you explain it to me? I'm watching some podcasts on the http package, but I still haven't gotten to the point where I understand the right use of websocket vs api query. (side note, know any good podcasts for Go?)
[removed]
The dB.Create() method has an additional property(not sure what it’s called) you can access ‘Error’. So I can do err := dB.Create.Error if i want the error or just dB.Create if I don’t. How does that work?
Could you please elaborate on that?
Oh, I see. You can put an underscore in the appropriate place to ignore any return value you don't want. For example, if a function returns (int, error) but you only want the error, you might do `_, err := fn()` instead of `x, err := fn()`
In the README, he says: &gt; "even simple changes require hours and hours of careful testing and validation. Unfortunately I no longer have the time or energy to continue this work. ... I feel that leaving it in its current state is the most prudent course of action." If he wants to claim that the project isn't dead, it might be helpful to reword the README to that effect and who is maintaining it. It sounds like he doesn't want to maintain it and instead links to bbolt which is actively maintained.
I rewrote some of your code and added comments explaining. // A function to create a new post func CreatePost(title string, content string) error { // Open a db connection and check errors db, err := InitDb() if err != nil { // use errors.Wrap to wrap the error with a useful message return errors.Wrap(err, "post creation failed") } // defer after you have checked for errors opening the database defer db.Close() // Migrate the schema db.AutoMigrate(&amp;Post{}) // Create a new post // reuse err variable err = db.Create(&amp;Post{Title: title, Content: content}).Error if err != nil { return errors.Wrap(err, "post creation failed") } return nil }
Any suggestions on how I should handles errors in a function that returns a boolean? Is this a bad idea: // Given a email check if user exists! func DoesUserExist() (bool, error) { // Open a db connection db, dbErr := InitDb() defer db.Close() if dbErr != nil { return false, errors.New("db initialization failed during user existence check") } // Check if user table exists var user User if db.HasTable(user) { return true, nil } else { return false, nil } }
Why do you keep doing `InitDb()` in all of your functions? Initialization and dependency injection should ideally happen once when your program starts. Some tips: * Read: [Practical Persistence in Go: Organising Database Access](http://www.alexedwards.net/blog/organising-database-access) * Use defer after you have checked for error. * No need to name each `err` variable differently unless you are shadowing it. * To check for error shadowing use `go vet -shadow` or [`gometalinter`](https://github.com/alecthomas/gometalinter). Use the ["happy path"](https://github.com/golang/go/wiki/CodeReviewComments#indent-error-flow): if db.HasTable(user) { return true, nil } return false, nil 
Why do you keep doing `InitDb()` in all of your functions? Initialization and dependency injection should ideally happen once when your program starts. Some tips: * Read: [Practical Persistence in Go: Organising Database Access](http://www.alexedwards.net/blog/organising-database-access) * Use defer after you have checked for error. * No need to name each `err` variable differently unless you are shadowing it. * To check for error shadowing use `go vet -shadow` or [`gometalinter`](https://github.com/alecthomas/gometalinter). Use the ["happy path"](https://github.com/golang/go/wiki/CodeReviewComments#indent-error-flow): if db.HasTable(user) { return true, nil } return false, nil 
&gt;Go is the future for doing data science. Big, if true.
Thanks for the suggestion, I was thinking about the reinitiaztion of the db as well. My InitDb is defined like this: package database import ( "github.com/jinzhu/gorm" "errors" ) func InitDb() (*gorm.DB, error){ // Opening db db, err := gorm.Open("sqlite3", "./data.db") // Error if err != nil { return nil, errors.New("failed to open/create db") } return db, nil } Should I do it this way: // Given a email check if user exists! func DoesUserExist(db *gorm.DB) (bool) { defer db.Close() // Check if user table exists var user User if db.HasTable(user) { return true } return false, nil } And then in my main: package main import ( "twain/database" ) func main() { // Open a db connection and check for any errors db, err := InitDb() if err != nil { fmt.Errorf("db initialization failed: %v", err) } defer db.Close() doesExist := DoesUserExist(db) print("User exists: ", doesExist) }
What are the differences between this tool and [`impl`](https://github.com/josharian/impl)?
I really don't give a fuck
I don't know where you're getting your numbers from. Probably out of your ass. It's even worse. It's 649€/year for ultimate. And I don't need help. It's you who needs help if you believe that anyone if going to fall for your blatant money grab. You are disgusting.
This is much better yes but I would go one step further. Wrap `*gorm.DB` in your own type and define methods to it: type DB struct { orm *gorm.DB } // NewDB should be called when program starts. Caller is // responsible for closing. func NewDB(driver, dataSource string) (*DB, error) { // call InitDB here } func (db *DB) UserExists(email string) bool { ... } This has the big advantage of abstracting the database code. If in the future you decide that you want to get rid of Gorm and use `database/sql`, the structure of your program will stay exactly the same and you only have to change the internals: type DB struct { db *sql.DB } Another big advantage is that you can use the power of interfaces to make your code more flexible and testable. For example if you write a function that needs to check if a user exists, you can define a "throwaway" interface ([in the consumer not the producer!](https://github.com/golang/go/wiki/CodeReviewComments#interfaces)): type UserExister interface{ UserExists() bool } And use that as an argument in your function: func Foo(ue UserExister) { // call ue.UserExists() } And the real magic happens when you pass your own type DB (which can have dozens of other methods) to Foo because it satisfies the throwaway interface implicitly: func main() { db, err := NewDB("sqlite3", "./data.db") if err != nil { log.Errorf("db initialization failed: %v", err) } defer db.Close() Foo(db) // Works because db satisfies UserExister } This has the additional advantage of reducing tight coupling between packages. Suggested material:[ SOLID Go Design](https://dave.cheney.net/2016/08/20/solid-go-design)
Yes. I did most of my commercial deep learning work in Go. The ability to send your clients a single executable that compiles in seconds is most useful.
Well, let's make it true
If you find a bug, it's highly likely to get fixed. Worst case scenario, you can literally pay me to fix it ;)
I do not work for JetBrains, not sure how else I can make it more clear.
The implementations produced by `stubber` are really only intended to be used for testing, and they effectively allow their implementations to be rewritten at runtime by specifying a new function value. This means that a single stubbed implementation can be shared across any number of tests, with each test defining its own behavior for stubbed resources.
Looks similar to [github.com/maxbrunsfeld/counterfeiter](https://github.com/maxbrunsfeld/counterfeiter) which provides some default functionality
Well, in general your HasTable method will also possibly return an error value, so you'll need to deal with that. I'd be inclined to have a variable for the boolean you're going to return, and initialize it to whatever you want the fail case to be (say, false). Then all your return statements are either `return result, nil` or `return result, fmt.Errorf(...)`. And again, don't defer db.Close() until you know it's open. For some databases, closing a closed database will cause an error which may obscure the details of what actually happened.
There are certainly some similarities. The biggest difference is simplicity; `counterfeiter` looks like it provides a number of tools that you would also find in tools like rspec, notably assertions on things like how many times a method is called, and what it was called with. `stubber` isn't designed for those cases, but instead provides the simplest possible API for tests that want to stub out resource calls in the context of a higher-level test.
And this is a really bad answer. Because you're being dogmatic by not giving any rationale for it (this is particularly bad since OP is clearly a beginner).
func whatever() error { err := doThing() if err != nil { return err } return nil } Contrived and typed on phone, but hopefully that helps.
Hi, everyone! As explained in the readme and accompanying article, this toolkit is very much based on Helm and Draft, and tries to be a starting point for people wanting to write a tool that connects to a Kubernetes cluster. Would really appreciate any feedback you have on the idea, here or as issues in the repo, and am glad to answer any questions you might have. Thanks, Radu M
Is Go really suitable for doing data science though?
Yep, single binary, static typing, excellent parallelism primitives and it's lightweight (looking at u, `jvm`) — the list goes on and on :)
Alternatively: `interface{}`
Sure. But... Why?
Does it perform as well as numpy and other solutions with SIMD instructions baked in?
errors.wrap of nil is nil, so the last few lines can just be err = db.Create(&amp;Post{Title: title, Content: content}).Error return errors.Wrap(err, "post creation failed") 
Hey you should take a look at my Jennifer package for code generation - might make some of your code a bit simpler: https://github.com/dave/jennifer
Hello there! I'm the author of the blog article. I agree with you - `interface{}` solves most of the use cases, and if it works for your use case, that is exactly what you should use. The only case which made me explore past this model was when I had to change the type signature of a compiled Type, while writing a Debugger. Additionally, this also helped me while writing a Foreign Function Interface. I hope the material can help others who are in a similar situation.
Is there any kind of gpu support out there yet?
Yes, Gonum has assembly implementations of the common math operations. Numpy is still a much more mature lib than Gonum. But the gap is getting smaller, so start using and give more feedback !
Hmm, can't you achieve the same result with the equally disgusting but slightly more safe reflection? I think reflection and unsafe are probably the only ways for this. Possibly code generation.
I spent a lot of time trying this, and unfortunately Type Signatures cannot be changed in runtime with reflection. No matter how disgusting the code
Title seems to be a bit misleading. Direct from the description of https://github.com/envkey/envkeygo: `EnvKey's official Go client library` This is not the implementation and from what I can tell that appears to be proprietary and hosted by someone or a company. I would not trust my secrets with it when something like HashiCorp's Vault exists (which is also written in Go if that matters)
Disclaimer: I do not know from first hand use I was told by a data science person at a recent Go meetup that Gorgonia did/does do GPU acceleration. He also said that it was a little broken at the moment, but he expected it would be fixed soon
Hmm yeah I believe you. Did you try code generation?
Well, I have used `go generate` along with go templating. I didn't think it would help here, because code generation and type inference is done at compile time. On that note, I've written a JIT in Go - which is code generation in its truest sense, but not something supported by Golang unless you do unsafe magic. If that's something you'd like to hear more about, I can share the details.
Sorry, didn't mean to mislead! Like 1Password, it's a hosted service, but the open source app and client libraries provide end-to-end encryption and do not trust the server. Hashicorp Vault is excellent, but takes a lot of effort to setup and integrate. EnvKey is designed as a lighter-weight alternative that can be integrated quickly and without needing devops expertise. 
Interesting. Any thoughts on using something like this vs a message queue like rabbitmq for similar tasks?
I would
I was just wondering if there is a solution that doesn't include unsafe but there doesn't seem to be. &gt; If that's something you'd like to hear more about, I can share the details. Honestly it doesn't personally interest me all that much but I am pretty sure it will make for a very interesting next article that many people will find useful.
I'm writing one about 'Creating Objects from Type Signatures in Golang' currently, I can write about JIT after that. Expect it in 2 days.
Oh thanks! I'll write about it as soon as I can and share it here.
Try using a json.NewEncoder(), which you can stream into, rather than your 1-shot Marshal(), and try having one go routine read the results and encode them and the other copy the encoded output to w. PS io.Copy(w, bytes.NewReader(data) is a complicated way of doing w.Write(data)
...he said, and created [Gorgonia](https://github.com/gorgonia/gorgonia).
For starters, regular expressions like shown in these examples might look incomprehensible, but in fact they are composed from a few basic rules. I did an [introduction to regular expressions](https://appliedgo.net/regexp/) a while ago to lower the entry threshold.
[Quick and Dirty](https://play.golang.org/p/V_mtlCg8VT). Of course, in practice, you'd want the replacement to be cleaner, add some extra checks on the type of the value passed in and maybe recurse on struct-fields/pointers (reflect isn't pretty). But it works :)
It's in the article
It was a wrong link in the readme, the correct one is https://github.com/hexdigest/gotests
Tying to change a structure in a library you have no control over by changing memory at runtime is a lame excuse. So.. why?
But I suspect the real answer is: because he wants to. (And bacause he wants to spend some quality time with the debugger)
They do go into alternatives and why they aren't tenable in this case. You apparently don't agree with the reasoning. But it's there. Pretending it isn't is just douchey.
He is asking for the deeper reason behind it.
I had a hunch that it was possible but I dislike reflect so much that I didn't even want to give it a go. Thanks for taking the time to show how it's done. (I have no idea who downvoted you).
Oh cool! This is really nice and way cleaner :) Thanks for sharing! The one difference between the two approaches is that your technique changes the type signature of the object. Each object should be processed individually. Mine changes the type signature of the compiled type (the type signature itself). Hence, all object of that particular type will marshal based on the runtime changes.
&gt; Mine changes the type signature of the compiled type (the type signature itself). Hence, all object of that particular type will marshal based on the runtime changes. True. I'd argue that's an advantage, though :) It means you are not screwing with other packages usage of the type :) FTR, I don't think "type signature" is a great term to use. You are simply changing the type itself - and the reflect-version creates a new type and converts the value to that new type. It may sound petty, but IMO it's good not to "pollute" how we talk about Go with new terms :) (also, I really enjoyed the article, wanted to dive into these topics myself at some point :) )
I think you're right :) I would still document it for that 0.1% use case that others run into, because I know how daunting such problems can be in the face of deadlines, and maybe some engineer at some company finds this useful for her work, and appreciates it. 
I think it's a useful post just because it dives into runtime/compiler internals. That's always a useful thing to learn about :)
Make your `getResults` write to a `io.Writer`. Setup a `json.Encoder` which directly writes to `w` and have it encode the output from `getResults`. Start with this. If you need further control, use `io.Pipe`. 
I'm not too sure. Most of data science are one-time exploratory analyses. I don't see Go replacing R, but maybe it could compete with Fortran or Julia. Or even python where they've picked python over R for production.
Nice, its one thing I would also implement in Go as an exercise. I have implemented a Bloom filter in Lua and I would recommend implementing Kirsch and Mitzenmacher hashing to see what impact it has on pergormance in Go. It had a profound effect in Lua. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.152.579
Take a step back and try to read the Go code and say out loud what you read. You'll find that it reads much better than most other languages. For example: var s string // A variable s of type string var string s // Variable string s? Try this with more complex code too. Once you realize how great it is, you might even have a hard time going back.
I broke it, fixed it in 0.6, broke it in 0.7, fixed in 0.8. In the upcoming version (0.9) is all about improving CUDA. I've a lot of personal code to backport into gorgonia
https://gorgonia.org/cu
As a frequent user of Gonum, I'd also like to add that one nice thing about Gonum over Numpy is that Gonum has a LOT of fit-for-purpose data structures. They feel weird when using them, but once you start using them you just wonder how you did it without them in the first place
Cheers to that. Contributions extremely welcome
not quite yet https://www.youtube.com/watch?v=lcyNjgEG9H8
Go's metaprogramming model is an endless source of comedy.
The post says (sic) "for the lulz". That's why.
Interested to know your comment on Francesc Campoy's recent dotGo talk, where he found Gonum to be lacking in some areas, especially on immutable matrices.
I think in the book Managing Humans: Biting and Humorous Tales of a Software Engineering Manager, the author described how C developers would work around the old blackboxes for Fortran developers. Now the tables have turned and Go developers work around the black boxes of C developers. Good for the next generation, because Go code is easy to read and convert.
&gt; Does this seem like good practice? Or awful, or just plain stupid? That depends a bit on… why. This is essentially a specialized [memcached](https://memcached.org/) - if your environment already has one of those, why not just use that? Or use something like [groupcache](https://github.com/golang/groupcache), which would even alleviate the operational cost of an additional memcached instance. The main question, I guess, is what the "other parts of the whole application" are. If they are all the same language, then it would seem more sensible to build this as a library on top of groupcache. Even if they are *not* all the same language, the cost of maintaining this logic in multiple languages should still be pretty low. Honestly, I'd just… not run this as a separate binary. I'd just use memcached/groupcache. Unless you need to do significant processing on the data.
It's a react native application which uses firebase for authentication. There's a Java service which basically interfaces with a broker(for actually buying/selling stocks), and then I'd like another service for fetching and storing the stock market data. Of course, I could just add the logic in Java, but I like the idea of having different services that I can change as I wish without touching the "core" of the application, if that makes sense?
This will be very interesting. I'm bookmarking this.
So you are writing a small service in order to add some specific new functionality without affecting the already working legacy/core system. Not that it matters but yeah I would call that a microservice and Go is a perfect fit for this.
An IoC container is just a generalized factory. So you replace your IoC container with a plain factory. type TypeProvider interface { GetTypeA()*TypeA GetTypeB()*TypeB } That's all. Obviously it will be more verbose than reflection and annotations on classes, but a factory method only has to be written once. The biggest issue is how to use a factory in an web app that has handlers and middlewares. My opinion is to put the factory into the request context, since it's request scoped and cannot live without the request context.
Glad to hear, those were my thoughts exactly. It's just gonna run a minimal webserver with a single REST endpoint that queries some information that lives in-memory. And of course, a feature which consumes that from a provider. Relatively simply input/process/output. 
The thing is that, what you are describing, sounds like maybe a hundred lines of code or so in either language. There is operational overhead involved in running an extra service and for that little code, personally, I wouldn't be willing to pay that overhead. The value added (from my POV) of doing it in a separate service, is that then multiple instances of your other servers can share an in-memory cache - but that's literally what memcached or groupcache are there to solve and they would be much cheaper, as you don't have to write them first. (while we're at it: Why can't you just use a caching HTTP Proxy anyway?)
The reason I'm leaning towards it is: 1. I want to learn Golang, and I learn it by using it 2. Go is quite fast at reading from memory, and it would be a good test to see if it should be used for more complex services later on 3. Either service might be completely killed or replaced at some point, dividing up the logic would make this very simple, whereas bad mistakes might be made if they were within the same webserver. How would a caching http proxy solve the problem? 
&gt; How would a caching http proxy solve the problem? The process you described is * $thing makes an HTTP Request fetching Data * $thing stores the Response in memory * $thing replies to HTTP Requests with the stored Data That's a cache. Strictly speaking, you haven't yet talked about what *triggers* the initial fetching, but even if you need something specific here, you can always just do a request to the cache at whatever trigger event you want. There might also be additional processing done, which I asked about above, which would make it more than a *pure* cache. But not that much more. Like, I'm really trying to figure out what the advantages are you are trying to achieve here. Because I don't really see any; it seems like a solution (I want to use Go!) in search of a problem (Let's write this thing in Go, even though it would be much easier not to). In the end, I mean… Whatever floats your boat :) I'm just saying, from what you explained so far, this would seem much better solved with a handful of lines of client-side Java and some existing service like memcached (you mentioned you are using Firebase, meaning you are using GCP, meaning there is a hosted offering) or a caching proxy. That may be, because you haven't described the complexity of a problem or it may be because of other circumstances I'm oblivious to - but if someone on my team would come to me with the design as described, I would strongly object.
Should have been IMO `// "&amp;"` etc. Sorry to miss that CL before committing. 
FYI, the [roasbeef fork of btcd](https://github.com/roasbeef/btcd) has a couple of interesting/WIP/bleeding-edge features in it that aren’t yet fully incorporated into the main btcd code base. Most notably, roasbeef’s btcd fork supports a new and improved approach to how full bitcoin nodes can interact with SPV/“light” clients (e.g. for mobile bitcoin wallets) that’s also written in Go called [neutrino](https://github.com/lightninglabs/neutrino). Also, it’s what [lnd — the *Lightning Network daemon*](https://github.com/lightningnetwork/lnd) is currently built against. P.S. for those who may not know much about the Lightning Network yet, it is a 2nd layer protocol which facilitates truely instant, low-fee (micro)transactions, without the need for any trusted intermediaries, with zero custodial risk, and with theoretically infinite transaction throughput. Oh, and LN can also be used for cross-chain atomic swaps (i.e. allowing for instant, trustless trading of different altcoins). Here’s a great [list of explanations and dev resources for Lightning Network](http://dev.lightning.community/resources/) stuff for whoever might be interested. 
I'd say you can do good DL/ML stuff in Go. Not everything is there on the shelf, ready to be imported. the "half empty glass" way to look at it is that it's a good time to contribute the building blocks (or just the nice user-facing API) for your favorite problem. here is an old-ish introductory lecture I gave: - https://github.com/sbinet/jdev-go-datascience-2017 
Hey gophers, I needed a reliable way to strip HTML tags from strings. After some research I've found a `stripTags` function in go [html/template/html.go](https://github.com/golang/go/blob/9c64c65d0ea251c3ac4d49556f10ad6ceb532f52/src/html/template/html.go#L170). But it's **not exported**. There's an unresolved issue [on Github](https://github.com/golang/go/issues/5884) to *un-unexport* this function. Simple copy/paste of the function is not possible, it relies pretty much on every other source file / type in `html/template`. Found some attempts at exporting said function ([1](https://github.com/grokify/html-strip-tags-go), [2](https://gist.github.com/christopherhesse/d422447a086d373a967f), [3](https://storage.googleapis.com/go-attachment/5884/7/strip.go)), but all solutions lacked an easy upgrade path for changes made from upstream. Most solutions took the content of all `html/template` files and put the content into *one single file*. What happens if a new go release modifies or fixes the `html/template` source files? How do you diff that? So I wrote [striphtmltags](https://github.com/denisbrodbeck/striphtmltags), which tries to simplify things a bit by: * download &amp; extract go source code * copy all files from `$GOSRC/src/html/template/` into `html/template` * add one extra file containing a function *StripTags* which in turn calls `stripTags`` * run all unit tests * commit all changes * create new tag matching go version (e.g. v1.9.2) I suppose one could access the unexported function by doing some *black magic* reflection and what not, but I wasn't able to pull off that stunt while playing with the code :/ Open for feedback - maybe the gopher community knows a better way.
Hi Dave, I've used your package in the past! Good to meet you, and thanks for taking a look at my project. I built my own representation of Go types because I wanted something more type-safe. If I recall correctly, many things in `jen` are just `Code` objects (or something similar), and there are many ways to compose them which don't produce valid Go. For simpler applications, this worked just fine for me, but for this one (for whatever reason) I was struggling to keep track of everything in my head and wanted some help from the compiler.
Are you using this to prevent XSS? If so, that seems dangerous. From https://golang.org/pkg/html/template/#hdr-Security_Model: &gt; This package assumes that template authors are trusted So, that means that you also assume that and therefore recommend nobody use this on untrusted input? Might be worth putting that in the README.
Yes that's right - jennifer is more of a tool for emitting arbitrary Go syntax than a tool for generating valid AST. Jennifer does however keep brackets, braces, list separators and imports under control though. My early iterations were further in that direction (see https://github.com/dave/geny) but I decided the syntax was too complex for real developer productivity. Good luck!
Not at all! I already did add an explicit topic on this into the [readme](https://github.com/denisbrodbeck/striphtmltags#security). My personal use case is stripping tags from html emails and processing that further. The readme lists some [use cases](https://github.com/denisbrodbeck/striphtmltags#use-cases) on why one would like to strip html tags from strings. Never intended to do XSS protection, that's a job for other HTML sanitizing libraries, like bluemonday.
Laolu's a beast.
Oh, this was me! Glad that others are finding it useful. If anyone has any comments about the design or implementation, you can let me know here.
If you can write a post about "how" you've implemented this, I believe that many people will find it valuable.
[removed]
This particular feature was simple to implement - the logic is just two lines, as go/ast already keeps track of inline comments on value specs (declarations). I've been doing other changes to stringer recently too, such as prefix trimming and fewer dependencies on generated code. Perhaps I should write on this, but I have never liked having a blog.
Yep, simple for me too, but not for everyone. If you write about it I can publish it or just send it here, you don't need a blog to do that. As you wish :)
Ouch, I've just realized, that [bluemonday](https://github.com/microcosm-cc/bluemonday) actually has a mode, which strips **all** HTML tags. &gt; `bluemonday.StrictPolicy()` can be thought of as equivalent to stripping all HTML elements and their attributes as it has nothing on it's whitelist. An example usage scenario would be blog post titles where HTML tags are not expected at all and if they are then the elements and the content of the elements should be stripped. This is a very strict policy. I've always assumed, that they stripped down HTML tags down to a minimal acceptable level, never removing all of the tags. That's good, they know their stuff, the library is battle tested and they are really fast. No need for my library. Going to delete the repository. One package less to support and worry about :)
I think tags (like json uses) might be better because then I could still have comments for humans next to it. Neat addition though. 
&gt; Miscellaneous utilities for dealing with JSON represented as `map[string]interface{}`, including an implementation of path-based indexing. Eww.
cool, sparks one's curiosity about e.g. what the repo growth top list looks like (cause we all like top lists don't we)
Seriously!
It might be, but in the current grammar constants don't get struct tags.
I think if we want to maybe break apart Greenspun's Law, we could say there are a couple of language features that are so commonly needed that a language without them will force you to reimplement them in an ad hoc way. One of them is, yes, automatic memory management, but it's worth noting that C also has problems with strings (C's native strings aren't good enough; good enough strings are immutable, which you'll need for…), key-value hash-maps, M:N thread-coroutine scheduling, a good system for importing core language libraries, and good system for importing other people's code. Go has had all but the last from the start and the last is coming into place with dep. 
&gt; I decided the syntax was too complex for real developer productivity. I could see that. Fortunately for me, I only need to build out the parts of the AST that I care about; I don't need a fully-working AST. Also, I have the advantage of being able to define the ASTs (both the TDL AST and the Go AST) with sum types thanks to TDL, which makes the task a lot less tedious than with Go.
If anyone is up to review, here's another little enhancement to stringer that I have just sent: https://go-review.googlesource.com/c/tools/+/85015
But still if you have ultimate edition you can use the go plugin just fine. 
Maybe it'll spoil the joke, but can you explain what you mean in more detail?
Always curious, could you explain what you mean?
My apologies, I missed the security notice. +1
Swap // for # and it's purpose is the similar to a preprocessor.
I have a dumb question for you: if the LN has no drawbacks, why are there non-LN transactions? Could / should the entire network migrate to LN? What's the catch, basically.
or python or java
It is still in a development/testing phase. 
- It's not ready yet. Testnet only until a future beta release. IIRC it's supposed to be the next one. - You have to be online to receive payments. - You have to have a connected route to the recipient. - You have to lock up funds in advanced like a checking account. Eventually I don't think this will be a big deal but I think it'll take some time to build the trust to make it easy to swallow. I think those are the highlights of why we couldn't go all in on it in OpenBazaar for a while, but we met with the Lightning team yesterday to talk about some of these things so the ball seems to be rolling as long it gets adoption. Same problem as most networks.
&gt; This project is currently under active development and is in a Beta state. Okay... &gt; It is extremely stable and has been in production use since October 2013. Errr, what? Which is it?
That's the format I took in my fork: https://github.com/augustoroman/enumer
The first argument is the prefix of the path of the request that your server received. The second argument is how you handle the response. In your case, you probably want to make your second argument with http.FileServer: https://golang.org/pkg/net/http/#FileServer 
It is unclear what you are trying to achieve but maybe it would help to explain why you're not just doing http.HandleFunc("/client", helloWorldHandler)
That makes sense. For merchants, it makes sense that they'd be online anyway, and if I understand you &amp; these articles correctly "locking up" funds to prepare for LN transactions doesn't delegate trust, right? Only once you've co-signed something can someone transfer your currency. Also, what do you mean by "connected route"? Do you just mean that co-signing is stateful, and therefore you have to interact over a few round trips? Dreaming blindly here, this seems compatible with a POS device. Scan a QR code on your phone, POS and phone talk over internet, the end. Right?
I'm not sure about the error, you are getting, but there is a problem with the structs you are using. You have to use Capitalized field names in order to deserialize and serialize in Go. It uses reflection under the hood and the values need to be publicly accessible, which only Capital fields are.
&gt; For merchants, it makes sense that they'd be online anyway Sure, but a lot of people want to use Bitcoin and not only merchants. If you want to have a Bitcoin donation address on your static site you probably don't want to have to run a Lightning node to handle it. For our project merchants don't want to have to keep their computers online constantly and so Lightning won't work for them at this point. &gt; Also, what do you mean by "connected route"? I mean that if I want to send you money then I must have a channel with an entity, who has a channel with an entity, ..., who has a channel with you. You can only send and receive transactions with people that have a chain of channels to you. &gt; Dreaming blindly here, this seems compatible with a POS device. Scan a QR code on your phone, POS and phone talk over internet, the end. Right? Sure, that would be cool. But that doesn't obviate the need for non-LN transactions.
Why program in a language with static types if you don't use them? Would you write a non-JSON-using program with `map[string]interface{}` as your main datatype? If not, then why are you willing to suffer that with JSON?
You need to merge the data in, you are just setting a new value to the same map entry each time through the loop: https://play.golang.org/p/bRZXye649fY
[removed]
https://play.golang.org/p/TbPg-T__oKS ?
You probably didn't keep refreshing :-) Not sure what the holdup is. It's still not in the list in Oregon or Virginia regions.
Hi there! I see what you did there. The HandlerFunc takes in a path as its first argument. This path is the path of the URL that must be handled by this function. For example, say you have a website http://example.com Then, say if your website has a blog page at http://example.com/blog then /blog is the path in this case. Therefore, in order to write a handler for that path, you'd write a handler func that looks like this ``` http.HandleFunc("/blog", blogHandler) // this handler will get called // whenever someone visits // http://www.example.com/blog ``` In order to match the root path (http://www.example.com), you can use this selector defined in the example ``` http.HandleFunc("/", rootHandler) ```
I think no one here can stop you from doing this, and you'll learn a lot if you do do it. Just don't inflict it on others.
It can certainly be both battle-tested in production and under active development. Noting that it's in beta and under active development is just a warning that the API might change.
Gotcha. That makes sense, and the chain of relationships definitely seems like that could get complicated. Thanks again.
There is a lot more subtlety involved than just saying data structures should be immutable. I'll try to break it down. Let's say we have a primitive operation: `Mul`, which is a Hadamard product (i.e. elementwise multiplication). And we have two advanced operations: `Square` and `Cube`. Both are elementwise operations. This are the definitions for the more complicate operations: ``` func Square(a Matrix) Matrix { return Mul(a, a) } func Cube(a Matrix) Matrix { return Mul(Square(a, a), a) } ``` If we say immutability is good for operations, then it stands to reason that every operation `Mul`, `Square` and `Cube` should be immutable - that is to say the input pointers of these operations should be different from the output pointers. Here we see a problem immediately: the operations are composed of other functions. `Cube` calls `Square` which calls `Mul`. If we require `Cube` to be immutable, then we have a situation where `Square` allocates a `Matrix`, and `Mul` allocates another `Matrix`. This kills the performance of anything you're trying to do. In machine learning there are a lot of tight loops which calls operations in form of functions of methods. If you're allocating in a tight loop, you're in a world of pain. So you are now left with two options: * rewrite the composed functions (`Cube`, `Square`) such that it allocates only once per operation. * write in some smart options to control allocations. * leave it to the final programmer to be smart about it You may say "oh, you should use a smarter language". Sure. Short of Haskell, which uses a G-machine to handle automatic memory allocation of composed functions, name me one other language that can ensure that `Cube` only allocates once if `Cube` is defined by calling `Square` and `Mul`. Maybe Julia, I'm not too familiar with its internals. Even with Haskell I'm not too entirely sure that it's as great as it can be with some manual controls. So let's evaluate the cost of the two options above: * Library developer cost: now every operation that you want to write has to be written in a way that supports allocation only once. * A performance cost from parsing function options - this happens in *any* language, be it Go, or Python, or C or Rust. What you can do is you can write your parser in such a way that minimizes cost. * End-user programmer cost: programmers have to be aware of the memory layout of the data structure. I opted for option 2 when I wrote Gorgonia. Gonum went with option 3. No sane person would go for option 1. 
Thanks! That worked perfectly.
the language should have been named "if err not nil" on every call to something which may err write this: ``` if err != nil { return err } ``` your code will be littered with them. it will look like tons of noise, then, after a bit, you won't even notice the litter. you'll live in squalor and not care about your captor.
Fair enough. In this case, `map[string]interface{}` is just used as an intermediate representation. The main part of the program still uses actual types. There are two main reasons to use the intermediate representation: * We're not sure what type to decode into, so we inspect the `map` before converting it to a proper type. It's not the only way to do this, but it's what works for our specific situation. * We need to perform some generic operations on (or with) the intermediate representation, regardless of the actual type. Basically, we only use `map[string]interface{}` for code that needs to handle generic input. Code that needs typed input uses specific Go types as usual.
That's actually super helpful; it didn't even cross my mind
I’ve never understood how the lightning network can support cross chain swaps. Can you explain how this is possible?
I like to build structs with this tool. Just paste in your sample json. https://mholt.github.io/json-to-go/
This should work for you - package main import ( "net/http" ) func main() { http.Handle("/client/", http.StripPrefix("/client/", http.FileServer(http.Dir(".")))) } 
&gt; An IoC container is just a generalized factory. So you replace your IoC container with a plain factory. &gt; The biggest issue is how to use a factory in an web app that has handlers and middlewares. My opinion is to put the factory into the request context, since it's request scoped and cannot live without the request context. But not everything in web app are request scoped. DB connector, logger are examples that need to be shared between request scoped and background. Maybe put the factory as a "global" scope are not so bad: type TypeProvider interface { GetTypeA(ctx Context)*TypeA GetTypeB()*TypeB }
Wow these are amazing, awesome work! 
Look what you made me do. // Update an existing post func UpdatePost(db *gorm.DB, title string, content string, postId string, author string) (error) { if db.HasTable(Post{}) != true { db.AutoMigrate(Post{}) } // SELECT * FROM post WHERE id = postId; var posts Post err := db.First(&amp;posts, postId).Error if err != nil { return fmt.Errorf("post update failed: %v", err) } // Update existing post with new information if no errors err = db.Model(&amp;posts).Where("id = ?", postId).Update("Title", title).Error if err != nil { return fmt.Errorf("post update failed: %v", err) } err = db.Model(&amp;posts).Where("id = ?", postId).Update("Content", content).Error if err != nil { return fmt.Errorf("post update failed: %v", err) } err = db.Model(&amp;posts).Where("id = ?", postId).Update("Date", time.Now()).Error if err != nil { return fmt.Errorf("post update failed: %v", err) } return nil } They're everywhere!
I've never used fish shell, but can you just update your configuration file with GOPATH and PATH? https://fishshell.com/docs/current/faq.html#faq-login-cmd
The way recommended in the FAQ doesn’t seem to work — it only temporarily changes it to work for Go, while commands like ls become broken (but cd works for some reason)
I hope that they fine-tuned their "10-point technical debt assessment" for Go, because some of those rules seem biased towards languages that are not Go. Specifically these ones: - File length - Excessive lines of code within a single file - Method length - Excessive lines of code within a single function or method - Return statements - Functions or methods with a high number of return statements 
I use fish shell, and it just works. Can you give more detail on your problem?
I know it's just a side thing, but `cd` is a shell builtin, whereas `ls` is a separate program. Something probably messes up the "standard" `PATH`.
In `~/.config/fish/config.fish`, append the line `set -x GOPATH "&lt;gopath&gt;"` where `&lt;gopath&gt;` is the path to your GOPATH.
The open source community gave us tools like gocode, that jetbrains ide exploit, for profit. What gotool did jetbrain gave back to the community? that's why I don't support these paid IDE, and other shouldn't. There is no reason any goland functionality couldn't be a cli-tool to be used by any text editor whatsoever. The PHP did the same mistake with PHPStorm and is now forced to use it because open source code quality tools, code-completion tools are mediocre. 
Thanks!
ent# export GOPATH=your_path_here
I hope to attend a few Go talks this year. Last year the room was packed and I missed out of them because of it 
Just FYI this was posted 5 days ago and you can read the discussion here - https://www.reddit.com/comments/7k10nw
Yeah, I plan to get to the room waay earlier than the first session. Only way to make sure.
Cool! Are/will the videos archived on YouTube?
It's not working, but don't worry. Thank you for your help! 
I see. Thank you kindly! 
Thank you for that! 
Thanks for the info. Im considering making the leap to vim..
yes and also Goland have the features of webstorm so in my case I still pay only once...more then only webstorm but once..
&lt;3
I have started making games with Go &amp; SDL2, here is a repo if anyone wants to have a look. https://github.com/demonshreder/sdl2-games
Fair enough :) I coded the whole thing in like 45 minutes, though I have never made anything this complex in Go before. It was a breeze! I really enjoy Go, even though I know Java well, this would take 3-4 times as long to do in Java for me I think. 
The room has been filled to capacity every single year. 
&gt;Each live stream will be archived on youtube after it is over. 
# What is inside? * Z to A * Scope ate my param * Quick to run the params * Captured in a Loop * Point of no return? 
What's your YouTube channel name?
I love go. I use it quite a bit, I have written a few machine learning applications with it, and it does just fine. But I've yet to find a case where it's the better choice of python or go. The big thing for me is the speed and flexibility of development. With Python, I can do things in 5 lines that can take 100 in go. Yes, they're straightforward and simple, but no matter how simple it is it just takes time. And should I need to change up the control flow, that's all the more code to check over, change, and test. I find that when I write my research programs in go, it takes me much longer and I'm not as likely to explore ideas and experiment because the incremental effort is greater. The basic ecosystem is much more complete than it was when I was doing more machine learning work in industry- I actually learned go to work on a natural language search API server, implementing semantic query expansion. Still, though, if I need an implementation of some model or technique, if there isn't a Python implementation (or an R one that I can hook into through rpy2) chances are I'm not going to find one in any language- much less go. There's a lot of reimplementing the wheel. Data preprocessing (I mostly do NLP) and string manipulation are a chore in go and it's very easy to end up with a whole data file in memory if you're not careful with the way you buffer. I've yet to find a usable plotting library that can do more than a spreadsheet program. While I like the static typing in general, constantly manually casting between int, uint, int64,float64, etc to make sure you're getting the right types to/from functions is extremely tedious and makes for unreadable code. AFAIK there's nothing like R or pandas dataframes, either. There's also very for sparse matrices, which makes life quite difficult without the numpy-style slicing/broadcasting and vectorization. With a bit of care, I can write python code that is comparable or better than go in terms of performance for most things without much trouble. So sure, you can do ML in go. People do, obviously, as they're here in this thread! But I've yet to find a case where go looks like a better choice to me. I have considered reimplementing specific pieces of a pipeline in go, particularly cases where the memory overhead of python objects is unacceptable or parallelization is required but python doesn't handle it nicely. But I usually end up deciding that I would spend more time writing it in go than I would save by having a faster program. All that said, what you do specifically within statistics and machine learning dictates the tools you need and that can vary quite a bit. There might be areas in which go is a much better fit, but as far as my little corner of Bayesian modelling goes, Python is really the only option for me most of the time. Julia, however, looks *extremely* intriguing and I hope to check it out soon- it seems to have the features I really like from both go and python, and could be really useful.
Given that `String()` always returns a string, aren't the quotes unnecessary though? I suppose there are edge cases where you might want a `\n` or something the string, but if you have non-standard cases like that you can just fall back to writing the code yourself.
It's pretty simple. 1) Create a .rc resource file with the properties desired. There are many resources online for resource file info. Here's a stripped-down version of the one we publish: #include &lt;winver.h&gt; #include &lt;winuser.h&gt; // VERSION INFO VS_VERSION_INFO VERSIONINFO FILEVERSION 3,0,0,0 PRODUCTVERSION 3,0,0,0 FILEFLAGSMASK 0x3fL FILEOS 0x40004L FILETYPE 0x1L FILESUBTYPE 0x0L BEGIN BLOCK "StringFileInfo" BEGIN BLOCK "040904b0" BEGIN VALUE "CompanyName", &lt;company&gt; VALUE "FileDescription", &lt;description&gt; VALUE "FileVersion", &lt;file version&gt; VALUE "LegalCopyright", &lt;copyright string&gt; VALUE "ProductName", &lt;product name&gt; VALUE "ProductVersion", &lt;product version&gt; END END BLOCK "VarFileInfo" BEGIN VALUE "Translation", 0x409, 1200 END END 2) Include a windres step in your build process to compile it in. if "%ARCH%" == "amd64" ( set WINDRESFLAGS=-F pe-x86-64 ) else ( set WINDRESFLAGS=-F pe-i386 ) windres -l 0 %WINDRESFLAGS% -o &lt;output .syso filename, put it in the directory your main file is in&gt; &lt;rc file&gt; // Regular main build goes here 
https://github.com/stretchr/testify/issues/526 is relevant info about this.
Hi! I'm not going to discuss whether the approach is correct, I'm going to show you how to get a function's input and return types by parsing the source code using abstract syntax trees. Usig this approach you can parse the entire source code, and when you find the node containing your target function (in this case it's called test), then you get all sorts of information on it, including the types of the params and return values. See example below. Please let me know if this helps! Thanks! file: main.go ``` package main import ( "fmt" "go/ast" "go/importer" "go/parser" "go/token" "go/types" "log" "net/http" ) func main() { fs := token.NewFileSet() f, err := parser.ParseFile(fs, "main.go", nil, parser.AllErrors) if err != nil { fmt.Printf("failed!, %v", err) } conf := types.Config{Importer: importer.Default()} info := &amp;types.Info{Types: make(map[ast.Expr]types.TypeAndValue)} if _, err := conf.Check("main.go", fs, []*ast.File{f}, info); err != nil { log.Fatal(err) // type error } ast.Inspect(f, func(n ast.Node) bool { switch x := n.(type) { case *ast.FuncDecl: if x.Name.Name == "test" { fmt.Printf("input: \n") for _, p := range x.Type.Params.List { tv, ok := info.Types[p.Type] if !ok { fmt.Printf("nil...\n") return false } fmt.Printf("%v %v \n", p.Names, tv.Type) } fmt.Printf("output: \n") for _, o := range x.Type.Results.List { tv, ok := info.Types[o.Type] if !ok { fmt.Printf("nil...\n") return false } fmt.Printf("%v %v \n", o.Names, tv.Type) } } } return true }) } func test(anotherint, n int, abc string, req *http.Request) (string, error) { return "", nil } ``` 
I'll post up a link to the youtube channel on the website, once the first episode has been done. 
Look at how this package does it in their examples: https://github.com/lxn/walk 
Is this organized by the same people that organize GopherCon US ? Or can just anybody organize a 'GopherCon' somewhere ? Are these some guys lucky enough (?) to claim the 'Europe' name first ? Just wondering - no intention at all to organize something myself (or to go to Iceland, btw - a more central location would have made way more sense).
The support is crap. Expect to spend time heavily customizing the rules to get anything useful out of it.
&gt; Hi! I'm not going to discuss whether the approach is correct, I'm going to show you how to get a function's input and return types by parsing the source code using abstract syntax trees. Heya, I'm sorry if I was not clear in my post but I wasn't asking for help on how to do it, just if there was this functionality previously existing somewhere so I didn't waste my efforts writing it. .. and then I waste your efforts writing it haha. My apologies. Regardless, I appreciate your example, thanks!
That seems to have work. Thanks a lot. I'll never have to live without syntax highlighting and autocomplete again.
Cool I actually mentioned that part for the sake of this answer
I suppose I was setting the path wrong. I tried: set GOPATH ~/gocode/src/mystuff $GOPATH set PATH ~/gocode/src/mystuff $GOPATH set -U PATH ~/gocode/bin $PATH Actually just looking at my command history I'm confused as to which one I was supposed to set to which (bin or src to path or gopath)
I was just recently thinking how cool it could be to make the game's engine multithreaded using Go's concurrency primitives... Subscribed, looking forward to checking it out.
I know it's a late reply, but have you looked at the lib's referenced in [Awesome Go](https://github.com/avelino/awesome-go)? I see a few linear algebra libs there.
Kinda weird to store secrets in strings and not `[]byte`.
[Here's a good explanation](https://blog.lightning.engineering/announcement/2017/11/16/ln-swap.html) (let me know if you have any questions?)
I ended up doing the project in C++ but thanks for the reply :) 
I've done it using the JSON format found in https://github.com/josephspurrier/goversioninfo.
Please don't do this. [As Dave Cheney says](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully), "Don’t just check errors, handle them gracefully". Just returning the error object up the chain leaves you with a good chance that by the time something *actually does something useful* with the error, it lacks enough context to *actually be useful*. Yes, there will be *some cases* where you just return the error you received, but writing tools to do so in *every case* just automates a bad habit.
I was just recently thinking how cool it could be to make the game's engine multithreaded using Go's concurrency primitives... Subscribed, looking forward to checking it out.
&gt; With services you have to document and communicate about the client, the API, and the code in the service, where a monolith has only the code. I'm glad I don't have to work on this documentation-and-communication-free monolith. Even a monolith has internal APIs, not breaking it into services isn't a get-out-of-documentation-free card. You could just as easy write a service with an undocumented API and never talk about the changes you make to it. This paragraph alone makes me distrust the entire rest of the article.
I'm a bit lost. Isn't returning them what happens a large portion of the time? I'm just trying to save typing from something I'm already doing. Returning wrapped and existing errors. What am I supposed to do, consume the error and not handle it? I think you misunderstand what I'm doing here. It has nothing to do with how you handle the errors, I'm simply trying to save myself typing the same thing 400 times.
I'm talking about what's in your original post: &gt; I'm trying to add autocomplete functionality to my editor. What it would do, is simply write a templated out error check, like so: &gt; `if err != nil { return err }` Automating that would be a Bad Thing™. Automating *good error handling*, to the extent that it's possible (because it will be *different in every error check*), could be valuable if its feasible.
Awesome, thanks!
Very cool, thank you!
For me usually it is: return nil, fmt.Errorf("description %v", err) What I mean is that I very rarely find myself returning `Struct{}` Nevertheless I am hoping for an addition to the language that will allow us to do return _, fmt.Errorf("description %v", err) And `_` will be replaced with the default zero value, be it `nil` for pointers or `Struct{}`.
Oh wow, that's slick. Thanks!
You can easily [make the code nicer](https://youtu.be/1B71SL6Y0kA?t=16s) because [errors are values](https://blog.golang.org/errors-are-values). But seriously, why are you doing 3 updates? If you did all the work in just one update then you'd have less error handling as well.
`\n` is not the problem, even though it's nice to support that if someone really needs it. The intent is just to distinguish the enumeration string value from a comment. Comments do not come often in the form of a quoted string, but comments in the form that stringer now picks up as the enumeration string value may happen just fine - meaning that one has to be unnecessarily much more careful when adding a comment to a typed enumeration constant.
Good point about the updates. I wrote this code when I wasn't too familiar with the GORM API, I'm working on refactoring it. Thanks for the help!
Highlights: * [Time](https://play.golang.org/p/3fv0L3-z0s) * [Balls](https://play.golang.org/p/rX_3WcpUOZ) * [Race](https://play.golang.org/p/y0tFGuIs9c) * [Train](https://play.golang.org/p/NOycgN2i6b) * [Life](https://play.golang.org/p/6j5z_RNr0q) 
The machine which generates the secret have to be destroyed after the creation of the shares so is faster to write the secret in plain
The github link is dead?
Why don't you want to go to Iceland. Feels like a wonderful place for a conference I will embrace my inner Björk :) 
Fixed. Thanks!
A friend of mine wrote [something similar](https://github.com/stapelberg/expanderr) recently, which might interest you.
I'm not seeing it anywhere. Have you?
`thou` will be an int and needs to be converted to a float so you can multiply it. With constants it doesn't matter, as the correct type is chosen automatically.
Because if it were to be in Germany, many people in Europe would still be able to drive there. Now everyone has to go by plane. Iceland is also pretty expensive afaik.
Oh my bad. Did a search but this link didnt crop up which i thought a bit odd.... Cheers for the link!
Unless you are committed to writing tooling that is based on a monorepo to ensure you have consistent dependencies (ie shared libraries necessary for interop between services), I'd just make them different repos. You can still create similar consistency checks using github (or whatever repo management system you use) to verify each service is using certain versions. CI is another way you can ensure things are consistent. For example, a global dependency repo can be added to a job that compares the specific repo with a microservice repo and ensures the dependencies are correct. One side effect of microservices is that the services are typically organized according to how they can be deployed. In practice that means having different repos for different services. You can certainly use a monorepo to deploy different microservices, but often times the tooling such as CI systems work much better with single repos per project that you are fighting an uphill battle. The downside of multiple repos is that you need to adopt an "Open Source" mindset in that each project might have different dependencies at different points in time and these dependencies can drift if you're not careful. None of this is insurmountable and often pushes you towards better practices such as ensuring APIs are where integration happens and not in libraries. I'd also mention that in many companies that have large monorepos, the circumstances were much different than someone today. These companies have internal tools and teams to support them, where it is much more likely you can create a Github organization and utilize the API along side CI to get many of the same benefits without the longer term challenges of managing an extremely large repository. 
Noone wants to do documentation. I have embraced gRPC lately with documentation generated from the protobufs. Saves a good deal of headache. I just moved our company from a unmaintainable monolith for similar reasons.
See [here](https://golang.org/ref/spec#Constants) for the relevant part of the spec and [here](https://blog.golang.org/constants) for an in-depth explanation.
About time. Thanks!
That's what `json.RawMessage` is for.
"test-go", seriously? Come up with names that don't make it look like your pet project is a standard part of Go. That's almost as bad as https://github.com/golang-standards
I don't know what you did there, but https://play.golang.org/p/GQL6jAQZACJ works (Arabic writing) and https://play.golang.org/p/pAKWeZtinv7 (hebrew)
Er, the second one actually reads better to me: var string s // A variable of type string called s
Cool. Now try both methods again with some complex code.
Nice trick. For people who are wondering, it's the unicode character (U+202E) that changes the text direction from right to left. How to do it: * Open your brower dev tools * Enter `copy('\u202e')` in the JS console * Paste the unicode character somewhere then start typing text right after it
[2012]
Is `\u202e` the variable name in my playground link? Or is it an invisible character that I pasted in along with the variable name? I just copied the variable name from a unicode chart, so if it's an invisible character that got picked up by my copy/paste buffer, then their chart is doing something funny.
If it’s not under a golang.org or GitHub.com/golang import url it’s not official. Officially only golang.org and Stdlib imports are supported by upstream go developers. I see no problem with the name. Its the entire point of the import url structure. They’re defacto namespaced. 
The programs they wrote are still cool though. :)
So you did it accidentally?
So you won't mind me registering http://github.com/ecnahc515 ?
Not really, though you might not be able to, since that was my old github username before I changed it ;). I probably still have stuff that has the old URL, and github is nice enough to automatically redirect to my new username, but I imagine if you took it that would break. But thankfully git will warn/fail if that actually occurred. Anything I haven't changed to use new imports is probably unmaintained/not used anyways.
Heh just tried, and it let me create the new account. I hope no one is using my old github repo urls! At least I expected this when I changed my username.
This is nice to see. I use libsodium to create and compare Argon2i password hashes right now, so it would be nice to drop the cgo dependency and use a pure Go solution once some more user friendly and well tested functions for password creation and comparison are built on top of this.
I think it should be pretty simple to add it to https://github.com/hlandau/passlib
https://i.imgur.com/N5E3Kak.png
Not benchmarks, but here is another blog entry from Cloudflare https://blog.cloudflare.com/exposing-go-on-the-internet/
I believe the majority of Cloudflare's performance work has been merged back into the standard library.
Thanks!
Look closely. OP's code has no quotes around the LTR character...
It is a good practice to pass the context as first argument and most of the libraries are moving in that direction. Worth to read https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39
I thought I'd play about with this, but clearly I have no idea of how these things work. fmt.Println(argon2.Key([]byte("crappypassword"), []byte("crappysalt"), 4, 32*1024, 2, 32)) fmt.Println(argon2.Key([]byte("crappypassword"), []byte("crappysalt"), 4, 32*1024, 2, 32)) I would have thought that given the same password and salt that the same key would be generated. But then this isn't a hashing function (is it?). So how would you go from the Key() function to a hashing function?
Not sure I'd call a dependency on mysql light weight...
Does this need a premium account?
I use a handy little [command](https://godoc.org/github.com/shurcooL/cmd/runestats) in situations where I want to find unwanted non-ASCII characters. It has happened more than once.
My mind is melting.
It looks really good, man.
This is such a great idea, I'm defnitely going to get a lot of use out of this. I opened a small PR and a couple of issues. :\^)
&gt; &gt; No default values for function/methods’ arguments: &gt; This is true, but if your function requires a lot of optional parameters there is probably something wrong with it. Still, in situations where you really need to pass optional arguments, you can use zero value check arguments, pointer arguments or variadic function arguments. Actually the answer to this is "use a separate type which holds the function's arguments". Coupled with iterals this makes the whole thing a no-brainer. type fooParams struct { s string i int } func foo(p fooParams) { ... } foo(fooParams{i: 42}) // s will be "" 
&gt; I don’t agree with the one letter variable, I think over the past 40 years the software industry has agreed that developers spend much more time reading code than actually writing it, meaning that the code should be written thinking about readers. I don’t want to have to remember that r most likely stands for Request and w for Writer. The rule of thumb is that the larger the scope of a symbol, the longer its name is. It's as simple as that. I see no point in using `reader io.Reader` over `r io.Reader` in a function which is a dozen of lines in length.
Ternary operators... Why people are so afraid of a little typing if it makes things more readable is beyond me
I don't have any direct feedback but there is a similar project https://github.com/acrisci/playerctl that may be useful for inspiration.
Agreed, we're moving to passing a context as the first parameter in all of our internal and open source projects. While I don't like every aspect of the Context pattern it still solves some real world problems in an acceptable way.
Main quote for your topic being: &gt; Back when crypto/tls was slow and net/http young, the general wisdom was to always put Go servers behind a reverse proxy like NGINX. That's not necessary anymore! ...it's now really fast..., and its security track record so far is excellent.
oh god yes, `return _` would be amazing, never thought of that syntax before! Maybe Go 2 :)
Yea, I can see where that led to confusion, but note that returning it blindly is not purely bad either. Eg, you don't want to blindly wrap everything. Then you'll be throwing away EOF/etc errors. The problem of actual error values becomes more complicated as you go up the function stack. Parent functions have less and less context to understand what you may have wrapped, and what you might not have wrapped. This is a case where I wish the `error` interface had some way of adding context to errors, without changing the value. Wrapping errors feels so terribly hacky. Like, a solution to a problem in Go that is caused by Go *(ie, a less than stellar design in this case)*. I wish Go had error handling like in Rust, powered mainly by Enums. It's so nice in Rust. Data can go along with the error, and everything is understood, rather than the wishy washy stack trace that we're creating by hand in one big ass string `foo: bar: bar: bang: boom: etc`.
is my fear, too expensive to go there 
I would suggest using a standard case for your repo URL, on GitHub you have "go-honeypot" but the Go imports use "go-HoneyPot". It might mess up the download process for some users, see this related issue (the user made its username lowercase &amp; broke everyone's builds) [0]. [0] https://github.com/sirupsen/logrus/issues/451
cool. will check it out
This isn't something I've ever considered. Thanks for tip! 
The following article might be helpful, I think the following article looks to be a good view of the state of things, https://medium.com/@timburks/openapi-and-grpc-side-by-side-b6afb08f75ed. Biggest con for us is the lack of pep8 for the python code generator. Makes it difficult to get the buyin of other teams when they are not pushing for the change. The pro for me it's that gRPC and protobuf have more robustness and help on the human side by being very explicit.
Unfortunately [it looks like you do](https://developer.spotify.com/web-api/working-with-connect/#premium-only).
I don't ever pass anything to any function unless I know I am explicitly going to need it. That said, I like the "opt-in" aspect of most libraries by having FunctionName and also FunctionNameContext
don't mix log.Print and fmt.Print*, pick one or the other https://github.com/Mojachieee/go-HoneyPot/blob/master/tcp/tcp.go#L30-L33 the tcp NewServer is passed a slice of ports, but the udp NewServer has a hardcoded set of ports, make them both passed in https://github.com/Mojachieee/go-HoneyPot/blob/master/database/database.go#L14 I would rename InitDB with New. It is in the database package so the object type is clear. I'd move any default values for the config into the config package and set them at: https://github.com/Mojachieee/go-HoneyPot/blob/master/config/config.go#L38 before decoding the JSON instead of having default values be spread around like https://github.com/Mojachieee/go-HoneyPot/blob/master/database/database.go#L16-L18 Need instructions on what the DB schema should look like config.Read should return (Config,error) instead of using log.Fatal, this way you could write a test without dying. In main you could check the return error and exit there instead. 
I wrote a command that breaks down stdin character by character for stuff like this: https://github.com/carlmjohnson/unicodechess
‮You can do it on the web, too. Although I needed to use the developer console to get it into the text box. Something seems to be filtering it. (You can do it on the web, too. Although I needed to use the developer console to get it into the text box. Something seems to be filtering it.) In firefox, I right-clicked on the text box to inspect it, then right-clicked on the element to "use it in console", then ran `temp0.value = "\u202eMy Text Here."` to get that first paragraph. On the web, the effect of the character is automatically scoped to the block element in which it appears. This message does not contain the character that flips it back to left-to-right; it's just scoped to that paragraph alone by the way HTML uses the character.
Thanks! Taking a look at them now. (:
If you want to create a variable and give it a default value when a conditional fails, the lack of ternary is a little annoying. 
You can actually pretty much [just do it](https://play.golang.org/p/52WNQU4JUdG) and it works out. The JSON decoder doesn't erase things it doesn't find in a given decode run.
Thank you! 
I've been kicking around something similar in response to the push to "cloud" lately. I dislike the Lambda approach for many reasons. I've been structuring a lot of my programs naturally in terms of modular services in Go; I tend to write a lot more fairly small packages than it seems many Go programmers do (based on what I see on Github), which has the effect of making the packages fairly independent across those package barriers. The idea I've been kicking around lately is using some sort of API gateway in front of my Go services that is capable of routing based on path, so if I need to upgrade my "billing" module, instead of having to take down everything and redeploy fresh new code, I bring up a new instance(s) of my monolith that just has the updated billing code, point the API gateway at that for just that path, and over time as things are mixed and matched we can shut down old servers using mostly outdated code, etc. I haven't worked it all out yet, but while I like some of the "serverless" stuff I really loathe how much of the baby got thrown out with the bathwater in that approach, and my services and executables are not so large that I can't afford to sometimes run some extra stuff. Executable sizes of even my entire infrastructure at once compiled into a single executable is still insignificant next to the resources of a modern machine.
IMHO gRPC is an amazing approach, but the code is still rather incomplete and immature. We're using it in production, hit a few roadblocks and worked around them. Right now it works pretty good, but don't forget about the overhead. You should probably only use gRPC if you have a good reason to. Otherwise just stick with HTTP.
You may look at this post https://blog.cloudflare.com/arm-takes-wing/ which is one month old. It's about Go's crypto performance on ARM64 but the charts can be used to compare recent Go to OpenSSL.
Could you elaborate on the road blocks?
This could be really useful. A lot of the current Spotify automation bits at least on macOS use applescript and are super CPU heavy/clunky.
Super cool - seems to be a company in Brazil. Thanks for the write up.
Oh fuck this shit ruined Ruby for me.
You can directly run assembly in Golang. It requires some type magic, but it can be achieved. I'll be writing about type magic in Golang in my blog tomorrow - https://medium.com/kokster/tagged/golang Following that I'll be writing about JIT in Golang - which runs assembly directly. If you just hang out on this subreddit and you'll see it in a few days.
The Go gRPC library has a history of serious herp derp programming.. - https://github.com/grpc/grpc-go/commit/3df1dd419a244c4a942c6a8b03ddc57e4fd4fec7 - https://github.com/grpc/grpc-go/commit/25dd388f9a5f61a32193fef98d28621c12c5f033 - https://github.com/grpc/grpc-go/commit/b5774fd760d0ecea631fabc49eb3b94b3324df92 There's plenty more there, that's just a quick sampling -- I stopped following the project more than a year ago. And then there's the bit where it reimplemented a http/2 server independently of net/http...
Oh dang I was gonna write a JIT in golang also! my plan was gonna be to wrap various os calls(virtualalloc/vmprotect(?)) and then use that abstraction layer in go. 
most experienced programmers that you seem to be describing don't just blindly step in to a debug session. most people put a breakpoint where they already know the issue lies or is related to, and treat it just like a verbose trace log, which is not that dissimilar from a crash log.
This is awesome, and you used cobra :heart:
I need to try gosublime out. I'm a golang noob and just defaulted to vscode cause I knew it would all "just work". However, I'm a long time sublime user + plugin developer and prefer it to any other window based editor. Any tips/tricks, or is it pretty smooth to get going?
Would love if the UI didn't close and showed what was currently playing! I'd replace my Mopidy/ncmpcpp setup with this in a heartbeat.
Where would you want that in the interface? I could probably do that.
Hmmm, maybe just show the status (what's playing, etc.) at the bottom? I'm on mobile right now but I'm going to play around with this later today.
Why does pep8 matter? Why do you lint generated code files (a.k.a. build artifacts)?
Correct. I copied and pasted a character from a unicode table.
I'm not sure about OpenAPI. I can describe my opinions on gRPC; maybe that will be useful. gRPC has a lot going for it. Its nice that all CRUD operations are hidden behind simple function calls, and that the system has libraries in every major language to make this seamless. Its nice that validation is built in. I think the real seller is the easy streaming of input/output; most other approaches require you to build a pagination system on top of the technology they provide, usually you get best practices for doing this, but having it built-in and done for you is huge. Every single API will implement pagination at some point; I'm not sure why more libraries don't do it for you. The fact that it is implemented over the performant HTTP2 streaming protocol is a bonus. There are a few things gRPC does I really really dislike, though. 1. ProtocolBuffers. gRPC is designed to solve google-scale problems, but in doing so makes tradeoffs that organizations below Google scale (IE: literally everyone else) don't have to make. By operating over proto, you can't just `curl` endpoints to make requests (without additional work, there are libraries that proxy on top of grpc and do this for you), and your clients need access to the proto defs for the client libraries to work. This is nice because clients are guaranteed to access the same API the server is exporting, but it introduces tight coupling. 2. API is defined in a different language. I hate this, with a passion. We have all of this amazing tooling built-in to your server-side language of choice, especially Go, and then ptoto comes in and says "codegen this other thing into your language". It works, of course, or no one would use it. In interpreted languages this matters less, because the codegened protobufs are conceptually more like build artifacts. In Go and other compiled languages, you need them pre-build for both compilation (obviously) but also things like editor auto-complete and suppressing red squigglies. It would make more sense to design your API natively in Go, then have tooling during the build to export the protobuf files for consumption by clients. 3. Maturity. gRPC is notorious for having low code quality, especially in some of the tertiary languages. The documentation is also, in Google fashion, atrocious. Huge swaths are outdated. Some of it is flat-out incorrect. Nearly all of it is incomprehensible. All of their Getting Started guides just say "download this examples repo" which is a disgusting form of laziness. Fortunately, once you learn the basics its pretty easy to just pick it up and use it; just don't even try to learn the basics from Google.
That's really interesting! I'd love to learn more about your design for the JIT, and share mine with you. I'll DM you
Agreed, sounds like some bells and whistles on top of the old database as a queue paradigm. 
Is there any actual reason the compiler can't infer float here?
Go 2.0? Did I miss something? ;-D
Pretty smooth, yes, I install it on the new machine directly from plugin marketplace, no manual pulling required. Just Sublime + GoSublime does all the job for me. And yeah, I debug using log.Println and happy with it.
It's no the generated files, it's that ever call to one of the generated files looks ugly/uses different conventions. 
Also load balancing becomes a problem too. For example ALBs in AWS do not load balance grpc services.
Looks a lot cleaner. Maps in particular should be much easier to deal with. 
That little annoyance is nothing compared to the terrible constructions one can make by chaining ternary operators.
It's their SDK's v2
WOAH! Use prepared statements. This code is begging for someone to exploit. https://github.com/Mojachieee/go-HoneyPot/blob/master/tcp/tcp.go#L72-L73 http://go-database-sql.org/prepared.html https://www.owasp.org/index.php/SQL_injection
Go doesn’t have implicit conversion of things with types because in C this has been an endless source of bugs. Fortunately, literals and constants don’t have to have types, so it’s not a problem in practice. Change to `const thou = 1000` and it will work. 
I'm going to answer with a big caveat here in which I only read about grpc and didn't build anything with it **yet**. I have a rest service which I'm going to attempt to port to grpc in the next week or so. grpc is in early development. It's not that mature both in the sense of the spec itself and the grpc binding. C++ is first class as far as I can remember. Things like support for bidirectional streaming is meh. The entire concept of cache control doesn't exist. I did heard of people complaining about how errors are handled/raised and how confusing it can be. I'm not sure what this is all about. Good on platforms that have a grpc binding but it can't directly be used on a web browser. I remember reading about load balancing problems as sessions are sticky. You can generate a rest service however, most of what you expect from an OpenAPI defined service isn't part of the protobuff spec. Things like providing examples, limiting parameters to certain set of values, defining responses, headers, etc. Either they are flat out missing or it's not that straight forward to do. When I was looking up to replace OpenAPI to protobuff I just straight up gave up on my goal to provide the exact same spec. It's a bit disappointing that I have to go 5 steps backward on my spec. Protobuff is easier to write than yaml.
Aside from what other people suggested, I think it's also worth to read my older blog post: https://faiface.github.io/post/context-should-go-away-go2/ Many people (I think most) agreed with me at the time.
It's bad, but there's no remote strings in there...
Please don't forget to post to reddit! This is a really exciting topic. 
I still find it strange that the sdk must implement its own primitives. Why is ‘aws.String()’ really needed? It gets really tedious and frustrating. 
~~I'm not sure that's true. Where does n come from in line 73 in tcp.go? conn.Read in 54 it looks like~~...Just use prepared statements/binding values ffs. EDIT: didn't brain good
https://grpc.io/blog/loadbalancing
Yes there are solutions, but it's a pain and as I said in AWS the layer 7 ALB does not work with GRPC you are stuck with using a layer 4 load balancer or using a client side load balancer.
I agree that using prepared statements is the right thing to do. But, remote/local address are going to be net.TCPAddr (IP:Port). n is bytes read (integer). So, this particular query isn't exploitable.
Yeah super confusing, just SDK v2 as /u/HectorJ mentioned... but if you follow /r/golang like me, there is occasional talk of Go 2 so that made it wicked confusing!
I haven't used GRPC myself, but have found openapi useful. Particularly the codegen capabilities of swagger in openapi are nice. I can generate my server code fairly easily and then serve up the api desc to my js, who will parse that desc and dynamically create a client. As the answer to your question, why use RPC in the first place? Large companies like Google and LinkedIn have many different processes each doing different specific jobs in what's called a microservice architecture. For example, LinkedIn might have a service whose only job is to keep track of connections and another service whose only job is collect the feed. Now imagine ~290 of these services, each with their own specific team. Now, each team could implement a rest api. But it is a hassle trying to convert native objects(say in Java) into a wire protocol like TCP or HTTP. You could use REST, but even then you would need to figure out how to encode it into a route and a payload. It would be a nightmare if every team implemented their own way of talking to each other. You as a service owner would need to maintain many different sets of clients to talk to each service. At LinkedIn scale, fanouts of a frontend service to backends can easily number around 20-30. Now imagine a standard system that translates native objects and then makes requests with them to other services. This is RPC. You'll see various implementations like gRPC, SOAP, RestLI, openAPI, and GraphQL. 
Notice that `aws.String()` and its friends return a pointer. This is useful when you want to differentiate between an empty string and a nil value.
Curious, what was wrong with v1 that it needed to be replaced? Also, will v1 continue to be supported?
Whoops, yes. Somehow convinced myself read returns bytes, rather than filling the slice. 
IIRC lots of people have mentioned that v1 was java in go.
Con: protocol buffers aren't self-describing. This is enough reason for me to look elsewhere unless I ever find myself desperately chasing better performance.
What do you have in mind when you say a GraphQL browser? Can you describe it in more detail... do you mean like [Graph*i*QL](https://github.com/graphql/graphiql), or something else?
Not 100% sure what you're asking, but: All GraphQL servers support [an introspection query](http://graphql.org/learn/introspection/) to determine the types, queries, mutations, etc that it offers. Forming structs based on the generic response of a GraphQL server is impossible, even if you know all of the types ahead of time. Main reason being that queries allow you to remap field names at will. You can certainly form structs based on the responses of specific pre-compiled queries.
Of course!
More or less exactly like GraphiQL.
I was looking for something that would be able to work generically with any GraphQL server where I would just startup my client with the GraphQL endpoint and then explore the queries it supports and play with those. That feels like it needs to be able to create queries and handle responses dynamically.
`AWS SDK for Go` is now `v2`
`aws.String()` just returns a pointer to a string, You're not at all obligated to use those methods. It's a convenience method that makes it easier to use hard-coded strings as values to AWS structs that need a string pointer, since you can't do `foo := &amp;"some string"` The [godocs](https://godoc.org/github.com/aws/aws-sdk-go-v2/aws#hdr-Value_and_Pointer_Conversion_Utilities) for the package explain in a bit more detail.
If you're writing this because you think it doesn't exist, I'd point you to [Graphql Playground](https://github.com/graphcool/graphql-playground) or [Graphiql-app](https://github.com/skevy/graphiql-app). If its just for fun or practice; you're gonna have to do something like 1. Load all of the types, queries, and mutation the server supports into structures so you know how to parse responses, via introspection. 2. Use map[string]interface{} and traverse it via the structures you have from (1) at runtime.
If I understand you correctly, you're thinking about creating Go types for GraphQL schema types. It is not possible with statically typed languages like Go, unless you know schema at the compile time (then you'd be able to do some codegen). Instead, you have to treat GraphQL schema types as data.
Looking at the answers to my comment, I should perhaps clarify that ;-D is an old-fashioned form of an emoji. It means "big grin with a twinkle", indicating that the preceding statement should not be taken seriously. (The elder among us may still know that emojis started as "emoticons", a short sequence of ASCII characters that resembles a face when you look at it with your head tilted to the left. AFAIK they were invented before "Unicode" even became a word.)
Nice write up. I'm also using gofpdf for reports generation in one service that runs 3.5+ years already. 
&gt; then there's the bit where it reimplemented a http/2 server independently of net/http Which was done so that they could provide http2 without tls on it. a feature not included in the net/http version.
I guess we all just missed your ancient emoji cuz it was legitimately confusing title. 
how exactly is pagination built into grpc? streaming != pagination. If you want a paginated rpc call you will have to have OFFSET and LENGTH parameters in your request just like normal REST. 1. You can't talk to any api without knowing the schema. I don't see how this creates tight coupling. This is no different to OpenAPI or even SOAP wsdl, except that it's a better implementation. Also gRPC != protobufs, it's merely the default serialization. You can plug in any serialization you want.
Is there any documentation (godoc) yet?
so use a better load balancer, envoy is pretty good.
OK, that is sort of what I expected, but I wanted to make sure I wasn't missing something obvious. thanks.
OK, I kind of assumed it was something along those lines, but I wanted to make sure I was missing a language feature.
I once worked at a company where they *insisted* that *all* variables were fully spelled out. So you had code like: public function GetLatestRevisionID() { $dso_WikiPageArticle = $this-&gt;getWikiPageArticle(); $dso_WikiPageArticleRevision = $dso_WikiPageArticle-&gt;GetLatestRevision(); return $dso_WikiPageArticleRevision['Id']; } It was terrible. It was beyond terrible even. This is a simple three-line example, but in more complex functions things got very *VERY* difficult to read. Everything is just dominated by a wall of text of variable and function names. I've worked with many codebases over the last 20 years, including many ugly codebases I'm not familiar with, and in general I managed to cope reasonable well. But this codebase is the only one I really struggled with. Not *just* because of this – there were other issues as well such as [writing JavaScript like this](http://tmp.arp242.net/wtf.png) – but it was certainly a large part of it. Always using very short variable names is clearly the wrong approach, but always using very long names is even more wrong, IMHO.
One of the downsides of this is that you can't have 1 required parameter and 2 optional ones. You can add a runtime `if` check, but this is at, well, runtime. In e.g. Python you can do: def foo(arg1, arg2='optional', arg3=True): And calling `foo()` gets caught at "compile-time"; not by Python itself, but by static analysis checks: no-value-for-parameter: No value for argument 'arg1' in function call In Go this would obviously be a compile-time check.
Well, not directly involved, but: [Syncthing](https://syncthing.net/)
I think docker is one of my favorites. I think it's an awesome idea and a great implementation that can be used creatively for tons of different things.
Anything and everything from [Hashicorp](https://www.hashicorp.com/)
I mean, lack of parameterized functions does suck. It's not unreasonable to say in 2017, when people are more and more interested in fully-featured type systems, that a relatively new language which lacks them and instead relies solely on structural inheritance, where you basically say "I'd like this to work with different types of similar things, so I'm going to make it take and return types of interface{}" is pretty regressive. In fact, it looks a lot like early Java where everybody would shove things into a container typed as Object. *** After reading another article about Go and it's place in the world, the Go community seems highly reactionary anytime Java is brought up, so to be clear, I'm not advocating for OO. In fact, my preference is for the simplicity of algebraic type systems. That being said, very robust type systems and type checkers exist in other languages which are evaluated at compile time which could make more robust typing in Go possible.
It isn't marketed with a fancy landing page or anything (yet, maybe?) but Allwrite Docs. Upon specifying a Google Drive directory ID, Allwrite with traverse the folders and files and generate an API for a frontend javascript client to use to display documentation in a nice and organized way. Essentially, using Google Drive/Docs as its CMS. Currently, only Postgres is available to use for storage but more will come soon (plus postgres full-text search). It's crazy fast. TL;DR it ultimately allows for folks within the company to use Google Docs to write documentation rather than using something like markdown in github (not that I have a huge problem with md). * Allwrite Docs core (Go): https://github.com/LevInteractive/allwrite-docs * Allwrite docs client (js): https://github.com/LevInteractive/spartan-allwrite/ * Allwrite express middleware (node): https://github.com/LevInteractive/allwrite-middleware-connect