Maybe change ExecutableInSequents to ExecutableInSequence
The answer from the tech lead on the Calibra team. Ben here, I'm the tech lead on the Calibra team. Libra started with a blank slate -- all options were open. Once we made the decision to build our own blockchain infrastructure, the next question was what language to use. The team spent time considering different options, many of which OP listed. As a project where security is a primary focus, the type-safety and memory-safety of Rust were extremely appealing. Over the past year, we've found that even though Rust has a high learning curve, it's an investment that has paid off. Rust has helped us build a clean, principled blockchain implementation. Part of our decision to chose Rust was based on the incredible momentum this community has achieved. We'll need to work together on challenges like tooling, build times, and strengthening the ecosystem of 3rd-party crates needed by security-sensitive projects like ours. We're looking forward to working with the Rust community for years to come. I'd love to hear your thoughts on ways that we can work together to continue building the momentum behind Rust. Source: https://www.reddit.com/r/rust/comments/c20aed/facebook_just_picked_rust_to_implement_their_new/erhsz9q?utm_source=share&amp;utm_medium=web2x
I can't answer for this company but the norm is for your employer to cover all reasonable costs of work travel.
I am really biased about Victoria metrics. I read a couple articles from the author about it, and they sound like it's a company advertising its paid solution, but at the same time I don't see any pricing, enterprise offers or other monetization offers. This company rather looks like a one man show (see contributors page on github) which however constantly acts as a company - by speaking in third person or about us/we. All mentioned features and performance benchmarks sound amazing, but I wouldn't believe it until I tested it on my own because of my concerns. Please share your experiences along with your use case and some data if you go ahead and give it a spin!
nice. In case anyone is curious about doing this on Linux (PR\_SET\_PDEATHSIG, not POSIX generalisable) you can use the set death signal on each child. I'll see if I have time tonight to come back and post an example.
Thanks. I struggled with this level. I wanted to tie into the files on the zip drive, but the Go Playground doesn't have the concept of an actual file system, so I took some liberty with the names. I might revisit this in the future though. Thanks for the feedback!
&gt; A single-node VictoriaMetrics may substitute moderately sized clusters built with competing solutions such as Thanos, Uber M3, Cortex, InfluxDB or TimescaleDB. See vertical scalability benchmarks. The linked benchmarks don't mention Thanos...
[removed]
What is considered mid-level?
!remindme
**Defaulted to one day.** I will be messaging you on [**2019-06-21 00:39:50 UTC**](http://www.wolframalpha.com/input/?i=2019-06-21 00:39:50 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/c2hnj5/an_easy_way_to_ensure_all_child_processes_are/erlmdia/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/c2hnj5/an_easy_way_to_ensure_all_child_processes_are/erlmdia/]%0A%0ARemindMe! ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! erlmjlq) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Can you give me some more info on what exactly is “making your urls deterministic”? First I’ve heard of it (aka noob haha)
This is awesome. I got no work done on my hobby project tonight because of this haha. Is there a way to compare our solution to the "" correct "" one? I just did #7 but there is absolutely no way this is right... What I did was &gt;!copy paste line 8 to 16 and replace 'epoch' with 'intercept'!&lt; ...
Thank you! It's fixed now.
&gt; or else throw away type safety altogether So Erlang is not a functional programming language? What *is* a functional programming language in your mind?
Maybe, but they are common. That's undeniable.
Check out [https://gophercises.com/](https://gophercises.com/). There they present the app concept, then you should try do it by yourself. If you get stuck there are videos of the teacher doing the whole app, so you can see how he done it (teacher's way is not the only way!). It's really organized! You can also check this repo on GitHub: [https://github.com/florinpop17/app-ideas](https://github.com/florinpop17/app-ideas). It is just a bunch of ideas which can be implemented in many ways, so how you gonna do it is up to you.
I am pretty sure casting a string to a byte slice makes a copy so the latter example is guaranteed to work every time.
Just watched!
[removed]
[removed]
Hi, Please help to pass [my resume](https://github.com/dumindu/hire-me) as well. Ready to relocate, if it's possible. Thanks
This is easy way to elaborate
Why this is wired example?
I will fix it
I think you missed the part where this subreddit is about Go.
This blog is readable /s.
All answers are valid and it looks like you found one I didn't think of yet! &amp;#x200B; I'll paste my solutions below for the curious: &amp;#x200B; Level 1 &gt;!agents\[2\].gear = "full"!&lt; &amp;#x200B; Level 2 &gt;!seconds = 79!&lt; &gt;!meters = 494!&lt; &amp;#x200B; Level 3 &gt;!return "D. D. D.Buggs"!&lt; &amp;#x200B; Level 4 &gt;!func online() RecordingDevice {!&lt; &gt;!return BadCamera{}!&lt; &gt;!}!&lt; &gt;!type BadCamera struct {!&lt; &gt;!name string!&lt; &gt;!}!&lt; &gt;!func (c BadCamera) record() string {!&lt; &gt;!return "Idle"!&lt; &gt;!}!&lt; &amp;#x200B; Level 5 &gt;!for x := 0; x &lt; 100; x++ {!&lt; &gt;!found := false!&lt; &gt;!for y := 0; y &lt; 100; y++ {!&lt; &gt;!passcode = strconv.Itoa(x) + "-" + strconv.Itoa(y)!&lt; &gt;!//codes = append(codes, passcode)!&lt; &gt;!respCode, \_ := validateCode(\[\]string{passcode})!&lt; &gt;!if respCode == 1 {!&lt; &gt;!codes = \[\]string{passcode}!&lt; &gt;!found = true!&lt; &gt;!break!&lt; &gt;!}!&lt; &gt;!}!&lt; &gt;!if found {!&lt; &gt;!break!&lt; &gt;!}!&lt; &gt;!}!&lt; &amp;#x200B; Level 6 &gt;!type LaserGrid struct {!&lt; &gt;!status string!&lt; &gt;!lasers \*\[7\]Laser!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!type Laser struct {!&lt; &gt;!id int!&lt; &gt;!isRunning bool!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!func setupLasers() \*\[7\]Laser {!&lt; &gt;!var lasers \[7\]Laser!&lt; &gt;!lasers\[0\] = Laser{1,true}!&lt; &gt;!lasers\[1\] = Laser{2,true}!&lt; &gt;!lasers\[2\] = Laser{3,true}!&lt; &gt;!lasers\[3\] = Laser{4,true}!&lt; &gt;!lasers\[4\] = Laser{5,true}!&lt; &gt;!lasers\[5\] = Laser{6,true}!&lt; &gt;!lasers\[6\] = Laser{7,true}!&lt; &gt;!return &amp;lasers!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!func testGrid(laserGrid LaserGrid) bool {!&lt; &gt;!laserGrid.lasers\[0\].isRunning = false!&lt; &gt;!laserGrid.lasers\[1\].isRunning = false!&lt; &gt;!laserGrid.lasers\[2\].isRunning = false!&lt; &gt;!laserGrid.lasers\[3\].isRunning = false!&lt; &gt;!laserGrid.lasers\[4\].isRunning = false!&lt; &gt;!laserGrid.lasers\[5\].isRunning = false!&lt; &gt;!laserGrid.lasers\[6\].isRunning = false!&lt; &amp;#x200B; &gt;!return laserGrid.status == "Operational"!&lt; &gt;!}!&lt;
Level 7 &gt;!interceptComms := make(chan string)!&lt; &gt;!go func() {!&lt; &gt;!interceptComms &lt;- messageQueue(0)!&lt; &gt;!interceptComms &lt;- messageQueue(1)!&lt; &gt;!interceptComms &lt;- messageQueue(2)!&lt; &gt;!interceptComms &lt;- messageQueue(3)!&lt; &gt;!close(interceptComms)!&lt; &gt;!}()!&lt; &amp;#x200B; Level 8 &gt;!func login() interface{} {!&lt; &gt;! type Sequence struct {!&lt; &gt;!I int!&lt; &gt;!S \*Sequence!&lt; &gt;!}!&lt; &gt;!return &amp;Sequence{0, &amp;Sequence{0, &amp;Sequence{2, &amp;Sequence{6, &amp;Sequence{12, &amp;Sequence{20, nil}}}}}}!&lt; &gt;!}!&lt; &amp;#x200B; Level 9 &gt;!var mutex sync.Mutex!&lt; &amp;#x200B; &gt;!func setButton(x int, sequence \*\[\]Button) {!&lt; &gt;!mutex.Lock()!&lt; &gt;!defer mutex.Unlock()!&lt; &amp;#x200B; Level 10 &gt;!var firstRun = true!&lt; &gt;!func init() {!&lt; &gt;! pump = func(rate int, capacity int) int {!&lt; &gt;! if firstRun {!&lt; &gt;! firstRun = false!&lt; &gt;! return fill(rate, 0, capacity)!&lt; &gt;! }!&lt; &gt;! return 0!&lt; &gt;! }!&lt; &gt;!}!&lt; &amp;#x200B; Level 11 &gt;!type Broadcast struct {!&lt; &gt;!Name string \`json:"-"\`!&lt; &gt;!Priority int \`json:"-"\`!&lt; &gt;!Message string \`json:"-"\`!&lt; &gt;!Location string \`json:"-"\`!&lt; &gt;!RealBroadcast!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!type RealBroadcast struct {!&lt; &gt;!Name string!&lt; &gt;!Priority int!&lt; &gt;!Message string!&lt; &gt;!Location string!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!func createBroadcast(real Broadcast, fake Broadcast) Broadcast {!&lt; &gt;!return Broadcast{!&lt; &gt;!Name: fake.Name,!&lt; &gt;!Priority: fake.Priority,!&lt; &gt;!Message: fake.Message,!&lt; &gt;!Location: fake.Location,!&lt; &gt;!RealBroadcast: RealBroadcast{!&lt; &gt;!Name: real.Name,!&lt; &gt;!Priority: real.Priority,!&lt; &gt;!Message: real.Message,!&lt; &gt;!Location: real.Location,!&lt; &gt;!},!&lt; &gt;!}!&lt; &gt;!}!&lt; &amp;#x200B; Level 12 &gt;!func enc(b \[\]byte) string {!&lt; &gt;! sha := sha256.Sum256(b)!&lt; &gt;! switch string(b) {!&lt; &gt;! case "masterPlan":!&lt; &gt;! b = append(b, ".pdf"...)!&lt; &gt;! case "financials":!&lt; &gt;! b = append(b, ".xls"...)!&lt; &gt;! case "doubleAgents":!&lt; &gt;! b = append(b, ".txt"...)!&lt; &gt;! }!&lt; &gt;! return base64.StdEncoding.EncodeToString(sha\[:\])!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!func secrets() func(\*\[\]Secret) {!&lt; &gt;! return func(s \*\[\]Secret) {!&lt; &gt;! recover()!&lt; &gt;! \*s = \[\]Secret{!&lt; &gt;! Secret{enc(\[\]byte("masterPlan")), enc(\[\]byte(".pdf"))},!&lt; &gt;! Secret{enc(\[\]byte("financials")), enc(\[\]byte(".xls"))},!&lt; &gt;! Secret{enc(\[\]byte("doubleAgents")), enc(\[\]byte(".txt"))},!&lt; &gt;! }!&lt; &gt;! }!&lt; &gt;!}!&lt;
I use this almost every day, and fine tune by hand when necessary: https://mholt.github.io/json-to-go/
Given they’re asking for 20% it sounds like they’re allowing 4 remote days and asking for one day a week in the office. I’ve known a few people who’ve had similar gigs with their companies (in the US) and they’ve been successful in getting parking, tolls, and train fare expensed. Can’t say the same for Monzo, but just another datapoint!
Is that you Jake Write. I'm in
Just because a language allows functions as values doesn't mean the language is functional. By that metric literally everything is functional, C is functional, the term would be useless. Almost all of the benefits of functional programming are made impractical or down right useless in Go, due to the language being imperative through and through. Just look at Rob Pike's implementation of the most basic fp higher order functions, map/fold/filter: [https://github.com/robpike/filter](https://github.com/robpike/filter) . Even the creator of the language says not to use Go like this. You will never find a production code base using Go in any style other than imperative. &amp;#x200B; Go supports almost none of the staples of what people refer to as functional programming, and as such should not be considered a functional language any more than C or Java. Go does not support: &amp;#x200B; \- Generic higher order functions \- Sum types \- immutable data structures \- anonymous lambda functions \- currying or partial application of any kind \- etc. &amp;#x200B; By contrast, Erlang supports all of these more or less
I'm relocating to London in a Month (I've work permit). I'd love to work at Monzo ! It just seems like a place to learn and grow. I've been learning Go through projecteuler.net challenges (here's my effort so far -&gt; https://oschvr.com/problems) and have around 5 years of experience as a Fullstack Web/Mobile Developer, but not necessarily consider myself an expert (yet). What's your position on the above ? Should I apply ? Do you have room for a passionate engineer, who's new in town ?
Oh my god. That blog was unreadable. My brain is fried.
same!!
Try using [https://github.com/Jeffail/gabs](https://github.com/Jeffail/gabs)
Very nice, looks fun!
All answers are valid :) I tried posting my answers below as spoilers, but the formatting was off on mobile and it displayed some of the code in plain text. I'd like to add hints eventually or maybe reveal other answers after you beat each level.
So what does this have to do with Go?
Every detail in Go is there for an opionated reason. (Like every missing feature is missing because its complexity cost is estimated to be too high, either for writing/understanding the code or for tooling and run time development and flexibility.) Shadowing is handy, if you want to use i, n, count, max, min, or problem domain related common words as variable names in inner "blocks" without worrying if they are simultaneously used somewhere else in the outer blocks. The syntax of ":=" vs. "=" is supposed to make it so that you do not accidentally litter an outer variable while temporarilty using the inner one. Scoping (as a part of even bigger abstract problem class of name space and address space issues) is non-trivial. [https://en.wikipedia.org/wiki/Scope\_(computer\_science)](https://en.wikipedia.org/wiki/Scope_(computer_science))
Are you hiring for infrastructure/DevOps?
b := []byte("ABC€") fmt.Println(b)
This is great. I loved the Sequence one :) &amp;#x200B; I need a hint for 10 please. "Objective: Pump 0 gallons without setting off the alarm" &amp;#x200B; Can't figure out how to inject my stuff (eg, redeclare pump).
I did #7 the same. &amp;#x200B; My hack for #9 is hilariously bad :) ... possibly worse than #7 :P
Gold
Considering this myself. I've been doing Go for about 3-4 years but not in any commercial role but worked at a few web agencies where I live, mostly PHP stuff. I've been to your old offices and a few Go London events, met a few of your other staff and Matt said he started with a similar background to me so that gives me a little confidence. Still worth me applying?
Single byte != byte-slice/-array.
PM sent :)
Yes https://boards.greenhouse.io/monzo/jobs/1428110
Hi, it's great that you're doing problems on project euler, and I like how you document your code. If you send me your CV I can do an internal referral :)
Preferably EU, mainly due to timezone issues. East coast could work though
Yeah of course, why not? I first touched Go to do the take home test from Monzo, so you're already ahead of where I was for the interview! 😊
Hi, yes we pay for both travel and accommodation costs for when you're in London
https://play.golang.org/p/SFuFcWZhjNG
The cadence for when you come in is not defined and 20% is a guideline, not a hard rule. If you can work effectively in your team while only coming a week every two months, that's great. There are engineers at the moment on that sort of schedule
This was going round our internal Slack earlier so... you decide? https://twitter.com/alicegoldfuss/status/1141114921645514752?s=19
&gt; By contrast, Erlang supports all of these more or less Erlang has a dynamic type system, which throws type safety away altogether, which precludes it from being a functional programming language according to the earlier comment. &gt; - currying or partial application of any kind Of any kind...? func divide(x, y int) int { return x / y } func divisor(d int) func(int) int { return func(x int) int { return divide(x, d) } } Works just fine.
Need a hint for 12 please I'm here checking secrets... opening: masterPlan.zip opening: financials.zip opening: doubleAgents.zip Just can't figure out how to change that file extension in the output :(
Are you guys hiring interns / fresh grads as well? Or just mid-senior level?
Not at the moment I'm afraid. I'm really sorry you didn't get a reply, I'll pass on the feedback as this is not how we want to treat candidates!
Hah, fair enough. Given those two options then yeah I'd go for YAML too :-)
Now that's the attitude I like :-) (As long as "passionate opinion" leads to reasonable debate and not people just stomping their opinions as fact.)
You are right, the web site does no reveal how the company wants to monetize the product. The code is under an Apache license, hence really open source, so I guess they plan to offer some kind of paid services around the product.
I pasted your regex to https://regex101.com/ (and found BTW that the first open parenthesis is missing), and it turns out that is is not compatible with the Go regex rules. (The regex is fine for PHP, JS, or Python.) Plus, it is a horribly complex expression, and even the generated explanation on that site does not really tell me what passwords would be valid according to this regex. As others have already strongly suggested here, drop the idea of using a regex. Get clear of each single requirement for the password, and write a function for it. For example, func longEnough(pw string) bool { return len(pw) &gt;= 8 } func includesNumbers(pw string) bool { ... } etc. Then run the password through each of them and reject it if one of them returns false. This way, your code clearly documents what rules a password must pass.
But hasn't "fine" always been the "F" in RTFM? ;-)
I am trying to solve #9 by not using the "nasty" solution but so far I am not successful, no idea how to fix the race condition for now.
I noticed that the order of the buttons was always the same when I logged it to console. Not sure if that's coz the random sleep wasn't working. &amp;#x200B; I just set the order of the button slice to the observed output :) Super hack. &amp;#x200B; I tried sleeping based on the X value, but it seemed to be ignored when running.
Yeah, me too. I basically tried to sleep for a while if x value was larger than the length of the array, but didn't work. The order of the buttons is always the same because the seed if the random number generator is always set to the same value at the start of the main function :)
Get to 12 already :) I want to know why mine isn't passing!
Alright! I got the correct sequence, but somehow is it still incorrect &gt;!for x &gt; len(\*sequence) {!&lt; &gt;!time.Sleep(10\*time.Millisecond)!&lt; &gt;!}!&lt; &amp;#x200B; It prints this, which should be Okay, but still it complains: Sending Code Sequence... 1 : red 2 : blue 3 : green 4 : yellow 5 : purple &amp;#x200B; Sorry, that's not correct &amp;#x200B; :(
So the 20% time in London is not really required?
I tried sleeping for multiple seconds - always resolved immediately - so I'm not sure.
Cool ! The lasers one and the sequence were really fun to get. Keep them coming :)
It's not the right sequence. &amp;#x200B; The sequence should be purple, red, blue, green, yellow.
Not even simply setting the button slice to the right order is working for me, it is super weird
PM'd
lol, why?
[Not true for Scala](http://blog.richdougherty.com/2009/04/tail-calls-tailrec-and-trampolines.html) [or Clojure](https://www.youtube.com/watch?v=RLqqGSthmC0), apparently.
Gotcha, thanks for clarifying that! Sounds like you guys are flexible and willing to accommodate individuals' preferences which is awesome to see!
[removed]
I've added hints to each level. Just click the lightbulb in the top right if you get stuck.
I've added hints to each level. Just click the lightbulb in the top right if you get stuck.
I've added hints to each level. Just click the lightbulb in the top right if you get stuck.
Awesome, it works! Thank you very much :)
There's nothing quite like a fine girl talking about golang.
This is pretty interesting. I've been working on something similar for tetris. Would you recommend contributing to open source projects from larger companies in lieu of experience for someone coming from more of an IT consulting background with some programming? Any golang repos that come to mind (complex ones are good too). Thanks!
You can do trampolin very well in Go, and even simply use goto which is exact tco.
Wtf...
And this is why women opt to disable DMs on pretty much any social platform.
ever used a \`chan\` before?
Why, exactly?
You mean go provide simple abstractions or enable you to write simple abstractions? I disagree with the latter but agree with the former.
Your original comment kinda implies you're objectifying her.
Sigh
&gt;have checks against nil succeed if the data within the interface is nil (example) Why? Any code that uses the interface shouldn't care. The type that implements the interface can implement methods that will work with a nil value. Notice that if you drop the type conversion to an int pointer it works.
Because I'm complimenting her? People are so incredibly transparent
It's non-obvious, and surprising is usually bad in a language. Internally, we have a type that implements `error` that can handle multiple errors (_very_ useful for logging), as well as different _types_ of errors (warnings, informational logs, etc). We had a bug where we _thought_ we were returning `nil`, but really we were returning a non-nil interface with nil data, so we were treating a few cases as if they errored when in fact they were `nil` (and then the type assertion would succeed, but the contents would be nil, and we had panics). Honestly, I can't think of a practical case where I'd want the current behavior. It's too easy to mess up and I can't think of a reasonable use-case for the present behavior. I understand why it is the way it is because I've had to dig into the memory structure of Go types, but it's not at all what I expected coming from other languages. Essentially, it's a footgun that I can't see a use-case for, so it should go.
This is a common misconception I see: **you're not complimenting her** because something being a compliment/insult heavily depends on the context. In this context, she's going over a complex topic which probably goes over quite a few heads, it certainly does mine. In that context, a compliment would be saying "Wow, amazing explanation of the (some specific detail), I always had trouble understanding it!" A non-compliement would be saying "Nice ass, m'lady!" because it's totally out of context, unwanted and unwelcome, at best to be ignored, at worst creepy and rude. If she was (sorry if she reads this, it's just a paint by numbers example which seems to be required) taking part in a wet T-shirt competition, saying "Hey bby, nice ass!" **would be a compliment** because that's the whole point. But she's not taking part in a wet T-shirt competition, is she? Keep your "compliments" to yourself.
Literally the only software written in Haskell that I know of which is in wide use is Pandoc. Even PHP, you can name a bazillion sites that were written in it, even if they shouldn't be. I think Haskell maybe got used for some fintech stuff at some point? But that's an exception that proves the rule: people with millions of dollars to burn can make idiosyncratic language choices.
how does this blend together with tools such as helm and kustomize, which are designed to handle image versioning in manifests?
Surprise... It is 2019!
All feedback is welcome :)
Wow, You two are like peas in a pod.
&gt; Literally the only software written in Haskell that I know of which is in wide use is Pandoc. I know != not exists. The only software in Go I know is Docker, doesn't mean Go is not used. Bluespec, CLaSH, Lava. It exists in hardware design, fintech. Even facebook uses it. Tho I prefer OCaml, Haskell is quite widespread, especially with motto such as "avoid success at all cost"
`
\+1 very good balance of motivation, puzzles, etc. Some levels had "clearly correct" solutions (&gt;!For example, using JSON annotations to solve the intercept problem.!&lt;), and others I felt like I was hacking around far too much -- but that was part of the fun. One problem is that it's far too easy to drag code from the protected block into the editable block, so I 'solved' a few levels that way. Felt like [Indiana Jones](https://www.youtube.com/watch?v=7YyBtMxZgQs). :P
Well first of all it *doesn't* go over my head. To me it's completely irrelevant whether she's a girl or not, the content of the video doesn't really come as particularly worthy of 25 minutes. Someone who has worked with golang linkers before (or any other compiler) would probably be well aware of the contents of the video, and average coders would probably find this superfluous anyway (considering the gravity of intelligent comments in this thread). Furthermore anyone who's worked with ld, libc, cgo, ELF, etc will know this better than her. If you look at it from that context, surely I meant to complement her.
And for all the breathless Rust evangelism on all the blogs and aggregators, at least their community isn't as insufferable as Go's (namely, this sub-reddit). It's like people in Go land take offense when high visibility projects are written in something other than go. It's okay, no one personally attacked your child.
That’s why in my edit I link to Wikipedia. Haskell is not a new language. It has been around since the 90s, and for a significant amount of time, its creator was on the payroll at Microsoft. If it was going to succeed at some non-abstracted IO free cost, it should have done something by now! “Facebook uses it” is so vague as to be meaningless. I assume they have tons of engineers who do one off analyses in pet languages. No one doubts that Haskell can be used to write programs. The question is whether, as FP advocates claim, purity buys you an order of magnitude in productivity. I see no evidence for the claim, but it is made often, eg by the OP.
Yes, it's all javascript-based, no backend. So if you really wanted, you could hack the JS and really manipulate things. Part of the fun is doing it "your way" :)
Every time I see a talk from Jessie I'm impressed by what new hacky cool stuff she comes up with. &amp;#x200B; Hats off to you Jessie.
This was surprisingly interesting.
I just skimmed quickly through ko’s readme, but running “kustomize build” or “helm template” before running ko should do the trick given the generated yamls contain ko import paths.
I work for Facebook and my team mostly uses Go (we own the low level infrastructure to install OS on physical servers). We even have some Go projects on GH: * [https://github.com/facebookincubator/dhcplb](https://github.com/facebookincubator/dhcplb) * [https://github.com/facebookincubator/fbender](https://github.com/facebookincubator/fbender)
&gt;It has been around since the 90s, and for a significant amount of time, its creator was on the payroll at Microsoft. It was never aimed at industry, it was born as a more radical version of Miranda. It was done to implement the most radical ideas, not to be widespread. Yet haskell was adopted in xilinx for hardware design and in fintech, it's a very good result for a language done solely for research and implementation of the most radical ideas. &gt; purity buys you an order of magnitude in productivity. Of course it does. Tracking effects is gradually becoming widespread. Algebraic effects and monads are making their way first into languages like OCaml and Scala, then in Java and C#. I'm not sure what productivity has to do with popularity, tho. There are much more metrics affecting adoption than productivity. Ada is much more productive than C, yet C is more widespread in embedded, for example. Familiarity and labor costs affect popularity more than productivity.
You are basically translating binary 0000 is 0 0001 is 1 0010 is 2 Perhaps just convert your pattern into a binary number and use that ?
\&gt; Similar to other tooling in the Go ecosystem, ko expects to execute in the context of your $GOPATH. This is used to determine what package(s) ko is expected to build. Not in a post-modules world though.
Basically the pattern struct will be created from the struct which will have query parameters from http request . Hence not using the number
Nothing says the struct can't have a method that returns a number to make comparisons easier.
But you can easily convert the `Patern` struct to a number: func boolsToInt(bs ...bool) int { x := 0 for _, b := range bs { x *= 2 if b { x++ } } return x } // convert the struct like this, p is a Pattern instance x := boolsToInt(p.DateWord, p.Data, p.StartData, p.Categories)
you're cringe. can't tell if troll bit or legit /r/niceguys /r/IncelTears &amp;#x200B; either way, if it's "completely irrelevant whether she's a girl or not" why do you remark with nothing quite like girl in x? troll
Even if it is int , than also I have to invoke functionality based on the number . Still I have to have a map in-order to avoid if-else .
The function in that SO answer takes a string for the binary number and gives an int. Conversions of the Boolean to “1” and “0” shouldnt be difficult. Then you can use the int for a switch statement if you need
Absolutely, but you can make it much less verbose and more performant: var state = [...]handler{ one, two, ... sixteen, }
Very that.
If you _actually need_ distinct and unique behaviors based on each possible combination of 4 Boolean values, then you may as well just [write a long switch](https://gobyexample.com/switch). If many of your behaviors overlap, however, (ex: everything with a dateWord but no date is invalid, or everything with a dateWord should have DW added to output) then you can use a [decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern) or [functor](https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6) approach to "build up" and then return your handler function as you check each Boolean. Also, if you have a slightly broader slice of your code in a [gist](https://www.google.com/) people can probably provide more clear advice.
Great article. Do you have any resources about what I can use this for? Conceptually, I seem to understand the context, but in my CRUD side project, I'm not sure I need it?
Never write `== true`.
Better not fuck with this guy. He's dangerous.
Plus I dont see any activity on [https://github.com/google/ko/issues/7](https://github.com/google/ko/issues/7). Bummer !
are you using GOPROXY? that will void your insteadOf setting.
Using GitLab here with Go modules. The dependency go.mod file should be set with a module name such as ‘module gitlab.yourdomain.com/groupname/packagename.git’ syntax. The important part in my case is the ‘.git’. It will not function properly without that in my setup. I’m using access tokens along with an .insteadof configuration however, not ssh,
Can't speak too much on it, but I had an opportunity to switch a server (one to begin with) to Rust from Go. The server was needing a rewrite, and there are some tight memory constraints that had me feeling I needed to work around Go's GC, so I decided to give Rust another try. For a pinch of context, the server isn't terrible complicated, but it has to manage ~40gb fo data (and infinitely growing) and serve largely random sets of data up quickly. After enjoying Rust so much in that rewrite, it has since spread to 3 other servers, with more to come. Though, the original rewrite is the only one that "made sense", the other Rust implementations were merely because I liked Rust, and it wasn't worse for the tasks at hand.
It's that a follower of Uncle Bob trying to poison go with "TDD" and "clean coffee"? I'll just post this http://www.opowell.com/post/casey-muratori-on-clean-code/
I was holding my breath that MAYBE this would be a tool to reduce the amount of yaml I write daily. Writing a dockerfile and building it is the least tedious part of deploying to k8s imo
Nothing fundamentally dangerous, as far as I can see. It would probably just be confusing to have both Read() and ReadRecord() which do similar things. Especially since readRecord() is "disconnected" from the ReuseRecord option: setting it to true doesn't affect how readRecord() works. Instead you have to pass in nil, which isn't as intuitive.
What is wrong with straight if statements?
I make a group , so that anyone who join me
But Why?
I like the idea of using a sync pool! But I think the reason the standard lib CSV package doesn't expose this function or use a sync pool internally is because CSV files are likely not read by more than one routine at a time. I suspect disk IO would be the bottleneck.
I fix , now enjoy
The error is telling you the problem. The negative look ahead in your expression is not supported. You can’t use the `(?!.*\s)` portion with the standard `regexp` package. You should read the documentation at: https://golang.org/pkg/regexp/ And the syntax info: https://golang.org/s/re2syntax
I don't know about subreddit ?
Skimming through the article it seems to me it has nothing to do with Bob Martin, but rather is a quite well written set of best Go practices regarding small things like naming, making small functions, thinking about scope, and so on.
I’d avoid this approach unless there was a performance requirement. It’s clever but not obvious.
The pattern approach seems find to me. Just don’t expose that mechanism to the user.
Canceling database query when a client prematurely closes an http request connection.
Don’t store connections in package level variables.
Whomever wrote that blog has a poor grasp on the English language and it's syntax (mainly punctuation), as well as a poor grasp on the concepts and/or a poor grasp on how to explain a concept in an easy-to-follow manner.
Nope, no GOPROXY environment variable is set. Thanks for bringing that to my attention though; I'll take a look at it to see if it's able to help at all.
In the target project's \`go.mod\` file, it defines it's own name as \`[mygitlabhost.com/group/subgroup/repo.git\`](https://mygitlabhost.com/group/subgroup/repo.git`). I also include the '.git' when attempting to \`go get\`, but the issue persists. I've also set a \`https.extraheader\` value to include a PRIVATE-TOKEN header (not a very secure approach, but I've been giving everything a go).
Use early exits instead of if else. I try to never use else statements. If x { // Do stuff Return result } If y { // Do stuff Return result } Return result This is easy to read, and we don't have a bunch of else conditions. If you need to some logical nesting then you can wrap the // do stuff sections in functions with the same early exit pattern so that you don't get any nesting.
Lisp is the de facto example of a functional language? Most implementations have side effects galore. AFAIK, the first ANSI standardized OOP was CLOS for Common Lisp.
All finished now. It was great. In addition to the hints, it would be great if, after you solved a level, you showed the actual solution you had in mind, so we can see how we could have done things differently. Also, there is probably room for a level involving something more interesting with channels. The queue had a very basic copy paste solution. This had me enthralled. Not many games or activities do that these days. Thank you very much.
Hah, must admit, for "gallons pumped" I did briefly open up the developer options in Chrome and poke around 🤣
The correct place to do code review is before a merge not a push. Fmting, lining and vetting are part of the code refinement process but shouldn't interfere with a developer backing up his repo.
Many people do this. There's a project called "pre-commit" which interprets a file called .pre-commit-config.yaml that's checked in to your Git repo and creates a Git hook at .git/hooks/pre-commit. We use our YAML file to run go fmt, go vet, go lint.
Off course not, it was just an illustration
Those aren’t just best Go practices. Those are best general programming practices.
The article has two main parts: Introduction to Clean Code, and Clean Go. The first part discusses general programming practices, while the second part discusses Go-specific things, like error handling, pointers, closures, and interfaces.
Clever answer.
Personally I cannot stand git hooks, they're so obnoxious. I end up just using --no-verify. Like the others said, linting and other style enforcements should be part of PR approval or CI, just like testing.
Eh I would argue that every language has its own little caveats, sure clean code is clean code, but it can look quite a bit different from language to language. Like I would crucify someone on a code review in JS if they tried to write a 1 letter variable name
The standard library's csv package is not really intended to be the very best possible csv library in terms of performance or format support. The devs have said they'd probably design it differently if writing it for the first time today. It does weird things like changing line endings within parsed strings, and configuring it is awkward. So that's basically why it doesn't have a better API. It doesn't hurt to ask but I doubt they would want to add more stuff to the API at this point.
Disk IO is definitely going to be the bottleneck. Best to have one reader doing parsing, which is going to be pretty minor all things considered, then feed those off to the workers.
https://github.com/Pungyeon/clean-go-article#comments Clean Go Code suggests code comments consisting of full sentences but without proper capitalization and punctuation? Thanks, but you lost me there. Now I'm back to writing my Dirty Go Code.
&gt; if(dateWord ==true &amp;&amp; date==true &amp;&amp; Startedate==true &amp;&amp; Categories==ture). `date == true` == `date`
Sure, but having (some of) them in a pre-commit hook ensures that at least to some degree your code will pass the most basic checks in the CI. Nothing more annoying than seeing CI fails because of a lint issue. It is annoying because CI is asynchronous (depending on how busy your on-premise or machines in the cloud are). Locally, it is synchronous. And nothing stops you from editing files in the meantime (as long as you do not save :)).
I used it in the past and don't remember any significant problems. The most noticeable problem is the use of cgo, which slows down your `go build` and `go test` executions a lot - but this is of course not specific to this package.
Not sure how I shall understand that remark? I know that "this is the Iris guy" is a well-founded warning, but "this is the fasthttp guy" rings no bell with me. What happened?
That’s the whole point I want to reduce verbosity and if-else will become verbose and male moths lengthy
Okay, that is nice to know. How complete is the binding? And what about styling in qt in general? Ideally I'm looking for material design.
If I'm pushing and need it to pass ci then I just run the lint and tests locally manually. Granted I do forget sometimes and having CI fail on lint is annoying. A lot of time I'm working on a feature with a coworker so I'll push WIP commits so they arent blocked. My contribution to a feature may be 3 or 4 commits over a few hours so if it's auto linting each time it can be a bit much.
I use this alot and it's become my go-to framework for apps. Two projects I have built using it: An end to end encrypted file sharing prototype: https://github.com/amlwwalker/wingit An example app to make getting started using this library easier and quicker: https://github.com/amlwwalker/got-qt The second has videos in the readme. Highly recommend and active repo.
goose and gorch made me lol!
Could you help me please? Getting: \~/go/src/goase$ go get -u [github.com/thda/tds](https://github.com/thda/tds) \# [github.com/thda/tds](https://github.com/thda/tds) ../github.com/thda/tds/session.go:351: undefined: driver.TxOptions ../github.com/thda/tds/session.go:368: undefined: driver.TxOptions ../github.com/thda/tds/session.go:377: undefined: sql.IsolationLevel ../github.com/thda/tds/session.go:377: undefined: sql.LevelDefault ../github.com/thda/tds/session.go:445: undefined: driver.NamedValue ../github.com/thda/tds/session.go:479: undefined: driver.NamedValue ../github.com/thda/tds/stmt.go:151: undefined: driver.NamedValue ../github.com/thda/tds/stmt.go:187: undefined: driver.NamedValue
repost of [https://www.reddit.com/r/golang/comments/c2gtri/regular\_expression\_in\_golang/](https://www.reddit.com/r/golang/comments/c2gtri/regular_expression_in_golang/)
coc.nvim is very easy to setup. I have to pin vim-go at v1.19.
Why? Use the if-else chain.
From what I remember, there wasn't anything missing that I needed, and the Hithub page suggests very little is missing. Also not sure about styling, but [this page](https://github.com/therecipe/qt/issues/82) contains an example of using Material style. In short, it's definitely the most capable package for creating GUIs in Go right now, despite the less-than-ideal use of cgo.
I highly recommend to do this whenever anyone creates a PR. For example I do all my work on github: \- pushing to protected branches is impossible (master, demo, dev) \- opening a PR triggers a set of checks (vulnerabilities, code quality, build, tests) \- a failure (of e.g. quality) blocks the merge to the protected branches (but can be overridden)
Casey Muratori writes tests and if you listen to more recent uncle bob talks, he says that it doesn’t really matter when you write your tests as long as they are good and you run them before committing. Also if you listen to what he uncle bob means by clean code you’ll see that he isn’t talking about the elegance you get out of stuff like map filter reduce, but instead the type of things that lead to clarity and readability, which if anything is the opposite of the brittleness of complex function composition (at least in languages not equipped to do that kind of work)
Previously posted 5 days ago: [https://www.reddit.com/r/golang/comments/c0x29l/writing\_clean\_go](https://www.reddit.com/r/golang/comments/c0x29l/writing_clean_go)
Sounds neat. &amp;#x200B; Contributing is certainly a great idea to show that you're active within whatever community you're interested in. Projects on the other hand are a great way to show skills that would be relevant the sorts of product development they're doing. If you have a demo of something you've built, tested, and maybe even CI/CD then that will go a long way to proving what you're capable of. That said, if you're able to put some time into making contributions to say Kubernetes or something surrounding it then that too would certainly help out. This might be a good place to start [https://github.com/trending/go?since=monthly](https://github.com/trending/go?since=monthly)
Not only that, but it directly states in Go's code review comments that [documentation] comments should be sentences. https://github.com/golang/go/wiki/CodeReviewComments#comment-sentences Also, variable names. In his article he says that you should use a variable of `worker_id` over `i` shown in a very local scope when again the code review docs say explicitly not to do so.
I hope that auth key in the GIFs has expired/is fake....
the auth key shown in the GIFs was created just for purpose of demo and had deleted already. Thanks for that
Dude. Don't post you opinions as though they are true. You make tons of mistakes in the article, and inexperienced Go developers might listen to you.
https://golang.org/pkg/crypto/x509/#Certificate Certificate.NotAfter ?
Interesting. Can you post the go.mod file for the dependency you’re trying to go get?
Already noticed! I've been able to complete the whole story. It was very fun and I need more! Any plans to do it with other languages like Rust or Python? :)
This is awesome! On the last note about supporting new architectures from their PDFs: yes, all documents are machine readable, but are we really structuring manuals that consistently?
Actually it does handle the case you mentioned. Like, if you force-kill the parent process(main program), child processes will die too by the operating system. That's why I'm using job object here.
Cool, I'll check them out. Is it considered best practice to use qml to write qt applications?
The fact that this comment has 10 upvotes, makes me really sad. I don't understand where this anger is coming from? If you look at the post which I posted a few days ago, I am very explicitly open to ideas. Ideally I would like this to become a community driven resource, but I just wanted to make the first part of the push of making \_something\_ happen. Of course, there are mistakes in there and I hope that they all will be fixed at some point. I encourage you to contributing with constructive feedback, rather than snarky comments. But of course, you are free to do what you please.
I think you read that wrong.... that was an example of how not to do it.. :D
Oh dear, I don't disagree with the fact that review comments should be sentences. Of course they should. I thought I had distinguished between documentation comments and more ad-hoc comments. But perhaps not? &amp;#x200B; As for variables names, I clarify this later in the article. But yes, I agree with you, when scope is local, variable names can / should be short.
I understand. It is annoying at times, but I still feel it is better in the long run :) But of course, nothing of this is set in stone and you should use what works best for you (and your team).
Thank you &lt;3
Ahh. Okay you're right on this regard. "Annotation comments, for documentation, should be written like documentation." I didn't totally catch the implication you made instead of what you showed. My apologies.
This is a rabbitmq question, not a go question.
No need to apologise! I really love that people are taking their time to give feedback.... I really appreciate it. So, thank you!
&gt;And so, to the point that we care about how clean code is, we only care about that in so far as it has an affect on our end product. – Casey Muratori Thanks Casey, so basically \_all\_ code.
Cool, these are nice and clean, only small comments I'd have if code-reviewing would be that in tests, assert.Equal has the expected value as the second argument, while you have the actual func Equal(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool and that your test for sorted is a bit convoluted with the making the array a string, if you're only testing with ints you could just used the builtin: arrs := []int{1, 3, 4, 2, 8, 5, 6, 7, 9, 0} sort.Ints(arrs) fmt.Println(arrs)
It's fine, if you want to review my code
Well qml is the UI layout language for Qt applications, but I suppose you mean as opposed to generating the elements in go/c++ code...? I guess it's what your feel you prefer, both have benefits, however I prefer separation of concerns and have never enjoyed writing UIs as part of my business logic whether it be Swing in Java or QtObjects in Qt. Once the code is compiled it's binary anyway, so I will always write my Qt application UI in qml unless someone's points out some disastrously reason not to. I actually have managed to get designers to use and like Qml and that has been massively helpful as they aren't going to learn Go bit they can still develop my UIs for me. I think whenever a business use case is a valid argument for something, that holds a lot of merit over the purist developer choice, which can often just come down to a language war and hefty bias. People here may hate me for saying that, but it tends to be a rule of thumb I've followed and benefited from in the past. I will however change my mind if there is a serious technical cost and I haven't seen that here. In fact I've seen huge benefit from writing my UI in qml over QtObjects. I might have missed the point of your question tho...
Stopped reading after the interfaces section. He does the opposite of what the Go Wiki and Code Review Comments say.
I'm aware of that. That's about the comment text, but you can easily see I've discussed its wrong form only.
I update my blog, checkout
Why would you back up to Google Drive? Use a real object store like S3. Google Drive has a lot of limitations like storage limits/pricing/etc.
Yes, all languages are in the table. On the homepage you can sign up for the interest lost and I'll let you know when new ones launch.
Cool, thanks for the feedback :) I'm definitely planning on a sequel with Go to dive into some of the other parts of the language.
That's only for projects backup. Things stored to s3 in my case limited to application assets like images, files attachment, etc. Google drive's pricing not an issue since the lowest plan can cover and the backup files only store at least 4 latest's date. Based on your suggestion, seems like i need to add new storage driver such as s3 and dropbox. Thanks for input
I come from a JavaFX background - the only UI framework I've used a little extensively (PyQt being the other one, a long time back). So, I'm speaking with relatively lesser experience. I've used the analogous of qml in JavaFX (fxml) and I agree with your point of separating concerns. I'm just trying to get the maximum inputs from you! :D Seems like a bit of qt documentation is waiting for me though. I think I've made my decision and I'll get to it. &amp;#x200B; BTW, if you're interested in the JavaFX app I'm talking about, it's a word game - [https://github.com/gravetii/wordagam](https://github.com/gravetii/wordagam)
I'm worried my application's code haven't written properly and followed golang standard best practice.
BTW, I'm developing something similar to your wingit project - https://github.com/gravetii/diztl
Cool, If you want to chat feel free to DM me. WingIt is a prototype/PoC I was using to demo to work what we "could" do. I'm working on an evolution of it now with a larger budget and team.... I find the whole go/qml experience really nice and love the cross platform compilation a lovely feature to have.
Tbh I learnt mainly from the tutorials, use qmlscene to compile your code, get a good syntax highlighter and you'll pick it up in no time.
Have you thought of using `switch` https://golang.org/doc/effective_go.html#switch
Sure thing! I'm also looking to evaluate using JavaFX with a JNI approach and a Go backend, but it doesn't feel too elegant to me for some reason. I'll put some time into evaluating qt and see how it goes.
I love how all "two page long if-else statement writing / fuck it, it works with O(!N)" lovers swarmed in here. Great read though, thank you!
qmlscene is part of the Qt creator right?
If you need more advanced regexp features, you will have to look outside the stdlib. I've been using https://godoc.org/github.com/dlclark/regexp on rare occasions
https://github.com/jhinrichsen/cert-validity-bounds
You're overly confident in your article. A newbie can't distinguish between tried, tested practices and your own opinion. I understand that you only want to share what you know and be helpful. So do I. Just add disclaimers. Attach references when you have them. If you don't have a reference, mark it clearly. You can look at Wikipedia for an example. This post, in comparison to your previous post, has no explanation. No mention of it being a draft. The anger comes from years of reading this kind of articles and assuming that the guy who wrote the article has actual proven experience working like this. I also assumed that the amount of upvotes/stars/likes are there as agreement with the content of the article. Now I know how mistaken I was. The real anger comes from no one dares to call BS because the author is actually really nice and he's doing his best.
Your link is broken now.
Just started developing this so comments are welcome. Problem it solves: type Foo struct {/*huge struct*/} var x Foo binary.Read(r, binary.LittleEndian, &amp;x) Now you can dump the struct but you can't get the file offsets nicely. With this you get something like [this screenshot](https://raw.githubusercontent.com/raspi/annotatorreader/master/_example/screenshot.png).
When u install Qt it will end up in your /usr/bin qtcreator I don't use.... Qt qml tutorials, I think just Google it, there's step by steps... Soz don't have a link available right now
I've always felt like Uncle Bob's early TDD obsession has caused more problems with developers than it solved. He was way too rigid and his ideas caused too many people to go completely polar opposite of him to the point where you had people like James Coplien basically saying don't write any unit tests at all. I'm really glad he has softened on these statements lately. Also, the concept of "clean code" has always been silly to me because it can mean just about anything. The goal of programming is to 1) solve a problem, and 2) make your code as easy to follow and maintain for the future as possible. Clean code could apply to 2 but your code doesn't have to be "clean" to be easy to follow and maintain.
This might just be a matter of preference, but I see this sort of pattern a lot in your code: ``` if len(q.Items) &gt; 0 { item := q.Items[len(q.Items)-1] q.Items = q.Items[0 : len(q.Items)-1] return item } else { return nil } ``` You could change this to something like this: ``` if len(q.Items) &gt; 0 { item := q.Items[len(q.Items)-1] q.Items = q.Items[0 : len(q.Items)-1] return item } return nil ``` In Go, I think the general consensus is to try and put any exception cases inside if statements, so it may be preferable to do something like this: ``` if len(q.Items) == 0 { return nil } item := q.Items[len(q.Items)-1] q.Items = q.Items[0 : len(q.Items)-1] return item ```
A couple of comments: First, TDD isn't a panacea. If you're designing an API, TDD can be the wrong thing to do, because the most straightforwardly testable API is not necessarily the best API for the end user. I prefer to design an API first, and let the API drive the design. Secondly, in the section on method names, `fileExtension(filepath)` is redundant. Just as `Parse` doesn't need to be `ParseFile`, so `extension(filepath)` suffices for computing the extension if there's nothing else you're likely to be computing extensions of. (If you're writing PABX software, of course, you might want to be more verbose.) Note that the standard library goes even further and just calls the method `Ext`.
Happy you enjoyed it! Yeah, some of the comments here are a little curious :) But honestly, I expected much worse... People seem to have very strong opinions about this topic.
I have ;)
\&gt; First, TDD isn't a panacea I 100% agree. \&gt; extension(filepath) suffices I would actually agree with this as well, especially if it is contained within it's own package. In my opinion having a file package with an \`extension\` function, is nice than creating a \`fileExtension\` function.... Perhaps the example is just a bit shit..... would you find it more appropriate / helpful if the article had it as a package function (i.e \`file.Extension\`) and did some further explanation regarding this? Also, thanks a lot for the feedback, reall appreciate it &lt;3
Uncle Bob is basically a fraud. Anyone whose main income is not from actual programming but from telling others how they should program should be seen as nothing but a fraud.
I love it. I'm also not native English speaker, so I won't help you with the english. Concurrency is not well taught in schools, and it's hard to get an intuition for it
Wrong
Thanks, feel free to tell if you think something can be improved 😸
https://github.com/carlmjohnson/certinfo
I believe u/joncalhoun is working on something like that. [https://www.calhoun.io/progress/new-course-website-and-algorithms-with-go-updates/](https://www.calhoun.io/progress/new-course-website-and-algorithms-with-go-updates/)
In the [section on Naming-&gt;comments](https://github.com/Pungyeon/clean-go-article#Comments) there are no examples of good commenting. I would insert some links to the stdlib showing examples of logical notes that are hard to explain even with straightforward code.
This kind of approach turns code into microscopic chunks of code that hide complexity in a huge tree (or at worst a directed graph) of function calls. I much prefer [Ousterhout's approach](https://amzn/1732102201).
git is designed from the ground up to allow programmers to commit and work with code that doesn't even compile (see git bisect). The insistence that code not just work but be beautifully formatted before it's even committed leads the the terrible practice of committing a bunch of broken ugly code and then flattening the commits to give the illusion that it was done perfectly every time. This of course discards information about how the development was done, and thus discards the thought process of the developer. It also prevents developers from every backing up or check pointing their code which can lead to data and work loss. It's important to be able to work at different levels and consider different aspects independently while writing code. In fact some might argue that abstraction in that manner defines software development. Vetting, linting and fmting are a different level of abstraction than writing. Now, I think any good editor should be continuously running those helper tools, and your employees should be listening to their output (although there might be good reason why they aren't e.g false positives). However, forcing your employees to do it as they commit or push fundamentally interferes with their judgement as programmers and is attempt to solve a personal issue with technology which is inherently doomed to fail. Ultimately, if you can't trust your employees to do their jobs, don't hire them.
Good one, thanks
I didn't find it surprising. It seems natural to me. That bug was probably from poor style. When you want to return nil, you return nil, not some variable you think contains nil but doesn't. The practical case is when you are... using an interface. If the underlying type implements the methods with support for nil like it should, it doesn't make sense to be unable to distinguish that from an actual nil.
&gt; That bug was probably from poor style. When you want to return nil, you return nil Here's an example that reproduces the type of issue I saw: https://play.golang.org/p/UkEyU8jaFuM So, I returned `nil` from one function, but because it got wrapped up in an `error` interface by the second function, the nil is not propagated. A comparison with `nil` will fail, but printing it out prints `nil`, and calling `.Error()` on it will panic (which you can fix that by making `Error()` have a pointer receiver, but oddly `fmt.Println` actually checks for nil content so it won't even try to call it if it would panic). &gt; edit: I'm guessing you're coming from a language like Java where invoking a method on a null value is itself an error. I've been programming in Go since just before it was released, so something like 10 years. I ran into this issue around 1-2 years in, and it still occasionally bites me because it's so easy to make a mistake. However, I usually spot it a lot faster now _because_ I've had trouble with it in the past. I'm coming from a variety of languages. I did Java a lot in college, but most of my professional experience is with Go, JavaScript, and Python (though I'm dabbling a bit in Rust ATM), with a few random other languages (C++, C#, Lua, etc). I don't think I've used a single language with this type of surprise. If I return `nil/null/None` from a function, that value is always `nil/null/None`, but in Go it can silently become non-nil. That's surprising, and IMO poor language design that could be rectified by treating nil content as nil, and I don't think anyone would _really_ complain (except perhaps language design purists).
Since that's just a build cache, it's safe to delete it all and let go rebuild it as needed.
All feedback welcome, especially if you managed to interact with Python already :)
Hey, i think it's a really good idea with an example of good commenting! I will think about that for next iteration. Also, thank you so much for your pull request. The reason why I use the HTML tags is just because of the editor I'm using. When converting to PDF, it looks a little nicer with the HTML.... It was a pure oversight that the center tag didn't render on GitHub
Maybe `go clean -something`? Try `go help clean` to see if there is something useful there.
You're welcome, I left the comment then figured I would just send a PR and see what you said.
yes but its my first learning project here thats why things go big and im on a journey here learning different parts so havent jumped into structuring things nicely yet. in the end i want to clean it all up and see if some of it can be made into a package but now i just sorted it out with alot of mains grouped in functionality so i can keep it abit more under control and it works great.
Just finished, a very fun riddle indeed. Did you think about letting players submit their solutions? It can be very interesting to see how others solved each step on the way. Thanks for this one, I've enjoyed it a bunch.
I’ve used the bindings several times now - the portability between platforms being a major driver. I write on a Mac and cross-compile for iOS, Android and Windows - pretty much seamless experience bar a couple of minor issues. Solid library, works well. Frustrating at times to translate from the Qt C++ to Go but once you’ve you’ve got your head around the basics, it all drops into place. Worth the effort. A great responsive repo owner too. WASM still seems a little patchy but that’s under development at the moment. Not sure if this week’s Qt update will help in that regard.
The errors return from those functions are instances of [\*NumError](http://127.0.0.1:9000/pkg/strconv/#NumError). [Type assert](http://127.0.0.1:9000/ref/spec#Type_assertions) them to that type and then do as you will with the fields in NumError.
Not a word about audits or background of developers. I can put up some crypto code on Github as well but I certainly wouldn't advise you to use it. I don't know what to think about this in that context.
It sounds to me like you haven't enabled the module (vgo) support in the Go section of your project settings in Goland. There should be no need for symlinks or GOPATH with modules and if your IDE knows about it. Technical the Go.mod doesn't have to be at the root of a project. It indicates to the tooling where the root of your packages will live under the module import path. But it makes sense at the root for an all-go project. You should be fine using it self contained as a branch if you fix that setting.
You're right! I made that change just now and everything worked immediately without the symlink, thank you!
`func (m C.matcher) CalculateDistance(l C.lead, p C.property)` At first I was like "woah you can attach methods to C types?". But then I wondered if this is a typo. It's being treated as a function and there is no defined C matcher
If Goland is behaving properly, it should really detect the Go.mod file and suggest in a pop-up for you to enable module support.
I do remember getting popups to that effect, I suppose I must've x'd them out without thinking... I'm *very* new to Go lol
The article explicitly states the project is for experimentation. Hell they even say you shouldn't really use it in production: &gt;The CIRCL library is offered as-is, and without a guarantee. Therefore, it is expected that changes in the code, repository, and API occur in the future. We recommend to take caution before using this library in a production application since part of its content is experimental.
[removed]
They say that the code and API can change and that is their reason for not using it in production. This is a different concern than I presented.
Sorry for the late response, but I thought this was a great question. Either is acceptable in English, because we have multiple ways of thinking about websites: as a static repository of information ("... at a website") or as a particular device that holds the info ("... on a website"). [https://english.stackexchange.com/questions/3491/this-question-has-been-asked-at-stack-overflow-vs-on-stack-overflow](https://english.stackexchange.com/questions/3491/this-question-has-been-asked-at-stack-overflow-vs-on-stack-overflow)
I am currently in uni, doing a SWE summer intrenship. Do you guys have summer/year-long internships or can it be arranged? I really want to work at Monzo and get to see the culture. I will be looking for an year log placement soon and Monzo, if possible, is my first choice (with the FANG of course)
[removed]
\&gt; I don't know what to think about this in that context. What's so difficult about not using it? You sound like some vast conspiracy is going on to make people use this software. &amp;#x200B; If you are skeptic about this (and this is good thing) then what is use of author's background, as it would be just appeal to authority. You should be having your own independent audit of this code.
You can search this very subreddit for discussions. It pretty much comes down to "fasthttp isn't http, it's can only handle what was sent by the handful of things the author tried running against it". That's not a great development philosophy, IMHO.
[removed]
Advanced gave it away, look at my supreme!
Thank you for your suggestion, great.
Is this related to CIRCL of MISP funding at all?
[removed]
[removed]
This is/was a great talk!
Make sure you read the license super closely. It’s not free for non GPL uses. And he’ll say “but it’s LGPL” and then you’ll realize go doesn’t do dynamic linking.
Not a "have to" by any means. `map[string]*json.RawMessage` etc.
 About assert.Equal, I use this package: [https://godoc.org/gotest.tools/assert#Equal](https://godoc.org/gotest.tools/assert#Equal) , It does not distinguish between the position of expect and actual. After that, I find another package: [https://godoc.org/github.com/stretchr/testify/require#Equal](https://godoc.org/github.com/stretchr/testify/require#Equal), It clearly distinguishes the position of expect and actual, I think it great, I will use it to replace [gotest.tools](https://gotest.tools). Thank you for your suggestion.
Yes, my bad, this is a typo. Thank you for the feedback!
Yes I know. I always love a good talk on Go internals.
See rclone.org !
Yes, that's a great suggestion. It would be easy enough to have a "share my answers" link. Curious how the prior could sit through and find the most interesting / unique ones though. Any ideas?
I've had luck interacting between python and Go like this. In my case we had a python library that we wanted to speed up in a specific component by writing it in Go. Because of the limitations in only being able to communicate in C structs, sometimes I found it easier to just serialize my input to json, pass it through the exported function to Go, and deserialize it to a Go struct.
Yes, I think it is definitely the easiest way. I am also considering that to avoid headaches with that code... Thank you for your feedback
Fantastic way to tackle such a complex topic, loved the approach of building a scheduler from scratch to slowly add-on the required functionality and avoid the pitfalls that came up.
My original idea was to suggest scoring players based on how many unique solutions they provide to each level and that level's difficulty; this can make the fun go on after completion of the first round of solutions. But, this raises the same question- how do we know that a solution is unique? I think a good starting point can be allowing players vote and comment on others' solutions. My experience was finishing the game and at the same spot rushing back to this thread to see what tricks others used to get the job done. Having a ranking system allows players to interact with each other, rewarding creative solutions and critical thinking, thus adding a new dimension to the chase ;) As for the question, if the solutions are sorted by upvotes/scores it can imply that the first ones might be more interesting. **This section includes spoilers** The question of uniqueness still stands but in general maybe using pattern matching to negate the use of particular techniques and working by elimination? For example [SPOILER](/the use of Mutex can be easily identified) same goes for [SPOILER](/using JSON tags in structs).
Looks promising.. thanks
I use neomake - [https://github.com/neomake/neomake](https://github.com/neomake/neomake) &amp;#x200B; I like to lint/vet my buffers when I save them to file: \`let g:neomake\_go\_enabled\_makers = \['go', 'golint', 'go vet'\]\`
&gt;But having them in a pre-commit hook too helps devs to avoid having to incur the time sink of all of that. I find this to be a terrible attitude. Code clarity and maintainability is something that developers should personally be striving to uphold, not lazily ignoring as some annoying "time-sink". Committing sloppy code because "it will just get fixed" is the hallmark of bad programmers.
Nice. Did you write it as a project to learn Go? You should take a look at http://coredns.io/
I can't follow this logic, so I think you misunderstood the suggestion. Sloppy code is rejected immediately, before it is even committed. If the pre-commit hook wasn't there, it would be rejected a few minutes after it is pushed to a branch, by CI. The time sink is simply those few minutes.
On supported Linux filesystems, files are preallocated using [fallocate](http://man7.org/linux/man-pages/man2/fallocate.2.html). [Windows support](https://git.sr.ht/~tslocum/preallocate/tree/master/preallocate_windows.go) is 100% boosted from [rclone](https://github.com/ncw/rclone/blob/master/backend/local/preallocate_windows.go). This library was created for [gophast - download manager and accelerator](https://git.sr.ht/~tslocum/gophast).
Thanks for the additional feedback. I've updated sponge again, hopefully it is satisfactory ;)
This is a fun project. Nice work. If you want to extend it further, I would first look at how you have defined domain names. It's not quite accurate. Yes, a domain name is a series of labels ending in a 0 length label, but it is not {length}{label}{length}{label}{length=0} only. There's a special value that can be placed instead of the length, that indicates an arbitrary offset into the packet, where you should continue reading. This allows packet authors to reduce the size of generated packets that contain long domains. For example, if you had hello.web.example.com, world.web.example.com, and something.example.com, you might find the packet actually contains {5}{hello}{goto @w}, {5}{world}@w{3}{web}{goto @e}, and {9}{something}@e{6}{example}{3}{com}{0}, where by the inline @'s I mean the addresses the goto's target. I hope I written that understandably. To see a better example and the original specification, look to the RFC. Section 4.1.4 of https://tools.ietf.org/html/rfc1035 discusses it. http://www.tcpipguide.com/free/t_DNSNameNotationandMessageCompressionTechnique-2.htm also seems to discuss it nicely. Doing this will add a fair bit of fun to your code. Obviously, following a series of arbitrary offsets could easily end you in a loop ( you'll need to track pointer recursion depth and decide when enough is enough ), or could direct you to read off the end of the packet ( which you'll generally want to avoid ). Additionally, you'll need access to the full packet inside each resource record parser so that if they should happen to need this name compression recursion, you'll be ready for them. It's not enough to merely have all the previous records, since there's nothing stopping some ingenious compressor out there from noticing the bytes representing an IPV6 address happens to be identical to the data it wants for a label in the middle of it and directing you to look there for said label. I've never happened across a packet doing that, but there's no rules against it either. The offset is arbitrary.
 [https://koohinoorgo.blogspot.com/2019/06/do-i-receiver-nil-argument.html](https://koohinoorgo.blogspot.com/2019/06/do-i-receiver-nil-argument.html)
For an interesting take on architecture/design I'd highly recommend Ralph Westphal: [new blog](https://ralfw.de/category/english) and [older blog](http://geekswithblogs.net/theArchitectsNapkin). Especially the [IODA architecture](http://geekswithblogs.net/theArchitectsNapkin/archive/2015/04/29/the-ioda-architecture.aspx) article.
Useful. Clear and concise. A great resource for people getting started (sort of like me!)
From Mozilla: bool mozilla::fallocate(PRFileDesc *aFD, PRInt64 aLength) { #if defined(HAVE_POSIX_FALLOCATE) return posix_fallocate(PR_FileDesc2NativeHandle(aFD), 0, aLength) == 0; #elif defined(XP_WIN) return PR_Seek64(aFD, aLength, PR_SEEK_SET) == aLength &amp;&amp; 0 != SetEndOfFile((HANDLE)PR_FileDesc2NativeHandle(aFD)); #elif defined(XP_MACOSX) int fd = PR_FileDesc2NativeHandle(aFD); fstore_t store = {F_ALLOCATECONTIG, F_PEOFPOSMODE, 0, aLength}; // Try to get a continous chunk of disk space int ret = fcntl(fd, F_PREALLOCATE, &amp;store); if(-1 == ret){ // OK, perhaps we are too fragmented, allocate non-continuous store.fst_flags = F_ALLOCATEALL; ret = fcntl(fd, F_PREALLOCATE, &amp;store); if (-1 == ret) return false; } return 0 == ftruncate(fd, aLength);
I was curious myself so I did a quick search, the only thing i found is that fasthttp seems to value speed over RFC compliance. https://groups.google.com/forum/#!topic/golang-nuts/OaQu4QezAr0/discussion
Awesome, thanks for the thoughtful feedback and ideas. I'll look into implementing something like this!
I feel like this ultra-cringe-inducing backronym makes it really hard to figure out what’s the actual purpose of the library. Hard pass.
To clarify, this a name resolver. It's in no way an authoritative or even capable of caching from an authoritative name server. Not knocking your project, but there are a few DNS server implementations.
Have a look at CoreDNS.
I'm still very confused what the goal of your blog is. What about nil arguments? Also, ESPECIALLY WITH EXAMPLE CODE, good variable names are C R U C I A L. I'm not inexperienced, and I had (still am having, really) a very rough time trying tofollow your code, mainly due to variable names. some explanatory comments would be nice—perhaps start by explaining why you have a list as a global variable.
Why GPL though?
[removed]
Yeah I wrote one in C# using the protocol spec and a lot of NetCap data as test data. Learned a bunch about the built in run-length encoding. It was part of an automated datacentre bootstrap and provisioning system I wrote some large evil empire a long time ago. Was a really fun project - learned all about C#’s stack. https://github.com/stephbu/csharp-dns-server
I think Packt has a book regarding data structures and algorithms, but I don't know about it's quality
Maybe there’s a code-signing issue. You should ask in a Mac-dev place.
Come thru and wear a suit to get burned in.
Wow, this is really cool! Good shit man :)
&gt;The real anger comes from no one dares to call BS because the author is actually really nice and he's doing his best. &amp;#x200B; I was kinda sure about these being far from good practices, but you're the hero of the day for pointing this out. Seems that people can't draw the line between nice, enthusiastic (trying to be nice too with the choose of the words)... And rightful. &amp;#x200B; Also, this ton of wannabe useful tips has been published on [the Go Gazzette](http://www.go-gazette.com/issues/writing-clean-golang-communicate-between-go-python-or-r-gophish-more-184197) too... I have to double, triple check my sauces now.
Because anyone publishing free and open source code can chose whatever licence he/she likes?
Just wanted to say \*something\* since you're not getting a ton of feedback. I've yet to closely evaluate your work, but I really appreciate you publishing it. I'm working with a lot of Earth data, and this could be very useful. At first glance, everything appears well written, with an intuitive interface. Thank you!
While that's technically the truth, that was a painfully inefficient and useless answer I'm pretty sure the original question was meant to be understood as "what are the author's reasons for making it GPL"
Thanks, I really appreciate the support
Pretty glad about the conclusion. Thanks for sharing this. It's quite cool. I take it the python team have to work out how to import this? I'd be interested in seeing what the code looks like
who that actually books him for their software consultancy has said he is a fraud? I've found his ideas influential. I've paid for some of his more accessible cheap offerings (compared to flying him in, or hiring him as a consultant); and if at any point I don't want to follow his advice, then I simply do not. If I don't want to buy his things, I don't. If they don't fit I don't use them. The main problem is that a lot of people want to walk like sheep and be told exactly what to type like some thin-client version of a human being
I just drink two coffees when I need to take a dump
This is great man! I definitely needed a tool like this. Mucho Thanks!
It seems like english is not the main language of the Poster, I understand communication skills are very important for individual success. But empathy is great for our collective success. I hope you care enough about humans to not just see a username, but know that there is a human that worked hard to build something open source.
Awesome stuff. The only thing I’d change is use a multistage build in Docker. Your images will be like ~15MB as a result.
Yeah, I saw a video on youtube explaining why that is. If I find it I will post here.
Hi. Some quick remarks: * Do not commit the built binary in Git. It will bloat the repository. Use Github's Releases to upload your binaries, if needed. * You don't need to insert the entire GPL license on your source headers. Look [here](https://www.gnu.org/licenses/gpl-howto.html). About Go, I'm not experienced enough on the language to comment :-)
Yeah, I mentioned that approach about half way through, I am planning a follow up on just that very topic! :D
Oh sorry if you mentioned it. I honestly skimmed the video with no sound and read all the files.
i’d like to try DigitalOcean. but their credit card only payment is a bummer. i only have a prepaid debit card. same for Azure. Azure even charged me a dollar only to tell me it doesnt accept debit cards. i was like, what?! AWS accepts it, i wish other providers did too.
https://stackoverflow.com/a/44367183 was answered, just use chan - same performance as *chan
There's shouldn't be anything special you need to do to make this work. Here's an example: [https://play.golang.org/p/sIJmguRT6xl](https://play.golang.org/p/sIJmguRT6xl)
Worse performance because *chan has to be dereferenced.
You don't need a pointer to a channel as channels are reference types, you could use a factory to store the chan in the struct at creation time, like: &amp;#x200B; \`\`\` type S struct { ch chan int } &amp;#x200B; func NewS(ch chan int) \*S { return &amp;S{ch: ch} } \`\`\` &amp;#x200B; then refer to the private field in your struct methods, but be aware that keeping a bunch of long-term references to a channel around can complicate cleanup if you decide to close the channel at some point.
Honestly why is that? It's a much better idea to use credit cards because they aren't linked directly to your money. It's a money proxy.
They also allow PayPal.
 help to dns protocol. thanks.
Hm. That’s what I tried but no message was being received. Maybe I messed up. I’ll look tomorrow and get back with you. Thank you again
How would you recommend this design be changed to not need long-term references to a channel?
Just pass the chan as an arg, as you've been doing.
I’ll post a code snippet tomorrow of what I tried. I’m pretty sure this is what I did, with bad results
Would be cool if it supported the official mongo-go-driver too.
I started to make it with official driver, but it was hard to deal with contexts. So, maybe I switch to official driver in near future.
Thank you for advices!
Updated. Thanks.
1. Hiding for loops is “bad practice” in Go - because it “hiding complexity”. 2. Go doesn’t have tail recursion optimization. 3. Here is no “copy on write” data structures. 4. All stdlib will not follow your linters or principles. Don’t choose most “anti-functional” language to write functional code. Just use GHC instead of linters.
Which FP patterns / style would you want to enforce with this tool? Last time I looked into FP in go, my conclusion was that it's just not feasible at this point, mainly due to the lack of support for parametric polymorphism. E.g. you'd need to define higher order functions (e.g. map, fold) for each possible function you want to pass in.
There was a talk by Francesc [1] on this a while ago. But he concluded that a functional style in Go gets ugly pretty quick. Go is meant to be written in a procedural way and it forces you on that path. Don't try to make it into something it is not. There are many great FPLs [2] out there. Maybe try one of those. [1] https://youtu.be/ouyHp2nJl0I [2] A few I like: Clojure, Haskell, Elixir, F#
This article was shared 3 times already in here. It’s not the best source to learn idiomatic go, there are many many things which aren’t correct at all
And one more thing. Most of People trying to use FP to achieve “safe parallelizm”. But in Go you can achieve it by follow 2 rules “use channels instead of shared memory”, “don’t send pointers to channel”.
https://github.com/luna-duclos/instrumentedsql/blob/master/README.md may help.
No offense taken. But you're right, I should clarify that. Thank you!
I've really just created it as a study project. I've added a note and a link to CoreDNS - thanks, I didn't know of that project.
&gt;https://github.com/stephbu/csharp-dns-server Cool project!
bad idea for the name
Please?
Or for a more general, standard way, use opencensus: https://godoc.org/github.com/opencensus-integrations/ocsql
This and her talk on channels are great.
Thank you for pointing me to DNS message compression, I wasn't aware of it. You're right that this could complicate things quite a bit. Initially my thoughts were that I don't really have to implement it, since I am only generating records and not parsing them - then I realized that I am indeed parsing records from the client's query and that I might not correctly identify compressed ones. In any case, thank you for the pointer and I added a note in the project to follow up on it.
Hey, what did you think was "aren't correct at all"? Totally open to making changes... As I mentioned in my original and last time it was posted, I understand this isn't perfect, but therefore encourage community feedback and contribution.
Awesome work dude! One comment I see a lot on my own videos is that the text is too small. It would be worth zooming in to your code either using your recording software, or by zooming in within VSCode using cmd - +
Why do you keep reposting it?
/u/Pungyeon only posted it [once on June 15th](https://old.reddit.com/r/golang/comments/c0x29l/writing_clean_go/); the other two re-posts were done by others who didn't bother to check/search before posting (this post and the other by /u/psxuaw [on June 21st](https://old.reddit.com/r/golang/comments/c341oa/clean_go_code/))
That's fair.
This.
Looks great. Is there any social channels for the project? You might want to grab the subreddit.
Please explain which things "not correct"
Hi! Welcome to Go! I am procrastinating from cleaning my apartment, so here is my CR. Overall, it seems like a nice CLI for the `github.com/nfnt/resize`. This could be useful for some people. As you point out, this is work in progress. As a general hint, don't add parameters that don't work yet. I will list every detail I notice - I know you are not doing anything serious, so you definitely shouldn't take this serious either. See it as things to consider in the future for other projects. Code: * package name - already covered. * Traditionally you would move your "main" to `cmd/girls` and not have your package as "main". This makes it impossible to use for anyone. * Documentation. Your exported types should have documentation. ``` // task ErrResImageType = 10 ``` error.go: * `type GirError` typo I suppose? * Your exported errors `ErrResImageType`, etc do not match the actual error, only the `No`. * `ErrorOut(no int, mark, msg string)`. Seems weird. A `func (e GirError) Print()` would be much more useful. girls.go: * Typically you would name the file with "main()" `main.go`. * No need to export `var Cmdline`. helper.go: * Start comments with function name. Capitalize words, no need for long param names. Example: ``` // Inlist checks whether s is in l. func InList(s string, l []string) bool { ``` * `helper_test.go` doesn't test much ;) resize.go: * Most of your functions here return a `(string, error)`. Document what `string` is. * `NewError(ErrOpenLocalImage, "open local image", err.Error())` - instead of converting the existing `error` to a string, maybe keep it as an `error`, so callers can inspect the value. * `resize.NearestNeighbor` if you are doing a resize library, do some basic research. This is without a doubt the worst option you could have chosen. (use bicubic/lanczos) * `newFile, _ := os.Create(save)` Check your errors! * `jpeg.Encode(newFile, newImg, &amp;jpeg.Options{85})` - wasn't there supposed to be a flag for quality? * `defer newFile.Close()` you might as well close it here, this is way too late. Move it to right after you've opened it. * `TestResize...` - you never really check that the outcome is *actually* saved/resized, just whether your function doesn't return an error. * `TestResizeHttpImage` - don't have your tests rely on external data. You can set up a local server to serve the files. See `net/http/httptest` package. task.go: * `type GirImage struct` - this should just be "Image". No need to prefix your types here. * `// GirImage.Resize used for various resource image type`... This documentation says nothing. * `type GirTask struct`.. again, could just as well be `Task`. * `fin: make(chan bool)` - this might as well be a `chan struct{}` since you are not using the bool anyway. * `GirTask` So the `data []byte` is the input file name or URL? Why is this a `[]byte`. And why is it called "data" - I assumed it was the image data. * `type GirImage struct`. I do like the `switch gi.resType {`. This could be an interface where the different types were implementations of it. Something like: ``` type Image interface { Resize() (string, error) } ``` * `func (gt *GirTask) IsEmpty() bool`. I personally prefer `Empty() bool` since the 'Is' is implied by the returned bool. * `log.Println("resize fail:", err)`: Consider whether this should be written to stderr instead. Also your program returns status code 0 even if something failed, maybe not the best idea. Nice concurrency work. Very good for a beginner! The only real problem I see is that you potentially start a lot of concurrent operations which may result in your program eating a lot of memory. Consider adding a limit to concurrently running operations. * `TestGirTask_ResizeImages`: Again, you are not really testing whether anything actually works. * `outDir := "/tmp/girls"` Not very friendly. Use `os.TempDir`. As I wrote, don't take this too seriously. Have fun. &lt;3
Be specific please
VictoriaMetrics core developer here. &gt; I read a couple articles from the author about it, and they sound like it's a company advertising its paid solution, but at the same time I don't see any pricing, enterprise offers or other monetization offers VictoriaMetrics provides [commercial support](https://github.com/VictoriaMetrics/VictoriaMetrics/wiki/FAQ#what-is-the-pricing-for-victoriametrics) for both single-node and cluster versions. &gt; This company rather looks like a one man show (see contributors page on github) which however constantly acts as a company - by speaking in third person or about us/we The company consists of four co-founders, including me. Read more [here](https://medium.com/faun/victoriametrics-creating-the-best-remote-storage-for-prometheus-5d92d66787ac). &gt; I wouldn't believe it until I tested it on my own because of my concerns It would be great if you test it on your own! Try substituting Thanos, Cortex or Uber M3 with VictoriaMetrics and share results with the community.
We already offer [commercial support](https://github.com/VictoriaMetrics/VictoriaMetrics/wiki/FAQ#what-is-the-pricing-for-victoriametrics) and plan launching paid SaaS and Cloud versions soon.
Right back at you
Thanos is hard to setup and tune comparing to the tested systems - InfluxDB, TimescaleDB and VictoriaMetrics. These systems provide production-ready Docker images with close-to-zero additional configuration. Thanos, on the other hand, requires [non-trivial setup](https://improbable.io/blog/thanos-prometheus-at-scale): - To configure Prometheus instances - To configure Thanos sidecars, store, compactor, querier and optional [receiver](https://github.com/improbable-eng/thanos/blob/master/docs/proposals/approved/201812_thanos-remote-receive.md) The [linked benchmark](https://medium.com/@valyala/measuring-vertical-scalability-for-time-series-databases-in-google-cloud-92550d78d8ae) doesn't mention Thanos, but it shows that a single-node VictoriaMetrics may accept 19M inserted rows per second and may perform thousands of heavy queries per minute. Heavy queries usually touch thousands of unique time series with millions of data points. Thanos is built on standard [Prometheus stack](https://github.com/prometheus/tsdb), which has lower performance comparing to VictoriaMetrics. So it is unlikely moderately sized Thanos cluster could achieve performance numbers shown by single-node VictoriaMetrics.
Could you give more information on this?
1. I agree with you on topic of pointer vs values, something similar I explained to my team member as "mindless overusing of pointers" 2. I like your thought about interfaces for inputs and concrete type for outputs 3. I am ambivalent for error variables 4. Naming, commenting,etc. - I prefer Rob Pike notes (with adaptation to go): https://www.lysator.liu.se/c/pikestyle.html Overall: good work, although I would consider to rename into something .. less pretentious maybe. Something like "Notes on good style in go" or similar
Really great video series! Easy to understand and follow. Appreciated your other videos on Chi as well. Watching these videos on a desktop PC the text is just right. I think you could've put all this into one video, but I'm sure you had your reason to split it up.
Long list of arguments is always leads to problems in reading code. And IDEs are not helping during github/gitlab reviews
Appreciate the encouragement! Thanks for the tip too, will definitely keep that mind for my following videos
Thanks for that! Really appreciate you saying. Let me know if there is a topic you'd be interested in hearing me cover in a future video. Had comments saying my previous videos were too long so I figured I'd experiment with breaking the videos up a little to see how people responded.
Rocket. I had some concerns about the performance but failed to find any meaningful benchmarks. Ultimately my concern for performance was speculation, and I figured I would only deeply follow if bottlenecks were discovered during benchmarking. Rocket was chosen because my shop is still heavily Python and *(and to a lesser extent)* Go. Rocket, as remarked by a coworker, looked shockingly similar to our Python web frameworks. I was introducing a rather complex language (Rust) by comparison of Py/Go, so I my choice of Rocket was a small measure of aiding familiarity among other devs. While they're not likely to be working on these projects anytime soon, I wanted to proactively minimize confusion where possible.
Something that is always interesting to me is how to implement more real world stuff. You could for example extend your series showing how to implement authorization for the api. How to deploy it to a prod environment, how to monitor the service etc..
Why don't you run it?
Thanks for feedback! As for the error variables, I get you. I included it, because I've had a lot of good experiences with using them and really like it when libraries include them. Could you elaborate on your thoughts? I will definitely have a look at the rob pike post and reflect :) Do you think the title is alienating certain community members?
I run it——it works, and try to find its problem. But I'm still not sure if it's safe.
Here's an example of where this behavior is perfectly reasonable: https://play.golang.org/p/pC3-KaBTqoO And here's your example, done correctly. https://play.golang.org/p/gYAKF8WeOW4
[removed]
It does block the goroutine there. But nobody waits that goroutine, so your main program won't block.
Go and Nodejs are good for that. You could you Sockets
Reducing your code, it is effectively the same as: [https://play.golang.org/p/O8DfXWuBdzP](https://play.golang.org/p/O8DfXWuBdzP) &amp;#x200B; Looping over the select, both channels can be received from: [https://play.golang.org/p/qwRi7-ociCy](https://play.golang.org/p/qwRi7-ociCy) &amp;#x200B; Using a done chan, the loop can be managed cleanly/flexibly (and the sleep can be dropped safely): [https://play.golang.org/p/wS0uCoYJwHJ](https://play.golang.org/p/wS0uCoYJwHJ) &amp;#x200B; Applying this to your code: [https://play.golang.org/p/\_NFtoWeohlP](https://play.golang.org/p/_NFtoWeohlP)
The select statement is unblocking the channel write being done by chanFunc in this example program
No love for Gitlab?
How does this differentiate itself from any other CI/CD solution?
I really do not understand this. In the other 2 post, there similar comments like yours, but no one explains, what is actually wrong with it. I think that this kind of criticism helps neighter the author, nor the readers here. Please elaborate more or make a PR to fix the wrong parts.
Thank you for your answer, this is the first time I have posted on reddit :), I really appreciate your answer so much, I carefully looked at the questions you pointed out, very fruitful, thank you very much.
Thanks for your guidance, I changed the name of the tool: goimgrz to make sure the purpose of the tool is clearer
Yes, English is not my main language, I have many skills to learn, good reading and communication through English is also one of them, because it becomes more and more basic in information communication.
You absolutely right, I should’ve explained what I thought was not very accurate and not just say it’s not correct. My bad. Anyway the frustration was mostly about people reposting it without checking. It shows that you did a very hard work at writing this, hat’s off to you for this. It’s just that like someone else said, many stuff there are not specific to go. In an article about clean go, I would expect for example a section on how to name the packages. (The all ‘don’t stutter’ rule) Other issues is as simple as that your code isn’t formatted, receivers aren’t named like the convention (one letter), and you have variable names with ‘_’. It seems stupid but these stuff are important imo. Other issue is when you suggest to add an exported type for an error. Dave Chaney has an awesome blog post where he explains why this is problematic. Check out his pkg/errors...
`github.com/miekg/dns` is the goto-package for anything-related-dns. It can be used low-level or high-level, depending on preference and need.
You're getting a rough reception here, the only sub that would even entertain this idea, because it's not a good fit. "Language $X is multi-paradigm!" is like some kind of magic armor people put on to avoid losing language-war arguments. Very few languages are "multi-paradigm" in any meaningful sense of the word. Go certainly is not meaningfully "Functional." It's like you posted in /r/france that you want to speak French but with meaningful tones like in Chinese because you heard that it can make your sentences more expressive. Just learn Chinese.
You are right.
Thanks a lot, this is exactly the kind of feedback I was hoping for! I think you are right that there is a section missing on package naming. This would be really useful. About the variables with "\_", this I apologise for. That is an absolute oversight and definitely something I will change immediately. The article got a little too vast to me to handle on my own.... But great, I will look for these mistakes and correct them. Interesting... I will check out the Dave Cheney post and reflect :) Thanks again for taking the time to formulate this. It's really appreciated &lt;3
Also, I understand the frustration of the reposts... I would definitely feel the same way as you 😄
This is a good source: [https://golang.org/doc/effective\_go.html](https://golang.org/doc/effective_go.html)
Nothing set up. It's remarkably difficult to use the Internet behind Tor. You can only click so many crosswalks, bicycles, and fire hydrants before becoming frustrated. &gt;You might want to grab the subreddit. Good idea. But I think due to the newness of my account and lack of karma I'm not able to. If anyone feels like squatting it for the interim I'd appreciate it.
To clarify, you need to decide if doMyErr is a constructor of a MyErr object, in which case the original behavior was correct, or if it's a function that is supposed to do something but can fail and might return an error. If it's the latter, the return type should be error, not *MyError.
Currently I run Prometheus and Cortex (with multi tenancy for multiple midsized Kubernetes clusters) side by side. I might spend some time into testing VictoriaMetrics to compare it against Cortex. It seems to be (by reading the ReadMe) much easier to setup. One problem we face with Cortex is actually still Prometheus which sends the samples via Remote Write API to the cluster. This prometheus instance consumes more than 10GB of RAM even though we already tuned it. Have you considered writing a Prometheus scraper, which could be much more lightweight as it wouldn't do anything but pushing metrics to a remote write target of your choice?
You right, answered in the other comment
Is there anyway to implement this with some of the self hosted fit servers like gogs or gitea?
&gt;github.com/miekg/dns "Supported RFCs: *all of them"*. Impressive!
And using options structs (especially for non-optional arguments) obscures implementation details as well, particularly in noticing what might unintentionally be passed as a default/nil value. No reviewer is going to have in the back of their head all of the possible options the struct could hold. Also, Sourcegraph is a thing, and negates both your and my argument, revealing those hidden implementation details in both cases, brining me again to the conclusion this is an issue of personal/team preference in a modern development environment.
Elixir/ Erlang is another option
you can but you will need to add gittea webhook support. or just create an issue
Of course there is [https://github.com/Clivern/Rabbit/issues/49](https://github.com/Clivern/Rabbit/issues/49), one week and i will add gitlab support
Please check the README since it has nothing to do with CI/CD
That should be a valid trade-off for anyone who seeks speed and does not need all the functionality and behavior that the RFC demands. However, it would surely help the project's credibility if this circumstance can be found straight in the project's readme, rather than being buried somewhere in a Google group.
&gt; since I am only generating records and not parsing them Ah. but you could be writing your own compressor to keep those outgoing packets small :) If you want to return 8 A records for a particularly long domain name in a response, you can use name compression to only have to drop the name in the packet once. But now you have to decide how to represent what domains have already been written into the packet efficiently so you can know when you can cheat and compress. do you represent the response abstractly and dedup during serialization? do you keep metadata with it that points to the present labels? do you just keep reparsing what you've already serialized looking for matching chunks ( probably not the best method :P )
Cool thanks, I’ll look into that. Regardless I might add this to my home lab
The language doesn't matter, rather you need to get your head around the architecture for implementing what you want. If your wanting to learn a new language then transitioning from PHP to Go is pretty easy. &amp;#x200B; If you want to stick with what you know then using ReactPHP would work well for creating the backend service with event driven features needed to achieve the periodic updates. Those updates are easily done by the browser opening up a websocket connection for making requests and receiving updates from the backend. &amp;#x200B; Start by looking at a simple client/server chat example which uses websockets for communication. The architecture used for chat can be applied to your goals. &amp;#x200B; If you want to learn Go, then it would be a matter learning how create an HTTP server and handle websockets. Learn about Go-routines for handling each client, and Channels for communicating between the backend process and browser. Throw in some Tickers for handling the periodic updates. &amp;#x200B; As for deciding which language to use, you could simply stick with PHP as its easier to implement something new with a language you know. However performance wise Go would smash PHP so that is something to consider depending on your use case and traffic volumes. You could always write it in PHP first then replace the PHP backend with a Go backend.
It's certainly something that would be considered "part" of a CI/CD pipeline. And, I would argue, something that many continuous delivery systems are designed to do. So, I think the question is valid and stands. How does this tool differentiate from the parts of common continuous delivery tools that provide a similar service?
Thanks for your advice! Writing it first in PHP is great idea.
Well, Continuous integration validate the changes by creating a build and running automated tests against the build and Continuous delivery is an extension of continuous integration to make sure that you can release new changes to your customers quickly. This project is an extension to CI to create go binaries that will be used later by Continuous delivery to deploy. &amp;#x200B; So indeed it differentiate and i even use it for production systems where we use bitbucket as VCS, jenkins for CI and Chef for CD. we need a tool to store all our binaries and chef will download the binary from there and compare the checksum. &amp;#x200B; If you would to build your binaries while deployment, don't use this, Easy right!
There's a plugin in vscode to run tests, and many a tool to reload web servers (or other types of app) on file modification. I personally use fresh.
I would do it this way if possible, or use a great big long switch statement if this looks too ugly.
Hey jid might be able to do the job but I could be wrong Anyway I would also like to hear how people visualize their logs. My guess is that people use a cloud service or something like the ELK stack? https://github.com/simeji/jid
[removed]
You should learn Go, because Go has high performance concurrency system. And the learning cost is lower than other type safe language. &amp;#x200B; If you are interested in microservice, you can make use of your experience of Go to it.
Different nil types.
Having to use \`map\[string\]interface{}\` to deal with arbitrary json data
I’m new to go. Can you explain this to me
How about building \`a\` out of the real part you have and the imag part of \`a\`?: [https://golang.org/pkg/builtin/#complex](https://golang.org/pkg/builtin/#complex) \`\`\` a = complex(2 \* real(b) + 1, imag(a)) \`\`\`
A nil does not have a default type, if you pre-declare something to be nil its the only untyped value in Go. So you have to provide the compiler with enough information to deduce the type of a nil from the context. package main func main() { // There must be sufficient information for // compiler to deduce the type of a nil value. _ = (*struct{})(nil) _ = []int(nil) _ = map[int]bool(nil) _ = chan string(nil) _ = (func())(nil) _ = interface{}(nil) // This lines are equivalent to the above lines. var _ *struct{} = nil var _ []int = nil var _ map[int]bool = nil var _ chan string = nil var _ func() = nil var _ interface{} = nil // This following line doesn't compile. var _ = nil } So if you think about it a string(nil) is equal to "" and an int(nil) is equal to 0 but they are not equal to nil. This is a pretty good read and its where I got the example above: [https://go101.org/article/nil.html](https://go101.org/article/nil.html)
That makes a lot of sense. But in some other languages (I *think* including C) `strings` and `ints` aren’t nullable either so that’s not a surprise to me. The rest is awesome info to have thanks for the detailed answer
Obligatory Go has no generics comment
I'm not saying it's unreasonable, I'm saying it's unintuitive. _I_ know to watch out for it and I _still_ occasionally get bitten by it; our junior developers are _much_ more likely to run into it. Sometimes returning the real type is useful, and sometimes returning an interface is useful. Which you choose to return shouldn't silently make your return value non-nil, that's surprising. Personally, I don't like the silent wrapping of types into an interface. I just don't see a good reason for the behavior. If there's a valid use-case for it, I'd like to hear about it, but "that's just the way it works" isn't good enough for me. The main defense I can think of for the silent wrapping is that it's necessary for reflection. Honestly, I'm not a fan of runtime reflection, and while I understand that it's useful, the same problem can be solved pretty cleanly with other approaches (I'm a fan of D's static reflection).
Huh, AFAIR logrus’ default console formatted prints stuff with colors? Are you overriding by accident and getting the JSON output instead?
``` output, err := someFunc() if err != nil { // do something } moreOutput, err := someFunc(output) if err != nil { // again } ```
I've tried fresh and many other build tools. 1 problem I faced was not being able to customize my command e.g. I can't select which test I want to run, or what command I'd like to run before the build etc.
In C, a string is just a `char *`; it is nullable.
Because Go is opinionated. It providing 1 way of doing things, 1 code formatter, etc... If you will able to implement 1 things in OOP/FP ways - it will produce fragmented codebase in large company (read as “many services in Cloud”). Fragmentation is bad (by authors opinion), same as “effects magically postponing” bad, same as “hiding algorithms complexity is bad”, same as “reducing cognitive load” is good, same as “density of information in each place of code must be same and must not be too high”. All this values/opinions are controversies with FP culture.
`return err`
I personally am on the fence about requiring actual booleans as the value of a "if" or "for". Being able to use C's zero and NULL for false, and non-zero/non-NULL for true actually gives you somewhat more readable code. There's some good in requiring a boolean, like not mistakenly assigning if you wrote "=" instead of "==", so like I say, on the fence. I'm also not that keen on "go build". Hiding the compiler does us all a disservice.
Actually, it's []map[string]interface{}... otherwise a JSON payload that's an array (starts and ends in brackets) will not deserialize properly.
log.Fatal(err) And then clean it up later when you're annoyed by application crashes.
* enums are horrible and hard to use * no sets. Only maps * can’t make things final beyond constants and that only works for a few things * I’d rather have a public/private keyword, defaulting to private. * working with time is hard and slightly confusing
No proper inheritance, not being able to extend structs/packages.
1. No generics (may be solved with code generators... But I don't really like it) 2. There's no way (at least that I know) for catching errors on multiple lines and using a general handling. Don't misunderstand me, I REALLY like the error handling in Go because it avoids the typical: try { /*millions of lines*/ } catch(Exception e) { printf("Something happened");} Which forces people to make good error handling... But I usually feel that I'm doing the same over and over, for example: if err = someThing1(); err != nil { return ParseError} if err = someThing2(); err != nil { return ParseError} if err = someThing3(); err != nil { return ParseError}
Can you elaborate on your go build point, I don’t know what I might be missing out on :)
Passing by value vs pointer without being able to declare const on the pointer. Pass by value can be expensive so passing by pointer is often needed, but I might want to indicate the function shouldn't change the data
I actually like this. Deep inheritance structures are a code smell
- `set`. I need a set, not a map. it works but why not? - `time` format. using `123456..` is cool but why? It's confusing and not as clear as using `%Y-%m-%d` as every other language. - error handling. Sometime it's good, but most of the time, I find it is a hassle.
I agree with everything besides the time, because that shit is hard in every language haha
The overextending into "simple" over programmer ergonomics. &amp;#x200B; * No ternary operator * No stdlib for basic slice operations * Like, are we seriously supposed to memorize this? [https://github.com/golang/go/wiki/SliceTricks](https://github.com/golang/go/wiki/SliceTricks) * No generics * No function overloading * I wish there was a `range` alternative that just went over the elements. Like `for _, e := range es { /**/ }` vs `for e := in e { /**/ }` * sorry, but `interface{}` is ugly * Capitals as exported/public * Unused import error * `:=` vs `=` with multiple variable assignment, it gets weird &amp;#x200B; All that said
I mean the whole "pick a formatter by using this arbitrary date you Google Everytime instead of some well defined enums or structure like yyyyMMDd" still boggles my mind
Right my bad. So then let me correct that to all primitives
Checking if an interface value “is nil”.
- Map order is randomized - Discerning error types requires casting - SO_REUSEADDR is incredibly painful to work around - Checking if net.Conn is closed is painful - CGO is expensive - Circular import checker is cumbersome - For a language so concerned with simplicity, [SliceTricks](https://github.com/golang/go/wiki/SliceTricks) exists rather than extending the language
Or just ‘interface{}’ and a type switch.
Definitely this. I can't imagine how it was agreed on that this should be the way rather than what every other language does.
The ‘net/url’ package name
to your point about generics and code generation I totally agree and would love generics. I also dont like how code generation is done in go (despite loving code generation vs reflection!). Arbitrary strings to define code gen or json types is so weird
&gt; It's confusing and not as clear as using %Y-%m-%d lol. Yes, nobody ever did %Y-%M-%d or even %H:%m.
People complaining about how there are no generics.
What's the alternative in a static typed language?
Maybe golang isn't for you. There was very good reasons for every one of those aspects of the language (except the parsing json part, i don't know the story behind it). All those decisions are very debatable because there's no perfect way of solving problems. I think you should use C/Java/C#/JS instead, because you think those are basics things the language should have. I, on the other hand, think that Go is one of the best designed languages (definitely the best I tried, even if I recognize it has its flaws)
This question again, and still with no qualifiers? How many languages do the people answering know? How many lines of go have they written? How many have they read/reviewed? A lot of the design of go is to make the readers/reviewers job easier. So from that it tends to limit magic, even when you could argue it's helpful magic, because then the reader/reviewer needs to know about that magic. This can be annoying to the writer though, because they'd obviously know about the magic they want to use. And some of this is debatable, so it's fine if someone mentions error handling (there's a reason they are trying to change it for 2.0) or even sets ... but it's better to know if someone is coming from a place of "I've written a lot of code and think adding sets would have been a big payoff for a small amount of magic".
No `const`. I mean, c'mon, that's a no-brainer.
You're basically stuck putting your working directory in $GOPATH/src/, and doing a "go build". You don't set compiler options, no extra waring flgs etc etc etc. I'm not sure this is a good idea. I'm cure you can do compiler flags if you really really want to, and I'm half-sure you can put your code somewhere not under $GOPATH/ but it's really difficult. It works for almost everything, but if you ever want to do something outside of the easy, official way to do it, it become very difficult.
Is it possible to make a not randomized map?
I feel like a kid forced to eat healthy. A programmer forced to check all the possible errors.
I legitimately see some of these at pros. I love the capitalization public/private thing. And I’m a fan of the less verbose initialization.
Its haters
The complaints about the lack of genetics.
&gt; So if you think about it a string(nil) is equal to "" and an int(nil) is equal to 0 but they are not equal to nil. None of that is legal go. Your pasted example was using "chan string(nil)" which is a nil channel, and any channel type can be compared to the untyped nil ... as can any pointer.
https://blog.golang.org/constants
https://golang.org/doc/go1#iteration
There are way better ways to handle it; rusts and_then and ? operator and Haskell’s bind and do notation are much more ergonomic while still ensuring errors aren’t ignored.
Have no idea any of those existed. I am a fraud brother.
&gt; and I'm half-sure you can put your code somewhere not under $GOPATH/ but it's really difficult. Isn't this mitigated with the whole modules thing?
The bullshit CLA.
https://docs.serde.rs/serde_json/value/enum.Value.html
Doesn't have conditional operator: `a := b ? c : d`.
I would've been fine with it, except the date format that matches to it is month/day/hour/minute/second/year/timezone, which seems off. &amp;#x200B; I almost want to make a lib that just does parsing that works off of ISO 8601 - year/month/day/hour/minute/second - that seems far more sensible. The worst part is that's what [time.Date](https://time.Date)() uses - they came so close, granted probably after the fact.
*sigh* I meant const variables, of course.
Ah yes, filtering without allocating. Because arr.filter(a =&gt; a.sum &gt; 0) is just too messy and unreadable compared to: b := a[:0] for _, x := range a { if f(a.sum &gt; 0) { b = append(b, x) } } for i := len(b); i &lt; len(a); i++ { a[i] = nil // or the zero value of T }
generally the whole process of unmarshalling data into an object is a bit of a chore. I know go is built off simplistic principles, but im sure there's a middle ground of building something minimalist that would still save time
map[string]json.RawMessage ?
Outside of gopath is now doable via go modules. Also go build accepts compiler/linker flags. One of the things I love about go is go build works most of the time as is, no need (mostly) for esoteric build flags
[https://github.com/tidwall/gjson](https://github.com/tidwall/gjson) One of the best JSON libraries in any language I've used. Create a function to plug the most frequently used values into a struct and you'll get all the static typing goodness too. Kind of a best of both worlds approach.
Ditto the unused import error; it's a useful anti-clutter feature. "Hey, I sped up our builds AGAIN by removing a zillion megabytes of #includes that it turned out we never used!" is email that I've seen (and sent) way too many times in my career.
I don't like that there are \*any\* nil types.
The name. Why did they pick something that is is un-Google-able?
I feel like it's a huge improvement over guessing when to use try/catch. If I use errcheck, a whole class of risks vanishes from my code. It's nowhere near as good as option types and and boxed return values though. Haskell is really good with this, but Rust's macros are probably the most slick error handling I've used in any language.
Parsing dates
Yes. In terms of error handling and being able to pattern match function outputs based on Option/Maybe types really changed the way I thought of error handling. I really wish Go had something like it.
I agree to you in some extent, but it doesnt mean you are lassing value means that it is always expensive. If you pass by value but the memory is allocated in the stack, it is still considered performant.
As a newbie, and maybe its just because im a newbie, but i know im in for a long night when i have to do work on types or different data-formats with JSON or something like that, even like the simplest of things where i need to convert a value to a string or a string to a value i end up battling for hours and the errormessages it produces rarely helps me get any smarter - this part seems to be the hardest for me to the the grip on in Go, where in any other language ive been through i kinda felt i had a pretty good idea of this very early in the game. &amp;#x200B; Probably because of being statically typed so i am not complaining about it just wish i could learn it more easily and be able to see the light faster. &amp;#x200B; So many other things that are quite hard to do in other languages just is a breeze to do in Go, where this that feels so simple in other languages still feels abit like a mystery to me.
The missing ternary operator
Thank you for your feedback. The mission is to teach everyone. It help me to understand more about topic and better technology for everyone. For example if you want to build any structure, we have a terminate point. How you can check whether your terminate point\[in case list is empty, in stack either is full or empty etc\]. For this purpose, you can call particular method, that take nil argument and return current state. \[Empty, full etc\]. I'm 24 year old.
I love Go. There are no things I dislike about it :)
Just ask everyone to write protocol buffers for their apis :)
I burnt half a day the other day on this not realizing that when you use type erasure you still retain the value of (whatever)(nil).
Have a look at Rob Pikes talk about lexing/parsing: https://youtu.be/HxaD_trXwRE Would that be of help? I know there are implementations on github that you can look at for reference. Since you know the start and end tokens, i would start by just figuring out how to single out those and them go from there, i.e. the pattern to begin with would be
1. No set type 2. No generics 3. Enums are meh. Union types with exhaustive switch checking would be a lot more useful and robust 4. No early return error handling without a panic/recover hack 5. Errors are strings 6. Membership checking on a list requires an explicit loop, list comprehension requires a temp variable and a loop, and lots of other "batteries not included" type stuff that creates verbosity and boilerplate 7. Nested maps requires very defensive programming and a lot of boilerplate to avoid nil panics 8. Naming convention for export cuts our available, sensible variable names in half 9. Not sure what language most of the community comes from (Java? C++?), but it's surprising how many people thing Go walks on water. There's a lot to love about it, but it has some serious warts right now too. &amp;#x200B; That said, I'm pretty hopeful for the future of Go. Some of these are most likely going to be addressed in the core language, and when we get generics I expect a lot of really good libraries are going to pop up to address the other things. Then it'll just be binary bloat from including too many add-ons.
Yeah, every single thing in that list has absolutely great reasons to be the way it is. That's why error handing is being worked on. That's why generics are bring worked on, which will bring functional programming, which will make most SliceTricks obsolete, which are totally fine btw.
What does it have over momgodump/mongorestore
Idk, I have been bit too frequently by the difference in MM and mm or SS and ss in some other parsers. With Go, although there was an upfront learning, I feel like it is worth it.
I disagree. In many real-world programs in other languages, I see Pokemon exception handling and can't imagine that is any better than in Go. At least in Go I get to handle the error within the context of it happening. Might just be me, but I prefer Go's... incessant... need for me to check errors as they occur.
Or just create a type to document the data schema so that people know what to expect?
Indeed this is a real anti-pattern in Go, thanks for bringing this up. &amp;#x200B; For other readers, &amp;#x200B; if err != nil { return err } &amp;#x200B; does nothing but bubbling up the error, hence giving no advantage over try...catch(). Always include layer-specific information to the error you are passing to the caller.
Tell that to the web-dev guys.
go maps are `O(log(n))`.
Well, I'm definitely not in favor of solutions that make error handling *worse*, I suppose I'm looking for *less boilerplate* and *more elegance.* Butalso, just because you *choose* to check your errors doesn't mean that it is Go forcing you to. You could absolutely just ignore that return value or `val, _ := func()` it. As I've commented to other responses, Option/Maybe types have definitely added a more elegant way to structure `Either return the value or an error` function signatures.
In most languages if you rely on map order, you are doing it wrong. Python only recently added it to the language that a map had a predictive order when iterating.
regexp are (really) slow
Can you give an example of when you would like to have things final beyond consts?
There's grpc-web (:
Lack of function overloading
I haven't used it in over a year, so sorry if this has changed, but it's quite frustrating that I can't just temporarily comment out code and recompile. Inevitably the code references some variable that wasn't commented out and so the compiler complains that the variable is unused, which is fine for a release build, but for debugging it introduces friction that is not helpful. I wish there were a compiler flag to turn this off.
Looks pretty simple! Does it work only with sha256?
real(a) is a function so you can't set it. Many datastactures in go has properties that you can set, such as a.Real or a.SetReal(value) but complex types don't have those definitions. What I would do is `a = a + complex( real(b), 0)`
Rob Pike just took the default output of `date`. The issue is that the output of `date` is, of course, locale-dependent.
Surprised this hasn't been mentioned, but the GOPATH is annoying as all hell. I do not like the forced file structure that GO seems to require at all - all of my GO code is *not related to all my other go code*.
Most languages don't make data structures an exercise in futility
Google App Engine datastore API is written by Google engineers and illustrates very well the cumbersome nature of Go for library code. datastore.get(key, value) and datastore.GetAll(keys, values) is pretty simple interface, but you only find out if you messed up and passed by value instead of by pointer at runtime, because value(s) is interface{}. Hopefully you find out while running tests and not in production.
Probably that there isn't a standard library package for user interfaces. Also that it can't be run on bare metal.
Except in that case, I know *exactly* what I’ve confused `%m` with. It should have been `%M`. With go, it could be any of a bunch of numbers.
[removed]
`New()` returns a `*Claims`, but no method has a pointer receiver.
IIRC, this is only partially correct. If I understand the runtime correctly, it's not that nil has types, it's that interfaces have 2 fields: type and pointer. You can't directly compare two different `nil` if they're not the same type already (compiler error). If they're converted to interface, then the two fields are set accordingly and then you get the confusion between `type:A,ptr:nil` and `type:B,ptr:nil` Finally, the last line doesn't compile because there's _no_ type information. Meaning there's no untyped values in Go. See this post for a more elequent and in depth explination: https://dave.cheney.net/2017/08/09/typed-nils-in-go-2
&gt; Surprised this hasn't been mentioned, but the GOPATH is annoying as all hell Probably because with modules you now can put your projects outside of GOPATH.
You just google for “golang”.
No ternary operator that i know of atleast. I just want to do `return (err != nil ? object : err)`
It kind of seems like Go isn't your bag
I hate slices in go.
Lack of parametric polymorphism, and the fact the go team pretends it's a hard problem to get right.
It may be shocking to know that there are applications which deal with arbitrary JSON data.
&gt; examples should go into a separate examples folder, maybe have a look at https://github.com/golang-standards/project-layout in general These are godoc examples, and should stay where they are
I think it's very nicely dome in .NET/C#, the `datetime` and `timespan` types behave as you'd expect and have all the comfy methods you'd want. e.g. Subtracting two dates yields a timespan, formatting dates is powerful and parsing from unix-time or filesystem timestamps also easy
Pfft, easily solved - just get a tattoo of the arbitrary date on your arm.
I actually think it is a beautiful design having different nil types, it is just that the comparison between then is non intuitive.
Not being able to write test := someFuncINeedToSeeWhatGetsReturned() and run the debugger. Sometimes I just need to see what’s going on without linting my code. I wish they’d add a magic variable name or something that I can use for quick and dirty breakpoints and debugging.
Just ran in to this today. My sql is stored as text, but it’s JSON stored as text. GORM won’t let me convert it as it’s loaded, but I can’t take a string struct member and marshal it to json.
I'd use bufio.Scanner to scan line-by-line, and start the read with the &lt;two letter code&gt; line, fill a buffer with the lines till &lt;estimated tax&gt;, then start over. &amp;#x200B; Later you can fill your struct as you find out what all those inner lines mean...
Pass by value is only more expensive if your struct is big and can't be copied within the same cache line (64 bytes). Copying a pointer (8 bytes) or any other amount of data within the same cache line basically takes the same amount of time.
1-2-3-4-5-6 is the quick rule of thumb to remember the `2006-01-02T15:04:05.000Z"` monster. - 1st month - 2nd day - 3rd hour - 4th minute - 5th second - of the year 2006
I use json.RawMessage when I'm passing data into an upper layer of my app for further processing. The idea is that the code deciding how to route the message should not be concerned with it's contents.
Genuinely curious - can you provide some examples? What sort of APIs generate arbitrary JSON?
This person gets it.
Slice operations. The infamous SliceTricks wiki page speaks for itself. Simple operations shouldn't be that hard. I also like how go is in general an easy language to read, and slice operations just make impossible to make code that is easy to read at first glance. Some kind of generics would be appreciated too. I get the whole sentiment that we don't need generics as much as we think we need, but generics could really help in avoiding some code repetition. Although i agree in general with the go proverb "a little copying is better than a little dependency", some copying just feels really unnecessary.
Lack of covariant slices/arrays
The go doc comments
I see you're being downvoted and I'm not sure why so correct me if I'm wrong but isn't stack memory still just memory to the OS that gets paged and cached regardless? The stack is more of a runtime data structure that resides in the first part of the allocated memory for a process. Any block in memory can be swapped and paged by the OS, and if you get a cache line miss it will have to read from the next level of cache which will always be slower.
Authentication token signing, if you want a central service to sign tokens with arbitrary data you could either just convert it to a string and have everyone agree on a particular key name "data". Instead you could embed the data directly into the token and each application can parse each token with the keys they care about. You also save on bandwidth not sending the escaped character sequences in strings for embedded data.
You could just push the check of err down further. It doesn't remove the need to return errors and add them to method signatures though.
This will need some custom unmarshaling... Range over the lines and start a new struct/dataset on the significant line(regex). Then regex/if the hell out of it to fill in the known data into your struct. For this you could create tags in your struct you range over so it isn't completely staticly coded, or have a configfile, which will make type casting harder... So many ways to do things like this. Good luck
This but unironically.
Having worked in similar codebases as you, I agree wholeheartedly. It feels so nice to read these explicit checks.
ahah
Same goes for just about any programming language tho, ever tried looking for anything related to C, D, etc?
Rob Pike explained why Go lacks the ternary operator, it's due to people abusing it to do long chains
Names such as `ctx context.Context`
&gt; Also that it can't be run on bare metal. TinyGo?
Just do it
I have to write \`if err != nil\` again and again
[removed]
And it's the default setting for a few weeks now..
&gt;no sets. Only maps You can use map[yourType]struct{} it behaves like set.
const refs and immutable variables and I want sum types. Also I hate having to specify the type of a struct I’m initializing if it’s obvious.
[removed]
There are no set, you need to do a map of you don't care what if you want to do a simple set.
Fair points all.
&gt;CGO is expensive True, but at the same time I believe this was a blessing for Go as an eco-system, where the default approach would have become "just use the C library" instead of "let's rewrite this in Go". We now have native SSH, DNS, ... libraries which is pretty awesome :) But yes - interfacing with C code is horrible.
I have a feeling the OP knew that. Without an in-built set, it means either using a library which generates a "proper" set data structure (with operations like `add` etc.) or re-implementing a set-type backed by `map` for every use-case.
The Folder Structure man.... I just don't want my folders to be in Github hierarchy If I need to publish on github. Example: * src/ * github.com/ * vs4vijay/ * 0xMatrix/ * &lt;my-file&gt;.go
C++ is okay tho
Verbosity. Relatively low signal to noise ratio. Having to read same statements all over again and again just to find a part which is relevant to domain logic and not language samantics.
Xerrors come with rescue.
How about not having a good profiler like javas visualvm. (I am aware of pprof)
That is what I ended up doing. But it looked strange.
I didn't understand why you reimplemented OpenSSH, but then I found your explanation in an old reddit thread. I like that I now have a CLI when I need one on windows. And I realized you parse SSH config files, and I think I have a use-case for that.
So no schema? Why not use NoSQL?
[removed]
It should have been an issue caught by a linter - say `gofmt` - rather than the compiler. Same with the "unused variable" error. The reason being that sometimes you're troubleshooting and want to quickly comment out statements and rerun the test.... only to get hit by a compilation error because you forgot to remove the unused import/variable you've left behind. It can be annoying.
\+1
I am glad it doesn't have it.
[removed]
&gt; I would've been fine with it, except the date format that matches to it is month/day/hour/minute/second/year/timezone, which seems off. No idea what yer on about here? Where does it use/expect/require that format?
Use `goimports`, it will automatically rewrite your imports so you don't even have to write the import keyword anymore. As for unused variables, that caught a bug in my code many times.
Looking at the tiobe top 20, the only languages I would consider un-google-able are C and Go.
I was talking about the reference date used for both time.Parse and time.Format.
Tabs
[removed]
[removed]
oooh, you mean the year being "6" in the reference date, gotcha
this guy gets it
And because of that decision, millions of people now think the name of the language is "golang". It annoys the shit out of me when I'm talking to someone and they say something about "working in golang".
&gt; enums are horrible and hard to use Go does not have enum types.
Yes it's the only one it works with. I need to update docs L
Yeah, it's slightly painful sometimes. I thought this feature would match go vet better.
Not a pro here. I did want to learn Go. But, when I read C I usually understand each line (if it’s reasonably written code). I’m familiar with some other scripting languages as well. In case of Go, even after reading entire spec I still have hard time to easily read Go code, it’s not appealing to a student. I’ve watched many dozens videos, all important ones, GooherCons, etc. you name it, and yes language is exciting ... but somehow not easily readable. I prefer C arrays and pointers vs slices. But again I’m not a pro, so my opinion is heavily biased.
[removed]
everything you say is correct. However, statistically it's likely that the page that holds the stack is already loaded to cache. This applies the same even if the stack is spread across multiple pages.
That's exactly the problem. On its own it's a fantastic idea, and then they had to make it utterly useless by inverting fields randomly instead of using the obvious and immediately rememberable rank of larger time periods to smaller time periods, year month day hour second, etc.
Oh I see of course that makes a lot of sense since the stack is frequent access so you're less likely to replace those cache lines. it's been a while since I touched up on my virtual memory stuff thanks!
Making the language less expressive because some people do stupid things is my number one complaint with Go.
Are you speaking about Go?
Everything if abstracted can be reduced to this structure.
You mean generics?
Can you clarify which operation and resource in Go gc 1.12 is O(log(n)) for maps?
This is good actually..
Why?
I don't know why you got dislikes !
Or postgres' built in json types.
Syntax. Sometimes it feels way too outdated.
Lol when searching for anything in D, Google will be like "did you mean 'Go'? ;)".
No choice. I didn't make the DB and can't modify existing schema until the old app is turned off (when I finish the go one) 🙃
I'd really like to see ternary as well, but I can see why it goes against the language's design pattern. I think the reason I "miss" it from the other languages I work in regularly is because I feel like I'm writing a lot of extra code when I'm working in Go. I still like the language as it feels like a nice middle ground between something quick and hacky like Python and a more performant native language like C/C++. I've only been writing Go seriously for a month or so, so I don't know if this con of "too much control" will flip-flop into the pro of "having complete control".
Whats the difference between a package and module ? To me it seems like in the tutorial you are doing excatly the same as using functions feom another package.
Ahh, maintaining something. Why not use a layer on top of GORM then that just received that one field as a struct? ``` byteString := []byte(struct.StringField) newStruct := new(formatOfStringFieldData) err := json.Unmarshal(byteString, newStruct) ```
object OR err ? that seems like a bad idea in any language. I want a ternary operator too, but not to do that.
And that is only intuitive for people in the US. Every normal person knows that it's DAY-MONTH-YEAR
Lack of sum types in general. There's a lot of places in the stdlib itself that will be cleaner and easier to understand if we had sum types.
Yes, but then it wouldn't work as expected, since the identifier day would not be Monday (the first day of the week). To each his own, but all in all, I very much prefer it to Python or Bash, where you have to look up the various strftime identifiers and end up with situations like [this](https://rachelbythebay.com/w/2018/05/13/dates/)
Month-day-hour makes no sense to most of the world outside of the US.
From the Go modules [intro blog post](https://blog.golang.org/using-go-modules): A module is a collection of Go packages stored in a file tree with a go.mod file at its root.
I acknowledge your concerns and they are not invalid, but be sure to [check the constants](https://golang.org/pkg/time/#pkg-constants) in that package for a variety of pre-rolled values. Often they'll do, and if not, it's easier to take one of them and tweak it than construct one from scratch. They are easy to miss since the time docs are so large... I did for a while.
Rob Pike
None of the hail hydra of Go dependency managers offer a way to track development dependencies, libraries and command line tools involved in linting, testing, or compiling a Go project, which should not be installed for regular users. The community. I'm not talking about toxicity, thank goodness. Just one specific thing about the community. Real world Go projects often break `go build`, instead using their own hinky build system. It's like going back to the dark ages. This problem was magnified prior to Go 1.12, when umpteen competing package managers required Go devs to learn, install, and manage umpteen competing package managers. Instead of having `go get` do most of the heavy lifting. Lack of thread safety for builtin data types. Unclear whether breaking C function call convention provides a performance gain worth breaking gdb. Platform tiers are seen as a maintenance premium, rather than an opportunity to finally leave C in the dust where it belongs. Don't get me wrong, everything about the Go cross compiler and organized assembly integration is fantastic. It's just that the choice of which platforms to include could be even more exhaustive!
Hmm, good idea. I wish I could just do a beforeMarshal hook in GORM like I’m used to doing in Django, but adding a second layer will probably work.
Avoiding feature abuse is setting developers for success
The requirement you mentioned is quite not realtime. You can use normal http in this case. But better option is Server sent events. With SSE client can send one request and server can keep sending responses whenever data is changed. Websockets are another option.
https://play.golang.org/p/MKzgBBypJ9A
You could use struct composition: https://play.golang.org/p/4KPix5OEXJC
Sorry, meant something like `return (err != nil ? (object, nil) : (nil, err))` Just wasnt thinking to much about it
&gt;I'm not saying it's unreasonable, I'm saying it's unintuitive. I understand that. It was intuitive for me though. What you seem to be missing is that nil is a valid value for a type. When working with an interface, you shouldn't care if that value is a typed nil. It's just another value of that type, and the details of what that means are abstracted away. Knowing the value is a nil breaks that abstraction. On the other hand, you do need to know when the value is an untyped nil. That's when you don't have a valid value for that interface. &gt;Sometimes returning the real type is useful, and sometimes returning an interface is useful. Specifically with errors, if the value is meant to signify an error it should ALWAYS be returned as the error interface. That's the entire basis of error handling in Go. &gt;I just don't see a good reason for the behavior. If there's a valid use-case for it, I'd like to hear about it, but "that's just the way it works" isn't good enough for me. What's wrong with the use case I showed you? What makes it not valid?
Yup obviously code generation is much better
All of my variables unless I plan to mutate them. final now := time.now
Unstructured log data querying or any random-data source querying. For whatever reason, the _majority_ of the JSON I interact with is unstructured.
Adding items to a nil map will panic, whereas appending items to a nil slice is allowed
it's because go was literally created as a dumbed down language for junior devs
If we want to be pedantic according to the current RFC we're basically just stuck with interface{}, because a single string or number is also valid JSON. In an API over which you have control (which I would expect is the majority of cases--certainly the vast majority for me), it's perfectly reasonable to require the top level element to be an object.
Why does year come sixth instead of first?
https://medium.com/@ConnorPeet/go-maps-are-not-o-1-91c1e61110bf
Writing the time formats is annoying, but reading them is infinitely better. Go very much optimizes for the entire software lifecycle, and code is read much more often than it is written (only once).
maps are bad in go here is for example `map assign` is cost the same as `sort` https://imgur.com/a/6ndeWAM
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/zYigLuT.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme)^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20erxhwnq)
yes, but generics bring images of Java so I wanted to avoid using it.
It's much easier to refer to it as "golang" rather than "go" though.
I feel like randomized maps ensure that we are using the data structure as it is supposed to be used. Just thinking out the bugs that would occur gives me headaches.
What is a protocol buffer?
&gt; Except in that case, I know exactly what I’ve confused %m with Only when you see the output is wrong ... or if you've gone through years of memorization. Someone just reading it either assumes it's right or has to lookup what the magic is, at best it's as bad/good as the go version. &gt; With go, it could be any of a bunch of numbers. No, the numbers aren't random. "03:04:05" vs. "03:01:05". You could argue that the day of the month and the minute could be confused as "03:02" ... so, at worst, you need to double check the ordering and it's as bad/good as strftime.
Several boomers wrote the language, so this isn't a surprise.
_Roll-your-own_ [sorted maps](https://play.golang.org/p/dvqcGPYy3-). Pretty small, but needed often enough that coping sorting code to each project raises questions.
Rust's ? operator is nice, because it's still explicit but only a single character of boilerplate. I still prefer try/catch *in general*, because if I as the programmer don't know how to handle an error from something I'm using further down the stack, trying to continue is only going to make things strictly worse than halting execution.
Corresponding discussion on Reddit which was discussing the graph in the article to be an effect of cache latencies/misses as normal real world machines do not provide the same access latency for all of ram due to levels of caches: [https://www.reddit.com/r/golang/comments/3n0lf8/go\_maps\_dont\_appear\_to\_be\_o1/cvjr884?utm\_source=share&amp;utm\_medium=web2x](https://www.reddit.com/r/golang/comments/3n0lf8/go_maps_dont_appear_to_be_o1/cvjr884?utm_source=share&amp;utm_medium=web2x) [https://raw.githubusercontent.com/bboozzoo/maps-are-not-o1/bboozzoo/cache-misses/plot-benchresults-rand-cache.png](https://raw.githubusercontent.com/bboozzoo/maps-are-not-o1/bboozzoo/cache-misses/plot-benchresults-rand-cache.png) A followup post taking this into account seems to have not been published (couldn't find it with a quick search).
&gt; Only when you see the output is wrong Or unit tests. Oops! That should have been `%M`… &gt; No, the numbers aren't random No, they're not random. But the reference time doesn't correspond to any commonly-used date format, nor to any notable date. I've never even heard of the timezone it uses. The bottom line is, if you fuck up a `strftime` format string, chances are good you can fix it without having to go and read the docs. With Go's weird method, I don't think I've ever been able to write a correct time format string that isn't just YYYY without having the docs open.
&gt; The bottom line is, if you fuck up a strftime format string, chances are good you can fix it without having to go and read the docs I would disagree.
In that case I think he'd have to use like 10 different error variables and check them all at the end? Or keep a slice of errors and return the whole slice
Yeah seriously... maybe the default behavior should be instantiating the maps and if you don't want it instantiated you do `m := nilmap()` or something. Seems like the real life uses for a nil map must be few and far between
Ya got a source for that or is that just your shitty opinion?
The constant asynchronous forking and _right-indent method chaining into oblivion. oh wait, that's Javascript
&gt;The key point here is our programmers are Googlers, they’re not researchers. They’re typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt. – Rob Pike https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent
You know it was a smart choice when the standard library uses aliasing tricks just so that the documentation for functions that take a url argument can use the name "url" instead of "u" or whatever. Single-type packages are kind of a problem in general, actually. If you have a foo package with a Foo type and a NewFoo function and you really want to just call all the vars of that type foo but you can't, it gets tedious.
[Protocol Buffers](https://developers.google.com/protocol-buffers/) are a data serialization format created by Google. They emphasize performance, backward compatibility with version changes, and language neutral approaches. Basically, you can define your API or data structure in the Proto definition language, then the Proto compiler will generate the appropriate types, methods, and data structures for your selected language. It works really well when creating gRPC services, and can also work exceptionally well at storing data structures as binary on disk, key/value, or database systems.
Op said that this model is used to get values from a database. In my experience with database drivers, when you get the values from the database they will be put into a struct that has at least all the columns returned by the query. Pretty sure that this would no longer work with your solution.
That’s basically how it’s done in Go, too.
IMO this adds nothing compared to [The Go Blog Go Slices: usage and internals](https://blog.golang.org/go-slices-usage-and-internals).
Meh, nobody says “clang” for C. Half the time when I have to google for something I use “c++” instead of “c” because I get better results.
&gt; What you seem to be missing is that nil is a valid value for a type No, that's completely separate. When you return `nil` from a function, you expect every other comparison with that returned value to be `nil`, but that's not the case if it silently gets wrapped up in an interface. For example, this is completely reasonable: https://play.golang.org/p/tjTp6Ph69fN And this makes total sense: func retInt() *int { return nil } func retBool() *bool { return nil } val := retInt() // compile error val = retBool() It's weird when you return a nil and somewhere down the line it gets wrapped silently in an interface and becomes non-nil. Pretty much nowhere does Go do silent type changes (I think interfaces are the only place), and if it's going to be silent, the behavior better not change just because I changed a type from a concrete type to an interface. &gt; if the value is meant to signify an error it should ALWAYS be returned as the error interface I disagree. If a value is meant to signify an error, it should ALWAYS _implement_ the error interface. We use fancy internal types to allow returning multiple errors and warnings, and distinguishing between only warnings and errors (e.g. for input validation). We return the concrete type because it drastically reduces the number of type conversions (and thus accidental panics/type checking), and our "public" functions all return `error`. When a new Go developer comes along, they may forget to check for nil when returning a concrete type as an `error`, and that _has_ caused some head-scratchers in the past because it wasn't super obvious (again, since I've been bitten by it, I know what to look for). Because of this, we've actually decided to reduce the places where we use these internal types _because_ the language doesn't help us avoid these types of bugs. Essentially, we're making our product a little less useful because of the language and our relatively novice developer base. &gt; What's wrong with the use case I showed you? What makes it not valid? Your use-case could similarly be implemented with an empty list: func NewShoppingList() ShoppingList { return ShoppingList{} } You get exactly the same result, and you don't have any weird surprises with `reflect.ValueOf(...).IsNil()` returning true when a regular check returns false: https://play.golang.org/p/denZEC1TcK2 Personally, I want Go to special-case `nil` when it's the value within an interface, but don't make other zero values equate to `nil` (they don't in any other context, so why here?). I think that would be intuitive for most new programmers, and Go is intended to be easy to learn, no?
Nice
Well well well. What do we have here? How did you comment so fast!? Oh wait, &amp;#76;e&amp;#69;pic&amp;#82;edditor&amp;#54;&amp;#57; is a bot out to be annoying for internet points! Nice nice nice. It'd be nice if you could differentiate between normal text and a link too in your detection methods. --- ^^^Pardon&amp;#32;me,&amp;#32;r&amp;#47;golang,&amp;#32;I&amp;#32;am&amp;#32;a&amp;#32;bot&amp;#32;trying&amp;#32;to&amp;#32;make&amp;#32;sure&amp;#32;you&amp;#32;know&amp;#32;that&amp;#32;&amp;#76;e&amp;#69;pic&amp;#82;edditor&amp;#54;&amp;#57;&amp;#32;is&amp;#32;a&amp;#32;bot&amp;#32;|&amp;#32;[Message&amp;#32;bot](https://old.reddit.com/message/compose?to=look-its-a-bot&amp;subject=REGARDING%20BOT&amp;message=I%20have%20an%20inquiry%20about%20your%20bot:)&amp;#32;|&amp;#32;[Why?](https://reddit.com/user/look-its-a-bot/comments/c4g9i5/)&amp;#32;|&amp;#32;Reply&amp;#32;with&amp;#32;'delete&amp;#32;this'&amp;#32;to&amp;#32;remove&amp;#32;if&amp;#32;&lt;&amp;#32;3&amp;#32;votes!
It's probably worth at least pointing out that the standard library already has the function.
It is not that black and white in my opinion. I believe the better argument against things like the ternary operator is uniformity. The ternary operator specifically doesn't add any expressiveness whatsoever. It just lets you write things in a slightly different way. Go tends to cut these things away and even has fantastic tools like fmt that ensures uniformity without forcing the developers to invent "guidelines". Lisp is one of the most expressive language family and it generally has very few syntactic features. A good example of where Go didn't cut away the unecessairy is the variety of variable declarations, which is a bummer. I applaud every instance of where they succeeded.
I didn't get it working after 8h :-(, but that's probably due to my inexperience with Typescript. Examples can be way better though. Did you get it working?
Please introduce enum's like they exist in Swift. There's no simpler way to define states which hold differing data.
All of those, and also: - Two different declaration/assignment syntaxes and you have to know about and use both. - Lack of parametric polymorphism. (I could take or leave the rest of generics.) - Totally inadequate standard logging library meaning that everyone has their own.
I don’t know how you’d make cgo *not* expensive. It’s expensive because of stack and ABI differences. Maybe if Go used LLVM as its backend or something? Go uses a small stack and C expects a large stack. So, the runtime has to copy everything over to the system stack. Because the ABIs are different, the runtime must save all the current registers then set up the registers, stack, etc. so that it matches gcc’s calling convention.
That’s literally the point of the language lol.
GC
So do people actually use this to define ALL of their data structures? Or just the ones being passed back and forth across services. I’ve had issues have to write wrappers to convert grpc proto buffer data structures to custom data structures used internally. New to it.
You are right! I actually used the official blog post as inspiration to write this. My aim was to make the explanation more accessible to beginners and newcomers, by using simpler language, analogies (comparing arrays to structs and slices to pointers), more diagrams, and real life use cases.
Oh, can't the same variable be reassigned? I guess then you only get the last error details. No elegant workaround.
I had used this repository. [https://github.com/improbable-eng/grpc-web](https://github.com/improbable-eng/grpc-web) When I wanted to use grpc web (around three years back) official version did not exist, but this did, and I was able to get it working. Since then I haven't had to work with grpc-web, but the repo I mentioned still works.
You already made that clear in your previous post :)
[removed]
[removed]
[removed]
[removed]
Yes, and there are errors in it: slice1 := []int{6, 1, 2} slice2 := []int{9, 3} ... // slices of different lengths can be equated slice1 == slice2 [No, they can't be equated.](https://play.golang.org/p/vqqZeu6b_I2)
[removed]
[removed]
What does "inconsistent" mean ? That some field may be missing (i.e. ADDRESS_3 from the 2nd entry) or that fields may be in a different order ? Or maybe that you can get completely unexpected data ? (that presumably you don't care about) ? In the first case you could build a state machine (that starts from the 2-letter code and ends with "ESTIMATED TAX". For the other cases, you still know beginning and end but as it has been said before, you'll have to check line by line if any field matches. For all cases you should have a structure that contains all possible fields, that you can fill for each record.
&gt;No, that's completely separate. When you return nil from a function, you expect every other comparison with that returned value to be nil, but that's not the case if it silently gets wrapped up in an interface. You're not returning nil from a function. You're returning a valid error interface value that happens to be implemented with a nil value. If in your example you did a check for your custom error being nil and returned an explicit nil if it was, you'd be happy with the result. Say for a second errors.New(text string) was actually errors.New(text *string). What you're doing is basically the same as returning errors.New(nil) at the end of your method and then acting surprised when the caller thinks your method failed. &gt;I disagree. If a value is meant to signify an error, it should ALWAYS implement the error interface. We use fancy internal types to allow returning multiple errors and warnings, and distinguishing between only warnings and errors (e.g. for input validation). We return the concrete type because it drastically reduces the number of type conversions (and thus accidental panics/type checking), and our "public" functions all return error. Well, you're swimming upstream, because that's not the Go way. Look at the syscall package (or the newer x/sys/linux). Even though the actual errors are syscall.Errno, the functions still always returns an error. Yes, my use case can be implemented with an empty slice. So what? Your use case can be implemented by always using the error interface when you have a return value that signifies an error. &gt;You get exactly the same result, and you don't have any weird surprises with reflect.ValueOf(...).IsNil() returning true when a regular check returns false That's not a weird surprise.
thanks for the correction! I've changed the content
I have to work with terrible Java code others wrote, I'll pick Go in corporate environment any day just because of monstrosities people do when they have tools that can be abused. I love to write sophisticated code but for myself or opensource, work is another story. As to expressiveness - there's perfect balance between that and code's volume, and that is literally one of the most important things for me. I was into c++ for the bigger part of my life and I loved its expressiveness, but there are apps where I need it and these where I don't and its just waste of eyes/energy to skip non-business logic when analysing something.
&gt;As to expressiveness - there's perfect balance between that and code's volume, and that is literally one of the most important things for me. Agreed completely. And requiring you to check an error var from nearly every function call falls squarely on the side of "too much goddamn keyboarding". That is a massive waste of eyes/energy when most of the time, the kind of errors I'm forced to handle are fatal to the program anyways and could be left to bubble up and cause termination.
Isn’t Echo the framework with the author that rewrites commit history to erase the contributions of others? I was pretty sure we all agreed to stop using it. Also, I know this is the bleeding edge, but I’m not going to follow instructions that boil down to “download tarball from github/google drive, extract, run shell script as root” on my local dev machine. I’d need to use a vm for this to not be utterly stupid.
Agreed!
Ignoring 50% of the words you quoted is great and all, but even if you hate elegance the amount of boilerplate required in Go error handling is pretty absurd. If I'm a plumber, why am I not allowed to ask for waste-of-time repetitive tasks to be removed from my workflow? If I'm a programmer, why am I not allowed to ask for \~50% of my code that is almost identical to be removed/handled for me?
I cant help you with the Webserver stuff i build vue frontend and go backend on a raspi, but i solved the cors issue with adding the function as a module to my backend rest api, i.e in gin gonic you need 1 additional Line and the Backend ist handling cors
Bookmarked :) thank you.
Yeah, I found error handling leaves a lot to ask, it has benefits, but also limitations. Actually that's one of my like.. 2 problems in Go. I keep tinkering around to find better ways to handle it and there is always some limitation that doesn't let me do it the way I want, maybe I'm naive looking for a solution hahah I've been playing with Go just for a few months, probably more experienced users would come up with better patterns. On the other hand, it's not that bad that I want to curse every time I have to check error, I could live with it.
Hello, I am working on a project that use intensively the native marshal and unmarshal, so I wanted to go deeper on it, here a brief summary. All feedback welcome, especially if you have experienced this question already.
You don't need to run anything as root on your dev machine, this is inside the Risc-V VM. Also it's a simple 15 line script to copy files around.
I maybe wrong, but IMHO, it is considered performant for various reasons and condition. If the value you are trying to allocate fits in the current stack size, this mean no resize is needed for the current stack. Stack gets cleaned automatically (no GC) when the function that is executing extied. Im relatively new to the language but if you want a good article about this, I can recommend you to read this: https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html
I guess it's ok to run simultaneously on different ports... You just access the frontend, and it will comunicate with the backend. Having them in different folders completley..
In all of your error cases, I see you return a default zero value rather than an error like an empty string or a nil. Could you maybe elaborate why you decided to go this router rather than returning errors?
Fair enough. I’d still ditch echo though. Unrelated questions: what kind of dev boards exist for risc-v? Is anyone making or planning to make server hardware? Any cloud providers looking to support the architecture? I love the idea of an open isa, but I’m honestly afraid we’ll only see serious support in places like China that want to stop buying western chips, and will therefore only get hardware that’s been compromised by bad state actors.
But why? Why would I couple my codebase with github.com and my username as foldername... why can't I use simple folder name and publish it... and somebody should *go get* it
I had no idea on Echo issues, just used it as it's an easy framework to play around. There is currently only one board capable of running Linux, the SiFive Unleashed. It's CPU performance is similar to a RPi3 but with 8GB RAM and a very slow SDcard interface (SPI). Also it costs $1000 due to low volumes. I've been in the Risc-V Workshop in Zurich 2 weeks ago and there are many companies working on board but it's currently booming for the embedded chips. I believe the SOC/desktop/server market will catch-up soon. If you look around there are still no official support for the Linux distros but it's progressing very quick! I'm betting my time and effort it will be big.. also big companies like Qualcomm, Western Digital and more are putting big bucks on it.
&gt; You're not returning nil from a function But I am. Here's what I'm doing: type myErr string // implements error interface func doErr() *myErr { return nil } func wrapErr() error { return doErr() } I'm returning nil, and the Go compiler is silently wrapping that up in an `error` interface. AFAIK, there's nowhere else in Go where a type gets silently converted to a different type. &gt; Yes, my use case can be implemented with an empty slice. So what? Your use case can be implemented by always using the error interface when you have a return value that signifies an error. And which one is less surprising, a nil value silently being wrapped up in a non-nil interface, or a nil value being converted to a nil interface? I argue the second, because: - that's how every other language with interfaces works - Go requires explicit type conversions; there are no automatic type conversions outside wrapping things in interfaces &gt; That's not a weird surprise. Why not? Can you point to any other languages where it wouldn't be surprising? This is a weird special-case of Go that has bit me, and it's completely non-obvious because it works differently than pretty much everything else out there. The closest thing to Go interfaces that I've played with are: - duck typing (say in Ruby or JavaScript) - traits (Rust) - interfaces (Java) - abstract classes (Java, C++, others) In all cases (well, except Rust, since it can't really happen), if you return a `nil`/`null`/`None` (or whatever), you'll always get a `nil`/`null`/`None`. It doesn't get magically wrapped up in a non-nil interface. In fact, AFAICT, interfaces are a compile-time feature pretty much everywhere, whereas Go does something funky at runtime that, without special-casing `nil`, results in surprising behavior for anyone familiar with pretty much any other interface-based type system.
I don't understand what the complaint is here.. What am I missing?
A similar task, for which there is a plethora of example codes online, is 'screen-scraping,' the process of processing a web-page or similar data source (originally literally a terminal screen, hence the name) and scraping the valuable data out of it. You can probably find examples of all the suggested methods, good, bad, and indifferent, in Go and in other languages by looking for it. I have done a lot of this with capturing printed reports from ancient DOS based or older systems, redirecting the printouts to files and then parsing them.
&gt; (the first day of the week) In your locale, maybe. Sunday is the first day of the week in mine.
I always want to use `url` as the variable name.
&gt;I'm returning nil, and the Go compiler is silently wrapping that up in an error interface. AFAIK, there's nowhere else in Go where a type gets silently converted to a different type. No, in that code wrapErr() does not return nil. It returns a *myErr, for which nil is a valid error value. To return a nil, wrapErr() needs to actually return nil. &gt;In all cases (well, except Rust, since it can't really happen), if you return a nil/null/None (or whatever), you'll always get a nil/null/None. It doesn't get magically wrapped up in a non-nil interface. Duck typing is nothing like interfaces. Java is a bad comparison because calling methods on null in java is not valid. The java way of doing it makes sense for Java, where null is not a valid implementation of an interface. It doesn't make sense for Go, where a typed nil is a valid implementation of an interface. Maybe you think calling methods on a nil receiver should panic or something, but this behavior is a natural result of Go treating nil as a valid receiver of methods.
Most modern frontend frameworks need a module bundler such as webpack to compile the code for production. Webpack includes a dev server with a proxy mode that can be used to easily pass specific routes on to a different webserver. No cors problems what so ever.
Yup. Doesn't matter which language I'm using, I always have to google/lookup the date formatting rules. The only difference with Go is that the format shows me exactly what my output will look like.
yyyyMMDd is hard to read and write. Go's is just hard to write.
&gt; does nothing but bubbling up the error, hence giving no advantage over try...catch(). Most of the time that's exactly what you want.
TL;DR: &gt; Prior to making any decision about switching from the standard library, you should measure how the json Marshalling/Unmarshalling impacts your application and if a gain of performance could drastically improve the performance of your whole application. If it represents only a small percentage, it is maybe not worth it, the standard library is now efficient enough in most of the cases.
The framework you have in mind is iris with the maintainer kataras. Echo is an awesome small web framework that has found its current form through various iterations and the maintainers are doing a great job with documentation and responding to feedback of the community.
&gt;Prior to making any decision about switching from the standard library, you should measure how the json Marshalling/Unmarshalling impacts your application and if a gain of performance could drastically improve the performance of your whole application. If it represents only a small percentage, it is maybe not worth it (...) I am very happy about this part of the conclusion: don't optimize prematurely, instead benchmark and fix the parts that are slowing your program down.
[removed]
Does `MarshalEasyJSON` respect special tag values like `omitempty`? Could you add a section about `UnmarshalEasyJSON`? I would be interested to see what code it would get generated.
&gt; n that code wrapErr() does not return nil No, it _does_ return nil. It's just not of _type_ `nil`. If you compare the return value against `nil`, the compiler will exchange `nil` with the nil value for the given type, but that's an implementation detail that really doesn't matter. To the programmer, a `nil` is a `nil`, and it doesn't matter what _type_ that `nil` is. &gt; Duck typing is nothing like interfaces But it is. If a type satisfies an interface, it can be passed around as any other type that satisfies that interface. Duck typing is probably the most common way to describe Go's interface system to people new to the language. The main difference is that Go's type system (structural typing) is compile-time checked when it can, but in many cases it's done at run-time (e.g. converting from `error` to `fmt.Stringer` or something). &gt; It doesn't make sense for Go, where a typed nil is a valid implementation of an interface. And my argument is that it _shouldn't_ be. &gt; Maybe you think calling methods on a nil receiver should panic or something And it usually does in practice. And yes, this is basically the crux of my argument. I disagree with this particular design decision of Go because: - it's not intuitive - it's not particularly useful
[removed]
So what makes nil special in Go? What about this: https://play.golang.org/p/j-gT8V3lv4F Should this code work? Should there be an exception for 0, because sometimes 0 is an invalid value for a method? What about negative numbers? Failure to account for negative values is also a common source of bugs. Why should the abstraction leak for nil? &gt;To the programmer, a nil is a nil, and it doesn't matter what type that nil is. And I say that to the programmer, the interface value is an interface value, and it doesn't matter what the underlying representation is. &gt;I disagree with this particular design decision of Go because: &gt;it's not intuitive &gt;it's not particularly useful The only reason you think it's not intuitive is because you've used other languages which choose to do things differently. I submit that if you were coming into Go as a tabula rasa your idea of what is intuitive would be exactly opposite.
Sometimes it annoys me that not everything can be nil e.g. the basic string is "" not nil.
Thank you for this I will watch!
Yeah, I get you. A slice of pie on the run is just isn't as good. You want to just stop and enjoy it, but always feel pressured to keep performance up so you have to stay moving.
can you use bufio.Scanner to start at a two-letter code within a set range of RP, LP, LR, MH,...... then scan until it hits a line that contains estimated tax and output al that to its own file?
I will look into scraping examples thank you for this lead.
Hi knome, you mentioned previously that valid domain labels could be found in an AAAA (IPv6) data record. That got me thinking. I believe I came up with a possible implementation approach and I can even justify it to be an efficient solution. Looking forward to your thoughts :-) 1. Keep a dictionary (hash map) of "suffix" =&gt; "byte index" key/value pairs Example: the domain [www.example.com](https://www.example.com) would give you a lookup table with the following values: lookup\["[www.example.com](https://www.example.com)"\] = 0x1234 lookup\["[example.com](https://example.com)"\] = 0x1238 lookup\["com"\] = 0x123F Lookups and inserts to a hash maps are O(log n) typically, but O(n) in the worst case. 2. Before writing a new domain name to the packet, do the following: Scan the entire packet for '\\0' and remember their indices. Create a fresh (empty) lookup table. Then, for each '\\0' found, scan backwards character by character to determine if valid domain name labels can be found. For each domain name found, populate the respective domain suffixes as indicated in step 1. This can be done in O(n) + O(n) = O(2n) = O(n) 3. Now write the new domain name. If the lookup table returns an available suffix available, use the given offset as a reference. Example: given [app.example.com](https://app.example.com), we would write \[3\] "app" to the packet, then a reference to 0x1238 as given by the lookup table. Each lookup to the hash map costs a worst O(n). Total time complexity: O(n)
Fields may be missing. There won't always be 4 address lines, there may be three also the copy and paste into reddit did not keep the formatting of the original text file. My experience with development work is novice at best. Building a state machine is not something I am capable of doing at my current level. I am looking for an example that I can look at study for a few minutes and if I understand it, alter it to assist me. But thanks for your input.
It certainly seems like there’s room in the market for a libre alternative to intel/arm. Glad there are some big players in the space. I’ll probably check back in once more official support exists, but I may check out your vm image anyways to see if some pet projects compile.
Please, test it out and report back anything you find. Follow the tracker on https://github.com/carlosedp/riscv-bringup!
I dunno, it seems like you just provided a good argument against ternaries :p
[removed]
&gt; This prometheus instance consumes more than 10GB of RAM even though we already tuned it As I know Prometheus stores recently added data in RAM. `recently added` usually means the last 2 hours. That's why it may consume big amounts of RAM when high number of targets with high number of metrics are scraped with small `scrape_interval`. Workarounds are: - To increase `scrape_interval`, so lower number of data points are added in RAM. - To reduce the number of metrics returned by each scrape target. - To split targets among multiple Prometheus instances, so each instance would required less RAM. But the total RAM size for all the Prometheus instances would remain the same. &gt; Have you considered writing a Prometheus scraper, which could be much more lightweight as it wouldn't do anything but pushing metrics to a remote write target of your choice? This sounds good, but I think it would be better if Prometheus could be configured with the reduced duration for storing recently scraped metrics in RAM. I'd propose filing an issue in Prometheus.
Check out Bettercap: https://github.com/bettercap/bettercap
&gt; Should there be an exception for 0 I specifically mentioned that only `nil` should be treated special, all other zero-values should be left as-is. That's because `nil` holds special meaning to nearly everyone, whereas `0`, `0.0`, `false`, etc are all context-sensitive. There's a reason why `nil` isn't a thing in Rust, and that's because it's a big source of bugs. Go's handling of the problem is worse, IMO, since it takes an opinionated stance on something that _will_ trip up a lot of people eventually, without a significant win aside from implementation consistency. &gt; Why should the abstraction leak for nil? It already leaks. If you assign `0` to an `int`, that value won't magically become `0.0` as a float or `false` as a bool w/o the programmer explicitly specifying that (and I can't remember if an `int` _can_ be coerced to a `bool`). If function A returns `nil` and function `B` returns the result of function A, I expect a comparison with the return of function `B` and `nil` to succeed in the same ways as a comparison with the return of function `A`. The fact that me saying `return nil` silently gets wrapped up in such a way that a comparison with `nil` fails is surprising behavior, and it shouldn't exist unless there's a good reason for it. There are a few solutions to this: - don't allow type-coercing constants (I like Rust's syntax of `0f64` and `0i32`; maybe that means `*T(nil)` or whatever) - have comparisons against interfaces _always_ check the data within (the type would either be `*T` or `nil`) The current solution is "well, I'm sorry you assumed" without a justification for _why_ it should be the way it is. `nil` is already special, let's make it special _and_ more useful. &gt; I submit that if you were coming into Go as a tabula rasa your idea of what is intuitive would be exactly opposite. I doubt it. In order to understand _why_ the behavior is the way it is, you need to understand that an interface consists of something like this: type interface struct { typ reflect.Type val reflect.Value } And that you're _really_ interacting with a `*interface`, when conceptually you're interacting with that part of the val that satisfies the typ. That's not immediately obvious, and the fact that `reflect.ValueOf(val).IsNil()` is different than a direct comparison with `nil` is confusing (again, I understand why, I just don't like it). Also, Go was designed to be familiar and productive, which is why it has pretty much _no_ new concepts. They didn't design it to be used by new programmers as their first language, they designed it to be used by Java and C developers.
&gt;{5}{hello}{goto @w}, {5}{world}@w{3}{web}{goto @e}, and {9}{something}@e{6}{example}{3}{com}{0} Oh and concerning your example, I believe it is sufficient to do *backward jumps* only. Here's a reordering of your example with exactly the same number of labels and references, resulting in the same, optimal result: {5}{hello}{3}{web}{6}{example}{3}{com}{0} {5}{world}{3}{web}{goto @e} {9}{something}{goto @e}
Ah thanks! Good reading
I’m afraid you will have to use your OS API for that...
This is cool! Thanks for sharing. I've been noodling how to safely and easily set up a secure tunnel across two docker hosts without using Swarm. I was able to quickly set something up using Mole.
immutable structures Mainly for ease of maintenance and understanding of the codebase. I don't want to have to read all uses of some structure to find out that it really is not modified in some module. In my experience most fields can be final/const and that helps to graps how a type behaves. Those few that are not are clearly doing something more. Reading code with final fields is much easier.
[removed]
[removed]
&gt;It already leaks. If you assign 0 to an int, that value won't magically become 0.0 as a float or false as a bool w/o the programmer explicitly specifying that (and I can't remember if an int can be coerced to a bool). If function A returns nil and function B returns the result of function A, I expect a comparison with the return of function B and nil to succeed in the same ways as a comparison with the return of function A. Did you even look at the example I gave? I did the same thing, but with the value 0 instead of nil, and it won't even compile. That's because an interface provides an abstraction that should and does hide the details of the implementation. &gt;In order to understand why the behavior is the way it is, you need to understand that an interface consists of something like this: No, you don't. You do need to understand that interfaces are similar to reference types, so they can be an untyped "nil", but if they're anything else all you know is that it's something that satisfies the interface, which means it is a valid receiver for the method signatures the interface declares. Since a nil of a specific type can be a valid receiver for the method signatures, the underlying value might be nil too, but you are _obliged_ to not care. &gt;And that you're really interacting with a *interface, when conceptually you're interacting with that part of the val that satisfies the typ. No. You are not conceptually interacting with the val at all. You are conceptually interacting with something of an unknown nature that implements certain methods. That's all. &gt;Also, Go was designed to be familiar and productive, which is why it has pretty much no new concepts. They didn't design it to be used by new programmers as their first language, they designed it to be used by Java and C developers. If it wasn't going to be different from Java and C there would be no value in it existing. The entire point of making it was to make something different from Java and C. Otherwise they'd have just written a competing JVM, or implemented another garbage collector for C.
Using them in our open source Marketstore time series database: [https://github.com/alpacahq/marketstore/blob/master/README.md](https://github.com/alpacahq/marketstore/blob/master/README.md) It's been very useful for isolating code that implements external API bindings from the core codebase. Interestingly, I've just run into a problem loading golang modules from Docker as of the most recent Docker-ce version 18.06.1-ce where running a container that tries to load golang plugins it hangs when trying to load. The issue is worked around by removing the secure computing profile using the flag "--security-opt=seccomp:unconfined", but I'm looking for a more targeted way to work around this issue...
Yes, it can be reassigned, but if you have an error and assign a nil to that, you'll end up with err == nil, so you'll see no errors. Also you may want to stop the code execution.
Have you see what people do in JS? I swear that it's common to see something like: function foo() { return condition ? // 20, 30, 50, even 100 lines of code : // 100 lines of code again ; } And when you as "Dude, if you're gonna do something as complex as that, why don't you use and "if" statement?" And they'll be like "That's an early return, readability -100, you have multiple exits in your code, blah blah blah" Same with everything that makes the language "less expressive" that stops people of doing crap. I'm so thankful that the Go designers removed those things even if it's a little bit "harder" to code, because when you read and maintain other people's code, you can understand it in minutes instead of hours.
You can, but you will be pigeonholed into using Protobufs for your application types. This may not be a problem for smaller projects, but for larger stuff having a models package with conversion methods is generally more manageable and flexible.
Mmmm, perhaps I'm misusing logrus? I use it to write down the log to the file and then open the file within the VS code editor.
I find myself just returning err in every case except where i would normally use a catch, so the additional explicitness is entirely boilerplate noise. May even make it somewhat harder to recognize at a glance where errors are actually being handled.
This transects with the whole caps = export problem. If I create a non-public struct called \`device\` it either has to be lower case or non-idiomatic uppercase (and commented if I want to pass govet). So, then I need a new name for actual instance variables, and the go convention is to create a (sometimes) obtuse short name, like fmt, or ctx. If I could import packages into my current namespace and use upper/lower for private variable names, this wouldn't be a problem.
Yeah this really sucks for dev, a command line argument to disable this would be great.
&gt; That's because an interface provides an abstraction that should and does hide the details of the implementation. Sure, and you're just explaining why the implementation does what it does. That's _far_ less useful than explaining _why_ the design is as it is. My argument is that treating `nil` special has value. Honestly, I don't really like the idea of `nil` at all, which is why I mentioned Rust. Rust is able to completely sidestep this whole issue because it's impossible to have the ambiguity (not to mention that everything is compile-time checked). When comparing an interface against `nil`, you use the same keyword as returning `nil`, so it can be very easy to make the mistake. Comparing an interface against `0` isn't something you ever do, though comparing against `nil` _is_ pretty common. The whole problem is that things get silently wrapped in an interface, whereas nothing else in Go (except constants, I suppose) gets its type silently changed. This is handy (you can do `fmt.Sprintf("%d", 1)` instead of `fmt.Sprintf("%d", interface{}(1))`, yet it results in this weird edge case and a bunch of others that can't be statically checked (e.g. the whole `reflect` library is needed for a lot of simple operations, where it's statically checked in other languages). &gt; Since a nil of a specific type can be a valid receiver for the method signature And as mentioned earlier, I'd be 100% okay if this were reversed. I like the fact that Rust avoids `nil` entirely, and it's certainly prevented a lot of bugs in my own code. However, doing that would make Go significantly harder to learn, so I'm looking for simple changes that would prevent the most common issues. So my question still is, what would be so bad about making a comparison between an interface and `nil` also check the data of the interface? Yes, `nil` is technically a valid value for the type, but is that useful enough to justify every case where it's not? What exactly does it allow you to do that wouldn't be doable otherwise? The only thing I can think of is pretty-printing a `nil` value with `String() string` or `Error() string`, and even then, just printing `nil` is probably good enough. &gt; You are conceptually interacting with something of an unknown nature that implements certain methods Or nil, meaning you have an invalid reference. Is the distinction between a reference to nil really any different than a nil reference? Yes, it is according to the implementation, but is the distinction important to the programmer? You give a method a pointer receiver because you want to be able to modify the data (or because copying is too expensive). You don't give a method a pointer receiver because you want to check for `nil`. It's almost always a mistake if a method gets called on a nil pointer, and *I* have never been able to come up with a useful use for it. I've done plenty of terrible things (e.g. using `*bool` to get three states: unassigned, true, false, `go panic(...)` to get around `recover()`, etc), but never have I come across a use-case for a nil pointer receiver, though I've been bitten by it on multiple occasions. I've learned to be more careful, but that's not very helpful when things work _almost_ like you expect for a new Go programmer, and I've often been in the unfortunate position of training new Go programmers who have mostly come from Python and Java, with a little C/C++. In fact, I don't think I've met _anyone_ who wasn't surprised at this behavior (again, it's on my short list of surprising Go behaviors). &gt; If it wasn't going to be different from Java and C there would be no value in it existing Sure. The point wasn't to make something different, the point was to make something that both could learn quickly. From Wikipedia: &gt; The designers wanted to address criticism of other languages in use at Google, but keep their useful characteristics: &gt; &gt; - Static typing and run-time efficiency (like C++) &gt; - Readability and usability (like Python or JavaScript)[25] &gt; - High-performance networking and multiprocessing Basically, they wanted a better fit for their problems, but to not stray too far from what their engineers were already familiar with. And I think they generally did a pretty good job. It's simpler than C++, more featureful than C, more productive than Java (that's pretty subjective), and way more performant than interpreted languages like Python and JavaScript. &gt; Otherwise they'd have just written a competing JVM, or implemented another garbage collector for C. No, that's not how Rob Pike works. He likes building things himself, which is why the Go compiler was based on Plan 9's C compiler (a project he worked on himself). If someone other than Rob Pike worked on it, the language would probably have looked more like Java, C, or Python than it does.
If you have a private (non-exported variable \`device\` (just something I recently used), and also an instance, what do you name them? dvc \*device? dev \*device? If there was an idiomatic naming convention for structs, like deviceObject or something, I could even get behind that, but as it is, your usable namespace is cut in half. That's my biggest gripe with the naming thing--I can't count the times I've had to get creative with naming to avoid conflicts caused by the namespace deficiencies.
Given its popularity and some of the really awesome stuff it can do, it would be nice if the language itself was more revolutionary. As it is it feels like simplified C code. There are some potentially game changing ideas in programming language design, and it's kind of disappointing that Go eschews those for obvious simplicity. I get why they did it, and practically speaking, it was a good idea, but I'd still like a language that makes me a better programmer instead of the other way around.
I have had the exact opposite experience.
Is this just another Go meta linter? Curious what new rules this scans for
THERE IS NO TRY CATCH IN GO
https://github.com/ksimka/go-is-not-good
It would though. With sql you scan individual fields which would work just fine. Mongo uses bson which works reasonably similarly to json with struct tags and the like, and json works fine: https://play.golang.org/p/GKBfr2NUwFZ
Like others have said, I wouldn't use Go for this. The Go2 proposals will allow you to build some core functional features, like boxed return values, maybe types, various iterators, etc, but it still won't change the core language. Go is very much a procedural language. If you're already experienced/comfortable with FP concepts from a real FP language, some of these new features will probably be a breath of fresh air, but they'll also be frustrating in that your favorite FP functionality will be comparatively crippled. IMO, if you want a compiled, statically typed language with FP and a strong, upcoming ecosystem, your best bet today is Rust. Your best bet with Go is to write some code in a good FP language, and then bring back some of the most useful concepts into the procedural world of Go. If you really have to do FP in Go, wait for the new features to make things better, and just realize that what you're doing in Go is never really going to be functional.
Did you read the instructions?
Sorry for brevity I'm in transit. &amp;#x200B; Thanks all for the feedback. I just started a book "Learning Functional Programming in Go- Lex Sheehan" and while it's interesting, after reading the comments here and other resources it does seem I'd be better off looking into Rust or a \`real\` FP language. &amp;#x200B; My original intention was to learn some FP concepts that could be used in go in hopes of basically writing better, cleaner, simpler go code.
Thank you that's a great talk
&gt; I find myself just returning err in every case Good, that's what's intended! &gt; additional explicitness is entirely boilerplate noise All signal zero noise. That's the beauty of explicitness. &gt; May even make it somewhat harder Nonsense.
Just to pass back and forth. They define a nice contract so you could write an api in go then send the protobuffer file to other developers who would then use it to generate a contract in their language/project to consume it.
I suspect they will catch on eventually. They are much easier to deal with overall than json.
I think I've had to do something similar as part of an ETL process that serializes db rows to json. I created a struct that maps to the database row, then create a function with that struct as a receiver to cast to a different type. See [https://play.golang.org/p/n-Ff6PIlVqs](https://play.golang.org/p/n-Ff6PIlVqs)
!!! Where my sets at?
Awesome. I have a request &amp;#x200B; Can you please write guides for this 01. Implementing audio chat/conferencing using Go and WebRTC 02. Implementing text chat using Go and WebRTC 03. Implementing video chat/conferencing using Go and WebRTC &amp;#x200B; I've explored pion webrtc package but the examples are overly complicated. So if you can make tutorial for this three, let me know please at my email that I have sent you in pm, thanks
I feel like who ever decided on this needs to explain them self, why throw away convention? Hopefully not just an esthetic choice.
I think most people just go with referring to other labels, but if you're parsing a packet, you need to be ready for anything that's legal. Actually redirecting into the header or mid data is probably a bit mad, but I think it's hilarious. If you're choosing to play at that madness, you could keep a running list of where any potential jumps might lead as well, checking behind each potential jump for a potential valid label and then being ready incase it jumps to a 0 or another label. The odds are incredibly against for anything short of manufacturing such packets for amusement, however. I should point out, you may have taken me to mean the jump is for the label and then back, but it's not. It's an unconditional jump from the end of one chain to the start or middle of another and never returns. Sorry if I misled you.
Yes, yes it is.
If performance isnt a big concern, i would simply json Unmarshal then json Marshal one struct into the other
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
I have a few more posts in mind that will touch some of those subject. Stay tuned!
&gt; _Is this just another Go meta linter? Curious what new rules this scans for_ The way you say that makes it sound like StaticCheck is a copy-cat of Gometalinter, but actually StaticCheck is 3+ years old [1] so while the two are similar, they are quite different. Also, in case you don’t know, Gometalinter was deprecated on April 7, 2019 [4] and the author explicitly suggests people to switch to GolangCI-Lint [4]. You can read about StaticCheck’s rules here [5]. [1] StaticCheck’s [initial commit was on Mar 13, 2016](https://github.com/dominikh/go-tools/commit/19ad1d326b88e978181d6fa0d06da0cbae2fa2d9) [2] Gometalinter’s [initial commit was on Aug 4, 2014](https://github.com/alecthomas/gometalinter/commit/00d12a1332c2b150e38024fe73a68ce298f5dd96) [3] https://github.com/alecthomas/gometalinter/issues/590 [4] GolangCI-Lint’s [initial commit was on May 4, 2018](https://github.com/golangci/golangci-lint/commit/cd8b11773c6c1f595e8eb98c0d4310af20ae20df) [5] https://staticcheck.io/docs/checks
It is not a meta linter, no. It's a proper linter, with &gt;100 rules, most of which do not exist in other tools. http://staticcheck.io/docs/checks has a list of all the checks.
[removed]
[removed]
[removed]
If you're using it as a part of a regular REST service marshalling/unmarshalling will be a tiny fraction of request processing. On the other hand if you're ingesting large (tens of megabytes and larger) files, then you might want to look for something a bit less safe but faster.
The benchmark is on a small JSON example. I did benchmark, too, versus json-iter and found that standard encoding/json does pretty well for small examples, but much slower for bigger JSON examples.
It's early days for it. But yes, it would be great if it was just another target.
Well, the very first part of the README explains exactly how that works: if you are streaming the output to a TTY, it'll by default use [this kind of formatter](https://camo.githubusercontent.com/b9d0e424bfc6378e79b90de33b983ef5bae2f578/687474703a2f2f692e696d6775722e636f6d2f505937714d77642e706e67), otherwise it'll just use plain text. Technically speaking, the best way to use logrus is to have two configurations: use the default when doing development, so you get the nicely-colored terminal output, then enable the JSON formatter in production and stream everything to a service like Datadog/LogDNA/ELK stack.
[removed]
you can write a custom `SplitFunc` then use `.Split(fn)`
You simply handle cors properly. There are dozens of packages and gists on github on how to do that like https://github.com/rs/cors
thats really awesome !
i use it for printing, you need to install libusb ( its also mentioned clearly in the installation process on github ): [https://github.com/libusb/libusb/wiki](https://github.com/libusb/libusb/wiki)
I'm curious what the point of equating slices of different lengths would even be?
From your example I got that this is a line-oriented protocol, that's why I suggested the default bufio.Scanner. If it is not, then you need your own SplitFunc, or read chunks and parse those. If all these are separate lines, then iterate the lines with bufio.Scanner, and decide what to do with the line based on your state (in a structure or not) and the line (out &amp; starts with a specific two-letter code -&gt; start a new struct, change the state to "in"; in and found the &lt;estimated tax&gt; -&gt; finish the struct and change the state to "out").
https://go.org/ Hello, it appears you tried to put a link in a title, since most users cant click these I have placed it here for you ^I ^am ^a ^bot ^if ^you ^have ^any ^suggestions ^dm ^me
Anyone have some "low seven figure" money laying around?
It does nothing for this problem. catch/handle would alleviate the pain here.
But you're not forced to check anything. You can ignore any error and no one's going to tell you anything.
Slice comparison is useful for unittesting. Typically this is done with [reflect.DeepEqual()](https://golang.org/pkg/reflect/#DeepEqual)
May be this would be useful 4 u &amp;#x200B; [https://www.youtube.com/watch?v=5buaPyJ0XeQ](https://www.youtube.com/watch?v=5buaPyJ0XeQ)
You could put a link to the go blog page in your article, together with your motivation and intended audience.
Why is that? Because of nested conditional operators to be used in a single expression? If so, Is there any way to disable nested conditional operators at compile time? In my own language, I tried this: [parser.go](https://github.com/movsb/taolang/blob/c35175c2dd85498b218569ef964501403c5e043a/taolang/parser.go#L543)
It adds layer specific error, and you want to catch errors from blocks. I don't say it's bad, but it is something different.
4) it's no hack, it's really bad decision. 5) Error is interface. Everything that can describe self by string can be error.
godoc.org shows the number of packages that import them, which might be usable as a basic stab at this, in addition to GitHub stars of you like that sort of thing.
Shitty ones. There are tons of APIs that generate inconsistent or invalid JSON.
Thank you.
This! Cross the bridge when you get there.
That’s what I thought but that’s not possible. You still get Cors errors while accessing the database via the other Webserver.
I'm sure google does.
Please show me. I am eager to use it! &amp;#x200B; I need map, filter, flatMap in the first round.
Ok, got it. You can write those, but the lack of generics makes it useless.
Random map order: consequence of using a hash map instead of a binary tree. Depending on the use case, hash maps may have advantages. There are many languages with built-in maps (instead of a library implementation) that is a hashmap, and thus random order. Most std. libraries of languages offer both options, hashmap or tree. The data strcuture library of go is weak and not much used, due to the lack of generics. Once we have generics, I expect useful extentions to the std. library and more use of a library provided tree-map that preserves order.
Not for Go though
I’m not sure if people on this subreddit would be interested, but since my father suggested these and he uses Go, I thought you might. :) I’m Kickstarting a set of Go Gopher enamel pins, they’re now available to back at \*link\*. If you’re interested this is the quickest way to get your hands on some! :) *Based on the Go Gopher, created by Renee French, but I’m sure this subreddit knows that. ;)* \-Fynn
I think the "golang" moniker is also useful because you can search for it!
No method overloading
We do not negotiate with terrorists and other hostage takers.
&gt; The gopher images are Creative Commons Attribution 3.0 licensed. That means you can play with the images but you must give credit to their creator (Renee French) wherever they are used.
how about some `defer recover()` for your needs? /s
 var value *MyStruct if somethingSomething { value = &amp;{} // or new() } that looks actually pretty good :o (not in the language tho)
Thanks dude, I had credited Renee already. :)
[https://hackernoon.com/parallel-merge-sort-in-go-fe14c1bc006](https://hackernoon.com/parallel-merge-sort-in-go-fe14c1bc006)
Great work [u/sparks\_333](https://www.reddit.com/user/sparks_333/)! Just played with the demo locally, fantastic how easy it was to setup! (compared to cool examples like this in other languages) &amp;#x200B; Thanks for using Pion! Also If there is anything I can do to make Pion WebRTC better always looking for feedback.
`Minimum offer 50,000 USD`
why.. just why is it not just `time.Parse(value, "yyyy-MM-dd HH:mm:ss")`
and now clang is not a c-language but a c/c++ language compatible compiler
yeah... No !
`net/uniformresourcelocator` sound more promising `uniformresourcelocator`.Parse("file:///c/files/test.ext") (i mostly call my urls "link" because of that issue)
&gt; Because arr.filter(a =&gt; a.sum &gt; 0) is just too messy couldn't you at least have used the go syntax for anonymous functions?
and the time formatting uses standard "yyyyMMddHHmmss" for everything (no it doesn't. It\`s really ugly)
Just to confuse your local post office you now have a pledge from Austria 😅
Exactly, "fast enough" is usually fine for 99% of projects.
Trying to use this now but having difficulty with telling it where the proto files are for decoding the messages. Finds the files in the directory path I specify but fails to resolve any included protos. On Windows 10. Could debug it but not a go practitioner yet!
Already Fix Content: #### Code - [x] package name - [x] Refactor one versions #### girls.go: - [x] Traditionally you would move your "main" to cmd/girls and not have your package as "main". This makes it impossible to use for anyone. - [x] Typically you would name the file with "main()" main.go. #### resize.go: - [x] No need to export var Cmdline. - [x] newFile, _ := os.Create(save) Check your errors! - [x] resize.NearestNeighbor if you are doing a resize library, do some basic research. This is without a doubt the worst option you could have chosen. (use bicubic/lanczos) - [x] jpeg.Encode(newFile, newImg, &amp;jpeg.Options{85}) - wasn't there supposed to be a flag for quality? - [x] defer newFile.Close() you might as well close it here, this is way too late. Move it to right after you've opened it. #### task.go: - [x] // GirImage.Resize used for various resource image type... This documentation says nothing. - [x] type GirImage struct - this should just be "Image". No need to prefix your types here. - [x] type GirTask struct.. again, could just as well be Task. - [x] fin: make(chan bool) - this might as well be a chan struct{} since you are not using the bool anyway. - [x] GirTask So the data []byte is the input file name or URL? Why is this a []byte. And why is it called "data" - I assumed it was the image data. - [x] type GirImage struct. =&gt; Refactor Image interface - [x] func (gt *GirTask) IsEmpty() bool. I personally prefer Empty() bool since the 'Is' is implied by the returned bool. - [x] log.Println("resize fail:", err): Consider whether this should be written to stderr instead. Also your program returns status code 0 even if something failed, maybe not the best idea. Thanks very much!!
i though this is a ternary operator. Its concise but can be hard to understand when you look at other people's code.
What? Aren't the conditional operator and the ternary operator the same things?
ARM / concerned about power usage is probably a good starting point. As well as its weight should be in grams, not kg.
&gt; which implementation is most stable? If there have been no commits since 4 years the implementation is "more stable" than then one from a different package with commits every 6 month?
If you don't already pool objects with the sync package, that might help reduce allocations dramatically. Make sure you hold the file open instead of opening it every read and closing it again. There might be other things you can do too but I wouldn't be terribly surprised if it's just hard to get good performance out of parsing millions of lines excel considering the storage is XML documents in a zip file basically.
Maybe we can start crowdfunding?
Great idea, joined the kickstarter as well! May I suggest a "vim-go" gopher pin as an option?
RemindMe! 2 days
Nice try, domain salesperson.
I will be messaging you on [**2019-06-27 12:11:15 UTC**](http://www.wolframalpha.com/input/?i=2019-06-27 12:11:15 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/c54qrw/some_pins_i_made_based_on_the_go_gopher_now/es03lqg/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/c54qrw/some_pins_i_made_based_on_the_go_gopher_now/es03lqg/]%0A%0ARemindMe! 2 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
&gt; Pass by value can be expensive Passing by value is only expensive if your parameters are extremely large, and in practice, the only way to do that in Go is if they contain very large arrays (not slices) as all other large types tend to have reference semantics. Consequently pass by value is rarely expensive, and you should never try to micro-optimize your code on this basis without profiling first.
Use gorm hooks (beforesave, afterfind) and an ignored field `gorm:"-"`
Can someone please start this?
Nice!
Why?
thanks, its just one function so far so if u see any other use cases feel free to send pr or create an issue ! :)
Great, Thanks!
Noted. Thank you.
Yes, you can find small perl scripts just about everywhere. It's got a bad rep but it's not the awful language some people make it to be. Have a look at [modern perl](http://modernperlbooks.com/books/modern_perl_2016/index.html) if you're curious.
Does the Luke gopher get sent out instead of or in conjunction with the OG gopher if 800 is reached?
You can as well as anyone else. But I gotta tell you, so as to calibrate expectations, I have no idea why I would contribute to it. My life isn't going to improve because someone else has the [go.org](https://go.org) domain.
Instead of casting to a byte slice and computing offsets yourself, you can just cast to an equivalent structure: p := (*struct{ addr *strings.Builder buf []byte })(unsafe.Pointer(&amp;sb)) p.buf[1] = 1
I love you. This is perfect.
These scripts all look small enough to be easily rewritten in Go. I wonder if there's a reason to keep them in Perl (or rather, why were they written in Perl in the first place)? I imagine the maintainers would be reluctant to accept a patch converting the Perl to Go, however; the Perl scripts have functioned perfectly well, and rewriting them risks breakage.
FYI you can wrap it in `if false {` and that will work like commenting out but not cause the compiler to complain about unused variables.
I am confused what does it do. Does it transpile go to JS or JS to go ? Or something else ?
Cloudflare has an office in Lisbon. Check out the site.
It is an implementation of the ECMAScript language specification. So at some point, you will be able to evaluate .js files. It's like Google's V8 engine, but in Go.
Ah, very cool. Thanks for teaching me something today. Would never have thought of that!
Rudiments from the times when the compiler was in C.
Creating a new logger and making a non zero instance of `bytes.Buffer` on every request will not perform efficiently both in time and allocations. Use `runtime.Caller` to obtain all that information directly.
Can't you use the literal object in a script tag? I [tried this](https://play.golang.org/p/iJuB8mDrgY1) and it seems to work
My implementation [https://github.com/HassankSalim/GopherExecise/blob/master/parallel-mergo-sort/merge.go](https://github.com/HassankSalim/GopherExecise/blob/master/parallel-mergo-sort/merge.go)
Why not?
Like goja or otto?
In terms of "working", I believe that would make it invalid for JSON-LD. The first non-whitespace character needs to be a bracket, I believe.
Here's the issue using your example. [https://play.golang.org/p/XoTsJ5\_7n3L](https://play.golang.org/p/XoTsJ5_7n3L) When I add an "&amp;" to your "This Works" it html escapes that string.
The interesting part is that's actually okay. The "&amp;" isn't the issue. The escaping slashes in urls are the real problem. I'm not getting that in the example window. I'm not sure why it's happening in my project.
Even better, you can just refer to the target field by name, even if not exported: From https://rosettacode.org/wiki/Break_OO_privacy#Go : func anotherExample() { r := bufio.NewReader(os.Stdin) // Do the dirty stuff in one ugly and unsafe statement: errp := (*error)(unsafe.Pointer( reflect.ValueOf(r).Elem().FieldByName("err").Addr().Pointer())) *errp = errors.New("unsafely injected error value into bufio inner workings") _, err := r.ReadByte() fmt.Println("bufio.ReadByte returned error:", err) } gives "`bufio.ReadByte returned error: unsafely injected error value into bufio inner workings`".
No, neither project has the intention to add much more than what you have in ECMAScript 5.1. Authors replied to requests saying that it isn't needed because there are transpilers that work just fine. At the moment, these libraries have poor module support, don't support Annex B of 5.1, and they have Date libraries that vary from browsers and node. It's been a while since I looked, but there might be some other issues too. That said, I have great respect for both libraries and am very thankful for the works.
There are a lot of times you might need a scripting language to configure something in the end product via a professional services team. Document management, workflow, many other enterprise apps, etc might want a way for sales to claim the product can do just about anything without a product change. Similarly, setup, configuration, and games might also need scripting languages. Current choices that avoid use of cgo include Lua (less known than JavaScript), JS (both main libs are fairly frozen at 5.1 support for ECMA standards), Python-ish syntax (which Delve is looking into using for scripting). Overall, there are a few good options, but there is plenty of reason to want more modern JS for scripting basic logic without transpiling. Anytime you add a scripting language, you are probably bumping up the complexity of a product a lot, but if you're selling to customers with 50k+ employees, you might need to check a lot of features off that you can't really provide in your main product.
This is a great reason. :) Parsing and interpreting is a lot of fun.
Interesting look at template.html vs template.js. Neither are giving me my escaped url slashes though. [https://play.golang.org/p/Ax7e0ULUaD1](https://play.golang.org/p/Ax7e0ULUaD1)
also json-iter doesn' t marshal properly. e.g it doesn't marshal slice of a custom type which does have MarshalJson function as an json array (like std lib). but as base64 encoded string. &amp;#x200B; I've reported it and received no response whatsoever.
I believe you. I'm pretty sure json-iter dropped some features for performance.
In this state, it sounds hard to collaborate. I starred it and intend to contribute as soon as you have progressed a little more. Perhaps after issue 3 is complete I can chip away at some built in functions.
I've made a simple golang project starter, which contains the following features: &amp;#x200B; \- Makefile using to run most common functions \- Debug tool using \[delve\]([https://github.com/go-delve/delve](https://github.com/go-delve/delve)) \- Automatically install dependencies using \[\`GOPROXY\`\]([https://github.com/golang/go/wiki/Modules#are-there-always-on-module-repositories-and-enterprise-proxies](https://github.com/golang/go/wiki/Modules#are-there-always-on-module-repositories-and-enterprise-proxies)) \- Automatically restarted webdev server \- Cross compilation demonstration command \- Automatically linting before \`git commit\` &amp;#x200B; Any comments are welcome!
What are you options if you don't want to stream audio to [Google for transcribing](https://github.com/rviscarra/webrtc-speech-to-text/blob/3d89718e3c12023d91f24ce6e7cd2dbb6295d610/internal/transcribe/gspeech.go#L9-L11)?
Agree. I wrote a simple AES-CTR encryption wrapper with SHA512 HMAC authentication because I wanted to work on large files without loading them into memory for Go's version of GCM. However, performance suffers some as you can see. https://github.com/Xeoncross/go-aesctr-with-hmac
good tip, thanks
some high-level tips off the top of my head: * validate your inputs from the clients * validate your data before you save it to the db. * manually convert client inputs to db models (rather than say, blindly unmarshalling to an internal struct) * Check that the current user has access to do the thing they're trying to do. Do this consistently at the same layer in the application so it's obvious when it's missing. * Part of permissions: check that the current user is the user being operated on if you're getting the user id from the route/params. Don't assume. * store passwords properly (currently that's bcrypt with \~11 rounds, not the default # of rounds! Make sure this setting is appropriate for the current era as the # of recommended rounds changes over time; especially important if you're reading this post years later). * use an random initialization vector for any manual crypto you're doing, and don't reuse it. * make a distinction between client-facing errors and server errors. Log server errors and don't return the text (just 500), send client errors with an appropriate client-error code (4xx) and the text saying what to do to fix it, if possible. Bonus points if your validation framework can return details on field-specific errors in a structure that the client can use.
This is awesome thank you!! I normally run wfuzz against all my input parameters to try and find crashes but I completely forgot about that. Also that's a really good point about converting data to models I'm not sure I'm doing this everywhere... This is the best info I've got on security best practices in Go APIs thank you so much!
The quick rule makes me mad everytime. Why month first? Why year 6th? If I have to remember all that, then any better than convention?
Look at this https://blog.cloudflare.com/exposing-go-on-the-internet/ it’s a little old but it’s useful - some other useful stuff on the Cloudflare blog
Thanks. I find structuring the app well helps with remembering to do these things. My apps are layed out with separate packages for contracts (client requests/responses), handlers, domain (business logic, access checks can go here), models, db (database-specific queries, etc), and middleware (auth goes here). I'm sure someone's going to come in and disagree with me here, but I've worked on many large Go projects, and I've never liked the many-package and repository approaches. Those packages seem to turn into a huge spaghetti messes where nobody knows what's going on and "refactoring" is talked about in every retro.
&gt; And by DOS I mean any inputs that may cause the server to panic and crash. Are there any good test frameworks for testing this kind of stuff?\ https://github.com/dvyukov/go-fuzz
https://astaxie.gitbooks.io/build-web-application-with-golang/en/09.0.html The chapters on security are well written and accurate.
I only just skimread a bit but that's some fantastic reading I've not come across before thank you so much!
A geedis pin would be better
You could use [Sphinx](https://cmusphinx.github.io/) or you could do everything in the browser using the [Web Speech API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API/Using_the_Web_Speech_API)
You’re bitten by sirupsen’s GitHub name change. I suspect you have an old reference to “github.com/Sirupsen/logrus”, with the capitalized name. Make sure all the references are properly lowercased.
Asymmetry reduced, but not eliminated. I approve!
Various perl scripts being ported/rewritten is not uncommon. Much of the code that generates `x/sys` was rewritten only a few months ago, among many other things. See: https://github.com/golang/go/issues/27779
Yup, pattern matching and better slice syntax is something that I miss constantly. I love Go, I understand why they did it but it still bothers me from time to time. BTW it's such bullshit for getting downvoted for saying what you don't like about a language in a thread that asks you what you don't like about the language. Whoever downvotes - fuck you sideways.
It would be valuable in the readme to compare this library to other implementations, and address the "why should I use this library over the others", eg given a library like [https://github.com/dgrijalva/jwt-go](https://github.com/dgrijalva/jwt-go), how does yours stack up and make it worth taking a "risk" on your library.
At this point, I wouldn't use webview. The master branch is IE11, which is a nightmare by the standards of the modern web. You really don't want to write a web app targeting IE11. The new branch is supposed to support Edge, but that works only on recent Windows 10 (no Win7 or Win8) and the project seems to be dead. 5 months without update and abandoned by the maintainer (not even merging other people's work https://github.com/zserge/webview/pulls). Realistically, use Electron and write the backend in Go or look into Flutter with go bindings. Flutter on desktop is still nascent but they are at least improving it steadily.
If you use go-fuzz, try the libfuzzer flag. Turns out it finds more bugs using libfuzzer and clang.
Hi thanks for the relpy! Do you know where I can change those references? It’s my first day using go so I am still learning a lot
Check your import statements at the top of your ‘*.go” files.
In the import it says “"github.com/sirupsen/logrus"”
When I used Sphinx around 10 years ago it was not very accurate. Ended up buying license of Loquendo at the time, which is now Nuance iirc.
The cgo unit tests also depend on fortran. Got errors about that when the environment I was using to build the compiler didn’t have fortran.
I think that's a decent idea. I'll add something
Did you check the Go.mod file as well?
Maybe check `go.mod` as well.
Yeah there it says github.com/sirupsen/logrus v1.4.2 //indirect
Not sure then. I’d grep your project and see if you can find anything upper cased. If you still can’t find anything, maybe look in your `$GOPATH` and see if you have a copy of the library in the wrong cases directory.
The Web Speech API only works on Chrome and uses Google anyway. I'll look at Sphinx though. &gt; On Chrome, using Speech Recognition on a web page involves a server-based recognition engine. Your audio is sent to a web service for recognition processing, so it won't work offline.
What I see now is that the sirupsen dir is not directly in my $GOPATH directory as it states but in other directory in that $GOPATH. When I transfer the sirupsen dir directly to the GOPATH dir the error stays the same and a second one appears?
yes, and installed libusb
i have installed it, but still getting an error
Found a few Go bindings and projects - Spinx: https://github.com/xlab/pocketsphinx-go and https://github.com/kladd/stt - https://github.com/mozilla/DeepSpeech: https://github.com/asticode/go-astideepspeech
I totally missed that, disappointing
Because a map variable in go is actually a pointer to the map header of the underlying map implementation. [This pointer can be nil itself.](https://play.golang.org/p/2l1dHYboGTq) `nil` is not a type in itself, just like `5` is not a type. Both are values.
To answer the rest of your question: The designers of golang decided to not put a nil check before every map access for performance reasons. It is up to the developer to make sure the map is not nil, just like it is up to the developer to make sure a pointer is not nil before dereferencing it. If you can't guarantee that your pointer or map is not-nil, you can put the check in your code yourself.
Fun fact, the golang specifications do not specify that map is a pointer type.
Golang is at least googleable, so I'm glad they established that with the url.
Do you mean like jdt annotations in Java/Eclipse? Because you can not guarantee that something is not nil... you can, but with go this would become incredibly expensive and complex (to satisfy the compiler in a way that you would with Java and jdt annotations)
Thank you, exactly my answer and motivation. And i agree on your last sentence!
Good point. The [golang specification](https://golang.org/ref/spec#Map_types) says &gt;The value of an uninitialized map is `nil`.
Because it isn't. Otherwise it would be possible to dereference it.
Why would that need "kickstarting"? Kickstarter was such a great idea that went to shit pretty fast.
I forgot that `nil` is not a type in Go...thanks!
Sweet! I’ve been looking for something like this because Go is a bit weird to start developing with
I use a config package that has no app dependencies, call config.Load() and pass the result around. Something along those lines.
“Make sure the libusb-1.0.pc pkg-config file from libusb was installed and that the result of the pkg-config --cflags libusb-1.0 command shows the correct include path for installed libusb.”
I see a lot of Gophers posting here looking for Open Source projects where they can contribute, so I wrote this up. &amp;#x200B; If you are looking to contribute to an Open Source project we would love to have you! I have been working on triaging things and making it more friendly. I would also love feedback about ways we can make the project more contribution friendly (or any way we can improve it!)
Saving this thread because I've been working with code generation from an OpenAPI specification into a Go client and server.
[removed]
[removed]
very nice list
You can lookup elements in a nil map. It always fails. What you cannot do is add an element to a nil map.
If you were interested in that article, you might also enjoy https://medium.com/@tonistiigi/early-look-at-docker-containers-on-risc-v-40ed43b16b09
I mean technically you can ...
Google has lots of money for Go but they spend it on programmers, infrastructure, sponsorships, etc, not on paying off domain squatters.
Thanks! I was going for a cuter &amp; shorter look, I think it worked out nicely! :)
I had never heard of Geedis, and now I must know what Geedis is! Who made it? A true mystery. :)
If you back for more than 1 pin, they'll all be sent out together. :)
Kickstarter has its problems, but it's good for raising funds to make fun things like these. :)
Obligatory: [https://xkcd.com/224/](https://xkcd.com/224/)
Lots of people are suggesting that, I'll have to make it now. :)
You'd have to look at languages with more sophisticated type systems, like crystal.
Lol! Hopefully they'll be able to manage with it! :)
thanks for hit, i updated thus packaged. also added flags to pick what data to return
Because you can’t
I meant no offense. Was just genuinely wondering what the motivations and expectations are for this project.
It is possible to design a language that does this by using initialization tracking. It would affect a number of language design decisions, though. Every variable would have to be assigned a value before use. Arrays would always have to be initialized to a literal value. Slices could only be created with zero length and grown with append (you could still preallocate capacity, though) unless they are created from a literal or an array. You wouldn't be able to grow a slice with existing surplus capacity manually. Map and channel operations would have to return optional values (values which can either be initialized or nil) to account for the cases where no value is available. The decision was made for Go to forgo initialization tracking, and instead to just give every type a "zero" value. In some ways, this makes things simpler and creates less friction when writing code. The drawback is that any pointer, map, chan, slice, func, or interface could potentially be nil. Since Go doesn't have initialization tracking, it requires you to specify when nil values are allowed at function boundaries as part of the unchecked contract of the function. If nil isn't a valid argument or return value to/from a function, then you don't need to check for it. You'll get a runtime error if a nil value appears where it shouldn't and you try to use it, which is all you can really do about contract violations in any case.
OP, were you able to resolve this?
I have this same request almost every time someone writes a library that attempts to re-solve a well known problem. Please add a section to your FAQ comparing this project to it's biggest competitors and inspirations. If you don't explain to me (without too much bias) how this is different and/or better than Cobra and docopt then I will just keep using those projects. This doc on how Vue differs from the alternatives is is the gold standard. https://vuejs.org/v2/guide/comparison.html
It sounds like you’re looking at the module cache. You should leave that alone. If you modified it, you can just delete the whole cache and it will be redownloaded. The uppercase issue might be in one of your dependencies. Mac OS is not case sensitive (it is case preserving), so it is possible a Mac developer didn’t notice they have the wrong path.
You might want to test how your app handles high load: https://github.com/rakyll/hey/blob/master/README.md
&gt; why can't the type-checking system warn you to make sure that the pointer is not nil before you try to access a value within the map? Type-checking does just what the name says - it *checks* that your program is well-typed. So if your type system (as in the case of Go) doesn't distinguish between `nil` and non-`nil` maps, then a type-checker can't solve that. It *is* of course possible to build a type-system that *does* distinguish between the two and it is possible to build a type-checker for that and check it statically. Go opted not to do that, though - mainly for simplicity. Now, you *can* implement a static check on top of Go's type system (that is, you don't modify the language, but have an extra tool to do this check). However, due to the unsolvability of the halting problem, you have to decide to either have false negatives (you won't find every mistake) or false positives (you might reject some valid programs). This is because otherwise, you could write var x map[int]int if RunInputProgram(prog, input) { x = make(map[int]int) } x[23] = 42 and solve the halting program - this program will panic if and only if the input program halts, so if you'd have a perfectly accurate static checker, it would need to determine whether the program halts statically. Note, by the way, that this dilemma is exactly what type-systems need to decide on too. They have to statically determine the validity of a program too, so they, too, must either be restrictive (thus rejecting some valid programs) or permissive (thus allowing some invalid programs). Both choices have advantages and disadvantages. Go opted for the latter. Some other languages (Rust comes to mind) opted for the former. Both are reasonable decisions :)
&gt; The designers of golang decided to not put a nil check before every map access for performance reasons. I don't think this fully tracks. It's just that you can't really do anything if the map is `nil` except panic anyway - so might as well do the check in hardware :)
Or like Kotlin where nullability is baked into the type.
Hey @zevdg, thank you for the **valuable** feedback. You're definitely right, that section is missing and I'll add it as soon as possible.
Nope. The golang domain is fine. These domain squatting scum don't deserve 7 figures. I hope google doesn't buy it out of principle.
Nope. The golang domain is fine. These domain squatting scum don't deserve 7 figures. I hope google doesn't buy it out of principle.
Great questions! I can suggest the following three resources: 1. [Awesome Golang Security List](https://github.com/guardrailsio/awesome-golang-security) 2. [GoSec - Security Scanner](https://github.com/securego/gosec) 3. [GuardRails ](https://github.com/marketplace/guardrails) - combines a bunch of open-source tools to identify security issues in code, hard-coded credentials/secrets, and known security issues in 3rd party dependencies Hope that helps!
Solid post, I’ve got these stupid coin things so ima give you silver even though I’m like 96% sure it doesn’t do anything
Thanks!!!
ISO / Most significant value first with timezone postfix. Not only is it conventional it's logical.
[removed]
You don't need dependent typing for null safety. [ADT](https://en.wikipedia.org/wiki/Algebraic_data_type) is enough.
Yes, you can. But the canonical way to avoid NPE is to use [Algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type), which generally requires generics support. There are some issues about adding sum type to go on Github, such that [\#19412](https://github.com/golang/go/issues/19412). If you'd like to know more, you may look at [Rust](https://www.rust-lang.org/) (or any other static functional language).
[removed]
[removed]
[removed]
You can just store the raw Argon2 hash it gives you. It's already hashed and secured for storage. You *could* take it to the next level and encrypt it like I think Dropbox does so they would have to both steal your key and then run it through a cracker but that's a bit paranoid short of wanting to do everything possible to secure passwords. &amp;#x200B; As for storage itself, Argon2 should be outputting a fixed length and that'd be slightly more efficient on the storage space. Probably not a huge deal unless you're storing tens of millions.
There is no difference between varchar(20) and text in postgresql. They even recommend to use the unbounded text.
yes, pkg-config is in PATH, i think there is some problem with libusb location, i tried to put it next to my project, tried to put in in libraries folder in system32, also tried to use Zadig, but still getting same error
[removed]
Not OP, new to golang and writing an API. Could you tell me how you can manually unmarshal JSON fields without instantiating a struct of the data you expect, and what are some vulnerabilities with that? At the moment I have a method on the struct that validates and sanitizes its fields, done before saving in persistence.
try icmpHeader := []byte(myICMPType + myICMPCode) checkSum := icmpHeader &amp; 0xFFFFFFFF
I was recently dealing with this issue. This should work as long as the repository isn't private. The way I have gathered to do this is like the following module gitlab.com/foo/foo require gitlab.com/bar/foo/foobar v1.0.0 replace gitlab.com/bar/foo/foobar =&gt; gitlab.com/bar/foo/foobar.git v1.0.0
&gt;You could take it to the next level and encrypt it like I think Dropbox does so they would have to both steal your key and then run it through a cracker but that's a bit paranoid short of wanting to do everything possible to secure passwords. Like have postgres also one-way hash the hashed password, then check password attempts against that hash in postgres?
No, literally encrypt it. Reversible. Dropbox or some other company I can't recall does the hashing (like your supposed to) which is non-reversible. Then they take the hash and encrypt it. They then store the encrypted version in the DB. &amp;#x200B; To check a password they would pull the users password from the DB, decrypt it to get the hash and then rush the hash verification function to see if the provided password matches.
Small addition on panics: you can wrap some handlers with function, which recovers from panic to avoid termination of the whole server. Or even add such middleware (in case you are using gorilla/mux take a look at RecoveryHandler).
This is all so helpful thank you!
OWASP ftw! [https://github.com/OWASP/API-Security/tree/develop](https://github.com/OWASP/API-Security/tree/develop)
In my case, I base64 it and store it in a \`varchar(256) NOT NULL\`. You could encrypt it too to make use of it like a pepper, but i'm not doing that for now. I know there is no technical difference between \`text\` and \`varchar\` in postgres, but I like to have additional input validation in my database.
Why are you being downvoted?! A bit wise operation on a bytearray works. Did I miss a typo?
Very interesting comment thread there with some heavy hitters. Gotta say I’m team Andrew here with his suggestion of basically cloning the source to a /vN folder in the repo.
If I understand right, it looks they want to continue using dep, and dep doesn't yet understand go module import paths. So they either need to use a solution that will add some amount &lt;= 764KB to the git repo size, or break package backwards-compatibility and remove support for go modules, which is what they decided to do so far (although that was only a little bit after they started a conversation with the Go core team, so they might change their mind).
We often only return either 500 or 400 (bad request) - don’t want to give attackers ANY clues as to why calls are failing At first I was skeptical, but try sending spoof calls to an API while getting detailed HTTP status codes and errors - it makes the job a lot easier :) (I work for a top 250 Alexa site)
I have 1,000,000 Zimbabwean Dollars!