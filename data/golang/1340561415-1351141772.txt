Thanks for the explanation. I always feel vaguely affronted by systems which want me to put my stuff in their directories, but it sounds like they have a decent reason for doing things this strange way.
Ah--that makes a lot more sense. Thanks!
The Zeus IDE is now out of beta with the latest officially release: http://www.zeusedit.com/go.html This release adds support for the Go language with features including syntax highlighting, code completion, class browsing, code folding, code templates and debugging. Zeus also supports the Go Build, Format, Run and Document commands. Jussi Jumppanen Author: Zeus Editor 
The early versions of Microsoft SQL Server, up to 7 I believe, shared most of the same source code. Not sure how much in common they have now.
http://tour.golang.org/#1
Effective Go is very good and covers pretty much all the bases that you need. In my opinion the import mechanisms are completely under-covered though.
For someone versed in programming the tour may be all that's needed to understand what Go is all about. Of course during programming we regularly refer to the docs.
I recently got [Programming in Go: Creating Applications for the 21st Century](http://www.amazon.com/Programming-Go-Creating-Applications-Developers/dp/0321774639). I haven't had time to read it yet, but I've read other books by Mark Summerfield which were quite good. Furthermore, the reviews on Amazon are good too (only 4 and 5 star ratings). The book is up to date with Go 1. This is probably the only comprehensive guide to Go out there (that isn't littered with faulty usage of the English language (like "The Way To Go")).
http://golangtutorials.blogspot.fr/2011/05/table-of-contents.html
It's a good source, but I don't know how helpful it would be for someone new to programming.
Don't forget #go-nuts. There are some very clever people in that channel.
How then do you explain the phenomenal success of C#? Disclaimer: I don't know C# and I don't do Windows. Linux/C++/Python all the way.
Many, many, many millions spent by MS in marketing it and building an "ecosystem" for it, including basically bribing many universities to teach it. That and managers in corporate environments.
Don't be dense. Look at the job market. Everyone and their mother is hiring .NET (READ: C#) developers. 
Didn't read Pike's piece yet, but the Python response you link is awful. Python's iterators and generators are one of the best things about the language, and if you think the "yielding from subgenerators" PEP is unnecessarily complicating the language, you've probably never tried to do what the PEP is enabling. Further, the author dismisses them by saying they're just "simplistic forms of concurrency and communication" (?), then links things like gevent which are solving completely different problems.
yeah, no kidding, this kind of automatic asynchronous decomposition support built into the language is extremely valuable for concurrent programming. 
I'm in the same boat. From native Linux land, the clamour C# generates is deafening. They must be doing something right.
Unless there's a special optimization for size 0 data, I think negligible would be a better descriptor.
Right. The language clearly supports some polymorphism for the built-ins. Somebody's going to template it.
I've mostly flicked through it whilst coding up some Go projects so I've not really noticed the bad grammar. I'm sure I'll pick up on it now ;)
It's funny to contrast the support C# and Go have gotten from Microsoft and Google respectively. Microsoft has done a huge marketing push for C# for decades, but none of their majors apps are written in it. Google has been doing fairly low intensity "we made a blog post!"-type marketing for Go, but the language was written by their engineers to solve internal problems and actually gets used by them.
I think the number of people using Go now and that used C++ before is higher than one might think. Before Ruby was my main language it was C++. Same is true for a friend of mine, although he is now using node, not Go. Not much time has passed since Ruby arrived in the mainstream...
They do unicode strings right. Not that most C# programmers understand that, but they do do them right.
I came here to post pretty much exactly this. The fact that Rob is conflating Java and C++'s approach to types shows that he does not understand C++. If the codebase he was working on used a Java approach, with inheritance, his compile times would not be 45 minutes (unless the code was truly awful). I was quite excited about Go's approach to polymorphism until I realised that it was severely limited, requiring either specialising containers or type erasure everywhere. I was more disappointed when I discovered that there are some polymorphic built-ins but the user of Go was not allowed to play in that domain. For example, let's say you make a Set and you want to iterate over its members, well tough, only the built-in range gets to for i := range foo, user code can't. I also have other gripes, but I think this is the biggest.
They are not drunks. They implemented tons of features and done them right. However, according to Rob (and more, and me), tons of features *is* the problem.
&gt; The user is effectively told to man up and use interface{} I've been writing Go almost exclusively for more than an year, last 6 months or so for my actual job, and I never ever written code that returns interface{} in any way. You are right that returning interface{} and forcing the user to make type assertions is probably a bad sign (though it has its uses), but guess what, if you have a little imagination and think outside the container philosophy you don't have to do it! 
&gt; We humans are excellent at communicating in extremely complex languages **with humans**
Not really, MS-world is all UTF-16, which is the worst of all worlds.
&gt; I was more disappointed when I discovered that there are some polymorphic built-ins but the user of Go was not allowed to play in that domain. Were you also disappointed that you could not create your own flow control structures? Seriously, as Rob said, I'm baffled by how much people care about something that comes up so rarely and which is relatively easily solved in the rare cases when you need it. Not to mention you can use a map as a Set even more easily. &gt; For example, let's say you make a Set and you want to iterate over its members, well tough, only the built-in range gets to for i := range foo, user code can't. Actually you can by providing a channel, and then you can range over the channel (this is not too different from say iterators in Python).
Even then, history is littered with the consequences of miscommunication among humans. Humans are excellent at *thinking* they are good at communicating with other humans, but when having to communicate complex things, there are tons of ambiguities and misunderstandings.
The internal representation of string objects doesn't leak out in C#. You have opaque string objects and you have arrays of bytes. To move between them you need an encoding, this is how it should work.
&gt; Were you also disappointed that you could not create your own flow control structures? It would be nice, but would be very rarely useful. &gt; Seriously, as Rob said, I'm baffled by how much people care about something that comes up so rarely and which is relatively easily solved in the rare cases when you need it. I don't know about you, but I use containers all the time. Sometimes exotic containers like stacks and queues! I would rather not have to implement a type specific lock free ring buffer every time, I'd rather do it once and get it right once. &gt; Not to mention you can use a map as a Set even more easily. I can also bang nails in with a wrench. &gt; Actually you can by providing a channel, and then you can range over the channel (this is not too different from say iterators in Python). It is nothing like iterators in Python, now I have to write a function to: create a channel, spawn a process writing into that channel and return the channel, also it's not polymorphic. It's messier and there's no support in the language or idiom in the standard library to do it because the standard library has custom support from the language. To explain further, with an array/slice I do "for i := range foo" for my container I do "for i := range foo.getIteratorChannel()". Now my code just looks messy.
No, but that will require me to Google what happened to COBOL :D
&gt; I don't know about you, but I use containers all the time. Me too, and I'm sure Rob too, that is why Go has maps and slices, and when one rarely needs something more "exotic" usually rolling out your own containers is the least of your problems, and is not particularly hard. By the way you can for example use a (buffered) channel as a queue. You want to add a huge complexity to the language for something that provides much less value than most people seem to think. C has done fine without "generics" for close to 40 years, and Go is in much better shape already having interfaces, maps and slices. Note how in the Go stdlib, which is hundreds of thousands of lines of code, covering all kinds of tasks, from XML parsing to image manipulation, there is not a single use of container/*, idiomatic use of what Go provides is more than enough 99% of the time.
If you look at the history of linguistics, or linguistic use among levels of education in society, I seriously doubt you will come to the same conclusion. Complex languages help develop early learning and a more complicated (detailed/precise) view of the world, but formal programming languages benefit from expressing complex systems in simpler and easier to manage terms. The simpler the expression of a complex system, the more complex of a system the language can express given a particular intelligence. The existence of languages highly specialized to particular problem sets is living proof of this truth.
&gt;&gt;Not to mention you can use a map as a Set even more easily. &gt;I can also bang nails in with a wrench. The best general purpose sets are implemented using hash maps. If your problem is so special that it can't be implemented with generic sets, you are going to implement specialized algorithms instead of using a container anyway. 
No, he didn't. &gt; Programmers who come to Go from C++ and Java miss the idea of programming with types, particularly inheritance and subclassing and all that.
&gt; Generics are not a huge complexity, I'm not asking for partial specialisation. [You're vastly simplifying what is actually a rather difficult decision about trade offs.](http://research.swtch.com/generic) &gt; Perhaps the Go stdlib would be much shorter with generics. Obviously code with generics is shorter. Nobody is debating that. The question is whether living without generics inhibits productivity enough to warrant the cost associated with having them. (See aforementioned link.) So far, from the people actually using Go on the daily basis, the answer seems *generally* to be "no." The Go standard lib is a particularly large data point in support of that conclusion.
You don't *need* generics to do all of those things. You can achieve a good deal of polymorphism in Go with its interfaces.
C#, having the CLR as a requirement, makes it a poor choice for consumer level apps. It does fine on the server and in corporate environments, however. Go will also fare poorly on the "desktop" (whatever that terms means nowadays) but those are all irrelevant battles to fight. C# is fine, don't worry about it. Excellent eco-system, tools, community. Nobody had to bribe me to choose it for my projects, it's pretty much the only sane choice compared to the rubbish that is PHP, Java, or C++ (shudder). Solid language, excellent libraries. Nuff said. I would weep with joy if Go were to achieve 30% of the success of .NET and I could get approval to use it in production. Let's focus on improving Go, not trash-talking everything that comes from Redmond. We can all learn from each other. 
Yes, and the disadvantages of doing so have already been described earlier in this very thread.
Can you be more specific about what practical situation you felt the lack of generics was a big problem? And was pre or post append()?
I know of no way to get a UTF-16 byte array in C# unless you ask for it. Now the fact that MS protocols tend to spit it out is annoying, mainly because most languages tend to assume they know best when it comes to encoding.
&gt; You're vastly simplifying what is actually a rather difficult decision about trade offs. Data is already boxed in go by the interface mechanism, so that article does not appear applicable. i.e. Go should be able to use the Java mechanism. Also, Go already has polymorphic types. &gt; So far, from the people actually using Go on the daily basis, the answer seems generally to be "no." The Go standard lib is a particularly large data point in support of that conclusion. Well yes, the people who use it are going to be those that like it.
Complex computer languages such as C++ add functionality by adding keywords and specializations. Complex human languages add meanings and associations to already existing terms. That's why natural language processing is so difficult. Even with human languages there are multiple opinions of how one should express oneself: http://en.wikipedia.org/wiki/The_Elements_of_Style. In the end, I think neither approach is good for programming languages. One has to maximize expressiveness associated with each language construct, minimize entropy among different constructs aimed at similar tasks. Programming languages are quite specialized compared to human languages. There are many approaches even among different programming languages intended for similar tasks. Letting complexity entrench itself into a system without any kind of suspicion sounds to me like a total lack of direction. 
Natural languages have a very complex set of rules governing those meanings and associations. One of the things Pike complains about here is rvalue references, is that really more complex than subject-verb agreement?
There are two comparisons between programming languages and natural languages worth exploring, as long as we really want to compare a good programming language with natural languages. One is how different meanings are associated with existing terms and expressions. It is good to associate meaning, as much as possible, in a flexible and consistent way, to terms so that you can use them in different situations and figure them out easily. But, unlike natural languages, it is good not to introduce specializations, as the constructs become more difficult to think about. A complex set of rules can generally be considered a bad thing. Another aspect is that natural languages can grow organically quite easily, they can have limitations (such as 2 or 3 levels of nesting beyond which it becomes extremely difficult to avoid ambiguity) as they're not intended to be well defined at all times. Programming languages don't evolve that easily. They have to be thought out very carefully to allow them to expand gracefully in the future without major modification. 
True.
If that were true, we wouldn't need formalism in math, software engineering, etc.
The formalism in maths is way more complex, and more fluid, than we use to program computers.
This reads to me like "Go won't let me write overly complicated software!" There's a reason for that. :-)
Did you even read the article? Your comment does not address the author's need at all. At least propose a solution how the author could have solved the "Uniform Access Principle," "Lack of Struct Immutability," and "Lack of Optional/Default/Named Function Arguments." The author gave actual use cases. Please give some actual solutions in Go instead of the blank statement you were making.
http://godashboard.appspot.com/project Search for yourself.
Those who knows nothing can only point to others since they have no answer by themselves. That link you pointed to is a list of *all* Go projects sanctioned by the go-team. You might as well have pointed at the ground and say, "that's where Hoffa is buried."
You really should first understand the context of the conversation before you add your two cents. You're misinterpreting the conversation.
UAP is a theory. The creators of Go disagree with that theory. If you really want uniformity of access of Go, you can always create your own getter and setter methods for fields and then hide the field values by making them lowercase. It's a bit of a pain compared to Ruby, but not crazy: Java users have apparently survived having to do this. Immutability can be done the same way. Make your field members private, provide getter functions, don't provide setter functions. There are a couple of ways to do functions with defaults. A fun way is using structs. I made a `Range` struct that looks like this: type Range struct { Start, Stop, Step int } You then use it like `my_chan := Range { Stop: 10 }.Channel()` (`Step` is changed to `1` if it's left as zero). You can do other things too, like just using a `map`, as the author mentions. Coming from Ruby, it's a weird complaint because to my knowledge (correct me if I'm wrong) for a long time Ruby's keyword arguments was a thinly papered over version of a hash map.
+1 on actual intelligent discussion. This is what zippoxer should have done instead of just spewing out blanketed statements.
&gt;The Uniform Access Principle (UAP) was articulated by Bertrand Meyer in defining the Eiffel programming language. This, from the Wikipedia Article pretty much sums it up: “All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.” I just threw up. I absolutely *hate* that about ruby; that when you access something, you don't know whether it's doing a function call in ruby or accessing some storage. I am happy Go doesn't follow that miserable, miserable design choice. &gt;Languages like Eiffel, Ruby, Common Lisp all satisfy the UAP, as does Python in it’s own way. Python absolutely does not follow that principle, unless you override `__getattr__` and deliberately call nonexistant fields to invoke some method that is discovered through a `__getattr__` hack, which is *extremely* unpythonic. *edit: as was pointed out, I'm just wrong here, due to the availability of `@property`, which I had forgotten about. &gt;By “immutability” I mean that there’s no way for a framework to prevent changes to structures that are supposed to be managed by the framework. what? That's not immutability, that's data hiding. This is fully supported if you use non-exported fields. If you want some manager struct that handles all of this, create a struct with a non-exported slice and put the hidden data in that field, exposing them in a controlled manner through exported methods. &gt;There is no way to store Go routine specific data that’s accessible to any function executing in the go routine. that only sounds useful until you remember that goroutines are not hierarchical. There's an implied assumption in this that they *are* hierarchical, and what you would want is a local namespace specific to the goroutine and each of its ancestors, but that concept is absent in go. Taken that there's no hierarchy, if you had goroutine locals, then the execution context that a particular function is running in would be completely altered if one were to simply stick "go" in front of it. It sounds like a convenience, but with enough scrutiny it breaks down rather quickly. With that said, it wouldn't be crazy for each goroutines to have a unique identifier, but it wouldn't be very useful. If you had equality defined for these identifiers, then one could make a map[goroutineid]whatever. That is *similar* in the type of utility that would be provided by goroutine locals, but without a lot of the ambiguity and complexity. You could then `var stuff map[GoroutineID]whatever` and `w, ok := stuff[runtime.GoroutineID()]` or something similar. But then you have to remember that maps aren't threadsafe and you're just going to wind up corrupting your map if you try to access it concurrently, so you create *another* goroutine to manage it, and now you're still interacting with channels or using a mutex somewhere, so you haven't really saved yourself much effort. Most of the convenient things that you could do with goroutine locals or goroutine IDs would become very unsafe very quickly. The whole section of limits to polymorphism is, again, better in Go because it prevents you from doing things that you just shouldn't do. Basically the complaint is "you can't override a parent method because it's not inheritance" and that's exactly the point, because a struct embedding another struct doesn't inherit it, and the system in Go prevents errors that would occur when doing something via multiple inheritance. Anyone who's used multiple inheritance in Python and created a nest of inheritance relationships that cause an unresolvable MRO will understand why Go's model is, simply put, more maintainable.
What if your range isn't type int. You ready to copy and paste that code for every type you want to iterate over? Edit: So you'll need: type RangeInt struct { Start, Stop, Step int } And then... type RangeInt64 struct { Start, Stop, Step int64 } And you can't reuse your `Channel` function, unless it returns type `chan interface{}`, and then you have to be casting it everywhere. So every `RangeT` will have its own `Channel` function, the list goes on. Note that I'm not saying this is a bad thing, but it's goddamn annoying. In Python for example, iterators, type methods, and dynamic types would let you write this once, and it would work for any iterable or integer type. Furthermore, a channel wouldn't be required (and to be fair its' a hack to use this in Go, albeit a nice one), Python has generators which fit the problem better. Also Python has named and default arguments... so the parent complaint is moot there too.
If your range isn't an int then you're always going to have to write code to handle that case so your copy-paste question doesn't seem to apply here.
Yes, GAE imposes some restrictions on how your application works, that is the price you pay for transparent automatic scalability and so on. Note that all the issues you mention affect (even more severely) Python and Java on GAE. All that aside, I have found developing for GAE really fun, it keeps me from having to do sysadmin work, which is a pain in the ass, but I agree that with Go the advantages are not as great, because Go itself already provides such a great environment and scales quite well out of the box (specially compared to python and java). Still, I think some of the issues seem to me to be based on misunderstandings and lack of familiarity with GAE, for example: &gt; Since GAE operates through a database for everything it does, there is no global state Use memcache.
Dunno, never tried. But I suspect that since Java/Python don't do a lot of the stuff that Go does as easily or tidily, you'd get more out of GAE than Go does, and thus enjoy the experience more. But Go without goroutines, channels, or embedding feels like writing C.
Judging by your recent comments, you are sick. You had no intention in letting anyone prove you that that complexity is wrong or is fine but Go has other solutions for these problems. You came here to fight. * [Stage one of your disease](http://www.reddit.com/r/golang/comments/vqpk8/a_rubyist_has_some_difficulties_with_go_so/c56ul9j) - fight Go. * [Stage two of your disease](http://www.reddit.com/r/golang/comments/vqpk8/a_rubyist_has_some_difficulties_with_go_so/c56w5p2) - give up fighting Go, fight zippoxer. Now stage three won't be give up fighting zippoxer, I guess. And how did you know that I *spewed* those statements? You also stalked me out of reddit?!
Bro, why are you mad? No one is trying to persecute you (or Go). I was merely commenting how bland and useless your response is to the author's points in the article. So far, you have yet to discuss how Go solves those problem except saying something to the equivalent of "Go is better," "answer is out there"---useless statements that show only you are nothing more than a fanboy. As for your other statements, dude, don't you know you can click on your username and see your recent comments? You don't have to go out of reddit to see how other garbage you've been putting out.
Nope. I'm saying that this guy's list of must-have language features would just lead to unnecessarily complicated programs that are hard to maintain. That's precisely the reason that Go doesn't provide those features.
The proposed solution was for int ranges. Copy pasting it for something else doesn't make any sense.
There's encapsulation, then once we have that we can consider the UAP (i.e. UAP assumes encapsulation). For an object to be encapsulated, very crudely, means that only the object gets to see or manipulate its members directly; everyone else has to go through an API. APIs are functions and procedures (and in Eiffel these are distinct). It is fairly common in the OO world to not provide getters and setters on all members, in fact some practitioners believe this to be in principle a Very Bad Thing. The UAP takes this a step further, and says that if you are going to provide getter/setter like functions in the API then the syntax should be uniform. In the case of Eiffel, this means that they look like T.a and T.a = 1 respectively. Now, which part has you throwing up?
I didn't mean 'data hiding' when I said 'immutable'. Consider a package in Go that has a private (lower case) var that happens to be a map. Now if there's a public function that returns that map then what can we do with it? Well we can look up the value associated with a key certainly. We can also change the value, and we can add new key/value pairs. That is not immutable, but it is data hiding. If you look at a language like Clojure that has not just immutable but persistent data structures, you simply cannot make those changes. There are functions that will create a *new* map with the changes requested, and in the case of Clojure, the new map will share much of the structure of the first map and so is less expensive than you might think.
You've said some interesting things about how hard it is to implement something like goroutine locals in Go. I'd gone through a similar exercise, and decided to ask. That's all anything in that post did... ask. The questions are general, not specific. They take the point of view of a Ruby programmer (Ruby as a stand-in for OO) and simply *ask* what the equivalent idiomatic way of doing this in Go might be, and if there isn't a way, for an explanation of the reasoning why not. In retrospect, I wish I hadn't decide to respond to individual issues in your comment, Reddit forces a 10 minute interval. Sigh.
'Must-have'... did you read what I wrote in the article? I don't think I was unclear, but maybe I was, though this is the first time anyone's interpreted the article this way. The only 'must-have' there is more along the lines of: I don't have but really think I must have an understanding how to do these kinds of thing in Go. I'll tell you what's hard to maintain... elaborate APIs where the sad user of a library or framework must ritualistically repeat an access pattern that could much more easily have been tucked away in an accessor. After discussion on the golang list it was confirmed that the way to do this is to provide a comprehensive API that includes functions/methods that look like accessors. That yes, while expressions like T.A, and T.A = 1, are idiomatic in Go they are not available to clients of the library/framework in this circumstance. And there appears to be no tricky magic stuff available either. Now there's a little trick with varargs that allows write expressions like T.A() and T.A(1) but, well, it's not as nice. There's also the problem that will come up in frameworks where the packaging system can't protect you because some of the client code runs in the same package as the frameworks. In an OO language, classes are often very similar to module/package boundaries.
I agree for the UAP. Design "principles" depend very much on a programming language's philosophy. And the Uniform Access Principle happens to be contrary to go's philosophy to be very explicit and predictable on everything (so if you're calling a function which could do a lot of things before returning, you'd better know that it's a function) But about functions with defaults, while the one you propose is a nice trick, I still think it's an unsatisfactory workaround. I like default values to be in the function's signature, so * you don't have to dig in the code to know what's optional and what its default value would be if you don't specify one * if you don't give a value to a parameter that has no default value, you get an error at compile time (not run time as with that approach in go) 
Sorry, I'm too busy writing actual Go code.
&gt; Sorry, I'm ~~too busy~~ not capable writing actual Go code. FTFY.
Writing Go code is what I do for living, it's great. Pointless internet drama is irrelevant to me. On the other hand it looks like it's very relevant to you. 
The list of Go projects in that link is not sanctioned by the Go team or anyone else, it's automatically generated by go get data. 
Poor disguise for your incompetence.
ah! OK, I see what you're saying. I misundertood what you were getting at in the post. You can accomplish a similar behavior by writing a function that returns copy(somethingPrivate). `copy` is built into the language for this reason.
http://gocos2d.org is the link btw
Seems like I can't open it. Down?
I should probably change it to gocos2d-lib for people who fork the project. Let me do that real quick. 
For clarification: It is thread safe without locks. No mutex in sight.
This post still has no links to the site or the repo, and the link you posted in another comment is still broken.
I'm really sorry, but if you write code like: if d.sceneStack = make([]Scene, 5); d.sceneStack == nil { and if &amp;d.sceneStack == nil { You do ***not*** know what you are doing. Also, things like var directorInitialized = false and deffining your own rgb type as an array of ints show you are not very familiar with the stdlib and things like sync.Once and image.color. Edit: Ok, I looked again, and I can imagine how perhaps the code that compares len with cap might make some sense, sorry about that. But I'm not sure why you would want to do things that way.
It looks ok, but: The links at the top don't work. And please, for heaven's sake, don't use jquery and ajax for a site that is just three static pages! 
Overengineering.
I dont remember why I used the &amp;scenestack. I had a good reason though at the time. Im sure it works right now without it. But it was for a future reason that I implemented it that way. Im too sleepy to remember atm. Im not a noob programmer by any means bro. Im fairly new to Go, but im getting comfortable with it. 
Thank you very much sir!!!
Yeah, but gopher has a bit more character.
&gt; I don't know any other developer that worked on both projects Russ did! Edit: Also, Ken.
Agreed, that's why I was surprised to see such a nice logo with such a consistent style between Plan 9 and Go, because that implied one of the developers on both projects did the design of both logos. Hadn't thought of the possibility of Rob asking the same illustrator.
I think this is really fantastic. Next time I need a thread safe hash map, I'm going to use your code. :-)
when is the next one getting uploaded?
Tomorrow I guess. There is an RSS feed, heh: http://arethegovideosupyet.com/atom.xml
Rob's wife drew them. 
In my opinion, the Go Phrasebook is a better introduction to Go than either Programming in Go or The Way to Go.
"Some people think they can outsmart me. Maybe. I've yet to meet one that can outsmart goroutine." -Gopher
Evan and Patrick's talks were good from "Go in Production". And "Meet the Go Team" in its entirety.
Well, "meet" a small part of the Go team, the thousands of gophers collectively known as Russ Cox were not there. (And quite a few others, like Ian Taylor also couldn't attend.)
 one := big.NewInt(1) for n := big.NewInt(1); ; n.Add(n, one) { fmt.Printf("rsc %v, ", n) }
Who are you?
http://3.bp.blogspot.com/-_n5yt22aCQU/TshBVTXnUGI/AAAAAAAAFZY/q2PPhDr35EE/s1600/Spidey-Bats.jpg
Bonk!
Local.
adg@golang.org
Not sure if Russ Cox fan or testing terminal line buffer capacity.
It is not a matter of whether a particular terminal has enough buffer capacity, but whether Russ Cox allows it to have enough capacity.
&gt; For example, the lack of generics means one is often casting things when you pull them out of containers or writing a "less than" function for sorting. That's busy work. How often do you use container/\*? I have yet to run into any situation where i needed it, and checking the whole stdlib, which is hundreds of thousands of lines of Go, I think there is a single reference to anything inside container/*. &gt; A good exception mechanism allows one to handle a number of similar errors in one place (i.e., in outer scopes or further up the call chain). I have very, very rarely see this work out in practice in languages with exceptions, usually the errors are not similar, and you are never really sure where or if they are handled, specially because when you call a function you are never sure which exceptions it might throw, and even worse, which exceptions any function that function calls might throw, and so on, "checked" exceptions try to remedy this, but even Java people hate them.
I like algorithm competitions. And for that I always have to use several data structures that c++ already handle offering them as containers. The lack of generic capabilities get in the way in this scenario =(. I really like Go but empty {} is awful... And for mathematic libraries the lack of Operator Overloading is equal to the nine level of hell... But for mathematics the programmer is usually concerned with performance and ends up using C, or fortran, or a python wrapper on those... For concurrent and network tasks, that are not heavily math, Go shines with it's simplicity and straightforwardness! 
I will admit that purely mathematical code maybe is not Go's strong point, although I can see how in the long term, once the compilers do better optimization it could be competitive with C given that C also lacks operator overloading and people seem to cope with it fine. And I understand the point about C++ templates, but still, algorithm competitions seems like a rather esoteric field, not to mention you would think in such situations you might be expected to write your own algorithms, not reuse somebody else's ;) Which in more practical situations is also one of the reasons why generics are overvalued, if you need some really fancy algorithm for performance reasons or whatever, you are probably better off rolling your own tailor made code than 'reusing' something generic which might not really be ideal for your problem.
It was a pretty good article---I actually really enjoy your writing style. Really engaging. I've bookmarked your blog for future reading :-) Personally, the computer science blogosphere would be a better place if there were more snarky bloggers with English degrees :P Off-topic: The font on your web site is really weird (not necessarily bad). Some letters, like the "w" in "were" aren't vertically aligned with other letters in the word. What's up with that? (Disclaimer: I know zero about typography.)
Also the right menu obscures the text wen viewed on an iPhone. 
@property is pretty standard and pretty effin' nice to have.
Go compiles to Android already. But its useful for only console-based programs (no GUI apps).
It's probably font-specific. I have the same problem on any website that uses Helvetica.
The article on the other hand was great :)
You might want to fill [an issue in the Android issue tracker](http://code.google.com/p/android/issues/list) just as there used to be one requesting Go in the App Engine tracker.
Aw, thanks. :)
It very well may be. It looks fine on my Mac in several browsers. :-/
My site looks pretty awful on pretty much every machine. A redesign has been on the to-do list for a while. It wasn't that big a deal when nobody was reading what I wrote, though. :P
I don't understand: "Honestly, I love that Go discourages or disallows my (destructively) lazy behaviour." The minimum possible effort with code that throws an exception is a crashed program. The minimum possible effort with code that has an error return is a program that keeps running. How do error returns discourage laziness? This isn't intended to be a pro-exception, anti- error return comment. The statement just seemed faulty on its face.
No, because I don't care for cellphones. I'm sure it'd be good for the language though, except that every Go related community would be flooded with Android specific stuff.
It seems like it *could* look good as it is with just a few fixes. Is there a site or browser plugin that lets you patch CSS and share a link to such?
Not that I know of, but the entire site is open source: https://github.com/paddyforan/paddyforan.github.com (branch master)
&gt;that any statement along the lines of "yes but I wouldn't do that" tends to be unrealistically optimistic. Careful, you've got rose-colored glasses on with Go. Don't forget all the satanic dark arts you've got perform chucking interface{} around. Further, that's true of *ANY* programming language. Every language has a bad style.
I think that the OP is referring to the notion that it's easy to skip or forget about exception handling---or worse, save it to be handled in one giant blob in `main`. Comparatively, this isn't as easy in Go. Thus, Go encourages one *not* to be lazy about errors.
i only learned java to develop for android, and i love coding in go, so i'd love to see this happen. i'm not holding my breath given android's huge investment in java but we can dream right? the xamarin people ported (transpiled?) the android java codebase to c# (http://blog.xamarin.com/2012/05/01/android-in-c-sharp/), maybe something similar could be done with go... besides a newer (hipper? sexier!) language, what would the switch bring to the platform? faster execution? lower memory footprint? for me the two big wins would be go's answer to inheritance to tame the view hierarchy (MapActivity vs FragmentActivity for example) and go's great concurrency features to help keep the UI buttery. 
...but the only thing you can do with `interface{}` is pass it to something else that accepts `interface{}`. Anything else would require a type switch or type assertion.
Thanks for pointing it out, should be fixed now.
I'm not yet convinced that explicit error handling is superior to exceptions. Here's an example where the Go approach went wrong: http://codereview.appspot.com/6327053/ The precedent with Perl is also discouraging: even writing to files, programmers rarely check the result of `print`, resulting in undetected data loss if the file system is full or turned read-only.
&gt; In Go, it's nearly impossible to not know that you're ignoring an error. Browsing the go-nuts list, there is one exception: error-returning functions which are only called for their side effect, such as `Writer.Write()`. Time will tell if this leads to data-loss bugs. `govet` hasn't got access to type information, so we're a bit in the dark about this one.
Thanks!
&gt; I'm not yet convinced that explicit error handling is superior to exceptions. I don't think I (or the OP) said that. I've had a much better time with explicit error handling than I have had with exceptions in the past, though. &gt; Here's an example where the Go approach went wrong: http://codereview.appspot.com/6327053/ Of course there are places where the Go approach can go wrong. That doesn't change the claim that Go's approach encourages one *not* to be lazy about errors. &gt; The precedent with Perl is also discouraging: even writing to files, programmers rarely check the result of print, resulting in undetected data loss if the file system is full or turned read-only. This is a problem with exception handling too... Yes, it's possible to ignore *any* error returned from a Go function, but this is true of exception handling too. The key to explicit error handling in Go is two-fold: that *if* the error is handled, it's handled locally rather than floating up a huge stack, and when using multiple return values, the compiler forces you to be very ugly when ignoring an error: val, _ := someFunc() What it comes down to is an experiential claim. I've found handling errors in Go much more pleasant that exception handling. Exception handling, when done right, can also be pleasant. But it's easy to abuse badly.
Go is very verbose. Clean, but verbose. 
You're correct, although it actually creates 160 hashed values (40 hashes, 4 numbers per hash... it just uses the *same* hash 4 times). This wasn't my idea, it was taken from the [original libketama code](https://github.com/RJ/ketama/blob/master/libketama/ketama.c). See lines 427-450.
Thanks. 
What about [mgo](http://labix.org/mgo)?
Is there something dysfunctional about [mgo](http://labix.org/mgo)?
oracle driver needed here :( 
GET HIM!
I use Java at work and Go for fun
I don't know if they're ready for production but there are a few drivers. Google "golang oracle". And it would probably be easy to code another one if the existing ones weren't good enough. Interesting points about accessing a database from go are : * you only have to change 2 lines in your program if you decide to use another driver (like in many other languages but not all) * a very clear and light syntax Some details [here](http://stackoverflow.com/a/11357116/263525) (the topic was mysql but it's applicable).
Cool diagnosis :D
This just seems way too complicated for what it's doing. Just use channels. That's what they're there for.
Haha, I was getting frustrated in Java and solved it in Go
Channels block until both sides are ready, so push and pull are conceptually the same. If you want to store past results, just add another layer that first listens to channel1, stores the result in a slice, then broadcasts on channel 2.
So basically, each node would have a channel it reads on (datasource) and a channel it writes on (next), and filters would still have a predicate. It's a slightly different implementation, but sometimes it makes sense to use a linked list over a slice.
Thanks for sharing, I was actually considering writing my own functional library too!
I believe more in Gonsalu interpretation. Ken Thompson is a C guru, and I think that for the compiler he prefers to be written in C. It was also said in the session that they see disadvantages in bootstrapping, like finding and fixing compiler bugs.
Slide 9 has "cloudflare" misspelled as "cloudfare"
Interesting, thanks! I'm guessing my next post will involve some benchmarking performance of the two methods.
Please submit it here again, that would be a great read!
maybe thats just the beginning?
Well, the Go team said they themselves aren't interested in writing a Go implementation of the compiler but of coure others can do so if they wish.
several slides also have very poor english. who cares :)
&gt; he said ken preferred the c compiler be in C That is not how I read it. This is what he wrote: &gt; Ken Thompson is a C guru, and I think that for the compiler he prefers to be written in C. I guess it is ambiguous what exactly this means, my interpretation is that it means: "all other things being equal, he would write a compiler in C rather than Go". Which AFAIK is not true. By the way: ken is not only a C guru, he is the co-designer of C and first C programmer. 
I vaguely recall reading an article, which I forgot by now, delineating the difference between concurrency and parallelism. Both requires different techniques as solutions. The actor model (goroutine) is more for concurrency while STM is more for parallelism. Can someone elaborate on this?
Just a correction: Go does not use the "actor model" it uses CSP.
What's the difference? No, really, I want to know without having to read through pages of definition. What's a good 2-sentence description of the difference without too much jargons?
By default they are synchronous, but they can be buffered, but just because buffered channels are async doesn't mean they are equivalent to Actor, for example, you can pass channels around (which makes them similar to capabilities or file descriptors) or even send a channel on a channel. 
Yes, it sure goes against the basic concurrency model of Go, but it is fun to build. And may be useful to someone - different patterns for different problems etc.
If I'm remembering correctly, gccgo supports dynamic linking and gc doesn't.
The difference is that in the actor model you direct messages to a process. That process has an identity and it can only receive messages that are explicitly addressed to it. Processes (goroutines) in Go do not have an identity. A goroutine can listen to messages from as many channels as it wants and the senders of those messages do not need to know anything about the recipient. You can build a similar things with the actor model but they require significantly more machinery.
Good write-up; quick and interesting. 
Very well put. I can only imagine why this subject is confusing to most, but I suspect that it's in part due to the jargon differences between Actor and CSP groups (I think Hewitt did this on purpose for pedagogical purposes) and the fact that CSP can be implemented from Actors and vice versa. Or perhaps not. 
Thanks, glad you liked it.
I've caught a couple bugs in the XML lib, but haven't submitted any fixes. I probably should have... 記事にありがとうございます
Wow, great detective story.
There's a few features that are must-have when using consistent hashing that this doesn't have: * "Remove" is rarely, if ever, used. Most of the time sysops will change a configuration file, and expect things to "Just work". libketama supports this, therefor so does [goketama](https://github.com/rckclmbr/goketama). This also means that creating the continuum (circle) must be as efficient as possible. Reuse a generated hash as much as possible. * Weighting of servers is generally a must. Often, people will use machines with different amounts of RAM in a memcached cluster. Again, goketama supports this. * 20 keys per node isn't enough. [RJ recommends 100-200](http://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients) Those are just a few small changes you could make to the code to make it a lot more ready for a production environment.
Ok, "more efficient in production". :-). They probably don't have the same traffic as say last.fm, facebook, or twitter, and don't have to manage the amount of servers those companies do.
Why not just generate a static site for that?
Sure, you can. This is just easier to setup and maintain.
So how would you set up a static website so that people can go get from it? I'd like to be able to 'go get example.com/some-package' where example.com can host plain HTML, PHP or a couple of others but I don't have SSH access and I can't install mercurial/git on the server. Would you just use redirects to github/bitbucket?
But do the same thing you're doing right now (pages with `meta name="go-import"`) and you're done. Just plain HTML.
This is pointless and creates more work. A better and more simple way is to just use git over plain old HTTP. 
Try doing that on a bitbucket repo. Also, creating a user named git is simpler than setting up git's smart HTTPS over Apache with a valid certificate. Not having to enter credentials for each package imported and not having to store plain-text passwords in ~/.netrc is nice too.
&gt; You've used the pure bliss that is the slices efficiency in a couple of other places and grew to expect the behaviour in new languages. If you've never used Matlab or numpy's indexing, then you've never used blissful slices. Too bad Go's slices don't even come close to the functionality. It's a great concurrent language, but slicing is perhaps the weakest of its features.
Well, in C arrays are just pointers with some fancy syntax.
He was talking about using private git repos over plain HTTP and you certainly need password for that even on Github.
What I meant by redirects was 3xx redirects are not followed. You can certainly use &lt;meta&gt; to redirect. gorepos is no magic. It uses existing discovery support in go get as I've mentioned in README. It is simpler to setup (at least IMO) and wanted to share in case others find it useful.
I created a second video showing how to build and install Go packages using the Zeus workspace feature: [http://youtu.be/eqa4Z0eOQjI](http://youtu.be/eqa4Z0eOQjI) Jussi Jumppanen Author: Zeus Editor 
I guess I didn't get my point across correctly. Under the veil of me saying "Go is boring" I was intending to secretly show that *fuck yeah* Go is worth screaming about with it's excellent simplicity. I'm working on my writing so thanks for the criticism.
The concepts used in Go are not "new" in the sense that "Go didn't invent them". But they're new in the sense that "they existed before .. but mainly in academia .." At least, this is my impression. I'd be interested in learning about what languages had coroutines before Go.
Maybe I'm being a bit naive but I quite like that. I do a lot of CSV processing and usually a line with variable length will represent a logically different line, in my eyes a line with length 5 and length 2 are completely different. If your function accepts an array with length 5 then there's a reason you've done that instead of a slice with variable length. Right? 
Well, to be fair, greenlets in Python (and Stackless Python before them), coroutines in Lua, processes in Erlang - all them are much older than Go. Also, from what I've heard, Go type system can be compared to Haskell/OCaml typeclasses. But that's what I've been told, never used neither Haskell nor OCaml in my life.
With the added benefit that OCaml and Haskell abstractions are more powerfull than what Go offers.
Haskell typeclasses are almost the same as go interfaces, there are a few differences that give them a different feel. You have to declare instances of type-classes - unlike Java interfaces you can do this outside the module that declares the type, so it seems to retain one of the largest single benefits of go interfaces. Also Haskell has proper generics, and a different type system in general, So while the features themselves are fairly similar, they feel rather different in their respective contexts. OCaml doesn't have typeclasses.
I kind of agree. Go doesn't have any singularly useful or innovative feature; it's the confluence of a few key features and the obsessive restraint from adding more bloat that makes Go interesting.
Thanks for clarification. So if I understand correctly, in case with typeclasses you have to declare their implementors? I mean unlike Go, where you have duck typing?
That's the most obvious difference - in Go, an io.Reader for example is anything that has a method called Read with the right parameters and return values. In Haskell, there's a typeclass called Show (which is roughly equivalent to Go's Stringer interface). A type must explicitly implement it, with some code like so: instance Show MyType where show x = (implementation of show goes here) However, you don't have to have the instance in the same module (package) as the original type declaration, so it gets around the problem you run into in java where you want to have some standard library class implement your interface, but you can't really modify the code. There are other differences as well; for example you can't really have a list of Show, whereas you could send Stringers (of different underlying types) down a channel, not caring about their implementation. Of course, you wouldn't really need to do this in Haskell - show is guaranteed to return the same string every time, So if you think you'll need a list of Show, really what you want is a list of strings (the results of applying show to things.) Because of lazy evaluation, this doesn't cause problems with large strings sitting around in memory for a long time waiting to be printed. type-classes are not that different conceptually from go interfaces, but the languages as a whole are drastically different, so you don't end up using them in quite the same way. edit: slight correction to the code; types have to be capitalized in Haskell.
Yes, like I said, I'm totally sold on how Go handles arrays.
I don't understand. Maybe a slightly less trivial example is in order...
Yeah, reading comprehension fail. Sorry.
The latest Zeus IDE beta adds support for *gocode* autocomplete: [http://www.zeusedit.com/z300/zeus-beta.zip](http://www.zeusedit.com/z300/zeus-beta.zip) The video shows how to configure the gocode autocomplete feature. NOTE: Zeus is shareware, runs natively on the Windows and can run on Linux using Wine. Jussi Jumppanen Author: Zeus Editor 
Haha, don't worry about it.
Sorry, but arrays are not pointers in C, you can interchange array and pointer notation between them but they are not the same.
Thanks! :)
Oh you...
Yes but it's unlikely to help you. You still can't call into Go code arbitrarily.
Closures aren't supported? Did I read this correctly from the source?
You mean my switch in evaluating the bytecode? Is a map[bytecode]evalfunc faster than switch? What are the advantages?
I'm working on closures/functions, so closures might not work yet. There's a lot to implement to get a working Python bytecode interpreter in Go, in particular classes, exceptions (they are only in a very early state yet), and several other basic operations/builtins. I've implemented only a subset of operations (like basic math or list operations), basic types (like int, string, list/tuple, functions, ..) and capabilities (functions, modules, while-loop) to prototype an interpreter.
Cool thanks for the hint, I'll compare them.
Lookup for the block of code needed to be executed by bytecode should take less than 0.1ms with either map or switch.
&gt; And almost all of the people who study CS started learning programming before they began their studies. I would have agreed with this years ago. I'm very skeptical of it now.
Well, Erlang is used (and was developed) by Ericsson. One of Lua's most popular uses is as a scripting language in video game development.
it's very cool :)
In Go all IO is blocking IO, as it should be in any sane system.
&gt; One of the most frustrating things when you start with go is that fact that IO is blocking No, this is one of the most frustrating things when *you* start with Go. You probably were used to node.js's bad habit of non-blocking by default system calls. Most system calls we do everyday are blocking, because we don't need them to be non-blocking, so why have the rarer option as the default? Other than that, this post might be helpful for node.js programmers starting with Go.
I'm starting to suspect Node.js and its async insanity has done as much damage to the programming world as Java and inheritance.
Should be fixed now.
I see them now, thanks!
Go doesn't have an exclamation point. There is a "Go!" language, but it's not this one. And it used to be described as a systems language, but it's mostly an everything language these days.
What I mean is, you're already stopping at utf8.RuneCountInString(s), so you shouldn't have to ask the channel if it's okay because you'll never request beyond the end of the string. Unless I'm missing something, which is entirely possible
the go compiler doesn't construct a jump table like mainstream C compilers often do. populating and fetching your byte codes from a map will be O(1), compared to the switch statement of O(n) where n is the number of byte codes. this doesn't mean the map is automatically faster, but it's very likely.
No inheritance is a choice in multiparadigm languages like C++. Actually in the C++/Java world there exist people that strongly advocate not to use class inheritance. (Which is after all exactly the Go way.) But yes, implicit interfaces I haven't seen either. Although after all I don't think they are so awesome. Often I still do the interface inheritance explicitely in Go.
&gt; Yes they are. not according to k&amp;r, c89, c99. what is your source? #include &lt;stdio.h&gt; #define nitems(x) (sizeof(x) / sizeof(*x)) main() { char *x, y[1]; printf("%u %u %u\n", sizeof(char *), nitems(x), nitems(y)); } &gt; Arrays decay to pointers in function arguments. that does not imply that array and pointers are the same
I'll have to look into this again then.
Awesome , going to convert my old project to use it.
It would be great, please let me know if you need any clarifications :).
Thanks, feel free to fill an [issue report](https://github.com/xiam/gosexy/issues) if you find any bug.
IMO one should use an application specific data API layer where all the specific technial details reside (ie, mysql or mongodb specific). So really there is no need to fully abstract away a database as long as you design your code right. Trying to use the least common denominator for *all supported databases* gives you a minimal feature set, overly complex interface, more code with less readibility. Sometimes you just wanna write SQL. Sometimes you just wanna talk BSON and mongo. Why do you need this extra layer? 
In fact one of the goals of this project is to reduce everything to a minimal feature set, this minimal feature set is what we use the most (insert, update, select, delete). Some projects may require fast prototyping and this library could be helpful on those cases. For any specific bottleneck or complex query, the underlying driver could still be used without being wrapped and you can talk BSON or SQL directly to it. And, on readability, that's a difficult, I do not have a technical reason on readability but I personally find it more pleasing to write SQL in the database console or database scripts instead of embedding SQL strings in my Go code, other people may like doing it too but some other may find that odd.
Is there a video available?
&gt; What is the right way to organize at the highest level a Go GUI program Due to the slight paradigm shift in the Go language compared to other languages, no one yet knows this. Try out what you think is best then post your opinions.
Kind of what I was expecting. I all ready feel like the way i outlined is wrong, but i'm not sure about what is right. Any other suggestions?
A great person to talk to about this would be skelterjohn on #go-nuts. He's been working on go.uik.
Thanks.
I was trying to build an application with go-gtk as well. I used Glade (interface design program) to build .builder files, then used GtkBuilder objects to load my builder files. *Technically* I used a bit of string substitution to dynamically modify my builder files as I was doing quite a bit of tweaking and git dealt with my dynamic files better, but it was quite easy dealing with the builders and getting the widgets (check out the repo for this) and I had no complaints with that part. I've got all the code in [this repo](https://github.com/acsellers/draught/tree/master/app); it is worth noting that the app isn't finished, but I've got things like TreeViews, Buttons, events, Initialization, etc. all working. Also worth noting is that I split out my code into a main, gimli (interface), and legolas (app data/connections) sections; the code also needs to be refactored as it was written in a bit more than a weekend. I ran out of time and got frustrated with the messiness, but was not up for a refactor at the time. If you have problems getting it running/question on how/why I did something I'm around on reddit most days.
Yeah...um that isn't exactly what I meant. I'm looking for a more high level view which *isn't* like that. I all ready said I wasn't looking to use the three god classes stitched together approach which is basically what you did as well.
It's kind of refreshing to see things being written with some style, but I still agree.
For all the rage in these comments, the blog has everything to do with timeouts. His solution doesn't have any spaghetti callback nonsense - it just wraps a blocking IO call with a timeout. Jeez
Nifty. I've got access to a Knight's Corner (Xeon Phi), if anyone has some interesting benchmarks for running lots of goroutines I should be able to share some scaling results.
https://www.nearlyfreespeech.net/ Search golang-nuts (I can't because it's blocked from my work place) and there's something from one of the Go authors about it.
It seems that the site http://nf.nfshost.com (the howto) is down.
I'd recommend going the VPS route (It's what I do). It isn't going to be cheap for some definition of cheap, but you can get started with [linode for $20/month](http://www.linode.com/). Then you can install whatever you want. :-)
As some have suggested going the VPS route, you can go check out some cheap VPS providers at http://LowEndBox.com (be careful which one you go with though).
&gt; CGI is not really the best way to use Go for web applications Why not? (just curious)
Are you sure about that? the startup is not measurably slower than a tcp connection.
&gt; I have been working on few web applications in PHP and I'd love to give Go a try 
It's back up now. I had neglected to top up my nfs account. :-)
Blobstore is free up to 5 GB. 
When you get enough traffic for this to matter you'll also probably want to get some pay for hosting with support.
Oh cool...before the price change it was only available with billing enabled apps which incur a minimum charge now but it looks like it works for free apps now. 
Its nice to see that there is support for native vim, but I cant help but feel a bit spoiled by SublimeText2 + GoSublime + vim mode enabled. Its a great combination of features. I would definitely recommend it to anyone that is looking for a nice Go dev setup.
I really like the ideas of Sublime Text, and it's look, but I think it's complex. There is too much noise around the code, too many different colors for highlighting, and the amount of options reminds me of C++0x's amount of features. Since names in Go are mostly short, forcing myself to make use of auto completion will only slow me down. I looked for an editor that is simple, not ugly and still powerful. [Intype](http://inotai.com/intype/) seems like a match. It's an attempt to bring TextMate to Windows, if I'm not wrong. It's simpler than it looks: files in a project are only links to the files that you drag &amp; drop to it. I had to write [grammar for Go](https://groups.google.com/forum/#!topic/intype-public/wxdj-l6TLPY), though. If I had a blog, this post wouldn't be here :P
It surely works.. I tried CGI on NearlyFreeSpeech some months ago after seeing your post on G+ and it worked great and I kept my account (the price is really hard to beat). For what I use it, I really don't see much diference in terms of speed and latency etc... but I would not use it for really high traffic sites (Unfortunately I don't have any of those :)).
What does Sublime do that's better?
Are you sure we are talking about the same text editor? Im not sure Ive experienced too many of your concerns. By default ST2 is literally just a tabbed editor -- no buttons, just text and some menus. For the first week, I didnt run any plugins, and it was literally just a guified, quicker vim for me. Im slowly learning more and more shortcuts (3 months into usage), and its been great. IMHO, the default color scheme isnt too bad, but I also prefer the white (+a couple of other colors) on black. Id be surprised if those couldnt be inverted. If I ever come come across a Windows box, Ill be sure to give Intype a look. I like their minimal approach too!
Hmm. Hard to say if its necessarily better. I love vim and still use it very heavily still, although, Im no power user. I know the commands that work for me, and I do quite well with them. ST2 was mostly just an extension of that for me. I wanted a bit of a gui and the option to get up and running quickly with a couple of helpful plugins. I think its just one of those things you have to give a try -- luckily its free (unless you want to support the dev).
Oh my mistake. https://github.com/DisposaBoy/GoSublime Take a look. Im still learning all of the bells and whistles. Most of what I enjoy about it, you can probably get out of just vim + gocode + margo (both are installed with gosublime), but having ST2 provide a sleek, simple interface makes it a great combination. I really like the live syntax/error checking, gofmt on save, exploring package declarations and a few others.
Looks pretty good. I've got pretty much the same thing set up in Vim. With the syntastic plugin I get syntax / build checking on save. Go's vim utilities provide :Fmt which I've set up to run on save to autoformat code, and there is also gocode support. Of course if you're happy with ST2 that's great too, but since this is a post on Go and Vim just thought I'd point out you can achieve the same thing there :)
Most certainly, and I run a similar setup when Im on the console! I didnt mean go offtopic for so long. Ill see myself out!
Some more tips: * the :Godoc command will give you documentation right in vim * pressing K over a package name will also show its documentation * to automatically gofmt your code when you save, add 'autocmd BufWritePre *.go :silent Fmt' to your vimrc * use [gocode](https://github.com/nsf/gocode) for smart code completion
i'm playing around with it at the moment. I wrote a blog post on my ideas on it: [Structure my Go GUI Code](http://scriptandcompile.wordpress.com/2012/07/25/structure-my-go-gui-code/) It's mostly just me pondering the possibilities and ideas. No decisions made just me thinking 'out loud' mostly. 
This is a great post. The author covers all of the steps from project creation to app deployment with a fair level of detail. Very handy for anyone starting out with Go.
MongoDB has had journalling for some time now (on by default), which means a single server can recover from a crash just like the big boys. For a 1997 guest book, I wouldn't worry. :-)
&gt; it's an attempt to bring TextMate to Windows FWIW Zeus is a Windows only editor and it [supports](http://www.zeusedit.com/go.html) the Go language. 
I know Go and I still enjoyed watching this. That's a good sign.
+1 for gocode. Works nicely together with neocomplcache: Bundle 'nsf/gocode', {'rtp': 'vim'} Bundle 'Shougo/neocomplcache' if !exists('g:neocomplcache_omni_patterns') let g:neocomplcache_omni_patterns = {} endif let g:neocomplcache_omni_patterns.go = '\h\w*' Somehow `set rtp+=$GOROOT/misc/vim` slows down vim startup, that's why I left it out. I haven't gotten around to figuring out why yet. :Fmt, :Drop, :Import, :Godoc etc. work despite not adding it. [The whole .vimrc on pastebin.](http://pastebin.com/2PbdiKaP)
Just curious.. Why was it down for so long?
Why is one of the functions named 'purgue' rather than 'purge'?
I'm using MyMySQL without problems.
Just say no to domainers. Come up with a different name.
gophers.**net** &gt; gophers.**org** since "Gophers **Net**work" &gt; "Gophers **Org**anization" I just hope it isn't 500$ too. gopher.net is available, by the way.
Unless their offer is cheap. You pay 500$ for gophers.org and you motivate who bought it to buy another 100 domains that he has no idea what they mean.
No its not.
Despite the politics of the domain name market where freeloaders get to profit over other people's ideas, there is a reason to commit to this url. A url can either break or make a website. You would be surprised by the loss of traffic a website receives because the website url isnt aesthetically pleasing to people. Therefore if were going to create a community website for golang.org, than gophers.org makes sense and is aesthetically pleasing. golangdevs.org, goprogrammers.com, ect are the alternatives, and in my opinion loses the overall go style "theme". As stupid as it sounds, unless the go team would be willing to add the feature to the main site then this is the way to go if anybody is willing to commit to it despite the politics. It may seem like a waste of money now, but it wont be later down the road. Id buy it if i wasnt strapped for cash right now, but thats fine because ill commit to building the site as my end of the bargain. 
Almost all of those names reflect the underlying projects while at the same time establishing a brand name built on innovative ideals unique to themselves. Google is based on the word googol which is 1 with a hundred zeros after it. Which to larry page and sergey brin was a joke representing the massive amount of information they wanted to organize. Twitter was named because "a little birdy told me..." was the theme and at the same time it means a short burst of inconsequential information. hy did you choose the name "Y Combinator?" The Y combinator is one of the coolest ideas in computer science. It's also a metaphor for what we do. It's a program that runs programs; we're a company that helps start companies. stackoverflow is a website about computer bugs. Come on now. gophers.org is aesthetically pleasing from the perspective that it's easy to remember, easy too type in, you relate gophers to go instally because golang programmers are called gophers, and its a site for gophers. As you can see if any of these sites didnt choose an iconic brand, they may not be as successful. Its not like they were the only sites to do the things they aspired to do. (though they did it the best). 
Just note that im not saying to buy me a url by the way as people in irc are criticizing me for. Im encouraging somebody who has the extra money, but perhaps no time to work on it to contribute via buying the domain name that they will still own. Perhaps it could profit you if google wants to buy the url off your hands to make it officially part of there portfolio of projects. Its not a bad investment and could potentially help the language grow in popularity. The idea is to attract people who dont use go to start doing so, that way they can work on projects that we dont have to build ourselves. There is a "cool" factor that goes into it. This is the last argument im going to make about it. If somebody picks it up, let me know and ill start working on it. If not, then oh well, i rest my case. 
Its my opinion that superseach.com wouldnt have been as successful as google even if they were the best, because their competitors had alot more money than google did and many good websites crashed and burned in the late 90s because of the vast influx of consumer confusion based on crappy brands and even crappier technology backing those brands up, where their generic names were caught up in the flood. Thats why I make the argument that gophers.org, is essential to the project. Otherwise its literally not worth the time investment to work on. Life is about time expense vs reward return. While i dont aim to profit from working on it. i do consciously choose to work on projects with the intent of getting every person possible to use it. Its in my opinion that there wouldnt be a more successful project for a gopher community than one with a domain of gophers.org. It just makes sense to me. If people disagree and dont want this. Then fine, it was just an idea, and i stated my case.
The links between packages are broken. For example if you go to http://gorilla-web.appspot.com/pkg/rpc/json the link to the rpc package documentation is http://gorilla-web.appspot.com/pkg/gorilla/rpc whereas the documentation is actually at http://gorilla-web.appspot.com/pkg/rpc
I use MyMySQL, no problems.
Here is the reason why I like Sublime Text 2 + Go Sublime. You have all the advantages of Vim with Vintage with none of the disadvantages. If you even want to get hardcore there are projects like vintage ex mode that you can use to extend to a more natural vim environment. Some examples of disadvantages of vim are things like the copy and paste bug. I have experienced this on like 5 different versions of vim on 5 different distros of Linux. Including Arch Linux with the latest rolling release. If you ever tried to copy a large piece of go code into vim for whatever reason you could end up losing X amount of bytes from the beginning of whatever you paste which screws up the formatting. With go's fmt thats fine, but not all languages have an awesome feature like that. Perhaps there is a fix for this, but regardless my philosophy is that if it doesnt work out of the box the software is ultimately flawed in that respect. Omni Complete in vim is horrible and requires hacking fixes that are in their own way horrible. For instance the super tab hack for auto completion is horrible. And then you have the gocode extra window that pops up that you have to hack out. Again hacks like these to me that dont just work right out of the box means the software is ultimately flawed, as the design should be intuitive from the start. Dont get me wrong, I love vim. I use it for all my tty based text editing. But only because the navigation is so damn useful, along with visual mode and the Ex commands. Sublime provides that plus none of the caveats. Also with gosublime, you have a very powerful Ctrl+".""." interface that is right there in front of you. The interface of sublime is SEXY if you install themes like Dark Soda. You are able to configure it as much as you want, and in my opinion it has the best plugins out there. Its probably the most important programming tool that has come out in the last decade. Its powerful and it only has room to grow and become better. You cant complain about bloat of features because you can turn them off. Including gosublimes auto completion. However why anybody doesnt want to use autocompletion is beyond me. 
Interesting stuff, I have been doing some websocket stuff with Go as well, but there is still 1 issue I am having trouble with. How do you detect clients disconnecting ungracefully (losing internet connection, closing laptop lid, timing out)? In my app, I prevent time outs by setting a interval in javascript, but I cannot seem to detect an ungracefull closing of a websocket.
Because I postponed fixing it forever. And because go.pkgdoc.org exists to fill the void.
Thanks, I just started working on a project using Gorilla Web for JSON-RPC so I'm glad the documentation site is all fixed now :)
It was using a custom version of old godoc with an old incarnation of text/template, all from r60. I was lazy to make it look like before. But hey, it was rather simple in the end.
Could you elaborate some more? In my experience even the "closed" websockets still don't generate an error when writing to them.
I'm a casual observer and very interested in go. I tried web.go and loved how simple it is. Since I'm not familiar with Go ecosystem, any testimonial about Gorilla? Anyone used it for production web development?
http://go.pkgdoc.org/desired/gogettable/package/here
Agreed. I am actually hoping to share several details of my latest foray with Go---I just need to find the time to write it up. For a quick tidbit, one thing I've found about Go is how easy parallelism can benefit a concurrent design. And I don't just mean the usual hoopla about goroutines and channels, either. A week or so ago, I was struggling with a rather resource hungry process (compressing all known protein sequences). It was pretty slow, and I wasn't sure how much performance I was losing by using Go instead of C. The whole program was about 3,000 lines, so instead of wondering, I decided to take a weekend and re-implement the entire thing in C (after writing [an option parser inspired by package 'flag'](https://github.com/BurntSushi/clibs/tree/master/libopt) and a [thread-safe concurrent queue](https://github.com/BurntSushi/clibs/blob/master/libds/queue.c) to act *like* a channel). The end result was quite shocking. Go, on average, tended to be faster. My current *hypothesis* is the amount of memory allocation happening in each thread---which is a lot. I was using the standard `malloc` in C, which to my knowledge, isn't that smart in a multi-threaded environment. A proper approach is probably to use something like [tcmalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html) that uses per-thread memory arenas that avoid the locking that happens in a standard `malloc`. My **guess** is that Go does this for you automatically. That's **convenient**. Obviously, I could have pressed on and used per-thread memory arenas and perhaps gone faster than Go with C, but at this point, I was convinced that Go was fast enough. The other cool part was that C memory usage was only a bit smaller than Go memory usage, although I may have missed some opportunities for optimal struct alignment in C. (N.B. I'm leaving out a lot of details. For instance, I did fairly extensive profiling with both versions, and profiling verified that CPU/memory hot spots were the same in each version. In particular, the big hotspot was protein sequence alignment.) The only real down-side with Go is that I have to modify its allocator to allow a heap bigger than 16GB. (I don't know exactly how much I need, but I know it's a lot more than 32GB and possibly more than 64GB.)
It is not "Go Lang." The name of the language is Go. Edit- Capitalization.
I recently had a go at translating Peter Norvig's sudoku solver into go. . It was very interesting to see just how different the outcome was. Still a work in progress, but I'll post it on the board once it's done. The lack of list combinators meant it came out much longer, but in a way much clearer than the original. Still not too sure how I feel about this. Terseness vs explicitness at the cost of verbosity.. 
1. Proper attribution is not given to xkcd. (source of comic: http://xkcd.com/303/) 2. It is not entirely true that Go does not support OOP.
At this point, what Go needs is high level APIs, like .NET or Rails. Integration with major IDEs, with code completion and template projects is also crucial. Educational articles are great but everybody who's anybody already knows about the language and at least some of its benefits. They are making an informed choice not to use Go because it is an infant language with few libraries. For example, I write iPhone apps (among other things). I would love to write iPhone apps in Go. It is technically possible - all I need is a compiled binary that I can codesign and put on my phone or submit to Apple. However, there is no toolchain, and no Cocoa bindings, so I am forced to stick with Obj-C. The situation is the same on desktop OSs, like Windows, Mac OS, GTK, and KDE. I don't know much about web programming but I know large, high level APIs are invaluable there as well. The only environments were Go is competitive are command-line utilities and back-end server software. In these areas its advantages outweigh the inconvenience of using such a young language. And still, to get anything done I have to use incomplete open-source projects to talk to ncurses or OpenGL. I wish I could use Go for everything, but I can't. Fixing that would help more than writing an article.
&gt; by Guest Author more like: copy and pasted from all over the internet by an intern.
Don't wish to sound non-constructive but you could just write your own library. I'm not sure what SNMP is but I'm presuming it's a network protocol, Go has all the network building blocks, you just need to find the time to implement the library that talks SNMP. 
&gt;I recently had a go I see what you did there
How about starting off with a list of libraries that are needed?
Do you have any pointers or examples of writing a compiled (non Objective-C) binary for and iOS device?
I would personally use the following: * a good twitter client * a good facebook client * a good foursquare client * a good instagram client * a good data validation framework * pure go implementation of OSC * full stack web framework * an up-to-date socket.io server implementation * OAuth server implementation * something, ANYTHING that reliably tracked the popularity of different repositories. We don't have anything as good as Python's cheese shop. some of these I have partially done. E.g., I started on a Twitter client but got sidetracked, [released it recently](http://github.com/jordanorelli/twitter) but I think it's kinda awful because I wrote it before my Go chops were any good. as for the framework thing, there's a bunch of libraries out there, notably the gorilla libraries, but there's no full stack framework worth talking about. Falcore was the closest thing that came to it, but the documentation is so sparse nobody knows how to use it, it doesn't seem to be very actively maintained, and I haven't heard anyone mention anything about it on either IRC or the google group. Yeah, the standard library is good enough for writing HTTP servers in the general case, but there's a lot of shit that's just plain missing. Want gzip encoding? Use encoding/gzip, now wrap all your handlers, and blah blah blah; it's a lot of bullshit, uninteresting gruntwork. A full stack framework is not a set of libraries. A full stack framework is not "agnostic" about everything. I'm talking about an opinionated framework. A big, monolithic piece of shit that breaks every "best practice", circle jerking, ivory tower rule and just lets you build awesome shit. Look at the shit that's coming out of the node.js community. For such a shitty language, they're really producing good tools and they're creating a really good ecosystem. Take a look at Node knockout and compare it to our ... wait, we don't have anything similar. The previous generation of web technologies was dominated by Python and Ruby. Node.js is the Rails of the current generation of web technologies. Where's the Django of the current generation of web technologies? It's nowhere. Where will it come from? It will come from us.
I would add a Tk client. Yes, Go's UI will primarily be the web, but having a dead simple native-look GUI library helps when marketing to coworkers. Also, more native database drivers would be appreciated. It probably is not possible, but native drivers for SQL Server would make pitching Go far easier in the average MS-centric IT shops.
Give git another try, this time forget what you know about mercurial because you are used to it and otherwise you'll curse every little difference git has from mercurial even if it's not bad.
My input won't be that constructive, but I really appreciate the fact that you've provided some example usage documentation in the README
This is really good, as an earlier post mentioned it is time we move beyond basic tutorials and into useful best practice regarding how to actually organize a Go application.
Using it a bit and liking it so far. One question/ suggestion though: it'd be nice to get the [LastInsertId()][godoc] back from Append(). [godoc]:http://golang.org/src/pkg/database/sql/sql.go?s=27773:27860#L1049
wow.. another tutorial... Even though its from Dr Dobbs, can we please move on.. We have too many tutorials!!!
In my use case I've found a decent hack around it. Some of my Nagios checks use ssh to do remote logins and run various things. I need to rewrite some of those checks as well and Go has a SSH lib that works okay. The downside of the SSH lib is it seems to only handle password auth at the moment(my prior ssh login scripts used RSA auth). This works for my environment since all the servers have the same root password. So I can do a memory check running a remote free command and parse on that. But, well, obviously having nagios checks with a root password compiled into the code isn't the most ideal way to do things. It works and I could even move the password out into a yaml file or something, but yeah. I really worry about the lack of lib support for Go. I know the lang is young and it's not at all fair to compare it langs that have 10+ years of dev behind them. But if the libraries don't see growth over the next couple years I don't see the language being adopted by a lot of people. Which would be a shame because Go feels like C for the Python/Perl/Ruby/PHP kids.
link?
I use CGI for a medium-traffic site ([cat-v.org](http://cat-v.org)), and never had any performance problems (even getting reddit-ted several times). But what shows the FUD about CGI performance is nonsense is that not only does that site run on CGI, it runs on a CGI that is a [bunch of shell scripts that do hundreds of fork()s per request](http://werc.cat-v.org). Fork is much faster than most people think, specially if you link your programs statically and use a system with a half decent kernel. Oh, and you avoid languages like Perl, Python and Ruby where startup speed is so bad that you could do millions of forks before hello world could print anything in those languages.
FWIW, the URL parsing library used in Google Chrome is named gurl.
Could've wrote a Go binding for gurl, but I don't see how it could serve better than net/url to anything other than Chromium.
Updating Go code for newer version always makes me think "Oh you ran `go fix`?" Great job anyway!
I had meant that the name had already been taken by a similar package, but now that I look I see it's usually called "googleurl", so maybe it's not worth worrying about. (If you search for "gurl url" you'll find e.g. Perl bindings for the other one.)
Thanks for the advice!
When would you ever want an object that can pop but not push? YAGNI.
Thanks for the advice, I'll look into it after work
Ah, well that's truly sad... hopefully they're working on it
Are you converting the code to Go?
Nicely done. I have one minor suggestion. This phrase: &gt;the oldest person that should date you is would be better written as: &gt;the oldest person *who* should date you is I hate to be a grammar na... SIEG HEIL MEIN FUHRER!
Nice idea, I suppose with something like that you're still writing code for each type, but the "stack" fundamentals are actually implemented in the layer below. I might write this up now and see how I get on, thanks for the tip
I cribbed this solution from the ultra-bad Java days when things like List could only store Object. It was a common pattern to see stuff like StringList which composed the generic list but provided identical, strongly typed interface semantics around it. As you pointed out, the nitty-gritty of the implementation stays in a single place. One cool thing about it is that you could (in theory) change the implementation of what you're wrapping - so you could have a slice-based stack, a linked-list type stack implementation, a stack that synchronizes itself over a network or IPC pipe... :) Oh, and if Go should ever grow generics, you can just delete the wrapper layer code.
Thanks so much for telling me about this. I was able to reduce my push function down to one line "s.front = &amp;Element{s.front, x}". It worked fine when I tested it so I think it's good. I love finding ways to reduce lines like this!
Well, I can see the fun of working through a book, but if it's not written for Go, you can't expect it to map one-to-one to idiomatic code. Try taking Go code that uses `go func()` and channels and porting it to Java. It won't be pretty! Different languages have different strengths. I would suggest just using an `interface {}` stack and queue instead of beating yourself writing a bunch of code to try to fake generics. 
Nice idea.
I personally would've preferred the effort be put into http://www.gophertimes.com/ ... but we'll see how this goes. GL
I try to follow as many Go news sources as I can and there just doesn't seem to be that much content out there. Maybe everyone is too busy writing Go programs to blog about them. ;-)
?
The only criticism I'll make is you need to log in to your google account to see the page.
You can view the list archives without logging in here: https://groups.google.com/forum/#!forum/golang-weekly
It took a bit more than running go fix. Still I'm tweaking that code from time to time and it became a nice way to gradually learn new things about the language. For example I just replaced the manual json construction/csv parsing with encodings/json|csv.
Concise names are easier to read and remember, longer more verbose names are often not more informative, they are simply more confusing, because to accurately describe a variable, you basically have to describe how it i being used, which is only properly done by the code itself. In the end, it is a cultural and style issue, you will get used to it.
Typing is not a problem. It's reading that's the problem. Long names distract from the code. It takes more effort to write concise, accurate names than to just say everything a thing does, but the readability benefits are huge. In a recent code review I asked someone to change `crypto.NewCompressingEncryptingWebfilter` to `webfilter.NewEncrypter`, and to just document the fact that it's compressed.
I find that in most cases in Go longer variable names would add no additional information. For example, in a recent bit of code I'm working on: func (n Node) DeleteProperty(p string) error { _, err := n.neo4jRequest("DELETE", n.PropertiesURL+"/"+p, nil) return err } I could have used `node` instead of `n` but then I'd just be repeating the type name that immediately follows it. The function is small enough that having a longer name would add nothing in the code inside either. 
See the [variable names](http://www.lysator.liu.se/c/pikestyle.html) section in Rob Pike's "Notes on Programming in C." (Rob Pike is a co-designer of Go.)
If it implements Django template syntax, why is it called GoTemplate? Also, golang already has an included templating engine.
I think the django template system is too inferior to html/template 
It's good to have alternatives and good for Go to have more libraries. The name is a little generic, though.
Name suggestion: [Reinhardt](http://en.wikipedia.org/wiki/Django_Reinhardt).
I didn't spend a lot time analyzing this, so I may be wrong on several or all points. I'm always glad to be corrected if I made a mistake. Questions that came to my mind while reading it: - Why use *send* to invoke the method? It's slow, very slow. Is it really necessary to compute the method name at runtime? - Why is there a *res* hash all threads are operating on? Why not use the thread_local storage *Thread.current[result] = c* and after the join collect those? *threads.each {|t| res &lt;&lt; t[result]}* - *join* can take a parameter for a time limit in seconds. It's more straightforward than using a timeout. - What's the timeout handler doing anyway? It calls on every thread *join* via the fancy, but very inefficient *to_proc* trick? Why? And if the timeout happens, just *join* gets aborted, not the thread itself, which makes the final *clone* "necessary". Leaving threads running uncontrolled around is bad practice. And a nice one: &gt; Aww, I already can hear all the Rubyists screaming that it has more lines of code and syntax is not as nice as in Ruby :P Actually, the proposed "nice syntax" ruby script looks more like java than like ruby. So, areyoufuckingcoding.me, are you fucking kidding me? Don't talk like that about my beloved ruby.
Yep, once I've found a better name I'll probably rename it (as mentioned above). :)
Also static means something completely different than pure. 
Glad to hear! :)
Once you make something public, you basically commit to support and maintain it as long as possible. This results in ever growing API cruft that makes documentation and maintaining code a pain. (For example, if the interface to that 'pure' function needs to be changed/improved, what you do? you keep two copies of the function?)
In which regards? Maybe we can make it better now.
Also Banjo or Gipsy, both short and memorable names.
For instance, the escaping in go's html templates is smart (context-sensitive), that is, if you're inserting a value inside a script tag, it will be escaped different from if it was being inserted inside a regular html block. You can also call regular go functions inside the curly braces {{ }} You also have named templates, and you can call them as if they were macros {{template "name" pipeline}} The template with the specified name is executed with dot set to the value of the pipeline. Really, just read the docs: http://golang.org/pkg/html/template/ http://golang.org/pkg/text/template/
* in this case it doesn't matter if i use send or #method or even counters hash or smth, the impact to overall benchmarks is very very small. * doesn't have significant impact on the performance as well, i actually bet this one will be slower than sync on results only. btw result should be a hash {network =&gt; count}. * Timeout should surround all operations. I wanted to get *all* possible results in max N seconds, not *each* of them in N. * The threads will finish with HTTP timeout, there will be no running threads left for longer than this timeout. Also there's no clean possibility here to stop threads with HTTP calls being performed within. Again about timeout, i want to limit execution to N seconds, as the goal of the app is to provide fast webservice, by fast i mean one with guaranteed total execution in reasonable time. Oh, btw Ruby is my language of choice and work for 8 years, but sometimes there's too much drama around it... you don't get trolling :P?
GoTemplate supports calling functions (with args) within any situations (in filters and also in tags, or in general every expression) (differs from Django), see for example https://github.com/flosch/GoTemplate/blob/master/src/template_test.go#L138 (you just have to make them available within the template `Context`). GoTemplate also supports template inclusion (include-tag) AND template extension (extends-tag, which the `text/template` package BTW doesn't has built-in and supports only very clumsy as I saw) (both tags are also documented in the tests). GoTemplate is still missing context-sensitive escaping (but still supports (auto- and explicit)escaping though). This is a thing which might be added to GoTemplate over time. I'm aware of that I've to add a documentation (beside to the tests) to show what's possible with GoTemplate and what's not. This is coming! Thanks for your feedback!
What "faults" have you hit?
Done.
The queue and publishing concepts you talk about sound like they match the functionality of other already existing projects. Since I assume that you already know of things like Redis pub/sub and RabbitMQ I was wondering what benefits you see in writing these components yourself?
Was it 32bit or 64bit? Was that with pre-Go 1, Go 1, or tip? There have been many GC improvements along the way.
Thanks for clarification. About the trolling. Let's just say, I don't like it.
at least one reason i see - having those embedded and compiled in right into the app
But the nature of messaging systems seems to benefit from not being inside the app. You usually want a number of networked producers and consumers along with some kind of persistence for unconsumed messages. Both requirements are (at a cursory examination, anyway) more easily satisfied with an external system.
Try 64bit. Also there have been many gc and code generation improvements since Go1, but pretty much everyone using Go in production use 64bit and 32bit is a kind of dead end so it doesn't see that much effort in optimizing it.
Has anyone had any luck with debugging packages written in multiple languages? I was working on debugging a mixed language package at one point, and couldn't figure out how to get it to give me C/C++ debugging information; I could only see symbol information for the Go part of the stack. Anyone dealt much with this situation before?
In addition to other comments I think it would be useful to actually to actually think about performance because it will lead to thinking about simplifying the code and that can only be a good thing will the code will likely need some tweaks as you actually start using it. From experience I find that if the code is simple and largely self-contained early on then it takes little come back and change or add something later. e.g many of those functions panic for for no good reason. In fact, this limits their usefulness considerably because I can't use some of them without checking string isn't empty before passing it to a function and by the time I do that I might as well just write the one or two lines that do what I want. Ranging over a string returns a decoded `rune` and the `byte` index where it starts. With that, many of the functions can be simplified using a loop that does what's required. You probably won't need to check that string is empty at all. Also take a look at the `unicode/utf8` package. I think I should also repeat that it's idiomatic to do what's intended and compare against "" e.g. s == "" or s != "" instead of using a constant, len(s) or wrapper function. Btw, EMPTY_STR should be written as EmptyString. I rewrote a few of the functions for comparison http://play.golang.org/p/gNf_NyCjG9
Personally I don't see performance a priority (for me) but I understand some people do. Is there any reason why a recursive approach (as I've taken with my code) is less performant that explicitly looping over a range of runes?
It wasn't about performance. It was about simplicity. The easiest way to gain performance is usually to simplify things. Using all the recursion hurts both performance and simplicity in this case.
From my perspective recursion is much simpler to reason about but I can see this approach is quite expensive. I've been doing some benchmarks between the two approaches and the non-recursive functions do seem quicker
Agreed! Very clean and informative.
It boils down to: if I execute a few remote operations in parallel and want to merge their results for processing, I'm going to have to write a way to wait for different response times, possibly cancel operations after X time, and handle the results as necessary. Similarly, a simple pattern is executing perhaps a few operations and blocking the next step until you get a response back - in parallel with some other operation. So, the goal is to explore building blocks like this. I suspect we all write the same patterns so I'd like to write them once. Edit: on phone. 
You make great points. What I'm trying to do exactly is encapsulate concurrency issues into a few verified, tested, and known primitives that I can combine arbitrarily into whatever computational pipeline I want. It's half exploration of an existing idea, half utility. I will say I'm not pleased with how "sites" currently work and I'm always open to simplifying what I do have with smarter Go idioms.
Take a deeper look at Erlang. I really do believe that half of what makes Erlang 'good' can be implemented in user-land Go in some form or another. Erlang's 'mailboxes' are essentially channels which are attached to some abstract type, in Erlang's case, this is the type `Process` or `Pid`. Having something similar in Go would mean: type Process struct { Pid // a type so we can have attributes on it, instead of pure int Job // this would be our earlier defined function Mailbox chan mail } Then in our magical Go VM we would have a global map of these Process' which would basically be an abstraction over the channel writes, async obviously. The CPU timeshare would be taken care of by simply executing the `Process.Job()` in a goroutine. I can forsee Go-centric patterns emerging much like what you say through some abstraction layer above the primitives supplied, much like what's done in Erlang. Similarly, process monitors could be implemented in either a `defer/panic` closure or in a 'heartbeat' channel monitor such as: type ProcessMonitor struct { watching *Pid monitor chan heartbeat timer chan time.Time } func (p ProcessMonitor) StartMonitor(interval time.Duration) { p.timer := time.After(interval) for { select { case &lt;- p.timer: // panic(fmt.Sprintf("%s panicked!") handleProcessFailure(p.watching) case &lt;-p.monitor: p.timer = time.After(interval) } } } I realise that this isn't what you're directly talking about, but I think what we *are* both talking about is creating a set of tools *above* the primitives which Go provides. Having some similar construct to a language which seamlessly already provides much of what you talking about, in my eyes, could provide you with the outcome you're after.
It might be based on peak times. Sometimes it's slow for me, other times it's quite snappy.
too late, i am going in
How about Gojango or just Jango? Although it sounds like it's going to be port of Django to Go, rather than a port of Django's template engine to Go.
Yeah, I don't like it either. Too bloated, too much crap to load for a teensy amount of text. Wtf, Google?
Don't get me started on the new interface. Not only is it clunky and sometimes slow, but it makes all my keyboard shortcuts (Vimium) completely useless. The worst part is that they've made switching back to the old interface rather difficult.
Stay on target.
Excellent thanks for a great reply, I'm going to look into your examples and integrate them into my package (with credit to you of course, if that's OK?) Here are some responses to your points &gt;There are quite a few places where you convert a string to []rune where you could just iterate over it with a range - this causes an allocation and a memory copy, and is generally avoided where possible. This is what confuses me about strings in Go, what does the "range" function/operator return exactly when you're iterating over a string? Does it return each rune in the string or does it return each byte (say for example UTF-8 characters may occupy 2+ bytes). &gt;There are a few places where you could easily use strings.Map and save code and time. The one thing I didn't realise about strings.Map was that returning -1 drops the result (which I noticed in your implementation of filter), so thanks for that! &gt; IsEmpty is unnecessary, as is Span (why not just use TakeWhile and/or DropWhile as appropriate?) I was probably just trying to be as faithful as possible to the Haskell Data.List library which provides these functions (although in Haskell code you would probably use pattern matching to detect an empty list) &gt; Distinct has O(n2) behaviour where n is the number of distinct runes. It's not hard to make this near O(n) where n is the length of the string. You should have seen my haskell-like implementation of Distinct ;), the performance was atrocious compared to the solution I have now. Judging by your approach there are further savings to be made! I'm intrigued to know why you've separated the ascii/non-ascii comparisons into separate maps though - efficiency? &gt; I can't see the point of the Init function. Me neither but again, just being faithful to what's available in the Haskell library! &gt; Most functions in the strings package that take functions have the function as their last argument. It's probably worth following that convention. strings.Map doesn't! I think this is a bit of a preference thing really. I only set them out that way because I'm used to writing them like that in Haskell/Clojure e.g. all (\x -&gt; x==1) [1,1,1,1] &gt; You should have tests that check behaviour with non-well-formed utf8 strings. This is definitely on my list &gt; "strings_ext" isn't a great name for the package identifier. Not that I can think of a better one! Yes this is one of the things I will probably be changing Thanks for your input it has been very helpful. 
I suggest "Pongo" for the name. Short, simple and cute: it is the scientific name of Orangutans. Also reminds Django a little, but nor much, so won't cause confusion. I'm suspect because I maintain gorilla, so I like primate names.
It is good to have more options. html/template has nice features but a bad API. There're some weird design decisions there, and it is a little cumbersome to use.
I just knew that this type of short-sighted elitism would show its ugly face somewhere down in the list of comments.
Yeah, it has maybe too much "django" in it.
extra +1 for having "Go" in "Pongo". :) Thanks for the suggestion!
Yeah that was on purpose. ;)
Here we go, I renamed it to pongo (thanks to moraes for the idea!): https://github.com/flosch/pongo
I can also attest to this. I've a Go rewrite of a C program that I've optimized until it's about 10x slower than the original C program. GC is about 60% of the overhead, the other 30% is lack of inlining.
&gt; Excellent thanks for a great reply No problem - just trying to boost the Go ecosystem :-) &gt; I'm going to look into your examples and integrate them into my package (with credit to you of course, if that's OK?) You'd be welcome to do that. &gt; This is what confuses me about strings in Go, what does the "range" function/operator return exactly when you're iterating over a string? Does it return each rune in the string or does it return each byte (say for example UTF-8 characters may occupy 2+ bytes). It gives each rune in the string (this is a significant difference from []byte). See http://golang.org/ref/spec#For_statements ("For a string value, the "range" clause iterates over the Unicode code points in the string starting at byte index 0") &gt; I was probably just trying to be as faithful as possible to the Haskell Data.List library which provides these functions (although in Haskell code you would probably use pattern matching to detect an empty list) While I think it's great to be inspired by the powerful Haskell functions, I'm not sure that it's worth having things in the package which are trivially implemented in Go as is. Most people that look at this package are probably not going to be Haskell afficionados... &gt; I'm intrigued to know why you've separated the ascii/non-ascii comparisons into separate maps though - efficiency? Yeah - I started by using a map always, but this made performance significantly worse, as the constant-factors inherent in creating a map are significant, particularly for short ascii strings. Note that I used [256]byte and type-converted the index to byte before indexing, which eliminates the bounds check (this may or may not make any difference at all here!) &gt; strings.Map doesn't! I think this is a bit of a preference thing really. yeah, strings.Map is the only (annoying) exception. personally I like the function to come last because I think this: strext.TakeWhile(s, func(r rune) bool { if someCondition { return f(r) } return g(r) }) is easier to read than: strext.TakeWhile(func(r rune) bool { if someCondition { return f(r) } return g(r) }, s) because the string argument isn't hidden away after the function definition - you can see first the string, then the function that's operating on it. "strext" would be a better name than "strings_ext" BTW (underscores are not conventional in package names). hstrings might work well too ("haskell-inspired strings package"). 
Done :) https://github.com/flosch/pongo
Just to be clear ... you mean the Google App Engine SDK.
I find it hilarious (in a good way) that I have never needed to debug Go programs during the last two years I have used it. Great news nonetheless!
The article suggests reading Applied Cryptography. That's a good suggestion, but keep in mind that this is a kind of encyclopedia of broken and not-so-broken cryptographic algorithms--it's extremely technical/math-heavy. *Cryptography Engineering* is much more hands-on with "practical" knowledge (it doesn't discuss the algorithms in-depth, but lays out the standard ones, and discusses how to use them correctly.)
The more correct your guess is, the longer it takes BrokenCompare to return. That's a very exploitable property. subtle.ConstantTimeCompare always takes the same amount of time whether foo is "aaaaaaaaaaaaa" and bar is "aaaaaaaaaaaaa" or foo is "aaaaaaaaaaaaa" and bar is "bbbbbbbbbbbbb".
Neat. Now I want to start a C/C++ implementation of the Go runtime as a personal project. Probably a bit out of my league though...
I was using [werc](http://werc.cat-v.org/) to publish documentation on some internal projects, and it was great, but then some people got interested a version that would run on Windows too, so I choose Go to attempt to mimic the very basic [werc](http://werc.cat-v.org/) functionalities (serve markdown files) and made binary packages for Linux, OSX and FreeBSD. Windows? welll... [Luminos](http://luminos.menteslibres.org/) does not work on Windows yet, it compiles cleanly, but it refuses to start, I'm looking into it. This server can play along with Apache2, nginx or any other server that supports FastCGI, or even without an external web server. It may come handy for documenting new Go projects.
Interesting. I'm still pretty new to go and I feel like I haven't been using it to its full potential because I don't know the best way to use its concurrent aspects.
I definitely recommend learning them. The concurrency tools in Go are my favorite part of the platform. Using them effectively requires a good mind-shift from other programming languages. For example, rather than using locking/synchronization around state, you create a goroutine for modifying it and channels to communicate with the goroutine. It's a fascinating change.
Of course, it doesn't improve the speed of your hard drive. There are two factors in play that make fast-archiver more efficient than, for example, tar, when reading huge numbers of small files. The first factor is that it performs multiple concurrent syscalls like open(), close(), and stat(); when you're reading small files sequentially, you spend a lot of time performing these system calls and not reading data. If you have a million 8k files, tar will give you a throughput of something like 6 MiB/s reading them, whereas fast-archiver will give you 25MiB/s. The second factor is that many systems are setup for concurrent I/O, using RAID arrays for example. I'm not really sure how much of a factor this is, since my benchmarks with fast-archiver show it to be more performant on a single-disk as well.
He's a troll. Obviously.
And you are wrong again. Really, if you don't know what you are talking about, better stop making claims or you will look very silly.
Unless you're going to tell me that go translates blocking system calls into non-blocking calls I think you might need to check who's looking silly.
Go does use internally some async syscalls, it also uses epoll/kqueue/... internally, so it does *not* need to keep an OS thread around for every IO operation, and it does not get "ridiculously slow very easily". 
The language itself says nothing about any libraries, or about OS threads, obviously, nor about whatever an implementation will internally use async syscalls or anything else.
Yeah, I did some bad settings in GAE and it started costing too much. Now it works again! :D
Thank you for taking the time to create this. It would be great to have a thin wrapper for Tk. An ANSI-C-based, lightweight, dead-simple, cross-platform, BSD-style licensed, native-look UI toolkit would seem to be a better fit for golang than Qt. Tk can look [native](http://www.tkdocs.com/tutorial/intro.html) and is designed to be [concise](http://www.softpanorama.org/Scripting/tcl.shtml) enough that a gui designer is unnecessary. There's Tcl/Tk, Python's Tkinter, Perl's Tkx, Ruby's RubyTk, and bindings for [other](http://wiki.tcl.tk/17264) languages. It would be great to have a go-tk too, and possibly easier to create than a binding for Qt.
I'm currently using goweb on an internal project and it's the bee's knees. Great for building RESTful APIs.
Explain? Are you joking? :O
As it happens, he's right. Network I/O is special - any other system call that's not known to be non-blocking will get a thread. Of course that might change in the future.
As you note, this is an implementation detail, and AFAIK there are other seemingly-blocking things that are done via async syscalls.
As someone learning Go from other languages, I am curious why the following would not be a good approach to the Undo's embedding problem (see page 2 of the article near "unwise"): package main import "fmt" import "errors" type History []func() func (undo *History) Add(function func()) { *undo = append(*undo, function) } func (undo *History) Undo() error { functions := *undo if len(functions) == 0 { return errors.New("No functions to undo") } index := len(functions) - 1 if function := functions[index]; function != nil { function() functions[index] = nil } *undo = functions[:index] return nil } type IntSet struct { data map[int] bool History } func NewIntSet() IntSet { return IntSet{data: make(map[int]bool)} } func (set *IntSet) Add(x int) { if ! set.Contains(x) { set.data[x] = true set.History.Add(func() { set.Delete(x) }) } else { set.History.Add(nil) } } func (set *IntSet) Delete(x int) { if set.Contains(x) { delete(set.data, x) set.History.Add(func() { set.Add(x) }) } else { set.History.Add(nil) } } func (set *IntSet) Contains(x int) bool { return set.data[x]; } func main() { set := NewIntSet() set.Add(1); set.Add(2); set.Add(3); set.Delete(2); fmt.Printf("%v\n", set); set.Undo(); fmt.Printf("%v\n", set); } The article would have us manually delegate Undo. Is the only reason to protect against a user casually adding something via set.History.Add()? Is there another way to automatically embed and delegate Undo from the History type? If so, do people regularly do manual delegation in practice? Isn't automatic delegation via embedding one of Go's handier features?
Thanks for the link! Looking at it, it's definitely more of what I'm looking for, but still not quite the same. Yeah, I'm using vim pretty extensively, which is why I started looking at the docs more. I like Vim quite a bit, but it leaves a bit to be desired in a few areas, looking up more than just function docs being one of them.
This will do the *opposite* of what you want (go from usage to definition), with ctags: My `~/.ctags`: --langdef=Go --langmap=Go:.go --regex-Go=/func([ \t]+\([^)]+\))?[ \t]+([a-zA-Z0-9_]+)/\2/d,func/ --regex-Go=/var[ \t]+([a-zA-Z_][a-zA-Z0-9_]+)/\1/d,var/ --regex-Go=/type[ \t]+([a-zA-Z_][a-zA-Z0-9_]+)/\1/d,type/
Hi David, thanks for your reply. In retrospect, I suppose you're right. The additional features (read timeout, logger, default handler) are not that difficult to add to the basic http.Server, and maybe it doesn't merit a pkg of its own. I was also recommended to use http.ServeMux over http.Server, but there's not much documentation I could find about it or why it's different/better than http.Server, so if you have any information about that, please let me know.
This isn't really a question specific to go. It depends entirely on the problem that you're tackling. Amdahl's law and whatnot.
I thought I'd get this answer first. However, the experiences with programs for real use are what I'm primarily looking for. It's never bad thing to get some tips and overview of the possible issues and successes after all. I'm trying to get access to some beefier machine myself but it's not going well. I'll definitely share my experiences here if I'm able to.
Concurrency is not Parallelism (it's better) http://concur.rspace.googlecode.com/hg/talk/concur.html#title-slide
It's been acknowledged that the goroutine scheduler has room for improvement. [dvykov](http://codereview.appspot.com/user/dvyukov) has been making some interesting changes in the libraries in regards to scalability and safety.
runtime.GOMAXPROCS(0) runtime.NumCPU can be 8, but if GOMAXPROCS is 1 it doesn't matter.
Could be possible too
True, but I am guessing the OP intended to show that paralellizing to multiple cores in Go is as easy as splitting the problem across the number of CPUs.
I've hit my 2 article limit only reading the Go articles ಠ_ಠ
Seems like he is throwing the baby out with the bath water. I have no love for exceptions, either, but I think I would have eschewed constructors and destructors, and had each init and term function call the base class version, all the way up the chain. You'd have one init function and still get an error return if it failed. If a user of the library cast the pointer to one of the base classes and called init on it to make some sort of semi-initialized object, well, that's their doing. They can also memcpy garbage into it. You can't completely idiot-proof code.
It sounds like the guy is making things hard on himself. Clearly, exceptions make for more idiomatic C++ code. &gt;While the possibility to handle the exceptions differently in different contexts may seem appealing at the first sight, it quickly turns into a nightmare. &gt;As you fix individual bugs you'll find out that you are replicating almost the same error handling code in many places. Adding a new function call to the code introduces that possibility that different types of exceptions will bubble up to the calling function where there are not yet properly handled. Which means new bugs. This is an interesting observation, because I've been seeing the opposite. I feel like I'm replicating error handling code with Go's explicit error returns. In a recursive descent parser I was writing, I ended up with a lot of code like this: value, err := someFun(...) if err != nil { return nil, err } value2, err := someOtherFun(...) if err != nil { return nil, err } Compared to exceptions, that's a lot of boilerplate just to pass the error up the call chain properly. In my Ruby code, I've had a very few, small and centralized 'catch' blocks and tend not to care what type of exception it is. I now know I could use panic/recover to get exception-like behavior in the parser code, but maybe I need to stop 'thinking in exceptions' and learn some better Go idioms. Edit: after reading some blog comments and thinking about it more, this is probably one of the well-considered tradeoffs Go has that I haven't understood yet. The code is more verbose and un-DRY than I'm used to, but maybe that's a good thing.
Nice. I know this isn't related to go, but we used moovweb quite a while back (when they were new, and before I'm sure they even started using go), and were very happy with their service... with the exception that it sacrifices control over the mobile code, and they essentially become contracted workers with a specialized toolkit. For a company who has a large website and wants to enter the mobile space, but doesn't have the employees with the knowledge of where to go, it's a no-brainer to choose this guys... they're quick and deliver a solid product. We're still using them on m.steepandcheap.com
Do you use Go at steepandcheap? 
I think it's great that you're making an ~~idea~~ **IDE** which supports Go, but I think you might be missing out on a lot of users because you don't support Linux natively, as I am under the impression that Go is mostly used on Linux (and possibly OS X).
Nope, we don't use any... Haven't really seen a good fit for it unfortunately.
Take my money!
Sorry I wasn't satisfied with the other ones I made earlier and I didnt have an imgur account set up at the time so I wasnt able to change them to add the license or anything like that. Some people kept asking me for a blue gopher and I took a bit more time to finish up the logo so it looks worthy of representing golang. :) Some people were offering me donations for this work. I really appreciate the offer but this is my gift to all my fellow gophers. The reward for me is to have it used on your guys web apps to show off to the world. :) Also a special shoutout to smw for coming up with the gopher on a wheel idea to fit the powered by gophers slogan. ;) License: The "Powered By Gophers Logo" was created by mortdeus and smw. This work is licensed under the Creative Commons Attribution 3.0 Unported License. This work is inspired by the Golang gopher mascots designed by Renee French.
I've been quite satisfied with [IntelliJ IDEA Community Edition](http://www.jetbrains.com/idea/download/) with the [Go plugin] (https://github.com/mtoader/google-go-lang-idea-plugin). Although I still haven't done any big project with it.
http://www.sublimetext.com/2 + https://github.com/disposaboy/gosublime
NO, EMACS IS BETTERRR!!!!!!!!!!
Whoa, thats looking good I dont know how I didnt heard of it before. added to main post.
Emacs?
Unix.
I really love how the wheel ended up looking. :)
https://github.com/nsf/gocode with vim or emacs
I use (very satisfied): Emacs + go-mode (go/misc/emacs) + gocode (https://github.com/nsf/gocode ) + http://www.let.rug.nl/~kleiweg/go/go-emacs.html I just tried the IDEA Plugin and seems great! But never did nothing more than little tests with it.
Yegge's NBL was JS. It was semi-clear at the time, lots of people guessed it, and he confirmed it later. That was pointed out in the comments.
&gt; The classic example is the readfile, where you have to call many functions (open, read, allocate, close etc), each potentially returning error values. … &gt; That's where GO fails spectacularly. I dont' want to wrap EVERY line of my code in an IF to check the return value, i want my whole function to fail if any of the calls fails, possibly with an intelligent way of releasing resources (which is not that hard, java is implementing it in java8 IIRC for example). So make a single function that does the reads/writes to the file and returns a single error message if need be. As for the cleanup, that's what `defer` is for. I think there's an argument to be made that Go should be slightly more high level about file handling, but if you're willing to get your hands dirty and write the function yourself, there's no reason you can't replicate exception-style "don't bother me now" file handling with Go as it is.
It's like most of the Dart lovers on that comment section have never used Go.
I still don't get it, how is an exception 'implicit'? it is an alternative pathway for code execution but the catch mechanism is as explicit as the rest of the code.
well no, this is an example of bad code that catches generic exceptions. I'm sure you can do the same in Go by returning a generic error, to be fair this example should raise and catch different exceptions for every kind of issue just like you would return different error information in Go right?
I'd like there to be a standard examination for people who say that they will never use Go because of "Those Three" reasons (we all know what they are, we've heard them time and time again). I'm sincerely convinced that Java and C++ programmers pretend to pop their head up every 3-4 years to proclaim that they are still top-dogs and they have nothing left to learn from programming. Go has provided me with the *perfect* middle ground between dynamism and type-safety. Between productivity and deployment. It's that perfect sweet spot much like when you finally scratch that itch on your back.
So, by following some of the comments, try { pizza(); pie(); cheese(); } catch (PizzaException e) { ... } catch (PieException e) { ... } catch (CheeseException e) { ... } is better than if err = pizza(); err != nil { ... } if err = pie(); err != nil { ... } if err = pie(); err != nil { ... } Really? And you're really going to argue up level up you'll be better prepared (have more information) to handle the situation? 
I think I get what you're saying... Hmm, interesting, new possibilities, can't decide which is better: try { open(); write(); close(); } catch (OpenException e) { log("open failed"); } catch (WriteException e) { log("write failed"); } catch (CloseException e) { log("close failed"); } Single point of collection? try { open(); write(); close(); } catch (Exception e) { log("open failed. or maybe write... close perhaps?"); } Don't tell me you're going to stuff all Exception types in a single try with a long list of catches. And you're probably not going to put all your application's file handling code under a single try. Anyway it's much easier using a function handling all the file stuff.
golangide LiteIDE Released for Go http://code.google.com/p/golangide/
Looks like it's aimed at people using Go as a first language. Might be good if you want to teach a class with Go. Note to high school teachers: the answers to homework you assign in popular languages is all available with a simple google search. Assign Go homework and you won't have that problem for another year or two! ;-)
Dart is the worst designed non-joke language I've seen. new HelloIsolate().spawn().then((SendPort sendPort) { sendPort.send("sailor", receivePort.toSendPort()); }); That's the example code for their concurrency model. Not sure what Google was thinking here. 
You just need to install gocode, and have its executable in your PATH.
My approach: http://www.reddit.com/r/programming/comments/zbc4e/interesting_language_comparison_building_a_simple/c638oro
[here's a less verbose version of java](http://www.reddit.com/r/programming/comments/zbc4e/interesting_language_comparison_building_a_simple/c639obk) uses java8 
This is not a worthwhile thing to argue. While verbosity often correlates inversely with expressiveness, it is possible to design a language which tends to produce quite concise programs which are impossible to read. There are other languages which gain on verbosity at the cost of totally missing out on some advantages provided by statically-typed languages, e.g. good luck renaming a variable in ruby. Or, if you want the concise response: **shut up, you.**
ed.
But your earlier comment about the simple lambda based solutions not being valid ASTs, doesn't it apply here? As I said, I am not sure I understand your reasons, but I can think of a few of my own. For example it is impossible to interrogate the generated function about what it does and what it consists of.
Yes, Go is probably the worst language I've ever used, except for the rest.
This is an area I think the D language handles well. D has a 'scope()' statement which operates rather like 'defer' in Go, except that you have three different flavours: scope(exit), scope(failure), and scope(success)... 'scope(exit) X' is just like 'defer X' in Go. 'scope(failure) X' will run the deferred code X only if an exception is raised from the current function, and 'scope(success) X' will run only if no exception is raised. It seems to strike a really nice balance between C-style error-handling and C++ style exception-handling, and allows you to tightly-couple the error handling with the setup code, but without the duplication of checks you illustrated. More flexible than either, yet also less verbose than either approach. The improvement in readability is fantastic. While I generally prefer the simplicity of Go to D, this is one area where I prefer D's approach. Far nicer than lots of nested try/catch blocks, and yet avoids polluting code with lots of 'if err...' statements, or even the 'if ... recover()' conditions of Go. 
http://www.quora.com/Python-programming-language-1/How-does-Google-keep-the-Python-interpreter-warm-for-AppEngine-calls
Can't wait for the new release.
If you're just saving JSON objects to disk, you should totally try switching out to mongo.
That would be the most sensible choice, true, but I wanted to keep it very simple using standard library functions whereever possible :)
Sweet, you should see about contributing it to go's lib. We could always use more libs like this that implement standard formats.
I presume using the sort library wasn't allowed as part of the assignment? Obviously it's only an exercise, but did you find using lots of go routines sped it up or slowed it down? There's a reasonable amount of overhead in creating each Go routine, so it might well be faster without them. 
When I ran it on my laptop more goroutines made it much faster. With 128 goroutines it was 620ms with 1024 goroutines it ran in 277ms. Java total was 832ms. One difference was I built it into a single binary. Standard disclaimer of YMMV. 
Because of your src folder it's not possible to "go get github.com/FliPPeh/goblog"
are you using the tip build? 
he's already doing this https://github.com/Skinney/WordSorter/blob/master/Go/main.go#L31
http://blog.golang.org/2012/08/organizing-go-code.html http://golang.org/doc/code.html 
I have been up and down that page many times now and I don't see what I'm missing. I have the src/&lt;package&gt;/&lt;package_files&gt; format, what am I missing? I've taken a look at the Markdown package I'm including using the github URL, and the author basically threw every source file into the root folder. I can't do that, I have 2 "main" packages now, they have to be separated. I have basically followed [this](http://stackoverflow.com/questions/9985559/organizing-a-multiple-file-go-project) structure and that works with go install and go build, so I have no idea what else to do.
I use the standard http package, plus some of the [gorilla libs](http://gorilla-web.appspot.com/), esp securecookie. it is ok, I never tried anything else though. Edit: Go's template system is a bit clumsy, though, I don't know of good alternatives. I'd love to use [jade](http://jade-lang.com/) or something similar, assuming it would be offering the same functionality as go's template package.
Yeah, I wasn't allowed to use the built-in sort library. When it came to Java, my sorted linked list was actually faster than the built in sort method anyway. Goroutines did speed it up considerably, even when setting GOMAXPROCS to 1, which really surprised me. Tested using Go 1.0.2. The reason why I think using more goroutines speeds it up, is because the linked lists will be significantly smaller. More goroutines, smaller lists, faster insertion time, faster sorting.
Many thanks, it seems to be working now, I can "go get" the package and build/install the programs using "go install github.com/FliPPeh/goblod/blogserver"!
God I find questions like that annoying. Reminds me of the time people discovered Ruby and thought everything should be done in Ruby. I don't understand people's obsession with Git, especially when comparing it against Hg. To me, Hg has 99% of Git's functionality with 30% of the learning curve. 
+1 
I've used Hg in the past and it's a fine system, but I don't use it now and I didn't have it installed on my laptop. But it didn't bother me even a little that the Go team settled on hg. So I install Go, easy as can be. Then... * I try "go get ..." and I get an error because I don't have hg installed. WTF? I don't think I should need to care what VCS the Go project is using unless I am involving myself at that level. * So I install hg, and get more errors and warnings because I haven't wrangled certs and my .hgrc into shape? WTF? Still not able to "go get" stuff. * After Googling for a while, I get hg configured well enough to do "go get" and I can finally actually do something. This kind of yak shaving sucks, and should not be happening unless I want to hg clone some part of the Go project. I don't recall *ever* having to concern myself before with what VCS a language project was using in order to use the language tools. It's surprising and dismaying.
Nice gotcha, but why would you check to see the connection was nil rather than the error in the first place?
Is this a sincere question or are you merely mocking those who ask questions such as the one mentioned in the submission? EDIT: For those reading this after he deleted his question: His original question was about why the Go project uses Google Code instead of Github.
You're awfully vociferous. What package were you trying to install with `go get ...`? If that package was using `hg`, then of course you need `hg` installed in order to retrieve it. &gt; unless I want to hg clone some part of the Go project Or if you want to clone another project written in Go that is using `hg`.
&gt; You're awfully vociferous. Yeah. Finding myself yak shaving just to do some tutorial stuff set me off. I think I have some justification. I didn't want to clone anything.
Why are people down-voting this? If you have feedback I would be grateful, and improve the code.
Writing a good suite of tests is not always easy, but the process of writing~~s~~ tests [ http://www.golang-book.com/12]
Probably because they're useful to very few people.
Github actually supports hg and svn if I recall corectly 
&gt;Three changes are necessary: change the return type to contain multiple types separated by ,, change the expression after the return so that it contains multiple expressions separated by , and finally change the assignment statement so that multiple values are on the left side of the := or =. [http://www.golang-book.com/7#section2](http://www.golang-book.com/7#section2) specific examples could have made this part better 
This is exactly what I was thinking.
This is the only place where Go does implicit conversions and it is unfortunately confusing for a lot of people.
None of what you said is a problem with Go. You simply had a bad experience while trying to install something and found out that you don't have the necessary tools to do so. What would you say if you tried to compile some C library and found out you're missing dependencies? would you complain that `gnu make` or `gcc` doesn't work? from your complaint which has nothing at all to do with the topic btw, I can guess the answer to my question but anyway... if I give you a url `git://example.net/a.git` kindly tell me how I get stuff out of it without using git. You keep talking about how you weren't trying to clone any but you don't seem to realise that the code cannot manifest itself out of thin air and you therefore need `hg` to retrieve it.... and before you start crying about how I downvoted you, that cannot happen since for me Reddit has only an upvote button.
When it was launched it was markeded as having similar speeds as C. So now with theese speedups i guess it must be faster than C ? ;-) 
The typeless constants isn't the issue. The issue is that if you convert a nil pointer to an interface you get a non-nil interface value that contains a nil pointer. Since this conversion is implicit in the assignment it's easy to miss that a conversion has occurred. 
I think you should read http://golang.org/cmd/go/#Download_and_install_packages_and_dependencies and `go help remote`.
Well, to me it seems more like you don't know mercurial that well.
How many features of (x) did you think you were going to use before you started using (x)? People who don't use git tend not to notice what they don't have. (this is a generalisation from speaking to converts, I have no personal experience with mercurial) 
I don't think we disagree, but I want to just write down my idea of what's happening for my own clarification: Let's say we have interface A, concrete type B that implements A, and function F that returns an object of type A. An interface is conceptually a struct containing a pointer to the concrete type and field containing what the concrete type originally was in case you want to get it back (no 'type erasure' in Go). If inside of F, I say make an object b that is a nil of type B, then the result of that function won't be really nil, because it will be a type A interface object that points to the nil type B concrete nil. A nil of type A, on the other hand, would just be a pure nil without field telling it about the concrete type B. Here's a test program: package main import ( "fmt" ) type A interface { Foo() } type B struct {} func (b B) Foo() {} func F() A { var b *B = nil return b } func main() { var nilA A = nil var nilB *B = nil f := F() fmt.Printf("%v\n%#v\n", f, f) if f == nil { fmt.Println("Is nil") } else { fmt.Println("Not nil") } if f == nilA { fmt.Println("Is nilA") } else { fmt.Println("Not nilA") } if f == nilB { fmt.Println("Is nilB") } else { fmt.Println("Not nilB") } } The output is: &lt;nil&gt; (*main.B)(nil) Not nil Not nilA Is nilB Should we blame the confusion on the typelessness of constants? Maybe, maybe not. I suppose an equal share of blame can be handed to the ease with which a concrete type can fill in for an interface type. But without that ease, there would be a lot of annoying busywork to shut up the compiler.
I don't see anywhere in your example where the typelessness of constants is any source of confusion. In all cases the nil constant is converted to the type that it's being compared against or assigned to as one would expect in most languages. The confusion is that the programmer writing f() didn't understand that nil *B would be wrapped in an A when it was returned and the programmer checking the result didn't understand how '==' works with interface values. 
&gt; Git gives you the option to use Github though hg gives you the option to use [bitbucket](https://bitbucket.org/) :)
I'll look for your post. More goroutines than CPUs should incur more context switches though, which is why I think more goroutines should be slower, at least intuitively.
Again, I don't think there's any real debate here, but notice that if you compare to a nilB, which is a nil that is explicitly typed as a B, the comparison is true.
Would there be a problem if when comparing "nil" to a nil interface value &lt;intfc-type, nil&gt;, that == is defined to be true? A downside isn't obvious to me.
I's not a Go gotcha as it's wrong to begin with. Any Go tutorials reinforce quite well that you check for the error value not for something else.
I's not a Go gotcha as it's wrong to begin with. This is the equivalent of saying: var x *tls.Conn if x==nil In which languages does that work or seem sensible?
tldr Git and Mercurial both work
Some useless trivia, Go used to use perforce before the public release.
I'm already doing this with my game engine source, giving the glfw and opengl files included in the source. the only problem is using this packages in different versions. But golang is trying to not use any 3rd party libraries and be as native as it can so I'm not sure how good this is.
http://www.youtube.com/watch?v=BMRlY9dFVLg The code is a little mass but its my first game engine so I'm doing my best and it will be more user friendly in later releases. Edit: link to source https://github.com/vova616/GarageEngine/ yeah go 1 is backwards compatible but you cant use .a files complied with version 1.X with version 1.Y
That one answers itself. 
thanks :) yeah they are for windows(32 bit) for that reason lol, I just used "go install" and copied the .a files it created. its little difficult to explain to people how to use these files though =\
are you on windows? its probably because you dont have glew, use the compiled .a files that are in the pkg folder and make sure the source of vova616/gl and jteeuwen/glfw is in your golang src folder, just use go get on them and ignore the compiling errors.
It's damn corporate management. Perforce is not open source, has awful GUIs, costs a lot of money, isn't distributed, and is Windows-oriented. Why? Because it makes middle management feel comfortable behind a wall of tools and safeguards, and justifies hiring people to "manage data". Also, Windows came with my computer. http://www.xtranormal.com/watch/7411309/windoze
First you need to submit a contributors license agreement application form. http://golang.org/CONTRIBUTORS Then you should post on the go developers mailing list stating interest in contributing the code. Regarding the code itself, perhaps checking out the encoding pkg source code and making sure that function names and the code's over all style beyond go fmt matches the source is great. Also the license should use golang's bsd license. All future code that could potentially be adopted into the golang source code should make sure that its licensed that way. Also researching the license permissions in regards to the patent holder on a protocol would also be ideal. I can envision that some proprietary protocols could provide a complication for code being accepted into the language's standard lib. This should all be discussed there. Regardless, I personally thank the author of this code for working on this. We need all the help we can get to make sure that we can reduce the setbacks a dev has to work out; so they may use Golang for their projects. The more libraries like this provided open to the community means the overall capability to address specific problems and the attractiveness of the language increases. 
I think you do, try to update it to the last version.
You're right, not a full context switch as with a thread or process. But there's a scheduler running in the go runtime that has to juggle these goroutines, decide which one goes next and for how long, etc. More goroutines is more overhead, even if goroutines are very lightweight and the scheduler efficient. So more goroutines is more work, no matter what's happening. Which is why it sounds wrong that 1024 goroutines is taking less time than 128 goroutines. Unless of course the two tests are running sequentially in the same program and the time is saved is the overhead of creating the goroutine contexts, which I'm assuming Go is caching and reusing.
Revel - very interesting. Coming from a JVM background myself, I was playing with the idea of a Play! framework inspired framework for Go. Looks like it's quite a way along as well in terms of feature set.
Great project! I look forward to more people feeling out time-series dbs. The one that really piques my interest right now is Datomic.
I met with a few of the Datomic guys Friday. The product is really quite cool and I intend to be working with it shortly. I don't think I can use it in place of seriesly, but I do hope to recommend it for other things. Are you doing anything with Datomic now? For what applications do you find it most useful? (I've got ideas, but I like other people's).
&gt; FWIW, I find the downvoting of my complaint pretty funny. You're being down-voted because your complaint resolves to this: "How dare the Go authors require me to have hg installed in order to install a package from an hg repository!" In other words, your complaint is senseless.
I didn't know beforehand that it was an hg repo. Other languages provide tools that work out of the box. Python, Haskell, etc., give you de facto standard package fetchers that just get the packages. This is more sensible. If the go docs had told me to "go hg clone this repo" then we wouldn't be having this discussion. You seem to think that's exactly what they've done, but it isn't. The `go` tool is meant to be a handy, all-in-one tool, and it's pretty nifty. But in this case it's obscured what was really going on. It was confusing and frustrating. My complaint is not senseless at all. I *like* Go as a language and plan to use it. I *like* Mercurial, though I currently use a different DVCS. I'm an experienced programmer who has used many different languages and tools. Most everything has warts. I found one with Go's package management. It's not a big wart, but it's annoying in how unnecessary it is, as seen by how other well known tools have avoided these frustrations.
Sorry to hear that... I've heard complaints about universities turning CS courses into purely vocational instruction and I've heard complaints about course that are full of things you'll "never use." Both are unfortunate in their respective ways (the former is an unenlightened university and the latter is a student who evaded enlightenment). I'm in the "learn everything you possibly can" camp. Java is quite boring and the JVM doesn't interesting me much, but I actually rather like clojure. I do most of my work lately in go or c++, though. I did have someone point out to me that one of the datomic requirements is [my memcached client](http://code.google.com/p/spymemcached/) I wrote back in my mostly-java days. That was kind of cool. 
Interesting. This would seem to imply that the map creation + the loop body in ThreeSum2 m := makeMap(lon) [...] lookingFor := -(j + k) if lookingFor != j &amp;&amp; lookingFor != k { if _, present := m[lookingFor]; present == true { threeInts = []int{j, k, lookingFor} return } } take longer than the entire inner loop of ThreeSum: for _, z := range lon[j+1:] { if x+y+z == 0 { result = []int{x, y, z} return } } When you look at it that way, it's not so surprising. A hash is an expensive operation, compared to some looping (on such a small array) and some integer math. That said, O( n^2 ) will outperform O( n^3 ) eventually. I wonder how big N would have to be to get there. *Edit: for^matting.
Most of the core contributors work at Google, but Google has no special rights to the software beyond the name. The people and companies who contribute code to the project remain the copyright holders; they just give Google Inc. a worldwide re-use license (standard open source [CLA](http://en.wikipedia.org/wiki/Contributor_License_Agreement).)
Jan Newmarch's book has a chapter on templates: http://jan.newmarch.name/go/
(x-post from /r/programming) web.go, Gorilla Toolkit, and Revel all looks like the perfect candidates in building high performance RESTful services. I have 1 feature request to give it a nice bow tie: OAuth provider. How awesome would that be? 
Komodo Edit has pretty good golang support with this plugin: [github.com/trentm/komodo-go](https://github.com/trentm/komodo-go)
&gt; I didn't want to clone a version controlled repo. You keep stating that's what I wanted to do, because it just so happens that's how the tool works. I never stated that was what you wanted to do---I said that was what **you did**. (Even though you said you weren't.) &gt; I understood this before I first commented, as you could read in my first comment here, having installed and configured hg in order for go get to work. I am left wondering if your misunderstanding of what I've been trying to say is willful. You continued to state you weren't trying to clone something even though *that is precisely what `go get` does*. This certainly isn't a misunderstanding on my part. And I'm not surprised that you've ignored the rest of my post. You're clearly not interested in a discussion about the merits of installing third party packages. There are good reasons why `go get` uses VCS. It makes distributing packages extremely simple. (Which you didn't bother to acknowledge in your shallow comparison to other languages.) A simple installation of mercurial or git is not a demanding dependency; that you had trouble with hg certs is unfortunate but not a problem with Go. (A packaging problem from your distribution?)
Looks fantastic! It didn't say anything about whether I can use this on Google App Engine. Does it work on GAE?
It doesn't look like there's anything there that would get in the way. It still lacks an ORM, so just use the AppEngine backend for data storage and you should be good.
Which part?
Thanks! I never knew!
I like turtles.
Just noticed it, hadn't noticed it before, thought y'all might not've either. Check the sidebar for more goodies.
What are some uses of a treap?
[Treaps](http://en.wikipedia.org/wiki/Treap) are balanced binary trees, much like [Red-black trees](http://en.wikipedia.org/wiki/Red%E2%80%93black_tree). For sorted data structures, balanced binary trees are the bees knees. They don't guarantee the same O(log(n)) worst case complexity as Red-black ones (or AVL trees, or a bunch of others), but instead provide an average O(log(n)) complexity. Since the algorithm is simpler, the code is often faster as well, and the average performance better.
So you like the 2nd version too? :)
me too man! me too...
It's a super casual meetup, currently scheduled for 1st Thursday of every month. If no one shows up, I'll be there drinking beer and programming in go. If anyone else wants to show up, I might share my beer with you if you want to talk about/learn/discuss the go programming language. Just to prevent any kind of confusion, there will be no 3000 year old board games being played. Carry on.
How about Othello? ;)
Alas, my coast is east.
On Linux? You can use the compose key instead of reddit markup. Then you can actually write O(n²).
Turbo Pascal was the shit. Then they added objects, with one of the most sane OO designs I've ever used. Not on topic, but fond memories...
Agreed. I learned to code with Turbo Pascal and I haven't enjoyed a better environment since. Of course, I wouldn't use it today. It was perfectly designed for the DOS world.
I went to take a look because of your post and thought the discussion was pretty sane compared to some of the /r/programming discussions about Go. There's always the usual list of complaints, but there's no point arguing with people who are saying "Go isn't good for me." Who are we to tell them what is good for them?
It seems to me that you could do this pretty easily using `container/list`. Have one buffered channel for the input and an unbuffered channel for the output. There's a listener to the buffered input channel, and whenever it finds something, it adds it to a queue. On the other side, there's a listener that just dequeue's the lowest item and puts it on the output channel whenever it can. I'm pretty sure you would even preserve FIFO order (or close enough to it) this way. Ex. http://play.golang.org/p/OE459gImGf
Pretty small distrubted task manager we recently open sourced and have been using in production for a months processing million+ tasks a day.
Well that's all quite hypothetical. In my experience the actor model is a better fit for DS, especially with the semantics being so similar to that of the network itself. But that remains to be seen with what the netchan package turns it.
"I have nothing but praise for Go." Really? I don't think pragmatist is the right word. I am not saying it is good or bad. I am currently evaluating it myself.
The RPC server is working properly in every instance. I believe it has something to do with how the syscall library accesses it in Windows 7, but don't know enough about internal Windows calls to venture a guess. I've settled on using os.Getenv("USERNAME") since it will only be run on Windows machines, but am still curious about it.
Maybe he interpreted "distributed" as "project with many developers, causing dependencies to be distributed across the network"?
File a bug. http://golang.org/issue/new
That would be OK with me. It's a good language.
Haha! Good point. He's a pragmatist in the sense that he only cares if something works.
Grrr... I want to make this, but it's on a weekday. I don't have the time to take the train out and back during the week. I hope these start happening more frequently.
Exactly. It's just like Thing4J, JThing, thing.js, thing-rb, pything, and so on. It's a namespace, and it's useful when it prevents confusion. Go isn't really any more guilty of abuse than any other language.
This always bugged me with Ruby gems, E.g. ruby-mysql, ruby-sqlite3. ("Yes, I *know* this is ruby; these are gems, for god'ssake!") I guess I'd rather the libraries not be named with a go- prefix since it's pretty obvious what's going on when you're writing Go code :-P I do understand the desire for the prefix though. I'd better--I just created a Golang version of my old trusty personal wiki called go-bwiki.
neat! I have a project where this might come in handy. I'll let you know if I use it and how it goes...
Too soon to tell really.
Here's something similar we did for skynet: https://github.com/bketelsen/skynet/blob/master/pools/resourcepool.go It started out very simple - a buffered channel like you've got. But we wanted to have a "maximum active" number of connections, so some extra book keeping arose.
it's ok if it's in the import path, but it's annoying if it's the package name.
Do we have to register on meetup.com to come, or is it open?
It's open, no registration or guest list required. If you plan on bringing 15 friends, I'd like a heads up to make sure we have space. But other than that, the more the merrier!
Here's something I wrote about mux()ing, which is exactly what's happening here. http://gowithconfidence.tumblr.com/post/31431608488/muxing
Wasn't there some thing a while back about how memory addresses could actually be one of two things leading to weird bugs on 32-bit systems? And the "solution" was to upgrade to 64-bit so that the bug would simply show up less often? (not familiar with the intimacies of go but remembering an article of that kind a while back...)
[the bug](http://code.google.com/p/go/issues/detail?id=909)
I didn't know people used Revel. I tried to use it the other day and was supremely confused.
so it's basically a way to pre-allocate memory when you anticipate an append, and also to set a hard-limit for append?
It's only allocation. There is no way to set a limit.
[Yes.](http://blog.golang.org/2011/06/profiling-go-programs.html)
Slices are not arrays, slices are like a smart pointer to an array that stores the pointer to the first element of the slice (not necessarily the first element of the array), the length of the slice and capacity to which the slice can be grown but not overflow the array. When you make a slice, by default it makes a slice with a capacity the same as the length. That slice can't be grown without allocating a new slicing and copying the elements over. But if you know the slice is going to have to grow you can allocate a larger backing array when you make the slice. Read this, it'll help. http://blog.golang.org/2011/01/go-slices-usage-and-internals.html
Could someone post a mirror using a service that doesn't limit the number of users to 8? edit: I did, http://pastie.org/4730734 Of course, it won't get updated when sync.in updates, but it contains a snapshot.
Go at bitly is missing: http://word.bitly.com/post/29550171827/go-go-gadget And the go at BBC link is broken: http://www.quora.com/Go-programming-lGetConsoleTitleanguage/Is-Google-Go-ready-for-production-use/answer/Kunal-Anand Should be: http://www.quora.com/Go-programming-language/Is-Google-Go-ready-for-production-use/answer/Kunal-Anand
I've noticed in the past month there is a sudden spike of Go-related articles all over Hacker News (and elsewhere) and wondered whether it's a part of a *very* well-coordinated promotion/PR campaign or simply everyone using Go came out at the very same time. Disclaimer: I'm largely a Python coder, planning long-term to use Go to address our future server-side performance issues (nominal speed of the code).
Well, I I certainly hope so! 
I wrote the last article. There's no coordination, we just like the language. You're just seeing the articles now because the dust has finally settled after the 1.0 release, and people are just now starting to feel like they've used it enough to start writing about it.
A text gist of links is a pretty poor way to present a case. Consider using markdown so your links are at least clickable.
Hmm, at the risk of sounding like a fanboy: Go was released in 2009, Java in 1991. By my calculations that's 18 years (check my math if you don't believe me). The Java benchmarks should be fucking ashamed that they are *only that much* faster than Go. They have had plenty of time to optimize their runtime.
You could always fork &amp;&amp; send a pull request.
Did you compare with 1.0.2 or tip?
1.0.2, the one that currently is in brew on Mac. That shouldn't matter for the speedup, though, just for the relative speed vs. Java.
That's a really silly thing to say. There is a limit to how little work you can do to calculate something. Java, C, C++ all do very well at getting close to the optimal for most workloads where there isn't a lot of wiggle room from increasing performance. 
I like this guy's angle. A great comparison would be idiomatic code examples and an analysis of the machine code generated for each language. I'm not sure I've ever seen anything quite like that.
People can use whatever metrics please them the best, and telling them that they're wrong is a complete waste of time, and imo, wrong. Go is a compiled language. One of its originally stated goals was to be fast (fast running, not just fast-to-compile). You don't get a pass on one of your originally stated goals for, well, any reason at all. The go devs work hard to improve the speed of the generated code, and they continually make progress. In the meantime, people can try gccgo.
I never meant to put emphasis on go; that the speed of its execution isnt important. However there are topics regarding how golang doesnt match up to a certain language in regards to benchmarks, and people being turned away by that fact alone. "oh java is faster so its better to start projects with that instead. Go is a waste of time.", is the argument being made right now, and its just not true. At the moment, gc is improving at a rate that benchmarks done today on the current binary release (1.0.2), would not do golang justice when go's devs are reporting that tip has a ~50% performance increase. My argument is to learn the language and build things with it in anticipation that golang's performance will continue to greatly improve over a short time period. You cant claim the same is true for other languages like python whose projects to build a faster language ultimately left alot to be desired for. (i.e. Laden Swallow). Thats when you should really bench mark languages.... My overall point is that its a shame if somebody decides to ignore golang because they think that golang is always going to be slower than java. People should judge the language for how enjoyable it is to program with and let the devs worry about the performance related things (GC for example). Thats always been the advice that I hear from go's core devs.
Im not calling people stupid. Also production projects take time to build before they are even ready for official release. And after that you have years of building on top of it. A decision not to build a project today based on Go's performance, may have people rewriting their entire code base in go eventually like many people have claimed to be doing already. Especially 1 year from now, when people decide they made a bad judgement call after revisiting the language. All im trying to say is for people deciding if go is for them; try the language and have a bit of faith before jumping to conclusions based on the critics claims. Benchmarks are good to know how well gc is doing today, but take it for what it is. A progress report, not a final grade. I dont expect everyone to agree with me on this, and I appreciate the counter arguments. 
You can argue with Rob about this one. "Go's implementation is getting faster all the time. We've seen massive improvements this year; relative to Go 1 the implementation at tip is seeing benchmarks that are often 50% or more faster, sometimes much more. We'll be releasing those improvements soon. " https://groups.google.com/forum/#!msg/golang-nuts/RxQ96lckPQ4/FGoCau6OFoYJ
Huh, I stand corrected. Apologies for my faulty memory.
Definitely not. It's roughly 1,366km.
Percentage speed improvements are usually not as impressive as they sound. 50% of 10 milliseconds isn't much of a gain and improvements get harder to do the closer you get to the optimum. Go should eventually catch up to the jvm but it trades a lot of things to get there. 
No, but it's something. The reason I mentioned that is because within 2-3 replies in that thread someone had written more specialized code which ran a *lot* faster for the images he was processing. Overall though, these kinds of benchmarks are irrelevant for most people. Would it be nice that Go was faster? Sure, why not. Will I notice? Not one bit. You get more mileage out of writing idiomatic code rather than waiting for the language to mature. As an example, I had a program which was reading/parsing/writing out 3-4k files in ~10s. It was sequential and naively made a lot of memory allocations, I profiled, I optimized and I came out with a 2s runtime which is entirely dependant on HDD speed rather than the runtime of the processing code. I'm sure you've heard this before but: if people are comparing Go and Java and looking at the speed benefits and actually caring about the results, then they'd be much better off writing their applications in C or C++ anyway.
Its all good. :) Thankfully im right and go is better in many more ways then just some. ;)
Sweden here.
+1 for you both, but I'd still say that "often 50% or more faster" != "across the board".
This was basically me. I'm really not interested in betas. But since it was announced stable and, more importantly, there were some decent books coming out for the language it was something I decided to check out. The books were a real help.
The UI is just so mouse-centric that it's a non-starter for me. I do my best to eliminate use of the mouse. (Vim, window tiling, and the Vimium Chrome extension.)
Estonia, Tallinn
Hungary here
There's a tradeoff here - in system programming (Go's originally intended use) the length in memory or on the wire is often the expected return from len(s). Yes, you can get bugs if users expect len(s) to be the number of characters (or CCSes), but there can also be problems if users expect len(s) to equal the number of bytes and it doesn't. 
The mascot is a happy sausage. Ohgodwhat.
We had an angry sausage in an earlier version. It didn't test well with our target demographic.
&gt; Sawsij currently only supports Postgres, but support for other DBMS systems will be added soon. For a variety of reasons, we're not planning to support MySQL. This may change if there's enough demand. We'll probably look at some NoSQL databases first. :-( A framework should never dictate what RDBMS, persistence engine, template engine, or components that could and could not be used. This is a web application platform and not a framework. 
&gt; We believe that modern DBMS systems (like Postgres) are very capable and there's no need for applications to reproduce functionalty that's already there. [...] We think that using a database for "object persistence" is a fundamentally flawed concept that ought to be avoided. I wonder if one of the devs of this could explain what this means, from a practical standpoint? How does interacting with the database work with this model versus and ORM? 
I'm the lead dev. An ORM, in the strictest sense, seeks to represent tables and relationships as objects. This is simpler than that. From the docs: "The Model package is intended to provide something analagous to a lightweight ORM, though not quite. The general pattern of usage is that you create a struct that represents a row in your table, with the fields mapping to column names. You then pass a pointer to that struct into Model's various methods to perform database operations." Docs: http://go.pkgdoc.org/bitbucket.org/jaybill/sawsij/framework/model 
I'm a gopher, in Tampa. See github.com/bketelsen for my Go projects. Also use Go at work in Clearwater.
Happy sausage, angry sausage ... I don't see either. I see what looks like a happy turd waving at me (which by no means implies anything about my views on the project).
Skynet looks pretty nifty. I think I've seen it mentioned elsewhere; I thought it was golang-nuts, but the latest I see there is 2011, well before I'd heard of Go. Anyway, nifty. Looks like a neat replacement for Condor, the job scheduler we use at work. Interested in having a beer and talking about Go? I've never really been a "User Group" kind of guy, but maybe now's a good time to start. :)
But in any other multi-byte built-in type `len([]type)` returns the number of units of type, not the number of bytes. `len([]int8{0,1,2})` returns 3, as does `len([]int32{0,1,2})`. The only reason to think `len("世界")` would return 6 instead of 2 is that we're used to languages where strings are arrays of `char`s/`byte`s instead of code-points (well, that and it's easier/faster to just return the implementation length of a variable-length type). If we taught that `len` and `[i]` returned code-points/`rune`s, but were slower for it, we'd be able to keep the abstraction and tell programmers who need to worry about byte length or speed to go use a library function instead. As I say in another reply, the obvious ways to operate on a type should maintain abstractions for clients. People who need special access to the implementation or special performance should be using libraries, not the other way around.
So brave!
I love the idea of an app implementing a file system, and interacting with the app via the file system. Want an external program to append to the file currently being edited? "`echo some_text &gt;&gt; /your_app/file1`". Very nifty.
Code-points are always full displayed characters. An astral character is one code-point, made up of 16-bit two code-units. An astral character, as given in the context *of the paragraph talking about how Java doesn't always return full code-points*, could fit in a single rune. A rune can fit any code-point, so if your operations are handing you full runes, you should be safe dorking with it directly. We run into these problems because our operations are returning us bytes which may or may not be full code-points. Change them to return runes holding full code-points, and we wouldn't have to worry about this. And yes, validating runes is horrible and they don't want to put that code in the common operators. As I said, I get why they're leaking the abstraction. It's still leaking.
True. Though they'd probably argue that all file systems are "virtual".
&gt; Says who? Nobody really, but the authors have already given us a level of abstraction that should support most cases. It makes it easier on users, us, to adapt when we can use whatever db driver we want (within the driver confines of course -- the implementation of LastInsertId() for pq below). sawsij only allows for postgres atm. &gt; errors.New("pq: this is postgres, a real database, this isn't a valid command") &gt; The framework's purpose is to build web apps. Yup. I just wish it would (or planned to) extend to other popular platforms.
Really wish google would start paying attention to google code. Or if they won't, just deprecate it so we can stop hoping. I used to love it but now there are so many other superior options; the only thing worse place to find a project you'd like to contribute to and realizing it's on SourceForge. If they do choose to deprecate it, I hope they'll just stop new projects from being created. It would be a huge loss to have all of the abandoned-but-relevant projects be made unavailable. *edit: didn't realize how old the conversation I was replying to was; sorry for the random notification.*
Ludicrously naive. Just as limited and short-sighted as the golang XML UnMarshal-&gt;struct behavior. Not only do you not understand the implications of specifying a persistence backend, you didn't even learn the DataMapper/ActiveRecord lessons of ORM design. Jesus christ, have you even built a large web app before or are you just making it up as you go along? Go read some SQLAlchemy source code or something. Something being rm -rf'ing your goddamn repo.
When using eshell (a shell inside of emacs), this can done easily too through redirection into buffers or even elisp variables. E.g. cat mylog.log &gt;&gt; #&lt;buffer *scratch*&gt; It's extremely powerful but has an extreme lack of documentation.
It would be interesting to design a follow-up interface once touchscreens become standard for regular computers and laptops. I'm sure certain types of input are much easier using a touchscreen (navigation, maybe selection of text). I think keyboard/touchscreen could be quite a powerful combination, and much easier than keyboard/mouse.
&gt; I relish the ability to decide on the persistence backend according to the problem being solved Well, when you decide you want to use Postgres, you can add Sawsij to the list of prospects, too. ;)
The people working on planb used to use a white board with a projector and laser pointers for selecting and executing text in their versions of acme(octopus). 
I think the bench is too simplistic. Here are my results when running http://pastie.org/4747137 BenchmarkAnonymousFunction 500000000 4.17 ns/op BenchmarkClosure 500000000 7.68 ns/op BenchmarkNormalFunction 2000000000 0.76 ns/op 
Sounds like fun to me!
It's also interesting to see that creation of anonymous function doesn't really increase the execution time, I think Go compiler did some optimization for that?
I am sorry my work is such a personal affront to you. You should probably go ahead and use something else.
Actually, I think we're going to start with FoxPro and then move to dBase4.
Well, good news. There *are* plans to support other popular platforms. We just wanted to come out of the gate with something that would support *one* popular platform as well as we could. We likely won't support mysql directly, but we'll make it pretty trivial for someone else to do it.
Multitouch gestures might help a lot there.
You should have seen the earlier, darker brown version we had. Oof.
Closures are one feature I've never really liked because, in my experience, it has always made for really awkward code. Generics would probably be more useful. Apples to oranges, I know, but if they had to cut _something_ this would be it.
On the other hand, I wasn't interested in early versions of Go until it got closures, and then I liked the language.
I genuinely find it difficult to believe that there isn't a more suitable container type/object when it comes to mixed types. If you're storing arbitrary types in a slice/array, it's weird, even in Go, let alone Python.
My thoughts were: tap+hold (middle finger), then tap and/or hold left or right of your finger in different combinations for different types of chording.
In Python, `["a",1]` is a lightweight struct with its fields evident in context. In Go, type tally struct { name string count uint } makes `tally{"a",1}` pretty lightweight too. If you wanted the full data structuring features in Python you'd have to define an object, it's more fuss. I kind of wish Go had first class anonymous tuples (so multi returns could be captured without destructuring, for example) but at least named data type definition is low-ceremony.
with most UIs, eliminating the mouse is a good strategy, because the mouse is so limited in its capabilities - it's like having a fist but no fingers. with acme, the mouse becomes useful enough that the keyboard feels like the lesser partner. the mouse has the particular advantage that it's context-free, so anything you can see is a quickly-reached affordance to some potentially interesting action. i was a dedicated and proficient vi user for a long time, but acme allows me to get things done more quickly, despite (or perhaps because of) the fact that the keyboard is almost completely un-meta. 
I can't tell you *why* this limitation exists, only that the short form of variable declaration can only be used inside functions. All global variables need to use the long form. Thems just the rules.
See also: http://golang.org/ref/spec#Short_variable_declarations
From [Rob Pike's message to golang-nuts](https://groups.google.com/d/msg/golang-nuts/OqYL9lgsPQ4/udp0nPHPZTgJ): &gt;At the top level, var (or const or type or func) is necessary: each item must be introduced by a keyword for ur-syntactic reasons related to recognizing statement boundaries. With the later changes involving semicolons, it became possible, I believe, to eliminate the need for var in some cases, but since const, type, and func must remain, it's not a compelling argument. 
make the anonymous function declared outside the loop doesn't seem to change the benchmark much: $ go test -test.bench=.* testing: warning: no tests to run PASS BenchmarkAnonymousFunction 500000000 3.56 ns/op BenchmarkReusingAnonymousFunction 500000000 3.24 ns/op BenchmarkClosure 5000000 298 ns/op BenchmarkReusingClosure 500000000 5.34 ns/op BenchmarkNormalFunction 2000000000 0.82 ns/op ok github.com/sunfmin/benchmark_go_closures 10.827s 
I'd like to think of it as because executable code can only reside inside functions. The short form involves both declaration and initialization (variable assignment), so it's not allowed outside a function. 
You can do "var x = 2" just fine. It's for parsing reasons.
I would like to thank all who took the time to reply.
Given that the framework is in a BSD license, I don't see why anyone couldn't add MySQL/MariaDB support and just submit it. Sounds like the devs are scratching their Postgres itch and would rather play with NoSQL before adding in MySQL. It doesn't sound like they're opposed to MySQL, just they rather put resources elsewhere first since they already have an open source RDBMS supported.
Salzburg, Austria here...
What the fuck subreddit did I just stumble into?
As an author of a [somewhat usable](http://github.com/AeroNotix/wedge) web-framework I commend you for adding another option to Go's ecosystem. I'm of the opinion that choice means better quality for all. I don't see any Forms module, will you be adding one? Also, looking at the API I notice a few things that I don't immediately associate with a web-framework, an example being `GetUserInput()`. Is there a command line abilities to this framework?
&gt; Java just magically rewrites your code? Basically yes. Consider this code from another go-nuts thread: http://play.golang.org/p/CWGxImVX7P If I compile it normally "go build test.go" and run it, it takes 67ms on my computer to run the compiled code. If I compile via "go build -compiler gccgo -gccgoflags '-static-libgcc -O2' test.go" it runs in about 120us. The compiler re-wrote my code in the 2nd compile. The JVM is going to do this sort of stuff all over the place, along with doing things like database results caching and statement preparation all on its own. 
I'm originally from Blackpool, yourself?
Go really is a good language for this task - goroutines that are waiting on IO can lie dormant while others encrypt the data.
Proof the language should endure has arrived? :-)
I used vi(m) for about 15 years, been using acme for the last three months and I've found the mouse to be incredibly efficient in this setup. I also think it's increased my productivity a bit. It's certainly an enjoyable editor that gets the hell out of my way so I can work. What started as a novelty has turned into a change in the way I get things done. I'll be using acme from here on out when it's available and I miss it when it's not there. I've learned from acme (rc, and other plan9 utilities) that I don't need as many bells and whistles as I thought I did. I always fancied myself a minimalist, but p9p has turned me in to a hyperminimalist. My only complaint is that I now try to use mouse chording and other acme features in things like chrome or my terminal, which yields minor frustration. I've even taken to running rc within acme to get around my system. Without a mouse, I couldn't imagine using rc, though. The other (minor) drawback is that you can't keep acme open in tmux (or your favorite multiplexer) so it's available with a quick ssh session. Source control helps with this issue. Use vim when I'm remote, and acme when I'm back in my native environment.
This is a really old article.
See also: http://geekmonkey.org/articles/20-comparison-of-ides-for-google-go
I don't know why they give such short shrift to Emacs and Vim. Both have graphical modes every bit as fancy as the editors mentioned, if that's what you want. [Here is Emacs with the menus and toolbars turned on](http://i.imgur.com/YC1qY.png) and [here is Vim running as gvim](http://i.imgur.com/pXwcK.png).
LiteIDE does have a debugger.
He does not mention Zeus: http://www.zeusedit.com/go.html For quite some time Zeus has had support for the Go language. Zeus does the standard Go syntax highlighting, code folding, code navigation etc. But it also has project/workspace management as well as support for the Go Build, Format, Fix, Run and Document commands. It even works with gocode and gdb. *Jussi Jumppanen* *Author: Zeus Editor* 
I use Komodo Edit for go work, works well, I hacked on the Go support a bit (komodo-go plugin). If sublime is an "IDE" then so is Komodo (I think they're both just editors).
Can I get a show of hands please - who's using a Go IDE and which one are you using?
+1 for Zeus. I've been using it for Go development and like it quite a lot. I use Komodo IDE for most of my other work, but it doesn't have a Go debugger. The Go debugger in Zeus really helped me learn the language. Also, the author is very responsive with bug fixes - I reported a couple of bugs in the Zeus forum and Jussi put out patch releases within a day or less. Nice work! Zeus is Windows only, but that's fine for me.
Thank you for your kind words :) I'm glad to read the new Zeus Go features are working well. &gt; Zeus is Windows only, but that's fine for me. Zeus is native to Windows, but it does also run fine on Linux using Wine. 
That question can't have a reasonable answer because it's entirely subjective. The same way some of us don't need an IDE for java is the same way some of us don't need an IDE for Go. But at the same time the right IDE can make things so much more enjoyable and if you aren't enjoying the experience then in most cases it's going to be a handicap for you regardless of how awesome the environment is.
For the same reason many is us suffered a perceived performance degradation by going with gnome on old hardware instead of lxde. Features mean nothing if the environment as a whole doesn't provide a great experience to the particular user. Personally I prefer vim over emacs but for me even vim is lacking compared to st2. It just doesn't feel as polished to me. Some of that is to do with the limited terminal window but grim et al. Doesn't do much to improve that either. YMMV
Is there somewhere a non video presentation/tutorial of Sublime+GoSublime ? Having just installed it I see it's fast and shiny, just the opposite of Eclipse, but I've yet to learn how to have shortcuts to execute current file for exemple.
Who made sdl? What's it doing with its surface objects?
Like?
Thanks for the suggestion. I included it in the article. Zeus looks really nice, although the interface for debugging could use a beautification.
Good catch. Fixed in the article.
Not really. Used Emacs/XEmacs since the early 90's and switched to Vim in 2002 and used it for 10 years. I really like Sublime.
&gt; Programming without an IntelliSense-style autocompletion is simply not something I'm willing to do anymore. Omnicomplete (vim's version of IntelliSense) for go is handled by "gocode", which takes all of a minute to set up. &gt;The fact that emacs and/or vim can be configured to have *this behavior* isn't interesting to me. Vim (gvim) has mouse selection, find-and-replace from the edit menu, and is nonmodal. Go comes bundled with syntax coloring and convenience scripts for vim. I'm sure emacs has something similar. &gt;I'm simply not interested in poring over meta-key apocrypha for weeks or months to eek out a minuscule gain in navigation efficacy. Type "vimtutor" if you have vim installed. A 970 line text document will come up. Read it, and ~1 hour later you will know all you need to know to be productive in vim. &gt; UX has made incredible advances in the last 20 and 30 years and I'm interested in taking advantage of that. Again, emacs has something similar. The appeal to progress is just as much a fallacy as the appeal to tradition. Use what works for you, but don't assume something is worse because its older.
I actually just created a build type for my project using sublime's built-in ability to create build-systems. It was pretty easy. :)
The tour is great. Mark Summerfield's book is also nice and hands-on: http://www.qtrac.eu/gobook.html
/thread
Oh wow, they moved the Reset button, thank goodness. Hitting Reset instead of Run a couple times was amazingly frustrating. Great tutorial, though.
Version 2, friend. Version 2.
Great book! I like the way it teaches by doing..
&gt; var p *uint32 = *uint32(int(surface.Pixels) + y*int(surface.Pitch) + x*bpp) You're trying to access a pixel in surface.Pixels, which is an unsafe.Pointer to the void* array in C. Since surface.Pixels is an array, you do not want to cast it to an int. It looks like you have two choices: * cast it to a fixed-length array slice, or * do pointer arithmetic with uintptr and cast it back to an unsafe.Pointer The syntax for the first appears to be n := surface.W * surface.H pixels := (*[n]uint32)(surface.Pixels) Then you can access an element in it like you would any other Go array. It's probably unwise to do anything else with the slice though. The second option is something like: var p *uint32 = (*uint32)(unsafe.Pointer(uintptr(surface.Pixels) + uintptr(y * surface.Pitch + x * bpp))) Disclaimer: I'm on old C programmer who took your question as an opportunity to try to figure out this part of Go. Similar test code appears to compile, but I haven't bothered to write actual SDL code to find out if this actually works properly.
Don't think so (don't work with my PyCharm). But work with InteliJ Community edition (free)
From [the official Python tutorial](http://docs.python.org/tutorial/datastructures.html): &gt; Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, **and usually contain an heterogeneous sequence of elements** that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of namedtuples). Lists are mutable, and their elements **are usually homogeneous** and are accessed by iterating over the list. Emphasis mine. In Python 3, you should write `if response in {200, 201}`. Cpython has some special case code to make it more efficient. It automatically uses a `frozenset` instead of a regular `set`, and the look up is O(1). See http://mail.python.org/pipermail/python-3000/2008-January/thread.html#11798
I was going to recommend the same book. It's short, but it goes over all the basics. It could use more examples, but otherwise, it's great. 
Fair enough. Thanks for the link!
I use Intellij IDEA based golang plugin. It's great for code completion, you can also hold down Ctrl and click on a function call to type name and get to it's source code. You can launch go programs from IDE, fmt code with one click. I use it on Ubuntu and it works great. Btw, IntelliJ IDEA is open source and is free. Check it out https://github.com/mtoader/google-go-lang-idea-plugin
The solution I'm using is: c := http.Client{ Transport: &amp;http.Transport{ Dial: func(netw, addr string) (net.Conn, error) { deadline := time.Now().Add(10 * time.Second) c, err := net.DialTimeout(netw, addr, time.Second*5) if err != nil { return nil, err } c.SetDeadline(deadline) return c, nil }, }, } resp, err := c.Get(url) I'm rather new to Go and the other replies here are making me wonder what exactly is wrong with this approach? Is it a matter of control over where exactly the timeout applies or what am I missing?
With this would I just use c.Get? Edit: this also makes a too many open files error.
Yes, in fact there are only a max of 768 open at a time. (Except for these supposedly timed out connections).
I looked at the source code, and it is a simple substitution cipher and therefore totally unsafe. Don't use this for anything! If you'd like a simple and understandable (but not the safest) cipher, use XTea: http://en.wikipedia.org/wiki/XTEA But better leave cryptography up to the experts. Use whats in the standard library, an off-the-shelf implementation, or a direct translation of an off-the-shelf translation to Go.
There is no such thing as a "UTF-8 character". UTF-8 is an encoding for Unicode characters, aka runes or codepoints. You have to decode the UTF-8 bytes to get the character, and at that point it is no longer UTF-8. All Unicode encodings, like UTF-8 and UTF-16, encode the same character values. I hate to be so pedantic but Unicode is widely misunderstood, and it is too important to get wrong.
This looks like it sets a deadline for a TCP connection 10 seconds from when the Dial attempt is made. This does not allow for reuse of the TCP connection for multiple requests, i.e. HTTP keepalive. Also, note that if you're using TLS connections (HTTPS) without keepalive, then this will result in a lot of time doing TLS handshakes.
I'm in London too, would definitely be up for a meetup.
Hahaha, nope :). I'm creating a stat service, but I want to benchmark it on high numbers of multiple connections (right now all testing is local, so nothing even goes out into the internet).
&gt; But don't you need to know how the function in Go returns errors too? Like which output argument is the error, what is the type of that error? Yeah, and it's a huge PITA. Good catch. When you do actually care about the details of the error, you have to cast it back, which is really annoying, and difficult to do. It's not even guaranteed as part of the interface, so the type can vary by OS. &gt; What's OOB? Out of band. Exceptions are used for OOB control flow, traditionally for errors. &gt; If you do it right, there is zero overhead if you don't use it. Example: C++. Yes but in my opinion, exceptions without tracebacks, and with C++'s inadequate exception handling constructs (no else/finally, wtf??) are _awful_. The OP compares Python exception handling with Go. &gt; Readability. Lots of branching to mingle the normal logic flow and all the error conditions, including those that happen only 0.0001% of the time. This point is moot. You have to handle it somewhere, explicit error handling means the interface will tell you if it's been handled for you or not. With Go's defer mechanism, handling errors inline is easy compared to C, where this was a nightmare of tiny functions, gotos, and if statements.
&gt; with C++'s inadequate exception handling constructs (no else/finally, wtf??) are awful. C++ does not need "finally" clause because it uses the much superior RAII, which even Python has started to mimic with the "with" clause.
I wish that book and others covered more concurrent programming. Go Phrasebook does a decent job covering it, but there is still a lack of decent resource for concurrent programming design patterns.
Once you are done with all the beginner resources, watch the concurrency video at http://blog.golang.org/2012/07/go-videos-from-google-io-2012.html and go thru http://nf.wh3rd.net/10things/ 
Titles like these - "I'm not leaving X for Go", "I'm not switching from Y to Go!" and etc. are not only a unnecessarily inflammatory, they're also a bit childish. Nobody is trying to take Python/C++ *away* from you and *replace* it with Go. It's not like Rob Pike et al are on a mission from Google to kill Ruby/Python/C++ and imprison those who use them. You can use Python *and* Go, and shit, even plain crufty old C, all together! It's a tool. It's just another tool. If you want to learn just *one* tool, and use it everywhere, fine. But I wouldn't trust you to be a good programmer just like I wouldn't trust a handyman who refuses to "leave my hammer for a screwdriver!". I used to think that programmers, of all people, would have a natural curiosity and desire to learn something new. Instead, I see so many that are afraid and suspicious and see Go as some sort of threat to their entire livelihood and existence, just because it decided to do some things differently. It's really strange and bizarre. 
I seriously want to leave python though. I hate that concurrency isn't a core part of the language. So sadly, yes, Python and Go are just different tools for different things. I genuinely believe we can make a more general tool that can solve both problems.
Interesting points. 1. I do appreciate C and what it's done for me dearly. 1. So you don't mind having to wrap every function call with error handling? You'd prefer handling errors for every function call be mandatory? 1. I don't like the situation in Python either. I was just hoping Go would be my savior.
&gt; It's not like Rob Pike et al are on a mission from Google to kill Ruby/Python/C++ and imprison those who use them. Yes, that is exactly what they want you to think, so certainly there's no need to become paranoid about it happening very soon when you least expect it.
In practice, you don't have to wrap every function call in an if -- although Go does have a very idiomatic way of doing it. Honestly, it's by far the majority case to not wrap every statement in an error handler. But at the end of the day, there is no saviour for this problem. Errors must be handled, and that's a fact of programming. Every time you read from the disk, network, or anything related you must check for errors. But for a great deal of code, you're just manipulating memory or doing other stuff that is largely error-free. For example, here's a short uid generator I wrote a while back: package uidgenerator type UidGenerator struct { channel chan int } func New() *UidGenerator { uidg := &amp;UidGenerator{make(chan int)} go func() { for i := 0; ; i++ { uidg.channel &lt;- i } }() return uidg } func (uidg *UidGenerator) NextUid() int { return &lt;-uidg.channel } It's a simple example, but this is the sort of thing were Go shines. You create a "UidGenerator" object, which is actually a goroutine internally. (As soon as you create it, it spawns a goroutine using an anonymous function.) Then, you can actually still interact with it as if it were an object and read out values. But since I'm just dealing with my own logic here, I don't need to do any error checking at all. And I guess that's what I mean -- sure the standard library has a lot of errors that *could* get thrown, but that's the *nature of standard libraries*. They deal with all that low-level net/disk/os stuff that's sketchy as heck. Once you get a layer up from that and start writing mostly logic code, you'll need to wrap as many functions in error checks as you want -- it's purely up to you
It's a very elegant example might I add. But the problem remains &gt; it's purely up to you With exceptions, ignoring errors is explicit and is very visible from the code. Return values ignored is a normal thing which will be missed on any radar once in a while. So that's why I think this is a fatal approach.
&gt; But don't you need to know how the function in Go returns errors too? Like which output argument is the error, what is the type of that error? By convention, the last return value indicates the error. The type of that error is "error", a built-in type. And to be honest, I find your question pointless. Of course, if you use a function or a method, you ought to know what its arguments are, its return values and if it throws an exception/panics.
I find your argument quite weird: you say that sequences of error checks are not necessary because you can just ignore errors and hope for the best. As a result, you are practically resorting to exception handling, because functions will fail, and it is common for Go functions to return a nil pointer under failure. The next invocation of a method on nil will result in a panic. However, it's an ugly panic that is totally uninformative. I am not arguing for exceptions, but it would be nice if there was a language construct where you could easily combine computations that could result in an error, that would short circuit on the occasion of an error and return that error. Obviously, you would not always use that construct, because in some cases you can handle errors, but it's handy for the common case where you want to do five things that can fail where you simply want to return the error in case of failure. Also, you keep the nice function signatures :).
There are two reasons why I really dislike exceptions: 1. Taxonomy: you never know what exception type to return; libraries do this right but average programs have to think about it and if they make mistakes they have to redesign the exception architecture; this is really difficult to do (I've needed to in a couple of places but gave up in the end) 2. Unpredictability: at work we have some exceptions that are caught in multiple places: if they're caught at a lower level they get treated like some sort of a more normal error with a normal error return, if they get caught a bit higher up they get treated like a more serious error; I had to make one of these exceptions get treated like a more serious error. I ended up running the program in the debugger to figure out where it gets caught and turned into the serious error. Maybe this is an example of bad usage but it's the kind people fall into easily. 
Malware developer using Go! Now, I know Go will be successful. Seriously, even bad guys are finding it useful. 
It would be nice if returning the specific error type would still satisfy looser interfaces. Example: type Fooer interface{ MightFail() error } type Foos struct{} func (me Foos) MightFail() FoosError { // } type FoosError struct{} func (me FoosError) Error() string {} Calling MightFail on a Foos will give you a FoosError, but Foos implements Fooer.
Defer will execute whatever you want so it can operate in a *kind of* similar pattern to RAII.
But RAII works well with classes because classes offer a constructor and a destructor that the language runtime takes care of automatically thus avoiding programmer forgetfulness. In Go, at every call-site, you better remember to defer closing the file whenever you open one.
I am on a mission to kill Ruby/Python/C++/Java, the complexity they represent is a technological cancer.
&gt; With exceptions, ignoring errors is explicit and is very visible from the code. No, it is *implicit* and *invisible*. &gt; Return values ignored is a normal thing which will be missed on any radar once in a while. You clearly have not written any Go code: you can't ignore return values in Go, it just does not happen. And for the extremely rare cases of functions with desirable side effects which only return one err value, is trivial to write some code to find such cases, but in almost two years of writing and reading Go code I have not seen a single instance of this happening.
I really like Go, but I disagree. a) It can help point the Go maintainers at what performance problems they should tackle, and b) it can help guide people whether they should adopt Go *right now*, or wait a bit. Frankly, I'm coming from Perl, and for me Go is *fast enough*. :)
Lots 'o comments in [/r/programming](http://www.reddit.com/r/programming/comments/10dx9z/error_codes_vs_exceptions_critical_code_vs/).
&gt; No, whatever type it really is is lost inside the interface value that now holds it. If a function always returns an error of a particular type, it should be able to return that and still satisfy an interface that requires that an error be returned. Go doesn't do type erasure. No information is lost, and is still accessible e.g. through type assertions. &gt; If you call os.Read and it fails, you get an error. But if you need to know the error code inside that error, you have to cast about and hope you strike gold. If a function returns a predefined set of errors, you can always compare against the instances of those errors (e.g. io.EOF), or you can do type assertions to test for specific errors.
When is go 1.1 supposed to be released?
&gt; No, it is implicit and invisible. Eh. I think this is a property of the implementation of exceptions, rather than the idea of exceptions. In Python they are implicit and invisible, though. Which is just plain awful to deal with. (It's probably my biggest gripe with the language.)
Yes, then there are checked exceptions as in java, that are almost universally despised, even within the Java community.
I've tended to waver between the two methods over my learning career, but I think the "forgetting to check error codes" point fails beautifully in a language with multiple return values and that requires all returned values to be acknowledged by the caller. Sure it's possible to say `f, _ := os.Open("test.txt")` and ignore errors, but you have to consciously do that. It's been easy to discipline myself to look up possible error values and handle them (or at least put an empty error check that will be obvious even under a quick pre-commit review) whenever I see that I'm calling a function that returns an error.
I think Go 1.1 is the one that's supposed to include the GC and scheduler enhancements.
&gt;Having your proram crash, a lot of the time, is just as bad as having it continue. Just wanted to share a personal anecdote for this. We have a system that in essence manages several disparate "tasks" and "services." -- Kind of a control panel for automated scripts. The manager is written in Java, the self-proclaimed king of exceptions. Interestingly enough: we are fighting with the fact that the whole program is crashing because a single task is "failing" a lot. (Not actually failing, just complaining that it has nothing to do.) -- I'm trivializing a bit for the sake of brevity, but basically we've run into a case that wasn't in the original design of the system, leading to an uncaught exception, leading to the end of the world [as far as our system is concerned]. Now -- the whole system is failing because of one failed job throwing an uncaught exception in code that hasn't been maintained in a few years. In this particular instance: our program could actually go on in an "undefined" state, without *actually* corrupting any program state. The error can be safely ignored; but exceptions [more specifically: how the author handled them] say "No! You may not ignore me!" --- Panicking is not always the best, or even the correct solution. Which is what this author seems to imply; This is why I quite like Go's distinction between errors and panics, and Go's ability to ignore errors when it may be programmatically correct, or simply desirable to do so.
&gt; you can't ignore return values in Go From the first lesson in the tutorial: package main import "fmt" func main() { fmt.Println("Hello, ??") } **[Notice that fmt.Println returns an error that was ignored.](http://golang.org/pkg/fmt/#Println)** The definition of explict: &gt; Stated clearly and in detail, leaving no room for confusion or doubt. And you reply &gt;&gt; With exceptions, ignoring errors is explicit and is very visible from the code. &gt;No, it is *implicit* and *invisible* When I said "ignoring errors" I meant letting them pass silently. This is how you ignore errors in python: try: urllib.urlopen('http://reddit.com').read() except Exception: pass And this is how you ignore the same errors in Go: http.Get("http://www.nuke.gov/seal_presidential_bunker") Or if you want to actually read something, here we're sort of explicitly (although very compactly) ignoring the errors: resp, _ = http.Get("http://www.nuke.gov/seal_presidential_bunker") 
&gt; http.Get("http://www.nuke.gov/seal_presidential_bunker") This code is absurd, I have not seen anyone write code like this, as it is patently obviously useless. Write some Go code, and tell me if you ever run into the situation that you are inadvertently ignoring an error like that. It has never happened to me, nor have I heard of it happening to any Go programmer, while Python exceptions getting ignored happens *all the fucking time*. And if that is an issue, is trivial to write a tiny script that searches for any unused returns of type error. But nobody has because simply it does not happen.
The two biggest reasons, I believe, are that the syntax was specifically designed to be faster to parse, and having a real package system instead of guarded #includes limits the number of times a file needs to be read and reparsed.
[Setenv](http://golang.org/pkg/os/#Setenv) can fail, [is this your code](https://github.com/uriel/cgd/blob/master/main.go#L34)? [Close](http://golang.org/pkg/os/#File.Close) can fail, [did you star this project?](https://github.com/couchbaselabs/cbfs/blob/master/http.go#L376) I'm sure that a more avid Go user can find other, more fatal misfortunes. Please understand that I do think Go has **a lot** going for it. Error codes are a good approach when you have the time, or the need to handle all errors exactly when they occur. That's simply not my daily use case and thus I prefer a different approach. [This guy analyzed the dilemma nicely imo.](http://www.yosefk.com/blog/error-codes-vs-exceptions-critical-code-vs-typical-code.html)
I believe that the guy was taking about compiling the C source code of the compiler, not using the compiler to compile Go code.
&gt; You keep picking examples that [...] what you want, is to ignore the error I'm just saying that ignoring the error should be more explicit. If one day Setenv() didn't work for some reason, you wouldn't want your application in some undefined state, would you? If you would, then it should be **clear** from the code that you're **silencing an error**. &gt; trivial to look up what Go functions might return an error, in Python you never know what exceptions any call might throw Do you trivially know which functions can panic in Go? &gt; Having to have try: except: ... around every time [...] I don't want you to have a try/catch for every line. I think you need to have a try/catch at whichever scope you need to decide what to do with the error. E.g. a message loop shouldn't crash because of bad message handlers. A webserver shouldn't crash because of a broken html file. Place the error handling wherever it's appropriate and enjoy debugging stack traces vs debugging error codes. I have to understand, are you completely, unequivocally against exceptions? Do you deny their worth entirely or do you believe that the cons outweigh the pros?
Timeout for HTTP client. HTTP connection before the websocket upgrade needs to have cookie information. Being able to know when HTTP connection to golang http server timesout or is dropped. Plus the new scheduler and all the other performance improvements that are in tip.
&gt; In Go is safe to assume functions don't panic. Period. What about when you're using a package somebody else wrote? Are you guaranteed anything about this? One day this assumption may bite back. I'll assume your experience has taught you things different from mine. Which is fine. I'll just mention a defining experience for me regarding exceptions: A few years back I wrote a safety critical program in C that should never crash. Believe me that I read the official documentation for every Windows API call in those 10K lines. Every single return value was always handled. Always. To my surprise, some broken hardware can cause an SEH exception on windows to be thrown on ReadFile because it somehow corrupts certain pointers. This was not mentioned in any of the API docs, [it isn't mentioned to this day](http://msdn.microsoft.com/en-us/library/windows/desktop/aa365467\(v=vs.85\).aspx). This is roughly equivalent to an unexpected panic from a call that should only fail through error codes. My point being - if Go is going for the "handle all errors explicitly" approach that's fine. It's good for the critical code that needs that kind of approach. But under that direction it would be an improvement if: * Any function that has a return of type error need be assigned (and thus ignored only explicitly). * Everyone be aware that panics can come out of nowhere. All programs that should never fail must explicitly handle the possibility of unexpected panics. &gt; I'm completely, unequivocally against exceptions I believe exceptions are an easier, more consistent approach for the reasons I've mentioned in the blog post and this thread. I respect the advantages of error codes, for me, they're just not worth the pains I've endured in their name. So I guess we're just going to have to agree to disagree then.
It'd be nice if you could use go get go to update go, is there any built-in update command or do we have to download the binaries?
Another think that hasn't been mentioned yet: better ARM support. See: http://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi
I use many languages, both exception-heavy like C# and error-code-heavy like Obj-C. I prefer error codes and Go handles them better than most. Others prefer exceptions because error checking is bulky. Without it, their code can read as if no errors occur, demonstrating how the program is supposed to work as simply as possible. The unfortunate but necessary exception handling gets a separate section, so you don't have to read it unless something goes wrong. The problem with this idea is if you're reading the code, something is wrong. If it ran fine you'd be working on something else. When writing new code, printf's in each error clause can tell you what went wrong and print relevant variables. Once it works you can remove the printf's but leave the proper error handling. If you come back to fix a bug, the error clauses make it obvious how the program responds to problems. You don't have to look up in the documentation which functions may throw exceptions of which type. It's all right there in front of you.
Does anybody else not feel strongly either way? I understand that the concerns are about the verboseness of error codes versus the difficulty of reasoning about exceptions. Having used both I have never felt that one is *clearly* preferable to the other. Both styles are tenable with good programming practices. It's a relatively minor issue for me when I'm deciding what language to use for a project.
&gt; dont make any lasting conclusions about the potential of Go I definitely agree!
Oh noes, some random developer isn't switching to go; the language must be bad.
Yes, I really don't get the drama over error handling. You write the code, if the function throws an error you either choose to explicitly ignore it via "_" or handle it with an "if then" and move on. I think people like to bitch over the smallest things. I see this with speed benchmarks too. Someone does something in Java/Python/whatever and see's that Go is 20% slower doing the same thing. Oh noes, 20%, really? Is that the life or death of your project? If performance matters that much why the fuck aren't you using C? 
Also, is there a roadmap somewhere? I.e. a list of next versions, maybe estimates for release dates, and most importantly, what features we can expect next. I'd like to know what the priorities of the go development team are.
I agree, you don't need it much. But sometimes you need to act on certain errors, and have to dynamically type cast.
&gt; I think the "forgetting to check error codes" point fails beautifully in a language with multiple return values I think that's a great point, and I hope that it works out that way in Go code long term. &gt; requires all returned values to be acknowledged by the caller Nitpick: I'm not sure I agree with this. If you acknowledge any return values, you must mention them all, true, but it's also legal to not mention any and ignore them all.
&gt; However, the **cost of a panic is the loss of at least one call frame from the stack**. We did this intentionally. To quote from the original mail: "This proposal differs from the usual model of exceptions as a control structure, but that is a deliberate decision. We don't want to encourage the conflation of errors and exceptions that occur in languages such as Java." Could anyone explain this? I'm not groking it. Moreover, I can't recall noticing a panic removing a call frame from the stack... (Particularly the part where I've added emphasis.)
It's interesting because in my mind Go's approach to error handling is better than pythons but not as good as ML. I'm happy to make that tradeoff because of how frictionless development in go is.
I have two complaints with this article: 1) When zooming, the text doesn't re-flow and results in a horizontal scrollbar. 2) There is no mention of `gofmt`. Any article discussing syntactical differences in Go *must* at least address `gofmt`, since it is vigorously applied to most projects. (I have a git commit hook in all of my Go repositories that doesn't let me commit Go code that isn't `gofmt`'d.) In this article's case, `gofmt` solves the problem at hand: [andrew@Ocelot ~] gofmt package main func main() { println("Hello, world!"); } package main func main() { println("Hello, world!") }
&gt; What about when you're using a package somebody else wrote? Are you guaranteed anything about this? One day this assumption may bite back. Any package that doesn't respect this is basically broken, and will be shunned. I have yet to see anyone doing this, and again, if anyone did, i doubt anyone would use such a package. &gt; Every single return value was always handled. Always. To my surprise, some broken hardware can cause an SEH exception on windows to be thrown on ReadFile because it somehow corrupts certain pointers. This was not mentioned in any of the API docs, it isn't mentioned to this day. This seems like an illustration of how exceptions fail, they are never properly documented. &gt; Everyone be aware that panics can come out of nowhere. All programs that should never fail must explicitly handle the possibility of unexpected panics. Then at the top of your program you have a defer/recover, and you deal with any unknow panics that way, there can always be cosmic rays or who knows what, for those cases where you really don't want to crash Go provides defer/recover.
Speaking about it without trying it is at best uninformed.
Good to know. Thanks! :)
Why not just: err := json.NewEncoder(rw).Encode(map[string]string{ "x": "y", }) or wrap the whole thing in a function: func writeJsonResponse(rw http.ResponseWriter, a interface{}) error { rw.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(rw).Encode(a) } 
I like your idea of wrapping it in a function, and any other normal day, I probably would have done it in a similar fashion, but I typically code in Python (for work) and I suppose my day-to-day use of the Tornado framework has gotten me used to directly passing a `dict` to a `tornado.web.RequestHandler.finish()` method. PS. Thank you for GoSublime. :)
I've never used Go and didn't read any of the Go docs or tutorials, but I have an opinion anyway. Please read my blog. 
&gt; I like your idea of wrapping it in a function, and any other normal day, I probably would have done it in a similar fashion, but I typically code in Python (for work) and I suppose my day-to-day use of the Tornado framework has gotten me used to directly passing a dict to a tornado.web.RequestHandler.finish() method. in that case I guess there is also an even fancier route that resembles Python's decorators http://play.golang.org/p/KMRjP4O6YP &gt; PS. Thank you for GoSublime. :) yw :)
The protocol probably defines its message lengths. No guessing should be required.
Connections to redis are persistent and won't close after each command (closing after each command would be terrible for performance). The redis protocol tells you how many bytes to expect per argument and CRLF delimits arguments, so you can't just wait for EOF to signal a completed command. See: http://redis.io/topics/protocol This might be useful as well: https://github.com/hoisie/redis.go/blob/master/redis.go
Wouldn't using a type switch allow all of the code within each case's block to be statically typed? Yes, you're still asking for the type at runtime, but you've either written handling for a given static-type error that can be statically checked so you know you're not doing anything terrible, or passing it onto the default case which passes it on or Strings it for reporting. I guess I'm working from the assumption that the code you're calling has documented the static types it's returning if it expects any of those types to be useful to the caller (or you've found the type on your own through investigating a returned error). Are you working with the assumption that they only claim to return `error`?
A small contribution: [a SO question with a great answer](http://stackoverflow.com/questions/1619152/how-to-create-rest-urls-without-verbs) about REST (scroll down a little to the answer with 500+ upvotes).
Heroku: jack of all trades, master of none.
I am a huge fan of [goweb](https://code.google.com/p/goweb/). It's lightweight, extremely easy to use and in active development. Next on the list of features is message signing, I believe.
It's a very seductive error of thinking to get lured into either or.
Yes, it does assume that the coder is disciplined enough to stop and insert an error handling block (or a dummy function) after every call that you notice returns one. It also assumes that you'll code review enough to notice the dud block before committing/shipping. I also try not to reuse an error variable that I haven't covered in one way or another, but I'm more prone to err on the side of "overwriting a variable name with an unrelated operation is bad until proven otherwise" because it gets in the way when modifying code later. I sometimes write a dummy function that takes an `error` and either outputs a reminder to Stderr or just does nothing and serves as a bookmark that will satisfy the compiler for now. The calls are easily searchable, and the compiler will gladly help you out if you delete the declaration during code review. It's definitely less of a pattern/solution and more a set of features that have helped me remember to handle errors a lot more than I remembered in C. You can do the dummy functions in C, but it's easier to remember when your error code is separate from the return value you really want, and you have to name that error in order to get hold of the value you really want, both enforced by the compiler, which means I often forget to place even a dummy call until I've already failed to compile once. Unfortunately, in your example, even that won't work, as the compiler won't complain if you don't save try to save any return values. The functions I tend to forget to check are the subroutines that are all side-effect and no "useful" return value. The compiler won't cover 100% of the ways to miss `error` (as others have said, a `go vet` pass to report the unhandled errors would be great)
That's the framework I've been thinking of using. Do you know of any up-and-running projects that are using it (open source of course)?
It is what it is. It would be nice, though, if Go did as Haskell does -- give the user an exception handling operator. You can either view the function as returning a pair *or* as returning a single value and throwing on failure -- it's just syntactic sugar.
If you guess the message length, bad things will happen. In the message header, it will tell you how many bytes to read. Then you use ReadAll with that length to read the correct number of bytes.
http://golang.org/pkg/io/ioutil/#ReadAll
[OP posted it both on SO and here at the same time](http://stackoverflow.com/questions/12604464/how-do-you-read-all-the-bytes-that-come-on-a-tcp-connection).
What platform do you preform? Or would you just rather run your own vps?
http://gosearchify.herokuapp.com/search?q=don%27t+tell
This looks very nice! I'm totally going to use this in my next Go program. Make sure to add a `COPYING` file or some such equivalent.
&gt;whereever possible 'Wherever' is the correct spelling.
I wrote [seriesly][seriesly] as a simple REST service using only the built-in HTTP stuff which I found to be quite sufficient. It maps specific paths of GET, PUT, POST and DELETE to internal functions to do the respective needful. Similarly, I built [cbfs][cbfs] in the last couple weeks with a guy who'd never worked in go before. cbfs differs seriesly in that seriesly provides an API for specific types of interactions with a database and cbfs is basically a scalable read/write HTTP server. [seriesly]: http://dustin.github.com/2012/09/09/seriesly.html [cbfs]: http://dustin.github.com/2012/09/27/cbfs.html
Looks neat.
By that, as in.. you were too busy, or you didnt find a problem ?
File locking wouldn't be too hard (I plan to support CAS type operations sooner, though). Authentication is the hardest part of authorization. You need a not-unpleasant way to get users to assert who they are and the server to be able to verify this assertion. S3 does it reasonably well given the scale (and doesn't require the user to do an oauth dance at inconvenient times). But cbfs is a different type of beast from NFS. Where NFS and CBFS really start to diverge is when you're dealing with partial file modification on all but the tiniest of files. NFS doesn't care -- it takes an offset, some data and sticks that data at the given offset. This is very efficient if you have a file on a filesystem that has cheap mutation operations. It's very expensive when your filesystem is a content addressable store. However, this is also why a system like cbfs can confidently cache any file content and maintain consistency. Now, there are, of course, solutions to balance these two things. Partial file mutation is not a priority at the moment, though. (however, random partial file access does work today)
&gt; Unfortunately, my productivity in go has prevented me from participating in the "go makes stupid language decisions that make it hard to write good code" arguments. I'm sure they were fun. I just wanted to say: Awesome. :)
I run my own stuff. It's very simple and I can run edge versions of various tools and middleware apps.
Answer: Yes. But seriously, &gt; Go will be **my first language and attempt at programming**. Why would someone who has never programmed want to do this stuff? &gt; I am gearing up to be able to build applications for the future releases of **FreeBSD** which should run **Clang** by version 10. It's your first programming language, but you use FreeBSD? Not even like Unbuntu Linux or something, FreeBSD. The OS off of which OS X and iOS are based? And you know for sure you want to use the compiler that Apple uses? &gt; So my first experimental project is to build a clock that runs on **a time I invented in my head after meditating on tetrahedrons**. OK, so the poster is crazy. *__OR__, we are meant to believe that the poster is crazy.* (The poster is crazy.) &gt; Even for ARM. Why would you want to use clang to compile Go to run in FreeBSD on ARM? What uses ARM?… except for iOS and other mobile/tablet devices. &gt; \*I have an interest in ARM and other low power consumption architectures in the works. So you can run your tetrahedron based clocks without using up a lot of electricity? Or so you can get 10 hour battery on the iPad? OK, so it's actually just a crazy person and not an Apple engineer posing as a crazy person, but we can dream, right?
Steve Jobs was a fan of LSD. Inventing a new time after meditating on tetrahedrons doesn't seem *that* far out.
Just getting this out of the way: vikings never wore horned helmets. /pedantic
I've asked for this several times, and the answer is usually "it's the tip". There aren't any solid plans, it's going to take another year or 2 to see if Go actually takes off. So far things are looking decent. I think Google is being careful not to overcommit to Go. IMO, the only thing Go lacks now is a decent GUI binding, and maybe a little polymorphic typing. Then it's sweet flying to the top.
Yep, me too! Give me concurrency or give me death. Writing code without good concurrency support quickly becomes braindead for all but the most straightforward code. Read *any* shell script, or asynchronous code in say C, Python, or C++ and observe how often concurrency is an issue that involves hacks. Sleeps, busy-waiting, trying to get N+1 event loops to cooperate.
I noticed go doesn't have any forums currently. While I prefer the mailing list, forums provide things such as topics and categorys which make searching and asking for specific information easier. Pretty much all languages have a forum, and I would like to see go have one as well.
In my code I just json.Marshal and w.Write the output. This looks 900% more complicated. I'm not really feeling why I would want to avoid the consistency and type checking of putting the data in a proper struct, unless I need something where the structure is basically undefined.
It is an answer to a problem. With reddit, suppose I have a niche question about networking in golang usinv ipv6. There is no r/golang-networking-ipv6. So you are forced to ask in r/golang. Then you have to hope that someone who is familiar with that specific question sees it. Where as in a forum, people who like networking with golang, can just look at that particular subforum. Additionally, very difficult problems don't get lost because of a lack of upvotes or a duration of time has passed. It solves a niche problem, which are nich problems. It is also easier to search, which will help to build a good base of golang questions and answers.
And there's also [stackoverflow](http://stackoverflow.com/questions/tagged/go), with an RSS feed that sends the discussions straight to your news reader.
The forum has an RSS feed as well. One main thing is being able to have categories though. Go is way to broad to subscribe to on its own. Forum allows you to monitor things like, graphics in go, or networking in go, very easily.
Why is this marked NSFW?
It's quite trivial to make sure committed code must compile using the stricter compiler, while still allowing individuals to temporarily turn it off. edit: by trivial I mean possible to automate
By forcing users to handle errors at their source, the language itself actually helps a lot in preventing the need for something like a Chaos Monkey. However, it still sounds like it could be useful for handling different error cases. As for different modes, there's no need. The "use requirement" isn't a problem. The blog post you read is a criticism written by someone who stopped learning the language after 2 days because he didn't feel like it was the solution to his problem; many of his points are entirely invalid.
It appears to be pretty well-written, and has lots of information about all sorts of aspects about networking in Go. Network programming in Go is something I've found quite fun, personally. The language I was using most before Go started maturing (which I can't name out of fear of being disowned) was a single-threaded interpreted language, so generally if I wanted to make a TCP server for something that could handle multiple connections at once, I had to really work to make sure everything was efficient and that nothing blocked for too long. When I found Go and how I could structure a TCP server using goroutines and the likes... Man that was nice, and so much less complicated to look at/maintain, with the added bonus of nice performance increases, although I can't say I've done something yet that required performance above what the aforementioned interpreted language gave me, it is always nice to have more power and not need it than to be running at 100% and still not have enough.
A great resource. Now I know where to direct people asking me about how to do their networky stuff in Go!
Yes, either Google in Stockholm or GoStockholm will send this live via Hangouts, and also record it.
The only significant difference between this and golang-nuts is organizing threads into categories. I predict that old gophers won't participate in the forum, but newcomers will find participating in a forum much easier than participating in a group at Google Groups since they are most likely not used to Google Groups. I guess this forum has a chance to succeed with newcomers who google "golang forum" or "go forum" before getting to know golang-nuts, although I wouldn't like it to succeed. Nothing personal, I just want most of the community to be in one place, where the Go team is participating too.
Thank you - very much - for the helpful explanation, MonkeeSage. :)
&gt;It would help tremendously if there were examples for most/all standard library functions and interfaces. This might sound a little silly, but again, documenting all functions helps newbs, and more importantly, it can be used as a tool to teach idiomatic Go. There simply is no substitute for a good example that demonstrates the author's intent. Amen brother!
Turbo Pascal was 30 years ago? Daaamn!!!
I wouldn't mind a TurboPascal style GO IDE at least in the windows world... ;)
The totalArea function uses the shape interface. You didn't notice, and that's what makes go' s interfaces so cool 
 cShape := Shape(&amp;c) rShape := Shape(&amp;r) multiShape := MultiShape {[]Shape{cShape ,rShape}} fmt.Println(totalArea(multiShape.shapes...))
Thanks! Just made changes to program and it ran. Now I have to study the code and maybe find some other source for a different explanation of chapter 9 that I can more clearly understand.
Having lived with c# for longer than i care to admit, this confused me at first. Then it clicked - and wow! Yes! Powerful stuff. Ace :D
This may also help: http://en.wikipedia.org/wiki/DuckTyping http://en.wikipedia.org/wiki/DuckTyping#Structural_type_systems
Perhaps even more informative: var multiShape Shape = MultiShape{[]Shape{&amp;c, &amp;r}} fmt.Println(multiShape.area()) Warning: this code is untested, and I'm still a bit of a Go newb myself. ;)
Interfaces in brief: Things that do an action or set of actions have other actions or properties that must exist. We can work with them. I think it is better to approach the problem from a use side. As you build programs and use types, you will reach situations where you want to write functions against multiple types, because they share some common action or property. When that happens it will all click.
Scanner is an interface that is needed by the Scan function. Scan is a function that implements the Scanner interface. What. The. Fuck.
I wonder why the author made `Multishape` a struct instead of just `type Multishape []Shape`. Seems like needless complication to me.
nice idea
One day, when I have a life because I quit programming - I'll read that whole thing.
&gt; Would you guys even recommend writing web applications in go? Umm. That's one of the places where Go *shines*. What would make you think otherwise? I think it would do you some good to browse [golang.org](http://golang.org). Then you could ask more pointed questions.
got any examples of websites built using go?
Thanks for posting this. I remember reading about the introduction of gdb support, but it promptly fell out of my head because at the time I had no plans to be writing Go in the near future. But here I am, in the near future, writing Go.
When web developers talk about "real-time" they don't mean the "real-time" that other developers talk about when they say "real-time". Go is awesome for the "real-time" that web developers talk about since it's not exactly real-time at all it's just 'real-networking'. Go is less awesome at the real real-time where a 100 millisecond pause might result in bad things happening.
Someone posted on the go-nuts google groups about a commercial minecraft server that supported a thousand concurrent users. The post was just a few days ago.
erlang it is then.
How about the one in the standard library? http://play.golang.org/p/s6uAdrH_bN http://golang.org/pkg/time/#Parse
I did look at that first. As far as I can tell, you have to tell it the layout beforehand. This doesn't fit my criteria: &gt;I can just throw it some text 
So you want a magical function which can parse a date string from random/arbitrary data? Can you point to another language which has this? Also, some example data would go over a treat.
The first parser I ever wrote did exactly that. It was designed for a piece of genealogical software, and it could handle any of a list of a dozen date formats the client handed me, plus a few more I discovered on my own. It was a pretty interesting exercise. 
I don't agree. At all. There are significant gains to be made on controlling *how* data enters your system. You can simplify things like this by installing something like a date widget to insert dates, rather than a text entry field. If you're looking for a module which you can use in a number of projects then (in the context of Go) I'd just go one by one collecting some regexes or parse strings which match the data you're receiving. If there's one out there now, I don't know about it. Ask on the #go-nuts channel. Even then, something like this just asking for trouble IMHO.
What do you think a format/layout string is? It is context. You want to require context in ambiguous cases, but not when you can guess? I would never want to have to work on your code...
Which is what the Perl library did (albeit with regexes). But therein lies another point; the 'allowable' dates is arbitrary and very dependent on the application. Your solution is the best, in this case, though.
I'm a fan of both Erlang and Go, and they are both suitable for low-latency work, however due to the GC they may not be the best choice. Erlang suffers from the same problem of GC/internal scheduling that go suffers from. Erlang is nice, and you can explicitly tell it how and when to run its garbage collection however it does have other problems. I've run up erlang and go on Red Hat Enterprise Linux MRG. Taking note of the response times, I found that the Garbage collection can kick in at the inconvenient times, however this is no different than any other interpreted or garbage collected language. (The trick is to code smarter). In a perfect world with absolute control, I'd like to see goroutines be spawned as new threads on a specific CPU affinity, these CPU's being isolated from the scheduler and dedicated for this task only. Hit me up if you want to talk more about any of these options, I was going to post the same link as mrmacky already has.. its a worthwhile read. 
&gt; There are COUNTLESS better ways to retrieve dates from users other than a fucking TEXT BOX which both make things more accurate and easier to parse. I think you missed this from the parent: &gt; No one is saying "store dates as arbitrary strings in the database and then parse them when you need to use them." Parsing arbitrary date strings is useful when you don't have control over the input. (The parent even gave one such example: Wolfram Alpha.)
This is a substantially different problem set than in Java. An understanding of the rather simple GC is all it takes to write solid long running processes. There are also some very clear patterns you can stick to rather than continually creating and dropping objects within a blocking function.
I think your downvotes are because the issue cited is still present in Erlang.
Kool. This way i won't have a solution.
i thought erlang was built for realtime apps like webservers/servers etc. the hello world of erlang is writing a webserver lol.
At the moment your best bet is to setup a few regex searches and then push it into a Time object, assuming you don't have a specific parse example you want to put in. Right now the core standard library is pretty good but it doesn't have all the bells and whistles other languages have built up over the decades. Also this type of input wouldn't go into the core language since Go is a VERY exacting language and a "random input, I hope I get what I want" is a bit contrary to its goals. Go favors accuracy, exactness and being explicit over ease of use. But that doesn't mean these kinds of libs won't end up being written by 3rd party people.
That isn't what a realtime app is generally understood as. https://en.wikipedia.org/wiki/Real-time_computing Especially considering under your proposed definition PHP with a reasonable cache could be considered real time. Yes Go and Erlang would both work well for web applications.
This actually sounds pretty reasonable. It's magical so long as you don't understand it. In a lot of the cases it could unambiguously guess what the input represents, much like a human could by looking at the string. In those that it can't, it would simply return an error. There is nothing inherently wrong with "something which takes such a wide range of input like that."
Yes, but it is less than ideal. When programming, you want to create data structures that map most correctly to the problem, not data structures that please the GC the most. While it's true that more advanced garbage collectors are more difficult to understand, you'll also less likely bump into problems. This, by the way, is also one of my annoyances with Go: a part of the community tries to reshape every disadvantage of Go into an advantage. Can't we just be fair?: yes, Go's garbage collector is weak and programs that put a lot of pressure on the GC often have to be optimized to avoid long stops. It's less than ideal. But Go also has many nice properties.
If you control user input, just formalize on a specific format and then you don't have to guess. If you don't control user input, you can't "disallow" a format, you can simply fail to handle it. If you fail to handle it, what should be returned? The input string? Empty string? Error? What will your code do, as a consumer of the library, in such a case?
&gt;There are COUNTLESS better ways to retrieve dates from users other than a fucking TEXT BOX which both make things more accurate and easier to parse. None of which work when you're working with text. I would actually vastly prefer a system of date/time input where, if I just learn a few basic rules, would be able to accurately and very rapidly input time/datestamps via keyboard and be reasonably sure that the system understood what I meant. That's pretty much how we work as humans anyway: - Hey, what day is it? - oh, it's the fifth - When's the appointment? - tomorrow at two / three weeks from now - when is it and how long does it take? - it's tomorrow and it'll take 3-4 hours - when will you come back? - I'll be away for the whole next month org-mode (or probably some emacs package behind it) kinda does some of these and (if we take out the keyboard requirement) I suppose Siri etc as well in a way. At the very least, I sincerely hope that a GUI element that requires mouse navigation or touch isn't the pinnacle of our user interface technology :-(
Yeah, that's exactly how i thought about it.
Sounds impressive... I'm not at a Linux machine to give it a test at the moment, but if it works, and I'm assuming it does work since you've posted it, that's pretty cool. I'll definitely give it a good testing in a few hours once I've got access to my laptop, though.
that isn't a web server. that's using the webserver library in go. in erlang you start from the beginning. i see a different erlang webserver released on github every month. last up was elli. what will be next month's webserver.
Oh this is so totally cool. However, I'm getting a panic when I try it :-( I've [filed an issue](https://github.com/scottferg/Fergulator/issues/1).
Just **A W E S O M E**
Thanks for the bug report. Not sure what's up I run both nesstress.nes and Super Mario pretty frequently. Looks like it's in the SDL logic though, might be related to that...I'll dig in.
Oh, wow, this is nuts! How long did it take you to make this?
This is fucking awful. You're terrible. 5 stars.
Is that crowd interested in emulator development? I always just assumed they were into using emulators.
Thanks for this post. I'm glad to hear an opinion from someone with a scripting language background. I am interested in learning Go and this gives me a little more confidence.
Much better than I expected given the title. 
"One of the things go added was the run command, which does a one-shot compile-link-execute of a source file. This, combined with the speed of the compiler, means that you can effectively use Go as a scripting language." I love this part! I used to use TCC because of that feature.
tiny c compiler i believe.
Nice read, and I agree 100 percent. This has been the only review that has thoroughly captured what Go is actually about by somebody who just recently learned the language. You even correctly mention the fact that Go doesnt really try to replace C or python, but rather it aims to exist in a medium between the two. While there are many influences in Go's syntax, this is how I often describe Go to people who visit in Go's #go-nuts irc channel. Though I want to clarify that while you are correct that Go is considered a systems programming language because it has a strict type systems. The idea of a systems programming language is that you build software that is very straightforward rather than up for interpretation. Ideas like unix pipes, where you have one program/tool do work on data that can then be piped over to another as input in a systematic series is what Go is all about. An operating system is a system, but by no means it is the only system. A network of servers is where go was designed to strive in. And it does this very wonderfly when you are skilled with the language. Everything from the useful standard library providing the essential standard requirements all programmers should use, to the fact that everything has to conform to a strict understanding that you know what data this block of bits represents. This all represents the go "idiom" to encourage creating reliable, boring, and straight-forward go code because its always fun to write software, however it sucks when that software takes 5 times as long to debug because you have to somehow try to understand what somebody else was thinking about incorrectly. 
Thank you very much. Those are valuable points. About the database write, I actually did try starting a new goroutine to increase the hit count but it didn't work for me. `sh.IncHit()` vs `go sh.IncHit()`. Can you think of a reason why it might do that? The call is made from `HandleShortID` inside `web.go`.
I'm also interested in learning how golang manages connection pooling but haven't been able to find write ups on it. Please advice!
sql.DB will automatically use a connection pool. See http://golang.org/pkg/database/sql/#DB. It's just that you're recreating the sql.DB in every request, so the pool isn't being utilized. Consider having a global *sql.DB that you use from every request. Here is a possible design. In web.go, refactor your handlers to do basic parsing from the http request, immediately call another function that does the actual work, and serialize the returned value to the ResponseWriter. Have these 'work functions' take a parameter of type ShawtieStore which is an interface with all the methods you require. GetOrCreate, GetByID, etc. Then, implement a "real" version of ShawtieStore using a struct that has a *sql.DB and perhaps a *memcache.Client as field members. You would implement all the required methods for this type to make it match the interface you defined. Keep a global variable of type ShawtieStore and initialize it in your main or in an init function to this real version. When calling all of your "work functions", have them pass this global variable. For testing, you can implement a test version of ShawtieStore that does everything in memory, perhaps using a map to store URLs, and test your work functions using that fake implementation. There are other designs that involve implementing http.Handler, and having your ShawtieStore inside your type that avoid having a global variable, and will allow you to test your http parsing code, but this is a good place to start.
I'm not sure why that wouldn't work. But you could just do it synchronously after you do the redirect. i.e. just move that call down a few lines.
Cool stuff! It's nice to see another emulator written in Go after [gospeccy](https://github.com/remogatto/gospeccy) (a ZX Spectrum 48k emulator).
Exactly...
this is very interesting to me. would you mind sharing any resources you used in learning the language that allowed you to use it in this way?
&gt; rsync, grep, webservers, etc. Most mainstream languages nowadays can be used to write those, as such, most mainstream languages are "systems languages". As for the languages used to write OS on, there are operating systems written in systems languages that are GC enabled. For example Oberon, http://ignorethecode.net/blog/2009/04/22/oberon/ But since none of those operating systems power joe and jane's desktops, people tend to think it is not possible to do so. With the trend of adding reference counting to mainstream systems languages (Objective-C, C++, Ada and Delphi), this will eventually become part of more known operating systems. Lets also see how Rust, D and Go evolve. 
I don't know about Kealper, but the official docs really helped me. 
And interface in simplest term is a stand in type. You define a set of methods that a user defined type must implement for it to be passed in that context. When it is passed in, the objects type is the interface type until you assert its type. x, ok := yourTypeMaskedAsInterface.(typeToCheckAgainst) http://golang.org/ref/spec#Type_assertions Interfaces allows you to reduce the amount of redundant code that will be written and is a form of polymorphism. Go isnt a class/inheritance based language, but it has features that provide the same sort of convienence. 
I like the article but a point sounds off : &gt; There are no database drivers in the standard library, only a standard API for any given database driver. Given that you just have to change a line in your code when you want to use another driver and that the Go install system makes the rest of the work, I'd say this complaint is strange. If you don't want a persistence framework but just a database driver, [it's hard to beat the simplicity of Go](http://stackoverflow.com/q/11353679/263525). I wouldn't want to have the Go team make the specific database drivers. 
I wrote [go-api](https://github.com/dpapathanasiou/go-api) with that in mind, and I'm using it for a new alpha project. Like you, though, I'm still fairly new to Go, so you might be better off with goweb or seriesly for more heavy-duty use.
 // is this safe/atomic or does it need to go through a channel? qCounter++ If multiple threads hit it, I think it need to be made atomic. From reading the memory model document, it sounds like it could especially be trouble on a 32-bit machine since qCounter is a uint64. A quick and dirty way around it is AddUint64() in sync/atomic: http://golang.org/pkg/sync/atomic/#AddUint64 but it could still be racy where you output qCounter, if that matters. Disclaimer: I am a Go beginner, so I am still wrong about a great many things. [edit: fix variable names]
&gt; but it could still be racy where you output qCounter, if that matters. I believe that `print`, `println` and `fmt.Print*` functions will interleave output, but the `log` package will not. &gt; Disclaimer: I am a Go beginner, so I am still wrong about a great many things. From what I can tell, you're right. `qCounter++` is absolutely not atomic.
Results are [here](http://geo.bitnames.com). tl;dr is that Perl is good for loads of &lt;200 lookups/sec while go has been seen at 5,000-6,000 per second
I must admit, I do like seeing all these places admitting that they're porting some tasks out to Go. Especially when they're pretty high-traffic places such as bit.ly and such; It really shows that Go is maturing and is becoming a viable, higher-performance replacement to things that used to be dominated by Python or Ruby.
You don't need to use CAS/mutexes if you're just sharing it with many threads, but you do need sync/atomic, a mutex, or a channel, if you want to be in-any-way confident that goroutines will observe changes you make, e.g. incrementing an integer.
&gt; can't say I'm not surprised Uh...
I had two thoughts when reading this. The first was, wow they wrote a go DNS server, awesome! The second was, holy shit! I can't believe their old DNS server was written in Perl.
Can you expand on what 386 issues you had?
But you can handle it in a function. Have you looked at the code written by Pike/Cox? Some elegant solutions there.
Your interface could demand an error function specific to each type passed to it, alleviating the burden of reflection and type casting from the interface itself...
That didn't make any sense. What do you mean?
&gt;The code your calling doesn't list the proper error types. That is the Problem. Allowing bad code is not the problem.
Nope, still not making sense.
This is a great comment, sagan bless you! You're a beautiful person. 
Arguably so between go and python, but C++ RAII is undeniably safer and more elegant.
Nice layout of the description and code.
Very cool!
Seems to be fixed now. (I sent a pull request for that earlier today.)
Calling Go functions from a scripting language is pretty much what I've been looking for. Yay for scripting.
Yes. A go-based Tcl would be a very productive combination.
Yes, the whole goal was to get something you could just "go get" and be up and running. otto currently passes most of underscore's tests (the ones not requiring jQuery and a DOM environment, anyway). One limitation so far, is that Go's regular expression library is not as expressive as JavaScript's, because it doesn't allow lookahead/lookbehind. I'm currently trying to figure out a fix.
(Author here). I totally agree on this - this really confused me when I was learning Go. I definitely hope to cover these topics on Go by Example.
This is impressive. I wonder why did you chose not to use goyacc? 
Another minor typo &gt; Tickers use a similar mechanism to timers: a chanel that is sent values. Chanel -&gt; Channel
Using tables makes it impossible to easily copy and paste the code.
Not to take away from the excellent otto, but you might want to take a look at `nodelint`: * [https://github.com/tav/nodelint](https://github.com/tav/nodelint) It lets you run JSLint from the command line and is fully configurable with custom reporters. Disclaimer: I originally wrote nodelint a few years ago.
Wow! How does the rendering work?
It is using OpenGL through GLFW right now. I am writing a native go windowing library called glif, so there won't be any external dependencies developers and end users need to worry about in the future. 
Nice!
&gt; I am writing a native go windowing library called glif Mind expanding on this a bit? Is it something that replaces X? Something that replaces OpenGL completely?
It is a drop-in replacement for glfw. Actually, the proof of concept is being developed on linux using your xgb library. So it does have dependencies, just hopefully ones a user would already have installed. 
This looks exciting!
Ah nice! I know embarrassingly little about OpenGL. Have you considered Wayland yet? From my adventures a few months ago, the future of Go and Wayland does not look too bright. Mostly because EGL is the tool of choice to do hardware compositing in Wayland servers/clients, but unfortunately, to use EGL you have to link it against the libwayland library. Which makes a pure Go library rather difficult... Do you think your glif library might help this situation?
Have you considered porting V8 Irregex to Go? I've never looked at the code but my guess is it might be easier than PCRE.
&gt; So it does have dependencies, just hopefully ones a user would already have installed. Oh yes please, that would make life so much easier.
Physics are little slow, I'm waiting for better float optimization on 32bit (also Matrix uptades are slow too). And for some reason functions calls/loops are a little bit slow too so I had to inline couple of them. But the good side is that I'm really enjoying programming the game/engine in Go and I never finished a game before. :)
Good job. I have never been more terrified of cookies in my life!
Good night, sweet prince.
That's really sad to hear. I recall reading posts of his years ago that were a lone voice in the wilderness still advancing the philosophy of simplicity-in-implementation and the unix-way. He detested the fads and fashions of computer science. I'll always associate his worldview with the "harmful stuff" page on cat-v.org. Perhaps his pragmatic philosophy will be vindicated if go takes off.
I'm so sad to hear. He was always working hard to get the good word out on Go, and was one of the first people I communicated with when I jumped head first into the Go world. I'll remember his friendliness, and as a tribute, I'll try to return the favor to other newcomers to Go.
Nothing on his google+ :-/
No time to trace the error down now, but got this: go get -u github.com/banthar/gl # github.com/banthar/gl gl.go:6:21: error: GL/glew.h: No such file or directory Appreciated if anyone knows the quick fix, if not I'll figure it out on my own eventually. 
Can someone confirm this? I don't think we want incorrect news to spread through these forums.
RIP
FWIW, I got it. :)
something similar can be done with gcc's attribute __cleanup__ as well...
very sad news
Feel free to jump in and send some pull requests. It started as a port of libtcod, and so there are still a lot of rough edges on stuff like path finding, field of vision, and...well... all the things that are specific to roguelikes and not rendering colorful @'s and #'s. The README lists other areas that need work. I have some ideas on how to iterate and innovate the library, and I'm sure other people do too. Have fun! I'm working on adding some generative audio in prep for a game jam in my town this weekend.
How do you mean? Could you throw up an example on pastebin? I tried it every which way I could think of, but there was no getting around the type requirements when actually invoking the query.
Why would you use pastebin instead of http://play.golang.org/ here? No ads, and it runs your Go code. The append built-in is specified here: http://golang.org/pkg/builtin/#append And here: http://golang.org/ref/spec#Appending_and_copying_slices And here: http://golang.org/doc/effective_go.html#append 
I didn't think about it. I updated to use golang playground. I have read the documentation on append. since the v array starts at 0 size and continues to grow, append() should return a new array, right?
Not necessarily. Think in the case of: a = make([]T, 0, 100) Where you allocate 100 capacity, but set the "length" of the slice to 0. append in this case should use the same internal array, just using more and more of the adjacent memory.
append may (does) over-allocate. Even though you're appending one item each time, if the slice doesn't have enough capacity, its capacity may be grown to exceed what is immediately required. In the current implementation, it's doubled each time. http://play.golang.org/p/rVDrs0atjc
`append` has some pitfalls. Think about it as `C++`'s `vector.push_back`. In fact, Go in this case mixes the concept of what usually called `StringPiece` (immutable reference to a piece of memory), and `std::vector` (auto-expandable array, who takes care for moving its content). Generally speaking, there's a little reason to write something other than x = append(x, ...) // that's what you usually want //BAD IDEA usually: y = append(x, ...) See my [humble slides](https://docs.google.com/presentation/d/1R4qlqe6Kj1nvvJEx-L7opZxPcfAkwxVdas_cmRzf6ME/present#slide=id.g247fa90e_1_16) about this very topic.
This is the first time i haven't assigned an append back to itself, so this is the first time i'm encountering one of the pitfalls. Thanks for the help!
I'm not sure anything provides a better discussion and explanation than this [golang blog entry on go slices usage and internals](http://blog.golang.org/2011/01/go-slices-usage-and-internals.html) (http://blog.golang.org/2011/01/go-slices-usage-and-internals.html)
I'll take a look, I was looking at Joni (oniguruma in Java) the other day.
I thought i had read most of the golang blog posts. I hadn't read that one. Thanks. It was a nice read. I should go back and read everything again now that i'm starting to actually develop in go. I have followed the language since the day it was released, but not been deeply involved.
What are my options for making this a bit more generic? I.e. I define something like: func time(f func() error) error { defer timeTrack(...) e := f() return e } I could leave it at this and close around my target functions: f := func() error { int, e := ioOperation(fd) //do something clever with return value. channel? } time(f); Or should I perhaps take a type-safe, but more verbose, approach? type timedIntFunc func() int, error func timeIntFunc(f timedIntFunc) int, error { defer timeTrack(...) i, err := f() return i, err } Just curious about idiomatic expression of this sort of thing.
Just as a note, one can use Go's websocket support via the code.google.com/p/go.net/websocket package. Docs are accessible via http://go.pkgdoc.org/code.google.com/p/go.net/websocket
Please, don't increase the size by a factor of 2, [it's mathematically proven to be the worst factor possible](https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#memory-handling) *Edit:* typos
Interesting read, thanks!
(plug etc) See also: https://github.com/jmoiron/jsonq
I'm not sure if this kind of actor model is idiomatic Go but there's nothing wrong in that implementation. You could return a channel instead of the actual variable though. (However, don't overcomplicate things if there's no benefit to it!) Usage: value := &lt;-GetNumNeighbors() or ch := GetNumNeighbors() // Do something while GetNumNeigbors does processing, // I/O or something else value := &lt;-ch
Nice. Good example of using wait groups, plus you are showing that the producer of data should be closing the channel, and never the receiver. If the receiver closes the channel and the producer tries to send to a closed channel, you get a panic.
He was 30. [This](http://www.reddit.com/r/programming/comments/11h7ab/9fans_uriel_has_passed_away/c6mg9uc) and [this](http://www.reddit.com/r/programming/comments/11h7ab/9fans_uriel_has_passed_away/c6mqfmn) should clarify how he died. 
tl;dr -- [go-pkg-xmlx](http://github.com/jteeuwen/go-pkg-xmlx) ;)
Well the recent updates to gokogiri have been to add more features rather than bugfixes, but I suppose that is potentially a fair point. Still, I like to see some active development of some kind :P
Sad news, everyone!
I actually really enjoyed this. Thanks! :-)
Every goroutine has a 4KB stack associated with it. Hundreds of thousands of goroutines seems a bad idea to me for this. 
Really? 390 MB is pretty small by today's standards.
This is just further proof that Go as a language is dying. Everyone head back to Python; nothing to see here.
Yeah I feel the same, I follow all Go channels, but golang-weekly was really useful as reminder and in cases when I missed something. I'm liking your idea! :)
[time.Ticker](http://golang.org/pkg/time/#Ticker) is exactly this.
you can try golang.org/pkg/time ticker := time.NewTicker(time.Second * 1) for { &lt;- ticker.C //do something }
&gt; Great job! I was playing with this a bit last night. I'll have more specific comments once I dive into it a little more Thanks! Don't hesitate to [file an issue](https://github.com/BurntSushi/wingo/issues?state=open) if you find something wrong or want to request a feature. &gt; but at first glance this looks like the kind of window manager I've been craving for a while You and me both :P
As was already posted, this is the exact functionality of time.Ticker. To answer your original question, though, there's no need to use select to receive from your ticker. You can just do: _, closed := &lt;- intv if closed { break } The receive will block until a value is available once a second. If channel is closed somewhere else, the receive will return and closed will be set to true. That's when you break out of the loop. I hope that helps. Edit: for reference: [Receive operator](http://golang.org/ref/spec#Receive_operator)
Yes, the performance went from not-enough to more than I needed, so that was good. I don't know if I enjoyed it more than Perl, but I had a good (and productive) time learning Go. The result was relatively bug-free, which was nice too (I think I only fixed one bug after deploying it fully in production). You can't really compare the implementation speed. As someone else pointed out it was much more work to over time bit by bit develop the old implementation as needs and ideas came up. Doing the Go implementation was not just working in a well known domain but essentially porting a program line by line (or at least function by function) with the benefits of hindsight and a well known input and output. For what it's worth the programs are of similar length (the Go version is ~30% longer, with slightly less but different features).
I don't care if other goroutines get it quite at the right time, just that the increments (mostly) don't get lost. Hmn. I'll make a ticket: https://github.com/abh/geodns/issues/19
The data structures it loads from the configuration files take about 15-20MB memory. Occasional/randomly the server will (on 32-bit only) get into a state where it never/rarely garbage collects this, so it quickly gets to using a lot of memory considering that some of the servers just have 256 or 512MB memory. Most of the DNS servers are hosted by volunteers: http://www.pool.ntp.org/dns-server.html
Thanks!
Note that this obviously can't work for anonymous functions. http://play.golang.org/p/wzyneNrfUb 
And with gokogiri (or nokogiri if you aren't using Go) you can reach a desired subset with xpath and the simply walk over the relevant parts, or even further use xpath to pick relevant pieces out of that subset.
Well, [it does](http://play.golang.org/p/HV9hSv4J-6), and it gives you the anonymous name of: main._func_002 main._func_001
See runtime.Caller and runtime.FuncForPC 
Okay, that wouldn't be good if I want to keep track of how much work they're doing. I will fix it before making the system use multiple CPUs then.
There's a bug in your Go code. Change the buffer to be 1 byte in length to illustrate the problem. why hello there -&gt; WHY HELLO THERE You need to check that the buffer is on a word boundary or not. If not (i.e. we're in the middle of a word, spanning two buffers), then you'd have to scan until you find a new word boundary before title-casing again.
True, nice catch — every 4000th or so character may be capitalized incorrectly. The other language versions avoid this issue by simply loading the entire file into memory first.
To the curator: Thanks for your work while it lasted. You don't have time, we understand. Good luck with the new stuff. To people getting all sentimental over it, it would take about 30 minutes to duplicate the functionality and service provided by golangweekly. Yeah it was a good mix of stuff from reddit, the list and g+, but nothing that can't be done via a free microblogging site and automated posts to a stream. Or something you can't find if you spend a little bit of time perusing the Go ecosystem for that matter. tag tag tag share share share. It's not that hard really. And creating pages served by go to serve one html page on GAE is just over-kill, redundant and NOT necessary. What's wrong with tumblr or any other microblogging service for something so simple? make a facebook or g+ page and go nuts. literally.
Here's the client I'm currently using: c := http.Client{ Transport: &amp;http.Transport{ Dial: func(netw, addr string) (net.Conn, error) { deadline := time.Now().Add(25 * time.Second) c, err := net.DialTimeout(netw, addr, time.Second*20) if err != nil { return nil, err } c.SetDeadline(deadline) return c, nil }, }, }
I'm cynical at the best of times, doubly so when I'm reading code that's written for performance comparisons, since you need to be comparing code that has the same behaviour for the comparison to be meaningful. It kinda just jumped out at me. Turns out I was being pedantic, since the performance profile doesn't change much even when catering for words spanning buffers. (@reddit wtf mate, stop eating my comments)
I'd much rather set it to 9001. On a more serious note: I know I can change the ulimit, but that feels like cheating. What if I were making a product for distribution to users that don't have access to that command? This *is* a bug, as far as I am concerned. Timedout connections should be closed, and the timeout duration should be able to be set more efficiently. Though I would like to see if there is an alternative approach for the closed connection bug.
I saw on that blog post that Go was roughly half the speed of C. Could this be because Go handles Unicode?
This is http://code.google.com/p/go/issues/detail?id=2631
It's not a bug as far as I'm concerned. If a connection times out you need to close it. It's no different than BSD sockets.
The bug is that I do close it, but the fd isn't freed.
Well damn, so it is a bug and not something I'm doing wrong. How much longer until Go1.1 do you think?
I think you should avoid the error by using `bufio` to read one line at a time. Of course, if you end up with a file that's all one line, you won't be much more efficient than just reading it all in, but it seems like a decent compromise. 