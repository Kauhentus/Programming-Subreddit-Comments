###[Here's your Reddit Silver, everdev!](http://i.imgur.com/x0jw93q.png "Reddit Silver") *** /u/everdev has received silver 1 time. (given by /u/jackmcmorrow) __[info](http://reddit.com/r/RedditSilverRobot)__
If the client side can control the output, and by doing so cause performance and overhead issues, that’s an entirely separate problem.
Right, that used to be the case. IIRC, I saw a commit which changed that.
What? Thats awesome. I love this feature.
App Engine is notoriously always behind on the Go version. You'll just have to wait for them to update it, or do a more traditional setup (or, write your code with 1.8 in mind).
Looks like a better and cleaner version of https://github.com/shurcooL/go-goon. They're both based on spew, and have the goal to emit valid Go literal code that compiles and reconstructs the original Go value.
I don't know why it says 1.8 on GAE Flexible. It just runs Docker images, so you can use whatever version of Go you want. GAE Standard however is always behind the curve.
I had a peek into the source code and found that both Start() and Run() call the function [run()](https://github.com/robfig/cron/blob/736158dc09e10f1911ca3a1e1b01f11b566ce5db/cron.go#L170) *that goes into an infinte loop.* So it seems that your binary needs to stay up and running as long as any scheduling shall take place.
Ok, let's say you look at this code after a year, would you still be able to "know" what it does? I would suggest to write inline documentation, or at least some useful comments. Some functions have been split up too much, and some need to be split up (like the "processLink" does 2 things). And for the first attempt, I rate this an 8 :-), now go on, and make it a 10 :-)
Thank you! True lifesaver!!
Yea, so that was why I was thinking to make it a daemon process. Do they not run until activated or something? I was thinking if I just threw an infinite loop after all my argument checks it would pick up the cron job and wait until the time passed, but that didnt seem to work :( 
The GAE flexible environment lets you specify a Dockerfile, and they'll automatically build it into an image and deploy it onto VMs. This is much more flexible than the standard environment. The downside is this is more expensive because you have to pay for a whole VM. They have a few premade Dockerfiles that you can use (their tutorials assume you are using one of these) - they are totally fine and safe to use, but they can get a little behind because a Google Engineer has to actually go in and update the Dockerfile. For most people, 6 weeks is not enough time to vet a new version of a language. There have already been a few hot fixes and security updates post-release. So unless you absolutely require Go 1.9 for something, you should just use Go 1.8 - that way, you don't have to do any custom stuff like modifying the GAE Dockerfile, and you can automatically upgrade to Go 1.9 when Google feels it's safe. The whole point of GAE is to let you focus on developing your app and less on chasing down random infrastructure bugs and security problems, so just take a deep breath and let them manage things for you. :)
I strongly disagree. I don't want `build` to do any more than compile, or your build process will have hidden magic like your CI silently using different dependency versions from your developers.
You don't need to explicitly name the models package after importing it It's usually better to avoid having multiple files in a package, mainly because once they are combined, it's really hard to pull them apart, and it's really easy to accidentally use a constant or variable defined in another file in the package. The Go stdlib mushes files together like this frequently, but they usually are very specific about what they put in each file. For example, the http package has a file that just has all the HTTP status codes in it. But having functions and other more complex things like that in multiple files can make life really difficult. Honestly, for your use case I probably wouldn't even put all those types into a separate package - but that's just me. models should be named model to be more consistent with package naming conventions. Your doc comments don't always follow the recommended format. (It's nitpicky, but I thought I'd let you know; I think the go linter would probably catch those errors). Many Go projects that produce binaries will have a "cmd" directory containing packages with all the `func main()`'s and a "pkg" directory containing packages with reusable or refactored code. If you Google around you can probably find a few posts on the subject. Everybody has their own thoughts on the right way to organize Go code, but I do find that putting files with `func main` in separate directories can make it much easier to figure out how the codebase works. Also, I personally really don't like putting Go files in the root of a repo, but again that's personal preference and doesn't really matter for a project this small.
The packages database/sql and jmoiron/sqlx support query parameters or named parameters (sqlx) which will escape any value that you pass to it. In terms of field names and table names, I would suggest you to validate inputs. Never trust user input. You can either create a slice with all the valid field inputs, or if you really don't want do to that by hand, you can retrieve the column names for a specific table from `INFORMATION_SCHEMA` table space (mysql, pgsql), or issue a `desc [table]` to get pretty much the same thing. You can then match any query inputs to actual database schema and reject any that reference non-existing tables or fields.
Good point!
There's also https://godoc.org/github.com/kr/pretty
Thanks for your reply, makes sense :)
&gt; some alternative solution
This makes operating / maintaining the compiler a lot more simple. The compiler doesn't need to be aware of how to get the source code, it just needs to have it in GOPATH. Think of the case you would like to use your own fork/mirror of a package but the compiler sees the import statement and goes to fetch that package from the original location.
The daemon package clearly lacks a useful description, but the code example seems to indicate that the Manage() method is intended to do the daemon work (in an infinite loop) if the binary is invoked with no args. In your code, Manage() simply exits if there are no args, maybe this is the problem?
It looks like this might be more related to `autocrlf` settings in Git. Given the warning message you are receiving it looks like it's to do with `autocrlf` being set to `input`. Maybe you either set it to true, or false. `false` will remove any chance of warnings, `true` will only warn you if you try to commit something with LF line endings. I'd also recommend using [editorconfig](http://editorconfig.org/) if you're not already, as it will really help ensure your team is consistent with this kind of thing.
This is fantastic. The only thing missing for me would be for `Dump()` to take in a `...interface{}` like spew does, so I can quickly output multiple things without having to write separate statements, that would be really awesome!
Try this: `go get -u github.com/posener/complete/gocomplete` `gocomplete -install`
&gt; go get -u github.com/posener/complete/gocomplete well, thank you. this gives me the options, but not the help lines. better than what I had anyway. thanks. 
Thanks for these, very valuable info
Makes a lot of sense, thanks for the feedback!
I work at Dgraph, the company behind badger. One of the things badgers design is optimised for (other than speed) is reduced write amplification. This is important when running on SSDs (excessive write amplification causes premature wear to the disks). There's not really any drawback to running badger on spinning disks, other than the normal speed reduction (in general) between SSDs and and spinning disks.
You just don't do it. Seriously. Don't think in terms of SQL query, think about implementing a feature that allows accessing said data.
If you're interested in using Sublime Text, have a look at my [blog post](https://medium.com/@arshamshirvani/super-charge-your-sublime-text-for-golang-development-3239d9c376bb) about how to set it up for go development.
[removed]
Honestly, it looks a little bit like it is - but even still, Go _is_ quite a verbose language. But that is one of it's strengths. I took a deep look into these "concise" languages like Scala for example, and I came to the conclusion when I returned to Go (even after initially not liking the verbosity of Go and actually trying to seek out these more concise, modern languages like Scala) that all of that conciseness can come with a great cost. Go is more verbose, but that helps it a few ways; it's trivial for new developers to pick it up and run with it, it's easy to read existing code, and other people's code (and the standard library's code), and it helps keep the language simpler which makes keeping the tooling top notch great. Scala again is another example of a language where the complexity of the language itself has hurt the tooling a _lot_ (e.g. extremely slow compile times, limited tool support, and limited willingness and ability to actually write new tooling for it).
Yes, it is contrived. He's comparing a snippet to an entire poorly written Go program. I don't think you could get down to the same lines of code as Perl but you could easily half that size. Go is generally considered to be more terse than Java and C++, so the fact this his examples don't illustrate that suggest he is doing something wrong. The readability and writability of languages are usually a seesaw where improving one hurt the other. Language designers have to try to find a balance. It's honestly more a matter of your taste and time investment. Languages that are terse usually require more time on your part to get comfortable but can sometimes become more productive. I like Go's balance and think it suits my style so it's my language of choice.
Am I blind or is it missing a license? Looks interesting otherwise! 
Its fine, but pointless as bytes.Buffer is in the standard library.
bytes.Buffer does not implement io.WriteSeeker
right. I've filed https://github.com/as/frame/issues/23
The example is contrived, and could easily be reduced by 30% with a naive refactor. But I wanted to be explicit, so I tracked down the slides from the comments, and came up with this: This is the starting version: - slides: https://www.slideshare.net/Ovid/perl-6-for-mere-mortals - slide 76 for Go - source: https://play.golang.org/p/1-JDgkIvWl - SLOC 56, not counting main but counting whitespace between functions. What the author did in `java` (slide 72) was: public double GetX() { return this.x; } Which is valid syntax in Go too (gofmt doesn't expand this). And so we come to SLOC 51 (39 without whitespace/imports), [playground link](https://play.golang.org/p/kZ3PUw4TLc). Note: I didn't modify `String()` or `IsValid` as well, that's low hanging fruit for later. Before we continue, I would like to fix the original `Set*` functions, as they didn't modify the point value. The java example does. The java example also doesn't return the previous value, so I'll keep the same semantics, returning just the error. SLOC stays the same: [playground link](https://play.golang.org/p/F7-o6xkq58). The function `IsValid` can also be reduced to a oneliner (directly return the boolean expression in the if-clause). Reduced to SLOC 48: [playground link](https://play.golang.org/p/X1W0N1Zy6j). We can use `Set*` now from `NewPoint` which the author didn't. We can also use named returns, which don't really modify the output that much, since we could/should still return nil for *Point. Unless we needn't? Anyway, we are still stuck at SLOC 48 - [playground link](https://play.golang.org/p/4Tr6L3O4Z8). Looking at other examples (C++) we can see that they are also structured differently. The returned error comes from the validation `constrain()` function. And looking at the Java constructor, we could also similarly modify our NewPoint. I mean sure, panicking would be less verbose, but we should handle those errors. Next: I modified SetX to return the original *Point, not adding any SLOC. They now return nil in case of an error. Due to savings in NewPoint, we reduce the code down to SLOC 45. [playground link](https://play.golang.org/p/ly9siIA4RQ). This is just about the limit of where you can go without being even more inventive. Cleaned up the low hanging fruit and ended up with 39 lines of code (28 without whitespace/imports) - [playground link](https://play.golang.org/p/iBEvv_T3xY). So, the results? -23.5% reduction of lines, -28% reduction not counting whitespace. The biggest issue in reducing this further is finding a pattern to reuse. 1. Both SetX and SetY have some common code, which is intertwined with `isValid`. You could reduce each by one line, but need to expand isValid to return the original float value and a declared return error (can't use bool, can't use `:=` short decl because we still need to write to p.x, example: func (p *Point) SetX(x float64) (px *Point, err error) { if p.x, err = p.isValid(x); err != nil { return nil, errors.New("Point X out of range!") } return p, nil } 2. NewPoint imho shows the most acute defect about Go as a language, and it doesn't have anything to do with generics. There no simple way to chain execution of multiple functions, to set values from an if clause, and break out of the execution flow if any of them may return an error. Picking some other language, you could do something like this (adapted for go semantics): if ( ( err = func1(); err != nil) || ( err = func2(); err != nil) || ( err = func3(); err != nil) ) { return err } The idea behind such a clause is that execution would break out as soon as a clause would evaluate to false. With Go however, the verbosity increases almost 4x in this particular case: var err error err = func1() if err != nil { return err } err = func2() if err != nil { return err } err = func3() if err != nil { return err } But, what can you do? ;) P.s. check out my blog https://scene-si.org if you liked the above comment. Doesn't hurt to get a few extra readers :)
https://github.com/golang/go/issues/21592
Golang's syntax is not verbose. Look at the horizontal vs vertical alignment for his programs. Languages that encourage horizontal code tend to discourage validation which leads to errors. Go's mantra is readability and explicit error handling. I doubt the programs he wrote for other languages bothered to check for errors. Therefore, a valid side-by-side comparison would set every error to underscore. verbose: public class foo { public static void main(string args, int argc){ System.out.println("foo"); } } terse: package main import "fmt" func main(){ fmt.Println("foo") } more terse: #!/bin/bash echo foo
Definitely no need to create a `func String()`, but seems he did more than just one thing wrong anyway, since SetX and SetY don't actually set anything. Or how he's not using them from NewPoint (as he did in Java). I gave a stab at optimizing this tire fire in a comment below :)
Thanks for the link. The issue references https://github.com/orcaman/writerseeker which is very similar to my implementation except the Read() method doesn't update the position.
There's difference between interfacing C from Javascript… and interfacing Javascript from, say, Python, over a C interface. In the former case, you can let the JS runtime handle garbage collection for all of its stuff, and manually manage the rest. But when you have garbage collected runtimes on both ends that think their main loop is the only active one, things get… interesting. I suppose you can get it to work, but it's not something I'm in any rush to try out myself.
I wrote mostly Perl from the late 90's to the early 00's. The obsession with conciseness has always been there (eg, Perl "golf" competitions). The result is Perl's reputation as a "write-only" language or "executable line noise". Not entirely deserved (there is good Perl code out there), but it didn't come out of a vacuum. Yes, you can pretty much always write a given program in fewer lines of Perl than Go, but I'd pretty much always take the Go program over the equivalent Perl if it's something that I'm going to have to maintain over time or collaborate on with other developers (not even getting into performance, concurrency, or deployment complexity). (maybe Perl 6 is radically different. I haven't really looked at it yet. I got tired of hearing about how great it was going to be when Perl 6 came out... back when I was still working in Perl every day).
&gt; where the complexity of the language itself has hurt the tooling a lot (e.g. extremely slow compile times, limited tool support, and limited willingness and ability to actually write new tooling for it). Can you expand on that? I'm pretty sure scala has superior IDEs, build tools, dependency managers and a much richer ecosystem than go can ever hope for. Slow compile time? Did you know that you don't need clean compilation every time? In practice, scala programmers barely use compilation because the IDE with the help of the typesystem catch a lot of possible bugs and incorrect API usages without wasting time with useless/obvious UTs. They don't need to resort to shitty "error-handling" mechanics like `if err != nil` to catch errors. They don't generate code with external tools or to use dynamic constructs in a static language due to poor compiler and language design. Go being verbose is not your worst problem - your community being delusional is. Stop pretending that you've good tooling because golang is just an average-joe in the industry. I've programmed in a lot of languages so far and golang and its tooling are nowhere near impressive or ok. Is it better than PHP to create webapps? What an achievement! You might as well start to congratulate each other for being gophers! Are you proud about the tooling? Then don't be because **you need fix the way you manage dependencies.** Do you know how many issues your language cause where I work at? Just before I started to come home from work *today* I got a bug report because one of our modules often fails to compile because of an indirect gopher module dependency - and we got the blame! How unprofessional you need to be to download dependencies from github and google? Yeah, just let's make a dependency-docker-container for every go module because some beginners were too lazy to learn a normal programming language. \s You gophers always choose the mindless with a lot of bad consequences because you barely have any experience with programming languages and when you receive critiques you'll just point to docker like it's some kind of a proof. You need to improve your game because **in practice, go and its tooling are cancer.**
&gt; The readability and writability of languages are usually a seesaw where improving one hurt the other... ...if your language designer has no experience with programming besides writing some toy apps in C and Perl...
Excellent suggestion, thanks. I've implemented this.
Anyone knows if the `gta` tool mentioned in the article is open-sourced?
Not yet, but there's no reason it shouldn't be. I'll see if Fatih and I can get that rolling.
50 and 48 are the values of the codepoints of '2' and '0'. Example: https://play.golang.org/p/LgyuvYzKW2
Ok. Thank you.
protip: never drop the error, even in examples. I can't tell you how many times I've done that and regretted it when I did something dumb. Just throw a `if err != nil { log.Fatal(err) }` in there for kicks. It'll save you a headache one day.
&gt;I doubt the programs he wrote for other languages bothered to check for errors. From [the slides of the presentation](https://www.slideshare.net/Ovid/perl-6-for-mere-mortals) you can actually see that all the other examples provide the same error handling and constraints. 
Hey. Are you just here to rant about how terrible you think Go is?
What did the prev. guy said again? Don't be hypocrites. My concerns are legal and represent real-world experiences not just "I've tried this and it's not my fancy".
No, they're the same level of completeness — the definition of the point type, without any code to exercise it. There's no main in the Go example, it won't do anything.
this is good advice. if you want to make it slightly less of a pain for throwaway scripts, just have a function like func check(err error) { if(err != nil) { log.Fatal(err) } }
I stand corrected!
Amazing! However I'm a bit confused by the fact you passed it through the Config object? Why use `litter.Config.Dump()` instead of simply `litter.Dump()`? 
The point isn't *conciseness* though. It isn't "OMG my code is shorter, so it's better". It's "look at all the work you need to do to be correct." If you don't write this much code, you're allowing your type to admit invalid values, which will wait until the worst moment to break. If you don't *know* that you need to check things this way, too bad, you lose. If you *do* know, but make a mistake like getting so distracted by enforcing constraints in your setter that you forget to actually set the value (as [Ovid actually did](https://www.reddit.com/r/golang/comments/75ol0g/contrived_go_comparison/do7u8nx/) in the Go example), then you're screwed too — you get code that builds, but has bugs. But every line of code that you don't have to write is a line of code that you don't get an opportunity to make a mistake in. I hate the Point class, because a terrible example of OO — it has no worthwhile behavior, and objects are supposed to be units of behavior, not bags of data. But in this case, it kind of works, because the point is that you should only be looking at the code that makes a type's behavior unique, and since our example has basically no unique behavior, it should also have basically no code. The idea of "it has a constructor, that accepts certain params, validates them according to certain rules, and puts them in its own state" should be bedrock. It just means that you work the same as everything else, so there's no need to draw attention to it, and no need to lead the computer step-by-step through the process.
**What’s inside?** * What is a typed and untyped constant * Default and ideal types * High-precision calculations * Flexible expressions * Scopes and shadowing * Benefits of constants 
&gt;I know Go is somewhat verbose. However, you can't read the code on the video. Is there an experienced gopher who can clarify? Is this example somewhat contrived? Or is Go really that wordy? Go proper is quite verbose due to its lack of generics. The approach most people take seems to be code generation which has some problems. I think comparing Go/Perl is more for educational value than anything else. There aren't many cases where "should I use Perl or should I use Go?" is a productive question.
Is this command-line, web oriented, or GUI oriented? There are a number of [console-based progress bars](https://godoc.org/?q=progress). You'd have to do some adapting based on the results but it would be feasible. If it's web, I don't see anything on godoc for that. Because of the incredible diversity of web tech stacks I wouldn't expect anything off the shelf. If it's GUI, well, which one?
Mostly as an API, I need some solution to a website file uploader. I found one that would upload to S3 and do some minifications, etc, but it's not what I need. 
As you write to io.Writer, simply count the bytes written. To cancel hit control c.
`litter.Dump()` is the same as `litter.Config.Dump()`, and `litter.Config` is the global mutable configuration that contains defaults. Changing that will obviously affect the entire program, so changing it is really not encouraged except for quick scripts. If you want to override any of the defaults, you should create your own config instance: var lit = litter.Options{ StripPackageNames: true, Separator: "\n", } // ... lit.Dump(myStruct) In retrospect, I guess we should have called it `litter.Defaults`, not `litter.Config`.
Aye, makes sense! Thanks for explaining!
Nice, I made a similar special purpose crawler to crawl a raw diamond database https://github.com/harryganz/diamonds. Is this just meant to be instructional, or are you going to make a crawling library?
No, it wasn't. It was a post full of sarcasm and condescension. If you intended to paint the Scala community as hostile and arrogant you couldn't hardly have done better. Do better advocacy.
FWIW, last I knew Perl 6 is still a complete nonstarter for any serious programming project, because their performance is entirely unacceptable. They were, last I knew, another several times slower than Perl 5, which is one of the slower languages around but is fast enough to do real work. I believe it is one of their current focuses but at this point you're justified to observe that the Perl6 world has a nasty habit of getting to a certain degree of progress and then throwing the entire interpreter away and starting over again. 
Hmm service discovery in a project structure is an interesting concept. I wonder if there’s a simpler way though. Thanks for posting!
Nice. It has always annoyed me that go's fmt defaults for %v do not emit parseable go.
Are you needing a web page that allows the user to select a file on their device (or local fileserver) and initiate an upload with a Go backend process to write the file to a server ? If so, I have used JQuery on the client and Go on the server to implement what you're looking for. The Go piece is quite straight forward.
I was also looking for web today. you should use dropzonejs. and look this tutorial. https://hackernoon.com/how-to-build-a-file-upload-form-using-dropzonejs-and-go-8fb9f258a991
IMO there is three good usecases for JSON columns/operations: 1) Development; during development work, adding and removing columns from the DB is annoying, having a sort of "garbage" column to throw in data for a quick test can reduce development time 2) Dynamic Data; especially when you ingest stuff like tags or highly dynamic documents that you don't need indexing on, it can be benefitial to just dump them into a JSON column and not have to think about it anymore 3) Directly ingesting JSON into a database; you can simply wire up a HTML form to a database. This might be dangerous but can be useful for debugging or logging.
Now, just pull your nose out of your ass and read my comments and my concerns. I didn't just theoretically call out golang - I've brought up *major* flaws why golang's tooling is not that good and I've asked you to not be so boastful. I'm suppressing FUD and delusion here for *your favor*. The first guy was calling scala's tooling weak but that's his "why do you look at the speck of sawdust in your brother’s eye and pay no attention to the plank in your own eye" moment. &gt; If you intended to paint the Scala community as hostile and arrogant you couldn't hardly have done better. Do better advocacy. I'm not really a part of the Scala community - I can replace it with another language you don't understand but still bash every day. Also, you're talking about "arrogance" yet your community constantly questions the usefulness of tools proven by the industry and by research. You're also fail to realize how much problem your community is causing in the software world - this is arrogance. &gt; I want you to know that it isn't because I'm too scared of the truth you laid down or something. No, it's because it's ok to bash every language on r/golang but it's not ok to bash go here. It's ok to bash java on r/programming but it's not ok to do it on r/java. I often see gophers going to r/programming and bashing the competition and refusing to use logical reasoning. Most subs are echo-chambers. You're just a part of a bubble and you act like your community does no harm. Everyone who calls out the madness you believe in are "arrogant assholes", right? I guess there is more sentimentalism on r/golang than honesty. &gt; I don't speak Scala, but I speak Haskell. Close enough. I know the party line quite well. Haha. "Close enough" in what sense? You won't be more likeable and I won't believe you anyway. Go has so many flaws that no decent programmer with standard principles would touch it. You can't say that good tooling is a principle of yours because there are obvious and well-known flaws in go's tooling. You can't say you like simplicity because none of you would protest so harshly against generics and proper error-handling models. If you think programming is just ifs and loops then you're inexperienced. Do you understand the average programmers' attitude towards go now?
This has been out goto pretty printer. pretty.Diff() is especially useful for testing. 
&gt; No, it's because it's ok to bash every language on r/golang but it's not ok to bash go here. It's ok to bash java on r/programming but it's not ok to do it on r/java. There's a difference between politely pointing out the flaws in something and ranting, insulting, and demeaning it. Not only did you come to a Go subreddit to do this, you insult the people who created and use it. That's like going to a stranger's house uninvited just to piss on their door and insult them.
&gt; services/ was once used as a root for all long-running services at DO. Over time, it became difficult to keep track of ownership of code within this directory, and it was replaced by the teams/ directory. I'd love to hear a little more detail on this. We're moving to a services based repo structure, with the assumption that teams will own specific services/microservices. That avoids the organizational issues you ran into with teams, and would only need to be reorganized if the actual service infrastructure changes.
Yep, so do we. After reading about Kubernetes labels and annotations, I wonder if there's a way we could label and annotate our projects instead of trying to fit things into a directory hierarchy.
Basically the directory got too large and messy, and especially if code was poorly named, it was hard to find. As mentioned in https://www.reddit.com/r/golang/comments/75pm12/cthulhu_organizing_go_code_in_a_scalable_repo/do8d2m3/, I wonder if there's a better approach.
&gt; Now, just pull your nose out of your ass and read my comments and my concerns. Literally stopped here.
Ours is somewhat kubernetes specific and not at DO scale yet, but our base directory is `namespaces`, which is comprised of several microservices that live inside an `internal` folder, to prevent cross-namespace imports.
So you want a go backend + web api? File upload progress is probably better handled in the front end by some JavaScript plugin Then just poll the api every X seconds to get the update/state/errors And cancel by sending a request that sets a flag that the processor checks every time it's about to process a row
I also built a *special purpose* crawler, https://github.com/qvl/httpsyet. Since the crawling logic is rather simple I implemented it myself instead of using a library. It is not intended to be general purpose. While doing this I realized that the channels communication is kinda neat and I wrote an article to share it. One reason is also me wondering if this is a good solution or if someone has an idea how this could be much simpler.
I like Go. It's a part of my limited tool set - Go, good ole Bash and enough C to get by. I was looking at Perl, Python and perhaps even Haskell as another tool in the box. I wasn't really looking to compare but while watching this video I just couldn't help but be distracted after his comparison. 
I'm impressed that you know all go programmers, or at least enough to so confidently generalize about what they know! You might be very clever, but intentionally or otherwise you come across as being on a very unfortunate place on a Dunning-Kruger curve. Why didn't 'dep' or one of the variations work for your work projects? For us it's fixed the "download random versions to build" problem completely. You're still left with the problem of managing the dependencies, but that seems inherent to having dependencies (and it's just a matter of how tightly you want to manage them).
I like Haskell quite a bit. Fast, safe, though the ergonomics compared to go are really not good. It's a very "tall" language so it can continue teaching you things for a very long time. Python I don't like anymore. Now that I've I started doing Haskell, the only advantage of Python I can see is that compile times are faster (since it isn't compiled :p).
Everything jq does
&gt; Can you expand on that? I'm pretty sure Scala has superior IDEs, build tools, dependency managers and a much richer ecosystem than go can ever hope for. Sure thing. Scala does have a couple of good IDEs, the main one probably being IntelliJ IDEA - which also happens to be what I'm currently using to write Go. JetBrains are also developing a Go IDE - Gogland. The feature set here is probably identical - built in debugging, integrated test runner, code completion, etc. I don't think there's much of a disparity here overall, but I'd argue you can productive in Go in more editors, more easily than you can with Scala. Build tools - not really sure what you mean here, `go build` is absolutely awesome. No configuration _necessary_. It's incredibly fast. Produces native binaries that are portable (though that one is with a couple of caveats, admittedly). It can be configured when you need it to be. Take SBT on the other hand, that thing is an PITA to set up, even moreso when you have to learn it for the first time. Things like that are important too, Go is good if you want to on-board new developers thanks to it's tooling, and incredibly small learning curve. SBT is certainly an impressive tool under the hood, it's doing a lot of stuff - but my problem with it and Scala is that it has to do that much stuff, and it takes it's sweet time doing it. I'll come back to that though. Dependency managers... This is something that really frustrated me, and I really did not understand what on earth the Go team was thinking when they released a modern language without _versioning_. Thankfully, that has changed since, and 'dep' is hurtling towards being a finished product. Aside from that you have tools like [glide](https://glide.sh) which I've been using for a while now, and it works great. I'll switch to 'dep' once it's ready. SBT on the other hand is again, incredibly slow, and more complicated to configure. The problem there is twofold. You have a lot of little dependencies with Java and Scala projects, so you end up downloading an insane amount of stuff (and taking a LONG time doing it) just to get started on a project. I've started Play Framework applications before on a 100Mb connection at the office, with maybe 2 other library dependencies and had it take about 20 minutes to download everything. Ludicrous. Glide is generally done, even in complex projects, on the same connection, in less than a minute, probably less than 30 seconds even (I've not actually timed it). Yes, I do know that you can use incremental compilation with SBT. Compiling a _single class_ in Scala can take longer than it takes to compile an entire Go application. Seriously. And I don't mean a "hello world" app, I mean like a micro-service or something. This is important! Being able to deploy changes rapidly is a great benefit. Being able to have a faster feedback loop locally when developing is also fantastic. It's not _that_ bad with Scala when using the incremental compiler, but by comparison it's very slow. When we're talking about doing a clean build in your CI too, then it's crazy how big the difference is. &gt; In practice, scala programmers barely use compilation because the IDE with the help of the typesystem catch a lot of possible bugs and incorrect API usages without wasting time with useless/obvious UTs. They don't need to resort to shitty "error-handling" mechanics like if err != nil to catch errors. They don't generate code with external tools or to use dynamic constructs in a static language due to poor compiler and language design. I will admit, I did really enjoy this aspect of working with Scala. You're spot on here, and Go does sacrifice some of that. Initially I actually tried Go before I started with Scala, then I stuck with Scala for about a year, learnt the language, tooling, libraries, etc. and after a year still felt like I didn't know much, and wasn't as productive as I'd hoped. I was able to get stuff done, for sure, but I always felt like I was battling the language to be able to get stuff done "right". I took another look at Go after that year and instantly fell in love. Near-instant build times, super fast testing, nowhere near as much to configure, faster dependency downloading, native binaries, simpler code that's easier to read and understand, an incredible standard library with a LOT of really useful functionality built-in. I was happy to sacrifice the type system for being _far_ more productive as a result. The best part about it is that I can make applications that are as fast, if not faster than what I would have made with Scala. Error handling is a bit of a tricky one. On the one hand, I'm not really happy with error handling in Go overall, but on the other, I don't mind the `if err != nil {...` stuff. It means when I dive into some code I can easily identify errors that are happening anywhere. I do however long for a nicer way of checking what type of error something is, i.e. not just `error`. Honestly, this point is probably a lot more subjective, so I'd take my opinion (and I will take yours) with a pinch of salt. I like this aspect of Go, but I also can see why others may not like it. Besides which, if you wanted to be really "functional" about it, using an `Either` or something is actually quite in some ways, just the way you handle error cases is different in Scala - but actually, that reminds me of something I did also not like about Scala with regards to it's error handling - it was much easier to just throw away errors and not handle them properly (e.g. by mapping over them or something) and not even realising. Then that can create pretty difficult to debug errors, because the code is more concise, that conciseness can actually harm readability (and the errors). Verbosity in some cases aint all bad. &gt; They don't generate code with external tools or to use dynamic constructs in a static language due to poor compiler and language design. Not actually sure what you mean here. Do you mean using `interface{}`? If so, it is somewhat regrettable, but I'm in the "no generics" camp, if there is one. I do believe they could be introduced in a way that restricts their usage to keep them simpler, but I'd have to see that to form an opinion on it. For now, as above, my opinion on this is that it does help maintain more simplicity, at the cost of more verbose code. I've also found that there is often a way around having to use `interface{}`, and code generation can be one of those things. In my opinion, code generation isn't all that bad. &gt; Go being verbose is not your worst problem - your community being delusional is. Stop pretending that you've good tooling because golang is just an average-joe in the industry. I've programmed in a lot of languages so far and golang and its tooling are nowhere near impressive or ok. Is it better than PHP to create webapps? What an achievement! You might as well start to congratulate each other for being gophers! Go's tools aren't as complicated, or configurable, and they don't do as much "fancy" stuff, and they're not perfect either - but they do help maintain a great level of productivity, and enable some really cool things to be built to support the language. For example, [this kind of thing](https://github.com/alecthomas/gometalinter#supported-linters), and you can run all of those at the same time, and they will all run insanely fast! That's enabled by the simple language, and great standard library. Go isn't for everyone, and it's no perfect. I certainly wouldn't claim that, there were reasons why I was turned off it when I first came across it. Go is however a careful balance of compromises from some very experienced people - and it really works. When I returned to Go I finally understood why certain decisions had been made, and I was completely behind them, 100%. I tried a LOT of languages whilst also considering Go, and there was always a problem like compile time, or tooling being completely immature, or no-one using the language, etc. in the other languages I tried. &gt; Are you proud about the tooling? Then don't be because you need fix the way you manage dependencies. Do you know how many issues your language cause where I work at? Just before I started to come home from work today I got a bug report because one of our modules often fails to compile because of an indirect gopher module dependency - and we got the blame! How unprofessional you need to be to download dependencies from github and google? Yeah, just let's make a dependency-docker-container for every go module because some beginners were too lazy to learn a normal programming language. \s Honestly, this just sounds like _you_ need to fix the way you manage dependencies. This is a solved problem in Go already, and it's been fine for me for a long time now. &gt; You gophers always choose the mindless with a lot of bad consequences because you barely have any experience with programming languages and when you receive critiques you'll just point to docker like it's some kind of a proof. You need to improve your game because in practice, go and its tooling are cancer. So, Go doesn't fulfil your requirements, that is absolutely fine. If you're having trouble at your job because of it, maybe you should work in a different place? I came to the conclusions I have about Go after quite a lot of time, research, and effort - and am still happy with my decision now. Based on all that I have learnt in the process, I have to disagree with many of your points. As I have. I actually started working at a new place last week as lead developer. The place predominantly uses Go, and it's been insanely easy to integrate with the team and start development, and it's a lot of fun too. I hope that my counter-points and views on this have been useful. To quote you: &gt; My concerns are valid and represent real-world experiences not just "I've tried this and it's not my fancy".
Yeah... if this is going over the web it's not very easy to describe the possible solutions, because there are so many, and they are all pretty much equally bad so there isn't a clear way to navigate them for you in a reddit post. I can offer the following hints, though: 1. Don't forget that Go's model of HTTP server is quite good, and in particular, it accurately reflects the fact that a web request can contain a stream in it. When you get the `*http.Request` sent to your handler, that's the point in the network transaction where you have received the header but you have not necessarily received the body. You can manipulate the io.Reader of the body in all kinds of useful ways. 2. In general, streaming things back out to the client is a nightmare of different approaches and tradeoffs. In this case I'd recommend a search for [server sent events](https://www.html5rocks.com/en/tutorials/eventsource/basics/), but many things work. Kinda unfortunate how many things work, actually.
If you want to put "methods" on the struct and some methods might modify the content in the struct, then you need a pointer.
It depends on the use case. Do you want the methods of the struct to generally modify the struct in place, or do you want the user to need to create or copy to a new struct when they want to make modifications? Generally, if the struct is rather large, a pointer is preferred for efficiency but most structs won't be large enough for that decision to matter most of the time.
Server sent events seems like a good fit, thanks.
I actually hit the character limit there and hat to chop a few bits out. I didn't intend to start any sort of debate here really, in any case. Like I said, I hope seeing my opinions here helps to change your mind that all Gophers are just mindless idiots that for some reason love the language and praise it's tooling with the only possible explanation being that they don't have any experience. Go does make some sacrifices, and as I said, it's not perfect - but no language is. The reasons one developer enjoys working with Go may not be important to another developer working with Scala, and that's totally fine - and the end of the day, things still get done, and the world keeps on spinning.
You didn't point out any tooling concerns other than that apparently you aren't using `dep`. You should calm down.
I just use the completion from zsh-users and it seems to work fine. How is it not working for you?
funny. I use zsh-users too, but it is not working for go 1.9. 
You're in luck, you can already output shared libraries for OSX/Linux and starting 1.10 you will be able to do it for windows as well.
I'd recommend you to go ask the #go-nuts channel on Freenode.
TIL. 
You're in luck that I was working on improving godoc and I had to deal with this problem as well. https://play.golang.org/p/mYeyUEwHGJ One way is to use ast.NewPackage with a very simple package importer. This is based on code found in github.com/golang/tools/godoc/server.go
Your stack is quite similar to ours except we use Kubernetes. Did you evaluate that and if so, what was the deciding factor for going with ECS? Also, do you do any local scaffolding using Docker and if so how does that work? Great article - helps us feel we were not crazy setting it up how we did. Thanks
With NATS it is possible to build a full mesh of NATS Servers. So even if 99 of 100 are down, it will still work.
Such a great discussion on optimizing WebSocket messages!! I really appreciate you sharing that with me! It will be of great help as my next step now is working on a Go implementation of the app.
[removed]
Quick follow up, I managed to get Redis and clustering working in harmony. I hope to be testing it soon and find out what the room capacity turns out to be. I also want to give a chance to gobwas/ws, gorilla/ws or c++/ws++, since they initially utilize the available cores unlike node which needs to be mounted a specific way for that to happen. Regardless, our interaction was fruitful and led me to a working solution already with Node and Redis. Big thanks for that!
&gt; The readability and writability of languages are usually a seesaw where improving one hurt the other quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x] biggerSorted = quicksort [a | a &lt;- xs, a &gt; x] in smallerSorted ++ [x] ++ biggerSorted func sort(values []int, l int, r int) { if l &gt;= r { return } pivot := values[l] i := l + 1 for j := l; j &lt;= r; j++ { if pivot &gt; values[j] { values[i], values[j] = values[j], values[i] i++ } } values[l], values[i-1] = values[i-1], pivot sort(values, l, i-2) sort(values, i, r) } oh man it so isnt. and this was probably one of the most forgiving-to-go examples i couldve used. No (if err != nil) madness, nothing involving something that would warrant using generics (Go would have to implement the same logic for each type). Any language in 2017 whose rebuttal to not having generics is "use copy paste" and "use code generation" (https://appliedgo.net/generics/) is not worth any self-respecting developers slightest attention 
Heck yes! I was building a Go program to be hosted on my server, due to limitations, I had to run it locally. I compiled my program to run on Android via Process. No change needed in my code either! Works out of the box. (Windows/Mac/Linux/Android tested). Although, I did try gomobile to bind my package as an Android lib (.aar), and had no luck with that. Not all functions were exported, if any. ¯\\\_(ツ)\_/¯
Awesome! 
A really nicely written article. Well done. Your stack is also very similar to ours.
Code tends to read a little better with struct pointers because any modifications to the struct pointer are persisted. Without a pointer, you could modify the struct values in one function but forget to replace the original struct with the modified one in the calling function. I can't think of many common use cases where you'd want to modify a copy of a struct and then ignore the modified copy. So, if you want to modify your struct values, easier to use a pointer.
Contra the other posts in this thread as I write this, whether or not the struct needs to be modified by the user is _not_ a determining factor in the decision. [What a method does is based on the method signature, not what you have](https://play.golang.org/p/QytLRByXNg); pointer methods can be called on non-pointer structs with no problem. (You do need to pick either pointer methods or non-pointer methods to implement a given interface, but that's another question.) The questions around whether you return a struct or not are all much more subtle than that and I typically don't spend a lot of time thinking about it. A direct return involves a copy into the caller, and you probably don't want to do that with big structs very often. Returning a pointer involves less copying. Either way, the caller can convert to what they want on the spot, either by taking the address of the returned value or dereferencing the pointer. Returning a struct directly probably gives the escape analyzer a better clue that this doesn't escape, there may be scenarios where that may make a difference. Mostly I wouldn't worry too much about this either way until you've got some code that is doing the wrong thing and it's a performance problem.
You're right it's not an entire program but it is substantially more than what an experienced Go programmer would write. He's using idiomatic Perl 6 and non-idiomatic Go and trying to make a comparison. That's almost always biased because few have taken the time to explore both languages properly (let alone the several he lists; I'm sure we could scrutinize most of them in other subreddits). There are several places where his Go is too verbose. Like mentioned above, you wouldn't need/use a String() method. The default fmt.Print* would give you what you need. You also don't need to do the IsValid check in the way it's done there. It would be as simple as: if x &lt; -10 || x &gt; 10 { return errors.New(...) } p.x = x return nil 
Not sure what you mean. That's almost always true for languages. There is some overlap but often the ability to write in a language quickly means it's harder for someone to come up to speed. He alludes to this in his presentation. I think his point stands that perl is "expressive" but that almost always means readability suffers. He says it's not that bad but then he uses his French as an example. What's he's alluding to is that "with practice, the perl 6 code will become second nature". Said another way, perl suffers from readability issues. It take more expertise to be sufficient at reading it.
Exactly correct -- if you're developing web-like stuff it's very refreshing to suddenly ignore the world of callbacks, promises, and other asynchronous garbage.
I would say that mixing pointer and non-pointer methods is very unintuitive (and will be caught by linters), so you should probably only be using one or the other, and while you can return a struct and have it use the pointer methods, that struct won't satisfy any interfaces the struct's pointer does: https://play.golang.org/p/Z9bakv8_rx So while its true that the type you return doesn't determine how methods will work, the type does determine what interfaces are satisfied by the result which can cause confusion or forced casting if the method receiver doesn't line up with the return value. I'm in favor of having a 'canonical' type for each struct, either a pointer or not, and having all receivers of that struct use that type and all constructors return that.
This is great. It would be nice if the example code lived in a gist or even better at a place that would be go-gettable.
Ehh, it seems like your example actually proves my point. I've never heard of anyone saying Haskell gets high marks in the readability category of language evaluation. Remember readability isn't just "does it have generics" or "can I read my own code". It involves how well another person, especially a novice to the language, could read your code or how long it would take a novice to become an expert in the language. I consider myself a self-respecting developer and I use Go. I've mentored a team at work and we've designed and built an extremely complex system in just a matter of months. I can't imagine the same would have been the case if I picked Haskell. I'd still be trying to explain what a monad is. :)
It *almost* does not matter. A goroutine starts with a stack size between 2KB and 8KB (depending on the OS), which is tiny but can sum up. 
That's for networking stuff, Go uses an event loop like model, right?
Yep, it really is refreshing.
Go has a [network poller](https://dave.cheney.net/2015/08/08/performance-without-the-event-loop), if this is what you mean by event loop like model. I cannot tell, however, if and in which way the networking model is related to the goroutine stack size.
Yeah I just started learning about this things, so yeah I guess I am equating the network poller with the event loop.
To add another aspect, many real-life networking challenges are above language level, but Go can help build solutions with low effort, as [this article about implementing a worker pool with goroutines and channels](http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/) nicely demonstrates.
&gt; It involves how well another person, especially a novice to the language, could read your code or how long it would take a novice to become an expert in the language. What's wrong with designing languages so that they're readable by experts? &gt; I've never heard of anyone saying Haskell gets high marks in the readability category of language evaluation. I dunno, I work with a lot of Scala developers and they think it's readable. 
Let me add Basic, Pascal, Fortran and C++ to this list.
Fair point. I'll whip up something. Thanks.
It would be nice to add that double assignment can be used to swap two variables content. a, b = b, a This is much readable than tmp := a a = b b = tmp
[removed]
&gt; What's wrong with designing languages so that they're readable by experts? Nothing inherently wrong but when you are doing a real language evaluation it is one of the criteria and it's important as the team makeup and duration of the project will affect being able to use a language that requires substantial ramp up time where the pay-off is later in learning curve. I'm just trying to point out that there is give and take. No language is perfect and is going to have weaknesses. You have to pick the right one that fits you and your team given all the constraints you have. &gt; I dunno, I work with a lot of Scala developers and they think it's readable. The thing about Go is that it seems to hit a sweet spot for many of the evaluations I do. Yes, your group of Scala devs might do well in Haskell or Erlang, so picking Go may not be in their best interest for some projects. If we are being realistic though, your group is probably a heavily skewed sample set. Most people will be coming from a procedural language like Java or C++. In the evaluations I've done, Go gets a B in most categories. Something like Haskell might get an A in a couple categories but an D in others. When you average it out, Go is the best fit. So, yes it doesn't have generics. My project hasn't missed it though. We just had to think more like Go. This seems like something that a Haskell programmer would understand. If you try to port your C program to Haskell, you're likely misusing the language. In the same vein, you need to think about how you use Go differently than you would use Perl (my original point; and why I think his example is contrived).
Sorts? Or filters routes to return one or more routes that contain a searched for IP? Make something like your RepoFindRoute, but search by the IP field. If you want to return multiple routes, don't return when searching the routes array function make a array/slice of matching values and return that at the end.
There's a lot of condensed syntax in the Haskell example that, yes, makes it hard to read. Anyone can read the Go example. To understand the Haskell example, you need to know that `++` concatenates things, that function application (if it's called a function, sorry) doesn't use parens like almost every other language does, that `|` defines a new variable from some kind of `&lt;-` syntax which is I suppose equivalent to `pop`? And you need to know that when you turn that arrow around it now means function application? And if it's an equal sign instead its defining what kind of type a function accepts? You also need to know what an `Ord` is, when 90% of languages would be using `int` or maybe `Sortable` or `Comparable` or something. You also need to know that functions can be defined multiple times with each definition taking in a unique argument pattern. That's a lot of stuff to know man In comparison, in Go you need to know math, for loops, function calls, and integer comparison operators, all using common syntax. 
have a single goroutine read the data and feed it into a channel then have multiple goroutines receive from the channel to process if you need to save the ouputs, open another channel and have all the processing goroutines feed into that one and a have a single goroutine receive from it to write to disk/wherever 
It's still a single point of failure, because all communication requires NATS to be running.
From what I understand, you're trying to deduplicate messages that are coming into several goroutines. There are several ways to go about it, but yes, generally you would keep a "seen" map that will tell you if a message has already been processed. Using a mutex is a valid way to ensure that only one goroutine can read or write from it. You could also resort to the `sync.Map` construct, added in 1.9, where locking is handled implicitly.
Thanks that makes sense but what if the values are duplicated and nested inside the values I'd be passing to the channel to process. The processing channel may need to do the process again but may be doing it on one that the other goroutines have already done. 
Technically you could hit issues where one goroutine would have a high CPU/IO use. For example, an infinite loop generating a lot of outputs that are sent into a buffered channel. The Go scheduler might decide that "hey this goroutine needs more time, let's give it to it". In practice that would mean that the secondary goroutine (reading from a channel) can be effectively stopped. The way to work around it is to call `runtime.Gosched()` from the CPU intensive routine to force the scheduler to give some time to the other goroutines. Here's a more concrete example from a [SO question and answer](https://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do)
done. you can `go get` the code like so: go get github.com/sbinet/blog/static/code/2017-10-11/... (this has also been "documented" on the post)
Wow, please do! I'd be super grateful if I could also ask you to message me when (and if) you manage to do that? We very much have a need for a tool like this; mulled over writing one quite a few times already, but the timing is not painful *enough* for us to do that yet... but if we could just use an existing tool, or perhaps at least fork it to tweak to our needs, that would be really awesome and make life so much easier!
there are several ways depending on your data/processing if your processing doesn't require the values to be passed in together you could unroll/flatten your data and deduplicate with a simple map before you feed it in if it does need the entire bundle, then it might easier to use the new `sync.Map` and check in the processing goroutines (update the map before beginning to process a value)
Which would be the faster approach assuming both were possible?
unrolling before feeding, simply because you don't need to deal with synchronization you can check [this article](https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c) on the performance between the 2
That seems fine to me. I'd add a Waitgroup, or a deferred channel close to actorLoop, such that Stop() can wait for the actorLoop to exit. In particular, I'd have Stop() take a context, and block until either actorLoop exits, or the context cancels, whichever comes first. (It should also be safe to be called multiple times). This is basically the pattern that net/http's Shutdown method takes: https://godoc.org/net/http#Server.Shutdown. One other thing I would recommend is to have actionChan be a "chan func(context.Context)" and propagate actorLoop's ctx into f. That way, when someone calls Stop(), the action functions will also be cancelled promptly.
Thx, I’ll add it as an example.
Thank you, i did like you said and now its working (almost). It doesnt show more then one result when searching for a specific ip :/
It's blocking in the sense that a goroutine can be suspended but under the hood IO is asynchronous. 
Well, from the slides you can also see that Go doesn't even provide a functioning SetX/SetY, nor that they are invoked from NewPoint or something like Java/others. At least the Go example is flaky at best.
It also matters if you're allocating heap memory. For example, if you're generating large json responses, each goroutine's json encoder will have a byte buffer, and your memory usage can get out of hand if you have a lot of goroutines.
The Go scheduler is cooperative. Goroutines are not preempted, but they do yield the processor under certain circumstances, namely at synchronization points, function call sites and when performing I/O. All network I/O is asynchronous under the hood and is implemented in the runtime network poller using the platform provided notification mechanism (epoll, kqueue, IOCP, etc). Because Go uses a user space scheduler on top of the OS scheduler, you are presented with synchronous looking programming interfaces, which are easier to use and reason about than explicitly asynchronous, callback-based constructs. When a goroutine must wait for something to happen (e.g. a channel operation or network I/O), it is parked, to be woken up by the scheduler when the operation is complete and it can resume execution. /u/ChristophBerger mentions goroutine stack size, which is another key element in making the Go programming model work. Generally, write straight-forward, synchronous code. Don't do things asynchronously just because you can (or because it is cheap to create goroutines). Introduce asynchrony only when you need it. If you're writing a network server, create O(1) goroutines per client connection, or use the ones created for you (for example: https://golang.org/src/net/http/server.go#L2720). Go allows you to write such code with the confidence that it will perform well, while hiding the hard realities of the underlying I/O under a useful abstraction.
I've seen that! Awesome indeed!
By any chance, were you using C++ libraries with your program?
I'd recommend writing a Go playground example / unit test for this kind of thing, which can help clarify what you mean when you say something like "sorts the json".
No, I wasn't. Just pure Go. 
A side effect of the "effectively make large, cross-cutting changes to the entire repository" tends to be the assumption that an atomic SCM change across multiple services will be deployed together. Not only that, but it also tends to have an effect in that changes within the organization can be forcibly pushed to a group by another group just going ahead and making the change. Are you doing something that actively prevents becoming a monolith of small services?
https://golang.org/pkg/context/ 5th paragraph down in the 'overview'...
 When you found your matching IP did you do what you did in your ID search and return (ending the loop) or did you add it to an array/slice and then return that slice when the loop finished?
i know that context shouldnt be stored, i also did my research and learned from the mailing list that there are exceptions to this "rule". note that what im storing is the cancelFunc, not the context itself. if you can enlighten me why a cancelfunc inside a struct is a bad idea then go on.
This is really great. Thanks for sharing. I am curious why you are using `alpine:latest` and not scratch. I was experimenting with a project and was able to do this https://github.com/amir20/clashstats/blob/go/Dockerfile instead. It works great and my images is less than 5 mb! 
I think you'll be fine. Just referencing what the package documentation says. I think it only even refers to it being that way because it's more explicit. If you make it part of the function definition, you require every call to pass a context.
True, if that was the case and we had only one instance to rely on. But isn't it also true when we employ redundancy, we avoid SPOFs? And actually the only pragmatic way of avoiding SPOFs is to employ redundancy?
Storing a CancelFunc in this way (for stopping a background goroutine) is exactly what you should do. The one thing I would add to that code snippet is that `Stop()` ought to block on actorLoop returning. Usually I do this by having the background goroutine defer a close of a chan struct{}, and then have the stop function wait on it. The reason for this is to ensure that by the time Stop returns, the goroutine is no longer doing work. This can avoid races in some cases, but in all cases avoids leaking goroutines in case your background goroutines is doing runaway work.
There’s also https://github.com/y0ssar1an/q
Personally I think it is the best second language, Python and JavaScript are great first languages. In fact, we require proficiency with Python (sync) *and* JavaScript (async) before offering Go. I make sure people learn Go because it forces looking at complex code management in a better way, favoring composition over inheritance for example. It is also the best first concurrent language anyone can learn for the simplicity of goroutines.
Yes. It's one of the simplest languages around that you can do professional work in. Possibly the simplest. 10 years ago I'd recommend Python, but that has actually become fairly complicated. Plus Python did perhaps too much shielding your from the underlying realities of computation; with Go you're not quite so far away, while still being relatively easy to use.
In my opinion yes, unless you want to start with something with a REPL (but even with Python/Ruby, how much can you learn with one liner ?) 
I love how you presented the information. You have way too much style to be a programmer.
Thx! I think this is a good thing, no?
I really reallllyy need to dissect this code and make sure I understand it, one of the simpler NN implementations I have seen.
Why would you put the server-certificate in /etc/ssl/certs/? 
[removed]
I personally think it's one of the best programming languages to start with. I wish I could've started with it first. The only thing it won't teach you is frustration of using other less pleasant languages, so you might not have enough context to appreciate some of the limitations and trade-offs that it makes.
There is a lot of noise here, but you never specify your actual problem. What is a "users certificate chain", what qualifies sufficient and what is the transport. It sounds like you are simply trying to perform client certificate validation over TLS- and over complicating the process. Do you maintain your own CA? If yes then you will need to clarify what your doing here because it sounds like clients are sending you intermediate certificates, which you state you want to add to certpools .. which could be a major security issue, as a client could send its own self signed root and be trusted by your entire system. Clients typically have only the roots installed, the ServerHello in tls negotiation will send the intermediates it trusts when requesting client cert authentication and optionally the root cert. The cert sent by client should be signed by the tail of the chain sent by the server, and the head of the chain sent by the server should be validated by the client to be signed by or in it's own trusted roots. So, knowing this we can add a certificate chain to a separate certpool (see my post history about this) and use it for our tls config, client certificates will be built during negotion for you. This means we have our chain from head covered by the server, and only need to validate the tail sent by client. No modification of our certificate store required, just set RequireAndVerify (check full name/google) in tls config to require client cert auth and let Go do the rest for you.
One of the problems with Go is that a lot of the documentation and "getting started" material assumes prior programming experience. The Python materials are a lot better in that respect.
You find certs/ and private/ below /etc/ssl/. If the host key is stored in private/ the certificate comes to certs/. And the whole point of the check is to help other admins to setup the service. It's not my server the service is running on, so I can't control how others setup their systems.
Heck yeah! * Simple grammar. * Teaches you type-safety, but not super draconian about it. * Bunch of libraries to be able to build something useful. * Runs hella fast, no need to rewrite it later because of performance. * Easy to share because of single binary executable.
Go or Javascript. Also Python.
This it is easily solvable, and this is just the type of contributions the community is looking for! You should consider contributing a "beginners guide to Go"! I'd help
`%v` is for humans. You can be annoyed at `%#v`. And for what it's worth, `fmt` prints struct fields that are pointers as numbers and not expanded because that's a simple way to avoid recursion.
Nope
what if i know some java? i made few simple android apps. 
I think go is better than python for two reasons: types and the compiler. Python might be nice for a super introductory course in "this is a loop, this is an int, this is a string".... but as soon as you want to build anything more than hello world, you run into attribute errors etc. Go also lets you transition easily into learning about memory and pointers, whereas that's basically impossible with python, so now you have to go switch to a different language and learn that one.
if you know some java, go will be easy.
I get it (loop avoidance) but it's not actually unsolvable. It leads to terrible logs and error messages that want to print state, but end up printing a pointer number, which is 100% useless in pretty much every conceivable way. And yes, I meant `%#v`- e.g. an empty string prints nothing.
What do you want to do with it? It has some advantages, particularly with ergonomics. It also has some signal faults - one of the biggest being that it teaches you some bad habits w.r.t. code generation. 
&gt; Teaches you type-safety, but not super draconian about it. Advanced type systems aren't really draconian. &gt;Runs hella fast, no need to rewrite it later because of performance. More dependent on algorithms than language. &gt;Easy to share because of single binary executable. Go did not invent static compilation.
Depends on what you're looking for: **Easiest** - No. Byte slices, pointers, channels, concurrency, etc. are probably going to be more challenging to grasp without prior experience. Ruby or other dynamic / scripting languages feel more newb friendly in that you can do some really bad programming really quickly. **Quality** - Yes. In my opinion, it's so easy to write and find bad code in Ruby, JS, etc. The languages are so flexible you can do some non-idiomatic things really easily. With Go, the tooling and compiler will help you and the community and golang.org are great resources. If you pick Go, stick with it. I almost have up a couple times, but mostly because of bad habits from other languages. Go will usually force you towards the right solution which can be frustrating if you're still learning what the right solution is. Once you get it though, it's a dream to work with and will make you a far better programmer than if you jump into another language first in my opinion.
OOP just means method polymorphism and encapsulation. Therefore Go is absolutely OO, in fact you're forced to use OO when dealing with I/O in go ( reader/writer interfaces).
Is blah a good choice of first programming language? My answer is always yes. Sure, some are easier to learn than others, or encourage good habits, or establish fundamentals. I really don’t care which one you learn first, just have fun!
[removed]
+1 Noting that uname -a is also helpful for many systems not supported by Go.
[removed]
Javascript can leave you with some callback habits, and it has some really jinky syntax leftovers. I'd personally sidestep that and suggest Dart, Go or C# for async.
&gt; &gt; Easy to share because of single binary executable. &gt; Go did not invent static compilation. It's still one of Go's strengths, regardless of who did it first. What's your point?
It depends on what your interests are. At the end of the day you’re going to have to do a lot of programming to become even just a decent programmer, let alone good. But don’t let this discourage you, as we’re all in the same boat. If Go gives you an environment where you can stay interested in working on projects, then it’s good. When it comes to server side, concurrent systems programming, Go excels — if this is an area that interests you, I encourage you to learn the language. And the fact that it’s a statically typed, modern language with good tooling make it a good starting point. If you do go with Go just get ready to get a little spoiled. I personally haven’t found many languages that have their act together as well as Go does. 
Generating static binaries is not hard in any language I've used.
Yes. Quite Good !
I think Python is the better choice here for the very same reasons: when you are first trying to grasp basic ideas of programming you don't need to think about types, compilation and pointers. Python also gives you REPL. Source: 3+ years of working full time as Python-only dev, 3 years of working full time as Go-only dev. + I have helped people start programming.
I liked your article, also the book seems interesting. I would like to buy it but I have not so good experience with packt. I would like to read a preview or a sample which is not possible, is there a way I could?
Yeah, that sounds awesome, but I'm afraid I don't really have the time or skills to do that well.
Cool, this reminds me of my CS 478 project in undergrad (a multi-layer perceptron from scratch in Go). Doing that helped me gain an understanding of neural nets that I couldn't figure out any other way.
For real. You know what you call someone who knows one programming language? A bad programmer. You cannot be a professional programmer without at least being interested in multiple languages. It absolutely does not matter what your first language is. Mine was BASIC. I kept learning!
For a quick/easy fix, you can just use http://petstore.swagger.io/ as your swagger server (just change the url at the top of the page to direct to your service's swagger.json file). We don't use go-swagger, but we do have an endpoint that serves the swagger-ui dist (https://github.com/swagger-api/swagger-ui/tree/master/dist). When we build our docker image, we add the swagger-ui files to the container. Here is an example: https://github.com/quintilesims/d.ims.io/blob/master/Dockerfile#L3 
Thx! I think I’ve got the design skills when I was designing my own websites back in 90s.
a coworker of mine learned Java first, Go is his second language. you should be fine.
&gt; No language is perfect and is going to have weaknesses I dont consider the fact that you can't immediately sit down and start writing haskell to be a weakness. In fact I believe it's a strength if anything. I've always hated that argument. Why would you want a language to be so trivial so as to allow for anyone to sit down and begin writing it? How much of a colossal stain on the sum total of Go code bases as far as shit code has been produced by people with this mentality? So yes you aren't able to be immediately productive but like i said how miserable would that code look? Haskell in a way forces you to write at least decent code. One of the reasons for this is that its purely functional (unlike Scala). Every side effect must be performed in the IO monad, literally forcing you to think about side effects, where in other languages you can just perform them willy nilly. Do you know how much shit code is out there because some company hired a bunch of newbs without properly vetting them, then assigned them to some project in say a langauge like go. They immediately started working on it and thought everything was going great "Hey this language is so simple to write" in. Then next thing you know months down the line the whole project has literally turned into a flaming ball of shit. And this is only one scenario. I'm done looking at piss code. I've looked at it enough (at work I maintain a pretty substantial Scala service and am in the process of day by day rewriting, so Ive been staring at shitty code pretty much every day for over a year now (and of course I think back to when i first started and I opened said project and I *didnt think* it was shitty haha) Do you know if there weren't senior engineers around that they had hired with me how much more i couldve destroyed that project. And this is in Scala, a language with infinitely more abstractions than Go. If it had been writtten in Haskell it wouldve taken me a month before I could even contribute a PR because I, rightfully so, would need to learn what hell i'm doing before just blindly jumping in &gt; Go gets a B in most categories. Something like Haskell might get an A in a couple categories but an D in others. When you average it out, Go is the best fit. Lol no Haskell doesnt. Believe me. And if you're trying to imply that averaged out Go would score higher...believe me it wouldn't. As I said its runtime is literally its only reedeming quality. Haskell will blow it out of the water in all other respects (Go's GC is better) &gt; We just had to think more like Go Having said what I've said what does this even mean? You're literally trying to pretend like like the lack of abstractions Go gives you is actually somehow clever and requires you to readjust you're thinking until you agree with the rest of the mob: "Yea this is so much better". That's called brainwashing not readjusting the way you think haha. You have to actually readjust the way you think with Haskell at first simply because it rests firmly in the functional paradigm and literally doesnt permit you to write imperative code at all (you can simulate it but its still not the same thing at all). So thats what people are referring to as far as the initial learning curve. Once you get sufficiently comfortable with functional programming its pretty simple to expand upon what you've learned by just exploring other native features in the language, since you already have a baseline understanding &gt;if you try to port your C program directly to Haskell, you're likely misusing the language I woudn't. I'd port them to Rust which is where all the hype should be. &gt; you need to think about how you use Go differently than you would use Perl (my original point; and why I think his example is contrived) Lol what ive said is exactly *why it isnt* contrived. That quicksort is what any quicksort looks like in any vanilla imperative, mutable language without interesting abstractions. Thats why I picked it like i said. I couldve gone in the deepend and found an example that displays all of Go's many warts (which aren't even warts. They're like bunyuns compared other languages's warts). But i didnt cause im not here to troll (at least not immediately, when I run out of patience I will probably will). I, and many other people would agree, for this reason that the Haskell example is waayyy more readable. 
**For visual learners**, go to 👉 https://blog.learngoprogramming.com
Any chance your syllabus is online? I've been looking for an assignment to do to help myself understand NNs better.
&gt; Anyone can read the Go example. Thats precisely the problem. Any first year CS student can read and almost every first year CS student knows fuck all about building software. So imagine the shitstorm that would occur if the 2 came together. That's exactly why that simply *isn't* an advantage or something to tout around as being a plus &gt; To understand the Haskell example, you need to know that ++ concatenates things, that function application (if it's called a function, sorry) doesn't use parens like almost every other language does, that | defines a new variable from some kind of &lt;- syntax which is I suppose equivalent to pop? And you need to know that when you turn that arrow around it now means function application? And if it's an equal sign instead its defining what kind of type a function accepts? You also need to know what an Ord is, when 90% of languages would be using int or maybe Sortable or Comparable or something. Read a little bit about Haskell first before you try to disect a program. `Ord` is a typeclass which is basically a better interface (so no need to pass in a freaking instance like you would in another language with `Sortable` or `Comparable` or whatever). All thats saying is "give me a type that implements the Ord typeclass". Int is one such type. Ord's members are &gt;=, &lt;=, &lt;, &gt; (among others). You get them for free on whatever type you pass in that meets that contracts. Yes ++ is a function (most thing sin haskell are). No theres no `pop` cause we aren't in mutable land so forget about that. thats a guard: [a | a &lt;- xs , a &lt;= x]. all its saying is "give me all the a's less than x as a list" &gt; That's a lot of stuff to know man It may be man. But you'll be all the better for it if you take the time to. If you stick with Go youll be writing the same shit you've been writing all you're days as a programmer
&gt; Why would you want a language to be so trivial so as to allow for anyone to sit down and begin writing it? To be more productive &gt; How much of a colossal stain on the sum total of Go code bases as far as shit code has been produced by people with this mentality? So yes you aren't able to be immediately productive but like i said how miserable would that code look? &gt; Go was designed to avoid this. This is why it has `gofmt`. This is why it forces you to remove unused imports and variables. Go's best feature is that it disables a lot of shit code from being written. &gt; Haskell in a way forces you to write at least decent code. Haskell forces you to write something the compiler will accept. That code does not need to be readable or sensible. &gt; Every side effect must be performed in the IO monad, literally forcing you to think about side effects, where in other languages you can just perform them willy nilly Pure functional lanugages are great, but it's sometimes easier to reason about code that performs side effects explicitly in a format that supports side effects that a format that forced you to hack your side effects in. Some problems are a lot harder to reason about when you don't allow side effects. Some, not. There's benefits to both approaches. The rest of your arguments appear to devolve into shitting on things without giving clear examples. Maybe you should take this to r/programmingcirclejerk?
I'm not sure what you're trying to say here. You argue that your code is readable but then you say that the Go code is more readable and that that is a bad thing because languages being readable makes them too easy to work with? If you don't want your language to be easy to work with, you're right, don't use Go.
I don't see it online anymore. But the assignment in the article is similar: write a fully-connected neural network (multi-layer perceptron) that can learn the iris data set. It's a very basic data set that is easy to learn with a small number of nodes and just one hidden layer. This article doesn't explain its backprop implementation and I find its use of gonum a bit confusing. I wrote my MLP using for loops and manually calculating dot products, etc. (Not super efficient but who cares when that's not the point here.) That exercise was very helpful, I thought. You can find more (and more difficult) data sets here in the UCI repository: https://archive.ics.uci.edu/ml/datasets.html
The thing is, you *do* need to think about types. Python *has* types, it just hides them from you, case in point: &gt;&gt;&gt; "2" + 2 Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: must be str, not int You can use `go run` if you don't want to compile. I find the playground to be much more useful than a repl. Who writes code one line at a time? That's not how real code works. And if you really want, there are unofficial go repls. Yes, python is probably better for the first week, but for the second week? I'd go with Go every time. Granted, I have not helped people learn to code, though I think it would be fun.
Figured someone on here might find this interesting; decided to re-implement the kubernetes selector parser for an internal service. Mostly it was to see if we could write the parser + validators with state machines. This resulted in a slight speedup in parsing and a big speedup in validation. 
&gt; Advanced type systems aren't really draconian. But they do include significantly more concepts. Go's type system has a really good balance of parsimony of concepts while having enough to provide guard rails to catch the stumbles of a beginning programmer.
Wow, thank you so much, absolutely incredible response. I am finding it difficult to express just how much gratitude I feel &lt;3
Not my article, I just posted the link.
You've clearly got a bee in your bonnet about this. The troll bit was laughable because I feel like that's what this conversation has devolved to. I'm not new to functional languages. I've been using them, including Haskell, for decades. We even evaluated several in our most recent analysis. Sorry you are stuck with crappy code. Maybe that's where all this pent up animosity is coming from. Just to be clear, there are really smart people who love functional languages but still understand the merits of imperative languages. These people can do a fact based analysis of languages based on the project, team composition, readability, writability, orthogonality, expressivity, abstractability, etc. and Go will come out the winner. It did in our case and we've been nothing but happy. We aren't the imbeciles you make us out to be either. I've been studying languages for decades and my team is highly educated with multiple postgraduate CS degrees.
I suppose. To me the advantage in using Go as a a beginner is that the ergonomics are such that you don't worry about stuff like learning the command line. The advanced type safety stuff is pretty much useful immediately, provided you want to write software, not just learn some programming.
I never said the Go code was more readable. Think about it like this Go is simple in the way that a bicycle with training wheels is easier to ride than a bicycle without them...and as a consequence you can't do the things you could do with a bicycle without them. So if you want to keep your training wheels then go for it. Fuck if i care. And for what its worth what would you split that comprehension into? rightTriangles = [(a, b, c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a + b + c == 24 ] ( i dont know if that even compiles) its the same things. whats the point? 
Not sure why you put the code for darwin in init(), instead of doing it on first access. Or why you keep the full map instead of just the single key that you'll always access. On the Linux side you are calling lsb_commands on every invocation? Also returning nothing for GetVersion() seems bad. Dito. empty version for the BSDs.
Lol you have not been using Haskell for decades. You know how I know that? Cause if you had you would think Go is as pointless as I do...and you sure shit after: &gt; We even evaluated several in our most recent analysis concluded that "you know what, fuck all of that useful abstraction nonsense we dont need that. You know what we need? 25 functions for 25 different types and the shittiest error handling semantics that seem like they were conceived of by someone that just started programming and is still copying and pasting code from Stack Overflow. Oh speaking of which, thats lauded as a reasonable solution. So boys, this is what we need" You can't be serious. if you need a realtime system or lower level semantics use Rust or something. But don't bullshit me with stuff like this: &gt; I've been studying languages for decades Because if that were actually true with respect for Haskell (or any other lets say more enterprise suited functional language like Scala) you simply wouldve left shit like Go in the ash heap of history, not ran to it. If that is actually true though then I would say theres is something enormously *profound* you missed when you were "evaluating" them
How's the user experience? Do you have any demo?
I think you should take this somewhere else. You clearly hate Go and don't want to listen to anyone telling you why they use it, so hanging around r/golang probably isn't a good idea for you.
There's absolutely no need to use a context in this scenario. Here's an example of a determinsitic shutdown via two channels https://gist.github.com/fortytw2/f716aff1d11fb90d4696bb7bf582464e Alternatively, you can use a channel of channels to do the same thing, I find two to be a bit easier to grok though.
100% agree, and I think this is something that we as a community can improve on.
From the article: https://github.com/Eun/http-response
YES!!!
Does anyone know of any "prettification" utilities similar to [panicparse](https://github.com/maruel/panicparse) but for `go test -v` output? After writing hundreds of tests using [Ginkgo](https://github.com/onsi/ginkgo), I've decided I prefer the simplicity of the standard library `testing` package. Unfortunately this means I just get bland test output which is more difficult to read than Ginkgo's prettified output.
I'll probably update this later today. A lot of this stuff looks exiting and I've been waiting for better OpenID/OAuth integration for a while now. Cheers to the maintainers and devs of Gitea, you're doing great work!
Sharing it here because I think it applies to Go pretty well. Sorry for causing you to click twice instead of once to get to the article. If you want to click once, here: https://mtlynch.io/human-code-reviews-1/
&gt; https://gist.github.com/fortytw2/f716aff1d11fb90d4696bb7bf582464e thanks! 
Depends on what you want out of it. If you just want to get stuff done quick, you might find the learning curve a little steep. If you want to learn how to do things right, it's an amazing language to get started in. This is because it has been designed with software engineering in mind and teaches you things like keeping your interfaces small, keeping your style consistent, to always think about errors, etc.
I think we often forget that "first language" and first immersion into computer science are not parallel they are often concurrent (pun implied)...I started with Go, but had to back up a bit and learn some Bash and of course Github and even some basic C in order to get a grasp on the basic "assumed" terminology...even at Go 101 there are a lot of assumptions about navigating the terminal and simple writing techniques in basic level code that a true novice-uninitiated-learner is going to struggle with. If there were a "Go for kids" I would have started there, but so far there is not (and there REALLY should be if we want our future generations to be fluent in anything except human)... I can remember being confused for the first few weeks about God being a "statically typed" language and thinking, "Well they all are typed on a keyboard aren't they?...the syntax of code itself should have a decent primer somewhere, but fortunately there are a ton of resources and the code *wants* to be discovered.
Yeah JS has too many warts that ES6 is covering up. It has a different paradigm of functions as first class objects that you are supposed to pass around. I would consider it more of an in-demand quirky language than something to learn with.
So this is just longpolling?
Are there any mature libraries when it comes to a basic FF / RR nets? I had found some repos in the past but they all seemed to have staled for quite some time (beyond a year even).
The Python docs are so badly structured imo. Very few relevant examples. Funcs and methods are poorly named and hugely inconsistent godoc is just... amazing. gos naming is just so well thought through. Plus the fact that you can actually read the stdlibs source code... 
Essentially yes. Using long polling to notify the user about the progress.
Cool I will definitely try this in my next project 👍 for the documentation as well 
Thanks, the retool its quite cool. Yeah I'm in two minds about vendouring, it just seems a very hacky solution to dependency management coming from an enterprise java background, but as with most things in go, there is something in its simplicity.
Would you ship to Germany?
I'm located in Switzerland, so Europe would be a nobrainer. 
Reminds me of the days when I was using PHP...
&gt; you never specify your actual problem. * I'm writing a program which offers a service over TLS. * Other people will setup this program on server I never saw. * I want to make the use of this program as easy as possible. * A lot of people don't know much about TLS. So you'll find a lot of badly configured services. * I do automatic checks to prevent misconfigurations. * I can't check the certificate chain which guys (I don't even know) provide on hardware I never saw. &gt; What is a "users certificate chain" I never said anything about that. And obviously I wasn't able to explain the problem without causing misunderstandings, sorry about that. It's all about helping strangers who happens to use my program setting up the TLS stuff in the correct way.
if it helps anyone one brink of a decision to get one: I love mine, gets a ton of attention at work (-. 
Using the word "Responsive" in the context of websites is confusing here.
...or in other words, we're manufacturing a few bootleg gophers and trying to find out how much people will pay for them.
is this not why websocket exists?
Yeah, what happened to Python. Man, it got complicated!
I like closely flirting with toxicity when dealing with retards! 
[removed]
I am not aware that you can use websockets without JavaScript
We are producing them with the original manufacturer. Currently no normal shop seems to have them in stock. We are planning to hand them out to our colleagues as a christmas gift. If we could order a smaller batch we wouldn't be posting here.
That's it! You've sullied my families name long enough! I challenge you to a programming duel! Your challenge it to solve this: https://imgur.com/a/hXQWX. If you don't, you'll go down in history as the fake haskell troll who couldn't solve a problem written by a profound imbecile that uses the Go programming language.
&gt; what cool program have you created using Golang? None. &gt; How did the experience of creating it using Go compare to another language you are skilled with? Terribly. &gt; What was your reason for using Go for this program? I didn't want to Stop. /s (I'm not a fan of these kinds of threads. They just seem like self-congratulatory echo chambers, and you *can* use almost any programming language for almost any purpose, and then retroactively justify why it was a great decision, even if it wasn't.)
No, it isn’t. The language itself would be a good choice, but the docs and broader community tend to assume you already know how to program. Tutorials are generally of a “here’s the Go way of doing that thing you already know all about” nature. Python would be a better choice, as there’s so much material aimed at people learning to program or non-programmers. It’s a more complicated language than Go, but you can ignore a lot of that, and Python is higher-level, so there’s less boilerplate and more “doing”. 
I'm using Go to build a functional language the compiles to Go. I could have used other languages, but static typing is important for compilers and most languages have over-engineered build tooling. Also, I would like for the compiler to be ported over to the language it implements; since it targets Go, this allows me to gradually port the compiler from Go into the source language.
Rat! https://github.com/ericfreese/rat The reader/writer interface is really nice to work with and the concurrency model made it simple to spin up many concurrent annotators. I do a lot of my professional work in ruby and JavaScript, so coming from that, the static type-checking was very refreshing. I also wanted it to be a standalone executable with no dependencies, and to be super fast. So far Go has delivered on everything except for the one downside of having a larger memory footprint than if it had been written in C or a similar non-garbage-collected language because IIRC Go doesn't release all collected memory back to the OS but hangs onto it assuming it will need to use it again soon. There may be something I can tweak to take care of that though.
My suggestion is to not use an assertion library. Doing standard `if` statements and calling t.Errorf or t.Fatalf goes a long way and I think it makes for more meaningful tests. The assertion libraries are really light wrappers around this and there is no reason why they would need "updating". As for test names, if you want to use the Go testing framework the function must start with Test. The rest is up to you, however i would strongly suggest trying to stick with proper go style. It may feel weird at first, but it's better to get used to it, as all the libraries and stdlib are going to follow that styling anyway.
https://github.com/uoregon-libraries/rais-image-server For the UO Libraries (as I once posted on google groups), I took an existing prototype of an image server and over time ended up rewriting the majority of the code in order to create something that drastically improved our ability to serve JP2 images (which are notoriously slow to decode) quickly and efficiently. We "chose" Go because the prototype was already in Go, and we couldn't see any way to do the project with a different language very easily. We had to have something that could act as a standalone server that integrated with libjpeg, and could serve up images as fast as possible. It was my introduction to Go, so it was really sloppy at first, but I found the learning curve to be very small. I was writing simple C bridges (to integrate with low-level libjpeg code) pretty much from day one, and having to handle a domain that was way over my head at that time (jp2 decoding). I found myself starting to dislike dynamic typing as I got deeper into Go with this project as well as others. Being able to quickly compile and see my obvious typos was a huge benefit, and made me feel a lot more productive. I really love that I can find and fix typos, type errors, etc. without crazy test suites that cost as much as the app to build and maintain. The tooling is amazing, too - various tools to try and lint PHP, Python, or Ruby have always felt to me that they're too slow and still fall short. There are plenty of annoyances I've had with Go, but so far I've found it to be the "least sucky" language I deal with. It often takes more code to do things in Go than Python or Ruby - but on the flip side, there's a lot less magic to try and remember, and again, far less need to unit test things just to find typos or verify APIs are being called properly.
I'm one of the engineers behind Nakama: https://heroiclabs.com https://github.com/heroiclabs/nakama It's a fast, real-time, extendable server aimed for apps and games. It has user accounts incl social login, a complete friends graph, groups and clans, notifications, cloud storage. Some game specific features are real-time multiplayer, filter based matchmaking and leaderboards and leagues. It comes embedded with a Lua runtime environment so you can extend or override the default server behaviours. Been working on it for the past 2yrs. Let me know what you think. 
I made a little collaborative drawing app with go and websockets. http://oursket.ch/ It needs more features to make it more fun. It's just a starting point. Go was a pleasure to use for this. Previously I would have used Node.js, but the Go just feels lighter. I don't mind sharing the source if you're interested. 
Sounds cool - is it working? Got a link?
https://github.com/mcandre/stank A collection of POSIX shell script analyzers. In the past, I would have written such tools in Ruby, being a tremendously productive language. Python plateaus pretty quickly into boilerplate tedium. I switched to Go for efficiency. Still incredibly productive, and I do prefer statically typed languages for robustness. Being able to produce native Windows, macOS, Linux, and other platform binaries FROM any of these systems TO any of these systems is a killer language feature. Oh, and Go has objects but no inheritance, just interfaces, a huge design win. OOP can go fuck itself.
Seconded. I personally hate having to relearn yet another stupid framework when adding tests to a suite. Less is more.
I don't have anything working end-to-end yet. I just built a type inference repl for toying around with the inference system. Hopefully I'll have something working end to end in a few weeks, but that largely depends on how much time I get to work on it.
it would be easier to just write javascript
it's nicer to hear that (Y) 
You didn’t actually say what it does. 
testify and goconvey are amongst most used. Also, you might want to look into github.com/kindrid/gotest. But I agree with others - try built-in test package and see if its work you.
ah nvm. What kind of website is this that you care to give users that don't have javascript enabled a good ux? You say in your article "most of the users (nowadays) expect pages to load instantly." But without any evidence I would posit that users that disable javascript don't care much about good ux, otherwise they would have javascript enabled. What domain is actually worth wasting so much effort to make it worthwhile supporting users with javascript disabled?
Lots of fun small apps. https://github.com/carlmjohnson/opensesame https://github.com/carlmjohnson/heffalump https://github.com/carlmjohnson/json-tidy https://github.com/carlmjohnson/sudoku https://github.com/carlmjohnson/shitpic 
https://magefile.org (makefile replacement using go code) https://gnorm.org (DB schema-&gt;code generator) https://github.com/natefinch/gocog (code generator) https://github.com/natefinch/gorram (go run for any go function) The fact that go compiles to a standalone executable is a big benefit for tools you want to distribute to people who might not be go devs. For me, that's a factor for Gnorm and Gocog, which both are specifically aimed to be used by devs of any language. I've written similar things in C#... which of course would require a .net installation. I think Go's stream handling (reading from / writing to files etc) makes the go code quite nice. Gorram and Mage both generate code that gets run by the go tooling, they're very Go-specific, but the fact that I can compile fast enough to generate and compile code without the user feeling like things are running too slowly is a huge win. of course, in an interpreted language, there's no compilation step, so it wouldn't apply. Go's strong standard library means that I don't have to reach for third party libraries that often, which makes my code easier to build and more reliable. Go's error handling means that I always know what calls can fail, and so I think about what I should do if something fails every time.... this makes my programs more reliable. 
Thanks!
I used to use [testify/assert](https://godoc.org/github.com/stretchr/testify/assert) (you seem to refer to it, too), but have switched to vanilla [testing](https://golang.org/pkg/testing) for several reasons. First, you have to manage one more dependency. This may be fine for bigger projects where you need dependency management anyways, but for small, self-contained libraries this could mean introducing it, which is a big step, relatively. Second, it is something every developer has to learn. It is fair game to assume that developers know the standard testing package, and if not, they would have to learn it either way. Learning an assertion API is an additional obstacle. There are also disadvantages, I must admit. You have to write a bit more code, especially for tests like the ones I wrote recently where items (with specific properties) should be contained in a slice, but at what index wasn't defined. This can mean writing a few lines, wheras with an assertion framework you would have written a one-liner. But I still think the cons (against an assertion framework) outweigh the pros.
At Serotiny we've built a 'biologically aware API' in Go that powers the design, construction, evaluation, and prediction of novel proteins. It's fast, strongly-typed, interfaces well with machine learning systems, supports immediate deployment across many different kinds of systems, and is easily readable/approachable for newcomers. It powers our genetic design web-app found here: https://serotiny.bio/pinecone/
A cross-platform code signing and package signing tool called relic: https://github.com/sassoftware/relic Supports signing a wide variety of file types (windows executables, RPMs, even .appx and visual studio extensions) using private keys in a HSM or plain file. Can run either standalone or in a client-server mode that is very efficient and doesn't require any scratch space on the server. Go was a great choice since being able to string together pipelines of bytes is a cakewalk. For some file types it ends up spawning half a dozen different digesters consuming different streams of bytes all without buffering anything to disk. There's also a wide variety of cryptographic algorithms and crypto-related encodings (ASN.1 in particular) ready to go that support a surprising number of use cases. Doing low-level crypto stuff in Python can be like pulling teeth because libraries tend to only expose the bare minimum functionality.
Goaty McGoface, obviously.
Thanks for your opinion. The service is already running and self providing. If no certificate is given, it generates one, but you're free to configure your own key and certificate or even generate requests for a CA. The only thing missing is the verification of the chain. Wrong chains won't crash the service, it may only cause the client to display a certificate warning. You won't be able to mess up the config that the service can't start. The worst thing is the fail safe with a self-signed certificate. The certificate chain check is just the icing on the cake. But I'll postpone this [again] and work on more pressing concerns.
Greenlight IDE (Go = greenlight, Stop = red. You get the idea.)
I very much advise you to take your time and watch [The Three Fallacies of Dependencies](https://www.youtube.com/watch?v=yi5A3cK1LNA) by Blake Miserany — it's fun to watch and it deals precisely with your use case ;-)
Goku
I like Greenlight. That's a good one.
Go Gland. I mean uhh... AlphaGo, like the AI
Getbrains
I made a stress tool for lorawan network server http://lorhammer.itk.fr It permit to stress your infra before your real sensors break your stack. It's a "work in progres" project but feedback are welcome ;) Futhermore, i made a tool to auto update dependencies with direct pull-request (or merge-request for gitlab) https://gitlab.com/ContinuousEvolution/continuous-evolution The idea behind this project is to open pull-request and developer can choose what to upgrade directly in GitHub (or gitlab). And to update all things in one shot (front npm, back pip/Maven, infra docker/docker-compose...) The configure by pull-request will happen when https://gitlab.com/ContinuousEvolution/continuous-evolution/merge_requests/36 will be merged ;) We have not lot of tools manager today because we want to stabilize API before adding lot of implementations but help is welcome ! And we will not refuse yours ;)
Gode
A little cross-platform textmode file manager https://github.com/TheJare/jm Go is the easiest language to come back to after months of not using it. Also the cleanest cross-platform experience. It's just cozy and comfortable. 
One thing that I suspect is an apparently blocker for some people is when they don't know about [reflect.DeepEqual](https://golang.org/pkg/reflect/#DeepEqual). But it is in the standard library. There is a library or libraries on github that can stand in for reflect.DeepEqual and tell you what the differences are instead of just returning true or false. I don't leave them in my code in the long term but it's useful for debugging. (I'd go find them but I'm getting rushed out the door.)
I've been building trading bots for crypto-currency exchanges. Easy concurrency and excellent http and websockets libraries make Go very well-suited for this. It's a fun and exciting project that has, at times, been quite profitable.
I've got Digger, Burrow, Diggo, and just plain Gopher. Good luck. :)
I'll do that for sure once I get to work on monday :)
Doge. wow such err many check wow
Building the leaderboard around SQL is interesting, not sure fast it is, I'm sure you looked at Redis as well?
GoFaster
Gojo (go dojo)
Gogeta
GoIDEr
Alternatives? What would you call it?
Wait. Why is it codenamed gogland? I don't get it. Gog-land?
I had "Indigo" in might, but there is already an IDE named like this: http://indigo.mapmasterz.com/
Whew. I'm so glad Gogland isn't the final name.
Gogland is an island near Kotlin, which is an island (and their programming language name), which is near St. Petersburg where one of their development office, and the Gogland team, is.
I believe it was codenamed after [this island](https://en.wikipedia.org/wiki/Gogland), because it starts with "Go." I think JetBrains has a thing for [islands](https://en.wikipedia.org/wiki/Kotlin_Island).
**Gogland** Gogland or Hogland (Russian: Гогланд; Finnish: Suursaari; Swedish: Hogland, Estonian: Suursaar, German: Hochland) is an island in the Gulf of Finland in the eastern Baltic Sea, about 180 km west from Saint Petersburg and 35 km from the coast of Finland (near Kotka). Hogland has an area of approximately 21 km2 (8.1 sq mi); its highest point is 173 m (568 ft). It belongs to Russia's Kingiseppsky District in the Leningrad Oblast. Hogland's tourist industry is growing in importance, with most tourists coming from St. *** **Kotlin Island** Kotlin (or Kettle, Finnish: Retusaari, Swedish: Reitskär) is a Russian island, located near the head of the Gulf of Finland, 32 kilometres (20 mi) west of Saint Petersburg in the Baltic Sea. Kotlin separates the Neva Bay from the rest of the gulf. The fortified town of Kronstadt is located on the island. The island serves as a gateway to Saint Petersburg and as such has been the site of several military engagements. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
heh. who knew. gogland just reads weird to me. nice to know its named after something else though.
GRV - Git Repository Viewer: https://github.com/rgburke/grv GRV is a terminal interface for viewing git repositories. Refs, commits and diffs can be browsed through. Ref’s and commits can also be filtered using a simple query language. It's not complete yet and is under active development with new features still being added. I found the development much more straight forward and quicker using Go, especially compared to C which I did initially consider using. The standard library is comprehensive and well documented. There's also an extensive set of quality libraries available which have been developed over the years and are easy to use in a project. Having garbage collection helps a lot. No matter how diligent I was when using C there would always be a memory leak or double free somewhere. I chose Go in the end as I was impressed with the language having spent a weekend trying it out. The good support for concurrency and language features such as channels were a big plus. I also liked the fact it integrates really well with C using cgo, as I wanted to use a couple of C libraries. Finally the performance is good and compiling down to a single binary is a nice bonus.
I'm building an open source minimalist and clean alternative to UserVoice, where the community can suggest, discuss and vote on ideas/feature requests/suggestions, etc. https://github.com/getfider/fider is built with Go, React and TypeScript
Gotbrains
No kidding. Why are we trying this hard to avoid a standard?
Goldsmith
Well that's what the link was for! I'll edit it
[removed]
Try https://github.com/google/go-cmp it usually solves all the problems with assertions. You do a normal if and get a diff like in python or groovy. 
[removed]
1.) A git based code review tool incl. web interface. It's a lightweight gerrit clone and also has a command line tool to create change lists, view status etc. I wanted something similar to gerrit but which is simple enough to setup and use (for small teams). It's in production in our company for almost a year but some features are still missing like pagination, notification via email (notification via chrome desktop notification works) and some goodies like that. Maybe I will open source it one day (if there is any interest). 2.) Go is a lot simpler than other languages but still fast. I also like that it compiles to a single binary. 3.) Simplicity for setup &amp; cross-compilation.
I picked up go a few years ago because I wanted to learn a new language and fell in love with how fast I could spin up a functionally useful server that could do real work. I've used it for several web scale systems and a bunch of tooling and automation. The most interesting things were stuff like a access control service that used a mix of data sources (some flat files, some DNSBL, MySQL, and some NoSQL based systems) together behind a single API call. The part I loved about it is that we found that it could handle enough DB requests to melt the DB and still serve up responses from the DNSBL or cached flat files with almost zero impact on the normal response times we see for request that use the cached flat file or DNSBL data. Goroutines are awesome.
I made a Mandelbrot fractal generator: https://github.com/marijnfs/gomandel It was quite easy to make it multicore because of go functions.
I have found Google's own `cmp` https://github.com/google/go-cmp to be very friendly for these needs.
I've made a messaging bridge that links lots of different protocols and messaging queues together in various configs: https://github.com/Jeffail/benthos And also a collaborative code editor for editing local files over LAN, similar to how it works in google docs: https://github.com/Jeffail/leaps
NiggerGo
Gotbrains
how fast does a leaderboard need to be
Me too
Go Gland
Gogiga Gagagigo
This is the only name that matters
GAY-DE
Gonada
iferrnotnil IDE
[Inigo](https://en.m.wikipedia.org/wiki/Inigo_Montoya)
**Inigo Montoya** Inigo Montoya is a fictional character in William Goldman's 1973 novel The Princess Bride. In Rob Reiner's 1987 film adaptation, he was portrayed by Mandy Patinkin. In both the book and the movie, he was originally from Spain and resided in the fictional country of Florin. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Gonads
Gonads
Gonads
I like your videos. But my question is does anyone know what code editor u/campoy is using?
Goliath
https://twitter.com/francesc/status/918639049056968709
Gobrains
Thanks! I've been using Gogland but not a fan of it being based on Java and using so much battery life. Going to give Visual Studio a try!
Gode
[removed]
Rusty. 
I've never understood that second G. It makes the word so cumbersome. 
So true. Even Goland would have been better, if not much better. I wrote "Go true." the first time. What is happening to me?
Yeah it compiles into a single binary which is really cool, but there are usually other files that are not embedded (html, css, js). I wrote bash script that copies public files and compiled binary together in one folder, but it's kind of annoying thing to copy and paste this script in every little project. How do you deal with this problem?
GoGo
Gogland is an island near Kotlin, which is an island (and their programming language name), which is near St. Petersburg where one of their development office, and the Gogland team, is.
Gogland is an island near Kotlin, which is an island (and their programming language name), which is near St. Petersburg where one of their development office, and the Gogland team, is.
I'm curious what this IDE does that LiteIDE doesn't? Just trying to understand the value proposition of what looks to me a commercial product...
Gopherit
Sounds neat. I'd love to see that. 
You can see some of the features described here: https://www.jetbrains.com/go/features/ The list of things the IDE can do is simply too big to go thru in here. Try it and see if you like it. If you don't, that's fine.
GoStickYourHeadUpADeadBear'sArse
GoJet
Hi Everyone, I am Arafat. I am the lead developer of [Tensorflow.rb](https://github.com/somaticio/tensorflow.rb)(The Ruby API for Tensorflow). I have also experimenting with Golang and recently developed a plotting library. I hope you guys like it. Feel free to ask any questions about Tensorflow or Glot. 
Burrow is already this crap Kafka monitor written in Go. 
At this point they may as well just keep the fucking name. It's dumb, but for better or worse it's got name recognition and by keeping it, google searches will remain relevant
Goosebumps
&gt; Gogland is an island near Kotlin, which is an island (and their programming language name), which is near St. Petersburg where one of their development office, and the Gogland team, is. Gogland is an island near Kotlin, which is an island (and their programming language name), which is near St. Petersburg where one of their development office, and the Gogland team, is. Still keeping it as Gogland is an option.
https://www.reddit.com/r/golang/comments/75y7pv/is_go_good_choice_as_first_programming_language/doavmri/ https://www.reddit.com/r/golang/comments/75y7pv/is_go_good_choice_as_first_programming_language/do9vkqw/ https://www.reddit.com/r/golang/comments/75y7pv/is_go_good_choice_as_first_programming_language/doah7hn/ Thats 3 retarded comments on *one* thread https://github.com/cheekybits/genny https://github.com/gernest/wow And 2 retarded repos that shouldnt be a thing And it took me all of 5 minutes to assemble this damning information. If you can do the same thing with Haskell in say 3 times as much time, you can be remembered as something other than the imbecile go troll who spent any amount of time creating an imgur of the Haskell logo with the title "profound imbecile" You're going to fail because the condensation of blithering idiots in the community is unmatched even by Javascripters
Official way of naming Go-related things: $ grep -i ^go /usr/share/dict/* | cut -d: -f2 | sort -R | head -n1 gondola
Great job dodging the challenge, troll. Any Haskeller worth their salt could solve the challenge. The fact you can't even see it tells me enough about your ineptitudes.
Now that sounds remarkably close goats*COUGH*well look at the time, I really have leave.
Gozone. It’s a Go Zone, and you get the Ozone thing for free. 
Looks awesome! I maintain github.com/wcharczuk/go-chart as well, which has more of a focus on technical analysis. This looks amazing so far though, nice work.
GoGoGadget
Thanks a lot. go-chart is really cool and beautiful. I will certainly have to dig through the code. 
Goast
Also refers to red green TDD, this is cool
And rename the company "We The Best Coderz"?
I wrote a memcached proxy/server for use at Netflix to enable a disk-backed memcached-like server: https://github.com/Netflix/rend/ Currently helping us save a boatload of money by enabling more efficient storage of large (tens of terabytes) data sets in cache. Go was fantastic for this purpose because *there is no magic* and I could dig in as deep as I needed to in order to make it fast. Case in point: the histogram code in the metrics package even has some assembly to help with bucketing values: https://github.com/Netflix/rend/blob/master/metrics/lzcnt_amd64.s We're using RocksDB to do disk storage, so the CGo performance, even though people rip on it, has been good to us. Currently it's doing over 5 million operations per second at peak with Go only adding something like a few dozen microseconds of latency, so it looks like Go was the right choice for us.
Ahh. Interesting. Still not an easy word for my American mouth to pronounce elegantly though. 
"Clippy".
https://github.com/eikenb/udev-notify Nothing big, but really scratched an itch I had for a long time. It is a tool to watch for device Udev events, matching on a property and running a configured command. Designed to run as part of a user session to do things like use xinput to configure devices. 
&gt; Gogland is an island near Kotlin, which is an island (and their programming language name), which is near St. Petersburg where one of their development office, and the Gogland team, is do you type this out each time, or do you copy/paste it from a file somewhere?
Carl Spackler
itelligo
Because JavaScript slows your i7-9999k down to a crawl and uses an hour of battery life 
Goliath 
Intelligo
Oh i almost forgot. One such retarded comment was yours and is the subject of an entire programmingcirclejerk thread https://www.reddit.com/r/programmingcirclejerk/comments/75p5de/go_is_generally_considered_to_be_more_terse_than/
Trolololol can't solve a simple programming challenge and can only argue with name calling. Love it. Keep it up.
That's cool. Count me in as a customer, I've been jealous of these for a while. While we're on the topic of commercial gophers, I just got back from visiting family and my aunt made me a [cute Gopher](https://i.imgur.com/muTikxil.jpg) out of felt. She has an etsy store, so I asked her about it and she'd be up for making them for sale. She can't mass produce them, but she could make a custom one to your specs. Feel free to PM me if you want your own gopher. 
I wrote Sparkyfish, an open-source network speed tester, inspired by Speedtest.net, but with a server-side piece that you can run yourself. Unlike Speedtest, the ISPs don't purposefully prioritize this traffic higher so you'll get a truer picture of your actual speeds: https://github.com/chrissnell/sparkyfish [Screenshot here](https://imgur.com/T3IRjwZ.gif)
I wrote a program to do Raymond Smullyan's Tableaux Method of proving that a propositional logic formula, a command line tic-tac-toe variant called "squava", self-replicating program, narcissist program, almost-narcissist program https://github.com/bediger4000/tableaux-in-go https://github.com/bediger4000/squava https://github.com/bediger4000/Self-replicating-go
Took the words right out of my mouth.
goatsy. there, I said it in a much less obnoxious manner
YoullNeverGetGenericsIDE
What advantage does this have over the many JavaScript graphing libraries that allow interactivity like zooming, getting data values by hovering the mouse over the line, and so on?
 gonorrhea
&gt; Go is generally considered to have whatever properties are convenient for the point I'm trying to make Tell me more about what Go is generally considered to have 
I will forever read it as go-gland, but I’m used to it now so I vote to keep the same name.
Definitely interested. I assume you would ship to the US?
Diego
I love plotting! .....and conspiring
Fazal. I gotta be honest with you. I don't think that Glot is better than the alternatives you suggested. I think of it as a tool that I made for fun and that works really cool with Golang. Obviously, for more serious visualisation needs there are much better alternatives that won't use Golang at all. However, If a developer needs to work with golang and needs a simple functionality for plotting(1-d,2-d plots) real fast then glot seems like a cool option. 
Green light.
Gonorrhea it is.
Look at SocketCluster for Node. 
Not to flame or something, but just surprised - isn't it the same as [port forwarding in SSH](https://www.ssh.com/ssh/tunneling/)?
I’ve been needing to generate charts to send over email for a while now. Now I can do it in Go! Thanks!
Gotcha
Godlike
https://github.com/opennota/tl A web app for translators. There's a GIF screencast.
Goanchor cause that's what it is. https://usesthis.com/interviews/rob.pike/
@pinpinbo That's great. Go ahead. 
Slow
I kinda like this tbh, its simple.
powerrangers.
Cache Invalidation.
Lingo https://www.google.com/search?q=lingo+definition
Godzilla
Going
&gt; IntelliGo, I guess this suits best. 
The fact that go gets posted on programmingcirclejerk all the time is something that makes me happy-- I'm glad you're all wasting your time making fun of your misconceptions while we're off being productive.
Gouda Graphene
Awesome!!
Quick user interaction/quick user feedback? I don't know.. they don't fit properly in a sentence. Maybe someone else have a better idea.
Gopher!
I imagine its hard to be productive when you're writing if err != nil { shitNotAgain() selfHarm() } all the time. Must get carpal tunnel at least? 
You don't write Go and are only on this subreddit to troll. Please leave. Don't come back.
Very nice! Been looking for something like this. Thanks!
I like Glide (GoLang ide) 
Goofy, Good, Gordon, Goal, Gone, Gobbled, Goodness I am terrible with names, sorry about those :) 
Why are you using strings, and parse them? A nicer alternative could be using constructors (i.e. String, Email, IPv4... functions which return a validator) -that way no more []string{} and get rid of parsing, too.
Hmmm. I didn't realize you were actually using Gnuplot under the hood. You could export to SVG instead of PNG using the relevant terminals.
We use this in production on a few sites, and it might as well be 1.0. 
Originally suggested here: https://www.reddit.com/r/golang/comments/7666p8/help_us_choose_a_name_for_our_go_ide/dobmev1/
Just cache it, who cares
Not program but package, which mostly runs in the background of the programs it's used in, so I consider it a program. GoLog, a package to use during development. Lets you set logging methods in a variety of ways, many of which don't require you to change your code. 1. You can easily add your own log methods, such as dumping logs to mongoDB or sql 2. You can add your own methods to change* your active log methods on a function by function basis, while your code is running, such as changing them from a gui or a text file. 3. Runs concurrently, so benchmarks are fairly accurate and it doesn't interrupt your actual program all that much. This is the first non-proprietary thing I've worked on, so if any of you feel you would benefit from having access to an efficient logger that doesn't make you constantly edit your code then pm me and I'll link it to you when first draft is done, likely this next week some time. Wanted to get some beta testers before moving forward
Could you please give an example using the existing validatior, it would be much more clear. 
Only web development can be give us a we control ability.fro this reason everyone can be control this and use this. 
I'm engineer at Schibsted Media Group My team created an automatic Ad moderator, reducing the fraud in 20%
Goatbrains
I [created](https://bitbucket.org/zurichess/zurichess/overview) a chess engine: www.zurichess.xyz. It's quite strong at ~2800 Elo, ranking around 60-70 of all chess engines. Afaik, it's the strongest chess engine written in Go. The main issue I had (and still have sometimes) was the performance. I did some Go compiler [improvements](https://go-review.googlesource.com/q/owner:brtzsnr@gmail.com) for the SSA backend which was a great experience. I'm comfortable with both Go and C++. For this projected I used Go because I didn't want to waste time debugging memory issues nor focus on micro optimizations. Now there are enough tools for C++ to address my initial concerns, but Go also has come a long way, too.
Like the package manager? that won't confuse at all...
I made a feed aggregator that I use on a daily basis. Almost finished with 2.0 as well. https://github.com/urandom/readeef
Using SSE and something like 5 lines of JavaScript would be a better solution. SSE works over HTTP2, whereas WebSockets won't and would need more JavaScript. 
[removed]
I will laugh my ass off if this gets selected, but I won't complain :D
goide 
It took you 1 month respond. Quite ironic for you to use that word. ;)
Of those i've seen so far, my favourites are gode, gochan and goku
The term responsive is used for something entirely different in the context of web apps. A better title might be "Better UX even with no JavaScript". I'd also prefer if you had a live demo or at least screenshots showcasing the UX. It's a little baffling to read an article about UX and offer no screenshots in my opinion.
I wrote an AI module for a nao robot. The module is meant to let the robot win at word games. Why go? We needed fast development to test different strategies, an efficient language to perform more simulations in the alloted time, and we needed dead easy deployment on the robot. Nothing but go came close of solving those needs.
I've been using testify for a long time now, on both big and small projects, and I'm really uncompelled by statements like "vanilla testing makes for more meaning tests" or "it's one more thing every developer has to learn". I'm not even sure what the basis of the former statement is, and while the latter one is true, the learning curve for testify is very small. If you're just using testify's assert/require packages, it's the most intuitive thing in the world to every developer I've introduced it to. I've found time and time again that when your project uses only the standard testing package, the output when tests fail tends to be completely useless. People don't like spending a lot of time writing tests and often just throw in `t.Fail()` statements rather than figuring out and printing the actual and expected outputs of their test subjects. Don't be put off by testify's lack of updates. Its assert/require packages are pretty much feature complete, and I would recommend them.
Sounds like you have some other issues if making a simple AJAX call in JS winds up your computer's fans.
Hey sorry it's a bit late, but take a look at my code coverage utility: https://github.com/dave/courtney ... you can mark blocks / files to exclude from coverage with the a simple annotation "// notest". Additionally it automatically excludes any error return blocks. Check out the readme for the reasoning behind this.
Yes! I love it. Programming circle jerk being used to support your case! MOAR!
Looks like the clean up was unsuccessful after the [test](https://github.com/golang/go/blob/release-branch.go1.9/src/cmd/go/go_test.go#L3402)
`ls $GOPATH/bin`
 lukasz@kerak ~ $ ls $GOPATH/bin backend gocode godef gomodifytags gopkgs goreporter go-symbols guru migrate.v1 dlv gocyclo golint go-outline gorename goreturns gotests impl sql-migrate 
Could you please post the result of : go env
echo $PATH
 lukasz@kerak ~ $ go env GOARCH="amd64" GOBIN="" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="linux" GOOS="linux" GOPATH="/home/lukasz/go" GORACE="" GOROOT="/usr/local/go" GOTOOLDIR="/usr/local/go/pkg/tool/linux_amd64" GCCGO="gccgo" CC="gcc" GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build082006211=/tmp/go-build -gno-record-gcc-switches" CXX="g++" CGO_ENABLED="1" CGO_CFLAGS="-g -O2" CGO_CPPFLAGS="" CGO_CXXFLAGS="-g -O2" CGO_FFLAGS="-g -O2" CGO_LDFLAGS="-g -O2" PKG_CONFIG="pkg-config" 
 lukasz@kerak ~ $ echo $PATH /home/lukasz/bin:/home/lukasz/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/go/bin:/usr/local/go/bin It appears that /usr/local/go/bin is duplicated, but can it be the case?
Do the packages you tried have a main in the git root? Try: $ go get mcquay.me/cs Or recursicesly try the ones mentioned: $ go get github.com/user/project/...
Did you install several versions of Go ? I normally set my PATH in .profile on Linux heres are my .profile: # GOLANG export PATH=$PATH:/usr/local/go/bin export GOPATH=$HOME/go 
Try adding GOPATH/bin to your path. That is currently missing.
Thanks! Looks like it works now ._.
People don't understand sarcasm unless /s is printed behind it, bolded.
Hey, problem was in my PATH env, it had missing $GOPATH/bin :)
Your welcome. I too have suffered through setting up the environment and through pain have learned! 😁
[removed]
I'm dying to know what x.exe is
Did you ever work with a leaderboard? If you have millions of players it needs to be fast.
[removed]
Yeah cache things that keep moving...
[ssh-chat](https://github.com/shazow/ssh-chat) was very fun to build and a lot of people like it. It's a custom SSH server that presents an IRC-inspired chat room instead of a shell. You can give it a try by ssh'ing into chat.shazow.net: $ ssh chat.shazow.net The reason I built it (or built it in Go): I was reading through the Go standard library (which I'm a big fan of) and I noticed the excellent [x/crypto/ssh](https://godoc.org/golang.org/x/crypto/ssh) and I thought to myself: It wouldn't be too hard to make a chat room out of this! Few hours later, I had a basic prototype. The things got out of hand and I fleshed it out into a full chat server.
Kindly keep me in the loop too.
Would something like this be Tor (NoScript) friendly?
&gt; The binary is left over from running TestImportMain in cmd/go. It's harmless. We should remove it, but it's harmless. Any virus scanner that thinks the binary is a virus is wrong. [src](https://github.com/golang/go/issues/22266#issuecomment-336651285)
sudo rm -rf /
Isn't the word you are looking for Reactive? Responsive means the layout changes with screen size.
Yeah absolutely.
&gt; in the C case I’ve turned optimisations off else the compiler spots the work is trivial, elides it and then it takes no time. 
I'd second this. I've had great results with testify/assert. I like it's functions for Equal, Len, NoError and NotNil. That's about 90% of what I use it for. And (this may be obvious, but still...) using it doesn't mean you have to only use it. Write vanilla tests where it makes sense, use the assert helpers where they make sense. And the point about formatting is not a trivial one. The assert.Equal has a nice feature that if you give it two byte slices and they are not equal it will show just the differences. That saved me a big headache once. Finally, slightly off topic but... write [table tests](https://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go) where you can.
If $GOPATH/bin was missing from PATH I believe that it would have still installed but you would just be required to type the entire path to the executable. Is it a different problem? BTW set GOBIN (it requires a full path) if you want to use "go install".
😂😂😂
Leaps sounds/looks like a cool project! I'm impressed!!
This technique looks so hot. I can’t wait for excuse to build something using this. 
Wouldn't that cause a problem by using redis since the dataset (probably just usernames sorted by score) needs to be kept in memory at all time and most of it will never be accessed anyways? I haven't had to solve this problem myself but I would tend to agree with you that redis is fast and simple enough for a leaderboard. 
In the same vein as PyCharm, I propose GoDiva. The command line tool should be called `diva` and the pronunciation of the IDE's name is "Go Diva". :P
Not as far as I can tell, but if you want go + make, maybe you want Makefiles written in Go? https://github.com/magefile/mage
Is there any reason to consider this now or in the future as an alternative to Kafka?
I made a [DNS server](https://github.com/abh/geodns) that runs the DNS service for the [NTP Pool](https://www.ntppool.org/). Something like hundreds of millions of users, several billion DNS queries a day on a tiny budget. (You can look up with Google or AWS charge for 60 billion queries a month). The staging version of the NTP pool is using a Go program to [do the monitoring](https://community.ntppool.org/t/beta-site-changes-monitoring-updates/659) of the servers, too. The original version of this was in Perl. I used Go because it was an easy way to get something production ready that's faster and can use multiple CPUs. At the time the system got less queries and the Perl version actually worked fine, except a few times a day when the query rate briefly spikes to several hundred thousand basically within a second.
I wrote a sentence tokenizer CLI and API written in golang. * https://github.com/neurosnap/sentences * http://sentences.erock.io
I want to ask this stupid question in a long time. Is Nats streaming (persistence) similar to gRPC streaming?
NATS Streaming does not support clustering. So you have only one instance and therefore SPOF. https://github.com/nats-io/nats-streaming-server/blob/master/README.md#clustering
looks nice, we use nsq; I'm waiting for redis streams http://antirez.com/news/114 and I think we will be replacing nsq with streams so that we can take advantage of the many other redis goodies.
I have built https://engossip.com and my personal website http://turalasgar.pro on Go. Go is my favorite language.
Godo
Glide 
How are you dealing with nikto's licensing for the db?
nikto is GPL and I only link to nikto
Are you using the db directly or wrapping Nikto? I member the db files had a different license than GPL. If you are just weapon= a guide why not tcl/tk?
This is what caused me to stop looking at NATS as an option and it sucks, I really wanted to use it. 
RIP
I ended up using only NATS request/reply and implemented the streaming functionality in Microservices. I can't wait until there is clustering functionality, even though I have been waiting for one year already, and it gets disappointing that is still not ready.
I wrote server with api for capturing screenshots of websites https://github.com/gen2brain/url2img , and app that can turn any webcam into an IP camera https://github.com/gen2brain/cam2ip . Also, I created an app to watch and stream movies from magnet links https://github.com/gen2brain/bukanir .
We already use Kafka and I was looking at it as a possible alternative for a project so it wasn't a huge deal but I still enjoy looking at new tech. Maybe someday we'll end up using NATS.
Im just calling/wrapping nikto... and why? because I hate python I learn to code in 1985 with basic then C... and until python developers do not get their shit straight between 2.x and 3.x I am just doing low level languages like C/GO do not take me wrong I can and do use pythong sometimes.. but I try to avoid it as much as I can
Python has the problem of any massively successful product doing a bunch of breaking changes, they have their shit together. It takes a long time to migrate a huge code base when you can not use tools to do it effectively
Tk/TCL is one of the fastest ways to make a cross platform GUI desktop app 
yeah that makes sense when is 1-2 years after upgrade... but we all knew 1 year before the change and 5 years now or more after what was going to happen.. if devs did not change, seek or cared about this.. is not the users fault... you know how fuck up is for a linux distro mainteiner to have to support 2 sets instead of 1 just like any other language?... and yes pytho is popular because is dam easy.
Thank you very much, I'll give it a try next time I iterate over this particular project. :)
QT is cross platform and is very nice and KDE/PLasma have a long way with it.. 20 years now. 
and pardon my ignorance but is not tcl/tk for scripting hight level languages?
They are distribution maintainers, that is their job. First the language needs to stabilize, then major projects need to port their code and keep things running and then end users need to port their code. There is a lot of testing, bug fixing and waiting for the previous step to stableize so you don't waste lots of work. This takes years
We use json for snapshots that contain data from multiple tables about some user at given moment of time. Like {"user_id": 123, "contact_data": {"msisdn": "12346789}}. We are doing that for some kind of log, to know how data was changed over time - those "snapshots" are generated by trigger on UPDATE and INSERT. Sometimes it is useful to fetch all data from snapshots instead of doing multiple joins/requests - another use case.
Any reason why you are not using https://golang.org/pkg/flag ?
Just because I didn't know about that.
Your readme could do with some work. See https://www.makeareadme.com/. The way you have it now 99% of people visiting will hit the back button within 3 seconds.
Ah okey :) Well done anyways! Recommend you to check it out! Golang have alot of good packages in standard library.
Thank you. I'm sure there are some things which can be improved. But I wanted to ship an early MVP before over engineering it :)
&gt; they have their shit together Until strings containing surrogate escapes are flagged in some way, no, they don’t.
I was talking in reference to the migration from 2.x to 3.x as a long slow process. Not the entire language 
I have used NATS Server extensively (and I'm very happy with it), but not NATS Streaming Server (yet). Should take a look at it.
You should really look at https://github.com/hashicorp/go-plugin/
Single binary with no dependencies as in libraries, secure, self contained (no zookeeper reequired), fast, no Java (written in golang), fast
Leaderboards are an interesting problem space, and depending on the features of the leaderboard, you can extend the complexity even more. For instance, do you want the leaderboard to only show the top 100, or a hay-stack query to show where the current player is in the leaderboard. If it's the former, caching the data could be generally ok because once the leaderboard settles the top X players rarely change. Hay-stack queries are more interesting, on one hand the player wants to know exactly where they are, but no point giving an exact rank information because the leaderboard could be moving up and down at snapshot, so as long as the rank is somewhat in the expected region it should satisfy the problem. Solving both types of leaderboard queries in redis is challenging because of three reasons; A) Depending on your key design, you likely will end up duplicating the information across two tables, one sorted by rank, the other sorted by username and other bits of meta information. B) Scaling redis means sharding it, which brings a whole lot of headache and data re-partitioning which is just a whole lots of devops problems. C) Usually leaderboard entries have some meta information associated with them. For instance, if you are storing race track times, you might need to store the track/weather conditions with it (see Top Gear), or more common example (from experience dealing with thousands of games), facebook profile URLs. Last point, especially about Nakama: We made the conscious decision of going with Go because we wanted to ship one single binary, and in the same manner wanted to only depend on one database, rather than a plentha of different databases that are optimized for one single purpose. We internalised a lot of different things within Nakama. For example, Nakama doesn't depend on etcd or zookeeper for service discovery, it's built-it to Nakama. The goal is to keep the server running as easy as possible. We optimised (the hell out of) the queries that we ran against CockroachDB / Postgres to make sure that the API commands directly hit indexes and are as performant as possible. We've documented as much of the queries like this one: https://github.com/heroiclabs/nakama/pull/43 We've `EXPLAIN`ed every query to make sure all is checked, and how they perform across clusters of Cockroach nodes. Hope this sheds some light :) 
Migration per se was never the issue. Folks were still starting new projects in Python 2 long after 3 came out. The main issue was (and still is) that you don’t get much in return for using 3 over 2, especially if you’re porting working code to 3, and it handles very common situations worse than 2, due to features that are *still* lacking. 
GOD. - which ide do you prefer for golang? + GOD
Apparently I fail at posting on reddit. I am looking for feedback on whether the code is idiomatic, and some suggestions on the read and write functions for testability. I actually use this tool for day-to-day todo management. It helps me track time against tasks, and makes reporting a breeze.
I assume the group you're wondering about is users of Tor who might want and value interaction, ux, etc but whom will value privacy more. There are lots of site categories that might value Tor-using customers. Personally, I don't develop for any of those categories.
Thanks for the advice. I haven't seen this resource yet, and it certainly looks good. I was pretty tired when I released this.... The whole "okay, it's done! git push, release!" workflow is something I need to iterate on ;) Will see about pushing out an updated README soon.
What did you try and what was the error?
error was whole my life. beside the joke, publisher hasn't added any guide for windows.just for docker and linux. 
It's getting very close: https://github.com/nats-io/nats-streaming-server/issues/316#issuecomment-335522449
I had a look at your code. I loved how clean is your code by now. I created a very similar tool ([act](https://github.com/gumieri/act)). Feel free to look at it. If allowed by you, I will "take some inspiration" from you ;)
Awesome! It's a cool project, obviously a lot of work - I'd recommend spending some time describing what it supports though. From my perspective as a user, what features does this have above ngrok 1.x ? It's really hard to see if I should invest in this new library when that one is already open source (https://github.com/inconshreveable/ngrok)
On Gophers Slack, https://gophers.slack.com/ (invites from here: https://invite.slack.golangbridge.org ) we have a special channel dedicated to those that seek or offer Go jobs named #golang-jobs . Feel free to join us and hopefully you'll find something that suits your needs.
I took a look - I think your project is much more ambitious than mine! All of my interactions are local, and are not integrated into anything other than the filesystem. As far as testing the commands, I'm assuming that the flag package works as intended, so I'm just testing that my functions respond appropriately to vars of the same type. I found [this](https://talks.golang.org/2012/10things.slide#8) via another post. I suppose I could return the interface from a dataFile function, and use that interface in the read and write functions. Still pondering that. 
You might install Docker for Windows and go from there. (Docker is in general a good idea here, since `gotrace` uses a patched Go version, so I would rather have it inside some container than directly on my machine.) The downside is that you need some Docker knowledge in case the steps in the readme do not work as expected at your end.
http://hottopicsnews.com/ - the curated list of news and topics. It's more news aggregator now but I'm working on machine learning stuff to make it more interesting.
well isn't that hard to explain? i mean using docker for visualizing simple go program. i think it will be great resource for any student who want to learn concurrency.
Not OP but thanks for the tip, I left a message there based on your tip.
I read it as Go-gland. 
* [sirdsc](https://github.com/DeedleFake/sirdsc), a SIRDS generator. The code's really old and in severe need of some pretty heavy refactoring and reworking, but it should still work. * [WDTE](https://github.com/DeedleFake/wdte), a simple, embeddable, functional-ish scripting language designed primarily for integration into existing projects. For example, want to be able to integrate some really simple scripting into a game you're working on? WDTE can be integrated with very few lines of code and absolutely no need to worry about VMs the way you do with a 'full' language like Lua or JavaScript. * [imgsize](http://imgsize.herokuapps.com), a simple middleware for doing on-the-fly image resizing.
You might be able to do it with [jsoon](https://github.com/itsmontoya/jsoon), but it's no where near production-ready. If you decide to use it and encounter bugs, submit a github issue
Easy. Use the existing json grammar with antlr. Have antlr generate your parser code, and write event handlers to handle the begin/end events as the string is parsed. http://www.antlr.org https://github.com/antlr/grammars-v4/blob/master/json/JSON.g4 It's a bit of a learning curve and not terribly well documented, but it's lightning fast and rock solid stable. 
you were correct, I will open a pr for the doc/examples lol. 
Absolutely, Please use anything you like! 
- Go-Fu - Id-Ego https://en.wikipedia.org/wiki/Id,_ego_and_super-ego - Godot https://en.wikipedia.org/wiki/Waiting_for_Godot
`[]json.RawMessage`, and perhaps `json.Decoder.Token`. How will you know what types the items will be? For example, does the first item dictate the types of the rest? If so, http://eagain.net/articles/go-dynamic-json/ and http://eagain.net/articles/go-json-array-to-struct/ should show you the way.
The article is written, I'll post it this morning when I get to work (in 2hrs most likely) 
 func returnByIp(w http.ResponseWriter, r *http.Request) { params := mux.Vars(r) for _, item := range routes { if item.Ip == params["ip"] { json.NewEncoder(w).Encode(item) return } } json.NewEncoder(w).Encode(&amp;Route{}) } // This is what it looks like atm. However it only returns one item matching the IP. Doesnt look for the other results. Maybe I need to make it a string before I range it?
Defer your close after checking errors. Not before Also, you can remove one tab level from a lot of your code with early returns, I think Other than that, looks good. 
 func returnByIp(w http.ResponseWriter, r *http.Request) { params := mux.Vars(r) for _, item := range routes { if item.Ip == params["ip"] { json.NewEncoder(w).Encode(item) return } } json.NewEncoder(w).Encode(&amp;Route{}) } // This is the function currently. However it only returns one result. Any idea how to make it return many results?
This project started because I was curious about gRPC and wanted to experiment with it in Go. I wrote a little utility that displays live weather on my Linux desktop and connected it with my homebrew weather server, also written in Go. Here in Kansas, we have exciting weather and I like to keep track of it when I'm stuck indoors at work. I have a [Davis Instruments Vantage Pro2](https://www.davisnet.com/solution/vantage-pro2/) station on a pole back on my property and it wirelessly broadcasts live readings every 3 seconds. I have a [website](https://mhkweather.com) for viewing my weather but I thought it would be cooler if the current conditions were displayed on my desktop in Polybar. So, I wrote [weather-bar](https://github.com/chrissnell/weather-bar), which pulls live readings from the [weather server software I wrote](https://github.com/chrissnell/gopherwx) and displays them in a Polybar module. It's important to note that this is the actual weather as observed right now on my property, not some NWS observation from the nearest airport. 
###r/unixporn --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/6xrtxg/ignore_list/)
Definitely consider using https://godoc.org/encoding/json#Decoder.Token, as /u/tv64738 suggested.
Which IDE you have on the screenshot?
Thanks for the feedback! I have opened a [PR](https://github.com/scotthelm/todo/pull/10) . Is that what you're talking about?
That’s Visual Studio Code.
The program may be simple (BTW I don't think it is simple - it parses your code and inserts commands, traces execution and generates WegGL graphics from that) but the fact that it needs a patched Go version makes installing complex, so Docker seems a pragmatic approach. Regarding native Windows installation, I don't see anything in the README that says that Windows is not supported, so maybe you could simply try it out and see if it works. Maybe the author just had no Windows around to test his tool there. This being said, the tool has a limitation that might make it uninteresting for many use cases. The only available patchfile is for Go 1.6.3, which is quite outdated by now.
**For more:** ★ [https://blog.learngoprogramming.com](https://blog.learngoprogramming.com) ★
Outside of the fact the animation gives no actual new information, and is just annoying, it's *wrong*. Why would Thursday be 7 when the iota value is 5? Friday and Saturday are likewise wrong.
Yep, it's midnight here, I've missed some details. Btw, thx for encouragement, you're awesome.
If it's as accurate as this animation, I'm gonna pass.
The article can be found here: https://medium.com/@brendanleglaunec/how-refactoring-my-c-application-into-a-go-library-made-it-better-in-every-way-b99aa15fcfdf
This article is a follow-up to https://www.reddit.com/r/golang/comments/759enq/golang_library_to_hack_cctv_cameras/ If you want more information, have any questions, whatever, feel free to comment the medium article or this thread :-)
Anyone have web and mobile application development project in golang, inbox me or visit: amcoitsystems.com
Interesting idea, thanks for sharing!
https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/
Wowwowweewow! Is there a name for a multi-code-point unit?
It's a code point.
Neat! Also, what window manager is that? i3?
That looks as the solution I needed!! Thank you
Thanks!! Json. Decoder. Token is exactly what I needed
Yep! Looks good!
In terms of skipping code points, UTF-32 is simpler, and intuitively seems like it would be more efficient, but since UTF-32 is generally more spacious than UTF-8, the cache may be a concern and the logic required to step past UTF-8 code points could be faster than loading more memory. In terms of testing equality or finding needles in a haystack, speed is only a matter of size, and UTF-8 code points will be as short or shorter than UTF-32 code points, so faster or as fast. UTF-8 is encoded so that a partial code point can not be mistaken for a full code point which simplifies searching a lot. It's like searching any string of bytes.
So, where is the code?
https://github.com/EtixLabs/cameradar There are two links to the repository within the article, as well as in the thread I linked right above :-)
&gt; Reduced the number of lines of code by 95% Does it mean "by 5%"?
Well completely rewriting something usually makes it better, so it would've probably be better in every way if you rewrote your C++ application in C++ too.
Looking at his top screenshot of the difference in lines of code, it likely means that the new source is now 1/20^th the original size.
Gode(GoDE) TanGo IdeaGo(IDEAGo) XGo VisualGo
Well, as usual: This depends. Measure. Any answer of the form "Yes!" or "No!" is plain bullshit.
Exactly
For sure, it I made it a C++ library it would have been bigger, tougher to maintain, less accessible, would have had a complex build tool chain, etc. I don't know if you ever had to maintain a C++ library but since the language is not safe, an overwhelming amount of things have to be done to ensure the quality of the library. With Golang, everything is easier. The point of my article is that if someone is in my previous situation, I strongly advise using a simpler language, and especially Golang, since it's the simplest language I know considering the possibilities and features. :-)
If you want to be picky the proper hard realtime definition is to have deterministic deadlines which means that the sucess rate is required to be 100%, the 99th percentile is not good enough. The acceptable deadline could also be 10 seconds, the important aspect is that it is never allowed to be missed.
Damn! Today I had thought how cool and useful it would be to have a kind of go run for functions and here it is! I really needed this one, thanks!
Where do you make the profit? Arbitrage?
Go is not memory safe in the same way as C++. Automatic memory reclamation doesn't make it memory safe.
OP didn't say memory safe, but I'm sure you know as well as anyone who has had to work with C/C++ that random crashes through development of the library due to seg faults or the like are rough to debug. I guess you can argue that being in control of all of your memory is safer than letting a runtime handle it, but then its only as safe as your personal diligence to it being safe. 
hi, I am using Golang as primary language. Currently I am rewriting .net based social media platform to Go.
OP's never said that.
And the main problem is that you have a ton of legacy Makefiles, that you'll need to convert into Mage. Or the whole approach will be useless.
So what does it mean to be 'safe' in this context? 
Yes, it's i3-gaps.
Have you ever heard about ASan, TSan, smart pointer and other modern C++ stuff?
A little. Mostly just from complaints of the added complexity. 
Achieving the same quality in C++ would have meant an incredibly bigger workload than in Golang. It would have been way less easy for people to contribute, as they would have had to learn about complex concepts and libraries, and I would have had to put in place numerous checks to make sure that whenever someone contributes to the project, they don't introduce undefined behaviors, stack smashing, memory leaks, etc. In Golang I don't have to worry about this. So as I stated already multiple times: I don't hold a grudge against C++, I don't hate it (I'm even the organizer of Modern C++ Luxembourg), but in the case of this specific project, Golang is a 100 times better answer than C++.
So the utility that can detect bugs automatically is an added complexity. OK.
Well, like I said, I've only heard a little about them.
Yes.
I don't agree with 'incredibly bigger workload' argument. If you don't care about performance that much you can write really simple and readable C++ (copy things by value, don't use pointer arithmetics, always use vector&lt;&gt; instead of manual memory management, etc). It will be as safe and maybe not as slow as Go. Some projects can benefit from goroutines and channels but others can't. For example, the standard library have some nice features (like built-in http support) but it laks some pretty basic things like ceil and floor math function, normal date/time support or even set operations (intersection/difference). 
Go has date and time support. https://golang.org/pkg/time/ Go also has ceil and floor. https://golang.org/pkg/math/ Do you want to back up your "maybe not as slow" argument with some benchmarks?
Live reload was already really fast, but even faster is better! Nice work!
Sorry, I mean round, not ceil and floor (just mixed them). This thread shows that most gophers can't code 'round' function right off the bat - https://github.com/golang/go/issues/4594. The 10% of C++ thing is totally a misinformation. Since Go lacks optimizing compiler and SIMD support this can't be the case. Modern C++ compilers can vectorize loops and de-virtualize method calls, JFYI.
I agree. As you just said in your last sentence, it depends on the project. Here the goal was to make a library to be used for building simple apps and microservices, performance was not an issue and there is not a lot of data processing at all, so Golang is a good answer. If you feel more comfortable with other languages than Go, or you don't like Go, I'm not saying you have to use Go, you're free to use the language that fits the best your project and current skills (and gives you the most fun). After all languages are nothing more than tools.
Well I think go creates a better mental model of your code base. This leads to many more improvements that get exponential. You could do most things in a lot of languages with enough discipline but that's only great for lifers. The point is that it starts out simple and so as he progresses, it may get more complex but he or anyone else doesn't get lost in the code. If you ever see an old legacy project that was code from different paradigms, you know right away how much reading you have to do to change an array. I'm talking hundreds of thousands of lines of code. Which doesn't take that long for a team to make. The point being that you don't have to rely as much on discipline, lifers, coding paradigms, and a bunch of senior guys to keep the platform going. It's not about computer science, it's about simplicity in all forms.
&gt; If you want a real answer, there are design patterns in Go that make error checking easier and I use them. You seem to be confusing "design patterns" with "libraries". Anyway, it's not like you've a choice when dealing with errors in golang. You don't have exceptions or monadic types so, the end of the day you'll be `err != nil` or fail at runtime.
Well, no I did mean design patterns.
&gt; I'm not saying that it laks date/time support. I'm saying that C++ has better date/time support. &gt; This is the opposite of real life. The std. date/time support in Go is the best I've seen in any language, maybe there's some external C++ library you are using that provides something good? Maybe just confused/trolling.
Well, then you don't know what are design patterns. There is only one uncomfortable way to handle errors in go. I guess you'd have already provided some links for us to support your claim, don't you?
No thanks, you don't respect me enough for me to spend the time educating you.
how about both of you calm the fuck down. it's just a programming language
I'm pretty calm, thanks
Somewhat related but totally unrelated. I'm an avid kite surfer and I want to collect data from weather stations like yours close to kite spots. This means I need wind speed and direction, being polled every 10 minutes or so. Are these weather stations connected to the internet usually? Or do I need to ask everyone personally to connect? Do you get an average for the last 10 minutes if you poll, or do you just get data for that point in time? Sorry for the questions, but I'm sure you know much more about this than me ;-)
I'm sorry, but you shouldn't expect anyone to respect any of you if you never support your claims and just question industry-proven methods while choosing childish alternatives. Also, I don't want to be "educated" by those [who can't understand normal languages](http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/) - it's well-known that go was created for beginners who don't the purpose of "modern" language features. Also, even if you want to you can't show me any proof about "better" error management in golang because there isn't one. All you can do is shout in your echo chamber.
I'm sorry you need to take your frustration out on Go, but it's really not nice for our community. Could you troll somewhere else?
I'm sorry you like to practice your ignorance, but it's really not productive in the programming community. Could you go and be fanatic somewhere else? Btw, I'm not trolling I'm demanding answers what you claim to have. I've stated only raw facts so far and you've only shown that you're a sensitive lier.
Most of the stations you're watching are probably capable of real-time data but not using it or providing it. The actual stations typically send the weather readings to some sort of console on premises. The station&lt;--&gt;console link is usually wireless (900MHz) but some are wired. These readings are gathered pretty regularly, every few seconds or so. Unfortunately, that's usually where the real-time nature of the data ends. Most people use software from the manufacturer or from a project like [WeeWX](http://weewx.com/) to post the data on the Internet and that data is only updated periodically, as you've noted. I never cared for this because I wanted to know what was happening in real-time; when I hear a big gust, I want to look down and see what it's blowing at. So, I wrote gopherwx to pull the data from the station and store it in the database like the other software packages do, but to also make it available for real-time viewing using gRPC as a transport. My goal is to write an iOS client so that I can see it on my phone, too.
Alright well if you're going to keep trolling I'll block you so you have less incentive to troll here.
Thanks!
Man, I like to jerk to the stuff that gophers say as much as the next man, but this really looks like harassment. 
Critiques and facts are not trolling. Refusing to provide proof on your claims is lying. Blocking someone when asked to provide proof is childish.
I'm asking for proof. I don't have to respect a lier troll to do so.
I'm glad you're all wasting your time writing dumb medium and hackernoon articles about go while we're off being productive.
Hey, please don't troll here, thanks.
You have no right to call someone a troll when you've shown the same arrogant behaviour as the previous person. That's hipocricy which makes your statements questionable.
Gokude
You dont even know what trolling is lmfao Go be ignorant somewhere else. Maybe 9gag is for you
&gt; Hey, please don't troll here, thanks. 
At first, but that space is pretty crowded now. I'm working on market making.
std::chrono (part of the C++ standard library) is basically the same as 'time' package. It provides time and duration types and all relevant operations. Chrono has a bit better interface because C++ has templates. But when I'm talking about better time support, I'm really mean boost datetime - http://www.boost.org/doc/libs/1_62_0/doc/html/date_time.html It's full fledged, stable, and peer-reviewed datetime library. There is nothing that comes close in Golang ecosystem.
&gt; Anyone can read the Go example. Counterexample over here reporting for duty! :D I know a little bit of Go and no Haskell (although I'm familiar with the concept of purely functional programming in general). If I were to say what a function performs without its name, I'd probably figure out the Haskell one quicker, because the idea behind the code is much more visible and it's also less text to read. If I were to verify the implementation I'd run into my lack of knowledge of Haskell details, but I'd run into the same problem with Go as well, since Go typically involves quite a bit of magic. This line is an example: `values[i], values[j] = values[j], values[i]` I don't _really_ know what this line does. I can _guess_ it's a value swap (but then again I can _guess_ that `++` is concatenation in the Haskell example just as easily) also because it's similar to tuple deconstruction / assignment in other languages. However, I also know Go has neither tuples nor deconstruction (correct me if I'm wrong). So what's this line exactly? Seems to me it's some kind of magical syntax of the assignment operator. And that makes matters complex, especially since in Go this sort of magic is pretty comonplace. Consider the function signtarue as well: `func sort(values []int, l int, r int)` The `values` thing there is another example of magic, since it's a generic type in a language that doesn't support generics (wat?). The same is true of hashamps, the `make` function, the `go` syntax, the `chan` syntax, the `defer` syntax, the `&lt;-` and `-&gt;` operators, the `iota` thing... There's quite a lot of magical bits and pieces about Go that can basically only be memorized. In contrast, in other languages, as you learn about the language's more advanced constructs, the syntax that used to be magical ceases to be magical when you start to understand the underlying logic. In Go, things just stay magical because they are hardcoded that way. I'm not saying Go is as complex as Haskell. But IMHO it's not as simple and "readable by anyone" as many people like to claim. 
&gt;Anything I dislike is trolling!
&gt;I will post the code, but didn’t want to waste people’s time if this is normal speeds. Performance is going to depend on network (i.e.: hardware) configuration, latency, etc, so it's very difficult to give a meaningful answer. If anything, it's wasting time _not_ to show us the code ;) If you post your code, we can try to spot any obvious inefficiencies. More to the point: is this performance fast enough for your needs? Does it need to be faster? If not, maybe this is premature optimization? 
How many messages per second can you insert into the Postgres database (using the same transaction granularity)? It seems a bit slow, unless that's how fast the database can go. The important question is: How many do you need? Is it fast enough? If so, stop and do something else.
Nice! I wrote a Go library that interfaces via serial to the Vantage Pro console called [govantage](https://github.com/brockwood/govantage)! It, too, sends data to InfluxDB. I [gave a talk](http://go-talks.appspot.com/github.com/brockwood/presentations/2016/Go-IoT-Binary/presentation.slide#1) at the KC Golang meetup a little over a year ago on the work. It is great to see a fellow enthusiast!
I'd suggest [taking a profile](https://blog.golang.org/profiling-go-programs) of the program and having a look. I'd also increase the number of messages you're sending, so you have time to take a look at the Postgres DB's resource usage. You may find it's maxing out your CPU usage, depending on how the table is set up. If A: it is postgres and B: this is somehow not fast enough for you, consider [having a look at this](https://www.postgresql.org/docs/current/static/populate.html). However, for non-initial-import uses I'd recommend against turning off the indexes. But the first two suggestions can be helpful.
I mean, I guess we disagree, but I would say that you did successfully read that Go example, because the one syntax you were uncertain of you successfully inferred. It's true that there are some things in Go that aren't in other languages, but Go has less of these keywords than any other serious language.
Good points! In regards to premature optimization: the system has a requirement to accept and process as many as 30000 messages total spread amongst up to 10 clients within 5 seconds. While I am easily within that now, I’m also not yet processing the messages; only inserting them to the database immediately. So perhaps I should implement the processing and then come back and revisit this. Thanks for the input! 
Good questions, thanks for the input! I admit I didn’t think to test raw DB insert performance, I kind of just assumed I must be doing something wrong. I’ll do that. Thanks! 
&gt; So perhaps I should implement the processing and then come back and revisit this. This would be my suggestion as well :) More likely than not, things will move around a bit as you implement the remaining pieces, which may or may not invalidate any benchmarks you perform before then. 
FYI - Go master branch has the round function implemented. https://tip.golang.org/pkg/math/#Round 
Excellent pointers, thanks very much! Being kind of a Go noob I had forgotten that profiling is so convenient. And I’m running on macOS at the moment so I’ll be sure to give iotop a spin. Thanks! 
&gt; but Go has less of these keywords than any other serious language. Go only has fewer keywords because it counts fewer constructs as keywords, not because it _actually_ has fewer of those constructs. For example the `iota` thing - it's not counted amongst keywords, but it amounts to the same thing. Same goes for basic built in integer types - the C language, for example, only has more keywords because unlike Go it counts basic types as keywords. Another example is a while loop - Go doesn't have a keyword for the while loop, yet while loop is still there, the documenetation [even says so](https://tour.golang.org/flowcontrol/3). So, the whole "fewest keywords" thing is basically just clever accounting since most of the constructs are still present, just not in the form of keywords. Btw. other languages sometimes avoid keywords in a similar way too (for example in C11 and others), this is typically done in order not to break backcompatibility (I'm not sure what the reason was in case of Go). &gt; But you're joking because you call slices generic I guess. Sorry. Huh? I wasn't joking. Why do you think a slice isn't a generic type? Anyway, I don't want to argue about that, it doesn't really matter anyway, my point was that the slice type is magic, which is true whether or not you think of it as generic. 
I'd wager that its your DB insertions which is the bottleneck. A fan-out approach with backpressure propagation is ideal for this. Have a primary goroutine which takes the connection and does 2 and 3. Then push a struct to a worker queue of goroutines (I usually use https://github.com/ivpusic/grpool) which does the job of inserting it to a postgres table. When the queue gets filled up, i.e. all workers are busy, your primary goroutine should block from accepting further messages from the connection. This is a simple model which bounds the no. of concurrent db inserts and at the same time does not let the client to push as many messages possible. You can even extend it to limit the no. of connections itself. 
I didn’t use a 3rd party library, but this is essentially the exact implementation I have for the inserts. I essentially am putting the messages into a buffered channel that then bulk inserts the messages using COPY periodically. Good to know I’m on the right track in that regard :) thanks! 
FWIW I use this in a project and it works well. I recommend it as well. One caveat, you have to remember to replace the remainder of the buffer at the front of the input reader after you're done reading the json. The parser has its own buffer.
When you have a modern network, a database, and a reasonably fast code and CPU, the bottleneck is almost always the database. If your message integrity allows it, try to batch together inserts to the database - i.e. instead of inserting 1 message per transaction, insert 10 (or more - up to e.g. 1000) per transaction and commit(). You can often get man, many thousands of percent speedup. The theory behind this is that for each transaction, the database have to commit the change to disk, wait for the whole IO operation to complete successfully - with spinning disks this is extremely slow, and the difference between committing 1 row and 100 rows to disk takes essentially the same time. You get less speedup with SSD disks, but usually the speedup is still significant. The drawback is of course when something goes wrong, you also can lose more messages.
&gt; deleted
&gt; Anyone can read the Go example. Nope. I can easily find people who can't. &gt; To understand the Haskell example, you need to know that ++ concatenates things Everything but to learn! No learning! Learning hurts your brain! &gt; In comparison, in Go you need to know math, for loops, function calls, and integer comparison operators, all using common syntax. Cavemens surely have simpler tools...
&gt; It's true that there are some things in Go that aren't in other languages, Like what? &gt; but Go has less of these keywords than any other serious language. You've plenty of useless keywords in go. You even have `goto`. &gt; But you're joking because you call slices generic I guess. Sorry. Arrays, maps and slices are generics. But you don't get support for user-defined generics which would make coding in go somewhat bearable. Your compiler designers don't know how to implement them and that's why they say that they haven't seen a "simple-enough" proposal. 
Slow, I would consider somewhere close to 300k per sec good enough if no file or db IO is involved, since a DB is involved scale that part first. And go bench is your best friend.
[removed]
Show us the code !!!
Thanks for posting, that is helpful for non-Go programmers! As an aside, Homebrew has begun preferring that components that are available via other package managers, such as pip, cabal, rubygems, npm, go-get, be installed by these instead of homebrew.
https://github.com/goreleaser/goreleaser is another very useful tool for creating releases and cross-compiling. It builds a homebrew formula and auto-pushes to a tap as well.
Great
It shouldn't always begin with go prefix. I suggest the "pocket" for go's small and simplicity. Also it refers to pocket gopher. From wiki &gt;All pocket gophers create a network of tunnel systems that provide protection and a means of collecting food.
most likely than not IO performance on DB end is the bottleneck here
Found an implementation in python: https://github.com/mozilla/pymake I am wondering how hard would it be to call it from go or port it from go. 
I hope the Homebrew team does not consider go get as a full-featured package manager. It lacks any means for checking for updates or choosing between stable or beta releases. I would not want to lose the ability to install Hugo or Syncthing or Dry via Homebrew.
At least currently, "go get" isn't used to install anything in the homebrew-core repository. I believe at the very least you'd need to be able to go get a specific git revision, and verify the download with a sha 256 sum.
Ha, nice! A fellow Midwesterner, too. My system uses the Envoy and TCP/IP but the protocol is the same as the serial interface. We should compare notes on our implementations. 
What distro is that? 
You seriously think that `std::chrono` has a better api than Go's `time` package? What are you smoking?
Thanks for your time! I have added the code: https://github.com/malexdev/datalistener-test I am using the built-in `database/sql` in conjunction with `pq`.
Done: https://github.com/malexdev/datalistener-test Thanks for your time!
It's Arch.
My "they're writing malware" senses are tingling.
Sorry it came across that way. I'm the creator of a plugin for a notable art program, and I wrote a binary part in golang to help parse files. I needed concurrency and just don't have the chops or patience for C++. One thing I need to check for (as it can absolutely mess things up) is whether the user has the debug flag enabled for the host program. In Windows it's a registry key and in Mac it's in defaults. I just need to retrieve it. I'm not sure what else to say... I have a long reddit post history and you can derive my real identity from it easily enough. I work in the video games industry but the plugin is my side project. As an aside, wouldn't registry fiddling be one of the most obvious things an AV would catch?
The only match I found on Github is [grapswiz/dfs](https://github.com/grapswiz/dfs) (Search: `language:go sort:stars mac defaults`). Under the hood, it simply seems to call the `defaults` command (see the "commands" field in [dock.json](https://github.com/grapswiz/dfs/blob/master/definitions/10.12/dock.json). Maybe that's what your code could do, too - call `defaults` via `os.Exec()` and fetch the output.
But are you clam? 
That's great. 
mmake is backwards comparable with make Github.com/tj/mmake
Why not just write in C then, man.
This guy clams
Exceptions? Like in every other language.
What's wrong with std::chrono, can you please elaborate? In my opinion, the code that uses std::chrono can look a bit complex because it supports arbitrary time representations, e.g. if your app needs to work with TAI64N timestamps you can still use std::chrono. It also allows simple time math without functions like Go's `time.Sub`, `time.Before`, `time.AddDays`, etc. Golang's approach to time is very opinionated. E.g. Go's Time type contains both wall clock time and monotonic clock time. When you compare two Time values it will use monotonic time so you will never see the negative time interval when measuring elapsed time but if you print Time value, the printing function will use wall clock time. But I may want to serialize monotonic time in some cases (because I want my logs and TCP payloads to have only increasing values), or I may want to compare wall clock times instead of monotonic times when the Time object represent the time of some event from the outside world. With std::chrono this is simple, you may rather use steady_clock or system_clock (or high_resolution_clock), depending on the situation. Yes, you're obliged to know the difference but this is something to be expected. Another problem that the 'time' package assumes Gregorian calendar (which is good) but doesn't allows you to easily use it. You can't check if the year is a leap year or find the first Monday after 2017-10-17 and do other stuff like that, but you can do this easily with boost.date_time (but not with std::chrono). The one really great feature of Go's time package is formatting. It's really versatile and easy to use.
"MPH" instead of "m/s" ruined it for me. Unscientific, boo!
404?
If you have a field that will always be there, you can define two structs with different fields and use that field to distinguish, which to use: https://play.golang.org/p/7_YcTY4Qt2 You could also unmarshal into a `map[string]interface{}` and then iterate over that and, depending on the key, manually unmarshal them, or write the equivalent using reflection, or try and find a package that allows you to decode a `map[string]interface{}` into a struct via reflection (there probably is one). Frankly, this is one of the reasons I've always been kind of dissatisfied with the `encoding/json` API; it treats how to encode/decode as a property of a *type*, instead of a property of the *process*. 
Your first case is basically useless; when the test fails, the other cases are tried. How do you differentiate between searching for both a level and an ip and only searching for one of them? My guess is that when you check for the level (resp. the ip), you should check if the ip (resp. the level) is empty.
You can call [defaults(1)](https://www.romaniatv.net/laba-si-muia-candideaza-din-nou-la-primarie_25465.html) through `os.Exec`.
/dev/null is faster anyway, checkmate MongoDB users
it's nice but depending on gnuplot means deployment isn't as easy as it could be. it's true that gnuplot has perhaps more feature than, say, gonum.org/v1/plot, but one has to go though some kind of IPC (a tmp file, a socket, ...) to get a plot: that's why I put github.com/sbinet/go-gnuplot on hold directed my gaze towards gonum/plot. FYI, there is also this repo that does with matplotlib what you do with gnuplot: https://godoc.org/github.com/cpmech/gosl/plt anyways: keep up the good work, having alternatives is always a good thing.
I see your comment got up voted and my reply and OP got downvoted. Real nice community you got here, friends. I'll be sure the door doesn't hit me on the way out.
Great, thank you! That sounds like it'll work.
How about you compare the asymptotic memory usage of your Go and Haskell 'quicksorts' and see if you're really comparing like with like?
Oh, in what way is it useless? I mean, does it not require both an level param and ip param or it will proceed to the next case? Is there something wrong with the formatting or? "you should check if the ip (resp. the level) is empty."- This is exactly what I would like to achieve, however as I'm still a newbie I don't really know how to do this. (Maybe with an if statement following the switch case?)
See for example: https://play.golang.org/p/F3qvyle1UW If the "params" map does not contain any "ip" key, the resulting string is the empty string "". You first check whether both level and ip matches; this fails. Then, you check if the level matches: if it does, then it does for any "ip". I wouldn't add an if statement, just another condition: case item.Level == params["level"] &amp;&amp; params["ip"] == "": 
There are two main problems here: 1. The switch statement is the wrong construct for this type of problem. You would better use an `if...else` sequence. 2. You need to address both the concern of checking equality and checking whether the parameter is set at all. For reference, here is how I would solve it. It allows any combination of keys to be the search criteria, and setting no search keys returns all routes. There is some boiler plate for dummy data. package main import "encoding/json" import "os" type Route struct { Ip string Level string Smethod string } func main() { var response []Route params := map[string]string{ "level": "5", } items := [...]Route{ Route{"127.0.0.1", "5", "POST"}, Route{"10.0.0.2", "7", "GET"}, Route{"10.0.0.2", "5", "POST"}, } check := func(set bool, pval string, ival string) bool { return !set || pval == ival } for _, item := range items { level, levelSet := params["level"] ip, ipSet := params["ip"] smethod, smethodSet := params["smethod"] if check(ipSet, ip, item.Ip) &amp;&amp; check(levelSet, level, item.Level) &amp;&amp; check(smethodSet, smethod, item.Smethod) { response = append(response, item) } } enc := json.NewEncoder(os.Stdout) enc.Encode(response) } 
settings are stored in plists files https://github.com/DHowett/go-plist
Thanks for pointing this out. Comparison to ngrok and maybe some other projects would be nice. Key difference in all the tunnels is how the multiplexing is done, here we use HTTP/2. It's much more stable (and faster) than other libraries I saw. The architecture is flexible and adding new protocols pretty straightforward. 
Best advice probably is : Don't. Keep each API the way it works. A snake_case standard is not helpful at all if dealing with encoding/json.
I'd be nice to have examples within godoc. https://blog.golang.org/examples
You need to use CGO to interface with CFPreferences. I have an example here https://github.com/groob/mackit/blob/master/example/main.go 
Why is this necessary?
I resolved the problem, so I pulled the public repo. Its actual home is on an internal server. I edited the main post but I guess I should have also edited my other posts. Sorry. 
You could embed the struct but I'd just keep things simple. Encase you want to add more.
I agree. If you can't guarantee the same api "standard", it's just useless work.
However, it's more efficient to learn how to properly use the tools at your disposal and understand their limitation.
I think it's just being upvoted because it's funny. Don't know why you got downvoted.
A quick comment on improving testability: separate opening files from writing to/reading from them. Have one function open the file and another two for dumping the data and reading it from an `io` interface like `io.Writer` `io.Reader` or `io.WriteCloser` etc. That way, you can unit test serialization and deserialization without touching the file system by implementing the interface as a buffer in the tests. This approach is particularly useful when implementing network protocols. As a matter of style, I see there are a lot of functions operating on either the Todo type or arrays of Todo. I would have created a new type `type Todos []Todo` and made all these functions methods on the Todo and Todos types or pointers to values of those types.
what? 
I have no control over the data coming from the wire, and standardization is important
Yeah. It has been incredibly frustrating. It was disappointing noticing the discrepancies on the apis, for sure, but this should have definitely been easier. Do you have an example of the manual unmarshal? It doesn’t seem at all straight forward is a strongly typed system (I’m coming from python)
What to you mean? It’s not useful to try and consume two different api sets and make something useful out of it?
&gt; in what way is it useless? If both conditions in the first case are met, then the condition in the second case has to be met. Since it performs the same operation as the first case, the first case doesn't add anything.
I made it to book an appointment to some extremely busy office. I.e. you can use it together with mpg123, which will play a sound after some element is changed on a website.
I'm afraid, constructing an RFC 822-compliant regexp to verify an e-mail address is valid [is proven to be a little bit more complex](http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html).
&gt;I have no control over the data coming from the wire Right &gt;and standardization is important Why? What happens if it's not standardized?
&gt; It’s not useful to try and consume two different api sets and make something useful out of it? That very much depends on what you're trying to do. We need context in order to give you a good answer.
&gt; The two struct solution will unfortunately not work for the api with hundreds of keys You are going to have to define a struct anyway. Seems to be a straightforward case for copy-paste, followed by search-and-replace. If you are *not* defining a struct (i.e. are throwing around maps, which FTR you shouldn't do), then just use `map[string]interface{}` and do for k, v := range m { k2 := camel2snake(k) if k != k2 { delete(m, k) m[k] = v } } in your unmarshal function. &gt; Do you have an example of the manual unmarshal? It doesn’t seem at all straight forward is a strongly typed system That's because it isn't :) If I had a simple example, I would've provided it. When I said "manually unmarshal it", I meant writing the equivalent of var m map[string]interface{} json.Unmarshal(data, &amp;m) foo.SomeKey = m["some_key"].(string) if v, ok := m["someKey"]; ok { foo.SomeKey = v.(string) } which, of course, is "not practical for 100s of fields" :) For the reflection-based solution, you want to do essentially the same thing that encoding/json is doing to decide where to store unmarshaled values. Unfortunately, this is non-trivial, which is why I am not-providing an example. If you want to go that route, I'd suggest to start by reading the source code of encoding/json. But I do believe, there is a high likelihood that someone had a similar need and already wrote something like `func Map2Value(m map[string]interface{}, v interface{}) error`, that you could use like var m map[string]interface{} json.Unmarshal(data, &amp;m) for k, v := range m { k2 := camel2snake(k) if k != k2 { delete(m, k) m[k] = v } } var foo Foo return Map2Value(m, &amp;foo) But as I never had this problem, I don't know any specific packages and don't want to recommend any I don't know. So I'd recommend googling this. Honestly, IMO the "two structs" approach is the most sensible, even if it requires copious amounts of copy-paste. But that's just… like… um… my opinion. Man. :)
The text can be customized with a formatting string like Polybar uses so it's easy enough to change.
But why?
&gt; I decided to standardize You're committing the classic blunder of "too many standards! I'll create my own..." [as parodied by XKCD](https://xkcd.com/927/). Unless you can give us a very compelling reason for doing so (and so far you haven't), I'd say this is your mistake right here.
Wouldn't it be better to invoke something more low-weight than a whole (outdated) browser? webpack is too slow? nuxt? an actual node prerendering service? I'm guessing the prerender here takes at least a few seconds to start up phantom, etc.
&gt; It’s not useful to try and consume two different api sets and make something useful out of it? It is. But this can be done easier if consumed without further modification or rewriting (even if you call this wasteful rewriting "standardization").
the go playground is the official repl.
Is this tool meant to handle only a single connection until it ends? What's it useful for? 
Just look at source, it's 60 lines of code https://github.com/microwaves/truck/blob/master/main.go and he is just io.copying the data between listening tcp socket and listening udp socket for one connection. 
What is that really neat shell thing you got going on there? I love the look of it.
Thank you so much! I really appreciate it :)
I'm not publishing this standard. This is a standard that will live inside of my environment. Honestly, it should have been to hard to allow my service to consume datasets using multiple different key casings...
I ended up writing my own UnmarshalJSON function, and it works like a charm! Thanks for the sensible responses! :)
No. It's not up to you what is necessary to make my project work.
It's about keeping a consistent interface inside the project. Consistency matters. And the fact that these two services are differing is important. I found a solution, though.
I'm going to have to remember whether or not I'm talking to service X or service Y, and thus have to remember if using PascalCase, or camelCase. Either way, it should be simple to make this easy to be consumed however I see it fit. I have 10 years of experience in the industry. I don't need anyone second guessing the needs I find in my own project just because they don't know the answer to the question I'm asking.
Yes I realize that :-) I was "calling out" the behavior I saw in the source code, asking if that was the intent. Because it seems highly limited as a tool.
&gt; It's a very "tall" language so it can continue teaching you things for a very long time. IMO that's a good thing, so many awesome abstractions and tools and SO MUCH POWERRRRRR.
I don't get it, what is this? Effort to increase open source footprint? Not impressed. 
Oracle's bad and Google is good It must be firmly understood If you're a mere undergrad Believe not in any falsehood Google is good and Oracle's bad (esp. if your name is Fitzpatrick, Brad) If you think otherwise you must be mad Just google it and it's all there Believing lies don't you dare 
Fantastic! Thank you very much for the feedback. Just so I understand: in the scenario you describe with the files, then I would be looking for a ReadCloser or WriteCloser in the functions where serialization is happening. Then I could write or read from the passed in interface and defer rc.Close(). Is that correct? I was trying to keep the main method readable. But from a re-usability standpoint, I can definitely see the value of simplicity in the functions. It's funny you mention making the functions methods! I was specifically trying to break out of my object oriented shell. But I may have stumbled on an anti-pattern in the process. Thanks again! 
It's a final prefixion Oracle's just bitchin' Ain't no condition Cause Google's been fixin' With they own rendition Upsettin' the prequel Some spanner of conviction Left hook at mysql Match up in any condition Real talk nuclear times Oracle's in a state of contortion Google knows all your crimes Modern day santa, no distortion When ya down passing dimes Oracle smacked down in confusion Big G why's the traffic tight? Big iron thermite explosion O's losing the fight tonight
I would rather have a pure Go backend, I find all of these solutions where you execute some JS from Go on the server side hacky. Part of the reason I use Go on the backend is because I dislike server side JS.
Most search engines use UTF-8, and don't bother converting because they operate at the byte level. This gets hard when doing case insensitive matching -- the branching factors get gigantic, and it becomes a lot less effective to use a simple memchr search. One strategy to deal with this is to down case the entire search document and the query before matching the query. Check out http://blog.burntsushi.net/ripgrep/ for some interesting search info.
&gt; I am 23 years old &gt; At the end of August, I finished my rotation on the Go team and gladly became a full-time, salaried Googler. Ok... What is this black magic!
More people are interested in my terminal configuration than my code haha, you're the 3rd person to ask already! Here is my answer to the previous guys: My configuration can be found on this repository: https://github.com/Ullaakut/new-environment-bootstrap I basically use fish as my shell, oh-my-fish and power line with a Roboto font for Powerline. My terminal emulator on these screenshots is iTerm2 under OSX. After I sent him this message, the first guy created his own repo to store his configuration, maybe you can find some inspiration there too: https://github.com/murillow/dotfiles 
You consistent interface inside the application does not depend on the details of the external serialization format.
That's what I'm trying to fix
interesting, have somehow totally missed this. two questions: • how does this compare to cockroachdb perf wise? • are there any plans to make it embeddable?
IF you want something like SSR (and whatever framework), you would either have to abandon said front-end framework, or hack together something like [robertkrimen/otto]( https://github.com/robertkrimen/otto) to support it. From what I read, one of the blockers there is having a [javascript compatible regex implementation](https://github.com/robertkrimen/otto/issues/215) that wouldn't hurt performance (but would at the same time enable support for more complex projects like babel ES6/7 transpilers etc). I'm not sure if this falls completely into "a pure Go back-end", but if you want server side rendering of angular/react/vue, your best bet today is to have a node sidecar app which you can forward requests to, and then cache this output (like a static site generator, but from a non-go upstream). This would drop the PhantomJS dependency, and imho, give you the shortest time to render individual pages.
Instead of keeping your internal standard as snake_case keys, you could internally keep a standardized representation of the state using a struct, which can be created from either of your external api:s. This way you can have a "standard" internal structure, that is by no means tied to either of the external api:s
No but serisously now. *Fuck* Oracle.
&gt; Fantastic! Thank you very much for the feedback. I am glad to be of help! &gt; Just so I understand: in the scenario you describe with the files, then I would be looking for a ReadCloser or WriteCloser in the functions where serialization is happening. Then I could write or read from the passed in interface and defer rc.Close(). Is that correct? Yes, exactly. The ReadCloser/WriteCloser guarantee that whatever is passed in have both Read/Write methods and Close methods. Structs satisfying those interfaces can be socket or file representations, compressors, pass through objects that measure the data rate, or stubs for testing etc.. &gt; It's funny you mention making the functions methods! I was specifically trying to break out of my object oriented shell. But I may have stumbled on an anti-pattern in the process. I can't say with confidence that it's an antipattern, more of a personal preference maybe. It seems clearer to me that when a function is clearly associated with a data structure for it to be a method on it. Practically, it means that your data structure can implement a (non-empty) interface and that the associated will still be passed along to the call if you point a function pointer to a method. In this case it's maybe not so relevant, but imagine writing two todo systems that both have the same API. Making them structs with methods, they could both implement the same interface and be used interchangeably.
Waouh!!!!!! Clap clap clap :-)
I created the tool mainly because `kubectl port-forward` only supports TCP at the moment. So if you want to test or work with a UDP service running on k8s, it becomes quite a challenge.
Can we stop posting these types of articles at this point? It feels like they are all the same. It's always performance/ease/channels. We get it, lets stop patting ourselves on the back.
Yep, that's right. I will add multi-conn support later. I did the tool mainly to debug and solve some issues of UDP services running on kubernetes. It's not a very UDP-friendly environment. With multi-conn would be even possible to use load balancers offered by cloud providers, who doesn't support UDP for obvious reasons.
The SysBench result we have done in our test environment shows that TiDB has better performance result than CockroachDB, but we strongly recommend testing your own scenario in your own environment.
Tldr: I like chi, use chi
You should look at changing the way you name your sub-packages, Go tends the work a little differently than languages than Python for example. Don't call a package "models", it's not really a great idea with Go, I have learned this after having used Go for a while now. I started off like that too, instead try to group by what it is, for example just a "contact" package would be fine. Also I don't tend to create an entire config sub-package just to hold a Config struct, I generally have that in the root package. Also linters will complain then that "config.Config" stutters. You might want to investigate the "standard package layout" https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 It seems you have chosen the "rails type layout", "approach #2": What it says about this layout: "There are two issues with this approach though. First, your names are atrocious. You end up with type names like controller.UserController where you’re duplicating your package name in your type‘s name."
Using go and no multi-conn support for such a simple tool. Wonder how this is possible... 
I'm 23 and in my third semester...
Ok I will take care of that for now!
If that's your sole take away, then you should read the other 95% of the article. tl;dr: I also like sqlx, use sqlx, I like stdlib use stdlib :D
Here is the link for the TiDB best practice: https://pingcap.github.io/blog/2017/07/24/tidbbestpractice/
Take your time :) It took me a few attempts at getting the perfect project layout, it's OK.
I'm actually learning Golang, so I borrowed/grabbed some code from Github, to make it work. I'm on my way, so advices are welcome!
Does it work with postgres drivers? I remember there were plans to support it, but I haven't followed in a while.
Follow the discussion here: https://groups.google.com/forum/#!topic/golang-dev/naQlgeWVtvA
Cheers! 🍺
To be honest, I fail to correlate the title of the post with its contents: indeed, as /u/dlsniper pointed out, the sole place where something which could be called a framework is being discussed takes two short sentences which indeed boil down to "X has N stars, we use X and I wholeheartedly recomend X". The rest of the post discusses really tangential topics. The problem I perceive with the post is that it actually does not *discuss* anything related to frameworks (okay, I take the term to mean "web framework" as it's what IMO 99.9% or /r/golang population seems to imply anyway). **TL;DR** A discussion of what criteria to use when considering what web framework to use is what I would expect to find after reading the title.
Currently, we just don't have the manpower. Any help from the community would be highly appreciated!
thanks for the answer. what about the embedding? :-)
I can't wait for the final release, this is such a good IDE!
Thanks, we're planning to have the release by the end of the year.
Oh my I was not inspecting it so soon! Best Christmas present ever then :) 
So it's all good, because he's working ON the Go team. It would be a different story if he were working at the Go team.
This is what i'm always concerned with. I need a simple, nicely featured embedded database for so many applications. Pure Go is such a selling point for me. At least, until we have Sqlite in Pure Go.
Start working full-time at 20. Worked for me. (Not a googler though).
I learnt literally nothing from this.
By posted old xkcds^^^^^^^^^/s
Saw some comments around clustering for NATS Streaming, etc. -- if anyone wants to chat or wants invite to NATS slack to discuss reach out anytime: brian@nats.io -- but yes, as noted via the GH link somebody shared progress is being made on that....and if anyone tries NATS and has any questions or feedback (beyond Streaming) just let me know; always good to learn and hear further..
I mean... That is what I'm trying to do. How would I go about doing that?
By hitting the turbo button on their PC /s
Just curious. Why are you building your own Nginx and mongo images? There are already official mongo alpine images. 
After it's released, will the Intelij Idea plugin have the same features? At the moment I'm using the EAP for my Go projects because the plugin on Intellij Idea says it doesn't have all the features of Gogland. I have an Intellij Idea Ultimate subscription but I was thinking to switch to All tools.
Claim they're doing [Hammock-Driven Development](https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/HammockDrivenDev.md)
unit testing.
+1. there is https://github.com/cznic/ql but it would ofc be a dream to have something slightly more feature complete. 
&gt; The fact that Go doesn’t have a package manager has significant implications in terms of the discoverability of packages. Please stop saying this. Yes, go does have a package manager. It's dep. It works great. If you want discoverability, search godoc.org. End of story.
Sorry, but this reads like a "What I did this Summer" essay
&gt; I have an Intellij Idea Ultimate subscription but I was thinking to switch to All tools. There are so many people think like you (including me) and that's why Jetbrains try to release many products (not as a plugin support) as many as they can? p.s I'm a CLion subscription user.
waiting on a cloud / jenkins / CI build...
This is important. /u/titpetric, please fix the post.
Here is a ACM article on Google's internal monolithic code repository mentioned in the article that explains how it works: https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext
Dep is not yet official. You might say gvt or glide would be the same. As such I can't say that it's somehow true. And not all packages are available via github or indexed on godoc, so it would be at best "best effort", and it's purpose is documentation, and not a package index, yes?
Great work! Now, let us never speak if it again; Compose your types thoughtfully to pass dependencies.
Hey Dave, there's a difference of opinion (or facts, as noted in my reply) that imho doesn't warrant deletion/correction. I realize that this fact will be outdated when/if dep makes it into the toolchain, but today that is not the case and there's still no central package index that would be comparable to npm or other listed projects. Godoc has a different use case and intent.
"Doesn't have a central index of packages" is not the same as "doesn't have a package manager".
Writing generics.
I will add the correction with "official", or "bundled" and listing some choices like gvt, glide. It seems to trip people up too much. Ty
Please don't send users in circles. glide is already forwarding users to dep. It would be kind, respectful, and most productive for all current projects/articles to do the same. https://github.com/Masterminds/glide/blob/master/README.md#golang-dep
Thanks for the comment. I amended the article clarifying the state of vendoring tools and the planned official inclusion of dep into the go toolchain. Hopefully the inclusion goes smoothly and on schedule.
Addressing discovery directly... Searching godoc is the/a primary entry point for finding publicly available packages. Suggesting otherwise is strangely discordant.
Thank you for the updates.
I'd be interested to know what you want in a package index. Is it just a place separate from the git (or whatever) repo to host the code? I honestly don't see the benefit in having two places to get the same code. But I also haven't used ruby or node, so I am starting from a place of ignorance.
I'd just use the vendor directory. If the two projects are in the same repo, I suppose you have a directory structure like this: GOPATH/ src/ repo/ project1/ project2/ So, you have two options, manage dependencies on each project (1) or in the upper directory (1) (1): GOPATH/ src/ repo/ project1/ vendor/ project2/ vendor/ (2): GOPATH/ src/ repo/ project1/ project2/ vendor/ I think (2) would solve your use case.
I amended the article to further clarify how and where packages are hosted. I agree the most complete list might be godoc, but it's definitely incomplete and people can and should often use other searches as well, like GitHub or Google. Re: other npm index features: there are projects like gopkg.in (which I mention in the article) that provides some features like installing a specific tag/branch in a more friendly way. But even gopkg still doesn't provide a central/global package index with some metrics about installs, mirrors of packages or information about tests or something. The packages are fragmented to whereever people choose to host them. There's a missing piece of the puzzle in comparison, which I'm actually arguing in the article is a good thing, because it forces evaluation of libraries before pulling them into your project. It's not a bad thing necessarily, but it isn't friendly either.
RESTful websockets or gRPC would be a good starting point.
They say websockets arent safe as xmpp?
When I do it this way, I get errors like “undeclared name: error (and 4420 more errors)”. What am I missing?
You must not be using Dep yet.
I am not aware of a Go-level one. What I would suggest is that there are locking constructs that you can use at the OS level that would permit this. I'm not sure what platform you're on, but I'm familiar with Unix where you can use [syscall.Flock](https://golang.org/pkg/syscall/#Flock). You'll need to read up a bit out of the context of Go as to [how to use that system call](https://linux.die.net/man/2/flock). Then anything that uses the DB should take a flock out on some agreed-upon file, and it will serialize just those tests.
Will all features be available in Idea ultimate? 
This should go in /r/rust
How do you you define "safe"?
You could move one set of tests to a new package that tests the existing one (but that assumes they only access exported functionality)
You can use t. Parallel() https://splice.com/blog/lesser-known-features-go-test/
The best way to do it would be if you could organize your packages such that all the DB ones are under a single tree, and then you could test those with -p 1, and test everything not in that tree normally. It would take two calls to test, but simpler than some other hacks. 
A bit nitpicking but I'm not sure RESTful websocket is a thing, REST is stateless, more appropriate would be JSON over websocket.
Nice :D The code was cool too :P
`go test -timeout 30m` etc 
Sure, let's take a look at npm, I'm going to choose a random package: https://www.npmjs.com/package/jsonp 1. provides a one liner top right how to install the package (ie, "howto"), 2. provides stats that serve as an evaluation of adoption (downloads, etc), 3. semantic versioning (you can list those with, `npm v jsonp`), 4. provides metadata from the bundled package.json (including license info, etc.) The search of the package index also enables things like search criteria ordering, by quality, popularity, maintenance, and best overall. When evaluating packages for Go today, it's common to go over several github profiles, check their stars to gauge adoption, check their issues to gauge abandonment, and the last date of the commit which was done on the project. It's common to install packages directly with the fqdn (go get github.com/sony/sonyflake) which doesn't pin the package to a specific version. There is `gopkg.in` which provides some of this functionality to directly install a specific branch/tag/commit, but it doesn't work by inspecting the git repository like npm would, to provide some kind of list of package versions. This is something that I find lacking in the vendoring tools that I've tried. Reviewing dep, their suggestion for pinning specific versions is `Manually edit your Gopkg.toml`. There's no equivalent of `npm v [package]` that I'm aware of. PHP Composer allows pinning packages via command line when installing a package (`composer require package:^1.1` for example). Having a central index of installable packages would also drop the FQDN part of the imports, but this isn't necessarily true. Well, it's about as true with gopkg.in which is tailored to github. Some features are definitely already available via godoc (imports these packages, imported by these packages) and gopkg.in (this being tailored to GitHub specifically, but doesn't support other public hosted git sources). NPM provides a mirror to work around this issue, so that you wouldn't have FQDN in the links. There are other implications what to do with the data around the packages, like actively marking packages like gvt/glide etc. as discouraged/deprecated. There are several packages in the go ecosystem that are actively discouraged, a notable example might be [martini](https://github.com/go-martini/martini), and other examples might include [iris](https://github.com/kataras/iris) which was discouraged by several people due to spammy practices and insinuations that the author paid for github followers to bump up the star count on the github repo. This would fall into somekind of policing territory, which I admit I don't know enough about to know how to handle. Having more data about the packages that exist that would be coherently listed and usable would enable developers to make more informed decisions about viability of some projects. I hope this explains some of my thoughts behind why not having something like npm isn't really friendly to the overall experience, and at the same time forces the developers to think more about which package to adopt. The evaluation part for this today is definitely hard, especially with web frameworks where there is more choice than lets say JWT libraries or GraphQL. Providing a friendly solve for these problems would make the experience better, but it's arguable if the quality of the packages being adopted would remain at a high quality level.
I will surely look into this as soon as possible. Thanks for the feedback
Running tests :)
websockets already have "wss://" which just initiates an https connection and then moves on to work with just the tcp layer. Is this still insecure ?
Since there’s literally not a single positive comment, I guess I’ll have to comment. Thanks for sharing about your experience, it was very interesting and helpful to me.
Thanks.
That works within a single package, not between packages.
Thanks for the very detailed response. I agree that it would be nice to have a kind of godoc.org++ that would host more of this information. I don't think any of this requires actually hosting the code on the site that displays the information, in most cases it could all be retrieved from VCS similar to how godoc does it. I also see only detriment to removing the fqdn from the packages. That is important namespacing that keeps squatters at bay (more or less), and also lets you know how to acquire the code and where to go to contribute. I am strongly against central policing. I think that's one of the biggest downsides to having a central repo - having some group of people with power over the whole ecosystem. But anyway, thanks for the info. I'd love to see either more info available on godoc.org or another site gather some of these statistics.
[removed]
To put a slightly different spin on "policing": Docker has something they call "official build" packages, so you can get a trusted version of mysql, redis, etc. for example. Similarly, some packages for Go could be flagged as recommended, due to their adoption, best coding practices or other criteria. I see this pattern in other communities as well (notably VueJS), and there's even some prior example of this in the Go repo which stuck in my mind: https://github.com/golang/go/wiki/SQLDrivers I'd flag this as another example of how various criteria for package adoption exists just about everywhere in various, often unstructured ways. For example: - Does the package rely on CGO (this could be obtained with an AST parse, I suspect), - Package testing information (includes tests, code coverage %) - GoReport card rating (golint, etc.) Obviously I realize that this also increases the requirements for the service itself, as it would have to interface with various providers to integrate this data.
Are you using IDEA 2017.3?
!Remind me 1day I am interested in this as well
Checking out the monorepo: https://twitter.com/monorepi/status/542081644954259457
I'm curious to know which packages that are go gettable do not show on godoc.org. In other words, how is godoc.org an incomplete list?
&gt; an integration test and I am currently trying to figure out how to create a mock database If you mock your database then it's technically no longer an integration test. What you should do is write tests that test against the actual database. There are many ways to do that. This [article](https://www.philosophicalhacker.com/post/integration-tests-in-go/) describes 3 ways. The article does extensive use of `TestMain` but it's not necessarily needed. You can have your `setup` and `teardown` helper functions inside each integration test function. There is also another way that involves build tags. So you guard your integration tests with say `// +build db` then in order to make them run you do `go test -tags=db`. Each way has their own pros and cons so pick the one that best suits you.
Yeah it's just cool to see a young engineer ramping up with such a brilliant group of people. Dunno why people on this sub are so salty.
Yes, we're planning to have the feature set in Idea Ultimate.
Yes, we're planning to have the feature set in Idea Ultimate. &gt; because the plugin on IntelliJ Idea says it doesn't have all the features of Gogland What're you missing? 
Depending on how ambitious you are you could try to implement the [Matrix protocol](https://matrix.org). Like others here suggested it's REST/JSON but lays out how a secure, modern chat client/server should work. I don't know if there is any work done in Go that goes into the direction but you can look at their [reference implementation](https://github.com/matrix-org/synapse) (in Python).
If you are using the new Go plugin by JetBrains (https://plugins.jetbrains.com/plugin/9568-go), then you will have all the Gogland functionality with IntelliJ IDEA Ultimate.
From the about page: &gt; To add a package to GoDoc, search for the package by import path. If GoDoc does not already have the documentation for the package, then GoDoc will fetch the source from the version control system on the fly and add the documentation. If you can't find a package in the search, you'd have to literally reference it with the full import path in order for GoDoc to index it. There's also some quirks with the search, so if you search for `flake`, you will not get `sonyflake` as the result. I think I'll stick to google for now, tbh.
So, I definitely like that idea better than "policing", although I am still hesitant to give one group of people power over what is considered official. I'd like quality to be something the community judges. But at the same time, care must be taken to avoid things like paying for github stars, which I am sure is probably a thing. So, being able to see what developers and projects you trust have used and/or marked as good quality is important, to avoid the "star farm" effect. And yes, definitely the full stats on go-specific data (CGO, test coverage, go report card etc). Right now, a lot of that is available in different websites, but it would be great if there were a one stop shop to store see everything about a project.
It seems a little excessive to expect the system to crawl through github looking for packages that have never been used publicly or added by a maintainer. However, you're dead-on with the godoc.org search. A package should not need to provide search terms when a partial search is found in related text numerous times. Using your example, "sonyflake" or "snowflake" is found 4 times within the path and synopsis. Here's the related issue: https://github.com/golang/gddo/issues/424
&gt; This is a standard that will live inside of my environment. It's still a new standard, as compared to the data you're consuming, and that's the point. Why do you even need a standard? You're consuming data, not producing it, right? Just be sure you can unmarshal the type(s) that are presented to you into a common data structure and you're done.
It seems simpler and less magical to me to just put the `COALESCE(0, age)` directly into the SQL query string.
*sighs* That doesn't really matter... I decided I needed it. My question had nothing to do with whether I should create a new standard in my project or not.
Why though?
You could look at https://github.com/mattermost/mattermost-server for inspiration.
The moonshot is to eventually have a CGo-free GTK+ Go bindings, for an example related to this post. Initially via the VM, later as pure Go using CCGO. And there's lot more C stuff I'm looking at.
I just use https://github.com/go-chi/render which provides more or less generic Binder interface in which you can do your validation code.
&gt; pure Go using CCGO This is confusing. &gt; The moonshot is to eventually have a CGo-free GTK+ Go bindings Noble goal but personally I'd rather see a pure Go graphics library take off. Maybe you could help [shiny](https://github.com/golang/exp/tree/master/shiny). Still good job.
Nothing about salary range in the description. Might be helpful for some people
/cc @dgryski @kris-nova @peterbourgon @natefinch Please tell me it's incidental.
/cc /u/dgryski /u/kris-nova /u/peterbourgon /u/natefinch Please tell me it's incidental. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/golang] [\[META\] Looks like we've got moderators... and they go around deleting comments](https://np.reddit.com/r/golang/comments/77ael1/meta_looks_like_weve_got_moderators_and_they_go/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
If you don't like websockets, then go with gRPC over SSL.
they're salty because a 23 year old is working on Google/Go and while they're stuck on their cookie cutter crud apps.
CCGO is bot CGo, CCGO transliterates C to Go.
Unless you've got some reason why the moderators doing their job is somehow out of the ordinary, I'm not sure what your point is?
The thing is, if you don't ask the right question, your answer might not exactly solve your problem. You're asking about unmarshaling, but what you might really ask about is how to model the data in your program. Once you nail that down, the unmarshaling issue is trivial...
This. I was saying the exact same thing at work the other day! 
Multi mentions doesn't work IIRC. Also I would suggest you solve this issue of yours in PM, if it's not truly something out of the ordinary. 
In general, you should only instantiate `json.Decoder` once per stream.
If you only have JSON coming in over that stream, yes. I have mixed data.
I use [OpenAPI](https://github.com/go-openapi) (aka swagger) to define the schema, publish the schema, and validate the request with the schema. It is the best solution I have seen in a long time. I also validate on the JS client-side against the published api specs.
Do source file paths on each machine matter? /tmp vs /builddir etc?
Oh alright. That extra C got me. :)
Daily stand ups ?
Please, illuminate me... How do I model the data in my program?
The "new" mods have been doing their job for a good long while now. Did you just notice?
By the way, it would be nice if the Readme had a "Project purpose/goals" section.
SPAM
Hello, we hear you. We're discussing it, but we're in disparate time zones so it may be a bit. For the record, yes, we delete comments. This is reddit, and there are plenty of trolls around. We want r/golang to be welcoming to everyone, and if we left up every troll's comment, it would not be. However, we try very hard to be judicious in our deletions. I can't discuss the thread you're presumably referencing until I can talk to the other mods, but I will get back to you about it. In the future, I'd prefer you just mail the mods. We're good, normal people, and we're happy to discuss any actions we've taken, and will admit when we've made a mistake, and if we don't think it's a mistake, we'll try to explain our reasoning.
Please stop spamming your website here. https://www.reddit.com/user/weighanchore/submitted/
Great read. Thanks for that.
Since the new update, the IDE has stopped saving files to the disk but it keeps them around in some internal cache. I wasted hours of work trying to figure out why something simple as adding a field to a struct would throw me "unknown field" error until I used a file editor and noticed that the IDE isn't saving the changes. Also, I can't seem to be able to globally configure the File Watchers.
Writing their own Contains, select, map, and search functions for every project and type.
Come on, you keep posting this literally every week. Please stop.
&gt; In the future, I'd prefer you just mail the mods. I don't normally pm strangers, but if you are okay with it...
I noticed a few [removed] comments before, but you know, it's hard to tell whether the authors themselves removed their downvoted comments or the mods did it.
Meetings. Lots and lots of meetings.
We're mods, it's kinda expected. And we're all pretty nice, normal people. 
We use pact for consumer driven contracts and it's pretty sweer
Have a look at portaudio: https://github.com/gordonklaus/portaudio 
&gt; Until someone speaks up, that is, and no one did that before, did they? It's probably because people who got their comment deleted by a mod already knew that their comment was toxic.
Waiting for CI to finish running tests.
This is not more secure that wss.
&gt; I'm not sure that it can handle my query as I think it maybe be a bit complex It can definitely handle your query. It isn't actually executing anything, and it isn't checking your syntax for compatibility. It's just doing a glorified string match on your query and then returning whatever response you've specified. That's not a knock on it, we use it extensively, but it isn't enough by itself. This is where we're heading for integration tests with our db, but haven't had time to actually try it out yet. https://github.com/ory/dockertest
My bad, I misread the original question.
Sorry for missing that question. Currently, we don't have the plan for being embeddable.
Yes, no magic indeed. But for a `datetime` typed column it'll be a little longer to write, as for MySQL is: "COALESCE(time_col, CONVERT_TZ('0001-01-01 00:00:00','+00:00','UTC')) AS time_col" If there're several nullable fields, the query clause will be a messy. So these package helpers will help you make it cleaner.
There is some truth in that jest. I love `dep`, but to keep things fast `dep ensure` only runs on the `make ci` target, which only needs running when you update `Gopkg.toml` or in a CI build. This keeps testing and normal running fast on local. Seriously though, many thanks to the Dep team. I really love your work and use `dep` anywhere I can. You've done a fantastic job.
tl;dr: comment gets deleted, nobody cares, moving on. Personally I have better things to do than to complain and appeal to the people who have deleted my comments. Got it, the nondemocratically chosen moderators of a private space hosted by a private entity don't like my content. Moving on. What, do you expect them to change their opinions or arbitrary guidelines for you? No, the trick is finding the places that already align with your thoughts and ideas, not to fight the places that disagree. Bubble, you say? Obviously, yes. But I don't think anybody who suggests deleting "toxic" comments has the right to complain about bubbles, as they've already built their own bubble.
Of course, finding out that your comments were deleted can be somewhat tricky when they only show up as deleted to others, but not yourself.
It's not really a dig on the team. Dep's still experimental and speed is an acknowledged area of improvement. =\^)
Madman.
[removed]
Well you build two functions that each speaks to one api endpoint. They would unmarshal the responses, and then map their different responses into a internal struct you declare, that would contain everything needed to describe either api response, assuming they are similar enough. Your code would then only deal with your internal struct, and no part should care about the casing of the api response Hope that helps!
You can unmarshal unto a `map[string]interface{}` and then use the `reflect` package to copy the values into the struct. Here's the code: https://play.golang.org/p/HIH4u3YvTK
Ah, well... Here's where things break down. I have been, throughout my code, using the same struct to both encode and decode data to and from json. It was working just fine when I was working with only one external service, but I just ran into the 2nd one with the differing key signature and I just realized the issue. The other problem is that this other api has a json payload with hundreds of fields. So, I'm not only taking data in, but also pushing it out as well with the same struct...
shiny uses cgo afaik
Hi, Thanks for giving it a look. It started as a quick spike and is still at beta release as of yet, hence tagged "v0.1" on Github. As of code file put in reference here, isn't active yet. All methods return WIP instead of going into main flow. Then, params providing "../" isn't the only way... people can just brute-force uuid as well. But this wouldn't work as unless correct TOKEN associated is provided, the value can't be deciphered and hence can't be returned. Every uuid has it's own random TOKEN, the value existing on Dory is AES encrypted with that. And I agree there would be more attack vectors, but not all vectors are relevant given the use-case of a service. It's like Solr doesn't provide authentication but it isn't supposed to be publicly available. I'll finish full property tests and lint issues before bumping it to a stable release.
Okay, yea I do think it might be best not to try to shoehorn these two API:s into a common interface. You could also build some structure in your app, where you separate the api:s and the internal app logic by separation of concerns
&gt; What you should do is write tests that test against the actual database. To be precise, write tests that test against a clone of the database you'll be deploying to. Tag the tests as suggested in the parent post, then run them on a machine that is also running an installation of postgres. Your integration test setup should create a clone of the database on the local server, populate it with test data, verify your software operates on the data as expected, then tear the cloned database down. Easy peasy! This is what we do for all our database-backed services and each test only takes about 6-8 seconds including setup and teardown. 
It’s just to learn!
A "music player" is not simple for any definition of "simple" and "music player". You'll either have to rely on other packages for basically everything which has to do with "music" and "playing" and all your Go code will be totally uninteresting and non-portable glue code of the form read file, push into external code. Or you have to dig into the gory details of audio formats (you'll learn a lot!) and will have to write strictly latency limited code (because the human ear is pretty good). All doable but not "simple". Expect several weeks to months to just study the format specifications if you are not working full time on such projects. (Nitpick: The language is called "Go" like C is called "C". "golang" is used to google it. "go lang" is awful.) 
I wish that syntax highlighting for text/template or html/template would make it into the final release :-) https://youtrack.jetbrains.com/issue/GO-2953 Otherwise nothing to complain about Gogland (the IDE ;-) )!
Nice read, I would have left out the docker bits to make it more approachable. Article covered just a bit too much in one... go.
Certainly very interesting, but also very ambitious. The matrix team is also currently working on a go rewrite so you might want to just jump on there.
Nice! You gave me a different idea while reading the code and tests, reflection would be an interesting way to do error handling. Actually, it's not even needed to use reflection for it, because the function signature could always be `func() error` and you can use just a variadic argument and break out when the first error is returned, not running the remaining functions :D ha. It's nice to connect the dots sometime.
Good idea! Gonna have a look. :)
Yeah option 2 is what you want here. Repos that represent their own GOPATH are nonstandard and fraught and shouldn’t be used outside of esoteric build environments, probably.
You might want to have a look at the [errgroup](https://godoc.org/golang.org/x/sync/errgroup) package. It's for parallel execution, but you could probably adapt it to be serial if required.
None, but I had an old version of the Go plugin installed and it says "Support for Go programming language. The plugin DOES NOT support all features that Gogland does. See Gogland for details." So I didn't check. Good to know that the plugin supports all the features, thanks.
Oh, I see, you're using https://plugins.jetbrains.com/plugin/5047-go-language-golang-org-support-plugin, it's abandoned, nobody from the Go community would like to contribute. But the brand new https://plugins.jetbrains.com/plugin/9568-go, officially supported by JetBrains has the same functionality as Gogland.
Easy, include sqlite, and wait 5 minutes while multi-megabyte C blob compiles every time you change something…
BAAS is Backend as a Service. Many of you would be aware of how easy it is to get started with firebase or parse, but they require you to use their services. Daptin is a self hosted BAAS I have been working on since the last 6 months. Checkout out a introductory usage article on creating a Todo list using Daptin: https://medium.com/@012parth/creating-a-todolist-backend-with-persistence-a1e8d7d39f62
Wasn't the answer: docker?
thanks again for your hard work. i will be giving you all my monies when this gets released.
To be honest, I just want to busy with something practical and not just that I'll be busy reading, I know this looks like such an interesting idea but I don't have much free time due to studies. So I might take the uninteresting choice and focus on giving it a ui. Then make my own when I get time for it. Thank you for your time and help.
Waiting for peer reviews
Instead of directly starting your own project, I can recommend maybe giving a try to contributing to small and simple open source projects. Doing this, you will most likely learn not only about the syntax but also about: - Useful libraries and tools - How to setup CI - How to properly use git (most schools don't teach git workflows) - Your code will be reviewed by people so they will point out problems and you will learn from this - You will be contributing to projects that people already use - You can even contribute to projects that YOU use and make them better
Never tried, quite new to go. Does it automaticly install the imported packages in your go code?
This tool is fantastic!
Not automatic. If you call "deb ensure" it will install the packages listed in Gopkg.toml in your Vendor folder and I think that "deb init" and "deb ensure -add &lt;package&gt;" will add packages to Gopkg.toml. It is mainly a management tool for your vendor directory. Here is a link: https://github.com/golang/dep I would recommend it for any (non lib) Project. 
Now it looks nicer when checking for nil 8-) https://play.golang.org/p/DP1dH4qkNi
and without err != nil check: https://play.golang.org/p/hTf3rs-rBY
Hello comrade, I wanted to do such a thing, but it seems way too complicated because I don't know how to attempt to do it since the software will be in a late stage version and I will have to understand most if not all of it. Which kinda makes contributing vague for me, I am familiar with basic git usage, I have used it couple of times. What's missing is "how to contribute to a project"
Very nice and approachable. Interesting linked resources. Personally enjoyed the inclusion of the dockerfile setup because it helps me picture how I would deploy such a thing, but can understand how that could be a lot. Any idea what the performance characteristics are? What's the response time? How many requests per second?
Please stop with these infomercial posts
Actually the implementation above is so short, I might just resort to errgroup when I need the concurrency :) TY
Nice! Thanks for sharing.
Silly me, forgot to link the source code. Here it is: https://github.com/tinrab/go-tensorflow-image-recognition.
There's a huge difference between being familiar with git by using it a few times on school projects and being able to use git optimally (learning how to squash your commits before rebasing your branch etc.) As for it being complicated, there are really many little go repositories that are easy to contribute to even without a deep knowledge of the language / project. (Lately I'm thinking about https://github.com/gernest/wow, which is a very simple and short project, and it's quite easy to build features on top of it or to fix existing issues.) Also some projects tag some issues as `beginner-friendly` or `easy` to make it easier to get into contributing. I might start doing this too on my project, but the upcoming tasks are mostly not beginner-friendly unfortunately. Good luck!
Does it feel allergic to you? And THIS a post I am sharing not just the link. Don't talk stop people from contributing open source, to let people know about a project, to contribute on that project. You don't contribute that doesn't mean others can't do it. and don't take it personally. 
I can’t believe I hadn’t heard of TiDB yet either since I like to think that I keep a pretty good pulse on the HA &amp; easily scalable DB landscape—**very** interesting! u/jinqueeny, it sounds like you work at PingCAP—if so, do you all have info about whether all of TiDB will always remain open source? And/or how PingCAP plans to make money? I ask this because, while I’m an SRE, evaluating just the tech alone is not a good idea in my experience... I definitely want to make sure that the main folks behind it will stick around for the long term, that there won’t be any surprise “gotchas”, etc :)
Using CSP channels on micro-threads is not that new either: http://stackless.readthedocs.io/en/2.7-slp/library/stackless/channels.html
To make benchmarking sensible, you'd first need to fix a lot of things. Validate and authenticate requests, protect against "png bombs", make concurrent requests possible, etc. Response time also depends on the image size. [TensorFlow Serving](https://github.com/tensorflow/serving) project might be worth looking into, for serving models internally. And then make a public-facing API separately.
That was hardly an infomercial. Especially for those of us who are deciding whether to use Python or Go for our next project.
I see, and somehow the million other infomercial posts (and yes, they are infomercial, since all they do is rehash the same info over and over while promoting their service) with almost identical content weren't helpful enough? There's nothing new here, just like there was nothing new the last 1000 times a similar post was made. 
I wasn’t here for the last 999 times, so I wouldn’t know. However, I’ll take your word for it that it’s a tedious posting.
How are they promoting their service? After reading the whole thing I have no absolutely no clue what they do..
Hmm cool project. Good tip. 
They barely mention what they do, so I don't really see the infomercial angle. I think I would have liked to see some more details on the performance differences they keep mentioning - json in python is reasonably fast since it's usually a C module. At least it recognized that many services aren't CPU bound or latency critical, but it would have been nice to get some details.
It's a worthwhile effort to start to learn to work in someone else's codebase, with other people, because it's what most of your professional life as a programmer is likely to involve. You will probably spend much more time reading code than writing it. Doing your own projects is also useful, but I wouldn't start with something like a music player. Start with something where you can do simple increments of functionality.
There's a typo in there - "CURD Apis", unless they're something whey cool that I don't know about.
So let me get this straight, you are embarking on a major redesign of your product, and instead of doing the sensible thing of doing research, you are waiting for rags like this to accidentally fall on your lap? Are you the author of this "article" by any chance?
Yeah, this article must be pre-wss. Although even the [2010 rfcs](https://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75) I found have wss in them.
There is almost zero detailed information here. For performance they cite alioth, which should be taken with a bucket of salt in any case. The rest is the same old rehashed story regarding performance, simplicity and concurrency. 
I created this while learning Go which I started about a week ago. I would _really_ appreciate any feedback from more (over a week) experienced Go developers. Thank you.
 s/deb ensure/dep ensure/g Also, if you're like me and find yourself growing more anxious every second it doesn't come back with any output, try `dep ensure -v`.
I don't know why, but I always confuse deb and dep.
Be nice. No, that’s not it at all.
Could it be that you are using a combination of the v variable and viper? When you set the config name, type and path try using v instead of viper.
Official plugin usually updated almost right after the new IDE release and have of the features, yeah.
I sympathize with you but not everything need to be microservice you know. This trend of making service for every minor task is flawed. If the microservice needs to interact with another service very frequently, then it should be part of that service instead of a separate service. Just my opinion. I apologize if I came out as a twat, that was not my intention. 
Thanks for pointing this out. Have fixed it :) 
So I get weird looks when I call Go a "scripting language", but one of the several reasons I say that is the internals look more like a statically-typed scripting language than one might naively expect. And where that really shows is in the `reflect` module, which is basically the run time of an interpreted dynamic language. You can do anything (or at least almost anything) in `reflect` that you would do in a dynamic language, up to and including function composition and all that juicy functional programming stuff. And I say Go is a scripting language partially because the runtime already has all the stuff it needs to support all that, built in. There's a couple of interesting possibilities that somebody looking for a meaty and potentially consequential Go package to build could look into for reflect: 1. A dialect on top of Go that is mostly Go, but allows more scripty-type use for reflect-based code. Right now, reflect is somewhat tedious to use, and easy to get wrong, but in theory a higher-level language could be laid on it that you could dip into if you needed to. 2. A postprocesser that takes a Go package that uses reflect, concretely instantiates it based on some types, and then goes through and resolves as much of the reflect usage based on the hard-coded incoming types as possible. Or, to put it another way, you write some "generic" code that uses reflect, then you say to this processor "Hey, I'm going to pass in []int64 here, what can you optimize for me?" This would potentially allow one to write "generics" that are pure Go code, and do things like examine incoming types to see if SIMD speedups could be used, but then in postprocessing refine out all the uses of `reflect`so all you get is the SIMD speedup. Come to think of it, in a weird sort of way, \#2 there sort of constitutes another Go generics proposal: "Raise knowledge of the reflect module up to the compiler and give the compiler knowledge of how to optimize out the reflect calls upon request." (Umm.... actually... other than the work involved on the compiler side, I'm not sure this is a half bad idea... well... this is the Internet so feel free to shoot it down in detail. :) )
I imagine it would be exactly that...knew it would be something stupid! 😂 I’ll give it a go later- thanks!
Frankly, no one cares. And the list of your reasons is stupid, because the #1 is actually static typing, which although is not that great as it could be still a major win over dynamic swamp.
I love Go, but this article did not add anything of value to the discussion of language pros and cons. 
Did we read the same article? They give explicit examples of what they changed and what the effect was, and why go was good for it. No, it's not a deep dive, but it seemed informative to me.
I think we have different definitions of infomercials. They weren't pushing their product. We delete those posts.
I'm out of ideas to be truly honest with you lads, mind telling me what are some simple projects i can consider making? Should I consider going for Web dev with go(im interested in web dev) ? Don't have a single clue.
A language's approach to dynamic types does not qualify, nor does it disqualify, it as an interpreted language. The weird looks received are likely because of the conflation of topics within the premise.
This is one of those things I have to bookmark, because I know I'll need it someday. Great guide!
Have you looked into gitea? https://gitea.io/en-US/ It is very light weight and you can host privately 
What did you use for parsing and lexical analysis? Don't have time to look through the code now. Will do later if you don't respond though.
I wrote my own tokenizer, mixed with some basic regex checks. So it can suck at some point. Haven't had any issues so far in syntax parsing. But I'm pretty sure something might come up.
We'll both get shot down for this, but as somebody who made a meta language before, I think it would be possible to implement an AST which would be something like Go++, Go with syntax candy thrown in (as you say, "a dialect on top of Go"). This AST would then be converted to the Go AST, and in turn Go code. Reflect I think wouldn't have a lot to do with it, at least not in the current go package sense, as you'd have to reflect the custom AST. Basically what the result would be is a code generator or transpiler, in the sense how ES6/ES7 gets converted to ES5 with babel. Or Typescript. Or Moonscript that compiles to LUA. The most basic example I know from Go is the template language [egon](https://github.com/SlinSo/egon) which didn't go the AST route, but more of a regex pattern search and replace. I did a similar thing with [minitpl](https://github.com/titpetric/minitpl), which enables javascript like object notation (object.object.field) and then uses the PHP's own AST to translate this into proper PHP code. I tried doing the same with the Go AST once, to see if I could detect `&lt;T&gt;` in the name of a struct, in order to generate code based on something like docbook comments that would specify which type substitutions I would need. You can imagine that didn't work, as the Go AST is somewhat strict in comparison with PHP and knows that the source analyzed isn't valid. That's why there's a 100% probability that you'd have to build either something more generic that isn't aware of Go internals but just basic control syntax and keywords, or something that's a superset of the Go AST and fully supports parsing valid Go code. I'd even work on this, if somebody thinks they can move the needle. One of the first steps would be some kind of meta language spec, so we could discuss / evaluate some kind of proposals of what language changes would be interesting. Hopefully that wouldn't end up just a copy of Java/Script specs :D
We use Gitlab at work, and it’s really good. The list of features is amazing, all the stuff you’d expect of git, plus a ton of CI stuff. We’re using the CI pipeline to build containers, push to AWS docker registry, update tasks and deploy services. They release on the 22nd of each month and it’s pretty cool to see all the new features completed over just the previous month. We’re over 12 months behind the latest version, and it still does 99% of what we need
Thank you very much!!! ❤️
As I said, this is only one component of the reasoning I use, not the whole argument. Part of the problem is the term is almost entirely undefined as anything other than "I'll know it when I see it" anyhow.
Wow, this is actually a pretty good article. Compared to most articles like: "here is how, and why I did this (with code examples)", this is more educational and right to the point. Keep up the good work. I can see myself reading more of this type of posts. 
Thank you very much!! 💙 I'm trying hard to keep the articles concise and as informative as possible with full of tips and tricks. I've even deleted the half of the article after editing. Now, I'm working on an article about functions.
does it webscale?
Oh ok. Are there any lexers and parsers for Go? I've been messing around with PLY for Python (ports lex and yacc to Python) and was wondering if there is a similar library written in Go.
2.0 will, and it will have rounded corners.
I have used [goyacc](https://godoc.org/golang.org/x/tools/cmd/goyacc) in the past with some success. There was a significant learning curve for me though. I think there are also some parser combinator libraries as well, but I haven't used any of them.
Sorry? I didn't get it
/u/bear1728 linked goyacc, which is probably the most versatile option. Go also has it's parser available as a package, so if you're okay with using Go syntax then you can use that. Iirc, it outputs a complete AST, you just have to implement traversal and execution.
Ah, but with such a restrictive license...
I'm surprised you didn't mention Atlassian's [Bitbucket](http://bitbucket.org). You're allowed as many free private repos as you like. Been using them for years, wouldn't use anything else, as they have an entire suite of products. They've got integration with tons of other services, including Jenkins &amp; Ansible. They also appear to have [Golang support](https://confluence.atlassian.com/bitbucket/language-guides-856821477.html). Plus I like the [SourceTree](https://www.atlassian.com/software/sourcetree) Git app that comes in handy from time to time. You get a free wiki and a lightweight issue tracker, and you can alway upgrade to Confluence &amp;&amp;|| JIRA if you need to. I've worked on a team of 10 using nothing but Atlassian, and I couldn't imagine better integration across all products than what you get with Atlassian. Their CI integration is referred to as Pipelines, or you can go all in and using Bamboo, but I think you may need to self host it. Their code review features are also great. Comments inline, and you can configure it to allow a change to be accepted after x number of OK's from other devs. It works really well. 
/r/hailcorporate
TL;DR - If producing a viable interpreter for a language requires a new dialect and/or alternate spec, it's absolutely not a scripting language. The potential for varied (and rule-bending) implementations of a language spec induces a blurring of the issue of language classification. Reducing scope to the basis of languages helps to make things more obvious. The intended use of a compiler rather than an interpreter radically influences decisions throughout the design process. Thus, the nature of a language is determined by the purpose(s) being fulfilled by the language authors. Being able to compile a script does not transform an interpreted language's nature, but it may create a feedback loop which influences future language design decisions that lead to it becoming (more) so. This is where the gray area cannot be avoided, and Ruby is probably a good example of this sort of "gray". Similarly, writing an interpreter for a compiled language does not transform a compiled language's nature. When "bending" the intent of a language there are debts to be paid which often require significant workarounds and language transformations which divorce the resulting product from the original language to differing degrees. Starting from a compiled language, using existing facilities to to inspect and handle dynamic types along with creating a dialect to negotiate/simplify the related complexity doesn't make a compiled language into a scripting language. It emphasizes that it is not a scripting language.
`dep` is nice for the development stage. Unfortunately, it is nice only for the development stage: `go get` is now aware of `dep` dependencies and will always download the head of the master. Is `go get` and `go dep` integration planned?
Thank you for the sensible answer. It looks like this code is getting stuck if one of my keys contains a list of types, or contains a struct. How could I update it to support those two?
You're meant to use `dep ensure -add` to add dependencies
No. I mean `go get` should use `dep ensure` if Gopkg.lock and Gopkg.toml are available: I recently run into unpleasant issue when `go get` took the latest commit of one library with breaking changes compared to the last released branch which the `dep` is stick to. That my utility is small and I would prefer its users would not bother with go get .... # Build fail! cd .... dep ensure go install ....
For that scenario, I'd suggest commiting the `vendor/` repo to source control. Unless and until `go get` uses `dep` that's the only way to ensure that `go get` uses exact versions of dependencies. From what I understand, integration of `dep` into `go get` etc. is the hope/goal, but not really "planned" until `dep` has proven itself.
You can use *string if req.Bio != nil { bio := *req.Bio } 
This is cool. I didn't realize tldr existed. I notice you depend on `unzip`; I haven't checked the issue tracker, but you can probably get rid of that dependency with the zip package in the standard library. It's probably slightly more work than shelling out to unzip, but might be nicer for folks on Windows.
They are different tools for different purposes. In the dep's FAQ (https://github.com/golang/dep/blob/master/docs/FAQ.md#does-dep-replace-go-get) there is more information about that.
If you are into it, ANTLR 4 generates LL(*) parsers with Go as a possible target (i.e. the generated parser is in Go). https://github.com/antlr/antlr4/blob/master/doc/targets.md
I wrote [participle](https://github.com/alecthomas/participle). IMO it is really nice to use, but the big limitation is that it currently only supports LL(1) grammars.
I really like all of your C/Go related stuff :) It's just the right amount of crazy :)
They are different things though. ``go get`` is part of the official tooling, not ``dep``. Have you tried setting up an alias so you don't forget to ensure your dependencies?
Wondeful! One thing I'd add for completeness: Json marshal/unmarshal functions to use the string value over the wire if you need that. 
Thank you! I thought about that then I gave up on the idea because I feared that I'll complicate things further. Maybe I should give it a second thought then? :/
Didn't get it, can you explain ?
Archiver can help with unzipping with pure Go: https://github.com/mholt/archiver
I assume it's referring to the GPL license. It's restrictive in that people can't make a profit from your work by building proprietary software with it. 🍿
Have they changed their mind about https://github.com/golang/dep/issues/929 ? No? /care then.
It's better to move the code in api/ to the root.
Is the CI integrated right into Gitlab or is it like Github where you can set your CI (travis/jenkins) to hook up to your repo?
[removed]
I'm pretty sure I took it how you meant it :)