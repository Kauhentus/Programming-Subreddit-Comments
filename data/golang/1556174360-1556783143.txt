Doing compression is pretty easy. Doing good and fast compression, quite hard. That said, I will likely start with some simpler implementations. I have considered making converters from gzip/deflate/snappy/lz4 that simply converts the bitstream and re-compress the parts of it. Should be pretty fast and offer fine compression. Could be a good start for a standalone implementation.
This was exactly my thought. I am giving caddy another try.
With the change of the license, is Caddy still phoning home telemetry data?
the link [https://github.com/alexpantyukhin/go-try-catch](https://github.com/alexpantyukhin/go-try-catch)
Telemetry can be disabled when downloading the binary from the build server. Even when the download of the binary is automated.
Yes :) He's talking about the `errors` package though and criticizing its approach. If every package defines its own error type, then yeah. But the package specifically exists so you don't have to do that.
Break out of the loop when Decode returns an error.
thanks :)
Yeah, looks like I confused myself there. Always had a notion that type conversion requires some kind of expensive "conversion" like it's the case with \[\]byte and string. In case of net.IP there a simple type cast because underlying array is shared in your example. But it looks like it's still is a type conversion according to the spec.
I've had success using a vjoy repo https://github.com/tajtiattila/vjoy
I like it. I am a big fan of its minimalistic style and it supports a wide array of target platforms. I couldn't reproduce (yet) targeting coverity scan analizer, for some of my C projects, but I didn't dedicate too much thought to it. For all my go projects it worked without a hitch.
&amp;#x200B; The MIT distributed systems course is pretty good and they use go as a teaching language, and it's taught by two big legends in the field Nancy Lynch (who literally wrote THE Book on distributed algorithms) and Robert Morris (yes the guy who wrote the first virus he's a professor emiritus ) Lecture Tapes [https://www.youtube.com/watch?v=hBWfjkGKRas&amp;list=PLkcQbKbegkMqiWf7nF8apfMRL4P4sw8UL&amp;index=1](https://www.youtube.com/watch?v=hBWfjkGKRas&amp;list=PLkcQbKbegkMqiWf7nF8apfMRL4P4sw8UL&amp;index=1) Lecture Notes and Selected Papers [http://nil.csail.mit.edu/6.824/2017/schedule.html](http://nil.csail.mit.edu/6.824/2017/schedule.html) I know that this isn't what you're looking to hear, but like looking when looking for courses on computer science principals, you shouldn't have a specific language as part of your criteria, most distributed systems courses are basically lectures explaining seminal papers, explaining fundamentals like CAP, and then you do projects like implementing RAFT or Memcached. Honestly the path to learning is just read papers and implement shit, have it fail in some way, learn your lesson, repeat. These are really noob friendly introductions to the basics that can get you caught up quicker than the book designing data intensive applications. [http://book.mixu.net/distsys/](http://book.mixu.net/distsys/) [https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/](https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/) Miscellaneous Resources The big seminal paper on crdts . [https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf](https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf) Yale Course Lecture notes (I use it as a briefer, easier to traverse, and more modern reference book, other people use Lynch's book) [http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf](http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf) SWIM (a simple scaleable gossip protocol) [https://www.brianstorti.com/swim/](https://www.brianstorti.com/swim/) Omega (Kubernetes is basically omega made user friendly and domain specific) [https://storage.googleapis.com/pub-tools-public-publication-data/pdf/41684.pdf](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/41684.pdf) Mesos (a cluster scheduler like kubernetes that uses a different model) [https://people.eecs.berkeley.edu/\~alig/papers/mesos.pdf](https://people.eecs.berkeley.edu/~alig/papers/mesos.pdf) A good overview on what goes into implementing highly performant clients, (retry policies, load balancing algorithms, and connection pooling). [https://twitter.github.io/finagle/guide/Clients.html#load-balancing](https://twitter.github.io/finagle/guide/Clients.html#load-balancing) Go Code Bases &amp;#x200B; Implements Swim [https://github.com/hashicorp/memberlist](https://github.com/hashicorp/memberlist) Implements Raft [https://github.com/hashicorp/raft](https://github.com/hashicorp/raft) An implementation of Google's Omega Scheduler [https://github.com/hashicorp/nomad](https://github.com/hashicorp/nomad) Consistent Hashing (Dynamo and Elastic Search use this to shard data) [https://github.com/lafikl/consistent](https://github.com/lafikl/consistent) A library for the major load balancing algorithms [https://github.com/lafikl/liblb](https://github.com/lafikl/liblb) Apart from the resources on theory, in production your metrics and logging game has to be on point, otherwise you're just a blind elf going through multiple layers of abstraction.
The most commonly used method for this is consistent hashing (elastic search, dynamo, cassandra, memcached) all use this, essentially you have a set of N nodes, the identifier for the resource (to make it simple let's make it a key in a kv store), is hashed and that hash is mapped to a specific node. There's a link to a go lib for it in my original reply
dec.Decide? If?
If your client is not a web browser I can really recommend to use [gRPC](https://grpc.io) instead of building your own decoding/encoding logic. It's the perfect solution when building server ↹ client data transfer with Go. It's a architecture developed and used by Google for their internal systems so really stable and proven design pattern.
The Killgrave name has a reason, Killgrave is a Marvel villain capable of manipulate minds, with this premise I decided to named the application, because a mock server is a manipulated server with a response do you want. Furthermore, I want people use the application, with names like Umbridge I don't know if people will do or they will run away hahaha
I use Vim-go with Vim and it just works perfectly
even with modules? &amp;#x200B; Me: \*hopes I'm able to find my old vim/go docker image somewhere\*
VSCode with modules and gopls works a treat. Suggestions are fast, everything works. Your installation is maybe broken?
Seems like you have broken or missconfigured Goland. Everything you listed works fine
 &gt;GoLand: &gt; &gt;* No automatic formatting/imports &gt;* Top level functions/types get suggested but methods don't. &gt;* Hovering over a function call doesn't show the signature &gt; I feel like toy haven't properly explored the functionality of Goland. I had previously been a dedicated SublimeText user until I discovered how much more productive I became in Goland. It DOES do automatic import managing and formatting. Check the editor settings. It can replicate gofmt or goimports style. And it's quite easy to see the signature of something by holding ctrl and hovering a symbol. Or I simply hit my doc hotkey to have it either pop up or twice to show it as a docked panel. I don't see why specifically having mouse hover (and wait for delay) is better than these options. I find the testing and debugging interaction just great. And I use the hell out of "Find Usages". I've even applied a SublimeText hotkey mapping to get similar functionality like my multi cursor editing.
Neovim vim-go module.
I was using a fresh installation, they didn't work OOTB and wasn't able to find them in settings.
You're right. gopls works great. The only problem was the terrible default tools. Thanks!
Need I write a screencast or you'll believe me? All working from the scratch in every project. Something wrong with your installation of Goland or Golang.
I'll believe you. Anyway, I'm back to vscode with some edited settings.
Noob here, would you explain me why should I pick gRPC over something's else? Which are the common cases? Never step into this world and there are so many techs that i feel overwhelmed.
For the record gopls is the default tooling in the latest version of the Go plugin.
Yes, I use YouCompleteMe for completion and it works just fine. Other modules are installed by Vim-go with :GoInstallBinaries
Could you please provide a detailed feedback on the edited settings so that we can benefit from it ? I don't use modules because VSCode didn't support them when I tested it (go1.11). I have the default tools.
```"go.useLanguageServer": true, "[go]": { "editor.snippetSuggestions": "none", "editor.formatOnSave": true, "editor.codeActionsOnSave": { "source.organizeImports": true }, }, "gopls": { "usePlaceholders": true, // add parameter placeholders when completing a function "enhancedHover": true, // experimental to improve quality of hover (will be on by default soon) }``` basically, the gopls setup instructions from github.
really? that's weird because all my plugins show up as up to date and gopls didn't work ootb.
Descriptive pkg name, core is too generic.
Overall I think the advice is focusing on the saying the OP should use an existing library for communication instead of implementing some of the basic parts of ensuring message reliability when other people have already done it with a variety of libraries. gRPC has implementations in quite a few languages which is a great plus. I prefer JSON based rest APIs due to their simplicity and prevalence, and I have looked with curiosity at examples combining rpc and gob. Chances are, you will do fine with most choices as long as you make a choice. If you are successful enough for the choice to matter significantly, it will be one of the least of your concerns anyway. The risk of implementing your own solution is simply that you might never cover all the edge cases or have a fraction of the functionality already available out of the box.
Ok.noted will change it to something descriptive.Thanks
I think the video is strongly suggesting to move away from using errors.new in the errors package and creating your own error constants. He does this at the end with ioError.
I use https://github.com/myitcv/govim &gt; I'm pretty damn close to just writing new Projects in Dart because right now I'm pretty much back to having 10 tabs of godoc open just to look up what parameters I need to pass. With govim it's enough to hover the mouse cursor over the function call to get the parameter info. &gt; No automatic formatting/imports Govim has that, by default it uses goimports. &gt; Top level functions/types get suggested but methods don't. Works in govim. &gt; Hovering over a function call doesn't show the signature See above. &gt; With modules, suggestions are slow as heck This one I don't know much about. &gt; "Go to definition" is broken Works for me in Govim very well.
If decode returns an error, then handle that error and break out of the loop.
&gt;No automatic formatting/imports &gt;Top level functions/types get suggested but methods don't. &gt;Hovering over a function call doesn't show the signature I have all of that in Goland. If you want a fully blown IDE, it's really good. If you don't want a fully blown IDE, vs code is more than fine
Nah the typos 😄
My setup is Neovim + vim-go + coc.nvim + gopls from saibing: [https://github.com/saibing/tools](https://github.com/saibing/tools)
Original author of petname here. You could just send me a pull request, and I'll add the medium and large dictionaries to golang-petname?
Same here, Vim + vim-go. Works wonderfully.
Surprisingly enough, I am seeing some job postings requiring this now. About 3-6 months ago, when I first heard about Go and had a skim over the language, I enjoyed it a lot coming from Python. However, I read many places that this was never going to make it to main stream for DS/ML.
I… don't think that holds up to scrutiny. He bases his suggestion on two perceived problems: a) that a sentinel declared using `errors.New` can be re-assigned and is ultimately not constant and b) that a sentinel declared using `errors.New` isn't "fungible". Now, I agree that if we wouldn't use the `errors` package at all and instead all declared our own error types, we wouldn't end up with errors identity confused between different packages - but then, we *already* are not in that situation with `errors.New` and that's the point of his argument in respect to b). And why would we *want* errors to be "fungible" in the space of a single package? The entire point why he *wants* to re-declare an error that is indistinguishable from `io.EOF` is so that he doesn't have to import `io` directly (which, to be clear, I don't think is a good argument either, but let's take it at face-value). If, as you suggest, errors in different packages are always equal and errors in the same package are "fungible", then we win nothing - we have no reasons to declare more than one instance of a sentinel in a package, as we can just refer to the existing instance *and* we can't declare a new instance of a sentinel in a different package, without importing that package (in which case we can just use the existing name). In the end, this section of the talk only makes any sense, if he *explicitly wants* the behavior I am criticizing as broken. Otherwise, the only thing changing would be a) (that you can use `const` instead of `var`, thus solving re-assignment) and there wouldn't be any reason for the excursion into fungibility at all. That section only makes sense, if we're talking about a shared error-type whose identity is determined by its text. And FWIW, I think people use `errors.New` for a reason - we *could* all declare our own error types already, but we don't. We *want* something like `errors.New` to exist. Anyway, maybe you watch the talk just very differently from me, which is fine. I don't think there's any point in reading tea-leaves here. I was just trying to make clear that I don't agree with his ideas here - and to be clear, I don't agree with *either* interpretation. I think "fungibility" is bad for error values *and* I think if you don't have fungibility anyway, you should just stay with `errors.New`, as it provides a better implementation of the concept. There are other ways to solve a), if you think it's that much of a problem.
What about the debian folder and the [update-wordlists.sh](https://update-wordlists.sh) script? It wouldn't work anymore with the new dictionaries setup.
You make a good point. I also think fungibility of error values in the same program—using an error type across packages of the same program—can also be problematic, and that fungibility within the same package doesn't win you much. As you state it solves the re-assignment problem. I came away from the video with the second interpretation, largely because the first interpretation is immediately problematic. I also agree [errors.New](https://errors.New) is still really convenient, and what people still want :)
Yes, works just fine. [https://github.com/fatih/vim-go/issues/1906](https://github.com/fatih/vim-go/issues/1906)
Please don't say stealing. If you look at the README, you can see I've made an effort to credit and link to the original author, I was just ignorant about the license, which I'm working to fix now.
For some reason bingo lang server works for me much better. Sometimes VS code stops autocompleting on gopls until restart, also not making auto imports and import ordering. (Last time I tried around month ago, maybe it changed)
You can't expose a gRPC server on a URL with a prefixed path though. gRPC servers need to be deployed on a root URL. This may give issues depending on your use case, so keep that in mind.
It is strange how much he emphasizes fungibility in the video, when i's immutability that you really want.
&gt; And I really hate the basically parallel DSL hidden within the `#[]` attribute syntax... . If you think build tags are bad enough, imagine having those everywhere, fundamentally altering the way two seemingly similar functions work. I mean sure, some crates certainly magic up things with compiler attributes / directives, but the base language doesn't have all that much that's going on in them either in terms of the 'DSL' or their effects on the compilation. More importantly, though: there's only so many other ways of trying to go about it, and for plenty of reasons you can dislike them too. I'm not a huge fan of `#[attrs_for_days]` but I haven't seen an alternative that offers any objectively superior means of dealing with the fact people are going to want optimizing compilers that do potentially a lot of mangling of what you might have expected, but still allow you to express that some things shouldn't be mangled in some ways because for whatever reason XYZ needs to match a certain execution profile in the final binary. &gt; The other problem I have with Rust is all of these safety guarantees are guarantees in the sense of the guy who sells you flex seal on TV guarantees it won't leak. They are just really strong assertions that "this really shouldn't happen if you follow these rules", but it isn't foolproof. I agree the safety guarantees are somewhat oversold as if Rust prevents all ills a program can fall to, but Rust's compiler gives you better static analysis which (while at times overzealous) can definitely help prevent a lot of bugs that other languages often can't or at least don't. Don't let perfect be the enemy of better. &gt; *technically speaking* since Rust doesn't have a specification, *all behavior* in Rust is undefined, :P Honestly that's one of my biggest complaints about Rust too. &gt; I want to write low level systems code and I don't trust myself enough to manage memory correctly or avoid writing insecure code (and don't know all the fancy tools and static analyzers people use these days or where to find out about them) The clang language server protocol implementation does a solid job and is probably the easiest thing to get going with that'll tell you why your technically valid code is probably a terrible idea when you make a bad cast and whatnot.
It's quite slow actually, considering Go doesn't have generational GC so no compaction and allocations are expensive.
I watched the last portion of the talk again. you are right it does suggest he wants to use the same error value as ioError. I assumed he would importing io for it's type, but what you are saying could well be the case. I agree this is problematic.
Neat! I love it.
A pedantic distinction. Jenkins is a "CI" tool but also a build tool. Most people refer to their Jenkins "CI Pipeline" as their "Jenkins Build" or "Jenkins Job" &amp;#x200B; Every CI tool I know of has building code as it's main purpose: "Each check-in is then verified by an automated build, " -- per thoughtwork's definition. &amp;#x200B; Additionally, this was part of my point: had Bazel been open sourced sooner, the additional stuff would have followed that form a more comprehensive CI/CD tool. &amp;#x200B; Finally, [https://blog.bazel.build/2016/01/27/continuous-integration.html](https://blog.bazel.build/2016/01/27/continuous-integration.html)
if it is the second interpretation. I think it's an elegant, if not slightly inconvenient way, of creating immutable, single error values. Curious if you or anyone else have other preferred methods of solving a) the immutable reference property?
Thank you - I will check it out!
Emacs with evil-mode and go-mode.
&gt; I don't see why specifically having mouse hover (and wait for delay) is better than these options. It does have that too, though.
Thanks, I appreciate the info. Running arbitray doesn't yield any results, but it surely gives me enough info to be able to look into it further.
I created a new go modules project and opened it in Code. It prompted me to install gopls. Everything mostly works like a treat, other than that autocomplete stops working fairly often and begins suggesting symbols in the local document instead of symbols attached to the object. When autocompleting symbols in the local document it often doubles up the words - ex autocompleting “editUser” and pressing enter after typing “edit” will result in “editeditUser”. I tried changing Code settings as suggested on the gopls repo and no change. Any guidance appreciated, would dearly love to get modules working.
Looks like bingo is no longer being developed and saibing is working with Google to move gopls forward. see https://github.com/saibing/bingo/issues/13 At the moment bingo is still better than gopls for me.
Thank you very much for the almost exhaustive list...
Honest question, why not just use Kafka? It's been beaten on and is containered, works with go via librdkafka.
I'm interested as well. Normally I just use pdfunite.
Look at the code under x/limiter, I cannot find any channels.
I think this is only valid for new people. Old users have to switch by themself.
This is in-process, so presumably door someone who wants kafka-like properties from a data structure without having to set up an external cluster or worry about network traffic.
I have noticed GO lang be mentioned in a few job requirements for Machine Learning lately. I remember a while back I had been reading about GO and read a few places that it would never / take a long time to get anywhere close to Python. Is the industry seeing a shift / trend towards GO now? Is it good to learn for some one in Python for about 1 year now?
From the documentation: "If the input is at EOF, Decode returns io.EOF and does not modify e." &amp;#x200B; You need to check for an error to know when the stream has ended.
Oh, I thought this was something like kafka-standalone, very nice and thanks for clearing that use case up.
What a weird thing to lie about. Bazel is a language-agnostic build tool--you define packages and tell it how to build each package. It understands exactly what packages to rebuild when a given file changes, and it builds those packages only. Jenkins is not a build tool at all; it's a CI server. It's core competency is running scripts on its worker nodes. It doesn't know anything or care about those scripts or about the structure of your repository. A common use case is to use Jenkins (or any other CI tool) to invoke Bazel (or any other build tool) to build your code (see your own link).
As others have mentioned, GoLand should work out of the box for the issues mentioned: &gt; GoLand: &gt; No automatic formatting/imports We do automatic import management out of the box, and while the builtin formatter is not on par with go fmt, you can use go fmt on-save via File Watcher. Go to Settings/Preferences | Tools | File Watchers | + | and select the go fmt template there, then press OK. &gt; Top level functions/types get suggested but methods don't. I'm not sure what to make of this without having a way to reproduce it. If it's related to completion, then this has been supported from day 0, so it's likely a weird case if it happens. Any help to investigate this and solve it would be very much appreciated. &gt; Hovering over a function call doesn't show the signature Go to Settings/Preferences and search for `mouse hover`. This will show the Editor | General settings and there you can enable the `Show quick documentation on mouse move` with a customizable delay for showing the documentation.
I would seriously consider using sqlite (even though it requires CGo). Unless you have very specific requirements for a bespoke file format, just use an existing solution.
Afaik, there's no excellent Go PDF library available. I've used PDFbox (java) with good success, and pdflib (vendor) for production usage with great success. You technically could use pdflib from go with cgo, but I haven't tried it.
If you don’t need plugins, you can download from GitHub.
&gt;Top level functions/types get suggested but methods don't. Basically, `go mod init`, then use the `New` function in `github.com/flimzy/kivik`. The suggestions for the `client` aren't very helpful at all.
Here's what I got: [GoLand](https://i.imgur.com/mcdsFEK.png) Please let me know if your results are different or if you took different steps. Steps to reproduce: - create a new `Go Modules (vgo)` project somewhere outside of GOPATH using Go 1.11+ (I did it with Go 1.12.4) - create a new file, with type `Simple Application` (to skip all the boilerplate needed) - type `import "github.com/flimzy/kivik"` - press Alt+Enter to get the quickfixes to show and use `Sync packages of &lt;project&gt;` quickfix - wait for everything to download and index - in the `main()` function type `kivik.New(nil, "", "").var` and press enter to get the variables added for the return values - (handle the error) - `client.` and get the completion items to show.
https://peter.bourgon.org/blog/2017/06/09/theory-of-modern-go.html
Free for AGPL licensed code: [https://github.com/unidoc/unidoc](https://github.com/unidoc/unidoc) Expensive for commercial or closed-source use.
I've worked with binary files just using binary.Read, but this was for a pre-existing binary format. At the time, I tried the 010 Editor for debugging, and it did cross my mind that being able to generate reader and writer code using their binary templates would be cool.
Kafka comes with specific guarantees to ensure reliable brokerage. If this library is similar, how does it compare?
Companies can, you know, pay for the services they use: [https://caddyserver.com/products/licenses](https://caddyserver.com/products/licenses)
To the best of my knowledge, it's still a good idea to focus on Python if your goal is to become a Machine Learning Engineer or Data Scientist. On the other hand, if you are more interested in working as a Machine Learning Infrastructure Engineer, building the distributed systems that execute machine learning pipelines, I'd recommend learning Go.
Why not to use Heroku's container runtime instead of doing workarounds with nodejs buildpacks?
Definitely interesting library. Very nice to have many useful functions and custom types supported with go generate. Len() has no benefits and should be removed!? Additionally the first example outlines why you must be careful when using such a library. It has huge overhead for large n: * O(n) time + O(n) space for Unselect. * O(n) time + O(n) space for Transform. * Just to discard everything and get the last element.
This could have been solved by using a Ø build pack such as https://github.com/TV4/go-binary-buildpack (Or a deploy to Heroku from Travis-CI)
Len() makes the slice support sort.Interface more easily.
&gt;eer or Data Scientist. On the other hand, if you are more interested in working as a Machine Learning Infrastructure Engineer, building the distributed systems that execute machine learning pipelines, I'd recommend learning Go. it would be a good idea to not just rely on one language anyways? and have show some experience / knowledge in a statically typed language too I assume?
Thanks.
Yeah, I think general software engineering knowledge and comfort with different kinds of programming languages is more valuable than deep expertise in one particular language in most cases.
[removed]
I wonder if the issue is on the website side, it may be programmed to send some custom “file not found” page with 200 ok status
yeah eventually I'm sure everything will work outside of gopath fine, but what I \_personally\_ really need is deterministic builds. Modules give that to me, and if I have to still use gopath for a while for development due to lack of tooling support, then so be it.
Would be nice to have Set operators - similar to go-set - on the slices (intersect/union et al)
When I go to the image in your code example, I'm seeing the image and seeing it's returning a 200 response code. By malforming the URL like so: [https://www.fitnessexchange.com/images/egymequipment-store\_1984\_32732548d.jpg](https://www.fitnessexchange.com/images/egymequipment-store_1984_32732548d.jpg) i'm clearly getting a 404 error page w/ a 404 response code. Can you confirm?
The link you posted returns an image. I get a 200 through the code you wrote and through curl as well. Used your code and purposely went to a link that doesn’t return anything and got a 404, so everything seems to check out.
It looks like they are using [incapsula.com](https://incapsula.com), which is blocking the request and returning a 200 status code. I printed out the body from the response: https://fitnessexchange.com/images/egymequipment-store_1984_32732548.jpgea 200 OK &lt;html&gt; &lt;head&gt; &lt;META NAME="robots" CONTENT="noindex,nofollow"&gt; &lt;script src="/_Incapsula_Resource?SWJIYLWA=5074a744e2e3d891814e9a2dace20bd4,719d34d31c8e3a6e6fffd425f7e032f3"&gt; &lt;/script&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;
I accidentally posted the wrong url in the sample, it is now corrected.
I accidentally posted the wrong url in the sample, it is now corrected.
If doesn't do any Unicode encoding. It doesn't even enfocode quotes in keys. No support for correctly formatted floats either. It also limits the maximum size of the generated json to 10mb. Also it is not really a json serializer, it is more of a json writer. Constructive feedback: use append to put bytes at the end of your slice or use bytes.Buffer to write the json. Checkout the standard library on the encoding of strings. If you claim a speed difference, add a benchmark to prove it.
Dude... Loved it! It is surprising that slices don't actually already have this built-in as Go is quite a modern language and all other languages already have things like that. 🤨
It looks like whatever is responding is actually returning a 200 with a body that redirects. Look at the body returned by your go service. I don't know what magic is used by the Incapsula to mess with things (probably sets a cookie and something else with javascript). ``` curl -i https://www.fitnessexchange.com/images/egymequipment-store_1984_32732548_19.jpg HTTP/2 200 content-type: text/html cache-control: no-cache content-length: 210 x-iinfo: 9-12013919-0 2NNN RT(1556234135670 0) q(0 -1 -1 4) r(0 -1) B10(4,289,0) U18 x-iejgwucgyu: 1 set-cookie: visid_incap_1982957=G7pKp36hRtWHyQn9XVjkTpc/wlwAAAAAQUIPAAAAAABm7YSYumig5sqrFbi6yGH3; expires=Fri, 24 Apr 2020 09:57:35 GMT; path=/; Domain=.fitnessexchange.com set-cookie: incap_ses_1181_1982957=gceAFX/zaU/2vkAQb8FjEJc/wlwAAAAA7cmSbxOiTgUnbMgvlFrTnA==; path=/; Domain=.fitnessexchange.com &lt;html&gt; &lt;head&gt; &lt;META NAME="robots" CONTENT="noindex,nofollow"&gt; &lt;script src="/_Incapsula_Resource?SWJIYLWA=5074a744e2e3d891814e9a2dace20bd4,719d34d31c8e3a6e6fffd425f7e032f3"&gt; &lt;/script&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; ```
As mentioned in another thread, these operations will have hidden (or non-obvious) performance issues with large data sets especially when used in chains. Whereas if you are manipulating slices directly with loops and indices it will be more obvious why you might be seeing slowdowns with larger data sizes, especially for beginners who may not have internalized what slices are doing internally.
In the past I worked with the PE File Format (still doing hopefully in the future) I largely based myself on every documentation + Microsoft released SPEC . I got away with [binary.Read](https://binary.Read) by building wrappers for predefined sizes and used with a Walker pattern so I could move my positions when Reading and keep a cache of previous one ...
It'd be beneficial to do a proofread. There's quite a few errors in the post.
An issue I found that I'm going to submit a merge request for soon is that, if you're building for `GOARCH=386`, it can't find `vJoyInterface.dll` so I've [forked it](https://github.com/artman41/vjoy/commit/bc6b8aba0abb8806ccc48ffc1ab0af003664b8c3)
So I managed to get it working perfectly, you might have success looking at [this package](https://github.com/artman41/guitarsniffer/tree/master/guitarjoypad) in my project
Thanks for the pointers, found vJoy from your suggestions and got it working from there
It seems like that's outside the scope of the project, and that's pretty easy to make for yourself I think, wrapping a IntSet struct around a map and all that.
I think it would be interesting if someone made a big-n version of slice manipulation, although this has probably already been done. So, instead of performing operations on each part, it queues them up in a smart way that's efficient for large n, then executes when told to, sort of like a database I guess.
1. Why not use standard http library? 2. I hope you aren’t share any sensitive information. Encourage HTTPS go client instead :)
Sorry to tell you, but they about to release go2 with generics 😅
OPC is everything but a binary format. It's just some zipped XML files.
Yes, you can of course get closer to the hardware with lower level languages, and get more control, at the cost of doing more work yourself. Compared to a lot of (if not all) of the current scripting languages (of whuch python seems most popular), go exposes more of the hardware, but not as much as C and ASM of course. OP asked about doing backend work in GO, I thought the simplicity and consequence of that simplicity of go was worth mentioning.
&gt; Second, if functions are verbs, it seems to help a block of code read more fluently. Remove "seems to".
Just like your web browser? And likely your phone and OS too?
That depends entirely on the implementation.
Without proper Unicode support and no support for encoding special chars in keys and some in values, I personally don't consider this as JSON serialization at all. The least that should work to call it a JSON serializer is that it supports all relevant data types and secondly that the JSON it writes can be unmarshalled back by another library without issues.
It's not against the GDPR to set cookies without consent. Actually, GDPR doesn't deal with cookies at all, it describes only processing of personal data. That's clearly not the same as "cookie", and even for personal data you don't always need to ask consent. Nothing about this is new. The old ePrivacy directive ("cookie law") already covered these aspects for a long time. Everything depends on what kind of personal data can be tied to a cookie. Checking amazon**.com** and ebay**.com** also doesn't strike me as correct, as these are not the European websites. I know that ebay.co.uk and ebay.nl (the Dutch website) have different designs to comply with local legislation, netflix.com serves you a different design depending on locality. The chief author of this has "Beijing" as their locality, so if you scanned from there the results will not be reliable. Either way, things are much more complex than what you stated, which is disappointing since this is from an organisation named "GDPR expert", because nothing in this demonstrates any level of in-depth expertise, only "zomg they're setting a cookie!" fear mongering.
Oh, and your website "gdprexpert.io" sets this: &gt;&gt;&gt; document.cookie "crisp-client%2Fsession%2Fd867c91b-30ea-4fba-b69e-352730e254c2=session_0c40bb69-d87e-45ec-88b7-8aed2decb718" Two cookies, and I gave no consent. It's also pegging a CPU to 100%. I consented to that even less...
Sydney dev drinks represent!!!!
All these sites are scanned from AWS Stockholm.
What you said is really a problem. I just put the page online, and can't wait to provide people a place to try the Scanner. To be honest, I'm really confused, some websites set Cookie before I click the "Accept", other set Cookie after I click the "Accept". Some sites provide me a very very detailed cookie usage checkbox, others not. So, what is RIGHT of GDPR compliance ????
&gt; 9) Programming Elixir
Building Microservices by Sam Newman, published by O'Reilly In my opinion, it's a great starter, giving a broad overview on Microservices at a high level (no code samples, whatsoever). I enjoyed reading it
thank you! Im gonna read it. But i wish there is something with examples
Yeaah will surely do thanks for pointing this out :)
If you use staticcheck as actively as I do, please consider [supporting Dominik on Patreon](https://www.patreon.com/dominikh/overview) or talking to your superiors about [sponsorship](https://staticcheck.io/sponsors).
I would recommend starting by understand the whats and whys, and only then the hows. Also getting the big picture helps a lot to clear the confusion you're talking about. Good luck
As OP said, GDPR is nothing to do with cookies. Eprivacy directive is to do with cookies. GDPR I can do what I want provided I don't store your personal data. (What constitutes personal being terribly defined.
You can not just say: "GDPR is nothing to do with cookies". You may check the [news from TC](https://techcrunch.com/2019/03/08/cookie-walls-dont-comply-with-gdpr-says-dutch-dpa/). &gt;And the Dutch DPA’s guidance makes it clear internet visitors must be asked for permission in advance for any tracking software to be placed — such as third-party tracking cookies; tracking pixels; and browser fingerprinting tech — and that that permission must be freely obtained. Ergo, a free choice must be offered.
That's specifically for tracking cookies.
Pls, name one which is not tracking cookie.
thanks for the tip!
That's how these sort of libraries typically work. See Java streams, LINQ for some examples.
I cannot give comments for the crypto related matters, but here are some general comments: &amp;#x200B; \- Decrypt will panic with input that is less than 32 bytes after base64 decoding. \- Return errors as errors for Encrypt / Decrypt, instead of string. This way you can actually make use of your crypto package in some other cases also. Otherwise there is no way to know if the functions really succeeded or not. \- Leave the "happy path" of the function as the last part of the function: `if ok := verifyHMAC256(ct[32:], hmac, key); !ok {` `return "", errors.New("Invalid hmac")` `}` `...` `return string(plaintext)`
Name a cookie which is not a tracking cookie? Any cookie not set by a third party and intended for use only on the domain it originates from. Session cookies, for example.
Not exactly what op is looking for but still a good read: Sam Newman, Microservices. This is a very good entry point when working with Microservices.
Holy crap they totally copied my library! They give appropriate credit too but still, would've been nice to find it some other way https://github.com/patrobinson/gokini
I don't know who the hell DigitalOcean's social media person is, but it just boggles the fucking mind that someone thought this completely content-free blog spam bullshit would be useful to _anyone_. Seriously, posting this sort of stuff will actively hurt DigitalOcean's reputation
I started this a bit ago, I think it has much of what you’re looking for: https://www.packtpub.com/application-development/building-microservices-go It’s a little rough around the edges, though (not edited very well it seems). Looks to be on sale now, at $10 I can recommend it. I didn’t get very far (other things came up) so I can’t say much more, but it seemed like a decent spread of material.
Isn't the idea of P2P VPN pretty useless as VPNs require trust in the provider?
The idea is not useless at all, we as a provider are trying to build the most secure VPN connection, for consumers and providers to be able to trust us. That is why we are always engaging communities with offers like this, to join and help us to build the best that is needed. For a provider to be safer, we implemented whitelisting at the moment, so you will be assured, that only verified traffic will go through your node
I use database/sql. For many tables, xo/xo helps generating the models, but I haven't seen an ORM that does not suck for joins. And I know SQL, so I use that.
SQL Boiler is pretty cool [https://github.com/volatiletech/sqlboiler](https://github.com/volatiletech/sqlboiler) but you will have to change your mindset a bit from SQLAlchemy.
Even in Python I prefer SQL for my queries, so it might not surprise you that I write SQL in Go and use the standard library plus, usually, SQLx for easier struct filling.
Right but if it's P2P I'd have to trust the random stranger proxying my traffic or what am I missing?
I'm in the process of migrating a Django project to go and (from the perspective of a rank amateur) Gorm isn't awful. I haven't found as complete a framework as the Django ORM or even SQAlchemy, but then I've also realised I don't actually need one. For a pretty complicated (25 models, 80/90 endpoints) api I think I have one instance (using a trigram similarity annotation) where I've needed to write raw sql.
It doesn't escape Unicode chars or print float types, you're right. I've missed to add that. These are minor things to add, not really anything fundamentally broken. I already escape many special chars properly, so adding one more (Unicode is when (the byte &amp; 0x80)) is not going to make any significant impact. These are simple additions, not fundamental disasters. &amp;#x200B; Benchmarks are (of course?) present. You hit "go test -bench .".
I was going to build an agent that can manage job easily (start, stop, inspect), a job can be an executable binary with/without arguments. So \`px\` should only care about the jobs started by \`px\` itself, excluding the other running process.
The only compelling reason to have a front-end session store is when you've got several dozen front-end servers and you can't afford the traffic to your DB for sessions all the time, even with modern fast sharded DBs. This is a degree of traffic you don't have. If you do, you have the self-confidence necessary to ignore Some Guy on the Internet. If you don't have that problem, then your backends can afford getting session state out of a DB in a call and having it that way. Otherwise, the security implications of front-end session stores are just scary, and not worth it. It is scary easy to muck something up and not realize it because everything's technically working.
So do I, \`px\` is just a project for fun with Golang
My point is that forcing you to do obvious things manually isn't a strength. If you don't understand the time and space complexity of reversing a list or whatever, Go is not going to save you from writing garbage, it will just take longer.
"Concurrent-safe FIFO queue" in Go is provided by a channel. What is the novelty of the presented approach then?
Thank you so much. I can't believe I went searching on medium and never came across this article. Thank you again.
It feels secure enough to me. What do you mean by muck up? Give the user accidentally some more rights than they should, any not being able to rectify the situation?
I've seen default keys used in production many times. The authentication key is the only thing preventing users from editing their own session, e.g. to add admin rights.
Have you looked at [Gorm](https://github.com/jinzhu/gorm)?
You are right: you can achieve the same goal using a channel, but you would do it from scratch. The goal here is to provide a pre-built lightweight package with multiple concurrent-safe Queue's implementations (using slices / channels, ...). I think it could save time to people in need of using a queue structure.
Assuming you can keep a secret, it shouldn't be such an incredibly bad idea. But I guess having that escape hatch (backend store) is pretty sensible.
No worries, I’ve spent quite a bit of time with the driver so if you have any questions let me know, I might be able to help.
I use gorm in a very high database throughput application with many (maybe 40 or so) models. It works fine but complex joins and queries require writing sql.
this
Look up “padding Oracle”. Even an encrypted cookie can be broken if your backend produces errors that are too verbose, or responds with different timing. Microsoft ASP got smacked by this pretty badly a few years ago, and there are still sites to this day that suffer from it. JWT is also a horrible mess. For example, some implementations will accept a “null” cipher, fully accepting unsigned JWTs that are completely user controlled. There’s a lot of other potential issues, but these are two that happen all the time to unsuspecting developers. The best way is to simply never trust the user, and give them nothing more than a opaque token.
[removed]
No, the point is, channels *are* a concurrent queue. You can do everything you provide with a channel, except grow without bound, which is generally a bad thing because you _want_ the backside backpressure the blocking provides. And your queues can't participate in select calls, making them strictly less useful.
Update go.mod for v2 by changing [this line](https://github.com/leononame/logger/blob/c59adc752fa64fb9c7e7bc0e77661388946cec2b/go.mod#L1) to `module github.com/leononame/logger/v2`. Update dependents to import "github.com/leononame/logger/v2".
&gt;You can do everything you provide with a channel, except grow without bound, which is generally a bad thing because you *want* the backpressure the blocking provides. That's true for the most of cases, but you might need to grow the queue's capacity in certain scenarios. &amp;#x200B; Please, could you elaborate on the following statement? &gt;And your queues can't participate in select calls, making them strictly less useful. &amp;#x200B; I don't see a clear way to lock operations over a channel if it is not at full capacity (other than using a different variable, like in goconcurrentqueue.FixedFIFO). Maybe I'm not seeing the most obvious way, could you give me some hint? &amp;#x200B; I really appreciate your comments. I'm sure I'll learn new things from this thread.
/u/kai, this is what I refer to. In theory, a perfectly implemented client-side session store *can* be secure. But there's a *ton* of ways to muck it up. It's very fragile; if you change anything, you may break the security. Implementing a secure-as-possible server-side store is relatively easy. Generate a random token using crypto-grade random numbers, give it an HMAC signature, check the HMAC signature with the correct constant-time algorithm as provided by your HMAC library, you're at least 99% of the way there. Consequently, because of the cost/benefit matrix here, I say it's not worth client-side session stores until you are truly so massive you literally can't afford the server-side version, at which point you can hopefully afford the people who can do it right. Here in 2019, to get to that point on readily available hardware where that is literally your *biggest performance problem* is very, very difficult. Anyone working on a website smaller than that should just use server-side stores. For your use case, client-side store is probably a very silly performance optimization that *also* has a very good chance of incurring a serious security problem at some point.
&gt; I don't see a clear way to lock operations over a channel if it is not at full capacity But why is this ever needed? A buffered channel is precisely defined to start "locking (write) operations" on it until at least a single buffered value is consumed. I mean, the channel's capacity is that cut-off value.
&gt; you might need to grow the queue's capacity in certain scenarios. Please take no offence but this is mere hand-waving. Your statement is correct _in theory_ but in practice you use queues to solve two broad categories of tasks: - (Temporary) buffering. - Queues which serve as transports in pipelines concerned with some task processing. When implementing the former case, one must be well aware of the fact that [_queues do not fix overload](https://ferd.ca/queues-don-t-fix-overload.html),_ and that's why it's insane to have them of infinite capacity. When implementing the latter, you typically do not need an in-memory throw-away queue anyway and you should turn to a proper job/task queue with certain persistency guarantees.
But that’s the story with EVERY orm. Roma are a crutch and in many cases provide very little value. Additionally if you structure your data the same way you structure your business/application objects then you are most likely making significant compromises. /end rant
Everything is described here: https://blog.golang.org/using-go-modules You can use ‘go get’ to update dependencies with or without a specific version
Won't the v2 version of the library also need to be in a `v2` directory within the repo? The way that go mod supports major versions is quite different to minor and patch versions.
Even if I specifically tell go mod or go get to download v2, it doesn't work.
I tried it out, it does work without needing a v2 directory. However, I still don't like this approach. I would much rather prefer it automatically choose v2 when I specify the normal import path.
I tried it out, it does work without needing a v2 directory. However, I still don't like this approach. I would much rather prefer it automatically choose v2 when I specify the normal import path.
We may be tired of posts on zstd, but I want hard working developers like you to continue to feel welcome to post here. You're saving us hundreds/thousands of combined hours and producing free useful tooling for compression, ray casting, or web assembly compiling. Keep it up. Your posts are much more welcome than "_Which router do I use?_"
ORM's aren't the best fit for Go, but https://github.com/jinzhu/gorm is probably the most popular. For everyone else https://github.com/jmoiron/sqlx makes SQL queries easier than plain `database/sql`.
Here are the first 3 links with click tracking removed: * https://flowdev.github.io/2019/04/02/why-go-contracts-are-a-bad-idea-in-the-light-of-a-changing-go-community/ * http://www.go-gazette.com/issues/why-go-contracts-are-a-bad-idea-reviewing-cve-2019-5736-go-aircraft-simulation-more-170169 * https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md
There are also small extra bandwidth costs due to encrypted cookies being larger because they must contain a bunch of fields to help verify to the server all the information about the client: IP, user agent, account id, expires time, HMAC sign, etc...
IMO, database/sql is more than enough to build apps that deal with databases. And to deal with migrations, what I do is execute an \`up.sql\` before my tests and \`down.sql\` after my tests, like this: &amp;#x200B; \`\`\` defer db.CreateSchema()() \`\`\` &amp;#x200B; \`CreateSchema\` executes \`up.sql\` and returns a function that execute \`down.sql\`.
Start with your imports, not with go mod. Add "/v2" to your import paths.
I'm having trouble seeing the usefulness of this library. Perhaps someone can explain with a better usecase. A simple example doesn't seem like it's really worth remembering to use this library: ``` const redCars []Car for _, c := range cars { if car.Color == "red" { redCars = append(redCars, car) } } // vs redCars := cars.Select(func(car Car) bool { return car.Color == "red" }) ``` Even a more complex chain seems longer (based on the demo docs) ``` cars.Unselect(func (car Car) { return strings.HasPrefix(car.Name, "J") }). Transform(func (car Car) Car { car.Name = strings.ToUpper(car.Name) return car }). Last() var lastCar Car for _, c := range cars { if strings.HasPrefix(car.Name, "J") { car.Name = strings.ToUpper(car.Name) lastCar = car } } ```
"magic"
https://www.vividcortex.com/resources/the-ultimate-guide-to-building-database-driven-apps-with-go http://www.alexedwards.net/blog/organising-database-access Tutorials - http://go-database-sql.org/index.html https://github.com/golang/go/wiki/SQLInterface Structs to tables - https://github.com/samonzeweb/godb/blob/master/README.md
&gt; One of the most common requests for Caddy is official packages and images. Now that version 1.0 is tagged, we will see about working on integrations with Digital Ocean, various Linux distros and package managers, and making an official Docker container. This means we'll finally see Caddy distributed through default distro package managers?? (Debian, Ubuntu, etc) Very excited about this.
No. That is an advanced option for people who want it, but most people should just leave the code in the root and simply tag the release as "v2.0.0". To go tool will find the right version through the tag. &gt;Won't the v2 version of the library also need to be in a `v2` directory within the repo? The way that go mod supports major versions is quite different to minor and patch versions.
Russ Cox explains in great detail exactly why he made this design choice in https://research.swtch.com/vgo-import Here's a key exerpt &gt; A year ago, I believed that putting versions in import paths like this was ugly, undesirable, and probably avoidable. But over the past year, I've come to understand just how much clarity and simplicity they bring to the system. In this post I hope to give you a sense of why I changed my mind. If you are more of a visual learner, much of the same content is in this talk. https://youtu.be/F8nrpe0XWRg
&gt; I haven't seen an ORM that does not suck for joins. Even `database/sql` is painful for joins as joins can introduce NULLs, even where your columns otherwise constrain them away, and NULL handling in `database/sql` is plain terrible. I often wonder if I am missing something obvious, but I see `database/sql` only being useful for simple queries. As soon as you try to compose tables through joins it all starts to fall apart, largely due to the above. I've evaluated *a lot* of options and came to the same conclusion you did. Join handling sucks. My solution was to create own "ORM" that was specifically designed around joins. I'm mostly happy with it.
+1 Everyone should keep posting their work - it is interesting and informative. The moderators will inform those who are abusing the subreddit.
Thanks, I'll definitely red the article - it might change my mind. So far, I have come to love the things in the Go ecosystem I previously didn't like - lack of generic, error handling, etc. The simplicity and cleanliness of the language have shown me how much more readable, concise and bug-resistant e.g. Go error handling is in comparison to C#, where most people just wrap the whole program in a single try-catch block.
"Brushing" is a term in China used like the English "fudged" or "fudging". It's a heavily used term in the e-commerce world where "brushers" will help add reviews/ratings to a Chinese company's products. Planet Money did an episode specifically on the e-commerce aspect of brushing.
Did I understood well that we have two zstd decompressors in native Go? This is great. It's a highly valuable contribution. What about the compressor ? Is it much more difficult to implement ?
Try `go get -d ./...`
Use `go get -d ./...` &gt; $ go help get &gt; … &gt; The -d flag instructs get to stop after downloading the packages; that is, it instructs get not to install the packages. &gt; …
Use `go get -d ./...` &gt; $ go help get &gt; … &gt; The -d flag instructs get to stop after downloading the packages; that is, it instructs get not to install the packages. &gt; …
That is correct, both I and klauspost have (until now) only a decompressor. I know he has some parts required for compressing already implemented (fse encoding for example). The hard part about compressing is getting the levels right. There are many ways to actually encode data using the zstd format, getting the result small is hard. I for my part will likely not implement a compressor any time soon, I dont have the time for it right now.
So, that list is the list of fonts used in the PDF. What you really want to do is to parse the content stream (where the text is stored) and on the font changes ( Tf command ) check the font weight (I think bold is not really a text attribute, but is defined as a threshold of font weight: https://www.w3.org/Style/XSL/TestSuite/results/4/XEP/bold.pdf). Text contained between font changes from "bold" to "normal" is bolded. pdfreader doesn't currently have a way to parse/extract text, so you would have to write your own. The Unidoc library (https://github.com/unidoc/unidoc) does implement text extraction and the code in https://github.com/unidoc/unidoc/blob/master/pdf/extractor/text.go does most of what you do. Check the process of "Tf" at https://github.com/unidoc/unidoc/blob/master/pdf/extractor/text.go#L47. You'll have to adapt this or write something similar that also add information about the font type. Once you have the "fontObj" object you'll have to find a way to get the font descriptor and check the font weight. If it's greater than the "bold threshold" you'll have to output the information that the text is now bold (and viceversa). Hope this helps!
Are you using Go modules? If so just run `go mod download` or simply `go build` and the toolchain will automatically resolve all dependencies.
&gt;But why is this ever needed? It is needed to lock enqueue/dequeue operations (on-demand) over a concurrent-safe queue (which is the original idea). If you use only a channel as a queue, then you can't lock it before it is at full capacity. Let's rephrase it: I don't see how to do it using only a channel.
Thank you for your contribution!
This so much. I don't mind people complaining about bad generics, and that we don't want to rush a solution that turns out to be bad. I don't mind people saying "I often don't need generics", or similar words to that effect. But the "generics suck and golang doesn't need them, but smap would be really nice" is almost as bad as the "generics are table stakes if you do 100k lines of code" (lots of history proving otherwise ignored).
Concrete scenario in which I need to grow the queue's capacity: I have a max limit for the queue, but I'm running out of RAM and I have to be very careful with the in-memory resources. I don't know if that max would be reached, it depends on some information I don't have at the time the queue is instantiated (using a buffered channel I have to decide the capacity at the "make" moment). But I know what is an average capacity that would work (average capacity &lt; max). I'd only increase the queue's capacity on demand, if needed. Btw, this is not a scenario I just created for this thread.
That Head First Design Patterns cover, so awkward.
I see. Those features/goals weren't clear from the README and the current state of the project. It looked like it just replicates a few existing shell commands. When I look at the implementation of the actions, they don't care about what px has previously managed. It literally just delegates to spawning a process, or sending a signal to a pid.
We use something almost just like this at work.
Buildbot.
I disagree. Currently your library is creating broken output for a lot of usecases, also there is still the 10mb limit. Which is really bad too. For the benchmark: you should move the creation of the object out of the for loop to make it more comparable.
Don't use gorm Popular but really crap, it will be your app bottleneck by itself And it does a lot of really bad magic like 2x requests for simple inserts
This is a nice write up!
Is consul a zookeeper equilavent?
Shouldn't have prematurely tagged that v1.0.0
[removed]
&gt;In what scenario would someone use your FixedFIFO instead of a channel? The goconcurrentqueue.FixedFIFO implementation (which relies on a channel) could be used if: \- you'd need to explicitly lock/unlock operations over the queue (before it is at full capacity) \- you need a queue but don't want to write all basic operations from scratch (enqueue/dequeue/lock/unlock) &amp;#x200B; On the other hand, goconcurrentqueue.FIFO would be useful if you don't know beforehand how many items would coexist at the same time in the queue.
Pretty much. You don’t need as heavyweight a client library, though, and it uses Raft as its consensus protocol: https://www.consul.io/docs/internals/consensus.html
Why did you go with Consul and not Serf? (the underlining library that Consul uses for leader election and consensus) https://www.serf.io/
Why is NULL handling terrible? I find that it's pretty straightforward between the `Null*` types and using pointers. Maybe I'm missing a pain point.
If we're going this way, let's talk on why Consul over etcd? I'm new to this and trying to kill my teams zookeeper dependency.
What part of "they can pay for it" don't you understand?
How does it compare to [Postgraphile](https://www.graphile.org/postgraphile/)?
How does it compare to [Postgraphile](https://www.graphile.org/postgraphile/)?
How does it compare to [Postgraphile](https://www.graphile.org/postgraphile/)?
I'm trying to understand fully, so I have a question: Given this scenario: * The `user_id` is stored in a cookie that is encrypted &amp; signed via the Gorilla `securecookie` library. * If we see a `user_id` in the cookie, we trust (due to the signature) that we previously authenticated this user. * This is what is used under the hood in the Gorilla `sessions` `CookieStore`. * Both `HttpOnly` (no cookie access from JS) and `Secure` (cookie can only be transmitted over HTTPS) are set. What is a possible attack vector? The only thing I can think of is physical theft of the computer that has the cookie. But in that case, a server-side store is compromised as well.
You could have gone one step further in typing your structures and gotten the whole thing decoded properly up front ``` type Results struct { Results []AccountWallet } ``` If you unmarshal into that, you wouldn't haven't to deal with manually building from interfaces
Russ's version is in his Go codesearch implementation: https://github.com/google/codesearch/blob/master/sparse/set.go
You are over-complicating the code. Use this website: https://mholt.github.io/json-to-go/ type Response struct { Result Result `json:"result"` } type Result struct { Wallets []Wallet `json:"wallets"` Total int `json:"total"` } type Wallet struct { WalletUID string `json:"walletUid"` AccountID string `json:"accountId"` Currency string `json:"currency"` Balance string `json:"balance"` }
You are over-complicating the code. Use this website: https://mholt.github.io/json-to-go/ Here’s the full solution — https://play.golang.org/p/leQrh97S17b type Response struct { Result Result `json:"result"` } type Result struct { Wallets []Wallet `json:"wallets"` Total int `json:"total"` } type Wallet struct { WalletUID string `json:"walletUid"` AccountID string `json:"accountId"` Currency string `json:"currency"` Balance string `json:"balance"` }
[removed]
[removed]
[removed]
I feel like you are getting a lot of flack for your project and some people may be missing the point of what you have shared. I want to thank you for the open source project. Frankly any open source project is a contribution to the community. I hope that you enjoyed go and look forward to seeing more of your work.
xo/xo mentioned above exhibits the issue. If a column has a NOT NULL constraint, the types it adds to the struct fields are neither `Null*` or pointers. But in a left/right join the columns are not guaranteed to be not NULL. Which means that you cannot safely use the model it has generated in a join other than where you can guarantee that both sides of the join will always be present. Which is fine. You don't have to use xo/xo. You can craft your own models. But now you either have to unnecessary leak database details into the rest of your application, or you have to define the model twice and perform the appropriate copy. While there is a time and a place, I am not convinced these are optimal in the general case. Just because it can be done does not mean it is a good API. But, like I said, I am probably missing something obvious. I would honestly love to see how others are structuring their code when constructing complex relationships. Plenty of `select column from table` examples out there, but I've never seen a non-trivial example. Pointers are welcome.
Serf isn't used for leader election nor consensus in Consul. Serf and the underlying memberlist are used for cluster membership and distributed health checks. The library that Consul uses for consensus is raft: https://github.com/hashicorp/raft
You can attack the crypto for one. Say a malicious user gets a legit authentication. They see its encrypted using AES-CBC. They then alter the legit token using a padding Oracle attack, altering only the last byte (you can look up the padding Oracle attack). Each response either responds quickly or slow. A quick response means it failed to decrypt, but a slow one means it succeeded but the plaintext failed to decode correctly. Classic padding Oracle. From there, they are able to reverse the crypto stream, and craft their own, “legit”, and verifiable cookies, and put in an admin user ID, or an ID of a targeted user. Say they note it’s a JWT. By the JWT spec, you can select a NIL algorithm for the signature. So they just craft their own JWT and send you whatever they want, and your server accepts it. To be fair, it’s rare to find a library that actually accepts a JWT with a nil crypto algorithm, but it’s possible. If you don’t know to look for it, you can be surprised. Lastly, don’t discount expiration. Imagine you have a 1 month expiration. Thats stored inside the token. Imagine the users machine gets compromised, or there’s some way for the token to get stolen (various MITM attacks, hopefully thwarted by using TLS), or perhaps they enter their password into a phishing site. The attacker now has unrevokable access to the token. You can’t block it. Even if they change their password immediately, the token is still live. The only way to stop that is to do a lookup on the users table for every access, defeating the benefit of client side tokens. One sort of middle ground is to use dual tokens. One for server side session info and another for short term session info. The short term ones only work for maybe a couple minutes, and once it expires, it rebuilds a new client side token. You get most of the speed benefit while limiting exposure. Recycle those session signing and encryption keys frequently, daily or more often. Ensure you’re using the encryption correctly (see Bruce Schneier’s book Cryptography engineering).
I believe in the "attack the crypto" case, the signature my application left on the cookie would now be invalid. So unless they can create a valid signature for their new cookie, `securecookie` would reject it. For the NIL algorithm part, `securecookie` doesn't use JWTs and doesn't work like that. There's no way to subvert it by that means. Expiration is a valid concern. I think it's possible to implement "logout everywhere" by storing a single random string per user (also included in the cookie) which can be shuffled on-demand should the user suspect their information is compromised. The main appeal of this over traditional backend sessions is this ends up just being a column in my users table instead of a whole new datastore for sessions that scales many-to-one with users and needs truncation and management to avoid unbounded growth. I guess the main advantage of this method could be summarized as "requires less infrastructure."
I endorse DeusOrtiosus' answer, but I'll further add that if all you're putting in there is the user ID you're hardly using "client-side session storage" anyhow; that's still very nearly using a server-side session store, or simply not having any state at all. You're really using a client-side store when you start trying to put more data in there, and the more data in there, the more of those exotic crypto attacks become possible. Also, I've lost count of the times that a developer has taken even a sensible, working crypto library and broken it by doing something, like taking the output of securecookie and appending their own stuff to it directly because they want to add something to the client session, or who knows what stupid thing like that. Having server-side session stores means even the developer doing something crazy (other than switching to client-side stores) is still generally secure. Client-side session stores are fragile to change. Maybe you work in a space where you can count on all your developers to understand the far-more complicated client-side requirements, but experience says I don't. APIs that are robust to some common forms of misuse are better than ones that break if some developer accidentally breathes on them funny.
If there was a session destroy error would the lock get released allowing a leader election to take place? Also how does the third leader get elected if there is no second or third for consensus?
But that opaque token is used to lookup the backend session in most cases. So I can't help but think if that token is somehow compromised, so is your backend? Of course as I point out in my video, kick off the user once you notice there is a problem, but let's be honest, you're probably not going to notice.
If you’re using opaque tokens the only viable threat is brute forcing. If the token gets compromised, then you often have a way to invalidate the users tokens, often triggered by a password reset, as well as a button to logout other sessions. You don’t need to know about it; only the user does. You can see this in action on gmail as it lets you see other logged in sessions and invalidate them. That’s simply not possible with a client side session. Keep in mind that a client side session just encodes the actual session data, like a user ID, and maybe their group membership, or access levels, inside a cryptographic blob that’s sent to the client, and then passed back. The server uses cryptography to validate, and sometimes hide, the contents from the client.
You're right... I was thinking that Serf used raft too.
It seems like the repo hasn't been tagged property. 'git tag v2.0.1' and git push --tag
 // The implementation is derived from https://github.com/patrobinson/gokini I never even noticed! Seems insincere to slap an 18 line copyright notice right above an attribution notice. https://github.com/vmware/vmware-go-kcl/blob/master/clientlibrary/checkpoint/checkpointer.go
This is great. I’m going to follow your work with much interest as I am keen to learn about getting the best performance out of Go
Client-side store as an optimization is something only the really big boys need. Client-side store as _means of avoiding all server-side mutable state_ can be very nice, for simple services.
[removed]
[removed]
[removed]
[removed]
You advocating something that doesn't handle strings with quotes right is very worrying. Who cares how fast it is, if it's obviously broken? I can make an even faster, even more broken, "json encoder" any time I want.
He missed the most important thing IMO - an entirely re-written escape analysis ! It fixes lots of cases which escaped to heap previously, but now they don't :)
The nodes [auto-renew their session](https://github.com/didil/go-consul-distributed-loggers/blob/master/node/main.go#L49) as long as they are alive. So even if the session destroy on exit didn't take place, the node's session would still expire after a while (ttl) when the node dies, and the lock would get released. The third leader still gets elected even though it's the only one left alive because there isn't really an "election", nodes don't vote and consensus isn't needed, it's just a simple model where the first node to acquire the lock wins.
&gt;Thank you!
Appreciate that, thx!
Thank you 🙏
No particular reason as I just wanted to give Consul a try. Etcd or zookeeper would have worked just fine. I could also have used [libkv](https://github.com/docker/libkv) which allows you to use any of consul, etcd or zookeeper as a backend with the same API.
This doesn't seem very Go-like to be honest. It seems like an attempt to get a JS promises in Go? Go is just a different language with different kinds of conventions. There are perhaps *some* uses for a library like this. At my last company we had a simple `must` library to run chains like this and panic() on error, which made server initialisation (where we sometimes called &gt;10 functions) a bit more elegant. But that was just a 10 line helper function, with most of the code dedicated to good error messages on failures.
Do you have link to the issue # ?
I think you missed the sarcasm there :p Killgrave is a horrible, horrible person. As are the rest of the ones mentioned.
&gt; It seems like an attempt to get a JS promises in Go? Not really - it is just the nomenclature that is slightly similar (`Then` and `Catch`) - it is not asynchronous (for now). Using a familiar name sounded reasonable. &gt; Go is just a different language with different kinds of conventions. How is that working for gophers? The error handling pattern is one of the most tedious pieces of code people write. I grew tired of it too, and a library emerged from the code patterns I kept on writing. It is not perfect, but it is a way of doing things that is perfectly in line with regular golang tools - higher order functions; using errors as values; wrapping structs into things to achieve more things. I appreciate your feedback though. Thanks :)
Why not if err != nil? Yes it’s repetitive, but who cares... What if I need a function to return more than just an error? ``` var data []byte seq := sequitur.Linear() seq.Do("reading file from disk", func() error { var err error data, err = ioutil.ReadFile("foo.bar") return err }) ``` What happens if I use seq.Parallel() at some point in the future? Do i have to synchronize access on data to avoid races? What if I need the returned amount of bytes in a write operation?
Is all this code really necessary for avoiding repetition with standart error handling? It's even bigger and not so straight forward.
This is terrible... 😄
You haven't really answered the question. Why would you want to restrict enqueue/dequeue when the channel is not at full capacity? Why not just make a channel of less capacity?
yes. its no distributed tech here, because it's just based on other distributed systems. 1. distributed lock services(default as redis cluster). 2. distributed storage service(PXC). anyway, I also think the system can be called distributed system. beacuse it's can be worked on distributed env.
There is a reason that google banned exceptions in C++, and subsequently dropped it from Go. This code is totally unreadable and prone to subtle bugs. Eg, defer is completely broken in this paradigm.
&gt; What happens if I use seq.Parallel() at some point in the future? Do i have to synchronize access on data to avoid races? This is still theoretical at this point but I guess you may proceed as usual - e.g. using mutex over a shared variable from the outside scope or using a channel from the outside scope.
It allows you to group code into application logical sequences. ```go var foo Foo seq := sequitur.Linear() //you can group logical operations together seq.Do("reading foo from file", func() error { data, err := ioutil.ReadFile("foo.bar") //it is still okay to use normal error handling if err != nil { return err } return json.Unmarshal(data, &amp;foo) }) seq.Do("processing foo", fooProcessingFunc) //... ``` btw: I added the above to the README.md file. Thanks for your feedback mate :D
Does the variable stay on the stack or does it escape? How does that impact performance?
&gt; There is a reason that google banned exceptions in C++, and subsequently dropped it from Go Errors are treated as values in golang, and that is a great thing. Execution does not jump implicitly, around because something happen in a sequence. You have the ability to use error as a value, compare, augment, store or otherwise report it. You can also use it to alter the flow of your program. From this a pattern can emerge. Distinguish between logical and technical operation sets. Label each set. One logical operation can have many technical errors, whenever one happens the whole sequence is invalid. On error, report the error, with information consisting of (label of the operation, technical error that occurred) Label of the operation can be used to provide useful information to the end user. Technical error is good for the admins / devs. &gt; defer is completely broken in this paradigm. It exists in the language for people to use. You can come up with novel ways of reducing redundancy in coding. Depending on the case, it is not entirely good or bad all the time.
It's all they're required to do by the license
Thank you very much r/tahkapaa for your feedback , I will be refactoring asap.
Hahaha yes, I've doubted about if you was been ironic or not, I don't know, maybe exists people that love Umbridge or Ratched hahahah And yes, I think that Killgrave is an horrible person but I think that he have more charisma than others do yo mention ir, he is as Negan from Walking Dead he is an asshole but sympathic at the same time :p Do you know what I mean?
I'm curious if you have found any issues with this library and what I can do to improve it given it's 90% my code :)
It is still theoretical, it would depend on the implementation. &amp;#x200B; With regards to performance, I have yet to do benchmarks to compare raw performance.
For people who are dismissive of this approach as un-go-like, I suggest reading [https://www.innoq.com/en/blog/golang-errors-monads/](https://www.innoq.com/en/blog/golang-errors-monads/). It is a great read, and combined with my personal experience, inspired me to this approach.
I don’t think it would. Please do so.
Oh that's tight
https://github.com/golang/go/issues/23109
Happy to see this; starred.
Very succinct and nice article. Thx. I have a usecase with similar example. Client.post.
Much appreciated!
anyone can explain this in layman's term?
never tested but you may have a look to [https://github.com/hhrutter/pdfcpu](https://github.com/hhrutter/pdfcpu)
Seems nice CLI application, thank you!
Yes, true ;)
The question we’re all asking: https://twitter.com/benjamin3977/status/1121659974810099714?s=20
&gt;Even database/sql is painful for joins as joins can introduce NULLs, even where your columns otherwise constrain them away Yes, it is possible to write your joins incorrectly.
You can clone the repository and build a binary with whatever set of options you like, and use it commercially or personally. The commercial offering is a more convenient way to do that.
Is the plan to make Caddy 2 licensed on a similar basis?
Agree with everything you've said but: &gt; slices can't have member functions in Go Slices can definitely have methods functions in Go: type Foo []interface{} func (f *Foo) Bar() { // do something } Or am I misunderstanding something here?
optimize it. (the amount of detail provided in my answer is proportional to the amount of detail provided in the question)
Thanks, I don't see much improvements in benchmarks. Is this expected? What do I get with new approach?
It looks as if the new error thing (golang.org/x/xerrors) is going to be rammed through despite a lot of contentious points. Many of the concerns and experience reports raised on the issue tracker are either ignored or summarily dismissed by the proposal's authors. This comment sums the situation up pretty well: https://github.com/golang/go/issues/29934#issuecomment-487258442 I hope xerrors is not included in 1.13. It needs more time in the oven, and the feedback needs to at least be acknowledged as valid, which simply hasn't happened yet. Looks like it should be a pretty good release without it though!
The link you shared is mostly opinion without substantive data. I'm not suprised if it was ignored. What do you think is broken, why, and what do you think it should look like, and why? Use data. Show examples. If you make a compelling case I can chase it but right now it just looks like what one of my lawyer friends would call "pounding the table"
I thought a backend stored session is better for synchronizing state between multiple devices / browsers. Like when my wife uses my Amazon account and puts something in the I put something in the cart, I'll see it immediately in my browser. There are shopping cart implementations where the devs used a frontend stored session for the cart, but it'll never sync between browsers. You also can logout everyone at once in a frontend store (not individually though). You just have to change the session secret crypto key used to sign the session. Then all session cookies are invalid because they aren't signed by the new session key. This is also something that is not as obvious to developers as it should be: if you commit the session key into your repo and never change it and you give people access to the source, they can create their own valid cookies.
A 50% reduction is code size and more inline comments so everyone can understand it.
Updated the post to a more clean version. Sorry about publishing the early draft .
Where are wrap and wrapf methods, which are clean and make sense. Did they finally add those or not?
Looks good then 👍
Not yet, unfortunately :(
Thanks for your work!
Consul has some convenient programming primitives like [locks](https://godoc.org/github.com/hashicorp/consul/api#Lock) and [semaphores](https://godoc.org/github.com/hashicorp/consul/api#Semaphore) which (last time I looked) you would have to implement yourself if using etcd.
I thought this existed?
[removed]
Nhooyr Software is known to be virus-free.
&lt;3
Bunch of improvements.
They didn't and it gets a fair bit of resistance from the authors that I cannot understand completely. They try to shove the proposal as quickly as possible yet they fear making any more changes and thinking about it a bit more.
uh, the only weird thing was the logging. My app also uses logrus for logging with dependency inject but I had to also set the global log level for logrus to silence info logs coming from the package. Not a huge problem, but if the library allowed me to inject a logger, I wouldn't have to modify globals.
Considering they're meant for completely different purposes and that Go has a runtime, likely never. It's not a goal, it never has been, and frankly anybody asking that question is missing the point so hard it's not even funny
First of all: Thank you very much! I would actually recommend following klauspost's repos. He has way more experience in writing low-level and fast golang (and way more "good" code already published on his github account).
Could you give more details?
I’m assuming you’re putting this behind a balancer, like amazons ALB. I just expose it the same way I expose everything else. So what if someone can hit it? It’s a static response with a 200 OK. Probably takes as little resources as an error message, so why not? Things like ALB that do route matching make it even easier, as you just don’t point a legit route at the server for healthcheck. Use pattern matching for your routes if you’re using a micro-services pattern.
Why can't the health check be exposed? It seems the easiest way to do it is remove any private information than expose to all interfaces. Who cares if someone else can make a health check on your server?
&gt; Goroutine and channel are the main (and only) building blocks to do concurrency in Go. As far as synchronization primitives go, this isn't entirely correct, what with `sync`, `sync/atomic` et al
Oh great, more pointless blog spam from DigitalOcean. /u/ambernc2004, you do realize that this is _not_ good PR for the company? If you folks want to keep churning out blog posts, at least try to come up with something that has relevance beyond what the Go Tour and every single other simplistic tutorial already offers
docker has a healthcheck built in you might be able to use https://docs.docker.com/engine/reference/builder/#healthcheck
Meanwhile, I am here hoping they'll reduce the binary sizes soon. It has gotten out of control at this point. :( In some of my programs, it's 2x of what it was with the latest compiler that was around a year ago.
Yeah that's true although I'd like to keep it away from the public API as it's something internal. I was thinking as a cleaner alternative returning a unauthorized HTTP status if the HTTP request IP is not localhost.
That would be my choice if you really need it to be private.
unused global variables generally do not throw an error, as the compiler can not assume if the variable will be changed from another place.
Do you mean a package scope variable (global variable)? Unused global variables are allowed. As well as functions and constants
You could require an auth token header for the healthcheck endpoint. Then you can still expose it on all interfaces and configure the Docker healthcheck to send the token. Any public requests without the token should return unauthorized.
What does he mean by "record version &amp; dep versions in binary"?
Thanks for your response Femaref. Could you elaborate further on "variable will be changed from another place or not" ? Changing meaning the value of the variable changing?
Bad phrasing indeed, I just updated with better wording, thank you.
yes, exactly. doesn't matter if it's in the same file of the main function or anywhere else, once a variable is global, the compile doesn't make assumptions about them, as their value can change.
&gt; A 50% reduction is code size and more inline comments so everyone can understand it. it means you'll be able to use the stdlib to figure out the versions of the dependencies that your program is using.
Ah I see. Thanks alot for the explanation, I really appreciate it.
For example, another package could import the package and change the variable’s value.
Though TBF this only applies to exported variables. The compiler *could* complain about unexported ones.
Yes although checking the IP is localhost is easier I think.
Also, one thing you may want to point out in a later post is that you don't necessarily need synchronization beyond `sync.WaitGroup` if you eg. know the number of results beforehand and use data structures that don't need synchronizing: https://play.golang.org/p/HKHJoT32H-q package main import ( "fmt" "math/rand" "sync" ) func main() { results := make([]int, 5) var wg sync.WaitGroup wg.Add(len(results)) for i := range results { go func(i int, wg *sync.WaitGroup, results []int) { results[i] = rand.Int() wg.Done() }(i, &amp;wg, results) } wg.Wait() fmt.Printf("%+v", results) } Each "worker" goroutine can write to its own index in a result slice, meaning there's no need for channels (which are pretty heavy-duty and should be avoided in performance-critical code), mutexes (which are more error-prone but faster) or anything from `sync/atomic` (which are even more low-level than mutexes). It should be noted that this won't work with maps as their memory layout isn't guaranteed to be stable when adding new elements
This should be the top level answer
You already got the more correct answer, but I just wanted to say that I highly recommend gjson: [https://github.com/tidwall/gjson](https://github.com/tidwall/gjson) It's fast and really powerful for one-off JSON manipulation. It makes it easy to do things that are hard in Python/JS/PHP, like looping over nested data embedded in lists. What you lose over encoding/json and the like is marshaling your data directly into a struct, so no autocomplete and other code intelligence tooling. This is what I've been doing to get the best of both worlds... type person struct { json gjson.Result name string id int64 } func newPerson(jsonStr string) person { json := gjson.Parse(jsonStr) return person{ json: json, name: json.Get("name").String(), id: json.Get("id").Int(), } } func main() { dave := newPerson(`{"name":"Dave","id":42}`) fmt.Println(dave.name) } I've found that I usually only use a subset of the data returned when interacting with an API, so I manually plug that data into my struct and keep the `gjson.Result` object for query capabilities. Since you're coming from a dynamic background, you could drop this whole thing and just use gjson directly. It's really easy, but when I did this, I missed the type safety, autocomplete, etc. I've been coding in Python and JS for years, but after using gjson (or serde\_json for Rust), I wouldn't want to go back. Unless you use a custom JS JSON lib, you're not going to miss the defensive programming (or hope it works) to avoid "cannot read property of undefined."
Nice. I tried googling the feature, looking on GitHub, etc, but I can't find anything about that. Do you have a link? Thanks.
That's a good point! You could kick everyone off changing the `SESSION_SECRET`! (haven't tested, but it makes sense) I also noticed that Sessions has the `Mechanism to rotate authentication and encryption keys.`. On different devices the session is unique, so it doesn't help co-ordinate the cart problem IIUC. I think you would still need to maintain a state independent of their session per user to get their cart.
check this out https://golang.org/pkg/runtime/debug/#BuildInfo
Very neat. But that is available right now. So what's new in 1.13? Same thing but for dep dependencies?
Inner join all the things! But you've got me curious, when you actually need a left join, how do you avoid nulls when the right side is not present?
How does this compare wth gorilla's
No one will know. Because the fact is this sub is rigged as fuck.
i will stick with gorilla only
I have experience in working with C++ (8 yrs), python &amp; java. I have been working in Go from past 1 yr and found it to be very nimble language. Even in the absence of generic you can work your way through code generation (thanks to the simple AST).
[https://github.com/nhooyr/websocket#gorillawebsocket](https://github.com/nhooyr/websocket#gorillawebsocket)
That was inaccurate. Replace *changed* by *accessed* which means modifying and reading. Some function in some package may access the variable. It would require to analyze all the code to detect such access or absence of access. And there is dynamically loaded code like plugins that is impossible to check at compile time.
I haven't looked into the code beyond a cursory glance, but I could see the utility in an in memory structure that supported things like consumer groups, offset management, etc. Especially if wrapped up behind a layer of abstraction as you could swap out the in memory structure with Kafka under the hood as your application grows and scales.
Server-side authentication, license key, and hardware ID.
Can you use a different picture than the holocaust memorial to illustrate your article? It feels very out of place.
Could it be issue with Linux privileges? Normal user cannot open port between 1-1024. For testing try sudo [startup command]
this.
Why’s that ?
Do you use dynamodb as kv store and sync.Lock as locking mechanism or do you use dynamodb as a distributed store for the locks and the user has to implement the storage interface by themselves? In case of version 1 this library would only work with a single process doesn't it? In case of version 2 I'm curious why op decided to use dynamodb as lock store as it cannot guarantee external consistency. Anyways I'm really sorry if I didn't quite understand the purpose of the library. Could op ad a passage to the README to describe why it was built? Which problems does it solve?
&gt; why does it exit immediately with no diagnostics? Sounds like you're not checking your errors.
This is the correct answer unless something is also listening on that port. Either run it an an elevated user or use setcap to let the standard user open the port.
What I have now is a `/healthcheck` route in my main server which is: ```go func (params *healthcheckParamsType) get(w http.ResponseWriter, r *http.Request, _ httprouter.Params) { clientIP, err := network.GetClientIP(r) if err != nil { logging.Info("Cannot detect client IP: %s", err) w.WriteHeader(http.StatusUnauthorized) } else if clientIP != "127.0.0.1" &amp;&amp; clientIP != "::1" { logging.Info("IP address %s tried to perform the healthcheck", clientIP) w.WriteHeader(http.StatusUnauthorized) } else { // Do the healthcheck here and return OK or not w.WriteHeader(http.StatusOK) } } ``` So the healthcheck is only performed if the client is localhost. Ideally, the `/healthcheck` route would be blocked at the proxy level so the server would not encounter clients from outside. Thanks again for your help !
Yes that's a fair point, blocking the `/healthcheck` route at the proxy level sounds adequate. I have implemented above some code that checks the client IP address and rejects it if it's not localhost, so that I could work without a proxy as well. Thanks !
My server contains a `/healthcheck` route to respond to the actual healthcheck query from Docker. It responds 200 OK is everything is fine, or something else if not. See above for a solution I wrote.
Yes I know that already, but the question was more about how to serve the healthcheck to the Docker healthcheck. I found a solution for now, written above. It uses a route `/healthcheck` on the main server which checks the client IP address and won't perform the healthcheck (which can be time consuming sometimes) if the client is not localhost.
This looks great - I have the official OpenAPI Codegen generators hooked into my current project's `go generate`, but it's gross since it requires Java installation, and the Go code it gives is... not always great. This seems like a nicer solution!
done! sorry, unsplash.com tags without very clear caption
This library is a basic kv store, and a distributed store for the locks, both of which are stored in DynamoDB. The API is "similar" to sync.Lock. This library uses similar model to [https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.OptimisticLocking.html](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.OptimisticLocking.html) Other work done in this area is [https://github.com/intercom/lease](https://github.com/intercom/lease) I am interested in where you read this. &gt; dynamodb as lock store as it cannot guarantee external consistency &amp;#x200B; I will definitely update the README with more background information. &amp;#x200B; Thanks
It depends on the project. If it’s a project which will be worked on by multiple engineers, and which will grow, it might be great to invest in architecture?
Its a personal/practice project.
If it's in the x area, that doesn't seem like being rammed through. Also, it seems like an area so important that there will be enormous disagreement no matter what happens. Decisions like this in a mature ecosystem are quite hard.
In short, yes, it is vital that you be able to write well designed code. You will become more proficient and effective with practice. This is all part of becoming a software craftsman.
Follow up question: where can I go to have people ~~roast~~ give constructive feedback on my code?
The docs state that dynamodb is eventually consistent. Reads can be quorum reads to read the latest write but these "consistent" reads are slow and expensive. Also consistent reads cannot scale horizontally and are not guaranteed to be available. Consistency cannot be guaranteed across tables. Just to make it clear, all this really isn't "bad" it's designed this way. I see dynamodb unsuited for cases like this. Why not use etcd or similar services? Dynamo DB seems to scale reads and writes pretty well when consistency doesn't matter. E.g. tracking events where it's not important to be consistent but rather have wrote availability. To me it seems a bit odd to use a technology that specializes in throughout for a task that needs consensus. In the end I really don't want to offend you. From what I can see you really put some good work into the API design etc.. I really like it when people solve a problem and publish a solution openly. Maybe it helps a bit to understand your efforts when it's more clear how your library fits in the space of locking systems. Anyways thanks for being open for a discussion.
Think of it as an investment. You can either wing it or you can learn on how to design it better. Personally, it's alright if what you're making is not going to grow big. But more often than not applications have a tendency to grow beyond their initial requirements and must accomodate new scenerios. Learning to write code that can grow is a skill that can be very valuable.
Not only does this remind me of javascript callback hell, it simply is much more code to write than if err := f(); err != nil
Npte that gorilla websocket does a shite job terminating the server side of the connection, making every request appear to have failed.
This isn't a book but a MASSIVE 10-part post on Go Microservices. &amp;#x200B; The author often posts on r/golang and promoted the heck out of this one months ago: &amp;#x200B; [https://ewanvalentine.io/microservices-in-golang-part-1/](https://ewanvalentine.io/microservices-in-golang-part-1/)
You can send a close code I believe? It's something you need to do manually before closing the connection though.
nice job
[removed]
Sir.. if i ever see you in real life... I owe you a nice beer! cheers
It’s interesting that Terraform can use DynamoDB as a lock store in light of this.
TF is awful so its no surprise that it includes a bunch of awful design decisions.
Glad to see \`sync.Pool\` getting "some love"...frankly the current state of it makes it a candidate for outright removal...hopefully some improvements can make it a candidate for real use once again. Everything else is awesome and speaks to the realistic intended use case for Go - industrial development. I want stability, GC edge cases solved, performance tweaks etc. I care less about making the language more attractive to tinkerers.
Eh, but then you’re adding a crazy level of complexity. It’s a gross hack really.
Been looking for an 3.0 alternative to go-swagger for a while, which is not planning to support 3.0 any time soon. Hope to see the code tested and stabilized.
Why do you think so? I've been using CloudFormation for a couple years and recently moved one of my side projects over to use TF. The experience is like night and day. IMO, writing HCL over YAML is a huge win, variables are much easier to work with and outputs are much easier to gather. I'm a novice with TF though so if you have any insights I'd appreciate you sharing.
sudo worked a treat! Thanks tons. I didn't know about setcap, either. And also I wasn't checking the log file :O
FYI Amazon has a DistributedLockClient library in Java, and it's built off Dynamo.
I’m learning golang for the little bits of backend work i do and its great. Only problem I’ve found with it is that google cloud is blocked in China. Having said that if I was looking for work in the UK I’d rather be using c#/.net, seems like theres a lot more work around for .net devs.
I’m no longer a novice with TF and while it still has pain points like literally any other technical tool, it’s a whole lot better than CloudFormation or any other alternative tool I’ve used. Also has providers for all sorts of platforms so now instead of just codifying my AWS stuff with CloudFormation, I can also include non-AWS aspects of our infrastructure. Really powerful tool and I have no complaints beyond trivial nitpicks and the occasional case where a platform provider lags behind the platform itself (e.g. new feature in AWS console/CLI might take a but to make it into the AWS Terraform provider).
Sounds like I'm a dumbass. Worst of both worlds--I was logging errors but couldn't find the log, then forgot about it. Redirecting stderr told me what I needed to know: `./test 2&gt;&gt; foo` Result was [predictably](https://www.reddit.com/r/golang/comments/bi9sfu/web_server_exits_immediately_on_port_80_aws/elz0oei/) this: `tcp :80: bind: permission denied` Thank you! One of my favorite parts of Go is its error handling philosophy... and I totally blanked.
[removed]
Awesome. We all need to learn sometime!
I feel like TF exists for people who can't write a python or perl script. Sorry I know that sounds like a harsh value judgement, but its a one-off tool with a one-off syntax that in the past I would expect a sysadmin or devops person to integrate into a broader, well-scripted toolchain. The problem is, these days sysadmins are nearly extinct and devops people often have no coding chops at all. The upshot is most of these devops folks would be better served by just upping the game with scripting tools than trying to figure out the weird corner cases of a one-problem tool like TF. TF is typical for Hashicorp stuff...tools useful for a very narrow task but a PITA for broader integration.
[https://blog.golang.org/gos-declaration-syntax](https://blog.golang.org/gos-declaration-syntax)
Here's a good article that opens up the reasoning a bit: [https://blog.golang.org/gos-declaration-syntax](https://blog.golang.org/gos-declaration-syntax)
I'm not sure, but I know there's a major outstanding issue currently where the main module does not have any embedded version information...
this xerrors package looks so similar to this one https://github.com/RoseRocket/xerrs
It's because of grammar. Language with these type of grammar will be easier to parse, or write a parser for. In language theories, there are several feats from natural languages are not left recursive, such as \`int myvar\`; in contrast \`var myvar int\` can be captured by LL(k) parser (in this case, the k is 0, I.e. no look ahead required.). Most of golangs decision is because the grammar in BNF are very friendly to a compiler person.
Consistent reads can't scale horizontally within the same row, but you still get horizontal scaling on your partition key, so you can get great throughput when managing lots of different locks. Amazon uses DynamoDB for distributed locking all over the place. See: https://github.com/awslabs/dynamodb-lock-client
I think swift does this too
Others have answered the "why" question, but as to whether other languages have had it, yes, here's a type declaration in Pascal: var i : integer; And 'functions' go: procedure getInt(j : integer); begin #function body here end;
There are other languages :) Haskell, oCaml, Ada, Swift just to give you a couple of examples.
I guess functional programming is not your forte. That's okay, although golang has full support for higher order functions and it is widely used everywhere. Maybe you don't use it or doubt see it. For example, net/http package handlefunc. Or the whole concept and common importations of middle ware. Open your mind and eyes friend.
do not forget TypeScript - which is quite good when you use GO in the backend and typescript for frontend
There is a big difference between using closures when they are needed for genericity like net/http and peppering them everywhere. I thought people like you mostly stuck to Haskell, what brings you to Go?
Great. Plan to try this out this week. You should be able to support oneOf by looking at the defined discriminators and constructing the right object, or am I overlooking something? I would probably go with interface as well to avoid too much complexity. I tell people to avoid using *Of in schemas unless they really think it’s going to be superior. It just seems to make everything slightly more complicated (eg the tools people write generally don’t support them - including my own).
Meh, I guess I’ll look into whether the effort of replacing github.com/pkg/errors with golang.org/x/xerrors is worth the effort. Probably not though.
From the end of the article: &gt; The new xerrors is due to be promoted into the standard library's errors package in Go 1.13.
Very nice bro. Am right in the middle of a new project where I have started to use go-swagger. However I'm not the biggest fan of the code that it generates. I'll give this a crack and see how it rolls. I like the fact that the generated code is so much easier to understand. Very nice. Thank you. \[forked\]
&gt; Language with these type of grammar will be easier to parse, or write a parser for. That's not true. The parser is just as easy to write as for other languages. And even if it was harder or easier to write, that is a poor argument for designing the syntax of a language. &gt; Example, int myvar although is left recursive, but the grammar syntax limits the interpretation should the language allows c styled function pointer definition How so? &gt; And it doesn't need a semicolon to end the line It does do so. It's just that semicolons are implicitly inserted at newlines under most circumstances in Go. Refer to the manual for details. &gt; plus the fact that it's unambiguously to read from left to right, even the definition is complex. That right here is the true reason for Go's syntax. &gt; Most of golangs decision is because the grammar in BNF are very friendly to a compiler person. Again, that's not the reason the grammar was designed this way. If this was the goal, Go would use S-expressions or similar. &gt; There are several PL uses this type of grammar. Pascal, Oberon. Pascal and Oberon use `variable : type` which is different from Go's `variable type` in that there is a separator between these two. Important difference! &gt; Some feats resonate with B too, the PL before C. Now that's just plain bullshit. The grammar for declarations in B looks like this: statement // excerpt = "auto" name constant? ("," name constant?)* ";" statement | "extrn" name ("," name)* ";" statement definition = name ("[" constant? "]")? (ival ("," ival)*)? ";" | name "(" (name ("," name)*)? ")" statement Notice how there are no type names in this at all? That's because B has no types! How can B be like Go with respect to the ordering of types and declared variables if it doesn't have type? And while a declaration with initialisation is `variable type = value` in Go, it's `variable value` in B, i.e. there is no separator between the variable and the value! This is quite different.
Note that Go differs from Pascal in that there is no separator between variable name and type name. This is quite a signficant difference as the syntax for types must be designed such that this sequence is always unambiguous.
None of these lack a separator between what you declare and its type. This is where Go is unique.
Ops. I forgot I knew OCaml and have done many projects with it lol
SQL has the *coalesce* function (first non null in list).
But then the columns would have values when they should be NULL. The issue isn't that SQL returns NULL, it is that the API for handling them in Go is terrible.
I’m confused. This looks wonderful, but I thought error improvements were not slated for 1.13 - are there more references to it being included somewhere?
Pretty interesting it’s taken that many versions to make that small a change.
"when they are needed" - are there hard rules to that? I like the simplicity of the language and the power too. Functions are first class citizens and this is by design. Just like errors are values. You can write your whole program as one big blob of code in a single function or you can divide it into several functions and modules. These are decisions left to the programmer. I believe there is value into dividing the code into logical segments rather than just technical segments, by wielding the power of standard features of the language. You want to be closed minded about it? So be it. People like me? I am a pragmatic developer. I value evolution over dogmatism.
Haven't dug in too deep, but how does this improve upon Dave's package? Especially given that there's no compiler/runtime change involved.
In version 3 and 4 of the article, can't this be accomplished currently with \`errors.Wrap\` and \`errors.Cause\`?
Its not straightforward though which is unfortunate. I made sure to make it a first class feature in my library.
Now it's an auth check not a health check
Does it mean [xerrors.Is](https://xerrors.Is) will become [errors.Is](https://errors.Is) in Go 1.13?
At work atm. Is this basically a replacement of Dave Cheney’s errors package?
I tried one on my own and worked fine of safari and chrome of osx but not on ios. I switched back to js.
Im not the one being dogmatic, at no point did I even say anything bad about functional programming.
The package doc here says it's the plan: https://godoc.org/golang.org/x/xerrors
DynamoDB can act as a distributed lock. [AWS has a guide on doing it here](https://aws.amazon.com/blogs/database/building-distributed-locks-with-the-dynamodb-lock-client/), and even publishes an associated Java SDK specifically for this use case. It essentially just requires the consistent read mode and conditional updating. You're right that consistent reads have to sacrifice availability, but that would be a concern with any system that could fit this task (fundamentally, its physics). And DynamoDB is much much safer in practice than any distributed locking mechanisms you'd build on your own. Its the same reason why Google Cloud Spanner says it "breaks the CAP theorem"; technically it sacrifices availability, but it doesn't tend to matter when your cloud provider is spending billions of dollars on private redundant infrastructure. Availability is the CAP theorem facet to choose to break, because networks (within a region) are practically unassailable and getting better every day. A more tailor made solution would be faster and scale better. That doesn't mean this doesn't have a place; Amazon seems to think it does, so much so that they publish their own library in Java to do just this thing.
&gt; Here we are implementing logic on top of the database Then why don't your just declare an `ErrAccessDenied` in your package and wrap the access in a function that can return that?
I just finished updating a downloaded in my app to work concurrently. I’m excited to check this out to see how I should have done it.
Here is the source code: https://github.com/dpc/rust-default/blob/master/src/lib.rs Now, do you still thing that it's exaggerated? :D
Standard http doesn't have circuit breaker
Right, Go doesn't use the colon. I'm just curious, along the lines of the 'why' question, what's the point of the `var` reserved word if you're declaring types anyway? gcc will know `int i;` is a variable, that `int half(int i) {int h = i/2; printf(h)}` is a function. Having var and the type seems redundant, but I guess that's an advantage for the compiler?
&gt; If it's in the x area, that doesn't seem like being rammed through It's being rammed through because it's being rushed out of the x area into the stdlib before any reasonable attempt to collect _and respond to_ feedback or experience reports has been made. Consensus that `Wrap` should be included seems pretty broad, and questions about performance (among other things) have been ignored. &gt; Decisions like this in a mature ecosystem are quite hard. Couldn't agree more, which is all the more reason to not rush.
Point taken, no need to reiterate the same criticism. Bug tracker holds these issues. Thanks
Yes, [https://tip.golang.org/pkg/errors/#Is](https://tip.golang.org/pkg/errors/#Is)
This short talk from recent dotGo explains reasoning behind xerrors: [https://www.youtube.com/watch?v=SeVxmQl9Wmk](https://www.youtube.com/watch?v=SeVxmQl9Wmk)
IMO the main difference is in error inspection, pkg/errors defines it as `Cause(err error) error`, xerrors has `Unwrap() error` with `As`, `Is` to search through error trace for a particular error value. And `errors.Wrap("foo", err)` becomes `xerrors.Errorf("foo: %w", err)`.
I (the OP) am no the author, just found this repo announced and thought I'd share it because I like tools that make handling API's easier.
You seem upset. If you look in the source you can see it does in fact properly escape quotes, backwards slash, newline, carriage return, tab, form feed and backspace. What is missing is also escaping 0x80 chars, aka UTF-8. It's one addition to the already existing 7 escapes and is tracked as a bug. &amp;#x200B; Keys should be escaped also, but that is a simple swap from PutKey to PutString, nothing to get your knickers in a twist over, it doesn't change the overall concept presented.
Thank you that's a good piece of feedback
Not sure if your comment is addressed towards the author or every reader. Just in case, I (the OP) have no relationship to the author(s), and I don't know if they read along. (To ensure you reach the authors, consider filing an issue in their repo.)
I wish the inconsistency between string.Replace and string.Split would be fixed. string.Replace takes a last parameter which is the number of replacements, while string.SplitN is used for splitting a string into N parts (not splitting N times). This is inconsistent. Having string.ReplaceN would help a bit, but the overall thinking is still inconsistent.
They are not inverted. e.g. Pascal does it in the same order. C and thus C++ and Java (and from there scripting languages with bolted on types) got it "wrong".
I'm not a fan of %w over `xerrors.Wrap()` or something similar. The latter is so much more readable.
Additional point for anyone who finds this thread later: I also had to \[change my line endings to lf\]\[1\] to get the rest of the features working. Currently I now have all LSP features enabled and it seems to work like a charm! &amp;#x200B; \[1\]: [https://stackoverflow.com/a/33424884](https://stackoverflow.com/a/33424884)
How on earth is return xerrors.Errorf("taildb: %q: %w", k, ErrNotFound) better than return xerrors.Wrap(...) ? &amp;#x200B; Why the %w which an API can do, if all it does is chaining.
* It does in fact work with Unicode - I just serialized the princess emoji sign without any issues and prettified, validated the output. Maybe I'm missing something? * It has benchmarks, it always had. How would I otherwise present any numbers? You think I just woke up one day and imagined a particular scalar out of thin air? * You are correct it does not escape the key string, only the value string. This has now been fixed. * You are correct it does not dispatch the float type, this has now also been fixed. * You are also correct it has a 10mb upper limit, this has "pretty much" been fixed now, I just need to decide on buffer resize strategies.
Maybe a stdlib version of it. Actually I'm using pkg/errors in my projects too and I am considering moving to xerrors when it's in stdlib.
&gt;can we make a quiz website using golang Yes.
&gt;There is a big difference between using closures when they are needed for genericity like net/http and peppering them everywhere. &amp;#x200B; I was referring to this. Is there a written rule for this or have you come up with this on your own - whereas the language itself not only allows but also includes (in its core libraries) the contrary?
While they perform a similar role, this has additional features such as `.As(...)` and `.Is(...)`. I expect that `pkg/errors` will continue to operate by extending the `errors` API again.
who is "we"?
Presumably because `fmt.Errorf` is going to have that functionality in 1.13, and then it'll be a simple matter of replacing `%s` with `%w` and voila.
True. But to be fair there's a bunch of cases where connections are terminated without a close code. It's not something you can really rely on. When looking through your code, there's a lot of pointless errors regarding the closing of a connection though. If a write fails, the connection is terminated. Yet you call a close on every instance, which triggers a close error as the connection is already closed. Why did you take this approach?
We refers to me and my friend. It's our first project for our high school.
This is so funny! You can be proud of yourself!
\&gt; For the benchmark: you should move the creation of the object out of the for loop to make it more comparable. &amp;#x200B; I disagree, but I added this case anyways. It makes almost no difference, still significantly slower.
I like it, but I normally keep the repository part aside from the model. Basically , a repository is the middle-man for the application to talk to datasources and stuff. And better is, if the repository itself has no idea where the data is coming from. So in my case: handler -&gt; repository -&gt; datasource -&gt; model Which makes it easy to get your data from a csv file, or excel file, or ..... (just by changing the datasource part, and the rest just works. (or from various databases with their own dialect)
Yes. &gt;If the last argument is an error and the format string ends with ": %w", the returned error implements errors.Wrapper with an Unwrap method returning it. This is not the way I'd expect this feature to be implemented in the standard library. This is the kind of clever code go usually tries to avoid.
I think both can co-exist with a little orthogonality violation.
Read about DER and PEM.
Permission granted.
Yes, it's a but risky, I agree... OTOH struct embedding is already [unpredictable enough](https://groups.google.com/forum/#!topic/golang-nuts/fRfkPNlA7Pk) :)
is your server side decryption golang as well?
The benefit is that if this were to become part of the standard library, we would have a standard way to handle error wrapping. This would allow for much better interoperability between code bases.
Do binary sizes matter so much, at least for server side applications? Genuinely curious.
The trick with Go's syntax is that it doesn't need to distinguish types and variable names at the parsing stage. For this to work, I remember that they need `func` and `var` keywords.
[removed]
For real, the new approach is really counter-intuitive. I like that Go is normally very plain and obvious about what's going to happen. It isn't clear that `Errorf` with `%w` _at the end_ will do that unless you already know about it.
Std or not, its still a dependency. Just not one outside std. I dont get why this is an issue with go modules tho?
Are facing a particular problem? What have you tried? Do you have any experience with building a website? Have you written any Go code before? You need provide context and to get a specific answer you need to be specific in your question.
It depends on your usecase/where you are deploying the project. If you are deploying it on a bare metal machine, docker container it's fine. The sizes have roughly doubled in size but (let's say) an increase from 15MB to 30MB is not significant if you have half decent internet. It does becomes a problem when you are deploying on stuff like Lambda or Azure functions. They have their own restrictions on max function size so, If you exceed that limit it's non-trivial amount of work to reduce it so you can deploy it there, you can use strip but sometimes that's just not small enough. and the tools I personally use to use serverless offerings is serverless.com which has a painfully slow, terrible way of uploading function zips(Sequential instead of parallel), So, It just ends up taking a lot more time. I have not been following go's development for the past year or so, So, I don't really know what change increased the binary size so much but I'd like them to be where they were in the past.
(Reposting from my Twitter reply to David.) &gt;I've used `xerrors` in a project. I remember wanting a way to simply add the frame information to a an error without adding a message. Something like `return errors.Here(ErrFoo)`.
Actually, now mine is not working again and that hasn't changed. I can't tell why, it might be something to do with having changed the Go version or idk what... gopath... i hate it when it changes and I can't point at anything concrete.
This is true- using these new features will require a dependency on Go 1.13. It’s a not a problem per se with managing dependencies, especially since as you mention modules make this much easier. In my case, it’s more a matter of preference- as currently I find myself using [github.com/pkg/errors](https://github.com/pkg/errors) in nearly every Go program that I write. Importing `github.com/pkg/errors` instead of `errors` for what IMO is essential error handling functionality is annoying. But to give an edge case where reducing external dependencies is advantageous regardless of modules, is when you work in an industry that requires development in an air gapped network. That’s not to say it can’t be done (i.e. modules `replace`, hosting a private mirror, etc.), but the effort and hoops you’ll have to jump through is a PITA.
I updated the README to add some responses to the questions you asked. Thanks for the feedback.
Thanks for the aws link, will add it to the references.
Oh wow. That's a real improvement! I think you really did well explaining the motivations and possible use cases. I also like the explanation to distinguish between etcd and your lib and why to use this one. Well done!
Is `xerrors` compatible with older versions than `go1.12`?
`Unwrap` should implement an `Unwrapper` interface, the way they've done makes no sense to me.
Appending a special flag feels more magical than what we normally see in Go. Feels wrong. The .Wrap that we see in pkg/errors feels much more idiomatic.
That not the common case though, you usually do want a error code. The close only happens once, see the sync.Once. All the others just return immediately. It’s just to ensure resource cleanup with defer.
This would break existing applications
Will clarify the docs, thanks. &amp;#x200B; [https://github.com/nhooyr/websocket/issues/78](https://github.com/nhooyr/websocket/issues/78)
Yes, unfortunately. Adding `string.ReplaceN` would not break anything, though.
This is for scraping a web page, right? The lack of an interface makes me think there's a missed opportunity somewhere...
You use \`WORKDIR\` to force the lib into \`go/src/app/vendor/github.com/...\` which is not in the lookup paths mentioned above. I think because the lib does not offer dep support. &amp;#x200B; Just check it out to \`/go/src/github.com/neo4j/neo4j-go-driver/neo4j\` instead to have it inside the default gopath.
If you really need a left join, then you know what you want to end up with in the empty columns and should write your SQL accordingly. Or is it simply that you don't actually know about `COALESCE`?
I'm allowed to freely possess and use MP3 files. I'm not allowed to distribute copies of them, and I'm expected to pay the service that provides me with the downloads.
For those interested, [recursive processing](https://github.com/danielkvist/fitchner/blob/master/filter.go#L92) with [html.Parse](https://godoc.org/golang.org/x/net/html#Parse) is slower (but easier) than using `html.NewTokenizer()`](https://godoc.org/golang.org/x/net/html).
I can see in hindsight how my comment wasn't clear, but I did [clarify practically a day ago](https://www.reddit.com/r/golang/comments/bhmaq6/coming_from_python_what_are_the_database/em0pvn3/). Your comment seems entirely redundant. The problem is that the Go sql package doesn't have a reasonable API to work with NULLs, not the NULLs themselves. You can fix the API by wrapping with a whole bunch of equally ridiculous code, but we'd be a lot better off if the standard library's API was better from the start.
You can also use `IFNULL(val, 0)` in your select to avoid having to deal with it from Go at all.
Hey Scott! Longshot here. I had a course via Google Dev Foundation( I Think) that I lost access to with a PC move. Do you happen to remember who you had that with so that I may try to find my login? Also, do you have, or recommend, a basic HTML /CCS book or course? I seem to remember that the Go course required just a bit of it. Cheers and Thank You for what you do!
I am new to programming and after web surfing for a while I found out that Golang is the best language for back end developers and I want to become one so I wanted to know whether we can make an online quiz app
The deeper problem is that nulls are [ambiguous](https://www.vertabelo.com/blog/technical-articles/50-shades-of-null-or-how-a-billion-dollar-mistake-has-been-stalking-a-whole-industry-for-decades) and not typesafe, so every strongly statically typed language has trouble dealing with them. The best option is to avoid having them in your database design to start with. The fact that Go forces you to use (for example) a nullable string type or a pointer for a nullable text column is a feature, because it forces you to think about the problem.
Wow that’s really cool. Isn’t webasm pretty beta with Go right now tho?
Realistically, all that needs to happen is to not halt the scan when encountering a NULL that cannot be satisfied by the target type. As default values are meaningful in Go, those values can remain in their default state. An error should still be returned detailing the presence of the NULL that could not be appropriately handled, leaving it up to the user how they want to deal with it. If the NULL really is an error, it can be corrected. If it is expected, the user can apply their own logic without having to resort to additional types that are not appropriate for the task at hand.
Yes, the support is still maturing, but it's still possible for Go newbie like me to port the program to wasm and run it in the browser, which is exciting!
This doesn't feel right. The `: %w` format string magic instead of just wrapping the error like we all already do. Trying to fit this into 1.13 when, by the articles own admission: &gt; However, Go 1.13 is only three months away! After that, all of these new changes (and this post only covers one) will be frozen forever in the standard library under the Go 1 compatibility promise. For such a high standard, this package is woefully under-tested. This just seems like we're rushing this through, and given the constraints of the Go 1 compatibility promise, we should do less now and add more later if needed.
Yes, it's basically his only function.
I had always had pending try html.NewTokenizer() but I've never found the moment to get down to it. Maybe now's a good time to try...
C's syntax is notorious ambiguous. You don't know what's a type and what's a function until the names are resolved, so you can't parse certain nested expressions either. See https://en.wikipedia.org/wiki/Most_vexing_parse
Return type first is terrible for functions. Declaring a function that returns a function in C et al is a nightmare. You could do a partial fix, like `func Closure(int x) -&gt; func (int y) -&gt; int` but at that point, might as well go all the way and make the variables first and types second.
https://research.swtch.com/deps
`check` and `handle` are not planned for 1.13. This is a separate error improvement.
Hi Gophers, if you like, please help me test this Go module proxy so that it can be released much more earlier. :-)
What I'm getting at, but correct me if I'm mistaken, if you run into a write error then you try to close the connection before returning from the write method. As a result, the connection's error will be both the write error and the connection close fail error (you can't close a closed connection)?
[removed]
Thanks, I was waiting for your permission
&gt; I'd also recommend using a coverage guided fuzzer, like libFuzzer or AFL. Two interesting test cases would be: FWIW the standard Go fuzzer seems to be https://github.com/dvyukov/go-fuzz
There're many changes that contribute to size growth. Pretty much all of them are internal due to some changes in the runtime or compiler. They're unavoidable and require separate measures to be developed to counter the growth. For example, dwarf compression was implemented precisely for that reason. There're compiler flags that can remove all debug information if you don't need debugger support. There're also edge cases where size growth is unexpected. 2x sounds like an anomaly and probably should be reported on the github [https://github.com/golang/go/issues/6853](https://github.com/golang/go/issues/6853)
It will only be the write error. The close error gets ignored.
Permission granted to grant permission.
Why does it return an `io.Reader` instead of an `io.ReadCloser`?
You're absolutely right, I just changed it.
That's an interesting idea, but it seems like a MySQL-ish way to handle it, and I can imagine it hiding all kinds of errors. Plus, doing it without reflection penalties would be hard. Maybe try writing a wrapper or a new type to do it, and see if it works well?
&gt; I can imagine it hiding all kinds of errors. Like what? It is effectively no different than how it is now, other than your valid columns wouldn't be left unset. Which, if someone is going to ignore the error returned by `Scan` for some reason, is even more dangerous. &gt; Maybe try writing a wrapper or a new type to do it, and see if it works well? This was already covered at the top of the thread. It does work well.
You mean copying the folder to that path or running the dep command in /go/src/ ? Because running the dep command give me an error -- `init failed: unable to determine the import path for the root project /go/src: dep does not currently support using GOPATH/src as the project root`
Thanks for the great write-up. I really love reading these raw explorative articles that show the process of overcoming one obstacle at a time. &amp;#x200B; Be sure to file github issues with BrowserFS to support the issues you had to 'patch' against, like read/write codes.
Interface for what? Interfaces are for the consumer mostly, but the lack of package internal usage of it might signal the lack of testing, that is true.
Don't forget to document what happens if the consumer modifies the html.Node reference, I'm guessing just undefined behaviour happens :)
What's the state of gopls? How does vim-go work if it's not installed? Is vim-go mod compatible?
• Since there’s only 100k unique lines, you could use a map where the key is either the log line, or a hash of it, and the value could be a boolean • If there’s something unique on each log that you can extract with simple string operations, then you should use that instead of the hash to save some calculation time • Also you may want to return a []byte from getURL instead of a string since most hashing functions I know require bytes • You may also want to add a semaphore in `main()` to send a small amount of HTTP requests per batch, right now it looks like you are sending 100k requests all at once, and that’s usually a bad idea
Right now, you actually have to run \`go run main.go --url [https://urlhere.com](https://urlhere.com) \--count 10\` or whatever. So basically, run this in a loop until you get 100k unique entries in the map? Every log line will be unique, and i also need to sort them from oldest to newest based on their time stamp, example log line here: May 3 18:23:56 localhost login[714]: ROOT LOGIN on '/dev/tty1'
&gt; you actually have to run […] or whatever If you don’t mind executing that command 10,000 times, sure. If you add the semaphore as I suggested, you only need to execute `go run .` once, and the semaphore and goroutines will take care of the rest. You can, for example, configure the semaphore to allow 50 requests per batch, which means you only have to wait for 2,000 iterations. This will surely be more productive than waiting for the command to finish before continuing with the rest of the operations. &gt; i also need to sort them from oldest to newest based on their time stamp In that case, instead of `map[string]bool` as I suggested before, use `map[string]time.Time`.
Well, you could have two log lines that have the same time stamp, so I'm not sure i can qualify a unique log line by timestamp, sadly. I don't even know what a semaphore is, so i clearly have more research to do!
Can you use the golang net library on wasm apps too ?
https://godoc.org/github.com/pkg/errors#Wrapf errors.Wrapf(err, "problem with %v", key) vs xerrors.Errorf("problem with %v %w", key, err)
Your bottom scope is racing with the top scope. It gets there first. The problem is the default statement. It executes immediately if none of the cases are ready. You want some way to block your 1st goroutine until the 2nd one has completed its work. A dummy chan (make (chan struct{}) or a sync.WaitGroup would do.
I suspect hysterix.Go executes the function passed as argument in a go routine. It may then happen that #2 is executed before #1, which result in what you see. That is the only explanation I could find that would make sense. You need a synchronization to ensure #2 is always executed after #1. Or you modify your code to enforce time order dependence.
You can compile it. It does not mean though that the browser will allow you to use it to its full capacity
What kind of answer were you hoping to get for this specific question? A yes or no? Or a complete description on how to develop your idea? The first is more likely, but also not very useful. The second is unlikely. So, yes you can do it. What is your next question that will actually be useful to your goal?
I wanted a Yes or No answer
If you moved the content of the default block out and after the select it will block until the errs runs, and then it will return the expected value.
Just plain copy or direct git clone into the fitting structure. You multi stage build should be able to `cd /go/src/github.com/neo4j/neo4j-go-driver/neo4j` and find the appropriate files. Once it does, the lib will be found during compile time.
Nice! The readme could be a bit more chatty though.
Thanks. You're right, it is a little terse. I'll update it. By the way and in the meantime, all the commands take a "-help" argument that gives a full usage message.
Neat. I have also found [https://github.com/wmark/semver](https://github.com/wmark/semver) to be quite helpful, as it can also recommend the next semver tags.
\&gt; "excited to share ... module mirror, index, and checksum database!" Here I sit, unable to share my excitement with my loved ones who have no idea what a checksum database is.
As an aside, have you considered the distributed, Go graph database dgraph? https://docs.dgraph.io/dgraph-compared-to-other-databases/#neo4j
%w looks trash compared to errors.Wrap. And errors.Is does not read well either, Is sounds like it should be a method on error types, not a function in the errors package (same with As).
Linked from the announcement is the [original proposal](https://golang.org/design/25530-sumdb). It provides a nice overview of the problem it solves and how it is solving it.
Thanks for the advice, I'll add it to the documentation as soon as I can.
Somehow, I don't think even the proposal abstract is going to help.
hi - I've just updated the README now. It should be a bit more inviting. &amp;#x200B; Thanks for taking the trouble to point it out
That's interesting. Thanks for pointing it out. You might also be interested in [github.com/rogpeppe/go-internal/semver](https://github.com/rogpeppe/go-internal/semver)
On the face of it an "online quiz app" would seem to have more frontend development than backend development. But you want to learn Go and it is a school assignment, so why not put the two together :-) My advice, if you want to learn how to develop for the backend: - Output the raw HTML, avoid writing any JavaScript. - Use someone else's CSS, e.g. [Bootstrap](https://getbootstrap.com), or be happy with an ugly web page. Avoid writing a lot of CSS. - Stick to the built-in Go packages, try to learn Go without trying to learn somebody else's libraries. (Ask questions like "what builtin package can I use to do X?") - Spend 20 to 30 minutes to make a plan and run it by the person who will mark the assignment. They will be looking for some key outcomes that you have to achieve. You don't want to find out that you're expected to use JavaScript and CSS in the final hour. I'm assuming that you both want to work on the backend. If your friend wants to do the frontend then my advice would be different. If the plan won't fly, just do what you must to fulfill the requirements. In this industry, you sometimes need to meet arbitrary technical requirements that were decided a long time ago by people who didn't know what they were doing.
I made my peace with that a long time ago.
Naive N-Queens solutions is know to be slow. It is a classic problem that requires optimization in ACM/IOI training, and as far as I know, all optimizations uses the fact that the pieces are queens, which means, it probably will not be suitable for your problem here. That does not mean your code has no flaws. &amp;#x200B; First thing first, without actually running or profiling it, the most obvious problem regarding performance is that your code allocates too much. Everytime you call a `b.Place` , you make an allocation for an entire new board. This is a huge waste - allocation is not free, nor is copying data. Considering there is no concurrency (thus no chance of data race), instead of creating a new board, simply modify your board before doing the recursion and modify it back (you don't even need to record the history of the board). board.Board[i][j]=pieces[0] board.Used = append(board.Used,c) // ... board.Board[i][j]='_' board.Used = board.Used[:len(b.Used)-1] This change breaks the code to add solutions though, since the underlying board is being constantly modified, so change the lines to: *solutions = append(*soulutions,b.CreateBoardWithPieces(board.M,board.N,board.Used) &amp;#x200B; It aslo breaks `testedConfiguration` but the use of testedConfiguration itself should be changed. Instead of keeping the whole board, keeps tracks of board.Used, and keeps them in a map of its length. So, change `testedConfiguration` into `map[int][]primitives.Attacks`. Only check `contains` with `testedConfiguration[len(board.Used)]`. And change the append to: append(testedConfiguration\[len(board.Used\]) = append(testedConfiguration\[len(board.Used\],append(primitives.Attacks{},board.Used...) There fore contains need a rework: func contains(usedContains []primitives.Attacks, testedConfiguration [][]primitives.Attacks) bool { for _,k := range testedConfiguration { if SamePieces(usedContains,k) { return true } return false } &amp;#x200B; You do not need to convert piece into strings to sort in SamePieces. &amp;#x200B; func SamePices(used1,used2 []primitives.Attacks) { // don't want to modify orignal used. u1:=append([]primitives.Attacks{},used1...) u2:=append([]primitives.Attacks{},used2...) for _,u := range [][]primitives.Attack{u1,u2} { sort.Sort(u, func (i,j int) bool { x,y:=u[i],u[j] if x.Row()!=y.Row() { return x.Row()&lt;y.Row() } if x.Col()!=y.Col() { return x.Col()!=y.Col() } return x.Name()&lt;y.Name() }) } for i := range u1 { if u1[i].Name()!=u2[i].Name() || u1[i].Row()!=u2[i].Row() || u1[i].Col()!=u2[i].Col() { return false } return true } It is a bit verbose, but it saves waste from constructing and comparing strings (which are much slower than comparing ints and runes). &amp;#x200B; Note: all above codes are written within a plain browser without test or `go fmt`, it might as well contain bugs. But I think they demostrate the idea between it. &amp;#x200B; The second but equally (if not more) important part: Code style. The way you orgnize code, the way you name things are very un-idmoatic in Go. Please read [effective go](https://golang.org/doc/effective_go.html). Usually, the constructor is called `NewXXX` instead of `CreateXXX`, and `IsSafe()` can simply be `Safe()` with `notYetPlaced` being `Placed`. And all the packages could very well be in the same one. ~~A small rant: The variable name you are using is simply too long and too verbose. It is such a pain for me to write code with these names.~~
[removed]
Well, yes in theory, Go is great for CLIs. But in this specific case, 1) You should learn to use the SSH config file. It trivially handles per-host configs for you. 2) You shouldn't be SSH-ing to servers all the time - you should automate more so you don't have to. (i.e. things like Kubernetes.)
I'm not sure I understood exactly what you need, but with some simple entries in your ssh\_config (\~/.ssh/config, see man ssh\_config for the full syntax) you can easily create aliases for the hosts you regularly connect to. &amp;#x200B; E.g.: &amp;#x200B; Host a HostName [a.long.hostname.com](https://a.long.hostname.com) Port 1234 IdentityFile \~/path/to/id\_rsa Host foo HostName 22.33.44.55 IdentityFile \~/path/to/another\_id\_rsa &amp;#x200B; This way you can simply run \`ssh a\` or \`ssh foo\` to connect to those hosts.
You could use both a map and a list. Use the map to check if a line is new or not (use the line or an hash as the key) and use the list to keep track of "new" lines in the order you read them. Again, with 100k unique lines it shouldn't be a problem to keep everything in memory.
Thanks for the advice guys, that’s exactly what I needed and was missing - I’ll check out the ssh config file. I figured I write Go all day may as well use it to solve this problem but seems a more elegant solution is already in place
Thanks!
Thanks! Agreed. We are moving to k8s and I personally can’t wait to never ssh into a server to tail logs again haha
I haven't dug into compilers to really know how it works, but just speculating it looks as if it wouldn't know a function from a type declaration until it hits a semicolon before a set of parentheses. That's why it made me wonder why Go would need the reserved words for func and var.
[removed]
Plus the ssh config file works with all ssh-based tools, so you get scp, remote editing with your ssh-aware editor, and this integrates cleanly with ssh abilities like sshing from one server into another in one shot without any of the programs using ssh having to be aware of the complicated things happening in the connection... great stuff.
IMHO they should either just adopt Dave Cheney's errors package ([https://github.com/pkg/errors](https://github.com/pkg/errors)) into the standard library or leave it as it is becoming the de-facto standard. &amp;#x200B; There parallel hackernews thread that you guys might find interesting too: [https://news.ycombinator.com/item?id=19778097](https://news.ycombinator.com/item?id=19778097)
You know how go fetches packages from Github and other repository hosts rather than from a single centralized server like many other package managers? A checksum database stores a kind of authenticity stamp of the available versions of every package, regardless where they are. (More precisely, it stores the content hash of fetched versions.) This allows you to continue using whatever third-party repo to download packages, but provides a secondary verification that the package source you retrieved is what you requested. That is, in order for someone to sneakily change the package from under you without you noticing, they used to only need to take control of the package repository. Now they also need to take control of the checksum database. More security!
Centralization, ah, that's the beginning. Used to be much better before.
\+1 for ssh config. Perfect for all my per machine configs including ability to vary username and keys by server as well as configure tunnels.
It's a yes, but it's also a yes for every single language you would be likely to ask about, so that's why you're getting answers that might seem to be chomping at the bit to answer more detailed questions. The hard part about writing a website is that there are so many different things involved in it. For something this simple, however, it's possible to accomplish it with most choices, so the best bet is to start writing code with whatever you're most comfortable using. :)
That is one simple way to go about it. Source files in the same package will share that same reference to the global Queue. And packages importing this one can access it as a public exported variable. However it isn't the most extensible way. It might be better for your to have a Queue context that gets created and passed around as a dependency, as opposed to having a single shared queue for the whole system.
An index is just an append only log in the category of decentralized package managers, what's the problem?
&gt; Gather around kids. I remember back in the day, before Go 3 was out, you used to be able to import packages from anywhere in the web! _Even without a Google account!_
&gt; **I removed a bad release from my repository but it still appears in the mirror, what should I do?** &gt; &gt;Whenever possible, the mirror aims to cache content in order to avoid breaking builds for people that depend on your package, so this bad release may still be available in the mirror even if it is not available at the origin. The same situation applies if you delete your entire repository. We suggest creating a new version and encouraging people to use that one instead. That doesn’t seem adequate to deal with the hacked popular package problem. There needs to be a way of blacklisting a known evil version.
There is nothing stopping other companies from hosting their own, and in fact that will make everyone safer. You could imagine Amazon, SourceGraph, maybe even GitHub itself hosting these.
Will this be open-sourced? It would be nice to host your own private mirror to avoid getting left-padded.
What is mu.Lock() defer mu.Lock() supposed to do?
&gt;defer mu.Lock() It should be defer \`mu.Unlock()\`. fixed
Yep. Ssh config file is a recently discovered God send for me.
Thanx pal
cool projects! we are using [https://github.com/syllabix/versioner](https://github.com/syllabix/versioner) at work to automate semver bumps in git versioned projects with everyone using conventional commit messages.
I just made some changes, it's `daemon` + `cli` architecture now, and it only manage jobs created by `px`
I wonder if it would be possible to re-implement that but using IPFS for both the module mirror, the index and the checksum database. Since it's content-addressed…
In your Go Configuration, did you try using the **Use Language Server** option? This should use gopls and possible (crossing fingers) solve all your issues. It did for me, and even solved my Go Modules issues. I think it's worth a try for you.
Try to use the native Go extension from Microsoft (yes, from Microsoft). It does autocomplete and a lot more
What are you talking about? You will still be able to pull dependencies directly from it's source without using a proxy. Additionally you can even use a different proxy if you don't like Google.
 go get -u &amp;&amp; go mod tidy go get: upgrading github.com/ugorji/go/codec@v0.0.0-20181204163529-d75b2dcb6bc8: unexpected status (https://proxy.golang.org/github.com/ugorji/go/codec/@v/list): 404 Not Found Darn, this proxy breaks on this package too. I was hoping it'd work. goproxy.io breaks (and generally doesn't work all that well), Athens works fine but is super slow.
[http://staticcheck.io/docs/checks#SA2003](http://staticcheck.io/docs/checks#SA2003)
Those "panics" due to detected deadlocks aren't panics, they're fatal errors. You cannot recover from them, unlike panics. &amp;#x200B; Also it is my opinion that any quiz where a possible option is "doesn't compile" sucks. I'm not a compiler, and I'm not gonna go through code looking for every possible syntax or type error.
What's the actual problem you're facing? Any program that imports queueTest would have access to the Queue variable through queueTest.Queue.
Instead of `var geocode map[string]interface{}` use this: https://pastebin.com/raw/wRsvBn2w I got this struct by copy and pasting the entire JSON here: https://mholt.github.io/json-to-go/ Then, you can print with: `fmt.Println(geocode.Results[0].Geometry.Location)`
You might want to re-read the parent comment :). He cant share his excitement with *loved ones who have no idea what a checksum database is*. He knows
You don't even need the whole structure, only the parts you are interested in. This makes it easier to see which parts you are interested in. Also, Gos JSON decoder will ignore elements not defined in the structure meaning it does not need to spend CPU cycles decoding parts you are not going to use. Though this won't make any difference for most applications.
Let me know if you see thinks that look awkward :) I'm still trying to improve it!
It depends on what you're doing. Networking from a browser is pretty restricted: you are limited to HTTP requests (and websockets, but that's still part of HTTP). So I imagine if you tried to, for example, open a raw TCP/UDP socket with the `net` package it would fail with a "not implemented" error similar to what we saw here. However, there is definitely a way you could make Go bindings for the JavaScript `fetch` API and send packets via a WebSocket. But that would require either some intermediary server to handle the WS&lt;-&gt;TCP translation or for the server to understand WebSocket natively. Both would require more significant overhead than just a raw socket, though. I guess we'll see where it leads as wasm matures!
Did you try adding an explicit length header? I guess there is a change in behavior between known and unknown sizes...
If memory will become an issue (when the logs grow to ex: 1m+ lines) try appending the logs to a file. You could group the hashes in separate files to avoid having to read the whole file when looking for a log. You could also take a look on how databases store stuff or maybe use a database like SQLite to store the logs.
https://github.com/golang/go/wiki/gopls
But it’s slow AF
You can use Golang for the experience of it, but a better approach would be to use a remote execution tool like Ansible or Salt.
Honestly, it's good that this explanation is added. I asked my colleagues, no body seems to know including me. So, it kind of helped a random soul.
Thanks for the thought - i just checked the response header and the app is setting content-length automatically (I tried setting it manually just now in the app, but it made no difference)
Ah, but that means that it first caches the complete response... Maybe you could enforce chunked encoding...
Compress the executable with UPX and you can create &lt;10M docker images from Go executables that are around 24M before compressing.
Any chance you have exec, the binary file of Pdfunite or link to download? Would be great to save it within the project..
That's C++ crazyness though. It's not as difficult in C. You basically just have to keep a symbol table with you as you parse the code.
(Assuming I understand your point correctly here) would that make any difference, given that the app serves large static files without a problem?
Cool. Hopefully it will make more sense to potential users as an option.
What’s the advantage of this over just using a lock file? It seems all disadvantage.
I read that dgraph does not support cypher and that can be a problem for me because I already built the project in spring boot but I want to move it to GO for some reasons. So I want to keep the same database I was using before.
checkout [athens](https://github.com/gomods/athens)
[Please don't use global variables](https://peter.bourgon.org/blog/2017/06/09/theory-of-modern-go.html). They make your code harder to understand, harder to test, and harder to maintain. Packages should store type declarations, and only those types should store state. Rather than package queuewhatever var Queue = queue.New() // used like // queuewhatever.Queue.Method() Prefer package queuewhatever type Thing struct { q *queue.Queue } // used like // t := queuewhatever.NewThing() // t.Method()
Looks like all effort was spent on creating those images instead of the actual content. This article has no meaning content at all. It's just blogspam. It pretty much admits as much in the "author" section: &gt; Hi, I'm Shivani from Cyber Infrastructure. A versatile content marketer, I have 5+ Years of experience in researching and creating unique and interesting content for many areas like technology, lifestyle, e-commerce, travel, health care, education, and more. Yeah...
I'm not sure what lidx and uidx are supposed to be? I presume one is the start index and one is the end? But I can't map that to L and U.
If I understood, you want the Reslice() function to receive a slice, a lowe index, and an upper index, and return a slice of the input slice starting from l-index and finish with u-index func Reslice(slc \[\]byte, lidx int, uidx int) \[\]byte { var s \[\]byte = slc\[lidx:uidx\] return s } This will do the trick if this is what you need
The details on Go Slices is all here: https://gobyexample.com/slices
Thanks, this tool is awesome. Is it the case that in Go you have to build a struct to describe the entire JSON, even when you only need a portion? I'm migrating my project from Python, where I could get away with just returning resp.json()\["results"\]\[0\]\["geometry"\]\["location"\]. I get that in Python, requests is handling loading the entire json into a dict for me to use, but there I don't have to predefine the output, especially for the parts I'm not interested in.
thank you so much, have been stuck there for some hours. really appriciate it :)
its upper index and lower index
;)
Thank you for the site, I can understand it much better than trying to read the blog. appriciate it :)
Couldn't agree more.
Thank you, I have been able to do that but I still have an issue with a dependency of the lib, &amp;#x200B; `../github.com/neo4j-drivers/gobolt/config.go:116:26: could not determine kind of name for C.BOLT_SCHEME_DIRECT` `../github.com/neo4j-drivers/gobolt/config.go:121:10: could not determine kind of name for C.BOLT_SCHEME_NEO4J` `../github.com/neo4j-drivers/gobolt/config.go:118:10: could not determine kind of name for C.BOLT_SCHEME_ROUTING` `../github.com/neo4j-drivers/gobolt/config.go:101:2: could not determine kind of name for C.BoltConfig_set_scheme` `../github.com/neo4j-drivers/gobolt/config.go:115:27: could not determine kind of name for C.BoltScheme` &amp;#x200B; Thank you for your help so far
Ha, I swear I read it like 3 times too! Oh well, glad it was helpful for some people.
What are you using to load test the Application? If each request comes in on a new session, setting up SSL connections is very expensive compared to just the TCP session with HTTP. If you try multiple requests inside the same SSL session you will find the rates will probably be very similar.
Can't really reproduce it with your test case – I get about 1300 requests per second on both static and dynamic content, go 1.12, Linux.
Also, [SliceTricks](https://github.com/golang/go/wiki/SliceTricks) is useful for some advanced techniques.
I reproduced using Go 1.12.1 on Windows and Go 1.12.4. The really strange thing seems that the time is spent in the handshake (which MUST be independent of the content / URL...). &amp;#x200B; The border that you are hitting is probably the \` bufferBeforeChunkingSize\` i.e. 2048k. There seems to be some pool of 2k and 4k bufio readers for caching. I can only assume that's where the issue lies... But really I think you should post this in the issue tracker of Go (and maybe stackoverflow). &amp;#x200B; On a more practical note: Do you really need the Go app to handle https? I always use something like Nginx or Caddy for this...
answering the question about web frameworks for those wondering: stdlib
There is nothing wrong with using port 8080, you should have an elb in front of it and that will handle 80→8080 for you
answering the question about web frameworks for those wondering: stdlib
Update: I've tried load testing my app using 'hey' ([https://github.com/rakyll/hey](https://github.com/rakyll/hey)) instead of Apache ab, and the app then works as expected, without slowing down on pages that are &gt; 2Kb. &amp;#x200B; So it seems there is some sort of negative interaction between Apache ab and Go net/http, but only on dynamic files &gt; 2Kb.
I was using Apache ab, although see my update post, using different load testing software produced different results.
Interesting - and that is using Apache ab to load test? I have just tried using [https://github.com/rakyll/hey](https://github.com/rakyll/hey) and that works OK, so the problem seems to be some strange interaction between ab and net/http...
"ApacheBench 2.3" built from httpd 2.4.39 sources. With hey I get about 12000 requests per seconds for both. Really looks like ab is doing something weird here.
are you using go modules?
It's got way too many dependencies, and it's actually part of poppler-utils. You could try having your app run inside Docker or something to make sure it's installed, or try to resolve the friends yourself. I use arch, so I personally would grab the tarxz files from the arch package archive, but there might be a better way.
Maybe you needed to be clearer about what the part was you didn't understand, then. You can distribute the binaries, but if you want access to a convenient download server that will customize them, you have to pay for server access. I don't see what's hard to understand.
I think this can be accomplished by having a single go routine running a struct method, and that struct contains a lock object that has to be acquired before it’s methods can be executed. I had a similar problem recently, I am on mobile and will post more details in a couple of hours.
Thanks for the suggestion, it's almost done already [https://github.com/superoo7/go-gecko/pull/8](https://github.com/superoo7/go-gecko/pull/8)
The article title is: How To Format Strings in Go
Using time.Sleep to control concurrency pattern is a very bad idea and may even be wrong. time.Sleep only ensures that something is happened after sleep, but not immediately after that and lack of time.Sleep does not ensure it will happen immediately either. In particular, in quiz 3: var wg sync.WaitGroup wg.Add(1) go func() { time.Sleep(time.Millisecond) wg.Done() wg.Add(1) }() wg.Wait() There are three ways things can happen based on how the scheduler work (which is not in the language spec and mostly considered an implementation detail): Deadlock, panic because of misuse of WaitGroup, and exit normally. Probably Official Go and other sensible Go compiler will have a constant panic here, but as a quiz, I think this is a bit misleading.
What you're looking for is `runtime.LockOSThread()` this will force the goroutine to stay on a single OS thread https://golang.org/pkg/runtime/#LockOSThread. As for the same goroutine being used each time. I would have it setup to feed the goroutine work via a channel. That way your wrapper would pass work off to the goroutine that is locked to the OS thread.
NICE! I just kind of learned about the elastic load balancer last night but totally didn’t know that was an option. Thanks tons!
On the code style. We use hooks to run linting before each commit to prevent commits with wrong code style. No need for alerts
If you are using aws take some time to learn the basic services. The time will pay for itself quickly. And thanks for the gold, first time for me
So you are changing developer code without their knowledge?
It likely just rejects the commit with a warning, not necessarily altering code. Basically "Hey, we rejected this commit because you're putting open brackets on the function declaration line, pls fix."
I am not sure I fullly understand the problem but I think this provides a similar design: [https://godoc.org/github.com/faiface/mainthread](https://godoc.org/github.com/faiface/mainthread)
Downgrade the VS Code extension to v0.9.2. Reference issue: https://github.com/Microsoft/vscode-go/issues/2469
Yeah handling JSON in Go does feel a little more awkward particularly when coming from a dynamic language. I came from Ruby to Go and in Ruby the model very much was to chuck all the JSON through a parser to get back a map/dict and then grab from there what you want; whereas in Go as you've found - it is possible to do that with a `map[string]interface{}` type, but you'll lose all the benefits of Go's type safety; so a more idomatic approach would be as stated above to define a nested struct containing the specific properties you are interested in, use this to parse and then when you use the data no need to type assert Note you may have to be a little careful if the length of the `Results` array could be 0, as if you try to use: `geocode.Results[0].Geometry.Location`, without checking if `geocode.Results[0] == nil` you might get a `panic`.
To aid mobile users, I'll link small subreddits not yet linked in the comments /r/GolangJobOfferings: A curated job subreddit for all the latest Golang offerings! --- ^I ^am ^a ^bot ^| [^Mail ^BotOwner](http://reddit.com/message/compose/?to=DarkMio&amp;subject=SmallSubBot%20Report) ^| ^To ^aid ^mobile ^users, ^I'll ^link ^small ^subreddits ^not ^yet ^linked ^in ^the ^comments ^| ^[Code](https://github.com/DarkMio/Massdrop-Reddit-Bot) ^| [^Ban](https://www.reddit.com/message/compose/?to=SmallSubBot&amp;subject=SmallSubBot%20Report&amp;message=ban%20/r/Subreddit) ^- [^Help](https://www.reddit.com/r/MassdropBot/wiki/index#wiki_banning_a_bot)
This ^^ The language server really helps out with auto complete. The go tools need to be compiled and configured correctly too, but VSCode seems to do that properly itself in my experience.
All I have to say is: stop importing stupid OOP patterns from Java to Go
Cool, thank you for confirming. I'll be sure to add an empty array check.
DI is apparently a valid need, google built [wire](https://blog.golang.org/wire) because of this need. I would also agree that run-time DI is a bad practice since it compromises your applications stability. &gt; The issue with factories is that the caller of createThing also needs a reference to runtimeDependency. This means that if the caller is not the owner of runtimeDependency, then it also needs a factory to combine its injected dependencies, one of which is ThingFactory, with the run-time information. I really like passing dependencies manually on initialization though. I really believe the parent often _should_ be passing "runtimeDependency" since it has a "bigger" picture of the environment than "Thing" does. Thing can't/shouldn't know what `cmd/*` was called or if we are in testing/stage/production. I guess you could argue that is what the DI configuration is for since perhaps neither should know/care about the environment, but I'm just not sure yet. I suppose it will be more clear if I ever work on a large codebase.
A go.sum file \*is\* the lock file. the go.sum file is the checksum file. A checksum database protects a user of first use/download of a dependency to ensure that the version-hash pair they got matches the version-hash pair everyone else and the independent server got. And the server can be audited as well.
Use a named interface and pass the “work” as a struct down a buffered channel. I am curious as to why OP would want such a pattern tho.
Do you really need the code to run in the same thread always? It seems like a code smell initially. What are you trying to do?
[github.com/ugorji/go/codec](https://github.com/ugorji/go/codec) is not a module from Go command's perspective. Seems like it was broken from the beginning and the owner of package fixed its module configuration and deleted problematic go.mod. None of the proxies (the module mirror, athens, or [goproxy.io](https://goproxy.io)) will not make up any modules that never existed or existed but disappeared before the proxies were launched.
I gave the language server a try, but found that it only worked for packages in the std lib. Gocode still works much better for me.
No, I am in my GOPATH.
&gt;Go Configuration Use Language Server is enabled, I looked at the output terminal on VS Code and I get this gopls error. &amp;#x200B; Request textDocument/completion failed. Message: no file information for file:///c:/Users.... &amp;#x200B; The file it is referring to is the file I am currently in.
There are plenty of hardware things that require the use of a specific thread. I've worked with versions of OpenGL that required certain API calls to always originate from the same thread, for example.
[removed]
[removed]
I don't understand why you need to be so dismissive... I don't even depend on this package, nor do any of my other dependencies, and `go mod why -m` doesn't say I need it either. It's just showing up in the process of doing updates (so someone probably used it at some point) and breaks my use of any proxy, much like the annoyance that is `github.com/golang/lint`. (goproxy.io doesn't seem to host updates regardless of this issue; `go get -u &amp;&amp; go mod tidy` always nets no changes when I use it)
[removed]
I was able to get help, you can check it out on this [link](https://github.com/neo4j/neo4j-go-driver/issues/56)
DI is probably the single most useful architectural pattern for large app development, even without a DI container. It's almost functional in it's approach, and makes your objects easily testable. That said, it means you have to do a potential load of initialization outside of every object, meaning you end up bucket brigading args through a hierarchy. This might be fine for smaller apps, but doesn't scale nicely to large hierarchies. So, we end up with DI containers or compile time libs to manage object lifecycles and interdependencies. &amp;#x200B; When done right, DI libs are anti-boilerplate. They are always pro-testing. I can't really knock either of these things.
Thanks for the suggestion! V0.9.2 didn't work for me but V0.9.1 did. Now I just hope it works with modules.
In the issue I referenced, there is now a beta version of the extension that fixes the regression. You may want to try that as well if 0.9x doesn’t work as well with modules (my co hasn’t transitioned yet, so I don’t know).
In the issue I referenced, there is now a beta version of the extension that fixes the regression. You may want to try that as well if 0.9x doesn’t work as well with modules (my co hasn’t transitioned yet, so I don’t know).
Yes I might post the issue on the Go issue tracker - I think part of the problem is Apache ab (see below, r.e. things working as expected using [https://github.com/rakyll/hey](https://github.com/rakyll/hey) ), although I think the problem can't \*just\* be in ab...
It's a pre-commit hook. And yes if the linting fails the commit does not go through and presents the user with an error indicating where the linting failed.
This smells a lot like a transport layer issue. Probably requires some tuning of your network stack and/or NIC driver. No idea how to approach this on Mac tho, I'm a Linux nerd...
Has anyone measured overhead of adding Frame to every error created? In the proposal they say it is a thing but it doesnt bother them
yea I was going to suggest the same thing and for something with lower overhead, Python Fabric is very good too.
Semaphor is just a mutex
This question has nothing to do with Go (the language). You should read up on [OpenCV](https://opencv.org/), there are bindings for any language.
[removed]
&gt; Is it the case that in Go you have to build a struct to describe the entire JSON No, the default behavior of encoding/json is to ignore JSON object keys not present in the Go struct.
[removed]
I’m not sure what you’re asking.
I can’t understand, why go libs for ML and NN tasks are so tiny and not popular. My tests (regressions, classifications) show amazing speed and results, like sklearn, for example.
This is great advice. Thank you for pointing this out. (this also led me to realize that `git-name` is probably a more convenient naming convention for folks anyway)
Just to be clear, are you talking about machine learning? Because this is a subreddit about a programming language, and saying ML in the context of programming languages is different.
Thank you for pointing this out! I think i'm done adding features for now and am working on refactoring/rethinking some of this. Do you have any good examples/tips as alternatives? Is the conventional approach to put everything on its own line, instead of chaining?
Yes, you’re right. But this is subreddit about a golang. And I’m asking about Machine learning in the context of golang :)
Gotcha. Can you clarify that in the post? Because I was confused and I don’t think I will be the only one.
Gotcha. Can you clarify that in the post? Because I was confused and I don’t think I will be the only one.
Okey. Thank you! :)
Filed a bug [https://golang.org/issue/31766](https://golang.org/issue/31766) This seems to be a problem with how the go command handles disappeared module when using a proxy. &amp;#x200B; Sorry if my comment sounded dismissive. I didn't mean it. :-)
[https://www.reddit.com/r/golang/comments/91rvzj/wire\_a\_di\_container\_from\_google/](https://www.reddit.com/r/golang/comments/91rvzj/wire_a_di_container_from_google/) [https://www.reddit.com/r/golang/comments/bajzxg/go\_dependency\_injection\_with\_wire/](https://www.reddit.com/r/golang/comments/bajzxg/go_dependency_injection_with_wire/) [https://www.reddit.com/r/golang/comments/9mqctx/compiletime\_dependency\_injection\_with\_go\_clouds/](https://www.reddit.com/r/golang/comments/9mqctx/compiletime_dependency_injection_with_go_clouds/) &amp;#x200B; Previous discussions regarding the value of DI. I personally agree with @peterbourgon do not see the value in automated DI, I've never found manual dependency injection to introduce enough friction.
Google builds a lot of things, just because they built it doesn't mean it's a valid need. &amp;#x200B; Previous discussion at [https://www.reddit.com/r/golang/comments/9mqctx/compiletime\_dependency\_injection\_with\_go\_clouds/](https://www.reddit.com/r/golang/comments/9mqctx/compiletime_dependency_injection_with_go_clouds/)
It is going to take a while to shift the whole industry. Besides, C/C++ based networks with GPU interfaces are faster.
Thank you for your opinion :)
The short form is that any language other than Python is going to be an also-ran for ML because Python is the language that's gained traction among data scientists. The dynamic, flexible nature of the language -- combined with tools like Jupyter make for an unmatched workflow when working on defining and validating a model. Execution of the model tends to be a secondary concern given the complex, iterative workflow needed to get a model developed and trained properly.
Thank you for your answer!
why would runtime DI in a statically compiled language compromise stability? The chance of the incorrect implementation or something else?
hides import JSON / YAML to interface{} (joking, but maybe not)
There's magic unix flags that are thread specific.
Just because it's statically compiled doesn't mean you can't mess-up runtime types: https://play.golang.org/p/tcKdk43QrRm
True, and i know there are situation where what op asked for is needed. Just wanting to make sure that op doesn't need a mutex, or some first class concurrency primitive or pattern.
Word Soup.
What about Echo?
I find DI to be in direct contradiction to ideas such as low coupling, high cohesion and encapsulation. It constantly leaks as far as I’m concerned. The argument that it makes it more “testable” has always been a poor one in my book. If testing can’t handle good programming practices then testing needs to change, not the other way around. I do think that go could use some improvements in the testing department, but not in the form of exposing everything further. Then again I also think that genetics are a terrible idea and exceptions far worse than goto, so I’m well aware that my opinions aren’t always welcome:) I had higher hopes for go though, as it seems to be a language where long term thinking prevails rather than flavor of the year. Java/JavaScript/Ruby/etc already exists for those that want all that noise. Go should be designed to survive as long as C will.
For the record, we ended up going with Casbin. I was wrong about the difficulty. Once I made a few simple test programs I realized I was overthinking the whole thing. The policies were actually really easy to write. Also when you use the Casbin role manager to open up greater hierarchy depths, it's very powerful. I've already developed a little storage library to use with our GraphQL-Hasura backend. We have this whole infrastructure stack we're building for easier micro-service development in the future. It was time for a true API instead of a collection of apps.
There's a fairly large machine learning library in pure Go: https://github.com/gorgonia/gorgonia The author (/u/chewxy) fairly regularly hangs around this sub too
Thank you!
Right. I intend to set one up at work so that I can stop bloating my internal repos with `vendor/`. If we have a proxy the whole company can use then we can stop copying the same vendored code into many repos: CI can just pull the code from the proxy.
While this may be technically possible, perhaps you should re-evaluate whether Go is the right tool for this. Sounds like Rust or C++ (or plain C) might be the better option if you need that level of control over OS-level threads.
I set up a simple instance at work a few weeks back, speeds up dockerized builds so much. Great stuff!
Ah yes. GUI stuff always needs that. I know iOS has a mainthread more or less dedicated to graphics. That makes more sense.
Cache the client
Help build one! [Gorgonia](https://gorgonia.org/gorgonia) is a suite of libraries that are competitive with Tensorflow and PyTorch. I use it in production and have deployed quite a lot of deep nets over the years in it. Now I want to address "unpopular". I have sat down and analyzed why Gorgonia didn't quite take off the way TF or PT did. I came to a conclusion: API friendliness. Gorgonia, like Gonum is quite low level. That stems largely from my understanding of software engineering: you want a neural network, just write an additional library in your local application. That way you can write a NN that is highly customized in performance to your program.' Unfortunately that does not help with improving the popularity of the library. More of the heavy lifting needs to be done by having even higher level APIs. So far, there has been some work done by Olivier W and Nabil S on that. But you can help too! You are correct that Go is seemingly amazing for ML. So let's make it happen!
I just gave an answer above too. Thanks :)
Thanks for this!
You don't need tensorflow. You need a thorough understanding of your problem, which I suspect you may not have. Scanning of barcodes and cards are easy. The process goes like this: 1. Grab input image from camera 2. Preprocess the image (usually B&amp;W, some sobel and edge finding) 3. Make it a matrix of floats 4. Run some simple logistic regression over it. Bar codes - there exist libraries for it. The rest are plumbing
The majority of memory use is from `ioutil.ReadAll`, that has nothing to do with the `http.Client`. (protip: you don't need the `if resp != nil` check) If memory use continues to climb, check the stack trace for leaking goroutines.
That example doesn't show the type system fall apart
Are your .go files in a 'src' folder under your GOPATH ?
Something seems to be missing, these values don't add up for me. You should only be using 1.5MB after 5 minutes of run time for actual message bodies (plus overhead for structs/JSON, HTTP client instances, net.Conn, etc...) ``` ("couple o minutes" * 60 sec) * (time.Sleep(time.Second) * 5k) != 600MB ```
Correct, it shows _you messing up runtime types_ because there was no compiler to warn you.
The client is only 32 bytes and quickly GC'ed. All the work is done by the transport, and this is re-using the default transport.
You gotta work on your variable naming ...
\&gt; I find DI to be in direct contradiction to ideas such as low coupling, high cohesion and encapsulation. It constantly leaks as far as I’m concerned. Coupling: DI does not add or remove cross-module dependencies from your class. It just hoists them into a parameter. It may actually reduce coupling, as you don't worry about how to build a instance of Foo within your class, which means that your class doesn't transitively touch Foo's construction dependencies. &amp;#x200B; Cohesion: Do the individual components and concepts that comprise your class belong together? That depends entirely on how you wrote the class. Hoisting dependencies into args actually removes dependency instantiation as a concern for the class, potentially increasing cohesion. &amp;#x200B; Encapsulation: Yes, DI intentionally reduces encapsulation. You advertise your class's needs upwards, turning instantiation into a dependency graph that can be recursively resolved, and you pull them from the world. That's why I mentioned DI being "almost functional in its approach". It's also declarative when used with a container, sort of like using a service locator, except without the antipattern of passing a service locator to every. single. constructor. &amp;#x200B; \&gt; The argument that it makes it more “testable” has always been a poor one in my book. If testing can’t handle good programming practices then testing needs to change, not the other way around. &amp;#x200B; Do you not like unit testing? I've found no better way to make a class unit testable than DI. Everything else is a hell of one-off mocks for object internals. I don't know how you're going to "make testing change" that. Is testing altering our architecture an instance of the tail wagging the dog? It most certainly is, but I think the final product is better. If you have some magic pattern that makes unit testing easy without DI, then, for the love of god, please share it! &amp;#x200B; \&gt; generics &amp;#x200B; They are horribly complicated, and I am willing to pay that cost since it allows me to express things without runtime performance or type safety penalties. Hell, I might start writing business logic in Go if we get generics. Would be nice to have the non-generics stdlib around forever, and continuously updated, though. You often do not need a gun that big. A footgun that big? &amp;#x200B; \&gt; exceptions &amp;#x200B; They are conceptually easy. They map most closely to the error handling that I usually want to perform - start a macro-operation that consists of a bunch of steps that might fail, deal with failures at the top and retry or fail the macro-op. THEY SAVE ME FROM HAVING TO WRITE AN IF BRANCH EVERY TIME I RUN A METHOD. EVERY TIME I RUN A METHOD! They are potentially slow. They are potentially dangerous and non-intuitive when you don't have a GC. Go has one, though, so I am in favor. &amp;#x200B; \&gt; flavor of the year &amp;#x200B; These things have been available in mainstream languages for like 25 years.
It probably does support views already - if you create the view in the database, the library will probably treat it just like a table.
The first rule of http benchmarking is "don't use ab". It's old, http/1.0, and just no longer up for the task. You have to make sure you're the client is able to stress the server, and not the other way around.
Not *genetics*, but *generics*. As for the rest: opinions differ, like all the time. There's never 100% consensus on anything. I mean, people actively use 1-index based programming languages (LUA), and it's a valid choice which we probablly both disagree with. As for generics or atleast steps towards making Go a little bit friendlier for programmers in general, my preferences would be along these lines: - overloading functions I'm not advocating for sum types here, but that's just my particular experience, I find that to be a perverted edge case - I find that `interface{}` isn't being used very often if you cancel out `json.Marshal` and I have some large codebases in my past. We could dig down and find cases where it does make sense to have sum types, but you're going to have more cases for declaring `Access(context.Context, *request.AccessRequest)` (our own service layer) or `Access(w http.ResponseWriter, w *http.Request)` (direct http layer). - constructors for structs to define a non-zero value default type I'm pretty sure these are valid choices. When you (or particularly the OP of this comment thread) bring prejudice from other languages into the discussion about DI/generics, people usually miss the distinction that DI in Go would be a different beast. The consensus has always been that we're trying to solve our very real pain points, and not just implement everything that C++ or Java have in terms of OOP. That doesn't mean that some things can't be adjusted to the Go way, where that may make sense. Sorry I went off a bit there, my point was just to advocate incremental enhancement towards something we might call DI, or OOP, or generics, which doesn't particularly have to have roots in any existing programming language, but actively tries to pinpoint code smells in current Go code bases (ie, type assertions/switches, conditional casting, even reflection if we consider codegangsta/inject as something we'd like to discourage). We should consider these work-arounds as the experience reports to evaluate and come up with suggestions that make sense. For example, I would very much like to type assert/switch a function that is declared on a struct, but I have to first assign it to an interface{}. Could anything be `x.(type)`-d? I the type assertion should work even on concrete types, not just an interface{}.
By lock I mean that no enqueue/dequeue operations would be allowed. Enqueue() and Dequeue() will return error when the queue is locked.
Can we please get a plaque with this put on the subreddit's wall? There are so many Go developers who refuse to use vindicated patterns just because they think it's "Java style".
[removed]
After read twice your question I think that would be better to replace "lock" by "block" (Queue.Lock() by Queue.Block()). What it really does is: block the enqueue/dequeue operations.
There's nothing inherently wrong with chaining as long as the line doesn't get to long and it's clear to the reader as to what's going on. You can break the chain into multiple lines (the dot goes at the end of the line that is being continued); but I don't know if it makes things any clearer, it's a bit of personal preference. If you decide to stick to the fluent style then you can incorporate error handling like this: [Errors are values](https://blog.golang.org/errors-are-values). It's idiomatic Go to see lots of error checking blocks: ``` foo, err := bar.Foo() if err != nil { return } ``` It can be quite jarring to Go beginners (especially to experienced devs) but I've found that I've gotten used to it. It's a big talking point when discussing (the mythical) Go v2.0. And there's some additions coming to the errors package (see [golang.org/x/xerrors](https://godoc.org/golang.org/x/xerrors)) that should make things easier.
Personally I can't get vscode to properlt. Whether the project is using modules or plain gopath something always ends up breaking. I'm currently using Goland (everything works) until vscode gets its shit together.
I agree and disagree with this. I understand where the "no java!" faction is coming from, but there are definitely useful patterns out there. Java's general enterprise bloatiness, especially with the mass amount of factories and multi-line inits, lends itself especially well to benefiting from DI containers. This is less useful for a lot of what Go is used to write. That said, writing stuff like a http handler with a DI framework is generally w o n d e r f u l. I imagine passing context around to every single function call would be an obvious benefit, assuming there was support for properly scoped instances. Then again, context objects probably wouldn't be necessary at all in the presence of a good DI implementation.
`return ioutil.ReadAll(resp.Body)` too
Thanks for your detailed response, wow, I need to work on this... Could you please tell me how would you parse this response? *EUR-USD* should be a dynamic market type, we don't know upfront what comes in as a parameter to the function. { "EUR-USD": { "baseCurrency": "EUR", "quoteCurrency": "USD", "lastPrice": "0", "bid": "0.0001", "ask": "10", "baseVolume": "0", "quoteVolume": "0", "dayLow": "0", "dayHigh": "0", "growthDiff": "0", "growthRatio": "0" } }
Does your system process list report the same memory usage (~660mb for the process?). Reading about it, `alloc_space` tells you all the memory allocated from the program start, which doesn't mean that it wasn't freed immediately. You should be using `inuse_space`, I believe.
 type Currency map[string]CurrencyDetails { type CurrencyDetails struct { BaseCurrency string `json:"baseCurrency"` QuoteCurrency string `json:"quoteCurrency"` LastPrice string `json:"lastPrice"` Bid string `json:"bid"` Ask string `json:"ask"` BaseVolume string `json:"baseVolume"` QuoteVolume string `json:"quoteVolume"` DayLow string `json:"dayLow"` DayHigh string `json:"dayHigh"` GrowthDiff string `json:"growthDiff"` GrowthRatio string `json:"growthRatio"` } Unfortunately, because the numbers are between quotes, you cannot use data types like `int` or `float`, but you could try to use `json.Number` instead, for example, but you need to test to make sure it works the same way as `string` in this case.
Checkout what gitlab is offering. I hadn’t even thought about them for the last 5 years and was surprised when someone told me about what they are doing for ci/cd using just the stuff built into the platform. ✅ static analysis ✅ build and deployment tools ✅ project management You can do pretty much everything in one place. https://about.gitlab.com
DI at runtime would possibly surface type errors, null pointers, and getting the wrong instance of an object, depending on implementation. Compile time DI frameworks would only surface the wrong instance issue, in theory. Missing dependencies or type errors should be caught during either codegen or compile.
Yeah, a DI container is just a spicy hash table, and DI-the-concept is just passing stuff in (not even spicy).
I'm always in a battle at work to convince people to use DI for the HTTP handlers. And I don't mean DI containers, I mean just a parameter in `New` or a factory function in the first place. It's excruciating. I agree it might not make sense to use enterprise patterns when making something low level for the OS which Go is often used for, but there are times when DI patterns, whether ror not you use containers, are good. And I think web development is one of those times.
Yeah, it's really good when you have a megamorphic dispatch point that the application funnels through...which actually happens constantly. Like any time you are writing a bunch of handlers, whatever it is they may be handling. It's even more useful in the context of a framework that does such diapatch into the framework consumer's code.
Thanks!
Thank you for doing this work. I was looking for this kind of approach for quite some time. I must say that I really like the website and documentation. It took me almost no time to get the basic idea and to start experimenting. I will try Wails for a simpler project and give my feedback. Looks promising!
In https://github.com/mdlayher/netlink, we use a vaguely similar construct, namely [`lockedNetNSGoroutine`](https://github.com/mdlayher/netlink/blob/master/conn_linux.go#L577). Note that this probably differs slightly from your requirements, since we do not need such calls to nest. In order to return values, we make use of closures, [like so](https://github.com/mdlayher/netlink/blob/master/conn_linux.go#L412-L423).
Thanks for the positive feedback! I'm really glad it might help you.
I was doing this for a while when I first got into go. At some point I realized it was ok not to and it felt like I had been wearing hand cuffs and they were just taken off. Really enjoying programming in go.
how big is a typical binary? and what are the rough edges?
“spicy hash map” 😂 so true
How does the rendering work? Also how's the performance? Curious of the memory footprint and cpu usage (looking at you eletron)
Yep my thoughts exactly
Will people think I'm a Ruby developer with a speech impediment?
Controlling threads is not a low level concept really, unless Python/C#/Java etc are lower level than Go (which they are not).
This is neat and weird. Can you explain more about the bind function and what types can be returned by the bound functions? Can I return errors? Multiple results?
Is this built on the webview-x branch? For folks wondering about the comparison with Electron, the readme says that Wails uses [Webview](https://github.com/zserge/webview), which is _good_ because it means that it doesn't package its own renderer (e.g. Chromium), so the binaries should be of reasonable sizes. The bad news is that, unlike Electron, this doesn't include other desktop GUI niceties like menus. I ask about webview-x because webview is undergoing a big rewrite which will allow the use of EdgeHTML (which I assume is Chromium nowish?) instead of MSHTML (Internet Explorer!) on Windows. This is a _hugely_ important difference because I, for one, would not want to have to ensure that my desktop app UI works on IE. That's one of the big things that has made Electron so powerful.
This is pretty awesome. Good to see this not bundling a browser like electron. A big fan of zserge’s thinking with webview and lorca. That said, Lorca seems to accomplish much of the same here. Why use this over Lorca? I don’t like pulling in cgo where avoidable, as it keep cross compiling simple
I'm not that familiar with any DI frameworks myself, but at work we had a big java app where runtime DI created very long startup times and ended up contributing to an outage (among many other causes). This is particularly bad for Java since the DI system touched many classes briefly and put a lot of pressure on the JVM internals before the app actually starts. Presumably a Go app would handle this a little better.
Thanks, it's good to hear how things went. How are you finding Hasura? Projects like that lead me to worry that I'll lose the ability to create the code I want because they're very opinionated (particularly for public internet facing API's).
Hope I'm understanding what you're looking for. I would suggest taking a look at [goreleaser](https://goreleaser.com) and [nfpm](https://github.com/goreleaser/nfpm) for building the packages. Then [packagecloud](https://packagecloud.io/users/new?plan=free_usage_plan) \- free tier to host the debs and rpms.
Not sure. But if I were in your position, I’d look at how golang is distributed for Linux on other architectures and work backwards from there. https://golang.org/dl/
oh that's a good idea!
Very nice, I'll improve later. Thanks.
I briefly scanned the src and don’t see a script that packages the various distributions, but I did find that it build a go tool named dist. https://godoc.org/cmd/dist I wonder if `install [dir] install individual directory` does something related.
&gt; https://godoc.org/cmd/dist Thanks! I'll take a look. I also found gentoo's ebuild script: https://gitweb.gentoo.org/repo/gentoo.git/tree/dev-lang/go/go-1.12.4.ebuild#n227
You never know your luck!
It's built on an older version of the main branch. As explained in the docs, the later versions appear to have an issue with external.invoke not being available (at least on OSX). Wails has a pluggable rendering system so would be easy (and desirable!) to move to webview-x when it is ready. Another option is [ultralight](https://ultralig.ht/).
&gt; objectively good patterns I have no idea what you're talking about
It seems like this is using webview rather than an instance of chrome. Lorca requires chrome to be installed, while wails looks like it doesn't need chrome installed. It uses webkit and mshtml (edgeHTML in the rewrite). I imagine this would use less system resources, but that's just a guess.
The overhead is about 8-10 meg on Mac. Rough edges are listed in the [project status page](https://wails.app/project_status.html) (plus the unknown unknowns!).
Rendering is done via the awesome [Webview](https://github.com/zserge/webview) project, which uses the native rendering engine on the platform. Performance appears pretty good on Mac. Would love feedback on performance.
Weird can be good :-) The bind function uses reflection to determine what the bound function signature is and creates Javascript versions of those in the frontend. Due to the async nature of the comms channel, every Javascript method returns a promise. Go method/function return values are mapped via the [binding rules](https://wails.app/reference/guide.html#binding-rules). So if you return a value and an error, this maps directly to resolve/reject. A single value return maps to resolve, unless it's a Go error, in which case it maps to reject.
Thanks! I don't know too much about Lorca but I believe it somehow binds with a user's local browser instance. I'm not too sure how it resolves different browsers. It may be a better fit for you. I don't think anyone likes pulling in cgo do they? ;-)
Bookmarked. need better tutorials please
I didn't say lower-level per se, just that Go is designed around abstracting away parallelistm (threads) from concurrency (goroutines), so if you need to micromanage parallelism perhaps another language would be a better fit.
Try out the Todo tutorial. It's pretty comprehensive.
cool, thanks. on it.
I have come to use the pattern where the goroutines also accept a context so that they can select on the channel and `ctx.Done()` in a `for{}` loop for clean exits if the goroutine is responsible for more than what a simple `defer` can do.
[removed]
I wouldn't be so sure. Poor design will affect anything in any language. You might have an easier time with GC in golang, but most of the things you're used to are gone It'll be a few years I'd guess before golang has the amount of libraries Java has
I ended up hacking this together: https://gist.github.com/cellularmitosis/351ee00c84a2d9ee068ccca683b0af07
&gt; I imagine passing context around to every single function call would be an obvious benefit I do that for all my handlers and I don't use any "DI container". I simply have a custom entry points for handlers: ```go func Handle(r *mux.Router, path string, handler func(*Context)) { r.HandleFunc(path, func(w http.ResponseWriter, request *http.Request) { var context = NewContext(w, request) defer context.conclude() handler(context) }) } ``` And then I use it like this: ```go // rounter mapping: var router = mux.NewRouter() Handle(router, "/", IndexHandler) // handler def: func IndexHandler(ctx *Context) { // do stuff! } ```
It's nice when people have no idea what they are talking about. Dependency injection is so pervasive, that there is a good chance that even you are using it, if you actually code that is
It looks nice. I've done something similar, but not with Vue, because I love to do as much in Go as I can. So my templates are made in Cloudykit/jet.
This file could be PDF/A compliant but pdfcpu only supports versions &lt;= PDF V1.7 &lt;- A restriction Pdfcpu has :(
[https://github.com/ipcjk/mlxsh/](https://github.com/ipcjk/mlxsh/) does a little bit like that, but for routers ;-)
Have you checked the size of the returned bodySize slice ? Is it 5kB ? Does the memory usage grow or is it simply huge and stable ?
How much does the resulting binary weight ?
On Mac, 8-10 Meg + your assets.
Usually you don’t cross compile Go itself. Instead, you cross compile your application. Go is unlike most systems in that it includes a full cross compilation tool chain on every system. It’s also fully standalone. Unlike python, node, Perl, etc, once you compile your binary, you don’t need the go runtime, at all. So there’s no need to install go anywhere. It’s what makes it so well suited for docker images as well, as you don’t need -any- dependencies (except cgo bound libraries or other such stuff). So, unless you actually need to build your apps on that other system, I would suggest building on a normal system, copy over the binary that you cross compiled and just be done with it. No more hassle.
I would be storing everything straight into a database. If the program crashed before someone completed their entry, you would lose any progress they made. It would also help you to keep track of the path the user has taken, so you'll know which message to send next.
Right, would be better to use cross-compilation for pdfcpu written in go, but it has pdf version restriction :(
I would just apply if you think you can do the job and you're interested.
This is suuuuper nice. Keep up! I am building a platform for PUG for CS (for now) over Go and was looking for an electron alternative. This looks very, very promising (no preassure). I might give it a go. Looks simple and tidy, things that I look at first. Bravo, man!
Go developer wanted, must have 10 years experience
The issue I'm guessing is that entry level guys are dime a dozen due to the number of developers who know language X already in staff and are more than happy to learn Go.. the new jobs are typically to teach these new Go devs how to effectively use the language/lead the project. That or they hired lesser knowledgeable people, fired them for not delivering, and now want a senior guy to come in and fix what was made. That's been my experience at least.
Oh god you're not alone with this thought. &amp;#x200B; Brand new to programming myself - only 6 months learning experience. Discovered Golang and really connected to it. &amp;#x200B; I think if you want entry level jobs, really, you need to have a good understanding of HTML / CSS / Javascript.
hasn't golang only been out for 9 years...?
🥰
I tried. Most of the time they have something like "Must have X years of experience; Expert in gRPC; Have build X enterprise level scalable applications"
On point xD
And that is the problem if you have a company and your recruiter is shit
&gt;The issue I'm guessing is that entry level guys are dime a dozen due to the number of developers who know language X already in staff and are more than happy to learn Go.. the new jobs are typically to teach these new Go devs how to effectively use the language/lead the project. That or they hired lesser knowledgeable people, fired them for not delivering, and now want a senior guy to come in and fix what was made. In my opinion, it would be more appropriate, if they hire a senior guy in the first place and then hire some entry level Golang devs if they really want to get their stacks up and running with Golang. I believe, the idea of making employees learn something they have not applied for is really uncool.
Thank you so much! I hope it does what you need it to do. If not, it would be great if you could raise a ticket. Good luck!
Most folks want to check out go ive seen. And it's a bonus for the company: maintain existing infrastructure, prepare for future, same person. I'm not saying this is always the case, but I know at least 2 companies I've worked for like this.
How big is the compressed tarball? Were you able to cut down the size?
Looks like you have [this](https://play.golang.org/p/3W2oTisw-y4) situation? It recreates the error message at least. The error is simple enough to fix. Make the `map` use the `IsFemEntity` interface. You won't be able to assign a `map[uint32]*FemMpc` map to the list, since they are different types. But you can assign a `*FemMpc` to any element of the map. https://play.golang.org/p/hVActPyvZ01
Yeah, there are some full-stack offers. Most of them requires some sorts of framework experience in front-end: ReactJS, Angular etc.
You dont need this `map[uint32]*(interface{ IsFemEntity })` Your want just `map[uint]*FemEntity`
It’s not necessarily Senior in Go. It’s a Senior that knows Go. And they want a Senior because the stuff you build with Go is often complex backend systems that require the experience of a Senior Engineer, you just have to know Go. Having the experience to apply mature engineering principles is language agnostic.
Yeah, it is.
So, the open access paper on our Go-based pipeline library was just published. It provides a thorough discussion of benefits of this approach, including how Go was a very suitable choice for this type of tool, over Python which is otherwise dominant in our field of bioinformatics. If you want to check out the docs, see: [http://scipipe.org](http://scipipe.org/) , and for the source code: [https://github.com/scipipe/scipipe/](https://github.com/scipipe/scipipe/)
[https://play.golang.org/p/UTaYyqwIEdf](https://play.golang.org/p/UTaYyqwIEdf) Looks like they get assigned at the same time.
Well, in that case, all Golang developers have to be a Senior Engineer to get a job.
So, the open access paper on our Go-based pipeline library was just published. It provides a thorough discussion of benefits of this approach, including how Go was a very suitable choice for this type of tool, over Python which is otherwise dominant in our field of bioinformatics. If you want to check out the docs, see: [http://scipipe.org](http://scipipe.org/) , and for the source code: [https://github.com/scipipe/scipipe/](https://github.com/scipipe/scipipe/)
They rejected you because you didn't have expertise in gRPC? Or you didn't apply because that was listed?
Well, in that case, each Golang developer has to be a Senior Engineers to get a job considering most the job posts require Senior Golang Developer.
People outside Google are coding in Go for the 11th year already.
Ah okay I see. Thanks for the example and your response.
It was meant as a joke based on Go 1.0 being released in March 2012
Dependency Injection != Object Oriented Programming, try again.
A lot of companies that use go are new-ish. They need senior people to not fuck up the foundations. Same thing for new projects on established companies. Then when you are a startup then juniors are not a good match in my opinion. They need supervision and this takes time of more senior people who could actually build the product in this time. Junior developers can grow in established projects where the team is larger and they can cut their teeth on some low risk tasks like maintenance. Just my two cents
They mean experience with Go but total years of experience should be 10. Not necessarily experience with Go for 10 years
You could debug into the go runtime to see what happens exactly
First, it means a senior that does Go, not just “wrote Go before it had a name.” 2nd, Go is frequently used in just the parts of the application perceived as high-value (yes, this is a loaded statement) and thus requiring particularly senior developers (yes, also a loaded statement).
the order that `x` and `y` are assigned to doesn't matter. this expression is executed by: (a) evaluating the right hand size of the `=` from left to right and store each value in a temporary memory location. (b) assign those values to the left hand size of `=` in order. so: ``` x, y = y, x ``` is basically: ``` t1 = y t2 = x x = t1 y = t2 ``` since everything on the right hand side is evaluated before assignment, the order that the values are assigned in doesn't really matter. for example, imagine if you had something like the following: https://play.golang.org/p/3kTxgIJ8tqs you may wonder how the values on the right hand side might change as the assignment is evaluated. well -- they don't change. From the Go spec: &gt; The assignment proceeds in two phases. First, the operands of index expressions and pointer indirections (including implicit pointer indirections in selectors) on the left and the expressions on the right are all evaluated in the usual order. Second, the assignments are carried out in left-to-right order.
It is not assigned simultaneously (unless I'm misunderstanding what you mean by that). Usually you would use a third variable to store a value temporarily. For example: z := x x = y y = z Because without z, you lose the value stored in x when you make it equal to y. `x, y = y, x` is syntactic sugar offered by Go. You don't need to use that third variable and you can do the operation in a single line. But the compiled code still have to do something similar to the code above. Since your code only has one line and you observe `x, y = 2, 1` before and `x, y = 1, 2` after, it's as if it was done in a single operation.
"Since everything on the RHS is evaulated before assignment" Ahhhhhh now I understand. Thanks alot man.
Have read through. Thanks for the in-depth explanation, I appreciate it.
Beginners need to understand that picking up a language isn't a big deal, although if you are learning your first language when this might feel very different because you're not just picking up a language, you're learning to express your thoughts in a new way. There are some languages which are more difficult than others to pick up, for example C++ or Rust will took significantly more time than lets say Python, but generally it's only a fraction of what constitutes competent developer. What I mean, is that a person who wrote python + js professionally for like 5 years will be a lot better Go developer even if that person hasn't wrote a line of Go, than a newbie who picked up Go as a first language and have been practicing it a for a year.
The company I work for (Leeds, UK) are looking for mid-level developers who can write Go. Many will be looking for senior developers who can write Go simply because of the types of problems they're solving. If you think about the kinds of software you see written in Go, it's not often trivial.
At first I thought this was a fair point, but this is such a huge change anyway to how errors are handled, if you're going to have to change your existing code at all, you might as well do it in a way that's clean and easy to understand, i.e. not the way this new errors library does it.
&gt; I'm always in a battle at work to convince people to use DI for the HTTP handlers. And I don't mean DI containers, I mean just a parameter in New or a factory function in the first place. It's excruciating. That's presumably because the current method is considered to be working well enough. "Always being in a battle" about stuff like this is seriously toxic for everyone involved. Talk to your team, make your case why you think this is better, agree on how to do it from now on as a team, and then stop fighting about it.
True story: the name came from Webview Rails...
You only gave C++ and Rust as examples, which both are ones of the lowest level languages that have ability to control OS threads. This clarification makes it clear but your previous message was not - that's why I've replied.
That's good to know, but I'm struggling to get that behavior to work as I wish. If I make a struct like this: type Coordinates struct { Lat float64 `json:"lat"` Lng float64 'json:"lng"` } and then initialize it as follows: var coords Coordinates defer resp.Body.Close() err = json.NewDecoder(resp.body).Decode(&amp;coords) if err != nil { log.Fatal(err) } return coords I get no failures, and no log output, but I also don't get my data. However, with the struct as defined in the link in the parent comment, I get the output I need: var geocode geocodeAPIResp defer resp.Body.Close() err = json.NewDecoder(resp.Body).Decode(&amp;geocode) if err != nil { log.Fatal(err) } coord := Coordinates{Lat: geocode.Results[0].Geometry.Location.Lat, Lng: geocode.Results[0].Geometry.Location.Lng} return coord How can I set up the first example to work as you describe?
Nice work. I will check this out. What would you say are the main differences or improvements to say nextflow or snakemake? Or simply make?
Thanks for the explanation, and sorry I missed that in the docs! I don't doubt that adding things like menus is tricky, and it's great to hear that you're looking to dig into that. I've toyed with the idea of building a desktop app, but I don't like Electron's size and I'd rather use Go than JS at this point. Wails is promising. Thanks for releasing it!
This is exactly what drove me to start building it. Regarding things like menus, I'm keen to see where webview-x goes. Menus at the Go level is pretty hard, but tray and notifications might not be.
New management was hired, and we were told to dump all of our C#/.NET Core code and use Go instead. I've been using C# since the 1.0 beta release in 2000. I have heard zero technical reasons for the switch. It's apparent new management hates everything Microsoft. They are taking our workstations away and giving us macbooks instead. I'm happy to get paid to learn Go, but once I have that Go notch on my resume I'm out of here.
Yeah that's a pretty weird tech change. I could understand if there were legitimate reasons for the switch, but nothing at all? I don't blame you for wanting to jump ship. I feel like I wouldn't trust the decisions management makes next.
Yeah, I've noticed there are a [few system tray libs for Go](https://awesome-go.com/#gui). BTW, I just submitted the project to awesome-go, though they may not go for it yet because of the "beta"ness of the project.
I think, one of the reasons also is, that typically Ho is not the first choice for beginners in programming world. It is expected that a person will have some knowledge of patterns, development and design principles with practical experience, before they pick up Go to successfully utilize the power of language effectively. That being said they mostly look for experience/seniority in general, not necessarily X years programming in Go. They want people that learned how to think and build applications and are now into Go.
Thanks for doing that. One thing I always want to try and keep is platform/feature parity.
&gt; Usually you don’t cross compile Go itself. Maybe OP did cross compiled Go compiler and needs advice about how to install it? Maybe we are that parallel universe.
anytime!
&gt; the idea of making employees learn something they have not applied for is really uncool Good companies don't want the kind of employee who isn't open to learning new things. I'd personally never hire someone like that.
Honestly we don’t have the bandwidth to train a new dev to use go. Senior just means you’re expected to pick things up and be productive day 1, very minimal training. A junior golang dev needs to learn the language still for the most part. Employers’ salaries pay for that to already be learned.
Time to jump ship. The new management doesn't know what it's doing.
Examples with pointers are what really bakes your noodle: https://play.golang.org/p/CmShWKJh0LL
This right here. Engineering Management is typically reluctant to add new technologies to their stack, especially when developers don't know the tech. Hiring senior devs who are have a very good familiarity with the tech and who can teach others is usually the way to go. You can learn a good deal by playing with the language in your spare time, but using it in production for many years is a different story. It's funny actually because at my company Go was actually started because "junior devs" had played with it and really wanted to refactor a scala service into Go. It wasn't really "approved" by management. It was when we hired a senior architect who had a lot of experience that it really became widespread. Doesn't mean we have a lot of senior Go devs, but we do have some.
Who is "they"? This is a made up situation
Dammit.. just one more year.
I think your first suggestion is on point, but if you're upset about learning new tech that's not on the job description you're not gonna last long.
FWIW, slices of slices are pretty much a bad way to implement things. An N-dimensional array can be mapped down to a one dimensional array with a simple mathematical formula. So for tic-tax-toe board, use a single array of length nine and then write a function that translates 0,0 into position 0 and 2,2 into position 8 etc. (Or it could translate A1 to 0 and C3 to 8, whatever you want.)
[removed]
Thanks, hadn't thought about that. Do you have any insight on why slices of slices are weird?
Thank you! :) The intro provides comparisons to other tools, including Snakemake and Nextflow, but in short, Snakemake and make are "pull based" and requires you to specify resulting filenames for output files. This is great for reproducing specific files, but can make it really hard to create more complex pipelines, which might not even be able to specify in terms of a file name pattern. Make in particular is problematic because of the lack of multiple interpolation patterns per task. "Pull based" tools also generally separate scheduling and execution in two phases, meaning that you can't readily schedule new tasks during the workflow run, e.g. to parametrize machine learning tasks with hyper-parameters optimized as part of the same workflow. Nextflow shares many similarities with SciPipe as it is also dataflow-based. Dataflow-based tools takes a bit of the opposite approach compared to Snakemake and Make and the likes, in that they only require you to define the dependencies between asynchronous processes, and not the resulting filenames, and that you then just feed this "dataflow network" with in-data and it takes care of the rest. These tools have thus been referred to as "push based". This makes these tools generally easier for more complex pipelines where you might not even know which the resulting output files will be, e.g. because of splitting a dataset based on a value obtained during the workflow run. Nextflow doesn't allow creating re-usable workflow components though, because of how dependencies are defined via dataflow variables which are "global" in the workflow definition scope. SciPipe instead sets dependencies between ports, which are fields or methods on the process structs themselves, which helps keep the components self-contained. Furthermore, SciPipe allows running only parts of a pipeline (up to a named process), which in part solves the problem with dataflow tools that they are somewhat less optimal to use if you want to re-create a given set of outputs - So, with SciPipe, you can at least decide to re-create all the outputs of a named process. &amp;#x200B; SciPipe also provides a number of other features that are so far somewhat unique, compared to many other tools, including Nextflow, AFAIK: 1. Audit logs created for every output of the workflow, as opposed to just one for the whole workflow run. 2. Ability to compile workflows to standalone executable files (as SciPipe workflows are just Go-code) 3. Zero required dependencies apart from Bash (optional dependencies for PDF plotting). 4. Super-small codebase (\~1/3 -1/2 the size of a popular python-based tool, Toil, last I checked). 5. No 3. and 4. above making SciPipe very suitable for vendoring into users' own workflow code repositories, guaranteeding that they will always run, whatever happens with the SciPipe project in the future. 6. Re-using existing Go tooling, because it doesn't invent any new syntax or language. 7. Streaming support, via named Unix pipes (very few tools support this, although there might be a few cases).
So is it atomic?
`board[:3][0]` doesn't do what you think it does. Chaining indexing like that doesn't do a clever multi-dimensional thing, it just says "give me the first three things, then give me the first thing out of what you get back", which is the same as "give me the first thing". I could see it working in Python, but not Go. `board[:3]` is basically just the same slice as `board` (since `board` has 3 elements anyway) and `board[:3][0]` is therefore no different from `board[0]`. Go doesn't provide a way to magically do the thing you were trying to do, you'll have to copy the values yourself like col := make([]string, len(board)) for i, row := range board { col[i] = row[i][0] } to extract column 0.
no -- not at all. there are a lot of steps there. :) again, something like: ``` a, b, c = f(c), g(a), h(b) ``` results in the following: ``` t1 := f(c) t2 := g(a) t3 := h(b) a = t1 b = t2 c = t3 ``` there's nothing about that which is atomic. :)
“So, unless you actually need to build your apps on that other system” Yes, that’s what I want 😎
That's true, it is not one of the most common queue's features. But I think it could be useful.
You are right! I was using **alloc\_space** instead of **inuse\_space!** The memory consumption the RSS stabilizes at 35 MB. I think it's to high for just getting 5KB JSON, but at least there is no leak.
I suspect this also and asked here. But I used wrong metrics alloc\_space, so the memory consumption is only 35MB, - still to high I think, but at least not 600MB.
The memory stabilizes at 35 MB and not on 600MB, because I was using the wrong metric with pprof. &amp;#x200B; Thanks for the suggestion!
I managed to get to 129MB vs. 107MB for the official pre-built tarball (330MB vs. 274MB untarred). Still a bit of fat left to trim if I'd like to make the script a bit more involved but I decided that was good enough :) I also built an ARMv5 installation which I'll use on an old NSLU2 (266MHz, 32MB RAM) and a few Pogoplugs.
I thought it was a play on the country Wales, ‘cause of the dragon
Yes, all seventeen of them.
GO for it.
I don't think this change is really that large. The [error handling proposal][1], on the other hand, is a sweeping change that inverts the way a lot of code includes context in their errors, but this change just allows a more straightforward way to check error conditions, and making it easy to make intermediate code pass them through seems like a benefit. I also really like the simplicity of fmt.Errorf, and many of the alternatives aren't as easy to use. [1]: https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md
[removed]
[removed]
Ok, tell us: why would you want to hire a Junior Gotlang dev?
What that usual means is a Senior Engineer + Golang experience. Just like understanding foundational paradigms in CS makes learning other languages easier to learn (it's just syntax at the point), being a Senior engineer usually means you understand foundational problems that exist in every large system regardless of language or technology.
[removed]
More likely C++ given the nature of Go projects.
[removed]
I agree 100%. It's not about the language, it's about experience. If you don't know the first thing about Go, but have 5 years experience working on a large-scale Python project, you are a good candidate. If you know everything about Go, but have never worked on any "enterprise-grade" project, you're not a good candidate.
To pay them less of course
[removed]
It must be `: %w` not only `%w` (curious not ?)
Depends where you are situated. I know, we keep looking for developers (The Netherlands, Noordwijk) and we train them ourselves. (I'm the Go Trainer of the company).
You don’t actually pay a junior less. That’s not how business works. Seniors get more pay because they do the job faster and with less risk. Otherwise everybody would just get juniors all the time. Seniors cost business less than juniors.
Not original commenter but one reason is locality. A slice is a pointer to a piece of memory, an array, and a length. So a slice of slices is a pointer to pointers to pieces of memory. This means the underlying arrays aren’t necessarily contiguous in memory, which is going to be less performant than a single piece of memory. That said, there are plenty of reasons to use a slice of slices. First, if the number of dimensions or maximum length of a single slice is not known, the mapping function mentioned above is going to be complex or less performant, since it may need to “push” things around to insert elements. Second, code is the enemy and writing something like that is going to be harder to grok than a simple to understand slice of slices. Remember that code is read more than it is written, and doing something clever without an explicit reason is never a good idea (in production code- being clever for fun is a great way to learn). Tic-tac-toe is a simple and well known example with known dimensions and length, so it would be easy to apply this mapping technique in that case. Other situations are not so simple. Personally, I would consider a bespoke mapping function as mentioned above a premature optimization and would use a slice of slices until performance dictated otherwise.
Welp, looks like I'm all set to crash my production app then...
Exactly. Go is training wheels off. Go is playing the game on hard mode. Unless a company was started with a Go stack the parts of their stack using Go are where they have a heavy load and probably directly drive company revenue. No manager in their right mind is letting someone with 6 months experience touch that code. It’s awesome you are learning Go. But as a junior trust is earned. You do that by showing up to work writing JavaScript and python or ruby or whatever other language they will let you touch. Build a track record of shipping working code to production. Then you get to play with the cool shit.
&gt;I believe, the idea of making employees learn something they have not applied for is really uncool. I don't wait for my company to make me learn something, I am continually learning all the time so that when my company want to use something I already know it.
You could be talking about DI, or DI injection frameworks or even the principle of encapsulation, abstraction, inversion of control etc.
Even managing a transition from one language to another usually requires a more experienced set of eyes so that you don't do an all-or-nothing effort for months and fail horribly.
The employer
Thanks, Guys, now it is compiling. And in my experience that means it should do something half-way plausible.
It is only fitting to have a made up answer to a made up job post.
Agree w/ what most are saying about it really being a matter of finding a senior who is solid in their programming to write and understand good Go practices. Additionally, the few companies I've found who are moving toward Go for certain circumstances need a team who can ramp up with little overhead/oversight and make good, sound decisions.
I hope they know what they're doing lol
Maybe there are no positions for junior devs because none are learning it. Might have something to do with the fallacious thinking and absurd gatekeeping oozing from your post. By your logic nobody hires C++ junior devs either, right? Not the case at all.
Her parents
They never got back to me in the first place. I guess it's all about portfolio. But, I wouldn't mind if they had assigned me to make a demo project to test my skills.
When I was on a team with lots of code in Go, we hired C# junior devs because we still had a major project in C# and it takes no time to be able to be a junior Go dev if you have any programming experience. It sure makes it harder to find a Go position, but I have found that since then lots of companies have at least a project or two starting to use Go, so the easiest way to write go at work might be to simply write it at a company that doesn't use it as their primary language.
I think it depends on the market, here in San Diego there are barely any Go and even less so Senior Go positions. The seniority requirement is focused on experience in working with mission critical systems for the company, a junior would be too quick to roll out implementations without considering many of the possible scenarios that the system should handle, Go is a language that allows you to get the ball rolling really quick but that does not remove the need for an in depth analysis and design of a service or system; the consequence is downtime for critical services and having to pair a Senior dev with the junior dev to review and fix in a time critical manner.
Once you get used to it you will understand why so many of us hate Microsoft's stack.
Even for single variables, if you want atomicity, you’ll have to use something like “sync/atomic”, which tries to use special CPU instructions if possible. For atomic operations on multiple values, you’ll have to get creative. For simple situations, I put all my values in a struct, create a new copy when I want to change things, and atomically swap pointers.
What are the skills you expect a developer to have before you recruit them?
Put it on kubernetes, get a fully tested set of everything out of the box.
Don't be afraid to apply anyway. Worst they can do is not hire you. Much/most of the time, the requirements are more like guidelines. You might be surprised at how often people get hired who don't 100% match the description. If you think you might be good at the job, apply.
Thank you for this. Since Go itself "just works" on it's supported platforms, there's almost an expectation that things written in Go just work on all platforms too. I was really happy when I saw installation covered for Windows as well, with good clear instructions, instead of "it should work, but I haven't tested it". The vital Todo tutorial is also really well done and thought out, even with little things like cancelling an edit. I will definitely be trying it out and will be encouraging my team at work to try it out too. Great work! This just might be enough from a GUI perspective.
consul and etcd aren't "service discovery" products (by themselves), at least probably not in the way you imagine. What exactly do you need when you say "service discovery"? consul and etcd are distributed k-v stores, and are used for shared state/consensus. If you ran one of them, you'd likely need to use something like [registrator](https://github.com/gliderlabs/registrator) as well in order to keep things up to date. Having used both consul (with a bunch of registrator+nginx nonsense) and etcd (first with fleet, and now with kubernetes), my recommendation would be to use kubernetes. There's a bit of a steep learning curve given how much kubernetes offers, but it's useful knowledge and definitely the direction the industry is trending towards.
That's kind of normal, unfortunately. Last time I went jobhunting I sent an application to perhaps ten places, and only two got back to me: one to say that they're not interested, and I eventually got hired at the other. The thing is, if you don't try you'll never get a job. I left school at 16 for various reasons and worked minimum wage jobs for a few years. I didn't have my first programming job until I was 25, but in hindsight that was mostly just because I didn't have the confidence to actually apply for the jobs I wanted. After I got my first job kinda by accident I've had no problems getting hired. Some random commentary: - Remember that a lot of job postings are badly written. Don't treat job postings like some sort of carefully crafted document, because more often than not it's a quickly and sloppily written afterthought. Often times I barely worked with half the tech listed. - You can kind-of ignore stuff like "expert in gRPC", "experience with SendGrid", and other really specific stuff. Those are nice bonuses but few companies will chuck out your application just for that. It's a library. There are hundreds of libraries and services you use as a programmer, and you can't possibly be familiar with all. Instead, focus on generic skills, like API design. - That being said, do be somewhat marketing-conscious. Listing gRPC on your CV is unlikely to hurt your chances, and all you need to do is write a gRPC program. You won't be an expert in gRPC, but you can truthfully list gRPC experience. Same applies to stuff like Docker or other "hot" stuff. - You don't need to send out your application *right now*. If you've got the time and you really want the job then spend a few days learning about the tech they use and write something with it. One of the reasons I got hired at my previous Go position in spite of having zero previous experience with Go is because I spent a few days learning Go and wrote a small program with it. - Many companies are just looking for good people, not "Go programmers". This is not always the case, but your non-Go experience and experience with tech other than what's listed on the application will certainly help in any case. - Make your CV not suck. May sound obvious, but hot damn have I see a lot of laughably bad CVs. Be obsessive about spelling, layout, what to include and exclude. This applies doubly to your cover letter, which is your first impression. - Make your cover letter count. Writing good cover letters is really hard, so I know this is easier said than done, but look at the job posting, what the companies does, and where you can "hook in". Sometimes this is really hard for badly written job postings or boring companies (like marketing, or whatnot). I tend to just not apply to those. Don't use a standard copy/paste cover letter (but do *save* your cover letters, and copy/paste paragraphs when applicable). - As I mentioned, just apply if you think you can do the job. You do need to use *some* common sense; applying for a team lead or senior position in a complex industry (like, say, science, or some finance stuff) is probably not a good idea. But in the end, the only thing you have to lose is the time you spend writing the cover letter. There are worse ways to waste time. - Trust me, if you spend some time on it your application will be *far* from the worst one. It's kinda like online dating: half the people have profiles/pictures that just suck. The number of people with only out of focus selfies on their profile is amazing. - You'll probably have better luck at smaller companies vs. larger ones. The person reading your application will be someone who actually knows their stuff, instead of a HR who's just scanning for keywords (there are some really good non-tech HR people, but they're rare). Probably more to be said, but this is all I have right now. Be confident and don't lose hope.
I have to be frank go feels like a breath of fresh air in terms of clarity after working with heavy weight Java for a few years. I don't really see what makes go "hard mode". Looking at my coworkers C code base I am only ever more glad that I don't have to touch C all that much
I don't value senior or junior that much. Just apply for the job and they will figure out in the interview if you are a match. In my 10+ years in the business I have seen seniors with the skills of beginners and vice versa. E.g. 10 years of bug fixing on Java might make you a senior, but when a given senior would have to build new microservices from scratch or simple restful api, you would be surprised how many will heavily fail or be factor 5 slower compared to the junior who just had programming as a hobby and only is around in professional life for a year. In general all boiles down to the specific experience and skill required in a team. So if they are looking for a senior bug fixer above hypothetical person could be the perfect match. At the end you have to fit in the team and the team can take things to a higher level. I don't believe in individuals 😊
https://12factor.net/
If you're running golangci on a ci server with a lot of cores, of which only some are available to you, make sure you add something like "concurrency: 4" to your golangci-lint config, or it will spawn a ton of jobs consuming massive memory.
Thank you very much. It was very insightful. I will definitely try following these points. I appreciate the time you have taken to write this comment; will help any developer find a job.
You are totally correct!
Google Cloud Build is a very good tool if you're already on GCP anyways. Costs are reasonable and it works already with GitHub. Triggers can be set for branches or tags at the moment. They announced PR integration on last years google next but I have yet to see it release. You can probably get access to an alpha/beta if you get in contact with them for the PR feature, which would enable you to do certain actions based on PR. Other than that, GitHub actions could take some of the efforts and most likely block PRs for you as well, again this will be only available through beta access at the moment.
&gt;There's a bit of a steep learning curve given how much kubernetes offers I would recommend starting with a Kubernetes-based products (Google Kubernetes Engine, for example), so you will not need to worry about managing master, etc.
Sounds like somebody in management is empire building.
My experience is that the flexibility of slice of slices (each sub slice has its own length) is a pain to manage in the usual case, which is that the game board has a single, fixed size. I think `myBoard.get("A1")` is much more readable than the alternatives.
This is because `return re``flect.New``(typ).Elem().Interface()` returns an interface to a struct value not a Pointer. Depends on design you can ask it to return a pointer (which makes more sense to me): `return` `reflect.New``(typ).Interface()` or create a new pointer of the struct via reflect: `method.Call``([]reflect.Value{reflect.ValueOf(`[`reflect.New`](https://reflect.New)`(reflect.TypeOf(i)))})` &amp;#x200B; Note: It is possible but not recommended and unsafe to take address of the struct value (of which returned to main()) by using unsafe and `Value.InterfaceData`.
In what world is Go “training wheels off”? It’s garbage collected...
https://istio.io/
Sounds really exciting. Good job.
And a blank slate :) sometimes junior devs fit better into a team than a senior dev
Yes, but the "lat" and "lng" keys are the only ones I need. I really only need that inner "location" object.
What we were already doing was pretty much a single rest endpoint that was communicating through predefined json objects, wrapped with top level keys such as, "system", "command", "data." So we were kind of already doing our own version of graph without having the relational abilities of graph data storage, and we were having to write server and client code for storing and retrieving data. So I was already kind of in the Hasura mindset. And Hasura is really amazing software. My first response was, "it this is the alpha, can you imagine the beta?" You need to go into postgres and do the due diligence of proper indexing, but once you do it's stupid fast and extremely flexible. The first problem was lack of a good Go client. I wrote a little library called gqlBuilder that took most of the trouble of out the process. It allows me to declare a client, create a query, insert, upsert, or delete request. Even grouped variations of those in a single request. It also scans nested structs to make the requests, or package the insert/update data (reflection nightmare territory). That whole thing works, and now we have a usable little ORM that's almost ready for prime time. Then for security I needed a webhook server for Hasura to use. The way I'm doing that is I'm sending ACL headers with every request (basically: {user: x, object: y, perm: read}) and Hasura sends those custom headers over to casbin on the webhook server and that responds with a Hasura role. We're only setting three roles throughout all of hasura: read, write, and delete. Hasura requests will only be allowed from our applications to Hasura, so we have a fairly good little security plan worked out. We tested all of that today and it worked. So I've got flexible storage, I've got a library to interface with it easily, and now that all has security. At this point it's time to start building, or migrating the apps to use it. It is scary to base so much of your infrastructure on a new project that might disappear over night? Yes, but aren't we all doing that all the time?
Theoretically.
Thanks for your feedback, I've been trying to clarify this for a couple of days, and your comments make totally sense. :-)
Well, I just worked for a startup that hired for 15$/h. That's also a business strategy, albeit less common.
I'm nothing special and I've been coding Go for around six years. So I think 10 years is probably more common than you think.
If you feel like that, you should try Flutter (Dart). Now *that's* a breath of fresh air in mobile development.
I am not one of them, but I can say I've been working with go for 10 years...It wasn't a 1.0, nor was it in production, but still...
Which means anyone is qualified.
I don't do mobile.
Fair enough but how did you find out about it? I don't even know if I'd call Go "mainstream" now but it sure wasn't common back then. My point is that relatively speaking, outside of Google, there weren't a lot of Go engineers in 2009.
What a retarded hole to pick at, the made up situation would have a made up employer to go along with it so its fair game to refer to them
That's what I thought until I tried Flutter
Based on my own experience, I probably first heard about Go about 5-6 years ago and I follow tech blogs, twitter, technical subreddits so I'd still argue that it was quite a bit less common just 3-4 years before that. No big deal, either way, it's significantly more popular now.
Wow, I am also looking for something similar. Have you checked ponzu-cms ? It is not having all the above but maybe something close. Could you also plz tell me if you know of any JS library that meets all of the above. It will be beneficial to me. Thanks.
I am a fan of Plan9. I have just kind of always kept an ear for Pike; once he went to Google, I knew to expect big things. My first intro to Go was right around when they made it public. I think it was 0.4 or to the likes. I was surrounded by OBJc and Java (mobile) with Python (server) devs. Python devs (me included) always bitch about writing concurrent process. The language was not designed for it, thus I found my self liking Go in it's immature stages.
I used nestjs as framework which made many of the listed requirements very easy to implement. It requires some time until you are familiar with all the features but it will help you to maintain a decent code architecture.
Thanks
Thanks
And garbage collection is appreciated after having experience with non-garbage-collected languages.
I've been looking for similar examples and so far I've found [Let's Encrypt](https://letsencrypt.org/)'s boulder codebase as one example. They have (web front end) [wfe](https://github.com/letsencrypt/boulder/blob/master/wfe/wfe.go) and [wfe2 on github](https://github.com/letsencrypt/boulder/blob/master/wfe2/wfe.go). Those files are pretty dense though so a beginner likely would take a bit to fully read/understand the file.
Relevant username?
[https://github.com/checkr/flagr](https://github.com/checkr/flagr) it covers some of the items you mentioned
Take a look at [jsonapi.org](https://jsonapi.org/implementations/#server-libraries-go), specifically api2go. I had success with this library.
Okay, yeah. The thing that works in python is `s[:3, 0]` if `s` is a numpy array or something else that overrides `[]` similarly. :)
The whole point of the xerrors lib is that you don't need 1.13 immediately.
Thank you!
You are being downvoted because your statements are not correct. &amp;#x200B; &gt;Go is training wheels off. Go is playing the game on hard mode. Compared to what? Go has fewer keywords than most other languages, requires every file to declare it's imports, requires every variable to have a type, etc. Languages like Ruby allow complex Metaprogramming. (So complex that the entire Rails team spent years digging themselves out of it.) &gt;Unless a company was started with a Go stack the parts of their stack using Go are where they have a heavy load and probably directly drive company revenue. Citation needed. At my company, we started using Go for our internal CLI tool, then our build servers, etc. &gt;You do that by showing up to work writing JavaScript and python or ruby or whatever other language they will let you touch. Build a track record of shipping working code to production. Then you get to play with the cool shit. But if you think Go is a better language, then you should want to give Go to the novice developers, and Ruby for the experienced devs (where it's easier to screw up, requires more testing because there is no type checking, etc). &amp;#x200B; And if you don't like Go, why are you hanging out in /r/golang?
Nothing wrong with garbage collected. But if you think go is a hard programming language without training wheels, man I shudder to think what you think about c or rust.
Off topic but could you explain what shortcomings you experienced in nestjs?
Basically you're asking for a spring framework but in golang
I habe always used echo and its middlewares (JWT etc.) in combination with other useful libs like logrus, mgo/gorm. Worked out for me, have been running dockerized and versioned APIs for quite some time now.
I have a very similar journey. NodeJS to Go. Moving to Go has changed how I structure projects. Interestingly, I structure my Node projects much like how I structure my Go projects now. A nice benefit of Go being how flat Goroutines make your code. You can just chain functions that have "async" actions consider the following javascript code: ``` const createAction = () =&gt; { const action = { value: '' } action.sleep = duration =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(action), duration)) action.setValue = (value) =&gt; { action.value = value return action } action.stepTwo = () =&gt; action action.stepThree = () =&gt; action action.getValue = () =&gt; action.value return action } void async function main(){ const result = await createAction() .setValue('test') .stepTwo() .sleep(1000) .then(ctx =&gt; ctx.stepThree()) .then(ctx =&gt; ctx.getValue()) console.log(result) }() ``` Not terrible, but a bit gross changing contexts to a promise chain. With Go, you can chain things flatly, and if an action is concurrent, it will be hidden by its implementation. Generally, what's striking about Go is it's inherent flatness. Anyway. Domain driven design is king here. I lay my project out into a entrypoint and domain packages. ``` /httpd &lt;- My web service lives here /platform &lt;- any project specific dependencies that aren't shared between services live here ``` ``` / /httpd /handlers hello-world_get.go hello-world_get_test.go /environment environment.go main.go /platform /profile profile.go profile_test.go ``` When you have multiple entry points. Like Lambda, Http, CLI - I set up a `/cmd` folder ``` /cmd/httpd /cmd/lambda /cmd/cli ``` (Though with Lambda, you can actually just switch out `http.ListenAndServe` with a lambda parser and your project can be deployed there without any changes whatsoever) Dependencies like DB connections, Redis connections, Http clients and anything that needs to be mocked I declare in the entry point: ``` /httpd.main.go ``` You can split the main package into multiple files if you have a lot of services being loaded. Then I pass them down into http handlers and into the packages those handlers compose to achieve the behavior they are trying to. I use the Chi http router. I have a custom package I use on top of that which add convenience methods to it https://github.com/qkgo/yin It's not perfect and I should update it. I use NewRelic for application monitoring and have a custom middleware I attach to each handler to gather metrics. I spent the last 6 months working with OAuth+OpenID authentication and have started writing an OpenID connect implementation for Go. Validating JWTs is a little bit annoying but long story short: ``` https://github.com/qkgo/openid-client/blob/master/verify-tokens.go ``` I've also started a video series where I am building APIs and that. I intend to continue making mire but it's tough finding the time and motivation. Plus I need a new microphone and probably a webcam. https://www.youtube.com/watch?v=zeme_TmXyBk
I've been expected to learn new things on my own time that will be used at work, and I've been expected to learn new things at work while I'm getting paid. I definitely prefer the latter.
Hahaha seriously. You can make that at a grocery store in my city.
&gt; I used nestjs as framework which made many of the listed requirements very easy to implement. If nestjs did the job, why are you moving to Go?
We need more people like you.
I've seen tons of companies hiring for roles doing basically this in Go. So I assume it's well suited for it. Has anyone ever seen a writeup and a basic video streaming server implementation? I don't think i've ever seen one but would love it.
For many of those requirements, I actually prefer to use an API Gateway like [Amazon API Gateway][1] or [Google Cloud Endpoints][2] so they don't even need to be something that's built into my app. In particular, API tokens, quotas, permissions, authentication and authorization, monitoring, load balancing, etc can all be handled outside your app. A lot of the rest are easy to build with orthogonal libraries like [go-swagger][3] or [gorilla/mux][4] based on the needs of the particular service. [1]: https://aws.amazon.com/api-gateway/ [2]: https://cloud.google.com/endpoints/ [3]: https://github.com/go-swagger/go-swagger/blob/master/README.md [4]: https://godoc.org/github.com/gorilla/mux
Rust is a unicycle and C has no wheels
This should get you most of what you need. https://github.com/micro/go-micro Check the plugins too https://github.com/micro/go-plugins/tree/master/wrapper/monitoring/prometheus https://github.com/micro/go-plugins/tree/master/wrapper/trace ...to name a few The Kubernetes helm charts or Kustomize or whatever you use to generate yaml would be custom to your environment. No one solution to rule them all.
The more time I spend with that I think it’s a jumbo jet airliner. You can let the autopilot do a lot or you can tweak every bob and setting if you like.
Rust.
Your best bet is to use hls, or rtmp. Hls will probably be easier, and will work on mobile devices. The reason you get stuff for encoding/decoding is because that's the hardest part at scale. Apple created hls, and has some great guides on it. They designed it specifically to solve problems with unstable networks. If you want to roll your own, I would base it off of that.
0_o Consul is very much SD. The kv is a sideshow by comparison.
Not Go specific, but look into RTMP and outputting to adaptive streaming formats, such as HLS or DASH. This is usually done through a server mod for Apache or NGINX as a live encoder and packager. Check out: https://github.com/arut/nginx-rtmp-module
I'm pretty sure Twitch is using Go for streaming, check out their engineering blog I'm sure you'll find something suitable there.
You can check out [pion](https://github.com/pion/webrtc) which is a full Go implementation of WebRTC. Otherwise as others mentioned, RTMP and HLS aren't tough protocols to implement although I don't know of any Go libraries off the top of my head. You can also look at [streamline](https://github.com/streamlinevideo/streamline) to learn a lot of the concepts behind video streaming at scale and delivering to potentially thousands of people in different areas of the world.
We are sort of doing that, but using websockets and rather video we use a frame of images. But your requirements seems a bit different.
A little refactor... func SetResManagerState(ampqAPIConfig RabbitConfig) { resManager = newOcrResManager() queueManager = newOcrQueueManager() urlQueue := ampqAPIConfig.AmqpAPIURI + ampqAPIConfig.APIPathQueue + ampqAPIConfig.APIQueueName urlStat := ampqAPIConfig.AmqpAPIURI + ampqAPIConfig.APIPathStats var old = true var cur = false for { ServiceCanAcceptMu.Lock() old, cur = cur, CheckForAcceptRequest(urlQueue, urlStat, cur != old) ServiceCanAcceptMu.Unlock() time.Sleep(1 * time.Second) } }
Service discovery: https://github.com/micro/go-micro
1. This is l10n, not i18n (you can argue that l10n is part of i18n, but this library doesn't do any other part of i18n). 2. Proper l10n is a lot more complex than simple string replacements, for example [plurals](https://developer.android.com/guide/topics/resources/string-resource#Plurals).
I prefer using a retrier, like here: https://github.com/eapache/go-resiliency/tree/master/retrier It's also important not to use a static 1 second interval for reconnect attempts. Use a variable interval (i.e. short at first, but longer waits on consecutive fails). It's also good to add a bit of jitter in there as well, ensuring if you have multiple clients connecting to a server they won't all try reconnecting at the same time if the server would be temporarily unavailable. Don't hug the server to death with reconnect code. Also don't use time.After(..) if you can end up timing things multiple times. Use the underlying timer object. If you check the time.After(..) implementation, you can see it returns a timer with the given duration. You can reset a timer and use it again.
💯
That’s one of the most common business practices! Hire the wrong people and go bankrupt slowly.
💯
&gt; Make your cover letter count https://boingboing.net/2010/10/05/hunter-s-thompsons-1.html
Are you currently using gcloud build? How are you using it? I've been using AppEngine, so I don't really need to build anything, only deploy. I do see a Cloud Build Github app! Incidentally, I subscribed to the Github Actions beta two days ago.
See last line of my thread, I knew this question was coming
 git fetch -p
No I am not, I asked for inspiration on how to structure / implement an Api with these features so that they are still very much maintainable. I did not use the word framework at all I believe
Do you have an example on how you structured the project/code? I am sure I could write horribly bad rest Apis using the same framework and libs you mentioned
It is the 4th time I see this library posted here by you. Please stop.
See last line, there was not really a reason to move away from nestjs, but for that project most of the code will be rewritten in golang. The problem primarily lies in nodejs rather than NestJs, such as lacking type definitions depending on the libs you want to use, testing and tooling capabilities compared to go, I can compile it to binaries, performance reasons etc. Also I wanted to test how well I can implement such REST Apis in go.
It is probably not. Unless you've left out a lot of details, and some other event might trigger a reconnect, or you wish for the timer to fire periodically, there's no reason to make this so complicated. If you always mean to reconnect, just manage your connections in a loop.
Sorry, I meant spring boot. I haven't been more productive than I'm in spring boot with kotlin setup for enterprise backend development thus far.
After a while, I noticed IntelliJ/GoLand were actually being a bit too aggressive with their autocomplete features so I stopped using it altogether. I just use VSCode now instead, although I'd like to switch away if I find something better.
[removed]
Honestly, VS Code is not very good for large projects. I am seeing issues with autocomplete, highlighting errors, find usages etc... And no good refactoring support. It used to work very well when we started.
I've noticed that too and haven't worked on any very large projects recently which JetBrains products are definitely geared towards.
We have an open position for a junior engineer and we do (almost) all of our work in Go. I just checked - our job listing doesn't explicitly state Go anywhere in it. Either it was an omission or an acknowledgement of the fact that very few (if any) universities teach classes in Go.
Have you tried it recently with the new language server, gopls? It's working really well (though I don't personally find fancy refactoring features useful, so maybe it's missing something).
No will try that. Thanks
Streaming Engineer here with a love for Go. Let me help you on your path with your video platform. There are certain things you need to have in order to be able to distribute video to the thousands. First of all, you need an encoder which creates the actual video. In your case, it sounds like you already have that covered as people who use the platform will be encoding the video. If you don't plan on doing anything with the video itself, you don't have to worry much in which video codecs you're going to allow. However, if you which to create adaptive live streams from a single incoming stream you will need to do some transcoding, and then, such things do play a role. The second part you need, is some form of ingest, so basically the part where people their streams to. If it's HLS you're planning on ingesting, then a simple Webdav would do, however, if you wish to use something like RTMP (like Youtube) need something for that. There are already certain solutions for that, such as Wowza, or NGINX with the RTMP -&gt; HLS module. Then, once you have the streams, in the bitrates you wish them to be, you need to consider how to distribute them. Now-a-days the standard packaging is HLS, MPEG-DASH and HSS. If you're not planning on using DRM, then the simplest of choice would be HLS. This enables you to reach most web browsers, Android and IOS. Only Edge and Safari have native support, but every HTML5 player would be able to play an HLS stream in most mainstream browsers. Examples are JW Player or Theo Player. As for HLS, if you need to read the manifests, [grafov](https://github.com/grafov/m3u8) has a great library for that. You mention gRPC. For which purpose do you wish to use it ? If it's for distributing the video, I would suggest against it. All the main stream video distribution methods now-a-days are based on HTTP traffic, so that it can be cached in CDN's and such, as you don't wish to hammer the servers which serve the video data to death. You can ofcourse use it for API calls and such. Lastly, if you do wish to build an encoder in Go, (e.g. H264/AAC) I have to warn you, a very extensive open source solution named [FFmpeg](https://ffmpeg.org/) which is written in C. It has taken years to make it with a large community and even though I surely love Go, I doubt anyone would be able to get close of it, let alone it giving you any speed advantage. When it comes to encoding video, nothing beats C. You could use bindings in Go to use the FFmpeg libraries. So a few keywords words to help you on your search. Packaging: HLS, MPEG-DASH, HSS (Smooth Streaming), MPEG-TS, RTMP. RTP, RTSP Codecs: H264 (AVC), H265 (HEVC), AAC (LC/HC) VP9, AV1 Software: Unified Origin, Wowza, FFmpeg, AVsynth
What kind of branches get removed? Ones that are merged into master?
I don't think Go is hard. It's minimal and simple. But it's created at Google and born out of a need for something better than C++, for large projects.
Firstly, your JSON is technically invalid, this sample may work with some implementations of JSON parsing, but not \`encoding/json\`. [Here is the correct Go way of doing it using only the stdlib.](https://play.golang.org/p/EcpD0rjLXja)