Not sure if I miss something obvious, but would a simple slice literal meet your requirements? slice := []int{1, 2, 3, 4, 5, 6, 7}
Thanks Appreciate your help. I got points 1 and 2 But for 3, the outer loop is iterate equal to the number of strings. Say if there are 3 strings, outer loop will go 3 times and for each of these, the channel will be read. So we are basically reading the channel 3 times. Is this right?
Websockets seems like a good plan. I like gorilla websockets.
You might want to check out https://golang.org/pkg/os/exec/#Cmd.StderrPipe. Or https://golang.org/pkg/os/exec/#Cmd.StdoutPipe. Something like: cmd := exec.Command(...) errpipe, _ := s.Cmd.StderrPipe() cmd.Start() go func() { errscan := bufio.NewScanner(errpipe) for { chk := errscan.Scan() if !chk { if errscan.Err() != nil { // error } break } stxt := errscan.Text() // stxt is your stderr output, per line } }()
Any examples?
[removed]
I did a review of Go linting tools at http://btubbs.com/a-survey-of-go-linters.html the other day (it's been a hot topic at work lately). I think the most important feature is the ability to disable specific warnings that are causing too much noise. (Which is what motivated me to fork golint and make gofluff.) I'll give a +1 to the three tools mentioned by /u/Jelterminator. I'm also exploring [gas](https://github.com/GoASTScanner/gas). Its ability to scan for insecure crypto usage is really attractive.
the millisecond ticker is part of demo, not part of the library. The implementation does not rely on the ticker.
I can also recommend trying out storm if you want to use boltdb and get indexing + advanced queries. https://github.com/asdine/storm
I believe that the form pResult.(interface{}) // var.(type) only works with the underlying type, not with an interface. Casting interface{}(pResult) // type(var) seems to work just fine here.
Thank you for the link. I've read it, and it seems you didn't look at the code I posted. It is almost exactly the same, with different naming scheme. All of the questions stand though.
Thank you for the answers. Could you post a more concrete example (just few lines is enough)? Preferably in the github issue?
I did look at the code you posted and the issues you opened. The majority of the issues seem to come from trying to force the implementation of other languages into Go. Naming is important.
[removed]
The Doxsey book is great. I routinely recommend that one to beginners to programming.
Thanks for the pointer on that one. I will have to figure out how I can pause a process at intervals for multiple routines I am running.
 sudo rm -rf /usr/local/go wget https://dl.google.com/go/go1.9.4.linux-amd64.tar.gz ~/Downloads sudo tar -C /usr/local -xzf ~/Downloads/go1.9.4.linux-amd64.tar.gz
It is almost exactly the same as in the link you posted. The "root" package that is mentioned in the post is basicaly my model (root model) + repository interface. Only difference is they are split in separate packages, which makes no difference.
Did you use apt to install Go the first time? Remember to --purge everything before installing the new version. Also check your $GOPATH
Use the official installation instruction provided by golang.org and nothing else.
&gt; Only difference is they are split in separate packages, which makes no difference. It does make a big difference. You open yourself up to cyclical imports and it makes imports uglier. This is the whole point of the article when it said "#1. Root package is for domain types". For example your [first](https://github.com/lunemec/go-clean-architecture/issues/1 ) issue is about duplication of models. Well if you kept your models on a "root package" as the article suggested you wouldn't have that problem. Have a look at how [Upsin](https://github.com/upspin/upspin) does the package architecture.
Hi, try to use https://github.com/moovweb/gvm This is go version control automatization tool
Flamegraphs are included in go's pprof tooling since 1.10, according to this [post here announcing it](https://rakyll.org/pprof-ui/).
Standard libraries.
Awesome work!
Most of the standard libraries aren't that low level.
I tried, but I am getting this error sudo tar -C /usr/local -xzf ~/Downloads/go1.9.4.linux-amd64.tar.gz [sudo] password for p: tar (child): /home/p/Downloads/go1.9.4.linux-amd64.tar.gz: Cannot open: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now 
Can you post the result of this command? go env 
File name shortening taken from standard library log package. Please see: https://golang.org/src/log/log.go?s=2378:2670#L129
Not sure if this is exactly what you're asking for but check out gophercises.com 
I have since un installed it. But it is still present in the user folder with a lock icon on the folder name. The program 'go' is currently not installed. You can install it by typing: sudo apt install golang-go 
&gt; but when looking at my code I'm under the impression that I'm not using efficient patterns and making the most out of what Go gives (forgetting to use pointers, scarcely using anonymous functions). * Read [Effective Go](https://golang.org/doc/effective_go.html) many times. * Read [CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments). * Use tools like `golint`, `go vet` and [gometalinter](https://github.com/alecthomas/gometalinter). * Post specific examples of things you are not sure about so we can help. * Don't worry and just keep coding. 
[F*ck yeah!](https://m.popkey.co/cd95f1/lNY0L.gif)
You do not have duplicate models. You have a single entity and distinct formats appropriate for a given adapter. There's not even a pressing need for them. Instead you could just assign a few variables before or after executing a query. However, the better solution would be to package the adapter with the formats it requires. Why's that correct? Because you're *always* transforming data into an appropriate format *after* receiving it from an inner layer and you're *always* transforming data into an appropriate format *before* sending it to an inner layer. This way, even when the formats are packaged together with the adapter, the dependency graph still always points from an outer layer to an inner layer. Also, of course, packaging those formats together with entities is quite misleading.
You do not have duplicate models. You have a single entity and distinct formats appropriate for a given adapter. Your package structure is misleading.
It's a host for running [cygwin](http://www.cygwin.com/)
I did almost exactly that with a python script that ran rsync. I'll show you a very stripped down version of what I have. This is my first time doing something like this and I'm still a beginner, but figured I'd share what worked for me. I used gorilla websockets. I'm sure it could be simplified quite a bit as well. var ( SyncOutput = make(chan string) SyncClients = make(map[*websocket.Conn]bool) SyncClientsLock = sync.RWMutex{} FileSyncing = false FileSyncLock = sync.RWMutex{} ) var upgrader = websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, } go WatchOutPutChannel() func runSync() { cmd := exec.Command("python", "-u", config.SyncFilesScript) stdout, err := cmd.StdoutPipe() if err != nil { fmt.Println(fmt.Sprintf("Error: %s", err)) } FileSyncLock.Lock() FileSyncing = true FileSyncLock.Unlock() err = cmd.Start() go WatchOutPut(stdout) } func WatchOutPut(out io.Reader) { scanner := bufio.NewScanner(out) for scanner.Scan() { SyncOutput &lt;- scanner.Text() } FileSyncLock.Lock() FileSyncing = false FileSyncLock.Unlock() SyncOutput &lt;- "Sync Finished" } func WatchOutPutChannel() { for { output := &lt;-SyncOutput SyncClientsLock.RLock() for client := range SyncClients { client.WriteMessage(1, []byte(output)) } SyncClientsLock.RUnlock() } } func wsHandlerSync(w http.ResponseWriter, r *http.Request) { conn, err := upgrader.Upgrade(w, r, nil) if err != nil { fmt.Println("Failed to set websocket upgrade: %+v", err) return } SyncClientsLock.Lock() SyncClients[conn] = true SyncClientsLock.Unlock() for { _, _, err := conn.ReadMessage() if err != nil { break } } SyncClientsLock.Lock() delete(SyncClients, conn) SyncClientsLock.Unlock() conn.Close() }
[removed]
https://groups.google.com/forum/#!topic/golang-dev/KXrkq0sqL-g
I think https://github.com/oklog/oklog is quite well-done and easy to read, but I’m definitely biased.
I wonder how quickly we'll get something like React bindings with WASM. I know, WASM immediately doesn't have DOM access, but Neelance himself mentioned in the Github thread for WASM that apparently a bridge is currently possible. I say that, because soon I'm going to start looking for, or making my own React bindings from Go. My plan was to use Joy with a limited Go feature set - since that would be a more direct binding than something like GopherJS, and I imagine more performant. However even if I use Joy, my plan was to abstract the design heavily from Joy so I could hopefully swap in WASM asap. Note, React may seem a bad fit for Go, I get that. I actually wrote a React binding for GopherJS ages ago, I get it. The reason I'm proceeding with React and not writing my own, is because I want these bindings to work for *ReactNative* as well. So I can't really just write my own DOM library, I want React Native to work. Awesome days for Go are coming though, regardless :D
Aren't GopherJS' days numbered with the existence of WASM? I get that DOM/interop is not easy with WASM *yet*, but once that's added fully, isn't GopherJS a dead project?
Or perhaps his $PATH is finding another `go` installation before the one in `/usr/local`?
Good guy Richard, man behind gopherjs and graphql-go
Yeah that actually sounds more likely.
&gt; Go’s garbage collection is fully supported. WebAssembly is planning to add its own garbage collection, but it is hard to imagine that it would yield a better performance than Go’s own GC which is specifically tailored to Go’s needs. As an aside, I wonder if in these situations we'd want to ship two different compile options. One using the WASM GC, one using Go GC. The reason WASM is going to ship with a GC of it's own is *for* GC'd languages, thereby reducing data they have to ship inside WASM binaries. Supporting that goal seems meaningful for Go - even if performance suffers _(hopefully not too greatly)_. Likewise though, some applications will want the runtime performance over load time - so supporting both seems important.
Thank you kind sir! Much appreciated. 
Yes, javascript will still be there. Otherwise the size of your WASM binaries will simply blowup if you have to insert the entire js runtime along with gc.
Nice and clean code. Looking forward to trying it out. I'll let you know.
Alexa says the two sites mentioned each have less than 2 visitors per day. Is this what the blogger considers high traffic?
&gt; The reason WASM is going to ship with a GC I'd wait until this happens before even pursuing it. WASM GC proposal hasn't moved much.
There's a lot more Gophers on https://gophers.slack.com where you can get help on almost everything. Give it a shot next time.
The problem with GopherJS though is that Go doesn't map too nicely to JS. Certain features end up producing *very* bloated JS files. So the arguments for using GopherJS over WASM are quite limited right from the start - and as the Go WASM implementation improves, I imagine GopherJS will continue to be less and less attractive. Keep in mind that GopherJS is not a 1:1 mapping to Javascript, so really GopherJS is sort of implementing it's own runtime, effectively making it a mini WASM on top of normal JS. So while yes, WASM is not a replacement for JS, GopherJS is not really JS - it's like an alternate WASM. Go's Joy would be a better example of something that should stick around even in the face of Go-WASM. Joy at least attempts to map closer to 1:1, suffering less of the performance hit and code explosion that GopherJS suffers from.
Thanks. Will check it out..
 $ grep '^windows$' /usr/share/dict/words Yep, that's in there too.
"Complex", a word you're using a lot here, is very non-specific. Features like transactions, data integrity, and schema need to stop being viewed as "features", let alone "complex" ones. To any company or application that has operated at scale, these cease to be features and become a requirement. The only requirement, in fact, that directly contributes to your ability to manage your clients' data with near 99.99% confidence that one of your developers didn't forget to cascade an update/delete, forget to manually (yes, it's manual) rollback a change given an error (because they have no idea what a transaction even is), and ultimately serve impure data to your customers. I feel extremely comfortable saying this too, since I also started from the NoSQL side of things and had the same approach you are defending. It wasn't until I had evaluated, implemented, and finally lamented the decision to use NoSQL from the beginning. For posterity of the thread: - If you care at all about data integrity, don't start with NoSQL. - Can you use NoSQL for personal hack projects? Absolutely. - Is NoSQL easy to setup and dink around with? For sure. If you are evaluating a database for your business, app, company, [insert anything important], and you are not concerned about these things, then you're likely not concerned about your users' data and in turn are being careless with the future success of your company on at least a few levels.
Nice but I never really understood the need of such tools with Go, with me it's always "just run the latest version of Go". If a new version comes out, within a week I am already using it and not looking back. Maybe that is a bit naive, but it's never caused any problems for me. All of the years I have used Go, I've never had to go back to an older compiler to compile something.
Yes, sounds like it. What puzzles me is his apt version was reporting 32 bit but his tar is 64 bit. So what is his platform?
Similar to how SQL does indexing, right? :) 
Thanks. I think the document should mention the author :-)
Shoot, can't wait for a Full Go stack, with everything from back to front done entirely in Go. Seeing as interop with Javascript is being done as Syscalls, we can probably have some libraries that let us create UIs from Go, maybe without the need to delve too much into HTML. Just sort of abstract the UI. Well, I guess we'll see what works and what doesn't once it makes it into the compiler.
Purpose of those things is to update with one command in terminal. Also you might want to have LTS and beta versions installed both. 
&gt; Certain features end up producing very bloated JS files I don't see how wasm makes much difference there. The issue isn't JS, the issue is everything in the runtime adding up whether it's targetting JS, WASM, or a native executable.
I should start learning GO
&gt; forgetting to use pointers A lot of people that using pointers makes your program "cool" and you feel like a real "software engineer". In practice, pointers do not give the best performance always. Run `gcflags="-m -m"` and see for yourself. Sometimes, it is better to put things on stack. The stack is fast and cache-friendly. As always YMMV.
Could you suggest what can be improved upon?
Love reading Chinese!
A tip: if you are gonna set a single book variable, it's easier and cleaner to use the atomic package and set an int32 variable to 1 or 0, it's easier to set and read than using a mutex.
Google
&gt; I want to explore hyper ledger Sounds like you need to explore bash first. Gotta walk before you can run. Seriously, if you're getting lost just installing the toolchain, you're still going to be lost once you get installed. Please, stop wasting our time, and make better use of yours...
 which go You don't even know what you're running... 
This is certainly what I use on Linux. It works very well and is simpler than even a ppa since you can switch versions back and forth with a single command. I have no clue why anyone would downvote you.
I find gvm to be the fastest way to get the newest version. It's also for people who might want to try a release candidate but keep developing in the stable version.
I don't think getting too far away from HTML/CSS is going to be viable anytime soon (it would require a lot of work), but having React-like semantics is definitely very viable. In case you haven't already seen it, it's good to know about [vecty](https://github.com/gopherjs/vecty#readme).
What advantages does React offer vs using web components?
I don’t know what you’re referring to by “web components”, so I can’t compare them.
Javascript and its ecosystem were never meant to support the now days application average complexity of applications. Large and very large applications are a PITA to develop, to maintain, to test and to support, specially when many and different people work on same project over time. WASM will allow more mature, engineered languages and toolkit to be used for frontend development. 
In this example, they could have just used the value receiver `(p Page)`. That method kind of looks like this under the hood: func save(p Page) error { ... } So `p` is just a parameter, even if it is the receiver. Generally speaking, you want to use the value receiver, but if you need to mutate the `Page` in the method, you'll want to use a pointer receiver. There is some thought that it's more efficient to just pass pointers everywhere. I'd like to discourage that. Copying memory is pretty fast (esp on the stack) and the read-only semantics you get from making a copy of the receiver is nice from a safety standpoint. My M.O. is to use value receivers unless I have to use a pointer receiver. 
Yeah, so first of all, to the part where i wrote "func save() (p Page)...", it should clearly have been "func save(p Page)" haha, I'm getting a bit tired as well. But yeah, so basically only use the pointers if there is a reason to, like if I actually wanna change the value of p, throughout the program. Thanks for the answer.
It's common to use a single receiver type when defining methods because it's easier to work with, let's say you have also have a method that modifies the receiver (in which case you want a pointer), it's more awkward to work with if you mix receivers: type Page struct { title string } func (p *Page) Title(title string) { p.title = title } func (p Page) Save() { ... } To call `Title` you need to obtain a pointer, or if you have a pointer, you need to deref it it call `Save`: page := Page{} page.Save() // works, however... // have to obtain a pointer to call Title p := &amp;page p.Title(`blah`) // have to deref if you have a pointer, to call Save *p.Save() Whereas if all methods have pointer receivers: type Page struct { title string } func (p *Page) Title(title string) { p.title = title } func (p *Page) Save() { ... } You just always instantiate as pointer, and can call any method: page := &amp;Page{} page.Title(`blah`) page.Save()
So I am new to go, but I thought the primary reason was one of memory consumption. I dont recall now but I thought go uses small stack sizes and thus passing by value could result in a large struct being copied on the stack.. or worse, if this were a service handling 1000s of simultaneous requests (e.g. API endpoint), all that copying would quickly consume memory. I may be off on that.. dont shoot me. However, typically I would think passing a 8 byte pointer, even if you dont plan to change anything about it, would be so much faster than copying the structure to the stack for each invocation. For me, it is about being consistent in my code, just in case it is going to be used in ways that I am not aware of. But then, it really depends on the code too. I typically work with high availability and scalable server architectures, so things like speed and memory are very important to be aware of. 
I don’t quite grok what web assembly is.. is it a binary format that runs in a web browser?
Golang 1.9. I know I am ignorant...but need to start somewhere. 
Thanks for your kind words. I will explore bash. I have been a technical manager for some time and want to explore a use case in insurance on hyperledger, so I am trying my hands on this. I know I may not be doing this right, but over multiple iterations..I hope I will figure it out. As of now I am lost. But as a kind man once told me, it is better to be lost than be struck. 
Ok..my machine is 64 bit and I was installing 64 bit go, but by mistake I have installed a 32 bit version of Ubuntu. I will uninstall 32 and install 64 and check. 
two points 1) it has to do with 'destructive' functions, ex AddOne(&amp;SomeVarThatIsEqualTo1) does the next time you use that object give 1 or 2? . if you pass a pointer next time that object can be 2, otherwise its still 1. (funcs get copies of variables by default) 2) 1, and for method chaining you have to return a pointer to the new object, ex: `SomeStruct{ 1, 2, 3}.DoSomeAltering().map(fmt.Println)`; you have two ways to get the right answer / and the correct functionality: Return a new object every time or pass a reference ( `(p *somestruct)dosomealtering()` ). (when you pass a reference if it modifies the object its called a destructive function);; but you could just return the new object every time. (so its like skipping 'return newobj'. a little less typing, but makes more sense when u write fucntions like 'removeItemFromArray')) 
His platform is Ubuntu 32 bit. Which is a mistake as the hardware is 64 bit. Changing that now. 
Modern Javascript is not nearly as bad as it used to be imo. There’s still some places where it falls short but it’s not a PITA to work with anymore with everything ES6 brought + async/await.
https://developer.mozilla.org/en-US/docs/Web/Web_Components
The issue is that there isn't a request. I want to 'push' it to the site every few seconds, but I don't have a value/file to 'push' because I can't get the new value on the server. That's where my issue lies. How can I get this value and only the value to the client every few seconds?
Actually, passing structs by pointer should be your default and you should only pass by value if there's a good reason to. With correctness in mind, it's more frequent to have a bug because you thought you modified the struct in a function but you didn't (because you passed a copy) than the other way around. With performance in mind, passing by copy is expensive. Not for an individual copy but if you make copies for every function call, those will add up very quickly, especially if you call such a function in a loop. The executable will be bigger (because those instructions to allocate a new object and copy the data are not free). 
Also, look into Lin Clark's amazing series - https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/. It's the best introduction to WA out there.
Oh, I'm not the one who asked the original question, I just linked to the web components docs on MDN for you since you wasn't aware of what /u/shovelpost was referring to.
Websockets or a separate http endpoint that returns only the value and poll it via a timer?
Have you looked into websockets? https://godoc.org/golang.org/x/net/websocket
I've started using server side events to push data to the client and plain old javascript XMLHttpRequest to push to the server. Basically, the server never closes the connection and periodically sends data to the client on the open connection. Check out the source code of this for how to do it: https://github.com/kljensen/golang-html5-sse-example
You can also use `go build` with the `-i` flag to put compiled libraries in `$GOPATH/pkg`.
From the linked [Roadmap](https://github.com/golang/dep/wiki/Roadmap) &gt; Once dep is absorbed into the toolchain, transforming GOPATH becomes possible Thank heaven that did not happen.
what a great link!! she even covers JIT. excellent thank you so much!
Go passes arguments by value, so if you want to modify a field in a struct, you'll need a pointer to the struct. Otherwise you'd modify the field in a copy of the struct, so nobody'd see the effect.
nice but 9 tests ...
Ah, I didn’t notice, my bad. :)
I've found that web components solve the majority of the problems you mention.
In Java all objects are accessed by reference (aka by pointer). There is no choice about it. In Go you have the choice.
Again the [usual culprits](https://caniuse.com/#feat=eventsource).
Quick answer: Because you need to modify Page.Title. [Not so quick but more informed answer.](https://github.com/golang/go/wiki/CodeReviewComments#receiver-type)
The link is great but Save() does not modify anything.
Sound very much like the opinion of a guy who's frustrated with JS. I don't see how it could die , npm is the biggest ecosystem that exist. Compiling to JS is just the type of the iceberg. Also JS is ranked has been ranked as the most used language on stack overflow for the past 5 years . The idea that WASM will kill all of a sudden JS because you can compile to JS is irrelevant . Dart and Java have compiled to JS since forever , didn't prevent Angular and React from becoming what they are today.
Very cool! I really like Pocket as a product, but this looks like a really good alternative to keep bookmarks locally. Would be interesting to see a browser plugin for it, as well. These are the sort of projects that I consider interesting when you want to learn a programming language: Simple in nature, more complex as features go. Kind of tempted to do one of these myself :).
only problem I have with pocket is that when filtering by tags, you have to choose tags from a list, instead of searching for tags, which is kind of stupid. Considering I've created a lot of tags and the list just gets bigger, I'd definitely try this if it can do that. Actually even if it can't, at least it's open source so we can add whatever. The only problem with this is that you have to manually handle a sqlite db, which sucks if you often switch between pc/laptop/phone. 
You could host the db in the cloud (dropbox, gdrive, seafile, etc). I saw a Github PR open to allow for this.
Oh you are right, my bad. I am gonna edit my post.
&gt; Sure, from almost 20 year of web dev I am frustrated with the state of JS. Okay since you have lots of experience with frontend I have a question. (Honest not sarcastic). From what I understand, Wasm is created to be complementary to JS, not a replacement. AFAIU it cannot access the dom. So can you elaborate on how it will be made possible to write frontend exclusively on a language that is not JS (without compiling to JS) using Wasm?
In the example that you have provided, you are right, it makes no difference. Except it is better to place the funtions you will use for a single type, in that type with a receiver. That is why your save function should belong to the struct. In that case for this example, because you dont modify anything, it is okay to have a non-pointer receiver. However, it is not the norm. Better have all receiver as the same type, which is usually a pointer because most functions somehow mutate the struct it belongs to.
You can access the dom with glue code today. This is how emscripten works. More support is planned for directly manipulating DOM from wasm, you can read about the proposal here: https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md
You you use Java you always are using a pointer to a Page. When you pass the pointer you are passing a reference to the same page. When you don't you are passing a copy. What performs better depends and what the struct is and how you are using it. What makes sense depends on how you are using it. If save altered the page, then you would need to use a pointer (or return a new copy of Page so you could get the change) The inability of Java to pick one or the other is a source of major performance problems sometimes. The JVM does a great job of mitigating that but it isn't perfect. 
&gt; You can access the dom with glue code today. Glue code doesn't sound so great. The way I understand it, if we are to completely replace Javascript with any language that can compile to Wasm then it needs much more than glue code. It needs to be really fast and native. &gt; More support is planned for directly manipulating DOM from wasm, you can read about the proposal here: I skimmed quickly through the proposal but I didn't find how DOM can directly be manipulated. I probably have missed it. Can you tell me where it is?
Yeah, everything else needed to create your own interpreted programming language.
People keep making projects like this (offline bookmark manager). I wish they could all cooperate and make a standard tool with a wonderful API. It's hard to choose between ~10 options -- which is what one needs to do right now. One to compare with this one would be https://github.com/jarun/Buku (1.7k stars)
Looks like you need a bounds check for the expires split that uses the tab separated split result.
Except when you're implementing an interface. Modified from your example: https://play.golang.org/p/LykTghhb68R `ChangeTitle(p)` will produce a compile error. The correct way of writing it should be `ChangeTitle(&amp;p)`
I'd suggest you resubmit this with proper title.
Yes sure. 
Auto correct at it's best.
I was wondering if you could explain what the below code does. I tried typing "ws://http://localhost:3000/ws" into my browser, but nothing happened. Is this the channel that it is sending the temperature through? r.Get("/ws", func(w http.ResponseWriter, r *http.Request) { m.HandleRequest(w, r) })
Really disappointing to see how people downvote without any reason. I'm beginner @ golang and just tried to create a tutorial for the locks at beginner tone. May be, there are flaws , but please a comment before downvote. 
What you are seeing is the same as this FAQ: https://golang.org/doc/faq#nil_error Slice nil is not the same as interface nil, they are two different types. You may want to look at something like https://github.com/google/go-cmp for your tests instead.
Good question, silly title :-)
 $ wc bigfile.txt
&gt; Is it possible to migrate into Go and if we do migrate will it be faster than django. Well everything is possible. But will it be faster? Nobody knows. It depends. Usually data indicate that [rewrites from Python to Go](https://github.com/golang/go/wiki/FromXToGo) lead to increase performance. But rewrites are incredibly complex. And for every success story that we know there might be one or more that we do not know. My suggestion is to isolate a small part of your application, maybe one that is performance critical and migrate just that. Or maybe write a new feature in Go. Then measure and learn from that experience.
It might be faster than django if your code is currently slow because of CPU-bound issues in the python code, rather than slow because of database tuning, design, queries, or other architectural issues like overly large javscript/css packages, images, and so on. So first be sure you know why things are slow. If for sure it is the python code, first think about whether more modest changes to the python could make it faster. Can you memoize things that you are computing a lot? Can you organize your data in memory better, better algorithms? But yes it is possible to migrate to Go, but a ton of work if your project isn't small, and if it was a line for line rewrite it would almost certainly be faster. 
Why not run this as a web application? https://github.com/RadhiFadlillah/shiori/blob/master/cmd/serve.go#L52
I don't think it has anything to do with popularity. Each language was designed for a different problem domain. For Go being server software. In fact if you want to be pragmatic, I don't think we currently have any strong indication that Go is a good language for building graphical user interfaces.
that is what you would write in the terminal right? what about in goland, like the actual code 
It doesn't look like you're getting downvoted to me
Actually few downvoted the moment I posted this. So I left a comment. 
Simple how-to questions like this are best asked (and already answered) on https://stackoverflow.com/a/16615559/99923
https://play.golang.org/p/8f3R0-tGu0v
According to [this](https://stackoverflow.com/questions/24562942/golang-how-do-i-determine-the-number-of-lines-in-a-file-efficiently) SO answer. func lineCounter(r io.Reader) (int, error) { buf := make([]byte, 32*1024) count := 0 lineSep := []byte{'\n'} for { c, err := r.Read(buf) count += bytes.Count(buf[:c], lineSep) switch { case err == io.EOF: return count, nil case err != nil: return count, err } } }
new relic shows that python's function call overhead is greater than MySQL query execution time
[removed]
The stellar [platform/network/sdk is ready written in go](github.com/stellar/go).
The standard library equivalent of an `assertEquals` function is to use `reflect.DeepEqual`. But recently the Tech Lead for Go on Cloud at Google mentioned that using `reflect.DeepEqual` can lead to [fragile tests](https://medium.com/@zombiezen/life-of-a-go-infrastructure-maintainer-cb1419308eb5). So... ¯\\\_(ツ)_/¯ 
I am with you here. I'd sure love for that to happen. But you also talked about being pragmatic.
I'm afraid golang stellar SDK is not the very easy to use and also not fully documented.
They just recently wrote about why they use Dart: https://hackernoon.com/why-flutter-uses-dart-dd635a054ebf
`reflect.DeepEqual` also returns `false` in this particular case.
Now that's pretty damn cool!
that would accept messages from the client, not required in the example, but useful generally
&gt; But rewrites are incredibly complex. Seriously, repeat this to yourself ten times every night before bed for a week and really grasp what you're getting into before your make this decision. You can take a snippet of Python code and port it to Go pretty easily, but that ease does not extend to porting an entire application. The package structures, norms, etc. of the languages are different and a port could require significant re-architecture, or worse, you might end up with a Go app jammed into a Python package style if you refuse to perform that re-architecture when necessary. A port can be a huge boon to your business if done well, but you need to understand what you're getting into first, because it can also kill a business if done poorly.
Well yeah because `[]string(nil)` and `nil` are different types.
Oh was never aware of, removed the parent comment. 
Lot of good answers here, but this is the official answer from the [Go Github wiki](https://github.com/golang/go/wiki/CodeReviewComments#receiver-type). tl;dr pointer shows intent to mutate, but it's also nice if you're working with big data types. 
I don't know much about new relic, but I'm surprised that it can tell you that. How does it determine that?
Okay well I am quite surprised to see that people here know nothing about web components. After reading the link you provided which states: &gt; Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data I think it's crazy that people have built an entire ecosystem around what sounds like a data binding library. I guess popularity wins. I was having a small hope that React components translate to web components under the hood but that doesn't seem to be the case. Maybe it will happen in React 2. Though admittedly I know nothing about React so maybe I am wrong.
not always. There are some problems that you really need to solve with something like C/C++ or Rust because you need that control. For some problems C/C++ is too risky with it's memory safety, for others Rust would be too hard and you would rather have garbage collection like Go, For others you really want powerful metaprogramming that Go doesn't have. and so on. 
I never really looked into dart but decided to take a glance, it looks like Dart is being designed / marketed as a [client side "UI" language](https://medium.com/dartlang/announcing-dart-2-80ba01f43b6). Based on the [language tour](https://www.dartlang.org/guides/language/language-tour) and code examples it seems like the offspring of javascript and java. I see the java 8 class based OOP mixed with a ton of the minimal syntax javascript features like closures and async concurrency. Basically the language is crammed with features and alternative syntax, multiple ways to do all the things, while &amp; for loops and so on. It's looks strongly typed with generics at a glance, but then it allows type omissions pretty much anywhere it seems: - Although Effective Dart recommends type annotations for public APIs, the [function still works if you omit the types](https://www.dartlang.org/guides/language/language-tour#functions): bool isNoble(int atomicNumber) { return _nobleGases[atomicNumber] != null; } // is equal to: isNoble(atomicNumber) { return _nobleGases[atomicNumber] != null; } So while it probably has the advantage of feeling familiar to the largest demographic of developers since you can write software in any style you want, it seems like handing this to the most unskilled demographic of developers is just asking for really unreliable, low quality software. I guess for UI systems it works out okay, let the low quality software throw and pop up an error or just ignore that event. Sucks for end users though.
I call this Quack Typing in go 
Cool write up, may want to make mention somewhere of the go test -race flag for running the race detector. While you're it may be worth showing how using [RunParallel](https://golang.org/pkg/testing/#B.RunParallel) with the race detector can really help prove a program is race free when you have any uncertainty.
Oh thanks for the response. Never heard of `-race` flag, yes will add it somewhere down the line. Also will look into RunParallel. Thanks for your inputs. 
Sweet, heres a [RunParallel headstart](https://gist.github.com/cstockton/e3ff9649cf78132735b5568d18226f88) for ya, that example shows how you can create contention among a key space with it which aligns to your example well. You can lower the **parts** slice to cause more contention (that is raise the chances that more than one RunParallel function will try to access the same part) or raise it to reduce contention. Where len(parts) == runtime.NumCPU() is a reasonable default.
[removed]
Sure , but i don't se how Go is nice fit for this. The language doesn't even have class ! Go was designed for large traffic web apps (and that's what I use it for ) , not Front End that's my point .
Are you seriously arguing that no major company uses NoSQL for anything other than personal hack projects?
Could you elaborate a bit more? How should my package structure look like? Thank you.
Are you using a Ticker (https://gobyexample.com/tickers ) or literally an infinite loop that checks elapsed time every iteration? The latter will definitely burn a lot of CPU, as it's processing that loop as fast as it can, checking the elapsed time as often as possible. With a ticker, the goroutine will be idle between the end of one loop and the next tick.
You could use this in your DB struct: // DB struct type DB struct { sync.RWMutex data map[string]string } This is more readable and idiomatic in your tx functions. You could use it like this: func (tx *Tx) lock() { if tx.writable { tx.db.Lock() } else { tx.db.RLock() } } 
I was using an infinite loop that checked elapsed time every iteration. For some reason I didn't like the idea of relying on a ticker since the tick period could change over time, and sometimes a given period would only be really execute once. 
Your gorountine is calculating the time difference with as many free clock cycles as the CPU has for it, which is why it uses so much CPU resources. Adding the sleep reduces the load because the gorountine rests but it's still just running the CPU over and over until the time has elapsed
Is that valid or misleadingly heavy?
&gt; If a program is too slow, it must have a loop. &gt; -Ken Thompson
I don't understand what you're asking. I'm not misleading you (at least not intentionally). You made a loop that basically subtracts two numbers (two timestamps) to determine how much time has elapsed. If you don't put a delay (sleep) in that loop, the CPU is going to subtract those timestamps as fast as it possibly can. Adding a sleep will reduce CPU load, but still potentially make the program unresponsive. The CPU won't be flooded with calculations, but the gorountine won't respond to your input until after it has "woken up" from it's sleep 
Right what I mean if you have many processes that have an infinite loop with short sleep periods, then surely it accumulates and slows down the cpu quicker overall? I can’t think of any other way to do it
I'm not arguing that at all. I do highly disagree with you that a majority of companies or services in the cloud (or not in the cloud) don't store relational data. Take a look at any app on your phone, any cloud service you use, or any sass product you subscribe to and it's more than likely they rely relational data. I actually agree with you that there are companies using NoSQL at scale. But that doesn't mean that it doesn't come with tradeoffs. Those tradeoffs are rarely valid but just because someone happened to arrive at that rare situation, never means it's the majority use case. The amount of relational data in our world greatly outweighs the non relational. You may have your use case, and that's fine, but my opinion here is not for you, as it's clear your opinion will likely never change (unless you happen to experience the pain of NoSQL at true scale sometime in the distant future at which point this thread will have long since exited your memory). My opinion is for all of the people who are truly trying to weigh their options for what type of database to choose and happen upon this thread. To those who do, please head our advice. Take the road with the long term in mind. Choose a relational database. 
Out of curiosity, how do you normally handle globally distributed data storage across dozens of machines with a SQL server?
Not all is lost though. What we want might end up happening [sooner or later](https://groups.google.com/d/msg/golang-dev/KXrkq0sqL-g/9aZwl9U3DQAJ). ;) 
I seem to behaving difficult time integrating this into my currently existing site. If you run the server as is on github, the system page is where I want the live updating numbers. For some reason when I uncomment the new websocket stuff to try out the dynamicness, it no longer serves any of the pages BUT at least there aren't any compile errors. Somehow something is messing with the handlefunc line, I am not sure how. [https://github.com/Rampagy/go_website](https://github.com/Rampagy/go_website)
https://kubernetes.io/ https://github.com/youtube/vitess
You're saying sleep for the tick period? like sleep for 25 mins rather than sleep for a millisecond and keep checking?
If you want to perform an action in 25 minutes, why would you keep checking a time difference to see if it has been 25 minutes when you could use a ticker for 25 min? You can even have the ability to cancel the tick if you select over the ticker and a cancellation 
Is it more efficient or really the same under the hood? Will look into using a ticker on a more serious project.
It is *considerably* more efficient to use a ticker. 
A ticker is (I assume) using the OS's time interruptions, so it's definitely much more precise than anything you can possibly do with a loop.
The Go runtime has a more efficient way to handle timers: https://golang.org/src/runtime/time.go
I'm on my phone so I can't give examples, but have a careful read of https://golang.org/pkg/fmt/ , looking for the phrase "Width is specified by an optional decimal number immediately preceding the verb".
If you’re trying to do something every x interval of time, look into using a time.Ticker(). Fabulous little piece of the standard library. 
The proposal is about including GC into the spec, for the purpose of better interop with the embedder (usually a web browser), and describes the embedder defining "types" that can be manipulated from WASM, for example, the DOM. &gt;The embedder may define its own set of types (such as DOM objects), or allow the user to create their own types using the embedder API (including a subtype relation between them). Such *host types* can be imported into a module, where they are treated as opaque data types.
[Like this?](https://play.golang.org/p/kB7vOr4JgMC) foo: 123 count: 1 foo: 12 count: 2 foo: 123 count: 1 foo: 12 count: 2
As others have said, it is likely it could be faster but you won't know until you test. Also, Django isn't the fastest python Web framework anyways. It is just a convenient monolithic Web framework. Aside from performance, your deployments should become easier when migrating it to Go. Django usually requires multiple uwsgi processes to scale it out on a single machine. And it also requires a virtual environment for all your dependencies. Go will be a static binary. It also properly utilizes multiple cores so you only need one instance on the host. 
In order to align, you can feed `fmt.Printf` additional directions. Specifically, `%ABv` tells Printf to pad the value v with up to B instances of rune A. This only works with some values of A, specifically, '0' and ' ' work. For example: for _, v := range []int{1, 12, 123} { fmt.Printf("%03v\n", v) } // outputs: // 001 // 012 // 123 for _, v := range []int{1, 12, 123} { fmt.Printf("% 3v\n", v) } // outputs: // 1 // 12 // 123 https://play.golang.org/p/u9NMaHMv6sI
Hmm, interesting. I guess I'm not sure I fully appreciate the difference between type assertion and type conversion. That said, I just tried this, but in this case I need to assert/convert to an interface pointer, and it's not buying it: pResult := (*interface{})(result) cannot convert result (type interface {}) to type *interface {}: *interface {} is pointer to interface, not interface
Thanks again, will look into it!
if result is already an `interface{}`, you can just say: pResult := &amp;result
I think the thing that I love most are the tools that are part of the language. Go fmt, go test -cover are my favorites right now. 
I use viper for 2 and environment settings for 1. It's worked well
Neat
It is not only considerably more efficient to use a ticker, it is tantamount to programming malpractice to spin like the OP describes in a simple userspace program. Wow, that's a lot of electricity to waste. Event driven programming: the OS is already keeping track of time with a periodic ticker in the hardware. Let the OS wake up your program as a simple side effect of that counter and you don't waste any more electrons. Modern OSes can do things like put the processor completely to sleep while waiting and let the hardware wake everything up on time.
Any sufficiently advanced technology is indistinguishable from magic. At this point in your programming career, just accept that the OS has deep magic in it. As you learn more, it will become less and less opaque and you'll see that what formerly looked like deep magic is just simple operations. Every OS has very optimized implementations of things to keep track of time and wake processes up. It's a fundamental building block of not only the base OS, but many layers above it, including the go runtime.
I guess thats what is implemented in the current version. The lock and unlock is called by the code, not by the users. Am I missing something here?
Website should probably link to GH repo (I couldn't find that link - if it is there it should be more obvious). You should probably extract templates for the generated Go source. Good work though - keep going.
Thanks! Did you get a chance to install and run graphqlator? 
Thanks for taking the time to reply! Ah good catch. I'll make sure to add the link in there. What do you mean by extract templates for the generated Go source? 
[removed]
Yes. So is your suggestion is to provide a generic template? For example a template of what the generated structs: ``` type TableName struct { ColumnName primitiveType `json:"ColumnName"` } ```
https://golang.org/pkg/fmt/
Thanks, that helps!
What compile errors are you getting?
I don't get any, it just doesn't serve the old project files.
Would you have a problem with me rewriting this in a slightly more idiomatic manner, using a few helper libraries for rendering etc. ?
goimports is my favorite thing ever. It's crazy the amount of time I waste screwing around with import statements in other languages. With Go I don't even think about it, except for the very rare collisions.
No
I have commented all the dynamic content lines back in one by one and narrowed the problem down to this line of code. If I add the router, it breaks, if I don't add it it only serves the static content. http.ListenAndServe(":8080", nil) //r) 
I have commented all the dynamic content lines back in one by one and narrowed the problem down to this line of code. If I add the router, it breaks, if I don't add it it only serves the static content. http.ListenAndServe(":8080", nil) //r)
A suggestion: don't have buf in the global namespace. Have it as a property of the fake. This way you can run concurrent test cases and not hit a race condition.
I have created a pull request that solves the issue.
[You guys are awesome!](https://static1.squarespace.com/static/586c6e33197aeaa9094a3e42/586ddb25e4fcb578539e4892/58718c4359cc68c638b88cf1/1483836488546/in+case+you+have+not+been-03.jpg?format=750w)
I've been wary of GraphQL for being a new tech, but can anyone give their brief thoughts on it? It sounds attractive to implement features fast, but at the same time it sounds scary because I don't know the performance implications, and I'd hate to end up entrenched in a technology that suffers performance problems down the road. Thoughts?
I don't care what language a bookmark manager is written in because it's unlikely I'll want to extend it. I just want one or two excellent ones with a great CLI. (Admittedly I would want it NOT to be written in Java or Javascript. Rust, Python, Go, Haskell are fine.)
Vscode has been a revelation for me. Didn’t know something like this existed for Linux. It’s a joy to work on. Especially once you set the formatting to go fmt in settings. 
its more of a conceptual standard than a specific technology, which has goals similar to OData. OData has lofty aims, but hasnt seen extremely widespread implementation. So, you can see why your qusstion is hard to answer, graphql at least, seems to have more interest at least.
I think they mean, Why not use go templates for the text generation? 
Thanks for the tip. Just googling it now and discovering these exist. Definitely going to take some time this week to incorporate these.
Freemarker, Velocity, StringTemplate, Thymeleaf, and Pebble are the general purpose template technologies for Java. They're NOT tied to HTML output. I've looked for one for Go, and I can find https://github.com/b3log/freemarker.go - but the README is anemic.
Set your ticker to the minimum interval of your event, but anytime you are polling for an event it's usually a hint that your design is flawed. You probably should be pushing the event to this goroutine from the receiver if it originates from within your program. Telling us more about this [xy problem](https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem) may get you a much nicer solution.
/s
It's great to see more and more projects based on the idea of generating a GraphQL API for your database which is similar to the following projects: - Prisma:https://github.com/graphcool/prisma - PostgraphQL: https://github.com/postgraphql/postgraphql Also it's worth noticing that the generated GraphQL API doesn't have to be used directly from the frontend but that you can easily wrap your GraphQL API to implement business logic by using GraphQL bindings: https://blog.graph.cool/reusing-composing-graphql-apis-with-graphql-bindings-80a4aa37cff5
ahmedalhulaibi, maybe you also want to collaborate with this project. Some parts seem similar: https://github.com/vektah/gqlgen
?
Ah, okay thanks. I had an inkling that I would need to dig into reflection to solve this, but I was hoping I had missed a simpler solution. That said, I'm not entirely sure I understand what reflection accomplishes that `result.(type)` doesn't... unless `result.(type)` is only returning the current type, where reflection returns the underlying type?
I felt really stupid for a second for not seeing it that way, but actually result is a pointer to an interface. One of the things I initially tried was using the `*interface[}` type on that param, i.e.: func (a MockAdapter) Find(id string, result *interface{}) error { But then it complains about the values being passed in: cannot use &amp;foo (type *Foo) as type *interface {} in argument to adapter.Find
&gt; The Bitcoin algorithm releases some Bitcoin to a winning member of its network every 10 minutes, with a maximum supply to be reached in about 22 years. Has something changed that I'm not aware of? I thought the max wouldn't be reached 'til over 100 years from now.
+1 for viper. 12 factor app is a good approach to configuration in general.
What does that mean for Go though?
Yikes, thanks for the catch! It should have said 122 years. It's been corrected in the post.
I think they are referring to the softcap because rewards will be like 0.2 per block. 
Small it is, fast not so much.
Run a Miller Rabin test with 2, 3, 67. You can get much faster. Math/big is designed for big numbers like 10^100 or more. For that purpose, it has many overhead when an int can contain the value.
Why is DKIM/DMARC "intentionally not supported"?
I enjoyed this article, thank you for sharing it with this golang community. the explanations and code were easy to follow along with and I feel like I learned something. I have a few follow up questions after reading, maybe someone can answer them. in the article's example proof of work, the block chain is comprised of BPM measurements. what is actually stored in the block chain for Bitcoin? is it possible to be awarded partial bitcoins for mining efforts? i.e., if you have just one machine attempting to complete proofs of work, I doubt it would ever finish first in finding the right nonce to get the right number of leading 0's vs. higher power dedicated mining setups. does that make single machine mining worthless? or is there a way to be awarded a small portion of the newly released coin that is proportional to your efforts? thanks!
Oh man - golang .NET sounds like an abomination I never want to know.
Your function will (practically) never finish for any cryptographically significant prime. That ProbablyPrime function is there for a reason.
1) Most of the data that's stored in a bitcoin block is a collection of transaction data that's lumped together. Have a look here at this actual block: https://blockchain.info/block/0000000000000000062e8d7d9b7083ea45346d7f8c091164c313eeda2ce5db11 2) No you don't get partial bitcoin for your mining efforts. It's a winner-takes-all approach and whoever solves the hash for a block receives all 25 Bitcoin (the typical reward). You can, in theory mine on your own PC at home but the amount of electricity you'd consume would far outweigh your reward in Bitcoin. You would in theory eventually solve a proof of work ahead of other high power rigs but it would take so long it wouldn't be worth the cost in electricity.
If it's just the complexity of implementing, I wrote a DKIM signer/verifier in Go (github.com/driusan/dkim) so that I could use it on Plan 9, and then discovered that as an external hook it works fine for verifying, but because of the specific place it needs to happen (after transforming line endings, after every header that you want to sign is added, but before dot stuffing) hooks don't work very well for signing. (I thought of writing an SMTP server in Go as a result, but it's been low priority and I haven't gotten around to it yet..)
&gt; I'm happy to hear arguments in favour of doing so One argument would be: to have a mailserver server that does all sane things out of the box. I'd also love to see ACME support natively without certbot, that would make putting it in a container a bit easier. Dovecot communication should be over a unix socket afaik, so that shouldn't be a problem.
I'll argue that you can have a reasonably sane _small_ mail server without DKIM, and is one of the reasons why it's not been a priority for me. Unfortunately also requires complex setup outside of the mail server domain (all the cert and DNS dance is non-trivial for most people), which personally I think it's a shame. And I definitely agree with you about doing "sane things out of the box"! Native ACME is on the list. Dovecot communication indeed happens over a UNIX socket, should be fairly straightforward to set up: the how-to doc has the dovecot config snippet, then it's a one-liner for chasquid (which may become the default in the future). It's quite new, so if you give it a try, I suggest building from source (and please let me know how it goes :). Thanks!
Setting up DNS is necessary for signing DKIM, but not for verifying. For verifying you just need to make a DNS query to look up the public key.
Re: Proof of work, people generally join mining pools to combine hashing power and make earnings more consistent. The difficulty (the number of zeros you need to find) is adjusted so the shares you submit aren’t likely a new block but give an indication of work done so the pool can give out the reward fairly. 
Well, it's useful to learn how other people added a non-gross generics system.
GoScript .NET EE
In addition to faiface's point, which I generally agree with, bear in mind that on most if not all of the architectures Go runs on, you are _guaranteed_ that time is not necessarily that accurate, because your code can be preempted by the OS at any time and starved of resources by the OS too, which is to say, there's no guarantees when you'll swap back in. The usual response is to just say that if the program encounters that situation, you'll do your best and the user will have to deal with the fact they're starving it of resources. If, for some reason, this is truly unacceptable to you, because for instance someone could die or be injured if that happens, you need to take some very serious steps quite soon to deal with that, because Go is not even a suitable tool for a hard-real time task like that. The term to google is "real time operating system". By far the most likely scenario is that you're in the first case, and you should just relax a bit about temporal accuracy... can you really notice whether the code ran 10 microseconds early or late? But if you are in the second case, it is vital that you take the proper steps immediately, one of which is to not use Go.
Not a Go programmer at all but I found your explanations simple enough to understand and your code was not that hard to understand. Overall I would say it was a job well done and thanks for putting it together 
There are definitely some similarities. I have been planning on doing something like this for graphqlator+gqlgen: * Use graphqlator to generate the gengql data model in the types.json file, along with the necessary GORM tags &amp; overrides * Use graphqlator to generate some basic queries/mutations in schema.graphql * Run gqlgen * Implement the resolvers interface generated by gqlgen - I think this one will be the tricky part. I only saw gqlgen a couple weeks ago when it was posted in this sub. I already have plans to make it an option in graphqlator, hence the `gen_mode` in graphqlator-pkg.json. I have not yet tried gqlgen to be honest, but their examples are straightforward and I'm certain it is possible. 
Why did you make this? I'm genuinely trying to ask (not trying to be rude). 
This. 
WHelp, guess we better shut the subreddit down. It was fun while it lasted.
Kind of an odd comparison. Comparing [go and javascript](https://trends.google.com/trends/explore?date=all&amp;q=%2Fm%2F09gbxjr,%2Fm%2F02p97), you could say that "go is overtaking javascript."
Definitely
What? Go and node are both backend focused. JavaScript is front end mostly. 
Yes, because this trending result say nothing.
It shows go's popularity in terms of web searches has been in decline 
To understand your motivation, the goal of the project, if you're trying to solve a problem that other smtp server's don't do well.
Node *is* javascript. Comparing Go and Node is like comparing Spring Boot and Python.
Sure, I hope my answer covers that at least partially, let me know if you have any other questions!
But only node is backend specific. Get?
You know emacs has this built in. And even adds a `NOTE` highlight. ;)
I very rarely google Go issues these days, godoc on localhost and cd $GOROOT/src is pretty much all I need to write Go code for days at a time. If you prefer Javascript over Go though that's cool, here's a [video](https://youtu.be/H8u6YTg-Vm4?t=10) you might light, maybe it can be used as a angulareactional MVC somehow with the right transpiler if async is fully scaled up.
This isn't nearly done yet.
Anyway go and node compete for the same mindshare. 
Go also compiles to JS so it can be used on the frontend.
Ok so go has shown frontend use via gohoerjs. But still beaten by node which is backend only
Hey Peter, what are you planning on using this library for? I see most people gravitating towards raft instead these days since it's simpler. I'm interested in why you're implemented Paxos instead.
Surely people write codes in search engines.
That’s a sign that “go doc” does a good job. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] ["Go Internals" first chapter, a "A Primer on Go Assembly", released!](https://www.reddit.com/r/programming/comments/824cki/go_internals_first_chapter_a_a_primer_on_go/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
This isn't true all the time. I use node and Go in unison all the time. I use node when I use Tailwind CSS, but that isn't backend. It is a css framework generated with node tooling. I use node to minify and package my js and css for web applications written in Go. Go buffalo projects have webpack setup by default, because node is incredibly useful for asset pipelines. There are situations where the two truly compete, but there are a probably as many if not more where they don't.
https://trends.google.de/trends/explore?date=all&amp;q=golang
This looks interesting, bookmarked (: 
This looks interesting, starred!
Try searching golang and go programming language at the same time.
hey Peter, curious about your reasons for implementing Paxos rather than Raft? Do you have plans for this library? :)
[removed]
Pretty cool, thank you.
So when will the money train arrive at my home? :-D
Node.js overtook Go slightly for 2 months! Gasp! The end is nigh!
you seem to be able to see the light just like @peterbourgon
[removed]
Yeah. I also estimate that with vgo and wasm support coming in Go 1.11-1.12 there will be a rise in Go's popularity.
&gt; pular in countries having developed IT industries: the USA, China, Russia. Countires what typically consume products, not made them prefer Node.JS try golang and go (programming language) together and you will find that Go beat golang by 10x.
 JS uses Prototypal OOP right from outset. It doesnt do Classical OOP. The class U see in es6 is just syntactic sugar. 
[removed]
I don't think it has been submitted yet. All the proposals have been public up until now. Last I checked Russ was trying to figure out how to incorporate vendoring in vgo. So maybe this has delayed the proposal.
Fair enough, I'm sure it'll pop up here somewhere once it is submitted. Vendoring has been the biggest issue I've seen people talking about.
Nothing.
Yeah. Russ has listened to the feedback and tries to do some changes. I don't know if they will make it or not. His paper made it clear that vendoring was not part of the plan. I am trying to find the relevant golang-nuts thread.
Well yeah, as you most likely already know: &gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses. &gt; -Bjarne Stroustrup
Great article! Thanks for putting in so much effort 🤩
NB: This isn't the original Paxos but CASPaxos
&gt; (Note the //go:noinline compiler-directive here... Don't get bitten.) Love the style. No BS, straight to the point.
You realize there is a popular board game called Go right? Do you also realize that this game was in the news several times in the past few years? Google trends doesn't know if go is Golang or go the game.............
U can specify go the programming language. That is what I have done! Lacking in attention to detail mate.
I just started learning Go and the biggest MINDSPLOSION for me was 'GOOS=windows_or_whatever go build'. Magically cross-compiling with no effort whatsoever? ungh In related news, I too love Go so far. 
Oh yeah, that's it! Sometimes I confuse golang-nuts with golang-dev :D
Awesome, a "primer on Go Assembly" is *exactly* what I've been on the lookout for! Sure, I can read &amp; grasps the 'basics of asm' elsewhere, but just handy to have a Go/pl9-specific reference for the rare few times one does want to dive deep into the topic without leaving the Go toolchain. Looking forward to reading
One point to note. . . Python and Go work quite well together. I've moved to doing some projects in Go instead of Python but for me, Python still hits a sweet spot or two that Go doesn't (small scripts for example) and. . . it's much nicer writing binary modules for Python in Go than in C.
C# has one of the nicest to use generics implementations. It is pretty easy to understand, to write, runtime performance is good, and I haven't noticed it causing obvious compile time issues either (though perhaps it can with abuse). if Go ever wanted to add generics, it would be a good example to look at. 
- https://github.com/topics/node - 7k - https://github.com/topics/go - 10k - https://github.com/topics/javascript - 60k 
&gt; though perhaps it can with abuse It's definitely possible, see http://mattwarren.org/2017/11/08/A-DoS-Attack-against-the-C-Compiler/ ;-)
&gt; Last I checked Russ was trying to figure out how to incorporate vendoring in vgo. So maybe this has delayed the proposal. AFAIR he was on vacation last week, delaying the proposal. And this week has only just begun.
Stay in school, work hard, eat right and get plenty of sleep and you'll achieve all your financial dreams!
I don't think that Go is that hard to learn, quite the opposite.
You already commented on my post explaining how Node is not “backend only.”
They also do not. There’s a myriad of reasons why they don’t, but you’ve decided how you feel.
Indeed, I'd mentioned it in the original post. I was just wondering if it had already happened because of the very definite wording regarding vgo being merged at a later date and replacing dep.
* https://github.com/topics/golang - 16.5k
Awesome read. Can someone explain this bit to me? I'm curious about why this is dangerous. &gt;The NOP instruction just before the CALL exists so that the prologue doesn't jump directly onto a CALL instruction. On some platforms, doing so can lead to very dark places; it's common pratice to set-up a noop instruction right before the actual call and land on this NOP instead.
Naming this the same ("autocert") as the "official" https://godoc.org/golang.org/x/crypto/acme/autocert seems unnecessarily confusing. 
From a quick look, it doesn't appear that OP's new package does anything special over the `acme/autocert` package in x. My own use of acme/autocert has looked almost exactly like the usage in OP.. I'm wondering if there was a reason this new library was developed.
Cool, thanks. I'll keep an eye out on that issue.
Valid point! Will rename the project tomorrow 
We used autocert, but had lots of issues with it. It failed to obtain certs, and in one case screwed up renewing a certificate. After some debugging we built the functionality with the LEGO acme client 
I've created the page as a resource for people that want to have a quick overview of vgo. However, after reading, and re-reading, Russ's posts as well as seeing this thread I can say two things: - I never had the intention to overcommit/mislead anyone. That is my current understanding of Russ's posts - if someone else has a better way to reword this, it would be very much appreciated. Maybe it's my inability as a non-native English speaker to better convey Russ's intentions / status quo. As such, I do apologize if this is misleading, please feel free to either make a direct edit of the page and improve it, or send me the suggestion and I'll make the changes as needed. Thank you.
[removed]
Could you elaborate on that? The other users of autocert might benefit from a couple of bug reports if possible.
Thanks for giving it a try! I had not heard about gopistolet (and I did look for similar projects before I began!), I will definitely take a look. I regularly do fuzz testing of some of the key and more exposed libraries (like spf, auth, normalize) but have not yet done it on the protocol itself, it's a good suggestion. That reminds me I need to clean up and submit the existing fuzzing tests!
And the near cultish reverence of the language
The page was edited by someone else, but yes, I think it looks much better now. Thank you for feedback!
Great, how am I going to convince my company that I need to go to Iceland, when there’s going to be one right here in London :sadface:
Funny this is exactly what I was looking for. Also does anyone know to get raw bytes without the runtime. The object file left over seems to be a go specific file with the instructions embedded. I would prefer a standard obj file if I could so I wouldn't need to use the go runtime.
No. Look again at the post I replied to. You thought you installed 1.9, but you don't understand why you still see 1.6. That's because you have no idea which binary you're running when you type "go" at the shell... You're wasting our time here simply because you haven't bothered to do the most basic troubleshooting yourself.
lol no generics
And, no, 32 vs 64 bit doesn't matter here.
They literally just took every single Golang course on Udemy and copied their description... Great list...
Only works with unix line endings, though. `bufio.Scanner` works with arbitrary line-endings. (yes, I too find it stupid that we still have to care about nonsense like this…)
FTR: Quote from OP &gt; so the true question is: why (by design) is the value in the interface wrapper a copy, not for example pointer to the original value? Exactly what my strawman-proposal was formulating. And yes, it'd still be perfectly possible and type-safe to do. But Go has no references.
You can receive the location of the templates through a flag or environment variable. One of the first things you should do when the application starts is to attempt to open the location and cache the templates as shown [here](https://golang.org/doc/articles/wiki/#tmp_10). If the location is wrong, simply do not start the application.
&gt; Not my solution. But your comment =þ &gt; Maybe you should reply to the SO thread. I'm one of those peasants with &lt;50 Reputation and can't comment ^^ For realz, tho, wasn't trying to criticize :) Just to clarify why it's not really an apples-to-apples comparison for bystanders :) Sorry for not emphasizing that enough.
Yeah no problem. To be honest I didn't even read (carefully) the problem (or the solution). I was just trying to be helpful and posted what I found from SO, as cheap as that was. I have no idea why the OP didn't google first but whatever. It doesn't matter anymore as the OP apparently deleted this. ¯\\\_(ツ)_/¯
Everybody should stay tuned for Florin Patan's next UK Conference, where we will be learning about "println vs printf speed".
didn't know about CASPaxos, thanks
Same here, I would love to find something like the big nasty behemoth Date::Manip from perl. Stop laughing. 
Admittedly, the fact that I want a pointer to an interface is a pretty big red flag to me, but I guess I don't quite see another way to accomplish assigning back to a parameter. Instinctively, I'd really prefer the method to look like this: func (a MockAdapter) Find(id string) (interface{}, error) But that becomes an issue with mgo, because it means the actual adapter method won't know what type to pass to mgo and (I believe) it won't be able to unmarshal: func (a MongoAdapter) Find(id string) (interface{}, error) { result := // ... something? err := mgo.Find(bson.M{"id": id}).One(result) return result, err }
I Googled around a bit and found this: https://github.com/olebedev/when There really isn't many libraries to do this in Go, there are way more available in JavaScript.
I haven't used this (just found it on Google), but it looks promising: https://github.com/olebedev/when
From my experience the reason 'unmarshal' style methods take in the result parameter is because they want to caller to remain in control of the concrete type. `func (a MongoAdapter) Find(id string, result interface{}) error` allows the caller to pass in a struct of any type or even a map to "collect" the data. `func(a MongoAdapter) Find(id string) (interface{}, error)` forces the caller to handle extracting data from the returned `interface{}`. I'd re-write your mock adapter like so: ``` type Foo struct { ID string } type MockAdapter struct {} func(a MockAdapter) Find(id string, result interface{}) error { value, ok := result.(*Foo) // If you know that your test will only ever pass in a *Foo if !ok { return fmt.Errorf("expected result to be of type *Foo, got %T instead", result) } value.ID = id return nil } ```
Yeah, that was my understanding of the unmarshal style, as well, and exactly why I was trying to replicate it. But, PERFECT. This was exactly the piece I was missing! switch result.(type) { case *Foo: value := result.(*Foo) // assign foo values case *Bar: value := result.(*Bar) // assign bar values default: return fmt.Errorf("Received unknown type %T", result) } return nil Works like a charm! Thank you so much for the help!
I would go one step further like this: switch result := result.(type) { // notice the assignment happens here case *Foo: // use result as *Foo case *Bar: // use result as *Bar default: return fmt.Errorf("Received unknown type %T", result) } return nil It's just a shorthand that does the variable assignment for you. You are very welcome :) 
Fair point. How about: they're a couple of months and several hundreds km apart and since we're such a fast moving field, one needs to be allowed to attend both? ;)
so...is this like grpc? go-kit? SOAP? i can't figure it out
Everyone has their favourite editor.
I'm confused, inside Run function *handler* was used instead of *uc*, as in handler.DB.QueryRow, handler.MailingService.Subscribe, handler.Emailer.WelcomeUser func (uc *UserCreator) Run(email, password string) (*User, error) 
If you have any benchmarks on your implementation vs stdlib that'd be great in the readme
This is fantastic explanation, I've been doing a lot of blockchain stuff over rpc learning all the json post and gets and how pools work recently but mainly all in python, i'm going to try use what you've put in here to adapt to the testnet of a coin i'm part of to get it working. Thanks!
What is substantial? 2x? 10x? Yes people want numbers. All benchmarks are misleading so you can just post them and assum tge reader knows YMMV
Why? 
Sorry, I really don't feel comfortable to make a more precise claim than "sometimes more than twice as fast" in a brief README file. However, the original article https://www.nada.kth.se/~snilsson/publications/Radixsort-implementation/ does have some measurements and a fairly detailed discussion. It's a bit old and it's a different implementation, but the results should tell what to expect. 
A typo. I wrote the code in markdown since it wasn't copy/pasted from a real app, but was only based on one. I pushed a fix.
[removed]
"Even C"... lol
Years of being a C# developer, paired with now years of being a golang developer - like so many others, I'm sure.
thank you, I also thought they're just typos. I like every bits of this repo [1]. I don't know if it meets your *service object pattern* but the package layout, the design of Store interfaces to support multiple storage backends, the authen service, api handlers etc. looks clean and easy to follow. Kudos to the author for he built that app while learning Go. [1] https://github.com/disintegration/bebop
Love the work you're doing. Makes it upsetting that there's no way to follow an organization on GitHub
It's the same now. https://trends.google.com/trends/explore?q=Golang,Nodejs,Go%20code,Node.js But even so, there's a lot going on here. When I do searches I use "go code ..." Plus, if a language has a lot of set ways of doing things it will be searched more. I feel like in go I have more control so unless it's something I have never touched before, I tend to not have to search it.
It's not a codec, rather a cgo wrapper around visualon's aac?
Right, AAC codec encoder, based on vo-aacenc. C code is included in package, but you need cgo.
I guess I have a fan. Can you imagine the time and effort that's wasted in this?
&gt; This makes it seem like vgo is an absolutely definite thing that will be happening. The odds of it not happening, even if the entire community were against it, are about the same as the odds were for community opposition preventing type aliasing.
So you invent a new format of configuration? Care to write a spec about it?
Pretty solid. It can get work done. Though it is too small to talk about design. One thing is that you are not handling or returning errors, though your API signature says you should. It is okay to just panic everything in small code like this, but it would be a better habit to at least return errors. Another thing is I think `printFile` should be sent to print tree, instead of addSubNodes. Responsibility. Oh and you seem to use too much onecrime variables. It is pretty fine to just use `DirTree(os.Stdout,"tmp",true)`
Wouldn't be easier to use `func Walk(root string, walkFn WalkFunc) error`
There's no value in having just the one file. In fact, there's an extremely negative value in having zero test files. I would also be extremely suspect of a library where someone followed the author's advice of "You can just drop one_file_pdf.go into your Go project."
Looks interesting but Unicode is important (I'm Russian and I can't use your library because of that). Go itself was build with Unicode in mind as all modern languages - I believe libraries should be too.
That's not how Google Trends works. Even if you do so, the results will be less informative than just using Golang. A better method is Github statistics.
Project was renamed to simplecert, please update your imports...
Привет! I will definitely add Unicode support, though the file may be get slightly less "minimalist". I totally agree that supporting files are important: unit tests and demo files to show what can be done with the PDF class. As it is, there are other auxiliary files already, like the single demo. I'm writing some unit tests right now.
I guess the author is coming from C. Includes and header files suck so much in C, that "single header libraries" are a real praised thing. Imports in Go are great though, so putting the whole package in a single file does more harm than good.
As short as possible still allows splitting into multiple files. Of course, both extremes are bad, too many files harms understanding, but so does a single 2k LOC file. Everything can be split into multiple, meaningful, well-named, files, such that it's perfectly clear, at the first glance, where to look for what.
Good stuff, John. Thank you!
This seems like a lot of work.. I just store my code as a plain text gibberish comment with they key hidden in the last few bytes. Easy Peasy. Some of my code has hundreds of upvotes! this gibberish: &gt;1216 points 7 months ago We're going to need at least a timelapse gif with a clock in frame of the strike and subsequent three hours here OP. For all we know, you just lightsabered the tree and posted it here under the premise of "lightning" for the easy karma! Is actually my first "Hello World!" app!
:)
Why, I suppose decent filenames help understand and navigate the code.
Got it! &gt; I’m actually a vimmer at heart so I use spacemacs Where is the ;)? :-D
And in Go ecosystem people use package as namespace. Dropping in a file is likely to mess up all private fields and other naming mechanism.
You do have a point: for example one file can be constants.go, to keep these out of the way when reading the code. Another could contain the type definitions, properties, etc. ...but then my gimmick is foiled and I'll have to find another name for the project.
I am actually thinking about grouping functions by features into files. Like metainfo.go or font.go (I know absolutely nothing about PDF but you get the idea).
Just like there's no value having the one file without a README.md, or demo.go. I'll change the wording about just dropping the file. It's a normal Go package, so the correct way to install is: go get github.com/balacode/one-file-pdf As for tests, they are very important, but I admit I didn't embrace TDD when I wrote the code some time ago, so I'm now writing unit tests after the fact. However I've been using this lib in production, where a report-generator reads data from a DB, does its own section grouping and then uses this PDF class to write its output. 
That is true, but the effect on the namespace will be you import PDF, PDFPageSizes, pdfPage, etc. All start with PDF.. or pdf.. However. I'll remove that advise. I believe in following accepted standards (most 'o the time).
[You sure?](https://trends.google.com/trends/explore?q=%2Fm%2F0h989,%2Fm%2F09gbxjr)
Unicode &amp; UTF-8 support would be an incredibly useful feature that many PDF libraries lack. I hope you succeed in adding it. Thank you a lot, your effort is greatly appreciated.
One file, who gives a shit?
The sky is blue. Who cares?
In L33, why are you checking for error ? There is no new `err` variable. It's the same one from ioutil.ReadDir which has been already checked. Also, the general convention is to do `panic(err)` instead of `panic(err.Error())`, unless you did that intentionally.
You are welcome When I was reading that spec, I got the impression that Unicode support is as easy as converting from UTF-8 string to UTF-16 and marking the string as UTF-16 but was not able to implement it and then I forgot the details.. Maybe you are more lucky. Here are some libs for UTF-16 conversion https://golang.org/pkg/unicode/utf16/ https://godoc.org/golang.org/x/text/encoding/unicode Good luck
Yes.. I remember searching about how to load the font at runtime instead of embedding it (because fonts like [Arian Unicode MS](https://en.wikipedia.org/wiki/Arial_Unicode_MS), who have good support for kyrilic &amp; chinese characters can be very big to embed) .. 
Exactly.. that would be awesome. If you find a guide like that.. share it :-)
I like it, and I'm really picky.
Data types like how time is being interpret (or not supported at all), or case sensitivity in both keys and values, or how to nest (or not supported), or how to set a key/value that includes a LF, or how special characters like "-" shall be handled in default case. The list is going to be long. And that aside, can the config even be generated back by the lib? Just read it and never write back? I don't want to discourage you but I would say this is at a too early stage to be compared with most configuration format for now. 
I don't see how this disproves anything. If anything, it shows that Google isn't too good at guessing whether a search is for the language or the game, given the similar lines.
Dude your a boss. This may be better than r's knitR if you need speed.
Use [goimports](https://godoc.org/golang.org/x/tools/cmd/goimports). Annoyance begone.
This is great. thanks
[Shixzie/nlp](https://github.com/Shixzie/nlp) Seems to [support time.Duration](https://github.com/Shixzie/nlp#supported-types). It also has [an example](https://github.com/Shixzie/nlp#usage) similar to what you're describing. Found in [awesome-go#natural-language-processing](https://github.com/avelino/awesome-go#natural-language-processing)
Is it a joke? If not, it would be great if you can share codes or algorithms. If it is, I am taking this as a coding proposal :)
Yeah, that's the bit I honestly have a hard time envisioning. Maybe run it once to come up with common words, then again to come up with close to a grammatically correct statement then a third time to "edit" out the flaws? Anyway, it would be interesting. 
As Visual Code user, I didn't realize something like this could be annoying 
Inspired by how you store you key in the joke, I think it is possible that we store some alter of word order in a few words that is sure to be common. Generate a grammatically correct sentence won't be too hard. I think there are already such algorithms in AI and auto generating texts, but maybe none for Go, but porting/wrapping codes into Go is easy. And as we don't really need it be that meaningful, maybe just change the word into correct gramma would work (like change stupid to stupidness if you need a noun). Anyway this area is well discussed, just need some research. Keep sentences related is another thing. Maybe we can set a topic on the gibberish, or maybe we can create some template with words like "so", "but", "lol" ignored. Given that nowadays computers can write novels, I think the idea is feasible. The key point is to lower the computing efforts (preferably run in browser for quick trolls) and the gibberish size (would be super cool of an image can be hidden in a tweet, but I don't think that is going to be possible).
TL;DR Don't use short declaration inside if statement when you feel it is ugly. Actually it is common sense and works for all embedded short declaration: switch, for, if. And I was expecting to see if and else on same line.
Cool, thanks!
Wouldn't all the atomic operations perform a lock on the permits counter? Not that it is wrong, just curious.
Here is a link to the code if you are feeling extra lazy :) https://play.golang.org/p/jT9cNtRAhn9
I found this talk extremely helpful: https://www.youtube.com/watch?v=rDRa23k70CU I can also recommend this as a good read: http://preshing.com/20120612/an-introduction-to-lock-free-programming/
You know, on Reddit mobile, your code in posts is literally a mess.
That's your fault not theirs. Open the link in a browser.
I was referring to the super lazy part. Was I unclear?
Sorry, if you have a better place that I can post it formatted, I would be happy to do so. I was only joking about the lazy part!
With no further design aim given, I would say current code is not bad in terms of Idiomatic Go. But I am not very comfortable with the idea of embedding a slice in a struct, though it might not be the point. However, you should know that w.Init is calling w.SamplePackages.Init. And any codes inside that call would have no knowledge about the "parent" struct, including new calls. This may cause unexpected behavior for new gophers. For further discussion, say, if you need to have some common behavior of different types, use a function that accepts an interface. If you need to keep it as a method of the type, wrap the function call. I am sadly on mobile and cannot provide codes for that. Maybe later.
Thank you so much for your time, it really means a lot! This was more like a personal exercise in using atomic instructions, but now that I have done that, I will definitely look into the channel implementation. The runtime package is used to yield the CPU time of a goroutine which is not able to obtain a successful CAS.
After taking a closer look at these things, are you really not seeing why? Russ obviously did his homework and put a lot of thought into this, then took care to put that thinking into a 7-part series of documents so that others are able to follow. The vast majority of other proposals posted to the tracker more or less amount to "I just had this brainfart and took a hasty five minutes to write it all up for you. *Bon Appétit!*" Apart from that, the alias proposal got retracted and only re-submitted for the next cycle in a heavily modified form *exactly* due to useful community feedback. While I wasn't initially convinced of its necessity, in retrospective I think the introduction of type aliases was a good thing.
Lockless lock implementation. What? Using atomic operations doesn't make something lockless. Pretty much all locks are implemented using atomic operations. You have implemented a spin(ish)lock inside. That yields on every spin. Which probably gives the same latency as a sleeping/waiting so it has no latency advantage over sleeping for the lock (which is the only dubious advantage that spinlocks have) and it wastes CPU which normal locks don't.
As acknowledged by the poster, this is not the experience report as requested by the Go team. It boils down to: &gt; I want to be able to call Map on a []T or a map[T]U (T and U are arbitrary types) and be able to transform the values into other slices or maps ( []A and map[B]C). The author goes on to show potential code snippets and explains why this would be a good feature. This is not an experience report. My understanding of an experience report is more along the lines of: "At company/project $FOO, we needed to be able to $BAR. We attempted this as seen in example $BAZ. The result was that we [had negative performance $QUX | were unable to implement the feature due to $QUUX | had to have the following crazy workaround $QUUZ]. We believe that if we had feature $CORGE, yadda yadda yadda..." To make their case better, the author could have shown actual library or application code where lots of cruft was manually added to make a map-like feature available, and then show how that led to less maintainable code because they forgot to update one of the N copy-pasta methods that were not able to be go-generated leading to downtime, messed up user records, etc. Because this is not an experience report and more along the lines of "I want generics because FP," I don't feel it brings anything new to the table. I think a great many of Go developers would welcome "Map" and it is easy to say why you think generics implemented in whatever way would be A Good Thing (tm). 
You probably want to use copy. As in copy(mySlice[3:5], []int{3,4,5}) 
Articles like this are mostly directed towards beginners, and the terminology used in the title is selected because it is how a beginner would (in this case did) phrase the question.
The following details the trade-offs of adding generics to go: https://research.swtch.com/generic Notice it was written 2009 this is a issue that has long been talked about
Also, reflection can build the APIs he's proposing, which likely covers most of the scripty ways you'd use this sort of thing. For performance you just want a for loop anyway.
I'm not sure how much this still matters in the 2018 landscape. The Go compiler is now written in Go. It's reasonable to believe it could lazily only compile and link the bits it needs. Also with cached compilation and language servers, we can imagine a world where the amortized compilation time is very low despite complexity and work being force onto the compiler. My bigger concern would be the unavoidable complexity load of generics on programmers and other tooling. Personally, I like generics but they do complicate the picture. 
When? Could you provide a reproducible example?
It is recommend you remove the PDF from the symbol. The namespace is considered part of the name, so: import ( ".../pdf" ) func() { pageSize := pdf.PageSizes("A4") } is the expected API
Fuck yeah... return type polymorphism is awesome and very useful. The current solution is to do this: func (t *Template) Funcs(fm FuncMap) Funcser But that violates a lot of independence of packages. If we have return type polymorphism, we can have that. 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/chewxy/stl) - Previous text "stl" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
There is a docker client API in go: https://github.com/moby/moby/tree/master/client
I saw the API but I don't think you can create containers with it
Thanks!
i like how the `otto` package (js runtime in Go) uses `panic` - as a simple and quick way to drop out of the js runtime and return control to surrounding code using the library. given the way the library works, it would be difficult to manage exceptional circumstances otherwise. seen this way, `panic` can be a glorified `goto`
[removed]
[removed]
Great! Let us know how it goes :-) 
There are plenty of examples of slice types in the standard library. Using the sort methods requires a slice type that implements the sort.Interface https://golang.org/pkg/sort/#Interface http://golang.org/pkg/net/#IP http://golang.org/pkg/sort/#Float64Slice http://golang.org/pkg/sort/#IntSlice http://golang.org/pkg/encoding/json/#RawMessage 
I did not recite all these code, but as far as I can tell, there are no *embedding a slice into a struct*, is there?
It's just like the case of time.Time in the standard lib. The only type you need to use is PDF, the rest are supporting types. That is, you'll hardly use PDFPageSizes. Removing the PDF prefix will make the code a bit cleaner, but make it harder using the PDF without its original module, e.g. as part of another lib because of name conflicts. For example, I use PDF in my core lib where it's in the same name space with other general classes. Just explaining my thinking. I'm also thinking of some other changes later: to remove unnecessary property getters and rename the Set...() methods. Eg. remove Title() getter and rename SetTitle() to Title(). Any necessary getters like for X, will be called GetX() etc. Then you can have code like: pdf.XY(10, 5).Color("red").Text("Hello") instead of pdf.SetXY(10, 5).SetColor("red").DrawText("Hello") What do you think of that?
I've seen this kind of "Experience Report" a lot lately. But I'm not quite sure why they are titled "Experience Report" as the do not describe the experience of implementing a real project delivering customer value. Instead these articles describe often a single technical annoyance. They are variants of "you cannot implement your own typesafe container classes in Go without the overhead of interfaces". I thought the call for experience reports was very clear and I understood it as "Show major problems in delivering real world, customer facing projects." instead of "describe inconveniences and annoyances while implementing a single package". What i'd like to read is an report like "We built product P which sells like sliced bread and where delayed by missing generics by 6 month: We tried A which was too error prone, B which was unusable in practice, C which was too slow and D which had that kind of issues. Our final solution was S. It would have been that simpler with generics because R. Here are the details...". I'm not interested in the problem of a single package author. But maybe that's just me. 
I've had the impression that you use interfaces as function arguments, and types as the return. For such situations, I return an empty Interface.
https://play.golang.org/p/qI3RfonHm2C
Hay Im searching for a helping hand for my sweet little project. I'm have no experience with groupwork so maybe we can learn from each other :) I send you my project with PM.
i'm interested too! been doing Go for 7 months now, and seek prominent/interesting to contribute to! if anyone has great ideas
https://gitea.io/en-US/ Is a really n1 Project
You can use metaparticle : https://metaparticle.io/tutorials/go/ than can create containers and even kubernetes orchestration requirements.
It is not easy to help you since you are not describing the problem you are trying to solve very well. Sure you're saying you want to "inherit" but then you might already using a mindset which might not be appropriate for the problem. Then it sounds like you have already created a working solution. What is the problem?
Looks good..but I seek something still very young and upcoming ..ine where my impact will really be felt! 
How do you do that? 
It doesnt seem to compile however?
IMO, the code is fine as-is. That is exactly what embedding is for.
I created an SDK for Amazon DRS. It covers the API but I am sure could use some improvement, even if only in docs or comments. Feel free to take a look: https://github.com/kevineaton/drs-sdk It's small but could be a great entry point if you have any recommendations!
Does that mean that we are one step closer for a pure Go SQLite?
My approach was to base64 encode the proto message bytes and write that to file. This way I can read the file line by line and be confident I only read complete messages.
Well we can create an Multi Blog Server with Plug and Play. I have this Project already but i have to rewrite it: https://github.com/i5heu/blog_cannon This Project needs only the Basics of Golang
At least the current master doesn't seem to actually call `reflect.Value.Slice`, so I'd second the question for a crashing code sample :)
Not only this, but the precise functionality and performance characteristics of a `for range` based implementation is far clearer, which is the Go idiom. Map etc may be the preferred tool of functional programmers, but Go is not a functional programming language.
Hey, You can check out this webinar organized by QASource. The webinar, 'The Future of API Testing - Trends and How to Propel Your Testing' will be held on Tuesday, March 27, 2018 at 11:30 AM PST. For FREE registration, click here: https://info.qasource.com/signup/the-future-is-api-testing
&gt; var _ Funcser = (*Template)(nil) What is the purpose of this line?
11:30 AM PST happens when this comment is 11 hours and 29 minutes old. You can find the live countdown here: https://countle.com/FH153251Y- --- I'm a bot, if you want to send feedback, please comment below or send a PM.
github.com/purpleidea/mgmt It's a pretty cool project I've been keeping an eye on for a while. They seem to be very open towards beginners.
If you're interested, my repo has some open issues that are easy to pick up and I'm looking for contributors as I don't have much time these days. Check it out here: https://github.com/Ullaakut/cameradar/issues
Since Go satisfies interfaces implicitly, this line explicitly forces the compiler to check that type `*Template` satisfies the `Funcser` interface. 
I had no idea you could do this. Add the type alias on top and my mind is blown!
Please check the documentation if you have a supported OS/platform combination and/or please fill an issue, thank you.
That will happen hopefully later this week for Linux and 386/amd64 platforms as an update of the cznic/sqlite project.
the solution is to move `Funcser` to it's own package and include it in both the implementer and relevant consumer. It's *really* not that big of a deal.
Nice logo!
I agree this post is a little short on details. I'm going to try to expand a bit here, but I'll update the post as well. According to the [Experience Reports](https://github.com/golang/go/wiki/ExperienceReports) wiki: &gt; The best experience reports tell: (1) what you wanted to do, (2) what you actually did, and (3) why that wasn’t great, illustrating those by real concrete examples, ideally from production use. I'll start with these three points, as I think they are enough to really illustrate the experience. &gt; (1) what you wanted to do Using [GORM](http://gorm.io/) is where this comes up most frequently, but it has happened with other packages in the past. In GORM you typically create queries by chaining something like this: ```go db.Where("role = ?", "admin").Or("role = ?", "super_admin").Find(&amp;users) ``` My issue is that the second I introduce this code into my application, I can't easily test it because I can't replace the `*gorm.DB` type with an interface. I now need either a live database connection for my tests, or I need to write a fairly large wrapper around GORM. That is, I can't write code like this: ```go type WhereOrFinder interface { func Where(...) WhereOrFinder func Or(...) WhereOrFinder func Find(...) *gorm.DB } func admins(db WhereOrFinder) []User { var users []Users err := db.Where("role = ?", "admin").Or("role = ?", "super_admin").Find(&amp;users).Error return users, err } ``` And then test it with a mock. Now before I move on, I'm guessing that most people are going to stop here and say, "Woah, you returned *gorm.DB on that `Find` method! Why not return it for all of the methods?" This doens't work because then the chained methods would no longer be using the mock. I can create a mock like this: ```go type mockDB struct {} func (m mockDB) Where(...) mockDB { return m } func (m mockDB) Or(...) mockDB { return m } func (m mockDB) Find(...) *gorm.DB { return &amp;gorm.DB{Error: someError} } ``` And it will work because my code doesn't leave the mock until the final result is returned, but if I were to instead create a mock like this: ```go type WhereOrFinder interface { func Where(...) *gorm.DB func Or(...) *gorm.DB func Find(...) *gorm.DB } type mockDB struct {} func (m mockDB) Where(...) *gorm.DB { // If I return a gorm.DB here the rest of my code will interact // with a REAL gorm db, not my mock! } func (m mockDB) Or(...) *gorm.DB { return ... } func (m mockDB) Find(...) *gorm.DB { return &amp;gorm.DB{Error: someError} } ``` You could make the argument that occasionally I will want to hit a live DB in my tests and I agree, but I don't want to do that for literally every single test that uses `gorm.DB`. It slows things down, and it means I need to do some sort of DB "reset" (or rollback) after each test to make sure I start with a clean slate. In an ideal world I would instead be testing with a mock. &gt; (2) what you actually did One of two things: - Option 1 - just use sqlite3 in the tests. No mocking or anything else, but it works even if it is slower. - Option 2 - Write a wrapper around the type so that I can more easily mock it. Here is an example of one someone else wrote for GORM - &lt;https://github.com/jinzhu/gorm/pull/1424/files#diff-48a8c4d93131a93810f1ac27bf60a10d&gt; I tend to end up going with Option 1 most often because it is clear what is going on and that we use GORM, whereas option 2 requires me to figure out all the methods we might use w/ GORM, make sure other devs know to add new ones they need if they aren't in the mock, and so on. &gt; (3) why that wasn’t great, illustrating those by real concrete examples, ideally from production use. Interfaces are, in my opinion, great in Go because they are easy to use and because someone creating a type doesn't have to go out of their way to define all the interfaces it implements. That is, I don't have to write something like: ```go type Dog implements &lt;Sortable, Stringer, ...&gt; ``` Duck typing and the simplicity it brings to Go's interfaces are (again imo) what allows the "accept interfaces, return structs" mantra to work. Having to create a wrapper or simply not use an interface isn't great because it is directly contradictory to this point. When we have a type that returns itself in a method, we now must either explicitly define the interface ourselves, or users of the type need to create an often large wrapper to enable that behavior. You can see this in the example I linked above for a GORM wrapper - the code there is required to overwrite every single method we might use in the original `gorm.DB` type and update them all to return a specific interface instead. It works, but it just never felt ideal. 
Yeah, I shouldn't have mentioned generics in the post. This definitely isn't a reason (at least on its own) to add generics. I think some implementations of generics might address it, but the two aren't tightly linked.
[dendrite](https://github.com/matrix-org/dendrite) needs all the help they can get. It's a golang replacement for the matrix homeserver [synapse](https://github.com/matrix-org/synapse/) which isn't quite scaling with the current load on matrix.org
I updated the post to discuss this. I agree I *could*, but in my experience I end up with a lot more issues that it solves when trying to create a wrapper around a type with a lot of methods (eg GORM's DB type)
I updated the article and commented about this here: https://www.reddit.com/r/golang/comments/82kigt/go_experience_report_interfaces_with_methods_that/dvb9s5k/ Hope that helps shine some light on why returning the type isn't always feasible. 
So the report boils down to "testing against a mock implementation of the ORM used was annoying." (Slightly exaggerating here.) Everybody knows that. If the ORM used is not designed to be mocked or offers an "interface only" API it will be hard to mock or write a stub/fake/whatever for it. Some kind of polymorphism/generics/covariance/whatever would be helpful here. We all know. Sorry. 
If you have some interest in Windows-related stuff (or just file formats), I have an open issue at [rsrc #10](https://github.com/akavel/rsrc/issues/10#issuecomment-357973632). The [rsrc app](https://github.com/akavel/rsrc) is a command-line tool for easy embedding .ico &amp; manifest resources in Go programs for Windows. It has 320 ☆ on github, 50 ⑂ and 23 👁, and was at time used by Docker for Windows executables (not idea who else is using it now). The [#10](https://github.com/akavel/rsrc/issues/10) is a popular enhancement request for adding support for version info. My app is very small, so befriending its code should be fairly easy. Other than that, the task would be based on some MSDN exploration and related googling, focused on a fragment of PE/COFF executable format (absolutely not rocket science; interesting for me, being some lower-level OS-related stuff). Plus testing the feature on a Windows machine. I'd be very happy and eager to guide and mentor a contributor! On the other hand, I must note I can be busy and may have a few days of latency when responding, as Real Life(tm) interferes quite often these days. But I'd absolutely do my best to communicate as quickly as possible. PS. Now that I've written all this, I'll try to go on and add this to the http://up-for-grabs.net site. Which may be also of interest to you, by the way!
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/akavel/rsrc/issues/10) - Previous text "#10" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
&gt; For performance you just want a for loop anyway. Also for clarity.
&gt; I now need either a live database connection for my tests If I understand correctly, the problem is testing a function that contains `db.Where("role = ?", "admin").Or("role = ?", "super_admin").Find(&amp;users)` or similar. I think testing against a live database is the right thing to do here. The obvious problem is that integration tests can be much slower than unit tests. What I like to do is guard these tests under a build tag. For example: // +build db Then you can keep running your unit tests as usual and use `go test -tags=db` to include the slower tests once in a while. This is very helpful as integration tests might need some extra work (like providing a test account and password). Integration tests can be easily included in test coverage with `go test -tags=db -cover`.
The problem expands beyond just ORMs. It occurs with any type that uses method chaining like GORM does. For instance, if a lib for talking with a remote server used this pattern then stubbing it out without a custom wrapper would be very hard and likely not what you (or the remote site) want in your tests. Even if you feel every instance if this should use a real DB (I actually don't feel it is necessary for every test but I'd have to write a bit more to explain why), I think most people will agree we don't want tests pinging third party APIs all the time.
We offer workforce pertaining to blockchain - Scala, Solidity, C++, PHP, Go and Java developers available for hire on an hourly basis - Recruit Blockchain consultants, expert analyst and tech support - Tech personnel available for hire on an hourly basis - Opportunities for Freelancers to contribute. - Expert analysts on request+ Get in touch with us on info@scalablockchain.com &amp; www.scalablockchain.com
In your example the `admins` function is not doing anything worthy of a test. Perhaps a more involved example would help with clarity. When it comes to dealing with DB's isn't it common to use a repository pattern? Gorm would then become an *implementation detail*. type UserRepository interface { Admins() ([]User, error) // other methods } type gormUserRepository struct { db *gorm.DB // whatever you'd need } func (r gormUserRepository) Admins() ([]User, error) { var admins []User err := r.db.Where("role = ?", "admin").Or("role = ?", "super_admin").Find(&amp;users).Error return admins, err } type mockUserRepository struct { WantErr bool } func (r mockUserRepository) Admins() ([]User, error) { if r.WantErr { return nil, fmt.Errorf("error retrieving admin users") } return []User{User{}, User{}, ...}, nil } var _ UserRepository = (*gormUserRepository)(nil) var _ UserRepository = (*mockUserRepository)(nil) This way you're not trying to mock out a chaining api; you're mocking out the where/how you actually got your admin users.
I'd be okay with some built-in collection functions that are similar to Scala's collections. I don't think we need generics to accomplish at least that part. I would not be happy with Go becoming a functional programming language either, because right now Go is kept simple and explicit, a lot of functional code I've seen is drowned in abstractions and can be taken to an extreme. As for the API that has been suggested, to me it'd make much more sense for there to be some built in function like `append`. In my eyes it might just look like this: ints := []int{1, 2, 3, 4} incs := map(ints, func(i int) int return i + 1 }) filtered := filter(incs, func(i int) bool { return i &lt; 4 }) fmt.Println(filtered) // []int{2, 3} The wrapping stuff seems really unnecessary to me.
&gt; I think most people will agree we don't want tests pinging third party APIs all the time. This is why integration tests are guarded with a build tag. This way unit tests can be run using `go test` and the slower integration tests can be run using a combination of tags like `go test -tags=integration`.
Hey! I've switched from C# to golang as well. If you're looking to contribute on a micro ORM for Postgres, this is something a couple of us have started and can be grown further :) https://github.com/paperchain/papergres
It's funny how the wrong approach to testing leads to an experience report that is indirectly asking for a certain type of generics to be added into the language. &gt; Option 1 - just use sqlite3 in the tests. No you do not test using sqlite. &gt; Option 2 - Write a wrapper around the type So if you tried to test a function that used `database/sql` you would write a wrapper around `database/sql`? What kind of insanity is this? [Stop trying to mock everything](https://medium.com/@zombiezen/life-of-a-go-infrastructure-maintainer-cb1419308eb5).
saw this on GSoC!
We did a wrapper around the official API at work, we might release it as open source in the future. Bottom line, it is entirely possible :)
New update: we have added Spanish and Chinese (Simplified and Traditional) versions to Clock of Atonement! https://twitter.com/hajimehoshi/status/971319244364361728
Take a look at Code Triage https://www.codetriage.com/?language=Go
Can it add custom images? (other than the grayscale thing)
Great collection of benchmarks. Nice to read through and see the performance impact of some common operations. Was surprised by the performance of append and performance of https compared to http.
Thanks! :)
Type has behaviors beside methods. Slice has index, and struct has field. While it makes sense in promoting methods to utilize that, it is inexpressive and sometimes confusing to have inconsistent behavior in similar and theoretically parell types. In OP's case, when acquring an element, it is sps[0] vs. wl.SamplePackages[0]. I would say, it would be much more idomatic if they are both x.Packages[0], even though Go does not support attribute interface.
[removed]
The extended example on using GORM to get admin users is not providing the right level of abstraction where you want mocks. You don't need an ORM object interface with chainable methods, you need something like `type AdminGetter interface { GetAdmins() ([]User, error }`. The fact that you use GORM or a DB at all is an implementation detail that only matters at the integration layer. Have a fakeAdminGetter and a gormAdminGetter. Latter, you might replace it with a userMicroServiceAdminGetter, and all your unit test continue to work, and you don't have to re-organize your code. Unit tests are about design and checking success and error paths. If you added a microservice to serve you admin users, all you would do is update your integration or acceptance tests which hit the concrete implementation (ensuring your code actually works for realsies before deployment) along with adding the library code to access the service. 
or just `binary.BigEndian.PutUint64(buf[:8], length)`
there's also this WIP, alpha-grade, read-only SQLite project: - https://github.com/go-sqlite/sqlite3 
alert "shameless plug" I have opensource projects in Go and would love contributors. when I seriously started with Go, I started building a common go utility collection repo [Gol](https://github.com/abhishekkr/gol)... which can have more utility packages and refinement on existing logic flows some other projects are * [Dory, a secret sharing service for masses](https://github.com/abhishekkr/dory), can use more data backend support, different encryption methods as option to pick from, more protocol support * [Tune.cli, a song finder](https://github.com/abhishekkr/tune.cli), currently just uses Tunefund as data-source... can use more data-source and find mechanisms; also recommendation strategy on already found music * [timefs, a timeseries datastore with no db engine](https://github.com/abhishekkr/timefs); is the most fresh project of mine with heavy feature influx at moment
&gt; Type has behaviors beside methods. But embedding is (mainly) about those. &gt; In OP's case, when acquring an element, it is sps[0] vs. wl.SamplePackages[0]. Ah, so your issue isn't "embedding slices vs. embedding something else", but "embedding slices vs. not embedding slices". Fair enough. I still think it's fine to embed to selectively overwrite methods. Yes, I agree that this will make it impossible to index into the embedding type, but more often than not that's an inconsequential restriction.
Well, if SapmplePackages is a struct with a slice field, like type SpamplePackages struct { Pkgs []whatever }, embedding will not cause any trouble. You can write uniformly x.Pkgs[0]. 
I really enjoyed reading this. No big surprises here, but good to have bookmarked for later reference when you're building something.
[removed]
That's great ! Congratulations! I was wondering if there are some performance issues, given the fact that go is a GC language 
Didn't work but thanks for trying
Readability and expressiveness, that's all. OP asks for idiomatic Go code, not how to promote methods. You can embed everything as long as the compiler does not complain about it (for now, it's everything except pointer types) as you wish, as you feel like. And you may simple not care about indexing, or any other problem it may cause, as long as the code compile and run. I feel I have completed my arguments, so I probably won't reply this again.
Name conflicts shouldn't be an issue, since you can rename a library on import. See https://stackoverflow.com/questions/10408646/how-to-import-and-use-different-packages-of-the-same-name-in-go-language (Sorry if I misunderstood)
What about making the micro ORM for CockroachDB? :)
I'm in the same boat as OP, though from a different origin language. Dory looks interesting. Starred. May fork later.
Hey hit me up too
I agree that, when it makes sense, you should take interfaces and return concrete types. Empty interface means nothing and is not a concrete type, and should probably only be returned when the caller explicitly knows what it should be and can convert the type. This happens in container solutions or caches that try to be generic. Generally, you should not return interface{}.
Works fine when I test it. What is the issue that you are seeing ?
I would like to know if Go is capable of high quality game development, or if it is more in line with Java in the camp. Does it have to reach out to native C based libraries for things like gpu access for fast performance, as well as audio and multi-channel capabilities? How does it handle cross platform game development? 
thanks :)
Please direct all questions and congratulations to /u/hajimehoshi . Original post is at at [gogamedev](https://www.reddit.com/r/gogamedev/comments/7yo2er/go_packages_we_developed_for_our_games/).
&gt; It might have been that the benchmark required backtracking. It does not. All expressions are regular, in the formal sense of the term.
Doesn't CockroachDB use the MySQL protocol? In theory any ORM that works for MySQL should work for CockroachDB too. P.S. I Haven't actually tried this so it might be nonsense.
It uses the Postgres protocol, but there's the smallest of differences I believe because Cockroach is NewSQL
True, I've only done that in library code where the user would never get an Interface{}. In other cases, I try to design my interfaces such that all methods return concrete types, although that is somewhat difficult for writing container code and implementing algorithms.
- https://github.com/go-sqlite/sqlite3 the goal of this package is to be able to read SQLite3 db files with a pure-Go package, without reaching for a C/C++ compiler and CGo. Eventually, writing SQLite3 files would be great too. Eventually-bis, defining a `database/sql` compatible driver. it's still very much a WIP and the codebase isn't too big yet (so relatively easy to get acquainted with) Right now, the biggest roadblock (IMHO) is to define a SQLite-dialect SQL parser so we can properly interpret the Table schema definitions.
It should not be bad because of sub millisecond stop there world pauses.
Closures and first-class functions may be the preferred tool of functional programmers, but Go is not a functional programming language. 
&gt; I would like to know if Go is capable of high quality game development, or if it is more in line with Java in the camp. Go is really a good language for game development :-) IMO, The pros of Go is that Go's specification is sophisticated and forces a relatively clean architecture. The cons of Go is a kind of ecosystem of game developing in Go is premature: the number of people is less than other languages'. You might feel like tools like IDE are missing. &gt; Does it have to reach out to native C based libraries for things like gpu access for fast performance, as well as audio and multi-channel capabilities? Language performance didn't matter at least to us. Go is fast enough, and in most cases, the bottle neck was the number of draw calls with GPU. As for audio, we haven't found any significant problems. If you want to have multiple-channel, you can use OpenAL directly. There are binding (e.g. godoc.org/golang.org/x/mobile/exp/audio/al). &gt; How does it handle cross platform game development? Go is really good thanks to Go's portability. You can write games in Go for desktops (Windows, macOS, Linux), mobiles (by gomobile) and even browsers (by GopherJS). 
Hey, tysm!
Have you looked at _anything_ to get started with this? I mean, even done quick search? Tried to start writing some code?
Read https://golang.org/cmd/go/#hdr-Remote_import_paths
Low latency GC is not a magic bullet. Specifically, it comes with an important tradeoff: reduced throughput, i.e compared to a STW implementation, Go spends more CPU time collecting garbage instead of running your code. This may or may not be acceptable depending on your use case, but it wouldn't be for e.g AAA games.
Thanks. That sentence has beed rephrased already. The idea behind these benchmarks is to make the results usable for real-world applications, rather than benchmarking real-world programs.
https://github.com/jivesearch/jivesearch It's a search engine I just launched last month (name subject to change). The instant answers are a great place for a beginner to start with the language. They can be pretty much anything: simple (reverse a string, etc.), API-based (like our Stack Overflow answers), from a database (like our Wikipedia/Wikidata/Wikiquote/Wiktionary answers), or JavaScript (our calculator, minifier). You can look at the road map I have up there as well for inspiration or tweet me with new ideas (@thebrentadamson).
[Syncthing](https://syncthing.net), [Docker](https://docker.com), [Gitea](https://gitea.io). All three great projects, but I'm not sure if this is what you're looking for.
With all due respect: http://www.catb.org/esr/faqs/smart-questions.html This will help you get more out of the community, even as it will make it easier on the community too.
[removed]
Yes, very alpha. Most of the fixes I've contributed were to fix a panic. 
I traced the problem to a combination of `dep` and `go.opencensus.io`. `dep` uses semantic versions before `master`, so in the case of `go.opencensus.io`, it is choosing `v0.3.0` instead of `master`. `google.golang.org` depends on `go.opencensus.io@master`. Running dep ensure -override go.opencensus.io@master fixed my build.
https://github.com/topics/nodejs - 35.8k
&gt; For example, I use PDF in my core lib where it's in the same name space with other general classes. Just explaining my thinking. If it makes sense to put it in a separate namespace, then do that. [https://golang.org/doc/effective_go.html#Getters](https://golang.org/doc/effective_go.html#Getters) I prefer the second, syntax personally. It describes what is happening more than the top example. Checkout [mastermind/squirrel](https://github.com/Masterminds/squirrel). It has a similar problem space to you, and I believe they chose the method that you're suggesting.
I maintain small library for an IRC bot on twitch.tv https://github.com/gempir/go-twitch-irc There are a few issues open which could be tackled :) For example pinging to check if the connection is still alive and restart it if not. 
An article about Go errors that isn't just like use `pkg/errors` and call it a day? Is this real? Wow! +1
https://gist.github.com/astenmies/96a9b09cfba1e9d204b00b08eed29e7f
&gt; I just bought the IDEA ultimate package, which includes their new GoLand IDE for Go. It is pretty nice so far, though I have yet to dabble with Go in it. Day job is all Java based so far. Would love to switch to Go but it is currently not an option. You mean IntelliJ IDEA? As I haven't use such IDE, I don't have a strong opinion on it, but this seems nice to learn a language. &gt; So.. can you write sophisticated games with Go.. or is it more of the types of games you see on mobile devices? [...] Or is it more suited for card games, puzzle games, and some lower end animated games (e.g. something like donkey kong, pac man, etc)?? So your question is, "what kind of game can I develop in Go"? The answer is 'theoretically any games'. As World of Warcraft is 3D games, this is different from Ebiten's target (2D games). You can still use other libraries for 3D like [Azul3d](https://azul3d.org/). &gt; Last question.. audio.. could you use Go to build a graphically powerful audio program, like Cubase, Cakewalk, etc? Sorry but I'm not familiar with music programming, so I don't have enough knowledge to answer your question. I feel like languages don't matter on what you want to do though.
I haven't even really begun to learn Go, so to -me- the idea of a one file app is great in the sense of looking and learning.
I'm not trying to mock everything, but the bigger issue still exists that you cannot easily mock out any type that uses the method chaining pattern and there are definitely times when mocking is the right choice.
You could give a try to https://github.com/heetch/confita. It's a lib that loads configuration from multiple backends and stores it in a struct. It's a cool project for beginners for various reasons such as: - codebase is still small - you can start by writing a new backend labeled as `good first issue`, if you're unsure of where you're going, just have a look at the other backends - we're welcoming contributions and we're not hostile. On the contrary, we'd be glad to gentle and constructive reviews.
You prefer pdf.SetX().DrawLine() to pdf.X().Line()? I'm suggesting removing most getters entirely: since this is a writer, most of the time we're just setting the state, but some getters, like X() and Y() are essential. But if I remove 'Set' and 'Draw' from the method names, then I'll have to prefix the getter with 'Get', though Golang docs don't recommend that.
I really recommend you to keep learning Go. It's a simple and powerful language. I'm glad the app is useful to you for learning.
Not right now, but soon I'll need to have colour PNGs, then other types of images too. It's not complicated. Today I'm adding methods to draw and fill circles and ellipses.
Thank you very much sir!! I have been wanting to start coding games in go but been dissuaded so far due to libs. I think you may have changed this. Is the process you used to build and release your games documented? Or are these just some packages of what you need?
A lot of work needs to go into vulkan and go before it's reasonable to use, but ideally it would 
In game development (especially with GC) you avoid dynamic memory allocation as much as possible. Pre-allocate blocks of memory on start-up, reuse objects instead of creating/destroying all the time etc. Besides that Go's GC is pretty awesome and for many (smaller) games GC is a non-issue anyways. 
&gt; Thank you very much sir!! &gt; I have been wanting to start coding games in go but been dissuaded so far due to libs. I think you may have changed this. Is the process you used to build and release your games documented? Or are these just some packages of what you need? /cc /u/hajimehoshi 
I honestly think you are trying to help, but at this point I'm a little too frustrated to bother updating the experience report. I am frustrated because I intentionally left the original experience report pretty vague because I wanted the focus to be on the general problem - you can't create an interface decsribing a type that uses method chaining - but after posting that experience report I received feedback like r/drvd's that argued that the report didn't illustrate how this issue affects a real application. I agree that sometimes real examples can help illuminate why something matters, so I added a real example only to have people latch onto that specific instance (instead of the general issue) and now I feel like we've come full circle with you telling me that I need to change the experience report because it now focuses on a certain practical problem and not the general issue. It is a lose-lose scenario; either I'm vague enough to keep everyone focused on the higher level topic and I'm told I need specifics, or I provide specifics and everyone latches onto them forgetting the higher level issue. To be clear, I don't think you specifically are at fault. It just seems to be the way the internet dynamic works at times and it can be very frustrating when trying to provide real feedback.
I know you are trying to help, and everything you said is true. I use tags like you mentioned to help separate my integration tests from my unit tests and it does indeed help. One could also use the short flag as you suggested to solve a similar problem. What I disagree with is the implied suggestion that I only use integration tests to test this code; based on my experience having a split of unit tests AND integration tests works better. That said, I do realize that every team and application is different, so it is very possible that you have always been in situations where the integration tests work just as well (if not better). The bigger experience I was trying to open a discussion around is that ANY type that uses method chaining isn't representable as an interface. We can represent functions in a mostly replaceable format (eg `exec.Command` can be assigned to `var execCommand = exec.Command` in code and then later replaced for tests), and we can create interfaces for most types, but if a type uses method chaining this often isn't possible and it can tightly link applications to those types.
&gt; Java Swing attempted something similar (using their own toolkit) and it never took off AFAIK Swing GUI was hot shit 10-15 years ago. Now they have updated it with JavaFX or something? I don't think it's that it didn't take off. I think it did but GUI apps became less and less relevant over the years.
&gt; But the next question is, why do you need this feature in practice? You need to find a new to answer that question. :) I suppose we are at an impasse because I don't agree with your conclusion. I agree that integration tests are useful and should be used, but I disagree that they should be used exclusively here.
I use interfaces like this, and I agree they are useful. We will still want to write tests for the `gormAdminGetter` though and it sounds like your solution is to use strictly integration tests there which I disagree with. I do agree that I should use some integration tests, but I disagree with them being used exclusively.
These are all awesome - but I'm not sure if I am at the correct "level" to contribute anything.
This sounds really neat! There also seems to be beginner --&gt; export level sort of things to dig into so I'll reach out :)
Do you have any issues geared towards a beginner of sorts? 
Hi, Thanks a lot, I created a plotting library in Golang. Go try [it out on github](https://github.com/arafatk/glot). 
When so many people told you more or less the same thing, you might have to consider that there's something there. &gt; I suppose we are at an impasse because I don't agree with your conclusion. I don't remember reaching any conclusion or speaking about integration tests. But from the context of the other comments I understand what you mean. You are not saying why you disagree though. You have already said that you do not want this feature because of some I-want-to-test-all-the-things attitude. Beyond that (which was my first guess), I truly can't think of any practical reason for this feature beyond convenience. But by this logic so many other features could be added in Go for convenience but they are not because they complicate things. Does this feature complicate things? I am not sure. I want to make it clear that I wouldn't mind having the feature if it was possible without complicating the language yadda yadda. But assuming that it does complicate things, the content of this experience report did not convince me at all that it is needed. The practical example that is solved with this feature has to change.
it will block any way what i am asking is how can i make sure theres more before blocking if theres no more then i would like to send the bytes to parser etc. 
In my case we are using binary protocol and sending the length in the 3rd byte so its no problem but i just wondered if theres any other way to do it without actually sending the length 
There is a ioctl (SIOCINQ) you can use to see how much data is in the kernel inbound socket buffer; but note, that this will only tell you how much data the kernel has buffered you haven't read, it doesn't tell you whether or not the other side of the connection will send *more* data eventually - that part is fundamentally unknowable. You know that the stream is done, when you get an EOF - until then, the best and idiomatic way to handle this is to blockingly read as much data as you get and hand it over piece-wise and do the framing on the application level. You probably want your parser to take an `io.Reader` and just pass the connection directly. It'll be fine.
oh yes that is what i am seeking for of course nobody knows whether the other party will send more messages or not but i would like to know how far i consumed of the message and how much is waiting to be consumed. I will see ioctl but cna you be more specific and is it cross platform ?
I still do not understand why you can not just block. Go goes to great length to make this as fast and efficient as possible and will do all kinds of polling itself. &gt; cna you be more specific Not really, I don't know enough about network programming myself. &gt; and is it cross platform ? Definitely not.
&gt; When so many people told you more or less the same thing, you might have to consider that there's something there. Everyone here will also say that ORMs are the devil, meanwhile I know many professional devs who leverage them successfully all the time (when used properly) and packages like GORM have 8k stars for a reason - they provide value. Similarly, I can point to large orgs (like [Google](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)) that advocate for more unit tests and fewer integration/e2e tests. I'm not saying there isn't value in what people are saying - I do try to listen and absorb what I'm being told, experiment with it, and see how it pans out. My issue here is that I have seen how just a few sanity unit tests can vastly increase development time over using just integration tests. Perhaps this is worth of its own write-up. &gt; I truly can't think of any practical reason for this feature beyond convenience. But by this logic so many other features could be added in Go for convenience but they are not because they complicate things. Part of this is convenience; I think anyone suggesting a feature be added to Go and claiming it isn't partially motivated by convenience is lying to themselves. If the language had glaring flaws that prevented developers from doing their jobs it wouldn't have the uptake it does, and clearly people are getting work done so its hard to argue that anything missing is project-halting, which implies that it is to some degree a convenience feature. The other part is that the current behavior takes some of the things I love about Go and "breaks" them (not literally). Eg I love that as I develop a package I can just return types and let others determine if they want to use interfaces and mock them out in tests or not. I love that I don't need to explicitly state, "This type implements the X and Y interfaces" and limit end users to those. I love that I can create an interface where I intend to accept it with a small set of the methods I need and accept any type that implements the interface as an argument. These are all incredibly powerful features of Go and I appreciate how they enable me to write very clean, maintainable code. Unfortunately, if any package developer introduces the method chaining pattern into a type this frequently stops working. I either need to wrap that type, write code that is tightly linked to it, or not use it at all. As I tried to demonstrate w/ a link in the article, wrapping it can often lead to mega-interfaces that I need to keep in sync w/ the upstream type and the other two options aren't always ideal either. Testing comes up because testing is one fo the most common situations where you replace an interface with another implementation. It is likely the one most developers are familiar with, but it isn't the only situation that would be affected by a change like this. The problem with specific examples is that just like the testing example, you can always point to it and say "oh well then clearly the package you are using was designed poorly" or "oh you can do X and Y - it is more code but works fine". There isn't a concrete "here is something that is impossible to do in Go without this feature" because as I said before - if those holes existed in the language we likely wouldn't have this many people using the language. The same is true of any argument for generics - I've yet to see a situation where it is impossible to create a solution without generics, especially with code generation as an option, but that doesn't mean that they aren't worth adding to the language. Also, just to be clear, I can live without this feature. I can live without generics. I could have lived without the type alias feature, and many others added to Go. I just don't believe that means the features aren't useful or don't have their place in Go2; as you said, it depends on the cost of adding them to the language. &gt; I want to make it clear that I wouldn't mind having the feature if it was possible without complicating the language yadda yadda. I agree fully that if the feature were going to overly complicate the language it would be bad to add. That is actually why I tried to avoid suggesting solutions in the article - I'm not in a position to evaluate the pros/cons of each solution. I just want the people developing Go 2 to consider this use case as they look at options and features to add in case it fits in. I do suspect it could be added with minimal downside, but truthfully I don't know enough about the compiler and tooling side to say that with 100% certainty. What I can say is that on the devs-using-go side I don't foresee any issues. Types - like `template.Template` - would start satisfying more interfaces than they did before, but I'm not aware of any situations where this would cause unexpected issues for developers. That is, I'm not aware of a situation where a developer relies on this NOT happening and would be caught off guard by it becoming true. 
Funny.. "I wrong Swing". I think that is what everybody decided. lol Pisses me off too.. Swing was good stuff. Obviously IntelliJ, NetBeans and several other apps are pretty good and work across platforms. That was one of the biggest things.. and especially when they started adding platform native capabilities into it. I wish they had kept it going and worked on good quality hardware acceleration and such into it. I had a slick plugin engine and naked framework that was 100% plugin based.. but my framework handled things like menus and hot keys, context sensitive menus to boot. Miss that stuff. Now all the rage is Electron framework with ReactJS Web UI and a back end Rest API. Which is awesome because it looks/works the same on mobile (more or less), desktops and in browsers. Postman, Slack.. to name a few do this.
Now that I am on a computer, I'm going to get very wordy :). What follows is not a "my opinion is better than yours," it is "this is the opinion I've developed based on my experience." I'd be interested in hearing why I'm wrong and why the way you propose is better. My goal is not a flamewar or anything. It is honest share of my understanding and a seeking of other understanding. &lt;/psa&gt;. I'm curious why you would want to test GORM outside of integration tests. I get the feeling that complete mockable objects is a thing some folks bring in from other languages and is a security blanket that some hold on to that provides no real benefit. It would be the same as testing\mocking `net` package calls, or needing fully mocked HTTP clients or TCP calls. In these cases, I would suggest what I suggested above: these are implementation details to be abstracted behind structs that match an interface that is easily unit testable. When you mock, you create assumptions. The more complex the mocks, the more complex the assumptions. I've lost count how many fully mocked objects in other languages that are just mocked wrong and when you actually run the application the code fails due to bad assumptions. At some point, you absolutely will have to verify the application actually works. I refer to these as acceptance or integration tests depending on the scope of systems involved. This is the perfect place to ensure that your dependency integrates with your system as expected and where you would test the proposed `gormAdminGetter`. Would you agree that he point of unit tests are for guiding design and verifying success and failure paths? Would you agree that integration tests should test your integrations with dependencies? Note: I think the caveat here is that it may be untenable to spin up your entire dependency stack in some cases, but there are ways around that (request playbacks, faked proxies, etc). I contend that in unit tests, you merely need to verify application behavior. How does the application handle the error in `err := db.Where("role = ?", "admin").Or("role = ?", "super_admin").Find(&amp;users).Error`; depending on error handling, you may need to return some different fake errors. You don't need to verify via unit tests that `Where`, `Or`, or `Find` cause specific errors or that they are used correctly; you just have `fakeAdminGetter.GetAdmins` return the error you need to assert against. It should make no difference to the application if how `GetAdmins` happened to get an error, it just matters how that error is handled. This achieves the goal of unit tests verifying success and error paths. To have a complete and complex mock for the chainable API coming out of GORM is vast overkill, just like it would be for a fully mocked sql.DB or http.Client. As your test cases get more complex, the mock has to get more complex, and this could end up with needing a virtual clone of a dependency, its bugs and all. At the end of the day, you absolutely will have to hit your code with a real request to make sure it works. The integration or acceptance tests will verify that you used GORM or whatever dependency correctly. There is no need to duplicate that work between unit and integration tests. &gt; I should use some integration tests, but I disagree with them being used exclusively In case I was unclear, you are not using integration tests exclusively; however, there is no better way to verify your application integrates with a dependency than to call the dependency in the test. Testing all the permutations is what fast unit tests are for (ie, verify all success and error handling paths). But you don't need a fully mocked object for this. You need a fake that adheres to an interface and can emulate any conceivable behavior you need to test. What value are you getting from elaborate mocks and fixtures? Instead of testing against assumptions, you get to verify actual behavior if you have integration or acceptance tests that use GORM and the DB. You've already verified all error paths in your unit tests. Now you just verify that the green path works as expected in your acceptance or integration tests and you are in a fantastic spot to confidently deploy the code. Anyway, as you might tell, I'm a little opinionated on this subject :). I'd be happy to get any criticisms of this approach or benefits to use of complex mocks. The only benefit I can see is the potential ability to ensure that you are passing arguments correctly in the concrete implementation. I feel that is a very small reward in exchange for complex mocks and their assumptions, and this particular issue will be immediately caught in the integration tests that you are going to need to write anyway. 
Gives error 503...
Excellent!
(pt 2:) ----- #### Abstracting Before Returning to the Caller This is the error&amp;#39;s perspective of case number 1. I considered abstracting when an error variable is collapsed into a single kind of error, when more than one bit of information is summarized in one error type or when errors are retinterpreted before they&amp;#39;re returned to the caller. Below, a special condition receives a name: // In the standard library&amp;#39;s net/http/h2_bundle.go if err == io.EOF &amp;amp;&amp;amp; cs.bytesRemain &amp;gt; 0 { err = io.ErrUnexpectedEOF cs.readErr = err return n, err } // In github.com/ethereum/go-ethereum/core/vm/interpreter.go if err != nil || !contract.UseGas(cost) { return nil, ErrOutOfGas } This time an error is reinterpreted: // In the standard library&amp;#39;s net/http/h2_bundle.go if err == http2ErrNoCachedConn { return nil, ErrSkipAltProtocol } // In github.com/golang/go/src/cmd/go/build.go if err != nil { return false } And, here, potentially many types of errors are collapsed into one type: // In the standard library&amp;#39;s os/env.go if err != nil { return NewSyscallError(&amp;#34;setenv&amp;#34;, err) } return nil // In the standard library&amp;#39;s runtime/pprof/internal/profile/legacy_profile.go if err != nil { return nil, errUnrecognized } #### Logging the Error This is the callers perspective of case number 2. Plenty of examples of simply logging the error were found. In this cases, the error message is exposed to whoever is looking at the terminal output. Notice how, even without context, you can see the errors seem to be &amp;#34;non-actionable&amp;#34;. Things related to hardware failure, invalid input, hard network problems, failed system calls, etc. The code can&amp;#39;t recover from this, but the programmer sitting in the chair can plug a network cable, optimize loops, fix the syntax error, and so on. // In github.com/kubernetes/kubernetes/test/e2e/common/autoscaling_utils.go if err != nil { framework.Logf(&amp;#34;ConsumeCPU failure: %v&amp;#34;, err) return false, nil } // In golang.org/x/tools/cmd/godoc/handlers.go t, err := template.New(name).Funcs(pres.FuncMap()).Parse(string(data)) if err != nil { log.Fatal(&amp;#34;readTemplate: &amp;#34;, err) } return t // In github.com/ethereum/go-ethereum/metrics/influxdb/influxdb.go _, _, err := r.client.Ping() if err != nil { log.Printf(&amp;#34;got error while sending a ping to InfluxDB, trying to recreate client. err=%v&amp;#34;, err) if err = r.makeClient(); err != nil { log.Printf(&amp;#34;unable to make InfluxDB client. err=%v&amp;#34;, err) } } // In golang.org/x/tools/cmd/toolstash/cmp.go f2, err := os.Open(outfile + &amp;#34;.stash.log&amp;#34;) if err != nil { log.Fatal(err) } #### Adding Debug Information This is the error&amp;#39;s perspective of case number 2. This were cases when the underlying error was not available to the caller, but its information was appended to the error message. Again, you can notice patterns similar to the aforementioned ones. These errors are irrecoverable, so a generic error type is returned. The caller can&amp;#39;t do anything and the underlying cause belongs to log messages, not the callers code. // In github.com/golang/go/src/cmd/go/build.go if err != nil { os.Remove(dst) return fmt.Errorf(&amp;#34;copying %s to %s: %v&amp;#34;, src, dst, err) } // In github.com/ethereum/go-ethereum/whisper/whisperv5/whisper.go if err != nil { return &amp;#34;&amp;#34;, fmt.Errorf(&amp;#34;failed to generate ID: %s&amp;#34;, err) } // In github.com/alecthomas/chroma/style.go if err != nil { return nil, fmt.Errorf(&amp;#34;invalid entry for %s: %s&amp;#34;, ttype, err) } # How to Allow for Good Runtime and Debug Time Decisions ### The Amount of Information an Error Exposes This is related to runtime decision making. When either a generic error is returned (`return fmt.Errorf(..., err)`cases) or no error is returned (`return nil`), the information of the underlying error is collapsed into one bit. The caller of this function has two cases to distinguish: either an error occured or it didn&amp;#39;t. When we define error types in Go (or exception types in Java, or special return values in C, etc.), we are giving the caller more information. A function that can return two kinds of error gives the caller three possible outcomes: errors of the first type, errors of the second type and no errors at all. Go has the special trait in that [errors are values][go-blog-errors-are-values]. This allows for flexible error handling techniques. The standard library has many ways of creating and exposing errors to its users: [using variables][bufio-pkg-errors], [types][net-pkg-op-errors], [methods][net-pkg-address-errors], [anonymous functions][json-pkg-error-to-string-function], etc. The principle is still the same: to convey the relevant information about the error to the calling code in the appropriate level of abstraction. ### Hiding (But Not Losing) the Underlying Cause As we can see from the code samples, sometimes information is hidden from the caller. When we wrap the underlying error by doing return fmt.Errorf(..., err) we are hiding from the caller the real cause of the error. Notice, however, that we&amp;#39;re not hiding it from the person debugging the output of the code. They still see the underlying error in the final message, because that might be useful for debugging. # Conclusions When returning errors to the caller, it&amp;#39;s important to distinguish the two types of decision making developers go through: runtime and debug time. Taking into account well known themes in computer science, such as [information hiding][wiki-information-hiding] and [abstraction][wiki-abstraction], we must careful not to conflate those matters and hide useless information for the caller (though possibly useful to someone debugging) inside the error message and expose only the necessary information for runtime decision making. # References - [Error Handling and Go, by Andrew Gerrand][go-blog-error-handling-and-go] - [Errors Are Values, by Rob Pike][go-blog-errors-are-values] - [Talk on Error Handling In Go by William Kennedy][wk-nation-conferences-talk] - [Build Web Application with Golang, by @astaxie on Github][build-web-applications-with-go-book] - [Why Go Gets Exceptions Right, by Dave Cheney][dave-cheney-why-go-gets-exceptions-right] - [Error Handling, by Dave Cheney][dave-cheney-error-handling] - [Bufio Package Errors][bufio-pkg-errors] [json-pkg-error-to-string-function]: https://golang.org/src/encoding/json/decode.go [net-pkg-address-errors]: https://golang.org/pkg/net/#AddrError [net-pkg-op-errors]: https://golang.org/pkg/net/#OpError [bufio-pkg-errors]: https://golang.org/pkg/bufio/#pkg-variables [go-blog-error-handling-and-go]: https://blog.golang.org/error-handling-and-go [go-blog-errors-are-values]: https://blog.golang.org/errors-are-values [wk-nation-conferences-talk]: https://vimeo.com/115782573 [build-web-applications-with-go-book]: https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/11.1.html [dave-cheney-why-go-gets-exceptions-right]: https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right [dave-cheney-error-handling]: https://dave.cheney.net/tag/error-handling [homepage-alex]: http://alexsalle.com [github-pietro]: https://github.com/pietromenna [github-trending-month-go-repos]: https://github.com/trending/go?since=monthly [wiki-confirmation-bias]: https://en.wikipedia.org/wiki/Confirmation_bias [wiki-information-hiding]: https://en.wikipedia.org/wiki/Information_hiding [wiki-abstraction]: https://en.wikipedia.org/wiki/Abstraction_(software_engineering)
**Information hiding** In computer science, information hiding is the principle of segregation of the design decisions in a computer program that are most likely to change, thus protecting other parts of the program from extensive modification if the design decision is changed. The protection involves providing a stable interface which protects the remainder of the program from the implementation (the details that are most likely to change). Written another way, information hiding is the ability to prevent certain aspects of a class or software component from being accessible to its clients, using either programming language features (like private variables) or an explicit exporting policy. *** **Abstraction (software engineering)** In software engineering and computer science, abstraction is a technique for arranging complexity of computer systems. It works by establishing a level of simplicity on which a person interacts with the system, suppressing the more complex details below the current level. The programmer works with an idealized interface (usually well defined) and can add additional levels of functionality that would otherwise be too complex to handle. For an example, a programmer writing code that involves numerical operations may not be interested in the way numbers are represented in the underlying hardware (e.g. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I’m a little late but if you want something a little different that will teach you a bit about the Go runtime and tracing while not being super difficult work there is: https://github.com/cstockton/go-trace/issues/2 - It’s to support version Go 1.10 of trace format which probably just includes an extra event type, the commit log probably has a prior upgrade like this in it. The project itself is a tool to parse the Go trace format, the main objective is streaming trace data at runtime.
What do you mean by "if theres no more"? You need to delineate your message boundaries somehow.
Sadly this article didn't end up conveying what I wanted, but I do respect you taking the time to provide feedback so I'm going to try to respond a bit. First, the primary point I wanted to convey is that a type like this: type A struct{} func (a A) Source() *os.File { ... } Not implementing an interface like this: type Sourcer interface { Source() io.Reader } func PrintSource(s Sourcer) { // ... do stuff w/ s } Is (imo) not intuitive and limits what we can do with mocks. The examples I used all used method chaining, but the underlying issue isn't specific to method chaining now that I think about it further. I say it isn't intuitive because [interfaces are implemented implicitly](https://tour.golang.org/methods/10), but the fact that this doesn't work feels counter-intuitive to me. In order to implement this interface we now have to explicitly define our type `A` in order to match the definition and aside from possibly making the Go compiler &amp; tooling easier to code, I don't see any other real benefits. Going back to your actual comment, I think it can be summed up into roughly three points: 1. Abstract most of your GORM specific code into something that can be mocked with an interface (eg a `UserAdminGetter` or something similar) 2. Use integration tests to verify things truly work - you can't be 100% positive unless you do so at some point 3. Complex mocks typically aren't worth all of the effort only to verify a few small details If I missed something let me know, but I think those are the major points, and I agree with all of them. I didn't mean to imply that I don't do (1), so that was possibly a mistake on my part. Regardless, it is almost always a great idea design wise and I encourage people to do this a lot myself. The only two things I'd actually like to comment on are (2) and (3). For (2), what I'd basically say is that I agree integration tests are useful at some point, and I agree that anything using the `UserAdminGetter` could be a unit test w/ that part mocked. What I would ideally also like to do is add a few sanity checks when testing the `UserAdminGetter` that don't require a real database connection, but as you stated with point (3) this is hard to do without overly complex mocks. My overall point was that if interfaces supported the use case described above taht this would likely be much easier to achieve making it no longer a "ugh, it isn't worth the cost of writing that complex mock" situation.
What in particular? Both of the things I mentioned use Git.
I'd be really interested to read or see more about how you developed and tested your game in the browser! And huge props for these libraries. I'd love to have the time to use them for something haha.
It would be cool to select your own GC. I'm not sure if that's currently feasible, but that would be an interesting direction for Go to take. I'm more interested in Rust for gamedev due to a lack of GC, but who knows, perhaps Go can adapt.
Me too!
Thanks for the detailed reply!
Very cool. You writing this? Let me know so I can use it!!
On another note, as I am a total noob still with Go, I am hoping there is a way to load dynamic Go code to support runtime plugin capabilities. One thing I like about Java is that ability to provide an interface and then load code at runtime that implements it, so you can dynamically swap code, or load multiple different implementations like plugins. Do you know if that is possible? If so.. how? I need to read up on that.
Project link: https://github.com/go-task/task A bit more than one year after I started this project, the version 2 is released. Task is a task runner/automation tool started because of my frustration with Makefiles and lack of good and easy alternatives. The biggest change for v2 is that now the Taskfile has a version indicator, so we can change the format without breaking existing Taskfiles. The syntax changed a bit. For those who are already Task users, please check the [Taskfile versions](https://github.com/go-task/task/blob/master/TASKFILE_VERSIONS.md) document. Please don't hesitate to feedback, contribute, etc.
Vulkan might solve performance issue, but portability would be problematic (at least browsers don't support it)
Sure, if you're incrementing a pointer in loop, defer has *tonnes* of overhead. 
&gt; Is the process you used to build and release your games documented Not yet for the whole process. Go part is just only a part of our games, and actually we needed some other libs like ReactNative and so on. Let me think to write this. &gt; Or are these just some packages of what you need? Yes, these are just packages we needed.
Like is Gitlab encrypting for you or are you just shipping encrypted files to them?
thank you for the really helpful tips, I've updated the code
yeah, no reason, must be a leftover from the old experiments, fixed, thank you
thanks a lot for the tips and feedback, I've tried to improve the code. regarding the `printFiles` semantic, I believe, it's a naming issue, as I don't have files in my tree if I'm not printing them, so, passing it to the print func makes no sense, as it prints what it gets (with or without files) I renamed to 'includeFiles` and it seems better now.
[removed]
thank you, I took some time to create a version using `Walk` https://play.golang.org/p/O-m_XZk0GvS Gee, it looks so complicated to me, perhaps, I didn't use it properly, but I tried to avoid maps or bi-directional trees. I use just stack and parse the Walk output line by line into my struct. I'd appreciate if you show a better version with `Walk`
How is this simpler and easier to use than make? 
Probably because op is more familiar with Task due to developing it.
According to the documentation: *The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB.*
It works on windows.
make works on windows
&gt; Everyone here will also say that ORMs are the devil, meanwhile I know many professional devs who leverage them successfully all the time There is nothing wrong with ORMs per-se, and nothing wrong with GORM if it fits your use-case. Your specific problem is that you have not separated your concerns and that tight coupling is making testing difficult, as tight coupling always does. I understand that a certain popular framework released 14-some-odd years ago decided to throw all basic architecture principles to the wind and encouraged that you mix your concerns all spaghetti-like. That may very well be the root of why you want to apply the same patterns in Go. But I will point out that certain framework also encouraged you to use an actual database for testing. It was only later that people figured out that they could abuse the language to mock the ORM supplied with that framework in ways that one should not abuse a language. That you find it difficult to abuse Go in the same way is probably a good thing. I don't actually disagree with your ultimate premise. However, your use case to describe why it should be that way detracts from the cause.
Point taken. I think using this specific example may have been a mistake but I still stand behind the premise that interfaces in Go being expanded to cover instances like this would be a net win. At some points I should find other examples of why this matters, but it's been a long day so I'm gonna let it go for now.
The db connection maintains a connection pool. Opening a new connection on every request is no bueno. Also look into gRPC. It’s blazing fast. 
gRPC
For someone new to both make and task. Task definitely is much much easier to pick up. 
My experience with Make on Windows was painful. There are many Make distributions for Windows, many incompatible with the Unix version. Even those that were supposed to be compatible have it's quirks. Unfortunately, Task (it the Bash interpreter Task uses) still lack some bash built-ins, but other than that, it should work identical on different OSes.
Thanks for the suggestion. I don't know how one tool gets published to Debian repos, but I think that probably the Debian guys choose what to package and package that themselves. If you have any tip, let me know. But I think this is unlikely to happen.
I just wondering why he stopped using mongodb... is there any better alternatives?
Unfortunately make is universal and isn't going away in the next decade.
Oh right yes I'm not actually aware of GitLab's encryption if any. Private repos are private but if you're really worried about the server being hacked then that might not be adequate.
I suppose this is where CMake comes in, a meta build system to generate build scripts for your native platform.
your lib module name needs to be something actually descriptive. it also handles multiple disparate things that aren't entirely related. separate those concerns properly. the url you contact should probably be multiple environment variables (one for the format string, the other for API key). You'll need this even more if you actually test your service with fakes for failure scenarios. ensure they have sane default values. the stock symbols are another one. make these configuration values. If I wanted to add a different stock I (nor you) should need to recompile. lib.MarketDataMap screams poor abstraction to me. Modules aren't objects or containers, don't treat them like one because it makes them harder to test. speaking of tests, you have zero tests but a lot of functionality that has dependencies. abstract those components so you can test them properly. when your stock list is small it's probably fine, but your tight loop to check all of them at once will probably get throttled (if they do any throttling that is) so you should expect it rather than trust they'll always let you spam them with requests. Thinking about the list of stocks as a queue and pulling them on an interval so you're not spamming the service that provides your data is a 'good citizen' thing to do. time.AfterFunc() recursive chains is a node.js (read: not idiomatic) way to handle concurrent routines. Don't do this because it's a lot harder to debug failures. Prefer an infinite for {} with proper shutdown/cancel signaling. You should also be handling shutdown/interrupt/cancel signals in general.
While Debian maintainers do decide to package open source software and ship it in Debian, I think upstream authors can also step up to maintain debian packages for their own software. https://www.debian.org/doc/manuals/maint-guide/
&gt; your lib module name needs to be something actually descriptive. it also handles multiple disparate things that aren't entirely related. separate those concerns properly. So, split them up into "security" and .... "data" or something? &gt; the url you contact should probably be multiple environment variables (one for the format string, the other for API key). You'll need this even more if you actually test your service with fakes for failure scenarios. ensure they have sane default values. What is best practice for this? Read it from a .yml file? &gt; the stock symbols are another one. make these configuration values. If I wanted to add a different stock I (nor you) should need to recompile. This, for sure, I have thought about! Even passing them as an argument when starting up the service, or something similar. &gt; lib.MarketDataMap screams poor abstraction to me. Modules aren't objects or containers, don't treat them like one because it makes them harder to test. Can you elaborate on this - I don't think I quite understand. &gt; time.AfterFunc() recursive chains is a node.js (read: not idiomatic) way to handle concurrent routines. Don't do this because it's a lot harder to debug failures. Prefer an infinite for {} with proper shutdown/cancel signaling. You should also be handling shutdown/interrupt/cancel signals in general. So, instead of afterFunc, I should just use an infinite for loop which calls the function itself recursively at a specified interval? And yeah I'm coming from Java but have used Python and Node a bit too, so I have some brain damage for sure :P Thanks for taking the time to look at it! 
[removed]
Thank you. That looks promising. I'll see if I can figure it out :)
Yeah it was not much fun, but we needed to implement other parts than the game, like ads. I'm not familiar with löve very much, but does (pure) löve do that? I've not achieved pure Go mobile game yet, but did almost pure Go: (e.g. [go-inovation](https://github.com/hajimehoshi/go-inovation))
An empty for {} will run until you specify a return, or you can listen for a signal from the OS to interrupt. Example here - https://gist.github.com/reiki4040/be3705f307d3cd136e85 
You project inspired me to reduce the number of files in my still-closed-source project. I've always been a fan of reducing cognitive load. Go is amazing for that: it does things in a simple, non-fancy way most of the times. I have a project with ~10k lines spread among 50 files and it's quite distracting to navigate all files while developing. I'll try to reduce it to 5 files including tests. Thank you!
But how would you add recursion as I did, for example?
For some reason, I read this as Task list for V2.0.0 is released and thought it's about Go v2
Recursion is unnecessary, a more idiomatic go approach would be to run the infinite forloop in a goroutine and share the data through a channel.
And then set an interval of which to call the API elsewhere? Since I can't spam it down.
Your best approach would be using the `encoding` packages from the standard library.
I don't see that. That is why I am asking and haven't gotten an answer yet. 
Haven't used channels yet but I will look it up. Cheers :) 
I've only used make previously, though I don't use it regularly, and reading the docs, I'd say task looks FAR easier to use. Perhaps make is easier for you if you develop C and / or use Linux most of the time but for people that are more Windows and no C, the similarity to package.json and descriptive syntax is quite nice.
I think I've maybe ONCE run into a makefile that was written correctly to still work on Windows. This makes it easier since you can use the same scripting regardless of where you are.
All my projects are on hold while I''m awaiting copyright clearance from a new employer to work on private things again, but I'm excited to try this out when I can!
nice try ( ͡° ͜ʖ ͡°), nothing works on windows
I wish in this example they'd have shown the real syntax. Eg: import person person.New() person.NewNeighbor() // vs person.Person{}.New() person.Neighbor{}.New() It's meaningful i think to remember how it'll be used, including the package name. Ie, in the `Person` example, `person.New()` is considerably cleaner, at least imo. Calling `person.Person{}.New()` violates the stuttering "rule". On the otherhand, `person.NewNeighbor()` isn't as clean of a win when compared to `person.Neighbor{}.New()`, that one is at least debatable. But yea, the stuttering on `Person` is pretty ugly methinks. 
[removed]
Like others have said, without protocol information, you simply can't know if more data is or is not coming. You need a blocking read. You can make a read timeout or similar. There is also Peek() which will let you know the next n bytes without advancing the reader, but you can only peek on what has already been sent. You can't know the future.
Yes, make is so good that for almost all non-trivial uses people use another tool (auto*/CMake) to generate usable/portable sources for make.
Well it doesn't have \t as a major syntax character, so that's nice.
I did try to suggest that this would be used where the namespace is shared, maybe I should have been more explicit about that. &gt; When writing your own applications however, the accepted wisdom is that you shouldn’t create subpackages unless you have clear reasons for doing so. Even more dramatic would be creating individual packages for each one of your structs, so you may provide separate New constructors for them. Apps *tend* to have several structs declared in the same namespace. That's where this approach is more useful, even if you don't capitalize the `new`, making it private to that namespace. I definitely agree with you however, `time.Ticker{}.New()` does feel ugly compared to `time.NewTicker()`. Obviously value receiver constructors seem to be most useful when you're in the same namespace as the struct which you're creating an instance of.
In general, use defer in order to ensure that your code is correct. I would not eschew the use of defer until you know that it's having a measurable impact on your real life program (hint: it probably won't unless you're doing something really weird).
p.s. Also, a point I should raise is that `time.Ticker{}.New()` isn't potentially ambiguous, while `time.NewTicker()` might be (ie, [time being an object and not a package](https://play.golang.org/p/WX8MBYbzV51), while `time.Ticker{}` will *always* be package.Struct{}). Generally people *do* know better than to end up with such code however. Just to add a viewpoint on the "is debatable" part of your comment :)
Wow this is super helpful! Thank you so much for posting.
Keep in mind when you do this you are implicitly declaring that your type is responsible for constructing new instances of itself. While many times in practice the semantic difference is irrelevant, you are potentially giving the type a responsibility it shouldn't have. Having a package level constructor function is saying: "this package knows how to instantiate this type". Having the constructor on the instance is more specific: "this instance knows how to instantiate another instance of the same type". 
I think I am understanding your post better now. I wonder if it would have been received more in line with your intent had you had it show the layered abstractions required to for making unit tests work, and then shown a "what if things were more simple" solution. I guess that is what you did, but others and myself jumped to the "here is how you handle that specific case" solutions. And I think that is the point of the Experience Report. Concrete problems with concrete solutions, where the existing "best solutions" adds so much extra to the mental model and code base as to render should-be simple things complex
I'd be a lot more likely to consider it if it didn't require writing YAML.
It's not really a constructor, it's an initializer. i.e. // Init initializes the Person struct to a valid state func (p *Person) Init() { ... } func NewPerson() { p := &amp;Person{} p.Init() return p } // Alternative to defining and using NewPerson person.Person{}.Init() I think initializers make perfect sense as a Go pattern. I don't think it's a good idea to call them constructors, though.
This is great feedback. Thank guys!
Haha, thanks!
Thank you, kind stranger!
I'm not too worried about that since Go won't let us break apart the concept of an exported type and an exported initialization sequence. If I want to export a type for some good reason that has no useful zero value, I already have to document that you can't expect `package.Type{}` to produce useful results anyhow. I don't think it makes a lot of difference whether you've got a mandatory init function or mandatory init method, just as methods that aren't participating in an interface are just syntax sugar around a function that takes the instance as the first parameter. Which brings up one interesting possibility this approach has, which is that method-based init can participate in an interface, if you've got some reason that multiple different structs can all take the same initialization parameters. Certainly not something I hit every day, but I've done some interesting meta-programming-ish things with that before.
Only if you ignore decades of open source written in C.
I'm not necessarily proposing this, but it's at least interesting to consider the question "What if calling `Type.Function` on a type implicitly created the zero value of the given Type and then called that function on it?" Then you'd end up with `time.Ticker.New(time.Duration)` and `time.Timer.New(time.Duration)`, which doesn't seem catastrophic. No chance of that ever being an accepted proposal to shave two characters, though.
Why though ...
I abhor `make` being used in Go projects. [mage](https://magefile.org/) is a much simpler alternative, or you can just write `build.sh`, `test.sh`, etc.
&gt; is there a plugin? I'm guessing his post body "is there a plugin?" is a clue as to what he means. I think he must be asking if you can install Go support into IntelliJ via plugin.
&gt; So, split them up into "security" and .... "data" or something? that's definitely an improvement, you might even find some stuff in your app.go file that could move into one of those modules. (like the early out check for authorization bearer tokens) &gt; What is best practice for this? Read it from a .yml file? I think there's multiple schools of thought on that, but [12-Factor](https://12factor.net/) has some prescriptive guidance on it. A yml file is also totally fine. &gt; Can you elaborate on this - I don't think I quite understand. You have a module that looks like a node.js module. It exports some public member (the map) and has a method to update it that you schedule as a goroutine. There are a lot of really specific usage details there, and those details leak into the caller's implementation. On top of that, because they're exposed as module level public members and functions, they're not mockable in unit tests. Ask yourself how you might mock the use of time.AfterFunc or http.Get in the update method. This problem you have now passed on to your caller. Maybe you create more module level variables to reassign these methods, but at some point this state could have more easily been placed in a struct so it could satisfy an interface definition instead and allow the caller to vary the implementation more clearly. the contents of the map, how they're keyed, when they're updated, etc. you also should be handling concurrent use of the map by locking it (perhaps with a sync.Mutex or replace it with a sync.Map instead) but you don't so managing data races is also left to the caller. the caller also needs to know how you populate the map to retrieve data out of it. these are all details the module should probably hide from the consumer, but I'd say the biggest error here is exposing a raw map to a caller, because they're not safe for concurrent use without a synchronization barrier (like a Mutex or RWLock). &gt; So, instead of afterFunc, I should just use an infinite for loop which calls the function itself recursively at a specified interval? others have chimed in on this, but recursion wouldn't be necessary. you'd simply loop forever. you typically would accept a context, channel, or other sync primitive to handle cancellation/shutdown of the goroutine.
https://golang.org/pkg/time/#example_NewTicker is better than that.
&gt; I think he must be asking if you can install Go support into IntelliJ via plugin. Then the answer would be yes, you can install the Go plugin in IntelliJ Ultimate 2017.3+ via the known route: Settings | Plugins | Install JetBrains Plugin | Go.
you could do it that way, or you could use a [Ticker](https://golang.org/pkg/time/#Ticker) i'd say either approach is fine
[removed]
Under which reasoning would you consider that a type shouldn't have a possibility to construct new instances of itself? At least singletons (let's leave out discussion if they are an anti-pattern) have had non-constructor initializer (`getInstance()`) functions that provided an instance of the containing class. And in terms of constructors, every example I know of has the constructor in the same class and not somehow... separate from it. Yep on the rest.
Well, yes. A rose by any other name would smell as sweet. :)
I don't think there's any requirement for `New` to return a pointer tho, and it's just a bound function to the class, so if anything you'd end up with `fg.g, err = group.Group{}.New()`, slightly more verbose compared to your final example (+3 lines if you don't compact the if clause), not that I'm against the Init() way, it's just two different sides of the same coin. Another comment actually pinpointed the semantic difference here between `constructor` and `initializer`. The constructor would provide a new allocation (New), while the initializer might just set/reset some values on an existing one (Init). I also mentioned it in the article, namely: &gt; Structs that don’t need an allocator or default value setup can completely omit the constructor,... In the main sense, constructors also provide a single instance, while an initializer would "reset" any number of instances that you can allocate with a single `make` call, as you've shown. Of course, this gets muted pretty quickly if there's a map you have to allocate within a `Person` struct as well, and you'd have to resort to a more thought out allocation process if you'd still like to handle that with one `make` call. I also have to thank you for taking the time to write your exhaustive comment and teaching me about the T.Init() idiom. I haven't noticed it (or didn't remember) in the stdlib so far, and now I hope to recognize it when I'll see it ;)
Was searching for the same a while back and short answer is AFAIK there is none. Basically the choices you have are: 1. Use C++ (e.g. [svgpp](https://github.com/svgpp/svgpp)) when you need speed 2. Use Chrome Headless when you just want to get it done.
You don't have to install Go on the destination. All go binaries are statically compiled with all golang internals. You just have to choose the plateform type at the compilation time: GOARCH.
A binary can still be portable without being OS agnostic.
So thats another question.. I havent yet seen how you would call C or native code from Go, or, in the case of something like using GPU and needing a dll (windows example), how you bundle/include/distribute your application. I am guessing in this case, you start to look at an installation program to bundle the different bits of your app and to install them correctly? Or is it pretty simple to just zip up the exe and dlls (and anything else) and have it unzip into a dir.. no installation needed? I am also guessing if you want auto integrated things like an icon on the Start/Task bar, that does require an installer of some sort? 
With Windows, you can zip up the dlls, since Windows looks for libraries in the same folder first. For Linux it's a little more complicated. But there are ways to package for Linux. Check out https://snapcraft.io/ for example.
Most of those decades people didn't write in make directly.
Posting this here because it mentions Go and the discussion it generates is likely to be interesting; not because I think these rankings are particularly meaningful or insightful.
That's a great reasoning. There are instances where types create similar instances of itself. An easy example is loggers. `logger.New("foo")` is fairly common. There is an implicit relationship to instances creating new instances. This style of "constructors" would give every instance a New() method. Are the instances related? Who knows, look at the docs. I'm not sure that's adding clarity
Great sheet. Will save it for later!
Are you maybe looking for this: https://github.com/golang/go/wiki/CoreDumpDebugging
&gt; I would like to get the time for analysis down. I'm being serious here: if your application doesn't crash, you spend less time analyzing it. Planning for failure is a good thing, but this reads more like you're designing for failure. That's... not the best design IMO. Yes, applications will do weird things, and you should program defensively and log verbosely when "weird happens"... but you shouldn't be crashing so much that you need such an elaborate design for debugging.
Yeah, I was looking for suggestions on how to implement a global with the db variable. I found this off [stackoverflow solution](https://stackoverflow.com/questions/31218008/sharing-a-globally-defined-db-conn-with-multiple-packages-in-golang)
I looked into the pros of gRPC; it's a nice library I'll probably use in the future. lol looks like it has a steep learning curve.
Because first, the arguments to `fmt.Println` are evaluated and *then* it is called. In this case, first `pow(3,2,10)` gets evaluated, then `pow(3,3,10)`, which executes the `fmt.Printf` from `pow` and then `fmt.Println` get called with the results of both `pow`-calls (which prints the 9 and 20).
Am I blind or are you not actually providing "an argument for value receiver constructors"? From what I can tell, you are providing primarily an argument for why one particular thing people could counter (performance, which isn't really something I would've been concerned with anyway) doesn't apply.
It seems so obvious now that you've explained it... Thanks a lot.
OK, I removed the asterisk.
&gt; Though I prefer the below form because it builds a good habit of allowing escape analysis to do it's job You almost universally do not have to worry about escape analysis and if your worry is based on the difference between `t := new(T); Foo(t)`, `t := T{}; Foo(&amp;t)` and `t := &amp;T{}; Foo(t)` I would go so far as to guarantee that it won't make a difference. That is pretty much what escape analysis is for :)
It would have to be some sort of context-specific thing; I don't think or propose that there would be a global one. But I could imagine something like AST nodes or something where you're got 6 different types of "Users" that all initialize the same way but have different behaviors or something (perhaps different permission sets). And it would have to be something where the interface could spell out the entire useful method set. But, still, it happens. I don't quite do this exactly, but I do have about half-a-dozen interfaces that specify "a method that will return a new zero-instance of whatever type you called it on" for one reason or another, which isn't quite the same thing but is at least getting close.
So Redmonk agrees with the Google trends someone posted here recently. I believe that with the addition of vgo and wasm, Go will get a boost in popularity.
www.gorm.io may be useful.
If you know Pyramid you will like Go. "pay only for what you eat" Pyramid helped me a lot to understand how to make my own framework in Go. I mean you don't need any external framework. You just add slowly what you need. Often you will do your middleware yourself. You can even do your own router like traversal if you want. For database, I use lib/pq and Postgresql. I don't see that is so much drivers ?
Yeah it looks nice, but it still has string stitching `db.Where("name = ?", "jinzhu").First(&amp;user)`, which is a bit problematic when you try do to a lot of dynamic queries in some cases. I'm looking for something like (pseudocode): `query.Where(User.name_col == "jinzhu")` etc.
FYI IPFIX is the name for IP Flow Information eXport, also known as Netflow: https://en.wikipedia.org/wiki/IP_Flow_Information_Export https://github.com/calmh/ipfix
Well pyramid still has quite a bit of functionality, I'd ideally try to avoid reinventing the wheel :)
You can chain the where's - eg `DB.Where(...).Where(...).Find(...)` You can also query with types: `db.Where(&amp;User{Name: "jinzhu", Age: 20})`
Awesome, can you do things like: `DB.Where(DB.And(clause1, DB.Or(clause2, clause3)))` ? 
Seems your code base is full of wonderful esoteric stuff :) I'd like to see the use case for that kind of interface if some of it is public?
I disagree about not "worrying" about escape analysis, where values live probably affect the performance of real world Go programs more than anything else. There is exactly one way to make an assumption on where a given value will live and that is by "worrying" (understanding) how escape analysis is interpreting the usage of your values. While I understand the compiler may *often* emit the same code for your 3 examples, it doesn't always: type T struct{ self *T } t := new(T) // escapes to heap t.self = t type T struct{ self *T } var t T // does not escape to heap t.self = &amp;t Don't worry I'm not looking to cash in your big guarantee :-) But I will highlight how carelessly defaulting to new(T) caused an allocation where it didn't have to. But really this isn't my main reason for making conscience decisions on how I declare values while writing Go programs, I do it because it shows the reader my intent. I can tell the author about the lifetime of the value with a simple alteration in my declaration, so why not do that? The benefits of hinting to the compiler what I'm trying to do is just a bonus.
See also godoc.org text interface: $ curl -H 'Accept: text/plain' https://godoc.org/?q=sql
It's not an either-or preposition, it's an argument why they shouldn't be blankly discarded. The most relevant (but possibly incomplete) list of arguments is in the closing section. Feel free to share your concerns if there's something you'd add and discuss, but please read the other comments first as well. People did mention that realistically this will not be usable as a public package api (`time.Time{}.New()` is stuttering), and I advocate this stuff for structs that live in the same scope, also as an alternative to the too-many-packages problem (mentioned in the article as well).
Learning gRPC looks more daunting than it actually is. You spend a little time learning protobufs and then you compile it into the generated Go code and you're off and running. Once you're familiar with protobufs you'll be able to go from zero to implementing your business logic in minutes. There's a few gems in the protobuf spec that once you're aware of them really help simplify your RPC interface, like "one of".
Well not sure what you mean by sensible, but feel free to extrapolate the playgrounds for [one alloc with new(T)](https://play.golang.org/p/7Lzx0pzC1t6) alloc and [zero for T{}](https://play.golang.org/p/Bq5esWR287M).
In the modern parlance of software development, "portable" means OS agnostic. Calling a binary portable because it can run on systems with the same architecture is a platitude.
Removed the asterisk didn't fix it, it just made Init() have no effect. You were probably looking for `new(person.Person).Init()` or `(&amp;person.Person{}).Init()`, which is basically a by-hand inline of `NewPerson`. I did [contemplate this stuff](https://twitter.com/TitPetric/status/971337992018321408) just before writing the article; Basically, `person.Person{}.New()` (i keep prefixing the package, like it's a realistic use case), is the most literal translation of something like `Namespace\ClassName::StaticMethod` from other languages. The second form would be somewhat a translation of `(new Namespace\ClassName()).Init()` which isn't really a *constructor* anymore, as we agree. But technically, I guess by the strictest definition, neither of them are constructors. `New` would be an [object factory](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)), I suspect. &gt; In object-oriented programming (OOP), a factory is an object for creating other objects – formally a factory is a function or method that returns objects of a varying prototype or class[1] from some method call, which is assumed to be "new".[a] More broadly, a subroutine that returns a "new" object may be referred to as a "factory", as in factory method or factory function. This is a basic concept in OOP, and forms the basis for a number of related software design patterns. Anyway, glad we're on the same page :)
If they are coming from a DOS/Windows development environment, then portable can certainly mean "can be ran on a different system without runtime" since Windows exe's are in PE (Portable Executable) format.
&gt; IMO, if there is no reason to do a thing, than the thing being unusual is reason enough to not do it. I'm sorry, I have to poke you a bit for such statements. At some point, everything was unusual, mainly because of the virtues of being new and thus unfamiliar. The car was invented before the seatbelt was - and boy, was it *unusual* at the time. &gt; Safety just didn't appear to come high on the list for American car purchasers. Nash was the first car to offer factory-installed lap belts, bolted to the car frame, in 1949. Some customers purportedly tore them out and cut them off with razor blades. Of the 48,000 cars bought with seat belts, only 1,000 reported using them routinely. In 1950 the option was removed. As Vice President for automotive research and engineering Meade F. Moore would later explain, the public did not accept seat belts, claiming they were a nuisance. Just by the virtue of something being unusual, doesn't make a thing useless. I don't want to drift from technical discussion too much, so let us return to the only fact I can address: Just refering to the godoc part. There's literally nothing binding `NewToken()` to the `Token` struct, apart from the fact that it's declared directly after a the struct declaration, and godoc groups it in this order. Godoc could be modified to sort value receivers first on the list of functions bound to a struct. There's no such thing as a "constructor" in Go, so even the non-verbal (but often written about) rule to create functions like `NewToken` are just an accepted de facto standard in the most literal sense, with nothing to enforce it (see context reference from article). Meanwhile, factory methods are a design pattern from something like 1994, and actually having them bound to structs creates opportunities to consider the responsibility of the construction of default values of a given instance, fall to the *declaration of the instance itself* and not an auxiliary globally scoped function. I think that's reason/incentive enough to consider limited use, but as you say: as you see fit :)
Or, if you already know strftime, http://fuckinggodateformat.com
Esperanto is vastly more logical and easier to learn than English. But if your goal is to talk to people then English is going to give much better returns on your effort.
I like http://gotime.agardner.me/ when I need to format time.
where is the Peek located exactly ? I clouldn't find it in net package.
I just use github.com/jehiah/go-strftime
I would suggest experimenting with it a bit. See http://gorm.io/docs/query.html for some examples to start with, and as you branch out enable log mode (https://godoc.org/github.com/jinzhu/gorm#DB.LogMode) so you can see the actual SQL queries being used. You can do AND and OR clauses, but they aren't quite the way you described. That said, you could wrap GORM to make them happen.
Nice! Don't hesitate to feedback once you try it.
Look in the bufio package
...except if you use cgo or something. In that case, you need to mess around with environment variables and linker flags a bit, iirc.
I'm not necessarily advocating for make but making claims like `simpler and easier than make` shouldn't be taken at face value without explanation from the author. Case in point, new people saying this is easier to use without actually using it vs. make. 
I’ve used both python and go for dB heavy tasks. I spend less time in golang writing raw sql queries and using go’s fantastic sqlx package to make it easy to populate structs than I did messing with python classes and sqlalchemy. Also, remember you’ll need a lot less server to get similar performance so a small amount of extra time spent writing performant go may be worth it. 
That's a great point. The fact the constructor is on the instance implies that the construction is stateful, else why isn't it a package function.
In Java for example, you new up objects with `new &lt;type&gt;()`, you don't instantiate the type (potentially with state) and use that to construct another instance. That would be equivalent to `new &lt;type&gt;().new()`. Also in Java, the constructor method is not really a "true" method, as it doesn't participate in any interfaces (as far as I'm aware), nor does it contribute to the API that the type is trying to implement. It doesn't exist on the instance generally speaking. So putting a true method on a type implies that every instance of that type, for presumably a good reason, can construct a new instance of the type. Some API's call for this: `github.com/gorilla/mux.Subrouter()` returns a router that is related to the parent. The child router needs access to the state of the parent during construction, so it makes sense to be a method not a package level function. This leads to potential readability issues, as in /u/sOunsofpErsistence comment, you can't tell if the two instances are related or if the construction was somehow stateful. You just have to read the docs, if there are any. Having a package function is absolutely clear: a new independent instance is being constructed. Having a method is ambiguous: it hints that the construction may need to borrow some state from the relevant instance, but it might not, so read the docs. 
Sign me up! Flying from Perth hurts the wallet big time :c
sqlx is the business. No "orm" style syntax. Know SQL isn't a bad thing and it is easy to port. I worked with ORM's in Ruby/Python land for a long time. It doesn't seem helpful with Go though. Also if you're using SQL there is no more... "how do I do this query in this ORM?!"
Puneage!
From a different perspective, Go is still the fastest growing. https://madnight.github.io/githut/#/pull_requests/2017/4 
&gt; using mongodb... I know pg support json doc as record unit, but is this the main reason?
What problem would that solve here?
 query.Where(User.name_col == "jinzhu") Not gonna work with go, because we can't override operators
It used to be: use javascript on the back-end because we are already using it on the front-end. Insert wasm. Now it will be: use Go on the front-end because we are already using it on the back-end. Jokes aside, won't every language get a boost (relative to javascript) because of wasm?
no peak function defined in bufio either
or you can just lookup google before deciding your project name
I really don't get why people like Gorm so much, it does soft deletes by default if you embed their Model struct, adding a deleted_at column to everything, which is horribly for querying and leaves data in your database. What I did when I was using Gorm is I created my own base model which only had the created_at field but not the deleted_at field, that turns of soft deletes.
Yeah, I don't expect go to be python so maybe something like: `query.Where(ops.eq(User.col, "jinzhu"))` would work? For now i'm just thinking in pseudocode.
It was early morning and I am in front seats total 352 attendees that have reached
&gt; won't every language get a boost (relative to javascript) because of wasm? I wish I could answer that. From my understanding WASM has been designed to be complementary to JavaScript and not a replacement. Yet somehow everyone seems to believe (or hope) that they will be able to stop writing JavaScript and start writing their favorite language in the frontend. That aside, I don't think every language will have the ease of Go when it comes to compiling to WASM. Assuming it will work that way, `GOOS=wasm go build hello.go` will be hard to beat.
That's an interesting site but it doesn't show 2018 yet.
Speaking about query builders, [this](https://github.com/ulule/loukoum) one looks pretty sweet. Pun intended.
Gobuffalo's ORM sort of does that and includes a migration system that isn't based on pure SQL migration files, but these more generic .fizz files. Most migrations frameworks I have seen in Go use pure SQL migrations which ties things to a specific DB system. But Buffalo is also a whole web framework that is makes a lot of choices for you like taking care of the frontend asset pipeline. If you don't want that, you might be able to use the ORM on it's own (it's called "pop").
&gt; GOOS=wasm go build hello.go Great point. 
... and a Go implementation of the protocol: https://github.com/calmh/ipfix
Is there a Live stream?
For a short period of time in the beginning, we accepted JSON and TOML because one person asked and opened the PR. But we shortly discontinued it because because few people used it and those syntaxes are much less flexible than YAML. Hard decision at the time, but necessary to keep we sane while the tool involved.
thank you guys, the project has been renamed :) It was more like a private joke internally but you are right it doesn't make sense since IPFIX is real. 
We have routing, template calling, interface for middleware, assets serving, request and response, logging. And even more with websocket for example. The benefit of working with Pyramid is that you know exactly what you need and where it will be :) for example authentification will go in a middleware. What do you miss from Pyramid that you don't see in Go stdlib ? 
Looks like it's an error from the MailChimp API, and it looks like the email you used should be valid... so this error is surprising coming from them. I'm going to add in a check for it though and just return an invalid email error if we get a 400 response from them. Thank you!
Did you start with go or did you try any other languages? If so could you elaborate on this a bit? Also would love to hear any challenges you faced as well as some of the library/framework choices used in your application. Thanks.
Yeah I didn't do it
Of course, that would work if the project implements it like that
Looks like Ebiten is surpassing Engo in the number of GitHub stars very soon. Great job!
I actually started out with PHP back in 2006, just learning web development in general with it and how to build dynamic web sites that use a database. Kept progressing and eventually built an affiliate network which took a year or so. After that I built my first true SaaS product, Navilytics, which was also in PHP. Soon after running that, I started to look into new languages and first sought out Node to use as the backend, but luckily found Go before I got too deep into the project. Built a couple very small projects to learn Go and React (like [resounden](https://github.com/beeker1121/resounden), the structure of this app is completely different, though) and then finally started building MailDB, and here we are :) Good questions. The toughest part Go wise was just figuring out the structure of the application, how to separate everything. Originally, MVC seemed like the way to go (the Node way), but after reading some articles from Ben Johnson and learning Go a bit better, eventually went for a sort of domain-service type structure. This isn't perfect in my opinion, but the way everything is separated out, and eventually pulled together where needed, makes it very simple to use, modify, and navigate imho. Will be writing an article on this soon. For framework and library choices - this project wouldn't be working if not for [this brilliant port of LevelDB in Go](https://github.com/syndtr/goleveldb). The search functions on the site just wouldn't return in the hundreds of milliseconds as they do, for any domain, if not for LevelDB. Other than that everything is pretty standard. Thank you for the questions!
I'd recommend to start small and use [`github.com/jmoiron/sqlx`](https://godoc.org/github.com/jmoiron/sqlx). As to "framework"; this is a very much flame-provoking topic as—on the one hand—there is a strong "start small" movement in the Go community suggesting to bootstrap your project using nothing but Go and its standard library and only throw more 3rd-party stuff in once you're confident you *need* it, and—on the second hand—Go has nothing like RoR, so everyone has their own pet web framework. I'm in the first camp (and [here's why](https://www.youtube.com/watch?v=yi5A3cK1LNA)) but if you insist on dealing with a framework the two *universal* recommendations are: - [Stay clear of Iris](http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html). - [Stay clear of frameworks which do magic](http://web.archive.org/web/20140625195045/https://codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/) — Go itself is entirely antithetical to magic.
&gt; The latest release mentioned this feature. Is it removing unused import on saving the file? No, this is removing the import as soon as it's not used in the file anymore, without saving the file, it's what I've mentioned here: https://www.reddit.com/r/golang/comments/82ilek/does_goland_support_automatically_remove_unused/dvace3n/
Well that seems to be one of more reasonable ways to create programmatic interfaces to sql that would be also cross database/driver that I can think of. I wonder if there are some ways golang orm's tackle this nicely.
Oh, i tought it was magic
Can you go into more details on your choice of the levelDB port, and why your chose a key value store over a relational database? I'm curious about the performance you are talking about. I work with a popular email SaaS, and we search through dozens of sharded datasets when looking up unsubscribed emails, and if it took hundreds of milliseconds, that would not work for us. Plus it seems like you store metadata with each record. My first, naive thought on what your schema should be is a domain table that has your domain metadata, then an email table which would have a two column index on the email prefix and foreign key domain. You could likely have another table that links potential similar records like john@example.com, john.doe@example.com, and john+linkedin@example.com. And to be compliant with GDPR, you might have each unique email address actually stored in the relational dataset as a hashed value. You might need to maintain a table of GDPR redactions (just the hashed value) to ensure you don't re-populate that email address into your dataset on the next crawling (assuming you are crawling for the data). This is all to say that I'm curious of how you set up your datastore, why you chose how you did, etc. While I feel there is room for a KV store, much of the data feels relational on initial thought.
Very good points and thoughts. One of the main goals was to use Go to try and keep the costs of the whole infrastructure as low as possible. We're storing hundreds of millions of email addresses. Along with each of those email addresses could be hundreds of source URLs that particular address was found on. As you can imagine, the size of the database required to do this adds up very quickly. MySQL was tested, along with PostgreSQL and even MongoDB. Sharding would have been required just to meet speed requirements if using MySQL or PostgreSQL, but given the size of the database, we would need either a few really powerful servers with huge memory capacity, or the dozens of less powerful machines. The costs of this though would add up. Just doing some quick maths on the GCE calculator, we could get 24 n1-standard-1 instances each with 3.75 GB for a total of 90 GB for $582.54 per month. 90 GB wouldn't even come close to our database size. Instead, the entire email database and application runs on a single n1-standard-1 server with 2 cores and a 1 TB SSD. We get these 100-200 ms response times pulling everything from disk. The crawler coded in Go is built with the same ideas. Crawl billions of web pages on a single machine, quickly, using just a couple gigs of memory and an SSD.
Neither Google trend or redmonk capture the popularity of a language well. Google can tell you how many questions are asked about a language. For me, I tend to not query for Go stuff. I look in the docs first, and maybe Google if I can't figure something out, if I don't ask a colleague or ask on a forum. For languages with good documentation, I think Google Trends will not give a good indicator of popularity. For Redmonk, they are looking at something more useful as it includes GitHub, but they are looking at PRs. But this could be more linked to buggy projects than popularity where more PRs are needed to fix things. Redmonk admits that they are not perfect and should not be used as a popularity ranking. I'm not sure the best way to gauge a language's popularity. It probably has something to do with current professional and personal use, job listings, repos, search queries, and community site postings. It is probably not worth it to do all that work, so we are left with Google Trends and Redmonk which might be the best proxies we have. At the very least, to see something show up towards the top of Redmonk, it signals to me that it has achieved some level of critical mass.
One more vector to add, cert transparency logs. E.g. https://crt.sh/?q=%25.example.com
Thanks for the response!
https://golang.org/pkg/bufio/#Reader.Peek
That makes sense. I'm spoiled bwith big, beefy database nodes. If you are running one one server, how are you handling backups? Or is that something GCE handles? 
Probably easier to abstract your database layer as an interface, and then write your actual sql for each dB if you need to support multiple dbs. Try to keep your business logic “above” the dB interface so you’re only writing the bare minimum database methods for each dB. Why are you so worried about writing some sql? It’s just not that hard...
GCE offers some guarantees with disk redundancy, but it's very easy to just create an image (or snapshot as Google calls it) of the disk on the GCE platform and that serves as the backup. You can even do this while the disk is attached to the instance, and the backup is incremental and automatically compressed for you.
Yup sqlx Get() and Select() are basically magic. :)
What exactly is the problem? I ran that on the playground and newVal evaluated to 2, as I would expect. 
What is the problem statement? &gt; I cannot seem to add other numbers to it does not count as one.
I have a little repo that reads the length prefix's of each message and only returns the bytes of complete messages.
Yeah I totally agree. I don't think there's any doubt that Go has been a success up until now. Even if you look at the same Redmonk thread discussed in [programming](https://www.reddit.com/r/programming/comments/82wpiw/the_redmonk_programming_language_rankings_january/) you can easily see that 3 out of 8 or so "comment threads" start with Go. Most of them end up being quite negative of course (except the comments where /u/weberc2 is involved). But negative or not, the fact that Go is discussed so much is a good indication of its popularity in my opinion. With vgo tackling dependencies for enterprises and WASM allowing Go to run natively on the client, the future only looks brighter in my opinion.
Seems like [it is working](https://play.golang.org/p/R2Z4mbbXHp6). What is the problem? P.S. Don't forget to check your errors.
Well, I've been meaning to open source this for a bit anyhow, so [here you go](https://github.com/thejerf/sijsop). The relevant type is the [Message interface](https://godoc.org/github.com/thejerf/sijsop#Message). Technically I could do the New() with reflection. Although theoretically, it could be the case that message objects need a bit of construction, so I guess even if I did use reflection I'd still have an option interface that could implement it. This is really a nice, simple protocol that is very useful for implementing simple network servers that want to speak back and forth to each other in a way that HTTP is not suitable for, usually involving session state being useful or unavoidable. I have experience that shows that even relatively new engineers who aren't experienced with writing network protocols can use this to fairly quickly come up to speed on what a protocol is doing. I've got several other places I use this pattern, but they're either much harder to extract, or I don't want to open source it.
I put the fix in the post, turns out to be an issue with casting it back to a string. Thanks! 
The issue was it didn't seem like the number was incrementing but rather giving a formatting error. What I didn't check was the conversion back to string. 
It doesn't look like Go is strongly typed on the assembly level?
Almost all assembly languages are not strongly typed, although there are research projects in this area.
.NET's is strongly typed.
New update: I've succeeded to embed our game in Ebiten into Twitter card: https://twitter.com/hajimehoshi/status/972148503479644161
I think it's better if you open an issue on https://youtrack.jetbrains.com/issues/Go as I'm not sure if this is the best place to get help for this. My initial thought would be to ask you for a screenshot of ` Settings | Go | Imports `.
The https://en.wikipedia.org/wiki/Common_Intermediate_Language is for the virtual machine, not the processor it's running on. The underlying processor (which Go's assembly is targeting -- mostly) is not.
&gt; They're just a sequence of bytes. In general: Yes. In detail: No. There are several operations built into the language which make UTF-8 the de-facto encoding for strings: * `range` assumes an UTF-8 encoded string * Escaped unicode-characters in string-literals are encoded as UTF-8: e.g. even though `"\u2665"` is ASCII it encodes to the bytes `[]byte{0xe2, 0x99, 0xa5}` * Similarly, `string('♥')` and (equivalently) `string(0x2665)` are both encoded as UTF-8, even though the rune/integer literal are both denoting unicode code points, not UTF-8 bytes It may seem pedantic, but IMO it is both incorrect to say "strings are UTF-8" and "strings are just a bunch of bytes". I think the most precise way to phrase it would be along the lines of "strings are canonically UTF-8 encoded but this requirement is not enforced".
Yes, and machine code is the processor's intermediate language that it turns into electrons moving around.
Last commit 2 years ago?
Hardware costs are an almost insignificant fraction of the costs to run a server in production.
The Go community already has a pretty negative reputation, let's not add to this :) Please try to imagine how you would feel if your first contact with a new community would be a comment like this. If you think the question is stupid (I don't), it's fine to simply not reply :)
https://github.com/killingspark/restic-cronned The jobs take advantage of channels to get triggered. 
I used the ghodss/yaml to do the conversion and for most part it works, except when I append the byte slices, I am missing yaml selection item "-". I will also the try the above method but it would need conversion of interfaces.
Yeah, GO is new to me... I started all of this about a week ago and just have been playing with GO + MUX + HTTP. I never did program in C or C++ so some of the unassumed things are new to me. 
Well, welcome :) It's fine to be new, I hope you keep at it and keep asking questions :) (and FYI, there is a #golang-newbies channel on the [gopher slack](https://invite.slack.golangbridge.org/) specifically dedicated to asking beginner-questions; it might be interesting to join that).
If you're not using a RDBMS, how are you storing emails and metadata? Also, thank you for sharing goque. An in-app desk-backed queue is a great solution for some things.
&gt; Edit: Thanks everyone... outside of this I was casting it back to string to place it in a cache... looks like you can't use string(int64) for int64s but rather need to use strconv.FormatInt() num := int64(61) fmt.Println(num, string(num)) prints `61 =` The int64 gets interpreted as a rune. As you figured out `strconv.FormatInt` is what you want to use. Also make sure to get familiar with the [fmt package](https://godoc.org/fmt). The printf functions allow a lot of control over the formatting for any types including integers.
That is really cool! I got [this far](http://instantshare.win/1li0bbltp87jj.png); is that close to end of game?
I found hooks and event system easy to implement in Go. acl system is the only things I found not easy to do. I mean to do the right way and reuse. I did a cms with traversal with Pyramid and zodb that I'd like to rewrite in Go. Don't know exactly how I will do it but It'll be a fun challenge, and for sure no framework exist like that !
&gt; Each code point takes up 3 bytes in UTF-8. Each code point takes up from 1 to 4 bytes in UTF-8, depending on the plane of the code point.
First of all, thank you for your detailed answer, but maybe i should have asked my question differently. I will try to explain my problem. I'am writing a program which outputs user inputs into a csv file. The csv file has the ascii encoding. My problem is now, in germany we have special characters like "ü", "ö", "ä" and "ß". If i try to import the csv file, which has ascii as encoding, into a database the characters mentioned above get replaced with a "?". I found out that, if i change the encoding to utf-8 the file gets imported correctly. I wanted to know if there is a way to set an encoding of a file while creating it. Kind regards.
Will do. Thanks for the tip!
its typically used for threading; threading is most commonly used when you need 2 cpu loops, ex: go DrawAllUI() go Sort1millionRows() go HandleUserInputWithNoLag() for example if you sort 1 million rows of a array while your UI is drawing anything: the mouse would stop responding and the UI would stop drawing typically MS windows and other UI's use 'message passing' to handle events between threads.... which is like javascript events, or callbacks: sendMessage(MyApp, WM_EventSomething, DATA1, DATA2) //is roughly equivalent to foo.trigger('click', {data: asdf}) and these are cross-thread communication but now you can use channels too to communicate between thread: events &lt;- someObjectGenerator('click', map[string]int{"x" : 0, "y" : 0}) 
Not yet unfortunately.
No hostility was intended. It was just a simple answer. The question isn’t stupid but the it also wasn’t “how do I write a UTF8 file”. Similarly if someone asked “does go have an ORM equivalent to sql alchemy” I would reply “no”. 
&gt; I wanted to know if there is a way to set an encoding of a file while creating it. But the answer still stands. You can write UTF-8 to a file, no problem. For example [this code](https://play.golang.org/p/cO9cy1eTn4N) will write some UTF-8 to "foo.txt". The file will still only contain bytes and does not "have" an encoding. Your problems could be caused by many different things, but most likely not Go. Let's walk through it: * You say you are writing user inputs into a csv file. Where do you get the user inputs? Are you reading them from stdin (e.g. via fmt.Scan*)? In that case, maybe your terminal isn't writing UTF-8, because your locale isn't set to one that does. You'd have to either switch to a UTF-8 locale, or decode the user input from the encoding that is specified in the locale (most likely ISO 8859-1 if it's not UTF-8?) * If you are not reading them from the terminal, but e.g. via a web-request or something, you have to rely on the `Content-Type` header or other out-of-band information that specifies the encoding used. * Once you know what encoding the user input is in, you can try and decode it using the library I linked. You can also try and find good Go bindings for iconv, which is the C-library that is usually used to de- and encode different character sets - or another, similar Go library. * I assume you are not touching the bytes themselves, after you read them and are just writing them out; that means, that whatever encoding the user input is in, that's going to be the encoding of your csv file * The database *might* try and read a UTF-8 csv-file as ISO 8859-1 or vice-versa (both would lead to the symptom you described), so even if the user-input is correctly encoded and written correctly, it might still jumble it up. What do you mean by this: &gt; I found out that, if i change the encoding to utf-8 the file gets imported correctly. As I mentioned, files don't "have" an encoding, they only contain bytes. So this most likely means you are using some other program to convert the file from one encoding to another? Does it tell you which encoding it guessed?
Been using them in a pipeline for a replacement for cloc I have been working on https://github.com/boyter/scc I’m a totally new Go developer so nothing fancy is going on in there. I suspect if you are new to it it’s likely to help with understanding. 
[removed]
I'm not sure you can have something like zodb in go? I'm postgresql fan myself though.
https://github.com/klauspost/pgzip/search?q=chan
Doesn't seem to have any updates to open issues and PRs, nor any commits in 9 months. Abandoned?
Just a friendly reminder that, as far as I know, you aren't allowed to use the SAP logo on your website ;) 
If you marshal a struct to a yaml and the output is wrong then it‘s a bug in the library you‘re using for marshallinhg - in this case you should report them a bug on github. Out of curiosity why not gopkg.in/yaml.v2 for yaml?
&gt; How would you feel if the IDE automatically added imports to your program? The IDE can do that automatically as it will add imports only if they are not ambiguous, eg math/rand vs crypto/rand, otherwise the IDE asks the user which import should be added. Given how unused imports are a compilation failure in Go, having something that automatically adds/removes them is a good productivity boost. &gt; As a programmer you should be aware that you've removed a dependency. That is something you can see when you review your code. The IDE also marks the parts that you edited before committing so that you can review them.
It worked really really well in this case! I started writing the article using `gob`, but since I was dealing with circular data structures I quickly figured out I had to change my approach...
Welcome to Go :) Take a look at - https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies
I meant that the runtime is packaged into the binary during compilation. I never said anything about dynamic executables.
Ahh ok, we'll look into this, thank you.
Write less &gt; write more
How does that compare to NATS?
&gt; I was curious why some implementation of Binary Search Tree have root node in the struct and some don't. It's likely so that receiver functions can be used with the struct. This is an example of that in the blog article that you referenced. func (t *Tree) Flatten() []int { ... } 
Oh, why auto cut off few asterisk symbol like Node* (currentNode, int newKey)
Technically you can export from pa large main. But does it make sense? Are you ever going to import that package main somewhere else? I think that is the litmus test for exporting: do not export if you have no plans to import. 
Got it, gonna rename my functions then.
https://en.m.wikipedia.org/wiki/Internet_Relay_Chat
Non-Mobile link: https://en.wikipedia.org/wiki/Internet_Relay_Chat *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^158130
**Internet Relay Chat** Internet Relay Chat (IRC) is an application layer protocol that facilitates communication in the form of text. The chat process works on a client/server networking model. IRC clients are computer programs that a user can install on their system. These clients communicate with chat servers to transfer messages to other clients. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
You can get x smaller servers in different geo zones too and you still save a LOT of money. I know because I am doing it.
Depends on your business model, it's significant in mine and many others. In its disclosure, Snap has said that it is contractually obligated to “spend $2 billion with Google Cloud over the next five years and have built our software and computer systems to use computing, storage capabilities, bandwidth, and other services provided by Google.” **Of the current losses at Snap, more than 80 percent of those funds go straight into Google’s pockets.** Indeed *insignificant fraction*.
Same here.. That question deprived me of my last bit of youth
You need to map volumes between docker container and host. 1. Change mkdir and WORKDIR to use /go/src/github.com/YourGitUserName/app 2. Add the following to your docker-compose file: version: '3' services: app: expose: - "80" volumes: - ./:/go/src/github.com/YourGitUserName/app
I wonder what kind of load can this thing handle. I can see from code few channels created per connection, plus the Read/Write locks and go routines. So far it sounds memory heavy and CPU heavy; some benchmarks would be nice.
I did lol at the title “... modern IRC...”
Excellent feedback, thanks.
For start, this is obviously a much needed solution. I'm doing almost the exact thing that your script is doing half manually over and over again for the past 3 years. Thought to write such a solution myself but failed to find the time. Now I'm gonna test your appreciated work and provide actual usage feedback. Thank you
Awesome! Feel free to raise issues on GitHub and I'll be happy to accommodate
GCP bills include a lot more than the cost of hardware. Which is my point, I believe.
Thanks. My new job is 100% Go and I'll start in three months so it'll be handful !
Slack but less media friendly and more fun. 
I'm a postgresql fan also, but for a cms zodb is magic ! I don't think it can exist in Go but for my very little need I will write it from scratch.
I'd suggest starting with gometalinter, running it across your code, tuning it down as needed or desired, then adding that to CI. You really want a tight loop at first without a CI system showing you down for the initial tune.
Lucky duck
What I read was that you can still link it to you project without making your own code open source. 
Yeah, my youth bit was 1 and now it’s 0.
Some useful CI services - https://github.com/golangci/awesome-go-linters#cloud-linters Properly configured Gometalinter is the best choice for development.
Yes and in most cases in my experience those things are over hyped and overpriced a lot. For example I helped one of my clients to migrate his infrastructure from cloud to dedicated machines and his bill went from 250k a month to 43k a month. He hired one devops guy and one more person to manage that which cost him around 220k a year. This solution works flawlessly for months now. In summary instead of paying 3 mil a year he is now paying 12*43k + 220k = 736k which means he saves over 2.2 mil a year. This is my point.
[Here is a basic intro to go:generate](https://blog.carlmjohnson.net/post/2016-11-27-how-to-use-go-generate/).
You get used to it. Also, sweet sweet fake internet points. :)
Mongo is unique in that they offer their own commercial licensing option apart from AGPL-3. They also offer publicly available binaries though, which have different provisions for use if i recall correctly. They license their db driver independently as Apache 2.0, so the code dependency is only against Apache 2.0 licensed libraries. This offering is comparable with the exception of a few points. The Go library they provide is EPL-1, which has similar restrictions to GPL licensed code (same license, disclose source) and while not all of their libraries for different languages are under this license, many of them are either unlicensed entirely, or are tightly bound to the MQTT library license they use, which is usually EPL-1 based. I'm not sure that legal will ever consider dockerhub a binary distribution method because there is a concern that building your own container from the project could be construed as a build time dependency, thus forcing you to be compliant with the license anywhere it is used. Anything GPL is generally frowned upon in corporations, but this specific project seems to have taken special care to either not think about it very hard, or went far out of their way to ensure no one outside open source uses it to make money.
Oddly I felt less self-conscious submitting awesome-consensus to proggit. Probably because I consider here to be my "home turf" and want to be more polite.
Modern... IRC ... both in the same sentence lol
This is pretty sweet. OP did you work on this directly?
I don't think its impolite to share your wisdom! 😉
well done
This guy gos
Is there a good formatter for comments? I would like to auto-format comments to 80 characters. 
Can run in a terminal window and uses less ram. 
I am 27 and this 
I'm a bit sad there aren't really job opportunities in Go here in Finland.
In France this is quite rare. I got lucky to find this :)
Does this work ? https://golang.google.cn/ There was a blog posts saying it's accessible in china https://blog.golang.org/hello-china but no idea if you can actually see the blog post.
"video file" is unfortunately not a very useful qualifier - there are numerous different video containers. If you can narrow it down to a single container type, or a limited set, there may be libraries that will let you read metadata for the contained streams. As a more general answer, there's certainly nothing stopping Go as a language from obtaining this information from files in pure Go, it's just a matter of writing parsers.
The first link works, and the blog is not accessable. Many thanks.
Have you seen ./golang.org/x/tools/imports/fastwalk.go ?
To get a more accurate benchmark, just append the file names to a slice, so you’re not measuring output buffering times. 
Related go issue: https://github.com/golang/go/issues/16399 It would be cool to add why fastwalk/godirwalk is faster (avoiding extra Stat calls) than walk.
It is just a convenience, sometimes can be useful as it is an extra layer of indirection, but you can do that with a double pointer to any given Node too. 
Think of this as an opportunity to learn about VPN and what it can do for you.
China can block VPNs
Sure. The video file will contain metadata describing its contents; [here](http://www.file-recovery.com/mp4-signature-format.htm) is a brief description of the MP4 container headers. Open the file, read in an appropriate number of bytes, look at the bytes in the correct position ( depending on the format you're reading ), and you've got your data.
&gt; golang.org/x/tools/imports/fastwalk.go Both that and https://github.com/mattn/go-zglob/blob/master/fastwalk/fastwalk_unix.go use the same design as godirwal, although the imports one has workers (probably won't show in tests that don't drop the kernel caches).
I see your point. Apologies if my previous comment appeared a bit snippy. What I wanted to indicate is that it depends on how to define "intermediate language". For some, "intermediate language" means a language that requires a virtual machine *at runtime* to execute the code, whereas for others it means just an intermediate format before the final step of compiling and linking, which produces real machine language to run on a real processor. This intermediate format is well suited for applying hardware-independent optimizations to the code. Go's final compilation result is native machine code. [There is no Go virtual machine at runtime.](https://golang.org/doc/faq#runtime)
[author of godirwalk] TL;DR: Version 1.6.1 released this morning is even faster, and is now tested on FreeBSD. It was pretty cool to read Ben's article this morning. The neatest thing in the world is to see how folks use a library you've written. A couple of things stood out to me: the library has a few usage examples, and the main one lacked setting optional ScratchBuffer and Unsorted options. Examples are meant to be easy copy-paste snippets of code, and that's what folks will do. The lesson I learned is to make sure the examples provided are how I would actually use the library. The `Unsorted: true` option speeds up walking directories because it will skip sorting the names of a directory's children prior to visiting them. For large directories, this is a huge performance boost. Whenever the application allows for it, I set this option to true and skip the sorting. However, if your program needs to walk the file system deterministically and in alphabetical order, leave this option off. The next oversight in the example I had provided was not setting a scratch buffer. Setting a scratch buffer is so important for performance that I updated the library to set one to 64 KiB if the upstream code does not explicitly set one.
Thanks. .NET also doesn't have a virtual machine at runtime. .NET IL is compiled to native machine code. Sometimes this is done immediately before execution (JIT) or immediately after compilation (AOT). .NET's IL was designed to have multiple languages running on top of it while still maintaining type safety. It looks like Go's IL was designed for Go and only Go and to be a very this abstraction over native machine code. Neither is better than the other, I'm just trying to get a sense for the design of the internals.
Oh damn, I had no idea VPN are all blocked there. Sorry.
The Go compiler complains about unused imports and variables. By assigning to `_`, you can "use" an import or a variable. This can simplify the code generator because it doesn't need to keep track of things that may or may not be used -- it can just spit out an import block and ensure that all the imports are "used", regardless of any other options that control the actual code generated.
Appending the results to a slice would start measuring the runtime in growing the slice over and over rather than enumerating the file system. A similar alternative would be to increment a counter in the callback handler, and print the counter before the program terminates, to make sure the numbers are the same.
The description of what this is confuses me. What is this? Is it ceph on k8s? Is it more than that? I can't tell? What problem does this solve?
You can run a local godoc server, it will have the language, spec, pkgs in GOPATH, etc. I have one that runs at startup for just the standard library and one that I run interactively for whatever workspace while I'm developing. Make sure you have the godoc tool: $ go get -u -v golang.org/x/tools/cmd/godoc $ go get -u -v golang.org/x/tools/cmd/... # I suggest getting all the tools. Systemd service file: $ cat /one/svc/godoc-std/service | awk '{print " " $0}' [Unit] Description=godoc-std [Service] Restart=on-failure Environment=GOPATH="" Environment=GOROOT=/ws/lang/go User=cstockton Group=cstockton RemainAfterExit=yes ExecStart=/ws/lang/bin/godoc -http=localhost:55555 KillMode=process [Install] WantedBy=multi-user.target Installing: $ cat /one/svc/godoc-std/install | awk '{print " " $0}" #!/bin/bash cp /one/svc/godoc-std/service /etc/systemd/system/godoc-std.service || { \ printf &gt;&amp;2 "[error] %s must be run as root\n" "${0}"; exit 1 } chown root:root /etc/systemd/system/godoc-std.service chmod 444 /etc/systemd/system/godoc-std.service systemctl enable godoc-std.service systemctl daemon-reload It's now available on localhost: $ curl -s http://localhost:55555/ref/spec | grep Introduction | awk '{print " " $0}" &lt;h2 id="Introduction"&gt;Introduction&lt;/h2&gt; Run interactively from the command line for just std lib: $ GOPATH= godoc -http=:55555 &amp; $ curl -s http://localhost:55555/ref/spec | grep Introduction | awk '{print " " $0}" &lt;h2 id="Introduction"&gt;Introduction&lt;/h2&gt; Run interactively from the command line for entire GOPATH. # if $USER == github username. $ GOPATH= godoc -http=:55557 &amp; $ curl -s http://localhost:55557/pkg/github.com/${USER}/|grep Package | wc -l 99 
You can preallocate...
Thank you very much for your comprehensive and useful feedback. &gt; The reason I'm saying this is that assigning function to a variable, because you want to override it later in your tests, may seem like a good idea at first, but complicates the "code research" later. A lot. From the very beginning I had a feeling that I'm not doing the right thing, for several reasons: it's quite easy to override a function and forget to restore it, for example... Also it doesn't seem to be right semantically: I'm not changing the variable in the release build. But I didn't manage to find a good way to mock functions. I've just read these two blogs posts. Using build tags for this sounds like a good idea, but I'm not sure that it's clear to me how to mock functions using build tags. Do I understand correctly that you are hinting at something like this? * Make all functions to be functions (without assigning to a variable); * Move all functions I need to mock into separate files and build them only when not running tests (by introducing a build tag); * Define alternative implementations for tests. I guess for tests I still need to assign functions to variables, because some functions should return different values in different test cases; &gt; try not to use `fmt.Errorf` result as a direct value for return. The reason is - it's extremely hard to analyse in method\function callers, because it's just a text. Same with `errors.New`. Create a new global variables - later you will thank you. I have a custom error type [here](https://github.com/m1kola/shipsterbot/blob/49994438cc64f07353ea7af5fd45f5a122c8ec92/bot/telegram/errors.go#L5-L11) and a global error variable for a specific case, because I need to understand difference between the following types of errors: * Something wrong with the infrastructure. For example, a storage (DB) is not not accessible. In this case I want to notify an user ("Sorry, something is wrong. Please, come back later"-like message); * User sends non-sense. Then the bot needs to reply like "Sorry, I don't understand you. I support the following commands: ..."; * I tried to route an update I received from Telegram to a specific group of handlers, but didn't found a match, so I need to try to route this to another group of handlers; * As an edge case of previous one: I tried to route the update, and found an appropriate group of handlers, but it looks like user sends something that we cant handle (unknown command, for example). Does it make sense? I use `fmt.Errorf` and `errors.New` only when I know that function callers do not care about this error much. But it's different in tests. If a function returns two errors created by `fmt.Errorf` or `errors.New`, I might want to check that I've got a specific error. Currently in few tests I'm asserting error text (using `strings.Contains`) which is stupid, I know. But I'm not sure that I want to define a global variable only for test assertions. Also I'm not sure that I actually need to assert specific errors when I know that function callers do not care about specific type of error. Probably I should just check that the function I test returns `error`, not `nil`. &gt; Sixth - prefer integration to unit-tests. I know it may sound weird, but too much of your code is overrided in test files, so you are essentially testing tests and not the app code. Or try to minimize the number of mocks. IMHO of-course. I don't want to have a database to be able to test my app code, that's why I use unit tests and mocks rather than integration tests. I'll, probably, add end-to-end tests to ensure that whole workflow works as expected and will run them only on CI. &gt; so you are essentially testing tests and not the app code Hm. I can't find places where I'm testing tests... If you see something like that in my tests, please, send me a link. I often have cases when a function `foo` calls a function `bar`. I override whole function `bar` when I'm testing `foo` to return a specific result and test `bar` separately. So I know that `bar` behaves in the way I expect and `foo` behaves in the way I expect. But I can't find places where I'm testing tests. &gt; P.S. You might want to fix Good catch! :) Thank you for your feedback and a lot of useful links. This is very helpful. Now I have a lot to read and try :)
Another project I created encodes data as qrcode animated gifs. It does not currently have the ability to decode 😁 https://github.com/keith-turner/qrcv I think its certainly possible to decode, but the decode code would take much more time to write. I have not found the time yet.
The goal of a function is to wrap the same piece of code written over and over again into a reusable unit. So if your question is "should I write functions", the answer is yes.
Might look into this. In general what I am doing is more likely to be run against files that are not in the file cache. 
I did try both actually. It made no difference to the actual count, which I suspect it down to how hyperfine works (have not looked at it source to confirm). Have updated the post with the count option though anyway to avoid this being raised as an issue in the future.
Sorry I think im abit unclear in my question, I have functions for it already, inside lets call it Project A, in project A i use elastic for logging. Now I am starting up a new project, Project B. Inside B I need to setup logging aswell, and going to use the same structure, elastic for logging. Should I have the same function in both projects or should i create a wrapper package, say Package elasticWrapper where I then put my functions and import it in both A and B? 
That's not a wrapper per sé, but rather a package which handles specified work which is to be reused. So I would say: yes create packages and abstract/wrap functions you often use in a package
Thanks Kirides, alright then Im not entirly on the wrong path!:) Is it called abstraction or do you know any place where I can find and Read more on the subject? 
Hi, all implementations except godirwalk seems to give you a FileInfo. If you need to look that up on every match I bet you'll quickly lose your advantage. Maybe the dirent contains similar info tough?! Could you please share some of your insight on the similarities and differences of the callback arguments? Maybe you can also share some do and don't of what people should use/avoid in their callback functions? TIA
First thing I did was create my own logging package. Was helpful for me learning the package system.
it's not a problem, don't take it too seriously
for example self balancing trees need parent pointer to ease algorithms,. But root pointer in every node is not needed in my opinion
Ye thats basiccly what Ive been doin, Ive been reading goinpractice chapter by chapter and is currently on the Logging chapter, great book for learning! 
He knows these giants came from Cambridge but he can't prove it - at least not without some chilly charms. 
One moment, he is discussing golang with his courageous mother, Stanley Connor; the next, watching with horror as snooty giants develop their library.
ah, i see your point. fwiw i think the "ecoji" decoding is probably more straight-forwrad than that of the QR code library. cool projects!
It is true that if you *do* need to `stat` every file system object then you lose some of the advantage in `godirwalk`, but there are some other optimization’s in `godirwalk` as well, so you might be surprised by a benchmark comparison.
You should take a look at the work going into IRC in the past few years. Lots of groundwork advancements and pushing new features into existing IRC servers and clients right now.
you can put them back in multiple directory, but your docker file should look something like this.. FROM golang:alpine WORKDIR /go/src/github.com/doomhz/my-go-project COPY . . RUN go get -d -v ./... RUN go install -v ./... ENTRYPOINT ["my-go-project"]
Generally the [Adapter Pattern](https://en.wikipedia.org/wiki/Adapter_pattern) is what you're describing, but it could also be used in combination with a [Façade](https://en.wikipedia.org/wiki/Facade_pattern) or other [Structural Patterns](https://en.wikipedia.org/wiki/Structural_pattern) from the [Gang of Four](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?ie=UTF8&amp;qid=1520805480&amp;sr=8-1&amp;keywords=0201633612) book.
**Adapter pattern** In software engineering, the adapter pattern is a software design pattern (also known as Wrapper, an alternative naming shared with the Decorator pattern) that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code. An example is an adapter that converts the interface of a Document Object Model of an XML document into a tree structure that can be displayed. *** **Facade pattern** The facade pattern (also spelled façade) is a software design pattern commonly used with object-oriented programming. The name is an analogy to an architectural façade. A facade is an object that provides a simplified interface to a larger body of code, such as a class library. A facade can make a software library easier to use, understand, and test, since the facade has convenient methods for common tasks, make the library more readable, for the same reason, reduce dependencies of outside code on the inner workings of a library, since most code uses the facade, thus allowing more flexibility in developing the system, wrap a poorly designed collection of APIs with a single well-designed API. The Facade design pattern is often used when a system is very complex or difficult to understand because the system has a large number of interdependent classes or its source code is unavailable. *** **Structural pattern** In software engineering, structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships between entities. Examples of Structural Patterns include: Adapter pattern: 'adapts' one interface for a class into one that a client expects Adapter pipeline: Use multiple adapters for debugging purposes. Retrofit Interface Pattern: An adapter used as a new interface for multiple classes at the same time. Aggregate pattern: a version of the Composite pattern with methods for aggregation of children Bridge pattern: decouple an abstraction from its implementation so that the two can vary independently Tombstone: An intermediate "lookup" object contains the real location of an object. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
good bot
Thank you whizack for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
This might be a good read for you. [The 12-Factor App](https://12factor.net/) While using ELK for log offloading is a good idea, you may want to consider that your application shouldn't need to know about its log archiving stack to operate successfully. Your orchestrator can handle offloading this data to ES through say FluentD or LogStash rather than needing to instrument every process you run.
Install the Task Management plugin as it's not shipped by default with the IDE.
What does this even mean?
What would your recommendation be? I left it alone on the assumption that you picked a reasonable default. Seeing as I want it to be fast for both small directories and large ones it seemed like a reasonable compromise. Have not looked through the source yet, but will probably do that over the next few days.
Why on earth is this downvoted?
Thank you for making such a sophisticated reply,which I don't completely understand.I'm still learning go command.Secondly,because Golang.org is blocked and I am not sure if the command with this website as the argument can run on my computer.
my beard just went grey....
It refers to this feature https://www.jetbrains.com/help/idea/managing-tasks-and-contexts.html
I don't get the meaning of this. We already have dynamic dispatching in Go, through embedding and interface mechanisms. Also, your code seems not to follow the best practices (a.k.a. "idiomatic Go"), so I'd suggest you to learn those!
That would explain why I am seeing no difference then, hence ill just stick with the default. If I am not getting enough performance out of it I can always tweak further or implement my own version which has just the subset I need to work with.
yes, this, times a thousand. log via standard-out (there's a reason it's called *standard*-out) in JSON with Uber's Zap library. The irony here is that I copy-paste the same `func init()` into all my microservices to set up the logger but it's better than the full elasticsearch setup/auth code.
How much more efficient is this than base64?
Do you have access to github or is that blocked too? You just need the source code for the tools so you can install them. You could also try the go get cmd with the can suffix. But all those instructions are for is running a site that looks like godoc.org on your localhost. It’s pretty convenient since it works while you’re offline and indexes your local packages so it shows APIs for the versions you’re actually using. Once you have the godoc cmd you can skip everything except and just run: godoc -http=localhost:&lt;pick a port&gt;. 
The `go get` commands won't work on `golang.org/...` import paths for him, since that domain is blocked...
It seems silly they've posted that post on the blog which isn't accessible. The post is short, I'll paste it here for convenience: &gt; Hello, 中国! &gt; 22 January 2018 &gt; &gt; We are thrilled to announce that the content on golang.org is now available in mainland China through the name https://golang.google.cn. The growing Go developer community in China can now directly access official documentation, technical articles, and binaries. &gt; &gt; The Go community in China is bigger than ever. In 2015, Robert Griesemer visited Shanghai to attend GopherChina, the first Go conference in the country. In the years since, it has become one of the largest Go conferences in the world with over 1200 attendees at their 2017 event. Over the same period, one of the most popular community-built Go forums saw their traffic increase threefold and the number of participants in Go-specific groups on social platforms like WeChat and QQ has grown to over 11,000 people. &gt; &gt; Go adoption within China-based companies has also increased, with Qiniu, Huawei, Alibaba, and countless others using Go heavily in their production stacks. &gt; &gt; We’re excited to provide even more resources for Go developers in China to supplement the excellent material already available to them, but this is just the beginning. We’ll be focusing on making Go more accessible to non-English speakers in 2018, so keep watching this space. &gt; &gt; By Andrew Bonventre
wtf for what you would ever use that &gt; Make your hashes more interesting. &gt; &gt; $ cat encode.go | openssl dgst -binary -sha1 | ecoji &gt; 🌰🏐🏡🚟🔶🦅😡😺🚆🍑🕡🦞📍🖊🙀🦉 ok that is a nice reason
&gt; Task Management great. thanks
A URL shortener that used Ecoji would be fun.
Is it inspired by https://github.com/AdamNiederer/base100 ?
Great! It looks like as of now it doesn't have nearly as many sources or options though. 
Also, mind linking the comparison? I'd love to see how things stack up.
What is that and why do we need it?
Github works in China. The forum mentioned in the blog post (https://gocn.io/) has download links. I assume they also have instructions on how to get around `go get` restrictions, but my Chinese isn't good enough to figure that part out.
Fair enough.
good bot
Thanks alot whizack, ill do some more reading on this subject! I really appriciate your time
Thanks, im reading up on that today!
Great tools this. 
Padding emojis are not really soft, opened an issue...
So basically an orchestrator that orchestrates an orchestrator? To me that translates to "if something does break, you're entirely boned since the structure is too complicated"
With build tags, you can define one implementation which is actually accessed fs\network\whatever and other test implementation, which internals (for example - expose global variables) you can override in your test files. 
Then this is a reason to pay for it.
A Go Kinesis library is already out there from amazon -https://docs.aws.amazon.com/sdk-for-go/api/service/kinesis/ Is the java library better than this ?
Yes very much so. It provides a bunch of extra features like: - Enumerating shards, if you add new shards it automatically discovers them and starts retrieving data from them. - Co-ordinating shard allocation to workers. Multiple workers utilise DynamoDB to lock a shard, ensuring only one worker processes a shard. - Parallel workers for each shard. You provide a process function and it launches a go routine of that function for each shard. - Checkpointing and recovery. The sequence number is updated in DynamoDB and if the node crashes it recovers this checkpoint. The java library also implements the following, which my library doesn't yet: - Automatic shard rebalancing, it will ensure shards are evenly distributed amongst workers.
The [example code](https://godoc.org/github.com/patrobinson/gokini#example-RecordConsumer) gives a good example of how to use it, it's a lot simpler than implementing one yourself and makes your workers stateless.
Pretty cool - haven't read through the SDK but is it not just worth sending in a PR?
The language is called "Go". "golang" is a keyword to perform searches using the Google Internet search engine.
Have you tried running anything stateful on k8s? So far, it hasn’t exactly been easy/automateble, but kubernetes “Operators” address that... and Rook is actually quite a cool example of one IMO. CoreOS has a good [explanation of the concept of k8s Operators](https://coreos.com/blog/introducing-operators.html): &gt; An Operator is an application-specific controller that extends the Kubernetes API to create, configure, and manage instances of complex stateful applications on behalf of a Kubernetes user. It builds upon the basic Kubernetes resource and controller concepts but includes domain or application-specific knowledge to automate common tasks. &gt; &gt; With Kubernetes, it is relatively easy to manage and scale web apps, mobile backends, and API services right out of the box. Why? Because these applications are generally stateless, so the basic Kubernetes APIs, like Deployments, can scale and recover from failures without additional knowledge. &gt; &gt; A larger challenge is managing stateful applications, like databases, caches, and monitoring systems. These systems require application domain knowledge to correctly scale, upgrade, and reconfigure while protecting against data loss or unavailability. We want this application-specific operational knowledge encoded into software that leverages the powerful Kubernetes abstractions to run and manage the application correctly. &gt; &gt; An Operator is software that encodes this domain knowledge” 
Are they implementing actual encryption, security, and distributed operation? IRC was nice in the 90's, but these (+ usability for the non-tech audience) were never the point there... 
&gt; What problem does this solve? Rook brings CephFS’s distributed, fault-tolerant persistent storage to kubernetes, making it easier to manage/scale a pretty important resource (beyond CPU and RAM) for folks operating large clusters. So, kinda a big deal if you fall into that camp IMO :)
No it was just something I though of. I think multiple people have had the same idea. In discussions on the unicode mailing list, people have told me about other similar projects.
Hello my friend, you were right, my datastream was ascii encoded. I used this library (https://github.com/djimenez/iconv-go) to encode the output into the file as utf8.
Nice work. I'm very interested for a "complete" version of this lib.
Don’t forget to use the ListShards API in favor of the DescribeStream API. That’s one of the big changes in KCL 1.9.0. The DeacribeStream API has a limit that can cause issues which you can avoid by using ListShards.
Thanks to all above for your help
Thanks for pasting the post, the helpful information is the link to Chinese local Go forum.:-D 
Thanks for this tip (and sorry for the delay in my response). Now when I build the image with `docker-compose build` it doesn't download the files from github. Excellent. I still do have an issue where I cannot re-build the go binary from inside the running docker container (always have to re-build with `docker-compose`), but I'll get that sorted out at a later point. Thanks for your help
I appreciate your reply. My main concern wasn't necessarily updating the app while the container is running (although that would be really nice and I will keep trying to figure that part out). The real issue was due to having the wrong volumes/workdir, as noted by /u/edwinTop Because those settings were wrong, Docker wasn't seeing the directories with code in them, and was assuming it needed to go out and fetch those from github (assuming an external dependancy). Lesson learned!
If imports don't become an issue subdirectories are also nice because people don't need to understand git to use/browse the repo on GitHub, and a decent chunk of your demographic likely doesn't know git well. That said, I have run into issues with the vNN approach when you have subdirectories with packages and want to import them because all your imports have to change each new version, so just keep that in mind.
I think https://github.com/neelance/graphql-go is better than https://github.com/graphql-go/graphql because of typed resolvers
I stopped reading at "Golang". The name of the language is Go.
Nice. https://github.com/TwitchScience/kinsumer is something similar, it implements shard re-balancing
I can only see a naive bayesian classifier in your repo, but in the post you mention an SVM and Neural Network classifiers too? 
Exactly. You live and learn. :)
Hey there everyone, thanks for checking out my project! If you have any questions or issues, feel free to yell at me here, happy to help!
The [sts](https://ircv3.net/specs/extensions/sts.html) extension covers some ground on the encryption/security front, automatically upgrading clients to use secure connections where possible. The various account caps like [account-tag](https://ircv3.net/specs/extensions/account-tag-3.2.html) can also help ensure identity when you're talking to other users. It's still super early but I've been playing with meshy S2S protocols to try and keep IRC's failure mechanisms while still helping reduce netsplits and similar network outages! As well as that, [various](https://github.com/ircv3/ircv3-specifications/pull/306) [extensions](https://github.com/ircv3/ircv3-specifications/pull/330) have been proposed to try to improve this, so lots of interesting stuff coming down the pipe for the protocol.
This isn't just a health check. This is an overloaded service. return &amp;Status{ .... numGoRoutines := runtime.NumGoroutine() Memory: Memory{ ... I'd suggest removing these metrics and focusing on health. Folks will want to use other libraries (like Prometheus) for metrics.
Thanks for this. Writing some code right now that i can use this for👍🏻👍🏻
Also, looks like you rolled your own WaitGroup / ErrorGroup in the checker routine. Would recommend using this instead: https://godoc.org/golang.org/x/sync/errgroup
Yep, that was my understanding. Thanks :)
I completed XML chapter for my free "Essential Go" book. The goal is to be pretty complete so it covers both the basics as well as more advanced use of XML parser in Go.
Do I understand it correctly? Is that finally something I can use to train my own model for non-English sentences?
You should be able to - it operates on bytes.
[removed]
Ah yeah thanks!
Of course! I couldn't find this earlier and that's why I wrote the library
No, KCL is a seperate library in Java and that's the way it should be IMO.
Try Google Reverse Image Search?
OK, I see this all the time and feel like I should say something. If you want people to check this out or discuss it, maybe post a description of what this package is about -- either in the linked page (release docs) or in the reddit post.
[removed]
Wow, this makes push notifications look easy! Great!
New version (0.2.0) is now available. Added JSONToken support. Improved documentation and examples. Added benchmarks.
[removed]
High performance, minimalist Go web framework https://echo.labstack.com
Thanks for the pointer. I’ve looked though all their stickers for “golang” and “gopher”, and while they have a bunch of cool ones, nothing similar to this one. Thanks so much for the suggestion!
I'll take 50 :D
Easily the best web framework for Go. Love it!
I don't see any use of namespaces, entities, or XML Schema validation in your examples. Is the core library actually good for anything except simple serialization? Or are we better off sticking with gokogiri (which wraps libxml)?
I've added those topics to my (never ending) list of topics to cover in the future. I believe standard library does support namespaces. It doesn't do XML Schema validation so for that you would need additional library.
[removed]
Found it! https://github.com/egonelbre/gophers/blob/master/vector/science/gas-mask.svg 
That is a lot smaller than I would've expected. type Coord3d struct { X, Y, Z int64 } So something like this at 24 bytes would generally have better performance passing by reference? In practice would it matter? Also in the situation that the struct contained a slice or map with several elements. I know that slices and maps pass a header rather their elements so should they be considered? 
This looks pretty cool. I'm planning on using go-chi on a new project but interested to hear feedback of anyone that has used Echo. What did you love/hate with it? At first look the echo.Context interface worries me with 53 functions. 
`Context` in earlier versions of Echo was a struct, changing it to interface gives you extreme power to overload it with your own functions similar to `http.ResponseWriter`. The key is to not think it like an interface int Java. For references check: - https://github.com/labstack/echo/pull/173 - https://echo.labstack.com/guide/context 
Stickermule and that SVG will get you 50 of em for a reasonable price, the stickers are great quality.
Right when you pass the slice you are passing just the slice info, not the contents, and having something like a Coord3d may be best to use values because they will be contiguous in memory. Rather than iterating over pointers to random locations in the heap. Though if you really want top performance you may want separate arrays of Xs, Ys, and Zs, depending on how you access them. 
Here's what I see: type UUID4 struct { bytes []byte // always 16 bytes of data } This makes a UUID4 take at least 16+24 bytes on a 64-bit CPU. In other words the slice header is larger than the data. You'd probably be better off with type UUID4 struct { bytes [16]byte } or even simply type UUID4 [16]byte though the latter allows direct access to the inner bytes, which you have deemed undesirable. --------------- bytes[6] = byte(0x40 | (int(bytes[6]) &amp; 0xf)) Why the cast to int? ----------------- DecodeString() makes a copy of its input inside Replace, and possibly a second copy in ToLower(). These copies are going to show up in a profile as a hotspot due to the malloc and gc costs. ---------------- Your unit tests are nice and thorough, but you might want some benchmarks. -------------- bytes := make([]byte, 18) in DecodeString() is pointless. You overwrite bytes on the next line. (Also 18 is weird for this code) -------------- if noDash[16] != '8' &amp;&amp; noDash[16] != '9' &amp;&amp; noDash[16] != 'a' &amp;&amp; noDash[16] != 'b' { That would be easier to test after the hex decode step, since it would become if uuid[8] &amp; 0xc0 != 0x80 { 
Though I love golang, why would I use kurly over curl? Kurly is not even at feature parity. I see in the readme that you'd like to replace existing tools using *modern and safe languages*, but that in and of itself is not compelling.
The Go ABI requires all parameters to be pushed on the stack. A register-based calling convention is an open bug: https://github.com/golang/go/issues/18597
I wouldn't worry about it until you see memcpy turning up in your profiles.
Totally agree. It's slightly better than posting a link to a tweet with no context. 
You'd be copying a pointer value which means indirection is required to get at the values. The copy itself may be faster using a pointer value, but you're making the accessing of the values 'slower' and less cache friendly. I think. 
That for sure is wrong in most cases.
I would suggest take another look at the error handling. Rather than sprinkling `log.Fatal` everywhere, make your functions return `error` and handle the error in `main`. Same goes for the `panic`s in `Downloader`, return errors instead of forcing the program to exit. `main` is responsible for cleaning up the program. Lastly, it's a good idea to handle the error returned from `GetPlaylistTracks`, instead of ignoring it with a blank identifier. Making a habit of not handling errors will bite you in the ass as your code grows, and it might be very cliche but, how you do anything is how you do everything. 
Yes, I agree. But I did not find any other way, I do not want the user to go get his own API keys. Is there a any better approach?
How does it compare to gin today? It looks very similar to gin. The one thing I can see is that echo has more frequent releases. The last gin release was more than 6 months ago. I'm still waiting for the new release to be able to bind query params to a struct. Gin is still actively developed, I'm just not sure why they don't do more frequent releases. This would be a big pro for echo over gin. So what about performance? Anything else I need to know?
It kind of depends, how far you want to go and when it is "too much" for this project. If you really don't want to display your API key publicly, you could build a service that distributes the token through a REST API, and just call that service.. But it is kind of far fetched. 
Awesome. I have been looking a fair bit into using go to help with NN productionization. 
This is quite interesting. I also wonder if there is a Go library like JPMML for parsing out and deploying PMML models. 
I was comparing different Faas offering recently, and I found it really strange that the Fission python builder directly depends on the 3rd party Flask Web framework and that it leaks the 3rd party api as the main interface of a python handler function. Why not create a generic handler function signature that a user should implement? In python it is easy enough to load a users function and call it with a context. You have to make calls into Flask to handle a call 
For anything performance related **benchmark** both solutions and see which is faster. There is no hard cut off for when one is better then the other and the only real way to tell is to actually test the performance of your application.
The last release was over 8 months ago. I'm waiting for a pull request I submitted to get a reply. 
This feels like an advertisement 
Another thing that is annoying me about Gin is that it uses a Travis ci configuration that requires it to pass builds against go 1.6. So that means my current pull request is failing because I used sub-tests
The package's README should start with explaining what differentiates this particular package [from the already existing implementations](https://godoc.org/?q=uuid+4). Legitimate reasons for multiple of them [do exist](https://groups.google.com/d/topic/golang-nuts/J_htXsnVjdY/discussion) but they should better be stated loud and clear to help the potential users decide. 
This raises the question, "what is an emacs"? And I can't really call something an emacs without the lisp.
The author(s) actually address this in the README: &gt; Timezones The location your server is configured effects the results! See example or https://play.golang.org/p/IDHRalIyXh and last paragraph here https://golang.org/pkg/time/#Parse.
Yeah. Where is my tetris and snake? 
Please beware: premature optimization is the root of all evil (or at least most of it) in programming - Donald Knuth, Computer Programming as an Art, 1974
It definitely does. Thought it was an actual reddit at ad first!
YOU LIKE CASTLEVANIA, DON’T YOU?
With or without Lisp, Emacs is all about being a live programmable editor. Having to bring up the Go compiler to write a custom function is not the same. Everything seems frozen and rigid (e.g. keybindings are hard-coded). Nice effort, though, I tested the released binary and it works quite well as a simple editor. 
At least you can quit the program easily.
But still, suppose I make a REST API, others can call the API and get the API key, right?
you could use kms instead of fbdev. It's available since SDL 2.0.6. on the rpi it's supported by the open source vc4 driver. On raspbian you can use raspi-config to switch to the open source vc4 driver instead of the proprietary broadcom one (which doesn't support kms). 
I'd say this fits in the group with `mg` and `zile` - following the style of keybindings, but not the functionality. 
Glad to see this. I had a similar script to identify dates but that is still covers much smaller cases then yours. I think I will drop mine and start using yours :) https://github.com/daptin/daptin/blob/master/server/columntypes/mtime.go
TIL about "Ersatz Emacsen": https://thestandardoutput.com/posts/evaluating-ersatz-emacsen/
Thanks a lot, I will give a look! I am spawning to much go routines for checkers and I really need to improve this piece of code.
Sorry, didn't mean that the API should return a API key. I meant that it should return the token. 
Great! Try and let me know if it can be improved in any way. Automatic tags is also along the way!!