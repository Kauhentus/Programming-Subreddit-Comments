&gt; if I had the option of immutability or generics for go right now I’d choose immutability Couldn't agree more. IMHO basically, if you want concurrency, you also want immutability. Also, immutability is probably much easier to implement and less likely to cause controversy compared to various generics proposals... 
I am all in for Generics. I think the language desperately needs them, there's only so much copy pasting, reflection and typecasting you can do before going crazy or doing silly mistakes that panic in runtime. However I don't like the contracts one bit. They seem so alien and complex at first glance(haven't looked deep into the proposal) that a lot of people will be put off by them, new and old gophers alike.
It is not a hype but rather a long and ongoing discussion about whether generics are needed in Go at all, despite what proponents of other languages say. Background: Generics include: - * generic types (imagine you could create a custom container type whose elements can be of any type, like the built-in slice and map types) and * generic function parameters (for example, a max(a,b) function that can take any parameters a,b that can be compared). The Problem: Generics are useful but also add complexity - for both the compiler and the programmer. Code using generic types or functions can simplify quite a few things, but "clever" programmers can also esaily write incomprehensible abstractions using generic types of generic types of generic types... Go is not about supporting highest-level abstractions and abstractions of abstractions but rather about getting sh*t done (that's my personal opinion). Many problems do not require generics to be solved. Bill Kennedy (instructor for Go classroom courses) once said he writes code since 25 years and never felt the urge to use generics. ("When the data changes, your problem changes.") That's why the introduction of generics to Go is so intensely discussed within the community. 
Thank you for this example, because it shows me how to make 2 linters that I wanted to make and it seems easy enough :-)
Very cool, thanks for sharing. 
Whilst anything Open Sourced is still popular people will maintain it. Part of the appeal to me is that the language specification doesn't keep changing. So I would be happy if it doesn't really change that much. External libraries will always bridge the gap to anything missing to the core libraries.
The only problem with your C# and Java claim is that Go ... just isn't like these languages. How much does not having generics hurt you, professionally? To be honest, I am getting tired of all these generics talks. 
\`require()\` or \`import()\`?
&gt; `require()` or `import()`? In the autogenerated go.mod file it says require. However I'm very new to the concept of go modules. So I might be missing something! 
Read the code https://github.com/golang/go
[removed]
Start looking at the code and documentation. Try to build the project yourself. If something doesn't work, don't get discouraged, start investigating. Ethereum has a test network, so you could compile and run the project on the test network.
The analysis API is quite nice. The source of built-in Vet passes are quite handy as well https://github.com/golang/tools/tree/master/go/analysis/passes
They aren't, but the concept of generics is universal, the way it's implemented is something entirely different. In my other post I explained why I think we need it and yes, it's hurting me every time I have to copy paste an otherwise perfectly reusable piece of code in other languages.
Depending on the team &amp; use cases. From my experience, I've seen more Go codes than Clojure.
One package at a time!
&gt; Documentation: Does all web frameworks need to have a complicated (or a lovely but lengthy) website to guide people how to use them? Well, Air has only one GoDoc with useful comments. In fact, Air is so succinct that you don't need to understand how to use it through a large document. Probably at least some form of complete documentation? I had to dig into the router tests to see what form of parameter and pattern matching is supported in routes. It wasn't in the godoc from what I can see. 
The greatest thing about Go is how it does packages. Let's not fuck it up. Thanks. 
aah, my mistake. This is `go.mod`. why not remove companyserver.com/path/to/common.git... lines on both go.mod and go.sum and rerun`go get -u companyserver.com/&lt;path_to_common&gt;/common` with/without revision/tag you needed?
It's like I said before, Go isn't Java/C#. The problem that I have is that "people like you" are pushing for things that are there for a reason: Simplicity!
Isn't it better to compare Go with Dart?
It makes you realize how other languages are going down a path go started with. Php getting declared datatype params as a feature? JavaScript and c# getting async await, all these new languages popping up using types as their main focus, Microsoft buying up most of the go advocates, posting Tony hoare on their front page, and now stealing plan 9 systems. You know, the usual.
 These types of comments do more discouraging of sharing then helping of others.
I need to have JavaScript just to load the page (ugh) and then: &gt; Login or register to see the full job description! Even harder ugh and close tab.
It's not FUD. Under the new model you either pay for Oracle JDK, or you pay the operational costs of developing against a new OpenJDK version every six months in order to continue getting security patches and bug fixes. Or use a downstream OpenJDK distribution that continues to backport those fixes beyond six months, which means you'll always be behind Oracle JDK for those important fixes. Tons of enterprise software is still using Java 7/8. This decision is going to force a lot of companies to migrate or upgrade sooner than they would otherwise have had to under the old model. 
There will always be people like you and people like me. Deal with it. I have my reasons, you have your reasons. The condescending tone will get you nowhere. If you despise generics so much maybe you can convince your team not to use them as well. On the other hand I am sick of interface{} in many cases it makes the code less readable than it would be in many other languages. In the end of the day it's our job to make the code we write readable and there's a lot of unreadable Go code out there as of right now.
I can see golang going far. It is not bad language and it is quite powerful. However, I am still not sure whether I like or not. It gives me headaches, when I am building reasonable error handling. And it certainly gave me hard time, before there was dep. &amp;#x200B; I will reconsider my opinion next year. Until than, more golang for me :).
Remember to checkout go modules.
Oh thanks a lot. Will do :)
Thanks
Yeah!! 
Hi /u/arp242 thank you for your feedback, it's appreciated. I will look into writing a ticket to make it more accessible to those without JavaScript. We've focused on making the register process as easy as possible (you can signup with your github). 
[removed]
How are you planning on rolling out (security) updates? How would a user install those? Is there a package manager that can take care of this?
Go modules definitely fixed the dependency pains for me. As for the language, idiomatic Go can a bit different from what you’d expect coming fro other languages (wrt error handling and the lack of generics) but the way it is is also part of it’s power. I personally learned to appreciate Go for what it is and love working with it.
&gt; you’ll want to do `i+size`. FWIW, you'd also need `&lt;=`, not `&lt;` - off-by-one error :)
&gt;I take big advantage of it to reduce my Maven builds from 40+ minutes to more like 6 - it's a lot of saved HTTP requests. Oh yes, this is a valid approach for sure. I guess my personal observation is... it feels like I'm doing something wrong from the beginning. I could hook up an external volume if needed, but want to avoid that if I don't truly need it. We use EC2 spot instances as build slaves, with a relatively short idle lifespan, so the act of getting the same server twice is pretty slim. We'd also have to consider concurrency limitations as having two jobs talk to the same "cache" has its own issues. This is where dockerizing the dependencies into its own image kind of works, but as others have pointed out, only until the go.mod/go.sum change and you have to re-build a new 1.8 GB image.
You need to sign in to read the full job description, otherwise you can see only first N words. That should not be necessary.
First off, a simple thank you for the time spent helping me understand go modules. Really appreciate it. I think re-implementing/extracting is probably my best bet. It sounds, at least in this case, the dependency tree for this project is massive and no easy way to cut it down/drop unused ahead of compile time using standard go mod utilities. Thanks again!
This is basically what I'm doing locally and to help local docker builds. I've also optimized my Dockerfile cache by first adding go.sum and go.mod and doing the go mod download as its own Docker image layer, and then re-copying my project in the next layer. This allows Docker to not have to re-evaluate that step each time I build. Found it in some blog post, not an original idea :)
But without them generics are pretty much useless.
It is simple and that is what I like. However, whenever I need higher level logic, I go for different tool. I tend to mix and match the golang with python and JavaScript and it works marvellously. &amp;#x200B; And go modules are a huge step. I have them on my todo list. Thanks for reminding me :) I forgot about them.
&gt; Arguments include: &gt; &gt; - additional complexity generics would add to the language That's fair I suppose. By consequence, the compiler gets more complex as well and might be slower (how much slower? depends). &gt; - generics sacrifice readability for writability, which is the wrong tradeoff I wouldn't say this is generally true. It depends on what you compare with what. If you compare a generic function to a non-generic one that takes a specific argument, then yeah, the latter is easier to read, obviously. However, comparing generics to type switches, reflection usage and/or code copy-pasting I wouldn't say they are doing so badly in terms of readability. I would say that generics are more honest about the readability/complexity thing. A type-paremetrized function or type definition can be somewhat harder to parse, but once you do, you're good to go. OTOH a function that takes the empty interface, for example, is easier to read but then some arbitrarily complex type juggling stuff may be going on inside which may or may not blow up at runtime etc. etc. A similar thing is true fore code copy-pasting... A single copy looks simple enough, but how many are there? And are they 100% the same code or slightly different? If I modify one, do I need to modify the others? Etc. With generics I can judge the complexity of some API more easily from a first glance (of course, this isn't bulletproof either, but it helps). Another aspect that many people seem to forget about is that generics lend themsleves pretty well to other useful things like documentation generation. For example, Rust is a fairly complex language and some generic interfaces are indeed pretty complex, but their excellent documentation generator makes up for this quite a lot. &gt; - non orthogonality with interfaces Yes, that's a weird thing. Personally I don't really understand why they introduced contracts rather then just enabling interfaces to be used with static dispatch as well. It would seem only logical and I don't think it would any worse in terms of complexity. Mabye there's some backcompat problem I'm not seeing. 
There will be no package manager. We are inspired by CoreOS in our strategy. The implementation ideas aren’t fully fleshed out yet but I imagine something similar. A user will be able to install via the CLI or an auto update feature. If your interested in influencing the direction we take feel free to join our slack and we can chat. 
For the _Oracle_ JDK, one of many JDKs out there. 
I thought https://ballerina.io/ was the language of the cloud.
Do those offerings give salary and the name of the company? What job offering pages are better?
I used to really like programming in Go, but lack of intellisense and such made it slightly more boring. Recently I installed atom and go-plus module, and it makes working with Go a breeze :D
Thank you!
For everyone saying you cant view the full desc, just open chrome dev tools and you can find the "hidden" elements there(they are all in p tags). It looks to be only hidden on the client side(i.e to call back to get the additional content). &amp;#x200B; " Some of the languages we currently use are: Golang, Java, Python, Ruby Some of the tools we use: Terraform, Docker, Vault, Consul, Linkerd Our platform runs in AWS where we use: SQS, SNS, EC2, ECS, RDS "
Yes, sorry. I don't use Java (nor C++) on a regular basis.
Bill Kennedy brings them up as first hand experience stories working with them if you ever take one of his classes. No idea how pervasive it is, but I could have sworn I saw them at a gophercon talk a year or two ago. Their github is also pretty popular and active https://github.com/Comcast
If I may recommend something, checkout GoLand from JetBrains. Easily the best Go IDE i've found.
IMO unit tests are the treatment for this problem, not linters.
We use several platforms but tend to have most success from [Hired.com](https://Hired.com). We've also received relevant applications from [Talent.io](https://Talent.io) and via the Slack #remotejobs channel.
The question isn't any kind of language comparison of Go vs anything else, it's about the "institutional risk" of Go. So no, I'm not going to compare it with Dart. I'm comparing low institutional risk - of which both Go and Dart are relatively low, and high institutional risk: Flutter. The point is that languages like Go, or even Dart, don't really get in the way of the goals of other businesses, ergo, they're really low risk. But if, say, Dart starts to embed Flutter features in the core, it may become problematic. Some tools, or frameworks, especially when you start talking about multiplatform support, can run high institutional risk if they get popular, and the other vendor (like Apple) decides it's a strategic problem.
Hi /u/Husio thank you for the feedback. We're trying to build a platform that doesn't just offer jobs, but also educational resources and the potential to contribute open source projects to the hiring process. So we are trying to grow our user base while also giving our community access to all the latest jobs available.
godoc doesn't work in module mode yet. The workaround is to create a directory resembling a GOPATH and put your project there and set the GOPATH variable to that. Or the copying solution is fine too. Tracking issue here - https://github.com/golang/go/issues/26827
Write a programming language from scratch
I would argue that it might be useful in cases when you don’t want the users of that package to create the variable of the type directly. Instead, you let them use your “factory” to return a predefined struct with the fields set to predefined values.
[removed]
[removed]
Does anybody actually use it in production? Looks pretty interesting.
[removed]
This is exactly what I was looking for.
&gt; Why does Go allow this behavior? I guess… because there's no reason to prohibit it :) Go allows lots of things that aren't particularly useful. &gt; If yes, when should I design my package like this instead of making User struct public, and remove the need for function NewUser() ? Honestly, you probably *should* do that, if that's an option. Unless you have a good reason to want to hide the type, don't hide it. Personally, I feel that factory functions are way overused. If your type is plain old data - just export it, it's fine. In general, I'd advise against using unexported types in APIs. As you've noticed, it's kind of a contradiction to both unexport a type *and* still make it available to users of your API. That being said, unexported types still have a place - for example, you can have an exported interface and return that instead and have your unexported type implement that interface. That is how the `context` package works, for example.
I mean `go mod vendor` essentially cuts it down to the things that are essential. But, yes the `go mod vendor` requires knowing all the `go.mod` files, hence needs to download.
It’s useful for JSON serialization because field names need to be public but the struct type does not. It’s pretty niche though. 
Its definitely not FUD. Open JDK is not a complete drop in replacement of Oracle JDK for everyone. Some of the flags and settings available in Oralce JDK are not available in Open JDK. Further more, certain software are certified for Oracle JDK and do not carry the same guarantees for Open JDK. You are on your own if you decide to run a non-certified environment including use of Open JDK. There is also no concept like LTS. You will not get security patches unless you constantly upgrade and have to deal with bugs and issues as a side effect. I repeat again that Open JDK is not a direct replacement for Oracle JDK as you make it out to be. &amp;#x200B; My company is currently in the process of migration from Oracle Java 7 to Open JDK and while its trivial with some applications, there are issues to deal with for others. The other alternative is buying the license and I was told that we were quoted a price of $18 million or something ridiculous like that for our Production usage. Don't assume that the CTO of a large corporate would make a decision as huge as stop usage of a language that their systems are built on without proper research and legal teams involvement. &amp;#x200B; As for myself, I have long discouraged developers from using any thing that has to with Oracle and Java itself is no exception. All the backend systems that I have put together are built on Go and 100% Oracle free (not just Java). 
What are some examples of flags that are different? 
And yet if you were to ask anyone on the street what three bears multiplied by three bears is, or one second plus one second, they'd be able to give you an answer easily rather than be a pedant. To reiterate, I don't dislike the design of the time library, but even having this conversation at all is proof that it's not a clear problem.
Thanks for the explanation. It's interesting because I've always thought returning an exported interface is not recommended as stated here [https://github.com/golang/go/wiki/CodeReviewComments#interfaces](https://github.com/golang/go/wiki/CodeReviewComments#interfaces) &amp;#x200B; It seems there is usage as depicted in `context` package, but I wonder why they don't have `valueCtx` and `timerCtx` exported.
Thanks, this is somewhat similar to the senior guys at my workplace told me.
Have they? It couldn’t be clearer on their website. And they give the same damn “future of the JDK” talk at every conference. I think it’s just internet Oracle hatred that is truly uncontainable. 
I’ve often wondered that myself. They have a huge booth at almost every trade show I’m at - I suppose I could go ask.
Sorry about that, I'm still working on it. This project is my undergraduate graduation project and I will treat it with care. Thank you for your reply Justin. :-)
The long term support cost is slight... I guess. Go offers 12 months of support instead of 6. Hooray? 
Find a project on GitHub that lacks test coverage and write the tests. Done.
There's an AWS equivalent, AWS Lambda authorizer. And, [https://blog.cloudflare.com/introducing-cloudflare-access/](https://blog.cloudflare.com/introducing-cloudflare-access/).
This is not pedantic, you cannot multiply time by time or bears by bears, it simply doesn't make sense.
Unit tests are indispensable, but they require that the developer has a clue about what to test. A linter can catch issues that the dev is not aware of.
FWIW I would be more sympathetic if the library used a casting syntax, like if the seconds conversion were done in a library function. Then I would expect the operation to be idempotent. But since it's multiplication this should but be expected.
Well, in your defence, the difference isn't very noticeable even if you did... 
Good luck! 
Thak you for the detailed answer and links. Managed to find out, that my backend I'm talking to advertises http/2 but doesn't "speak" http/2.
In this case I’m sure it’s less than and not less than it equal. If one tries to use the size plus i it would overflow. 
`5 * time.Second` has been described to me as a cast before, since 5 is an untyped constant, and is coerced at compile time.
Patents is also a thing.
In a factory function, you can do value sanity checking that you simply couldn’t do if you left the user to build the instance. So, just prevent them from messing up by preventing them from creating it directly. In an API, your goal is to make it as hard as possible for the user to mess up, and as easy as possible for the user to successfully use your API. Of course, checking can happen when you use the struct subsequently, but that’s up to you and how you use the code. 
i've written code for 30 years and completely disagree with that guy. now what
It includes a cast, but it is a multiplication.
since `refs/changes/13/713/1` is not actually a tag, it likely won't work with `go.mod`. tag it manually might make it work, or you could try use the commit sha1 and construct the `v0.0.0-datetime-sha1` pseudo-tag.
It includes a cast, but it is a multiplication.
Couldn't agree more.
I am unsure what "pipe operator" you mean?
&gt; If you compare a generic function to a non-generic one that takes a specific argument, then yeah, the latter is easier to read, obviously I'm not even sure that's universally true. `ReadInts(raw []byte)` vs `Read[[]int](raw []byte)` is negligible at worst, and at best I know that `Read[]` is one behavior vs potentially lots of different behaviors for `Read[[]int64]`, `Read[[]int32]`, etc. Add a few generic params and the difference is even more drastic. `ReadIntsFromMyBuff()` vs `Read[[]int32, mypkg.Buffer`]. Add a few refactorings and now your `mypkg.Buffer` is called `mkpkg.BytesBuffer` or something, but now `ReadIntsFromMyBuff`'s name doesn't match its signature and there's nothing to tell you that. 
Google is known to drop projects left and right if they don't benefit them anymore. Google wave, plus... For example.
I mean, in the sense that all magic numbers undergo casting, sure. time.Second is simply an int64 representing nanoseconds, like all Durations, so yes 5 is cast to int64 but that hardly seems relevant to this discussion. I also wouldn't describe `5 * 1500` as a cast, FWIW.
It was never a debate about their usefulness. It always was about getting proper implementation. Further reading includes: - [The Generic Dilemma by Russ Cox](https://research.swtch.com/generic) which somewhat started this discussion. Pay attention to the date of the blog! - [Summary of Go Generics Discussions](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view#) which discusses a lot about the upsides and downsides of generics implementations, including the ones that which are used by other languages. - [Proposal: Go should have generics](https://go.googlesource.com/proposal/+/master/design/15292-generics.md#) previous proposals. - [Generics — Problem Overview](https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md) the latest proposal and the discussion about what change today. (thanks /u/burntsushi btw for gathering all those links in one place) So pointing it out to Java Generics, which are type erasured and boxed, and C#, which are instantiated at the runtime. right before the usage, is somewhat incorrect from both compiler perspective and language perspective (since Go do not have extends\implements relationships between types).
Go isn't something that sits on Google's periphery, like a single disposable app. For certain categories of applications, Go is becoming dominant, seeing increased used both within and outside Google. Go is a success and it's accomplishes what it's designers had set out to achieve: solving many of Google's day-to-day engineering issues.
Not so far! I formed and modified a bit because I need to be able to asynchronously handle events that come back, but other than that it's doing fine.
&gt; If Google as a company was launched into the sun today I don't think GO would disappear. Yeah, Sun was launched into the sun, by Oracle. And Java survived.
&gt; Unless you have a good reason to want to hide the type, don't hide it. Remember that any type of function you export is now part of your public API and cannot be modified without potentially impacting users of the package.
Wait, what about the last chunk that's incomplete?
Most people that are against generics in Go are against generics for readability/simplicity I think. Haven't seen implementation being brought up. That's why I suggested Java/c# to someone absolutely unfamiliar with generics.
Yes, it does. That is the definition of open source. [https://opensource.org/faq#restrict](https://opensource.org/faq#restrict) **&gt;Can I restrict how people use an Open Source licensed program?** \&gt;No. The freedom to use the program for any purpose is [part of the Open Source Definition](https://opensource.org/docs/osd#fields-of-endeavor). Open source licenses do not discriminate against fields of endeavor. &amp;#x200B; Golang is open source: [https://github.com/golang/go/blob/master/LICENSE](https://github.com/golang/go/blob/master/LICENSE) you can create any version of you want, and you are ok. Oracle JDK (the Java they are sueing about before OpenJDK) was not open source, so googles re-implementation of "Java" broke their licensing terms. There is now OpenJDK, but that's not the "Java" google was based off of.
Interesting approach to wiring up a bunch of products. I suppose lots of creative google analytics tagging could also do for basic user reporting on which products people are leaving the cart, etc.
You've proven yourself unqualified to be a Go instructor.
Ah yeah - it's less "shared storage" and more "treat package cache as an implicit artifact". The mechanics of it are more like this: - At the end of a successful CI run: zips up the directories which are marked as "cache me" and sends it to S3 - At the start of a CI run: Fetches the latest zipfile and extracts it into the container So in terms of CI concurrency it's pretty safe. The only downside I've seen so far is that Bitbucket Pipelines occasionally purges old S3 caches, so if you don't push a new build for a few days, you lose the speed benefit for a build or so.
VSCode, GO and AppEngine is the perfect combination for me
If you want bloated frameworks, go to node, ruby, or python. The golang ecosystem expects you to pick the libraries you need for a particular purpose yourself.
http://www.catb.org/esr/faqs/smart-questions.html#explicit Your question is so broad it cannot be answered.
Someone who wrote code and "never felt the urge to use generics" is probably someone who doesn't understand what they're used for, 25 years of experience or not. It's not _that_ hard to find use cases for them. People in the go community seem to only think generics are only used for algorithms and data structures, but they're used for general reusability. If he said "when the data changes, your problem changes", this just further reinforces the idea that he's not familiar with them, because that's absolutely untrue. Generics by definition are meant to be used with similar problems but just with different data. I suspect he hasn't worked for an extended period of time in a language with generics, because I don't get how he can't come across a usecase for them. What is he doing instead? Copying and pasting code? Using external code generation tools? Using `interface{}` everywhere? Go has no downside-free answer for generics. You have to pick your poison when you have a need for them. Is there a single argument from someone who actually has experience with generics? Not a rhetorical question. A blogpost, a talk, anything? Like someone who comes from .net, java, or similar and demonstrates how they wouldn't be a beneficial addition to the language? Because I'm tired of reading things from people who have only otherwise used Python, Ruby, or Javascript saying that Go doesn't need generics. Of course they think that, they don't have experience with them. Even modern C has support for generic function dispatch now.
Generics aren't that complicated, especially in a language that doesn't have inheritance. Think of it this way: the problems that generics solve don't go away just because they aren't in the language. Instead, you're forced to solve the problem in your own ad-hoc way. Talk about lack of simplicity!
Chi for routing. Sqlx for DB. This for understanding that error != Exceptions https://middlemost.com/failure-is-your-domain/ While I’m sure we could all bikeshed about preferred this or that, this is a reasonable starting point. 
Yea I thought about it more and realized that it wouldn’t even be a good method for chunking. Instead, just check the bounds of I+size and len(a) and only grab the chunk that’s the smaller of the two. 
I like how every time the "get shit done" thing comes up there is a silent implication that abstractions and getting shit done somehow contradict each other, rather than being either completely orthogonal or support for abstractions helping with "getting shit done".
Yes, in an ideal world, people do not make silly mistakes like performing nonsensical unit arithmetic, reviewers read every line of code, and there are comprehensive test suites that exercise every code path and catch all bugs. Unfortunately, the reality is much bleaker for most of us ordinary folk and none of those things are as commonplace as we would like them to be. &amp;#x200B; I am in no way advocating that everybody should eschew good software engineering principles for linters. I just found a bug in a codebase, wrote a tool to discover further occurrences and then open-sourced it in case someone else finds it useful. If you don't think it's something you'll ever need, you're free to ignore its existence and get on with your life.
Nah nodes packages aren’t bloated. They’re 3 lines that just include an exported regex. And you’ll need 3000 of them. Each which will break on any update to any of their sub libraries, which are also just 2 lines of code each. And they also need 3000 dependencies. Seriously what the fuck is up with Node packages. Golang, roll your own, copy some code, or use a straightforward package. Most things, like http, have native packages, so you rarely need to go into deeper packages anyways. 
Many prefer [http://www.gorillatoolkit.org/pkg/mux](http://www.gorillatoolkit.org/pkg/mux) (directed at OP, just providing an alternative). 
&gt; Go Please, help us help you with a better thread title...
[removed]
[removed]
Okay. So, let's say, as an example `size == 1`. Then the last element in the slice wouldn't be hit, as the conditional is `i+1 &lt; len(a)`. Or, alternatively, imagine that `len(a) == size` (i.e. it contains exactly one chunk of that size). Then your loop wouldn't do anything, as `0+size&lt;size` is always false. It really is `&lt;=`, not `&lt;`. Because you don't go from index `i` to index `i+size` -- you go from `i` to `i+size-1` (just like a slice goes from 0 to `len(a)-1`).
That’s why it needs to be less than. Because if you don’t then you end up overflowing it. It’s not the best approach either way unless you need defined size chunks. 
This is rather funny to me, I started learning Turkish a few weeks ago and I found out about Go today. Now the two have been intertwined. :p
How do you use go with python?
I’m thinking about using this. Probably will use it no matter what but... what’s the collision rate for Murmur? I’m going to be using it to hash domain names and don’t want false positives.
They’re watching you... 
Out of curiosity, how long did you take to read it, and how did you do it? E.g. read-experiment-read-experiment cycles.
The insta-answer here is: the standard library. Go is all about keeping it simple.
For just getting started you can get most things done w/o any third party framework. Take a look at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/) for "micro services" (assuming generic http apis), and look at [https://golang.org/pkg/database/sql/](https://golang.org/pkg/database/sql/) for connecting to a database. &amp;#x200B; If you REALLY want to dig into frameworks, I highly recommend only doing this when needed and after getting familiar with the standard library, look at [https://github.com/gobuffalo/buffalo](https://github.com/gobuffalo/buffalo) (rails/django scope) or echo/gin/... for slightly lighter options. &amp;#x200B; If you find yourself lacking some abstraction in net/http or database/sql some common things to include are: \- routing (chi, gorilla/mux, httprouter) \- logging (logrus) \- database (sqlx)
Okay. Now, let's talk about an ancestor of Go, named [Oberon](https://en.wikipedia.org/wiki/Oberon_(programming_language)). Did you know that Oberon didn't have (u)int16? Or (u)int64? Or uint? They didn't need to have these types so they didn't introduce them. But thanks to that simplicity they also didn't need to have generics, which they didn't have.
No language _needs_ generics, it's just a feature that makes certain patterns easier and/or more performant. Oberon is statically typed, therefore it could have benefited from generics. Generics aren't just for specializing over numeric types, so I'm not sure why you brought that up. 
Most people at Google that I've talked to about it honestly do not like the language.
Here, we insta tell you to use the standard library. 👍🏻
This will probably get you started https://youtu.be/XbKSssBftLM
You are welcome: https://play.golang.org/p/lh6F0HQ-EH9
As a microservice. I split computing and high level logic. Python than act as a manager, where you compose microservices together.
Close to the birthday problem with uniform random distribution on random input. 
just a comment on the example, wrapingFunc sounds odd, I think you mean wrappingFunc ;)
is all this aversion to generics caused by people getting burned by C++? i understand that C++ is an absolute monster of a language (not unlike english) with tons of deprecated features kept for legacy, and an ever-expanding syntax making even relatively simple features contain more punctuation than bloody klingon. If people need to do something, they'll find a way to do it, even if it's ugly and incomprehensible, see all the #define abuse in any C codebase
So, in one of your projects you want to try out a change to the standard company library? That shoudl have a newer revision too, I suppose (with tests that is prove that the patch is valid) Than just do the require to the correct version. &amp;#x200B; If it just a tryout, where the patch is made during the development of the package you're working on,\\ just point to the local copy of the company library like this: replace YourLibPagacke/subPackage v0.0.0 =&gt; ../YourLibPagacke/subPackage (the last part assumes it's one directory up) Then check the patch, improve the company lib is necessary, and you're good to Go ;-)
&gt;Interesting approach to wiring up a bunch of products. I suppose lots of creative google analytics tagging could also do for basic user reporting on which products people are leaving the cart, etc. Thanks
Why can’t you change inner backticks to single quotes?
damn, my life is ruined
Thank you to the kind anonymous person who granted this gold! Your message has made my day already! :D
You can't really do that https://stackoverflow.com/questions/21198980/golang-how-to-escape-back-ticks
You could * read your literal from a file * use some special character sequence and use `strings.Replace` * interrupt the raw literal and add the characer in double quotes: https://play.golang.org/p/-q09o1ds6Vf
This is so cool! I've been thinking of writing my next web project in Golang but haven't been able to find a simple but detailed tutorial using Gin yet. I love this, will start tomorrow!
Great tutorial. Well done.
Context.Context is an interface, you cannot unmarshall it without providing a concret type. Most likely the problem is that you shouldn't serialize the context at all.
Thanks, that's what I thought. Following new approach.
Upvoted, this was a nice article and I don't want to come off as negative, but this seems more suited to someone who absolutely must use React and some other CMS, than to someone who just wants a blog, while also leaving out many details on how to deploy securely to the web. At least a mention to Hugo/Inkpaper or any of the nice static site generators would be also nice.
Hmm. I’ll give it a shot and see how it goes. It’s basically to reduce memory consumption over storing the full domain name so if that’s the tradeoff I’ll document it and move on.
I believe what you're writing about is Go concurrency, not parallelism More information here: [https://vimeo.com/49718712](https://vimeo.com/49718712)
I take the point. This was more just detailing how I created mine, but you are right in that React/ButterCMS even Go aren't all mandatory in creating your Blogging platform. &amp;#x200B; I'm probably going to add the details of how to deploy to a cloud platform in the open-source Github repo. &amp;#x200B; Thanks for the feedback!
Again, I didn't mean to sound negative, you did a great job. And yes, deployment can range from very simple to a big PITA, so providing that information to newcomers will make this whole thing even more complete! Keep up the nice work :)
Thanks a lot!
Any feedback is good :-) I decided I wanted a new blogging platform for myself, as I was fed up of Medium, and then thought the best "first post" would surely be how I did it! 
I’ve also had success with something like... type MyError string func (e MyError) Error() string { return string(e) }
Thank you!
Can people stop linking to this junk domain, please? This is a copy and paste of https://medium.freecodecamp.org/a-guide-to-golang-e-commerce-8c0804088e4e but with the author name changed. I checked in with several authors of original articles copied onto that site and none had given their permission and were annoyed at the way other people had put their names on their content.
This is great
Good post. Let's now wait for the guy who always screams "just use the standard library!" :)
Nice, I'll replace Gorilla for Gin anytime soon. [https://github.com/cyruzin/feelthemovies](https://github.com/cyruzin/feelthemovies)
Just wrap your project in a bunch of packages you never heard before and it'll benchmark in some cases over one golang framework that most people don't use. With being able to write things 100 different ways what could go wrong with microservices?
clickbait if i ever saw one: "**Node.js Boost overtakes Go**" =&gt; just introduce another language (c++) to handle the problem &amp;#x200B;
"C++ library with node wrapper invoking it slightly faster than a pure Go library" .net can use C++ libraries too. It doesn't make it a better language, but I can see why JS fans would like this. It makes JS a bit more feasible. 
I was using vscode for a while, but I like atom more. Never used AppEngine, but it looks very interesting. I'll look into it :)
Not for the open source fans XD
Hey this is very cool! i would recommend putting variables you use like the waitgroups into a struct type so one can spawn multiple sorters at once
How many domains? Just avoid the 32-bit hash if you have a lot.
You may refer to https://github.com/go-modules-by-example/index
Really excellent article, can't believe I haven't seen it before. (posted 2018-10-20) 
Oh hey, this is my repo - feel free to ask any questions, been using this for 3 years for almost every bit of non-trivial concurrent code I write.
\&gt; I can move interface definitions to a different package, but I'm not sure if that is sane. &amp;#x200B; Interfaces should be defined in the consuming packages, not in the packages implementing them.
As in because the editor is not open source? Or do you believe that the editor won't run on Linux?
Wasn't aware of the existence of this. Thank you! 
Fucking. Thank you. &amp;#x200B; This is what I came to say. This isn't Node getting better, this is bypassing the problem by using a different language.
Gin? Nah I usually write web apps while drinking beer. But good on ya!
You should be able to but you don’t even have to import them if they are in the same package. So basically all files with “package main” on top will be part of that without you doing anything The only difference is that when you run your project use $ go run *.go And then go will just look at every file in that tree and combine them directly as if they were in the same file 
Interesting material. I would however check the account first and then move to the transfer, because transfer does obviously more than just transfer. (I like small functions sorry) &amp;#x200B; But I can imagine, this can be used for functions that return a lot of different errors.
I just made it an option and put it on the user :D.
Nice one . Wanted to build my next project with golang + react to learn react from scratch and getting better at go 
Since I couldn't add context, I found this interesting. Yes, it is a better implementation for JS. The interesting thing is that the implementation shows it's not the language that sucks so much. 
This was a great read thanks for posting!
I loved the first half of the tutorial, then I had to register with some service to make it possible for users to log on to the new web application. I want to build something that can outlast the ups and downs of companies, services and websites.
Rx is *not* a typically Javascript library. Rx is originally a .NET library ported to many other languages. RxJS doesn't have to deal with types or concurrency, so it's the least similar to the original and the spec. RX.NET, RxJava, RxSwift, RxCPP, etc. are better examples when talking about Go. Dynamic typing is indeed possible in Go. RxGo, which does exist, does exactly that, passing `interface{}` everywhere. Compared to typical non-Rx code Go, it sacrifices typesafety and performance. The other statically typed languages don't have to make that sacrifice. Zero typesafety is not a sane foundation for a Go application on, so I consider that an absolute deal breaker.
This is awesome! Thank you for sharing. I see that your app is already highly rated in Google Playstore, which is nice. Just a quick typo: the last link in this post also points to feelthemovies_dashboard.
[removed]
Sorry, I don't get it. Do you mean the project's description? 
I'll answer myself - yes, go doesn't appear to like constants all in capital letters. E.g. `const DEBUG = true` doesn't appear to be allowed when used in another file in the same package, but it's totally fine with `const Debug = true`
Something like this is what I was after! Added to the reading list!
I'll check it out, thanks!
Yeah maybe, but I also think I probably missed some things. So I should probably reread it or read something else go related.
That sounds cool, I have been looking at rust and wasm. Mainly to learn rust, will check it out
Ha! Maybe it would be good to learn the ins and out of the most commonly used functions and methods :)
Around one and a half months of reading. I did most of the exercises. And when they showed code in the book I often tried it out for myself. 
OAuth providers are one of the most complex things imaginable. It is much better to rely on others to manage it than doing it yourself. If you want to self host - however, you can use [https://github.com/ory/hydra](https://github.com/ory/hydra) with whatever authentication library you want. &amp;#x200B; Also, OAuth providers can be exchanged at any point with no change to your code (would just force users to sign in again), so even if you go Auth0 now, you could rip that part out and switch it over to whatever else you want later with no code changes.
Just asking, why did you choose ButterCMS if its a non open source product?
I just happened to come across it, and thought it was worth trying. It was either going to be ButterCMS or Ghost and, at least to start with, I wanted a SaaS solution. Any other CMS should be easy to drop into this tutorial though. You'd only need to change the \`cms.go\` file in the server directory.
&gt; it is a better implementation for JS No, it’s a way to bypass JS for a large portion of the work. &gt; The interesting thing is that the implementation shows it's not the language that sucks so much Interesting. From my perspective, it’s proof the language sucks that much. 🤷‍♂️
Fascinating that it specifically mentions non-pipelined requests. HTTP/2 is all about pipelining. I’m willing to guess that the JS execution is still limited to a single core.
I've never heard of this all-caps restriction before. It should only be a stylistic issue. All symbols, public or private, should be visible between all files in the same package. Do you have a compile error to back this up? 
No, no error, goland (which I'm trying out) is throwing red squiggles everywhere!
Eh HTTP/2 doesn’t really do pipelining tho. It does do multiplexing, which can be confused with pipelining. Pipelining is dropping multiple requests into the same channel, which means the second request gets blocked until the first is done. h2 allows them to happen concurrently. It’s a stupid distinction. JS is such a bad option for servers, I have no idea how the Node community functions. 
Since Go can call into C as well, one could imagine a test where that top binding layer was also implemented in Go. The results would probably show that you are just benchmarking the heavy lifting of a C/C++ implementation. That is, unless the cgo overhead of the message handler callback is significantly expensive. 
I wonder what would happen if someone build a Golang based middle layer for Node. It’s entirely possible to build shared or archive files from Go and use them in any C bound context. 
So that is just stylistic issues from your IDE. I don't think it is correct to say that Go doesn't allow you to share access to a const DEBUG between files of the same package. You should be able to compile fine with any case formatting. 
Yes. Very much so. Except I wouldn't call those words a description, more like vague marketing.
This is one of the few recommended reads. It practically answers beginners to intermediate common issues from project structures, package design to proper error handling. Good concepts are hard to explain and I believe this article does it well. Also an interesting read on concurrency.
If anything this article praises Go. NodeJS had to resort to calling C++ code to compete in a synthetic benchmark. In a real world application you'd have to rewrite large portions of a nodejs project in C++ for it to compete and it would still use a magnitude more memory due to how NodeJS handles connections.
Great tips. Thanks for sharing..
A few suggestions: 1. At [L132](https://github.com/fortytw2/leaktest/blob/9a23578d06a26ec1b47bfc8965bf5e7011df8bd6/leaktest.go#L132) the reason of context cancellation is not always timeout so it might be better to use something like `t.Errorf("leaktest: %v", ctx.Err())` instead. 2. At [L144](https://github.com/fortytw2/leaktest/blob/9a23578d06a26ec1b47bfc8965bf5e7011df8bd6/leaktest.go#L144), it's probably better to use [`time.Ticker`](https://godoc.org/time#Ticker) in the `select` instead. And instead of continuing in that case, break from the `ctx.Done()` case might be clearer for readability.
Thanks! The link is fixed :)
Exactly. This post has a great title too! I hope the solution isn't like we have today (either half-baked and deficient or utterly convoluted).
[removed]
Good reply. I agree, specially when the title of OP itself suggests that Generics will eventually come to Go. The author does not come across as exhausted, but as someone who thought his opinion through.
I like most of it but not this: &gt; Naming the `*Config` parameter `config` is redundant. We know its a `*Config`, it says so right there. Yeah, maybe in the function header. But the lines below are all much more readable if the config was just named `config`. A name doesn't appear only once.
&gt; Using a const from the same package but different file. Is this possible? Yes, it is possible. Your IDE, Goland [1], is using a linter called “golint” [2] that throws this warning: &gt; warning: exported const DEBUG should have comment or be unexported (golint) Go recommends to write variables, constants, and functions using Mixed-Caps [2]. All of the following constants are syntactically correct and accessible from the same package. const debug = true const Debug = true const dEbUg = true const DEBUG = true However, if you are trying to access a function or constant defined in a different package, it has to be defined as a public resource by writing the first letter in caps: // Visibility // Same Package | Different Package | const debug = true // Yes | No | const Debug = true // Yes | Yes | const dEbUg = true // Yes | No | const DEBUG = true // Yes | Yes | [1] https://www.jetbrains.com/go/ [2] https://github.com/golang/lint [3] https://golang.org/doc/effective_go.html#mixed-caps
I searched _“qt build constraints exclude all Go files”_ on Google and found this: • https://github.com/therecipe/qt/issues/450 • https://github.com/golang/go/issues/24068 • https://github.com/golang/go/issues/24433 &gt; Setting CGO_ENABLED to 1 fixed the issue
thanks, I'll have to go back and revisit as I can neither understand why it was so sensitive to the Debug vs DEBUG issue
If "foo" is either at the root of your GOPATH or is the name of your module (go.mod) then the import path of "foo/bar/car" should be valid to import the "car" package. You may need to provide more details about which package is importing which, and your build command output. 
Thanks for pointing out my incorrect terminology. My point, which you clearly understood, was that with HTTP/2 there’s likely to be a lot more overlapping requests which would ideally operate asynchronously across as many cores as you have available. To is fantastic for that, and it appears to me that this test avoided that issue entirely. Willing to bet that go will blow this things’ doors on a machine with more than 1 core.
A few notes: * [Consider fewer, larger packages](https://dave.cheney.net/practical-go/presentations/qcon-china.html#_consider_fewer_larger_packages) will increase chances of having to trade-off with [A good package starts with its name](https://dave.cheney.net/practical-go/presentations/qcon-china.html#_a_good_package_starts_with_its_name). Personally I favor the latter over the former. * The section on [Identifiers](https://dave.cheney.net/practical-go/presentations/qcon-china.html#_identifiers) is OK, but I feel that identifiers should *always* be short and concise. If you find yourself having to assign a compound name to a variable/function, then it's a code smell and you should look to refactor your function to make it shorter. **This does not mean the solution is to create "artificial" functions just to satisfy this requirement.** You should try to extract reusable and composeable functions. * [Comments](https://dave.cheney.net/practical-go/presentations/qcon-china.html#_comments): consider comments on variables inside functions a code smell. Also, and this is something I still don't understand: why is the "godoc" to document something by redundantly starting with the identifier's name?
Great read! I’ve been struggling with some decisions regarding a package I’m about to open source, this helps alleviate a few of my worries. 
I think I tried getting into go two times by now and I’m yet to have that “zing” because of this. Everywhere you go people hammer you with this. Use the standard library. And because of this I fell we’re not getting the quality frameworks that we could’ve got otherwise and that other programming languages have. Well I agree the standard library is very powerful, but it just feels way too low level. I feel like I would need to write a lot of code to implement a decent router/cookies/sessions handling/http client/etc.
Having a powerful std library doesn't necessarily mean easy and fast development too. I would use the std to do most of the job, especially those things that aren't already implemented, but web development has a lot of common cases, people who keep yelling std library like a mantra, are basically apes who reinvent the wheel everytime, and think to be smart by doing it. 
Couldn't agree more. Is there a term for just giving up and accepting things the way they are? I can't stand that kind of thinking.
A great comparison. Objective-C also got crufty and weird trying to maintain compatibility. Go is doomed to get weighed down by its past in the same way.
Pretty much the latter. Use a good library that does something like scrypt or bcrypt instead of rolling your own hashing methods. It’s not as bad as it seems. 
That's what I was seeing. People hashing with bcrypt and sending off to the database. I guess I just need to trust myself and ask for feedback when I'm done. Thanks.
I think, as a community, we should try to restate this concern as "use composable libraries and not frameworks". Coming from Rails or Django there is the concept of everything interfacing through a single framework which i think drastically hurts the scalability and flexibility of these apps long term. Instead if you can compose components together, swap them out, rewrite them (use the stdlib, or use a mux) then it really doesn't matter. I haven't used Gin, but it seems like sometimes it feels a bit more like a lightweight framework and can fit this model. I also think people starting out should start with the stdlib, find the limitations, and then look for alternatives to problems instead of just choosing the framework with the most features which is also probably why you hear that phrase being repeated in many posts.
Thank you :)
Thanks for the tip :)
I'm newbie but I assume 2nd one (func NewSession()..) will allow multiple sessions open with 1 user ID while the other one isn't? 
Assuming you’re not using an ORM that imposes other conventions, I would say your second one is more idiomatic. Go uses the `func NewFoobar() *Foobar` convention quite a bit. The only other thing I’d consider is whether you actually need the entire `Account` struct to create a `Session` or if you could get away with `func NewSession(accountID int) *Session` or similar. I find it best to only include information that’s truly necessary in your function signatures.
I thought the whole point of Go was a language that forces you to write in a certain way without you being required to read and remember rules like this. When reading these 'advices' I feel like I'm back to Rails and the Rails way.
Python would be more appropriate for that age group. 
Since you’re creating a struct method on Account, why not place session in the account struct, and mutate it from nil when a session is established: type Account struct { Username string Password []byte Session *Session } func (a *Account) NewSession() { // establish session logic here a.Session = &amp;Session{} }
&gt; why is the "godoc way" to document something by redundantly starting with the identifier's name? The explanation I read once was along the lines of “so people can `grep ‘// Name’` to find the one-line description.
Thank you. May I ask why? Just curious.
Yep, I think it would work. The lack of generic methods is unfortunate, because it prevents the typical pipelining style of Rx. But functionally, it should be plenty. 
I am a published Python O'Reilly author (Fluent Python) and last year I worked for several weeks on an introduction to programming using Go, inspired by the awesome Think Python book by Allen Downey (CC, check it out!). But after struggling to make the introductory chapter interesting, I decided that kids in 2019 would be more interested in learning mobile development, and neither Go or Python are good options for that. My top choices: #1 Corona, which you program in Lua, is great for 2D games, has an amazing simulator, and targets iOS, Android, Windows, MacOS, etc. #2 Flutter, programmed in Dart, targets iOS and Android (native apps) and Web.
Very interesting reply and food for thought. Thank you very much!
i think Go may be an excellent choice. python often frustrates kids who cant send what they made to their friends in any easy way. as well go is simple and lets you learn a bit about pointers. you may get some inspiration from gameswithgo.org 
I'm not a teacher, but have volunteered through TEALS to teach CS in a local high school. We used JavaScript (CodeHS) and Snap! ([https://snap.berkeley.edu/](https://snap.berkeley.edu/)) for Intro to CS and Java for AP CS. Java is required for AP CS, but I would recommend Go over Java, if/when that's an option. For Intro to CS, I think Snap! is great. All a student needs is a browser. TEALS has the lesson plans for Snap!. There are also packages for Arduino integration with Snap! to introduce robotics concepts.
Go for it! Go is a brilliant language to start with, it introduces pointers in a safe-ish environment and isn't an alien compared to other programming languages (Python)
Python is nice because you can get instant feedback out of the box at the Python REPL. There are Go REPLs, but I'm not sure how mature they are, and in any case require extra installation. There's loads of help online for Python, too. (Go too, but I think the Python help might be friendlier to high school students. All that said, I personally was programming in Turbo Pascal at age 16(ish), so it's not like Go would be impossible for high schoolers to understand. You said you're new to Go. If you have time, implement a small but meaningful program in both Go and Python and see which one you think would work best for your students. Not just the language, but environment, work flow, ease of development, etc.
[removed]
i would recomend a language that you dont have to compile like ruby or python of js
the REPL is key to learning!! instant feedback make it so much easier to learn imo. &amp;#x200B; &amp;#x200B;
Thanks. Cheers man
The only example I don't like is the very last one. I think with channels,you should avoid having to specify a capacity like that. It seems like a major code smell unless you are doing it for performance or something. In this case, if you used closures instead of separate functions, you could use a wait group (you could do with functions too but there would be a lot of arguments). Or, more typically, you could use a struct, like a "service" struct or something like that, to hold the wait group and done channel.
REPLs are nice, to be sure, but they’re not the only way to get instant feedback. Tools like goconvey make it pretty easy, too. (Goconvey runs unit tests as soon as you change any code and shows you results in a browser.)
Yeah I think this is nit picky TBH. `conf` `c` or `config` are all fine. I would not mention this in a code review.
Awesome
If you do decide to go with Go, if you really want to blow their minds, show them GopherJS, which compiles Go to JavaScript. If you go with Python, well, there might be a tool that compiles Python to JS, too, I dunno. Either way I think it’d be neat.
See also https://blog.golang.org/pipelines examples of the sort of "intended use" of channels.
Sure but for someone who has never programmed ever REPL beats tests 
[removed]
[removed]
[removed]
You really shouldn't be getting an EOF in that scenario, assuming the port is still connected. That seems like a buggy library, and https://github.com/tarm/serial/blob/98f6abe2eb07edd42f6dfa2a934aea469acc29b7/serial.go#L149-L150 and https://github.com/tarm/serial/issues/27 look suspect, that's just a bad design. Try a different library?
[There is a qtdeploy command you can use](https://github.com/therecipe/qt/wiki/Deploying-Linux-to-Windows-64-bit-Shared) to compile from Linux to Windows x64.
I'm sure that pull requests would be welcome
“Does anyone actually read this” haha great catch 
You should teach them more advanced topics using Javascript. This is the very first time they are getting exposed to a programming language. There are a lot of different topics, patterns, approaches that they have never seen. Switching to another language would throw away the current investment that you have already made. You want to foster the mindset of "I have a problem. I can solve this with programming." By switching languages quickly, you'll be leaving the impression that there are things they can't do until they learn another language. What is the curriculum that you have taught them already? What topics do you want to teach them next trimester? Some javascript project ideas that can forward their education: * Minecraft bot (is minecraft still cool? Fortnite won't look fondly on any scripting unfortunately) * Raspberry Pi and GPIO programming to control leds, switches, etc... * Buffer clone (send tweets at a scheduled time)
I have no experience with Django. I do have experience with Spring Boot (Postgresql) and ArangoDB. In Spring Boot, you can directly integrate with Liquibase, which is a tool that manages migration scripts. I have code deployed that uses this. I've used a migration tool for ArangoDB written in Go. You can invoke directly as part of your boot process. All that said, I've moved away from the idea of coupling migrations with services. If you have a large migration, then your services block until the migration completes. Another option is a green-blue migration when you phase the change into the DB over a few releases. Let's say you add a column. For a period of time you can allow nulls in it. This allows two instances of the services to work against a common DB: one writes nulls, the other writes the proper values. You then stop all the old-write-nulls instances. Finally you run a massive, in parallel to the running services, migration that sets the null values to their proper instance. This takes some planning. For example, explicitly select columns in your query. If you are removing a column, the first thing to do is update the service code to not write it, but leave the physical column there for the old code. Why say all of this? You can now use whatever migration tool you want to migrate when you want. You can have a migration container and a service container. Since you've planned around the idea of migrations, you can run them whenever you want with little downtime. As for testing against a DB, there are multiple patterns that can help you. [https://stackoverflow.com/questions/25965584/separating-unit-tests-and-integration-tests-in-go](https://stackoverflow.com/questions/25965584/separating-unit-tests-and-integration-tests-in-go)
If you need resources. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
\`wooStuff\`
I'm not from the Django world and and I'm not sure how _best_ to do these things, but I'm kind of sure [Buffalo](https://gobuffalo.io/en) does at least migration management. [fizz](https://gobuffalo.io/en/docs/db/migrations/) does migrations; I'd suggest poking around there first.
I had this just come up the other day. 25 lines into a function there were probably 4 single character variable names and it took me a solid 15 minutes of going back and forth just to remember what the fuck they were. It's a big deal to me, personally, just name the god damn thing what it is. Doesn't have to be 30 characters long but "config" is better than "c". We can spare the extra 5 characters now, it's not 1960.
“They probably should”
Very interesting reading! Thanks for shsring
for the command line part, you may want to look at os.pipes and fmt.scanf https://stackoverflow.com/questions/46399395/golang-to-redirect-fmt-scanf-to-read-from-file-instead-of-os-stdin Perhaps they are looking for the directory structure. Otherwise: http://farm1.static.flickr.com/3/5414660_8716bf615a.jpg 
I thought I was on /r/funny and was like... wait, that's actually Go! And it's not entirely random bs.
I wonder what this code does? It's also copy &amp; pasteable from the background of this Akamai white paper PDF https://www.akamai.com/us/en/multimedia/documents/white-paper/5-reasons-enterprises-need-a-new-application-access-model-white-paper.pdf
someone should run `gofmt`.
You could take a look at authboss. I've not used it and it isn't a drop in solution from what I understand. However it looked like a great place to start with implementing a custom system, especially if you're not sure what you need before you need it. 
[https://play.golang.org/p/6KUZsWaVzBK](https://play.golang.org/p/6KUZsWaVzBK)
Love the emphasis on writing clear and maintainable code. Generally disagree about comments, and generally disagree with godocs required comments for exported funcs. Problem I have is that they're usually a signal of code complexity. Break the func down and let the func names comment the code. The advantage here is that the comment cannot lie. The code is the comment.
Further, you should never store context in a struct. The docs mention this. 
I generally find that the bottleneck is the database.
If we use distributed db or file system it should not be a issue isn't it? 
I'd say it's a set of tools and components for rapid prototyping.
With focus on the code. I use helium in my projects. But at some point, I wanted to share it with the world. I would like to hear critic, perhaps it would be useful not only to me, but also to the rest.
At a glance then that's exactly what I said. :-) If you live in a world outside GPL, then GPL software is software you basically can't touch or "look inside". It might as well be under a commercial license ... which, for some people who like the GPL is exactly the point. They want you to buy a commercial license instead to work with it. (There are also the "free software" people who like the GPL and other restrictive licenses like them for other reasons).
I would teach them something useful that complements HTML, CSS, and Javascript. The best choice, I'm afraid, would be PHP. Much easier to learn than Java (or Go) and plenty of jobs, unlike Go. Python seems more used as a general purpose language than a web back-end.
Perhaps. I'm sure there is a level of performance of the data storage that makes the CPU the bottleneck, not the DB, but it's worth thinking about.
I'm a big fan of Go and not quite so of Node but.. if your students already know Javascript why not use Node.JS? It's easier to learn than Go because it doesn't have types and you'll find a ton of beginner resources. If you need a new focus, let them build a Node.JS Webserver that serves your HTML Frontend. Then add a javascript network call to the frontend to load some data and update the view. Data is going to be loaded from the backend so you'll have them implement a basic router.
u:= &amp;User{} It’s common to use smaller variable names in Go. Unlike other languages that promote the idea of using huge variable names. Everything is Type safe, and go complains if you don’t use a var or haven’t declared it correctly, so there’s some safety there that you won’t see in things like JavaScript or ruby. 
First, can your new focus instead be something else with Javascript? I don't know what you taught in the last trimester, but presumably it was the basics. Maybe now the next trimester could be games in Javascript? Making hangman, tic-tac-toe, maybe even Tetris if they're really good? Go is awesome but not really appropriate for almost all Junior High students. If you absolutely have to teach them another language, I'd do Python. But I think it's far better that they get better at one language (which you've already picked, Javascript), then they learn other languages. 
Another option if gaming isn't your thing, would perhaps be to teach them basic React as the focus?
It sounds like this is correct. It generally makes the documentation easier to read outside of the context of the code. From https://blog.golang.org/godoc-documenting-go-code: &gt;Notice this comment is a complete sentence that begins with the name of the element it describes. This important convention allows us to generate documentation in a variety of formats, from plain text to HTML to UNIX man pages, and makes it read better when tools truncate it for brevity, such as when they extract the first line or sentence.
It's ok to have a favorite language, but you should avoid the temptation to talk about what you like over whats actually more practical and applicable in the field at large. If it's web, JavaScript should be the language you are teaching. It also has benefits of dynamic typing which is better for students in general. As the code will always do something. And you can inspect why and what works wrong if it dies. Compiler errors are not engaging.
Capitalization is for exported/unexported only. This holds for types but also for functions, methods and **variables** too. There is no need to distinguish types through typography, capitalisation or whatnot.
that would require to sacrifice with the readability of the code, which I would try to avoid, that's why I'm asking.
I use the Docker builder for this. It lets me build static W64 executables without issue from MacOS. It’s a really powerful toolkit. With only two things I don’t seem to be able to fix: SQLite - I want to use a secure version and can’t get that to cross compile at all. It collides with the built-in DB. This crashes out on Windows ... so I resorted to encrypting and then storing using the built-in. Not ideal but it sort of works. The other weird thing for me has been subsequent cross compilation to iOS - the app crashes on orientation change and I don’t seem to be able to stop that from happening. The other trick seems to be to call a show() prior to building as that also can cause a few issues. Otherwise a great library. 
I like to create a test helper function to ensure that an external resource (in this case a database) is available. Such helper function either returns a connection/pool/client or skips the test. Here is an example of a test helper function that returns a postgres connection https://github.com/husio/gbb/blob/master/gbb/postgres_bbstore_test.go#L115-L170 Notice a few things * first line of the function is `t.Helper()` * connection can be configured via environment variables if needed * if a database connection cannot be opened `t.Skipf` is called * the user of this function is responsible for closing the database connection https://github.com/husio/gbb/blob/master/gbb/postgres_bbstore_test.go#L67-L68 There are plenty of packages that promise to solve the SQL database migrations problem. You can use one of them or start with a custom solution before committing to a dependency.
A chained method call in f# 
I just learnt about this feature so I have no idea if it's a good practice but you could probably move the internal structs to an `internal` package. If you have this hierarchy: ``` pkg/ apackage/ internal/ anotherpackage/ ``` The struct `User` defined in the `internal` package can be imported to `apackage` but can't be imported in other packages. This method would let you use capitalized structs but still keep them unexported outside of the current package. If you try to import an `internal` package from outside you will have this compilation error: ``` main.go:6:2: use of internal package github.com/kdisneur/example/apackage/internal not allowed ``` 
Very well written. I would put emphasis on avoiding a "common" pkg. If you find yourself that you need it all the time it's very likely because you have shared responsibilities between packages. A design issue.
[https://github.com/snwfdhmp/errlog](https://github.com/snwfdhmp/errlog) &amp;#x200B; For my mobile people
I'd second this - teach them some Python and then they'll have an excellent foundation to move on to typesafe languages such as Go. Python also has a huge number of libraries and code examples available, so if any of them get hooked and want to do projects in their spare time, they'll find the resources they need are just a Google away. On that note, I'd also ensure you teach them about StackOverflow and other similar resources, and also make sure they learn to use/adapt other peoples code to get the results they want. It might seem counter intuitive for a school class, however, that's the way people write code, so it needs to be taught from the start.
Ah yes, that is true yet I find it makes code often harder to read.
This looks pretty cool.
Sounds like you've experienced `libp2p`. It used to be so annoying how they depended on the crappy versioning tool, ex. Glide with symver was so much better. I've not experienced the problems I've had with this lib in any other repos anywhere. The only thing I've ever had issues with elsewhere was people not maintaining their work or competing features, leaving me to really do the patching when I found something that someone else made that was like 60% where it needed to be. 
Was this just open sourced? Why haven't I come across this before? Looks really awesome, going to try it out
This is what \[go guru\]([https://godoc.org/golang.org/x/tools/cmd/guru](https://godoc.org/golang.org/x/tools/cmd/guru)) is for.
I doubt it's required to generate docs. [Go Guru](https://godoc.org/golang.org/x/tools/cmd/guru) can find the godocs anyway. This is because comments are part of Go's [AST](https://golang.org/pkg/go/ast/#Comment) \- they just need to appear right before the declaration IIRC.
JavaScript me: gah! go me: go fmt!
What did you find out in Chromium?
Done! :)
JavaScript me : VSCode -&gt; Preferences -&gt; Settings -&gt; Format on save : Yee
This guy VSCodes.
https://github.com/golang-migrate/migrate
AWESOME :) Thx!
Blogger just wants constructor methods, which grow obtuse. Dependency Injection nearly eliminated constructors in Java with Spring. They’re not really needed in Go, and when they are, you can make them... you don’t need to “bypass” anything
Why? Check that your package's godoc is formatted correctly in the browser. Or because you like to view godoc in HTML. ``` $ gohdoc open current pkg godoc in browser $ gohdoc . same as above $ gohdoc my/sub/pkg $ gohdoc /go/src/github.com/my/pkg $ gohdoc fmt $ gohdoc fmt#Println open fmt#Println godoc ```
It's awesome and fully developed in Go :D 
Blogger here - mostly agree! For DI in Go, I haven't seen anything that doesn't require exposing everything as public properties of structs, which then of course allows them to be changed. As of now I haven't seen really nice DI in go, even with Wire, Dig or others. For the title, maybe "alternative to" would have been preferable, I can update that. :-)
Epic post!
I'm guessing cause you are messing with the pointer to S. This prolly has to do with value that is in that location. And you are giving that pointer a bunch of type names that have access to that memory location. Unless there is really big need for efficiency, I really wouldn't do this.
It is great in the area. I used Go for such kind of work in the past, even did some tools to simplify typical tasks without losing performance: 1. [fast line data extraction](https://github.com/sirkon/ldetool) 2. [clickhouse](https://github.com/sirkon/ch-encode) [related](https://github.com/sirkon/ch-insert) tools 
Excellent, I used a different library and the EOF issues seem to have gone. What I'm now facing however is that for some reason the buffer seems to be full of old data before my first read? What I'm now doing is discarding a bunch of bytes before actually starting to decode the data. This is what the code looks like now. ```go reader := bufio.NewReader(openSerialPort) scanner := bufio.NewScanner(reader) scanner.Split(bufio.ScanBytes) packet := make([]byte, 0) // Discard first 5 packets n := 0 j := 0 for scanner.Scan() { n++ if scanner.Bytes()[0] == 0x00 { if j++; j == 5 { break } } } log.Printf("discarded %d bytes", n) for scanner.Scan() { b := scanner.Bytes()[0] if b == 0x00 { decoded, err := cobs.Decode(packet, 0x00) spew.Dump("decoded: ", decoded) if err != nil &amp;&amp; err != cobs.IncompletePacket { log.Print(err) os.Exit(8) } if err == cobs.IncompletePacket { log.Printf("incomplete packet:\n") spew.Dump(packet) } packet = nil continue } packet = append(packet, b) } ``` As you can see I'm discarding the first few packets to make sure that nothing bad gets to the decode function, but obviosuly this is a bad approach. The port does not have particularly high output, it's about 130 bytes every 100ms so I don't think that the buffer is overflowing from the moment it opens to the moment it is first read? Is there a way to properly flush the read buffer of possibly overflowing data without discarding useful data, if that even makes sense? 
Only one instance of `if err != nil`?
What makes you so certain? How many did you instruct and to what success?
Hey, now sadly I do not have very good knowledge of the inner workings of the JSON package but I'll provide my best reasoning. Json.Unmarshal expects a pointer to a value, now an interface contains 2 things a pointer to a type and a value. What is happening when you do `var c I = &amp;S{}` is that you are assigning to an interface a pointer to type S and in it's value field a pointer to a value of type S (in our case &amp;{X:0}). So when you provide this interface into the unmarshal function it can use it's value field, which contains a pointer to a type S remember, and unmarshal into it. &amp;#x200B; Now let's look at the other example `var d I = S{}` This is assigning again a pointer to type S in one field of it's interface and in the value field for the interface it is storing a value copy of type S (in our case {X:0}). So when provided with this interface's into the unmarshal function it'll try to use it's value field to unmarshal, but it contains a value rather than a pointer. So it'll give you the error. &amp;#x200B; Now the error is a bit misleading claiming that it cannot unmarshal into type main.I, in my opinion it should say it cannot unmarshal into type main.S because that's where the point of failure is. If you use the reflect package and it's TypeOf function you will see that what you are giving the unmarshal function is indeed a pointer to a type main.I, nevertheless, the error comes in with that interface's value field, which again is not a pointer itself. &amp;#x200B; If you could somehow access that field and get it's address the unmarshal function would work just fine, the problem is the interface is providing it with a value and not a pointer. &amp;#x200B; Disclaimer: To reiterate I don't have profound knowledge of the JSON package, I could be completely off basis, and would be delighted to be corrected, this is just my interpretation of what is happening after looking into it for about an hour.
I am sorry I have not checked the code but how is this different from lxn/walk ?
Rule of thumb: Pointer to interface is wrong in almost any case.
Blogger misspells name of language.
Well GoLang stands apart, but you should take a look at GolANg and GOlang too! What's the problem with mentioning "golang" and/or golang.org a handful of times for SEO but calling Go by its name "Go"?
JavaScript me: prettier! go me: go fmt!
lxn/walk uses deep declarative style to create UI. This package uses very different style: your UI code should be close to left side of the screen with minimal indentation. If you have used lxn/walk you will know what I mean.
lxn/walk uses deep declarative style to create UI. This package uses very different style: your UI code should be close to left side of the screen with minimal indentation. If you have used lxn/walk you will know what I mean.
I was reading a bit about that in relation to this problem. So does that mean that because json.Unmarshall's second argument must be a pointer, you should never attempt to unmarshall into an interface? (Since if you tried to, as I did with c and d, you would have to create a pointer to an interface.)
Blogger here - All my web searches start with "golang" as "go" isn't sufficient to retrieve accurate search results. The blog post refers to the [moniker](https://tip.golang.org/doc/faq#go_or_golang) for SEO.
Thanks for your reply. I think you might be right. The [godoc][1] for Unmarshal says that if the type is not a pointer, Unmarshal will fail. I thought that because I *was* passing in a pointer type to Unmarshal, it would be fine, but I suppose because of the way interfaces work (they are a pair of actual concrete type and a value of that concrete type, as you said), even if I pass a pointer to interface to Unmarshal, it will try to then use the value inside the interface, and if that value is not a pointer, it will fail. [1]: https://godoc.org/encoding/json#Unmarshal
because it is 2 characters? and golang is infinitely less ambiguous than go? Why is this hard to understand? People say nodejs all the time too, because node is also a generic term. Why is this an issue for you?
I taught intro to cs courses at Stanford as a TA for 3 years. People learning to code don't write tests (well or before they code). Tests are not explorative like a REPL. Exploration is key to learning
When you use Go, do the Go way. Otherwise just use Java or whichever you used for OOP and DI.
&gt; Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out? There is nothing stopping you from passing the wrong dependencies (partially initialized or null) into a PHP constructor as long as they are valid types for that constructor (if you are using type hints at all). There is also nothing in PHP (or any other language that I know) preventing you from implementing a constructor incorrectly. The reality is a constructor *is* a factory, albeit a very naive one that's bolted on to the class namespace. Nearly all DI frameworks will use factories (and registries) in one some way. They just hide/abstract that from the user (and the user pays the price for that). Finally one of the core tenets of DI is that *an object instance is not responsible for locating and assembling it's dependencies*. They have to be provided in a valid state. This works recursively, all the way down the dependency chain, which in the end means that when DI code is running, each dependency must be wired to be in a "ready to work" state. In other words, invalid initialization of instances is a bug in DI code. This is clear if you do TDD, because your setup() is going to become a mini dependency injector of sorts.
I don't know of a subreddit, but there is Exercism and Codewars.
People writing web apps in Go do not seem to mind keep reinventing the wheels. Here is an example of a home grown sql migration: https://gitlab.com/commento/commento/blob/master/api/database_migrate.go I guess when the same developer creates a new web app, he writes yet another sql migration, very similar, if not the same as, this one. Then, when there is bug in that home grown sql migration file, that programmer fixes the bug in that project and other N -1 projects that use the same migration file. Which begs the question, why not factoring this into a library, or using existing ones?
Thanks for your input! I think we agree on most of the above. So a few things.. &gt; There is nothing stopping you from passing the wrong dependencies (partially initialised or null) into a PHP constructor as long as they are valid types for that constructor (if you are using type hints at all). In PHP, a partially or incorrectly initialised object would be a dev error directly in the dependencies' implementation in the constructor. There would be no other way of creating the object. In Go, I am advocating using the same tactic - enforcing the equivalent of a constructor (which is a factory as you point out) whilst making the type private so it cannot be initialised without going through the factory. This leaves initialisation errors solely within the factory and these problems, such as null pointers, do not need to be considered elsewhere. &gt; Finally one of the core tenets of DI is that an object instance is not responsible for locating and assembling it's dependencies... I am very much on-board with this and completely agree with it. :-) There are however [many cases](https://qafoo.com/blog/111_injectables_newables.html) whereby the initialisation of an object will not be done through dependency injection.
Daily programming exercises are a nice way to ramp up on the language. But beware, they have diminishing returns once you have a firm grasp of the language. You should work on a project you are passionate about. (Start one or join one). The ability to organize/modularize a large project is a *completely different skill* than learning the low-level bits of the language/library. The ability to organize code is also worth a lot more than knowing the language trivia. After all, it's easy to look up "what happens when you send on a closed channel?", but it's impossible to Google your molecularity decisions.
Constructor guarantees proper initialization of private data/fields. Factory does not. You could, of course, add an initialization method to the type. But factory is not guaranteed to call it after constructing an object. Zero values for private fields may not always make sense.
Storing them in the package that will be returning them like [so](https://golang.org/src/database/sql/sql.go#L335) would be my suggestion if I understand what you're asking.
Yes exactly 
Like [this](https://play.golang.org/p/WxEw97Giwd2)?
Hackerrank? I burned through the algorithms section in a day but there’s still tons of stuff to do on it. I think they have daily challenges too. 
Always define things as close to their use as possible. Making a special package just for your errors would be an anti-pattern in Go. Instead, define them in each location where they’re being used. 
I thought it would just be random code for the design, but with function names like "doStuff" this appears to be real-deal production ready code.
Something like json.Unmarshal where it "returns" a value by modifying your pointer is probably the only time you'll ever see it. And this style is rare. json.Unmarshal only does it so you can use the type to specify how you'd like a value to be unmarshaled.
Thank you! It works. :)
I always search Golang when googling. Go is too generic of a term and will return results that simply aren’t relevant. Golang narrows it down really nicely. 
&gt; Constructor guarantees proper initialization of private data/fields. For what definition of "proper"? Consider the following session in PHP: php &gt; class A { php { private $a; php { public function __construct() { php { } php { } php &gt; php &gt; var_dump(new A()); object(A)#1 (1) { ["a":"A":private]=&gt; NULL } &gt; But factory is not guaranteed to call it [the initialization method] after constructing an object Neither is the constructor. If the dependency is meant to be injected, all the constructor does is an assignment. If it's not, the code has bigger problems anyway (e.g. it can't be tested at unit level). Generally in go you'll have to choose between having a meaningful zero value or not allowing one to be created in the first place (private type + public factory returning an interface). The single responsibility of a factory is to create an instance of an object. If the dependencies of an object change, then of course all factories for this type of object must change too.
&gt; In PHP, a partially or incorrectly initialised object would be a dev error directly in the dependencies' implementation in the constructor. There would be no other way of creating the object. This is correct, but you still lack the guarantee you seek: that an object which was passed correct instance types via the constructor is ready to be used when the constructor is done executing. You may even have it unit tested with 100% coverage and then in the production code miswire the dependencies. My point is that traditional constructors don't guarantee as much as people think they do, and that it is equivalent, if not better, for that responsibility to be moved to a factory. &gt;In Go, I am advocating using the same tactic - enforcing the equivalent of a constructor (which is a factory as you point out) whilst making the type private so it cannot be initialised without going through the factory. This leaves initialisation errors solely within the factory and these problems, such as null pointers, do not need to be considered elsewhere. This is used in go only if the zero value is not meaningful (which, to be fair, I would expect to occur frequently in larger, more OO codebases with a lot of DI). When the initialization of an object is not done via DI it is usually done via something which is also a factory (e.g. a UserRepository, which has methods that behave as factories for Users and list of Users). 
I'm working through Hackerrank and codewars. Trying to do one a day as well, still consider myself a golang noob. There isn't as much resources since it's a relatively young language.
It's not a flush issue. You need to read in a string and then try to run strconv.Atoi, else scanf will first read the 'e' , bail out , then in the second loop run it will read the left '\\n' from the input buffer, bail out again.
You can print to stderr.
&gt; This is correct, but you still lack the guarantee you seek: that an object which was passed correct instance types via the constructor is ready to be used when the constructor is done executing. I can't see a reason not to use a factory instead of a constructor, so I agree with you there. It is not the guarantee of an error free object that I seek, I can't stop user error. :-) What I do seek though is limiting the scope of this type of user error solely to the factory, and the guarantee that when the nil pointer occurs it's simply because it was incorrectly allowed in the factory and not somewhere else to be chased through the codebase.
Yea, I also seen the overuse of channels when I passed it.
Despite the visual appearance of the screen, Scanf is not seeing the "Wrong entry" text. "Wrong entry" goes out on standard out, and you are reading from standard in; the two do not cross. If you run: package main import "fmt" func main() { for { fmt.Print("Enter something: ") var s string fmt.Scanf("%s\n", &amp;s) fmt.Println("You typed:", s) } } You'll see that what you print never comes in. You can see this with the source code that you gave by typing `eeeee6` and hitting enter. You'll get a wrong entry for each "e", and then it'll be happy with the 6. I don't think you can flush STDIN at this level, without going a lot deeper into terminals than you want to. You probably want a bufio, which will give you an easy "read until the newline, then stop": package main import ( "bufio" "fmt" "os" ) func main() { var val int var err error r := bufio.NewReader(os.Stdin) for { fmt.Print("Enter a number between 1 and 10: ") _, err = fmt.Fscanf(r, "%d\n", &amp;val) if err != nil || val &gt; 10 || val &lt; 1 { fmt.Println("Wrong entry") r.ReadBytes(10) // read until newline } else { break } } fmt.Println("All good.") } 
[https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/) might help &amp;#x200B;
Thanks for making this. We need more decent UI toolkits. My personal wishlist in a UI toolkit: a layout system inspired by Flutter. The layout is the biggest pain in making UIs (i.e. repositioning things when the window is resized or because a control changes its size and it affects how other elements should be positioned). Flutter came up with what I consider the best way to do layout. I'm not talking about implementing the exact same thing (because it's large and some things are closely related to other things in Flutter) but a light-weight version inspired by their ideas and tweaked to go.
Surely, we getting a glimpse into true enterprise level coding here. 
Hello friend, &amp;#x200B; Just wanted to let you know you have some errors in your code examples. &amp;#x200B; Two things: The first is the unnecessary usage of pointer receivers in the following code: `type Animal interface {` `Call() string` `}` `type Cow struct {` `name string` `}` `type Dog struct {` `name string` `}` `func (c *Cow) Call() string {` `return fmt.Sprintf("Mooohoooo %s Booo!", c.name)` `}` `func (d *Dog) Call() string {` `return fmt.Sprintf("WooofWaf %s Wuf!",` [`d.name`](https://d.name)`)` `}` &amp;#x200B; You don't need to use the pointer types `*Cow` or `*Dog` in your receivers here because you're not actually changing any value on the associated Cow or Dog structs. This might seem nitpicky, but it is actually important to the context of your article. &amp;#x200B; With these methods on pointer receiver, the value types like `Dog{}` or `Cow{}` types don't actually satisfy the `Animal` interface making your later switch statement checks for value types irrelevant. &amp;#x200B; If you change your code to use the Value type receiver instead, both the Value type `Dog{}` AND the pointer type `&amp;Dog{}` will in fact satisfy the Animal interface. &amp;#x200B; Secondly is that you are incorrectly using the switch construct. Go switch statements work differently than switch statements you've used in the past. &amp;#x200B; Your code: &amp;#x200B; `func getSpecies(i interface{}) string {` `var m string` `switch a := i.(type) {` `case Cow:` `case *Cow:` `m = fmt.Sprintf("I'm a Cow, %#v", a)` `break` `case Dog:` `case *Dog:` `m = fmt.Sprintf("I'm a Dog, %#v", a)` `break` `default:` `m = "Don't know what species this is"` `}` `return m` `}` &amp;#x200B; The above is wrong in that `break` statements are actually implicit for every case. If your type were the `Cow` value type, an empty string would be returned. If you want the "traditional" case statement behavior you would use the `fallthrough` keyword. &amp;#x200B; `switch a := i.(type) {` `case Cow:` `fallthrough` `case *Cow:` `m = fmt.Sprintf("I'm a Cow, %#v", a)` `case Dog:` `fallthrough` `case *Dog:` `m = fmt.Sprintf("I'm a Dog, %#v", a)` `default:` `m = "Don't know what species this is"` `}` &amp;#x200B; However, go provides an alternative syntax allowing you to specify multiple conditions per case statement &amp;#x200B; `switch a := i.(type) {` `case Cow, *Cow:` `m = fmt.Sprintf("I'm a Cow, %#v", a)` `case Dog, *Dog:` `m = fmt.Sprintf("I'm a Dog, %#v", a)` `default:` `m = "Don't know what species this is"` `}` &amp;#x200B; Here is a complete example of these fixes: [https://play.golang.org/p/UPDUsCIAqQm](https://play.golang.org/p/UPDUsCIAqQm) Go switch statement wiki: [https://github.com/golang/go/wiki/Switch](https://github.com/golang/go/wiki/Switch) &amp;#x200B; Hope this was helpful!
You would need to wrap the handler in middleware that passes the writer through a gzip writer. Something like https://www.lemoda.net/go/gzip-handler/index.html
Oh wow this is very appreciated feedback. Currently on mobile, will update my code examples and persist this knowledge in my brain once I have time tomorrow to access my computer 
[Gophercises](https://gophercises.com/)
Ok, I get it now. Thanks to your answer and /u/jerf's I better understand what's going on. Thanks! In fact it's not really a good idea to use Scanf to read something else than strings, isn't it? If the expected format is not respected, the behaviour might be hard to handle.
[removed]
Thanks for your very complete answer, I better understand what's going on now. I've adapted my code so user's entry is easier to handle.
There are a couple connections that I wish had been made clear in the blog post. First is the part where a private type is suggested, and then later a public interface counterpart. I wish it had been made clear that making your type private and leaving only a public constructor removes the visibility of documentation for the type. Only by later adding in the public interface can you ensure some type of relevant documentation is generated since the interface would have to explain the methods for the private concrete type. Second, I have seen it stated multiple times in the past that it is good practice to "make the zero value useful". Yet this post steps around that phrase and suggests it's more of an annoying approach to be avoided. I would have liked to see the direct mention of the benefit of making the zero value useful (it was mentioned by someone else in the replies to this thread). 
Thanks for your feedback !
Thank you !
Scanf isn't great in general, no. If you plan on writing "real" interactive shell commands, you'll need to do something more robust and usable, which gets you into readline territory pretty quickly. For the most part, these functions are used in just exactly the way you are using them; initial experimentation with simple programs. Real code almost always involves something else.
&gt;Gofmt's style is no one's favorite, yet gofmt is everyone's favorite. &gt; &gt;\-- Go Proverb &amp;#x200B; [https://go-proverbs.github.io/](https://go-proverbs.github.io/) [https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=8m43s](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=8m43s)
What you could do is move the `strings.Replace` parameters onto their own line, like this: ``` val = strings.Replace( arg1, arg2, arg3) ```
Thanks very much for the constructive feedback, this is what I need! I need to work with and think about "making the zero value useful". My concerns with validity revolve around "valid in this business context or not valid at all", which also includes nils - that is what I was trying to avoid with only factories to create things. 
&gt;could do is move the &gt; &gt;strings.Replace I think writing the function parameters in this way will make the code more complex. &amp;#x200B;
First off, I appreciate the contribution. However, I read the proposal and I still don't understand. This looks like just an incomplete proposal for generics. Am I wrong?
CI/CD @OVH in 2018 – Five million workers * About 5.7M workers started and deleted on demand. * 3.7M containers * 2M Virtual Machines This article explains the main aspects of CDS : [https://www.ovh.com/fr/blog/how-does-ovh-manage-the-ci-cd-at-scale/](https://www.ovh.com/fr/blog/how-does-ovh-manage-the-ci-cd-at-scale/) &amp;#x200B; &amp;#x200B;
can be done without dependency on `strconv` by using `fmt.Sprintf` &amp;#x200B; from `queue_subscribers := "index_subscribers:" + strconv.Itoa(i)` to `queue_subscribers := fmt.Sprintf("index_subscribers: %v", i)`
Well, you asked for *aligned* code. This is probably the only method that `gofmt` will accept. 
&gt;&gt; It's a 30-minute elective course I instruct to a group of about fifteen or so _6th, 7th and 8th graders_, five days a week. That's middle school. Don't make very elaborate plans; child developmental psychology is always going back and forth about the details but broadly speaking the ability to understand very abstract concepts is _physically_ not present until high school. I can not emphasize that "physically" enough, because every time I say this, someone goes "oh, but _I_ was programming in 8th grade". Yeah, so was I, but I _guarantee_ you you were not ready for the sort of programming you do now... because you are _physically_ still growing the necessary brain structures in middle school. Generally you're still doing so until about 25 years. You hacked around a bit, but you weren't anywhere near professional-grade yet. The REPL will help a lot. The fact that a ton of people have done this with Python and there's a ton of resources online will help too, as well as the fact you can find programs that have demonstrated success. Go is very easy, yes... _buuuuut_ honestly, right there down at the bottom, it gets less easy again. Go simply can not compete with typing "python" and, bam, there you are, you're in a programming language. Python was originally descended from a line of languages intended to be used to teach people programming. Go is descended from a line of languages intended to be used to get real work done. There is a lot of overlap even at the medium level between those two goals, but for the very rank beginners, Python's the winner.
I cannot argue with any of this. Well said.
Ok, thanks for the insight. Indeed, I discovered Go a few days ago so I'm doing some usual beginner's exercises, such as a "Higher or Lower" game, adding gradually some features to test Go possibilities.
Thanks for taking the time to read it. The proposal is inspired by the current discussion around generics. However, I tried to come up with a design that does not solve the "true generics" problem. In my opinion what most Go developers search for is a way to define composable data structures. I know, polymorphic functions and friends seem exciting, but are they really needed? That said, do you still think it's missing more of the "true generics" stuff?
Done =) Any thoughts on dfinity? Seems like you can write dapps with Wasm, given that it's not a scam :D 
[removed]
[Deleted] The tinfoil thickens 🤔🤔🤔
Next ddos attack will use golang
Except for the "does anyone actually read this" comment
Also this: [https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f](https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f)
If your errors are numbered, you can put them in an array or ENUM like this: [https://golang.org/src/syscall/zerrors\_linux\_s390x.go](https://golang.org/src/syscall/zerrors_linux_s390x.go) &amp;#x200B; But I would only use this pattern for highly "standardized" errors. Most of the time, you should just generate the error via `errors.New` and return it immediately. No need to be so formal.
Why will the ´struct`types only satisfy the `Animal` interface if they implement `Call()` with value receiver and not pointer receiver? 
One obvious limitation of this proposal is that it does not separate the behaviours that the concrete types must support from the current, specific implementation of the generic function/methods/etc. I feel that this tight coupling between interface and implementation is a serious issue for long term code maintenance; it seems likely to make changes to either side fragile and prone to surprising and unexpected errors.
HandleFun woo
What area do you (the OP) work in? Network stack, HTTP API? 
I've had the same experience. The standard library of Golang is just....too convenient. They took the top ~100~ 1000 libraries one would need and standardized it. Other languages just didn't get that start. Like today, I was writing Java and needed to parse some XML. The documentation I was looking at provided 6 ways to do the same thing....
I've personally never been interested in C development other than for systems programming. Like the linux kernel, device drivers or embedded systems. I've always been much more interested in DSL scripting languages. What really attracted me to golang is that its basically C with automated memory management, lightweight threading and a robust standard library. In other words, it's a system programming language for 'script kiddies' like myself, that are not full-blown systems programmers. I've been avoiding it for a bit because I don't like being an early adopted, but its robust enough now that I trust it.
I tried C++ to get started in game development. The thing I missed the most was the ease provided by Go's toolchain and tests tools. And also knowing exactly what type to use for integers...
My favorite part of the talk &gt; Simplicity is a great virtue but it requires hard work to achieve it and education to appreciate it. And to make matters worse: complexity sells better. - Dijkstra
“React” plus “basic” equals “does not compute”. Seriously, to write React requires understanding JS201x inside and out. I don’t think it’s fair to throw that at middle schoolers.
I question the same thing.
Now I understand and appreciate := and interface{} a lot!
If you like the layout algorithm used by Flutter, please look at [bitbucket.org/rj/goey](https://godoc.org/bitbucket.org/rj/goey). The range of widgets is no where as complete as Flutter itself, but it does use the same algorithm for automatic layout. I think it has a few other advantages as well, but I might be biased... &amp;#x200B; &amp;#x200B;
I'm not certain that I would go back to updating GUI elements by hand to avoid indentation. Also, indentation can be reduced by a few methods. You can factor nested sections into a function. You can build parts of the tree early and hold the fragments in a variable.
Why does this happen? https://play.golang.org/p/at-ENSSz4Yc 
Rich Hickey: reeeeeee!
That quote is my wallpaper.
XML is a nice thing (C# actually does fairly well with it), but there are things Go has that just feel standard library quality but that I never really asked for: https://golang.org/pkg/index/suffixarray/
I get your point but XML, ugh, is part of what I wish Go can improve with. Namespaces are yet not fully supported. &amp;#x200B; See: [https://github.com/golang/go/issues/13400](https://github.com/golang/go/issues/13400)
package main import ( "log" "net/http" ) func main() { // Simple static webserver: log.Fatal(http.ListenAndServe(":8080", http.FileServer(http.Dir("/usr/share/doc")))) } How do wrap this ?
You can use grpc-gateway, but that won't create a RESTful proxy - just an API proxy which receives JSON objects with the call parameters, calls the underlying gRPC server with proper protobuf, receives the answer and sends it back as JSON to the client. &amp;#x200B; This is not a RESTful backend in its true meaning, but may be just enough for your frontend. I mean it won't handle "GET /users" to list the users, "GET /users/:id to get one specific user" and "POST /users" to create a user, but "POST /listUsers", "POST /getUser" and "POST /createUser", if you have "listUsers", "getUser" and "createUser" gRPC functions defined. So no REST, just RPC.
Now try to go back to Python. You’ll be amazed how much longer it takes to create functionalities in Go.
Okay thank you, this I think helped me clarify a few things!
I’m pretty sure Guru came after the convention had been adopted. 
You should literally be able to copy that example and wrap your FileServer: http.ListenAndServe(":8080", makeGzipHandler(http.FileServer(http.Dir("/usr/share/doc")))) Your ListenAndServe is just like the example, accepting a handler function which can be wrapped by a gzip handler. 
Any tl;dr? The first minute made me cringe so many times at her presentation that I could not continue
Don't mistake lack of classes for lack of OO. Same patterns apply.
Hi there if use nginx as reverse proxy with tls so you dont need to config your app too.
Just skip past it
Usually easier to leave nginx out.
GO APP MONITORING: EXPVAR, PROMETHEUS AND STATSD [https://www.opsdash.com/blog/golang-app-monitoring-statsd-expvar-prometheus.html](https://www.opsdash.com/blog/golang-app-monitoring-statsd-expvar-prometheus.html) Get that info without tools [https://stackoverflow.com/questions/11356330/getting-cpu-usage-with-golang](https://stackoverflow.com/questions/11356330/getting-cpu-usage-with-golang) 
You may explore `/proc/$PID`.
&gt; In my opinion what most Go developers search for is a way to define composable data structures. I know, polymorphic functions and friends seem exciting, but are they really needed? I think you are projecting here. Personally, I am *far* more interested in parametric functions than I am in parametric types. Of course, there are already fairly clean and simple proposals that would give us *both*, so I don't even understand why you'd want to go for something else :)
The context of how Go evolved as a language is more than informative! It's interesting hypothesis that limitations to Moore's law led the recent drive towards concurrency. That might also why Java saw a resurgence in popularity in the past decade.
Really depends on what you are aiming to do. Please clarify the context of your question?
i dont think it works that way... &amp;#x200B;
&amp;#x200B;
`C:\go-work\src\website&gt;go build` `# website` `.\main.go:12:50: cannot use http.FileServer(http.Dir("./html")) (type http.Handler) as type http.HandlerFunc in argument to makeGzipHandler: need type assertion` it does not works that way 
It’s a good talk
It’s a great talk, worth watching through
How to move from C to Go? And is Go mostly used for creating microservices only?
This question has really scattered details that make it difficult to understand your project layout. Is there one myLib module with a myLib/file and myLib/error package? If so, why is there a requirement in your mod file for a package that is within the same module? And did you say you have two files with different packages in the same directory? I think a clearer picture of your project layout is required. 
What do you think about to try Rust?
To add to the above answer you could also consider the grpc-web project and then you don’t need grpc-gateway/REST for your web application. 
I'm in a similar situation. I've been porting an existing python project to Go, where the python project was using nginx for the https termination, and also websocket uwsgi proxy. Now that is it almost ported to Go, I am thinking I could just support https at the Go app and get rid of the nginx dependency. 
I use autocert in Go directly. I have a “local” switch to allow me to use self-signed certs for local testing. I prefer to have security built-in to the web server with local self-signed certs as a backup in case autocert fails. That way, I always have an encrypted connection - and it removes the risk that a change to NGINX’s config won’t accidentally create an open connection to your servers. 
It was like seeing light. I am from C. Everything that I wanted, like unit testing and "auto" documentation without configuring anything is a bliss. In my opinion, Go is C friendly. Its not for microservices only, many CLI has been written, server application, etc.
I wrote an extra part where I hopefully clear things up. (If not, please explain what to clearify more)
I wish I had this perspective, Go is by far the lowest level language I've used
Your packages will be searched starting from `$GOPATH/src/`. For modules you need to prepend the module path to sub packages. I guess you are missing this because you use the relative path. So are you developing a package inside your GOPATH, a module inside or a module outside? You also don't need to require subpackages of you module explicitly, but you can do this (so your module depends on an earlier version of itself).
Because the input parameter to Call is not used and Dog is the zero value of Animal, hence empty string.
"It depends". Me? I tend to have a single server running 50+ HTTP-sites. So I have nginx/apache serving some, and running as a reverse-proxy to others. If I want to throw up a new service that means I _can't_ globally bind `:443` in a golang application. So I stick it behind the front-end. Having a front-end, such as apache or nginx, allows you to do rewriting, caching, and similar things. Even if you don't think you need it you can benefit. (For example how many golang HTTP-based projects ship `/robots.txt`, `favicon.ico`, etc? With nginx you can rewrite those to a local file, or handle 404 immediately if you prefer.)
My modules are outside of my $GOPATH/src the error package inside my module is mentioned in the go.mod of the module: (as I wrote) I don't know if I don't need the subpakages to be required or nit, since the documentation is not very clear about the modules subject :-( So this is my library, which has functionality of it in use in other parts of my library AND of course in other programs (aka modules) So I think, in order to find them in other modules, the go.mod of the library should have those requires inside. But I love to see a full explanation, because I can't be the first with a library working with modules. (and all modules info I found, was just within one module) &amp;#x200B;
So, this describes how to build a Rails-y web app using standard library components instead of magic frameworks? Sounds good
Have you checked out the official documentation: https://github.com/golang/go/wiki/Modules ?
Hey, didn't research them yet, can't judge. Ethereum is a safe bet for now.
Thanks for sharing!
Agreed. C# does it well Standard libraries are supposed to have more than what you asked for. I would hope more gets standardized. The goal is to focus the conversation around a single piece of code and balance a community so a standard way exist. That means we can all complain about issues and guide the dialogue to the best community solution.
Ya. Hence the Java. Is that a language problem or an XML issue though? 😉 Based on this: https://github.com/golang/go/issues/13400#issuecomment-382382394 Most issues in the thread are resolved. Though namespaces still are meh. 
I think it would be easier to just let nginx or another reverse proxy handle it. But if you really want to put in the work, please make sure it's possible and documented how to validate a configuration and how to reload your server config (and the certificate) without stopping the server. If it is possible to request Let's Encrypt certificates in your server automatically, that would be awesome, but the problem is: all this work isn't really necessary to have in every server, but it's needed in professional operations, so it's typically easier to use a reverse proxy instead of using something that's not fully thought through.
Do it in Go! You can use https://github.com/foomo/simplecert for automatically obtaining and renewing letsencrypt certificates for your Go backend. HTTP, TLS and DNS challenges via ACMEv2 API are supported, and for generating TRUSTED self-signed certs for local development, the mkcert util is integrated :) Happy Coding 
I have a go autocert https server in the front that uses my various go websites and apis in the back
Hmm.... I wonder, what makes programming in Go different on Windows compared to Mac or Linux? 
Well I'm guessing servers aren't different but any os programming sure will be. I just can't stand DOS. I know there is the Shell but...I really don't like installing a bunch of stuff to write go. I love in go you don't need much. On windows I just feel it's kinda weird to write go on it. I mean isn't that exactly what .net is for?
Sorry I just forgot to clarify what I've been doing. I was to mean Windows application development, using Windows APIs and creating Windows services that can interact with users, listing processes, that sort of things. I mainly develop a Windows daemon service at my work.
Yes, right. .NET stands for these things. To tell you my working environment, my program should not be rely on .NET though. It should be a complete standalone application. And I'm sure writing this things in C or C++ was really a pain.
You can do windows syscalls with [x/sys/windows](https://godoc.org/golang.org/x/sys/windows). When you have platform,-specific code, you can [conditionally compile with +build flags](https://golang.org/pkg/go/build/), selecting by platform. Why would you do it? Certain filesystem concepts don’t carry between platforms, some networking stuff is different, and access to different windows resources is easier with native apis. Windows is mostly posix so it’s not as big a deal as it was in the past.
No golang there. They only have C, Java and Python.
Well the jobs I've done was about tips about doing common things right(in Windows). For an example, properly(properly here means to get around memory leakage problems, correct type conversions, etc.) getting process list is not well documented. And making Windows service interactable with user input, it is not well documented, too.
I think that anything that increases the knowledge of go on windows would be great. You could probably do a Udemy series on it and make a living at it, as that niche isn’t covered, and I know there are people out there who prefer windows or have to work in it as a ms shop and want to bring a strong systems language in.
Ok, thank you. Suggestion of Udemy series was good but I think that's beyond my ability. I'll start off by writing some tutorials right now!
interesting. I'm guessing each CreateEmployee() starts it's own transaction?
Right towards the end at [46:38](https://youtu.be/bmZNaUcwBt4?t=2798) she confirmed a feeling I've had about Go: it's a language designed by people with a strategic vision (top-&gt;down) to solve problems with software engineering at [Google] scales. It was never an academic exercise in *language design*, and it shows. It may have reached the goals it set out to achieve, but that still doesn't explain why the average Go programmer espouses so much love for Go as a language.
`Prepare()` + `Exec()` for the insert (so default behavior, whatever that is!).
Yes i would be interested.Sounds really interesting
how are the transactions being closed? are you sure they are being closed? Might not be worth the trouble but i'm guessing that the devs at https://github.com/lib/pq would love to have this replicated to investigate the potential bug.
On a POSIX compatible system you can use [syscall.Getrusage](https://golang.org/pkg/syscall/#Getrusage) to observe accumulated CPU time spent in user space and in kernel while executing the process. [Rusage struct](https://golang.org/pkg/syscall/#Rusage) packs other stats like maximum resident memory usage, numbers of voluntary and involuntary context switches, etc. If you want to get an “instantaneous CPU usage snapshot” of the process, like you would expect from `top` or similar interactive monitoring tools, you have to sample this information and derive the percentage with the knowledge of underlying system topology, i.e. number of available cores. 
Consider https://godoc.org/github.com/shurcooL/httpgzip.
Until a certain codebase size, where Python will collapse under its own weight, while a similar sized Go program starts to shine.
Anything that doesn't require building a deep hierarchy is a good fit for Go. Writing something like a vector math library is a poor fit, due to the lack of multiple dispatch.
For command line tools I often compile my .NET Core apps through CoreRT. You get a single fully self contained executable. 
Do you mean real database transactions? If so, I'm not using any for the test. Otherwise I'm just running the app and not explicitly closing. It's strange that the behavior only happens with those particular parameters. I'll probably try once more to confirm, but three in a row and I figured that was consistent enough (when it didn't hang otherwise).
NVM node version manager on windows is written with go. [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)
https://github.com/jet/damon
Not sure about CPU usage, but memory info is available from \`runtime\` re: [https://golangcode.com/print-the-current-memory-usage/](https://golangcode.com/print-the-current-memory-usage/)
I'm not sure what it is that makes Windows programming dramatically different. At my work, we program for Linux, Mac, and Windows with Go interchangeably. Sure, the API calls are different sometimes, but that doesn't seem a huge thing to me. Of course feel free to write your tutorials if you think it would be beneficial but IMO the reason you don't see many docs or tutorials is that it's not dramatically different.
Check out Rust. It's got the low level control that you'd need for AAA games like C++ but with the modern tooling and design of Go. Built-in unit testing, benchmarks, and package management, and straight forward integer types. Though it's definitely a heavier language and development time is more like C than Go imo.
It's a library issue. I wrote an SVG sanitizer in Go, and I forked the encoding/xml library to do it to add the namespace support I needed. (It's specialized to my task and I'm not sure it's sufficiently generic, so you probably don't want it.) There's nothing about Go itself that can't handle namespaces. The problem is just that you really need to write your library to be namespace correct from the get-go, it's really hard to retrofit _and_ maintain the 1.0 compatibility guarantee with the original encoding/xml, which has issues _at the API level_ with dealing with namespaces correctly, as most XML libraries tend to. I wonder if there's any appetite for Go 2.0 to contain a new encoding/xml that is namespace-correct? Or a new encoding/xml2, or move the current one to encoding/xml1, or something.
What is the GO MAXPROC set to ? If not set, how many cores is the CPU ?
You can actually define multiple resources in a separate yaml configuration for grpc-gateway, allowing you to point the POST and GET methods on one path to different gRPC methods. A little extra effort and complexity, but you *can* make it RESTful. 
I can see that. Maybe the xml2 scenario is a good start. If you make it available and point the Golang Devs at it, I bet they will see what they can do.
This may help your decision: https://blog.gopheracademy.com/advent-2016/tls-termination-bench/
It's a tradeoff in readability but you see if everywhere in Go code. One could consider it a standard convention that you're obligated to stick to.
Go provides a healthy asynchronous execution model which lends well to multiplexing IO in sane and performant ways. Not only that but the execution speeds are well enough that you'll more than likely saturate IO (eg: network, disk IO) before running into CPU limitations. I've also found good success in tuning Go code when you do run into CPU limitations to tease out hard performance corners.
I keep my projects cross platform with very little effort with Go but my primary dev machine is in fact windows. I have not had any problem figuring anything out, including advanced stuff like code injection / hot memory patching, low level API work, and my hobby project a 3D game engine (which i feel like showing off as I just fixed the skybox issue: https://www.youtube.com/watch?v=OZgnyBtI1hw&amp;feature=youtu.be) (the framerate is crap in the video because my internet is the worst, i assure you it runs crystal clear at 60fps vsyncd) i love go!
```go var mStats runtime.MemStats runtime.ReadMemStats(&amp;mStats) // mStats is now populated with memory and other information ```
For application development, you really want to a framework. It's just too much work otherwise. Unless you're up to the task of creating such a framework, I don't think it makes much sense to use Go for this if you can't find one to use. I'd just do the backend in go and then use something else for the UI. Perhaps just a webpage to begin with. Or some sort of thin client sending commands to the Go process. 
I use autocert for things where it's just one binary, and traefik for anything more complicated (like my home server with multiple services, some Go, some not).
It has to do with how go handles method sets. Pointer types inherit methods from the Value type. Here's a pretty good explanation: [https://suraj.io/post/golang-methods-interfaces/](https://suraj.io/post/golang-methods-interfaces/)
I'm starting to like go, but that colon equals looks so much like equals is basically unforgivable. Someone made the worst possible decision there.
You really don't need a framework unless you're doing desktop or mobile GUI app development.
Well that's what I understood " Window Application Development" as. Not sure what else OP meant then. 
all this is very easy to do in go. search for the w32 package and it's cake
Do you mind to share it? :)
Thanks for the tip. I'll definitely give Rust a try. I learned Go so deeply that I still didn't have the courage to venture in Rust, but I'm aware that the RAII approach is a better fit for games than GC. My only worry is about consoles. Maybe one day I'll need to port a game to consoles, and I will not want to touch C++, but will do if I have to.
Windows can run CLI tools and background services just like any other OS.
Thanks for the link. Looked at the code and it does look good. I see not just layout but also the rendering is inspired by Flutter. Very cool. Will have to try it out. I assume this your project, so a bug report: godoc link on https://bitbucket.org/rj/pdfwriter points to goey docs A total aside: you're loosing a lot of potential exposure for the project by not being on github 
Of course, but I wouldn't call those applications. But perhaps I'm not up to date on the current jargon. 
&gt;Sure you don’t get inheritance, but it’s pretty rare that I’ve ever used that in OOP anyways Oh ok, do you're a terrible programmer. 
Close. For a Full Rails experience I’d look into Buffalo. That said, after doing WPwG, I feel a lot more confident that I’d understand Buffalo if I were to go back to it.
Not right now. Perhaps if there was a cross-platform UI framework like JavaFX for Java.
You can create a custom type for url.URL that implements the Scanner and Valuer interface https://golang.org/pkg/database/sql/#Scanner https://golang.org/pkg/database/sql/driver/#Valuer
I’m frontend dev and Im using go from time to time. Js ecosystem is a real mess. Tooling is very fragmented. Build process is painful. Go instead offers great dev experience and tooling. Formatter and linter are included by default and has strict defaults. Build process is very easy. Ecosystem is also great. Sure that there are some rough edges and pitfalls but I guess go 2 would bring awesome improvements to language core and make it better
What is available as a subpackage of the module path defined in `go.mod` does not require any `require-statements` to use them across the same module. Require is for module-external dependencies only. Or if you want to import another version of your same module. With no module-outside dependencies no `require`-statement is needed at all. If you import from the outside `go build` should add the `require`-statements by itself to `go.mod`. That’s the beauty of it. What path to use to import an inside-module is determined by `go.mod`-s module definition which gives the root path of the module and from there any package you add has the root path prepended to it’s path inside the module.
Is actually like to see some of your code inject/hot patch work
I tried to submit this as a comment to the original article but then it said comments were close :) Thanks for the writeup. I've written a number of cgo bindings in the past and a few point you had made confused me. Why did you have to modify the OprnVPN project to provide exported C symbols? In my experience, I would just write a local C shim layer which would deal in opaque pointers and function and delegate to the C++ library. The part where you say Go tooling must have source files in the project seems to me more like an option. If you have C or C++ source files alongside the Go files, the cgo compiler will be invoked for you. But there is nothing saying you can't pass arbitrary CFLAGS and LDFLAGS to the build to link against any internal or external library. You said you were forced to add an empty c++ source file to trigger c++ linking. Would it not have worked to add a directive to your go file like "#cgo LDFLAGS: -lstdc++"? You said cgo won't let you pass a function reference to C. But the rules are that it won't let you pass objects which contain nested pointers. I have bindings where I can define a generic exported go callback and then a public callback function type. And I can pass the unsafe pointer straight into C so that it will get passed by to my exported callback handler, type asserted, and executed. One must remember to use runtime.KeepAlive() to keep the callback pointer alive while the pointer is being used. Was your problem that you experienced an async callback pointer being moved by GC and later crashing? 
I’m someone who has completely phased out windows in and out of work. I think you’ll find that there are a lot of people out there like me, which is why there’s little documentation for Golang programming in the Windows space. That being said, it needs to be done. I hope you do it well, and people look to your materials for guidance. Good luck!
No, you didn't list enough of your project layout. Where is your go.mod file in relation to the packages? Get rid of the requirements in your go.mod for packages that are within the module. Those are only for external dependencies. You didn't list what you named the package within your go.mod but I assume it is 'myLib'. So if your project directory is 'myLib' and you have 'file' and 'error' directories under that, and a go.mod file at the root of 'myLib' then your import path within your error package would be 'myLib/file'. Also it is possible that it's an issue to have two packages within the same directory (file and file_test) 
What would you prefer instead? Colon equals has been around for decades before Go
Wouldn’t it be easier to set HTTP cache headers appropriately?
Both. Encrypt everything!
Really curious. What would it automatically generate in the comments? 
Thank you for reading the article, and for your input. Could be my lack of knowledge but I always thought of HTTP cache headers and eTag to be browser (or front end) specific and not something between microservices. Will have a look at it. This would just be an alternate solution
Most, and in my opinion all good HTTP clients, properly support HTTP cache headers.
Yea they do. I was on it a few weeks ago and went through maybe 50 algorithms problems in Golang. 
I just don’t rely on that as a crutch. 
Wouldn't the Cache-Control or eTag be a browser specific setting? I mean, if I had were to pass the header, there are two ways I can process it 1) Store the Cache-Expiry against the key locally so that I don't have to make a request again. I'm don't think Golang httpclient implements an in memory cache for that 2) Receive the request, read the If-None-Match and eTag and then send back a response. Correct me if I am wrong, just trying to understand if cache headers are used between microservices
I figured. Could be &amp;=, t=, 3=D who cares make it easy to distinguish
Are you certain the HTTP client doesn’t use them correctly on your behalf? I’d be disappointed if it wasn’t an option But that’d be a killer open source package to author. 😊
 We are in agreement about all the other points. I just want to warn whoever reads this thread about something: &gt; What I do seek though is [...] the guarantee that when the nil pointer occurs it's simply because it was incorrectly allowed in the factory and not somewhere else to be chased through the codebase. This is the code smell! An object shouldn't be initialized all over the place. Each "type" of object initialization should have a "name" and if you need a ton of those with differences, this would be a newable, not an injectable (to use the nomenclature of the article you pointed to). When you have `new Whatever(...)` or a parametrized factory method scattered all over the codebase, you are giving the callers of those things the opportunity to screw up the object initialization via improper parameters. However, if all your injectables have well defined initializations, and those are limited in number, then your factories need no parameters, and you can even cache those instances to share resources. In other words, you've just made your own mini DI framework of sorts. Think `MakeMasterDBConnection()` and `dicontainer.MasterDBConnection()` everywhere instead of `new sql.DB{...}` everywhere. The absence of parameters in the factories/retrievers is what prevents the mistake, not the encapsulation of the initialization logic. That you always have to implement correctly anyway. 
I also want to learn web programming with go, and his book/course seems the best option
Honestly it's a VERY comprehensive and easy to follow guide. Highly recommend. Worth every penny so far
I read this post as looking for something that could produce something a bit like JavaDoc - i.e. for every function/method, a comment is added describing what inputs are required, what return values may come out, etc.
Important for future readers also: &gt; Think `MakeMasterDBConnection()` and `dicontainer.MasterDBConnection()` everywhere instead of new sql.DB{...} everywhere. I vehemently disagree on `dicontainer.MasterDBConnection()` or `MakeMasterDBConnection` "used everywhere", the former being the service locator anti-pattern and the latter being a singleton creating coupling everywhere it is used. Whilst I am not advocating for an object being initialised all over the place, there will be cases where newables are required and the inability to initialise these incorrectly in any place other than the factory method is what is achieved here. From the rest, I cannot see anything we are in disagreement with. Assuming we have a proper injector doing it's work, and we tell the injector at the composition root: "use this factory method to instantiate this object", the inability to execute `new(X)` (because they are private) somewhere else in the codebase provides fewer chances of those nil pointers.
File system and user permissions are the two big differences in my experience. Mostly applies to writing client tooling, but may be relevant to others. 
[http://markhuge.com/](http://markhuge.com/) the dev apparently has a decent resume too. Found this wanting to do something more elegant than a redirect page + web server.
- The application should handle errors returned by http.ListenAndServe [(1)](https://github.com/markhuge/301/blob/6db46e74b91e0f4199b5ab7abe08211a2ad095bf/redirect.go#L27), [(2)](https://github.com/markhuge/301/blob/6db46e74b91e0f4199b5ab7abe08211a2ad095bf/healthCheck.go#L51), probably by logging the error. - The application does not need to use a mux because it only has a handler for `/`. Replace [this code](https://github.com/markhuge/301/blob/6db46e74b91e0f4199b5ab7abe08211a2ad095bf/redirect.go#L20-L27): redirServer := http.NewServeMux() // This feels super dirty redirServer.HandleFunc("/", func(res http.ResponseWriter, req *http.Request) { handleRedirect(res, req, proto, domain, port) }) http.ListenAndServe(portstring, redirServer) with: http.ListenAndServe(portstring, func(res http.ResponseWriter, req *http.Request) { handleRedirect(res, req, proto, domain, port) }) A similar improvement can be made in the health check code.
I'm doing pretty low level video processing.
I'm an old coot. I've done years worth of assembly language programming. &amp;#x200B; When I learned 'C' back in the mid-80s, I started out by compiling my code to assembler. (Oh, that's what it's doing)
Most of my career has been in the kernel, or working within an RTOS. Lots of C in there.
That's exactly what I'm talking about. You are a systems programmer, I'm not. Golang is a bit of an equalizer in this regard. 
Just create new *.go files in the same directory and give them the same package name. 
And it will automatically compile them as well?
Yes. 
Yes, just don't specify any file when you run "go build", or you can do "go build *.go"
I was thinking there was probably some include thing similar to import or something. I will give it a try, thanks for the reply!
I admit it's badly explained, but it's really quite simple: &amp;#x200B; \&gt; Is there a way to split this up these functions into separate files to make it easier to deal with? &amp;#x200B; Yes. You can split up code from the same package just by putting it in multiple files in the same directory. (With the same `package` declaration.) When you build, build the directory, not a file. \&gt; I know how to make my own packages, but do I actually have to create every additional file as a package? No. Each `package` needs it's own (exclusive) directory, but can have multiple files. If you don't want to deal with GOPATH, your main package can use relative imports to find these libraries. \&gt; Is there not a way to just compile multiple files into one? Yes. Don't name files to compile, name the directory. &amp;#x200B; `$ more *.go` `::::::::::::::` `o.go` `::::::::::::::` `package main` `import ( "fmt" )` `func main() {` `file2()` `fmt.Println("hi1")` `}` `::::::::::::::` `oo.go` `::::::::::::::` `package main` `import ( "fmt" )` `func file2() {` `fmt.Println("hi2")` `}` &amp;#x200B; `$ go run .` `hi2` `hi1` &amp;#x200B; &amp;#x200B; &amp;#x200B;
Yeah, I have been going over information and golang resources and I have never seen it explained. It is like to simple I sort of can't believe it. I guess coming from PHP i think i need to **include** everything and I learned about using packages, so I sort of figured there is probably another way to do this with files, but I couldn't find documentation about it... because it is just that easy it works HAHAHAHA.
I also like Alex Edward’s book (Let’s Go). Short and well-written. https://lets-go.alexedwards.net
Run it under strace. My random guess is that `uuid` is using /dev/random, which blocks if it runs out of randomness.
Have you read both? Which would you recommend between the two?
appreciating generics?
WinApi man :)))) that event loop 
I had always thought about this idea as well since the beginning of my Go adventure. I get really annoyed with the linter putting an item in the Problems list because my exported function doesnt have a comment yet, I always wanted to make a plugin for vscode thaat would just add something like automatically: ``` // MyFunction ... func MyFunction() { } ```
But isn't that redundant to the automatically documented method signature? Why would you want a text-based version of the same thing that could go out of date? godoc already gives you automatic linking to the input and output params. Then, there is nothing left to generate?
But then you are just ignoring the fact that you should be documenting your exported functions :-) So you will have it autodoc away the comment with redundant info?
I can't do a comparison because it wouldn't be fair. I think both Alex and Jon are awesome. I'll just share my experience: &amp;#x200B; I purchased Jon Calhoun's book about a year ago and read the first \~100 pages. He explains stuff really well, but I got overwhelmed at the size of the book (700+ pages) and I was also VERY new to go at the time and just felt overloaded (which was due to my own lack of experience). I took a break and just did other projects to expand my Go skills and comfort and never really got back to that book. &amp;#x200B; About a year later I picked up Let's Go by Alex Edwards and am pretty much done with it (about 25 pages left). So far, I have thoroughly enjoyed the book and thought everything was really concise and well-written. Key concepts were explained very clearly. &amp;#x200B; If you're really new to Go and don't mind a more comprehensive + longer book, maybe Jon Calhoun's book makes more sense to get. On the other hand, if you know a bit more Go and you just want something super concise but well-written, maybe you want to go with Alex Edward's book. &amp;#x200B;
Ideally, any exported function should create a comment with the function name and a placeholder on save. For example the `// FooBar todo` would be generated. // FooBar todo func FooBar() { fmt.Println("HI") }
Yes!
Can you help me understand why Interface can't be beefed up to accommodate contract?
i'm working in the languages my company wants me to work in. &amp;#x200B; Rust may be interesting, but, not for the work I'm doing.
I don't know. I've never explored the use of interface instead of contracts. So, I will quote the arguments from the authors of the Contract proposal: &gt;Why not use interfaces instead of contracts? &gt;The interface method syntax is familiar. Writing contract bodies with x + x is ordinary Go syntax, but it is stylized, repetitive, and looks weird. &gt;It is unclear how to represent operators using interface methods. We considered syntaxes like +(T, T) T, but that is confusing and repetitive. Also, a minor point, but ==(T, T) bool does not correspond to the == operator, which returns an untyped boolean value, not bool. We also considered writing simply + or ==. That seems to work but unfortunately the semicolon insertion rules require writing a semicolon after each operator at the end of a line. Using contracts that look like functions gives us a familiar syntax at the cost of some repetition. These are not fatal problems, but they are difficulties.
Where do you think the client stores the cached copy?
There's one in development: [https://godoc.org/golang.org/x/exp/shiny](https://godoc.org/golang.org/x/exp/shiny)
Surprisingly I can't \*immediately\* find an official reference saying something to the effect of "a package consists of one or more go source files within a single directory, sharing the same package name". The [Go language spec](https://golang.org/ref/spec#Packages) does say this: &gt;Go programs are constructed by linking together *packages*. A package in turn is constructed from one or more source files that together But it doesn't specifically say that they are multiples files in a single directory. That is likely because it is specific to the Go tooling as to how to collects source files.
What is the advantage to making your app with these Windows specific API calls? If it takes extra effort to implement them, why not just stick to cross platform modules?
Yeah, I read this, but this thinking that packages are made up of one or more files, by somehow linking them together. With import, but that is when you call a package. I wasn't thinking it just automatically uses the other files in the directory. Pretty interesting in how it does this, from what I have seen so far each file still needs its own imports, but I actually like it. Otherwise I would forget which import was for what file if they were all in the main.go.
I love python, but its reliability definitely doesn't scale.
Go turned out to be a good fit for many cases even at lower than Google scales. The average Go user I know is interested in getting things done without being too enamored with the solution itself. As I see, they espouse Go mainly for its pragmatism.
Native api calls are are very different.. Eg. Check if a process is running by a given process name on Linux and windows...
lol you have a very weak grasp of OOP if "relying on inheritance is a crutch. "
So let me get this straight, one needs to only do inheritance in OOP to be a “good programmer”, instead of using the multitude of different options. You do you. 
Client side caches help when individual clients make the same request repeatedly. Server side caches help when many different clients make the same request. They solve different problems and the right answer (which can also be no cache) depends on the case specific request pattern.
Using a randomized cleaner you can reduce the time the lock is held: https://github.com/dgryski/go-expirecache/blob/master/cache.go#L170
Thanks for the bug report. Turns out that I had the fix sitting on my drive, just not pushed. You're probably right about not being on github. I'm trying to get a port to MacOS more or less ready, but afterwards will have to consider moving the repository.
The go http client does not.
Thanks. It's easy enough to test without `uuid` at all (and I probably should have done that sooner). This was helpful too, because it's still stalled out, but this time at 999681 rows, which makes sense because it's faster now, right? `pg_stat_activity` shows the same as before. I added a couple of updates above which show that it will finish, eventually, but the long duration of this seems odd (along with the magic of 3 and not 0-2 or &gt; 3 goroutines.
No, you need to understand why using inheritance in OOP is not a crutch to be a “good programmer”
If you honestly think that requiring using inheritance instead of the multitude of other means makes someone a good programmer, you need to seek help. 
Thanks very much for your thoughtful reply!
The linked article is also worth a read: [http://www.automatedtrader.net/articles/strategies/156590/what-ive-learned-building-low-latency-systems](http://www.automatedtrader.net/articles/strategies/156590/what-ive-learned-building-low-latency-systems)
Just out of curiosity, what is your current job title?
Consider [https://lets-go.alexedwards.net/](https://lets-go.alexedwards.net/) Not affiliated, did however buy the book. The book basically is a web app/API in which you recreate github gists. Uses modules and an idiomatic project layout, quality tutorial. I consider it in the same vein as the Rails Tutorial by Mike Hartl, the only other tutorial book I've ever paid for. 
For non-webdev practical examples with Go, search on Amazon for the books "How to write a interpretor in Go" and its sequel "How to write a compiler in Go".
A lot of people are saying that you need to create them in their own directory. You do not. You can alias the same package from multiple directories. I posted an example here: [https://github.com/Dispersia/TestGo](https://github.com/Dispersia/TestGo) you can use the same package and alias different directories, and you still only have to reference a single file to build it all together (In my case, go run main.go, go build main.go).
Per se, no, but it would violate two principles most Gophers hold dear: First, fail as early as possible, and second, it complicates the “line of sight” of the code. Both of those are google-able if you want to read more. Good luck!
what do you gain by randomize it, instead of just doing batches ?
this is a great answer!!!
Oh, wow, that could be a tasty pull request. I think I’ll start hacking...
Where ever it chooses to store it. I’d vote for /tmp somewhere...
If you set the headers, you can trivially add nginx, varnish, or CloudFlare to handle the rest of the caching.
This problem is virtually nonexistent in Go. It is the intention of the maintainers to never release breaking changes in any releases of Go 1. It's impossible to guarantee that no future change will ever break a program, but I've been writing Go for years and have never had a program break by updating the version of Go I was using. https://golang.org/doc/go1compat
Even when Go introduced some breaking changes they wrote rules for the "go fix" command that would update your code automatically. But it's not happened any time recently. I remember "go fix" was used alot more during the pre 1.0 era
Align the happy path to the left edge: https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88
 func TestStructToStruct(t *testing.T) { now := time.Now() var src = struct { Field1 int Field2 string Field3 int64 Field4 float64 Field5 time.Time }{ Field1: 1, Field2: "you are a good guy", Field3: 3, Field4: 3.141592654, Field5: now, } var dst struct { Field1 int Field2 string Field3 int64 Field4 float64 Field5 int64 } cpr := copy.NewCopier() assert.NoError(t, cpr.Copy(&amp;dst, src)) assert.Equal(t, int(1), dst.Field1) assert.Equal(t, "you are a good guy", dst.Field2) assert.Equal(t, int64(3), dst.Field3) assert.Equal(t, float64(3.141592654), dst.Field4) assert.Equal(t, now.Unix(), dst.Field5) } What is with the time.Time field? Also, to be fair, you use a cache in your benchmarks, the other projects do not. So it isn't exactly a valid comparison of the copying itself. It's however a great comparison to show how beneficial caching could be. I disabled the save method to check how it performs without a cache. ➜ go test -bench=. -benchmem go: finding github.com/ulule/deepcopier latest go: finding github.com/jinzhu/copier latest go: downloading github.com/ulule/deepcopier v0.0.0-20171107155558-ca99b135e50f go: downloading github.com/jinzhu/copier v0.0.0-20180308034124-7e38e58719c3 goos: linux goarch: amd64 pkg: github.com/liguangsheng/go-copy/_benchmark BenchmarkJinzhuCopyBig-8 10000 113326 ns/op 68848 B/op 487 allocs/op BenchmarkDeepCopyBig-8 500 2093043 ns/op 1907779 B/op 25759 allocs/op BenchmarkJSONCopyBig-8 50000 25718 ns/op 4759 B/op 152 allocs/op BenchmarkCopyBig-8 10000 135484 ns/op 154874 B/op 443 allocs/op BenchmarkJinzhuCopyMedium-8 200000 7717 ns/op 7320 B/op 58 allocs/op BenchmarkDeepCopyMedium-8 50000 28497 ns/op 21672 B/op 331 allocs/op BenchmarkJSONCopyMedium-8 500000 2767 ns/op 472 B/op 17 allocs/op BenchmarkCopyMedium-8 100000 14189 ns/op 13131 B/op 60 allocs/op BenchmarkJinzhuCopySmall-8 500000 2348 ns/op 1616 B/op 21 allocs/op BenchmarkDeepCopySmall-8 300000 4118 ns/op 2520 B/op 49 allocs/op BenchmarkJSONCopySmall-8 2000000 774 ns/op 104 B/op 5 allocs/op BenchmarkCopySmall-8 300000 3636 ns/op 2064 B/op 24 allocs/op PASS ok github.com/liguangsheng/go-copy/_benchmark 17.639s Ofcourse this slows down your lib, by a lot. But to be fair, you designed it to use a cache. So ofcourse disabling one method instead of tweaking everything else correctly, will affect the results. That being said, I don't mind a cache at all, as long as it's mentioned in the README and benchmark results you provide. 
This is surprisingly a very good talk. The speaker seems pretty eloquent too!
Submit a git &amp; pull req? Doesn't look like author has been active lately though.
I come from C++ so I'm a little curious why we can't do something like? ```go Template{type T} func Print(s []T) { for _, v := range s { fmt.Println(v) } } ``` Or even this, to support specific types only ```go Template{type T, types{int64, flaot64}} func Print(s []T) { for _, v := range s { fmt.Println(v) } } ``` I feel that this makes it easier to spot at first glance that this is a generic. I haven't read through your entire proposal yet. But I always get happy when I see people put in the work. Keep it up! :)
Good idea, but you'd still need to use this which does more or less the same thing as what OP's lib does. It wouldn't be inherently any faster.
The best use case for them I've found is for simple data. HTTP calls can actually be quite expensive for high performing micro-services. Asking the server if nothing has changed is much cheaper than making the full request, even if the server on the other side can just serve it up basically instantly. This gets even better when you put caches (such as a Content Delivery Network, commonly thought of as useful for static assets like images and video). If you have a global network of microservices, this is how you keep performance up.
I don't get why we can't just do func Print&lt;T&gt;(t T){ // stuff here } It seems like the most clear way to implement generic types. Not to mention it aligns with most of the current languages which accept generics
Brilliant thanks
Good insight. I'll probably pick up Alex Edwards book once I'm done with Calhoun's, just to pick up some snippets that may or may not be in Jons
You also haven't shown the code for CreateEmployee, maybe you did something odd there? Also make sure to run `go vet` and build with `-race` to try and spot races.
&amp;#x200B; 1. thanks for you reply 2. I design it can copy time.Time to int64, because i have seen people need this feature. Also it can register custom descriptor to copy between different type. 3. it did use cache and it's implements as cache friendly, so if you disabled cache, it is slow down. 4. JSONCopy in benchmark implements with jsoniter, jsoniter use cache too. 5. sorry for my broken english.
Under the same directory, there's no difference between putting all code into a single .go file, or put them across multiple .go files. You might as well note two things: 1. there can be only 1 `main` functions in all .go files in the directory, otherwise it would not compile; 2. each file is allowed to have its own `init` function which will be run before the `main` is run. This could be useful if you want each .go file to register something globally before the program actually runs, like the database drivers. 
You *could* do that if you wanted to subdivide further into separate packages. You'd just be using import. import ( "fmt" "path_to_your_other_package" ... ) But it sounds like that's not actually what you want.
Don't use empty interface if you can
That's pretty cool!
Thanks Patrick, I'll add this to my blog
Thanks for the input. I think redis follows a similar approach as it reads a bunch of random keys every second and evicts them if it has expired. I've taken a read lock to read the keys in a particular shard and then I take a write lock only to delete the expired keys, hence not having a complete block on the shard periodically. So in case there are no keys to be evicted, no write locks would be taken on the shard. What do you think about this approach? 
Understood :) Yes, I'm sure http clients do not do that in general. I agree with you in terms of browser requests
Unfortunately, without C++-like templates, I haven't found the proper way how to pass different variable types. I've discovered golang sources and even golang uses empty interfaces under the hood (for example, in fmt.Print\*).
It's above: Prepare() + Exec() for the insert statement (plus the usual check for err after each), and that's all, basically two lines for this test. Insert first name, last name, and `NOW()`, now that I've removed `uuid` to simplify. `vet` and `-race` didn't have anything to say, but I appreciate the prompt, because I should probably be doing this more, too.
A couple of years ago I had a similar need so I was curious about your solution. At first glance I didn't understand why you had to create shards for an in-memory cache but then when I looked at the source code I realized that the reason is solely for scalability reasons on the key eviction side. Overall one thing that I didn't like was the fact that for every shard you're locking the shard and looping through all the data in it during eviction. If we're talking about hundreds of thousands of keys this can make a dent in your latency requirements and some hiccups on your CPU usage. At what scale have you tested this? Another issue is you RLock the shard for retrieving the keys for eviction but then you Lock it again to delete them. There's obviously a race condition here (eg. suppose someone sets a key between the locks and that key just expired, you're going to delete it even though you shouldn't have because it was just extended). Anyway here's a link to my similar solution https://github.com/imkira/go-ttlmap
Because it’s a feature used by almost no one and has associated support costs? As was explained in the linked issue. Also, why would you distribute a web framework like beego as a binary-only package? (From your comment on said issue)
I removed all go.mods in every directory of my lib and started over. did the go mod init myLib (in the root of myLib) the tests run fine (and as I wrote, they are in the same directory as their counterparts, only in a \_test package). So far so good. &amp;#x200B; Now I go back to one of my other projects "bmaker" that uses this library. It starts complaining about: go: parsing ../myLib/file/go.mod: open \~/data/go/myLib/file/go.mod: nosuch file or directory Which I fixed in the past by having a go.mod in that specific directory of my library. But what you are telling, this is not needed, so how to fix those messages to be able to use the library? &amp;#x200B; I will do the same: remove the go.mod (in the bmaker root) and initialize it again, see what happens. go build complains about the module packages not found, so I added myLib/error v0.0.0 within the require and at the bottom I added: replace myLib/error v0.0.0 =&gt; ../myLib/error build again and another complaint: go: parsing ../myLib/error/go.mod: open \~/data/go/myLib/error/go.mod: no such file or directory &amp;#x200B; This tells me to make a go.mod in the subdirectory of my library. But I can't find this particular obligation in the documentation (or my english is that bad so I misunderstand) Let's assume, it is not needed in the subdirectory. How to fix it then? Hope this is really clear enough. (BTW I appreciate your help!)
Examining postgres stats again, all three are marked `idle`, and two out of three are waiting on `ClientRead` (the third is null).
Thank you for reading the article and for your input. Good to know you've also encountered the same problem. Here's my take on your questions: 1) I've taken a read lock to read the keys in a particular shard and then I take a write lock only to delete the expired keys, hence not having a complete block on the shard periodically and requests can still keep serving as a Read lock would not block the shard. Hence it gives me an advantage in case there are no keys to be evicted, since no write locks would be taken on the shard compared to periodic check and deletion like redis (this design suited my current use case tbh, no other reason). I've tested and used this in multiple microservices, each serving ~ 2k-3k QPS 2) The evictionTime can be varied so that the goroutine evictor can run every minute or second or after every few mins. 3) You are right about the issue you pointed out. I had thought about it but I took a hit on that mainly because I did not want to fully Write-Lock the shard and since this acts like a L2 cache for me, it would lead to another cache miss which can be recouped in the next request. Thanks for pointing this out though, appreciate it and will see if I can do something about it. Appreciate the link to your solution! Going through it
I think you are saying: there is one go.mod (in the root of a project) a require is needed if an external project is needed (which a build will inject this into go.mod) For the last part, I don't understand what you mean by it. In one of my subpackages, I need to use some other library functionality, so there I have import libError "myLib/error" That seems to work and I didn't have to change the go.mod file for it. (inside the go.mod there are only external libraries now) &amp;#x200B; But how to use the same functionality in another module?
I did and there is no mentioning about how to use it in a multi module environment :-(
&gt;As a corporate programmer, the closed-source use case is very important. A language that is so RMS idealism friendly that it doesn't even allow one to use closed-source dependencies is a very hard sell in many corporate environments. Like this guy said, for using closed source purpose. Swift and C++ has the same feature, all you get is an binary-only package, with Swift is framework. Its all about IP, i want other developers in my team to use my framework without copying my code to use on another project. &amp;#x200B; Russ Cox said we can use plugin, but they are two different things. 
&gt; Its all about IP, i want other developers in my team to use my framework without copying my code to use on another project. &amp;#x200B; If that is the case, why did you open source it? [https://github.com/astaxie/beego](https://github.com/astaxie/beego)
1- I guess that's a good rate. For how long did you run those tests? How many shards did you have and how many keys in the cache or per shard did you have? 2- I think you could improve and have 1 sweeper goroutine per cache rather than shard. Is there a need for 1 goroutine per shard? 3- You might consider rechecking the expiration of keys inside the Lock, just in case they were extended by some unlucky Set after the RUnlock and before the Lock.
Im not the author of beego. I take it for an example for my private frameworks. 
You should avoid a nested tree of go.mod files (ie another one in your myLib/error). It's over complicated and not necessary. Just one in the root. Now, your package that your require in your bmaker project should actually just be "myLib v0.0.0". Why? Because your versioned module is "myLib". When you add the subpackage it is trying to treat it like a module and expect another go.mod. Remember your go.mod file tracks module names, not every package within a module. 
I store them in the package they are returned from as exported variables to be used from callers to check which error was returned. There are naming conventions: &gt;[Error types end in "Error" and error variables start with "Err"](https://github.com/golang/go/wiki/Errors#naming)
aaaahhhh . :-) That was what I misunderstood. Yay! This last piece of the puzzle was great to find. (You earned yourself a virtual beer)
I wonder if I'm encountering this issue: http://go-database-sql.org/prepared.html I've tried it again without the prepared statement, and it didn't hang this time. Also doubled the inserts, in case it was finishing sooner and avoiding the problem. The situation described in the above link sounds potentially applicable here with the goroutines, however. Though the magic of 3 isn't clear, when quantities greater and less than have all been fine.
Supply the interface code with your binary. Problem solved.
Can you tell more detail about it?
There are a lot of unchecked errors or potential panics in the codebase. The use of interface types is the problem. This would be an immediate blocker for use in any program for my company. My main critique l, though, lies in the use case. Why not utilize gomaxprocs and channels instead of creating threadpools? Part of the core features of golang are channels and thread management. https://stackoverflow.com/questions/17853831/what-is-the-gomaxprocs-default-value
I think main goal was fast compilation times. Which might be counter intuitive but if you see how google works that might be main reason with concurrency support out of box close second. Everything else doesn’t really matter and everything else was added/adopted later on. 
That might be true since go mod but before in the gopath times build process was a mess for go. Also npm vs yarn issues might be a problem in 2015/2016 now with npm having such a good dependency resolution I think it is fine. What has littered with shit build process is C++.
Man it is about typing. Writing : is easier than any of the top shift numbers on keyboard. It is for simplicity and ease. 
Beyond the issue of package reference many have addressed for you here. You may wish to use a good layout to your project. Especially for internal and pkg level functions you may with to reference. Take a look at [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)
You are simply ignoring all the errors. Inspect if there was an error or not properly, not to ignore them, and then see what happens again.
The problem is not parametric polymorphism and the syntax for that but how to specify what operations the type parameters support (ad-hoc polymorphism). &amp;#x200B; One problem contracts are designed to solve (similarly to concepts in C++) is the problem that without external specification of the allowed operations it is possible for modifications internal to a function to affect its type signature (by changing what operations the types need to support). Other languages solve this in different ways (e.g. typeclasses).
This snippet is all of the main function in my local program. On compiling, I didnt get any errors. 
Yeah I meant runtime errors, not compilation errors. Look at your code you are just ignoring possible runtime errors that would came from function by putting _ on the left side of assignments.
Regarding to the documentation, GOMAXPROCS sets the maximum number of CPUs, it also can be the environmental variable that specifies the number of OS threads that Go can utilise. This approach looks like not very flexible (for me), because it's affected the whole application. But maybe this is a good approach in GO, I'm not sure. In my solution, I want to save you from using waitgroups, atomic and other stuff. I want to get the easy to use and effective tool, that "just works". But you right about error checking, thank you, it's a very important point. &amp;#x200B;
I am not the author of the original Contracts proposal. My proposal tries to make it more readable. But, AFAIK, C++ does not enforce constraints on the type arguments. That is the whole objetive of contracts.
Damn, I completely missed that. Thanks.
It may be a good idea to drop permissions in your docker containers, currently they're running as root.
`url.QueryEscape` is probably the one you're looking for. Here's a playground link: https://play.golang.org/p/Fim4gcn-ZJa
Awesome! Enjoy. 
Interface is about a single type. Contracts show relationships between multiple types.
At the last line of the Usage part of the README you write d.Close(), I think you meant db.Close() ?
Yeah, Thanks for noticing it. will update it now
So far the _language_ hasn't had breaking changes, but they will probably come in go 2.x. That said it is common to have breaking-changes in _libraries_ which others have developed. In an ideal world you'll use vendor, or modules, to pin dependencies. But too often people don't bother, which leads to surprises when you try to build code that "hasn't changed" for six months+.
In regards to Go 2, it's worth noting that that release is probably a long ways down the road
The only "breaking changes" I know is that when adding a new GOOS or GOARM, filenames may become OS-/ARM- specific. &amp;#x200B; When Wasm is out, one of my package with a file namd \`encrypt\_js.go\` stops compiling. But it is really trivial to fix.
I already knew about this, which I have done with the more common functions. But I was hoping for a way to split up the handler functions when using net/http. I just didn't know about the *.go and how it automatically handles that like a boss. 
Thanks for the help guys! I was just overthinking it, u/Benz1267 got me on track and thank you u/BraveNewCurrency for the example. It was really just that easy. O.O 
Oh nice, that is actually very helpful for rebuilding this project. 
I have tried that earlier. But it's replacing space characters with + instead of %20. https://play.golang.org/p/L0WvTs5T-2r
I have tried that earlier. But it's replacing space characters with + instead of %20. https://play.golang.org/p/L0WvTs5T-2r
It doesn't build on Windows: `#` [`github.com/sch00lb0y/aran`](https://github.com/sch00lb0y/aran) `.\table.go:52:15: undefined: syscall.Mmap` `.\table.go:52:70: undefined: syscall.PROT_READ` `.\table.go:52:89: undefined: syscall.MAP_SHARED`
Ok I got your point. `url.PathEscape` does replaces spaces with `%20` but this time it doesn't escape plus signs. I think you should implement your own escape function.
Yeah, will update it. Thanks
I know it's a quote so this comment isn't really to you. &gt; It is unclear how to represent operators using interface methods. That's a weird thing to say since the contracts draft doesn't deal with it either. type Add interface { Add(something Add) Add } func &lt;T&gt; addTogether(one, two Add) (T) { return T(one.Add(two)) } I have no idea how hard it is to compile time check that cast. It doesn't remove the casting but it does contain it more. If you want to go all out on syntactic sugar then the cast could be done implicitly. func &lt;T&gt; addTogether(one, two Add) (T) { return one.Add(two) } I've only looked at the original draft and your proposal for about an hour now so I'm sure I'm not understanding something. The implicit cast might be a bit confusing for multiple returns. func &lt;T&gt; addTogether(one, two Add) (T, bool) { return one.Add(two), false }
Oh no. I mean the article linked in your blog. You've done a great job.
btw, it seems both Go's and JavaScript's follow standard, just differ in strictness. What's your main problem now? Should the encoded uri exactly same as JavaScript?
Thanks for pointing out that package! Not making a request is far faster than making a request to a faster endpoint!
As kindly provided by /u/zegdv: https://github.com/gregjones/httpcache
Yes, I've been using resty a golang library for making http requests. So while sending the requests along with query params which has spaces in-between them are giving me internal server error. For ex: https://www.facebook.com?message=it doesn't encode spaces But after replacing the spaces with %20 it's working properly. Bcse space is in raw form, instead of Unicode format. 
btw, it seems both Go's and JavaScript's follow standard, just differ in strictness. What's your main problem now? Should the encoded uri exactly same as JavaScript?
Yes, I've been using resty a golang library for making http requests. So while sending the requests along with query params which has spaces in-between them are giving me internal server error. For ex: https://www.facebook.com?message=it doesn't encode spaces But after replacing the spaces with %20 it's working properly. Bcse space is in raw form, instead of Unicode format. 
Well then how about this? https://play.golang.org/p/ZyKhmOUv3tU Escape first then replace plus signs with %20 manually. It can be assumed that remaining plus signs after escaping are from spaces.
1. Use SDK is not enough for you? like recommended here: https://docs.docker.com/develop/sdk/examples/ 2. Did you enable GO11MODULE=on ? 3. Try to delete go.sum file and run go get again. 4. Try also run “go mod vendor” then see what versions of modules are in vendor folder (of course better use exact release of Docker, because their master can be broken). 
&gt; Use SDK is not enough for you? That's pretty much what I use, but I also use some stuff from `docker/cli` because I need to deploy stacks and don't want to reimplement all that logic. &gt; Did you enable GO11MODULE=on ? It is auto by default, and since I am outside of GOPATH it should be on. Just in case deleted `go.sum`, ran `GO11MODULE=on go install`, it fails with an error that some k8s module can't find a package. Suggested fix is to modify the used k8s versions in my `go.mod`, which I am not sure is a good thing, as I said in my post.
currently support only c#, but ms plans to another languages &amp;#x200B; great opportunity for seeking golang project ideas to pickup go implementation
Embedded?
Yeah, it's embedded. have to lock the direcotry to avoid other instance access. will implement the dir lock tommorow may be. lemme know if you would like to see anymore feature. 
I can do this. But the thing here is, this is only one situation, but the same thing can happen for other characters also. If the customer uses some characters which were not tested by me, can cause serious problems. I'm looking for a generic solution which will fix for once and all. 
Even for Go 2.0, the changes will most likely be backward-compatible. The designers are doing everything they can to avoid a Python 2 to 3 type of transition. They cannot just change the language and hope that the whole ecosystem will eventually follow. 
Why the reference to config files if you don‘t use any? Looks like you used the cobra init blindly. Why use cobra at all if all you need is 2 flags? 
Can your rename your interface? For readability reasons only ``` type Addible interface { Add(something Addible) Addible } ``` For me this looks very clean. I think if generics were ever to be added to go, beefing up interfaces might be the cleanest way to do it without complicating the language too much.
You should put in some for request headers, bodies, and db like I did here. https://gitlab.com/zendrulat123/prettymiddleware/wikis/home Just add the r.Whatever is needed. Except I'm just not totally sure what you can do with all that info programmatically + context? But I know there is something. 
You're right, I needn't use Cobra at all, just my habit when starting new CLI tools because further improvements are a lot easier to implement then. After further thinking, I don't think this program will need more options or special configuration in the future, so I will probably remove Cobra layer. Thank you for the precious advice, feel free about sending the PR yourself if you want to improve the tool ! :)
Simpler than `python -m http.server` ? Hmm...
Hmm, honestly I'm not totally sure about what you mean here ?
In other frameworks you still handle GUI elements by hand. lxn/walk is fine. Use it if you feel it is better.
Good implementation, good code quality. Take a look at github.com/qiangxue/golang-restful-starter-kit in apis/util.go for a really smart way of paginating. Take a look at https://github.com/snwfdhmp/errlog to improve your error logging so that your package can be used in both development and production environment. Search for "github README best practice" on Google to improve your READMEs a lot and catch more developers that might want to use your package.
Basically, context might be needed for debugging. Also, header, body, request, DB information might be needed as well. Especially if you have a lot going on. Basically my link isn't a package but just end points in different go core packages. It came out of the frustration for constantly checking stuff but also seeing on Google app engine this request logging information. https://cloud.google.com/appengine/docs/standard/go/reference/request-response-headers https://cloud.google.com/appengine/docs/standard/go/logs/
Although turning it into a program would be awesome like this. https://cloud.google.com/logging/docs/view/overview
Let me see if i cant get some motivation to clean it up a bit today and push it to github, i'd be fairly embarassed to show it as is
In your example, don't you want to defer the `db.Close()` before the second panic? Otherwise you're gonna leave the database open if it panics.
Holding the RLock doesn't block other readers, but it does block any writers that want to add a key during the sweep.
Without seeing a code example this might be a little off. If the tables need to be created in a specific order, then maybe using goroutines for concurrency is not the best solution here. As you mentioned, you can use `sync.WaitGroup` as well as channels to wait for goroutines to complete, but if you have a string of statements and are trying to run each of them in a goroutine and execute them strictly in order, you probably don’t need goroutines at all. Goroutines are an awesome tool for doing things concurrently but I when I first started writing Go coming from a JS-heavy background, I equated them too much to Node’s asynchronous callback/promise style designed to maximize utilization of the event loop. Go programs have no event loop* so there are different considerations here. In general, if you need things to happen in order, don’t over complicate it by using goroutines. I highly recommend Rob Pike’s talk at Heroku “Concurrency is not Parallelism” where he dives into some program design using goroutines. You can find it on YouTube. *Well, at some point every program has an event loop of sorts in the kernel.
Good catch. I'm away from keyboard. Will update the example after I reach. Thank you very much
I believe sql.Exec is a goroutine by itself. var Users = "CREATE TABLE...." var UserPhones = "CREATE TABLE...." func createTables(db *sql.DB){ err:=db.Exec(Users) if err!=nil panic(err) db.Exec(UserPhones) if err!=nil panic(err) } I get error table user is not defined (table UserPhones references User). This is ofcourse simplified example, but I hope you get the picture. Since db.Exec runs in async there is no way of knowing the order of execution.
How do you handle localization then? (Honest question, not meant to be snark)
Ah, I see what you’re saying. That’s… weird. Exec’s usage should be synchronous. What database driver are you using? Also, mind posting your full SQL?
Which driver are you using? The code is all synchronous for Exec.
Depends. If you're only sending, then you just need to comply with the SMTP spec. 2 ports are used for that if you want both clear and ssl traffic. 
Maybe a dumb question but the json copy results in the Benchmarks are better than your package right? Why would i not use that instead then?
im using "database/sql" this is one of the sql's var Phone = `CREATE TABLE IF NOT EXISTS Phone ( "id" uuid primary key NOT NULL DEFAULT uuid_generate_v4(), "userId" uuid NOT NULL REFERENCES "User"(id), "phone" text UNIQUE NOT NULL );`
A data race is a condition in which two threads are accessing and updating information concurrently and the potential correctness of the operations is left to the order of execution of the instructions. This is bad. If instead we use some mechanism like a lock around sections of things we change in threads then we can make sure that when we want to make a change to something it is being changed everywhere and force the other threads to wait until it’s been updated before accessing that data. I’m Go, the answer is the *sync.mutex. Here’s a bit more technical usage for it. https://gobyexample.com/mutexes
Depends entirely on your use case and what trade offs you are willing to make. I'm sorry but your question is way to vague. 
You can program in Go without ever using :=.
Use case here is to send strings of data. I intend to write an SMTP server and I need my web server to communicate with it. So all the data I need to send must travel how? Is my question. 
As I commented below, I am trying to write a rudimentary SMTP server so I need my web server and SMTP to communicate
Man i think i found a magic bullet for building webapps in go. React for frontend and Go for API backend. It kinda is sweet if you are building WEB APP not WEB PAGE :D. 
Shame I know fuck all javascript
good point
sorry, wrong c/p github.com/lib/pq
There are two things to explain here: the underlying race condition in your code, and what the race detector is telling you about it. First off, the bug in your code. You have one goroutine (call it A) "writing" to a task field (in this case, t.status and t.updatedAt) concurrently with another goroutine (call it B) "reading" from that field. Without any synchronization, the value could be written by A before it is read by B, but B will use the former value (because the CPU tries to avoid actually reading from memory as much as possible), and that's probably not what you intended. What the race detector is doing is logging the timestamp and goroutine on all reads and writes to each allocated variable, and reporting when it sees suspicious access patterns. E.g., in this case, you have a read from B occurring just after a write from B, or writes from A and B happening in sequence without any intervening reads. A common way to fix this particular class of race condition is by using a [sync.Mutex](https://golang.org/pkg/sync/#Mutex) to guard access to your shared memory and ensure the intended ordering of reads and writes.
Simplicity and ease? I'm the only one who miltiple times a day gets that annoying error purely because at first glance I can't tell the difference between := and =? Maybe I need glasses
&gt; you should never attempt to unmarshall into an interface? How should that even work? After unmarshalling the interface value should contain one value implementing that interface and containing the unmarshalled data. Which type should be chosen? 
"Swift and C++ have it" is not a valid argument. Go doesn't need to be C++ or Swift. The community doesn't gain anything by being popular among people who want to distribute closed source libraries, and it isn't going to lose anything if those people go elsewhere. 
Ah, I think I see the problem. Exec’s signature is different than how you’ve got it here; it returns a Result and an error (in that order). Try `_, err := db.Exec(...)`
Working code is best code... It's not a beauty contest :P besides code with " fuck it, I dunno why this works" is always more fun to read
Thanks! I’ll check! 👍
I recommend using the `net/url` package to construct your URLs in a safe way by composing them of parts and doing the encoding, like so: https://play.golang.org/p/e2mDDBEdbYc
Anyone have an open copy of the paper?
you could say same about HTML, CSS, Makefiles, M4... you can't nowadays build a nice working web app without even tiny amounts of JS. Imho if you go React + Go what you get for free is a ready to use API for your mobile or client without being tied to HTML generation. That is a massive benefit.
i had this maybe within my first 2 months of using GO. Now it almost never happens and if do compiler catches me on it and points me into fixing it.
you can use sci-hub to download :P
Also getting better for me. But, can we not admit the two should be easy to distinguish, but the symbol you can add to = to make it most resemble = is : ? We are talking information theory here. Different pieces of data should be easy to differentiate. Why would anyone downvote this issue. Craziness.
Oh got it :) THank you
Thanks for the input! I'll open an issue linking this comment so I don't forget about it (as I did... until now)
I'm also fairly new to Go and modules. A fair number of go tools are not yet working with modules. One of them is guru, which I have come to rely on. Once I figured that out I just went back to GOPATH. I figure I'm a noob and not in a good position to beta test fundamental changes to the build and package system when there are significant known bugs.
Usually i18n. But I haven’t used that in anything production wjth go. 
It was more a personal reflection. My front end skills, apart from HTML and CSS, leave a lot to be desired.
Could somebody please explain to me what "Railsy" means? I assume you're talking about Ruby on Rails. But what makes an app "Railsy"?
If I add space between the query param values, the issue still persists in your solution. https://play.golang.org/p/h0cZUzugV-d
Very interesting and hard problem it's a race condition hell
It could be your dispatcher in main.go. You're creating a new dispatcher, calling run in a goroutine and then calling setuprouter which may be further modifying the dispatcher. Thus, two routines modifying disbatcher
Mixing Docker and modules is pretty frustrating and has been since day one; Docker simply doesn't version things the way that the new Go tooling expects, and I'm not sure if it'll ever be resolved. I have one project which uses a lot of Docker libraries, and if I want to use modules, I use the commit hashes ([manually pick these revisions by hand](https://github.com/docker/cli/blob/master/vendor.conf), or just ask for `@master` for all of them). Even then, it's not enough, as then `go get -u ./...` isn't able to update docker either, so I had to come up with my own solution to actually do the update for the libs I want: go get -u github.com/docker/{docker,distribution,cli}@master go get -u ./... go mod tidy Which at least works better than deleting the `go.mod` and doing it from scratch. Theoretically, only those three repos would be at master, the rest picked by the Go tool (likely versioned). I've personally moved on from trying to use Docker as a library, and if you can escape projects which don't use the "expected" versioning scheme, things work alright with modules, but when you hit an edge case they sure can be irritating.
You argument doesn't stand either because even if my code is under GPL but my company is the only customer/user of the product built using that code, only they will get the sources. The community, on the other hand gains new developers and businesses where Go is becoming used. Developing closed source solutions doesn't mean that you can't develop open source on the side projects or even inside your company for the different product.
Look into net.Conn and tls.Conn. https://godoc.org/net That’s the standard way to open a socket. You’ll notice it puts each new connection inside its own goroutine in the sample as a way to handle multiple connections efficiently. You will also want to implement opportunistic TLS, or even native TLS. https://en.wikipedia.org/wiki/Opportunistic_TLS The basic would be to have a struct wjth two net.Conn interfaces. One for the raw and one for the “result”. If they call STARTTLS in the stream, then replace the result net.Conn with a new tls.Conn that adheres to the interface. You would need to sort out those details tho. 
Here you go: [https://imgur.com/AycQ76N](https://imgur.com/AycQ76N)
Working with binary-only packages in C++ (aka *.a files) is a nightmare. They should be fully compatible with your build target, which means that most of the time, they had to be built with the same arch-os-compiler as you using. This limits the use cases a lot, while not gaining anything substantial (those packages are trivially reversed to the original source code if your intention was to hide the code from the client). There are three options: 1. Plugins. While not exactly production ready, it should suffice in most cases. 2. RPC. gRPC and the likes. Most of the code will be generated for you and you get the scalability out of the box. You also get some perf and latency penalties tho. 3. C api. Like plugins but can be used with any language that is C ABI compatible. 
Go already had it since 1.7 Did they think that is valid argument at that time? I don't ask for a new things. Using binary package has its flaw but it can be fixed. Providing solution for closed source should be an option because many want to have it. &amp;#x200B; Does Google open source their search engine? Does Uber open source their routing algorithm? If you're working at Google, all you know is few piece of code, not the whole framework or their infrastructure. Why the hell Google have to sue Uber for stealing self-driving car algorithm? [https://www.digitaltrends.com/business/google-sues-uber-over-self-driving-car-secrets/](https://www.digitaltrends.com/business/google-sues-uber-over-self-driving-car-secrets/) The community doesn't gain anything right? Lol
Reading the OP and the comments here I am still not quite sure what you want to communicate with what. Do you want to build a web frontend to the email server? If so that can be done in many ways, but I don't think there is a "industry standard". You could build the frontend directly into the email server as a single binary. In that case you could just directly call functions of the email server. This is the easiest way, but I wouldn't recommend it. You could also have the frontend communicate with the Email server over some RPC protocol like jsonrpc or grpc. You could reuse the DB layer of the Email server for the frontend and communicate over the DB. Or you could implement IMAP or POP in your email server and have your frontend communicate that way. If you do that you could also just not implement a frontend and use any email client. 
`db.Exec` is not a goroutine. I don't think any API in go is a goroutine. You must specifically run it with `go db.Exec()` for it. So, that's not the problem here. Better, put the source code here. Maybe you are not handling the errors correctly. It should be something like this. ```go func createTables(db *sql.DB) error { if _, err := db.Exec("CREATE TABLE IF NOT EXISTS users (...)"); err != nil { return fmt.Errorf("could not create users table: %v", err) } if _, err := db.Exec("CREATE TABLE IF NOT EXISTS phones (...)"); err != nil { return fmt.Errorf("could not create phones table: %v", err) } return nil } ``` **replacing `...` with the correct table definition.** 
[removed]
My answer (which is not necessarily everyone's) is that interfaces are the wrong starting point because they are about methods, while many constraints on generic types are about the types themselves. It's an explicit feature of interfaces that they don't constrain the underlying types that implement them, but a lot of use of type constraints needs to constrain the type itself (so, for example, it is comparable, or usable as a key in a map). (I wrote a blog entry about this if you want to see the argument at longer length; it's [here]( https://utcc.utoronto.ca/~cks/space/blog/programming/Go2GenericsNotWithInterfaces).)
Are the slides available? Would very much prefer that over a long video. 
Google and Uber do not release any closed-source libraries. They both do maintain many open-source libraries.
You might be right, but I personally believe the intersection of "people who write high-quality open-source Go packages" and "people who would not write (or stop writing) open-source Go packages if closed-source packages are not supported" is zero or close to zero.
Yeah, good suggestion. I think the nice part about this is that it doesn't even change interfaces at all. It's an additional feature to func.
&gt;Google and Uber do not release any closed-source libraries. They both do maintain many open-source libraries. &amp;#x200B; They don't release any closed source library but they develop it and protect their source code. If they aren't, show the the open source code of Google search engine and Uber self-driving algorithm please.
I'm having trouble understanding the example in Figure 1. What is the desired outcome when timeout happens, then later result is ready? Discard result? What if it points to some external resource which needs to be released?
I would suggest different variable names such as port and serveDir or something. The „server“ is obvious IMHO. Sry for the tone earlier, did not want to sound harsh. 
Is there any disadvantages of using this over API gateway?
ok, got this to work. Thin is, I made an array of string, then I iterated over the and sent them to function with exec. As this was void func it wasnt waited buy the for loop it seems. 
Read the docs: https://godoc.org/net/url#PathEscape
I have never seen a client that does that. Can you imagine your /tmp filling up because some HTTP client decided to place cache files there? 
Most channel-related bugs that I've seen stem from the programmer not understanding that the sender of a message on an unbuffered channel will wait until the receiver reads it. I think Go needs to do a better job of making a clear distinction between buffered and unbuffered channels.
The point of the buffer size of 1 is that the result can be placed in the buffer and the goroutine can exit. The result is discarded in effect. &amp;#x200B; The cause is the way unbuffered channels work. In essence: when you put something in the channel the goroutine will pause there until another goroutine accepts the value that is being put into the channel. Since the value is never read from the channel after the timeout the goroutine will never exit. It is a hard bug to notice since you probably will need a lot of timeouts till you have enough running goroutines that it will noticeably impact your application.
What if the result points to some external resource which needs to be released? Then this resource will be leaked. This is similar to https://rakyll.org/leakingctx/. "Discard result" seems like an anti-pattern. Buffer size 1 just hides this bug.
All of it. Except the convention of using comments for documentation. But not javadoc. Godoc. :)
They've already said that any changes will be backwards compatible or very easy to fix (probably automated). They also added a way to choose what version of go to use for a package, so if they make breaking changes the code will still interop just fine.
You bring concepts, not syntax 
Not everything has to be an “object”. Sometimes it’s the right abstraction, sometimes you can just use a couple or slices or a map and be fine. When you choose to use choose a struct, be careful with struct of structs. There’s nothing wrong with that choice occasionally, but Java thinking will probably make you over-pick that design option.
More than you think. Biggest one I can think of is, abstractions. In go, people are very into long verbose ways to do things in the name of "the go simple way". Here come the downvotes...
Does this help? https://eagain.net/articles/go-json-kind/
I think you would likely want a json.Unmarshaler interface. I haven’t done it, but you likely need to make an object that you use as a master object and then unmarshal depending on what it sees at the top level. 
Good point, here's the slides: [https://www.slideshare.net/RomanAtachiants/large-scale-data-capture-and-experimentation-platform-at-grab](https://www.slideshare.net/RomanAtachiants/large-scale-data-capture-and-experimentation-platform-at-grab)
I think stick exact versions of such big libraries like Docker and k8s - it’s very good practice (go modules by default downloading master HEAD, not last released semver version) - if you don’t need to setup exact versions for all libs, but just k8s and docker is enough - then i feel it is good solution. Problem with docker/cli - they don’t use go modules and commit vendor directory - it means your vendor directory can conflict with their. Not much go opensource projects go this way - probably docker/cli is not prepeared well to be used as a library. 
Forget about abstractions, inheritance, pretty much most/all of OOP, and all the factories, exception based logic. Also forget about using xml, orm, and all the fancy build systems. Also, don’t mind repeating yourself in code, a lot.
Thank you! Much appreciated 😃
Forget ORMs? Personally, I use Gorm, and I quite like it. Factories can be used in Go, also (according to books I've read, at least, haven't put it to practice yet). About repeating yourself... that normally means your code needs refactoring. Best of all, you can forget about 5 minute compilation times :D
The former. As far as I can recall, it is available for Linux. I wouldn't have considered installing it otherwise, I don't run other OSs. - Yup, just checked: available for Linux, Windows and Mac.
If err != nil... :p theres quite a bit in go that doesn’t lend itself to DRY. It’s not wrong or right imo just the way it is
[removed]
Still not right. Defer needs to be after the first panic. Take the following example using net.Dial from the standard library. conn, err := net.Dial("tcp", "what what what") defer conn.Close() if err != nil { log.Printf("err: %v", err) return } This code panics because net.Dial returns a nil connection if it encounters an error. Functions that allocate resources and hand ownership of those resources to the caller should clean up after themselves. Ownership should be transferred only when the call is successful. Not that your library does the same: https://github.com/sch00lb0y/aran/blob/6fe3e7f993e73fa1c4d6aa20d2fd9058e3a2f950/db.go#L56
Gorm is nice, but it looks more like that spring jdbc templates or mybatis than the jpa/hibernate type orms that are often used to build giant beautiful monoliths in Java. Compile times are nice - although it gets comparably sluggish in codebases of equal complexity - especially if you bring in any largeish native libs or vendor in something unusual (which is typical in larger production go codebases).
Plenty of abstractions in golang, io.Writer comes to mind as a widely used abstraction. 
If you forbid editing tools.go, you need to provide an alternate user interface to all the possible manipulations, and lose the ability to e.g. store justifications for things in comments. That doesn't seem like a great route forward. Building all of the tools listed in tools.go is a simple &lt;150 line program, this thing has way too much unnecessary complexity... Finally, I'll leave you with this: &gt; `func NewManager(executor manager.Executor) manager.Interface {` https://github.com/izumin5210/gex/blob/6a8ff20e059b495d485bac648d28b9c18cc9103a/pkg/manager/mod/manager.go#L12
[removed]
I've currently planned to separate the SMTP server and the web server so whatever the communication must happen between them, say sending small strings of data must be done. How exactly would I have an "db layer" to the email server? I didn't clearly understand that. Currently all the DB communication is done by the web server. I'd want to hear more suggestions based on my idea of design of possible. Thanks. 
[removed]
It's pretty clear: https://tour.golang.org/concurrency/2
So basically I need to get the data like the composed email and list of TO addresses entered by the user. I tried using string data type and using the "scanner" to send data to the listening connection and back. I am not quite sure whether that's how it is to be done. I mean the large data of the email composed. Can I get suggestions based on these? 
Be careful of interface pollution, many people coming from an OOP background made this mistake when switching to Go. The mistake is described here: [https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html](https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html)
You’re just looking to tap the email connection? 
No, I meant when I am writing such an email server and it's frontend I need to provide email sending, creation services right? That. So when one enters data into the compose box, I need to obtain that in the backend
[removed]
forget about `get` prefix for getters... just don't forget to read Effective Go
[removed]
In general such multi-type thing is bad for statically typed languages like Go. But there are ways. See a possible mapping auto-generated by a nifty quicktype app: https://app.quicktype.io?share=SUwtKdT5LeMDlAcOuJ53 Their approach is to have a mega-struct that includes fields for all possible variations of resources. Another option is to decode into map[string]interface{} and manually access all fields. A variation on this: decode to map, check and remove the type, serialize map back to json and deserialize again to a struct for a given type. Also look at json.RawMessage type https://golang.org/pkg/encoding/json/#example_RawMessage_marshal 
I'd say, bring the SOLID principles. Go [implements them quite nicely](https://youtu.be/zzAdEt3xZ1M). Error types are quite different, as is composition (as opposed to inheritance). Focus on simplicity and you'll see why Go does things a certain way. Forget about Generics. If you think you need them, ask yourself if you really, really do. The answer is usually no. 
This is a fantastic question, and I wish more people asked such questions when jumping into a new language. I don't have much Java experience, but I have helped people transition from Java to Go. A lot of very effective Java wants a lot of indirection in order to make the happy path clear (or so it seems). Effective Go avoids indirection as much as possible in order to make the sad paths clear.
AFAIK tagging is repo level, so you can't version parts of it differently. Accept it, version mainly according to the framework's needs. But as I understand it, the bot and the framework are very closely tied together, so "co-versioning" them is a sane decision.
Was that Aztec 'C'?
I am following because mods confuse me. Especially the lack of locking to version and manual controller always pointing to latest tags etc. I am lost with project structure the Richt way. 
I learned 'C' using tools that generated 8086 code but ran on a DEC VAX. I have no idea who made that compiler. My next job was at Bell Labs in NJ, and I used whatever they used, again, development was done on the VAX, but in that case ran on an embedded 68000 processor.
Forget about the notion that you need a framework for every layer of your system. Default to the standard library until you come across something you can’t do with it.
You might be in this repo, specifically this example: https://github.com/go-modules-by-example/index/blob/master/009_submodules/README.md
You can use docker/cli as a library, if you're careful. It was pretty easy with dep, and can still be done with modules (though with more effort, see my other comment).
Thanks for the advice ! I've renamed serveDir to dirToServe, that is more clear. No problem :)
*Shhht* ;-) At least its shorter to write.
Sure, but I \*can also imagine\* the client managing the cache size appropriately.
Looks very nice ! I'm going to dive into it this week I guess.
My emacs lisp file for golang kkk \- Debug golang : I use gud-gdb with dlv and use golang mode syntax highlighting for go-mode. \- Find definition : godef \- Find reference : go-guru \- For not getted source packages and you want to get that stuffs with "go get" command, you can use 'jong-get-imported-packages' implements by me :) &amp;#x200B; links : [https://github.com/jongyoungcha/.emacs.d/blob/master/jongyoungcha/jong-go.el](https://github.com/jongyoungcha/.emacs.d/blob/master/jongyoungcha/jong-go.el) &amp;#x200B;
I apologize.. not sure I fully understand the OP. Are you basically building a "library" that others can use, and you are not sure how to version it so others can depend on specific versions? 
Figure 1 has incorrect code. The anonymous function call must be called using `()`. Funny that a paper showing bugs in Go code itself has a bug. Or maybe it's a meta joke.
Good point, and I agree that using abstractions does not automatically lead to unproductiveness. However, it is very easy to get dragged into constructing abstractions from the beginning, whether they are necessary or not, rather than focusing at the problem at hand and adding abstractions later if the need arises. 
When programming in Java, it is natural to ask "what is it" and " what does this class inherit from/to". This way of thinking fits Java well, but makes it harder to program in Go. For Go it works better to focus on actions: "what is the thing that should be done?". Go really shines when focusing on what should be done, but is not that great at building deep hierarchies, for better and for worse.
u/YourTechBud is the developer of this service
&gt;Effective Go Agreed.. need more like this. I am also trying to switch to Go. As someone who is trying to build a microservices sort of project template/framework (to learn, but also to build off of for various ideas), I tend to think Go fits the notion of small fast services (that communicate to one another via MQTT via msg bus) more so than Java. Though, the latest multi stage Java docker container/builder with a good Spring Boot app are more appealing lately than our old way of building a monolithic Spring boot JEE style application! &amp;#x200B;
I am glad you said that.. in my mind, with the lack of strong OOP, inheritance and generics, my thought was that I would be writing a lot of interfaces. I dont know yet, but glad I read your response here.
This is my first try in writing go code, so It would be really nice to give me a short review :-)
I see the points you make but for the sake of a fruitful discussion please do not turn to attack people personally. It is your right to disagree with other peoples' opinions and to question their experience, but please do it in a respectful way. 
Long verbose ways? Seriously? The difference between public and not public is a single letter!
It is absolutely your right to disagree. Different experiences yield different truths. Generics can be indispensable in one problem area and unnecessary in another. 
I didn't attack him personally. I did just what you said, attack his experience (with generics and dynamically typed languages).
A question I have is whether the versions of my optional dependencies will affect those who don’t import them. Let’s say I have a package that has some http handler, and in a subpackage, I import the AWS SDK and export a Lambda function as an optional, convenient way to use it. If another package imports my http handler but not my Lambda function, will they still be affected by my AWS SDK minimum version?
https://eagain.net/articles/go-dynamic-json/
Damn, this is a amazing proct, though docs lack a bit
Make the resources a []interface{}. Create a « header » struct type containing the « resource-type » and « name » fields only, and a struct for the each final detailed structures. Unmarshal the Json as usual, then loop over the resources []interface{} and unmarshal its elements in 2 steps: 1- unmarshal the element into a header struct to be able to get its resource type and name 2- In a switch (or equivalent), unmarshal a second time the element to the final struct according to the header fields values 3. Done 
like the other said, with a massive universal node struct: [https://play.golang.org/p/do5dr2NAduv](https://play.golang.org/p/do5dr2NAduv) or delay parsing with `json.RawMessage` and probe each to determine its type and unmarshal into its own struct: [https://play.golang.org/p/MGnQYki1Eut](https://play.golang.org/p/MGnQYki1Eut)
\- Large interfaces \- Making everything a class/struct/object \- Factories unless you really really really need them \- Abstracting everything \- Inheritance (use embedding and only if you really really need it) \- Private class variables with Getters+Setters. Instead use public struct members without gettings/setters unless really needed \- Hiding too much in a package. If a constructor creates an object, make the struct/class public. Don't be afraid and hide all/most things by default. \- Globally configured packages + singletons. \- Do bring dependency injection but bare bones simple one. Use it instead of globals. \- Generics :P
Point taken. I did not mean to say that it was your intent to attack him personally, apologies if this came across that way. Stll, saying that someone does not understand something can be understood as a personal criticism even if not intended this way.
Thanks buddy. Actually I do need help in getting the docs ready!
Yeah, thanks for correcting me again. 
A better solution might be with using select default. This way you are sure that it will never block and you could fit any cleanup code in the default block. When reading the code it is also clear it will never block. This in contrast with the buffered channel. You will have to go back to see if it is buffered or not &amp;#x200B; `package main` `import (` `"fmt"` `"time"` `)` `func main() {` `c := make(chan int)` `go func() {` `time.Sleep(time.Second)` `select {` `case c &lt;- 1:` `default:` `}` `fmt.Println("exit")` `}()` `select {` `case v := &lt;-c:` `fmt.Println("received", v)` `case &lt;-time.After(time.Millisecond * 500):` `fmt.Println("timeout")` `}` `fmt.Println("done main")` `}`
Love it or loathe it ... Axel gives a fantastic example of using the panic/recover pattern, along with considerations for using it, at this months London Gophers Meetup. 👍
ps aux | grep "app"
Why ssh? Why not just good ol' ping? If ssh, it should be able to use the ssh agent, otherwise it's unusable.
I wanted all nodes to ping each other, so my solution was to ssh into each node then ping other nodes from there
What do you mean with indirection?
https://en.wikipedia.org/wiki/Ssh-agent You can use golang.org/x/crypto/ssh/agent (NewClient with $SSH_AUTH_SOCK) with golang.org/x/crypto/ssh.AuthMethod. For Windows, I don't know.
Thanks I'll look into it.
Hello, would you say the book is enough or would you recommend the whole course? 
Deserved downvoted I have to say
It depends what you mean by "enough"? What are you trying to achieve? But I have just the book, and so far, for me, looking to develop a web app, it is more than enough.
Well I'm currently learning web development and currently on frontend react stuffs but haven't really gone much into backend. I decided to go with Go and trying to pick a course/book, also I can't really afford the course but I'd consider the book if it's got more content than say, an udemy course. Unless you know a really good udemy course on Go, cause they're still cheaper than the book 😂
The Todd McCleod Udemy course is really good for syntax etc. But for actually building web apps this book has been the best Ive seen so far.
Ah I think I'll go with the book then. The docs probably have most information about syntax and learning how to build stuffs with Go would be more helpful for me. 
[removed]
Let me know how you get on with it
Here is an example of its implementation -- versioned mono-repo with versioned sub-packages. https://github.com/sotah-inc/server/tree/master/app `/pkg/` contains reusable code. `/cmd/` contains (unversioned) commands. Builds are typically `go build cmd/app` or `go build cmd/whatever`. `/fn/` contains versioned sub-packages. These are used exclusively for Google Cloud Functions. Every time `github.com/sotah-inc/server/app` (the main mono-repo) changes, the `/fn/` sub-packages need to have their deps updated via `go get github.com/sotah-inc/server/app` which updates `go.mod` and `go.sum` accordingly.
Instructions unclear, built FactorySingletonFactory in Go
Although tagging is done at the repo level, according to [this walk through](https://github.com/go-modules-by-example/index/blob/master/009_submodules/README.md) you can use a tag like "foo/v1.2.3" to version multiple modules inside a repo independently.
By indirection, I mean the kind of abstraction that moves details into another method. A classic example is dependency injection. In Go, I might do the following: type Thing struct { Sink io.Writer } // and then construct it directly thing := &amp;Thing{Sink: os.Stdout} Some people transitioning from Java to Go might prefer (in the extreme) to add methods to `Thing`for setting a `Sink`, creating another type that sets `Sink`s on types that have methods for setting `Sink`, and add a constructor that takes *that* `SinkFactory` type as an argument. That's probably not the most fair representation of Java programming style, but dependency injection is one of the most common examples of indirection I see carried over into Go.
your suggestion fixed my issue. Also i have done some research on space(" ") character being replaced with "+" in golang, and "%20" in javascript. It seems like both replacements are somewhat correct and we can use any one of them. Thanks for pointing me towards right path
Sorry for the late reply. I run it in production (additional test cases added in private repo) with minimum 256 shards. There are around 10k keys present but that varies. I actually have a goroutine per shard. Each shard's sweeper starts at a randomized time and this helps in avoiding global locks on all the shards. That was the only intention. Thanks for the suggestion, I shall surely look into what you've suggested. Your library looks good too!
After looking at the website and github, I have very little idea what this actually is? Am I the only one confused? Or more specifically, what use cases does it solve / what's it supposed to be used for?
You're not the only one. Sounds like it's trying to expose a database similar to graphQL but over REST? No idea what real problem it's actually trying to solve. Seems it's just trying to mask the work of, you know, actually using and optimizing a database. 
[https://github.com/dunglas/mercure](https://github.com/dunglas/mercure) [https://github.com/jirenius/resgate](https://github.com/jirenius/resgate) &amp;#x200B;
&gt; Prerequisites: MongoDB database So it's a wrapper around MongoDB?
SQL isn't designed to be migrated, and it shows. (I have to admit I do not know off the top of my head what "designed to be migrated" would look like, but SQL is clearly not it.) Consequently, any time someone says "hey, let's create a migration library", it has a strong tendency to become arbitrarily complicated, because migrations are arbitrarily complicated. So, when someone comes along later and basically just wants to add a new column or something to their table, and they look at migration libraries, they're smacked across the face with a library that has several dozen pages of documentation and introduces 5-10 new idiosyncratic concepts, and may even try to require the code base using the library to do something... and for all that, may _still_ not do what the user was looking for, and will almost certainly take a substantial quantity more code than "just" writing the migrating SQL by hand. That said, I do recommend that if you are going to go the library route, that you use an existing one, and a lot of people don't seem to notice that there's not a particularly compelling reason for this library to be written in the same language as the rest of the project. That is, there's nothing particularly wrong with using a Python library to migrate your database even if your main code base in Go. You won't see those migrations written in Go, of course. Personally, I tend to just having "a database version" and "here's the SQL to run if we need to migrate". I tend to write all my SQL with an indirection layer for the DB/table name anyhow, so I can switch things in real time if I need to. (And this is also why I tend to avoid this sort of library too; I can't tell you how amazingly useful it is to indirect the table name, even at runtime, and the way the vast bulk of SQL "libraries" tends to make that _impossible_ immediately disqualifies them for me.)
Its a wrapper around goqu
Super hack, using recursion: ``` func (s *leaser) cleanLeases() error { s.lock.Lock() wasUnlocked := false defer func() { if !wasUnlocked { s.lock.Unlock() } }() for mediaIndex, media := range s.media { if len(media.leases) == 0 { // This mounted item currently has no leases. // Let's see if it has been closed for enough // time to auto close it. elapsed := time.Now().Sub(media.lastClosedTime) if elapsed &gt; time.Second*5 { // This mount has been stale, let's unmount // and remove it. err := media.MountSession.Release() // Regardless of if it error'd or not, let's remove it. s.media = append(s.media[:mediaIndex], s.media[mediaIndex+1:]...) if err != nil { return err } wasUnlocked = true s.lock.Unlock() return s.cleanLeases() } } } return nil } ```
You can just iterate using the length ("normal" for-loop syntax), and when you delete just decrement the index variable to avoid skipping // **** MODIFIED CODE **** for mediaIndex := 0; mediaIndex &lt; len(s.media); mediaIndex++ { media := s.media[mediaIndex] // **** END MODIFIED CODE **** if len(media.leases) == 0 { // This mounted item currently has no leases. // Let's see if it has been closed for enough // time to auto close it. elapsed := time.Now().Sub(media.lastClosedTime) if elapsed &gt; time.Second*5 { // This mount has been stale, let's unmount // and remove it. err := media.MountSession.Release() // Regardless of if it error'd or not, let's remove it. s.media = append(s.media[:mediaIndex], s.media[mediaIndex+1:]...) // **** MODIFIED CODE **** // we deleted the current entry, so the "next" entry is actually at this same // index, meaning we need the next iteration of the for loop to look at the same // index... so we have to decrement mediaIndex by one mediaIndex-- // **** END MODIFIED CODE **** if err != nil { return err } } } }
I'll give you props for cleverness but this is probably not the "right" approach since it requires you re-iterate entries every time you delete one. That can get costly pretty fast...
But why? Bumping dependencies should never be an automatic action, unless there's a known vulnerability on the version currently using. 
I wish there were some docs, but from glancing at the TODO list, it *seems* to be a bit like [Meteor](https://www.meteor.com/), but for Go?
[removed]
Maybe to stay on top of breaking changes that occur in dependencies? I could see it helping to stay on top of tech debt when having to upgrade due to a vulnerability or something.
Yup ;)
Surely this would panic with an index out of range if at least 1 item was removed?
No, because `len(`[`s.media`](https://s.media)`)` is re-evaluated at each loop iteration. If you tried to calculate the length once re-use the value, you'd be right, though. I use this all the time when I might need to delete during the iteration.
[Thanks!](https://github.com/pauldotknopf/automounter/commit/04e0f72064f1a43b0b7ba01a19f4f3a439bdedc5)
Awesome, glad I could help :)
Pay up to $100/month for someone else's computer to run `go get -u` for you?
Thank you, I appreciate the feedback!
PRs aren't an automatic action. Automatically merging would be a bit more problematic.
Never mutate a collection when iterating on it. This doesn't just apply to Go.
Isn't this O(n^2)? It may be cleaner and worst-case faster to do ``` media := s.media s.media = s.media[:0] for _, m := range s.media { if &lt;not errored&gt; { s.media = append(s.media, m) } } ``` There's also the trouble that doing this keeps the capacity at its high-water mark, and prevents all those items off the end of the slice from being garbage collected, even though they'll never be used again. May or may not be an issue. Many ways to deal with that, but the simplest is to be even more obviously correct and do ``` s.media = make([]Media, 0, len(s.media)) ```
I may be wrong, but I'm quite sure the [ABI](http://www.mingw.org/wiki/Interoperability_of_Libraries_Created_by_Different_Compiler_Brands) is where you'll have a problem. If you can't recompile the library using the same compiler, then one option may be to wrap the library in a DLL and use normal Windows calls to load it at runtime. Of course, this means you'll need to distribute the DLL with your binary... Essentially you need to change how you interface to it.
Oh wow, you're right, my bad! TIL!
You can merge automatically too if proper tests are in place and passed. In case of failed test, of course some manual actions involved and here problem starts.
I would suggest using 2 variables like good old \`c\` .The code is concise and clean func (s *leaser) cleanLeases() error { s.lock.Lock() defer s.lock.Unlock() for i, j := 0, 0; i &lt; len(s.media); i++ { if len(media.leases) != 0 { break } elapsed := time.Since(media.lastClosedTime) if elapsed &gt; time.Second*5 { if err := media.MountSession.Release(); err != nil { return err } } else { s.media[j] = s.media[i] j++ } } s.media = s.media[:j] return nil } here is a sample implementation of the same in playground : [https://play.golang.com/p/nGsCyjgxxhm](https://play.golang.com/p/nGsCyjgxxhm)
Same problem. What if "1" represents a resource that needs cleanup? It is like running a function and skipping defers. It will probably leak something.
Architectures like [this](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition).
I realize this isn't really answering the question, but wouldn't it be more efficient to use a map and just delete the key associated with a given lease than to keep slicing and dicing the array?
Well, in a way both are necessary for reliable production builds. Go can't fail gracefully or recover. Part of Go's "simplicity" that it relies on rather complex distributed systems in order to work in secure manner. [https://www.youtube.com/watch?v=40d26ZGfhR8](https://www.youtube.com/watch?v=40d26ZGfhR8) dwells into the topic in detail.
Kubernetes is only going to be become more and more relevant. I introduced it in my current job, where i was a first time user and the others hadn't tried it before either. The fact that you can roll back and forth between release versions by editing a single image tag in a deployment is just insanity compared to how people roll back manually in production environments.
I've never used JB for Go development. How does it compete to VS Code?
Umm, yes, it's a wrapper around sql, or monodb, or postgressql.
Its like hasura, but with CRUD, user management, data management built in.
I would say much better. seems like vscode intellisense is breaking constantly
The js client is properly documented, this went open-source few days go, the author is writing docs.
Like their other IDEs, it's the best thing available for its language
That CPU profiling support looks really nice right in the editor.
It basically adds authentication and authorisation on top of MongoDB (and a few other databases) to safely expose it over a public api. Along with that it also provides real-time functionality to sync data cross clients.
Goqu is used for SQL databases. But what this project adds is authentication and authorisation based on super flexible security rules. Also, the APIs are real-time. Data across multiple clients is kept is sync.
Well the idea is to build a tool which replaces nodejs, php or any other back-end code one might have to write. It does offer a module called `functions` to extend this tool with your own custom code. It provides instant realtime APIs on the database of your choice.
&gt; Personally, I tend to just having "a database version" and "here's the SQL to run if we need to migrate". I tend to write all my SQL with an indirection layer for the DB/table name anyhow, so I can switch things in real time if I need to. This is not clear to me. Do you have any links to code for this?
You did get it right. It is similar to graphql but over rest. But in this case, you do not need to write any back-end code (resolvers or anything similar) whatsoever. Space cloud itself is a server. The goal is to integrate with various cloud technologies to expose a unified rest api which can be consumed directly from your frontend.
The project has been inspired by meteor. But it aims to be cloud native with zero lock ins. It can work with a broad range of technologies (sql and nosql databases, object stores, etc) and has heavy emphasis on security. The front end could be anything (web, native, iot devices, etc.) The docs are very weak. Need tons of work. Just needed some feedback so we can incorporate that into the tool at an early stage.
Great resources. But those tools would simply be a small portion of all that space cloud has to provide. Space cloud currently uses nats or kafka (pluggable) to achieve reliable real-time data sync. Moreover it exposes a database over to the frontend over a rest api. Its more than just a gateway.
Maybe I'll have to give it a try. What are JB charging these days??
Title update: "... and a SaaS I'd like you to pay money for."
I use JB for .net stuff too, this year I paid 120 or so for the full suite of their products, including goland. I really think it's worth it.
Please don't post the same thing daily.
What about the new Go modules? I just read first few sentences on webpage and noticed it mentioned support for Go dep. Interesting to integrate this in CI.
It's great. It's an IDE, so it makes things a bit nicer
Also paying for the full suite. I use JetBrain's products for Ruby (RubyMine), Php (PhpStorm), Go (GoLand), database (DataGrip), and Python (PyCharm). Very satisfied. I'm considering giving VSCode up for web development but VSCode's TypeScript support is first-class.
I'm not sure which sentence you're referring to, but in both cases, no, I have no public code. In the first case, I generally just have some table where I store a number, which is the version, and in the program, I have bits of code ordered by number. If the program expects a later version, it runs all the bits of code from that current version to the desired version. This doesn't scale to massive scales, but it scales well enough for what I've needed. And to the extent that it doesn't scale, a lot of the libraries don't help me with this problem anyhow. For the second one, I never write query := "SELECT col FROM table WHERE ..." I always have some sort of lookup table, and write some variant of query := "SELECT col FROM " + tableMap("table") + " WHERE ...." `tableMap` is written to be concurrency safe, and usually I can change it even at runtime without a problem. Usually I have helper objects to help with this that become part of the environment. In addition to helping with migrations, it also helps with testing. I always have code to create the database from scratch (i.e., "version 0" from the previous stuff), so to write test integration code I can always trivially just create a new DB schema and all my code works with it, because it always indirects through a lookup table, including all the CREATE TABLE statements and their foreign keys. I don't have to play fragile games with what is the "current" database on the connection or anything. It isn't paradise, exactly, since I have to write a lot of SQL, but often in the long run and even in the medium run it comes out simpler than some massive library, and simpler can have its own virtues.
Ah I see. Goland is what their Go IDE is called? That helps when I'm looking for it Haha!
Interesting. I used Atom and then VS Code. I've never used Jet Brains. I guess I don't know what it will give me over and above VS Code......
The IDE is free while in the EAP period and we really appreciate any feedback for it. As for the regular price, it's $89/first year and then $53/from the third year and after. And once you pay for 12 months you get to keep the IDE license for life.
Thanks for that, I'll have to do some research and see if that's enough to make the jump from VS Code :-) Excuse the ignorance... what's the yearly charge for if you get to keep the IDE license? Updates I assume?
If order is not important, just swap with the first element, slice the head down (and decrement the loop counter): s.media[i] = s.media[0] s.media = s.media[1:] i--
VSCode is fantastic for front-end development, but the code completion/"IntelliSense" in Ruby, Php, Python, and Go is sorely lacking. I'd love to be proved wrong but I haven't reliably been able to get code completion to work with Ruby, Php, and Python, and it *was* working for me with Go until I switched to using module-based dependencies.
Well most of my days are taken up with Go development, so perhaps it's worth a try!
Jetbrains is a full ide with refactoring support and other more advanced features (project solution support). I find myself using vscode for smaller things but rider/goland for bigger projects that can take advantage of the more advanced features.
Thanks. I personally find this confusing. I know sql was not designed for migrations, and I know that the migration tools out there are not perfect and ideal, but they work well for &gt; 90% of cases. Each are a tool that you setup once, and then run some migrate command for the life of the applications. I do not believe most of applications need bespoke tools for this. I have a similar complain to yours about going through the migration tools documentations: when you go through someone else's home grown migration solution and have to make a mental map of their reinvented wheel. I wish sql engines, at least postgres, would come up with a built in solution for this. It is clearly a requirement for any real world app, no mater what sql fanatics say.
Thats what i thought, two completly different techs that im going to have to decide what to pick first.
Quick question: as Kubernetes is written in Go wouldn't it be useful to know Go? Especially if you want to create some package? 
This is cool, but there's already a very widely used memory cache, written by Brad Fitzpatrick (the Googler who wrote memcached, most of Go's standard library HTTP code, etc.), that people might also want to consider:
Yep [https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-a-perpetual-fallback-license-](https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-a-perpetual-fallback-license-)
Nice tut. For future readers, try to replicate for channels and latter for private chats. You'll enjoy defears and pings and wonder why Go isnt used more!
I'm out
Only if you want to know how to make plugins or modify it. Most people don’t know how C works, yet they happily use VMware. It becomes a tool to use. Building something is quite different from using something. I would recommend learning Go if one needs to build something in it. 
I've made very good experiences with [https://github.com/spf13/cobra](https://github.com/spf13/cobra)
Loading a DLL in windows from Go is pretty trivial. We were cross compiling from a Mac to windows (GOOS,GOARCH), and saw no issues loading the DLL that was delivered. Sadly it was a 32 bit binary but it worked nonetheless. 
Thanks, it makes sense.
This makes the most sense to me from a process perspective, but when I try to unmarshal the resources, I end up with an error - `cannot convert Record.Resources[i] (type interface {}) to type []byte: need type assertion` I'm guessing that I'm missing something (Code snippet)[https://gist.github.com/pezhore/06dbed8d122cdeb60af2447ccf278769]
Some \`packages\` or how you want to refer to them is simply other applications being wrapped in a Kubernetes service/deployment/configuration etc. exposing their functionality e.g. Nginx(C), JenkinsX(Java), Apache(C, XML), Mysql(C,C++). You can see the kubernetes package manager which is pretty popular here:\`[https://github.com/helm/helm](https://github.com/helm/helm)\` It gives you a good guide on how to package your application as a helm chart(package). You might notice that Helm it self is implemented in \`Go\`, and of course \`Kubernetes\` it self is implemented in \`Go\`, so if those are the projects you are interested in contributing to then of course it would be beneficial to know \`Go\` :) 
Yeah well, \`Go\` is a nice little language to learn, i can highly recommend it. Start with: [https://tour.golang.org/welcome/1](https://tour.golang.org/welcome/1) Then delve a bit deeper: [https://golang.org/doc/effective\_go.html](https://golang.org/doc/effective_go.html) Then maybe try to contribute to a small open-source project written in \`Go\`, to keep the ball rolling. 
Thank you for the tool. I have a couple of questions: - Why `semver.json` instead of `VERSION` [1]? “VERSION” plays better with other standards like “LICENSE” and “README” - Why hardcode the location of the RSA file? [2] You’ve added seven (7) flags to this program, why not add another one to allow the user to configure the location of the SSH key? - Renaming without checking if the destination already exists? [3] So if I already have a script with the same name, you don’t want to warn me about the replacement? [1] https://github.com/meinto/git-semver/blob/fb493df/semver.json [2] https://github.com/meinto/git-semver/blob/fb493df/cmd/version.go#L237 [3] https://github.com/meinto/git-semver/blob/fb493df/cmd/init.go#L69
Try casting to the resource interface{} to string: json.Unmarshal([]byte(record.Resources[i].(string)), &amp;header)
JetBrains is so good it's painful to go back to free editors. It will give you the bends. I'm not a fan of SaaS, but in this case it works better than anything else available but a significant margin.
Thanks for your explanation
Go is strictly pass by value, just like C. If you want to modify a struct, you need to pass a pointer.
&gt; When you pass a struct in Go, is it like C, where all the data in the struct is copied, or is it more like newer languages where composite objects are passed by reference and can be modified in place. It is like C. &gt; In C, I would normally always pass as struct by pointer or as const so I could avoid having to copy wide data, but my gut says Go wouldn't make you do that explicitly for the sake of efficiency. Your gut is correct, in general you shouldn't worry about passing efficiency in Go. This is because almost every data type that can "hold" lots of data within it already has reference semantics: slices and maps are small data types in themselves, which point to collections on the heap, so copying them around as struct fields is very cheap. The only situation where you want to think about passing efficiency in Go is when your struct fields _don't_ have reference semantics, and in practice the only situation where that actually matters is if your struct contains large _arrays_ of data, i.e. `[1000]uint64`. &gt; My feeling is that pointers in Go are mostly for passing something you want to mutate in the caller, but I'm not sure. Are pointers ever necessary for efficiency, as in C? Your feeling is correct, and you should always make the "pointer or value?" decision based on required semantics, i.e. "mutate or not?", until profiling proves otherwise.
See https://golang.org/pkg/net/http/#Server.Shutdown
Thanks for this helpful and detailed answer. I shall pass the info along.
Also, when it fails.
Goland breaks less during updates and has better debugging. It feels very smooth to debug in Goland. If you write any SQL inline, you'll be excited to have context sensitive SQL syntax highlighting and validation in those strings in Goland. Rename works. I've never had it complete in VS Code. On the flip side, I like the simple, fast terminal and Git integration with VS Code much more than Goland because the later seems like it takes too many clicks to commit things. It's a little slower to load than VS Code. Another advantage of Goland is that dlsniper is a very active user on this sub, and when people have a problem, he is drawn to it like magic! :) You don't get that personal team interaction with VS Code. It feels much more fragmented where you try to solve an issue just to realize it's actually in a totally different repo or maybe interacts between many repos.
Additionally, ListenAndServe can return an error by itself if it is unable to listen (for example, the port is in use). While I've not personally seen it before, in theory this could also happen after it had been serving for a while if "accept" for an incoming connection fails (perhaps because the process has run out of available file descriptors). As the docs indicate, ListenAndServe always returns a non-nil error. The only situations where it returns are situations in which something has happened that prevents it from continuing to listen or serve. As is often the case with networking, the circumstances under which this can actually happen are many, but all unusual.
Pointers for efficiency should not be necessary in Go. If you pass a large object by value the compiler will automatically pass a "pointer to constant" instead.
Ah, true, there is that, I suppose... :( 
Thanks for your feedback! I've added a flag `--sshFilePah` to set a custom ssh file. In the init command you will now be asked if you want to replace the file if it already exists. Regarding to `semver.json` : I thought it was a good idea to choose a common file type that can easily read in most languages. I've never seen a `VERSION` file in a repository. Do you have an example for me? Is it a plain file with the following content? `VERSION=1.0.0`
Is this true?
it hasn't. just gotten faster. that's the beauty of it. i have software running since 2013 that still delivers what it promised, only faster.
I've had no problem with Go autocomplete in VS Code, but Python is a different story, though that's partly due to the nature of the language. 
Go wins in ecosystem, ease of use, and tooling, so even though I agree that Go is objectively worse as a language, it's way easier to write, get started with, onboard others onto, etc.
There are a number of dubious assumptions in that comparison. I wouldn't give it any weight.
I'd like to know as well.
Why does this need write access to the repo? Anyone can open a PR without write access.
Not to my knowledge, no.
It supports Go modules
Neither of those statements are true. &amp;#x200B; A passing a large struct or array is always going to be slower than passing around a pointer. And structs can't magically change from values to pointers, that would change the entire meaning of your program.
Woohoo!! And with that, we just merged TLS 1.3 support into Caddy, enabled by default: https://github.com/mholt/caddy/pull/2399
Man, really glad I spent all day putting together a 1.11 windows/cgo build environment...
&gt; When executing a template, long context values are no longer truncated in errors. &gt; […] &gt; If a user-defined function called by a template panics, the panic is now caught and returned as an error by the `Execute` or `ExecuteTemplate` method. Gonna be a _lot_ of happy [Hugo](https://gohugo.io/) users after bep and co. switch to 1.12. 
backend noob here, what does your comment mean?
A newer version of Transport Layer Security (TLS) protocol is being used. Instead of the previous version 1.2, it’s now 1.3. You can read about TLS at https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.3.
Caddy is a web server. So, sites powered by Caddy will, when accessed from modern browsers, connect faster and be more secure.
Hey it was just a dry run. :-)
I read your github tags, your README, even some of your wiki and I have no idea what Caddy is. Is it a static file server? does it depend on already running caddy instances? is it a net/http replacement? What does the architecture look like? can I run this on a closed network?
compared to what?.. &amp;#x200B; How fast is the build for go 1.11 for you? Also, you have to run that several time to get a decent avg.
Maybe the Caddy website will help: [https://caddyserver.com/](https://caddyserver.com/) Caddy is often considered an alternative to Apache (httpd) or nginx. Running `caddy` is the rough equivalent of `python -m SimpleHTTPServer` except it is production-ready. And if you give it a hostname (`caddy -host example.com`), Caddy will serve the site over HTTPS just like that. So: &gt; Is it a static file server? Yes &gt; does it depend on already running caddy instances? No &gt; is it a net/http replacement? No, although it can be used as a library if you need to embed a powerful/flexible web server into your Go program. (If all you need is automatic HTTPS with certificate management, use [CertMagic](https://github.com/mholt/certmagic) instead.) &gt; What does the architecture look like? I need to write about this. Caddy has a plugin architecture. Its HTTP server is a plugin. Each directive, or functionality, of the HTTP server is also a plugin. Basically it just wraps HTTP handlers as a chain of middlewares which it uses to serve your sites. &gt; can I run this on a closed network? Yes
A lot of docker images don't have ssh possibilities tho.
I’m glad you added the additional flag and the rename warning. Regarding your question about the “semver.json” file and my suggestion to use VERSION… There’s a list of files that are considered standard among C programmers to include metadata in their projects: README, LICENSE, VERSION, CREDITS, MAINTAINERS, COPYRIGHT, COPYING, CONTRIBUTORS, AUTHORS, PATENTS, INSTALL, CHANGELOG, among a few others that I don’t remember. In recent years, other communities _—specially web developers—_ started to imitate these names but with a twist, using Markdown files. That’s why now you can find README.md and LICENSE.md all over the place on websites like GitHub. I think the majority of young programmers do not realize where these names came from. Here are a few examples: - https://github.com/golang/go - https://github.com/torvalds/linux - https://github.com/qt/qtbase - https://github.com/qt/qt5 - https://github.com/apple/swift - https://github.com/freebsd/freebsd I understand the appeal of using JSON files, and considering your background, it makes sense to choose a file name like “semver.json”. But coming from a system programming background _(C, C++, Java, among others)_ the name doesn’t seems to carry the meaning that you want to provide. On the other hand, VERSION is already known by many of us, specially Go programmers coming from a non-web background, the purpose of the file is very clear, and there’s no need to include an encoder/decoder to write/read its content. How to create a VERSION file? Simple `echo "1.2.3" 1&gt; VERSION` How to read a VERSION file? Simple `cat VERSION` Of course, if you are trying to advertise this tool among programmers coming from a web community like Node.js, then yes, semver.json seems to be like a good name, it probably means more to them than VERSION.
I don't think it was made to win an award in language design, it's very regressive in that aspect, but it's still 1) Is much faster than interpreted languages. 2) Is much more productive than the low level ones. 3) Has an excellent standard library. 4) Has a great ecosystem and tooling. 
He's complaining about a go and at the same time he's not handling an error returned form a function call.
Did your complete this? If you put it up on GitHub or something I'd love to see it.
What HW?
This is time to build + the time to run the _entire_ test suite. If you just want to build, use `make.bash`
l33t user :)
Except for a version number, everything else I would assume would be the same wrt windows/cgo.
Thanks!
Messing with a slice (or map) while iterating it is dangerous. It might work, if the memory allocation gods smile on you. But it'll probably blow up. By far the safest way is to not touch the original slice until you've stopped iterating it: result := []media for _, media := range s.media { *** do the calculation to keep/remove/whatever*** if keepingThisOne { result = append(result, media) } } s.media = result 
I'll have to give it a try then maybe!
How long is this in 1337$p34k?
I've used caddy and it's amazing. It's like Nginx but doesn't require days of configuration and tuning. 
I just came here looking for gold.
Hey Richard, this is a really cool approach that definitely needs more exposure. One of the things that hold be back from using TinyGo was the lack of the builtin maps: https://tinygo.org/lang-support/#maps Did you run into this problem? Came up with any solutions? 
To be honest, I don't have any good solutions. I'll probably end up trying to write some simple low level data structures and see how crazy things get.
Right, what I thought about (but haven't tried) is working with the lock-free map implementation over here: https://github.com/cornelk/hashmap This would still lack type-safety as we're used to with go but its something. Anyway, super cool project and nice to see that the world is heading towards a WASM future!
Cool repo. Thanks for the compliment! 
Totally agree. There are proposals to "fixing" that, though. In the end, I like Go's error handling. I can mentally process the stacktrace, which is impossible in a lot of cases in Java. 
I see that my statement is received with a bit of skepticism :-) but this is fine and I don't have a "hard" proof to offer after all. &amp;#x200B; I can share my experience though. &amp;#x200B; A program of mine needs to do a lot (millions) of operations with matrices and vectors of 64 bit floats. I wanted these objects to be immutable so I decided to pass them all by value. That had me worried a little about performance, so I started profiling early in case I had to change my mind. &amp;#x200B; Well, all the copying that was supposed to happen, it never showed up. Whereas other copies that I overlooked (for example, using range to iterate over an array of largish structs) showed up very quickly in the profiler. &amp;#x200B; A while later, another strange thing happened. I needed to add a couple more fields to a struct that is passed around by value quite often. Sure enough, I added the fields and the performance dropped a little in my benchmarks. Another field added, another slight drop in performance. But when I added three more fields, there was a performance gain! I repeated this experiment several times and it was very reliable. &amp;#x200B; So, my deduction about the "pointer to const" may be wrong but in my experience Go is doing something to handle these situations in a smart way, it really looks like it's not just copying data around for no reason. &amp;#x200B;
Nice! Just waiting the updated image on [https://hub.docker.com/\_/golang/](https://hub.docker.com/_/golang/) to bump the version on my servers.
Surprised to see this pop back up. The [last time it was posted](https://www.reddit.com/r/golang/comments/8v3tmv/a_compiler_interpreter_for_a_simple_virtual/) it was popular enough I guess. If you'd like to see a _real compiler_ take a look here: * [http://github.com/skx/math-compiler/](http://github.com/skx/math-compiler/)
I hope that we will soon finally get a module-aware version of godoc. As of now, if you start the godoc server from a non-GOPATH project root, it doesn't seem to show the docs for the project.
[removed]
I'm curious to see how mid stack inlining improves performance. I'd expect gains up to 5% but also slightly larger binaries. And also finally sorted maps for debuging. 
FYI: [https://github.com/docker-library/golang/pull/264](https://github.com/docker-library/golang/pull/264)
will you be tagging a release in the near future?
New version, new me 
FYI, mid stack inlining hasn't _fully_ landed yet. https://github.com/golang/go/issues/19348 Improvements are being done every release. Let's hope 1.13 will be the release to finally finish any pending work.
What is the advantage of GoLand over LiteIDE or fully configured NeoViM that has refactoring, code completion and connects to a Go language server?
[Learn Go Programming](https://github.com/inancgumus/learngo) course repository contains 1000+ exercises.
I don’t like hiding any files, I would not hide the files. 
The files arent hidden. They do show up if u look at my illustration. Just for any given file that has a designated test file, a link to the test file is shown next to the filename. And the row of the testfile is removed. They simply merge to save space.
I didn’t see that specific illustration, as the others omit that element. Still I don’t mind the rows and wouldn’t remove the file rows. 
Great news !
Oh, I should probably restart the Discord bot I forgot about!
Does anyone has numbers about speed and binary sizes?
There is only 1 that omits them and 2 that shows this feature. The last two are basically unreadable and arent as dominantly present as said ones. I do appriciate your reply, but I would advice to read the proposal again. And actually study the suggestions made.
Only one image shows the feature.
You really need to post this 3 times in 24hrs???
See example1 and example2. It helps if you read the actual text. Please read it before you continue.
[removed]
Not to say that Caddy isn't great, but setting up Nginx in common use cases is about 10 lines of config and most of that is the same from config to config, so if you've done it once you have it. Even things like load balancing is trivial in Nginx and only require a couple of lines of config.
&gt; net/http/httputil ¶ &gt; The ReverseProxy now automatically proxies WebSocket requests. Nice.
You seem to have a habit of spamming your stuff multiple times, I don't know what you expect to get out of this, but please stop.
Impressive. Typical Go `app.wasm` file is around [1mb](https://sebastian-holstein.de/post/2018-07-05-go-wasm-application/) before GZIP due to including standard library. Your demo shows [4.1KB](https://i.imgur.com/nLpQMu5.png). 
&gt; In what circumstance would ListenAndServe() stop listening and serving, and allow the program to continue? The most common one is when the port is already being listened to by another process.
No, I didn't finish it yet. I haven't worked on it since the hackathon. At some point I do intend to work on it again, though. The source is here: https://github.com/ironarachne/writing-system-generator
Thank you very much, I will rethink should I make this repo into multi-module or what
Maybe it's just me getting ahead of myself and assume that someone would use the library